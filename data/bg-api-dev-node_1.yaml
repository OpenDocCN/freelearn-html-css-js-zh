- en: Introduction to Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js简介
- en: This chapter is designed to cover a few fundamental concepts in Node.js, as
    we lay a foundation for our subsequent chapters on API development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在涵盖Node.js中的一些基本概念，为我们后续的API开发奠定基础。
- en: Let's start this first chapter with a quick dive into how Node.js works and
    where it's being used lately. We will then have a look at its module system and
    its asynchronous programming model. Let's get started.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Node.js的工作原理和最近的使用情况开始这第一章。然后我们将看一下它的模块系统和异步编程模型。让我们开始吧。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够：
- en: Describe the basics of how Node.js works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述Node.js的基本工作原理
- en: List the applications of Node.js in modern software development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出Node.js在现代软件开发中的应用
- en: Describe the module system used by Node.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述Node.js使用的模块系统
- en: Implement basic modules for an application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序实现基本模块
- en: Explain the asynchronous programming basics in Node.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Node.js中的异步编程基础
- en: Implement a basic application using `async`/`await`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`async`/`await`实现基本应用
- en: The Basics of Node.js
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的基础知识
- en: Node.js is an event-driven, server-side JavaScript environment. Node.js runs
    JS using the V8 engine developed by Google for use in their Chrome web browser.
    Leveraging V8 allows Node.js to provide a server-side runtime environment that
    compiles and executes JS at lightning speeds.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个事件驱动的服务器端JavaScript环境。Node.js使用由谷歌开发用于其Chrome浏览器的V8引擎来运行JS。利用V8允许Node.js提供一个服务器端运行环境，以便以闪电般的速度编译和执行JS。
- en: Node.js runs as a single-threaded process that acts upon *callbacks* and never
    blocks on the main thread, making it high-performing for web applications. A callback
    is basically a function that is passed to another function so that it can be called
    once that function is done. We will look into this in a later topic. This is known
    as the **single-threaded event loop model**. Other web technologies mainly follow
    the **multithreaded request-response** architecture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js作为一个单线程进程运行，对*回调*进行操作，永远不会在主线程上阻塞，使其在Web应用程序中具有高性能。回调基本上是一个传递给另一个函数的函数，以便在该函数完成后可以调用它。我们将在以后的主题中研究这一点。这被称为**单线程事件循环模型**。其他Web技术主要遵循**多线程请求-响应**架构。
- en: The following diagram depicts the architecture of Node.js. As you can see, it's
    mostly C++ wrapped by a JavaScript layer. We will not go over the details of each
    component, since that is out of the scope of this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了Node.js的架构。正如您所看到的，它主要是由JavaScript层包装的C++。我们不会详细介绍每个组件，因为这超出了本章的范围。
- en: '![](img/00005.gif)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.gif)'
- en: Node's goal is to offer an easy and safe way to build high-performance and scalable
    network applications in JavaScript.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Node的目标是以一种简单而安全的方式在JavaScript中构建高性能和可扩展的网络应用程序。
- en: Applications of Node.js
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的应用
- en: 'Node.js has the following four major applications:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js有以下四个主要应用：
- en: '**Creating REST APIs**: We are going to look into this more in subsequent chapters'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建REST API**：我们将在后续章节中更深入地研究这个问题'
- en: '**Creating real-time services**: Because of Node''s asynchronous event-driven
    programming, it is well-suited to *reactive* real-time services'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建实时服务**：由于Node的异步事件驱动编程，它非常适合*反应性*实时服务'
- en: '**Building microservices**: Since Node.js has a very lean core, it is best
    suited to building microservices, since you will only add dependencies that you
    actually need for the microservices, as opposed to the glut that comes with other
    frameworks'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建微服务**：由于Node.js的核心非常精简，最适合构建微服务，因为您只会添加实际需要的微服务依赖，而不是其他框架所带来的过剩'
- en: '**Tooling**: For example, DevOps automations, and so on'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具**：例如，DevOps自动化等'
- en: 'Activity: Running Basic Node.js Code'
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：运行基本的Node.js代码
- en: '**Before You Begin**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**开始之前**'
- en: Open the IDE and the Terminal to implement this solution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打开IDE和终端来实现这个解决方案。
- en: '**Aim**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Learn how to write a basic Node.js file and run it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何编写基本的Node.js文件并运行它。
- en: '**Scenario**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: You are writing a very basic mathematical library with handy mathematical functions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在编写一个非常基本的数学库，其中包含方便的数学函数。
- en: '**Steps for Completion**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: 'Create your project directory (folder), where all the code for this and other
    chapters will be kept. You can call it `beginning-nodejs` for brevity. Inside
    this directory, create another directory named `lesson-1`, and inside that, create
    another directory called `activity-a`. All this can be done using the following
    command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您的项目目录（文件夹），其中将保存本章和其他章节的所有代码。您可以称之为`beginning-nodejs`以简洁。在此目录中，创建另一个名为`lesson-1`的目录，在其中创建另一个名为`activity-a`的目录。所有这些都可以使用以下命令完成：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inside `activity-a`, create a file using `touch maths.js` command.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity-a`中，使用`touch maths.js`命令创建一个文件。
- en: 'Inside this file, create the following functions:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，创建以下函数：
- en: '`add`: This takes any two numbers and returns the sum of both, for example, `add(2,
    5)` returns `7`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`：这需要任意两个数字并返回两者的和，例如，`add(2, 5)`返回`7`'
- en: '`sum`: Unlike `add`, takes any number of numbers and returns their sum, for
    example, `sum(10, 5, 6)` returns `21`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum`：与`add`不同，它接受任意数量的数字并返回它们的总和，例如，`sum(10, 5, 6)`返回`21`'
- en: 'After these functions, write the following code to act as tests for your code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些函数之后，编写以下代码作为代码的测试：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, on the Terminal, change directory to `lesson-1`. That's where we will be
    running most of our code from for the whole chapter.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端上，切换到`lesson-1`目录。这是我们在整个章节中将运行大部分代码的地方。
- en: 'To run the code, run the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行代码，请运行以下命令：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `16` and `21` values should be printed out on the Terminal.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`16`和`21`的值应该在终端上打印出来。'
- en: Even though you can configure the IDE so that Node.js code be run at the click
    of a button, it's strongly recommend that you run the code from the Terminal to
    appreciate how Node.js actually works.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您可以配置IDE，使Node.js代码可以通过单击按钮运行，但强烈建议您从终端运行代码，以了解Node.js的实际工作方式。
- en: For uniformity, if you are using a Windows machine, then run your commands from
    the Git Bash Terminal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了统一起见，如果您使用Windows机器，则从Git Bash终端运行命令。
- en: For the reference solution, use the `math.js` file at `Code/Lesson-1/activity-solutions/activity-a`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于参考解决方案，请使用`Code/Lesson-1/activity-solutions/activity-a`中的`math.js`文件。
- en: The Module System
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块系统
- en: Let's have a look at Node's module system and the different categories of the
    Node.js modules.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Node的模块系统和Node.js模块的不同类别。
- en: Application Modularization
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序模块化
- en: Like most programming languages, Node.js uses modules as a way of organizing
    code. The module system allows you to organize your code, hide information, and
    only expose the public interface of a component using `module.exports`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数编程语言一样，Node.js使用模块来组织代码。模块系统允许您组织代码，隐藏信息，并且只使用`module.exports`公开组件的公共接口。
- en: 'Node.js uses the CommonJS specification for its module system:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js使用CommonJS规范进行模块系统：
- en: Each file is its own module, for instance, in the following example, `index.js`
    and `math.js` are both modules
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文件都是自己的模块，例如，在下面的示例中，`index.js`和`math.js`都是模块
- en: Each file has access to the current module definition using the `module` variable
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文件都可以使用`module`变量访问当前模块定义
- en: The export of the current module is determined by the `module.exports` variable
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前模块的导出由`module.exports`变量确定
- en: To import a module, use the globally available `require` function
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要导入模块，请使用全局可用的`require`函数
- en: 'Let''s look at a simple example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To call other functions such as `mul` and `div`, we'll use object destructuring
    as an alternative when requiring the module, for example, `const { add } = require('./math');`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用其他函数，如`mul`和`div`，我们将使用对象解构作为导入模块时的替代方法，例如`const { add } = require('./math');`。
- en: The code files for the section *The Module System* are placed at `Code/Lesson-1/b-module-system`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块系统*部分的代码文件放置在`Code/Lesson-1/b-module-system`中。'
- en: Module Categories
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块类别
- en: 'We can place Node.js modules into three categories:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Node.js模块分为三类：
- en: '**Built-in (native) modules**: These are modules that come with Node.js itself;
    you don''t have to install them separately.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置（本地）模块**：这些是Node.js本身附带的模块；您不必单独安装它们。'
- en: '**Third-party modules**: These are modules that are often installed from a
    package repository. npm is a commonly used package repository, but you can still
    host packages on GitHub, your own private server, and so on.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方模块**：这些通常是从软件包存储库安装的模块。 npm是一个常用的软件包存储库，但您仍然可以在GitHub、您自己的私有服务器等上托管软件包。'
- en: '**Local modules**: These are modules that you have created within your application,
    like the example given previously.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地模块**：这些是您在应用程序中创建的模块，就像之前给出的示例一样。'
- en: Built-In Modules
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置模块
- en: 'As mentioned earlier, these are modules that can be used straight-away without
    any further installation. All you need to do is to require them. There are quite
    a lot of them, but we will highlight a few that you are likely to come across
    when building web applications:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些是可以直接使用而无需进一步安装的模块。您只需要导入它们。它们有很多，但我们将重点介绍一些在构建Web应用程序时可能会遇到的模块。
- en: '`assert`: Provides a set of assertion tests to be used during unit testing'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`：提供一组断言测试，用于单元测试'
- en: '`buffer`: To handle binary data'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`缓冲区`：处理二进制数据'
- en: '`child_process`: To run a child process'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`child_process`：运行子进程'
- en: '`crypto`: To handle OpenSSL cryptographic functions'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypto`：处理OpenSSL加密函数'
- en: '`dns`: To do DNS lookups and name resolution functions'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dns`：进行DNS查找和名称解析函数'
- en: '`events`: To handle events'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`events`：处理事件'
- en: '`fs`: To handle the filesystem'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`：处理文件系统'
- en: '`http` or `https`: For creating HTTP(s) servers'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http`或`https`：用于创建HTTP(s)服务器'
- en: '`stream`: To handle streaming data'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream`：处理流数据'
- en: '`util`: To access utility functions like deprecate (for marking functions as
    deprecated), format (for string formatting), inspect (for object debugging), and
    so on'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`：访问实用程序函数，如deprecate（用于标记函数为已弃用）、format（用于字符串格式化）、inspect（用于对象调试）等'
- en: 'For example, the following code reads the content of the `lesson-1/temp/sample.txt`
    file using the in-built `fs` module:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码使用内置的`fs`模块读取`lesson-1/temp/sample.txt`文件的内容：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The details of this code will be explained when we look at asynchronous programming
    later in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的详细信息将在本章后面讨论异步编程时解释。
- en: npm – Third-Party Module Registry
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm - 第三方模块注册表
- en: '**Node Package Manager** (**npm**) is the package manager for JavaScript and
    the world''s largest software registry, enabling developers to discover packages
    of reusable code.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node Package Manager**（**npm**）是JavaScript的软件包管理器和全球最大的软件注册表，使开发人员能够发现可重用代码的软件包。'
- en: To install an npm package, you only need to run the command `npm install <package-name>`
    within your project directory. We are going to use this a lot in the next two
    chapters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装npm包，只需在项目目录中运行命令`npm install <package-name>`。我们将在接下来的两章中经常使用这个命令。
- en: 'Let''s look at a simple example. If we wanted to use a package (library) like
    `request` in our project, we could run the following command on our Terminal,
    within our project directory:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子。如果我们想在项目中使用`request`这样的软件包（库），我们可以在终端中运行以下命令，在项目目录中：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use it in our code, we require it, like any other module:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的代码中使用它，我们需要导入它，就像导入其他模块一样：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'More details about npm can be found here: [https://docs.npmjs.com/](https://docs.npmjs.com/).
    Recently, a new package manager was released called YARN ([https://docs.npmjs.com/](https://docs.npmjs.com/)),
    which is becoming increasingly popular.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有关npm的更多详细信息，请访问：[https://docs.npmjs.com/](https://docs.npmjs.com/)。最近，一个名为YARN的新软件包管理器发布了（[https://docs.npmjs.com/](https://docs.npmjs.com/)），它变得越来越受欢迎。
- en: When you run the `npm install <module-name>` command on your project for the
    first time, the `node_modules` folder gets created at the root of your project.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次在项目上运行`npm install <module-name>`命令时，`node_modules`文件夹将在项目的根目录下创建。
- en: Scanning for node_modules
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描node_modules
- en: 'It''s worth noting how Node.js goes about resolving a particular `required`
    module. For example, if a file `/home/tony/projects/foo.js` has a require call
    `require(''bar'')`, Node.js scans the filesystem for `node_modules` in the following
    order. The first `bar.js` that is found is returned:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是Node.js如何解析特定的`required`模块。例如，如果文件`/home/tony/projects/foo.js`有一个require调用`require('bar')`，Node.js按以下顺序扫描文件系统中的`node_modules`。找到的第一个`bar.js`将被返回：
- en: '`/home/tony/projects/node_modules/bar.js`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /home/tony/projects/node_modules/bar.js
- en: '`/home/tony/node_modules/bar.js`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /home/tony/node_modules/bar.js
- en: '`/home/node_module/bar.js`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /home/node_module/bar.js
- en: '`/node_modules/bar.js`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /node_modules/bar.js
- en: Node.js looks for `node_moduels/bar` in the current folder followed by every
    parent folder until it reaches the root of the filesystem tree for the current
    file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js在当前文件夹中查找`node_moduels/bar`，然后在每个父文件夹中查找，直到达到当前文件系统树的根目录。
- en: The module `foo/index.js` can be required as `foo`, without specifying `index`,
    and will be picked by default.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`foo/index.js`可以被要求为`foo`，而不需要指定`index`，并且将默认选择它。
- en: Handy npm Commands
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方便的npm命令
- en: 'Let''s dive a little deeper into npm, by looking at some of the handy npm commands
    that you will often use:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下npm，看一些你经常会使用的方便的npm命令：
- en: '`npm init`: Initializes a Node.js project. This should be run at the root of
    your project and will create a respective `package.json` file. This file usually
    has the following parts (keys):'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm init：初始化一个Node.js项目。这应该在项目的根目录运行，并将创建一个相应的`package.json`文件。这个文件通常有以下部分（键）：
- en: '`name`: Name of the project.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：项目的名称。'
- en: '`version`: Version of the project.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：项目的版本。'
- en: '`description`: Project description.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：项目描述。'
- en: '`main`: The entry-point to your project, the main file.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`：项目的入口点，主文件。'
- en: '`scripts`: This will be a list of other keys whose values will be the scripts
    to be run, for example, `test`, `dev-server`. Therefore, to run this script, you
    will only need to type commands such as `npm run dev-server`, `npm run test`,
    and so on.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`：这将是其他键的列表，其值将是要运行的脚本，例如，`test`，`dev-server`。因此，要运行此脚本，你只需要输入命令，如`npm
    run dev-server`，`npm run test`等。'
- en: '`dependencies`: List of third-party packages and their versions used by the
    project. Whenever you do `npm install <package-name> --save`, this list is automatically
    updated.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`：项目使用的第三方包及其版本列表。每当你执行`npm install <package-name> --save`时，此列表会自动更新。'
- en: '`devDependencies`: List of third-party packages that are not required for production,
    but only during development. This will usually include packages that help to automate
    your development workflow, for example, task runners like gulp.js. This list is
    automatically updated whenever you do `npm install <package-name> --save-dev`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devDependencies`：不是生产必需品的第三方包列表，只在开发过程中使用。这通常包括帮助自动化开发工作流程的包，例如，类似gulp.js的任务运行器。每当你执行`npm
    install <package-name> --save-dev`时，此列表会自动更新。'
- en: '`npm install`: This will install all the packages, as specified in the `package.json`
    file.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm install`：这将安装`package.json`文件中指定的所有包。'
- en: '`npm install <package-name> <options>`:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm install <package-name> <options>`：'
- en: With the `--save` option, installs the package and saves the details in the
    `package.json file`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--save`选项，安装包并将详细信息保存在`package.json`文件中。
- en: With the `--save-dev` option, installs the package and saves the details in
    the `package.json`, under `devDependencies`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--save-dev`选项，安装包并将详细信息保存在`package.json`的`devDependencies`下。
- en: With the `--global` option, installs the package globally in the whole system,
    not only in the current system. Due to permissions, this might require running
    the command with administrator rights, for example, `sudo npm install <package-name>
    --global`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--global`选项，在整个系统中全局安装包，而不仅仅在当前系统中。由于权限问题，这可能需要以管理员权限运行命令，例如，`sudo npm install
    <package-name> --global`。
- en: '`npm install <package-name>@<version>`, installs a specific version of a package.
    Usually, if a version is not specified, the latest version will be installed.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm install <package-name>@<version>`，安装包的特定版本。通常，如果未指定版本，将安装最新版本。'
- en: '`npm list`: Lists the packages that have been installed for the project, reading
    from what is installed in `node_modules`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm list`：列出已为项目安装的包，从`node_modules`中安装的内容中读取。'
- en: '`npm uninstall <package-name>`: Removes an installed package.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm uninstall <package-name>`：移除已安装的包。'
- en: '`npm outdated`: Lists installed packages that are outdated, that is, newer
    versions have been released.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm outdated`：列出已过时的已安装包，即已发布更新版本的包。'
- en: Local Modules
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地模块
- en: We have already looked at how local modules are loaded from the previous example
    that had `math.js` and `index.js`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了如何从之前的示例中加载本地模块，其中包括`math.js`和`index.js`。
- en: Since **JavaScript Object Notation** (**JSON**) is such an important part of
    the web, Node.js has fully embraced it as a data format, even locally. You can
    load a JSON object from the local filesystem the same way you load a JavaScript
    module. During the module loading sequence, whenever a `file.js` is not found,
    Node.js looks for a `file.json`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**JavaScript对象表示**（**JSON**）在Web中是如此重要，Node.js已完全将其作为数据格式采纳，甚至在本地也是如此。你可以从本地文件系统加载JSON对象，就像加载JavaScript模块一样。在模块加载序列期间，每当找不到`file.js`时，Node.js都会寻找`file.json`。
- en: 'See the example files in `lesson-1/b-module-system/1-basics/load-json.js`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`lesson-1/b-module-system/1-basics/load-json.js`中的示例文件：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, you will notice that once *required*, the JSON file is transformed into
    a JavaScript object implicitly. Other languages will have you read the file and
    perhaps use a different mechanism to convert the content into a data structure
    such as a map, a dictionary, and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你会注意到一旦*required*，JSON文件会隐式地转换为JavaScript对象。其他语言可能要求你读取文件，或者使用不同的机制将内容转换为数据结构，比如映射、字典等。
- en: 'For local files, the extension is optional, but should there be a conflict,
    it might be necessary to specify the extension. For example, if we have both a
    `sample.js` and a `sample.json` file in the same folder, the `.js` file will be
    picked by default; it would be prudent to specify the extension, for example:
    `const config = require(''./config/sample.json'');`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地文件，扩展名是可选的，但如果存在冲突，可能需要指定扩展名。例如，如果我们在同一个文件夹中有`sample.js`和`sample.json`文件，`.js`文件将被默认选择；最好指定扩展名，例如：`const
    config = require('./config/sample.json');`
- en: When you run `npm install`, without specifying the module to install, npm will
    install the list of packages specified (under `dependencies` and `devDependencies`
    in the `package.json` file in your project). If `package.json` does not exist,
    it will give an error indicating that no such file has been found.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`npm install`时，没有指定要安装的模块，npm将安装项目中`package.json`文件中指定的包列表（在`dependencies`和`devDependencies`下）。如果`package.json`不存在，它将给出一个错误，指示未找到这样的文件。
- en: 'Activity: Using a Third-Party Package for the Previous math.js Code'
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：使用上一个math.js代码的第三方包
- en: '**Before You Begin**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**开始之前**'
- en: This activity will build upon the, *Running Basic Node.js* activity of this
    chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动将建立在本章的*运行基本Node.js*活动之上。
- en: '**Aim**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: If the argument is a single array, sum up the numbers, and if it's more than
    one array, first combine the arrays into one before summing up. We will use the
    `concat()` function from `lodash`, which is a third-party package that we will
    install.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是一个数组，对数字求和，如果是多个数组，首先将数组合并成一个再求和。我们将使用`lodash`中的`concat()`函数，这是一个我们将安装的第三方包。
- en: '**Scenario**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We want to create a new function, `sumArray`, which can sum up numbers from
    one or more arrays.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想创建一个新的函数`sumArray`，它可以对一个或多个数组中的数字进行求和。
- en: '**Steps for Completion**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Inside `Lesson-1`, create another folder called `activity-b`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Lesson-1`中，创建另一个名为`activity-b`的文件夹。
- en: 'On the Terminal, change directory to `activity-b` and run the following command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上，切换到`activity-b`目录并运行以下命令：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will take you to an interactive prompt; just press *Enter* all the way,
    leaving the answers as suggested defaults. The aim here is for us to get a `package.json`
    file, which will help us organize our installed packages.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带您进入交互式提示符；只需一直按*Enter*，将答案留在建议的默认值。这里的目的是让我们得到一个`package.json`文件，这将帮助我们组织我们安装的包。
- en: 'Since we will be using `lodash`, let''s install it. Run the following command:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用`lodash`，让我们安装它。运行以下命令：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we are adding the `--save` option on our command so that the package
    installed can be tracked in `package.json`. When you open the `package.json` file
    created in step 3, you will see an added dependencies key with the details.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在命令中添加了`--save`选项，以便在`package.json`中跟踪安装的包。当您打开步骤3中创建的`package.json`文件时，您将看到一个带有详细信息的`dependencies`键。
- en: Create a `math.js` file in the `activity-b` directory and copy the `math.js`
    code from *Activity*, *Running Basic Node.js* into this file.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity-b`目录中创建一个`math.js`文件，并将*Activity*，*Running Basic Node.js*中的`math.js`代码复制到这个文件中。
- en: Now, add the `sumArray` function right after the `sum` function.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`sum`函数之后添加`sumArray`函数。
- en: 'Start with requiring `lodash`, which we installed in step 4, since we are going
    to use it in the `sumArray` function:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从要求`lodash`开始，我们在步骤4中安装了它，因为我们将在`sumArray`函数中使用它：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `sumArray` function should call the `sum` function to reuse our code. Hint:
    use the spread operator on the array. See the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sumArray`函数应该调用`sum`函数来重用我们的代码。提示：在数组上使用展开运算符。参见以下代码：'
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the end of the file, export the three functions, `add`, `sum`, and `sumArray`
    with `module.exports`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾，使用`module.exports`导出三个函数，`add`，`sum`和`sumArray`。
- en: In the same `activity-b` folder, create a file, `index.js`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`activity-b`文件夹中，创建一个名为`index.js`的文件。
- en: 'In `index.js` file, *require* `./math.js` and go ahead to use `sumArray`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.js`文件中，*require* `./math.js`，然后继续使用`sumArray`：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the following code on the Terminal:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上运行以下代码：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should see `21` and `30` printed out.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`21`和`30`被打印出来。
- en: The solution files are placed at `Code/Lesson-1/activitysolutions/activity-b`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案文件放在`Code/Lesson-1/activitysolutions/activity-b`。
- en: Asynchronous Programming with Node.js
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js进行异步编程
- en: Let's have a look at asynchronous programming model that is at the heart of
    how Node.js works.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Node.js工作原理的核心部分，即异步编程模型。
- en: Callbacks
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: Callbacks are functions that are executed asynchronously, or at a later time.
    Instead of the code reading top to bottom procedurally, asynchronous programs
    may execute different functions at different times based on the order and speed
    of earlier functions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是异步执行的函数，或者在以后的某个时间执行的函数。异步程序可能根据先前函数的顺序和速度在不同的时间执行不同的函数，而不是按顺序从上到下逐步执行代码。
- en: Since JavaScript treats functions like any other object, we can pass a function
    as an argument in another function and alter execute that passed-in function or
    even return it to be executed later.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript将函数视为任何其他对象，我们可以将一个函数作为参数传递给另一个函数，并执行传入的函数，甚至返回它以便以后执行。
- en: 'We saw such a function previously when we were looking at the `fs` module in
    *The Module System* section. Let''s revisit it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在*模块系统*部分查看`fs`模块时看到了这样一个函数。让我们重新访问一下：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code files for *Asynchronous Programming with Node.js* are placed at `Code/Lesson-1/c-async-programming`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用Node.js进行异步编程*的代码文件放置在`Code/Lesson-1/c-async-programming`。'
- en: On line 3, we use a variable part of the `globals`, `_ _dirname`, which basically
    gives us the absolute path of the directory (folder) in which our current file
    (`read-file.js`) is, from which we can access the `temp/sample.txt` file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们使用`globals`的一个变量部分，`_ _dirname`，它基本上给了我们当前文件（`read-file.js`）所在的目录（文件夹）的绝对路径，从中我们可以访问`temp/sample.txt`文件。
- en: Our main point of discussion is the chunk of code between lines 5 and 8\. Just
    like most of the methods you will come across in Node.js, they mostly take in
    a callback function as the last argument.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的主要内容是第5行到第8行之间的代码块。就像您将在Node.js中遇到的大多数方法一样，它们大多数都将回调函数作为最后一个参数。
- en: Most callback functions will take in two parameters, the first being the error
    object and the second, the results. For the preceding case, if file reading is
    successful, the error object, `err`, will be null and the contents of the file
    will be returned in the data object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数回调函数将接受两个参数，第一个是错误对象，第二个是结果。对于前面的情况，如果文件读取成功，错误对象`err`将为null，并且文件的内容将在数据对象中返回。
- en: 'Let''s break down this code for it to make more sense:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码，以便更容易理解：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s look at the asynchronous part. Let''s add an extra line to the
    preceding code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看异步部分。让我们在前面的代码中添加一行额外的行：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'See what we get as a print out:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们得到了什么打印输出：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How come `Print out last!` comes first? This is the whole essence of asynchronous
    programming. Node.js still runs on a single thread, line 10 executes in a non-blocking
    manner and moves on to the next line, which is `console.log('Print out last!')`.
    Since the previous line takes a long time, the next one will print first. Once
    the `readFile` process is done, it then prints out the content of file through
    the callback.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`Print out last!`先出现？这就是异步编程的全部意义。Node.js仍然在单个线程上运行，第10行以非阻塞方式执行并移动到下一行，即`console.log('Print
    out last!')`。由于前一行需要很长时间，下一行将首先打印。一旦`readFile`过程完成，它将通过回调打印出文件的内容。
- en: Promises
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: Promises are an alternative to callbacks for delivering the results of an asynchronous
    computation. First, let's look at the basic structure of promises, before we briefly
    look at the advantages of using promises over normal callbacks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是传递异步计算结果的回调的替代方法。首先，让我们先看一下承诺的基本结构，然后简要地看一下使用承诺而不是普通回调的优势。
- en: 'Let''s rewrite the code above with promises:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用承诺重写上面的代码：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code can further be simplified by using the `util.promisify` function,
    which takes a function following the common Node.js callback style, that is, taking
    an `(err, value) => …` callback as the last argument and returning a version that
    returns promises:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还可以通过使用`util.promisify`函数进一步简化，该函数采用遵循常见的Node.js回调样式的函数，即以`(err, value)
    => …`回调作为最后一个参数，并返回一个返回承诺的版本：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From what we have seen so far, promises provide a standard way of handling asynchronous
    code, making it a little more readable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们迄今为止所见，承诺提供了处理异步代码的标准方式，使其更易读一些。
- en: 'What if you had 10 files, and you wanted to read all of them? `Promise.all`
    comes to the rescue. `Promise.all` is a handy function that enables you to run
    asynchronous functions in parallel. Its input is an array of promises; its output
    is a single promise that is fulfilled with an array of the results:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有10个文件，您想要读取它们吗？`Promise.all`来拯救。`Promise.all`是一个方便的函数，可以让您并行运行异步函数。它的输入是一组承诺；其输出是一个用结果数组满足的单个承诺：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Async/Await
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步/等待
- en: This is one of the latest additions to Node.js, having been added early in 2017
    with version 7.6, providing an even better way of writing asynchronous code, making
    it look and behave a little more like synchronous code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Node.js的最新添加之一，早在2017年的7.6版本中就已经添加了，提供了一种更好的编写异步代码的方式，使其看起来和行为更像同步代码。
- en: 'Going back to our file *reading* example, say you wanted to get the contents
    of two files and concatenate them in order. This is how you can achieve that with
    `async`/`await`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的文件*读取*示例，假设您想要获取两个文件的内容并按顺序连接它们。这是您可以使用`async`/`await`实现的方法：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In summary, any asynchronous function that returns a promise can be *awaited*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，任何返回承诺的异步函数都可以*等待*。
- en: 'Activity: Transforming a Text File Using an Async Function'
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：使用异步函数转换文本文件
- en: '**Before You Begin**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前
- en: You should have already gone through the previous activities.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经完成了之前的活动。
- en: '**Aim**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Read the file (using `fs.readFile`), `in-file.txt`, properly case format the
    names (using the `lodash` function, `startCase`), then sort the names in alphabetical
    order and write them out to a separate file `out-file.txt` (using `fs.writeFile`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件（使用`fs.readFile`），`in-file.txt`，正确格式化名称（使用`lodash`函数`startCase`），然后按字母顺序对名称进行排序，并将它们写入到单独的文件`out-file.txt`（使用`fs.writeFile`）。
- en: '**Scenario**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 场景
- en: We have a file, `in-file.txt`, containing a list of peoples' names. Some of
    the names have not been properly case formatted, for example, `john doe` should
    be changed to `John Doe`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个文件`in-file.txt`，其中包含人们的名字列表。一些名字没有正确的大小写格式，例如，`john doe`应更改为`John Doe`。
- en: '**Steps for Completion**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤
- en: In `Lesson-1`, create another folder called `activity-c`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Lesson-1`中，创建一个名为`activity-c`的文件夹。
- en: 'On the Terminal, change directory to `activity-c` and run the following command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上，切换到`activity-c`目录并运行以下命令：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Just like in the previous activity, this will take you to an interactive prompt;
    just press *Enter* all the way, leaving the answers as suggested defaults. The
    aim here is for us to get a `package.json` file, which will help us organize our
    installed packages.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在以前的活动中一样，这将带您进入交互提示符；只需按照建议的默认值一路按*Enter*。这里的目的是让我们获得一个`package.json`文件，这将帮助我们组织我们安装的软件包。
- en: Since we will be using `lodash` here too, let's install it. Run, `npm install
    lodash --save`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们这里也将使用`lodash`，让我们安装它。运行`npm install lodash --save`。
- en: Copy the `in-file.txt` file provided in the `student-files` directory into your
    `activity-c` directory.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`student-files`目录中提供的`in-file.txt`文件复制到您的`activity-c`目录中。
- en: In your `activity-c` directory, create a file called `index.js`, where you will
    write your code.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`activity-c`目录中，创建一个名为`index.js`的文件，您将在其中编写您的代码。
- en: Now, go ahead and implement an `async` function `transformFile`, which will
    take the path to a file as an argument, transform it as described previously (under
    *Aim*), and write the output to an output file provided as a second parameter.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续实现一个“async”函数“transformFile”，它将接受文件路径作为参数，按照之前描述的方式进行转换，并将输出写入作为第二个参数提供的输出文件。
- en: 'On the Terminal, you should indicate when you are reading, writing, and done,
    for example:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上，您应该指示何时正在阅读、写作和完成，例如：
- en: '`reading file: in-file.txt`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “读取文件：in-file.txt”
- en: '`writing file: out-file.txt`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “写入文件：out-file.txt”
- en: '`done`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成
- en: You should read the quick reference documentation on `fs.writeFile` since we
    haven't used it yet. However, you should be able to see its similarity with `fs.readFile`,
    and convert it into a promise function, as we did previously.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读有关“fs.writeFile”的快速参考文档，因为我们还没有使用它。但是，您应该能够看到它与“fs.readFile”的相似之处，并将其转换为一个promise函数，就像我们之前所做的那样。
- en: The solution files are placed at `Code/Lesson-1/activitysolutions/activity-c`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案文件放置在“Code/Lesson-1/activitysolutions/activity-c”中。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through a quick overview of Node.js, seeing how it
    looks under the hood.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速概述了Node.js，看到了它在幕后的样子。
- en: We wrote basic Node.js code and ran it from the Terminal using the Node.js command.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了基本的Node.js代码，并使用Node.js命令从终端运行它。
- en: We also looked at module system of Node.js, where we learnt about the three
    categories of Node.js modules, that is, in-built, third-party (installed from
    the npm registry), and local modules, and their examples. We also looked at how
    Node.js resolves a module name whenever you *require* it, by searching in the
    various directories.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了Node.js的模块系统，学习了Node.js模块的三个类别，即内置模块、第三方模块（从npm注册表安装）和本地模块，以及它们的示例。我们还看了Node.js在*require*模块时如何解析模块名称，通过在各个目录中搜索来实现。
- en: 'We then finished off by looking at the asynchronous programming model that
    is at the heart of how Node.js works, and what actually makes Node.js tick. We
    looked at the three main ways you can write asynchronous code: using *callbacks*,
    *Promises*, and the'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过查看Node.js工作方式的异步编程模型来结束，这实际上是Node.js运行的核心。我们看了您可以编写异步代码的三种主要方式：使用*callbacks*、*Promises*和
- en: new *async/await* paradigm.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 新的*async/await*范式。
- en: The foundation is now laid for us to go ahead and implement our API using Node.js.
    Most of these concepts will crop up again as we build our API.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为使用Node.js实现我们的API奠定了基础。在构建API时，这些概念中的大部分将再次出现。
