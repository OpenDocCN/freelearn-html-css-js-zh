- en: Chapter 10. Building User Interfaces Using React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：使用 React 构建用户界面
- en: Writing code for reactive UI is a difficult task, as writing code to manipulate
    the DOM using JavaScript whenever the application state changes is difficult and
    it makes understanding the application difficult. Therefore, the MVC architecture
    was introduced, where we define the UI and application state separately, and the
    UI is updated automatically as the application state changes. MVC framework views
    have been concentrating on making the writing of code for reactive UIs easier
    but not increasing rendering performance, reusability, and ease of debugging.
    This is what React aims to solve. It not only makes writing code for reactive
    UI easier but also takes care of rendering performance, reusability, and ease
    of debugging.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写响应式 UI 的代码是一项困难的任务，因为每当应用程序状态改变时编写使用 JavaScript 操作 DOM 的代码是困难的，这也会使理解应用程序变得困难。因此，引入了
    MVC 架构，其中我们分别定义 UI 和应用程序状态，并且当应用程序状态改变时，UI 会自动更新。MVC 框架视图一直专注于使编写响应式 UI 的代码更容易，但并没有提高渲染性能、可重用性和易于调试。这正是
    React 旨在解决的问题。它不仅使编写响应式 UI 的代码更容易，而且还关注渲染性能、可重用性和易于调试。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What React is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 是什么
- en: Virtual DOM technology
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟 DOM 技术
- en: Component-based UI development using React
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 进行基于组件的 UI 开发
- en: One-way dataflow programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向数据流编程
- en: Using JSX to write React code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSX 编写 React 代码
- en: Using React on the server side to build isomorphic apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端使用 React 构建 isomorphic 应用程序
- en: Many other topics to help us get a good hold on React
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其他主题帮助我们更好地掌握 React
- en: Introducing React
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 React
- en: React is a JavaScript library for building reactive UIs. We usually use jQuery
    or pure JavaScript to manipulate a reactive UI whenever the application state
    changes, which makes it difficult to reuse and understand the code. Instead, we
    can use React, which lets us declare how the UI behaves based on the application
    state, and it automatically updates the UI whenever the application state changes.
    There are lots of libraries and technologies, such as web components and templating
    engines, that aim to make the building of UIs easier, but React stands out from
    the crowd as it makes it easy to build reusable and high-performance reactive
    UIs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个用于构建响应式 UI 的 JavaScript 库。我们通常使用 jQuery 或纯 JavaScript 来操作响应式 UI，每当应用程序状态改变时，这使得代码难以重用和理解。相反，我们可以使用
    React，它允许我们根据应用程序状态声明 UI 的行为，并且每当应用程序状态改变时，它会自动更新 UI。有许多库和技术，如 Web 组件和模板引擎，旨在使
    UI 的构建更容易，但 React 在人群中脱颖而出，因为它使构建可重用和高性能的响应式 UI 变得容易。
- en: React is also used as a view library because it is exactly what a view library
    is supposed to be. A view holds the UI of the application and defines how the
    UI changes based on the application state, that is, how the application state
    is displayed. As it's just a view library, it doesn't tell us how to manage, access,
    and mutate the application state. It can be used as the view layer in any kind
    of architecture and framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: React 也被用作视图库，因为它正是视图库应该具备的样子。视图持有应用程序的 UI 并定义了基于应用程序状态 UI 如何变化，也就是说，应用程序状态是如何显示的。由于它只是一个视图库，它不会告诉我们如何管理、访问和修改应用程序状态。它可以作为任何类型架构和框架中的视图层使用。
- en: Remember that React is a library and not a framework such as Angular or Ember.
    Thus, React can be used with Angular to make Angular views better in terms of
    performance and reusability.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，React 是一个库，而不是像 Angular 或 Ember 这样的框架。因此，React 可以与 Angular 一起使用，以在性能和可重用性方面使
    Angular 视图变得更好。
- en: For example, there is an AngularJS module named ngReact that lets React be used
    as a view in AngularJS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个名为 ngReact 的 AngularJS 模块，它允许 React 在 AngularJS 中作为视图使用。
- en: Even the Flux architecture uses React as its view. We will learn more about
    Flux in the next chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是 Flux 架构也使用 React 作为其视图。我们将在下一章中了解更多关于 Flux 的内容。
- en: React is always used with a framework as it only defines the UI but doesn't
    tell us how to manage the application logic and state, just like a template library
    or web component is always used with a framework.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: React 总是与框架一起使用，因为它只定义了 UI，但没有告诉我们如何管理应用程序逻辑和状态，就像模板库或 Web 组件总是与框架一起使用一样。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Is React a templating engine?**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**React 是模板引擎吗？**'
- en: React is not a templating engine. The views of most of the popular MVC frameworks
    are of a template system. In a templating system, we write HTML with a template
    language for the UI, and it is processed in order to generate the final HTML.
    For example, an AngularJS view is a template system that's composed of directives,
    expressions, and so on. React is not a templating engine because we don't write
    HTML. Instead, we define the structure of the DOM using JavaScript. React can
    also do much more than what a templating engine can do. It can also capture user
    events in the UI. This is how it differs from traditional views. It's just that
    React works in a different way than a template system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: React 不是一个模板引擎。大多数流行的 MVC 框架的视图都是模板系统的。在模板系统中，我们使用模板语言编写 HTML 以构建 UI，然后对其进行处理以生成最终的
    HTML。例如，AngularJS 视图是一个由指令、表达式等组成的模板系统。React 不是一个模板引擎，因为我们不编写 HTML。相反，我们使用 JavaScript
    定义 DOM 的结构。React 还能做许多模板引擎做不到的事情。它还可以捕获 UI 中的用户事件。这就是它与传统视图的不同之处。只是 React 的工作方式与模板系统不同。
- en: When building user interfaces using React, we don't write any HTML to build
    the UI like when using other frameworks and libraries; instead, we declare the
    DOM structure using JavaScript only. This programming style is what makes React
    able to implement various algorithms and technologies to achieve high rendering
    performance and reusability.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React 构建用户界面时，我们不会像使用其他框架和库那样编写任何 HTML 来构建 UI；相反，我们仅使用 JavaScript 声明 DOM
    结构。这种编程风格使得 React 能够实现各种算法和技术，以实现高渲染性能和可重用性。
- en: Before we get further into learning React, let's first set up a project to use
    it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步学习 React 之前，让我们首先设置一个项目来使用它。
- en: Setting up a basic React project
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基本的 React 项目
- en: At the time of writing, the latest version of React was 0.14.7\. This is the
    version this book uses. First, visit [https://facebook.github.io/react/downloads.html](https://facebook.github.io/react/downloads.html)
    to download React. Here, you will find two types of React builds, namely, production
    and development builds. The difference between these two build is that the development
    build is uncompressed and includes extra warnings, whereas the production build
    is compressed, includes extra performance optimizations, and strips all errors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，React 的最新版本是 0.14.7。本书使用的是这个版本。首先，访问 [https://facebook.github.io/react/downloads.html](https://facebook.github.io/react/downloads.html)
    下载 React。在这里，你可以找到两种类型的 React 构建，即生产构建和开发构建。这两种构建之间的区别在于，开发构建未压缩，包括额外的警告，而生产构建已压缩，包括额外的性能优化，并删除了所有错误。
- en: You should use the development build when your application is in the development
    phase. Once your application is ready for deployment, you should change to the
    production build.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序处于开发阶段时，你应该使用开发构建。一旦你的应用程序准备就绪，你应该切换到生产构建。
- en: 'Again, you will find two types of production and development build: one with
    add-ons and the other without. We will use the development version without add-ons.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你将找到两种生产环境和开发环境的构建版本：一种带有附加组件，另一种不带。我们将使用不带附加组件的开发版本。
- en: 'You will find CDN links as well as links to download and enqueue React manually.
    React is composed of two files: `react.js` and `react-dom.js`. Download both of
    them manually.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以找到 CDN 链接以及下载和排队 React 的链接。React 由两个文件组成：`react.js` 和 `react-dom.js`。请手动下载这两个文件。
- en: 'Create a folder named `react-demo` and place both the files in it. Then, create
    a file called `index.html` and put this code in it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `react-demo` 的文件夹，并将两个文件放入其中。然后，创建一个名为 `index.html` 的文件，并将以下代码放入其中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Later on in this chapter, we will learn more about why React is composed of
    two files and not one. For now, just ignore this.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将学习更多关于为什么 React 由两个文件组成而不是一个的原因。现在，只需忽略这一点。
- en: Virtual DOM
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟 DOM
- en: A browser interprets HTML and creates a DOM. A DOM is a tree-like structure
    that defines the structure of the page. The browser then renders the DOM on the
    page. The DOM API is what we use to manipulate the DOM. When we manipulate it,
    the browser re-renders the manipulated parts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器解释 HTML 并创建一个 DOM。DOM 是一个定义页面结构的树状结构。然后浏览器在页面上渲染 DOM。DOM API 是我们用来操作 DOM
    的。当我们操作它时，浏览器会重新渲染被操作的部分。
- en: The problem is not with how the DOM works, but how we programmatically alter
    it. Manipulating nodes of a DOM requires expertise; otherwise, we could often
    end up re-rendering lots of nodes unnecessarily, which would result in poor rendering
    performance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于DOM是如何工作的，而在于我们如何程序化地改变它。操作DOM节点需要专业知识；否则，我们经常会不必要地重新渲染很多节点，这会导致渲染性能不佳。
- en: For example, imagine we have a large list of products in an e-commerce website.
    We also have a filter widget to filter the items. When we change the values in
    the filter widget, the list items are reloaded and the complete list is re-rendered,
    which requires a lot of manipulation to the DOM and can result in bad rendering
    performance. To get better performance, we can actually manipulate only specific
    parts of the list, such as product titles, image, and cost. But writing code for
    this is going to be hard.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象我们在一个电子商务网站上有一个大量的产品列表。我们还有一个过滤器小部件来过滤项目。当我们更改过滤器小部件中的值时，列表项将被重新加载，整个列表将被重新渲染，这需要对DOM进行大量的操作，可能会导致渲染性能不佳。为了获得更好的性能，我们实际上可以只操作列表的特定部分，例如产品标题、图片和成本。但编写这样的代码将会很困难。
- en: Let's take another example. If you are using `ng-repeat` to display a list,
    then adding a new item to the list will cause the complete re-rending of the list.
    So, if Facebook or Instagram had used `ng-repeat`, then whenever we scrolled down,
    the whole set of posts would have been re-rendered. The solution to this problem
    is instead of using `ng-repeat`, which re-renders the whole list, we can append
    a new post to the end of the list using jQuery or pure JavaScript. But if you
    want to maintain the posts that are being displayed, then you will end up writing
    some more complex code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子。如果你正在使用`ng-repeat`来显示一个列表，那么向列表中添加一个新项目将导致整个列表的重新渲染。所以，如果Facebook或Instagram使用了`ng-repeat`，那么每次我们向下滚动时，整个帖子集都会被重新渲染。解决这个问题的一个方法是不使用`ng-repeat`，因为它会重新渲染整个列表，我们可以使用jQuery或纯JavaScript将新帖子追加到列表的末尾。但如果你想要保持显示的帖子，那么你将不得不编写一些更复杂的代码。
- en: Due to these kinds of problem, virtual DOM was introduced. Virtual DOM makes
    sure that anyone can write complex reactive UI code without worrying about performance.
    Virtual DOM is the secret that React implements to achieve rendering performance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这类问题，虚拟DOM被引入。虚拟DOM确保任何人都可以编写复杂的响应式UI代码，而不用担心性能。虚拟DOM是React实现渲染性能的秘密。
- en: A virtual DOM is an abstract version of the real DOM, that is, a description
    of the real DOM. Virtual DOM elements are just JavaScript objects whereas real
    DOM elements are real UI elements. Virtual DOM is much faster as it's just a JavaScript
    data structure and manipulating it doesn't automatically re-render the UI. Earlier,
    I said that in React, you don't write any HTML but instead declare the structure
    of the DOM. Actually, you declare the structure of the virtual DOM, not the real
    DOM. React keeps the real DOM in sync with virtual DOM. Whenever the application
    state changes to update the UI, React uses complex algorithms to compare the real
    DOM with the virtual DOM and finds as few mutations as possible for the real DOM
    to sync with the virtual DOM. We will later see how these algorithms actually
    find the difference and mutate the real DOM. For example, if we have a list in
    the virtual DOM and we remove the list and add a new list with just an extra item,
    then, only the new item is rendered when synced with the real DOM, not the whole
    list.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟DOM是真实DOM的抽象版本，即真实DOM的描述。虚拟DOM元素只是JavaScript对象，而真实DOM元素是真实的UI元素。虚拟DOM要快得多，因为它只是一个JavaScript数据结构，操作它不会自动重新渲染UI。之前我说过，在React中，你不会写任何HTML，而是声明DOM的结构。实际上，你声明的是虚拟DOM的结构，而不是真实DOM。React保持真实DOM与虚拟DOM同步。每当应用程序状态改变以更新UI时，React使用复杂的算法来比较真实DOM和虚拟DOM，并找到尽可能少的突变以使真实DOM与虚拟DOM同步。我们稍后会看到这些算法实际上是如何找到差异并突变真实DOM的。例如，如果我们有一个在虚拟DOM中的列表，我们删除列表并添加一个只有一个额外项的新列表，那么，当与真实DOM同步时，只有新项被渲染，而不是整个列表。
- en: 'Let''s look at some example code to print **Hello World** using React. Inside
    the `index.html` body tag, place this code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些使用React打印**Hello World**的示例代码。在`index.html`的`body`标签内，放置以下代码：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are going to display **Hello World** inside this `div` element. Place this
    code in the script tag of the `index.html` file to display **Hello World**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个`div`元素中显示**Hello World**。将此代码放置在`index.html`文件的`script`标签中，以显示**Hello
    World**：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is how the code''s output looks:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码输出的样子：
- en: '![Virtual DOM](img/B05154_10_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟 DOM](img/B05154_10_01.jpg)'
- en: Let's understand how the code works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解代码是如何工作的。
- en: '`React.createElement` is used to create an object of a `ReactElement` interface.
    A `ReactElement` object is a light, stateless, and virtual representation of a
    real DOM element, but it''s not a real DOM element. It''s a virtual DOM, basically.
    `ReactElement` and real DOM elements are of different interfaces. The first parameter
    of `React.createElement` can be an HTML tag name or an object of a `ReactClass`
    interface. We will learn more about `ReactClass` later on. The second argument
    is an object containing attributes of the HTML tag or properties of the `ReactClass`
    object. And then, we can pass an infinite number of arguments, which can be strings,
    `ReactElement` objects, or `ReactClass` objects. All the arguments after the second
    argument are treated as children of the `ReactElement` object that''s going to
    be created. If the children are dynamically decided, then you can provide an array
    as the third argument.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.createElement` 用于创建一个 `ReactElement` 接口的对象。`ReactElement` 对象是一个轻量级、无状态和虚拟的真实
    DOM 元素的表示，但它不是一个真实的 DOM 元素。它基本上是一个虚拟 DOM。`ReactElement` 和真实 DOM 元素具有不同的接口。`React.createElement`
    的第一个参数可以是一个 HTML 标签名或 `ReactClass` 接口的对象。我们将在稍后学习更多关于 `ReactClass` 的内容。第二个参数是一个包含
    HTML 标签属性或 `ReactClass` 对象属性的对象的参数。然后，我们可以传递无限数量的参数，这些参数可以是字符串、`ReactElement`
    对象或 `ReactClass` 对象。所有第二个参数之后的参数都被视为将要创建的 `ReactElement` 对象的子元素。如果子元素是动态决定的，那么你可以提供一个数组作为第三个参数。'
- en: Here, we created three `ReactElement` objects. `helloWorld` is an anchor tag
    with `helloBold` and `worldItalic` as its children. We assigned the `href` attribute
    of the anchor tag to `#`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了三个 `ReactElement` 对象。`helloWorld` 是一个锚标签，其子元素为 `helloBold` 和 `worldItalic`。我们将锚标签的
    `href` 属性赋值为 `#`。
- en: '`ReactDOM.render` is used to render `ReactElement` objects in the real DOM.
    `ReactDOM.render` takes a `ReactElement` object as first argument, and the second
    argument is the reference to the container element in the real DOM inside which
    we want to add to the `ReactElement`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactDOM.render` 用于在真实 DOM 中渲染 `ReactElement` 对象。`ReactDOM.render` 的第一个参数是一个
    `ReactElement` 对象，第二个参数是我们想在其中添加 `ReactElement` 的真实 DOM 容器元素的引用。'
- en: Here, we've rendered the anchor tag inside the container element.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在容器元素内部渲染了锚标签。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a `ReactElement` object is stateless, we cannot assign any UI event handlers
    to the `properties` object. Also, directly mutating the properties passed to the
    `ReactElement` object will not have any effect, as React doesn't watch the properties
    directly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ReactElement` 对象是无状态的，我们不能将其分配任何 UI 事件处理器到 `properties` 对象。此外，直接修改传递给 `ReactElement`
    对象的属性将没有任何效果，因为 React 不会直接监视属性。
- en: 'In the beginning, it may feel as if `ReactElement` and real DOM elements are
    just created in different ways and their interface is the same, but this is not
    true. Here are a few differences:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，可能会感觉 `ReactElement` 和真实 DOM 元素只是以不同的方式创建，并且它们的接口是相同的，但这并不正确。以下是一些差异：
- en: Instead of the `class` attribute, you need to use `className`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是使用 `class` 属性，你需要使用 `className`
- en: Instead of the `for` attribute, you need to use the `htmlFor` attribute
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是使用 `for` 属性，你需要使用 `htmlFor` 属性
- en: The `style` attribute cannot be a string; it has to be a object
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style` 属性不能是一个字符串；它必须是一个对象'
- en: There are many more. We will explore them as we go deeper.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多。我们将随着深入探讨它们。
- en: Components
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: You can use React using only `ReactElement` objects, but to take advantage of
    React, you have to use React components. `ReactElement` objects are stateless
    and immutable and therefore useless for building reactive UIs. Also, they don't
    provide a structured mechanism for UI reusability.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 React 仅使用 `ReactElement` 对象，但要充分利用 React，你必须使用 React 组件。`ReactElement`
    对象是无状态和不可变的，因此对于构建响应式 UI 来说是无用的。此外，它们不提供 UI 可重用性的结构化机制。
- en: A React component is a reusable custom tag that is mutable and encapsulated
    with an embedded state, that is, changes to the state or properties will mutate
    the UI. For example, we can have a component named `clock` that takes the current
    time as an attribute and displays a clock with the passed time. Another exchange
    could be a Bitcoin price component that displays Bitcoin prices in real time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件是一个可重用的自定义标签，它是可变的，并且封装了一个嵌入的状态，即状态或属性的更改将修改 UI。例如，我们可以有一个名为 `clock`
    的组件，它接受当前时间作为属性并显示带有传递时间的时钟。另一个例子可以是显示实时比特币价格的比特币价格组件。
- en: A component state is internal to the component. It's created and mutated inside
    the component. However, the properties of a component cannot be mutated inside
    the component; rather, they can be mutated by the code that created the component
    instance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 组件状态是组件内部的。它是在组件内部创建和变更的。然而，组件的属性不能在组件内部变更；相反，它们可以通过创建组件实例的代码进行变更。
- en: You can break your complete UI into components—this is the style of coding that's
    recommended when building a UI using react. You can use components inside components
    as well. Before we get further into components, let's rewrite the previous **Hello
    World** code using components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将完整的UI拆分为组件——这是使用react构建UI时推荐的一种编码风格。您还可以在组件内部使用组件。在我们进一步探讨组件之前，让我们使用组件重写之前的**Hello
    World**代码。
- en: 'Inside the `index.html` body tag, place this code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`的`body`标签内部放置以下代码：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We are going to display **Hello World** inside this `div` element. Place this
    code in the `script` tag of the `index.html` file to display **Hello World**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个`div`元素内部显示**Hello World**。将此代码放置在`index.html`文件的`script`标签中，以显示**Hello
    World**：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the output of the previous code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上一段代码的输出：
- en: '![Components](img/B05154_10_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![组件](img/B05154_10_02.jpg)'
- en: 'Here is how the code works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的工作原理：
- en: A component is created using the `React.createClass` function. This function
    takes an object, and the object must have a `render` property assigned to a function
    that returns a `ReactElement` object. The `ReactElement` object returned by the
    `render` method is said to be the content of the component, that is, it states
    how the tag is rendered. Whenever we try to display the tag, the contents of the
    tag are displayed in place.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件是通过`React.createClass`函数创建的。该函数接受一个对象，并且该对象必须有一个`render`属性，该属性被分配给一个返回`ReactElement`对象的函数。由`render`方法返回的`ReactElement`对象被称为组件的内容，即它说明了标签是如何渲染的。每当尝试显示标签时，标签的内容就会在相应位置显示。
- en: '`React.createClass` returns a component. To use the component, we need to create
    instances of it. Like `React.createElement` is used to create a `ReactElement`
    object for an HTML tag, it can also create a `ReactElement` object for a component.
    So, `React.createElement` is used to create instances of a component. `this.props`
    is used inside the component to access its properties.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`React.createClass`返回一个组件。要使用该组件，我们需要创建其实例。就像`React.createElement`用于为HTML标签创建一个`ReactElement`对象一样，它也可以为组件创建一个`ReactElement`对象。因此，`React.createElement`用于创建组件的实例。`this.props`在组件内部用于访问其属性。'
- en: Here, we created a component called `anchorWithBoldItalic`, which is an anchor
    element with some text displayed as bold and some displayed as italic.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个名为`anchorWithBoldItalic`的组件，它是一个带有一些文本以粗体和斜体显示的锚点元素。
- en: Then, we created a `ReactElement` object for our component and finally rendered
    it using `ReactDOM.render`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为我们的组件创建了一个`ReactElement`对象，并最终使用`ReactDOM.render`将其渲染。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that mutating properties after a component instance has been created
    will re-render the component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在创建组件实例之后变更属性将重新渲染组件。
- en: One-way data binding
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单向数据绑定
- en: In the previous subsection, I stated that a component has an enclosing nature.
    Whenever we make changes to the state, the component is rendered. Components also
    let you register UI event handlers, and you can mutate the state inside the event
    handlers too.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子节中，我提到组件具有封装性。每当我们对状态进行更改时，组件就会被渲染。组件还允许您注册UI事件处理器，您也可以在事件处理器内部变更状态。
- en: React lets you manage, access, and mutate UI state but not application state.
    The difference between UI state and application state is that the UI state represents
    the data that's used to manipulate the UI whereas the application state represents
    the data that's displayed in the UI. For example, let's assume that you have a
    comment box. The comments in the comment box are the application state, and the
    **View more comments** button is the UI state, which may or may not be displayed,
    depending on whether there are any more posts.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: React允许您管理、访问和变更UI状态，但不能变更应用状态。UI状态和应用状态之间的区别在于，UI状态表示用于操作UI的数据，而应用状态表示在UI中显示的数据。例如，假设您有一个评论框。评论框中的评论是应用状态，而**查看更多评论**按钮是UI状态，它可能显示也可能不显示，这取决于是否有更多的帖子。
- en: Data binding between a UI and its state is only one-way. This means that user
    actions on the UI cannot alter the UI state directly, but the UI state can alter
    the UI.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: UI 和其状态之间的数据绑定是单向的。这意味着用户对 UI 的操作不能直接改变 UI 状态，但 UI 状态可以改变 UI。
- en: It may seem as if this were a limitation as AngularJS and other popular frameworks
    provide two-way data binding, but this is actually a feature. This feature makes
    it easier to understand and debug applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个限制，因为 AngularJS 和其他流行的框架提供了双向数据绑定，但实际上这是一个特性。这个特性使得理解和调试应用程序变得更加容易。
- en: Many developers tend to use UI state as application state, but for complex and
    large apps, this will cause issues and make it difficult to build the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者倾向于将 UI 状态作为应用程序状态，但对于复杂和大型应用程序，这会导致问题，并使得构建应用程序变得困难。
- en: Let's look at an example of how to use component state by building a button
    that hides/shows a box when clicked on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过构建一个在点击时隐藏/显示盒子的按钮来举例说明如何使用组件状态。
- en: 'Place this code in the `<body>` tag of the `index.html` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放在 `index.html` 文件的 `<body>` 标签内：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will display the component inside this container element.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个容器元素内显示组件。
- en: 'Place this code inside the `script` tag:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放在 `script` 标签内：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the output of the previous code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上一段代码的输出：
- en: '![One-way data binding](img/B05154_10_03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![单向数据绑定](img/B05154_10_03.jpg)'
- en: 'This is how the code works:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的工作原理：
- en: At first, we create a new component.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的组件。
- en: The `getInitialState` method returns the initial state of the component.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getInitialState` 方法返回组件的初始状态。'
- en: Then, we create a click handler that toggles the display state. When mutating
    the state, you must use `this.setState` and not directly mutate the state using
    `this.state`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个点击处理程序，该处理程序切换显示状态。在修改状态时，你必须使用 `this.setState`，而不是直接使用 `this.state`
    来修改状态。
- en: Then, we create the `render` method, which displays a button and a small red
    box. The `render` method sets the display style of the box to the display state.
    So, whenever the state changes, React renders the component. Instead of rendering
    the complete component, React re-renders it by comparing the virtual DOM with
    the real DOM and mutating only the required DOM elements. This is how it achieves
    rendering performance.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建 `render` 方法，该方法显示一个按钮和一个小红框。`render` 方法将盒子的显示样式设置为显示状态。因此，每当状态发生变化时，React
    都会重新渲染组件。React 不是重新渲染整个组件，而是通过比较虚拟 DOM 和真实 DOM，只修改所需的 DOM 元素来重新渲染它。这就是它实现渲染性能的方式。
- en: Finally, we create a component instance and add it to the container element.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个组件实例并将其添加到容器元素中。
- en: Also note that we've only specified a number for height and width without any
    unit. In such a case, the unit is pixels.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要注意，我们只指定了高度和宽度的数值，而没有指定任何单位。在这种情况下，单位是像素。
- en: Isomorphic UI development
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同构 UI 开发
- en: '**Isomorphic development** is where we can use the same code in both the frontend
    and backend.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**同构开发**是指我们可以在前后端使用相同的代码。'
- en: Till now, we've seen how to use React in the frontend to build reactive UI,
    but the same React code can also be used in the backend. When used in the backend,
    React outputs HTML and doesn't provide any kind of UI performance advantage or
    reactivity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在前端使用 React 来构建响应式 UI，但相同的 React 代码也可以用于后端。当在后台使用时，React 输出 HTML，并且不提供任何类型的
    UI 性能优势或响应性。
- en: 'The isomorphic nature of React is one of the things that make it so popular
    and powerful. It has made many things easier. For example, it makes it easier
    to prevent FOUC by letting us pre-render the page in the backend, and then in
    the frontend: the same components will just add event bindings.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: React 的同构特性是使其如此受欢迎和强大的原因之一。它使许多事情变得更容易。例如，它使得通过让我们在后台预先渲染页面来防止 FOUC 变得更容易，然后在前端：相同的组件只需添加事件绑定。
- en: React code not only executes in Node.js but can also be executed in PHP, Ruby,
    .NET, and some other major backend languages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: React 代码不仅可以在 Node.js 中执行，还可以在 PHP、Ruby、.NET 以及一些其他主要的后端语言中执行。
- en: 'Due to the fact that React can be used in both the frontend and backend, the
    React developer team decided to split React into two files: React core and another
    part that is specific to the executing environment. That''s why when we included
    React in our HTML file earlier, we included two files. The React core contains
    `React.createElement`, `React.createClass`, and so on whereas the React DOM contains
    `ReactDOM.render` and so on.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 React 可以在前端和后端使用，React 开发团队决定将 React 分成两个文件：React 核心和针对执行环境的特定部分。这就是为什么当我们之前在
    HTML 文件中包含 React 时，我们包含了两个文件。React 核心包含 `React.createElement`、`React.createClass`
    等，而 React DOM 包含 `ReactDOM.render` 等。
- en: Let's look at an example of how to use React in Node.js by creating and displaying
    the previous hello world component in Node.js. Create a directory named `React-Server-Demo`.
    Inside it, create files named `app.js` and `package.json`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 Node.js 中创建和显示之前的 hello world 组件来查看如何使用 React 的一个示例。创建一个名为 `React-Server-Demo`
    的目录。在其内部，创建名为 `app.js` 和 `package.json` 的文件。
- en: 'Inside the `package.json` file, place this code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `package.json` 文件中，放置以下代码：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, run `npm install` to download the Express and React modules. Now, in
    the `app.js` file, place the following code and run the `node app.js` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行 `npm install` 下载 Express 和 React 模块。现在，在 `app.js` 文件中，放置以下代码并运行 `node
    app.js` 命令：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, open `http://localhost:8080/` in your browser; you''ll see this output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的浏览器中打开 `http://localhost:8080/`；你会看到以下输出：
- en: '![Isomorphic UI development](img/B05154_10_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![同构 UI 开发](img/B05154_10_04.jpg)'
- en: 'This is how the code works:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的工作原理：
- en: First, we import the React core module, then the React server-side module, and
    then Express.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入 React 核心模块，然后是 React 服务器端模块，然后是 Express。
- en: We're using the same code we used earlier to create the component.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用之前创建组件时相同的代码。
- en: Then, we create a route for the root path.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为根路径创建一个路由。
- en: The root path uses the `renderToString` method of the React server-side module
    to generate the HTML code of the component.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根路径使用 React 服务器端模块的 `renderToString` 方法生成组件的 HTML 代码。
- en: Finally, we send the HTML to the client.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将 HTML 发送到客户端。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that by default, React will be in development mode. To use React in production
    mode, set the environment variable `NODE_ENV` to `production`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下，React 将处于开发模式。要在生产模式下使用 React，请将环境变量 `NODE_ENV` 设置为 `production`。
- en: Getting started with JSX
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 JSX
- en: Writing JavaScript to define a tree-like structure and attributes while building
    UI using React is difficult and also makes it difficult to understand the UI.
    So, the React team came up with an alternative syntax to write React code, which
    is easier to write and understand. This alternate syntax is called JSX. JSX stands
    for JavaScript syntax extension. It looks similar to XML. Files that contain JSX
    code have the`.jsx` extension.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript 编写代码来定义树状结构和属性，同时使用 React 构建 UI 是困难的，也使得理解 UI 变得困难。因此，React 团队提出了一种替代语法来编写
    React 代码，这使得编写和理解代码更加容易。这种替代语法被称为 JSX。JSX 代表 JavaScript 语法扩展。它看起来类似于 XML。包含 JSX
    代码的文件具有 `.jsx` 扩展名。
- en: Compiling JSX
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译 JSX
- en: Of course, browsers and server-side engines cannot understand and interpret
    JSX; therefore, we need to compile JSX into pure JavaScript before using it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，浏览器和服务器端引擎无法理解和解释 JSX；因此，在使用 JSX 之前，我们需要将其编译成纯 JavaScript。
- en: There are various open source JSX compilers. You can find the list at [https://github.com/facebook/react/wiki/Complementary-Tools#build-tools](https://github.com/facebook/react/wiki/Complementary-Tools#build-tools).
    The most popular and recommended compiler for JSX is Babel. Babel can be installed
    ([https://babeljs.io/docs/setup/](https://babeljs.io/docs/setup/)), we can use
    the Babel compiler online ([https://babeljs.io/repl/](https://babeljs.io/repl/)),
    and we can also embed the Babel compiler in our HTML page so that it compiles
    in the browser.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种开源 JSX 编译器。你可以在[https://github.com/facebook/react/wiki/Complementary-Tools#build-tools](https://github.com/facebook/react/wiki/Complementary-Tools#build-tools)找到列表。最受欢迎和推荐的
    JSX 编译器是 Babel。Babel 可以安装([https://babeljs.io/docs/setup/](https://babeljs.io/docs/setup/))，我们可以在线使用
    Babel 编译器([https://babeljs.io/repl/](https://babeljs.io/repl/))，我们还可以在我们的 HTML
    页面中嵌入 Babel 编译器，以便在浏览器中编译。
- en: For the purpose of demonstration, we will embed the Babel compiler in our HTML
    page. Compiling takes time, so in production sites, you should never embed the
    compiler in web pages; instead, you should precompile and serve JSX code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将在我们的 HTML 页面中嵌入 Babel 编译器。编译需要时间，因此在生产网站上，你永远不应该在网页中嵌入编译器；相反，你应该预先编译并服务
    JSX 代码。
- en: 'To embed the Babel compiler in a webpage, visit [https://cdnjs.com/libraries/babel-core](https://cdnjs.com/libraries/babel-core)
    and download the Babel core. These are CDN links, so they can be embedded directly,
    but let''s download and embed them in our webpage. Download the `browser.min.js`
    file and place it in the `react-demo` directory. And then, embed it in the `index.html`
    page by placing the following code in the `<head>` tag:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Babel 编译器嵌入到网页中，请访问 [https://cdnjs.com/libraries/babel-core](https://cdnjs.com/libraries/babel-core)
    并下载 Babel 核心。这些是 CDN 链接，因此它们可以直接嵌入，但让我们下载并嵌入到我们的网页中。下载 `browser.min.js` 文件并将其放置在
    `react-demo` 目录中。然后，通过在 `<head>` 标签中放置以下代码将其嵌入到 `index.html` 页面中：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, create a new `<script>` tag at the end of the `body` tag and set the `type`
    attribute to `text/babel` so that the Babel compiler knows which code to compile.
    Here is how the code should look:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `body` 标签的末尾创建一个新的 `<script>` 标签，并将 `type` 属性设置为 `text/babel`，以便 Babel
    编译器知道要编译哪种代码。代码应该看起来像这样：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From now on, all the JSX code will be placed in this script tag.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有的 JSX 代码都将放置在这个脚本标签中。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**JSX editors**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSX 编辑器**'
- en: There are extensions available for almost all the popular code editors to properly
    highlight JSX syntax.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有流行的代码编辑器都有可用的扩展来正确突出显示 JSX 语法。
- en: JSX syntax
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX 语法
- en: 'Let''s rewrite the data-binding example code using JSX syntax. Place this code
    in the `body` tag to create a new container element:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 JSX 语法重写数据绑定示例代码。将此代码放置在 `body` 标签中以创建一个新的容器元素：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the JSX code. Place it in the `script` tag that will be compiled by
    Babel:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 JSX 代码。将其放置在将被 Babel 编译的 `script` 标签中：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the code is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![JSX syntax](img/B05154_10_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![JSX 语法](img/B05154_10_05.jpg)'
- en: 'Before we see how this code works, let''s look at its compiled version:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看代码如何工作之前，让我们看看它的编译版本：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This compiled version will give you a basic idea of how JSX syntax works. Let's
    understand how the previous JSX code works.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编译版本将给你一个基本的了解 JSX 语法是如何工作的。让我们了解之前的 JSX 代码是如何工作的。
- en: In a nutshell, JSX is used to write the `React.createElement` method in XML-like
    syntax. The XML tag name is the first argument, the attributes are the second
    argument, and finally, the child elements are the other arguments of `React.createElement`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，JSX 用于使用类似 XML 的语法编写 `React.createElement` 方法。XML 标签名是第一个参数，属性是第二个参数，最后，子元素是
    `React.createElement` 的其他参数。
- en: If a JSX tag name starts with a lowercase letter, it's an HTML tag, whereas
    if it starts with a capital letter, it's a component. So here, we made the component
    name start with a capital H. Had we used a small H, it would have been treated
    as an HTML tag, and `<hideShowBoxButton></hideShowBoxButton>` would have been
    inserted into the page, which would have rendered nothing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 JSX 标签名以小写字母开头，它是一个 HTML 标签；而如果以大写字母开头，它是一个组件。所以在这里，我们使组件名称以大写 H 开头。如果我们使用小写
    H，它将被视为 HTML 标签，并且 `<hideShowBoxButton></hideShowBoxButton>` 将被插入到页面中，这将不会渲染任何内容。
- en: In the `HideShowBoxButton` component, except the `render` method code, everything
    else is the same. We rewrote the `render` method using JSX syntax.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HideShowBoxButton` 组件中，除了 `render` 方法代码外，其他都相同。我们使用 JSX 语法重写了 `render` 方法。
- en: JSX provides `{}` braces to wrap JavaScript expressions while assigning them
    to attributes or using them as child elements. Here, we've assigned JavaScript
    expressions to `onClick` and `style` attributes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 提供了 `{}` 大括号来包裹 JavaScript 表达式，在将它们分配给属性或用作子元素时使用。在这里，我们将 JavaScript 表达式分配给了
    `onClick` 和 `style` 属性。
- en: Finally, we created an instance of the component using JSX syntax.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 JSX 语法创建了一个组件实例。
- en: In the compiled code, you will find a `displayName` property in the object passed
    to `React.createClass`. The `displayName` property is used for debugging. If not
    set, it's set to the component name while compiling.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译后的代码中，你将在传递给 `React.createClass` 的对象中找到一个 `displayName` 属性。`displayName`
    属性用于调试。如果没有设置，则在编译时设置为组件名称。
- en: Digging into components
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入研究组件
- en: Let's dig further into components and master them. We'll look at component composition
    and ownership. Learning this will help us build complex reactive UIs that are
    easier to manage.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步深入研究组件并掌握它们。我们将查看组件组合和所有权。学习这一点将帮助我们构建更易于管理的复杂响应式 UI。
- en: Component composition
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件组合
- en: '**Composability** is a feature that lets you use a component inside another
    component''s `render` method.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**可组合性** 是一个特性，允许你在另一个组件的 `render` 方法中使用一个组件。'
- en: 'Let''s look at a basic example of component composition. First, create a new
    container element. To do so, place the following code in the `body` tag:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看组件组合的基本示例。首先，创建一个新的容器元素。为此，将以下代码放置在`body`标签中：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the component composition example code. Place this code in the `script`
    tag that''s compiled by Babel:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是组件组合的示例代码。将此代码放置在由Babel编译的`script`标签中：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the output of the code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的输出：
- en: '![Component composition](img/B05154_10_06.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![组件组合](img/B05154_10_06.jpg)'
- en: Here, we've created two different components. Inside the Card component, we
    are using the `ResponsiveImage` component to display a responsive image in it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个不同的组件。在Card组件内部，我们使用`ResponsiveImage`组件来显示其中的响应式图片。
- en: Component ownership
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件所有权
- en: When components are used inside other components' `render` methods, they are
    said to have an owner-ownee relationship and not a parent-child relationship.
    Component X is said to be the owner of component Y if component X created an instance
    of component Y in its `render` method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被用于其他组件的`render`方法中时，它们被称为所有者-被所有者关系，而不是父子关系。如果组件X在其`render`方法中创建了一个组件Y的实例，那么我们说组件X是组件Y的所有者。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that component X is not called the parent; rather, it's called the owner
    of component Y.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，组件X不被称为父组件；相反，它被称为组件Y的所有者。
- en: For example, in the previous code, the `Card` component is the owner of the
    `ResponsiveImage` component and `<div>` is the parent of `ResponsiveImage`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在之前的代码中，`Card`组件是`ResponsiveImage`组件的所有者，而`<div>`是`ResponsiveImage`的父组件。
- en: If we place a component instance inside the opening and closing tags of a component
    instance, then they are said to be in a parent-child relationship. The parent
    can access its children by using the `this.props.children` object. React also
    provides utility functions to make working with children easier. You can find
    the utilities at [https://facebook.github.io/react/docs/top-level-api.html#react.children](https://facebook.github.io/react/docs/top-level-api.html#react.children).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将组件实例放置在组件实例的开头和结尾标签内，那么它们就被说成是父子关系。父组件可以通过使用`this.props.children`对象来访问其子组件。React还提供了实用函数来简化与子组件的工作。您可以在[https://facebook.github.io/react/docs/top-level-api.html#react.children](https://facebook.github.io/react/docs/top-level-api.html#react.children)找到这些实用函数。
- en: Reconciliation
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调
- en: '**Reconciliation** is the process by which React updates the DOM whenever the
    state changes. React doesn''t re-render everything from scratch when the state
    changes; instead, it first finds whether a mutation is required by comparing the
    new virtual DOM with the old one, and if there is a difference, it compares the
    new virtual DOM with the real DOM and makes the necessary mutations.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**协调**是React在状态变化时更新DOM的过程。当状态变化时，React不会从头开始重新渲染一切；相反，它首先通过比较新的虚拟DOM和旧的DOM来查找是否需要变异，如果存在差异，它将比较新的虚拟DOM和真实的DOM，并做出必要的变异。'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that reconciliation doesn't happen only when you change the component state;
    it also happens when you call `ReactDOM.render` on the same container element
    again.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，协调不仅在你更改组件状态时发生；它也发生在你再次在相同的容器元素上调用`ReactDOM.render`时。
- en: 'Let''s see how exactly reconciliation happens by looking at an example. Suppose
    this is the initial render:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一个示例来了解协调是如何发生的。假设这是初始渲染：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we remove `Item 1` from the state, then the render will change to this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从状态中移除`Item 1`，那么渲染将变为：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: React algorithms compare DOM items one by one, and whenever they find a difference
    between two nodes, they make mutations. So here, React will remove the `Item 1`
    list item by changing the text of the first list item and removing the last one.
    This process is much faster than removing both the list items and adding a new
    list item, which is what `ng-repeat` does and what we used to do using JavaScript.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: React算法逐个比较DOM项，并且每当它们在两个节点之间找到差异时，它们就会进行变异。因此，在这里，React将通过更改第一个列表项的文本并删除最后一个来移除`Item
    1`列表项。这个过程比移除两个列表项并添加一个新列表项要快得多，这正是`ng-repeat`所做的工作，也是我们过去使用JavaScript所做的工作。
- en: If the node type is different, React will treat them as two different subtrees,
    throw away the first one, and build/insert the second one. For example, if we
    change `<ul>` to `<ol>`, the complete `<ul>` tree will be deleted.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点类型不同，React会将它们视为两个不同的子树，丢弃第一个，并构建/插入第二个。例如，如果我们将`<ul>`改为`<ol>`，完整的`<ul>`树将被删除。
- en: 'This behavior is fine until you add new items to the end of the list or modify
    them. In case you add new items to the beginning or in between the list, you will
    start facing rendering performance issues. To understand the issue, let''s take
    an example. Let''s add `Item 0` to the beginning. Now, the render will look like
    this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在添加新项目到列表末尾或修改它们之前是正常的。如果你在列表的开始或中间添加新项目，你将开始面临渲染性能问题。为了理解这个问题，让我们举一个例子。让我们在开始处添加
    `Item 0`。现在，渲染将看起来像这样：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, while reconciling, React will first change the text of the first list
    item to `Item 0`, then change the text of the second list item to `Item 1`, and
    finally will add a new list item and assign its text to `Item 2` instead of simply
    adding a new list item to the beginning of the list. This behavior makes the rendering
    actually slower.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在协调过程中，React 将首先将第一个列表项的文本更改为 `Item 0`，然后更改第二个列表项的文本为 `Item 1`，最后将添加一个新的列表项并将其文本设置为
    `Item 2`，而不是简单地在新列表项的开头添加一个新的列表项。这种行为使得渲染实际上变慢了。
- en: React does provide a way to get around this kind of issue as well. It lets us
    uniquely identify each child by assigning it a unique key. When React reconciles
    the keyed children, it will ensure that any child with a key will be reordered
    (instead of being mutated) or destroyed (instead of being reused). A key is assigned
    using the `key` attribute.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: React 也提供了一种绕过这类问题的方法。它允许我们通过分配一个唯一的键来唯一标识每个子元素。当 React 对带键的子元素进行协调时，它将确保任何带有键的子元素将被重新排序（而不是被修改）或销毁（而不是被重用）。键是通过
    `key` 属性分配的。
- en: 'Let''s look at an example of how to create keyed children. Here is the code
    to create a new container element. Place this code in the `body` tag:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建带键的子元素的示例。以下是创建新容器元素的代码。将此代码放置在 `body` 标签中：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the React code for creating keyed children:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建带键的子元素的 React 代码：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the output of the code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码的输出：
- en: '![Reconciliation](img/B05154_10_07.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![协调](img/B05154_10_07.jpg)'
- en: Here, when the `anchor` element is clicked on, a new object is added to the
    beginning of the result array. As the state changes, the list is re-rendered.
    While rendering, React will reorder the list items and add new list items to the
    beginning instead of mutating them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当点击 `anchor` 元素时，会在结果数组的开头添加一个新的对象。随着状态的变化，列表被重新渲染。在渲染过程中，React 将重新排序列表项并在开头添加新的列表项而不是修改它们。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that when dynamically creating component instances, the key should
    always be supplied to the components in the array, not to the container element
    of each component in the array.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在动态创建组件实例时，应该始终向数组中的组件提供键，而不是向数组中每个组件的容器元素提供键。
- en: Default component property values
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认组件属性值
- en: React lets you define default values for properties in a very declarative way.
    The default value is used if the parent does not pass a property.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: React 允许你以非常声明性的方式定义属性的默认值。如果父组件没有传递属性，则使用默认值。
- en: 'Default values are returned by a method `getDefaultProps`, which is a member
    of the object passed to `React.createClass`. Here is some sample code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值由一个名为 `getDefaultProps` 的方法返回，它是传递给 `React.createClass` 的对象的一个成员。以下是一些示例代码：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Component life cycle methods
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期方法
- en: Various methods are executed at specific points in a component's lifecycle.
    Let's look at them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的生命周期中，会在特定的点执行各种方法。让我们来看看它们。
- en: componentWillMount()
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`componentWillMount()`'
- en: The `componentWillMount()` method is invoked once immediately before the initial
    rendering occurs. If you call `setState` within this method, `render()` will see
    the updated state and will be executed only once despite the state change.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillMount()` 方法在初始渲染发生之前立即被调用。如果你在这个方法中调用 `setState`，`render()` 将会看到更新后的状态，并且即使状态发生变化，也只会执行一次。'
- en: componentDidMount()
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`componentDidMount()`'
- en: The `componentDidMount()` method is invoked only on the client side. It is invoked
    only once after initial rendering has occurred.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidMount()` 方法仅在客户端调用。它仅在初始渲染发生后调用一次。'
- en: componentWillReceiveProps(nextProps)
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`componentWillReceiveProps(nextProps)`'
- en: Directly mutating the properties passed to a component will have no effect because
    there is no way for React to find value changes as it doesn't watch the properties
    directly. But sometimes, it is possible for React to predict property value changes,
    and in that case, it calls the `componentWillReceiveProps` method, if it exists,
    with the new property values as its parameters, and it also re-renders the component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 直接修改传递给组件的属性将没有任何效果，因为 React 无法找到值的变化，因为它不会直接监视属性。但有时，React 可以预测属性值的变化，在这种情况下，如果存在，它会以新的属性值作为参数调用
    `componentWillReceiveProps` 方法，并且它也会重新渲染组件。
- en: For example, if we change the state of the owner of a component, then that sends
    a signal that the properties of the components it owns might have changed, so
    it calls the `componentWillReceiveProps` method and re-renders the components
    it owns.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们更改组件拥有者的状态，那么这将发送一个信号，表明它拥有的组件的属性可能已更改，因此它将调用 `componentWillReceiveProps`
    方法并重新渲染它拥有的组件。
- en: 'Let''s look at an example to demonstrate the `componentWillReceiveProps` method.
    We will create a button whose value increments every second. Here is the code
    to create a new container element. Place it in the `body` tag:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示 `componentWillReceiveProps` 方法。我们将创建一个每秒值递增的按钮。以下是创建新容器元素的代码。将其放置在
    `body` 标签中：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the code for our example. Place this code in the `script` tag that
    will be compiled by Babel:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里是我们示例的代码。将此代码放置在将被 Babel 编译的 `script` 标签中：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the output of the code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的输出：
- en: '![componentWillReceiveProps(nextProps)](img/B05154_10_08.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![componentWillReceiveProps(nextProps)](img/B05154_10_08.jpg)'
- en: In the code, we are changing the state of the owner every second after the initial
    rendering has occurred. Whenever the state changes, the `componentWillReceieveProps`
    object of `ButtonComponent` is called. Inside the `componentWillReceieveProps`
    object, we can use `this.props` to access the previous values of the properties.
    The button is rendered whenever its owner's state changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们在初始渲染发生后每秒更改拥有者的状态。每当状态改变时，`ButtonComponent` 的 `componentWillReceieveProps`
    对象就会被调用。在 `componentWillReceieveProps` 对象内部，我们可以使用 `this.props` 来访问属性的先前值。每当拥有者的状态改变时，都会渲染按钮。
- en: Remember that `componentWillReceieveProps` is called before the component is
    re-rendered, so we can make any state changes we want inside it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`componentWillReceieveProps` 在组件重新渲染之前被调用，因此我们可以在其中进行任何我们想要的州改变。
- en: shouldComponentUpdate(nextProps, nextState)
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: shouldComponentUpdate(nextProps, nextState)
- en: The `shouldComponentUpdate(nextProps, nextState)` method is called before the
    `render` method is called, that is, before rendering happens. If this method returns
    `false`, then rendering is skipped.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `render` 方法之前，会调用 `shouldComponentUpdate(nextProps, nextState)` 方法，即在渲染发生之前。如果此方法返回
    `false`，则跳过渲染。
- en: Remember that this method is not called before forced updates or initial rendering.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，此方法在强制更新或初始渲染之前不会被调用。
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**What is a forced update?**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是强制更新？**'
- en: React provides a `forceUpdate` method inside a component, which renders the
    component when called. This can be used when the `render()` method depends on
    some other data instead of just `this.props` and `this.state`, as changes to other
    data don't trigger the `render` method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: React 在组件内部提供了一个 `forceUpdate` 方法，当被调用时会渲染组件。这可以在 `render()` 方法依赖于某些其他数据而不是仅仅
    `this.props` 和 `this.state` 时使用，因为其他数据的更改不会触发 `render` 方法。
- en: componentWillUpdate(nextProps, nextState)
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: componentWillUpdate(nextProps, nextState)
- en: The `componentWillUpdate(nextProps, nextState)` method is invoked immediately
    before rendering when new props or state are being received. This method is not
    called for the initial render.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到新的 props 或 state 时，`componentWillUpdate(nextProps, nextState)` 方法会在渲染之前立即被调用。对于初始渲染，此方法不会被调用。
- en: Note that you cannot use `this.setState` inside this method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你无法在此方法中使用 `this.setState`。
- en: componentDidUpdate(prevProps, prevState)
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: componentDidUpdate(prevProps, prevState)
- en: The `componentDidUpdate(prevProps, prevState)` method is invoked immediately
    after the component's updates are flushed to the real DOM. This method is not
    called for the initial render.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidUpdate(prevProps, prevState)` 方法在组件的更新被刷新到真实 DOM 之后立即被调用。对于初始渲染，此方法不会被调用。'
- en: componentWillUnmount()
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: componentWillUnmount()
- en: The `componentWillUnmount()` method is invoked immediately before a component
    is unmounted from the real DOM.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillUnmount()` 方法在组件从真实 DOM 中卸载之前立即被调用。'
- en: Mixins
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合
- en: There are times when multiple components share the same code; in such cases,
    we can use mixins instead of writing the same code again and again.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，多个组件共享相同的代码；在这种情况下，我们可以使用混合（mixins）而不是反复编写相同的代码。
- en: A **mixin** is an object that holds component methods that can be easily plugged
    in to any component.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合**是一个包含可以轻松插入到任何组件中的组件方法的对象。'
- en: 'Let''s look at an example to demonstrate mixins. Here is the code to create
    a new container element. Place it in the `body` tag:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示混合（mixins）。以下是创建新容器元素的代码。将其放置在 `body` 标签中：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here is the code for our example. Place it in the `script` tag that will be
    compiled by Babel.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的示例代码。将其放置在将被 Babel 编译的 `script` 标签中。
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is the output of the code on the page:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是页面上的代码输出：
- en: '![Mixins](img/B05154_10_09.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![混合](img/B05154_10_09.jpg)'
- en: 'And this is the output on the console:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制台上的输出：
- en: '![Mixins](img/B05154_10_10.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![混合](img/B05154_10_10.jpg)'
- en: Here, we've created two mixins and added them to `HeadingComponent`. These mixins
    can be used in any number of methods. Mixins simply increase code reusability.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个混合并将它们添加到 `HeadingComponent` 中。这些混合可以在任意数量的方法中使用。混合只是增加了代码的可重用性。
- en: Using Refs
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用引用
- en: '**Refs** are used inside components to return references to real DOM elements
    rendered by React. So, instead of assigning an `id` or `class` value to elements,
    we can assign refs. It''s easier to get references to real DOM elements using
    refs than `id` or `class` attributes.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用**（Refs）在组件内部使用，用于返回 React 渲染的真实 DOM 元素的引用。因此，我们不需要将 `id` 或 `class` 值分配给元素，而是可以分配引用。使用引用比使用
    `id` 或 `class` 属性更容易获取真实 DOM 元素的引用。'
- en: 'Let''s look at a basic example of how to use refs by creating a form. First,
    create a container element and place it inside the `body` tag. Here is the code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个表单来查看如何使用引用的基本示例。首先，创建一个容器元素并将其放置在 `body` 标签内。以下是代码：
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is the code for the form, which uses refs:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用引用的表单代码：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of this code on the webpage is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在网页上的输出如下：
- en: '![Using Refs](img/B05154_10_11.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![使用引用](img/B05154_10_11.jpg)'
- en: 'If we enter `Hello World` in the text field and click on the button, then the
    output of the console is this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在文本字段中输入 `Hello World` 并点击按钮，那么控制台的输出如下：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the previous code, we're assigning a `ref` attribute to the button element.
    To refer to the button in the methods of the component, we use `this.refs`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在将 `ref` 属性分配给按钮元素。要在组件的方法中引用按钮，我们使用 `this.refs`。
- en: ReactDOMServer.renderToStaticMarkup
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactDOMServer.renderToStaticMarkup
- en: Earlier in this chapter, we used React on the server side to generate HTML.
    The HTML generated by React on the server and client side contains `data-reactid`
    attributes, which are used by React internally. On the client side, it makes sense
    to have `data-reactid`, as it is used during reconciliation and other processes
    and features.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们使用 React 在服务器端生成 HTML。React 在服务器端和客户端生成的 HTML 包含 `data-reactid` 属性，这些属性由
    React 内部使用。在客户端，有 `data-reactid` 是有意义的，因为它在协调和其他过程中以及功能中使用。
- en: You must be wondering what the point of adding this attribute on the server
    side is. Actually, it is added so that if you call `ReactDOM.render()` on the
    client side on a node that already has React server-rendered markup, React will
    preserve it and only reconcile it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道在服务器端添加此属性的意义是什么。实际上，它是添加的，以便如果你在已经具有 React 服务器端渲染标记的节点上在客户端调用 `ReactDOM.render()`，React
    将保留它并仅进行协调。
- en: If you don't want `data-reactid` attributes to be generated on the server side,
    you can use `renderToStaticMarkup` instead of `renderToString`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在服务器端生成 `data-reactid` 属性，你可以使用 `renderToStaticMarkup` 而不是 `renderToString`。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned React up to an intermediate level by covering in
    depth its features and components, JSX, using it for server-side rendering, reconciliation,
    and so on. We also learned miscellaneous features such as mixins and refs. Now,
    you should have a basic understanding of how and when to integrate React into
    your websites.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过深入探讨其特性和组件、JSX、服务器端渲染、协调等，将 React 学习到了中级水平。我们还学习了混合（mixins）和引用等杂项功能。现在，你应该对如何以及何时将
    React 集成到你的网站中有一个基本的了解。
- en: In the next chapter, we will learn React in more depth by building an application
    that uses the Flux and SPA architectures.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过构建一个使用 Flux 和 SPA 架构的应用程序来更深入地学习 React。
