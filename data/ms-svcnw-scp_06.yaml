- en: Advanced Server-Side Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级服务器端脚本编程
- en: In this chapter, we will be taking a look at the advanced side of server-side
    scripting. We will explore some more advanced methods and techniques that can
    be used on the server side, building upon what we learned in the previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨服务器端脚本的高级方面。我们将探讨一些更高级的方法和技术，这些方法和技术可以在服务器端使用，建立在上一章所学内容的基础上。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Script includes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本包含
- en: Scheduled jobs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时任务
- en: Background scripts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景脚本
- en: Workflow scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作流程脚本
- en: Event management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件管理
- en: Script actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本操作
- en: Advanced server script examples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级服务器脚本示例
- en: Script includes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本包含
- en: Script includes are at the heart of scripting in ServiceNow, and are arguably
    the most commonly used when it comes to writing code. Script includes are used
    to hold classes of code, and for a lot of the backend script used by the ServiceNow
    platform.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本包含是ServiceNow脚本的核心，并且在编写代码时可以说是最常用的。脚本包含用于存放代码类，以及ServiceNow平台使用的许多后端脚本。
- en: When creating your script include, you first need to give it a name. This name
    will be important, as it will be used in other code to call the methods in your
    script include.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建您的脚本包含时，您首先需要给它一个名称。这个名称将非常重要，因为它将在其他代码中用于调用脚本包含中的方法。
- en: Ensure that the name you choose for your script include does not contain spaces
    in it. It is best to use underscores to separate words in the name.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您为脚本包含选择的名称中不包含空格。最好使用下划线在名称中分隔单词。
- en: Once you enter a name for your script include, you will notice that the API
    Name and the script fields are populated. The API name is read-only, and given
    based upon the name of the application this script include is being created in,
    followed by the name of the script include itself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为您的脚本包含输入一个名称，您会注意到API名称和脚本字段已被填充。API名称是只读的，根据创建此脚本包含的应用程序的名称以及脚本包含本身的名称给出。
- en: 'The script field is populated with some introductory script creating a class
    for this script include, taking into account the name of the script include. As
    an example, if we named our script include `script_utils`, we would be given the
    following script:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本字段填充了一些用于创建此脚本包含类的简介脚本，考虑到脚本包含的名称。例如，如果我们命名我们的脚本包含为`script_utils`，我们会得到以下脚本：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This gives us the basic code to create a script include class that can be called
    from the server side. One of the first questions to ask when creating a script
    include is whether the script will be called from the server side only, or from
    the client side. This is because if we are going to be calling the script include
    from the client side (for example, for an AJAX call), we need to tick the Client
    callable checkbox, and in doing this, you will also notice that the code changes,
    too.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了创建一个可以从服务器端调用的脚本包含类的基代码。在创建脚本包含时，首先要问的问题之一是脚本是否仅从服务器端调用，还是从客户端调用。这是因为如果我们打算从客户端调用脚本包含（例如，用于AJAX调用），我们需要勾选客户端可调用复选框，并且在这个过程中，你也会注意到代码也发生了变化。
- en: 'For our example, this will change the code to the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，这将更改代码如下：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This changed script allows the script include to inherit the `AbstractAjaxProcessor`.
    Without this, AJAX calls will not work, so it is important to remember this if
    the script include will be called on the client.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改后的脚本允许脚本包含继承`AbstractAjaxProcessor`。如果没有这个，AJAX调用将不会工作，所以如果脚本包含将在客户端调用，这一点非常重要。
- en: Although this is the starter code that ServiceNow provides for you, it is not
    necessary to create a class in a script include. You can also simply create a
    function to call in a script include when calling server-side script.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是ServiceNow为您提供的入门代码，但并不需要在脚本包含中创建一个类。您也可以简单地创建一个在调用服务器端脚本时在脚本包含中调用的函数。
- en: 'Let''s look at a short example of how that can be done:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简短的例子，看看它是如何做到这一点的：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a simple function that will just return the string of text, but can
    be called simply as a standalone function, rather than creating a whole class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，它只会返回文本字符串，但可以简单地作为一个独立的函数调用，而不是创建整个类。
- en: 'Let''s now have a look at creating a script include with a class and methods.
    We can add as many methods as we like to our script include:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看如何创建一个包含类和方法的脚本包含。我们可以向我们的脚本包含中添加任意多的方法：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our `testMethod` method will return a string when called on the server side.
    To call it, we use the line of code as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当在服务器端调用我们的`testMethod`方法时，它将返回一个字符串。要调用它，我们使用以下代码行：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can also assign this line of code to a variable or use it for a condition
    check if the method returns true or false.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将此代码行分配给变量，或者如果方法返回真或假，则用于条件检查。
- en: Script includes can also call each other and methods contained within them.
    When building up the bulk processing of server-side script, it is usually best
    to consider script includes for the job. Looking at the existing script includes
    that come with the ServiceNow platform is a good way to enhance your knowledge
    of writing script includes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本包含也可以相互调用，以及它们包含的方法。在构建服务器端脚本的批量处理时，通常最好考虑脚本包含的作业。查看ServiceNow平台附带现有的脚本包含是提高编写脚本包含知识的好方法。
- en: Scheduled jobs
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计划中的作业
- en: Scheduled jobs are a way of generating a report or record and automatically
    running a script. Creating a report or record is a configuration and does not
    require scripting. What we are interested in for scheduled jobs is the ability
    to automatically run a script.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 计划中的作业是一种生成报告或记录并自动运行脚本的方式。创建报告或记录是一种配置，不需要脚本编写。对于我们来说，计划中的作业最感兴趣的是能够自动运行脚本的能力。
- en: A scheduled job is a helpful way to run a script at a time of your choosing.
    This can be an overnight job or a script that can run frequently, say, every hour.
    In my experience, running script out of hours is one of the main benefits and
    uses of a scheduled job. Common uses are preparing data for users first thing
    in the morning, or to remove old data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 计划中的作业是一种在您选择的时间运行脚本的有用方式。这可以是一夜之间的作业，也可以是每小时运行一次的脚本。根据我的经验，在非工作时间运行脚本是计划中的作业的主要好处和用途之一。常见的用途包括在早上最早为用户准备数据，或者删除旧数据。
- en: When creating a scheduled job, we set the frequency of the scheduled job by
    using the run field. The different time options in this field give the developer
    different fields to fill in to schedule the script execution appropriately. If
    the On Demand option is picked, the script will only run if the Execute Now button
    is pressed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建计划中的作业时，我们通过使用运行字段来设置计划中的作业的频率。该字段中的不同时间选项为开发者提供了不同的字段来填写，以便适当地安排脚本执行。如果选择按需选项，则只有在按下立即执行按钮时脚本才会运行。
- en: In addition to the schedule, we can also add a condition to the scheduled job
    so that it will only run when the condition evaluates to true. If you check the
    Conditional checkbox, then an additional Condition field is displayed. For the
    script in this Condition field, the final expression of the code needs to evaluate
    to true or false.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日程安排，我们还可以为计划中的作业添加一个条件，这样它只有在条件评估为真时才会运行。如果你勾选了条件复选框，则会显示一个额外的条件字段。对于这个条件字段中的脚本，代码的最终表达式需要评估为真或假。
- en: 'Let''s have a look at an example of a condition script for a scheduled job:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个计划中的作业的条件脚本的示例：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the example, we are checking if the current day is Sunday, and if so, we
    will not run the scheduled job script. The `getDayOfWeek` method gives us the
    day of the week, with one being Monday and seven being Sunday.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们正在检查当前日期是否为星期日，如果是，则不会运行计划中的作业脚本。`getDayOfWeek`方法给我们提供了星期几，其中一代表星期一，七代表星期日。
- en: The second line of script above can give a syntax error saying that a semicolon
    is missing and an expression is seen when a function call or assignment was expected.
    Normally this would be valid, but for the condition field in a scheduled job we
    are expecting an expression and adding a semicolon here would cause the script
    to break.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的脚本第二行可能会出现语法错误，表示缺少分号，并且在函数调用或赋值时看到了表达式。通常这将是有效的，但在计划中的作业的条件字段中，我们期望一个表达式，在这里添加分号会导致脚本中断。
- en: Now let us look at the Run this script field. This is the field where we put
    the code that we would like to run at the scheduled time we have defined.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看“运行此脚本”字段。这是我们将希望在定义的计划时间运行的代码放入的字段。
- en: 'For an example, let us log that our code has run and that it is not a Sunday:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们记录我们的代码已经运行，并且它不是星期日：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can write any server-side script we like in this field to run at the specified
    time. We will look at a more advanced example later in the chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在该字段中编写任何我们喜欢的服务器端脚本，以在指定的时间运行。我们将在本章后面更详细地查看一个更高级的示例。
- en: 'We can see what our scheduled job will look like if we set it to run daily
    at 1:00 a.m. in *Figure 6.1*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将计划中的作业设置为每天凌晨1:00运行，我们可以看到它在*图6.1*中的样子：
- en: '![](img/62e598d5-721a-4ba5-8b41-948d9c466704.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62e598d5-721a-4ba5-8b41-948d9c466704.png)'
- en: 'Figure 6.1: Scheduled job to check if the day is Sunday'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：检查是否为周日的计划任务
- en: A scheduled job is a great way to run script-performing server-side tasks out
    of business hours.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 计划任务是一种在非工作时间运行脚本执行服务器端任务的好方法。
- en: Background scripts
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景脚本
- en: Background scripts are server-side scripts that administrators can immediately
    run on the ServiceNow platform. A background script cannot be saved and does not
    exist as a record. However, they can be extremely useful for trialing scripts
    out and fixing one-off issues with an instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 背景脚本是在ServiceNow平台上管理员可以立即运行的服务器端脚本。背景脚本无法保存，也不以记录的形式存在。然而，它们对于尝试脚本和修复实例的单一问题非常有用。
- en: To start creating a background script, you simply need to select the Scripts
    - Background module in the System Definition application. This brings up a large
    box for the developer to write their code into. If you have administrator access
    and you cannot see the module, there is a system property that can be set that
    means an elevated privilege is required to access background scripts. If this
    is the case, this usually means you need the security_admin role to access background
    scripts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建背景脚本，你只需在系统定义应用程序中选择“脚本 - 背景模块”。这会弹出一个大框供开发者编写代码。如果你有管理员权限但看不到该模块，可以设置一个系统属性，这意味着需要提升权限才能访问背景脚本。如果情况如此，这通常意味着你需要安全管理员角色才能访问背景脚本。
- en: Because background scripts grant the ability to run any JavaScript on the platform,
    this module is often locked down more securely for security purposes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为背景脚本赋予了在平台上运行任何JavaScript的能力，所以出于安全目的，这个模块通常会被更安全地锁定。
- en: 'There are a few choices and buttons that appear under the large script box
    for background scripts. These are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在大脚本框下方有几个选项和按钮出现，用于背景脚本。这些是：
- en: 'Run script (button): Runs the script currently in the Run script box on the
    server side'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行脚本（按钮）：在服务器端运行当前在运行脚本框中的脚本
- en: 'in scope (drop down): Allows the background script to be run in a different
    scope outside of global, if required'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围内（下拉菜单）：如果需要，允许在全局之外的不同范围内运行背景脚本
- en: 'Execute in sandbox? (checkbox): Executes the script with sandbox restrictions;
    for example, data cannot be inserted, updated, or deleted'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在沙盒中执行？（复选框）：以沙盒限制执行脚本；例如，无法插入、更新或删除数据
- en: 'Cancel after 4 hours (checkbox): Check to cancel the script if it is still
    running after four hours'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4小时后取消（复选框）：如果脚本在四小时后仍在运行，则取消脚本
- en: 'Let''s look at an example of a background script:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个背景脚本的例子：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the example, we are checking for all of the incidents that have the software
    category. In the background script, we are logging each incident we find so that
    we can review the list before we go ahead with the deletion. Once we are happy
    with the list that will be deleted, we will see in the log that we can remove
    the log and remove the comment lines, allowing the deletion to take place.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在检查所有具有软件类别的所有事件。在背景脚本中，我们正在记录我们找到的每个事件，以便在执行删除之前审查列表。一旦我们对将要删除的列表感到满意，我们将在日志中看到可以删除日志和删除注释行，从而允许删除操作进行。
- en: This type of example is useful when performing a large removal of records to
    gauge the impact before going ahead with the script.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的例子在执行大量记录删除操作时非常有用，可以在执行脚本之前评估影响。
- en: 'Let''s have a look at what the background script will look like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看背景脚本的样子：
- en: '![](img/73762321-666e-49c6-ba62-dd04a5487b8c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73762321-666e-49c6-ba62-dd04a5487b8c.png)'
- en: 'Figure 6.2: Background script to log records for deletion'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：用于记录删除记录的背景脚本
- en: Background scripts are very helpful for running script to check results before
    performing actions, and also to test parts of a script involved in a long process
    so the process does not need to be walked through each time to test the code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 背景脚本对于在执行操作前运行脚本以检查结果以及测试长时间过程中涉及的脚本部分非常有帮助，这样就不需要每次都遍历整个过程来测试代码。
- en: Workflow scripts
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作流脚本
- en: Workflows use a number of activities to build up a process in ServiceNow. These
    activities can often be used on a basic level, without the need for scripting.
    However, to build a more advanced workflow, we can use code to enhance the workflows
    we build.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流使用多个活动在ServiceNow中构建流程。这些活动通常可以在基本级别上使用，无需脚本。然而，为了构建更高级的工作流，我们可以使用代码来增强我们构建的工作流。
- en: Scripts can appear in a number of workflow activities, including approvals and
    task creation. For approvals, it is possible to add users and groups to approval
    activities using script. In task creation, we can use script to set values on
    our task before it is created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以出现在许多工作流程活动中，包括审批和任务创建。对于审批，可以使用脚本将用户和组添加到审批活动中。在任务创建中，我们可以在任务创建之前使用脚本设置任务上的值。
- en: The main area for scripting in a workflow, though, is in the Run Script Workflow
    Activity. This activity allows the developer to run any server-side script they
    like at a point in the workflow. This can be used to manipulate records, kick
    off integrations, or perform other outcomes using scripts.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在工作流程中脚本的主要编写区域是在运行脚本工作流程活动中。这个活动允许开发者在工作流程中的某个点上运行他们喜欢的任何服务器端脚本。这可以用来操作记录、启动集成或使用脚本执行其他结果。
- en: The other area of workflows in which you often come across scripts is in setting
    up approvals. A simple approval workflow activity will simply pick a user or group
    to approve, or perhaps the value of a particular field. However, if you require
    the selection of relevant approvals to be more complicated than this, then you
    may need to use some code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作流程中，你经常遇到脚本使用的另一个领域是设置审批。一个简单的审批工作流程活动将简单地选择一个用户或组进行审批，或者可能是某个特定字段的值。然而，如果你需要选择相关的审批比这更复杂，那么你可能需要使用一些代码。
- en: With scripts, you can add extra elements to who will be selected to approve,
    for example, by checking attributes about the users approving, or the record being
    approved. It may be that if a record has a particular category, it is sent to
    a certain approval group, or that the approver of the record must have a certain
    role. This type of functionality is achievable with script and can cater for many
    other scenarios too.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用脚本，你可以添加额外的元素来决定谁将被选中进行审批，例如，通过检查审批用户的属性或被审批的记录。可能的情况是，如果一个记录有特定的类别，它将被发送到特定的审批组，或者记录的审批者必须具有特定的角色。这种功能可以通过脚本实现，并且可以适应许多其他场景。
- en: The potential for building a complex approval system is huge, but be careful
    to make sure that what you create provides value and can be maintained.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构建复杂审批系统的潜力是巨大的，但请务必确保你创建的内容具有价值并且可以维护。
- en: 'Let us have a look at an example of a workflow script in a Run Script Workflow
    Activity:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个运行脚本工作流程活动中的工作流程脚本示例：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the example, we are adding `URGENT` to the short description of the record
    if the priority is critical. We also have access to the current record in the
    workflow script, with the current record being the one from which the workflow
    launched.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，如果优先级是关键，我们将`URGENT`添加到记录的简短描述中。我们还可以在流程脚本中访问当前记录，当前记录是工作流程启动的那个记录。
- en: 'Let us have a look at what this activity will look like, in *Figure 6.3*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个活动在*图6.3*中会是什么样子：
- en: '![](img/3d7f4875-9f7c-4d35-9f77-4bf124e4c267.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d7f4875-9f7c-4d35-9f77-4bf124e4c267.png)'
- en: 'Figure 6.3: Workflow activity to update the short description based on priority'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：基于优先级更新简短描述的工作流程活动
- en: Workflow script can be particularly handy for adding an extra layer of functionality
    to your workflows. Sometimes, when you look at the activities available, you cannot
    find one that will meet your requirements, and in this instance, scripting can
    be the solution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程脚本可以特别方便地为你的工作流程添加额外的功能层。有时，当你查看可用的活动时，你可能找不到一个能满足你要求的活动，在这种情况下，脚本可以是解决方案。
- en: Event management
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件管理
- en: Events that trigger different outcomes in an instance run in ServiceNow. An
    event can be invoked from any script on the server side. The main outcome from
    an event being triggered is either a notification or a script action. Notifications
    are usually emails, and we will take a look at script actions later on in this
    chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在ServiceNow中，实例运行中触发不同结果的事件。事件可以从服务器上的任何脚本中调用。事件被触发的主要结果要么是通知，要么是脚本操作。通知通常是电子邮件，我们将在本章后面讨论脚本操作。
- en: 'First of all, to trigger an event, the event will need to be defined. To define
    an event, we can navigate to System Policy | Events | Registry and click on the
    New button. Upon doing this, we are given the form shown in *Figure 6.4*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要触发一个事件，需要定义该事件。要定义一个事件，我们可以导航到系统策略 | 事件 | 注册表，然后点击新建按钮。执行此操作后，我们将看到*图6.4*中所示的形式：
- en: '![](img/9adebc8d-7c21-48ce-99d8-5cd58cc5415a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9adebc8d-7c21-48ce-99d8-5cd58cc5415a.png)'
- en: 'Figure 6.4: New event form'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：新事件表单
- en: In the form, we need to give the event a name. Event names are usually words
    split by full stops and underscores, and if you look at the list of events, you
    will see the general format used for events. It is also good practice to fill
    in the table field for reference. The Fired by and Description fields are simple
    text fields, but it is a good idea to fill these in with details of when the event
    should be fired and how the event is fired. Then, the event can be used by others
    or its trigger point easily found by another administrator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单中，我们需要为事件提供一个名称。事件名称通常是点号和下划线分隔的单词，如果您查看事件列表，您将看到用于事件的通用格式。填写表格字段作为参考也是良好的实践。触发者和描述字段是简单的文本字段，但填写这些字段以详细说明事件应该在何时触发以及如何触发事件是个好主意。然后，其他人可以使用事件，或者另一个管理员可以轻松地找到其触发点。
- en: 'Once we have defined an event, we then need to be able to call the event to
    add it to the event queue. We can use the `GlideSystem` method `eventQueue`, as
    shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了一个事件，我们就需要能够调用该事件以将其添加到事件队列。我们可以使用`GlideSystem`方法`eventQueue`，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we would be calling the event `custom.event`, and this
    would need replacing with the name of the event you have created. The second,
    third, and fourth parameters are an object and two strings, respectively. The
    second parameter is almost always the current record, so that the current record
    data can be used once the event is processed. The third and fourth parameter are
    more commonly known as Parm1 and Parm2\. These can be used in scripts or in notifications;
    for example, you are able to send an email to the value held in Parm1.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将调用事件`custom.event`，这需要替换为您创建的事件的名称。第二个、第三个和第四个参数分别是一个对象和两个字符串。第二个参数几乎总是当前记录，这样一旦事件处理完毕，就可以使用当前记录的数据。第三个和第四个参数更常见地被称为Parm1和Parm2。这些可以在脚本或通知中使用；例如，您可以将电子邮件发送到Parm1中持有的值。
- en: In the example, we are sending the current logged-in user's ID and name. The
    information sent in these parameters often changes, and is often about the current
    user or a value that is useful once the event has been processed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在发送当前登录用户的ID和名称。这些参数中发送的信息通常会变化，并且通常与当前用户或事件处理完毕后有用的值有关。
- en: We can also use the `GlideSystem` method `eventQueueScheduled`, which is very
    similar, except the fifth parameter is the time at which the event should run.
    This can be set as the value of a field that is of `glide_date_time` type.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`GlideSystem`方法`eventQueueScheduled`，它与前面提到的非常相似，只是第五个参数是事件应该运行的时间。这可以设置为`glide_date_time`类型的字段值。
- en: 'We can see an example of this in the following code, using the same event from
    before:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码中看到这个示例，使用之前提到的相同事件：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once an event has been triggered, it will be processed fairly quickly, unless
    it has been scheduled for a certain time, and the events that have been processed
    can be seen in the event logs. To see the event logs, navigate to System Logs
    | Events. From here we can see the  events processed, the processing time, and
    events still to be processed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦事件被触发，它将很快被处理，除非它被安排在特定的时间，并且已经处理的事件可以在事件日志中看到。要查看事件日志，请导航到系统日志 | 事件。从这里我们可以看到处理的事件、处理时间和尚未处理的事件。
- en: Events provide a great way to process multiple scripts or send notifications
    based on a single event, and because an event can be triggered in any server-side
    script, the ways in which an event can be triggered are almost limitless.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 事件提供了一种处理多个脚本或基于单个事件发送通知的绝佳方式，并且由于事件可以在任何服务器端脚本中触发，因此触发事件的方式几乎是无限的。
- en: Script actions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本操作
- en: Script actions tend to be some of the lesser-used methods of server-side scripting.
    They are run after an event has run in the system scheduler. This can be helpful
    as a way to run some script at a set point in the future.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本操作通常是服务器端脚本中较少使用的方法之一。它们在系统调度器中某个事件运行之后执行。这可以作为在未来的某个设定点运行脚本的一种有用方式。
- en: There are some system events that will already exist in ServiceNow that you
    can use to run your script actions from, or you can create your own events and
    execute them from any server-side script.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在ServiceNow中已经存在一些系统事件，您可以使用这些事件来运行脚本操作，或者您可以创建自己的事件，并从任何服务器端脚本中执行它们。
- en: When creating a script action, you need to pick the event to run the script
    action against. This is picked from a list, so make sure the event exists before
    you create the script action. There is also the option to add a condition script,
    which is written in the same style as a business rule. You can also perform condition
    checks in the main script, but if you can use the condition script, it is considered
    better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建脚本操作时，你需要选择运行脚本操作的触发事件。这是从列表中选择的，所以在创建脚本操作之前，请确保事件存在。还有一个选项可以添加条件脚本，其编写风格与业务规则相同。你也可以在主脚本中执行条件检查，但如果可以使用条件脚本，则被认为是更好的选择。
- en: 'Let''s have a look at a script action in use. The main script field can run
    any server-side script. Here, we will add a simple log:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个正在使用的脚本操作。主脚本字段可以运行任何服务器端脚本。在这里，我们将添加一个简单的日志：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example will send a log to the system logs to say that an approval has
    been inserted. This is fine as an example or for debugging, but would not be recommended
    as a script for a production instance, as many approvals are created, and this
    would swamp the logs with this message.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将向系统日志发送一个日志，表示已经插入了一个审批。这对于示例或调试来说是可行的，但不建议作为生产实例的脚本，因为会创建许多审批，这会导致日志被此消息淹没。
- en: 'Let''s have a look at the script action itself, shown in *Figure 6.5*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看脚本操作本身，如*图6.5*所示：
- en: '![](img/de0b276d-5d9b-41f6-8b96-fd10f0803567.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de0b276d-5d9b-41f6-8b96-fd10f0803567.png)'
- en: 'Figure 6.5: Approval-logging script action'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：审批-日志脚本操作
- en: Script actions can also be used to set an action to be performed in the future;
    for example, keeping a record on hold until a certain time in the future.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本操作也可以用来设置将来要执行的操作；例如，将记录保留到未来的某个时间。
- en: Script examples
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本示例
- en: The advanced server-side techniques we have seen can be used in a number of
    ways, and you will find advanced server-side scripting to be some of the most
    common in the ServiceNow platform.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的高级服务器端技术可以用多种方式使用，你会在ServiceNow平台上发现高级服务器端脚本是最常见的。
- en: Now that we have seen where to write our advanced server-side code, we can have
    a look at some further examples to solidify our understanding.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了编写高级服务器端代码的位置，我们可以看看一些进一步的例子来巩固我们的理解。
- en: Let's have a look at a script include example first. We will write a script
    to return the active tasks of a requested item. This can be helpful for letting
    users know which tasks need to be completed for an item to be fulfilled.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看一个脚本包含的例子。我们将编写一个脚本以返回请求项的活动任务。这可以帮助用户知道哪些任务需要完成才能使项得到满足。
- en: 'First we will take a look at the script include code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看脚本包含的代码：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are using the `getActiveTasks` method to get all of the active tasks returned
    to us, passing in the item parameter as the requested item record to get the tasks
    for. Using a `gliderecord` query, we can find all of the tasks, and are returning
    them as an array.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getActiveTasks`方法获取所有返回给我们的活动任务，通过传递项目参数作为请求项记录来获取任务。使用`gliderecord`查询，我们可以找到所有任务，并将它们作为数组返回。
- en: In the example, we have started the creation of an item utilities script include.
    You will often find these in ServiceNow instances having been developed by other
    developers. We have created the first method here, but you would usually build
    up more methods for requested items as part of this class to keep the code organized.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们已经开始了项目工具脚本包含的创建。你通常会发现在其他开发者开发的ServiceNow实例中存在这些脚本。在这里，我们创建了第一个方法，但通常你会在这个类中为请求项构建更多方法，以保持代码的整洁。
- en: 'We can see what the script include will look like in *Figure 6.6*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图6.6*中看到脚本包含的内容将是什么样子：
- en: '![](img/ff0e0038-7e12-46a1-b352-0156b8f9f17f.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff0e0038-7e12-46a1-b352-0156b8f9f17f.png)'
- en: 'Figure 6.6: Item utilities script include'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：项目工具脚本包含
- en: Now that we have the script include, we need to call it from another location.
    Here, we will do this from a business rule, and simply log the result. You can
    use this type of script include to assist in whether to close out requested items,
    too.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了脚本包含，我们需要从另一个位置调用它。在这里，我们将从业务规则中这样做，并简单地记录结果。你也可以使用这种类型的脚本包含来帮助决定是否关闭请求项。
- en: 'Here is the code for the business rule to call the script include:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是调用脚本包含的业务规则的代码：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We would run this business rule on the requested item table. In the code block,
    we put the value of the script include into the tasks variable. We also pass the
    current requested item record using `current`. We are just logging the output
    here, but this data could be used for other uses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在请求项表中运行这个业务规则。在代码块中，我们将脚本包含的值放入任务变量中。我们还使用`current`传递当前请求项记录。我们只是在记录输出，但这些数据可以用于其他用途。
- en: 'Let us also see what the business rule would look like, in *Figure 6.7*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看业务规则的样子，如图6.7所示：
- en: '![](img/e09d3e77-afb0-419a-9e21-5a96f7d59df1.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e09d3e77-afb0-419a-9e21-5a96f7d59df1.png)'
- en: 'Figure 6.7: Business rule to log active requested item tasks'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：记录活动请求项任务的业务规则
- en: Now, let us have a look at a further example of a scheduled job.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个计划任务的例子。
- en: For this example, we will look at deleting all incidents that are over a year
    old. This kind of example shows how we can remove old records overnight for different
    tables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将查看删除所有超过一年的事件。这种例子展示了我们如何在不同表中一夜之间删除旧记录。
- en: 'Let us have a look at what the code would look like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码会是什么样子：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, we get the current date and time by initiating a new `GlideDateTime`
    class, and then removing a year from this time. By using a negative number, in
    this case `-1`, we subtract a year from the current date and time. Using a `GlideRecord`
    query, we are finding all of the incidents updated over a year ago, and deleting
    them using `deleteMultiple`. This deletes all of the records without the need
    to query the `Gliderecord`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们通过初始化一个新的`GlideDateTime`类来获取当前日期和时间，然后从该时间中减去一年。通过使用负数，在这个例子中是`-1`，我们从当前日期和时间中减去一年。使用`GlideRecord`查询，我们正在查找所有一年前更新的事件，并使用`deleteMultiple`删除它们。这删除了所有记录，无需查询`Gliderecord`。
- en: This type of overnight job can be great for clearing out old records or performing
    updates, ready for the day ahead.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的夜间工作对于清除旧记录或执行更新，为第二天做准备是非常好的。
- en: '*Figure 6.8* shows what the scheduled job itself looks like:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.8*显示了计划任务本身的样子：'
- en: '![](img/8153a1c7-bfdb-4c37-b081-ec0a030e4d20.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8153a1c7-bfdb-4c37-b081-ec0a030e4d20.png)'
- en: 'Figure 6.8: Scheduled job to delete old incidents'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：删除旧事件的计划任务
- en: As you can see in the preceding figure, this scheduled job would run at 1:00
    a.m. and delete the incidents overnight. This is common practice so that system
    resources are not being used during the working day.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，这个计划任务将在凌晨1点运行并删除夜间的事件。这是常见的做法，以便在工作日不使用系统资源。
- en: It is also best practice to run long-running scripts overnight so that they
    do not impact the instance resources during business hours. There are also jobs
    that run overnight written by ServiceNow included in a brand new instance; for
    example, the `import set deleter`, which cleans up import sets after seven days.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是在夜间运行长时间运行的脚本，这样它们就不会在业务时间影响实例资源。在全新的实例中还包括ServiceNow编写的夜间运行的任务；例如，`import
    set deleter`，它在七天之后清理导入集。
- en: Running overnight scripts is a great way to use scheduled jobs. This can be
    useful for cleaning up old data or setting up reports so that they are available
    to users first thing in the morning.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行夜间脚本是一种使用计划任务的绝佳方式。这可以用于清理旧数据或设置报告，以便用户在早上第一时间可以使用。
- en: Now, let us have a look at a workflow script example.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个工作流脚本示例。
- en: Here, we will use an approval activity to add an approval that is the director
    in charge of the current caller. This involves iterating through managers of users
    in the database until we find one that is a director.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用一个审批活动来添加一个由当前调用者负责的主任的审批。这涉及到遍历数据库中用户的主任，直到找到一个主任。
- en: 'Let us take a look at the code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the example, we use the `manager` string to keep adding `.manager` to until
    we find a user that is a director. This means saying the manager of the manager
    of the manager, and so on, until a director is found. We can execute this in a
    loop to save time and resources by using `eval`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`manager`字符串不断添加`.manager`直到找到一个主任用户。这意味着说主任的主任，以此类推，直到找到主任。我们可以通过使用`eval`在循环中执行此操作以节省时间和资源。
- en: '`eval` evaluates the contents of the brackets, rather than treating it as its
    current type: in this case, a string. This allows us to dot walk to find the title
    of the user and get the `sys_id` if we find a director. It is also how we can
    use a loop here, adding `.manager` to the string each time we run through the
    loop. `eval` can be very helpful when using script to find the field you require,
    and then to evaluate it once it is found.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`评估括号内的内容，而不是将其视为其当前类型：在这种情况下，一个字符串。这允许我们通过点遍历找到用户的标题并获取如果找到负责人则的`sys_id`。这也是我们如何在每次循环运行时将`.manager`添加到字符串中的方法。`eval`在用脚本查找所需的字段并在找到后对其进行评估时非常有用。'
- en: If no director is found, then no approval will be added at this stage in the
    workflow, as when we get to the top of the organisational tree we would meet a
    user with no manager and exit the loop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到任何负责人，则在工作流程的这个阶段将不会添加任何批准，因为当我们到达组织树的顶端时，我们会遇到一个没有经理的用户并退出循环。
- en: 'We can see the approval activity from the workflow in *Figure 6.9*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从工作流程中看到审批活动，如图6.9所示：
- en: '![](img/ec3a826e-7951-4fdd-b6f2-c1067c25864f.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec3a826e-7951-4fdd-b6f2-c1067c25864f.png)'
- en: 'Figure 6.9: Approval activity to find and add the user''s director as an approver'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：查找并添加用户的负责人作为审批人的审批活动
- en: For our final example, we will take a look at a script action.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最终示例中，我们将查看一个脚本操作。
- en: Sometimes we want to put an incident on hold, but incidents can get left on
    hold for extended periods of time. In this example, we will create a new field
    to hold a date and time for the incident to stay on hold until. Once the date
    and time are reached, an event fires which will run our script action and take
    the incident off hold and move the state to in progress.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们想要挂起一个事件，但事件可能会被挂起很长时间。在这个例子中，我们将创建一个新的字段来保存事件保持挂起状态的日期和时间。一旦达到日期和时间，就会触发一个事件，该事件将运行我们的脚本操作，将事件从挂起状态移除，并将状态移动到进行中。
- en: 'To achieve this goal, we also need to set the event to be scheduled in the
    future. Here, we will use a business rule to do this. The code we will need looks
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们还需要将事件设置为未来安排。在这里，我们将使用业务规则来完成这个操作。我们需要使用的代码如下：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the business rule, we are using the `GlideSystem` method `eventQueueScheduled`
    to put an event into the system scheduler. We have set the third parameter, or
    what can be referenced as `event.parm1`, in later scripts to be the `sys_id` of
    the current incident. You will also notice that the final fifth parameter is the
    value of our custom field to hold the date and time we want the incident to stay
    on hold until.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务规则中，我们使用`GlideSystem`方法的`eventQueueScheduled`将事件放入系统调度器。我们在后续脚本中将第三个参数，或可以称为`event.parm1`，设置为当前事件的`sys_id`。您还会注意到最后一个第五个参数是我们自定义字段中保存我们希望事件保持挂起状态直到的日期和时间的值。
- en: This method sets an event into the system scheduler which will run the event
    at the time we have set in the custom on hold until field. The event we are firing
    (`incident.off.hold`) is a custom one we have created for this particular functionality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将事件设置到系统调度器中，该事件将在我们在自定义挂起直到字段中设置的指定时间运行。我们正在触发的事件（`incident.off.hold`）是我们为特定功能创建的自定义事件。
- en: Once the event fires, we need to move the incident out of the on hold state
    and into in progress. For this, we are going to use our script action.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦事件被触发，我们需要将事件从挂起状态移动到进行中状态。为此，我们将使用我们的脚本操作。
- en: 'The code in our script action is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本操作中的代码如下：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are using the `event` parameter we set in the business rule to use `gliderecord`
    to get the incident record we want to update. Once we have the record, we can
    change the state to in progress, with a value of two, and reset the on hold until
    field before updating the incident record.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在业务规则中设置的`event`参数，通过`gliderecord`获取我们想要更新的事件记录。一旦我们有了记录，我们可以将状态更改为进行中，值为二，并在更新事件记录之前重置挂起直到字段。
- en: 'We can also see the full script action in *Figure 6.10*:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在图6.10中看到完整的脚本操作：
- en: '![](img/045659ff-7ff3-4e96-a9f0-c69401be6c6d.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/045659ff-7ff3-4e96-a9f0-c69401be6c6d.png)'
- en: 'Figure 6.10: Script action to take an incident off hold'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：移除事件挂起状态的脚本操作
- en: This combination of business rule and script action is a very useful technique
    to know for having the ability to run scripts at a specified time in the future.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种业务规则和脚本操作的组合是了解在未来的指定时间运行脚本的能力的一个非常有用的技术。
- en: These practical examples are great for reinforcing the understanding of these
    more advanced server-side script techniques.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实用的示例对于加强对这些更高级服务器端脚本技术的理解非常有帮助。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Advanced server-side scripting was the theme for this chapter. We looked at
    the greatly used script includes and scheduling scripts using scheduled jobs,
    events, and script actions. We also saw how to write script as part of ServiceNow
    workflows and how to test aspects of our code using background scripts. We finished
    off with some great examples of how to use these advanced server-side techniques.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题是高级服务器端脚本。我们探讨了广泛使用的脚本包含以及使用计划任务、事件和脚本动作来安排脚本。我们还展示了如何将脚本作为ServiceNow工作流的一部分来编写，以及如何使用后台脚本来测试代码的各个方面。最后，我们提供了一些如何使用这些高级服务器端技术的优秀示例。
- en: In the next chapter, we look at building your own custom pages by utilizing
    UI pages. We introduce Jelly script and where it appears in ServiceNow, as well
    as show some examples of creating simple custom pages.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过利用UI页面来构建自己的自定义页面。我们介绍了Jelly脚本以及它在ServiceNow中的应用，并展示了创建简单自定义页面的示例。
