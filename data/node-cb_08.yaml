- en: Chapter 8. Integrating Network Paradigms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。集成网络范式
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Sending email
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: Sending SMS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送短信
- en: Communicating with TCP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与TCP通信
- en: Creating an SMTP server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建SMTP服务器
- en: Implementing a virtual hosting paradigm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施虚拟主机范式
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Node's capabilities extend far beyond simply serving web pages. Node's core
    focus of supporting various computing tasks and networking objectives with a simple
    to understand interface allows developers like ourselves to unleash our creativity
    and innovate increasingly interconnected solutions and ideas.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Node的能力远不止于简单地提供网页服务。Node的核心重点是支持各种计算任务和网络目标，其简单易懂的界面使得像我们这样的开发人员能够释放创造力，创新日益相互连接的解决方案和想法。
- en: In this chapter, we'll be looking at some fundamental examples of such interconnectivity
    with the knowledge that we can take these archetypes, growing and combining them
    into larger applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将以一些基本示例来看待这种相互连接的知识，我们知道我们可以将这些原型应用到更大的应用程序中。
- en: Knowledge of how to implement network paradigms can help us to exceed the normal
    boundaries of a web app, providing advanced functionality to our users, and implementing
    more ways for individuals to connect with our services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何实施网络范式可以帮助我们超越Web应用程序的正常界限，为我们的用户提供高级功能，并实现更多与我们服务连接的方式。
- en: Sending email
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: In many platforms, the ability to send email comes standard, but the Node approach
    leaves the email functionality to the developer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多平台上，发送电子邮件的能力是标准的，但Node的方法将电子邮件功能留给开发人员。
- en: Thankfully, there are some excellent module creators in the Node community who
    have already created modules for sending email. In this recipe, we'll be using
    the well-featured third-party `nodemailer` module to send an imaginary newsletter
    to a list of recipients.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，Node社区中有一些出色的模块创建者已经为发送电子邮件创建了模块。在本教程中，我们将使用功能齐全的第三方`nodemailer`模块向一组收件人发送虚构的通讯。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to send an email, we'll need a functioning SMTP server that we can
    connect to. In a later recipe, we'll be creating our own SMTP server, but for
    now we'll have to acquire some details of our SMTP to use our client with.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送电子邮件，我们需要一个可以连接的功能正常的SMTP服务器。在后面的教程中，我们将创建自己的SMTP服务器，但现在我们需要获取一些我们的SMTP的细节来使用我们的客户端。
- en: If we have an email address, we have access to an SMTP server. We can find out
    the SMTP host address from our provider.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个电子邮件地址，我们就可以访问SMTP服务器。我们可以从我们的提供商那里找到SMTP主机地址。
- en: If required we can obtain access to an SMTP server by signing up for a Gmail
    account (at [mail.google.com)](http://mail.google.com)). Once we have an account,
    we can use `smtp.gmail.com` as the host, with our Gmail address as the username.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以通过注册Gmail帐户（在[mail.google.com)](http://mail.google.com)）来获得访问SMTP服务器的权限。一旦我们有了帐户，我们就可以使用`smtp.gmail.com`作为主机，使用我们的Gmail地址作为用户名。
- en: We'll create a new folder with a new file called `mailout.js` to hold our code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的文件夹，其中包含一个名为`mailout.js`的新文件来保存我们的代码。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There are three main elements to using `nodemailer`. They are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nodemailer`有三个主要元素。它们如下：
- en: Setting up the SMTP transport
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置SMTP传输
- en: Putting together the message object (which includes the transport)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组装消息对象（包括传输）
- en: Passing the object to the `sendMail` method.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象传递给`sendMail`方法。
- en: 'Let''s add the `nodemailer` module and create the transport as shown in the
    following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`nodemailer`模块，并按照以下代码创建传输：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will need to fill in our own SMTP settings for the `user` and `pass` values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要填写我们自己的SMTP设置，包括`user`和`pass`值。
- en: We've used the `secureConnection` setting and set the port to `465`, so we can
    use Gmail's SSL/TLS-secured SMTP server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`secureConnection`设置，并将端口设置为`465`，因此我们可以使用Gmail的SSL/TLS安全的SMTP服务器。
- en: 'Now we incorporate our configured transport into an object which we''ll call
    `msg` as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将我们配置的传输合并到一个名为`msg`的对象中，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice we haven't set a `to` property on the object. We're going to mail out
    to multiple addresses, so `to` will be set dynamically. For testing purposes,
    we'll create an array of `mailinator` email addresses. **Mailinator** ([http://www.mailinator.com](http://www.mailinator.com))
    is a free service that allows us to quickly create temporary email addresses simply
    by sending an email to an invented address.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还没有在对象上设置`to`属性。我们将要发送邮件到多个地址，所以`to`将动态设置。为了测试目的，我们将创建一个`mailinator`电子邮件地址的数组。**Mailinator**
    ([http://www.mailinator.com](http://www.mailinator.com))是一个免费服务，允许我们通过向虚构的地址发送电子邮件来快速创建临时电子邮件地址。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we simply loop through and send our newsletter to each address as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需循环发送我们的通讯给每个地址，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we point our browser at [http://mailtest1.mailinator.com](http://mailtest1.mailinator.com)
    (or `mailtest2, mailtest3`, and so on), we should see our message in Mailinator's
    temporary inbox.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将浏览器指向[http://mailtest1.mailinator.com](http://mailtest1.mailinator.com)（或`mailtest2,
    mailtest3`等），我们应该在Mailinator的临时收件箱中看到我们的消息。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: With Nodemailer's `createTransport` method, we can quickly configure our app
    with the required SMTP settings, later including these settings in the `msg` object
    as used by the `sendMail` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nodemailer的`createTransport`方法，我们可以快速配置我们的应用程序所需的SMTP设置，然后将这些设置包含在`sendMail`方法使用的`msg`对象中。
- en: We don't set an initial `to` property because it's modified through each iteration
    of `maillist.forEach` before being passed into the `sendMail` method.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有设置初始的`to`属性，因为它在每次`maillist.forEach`迭代中被修改，然后传递到`sendMail`方法中。
- en: '`sendMail` is asynchronous, as most methods with callbacks are (`forEach being`
    an exception). After each `sendMail` is called, `forEach` moves on and calls the
    next `sendMail` without waiting for the `sendMail` invocation to complete. This
    means that the `forEach` loop will finish before all the `sendMail` calls are
    finished. So in order to know when all the mail has been sent we use a counter
    (`i`).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendMail`是异步的，就像大多数带有回调的方法一样（`forEach`是一个例外）。每次调用`sendMail`后，`forEach`都会继续调用下一个`sendMail`，而不会等待`sendMail`调用完成。这意味着`forEach`循环将在所有`sendMail`调用完成之前结束。因此，为了知道所有邮件何时发送完毕，我们使用一个计数器（`i`）。'
- en: Each time an email is sent we increase our `i` variable by `1`. Once `i` is
    equivalent to the size of our `maillist` array, all emails have been dispatched
    so we call `transport.close`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每次发送一封邮件，我们都会将我们的`i`变量增加`1`。一旦`i`等于我们的`maillist`数组的大小，所有邮件都已发送，所以我们调用`transport.close`。
- en: Nodemailer opens multiple connections (a connection pool) to the SMTP server
    and reuses those connections for all the emails being sent. This ensures fast
    and efficient emailing, removing the overhead of opening and closing connections
    for each email sent. `transport.close` shuts down the connection pool and thus
    allows our app to finish execution.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Nodemailer打开多个连接（连接池）到SMTP服务器，并重用这些连接发送所有的邮件。这确保了快速和高效的发送邮件，消除了为每封邮件打开和关闭连接的开销。`transport.close`关闭连接池，从而允许我们的应用程序完成执行。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Nodemailer is a well-featured, highly-configurable mailing module as we'll see.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Nodemailer是一个功能齐全、高度可配置的邮件模块，我们将会看到。
- en: Using sendmail as an alternative transport
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用sendmail作为替代传输
- en: 'Many hosting providers have a `sendmail` service that connects to a default
    SMTP server, the details of which we need not know. Nodemailer will interface
    with `sendmail` if we simply alter our `transport` object to:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 许多托管提供商都有一个`sendmail`服务，连接到默认的SMTP服务器，我们不需要知道其详细信息。如果我们简单地修改我们的`transport`对象为`sendmail`，Nodemailer将与`sendmail`进行接口。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If `sendmail` isn''t in our host server''s environment `PATH` variable (to
    find out simply type `sendmail` from an SSH prompt), we can instead specify where
    `sendmail` is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`sendmail`不在我们主机服务器的环境`PATH`变量中（要找出来，只需在SSH提示符中键入`sendmail`），我们可以指定`sendmail`的位置如下：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: HTML emails
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML邮件
- en: 'Emails can contain HTML and gracefully degrade to plain text for basic user
    agents. To send an HTML email, we simply add the `html` property to our `msg`
    object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件可以包含HTML，并在基本用户代理中优雅地降级为纯文本。要发送HTML电子邮件，我们只需将`html`属性添加到我们的`msg`对象中：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The plain text should be included along with HTML, allowing a fallback for email
    clients with no HTML support.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 纯文本应该与HTML一起包含，为不支持HTML的电子邮件客户端提供备用。
- en: 'If we don''t want to write the text portion separately, we can have Nodemailer
    extract the text from the HTML for us, using the `generateTextFromHtml` property
    as shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想单独编写文本部分，我们可以让Nodemailer从HTML中提取文本，使用`generateTextFromHtml`属性，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sending attachments
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送附件
- en: What if we wanted to tell a really bad joke, using email attachments?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过电子邮件附件讲一个非常糟糕的笑话，该怎么办？
- en: We'll dynamically create a text file and load an image file from disk, both
    of which we'll attach to an email.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将动态创建一个文本文件，并从磁盘加载一个图像文件，然后将它们附加到一封电子邮件中。
- en: For the image, we'll be using `deer.jpg` (which can be found in the supporting
    code files). This should go in the same folder as our mail out file (let's call
    it `mailout_attachments.js)`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图片，我们将使用`deer.jpg`（可以在支持代码文件中找到）。这应该放在与我们的邮件文件相同的文件夹中（让我们称之为`mailout_attachments.js`）。
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course this is a proof of concept for attachments, and isn't the best use
    of email. Attachments are provided as an array of objects within the `msg` object.
    Each attachment object must have a `fileName` property, which is the filename
    given to the attachment in the email. This doesn't have to match the name of the
    actual file loaded from disk.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个附件的概念验证，并不是电子邮件的最佳用法。附件作为`msg`对象中的对象数组提供。每个附件对象必须有一个`fileName`属性，这是在电子邮件中附件的文件名。这不必与从磁盘加载的实际文件的名称匹配。
- en: The file contents can be written directly via the `contents` property, using
    a string or a `Buffer` object, or we can use `filePath` to stream a file from
    disk (we can also pass a stream directly to a `sourceStream` property).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容可以直接通过`contents`属性写入，使用字符串或`Buffer`对象，或者我们可以使用`filePath`从磁盘流式传输文件（我们也可以直接将流传递给`sourceStream`属性）。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Sending SMS* discussed in this chapter'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的*发送短信'
- en: '*Creating an SMTP server* discussed in this chapter'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的*创建SMTP服务器'
- en: Sending SMS
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送短信
- en: Being able to send SMS text messages to our users is another way for us to connect
    with them
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 能够向用户发送短信文本消息是我们与他们联系的另一种方式
- en: It is possible to connect our computer to a GSM modem, interact with specialized
    libraries (such as Asterisk, `asterisk.org`, combined with ngSMS, `ozekisms.com)`,
    and interface with the libraries and the telephony equipment to send SMS messages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将计算机连接到GSM调制解调器，与专门的库进行交互（如Asterisk，`asterisk.org`，结合ngSMS，`ozekisms.com`），并与库和电话设备进行接口，发送短信。
- en: There are easier ways though. Services like Twilio provide gateway SMS services,
    where we contact them via an HTTP REST API and they handle the SMS sending for
    us.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然还有更简单的方法。像Twilio这样的服务提供网关短信服务，我们可以通过HTTP REST API与它们联系，它们会为我们处理短信发送。
- en: In this recipe, we'll convert our newsletter mail out app into a blanket SMS
    service using the `twilio` module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用`twilio`模块将我们的通讯通讯应用程序转换为一个通用的短信服务。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This requires a Twilio account ([https://www.twilio.com/try-twilio](https://www.twilio.com/try-twilio)).
    Once signed up and logged in we should take note of our Account SID, Auth Token,
    and Sandbox phone number (we may have to select our country of residence to obtain
    the appropriate Sandbox number).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个Twilio账户（[https://www.twilio.com/try-twilio](https://www.twilio.com/try-twilio)）。一旦注册并登录，我们应该注意我们的账户SID、Auth
    Token和沙箱电话号码（我们可能需要选择我们的居住国家以获得适当的沙箱号码）。
- en: We'll need some phone numbers to send texts to for testing purposes. In the
    sandbox mode (which is what we'll be using for development), any number we want
    to text or call must go through a verification process. We do this by selecting
    the **Numbers** link from the **Account** section, and clicking **Verify a Number**.
    Twilio will then call that number and expect a PIN provided on screen to be entered
    for confirmation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些电话号码用于测试发送短信。在沙盒模式下（这是我们在开发中将要使用的模式），我们想要发送短信或打电话的任何号码都必须经过验证过程。我们通过从**账户**部分选择**Numbers**链接，然后点击**Verify
    a Number**来完成这个过程。然后Twilio将拨打该号码，并期望在屏幕上输入提供的PIN以进行确认。
- en: 'Let''s create a new file, `smsout.js`, and install the `twilio` helper module:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新文件，`smsout.js`，并安装`twilio`助手模块：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we require `twilio` and put together some configuration settings:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要`twilio`并组合一些配置设置：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Twilio phone number**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Twilio电话号码**'
- en: Before we can start interacting with the Twilio service, we have to specify
    a registered Twilio phone number in order to create our `phone`. For development
    purposes, we can simply use the sandbox number, which can be found from the Twilio
    dashboard ([http://www.twilio.com/user/account](http://www.twilio.com/user/account)).
    In a production scenario, we would need to upgrade our account and purchase a
    unique phone number from Twilio.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始与Twilio服务进行交互之前，我们必须指定一个注册的Twilio电话号码，以创建我们的`phone`。在开发过程中，我们可以简单地使用沙盒号码，可以从Twilio仪表板中找到（[http://www.twilio.com/user/account](http://www.twilio.com/user/account)）。在生产环境中，我们需要升级我们的账户并从Twilio购买一个唯一的电话号码。
- en: 'With our `settings` present and correct we''re ready to create a Twilio client,
    using it to initialize a virtual phone:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的`settings`正确，我们准备创建一个Twilio客户端，用它来初始化一个虚拟电话：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We created `restClient` here also, which offers API calls reflective of Twilio's
    raw REST API. We'll be using `restClient` to check the status of our SMS message
    in order to determine if the message has been sent from Twilio to the target phone.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里也创建了`restClient`，它提供了反映Twilio原始REST API的API调用。我们将使用`restClient`来检查我们的短信消息的状态，以确定消息是否已从Twilio发送到目标电话。
- en: 'Now we define a list of numbers to text (we''ll have to provide our own) to
    text, much like our `maillist` array in the previous recipe:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义了一个要发送短信的号码列表（我们必须提供自己的号码），就像我们在上一个示例中的`maillist`数组一样：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unless we have upgraded our account, any number on `smslist` must be pre-verified
    with Twilio. This can be done through the Twilio Numbers account section ([https://www.twilio.com/user/account/phone-numbers/](https://www.twilio.com/user/account/phone-numbers/)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们升级了我们的账户，否则`smslist`上的任何号码都必须经过Twilio的预验证。这可以通过Twilio Numbers账户部分完成（[https://www.twilio.com/user/account/phone-numbers/](https://www.twilio.com/user/account/phone-numbers/)）。
- en: 'Then we simply loop through `smslist` and use `phone` to send an SMS message
    to each recipient as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简单地循环遍历`smslist`并使用`phone`向每个接收者发送短信消息，如下所示：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This should work fine, except that the process won''t exit (because `twilio`
    initializes a server to receive Twilio callbacks) and we don''t know when an SMS
    is actually sent from Twilio to the recipient. One way to check is to make another
    request to the Twilio REST API asking for a status update. The `twilio RestClient`
    makes this easy for us as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该可以正常工作，除了这个过程不会退出（因为`twilio`初始化了一个服务器来接收Twilio的回调），我们不知道Twilio何时向接收者发送短信。一种检查的方法是向Twilio
    REST API发出另一个请求，请求状态更新。`twilio RestClient`使我们可以轻松实现这一点，具体如下：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If our SMS hasn''t been sent on the first call, we need to wait and check it
    again. Let''s make some final improvements as shown in the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的短信在第一次调用时没有发送，我们需要等待并再次检查。让我们进行一些最终的改进，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now the console will output each time a number has been confirmed as sent. When
    all numbers have been messaged the process exits.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在控制台将在每次确认发送号码后输出。当所有号码都已发送消息时，该过程退出。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `twilio.RestClient` gives us access to low-level interactions with the Twitter
    API via the `twilio` helper. This simply wraps generic API calls with our preset
    authorization settings for us, making the HTTP requests on our behalf.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`twilio.RestClient`通过`twilio`助手为我们提供了对Twitter API的低级交互访问。这简单地为我们预设的授权设置包装了通用的API调用，代表我们进行HTTP请求。'
- en: '`twilio.Client` is a higher-level API presented by the `twilio` helper and
    handles two-way interactions between Twilio and the client. The third parameter
    that must be provided to initialize a new client is the `hostname` parameter.
    The `twilio` module provides this to Twilio as part of a callback URL requested
    from the Twilio servers to confirm that an SMS message has been sent.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`twilio.Client`是由`twilio`助手提供的更高级的API，处理Twilio和客户端之间的双向交互。初始化新客户端时必须提供的第三个参数是`hostname`参数。`twilio`模块提供了这个参数给Twilio，作为从Twilio服务器请求的回调URL的一部分，以确认短信消息是否已发送。'
- en: We ignored this behavior and supplied a dummy hostname, implementing our own
    method of confirming an SMS was sent. Our method doesn't require us to have a
    live server address accessible from the Web (see the *There's more..*. section
    for a live server implementation that uses the `hostname` property as intended).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略了这种行为，并提供了一个虚拟的主机名，实现了我们自己的确认短信已发送的方法。我们的方法不需要我们拥有一个可以从Web访问的实时服务器地址（请参阅*还有更多..*部分，了解使用`hostname`属性作为预期的回调URL的实时服务器实现）。
- en: We use the `sendSms` method of our created `phone` object to make an HTTP request
    of the Twilio API via the `twilio` module, passing in the desired recipient, message,
    and a callback function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们创建的`phone`对象的`sendSms`方法通过`twilio`模块向Twilio API发出HTTP请求，传入所需的接收者、消息和回调函数。
- en: Once the request is made, our callback is triggered with the initial `sms` object.
    We use this to determine the ID that Twilio has given our `sendSMS` request with
    `smsInstance.sid` (which is `sms.smsDetails.sid)`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求发出，我们的回调就会触发初始的`sms`对象。我们使用这个对象来确定Twilio给我们的`sendSMS`请求分配的ID，即`smsInstance.sid`（即`sms.smsDetails.sid`）。
- en: '`smsInstance.sid` is passed to `restClient.getSmsInstance` which provides us
    with an updated instance of our `smsIntance` object, we call it `presentSms`.
    This call is made from within a custom, self-calling function expression called
    `checkStatus`, which has our initial `sms.smsDetails` object passed to it.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`smsInstance.sid`被传递给`restClient.getSmsInstance`，它为我们提供了我们的`smsIntance`对象的更新实例，我们称之为`presentSms`。这个调用是从一个名为`checkStatus`的自定义自调用函数表达式中进行的，它将我们的初始`sms.smsDetails`对象传递给它。'
- en: We are looking to see if Twilio has sent our text message yet. If it has, `presentSms.status`
    will be `sent`. If it's anything other than this, we want to wait a short while
    and then ask Twilio for another update on the status of our queued SMS message.
    That is, unless the returned status is a `404`, in which case there has been an
    issue and we need to notify the user, but continue on to process the next SMS
    message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望看到Twilio是否已经发送了我们的短信。如果是，`presentSms.status`将是`sent`。如果不是，我们希望等一会儿，然后要求Twilio再次更新我们排队的短信消息的状态。也就是说，除非返回的状态是`404`，在这种情况下出现了问题，我们需要通知用户，但继续处理下一个短信消息。
- en: As in the *Sending email* recipe, we keep a count of how many messages are sent.
    Once they total the amount of recipients we exit the process, since `smsout.js`
    is a command-line app (in a server scenario we wouldn't need or want to do this).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就像*发送电子邮件*的示例一样，我们会记录发送的消息数量。一旦它们总数达到收件人的数量，我们就会退出进程，因为`smsout.js`是一个命令行应用程序（在服务器场景中，我们不需要也不想这样做）。
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Twilio module's versatility stretches beyond sending SMS messages. It can
    also transparently handle Twilio callbacks for us through emitting events.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Twilio模块的多功能性不仅限于发送短信。它还可以通过发出事件透明地处理Twilio的回调。
- en: Using the processed event listener
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用processed事件监听器
- en: With a live public server, we would be better off providing our hostname to
    `twilio.Client` so it can manage callback URL requests.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时公共服务器上，最好向`twilio.Client`提供我们的主机名，以便它可以管理回调URL请求。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this code to work, it must be hosted on a live public server. For more information
    on hosting Node on live servers, see[Chapter 10](ch10.html "Chapter 10. Taking
    It Live"),Taking It Live
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这段代码工作，它必须托管在一个实时公共服务器上。有关在实时服务器上托管Node的更多信息，请参阅[第10章](ch10.html "第10章。携手共进")，携手共进
- en: 'We would remove `restClient` and change our `settings` object to the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将删除`restClient`并将我们的`settings`对象更改为以下内容：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then our SMS sending code is simply:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的短信发送代码就是：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `twilio` client provides a `statusCallback` URL to Twilio. Twilio will request
    this URL (something like `http://nodecookbook.com:31337/autoprovision/0)` to confirm
    and the `twilio` helper module will emit a `processed` event to notify us of Twilio's
    confirmation. We listen out for this event, checking the given `SmsStatus` via
    that `req` object to confirm success.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`twilio`客户端提供了一个`statusCallback` URL给Twilio。Twilio将请求这个URL（类似`http://nodecookbook.com:31337/autoprovision/0`）来确认，`twilio`辅助模块将发出一个`processed`事件来通知我们Twilio的确认。我们监听这个事件，通过`req`对象检查给定的`SmsStatus`来确认成功。'
- en: Making an automated phone call
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行自动电话呼叫
- en: For this next example to work, we would need to have a valid hostname and be
    running our app on a web-exposed server as in the previous section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使下一个示例工作，我们需要一个有效的主机名，并且在一个公开的服务器上运行我们的应用程序，就像在前一节中一样。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this code to work, it must be hosted on a live public server. For more information
    on hosting Node on live servers, see[Chapter 10](ch10.html "Chapter 10. Taking
    It Live"),Taking It Live
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这段代码工作，它必须托管在一个实时公共服务器上。有关在实时服务器上托管Node的更多信息，请参阅[第10章](ch10.html "第10章。携手共进")，携手共进
- en: To make a call we start with the usual setup.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行呼叫，我们从通常的设置开始。
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we use the `makeCall` method as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`makeCall`方法如下：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If our account is not upgraded, whatever number we supply to `makeCall` must
    be verified through the Twilio `Numbers` area in the account section ([https://www.twilio.com/user/account/phone-numbers/](https://www.twilio.com/user/account/phone-numbers/)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的帐户没有升级，我们提供给`makeCall`的任何号码都必须通过Twilio帐户部分的`Numbers`区域进行验证（[https://www.twilio.com/user/account/phone-numbers/](https://www.twilio.com/user/account/phone-numbers/)）。
- en: '`makeCall` invokes a callback with a `call` parameter. `call` is an event emitter,
    with `answered` and `ended` events. The `twilio` module transparently converts
    Twilio confirmation callbacks into these events.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeCall`调用一个带有`call`参数的回调。`call`是一个事件发射器，具有`answered`和`ended`事件。`twilio`模块将Twilio的确认回调透明地转换为这些事件。'
- en: The `answered` event feeds the `req` and `res` objects to its callback. `req`
    holds information about the outgoing call, and `res` has methods which allow us
    to interact with the call, namely `res.append` and `res.send`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`answered`事件将`req`和`res`对象传递给它的回调函数。`req`包含有关传出呼叫的信息，而`res`具有允许我们与呼叫交互的方法，即`res.append`和`res.send`。'
- en: To send a computerized text-to-speech message to the recipient, we instantiate
    a new instance of the `twilio` module's `Twiml` class and use the `Say` method
    (watch out for the unusual convention of giving a capital S to a non-class, using
    a small s will throw an error).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要向接收者发送计算机化的文本到语音消息，我们实例化`twilio`模块的`Twiml`类的新实例，并使用`Say`方法（注意给非类的大写S的不寻常约定，使用小写s会引发错误）。
- en: '`TwiML` is Twilio''s markup language. It''s simply API-specific XML. The `twilio`
    module provides the `Twiml` class to handle the ugly business of forming the necessary
    XML. We use it to create two `Say` verbs. Behind the `twilio` scenes, the two
    `append` calls followed by the send invocation would create and issue the following
    `TwiML` to `twilio:`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwiML`是Twilio的标记语言。它只是特定于API的XML。`twilio`模块提供了`Twiml`类来处理形成必要XML的繁琐工作。我们用它来创建两个`Say`动词。在`twilio`的背后，两个`append`调用后跟着的发送调用将创建并发出以下`TwiML`到`twilio`：'
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `TwiML` code is received by `twilio` and converted into speech. After the
    woman's voice says `Come alone` the phone call ends, triggering the `ended` event
    in our app (which the `twilio` module emits as a result of receiving an HTTP request
    from `twilio` signifying the call has ended).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwiML`代码由`twilio`接收并转换为语音。在女性的声音说“独自来”之后，电话结束，触发我们应用程序中的`ended`事件（`twilio`模块作为接收来自`twilio`的HTTP请求的结果发出的，表示通话已经结束）。'
- en: We listen to the `ended` event determining when `twilio` (or the recipient)
    have hung up. Once `ended` has triggered we exit the process, outputting the `req`
    object as an overview of the call.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们监听`ended`事件，确定`twilio`（或接收方）何时挂断电话。一旦触发`ended`，我们就退出进程，并输出`req`对象作为通话的概述。
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Sending email discussed in this chapter
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论的发送电子邮件
- en: Communicating with TCP discussed in this chapter
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论的TCP通信
- en: '[Chapter 10](ch10.html "Chapter 10. Taking It Live"),Taking It Live'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html "第10章. 实时运行"),实时运行'
- en: Communicating with TCP
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TCP通信
- en: The Transmission Control Protocol (TCP) provides the backbone of HTTP communications.
    With TCP, we can open up interfaces between processes running on separate server
    hosts and remotely communicate between processes with less overhead and fewer
    complexities than HTTP.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 传输控制协议（TCP）提供了HTTP通信的基础。通过TCP，我们可以在运行在不同服务器主机上的进程之间打开接口，并且与HTTP相比，可以更少的开销和更少的复杂性远程通信。
- en: Node provides us with the `net` module for creating TCP interfaces. When it
    comes to scaling, reliability, load balancing, synchronization, or real-time social
    communications, TCP is a fundamental element.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Node为我们提供了`net`模块，用于创建TCP接口。在扩展、可靠性、负载平衡、同步或实时社交通信方面，TCP是一个基本要素。
- en: In this recipe, we're going to demonstrate the sort of foundation needed to
    communicate between processes over a network by setting up a TCP connection that
    allows us to remotely monitor and filter HTTP headers of website hits in real
    time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将演示建立一个TCP连接所需的基础，以便通过网络远程监视和过滤网站访问的HTTP标头。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll need two new files: `server.js` and `monitor.js`. Let''s place them
    in a new folder.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个新文件：`server.js`和`monitor.js`。让我们把它们放在一个新的文件夹里。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'First, let''s create our first TCP server in `server.js` as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`server.js`中创建我们的第一个TCP服务器，如下所示：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use the `nc` (netcat) command-line program to test this out in another
    terminal as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`nc`（netcat）命令行程序在另一个终端中进行测试，如下所示：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we're using Windows, we can download netcat from [http://www.joncraton.org/blog/netcat-for-windows](http://www.joncraton.org/blog/netcat-for-windows).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Windows，我们可以从[http://www.joncraton.org/blog/netcat-for-windows](http://www.joncraton.org/blog/netcat-for-windows)下载netcat。
- en: The response should be `Hello, this is TCP\n` and the `server.js` console should
    output `testing 1 2 3`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应该是`Hello, this is TCP\n`，`server.js`控制台应该输出`testing 1 2 3`。
- en: Remember, HTTP sits on top of TCP, so we can make an HTTP request of a TCP server.
    If we navigate our browser to `http://localhost:8080` and watch the console, we'll
    see all the headers from our browser's HTTP request appear in the console, with
    the browser displaying **Hello this is TCP**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，HTTP建立在TCP之上，因此我们可以向TCP服务器发出HTTP请求。如果我们将浏览器导航到`http://localhost:8080`并观察控制台，我们将看到浏览器的HTTP请求中的所有标头显示在控制台中，并且浏览器显示**Hello
    this is TCP**。
- en: We've given the TCP server the name of `fauxHttp`. We're going to use it to
    record HTTP headers from browser clients (with some adjustments we could easily
    adapt our code to work with an actual HTTP server).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给TCP服务器命名为`fauxHttp`。我们将使用它来记录来自浏览器客户端的HTTP标头（通过一些调整，我们可以很容易地调整我们的代码以与实际的HTTP服务器一起工作）。
- en: 'Still inside `server.js`, we''re going to create another TCP server that opens
    a second port for `monitor.js` to communicate with our server. Before we do though,
    we''ll make a new `EventEmitter` object as a bridge between our two `server.js`
    TCP servers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`server.js`中，我们将创建另一个TCP服务器，为`monitor.js`打开第二个端口，以便与我们的服务器通信。不过，在此之前，我们将创建一个新的`EventEmitter`对象，作为我们的两个`server.js`
    TCP服务器之间的桥梁：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've replaced `console.log` in the `data` listener of `socket` with new `stats
    EventEmitter` which will `emit` a custom `stats` event upon receiving TCP data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`socket`的`data`监听器中用新的`stats EventEmitter`替换了`console.log`，它将在接收到TCP数据时`emit`一个自定义的`stats`事件。
- en: 'We also included a `filter` variable to be used in our second TCP interface
    in `server.js` as shown in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`server.js`的第二个TCP接口中包含了一个`filter`变量，如下所示：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our `monitorInterface` server listens to our `stats` emitter to determine when
    the first TCP server has received information, sending this information (after
    it has been filtered) to a client connected on port `8081.`
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`monitorInterface`服务器监听我们的`stats`发射器，以确定第一个TCP服务器何时接收到信息，并将此信息（在经过过滤后）发送到端口`8081`上连接的客户端。
- en: 'All we have to do now is create this client. Inside `monitor.js` we write the
    following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要创建这个客户端。在`monitor.js`中，我们编写以下代码：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we open two terminals, running `server.js` in one and `monitor.js` in the
    other, and navigate to `http://localhost:8080` in our browser `server.js` transmits
    the `User-Agent` string from the HTTP headers of each request to `monitor.js`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在两个终端中打开`server.js`和`monitor.js`，并在浏览器中导航到`http://localhost:8080`时，`server.js`会将每个请求的HTTP标头中的`User-Agent`字符串传输到`monitor.js`。
- en: We can apply a different filter, such as `Accept`. By simply typing it into
    a running `monitor.js` process, any non-matching filters will default to returning
    the preliminary request line (`GET /, POST /route/here`, and so on).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用不同的过滤器，比如`Accept`。只需将其输入到运行中的`monitor.js`进程中，任何不匹配的过滤器都将默认返回初步请求行（`GET
    /, POST /route/here`等）。
- en: 'To run across separate systems, we simply place `server.js` on a remote host
    and then update the second parameter of `net.connect` from `localhost` to the
    name of our server, for example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不同的系统上运行，我们只需将`server.js`放在远程主机上，然后将`net.connect`的第二个参数从`localhost`更新为我们服务器的名称，例如：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The HTTP layer works on top of TCP. So when our browser makes a request, the
    TCP server receives all the HTTP header information. `http.createServer` would
    handle these headers and other HTTP protocol interactions. However, `net.createServer`
    simply receives TCP data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP层建立在TCP之上。因此，当我们的浏览器发出请求时，TCP服务器接收所有HTTP头信息。`http.createServer`将处理这些头信息和其他HTTP协议交互。但是，`net.createServer`只是接收TCP数据。
- en: '`socket.write` and `socket.end` are similar to `response.write` and `response.end`
    within an HTTP server callback function, but without reference to the requirements
    of the HTTP protocol. Nevertheless, the similarities are enough for our browser
    to be able to receive data from `socket.write`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.write`和`socket.end`类似于HTTP服务器回调函数中的`response.write`和`response.end`，但没有参考HTTP协议的要求。尽管如此，这些相似之处足以使我们的浏览器能够从`socket.write`接收数据。'
- en: All our `fauxHttp` TCP server does is receive a request via port `8080`, outputs
    `Hello, this is TCP\n` to the client, and reads any data from the client directly
    through to our `stats` event emitter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`fauxHttp` TCP服务器所做的就是通过端口`8080`接收请求，向客户端输出`Hello, this is TCP\n`，并直接通过我们的`stats`事件发射器读取客户端的任何数据。
- en: Our `monitorInterface` TCP server listens on a separate port (`8081`), essentially
    giving us a sort of (completely insecure) admin interface. In the `monitorInterface`
    callback, we listen to the `stats` emitter which is triggered whenever a browser
    (or any TCP client) hits `localhost:8080`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`monitorInterface` TCP服务器监听一个单独的端口（`8081`），基本上给了我们一种（完全不安全的）管理员界面。在`monitorInterface`回调中，我们监听`stats`发射器，每当浏览器（或任何TCP客户端）访问`localhost:8080`时触发。
- en: Inside the listener callback of `stats`, we retrieve the desired `header`, using
    the `filter` variable to search the HTTP headers with the `match` objects `index`
    and `input` properties, enabling us to extract the specified header. If there
    are no matches, we `match` an empty string, thereby returning a `match` object
    containing an `index` of `0` resulting in the extraction of the first line of
    the HTTP headers (the requested path and method).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`stats`的监听器回调中，我们检索所需的`header`，使用`filter`变量搜索具有`match`对象`index`和`input`属性的HTTP头，使我们能够提取指定的头。如果没有匹配项，我们将匹配一个空字符串，从而返回一个包含`index`为`0`的`match`对象，从而提取HTTP头的第一行（请求路径和方法）。
- en: The last part of the `monitorInterface` TCP server callback listens on the `socket`
    for a `data` event and sets the `filter` variable to whatever the client sends.
    This enables the `monitor.js` client to alter the `filter` by piping the `process.stdin`
    stream directly into the TCP `client`. Meaning we can type directly into `monitor.js'`
    running process and the `data` event from the `socket` of `monitorInterface` will
    trigger in `server.js` receiving whatever is typed in `monitor.js'` STDIN.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`monitorInterface` TCP服务器回调的最后一部分监听`socket`的`data`事件，并将`filter`变量设置为客户端发送的内容。这使得`monitor.js`客户端可以通过将`process.stdin`流直接传输到TCP`client`来改变`filter`。这意味着我们可以直接在`monitor.js`的运行过程中输入，并且`monitorInterface`的`socket`的`data`事件将在`server.js`中触发，接收`monitor.js`的STDIN中键入的任何内容。'
- en: '`monitor.js` avails of this functionality by piping the `process.stdin` stream
    directly into the TCP `client`. This means we can type directly into the running
    process and the `data` event from `socket` of `monitorInterface` in `server.js`,
    and this will trigger passing anything typed from STDIN of `monitor.js`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`monitor.js`通过将`process.stdin`流直接传输到TCP`client`来利用这个功能。这意味着我们可以直接在运行过程中输入，并且`monitor.js`的`socket`中的`data`事件，这将触发从`monitor.js`的STDIN中键入的任何内容。'
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's look at some ways we can further harness the power of TCP.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些进一步利用TCP强大功能的方法。
- en: Port forwarding
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口转发
- en: There can be various reasons to forward a port. As an example, if we wish to
    SSH into our server over a mobile connection, we may find that port `22` has been
    blocked. The same can apply with corporate firewalls (this could be because a
    blanket block is applied to all privileged ports except the most common such as
    `80` and `443)`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 转发端口有各种原因。例如，如果我们希望通过移动连接SSH到我们的服务器，可能会发现端口`22`已被阻止。公司防火墙也可能会有同样的情况（这可能是因为所有特权端口都被屏蔽，除了最常见的端口，如`80`和`443）。
- en: We can use the `net` module to forward TCP traffic from one port to another,
    essentially circumventing a firewall. So naturally this should be used only for
    legitimate cases and with any necessary permission.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`net`模块将TCP流量从一个端口转发到另一个端口，从本质上绕过防火墙。因此，这应该只用于合法情况，并且需要任何必要的许可。
- en: 'First, we''ll require `net` and define ports to forward from and to:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将需要`net`并定义要转发的端口：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So we can either define ports via command line or default to forwarding the
    arbitrary port `9000` to the SSH port.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过命令行定义端口，或者默认将任意端口`9000`转发到SSH端口。
- en: 'Now we create a TCP server that receives connections via `fromPort`, creating
    a TCP client connection to `toPort`, passing all data between these connections
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个TCP服务器，通过`fromPort`接收连接，创建一个到`toPort`的TCP客户端连接，并在这些连接之间传递所有数据，如下所示：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use the `data` events to receive and push data between `client` (our bridge
    connection) and `socket` (the incoming connection).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`data`事件在`client`（我们的桥接连接）和`socket`（传入连接）之间接收和推送数据。
- en: 'If we now run our script on the remote server (with no arguments), we can log
    in to a secure shell from our local computer using port `9000` like so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在远程服务器上运行我们的脚本（不带参数），我们可以使用端口`9000`从本地计算机登录到安全shell。
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using pcap to watch TCP traffic
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用pcap来监视TCP流量
- en: With the third-party `pcap` module, we can also observe TCP packets as they
    travel in and out of our system. This can be useful for analysis and optimization
    of expected behaviors, performance, and integrity.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三方的`pcap`模块，我们还可以观察TCP数据包在系统内外的传输。这对于分析和优化预期行为、性能和完整性非常有用。
- en: 'On the command line:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For our code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的代码：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If `pcap` fails to choose the correct device, there will be no output (or maybe
    unrelated output). In this case, we need to know which device to sniff. If we
    are connected wirelessly, it may well be `wlan0` or `wlan1and` if we are wired,
    in it could be `eth0/eth1`. We can find out by typing `ifconfig` (Linux, Mac OS
    X) or `ipconfig` (Windows) on the command line to see which device has an `inet
    address` matching the network part of our router's IP address (for example, `192.168.1.xxx)`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pcap`无法选择正确的设备，将没有输出（或者可能是无关的输出）。在这种情况下，我们需要知道要嗅探哪个设备。如果我们是无线连接，可能是`wlan0`或`wlan1`，如果我们是有线连接，可能是`eth0/eth1`。我们可以通过在命令行上输入`ifconfig`（Linux，Mac
    OS X）或`ipconfig`（Windows）来找出哪个设备具有与我们路由器IP地址的网络部分匹配的`inet地址`（例如`192.168.1.xxx`）。
- en: 'If we save this as `tcp_stats.js`, we can run it with the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此保存为`tcp_stats.js`，我们可以使用以下命令运行它：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `pcap` module interfaces with privileged ports and therefore must be run
    as root (for operating systems such as Linux and Mac OS x that enforce privileged
    ports).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`pcap`模块与特权端口进行接口，并且必须以root身份运行（对于强制执行特权端口的Linux和Mac OS X等操作系统）。'
- en: If we navigate to any website and then refresh the page, the `tcpTracker end`
    event of `pcap` is triggered in which we output the `session` object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到任何网站然后刷新页面，`pcap`的`tcpTracker end`事件会被触发，我们会输出`session`对象。
- en: To initialize the `tcpTracker`, we create a `pcap` session and attach a listener
    for the `packet` event where we pass each decoded `packet` into `tcpTracker`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化`tcpTracker`，我们创建一个`pcap`会话，并为`packet`事件附加一个监听器，将每个解码的`packet`传递给`tcpTracker`。
- en: Upon creating the `pcap` session we pass an empty string followed by `tcp` to
    the `createSession` method. The empty string causes `pcap` to automatically choose
    an interface (if this doesn't work we can specify the appropriate interface, for
    example, `eth0, wlan1` or `lo` if we want to analyze `localhost` TCP packets).
    The second parameter, `tcp`, instructs `pcap` to only listen for TCP packets.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`pcap`会话时，我们传递一个空字符串，然后是`tcp`到`createSession`方法。空字符串会导致`pcap`自动选择一个接口（如果这不起作用，我们可以指定适当的接口，例如`eth0，wlan1`或`lo`，如果我们想要分析`localhost`的TCP数据包）。第二个参数`tcp`指示`pcap`仅监听TCP数据包。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating an SMTP server* discussed in this chapter'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的创建SMTP服务器*'
- en: '*Implementing a virtual hosting paradigm* discussed in this chapter'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的虚拟主机范式的实现*'
- en: Creating an SMTP server
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SMTP服务器
- en: We don't have to rely on a third-party SMTP server, we can create our own!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必依赖第三方SMTP服务器，我们可以创建我们自己的！
- en: In this recipe, we'll create our own internal SMTP server (just like the first
    SMTP servers) using the third-party `simplesmtp` module which is an underlying
    library of the `nodemailer` module from the first recipe of this chapter, *Sending
    email*. For information on converting an internal SMTP server to an externally
    exposed MX record server, see the *There's more..*. section at the end of this
    recipe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用第三方的`simplesmtp`模块创建我们自己的内部SMTP服务器（就像第一个SMTP服务器一样），这是第一个配方中`nodemailer`模块的基础库。有关将内部SMTP服务器转换为外部公开的MX记录服务器的信息，请参阅本配方末尾的*还有更多..*部分。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s create a file and call it `server.js`, then make a new folder called
    `mailboxes`, containing three subfolders: `bob, bib`, and `susie`. We''ll also
    want to have our `mailout.js` file from the first recipe to hand.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个文件并将其命名为`server.js`，然后创建一个名为`mailboxes`的新文件夹，其中包含三个子文件夹：`bob，bib`和`susie`。我们还需要准备好第一个配方中的`mailout.js`文件。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we''ll set up some initial variables:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置一些初始变量：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we initialize the SMTP server with authentication enabled:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们启用带有身份验证的SMTP服务器：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we''ll react to some `simplesmtp` events to process incoming mail, beginning
    with the `startData` event:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对一些`simplesmtp`事件做出反应，以处理传入的邮件，从`startData`事件开始：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then the `data` and `dataReady` events will be as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`data`和`dataReady`事件将如下所示：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For terser code we chained these two events together with dot notation. Finally,
    we tell our SMTP server what port to listen on:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更简洁的代码，我们使用点符号将这两个事件链接在一起。最后，我们告诉我们的SMTP服务器要监听哪个端口：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In production, it would be expedient to specify the port as `25` (or in more
    advanced cases `465` or `587)`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，指定端口为`25`（或在更高级的情况下为`465`或`587`）会更加方便。
- en: Now let's test our server by converting our `mailout.js` file from the *Sending
    email* recipe.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过将*发送电子邮件*配方中的`mailout.js`文件转换来测试我们的服务器。
- en: 'First, we alter our `createTransport` invocation to reflect the values of our
    custom SMTP server:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们修改我们的`createTransport`调用以反映我们自定义SMTP服务器的值：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we modify the `maillist` array to reflect our mailboxes, as shown in
    the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们修改`maillist`数组以反映我们的邮箱，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Bob and Bib are sent together. We also added an address which doesn't have a
    mailbox ( `<[nobody@nodecookbook.com](mailto:nobody@nodecookbook.com)>` ) in order
    to test our catch all functionality.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Bob和Bib一起发送。我们还添加了一个没有邮箱的地址（`<[nobody@nodecookbook.com](mailto:nobody@nodecookbook.com)>`）以测试我们的捕获所有功能。
- en: 'Now, if we run `server.js` in one terminal and in another run `mailout.js`,
    output from `mailout.js` should be something like:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在一个终端中运行`server.js`，在另一个终端中运行`mailout.js`，`mailout.js`的输出应该是这样的：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we look in the `mailboxes/bob` directory, we'll see our email from `spamnot@ok.com`,
    the same for `susie` and `bib.`
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`mailboxes/bob`目录，我们会看到来自`spamnot@ok.com`的电子邮件，`susie`和`bib`也是一样。
- en: '`server.js` should have the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.js`应该有以下输出：'
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Therefore, upon analyzing the contents of `mailboxes/caught`, we'll see our
    email in there sent to Mr Nobody.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当分析`mailboxes/caught`的内容时，我们将看到我们发送给Mr Nobody的电子邮件。
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: SMTP is based upon a series of plain text communications between an SMTP client
    and server over a TCP connection. The `simplesmtp` module carries out these communications
    for us, yielding a higher-level API for developer interactions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP基于SMTP客户端和服务器之间的一系列纯文本通信，在TCP连接上进行。`simplesmtp`模块为我们执行这些通信，为开发人员交互提供了更高级的API。
- en: When we call `simplesmtp.createServer` with `requireAuthorization` set to `true`,
    our new server (simply called `smtp)` will emit an `authorizeUser` event and will
    not continue to process until we have invoked the fourth parameter, `cb` (the
    callback). `cb` takes two parameters. With the first we can specify a reason why
    access is denied via an `Error` object (we simply pass `null)`. The second is
    a Boolean saying whether the user is authorized or not (if not, and the error
    parameter is null a generic access denied error is sent to the mail client).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `simplesmtp.createServer` 时，将 `requireAuthorization` 设置为 `true`，我们的新服务器（简称
    `smtp`）将触发一个 `authorizeUser` 事件，并且在我们调用第四个参数 `cb`（回调）之前不会继续处理。`cb` 接受两个参数。第一个参数可以通过
    `Error` 对象指定拒绝访问的原因（我们只是传递 `null`）。第二个参数是一个布尔值，表示用户是否被授权（如果没有，并且错误参数为 null，则会向邮件客户端发送一个通用的拒绝访问错误）。
- en: We determine the second `cb` parameter by looping through our `users` array,
    finding out if the username and password are correct (in reality, we may wish
    to use a database for this part). If there is a match, our `auth` variable is
    set to `true` and passed to `cb`, otherwise it remains `false` and the client
    is rejected.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过循环遍历我们的 `users` 数组来确定第二个 `cb` 参数，找出用户名和密码是否正确（实际上，我们可能希望使用数据库来完成这部分）。如果匹配成功，我们的
    `auth` 变量将设置为 `true` 并传递给 `cb`，否则它保持为 `false`，客户端将被拒绝。
- en: If the client is authorized, `smtp` will emit several events for each envelope
    (an envelope is an email package containing all the recipients for that email,
    body text, email headers, attachments, and so on).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端被授权，`smtp` 将为每个信封（一个包含该电子邮件所有收件人、正文文本、电子邮件头部、附件等的电子邮件包裹）发出多个事件。
- en: In the `startData` event, we are provided with an `envelope` parameter where
    we use the `envelope.to` property to check whether our recipients have a mailbox.
    SMTP allows more than one recipient to be specified per email, so `envelope.to`
    is always an array, even if it contains only one recipient. Therefore, we use
    `forEach` to loop through `envelope.to` in order to check mailboxes for each recipient
    stipulated.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `startData` 事件中，我们会得到一个 `envelope` 参数，我们使用 `envelope.to` 属性来检查我们的收件人是否有邮箱。SMTP
    允许在一封电子邮件中指定多个收件人，因此 `envelope.to` 总是一个数组，即使它只包含一个收件人。因此，我们使用 `forEach` 循环遍历 `envelope.to`，以便为每个指定的收件人检查邮箱。
- en: We find out the intended recipient mailbox by splitting the address by the `@`
    character, loading it into our `rcpt` variable. We perform no verification on
    the domain portion of the address, although `simplesmtp` automatically verifies
    that the domain is genuine before emitting any of the events.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将地址按 `@` 字符拆分来找出预期的收件人邮箱，将其加载到我们的 `rcpt` 变量中。我们对地址的域部分不进行验证，尽管 `simplesmtp`
    在触发任何事件之前会自动验证域是否真实。
- en: '`rcpt` gets added to our `envelope.mailboxes` array, which we added to `envelope`
    before looping through `envelope.to`. We use `envelope.mailboxes` in the later
    `data` and `dataReady` events.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcpt` 被添加到我们的 `envelope.mailboxes` 数组中，在循环遍历 `envelope.to` 之前，我们将其添加到 `envelope`
    中。我们在后续的 `data` 和 `dataReady` 事件中使用 `envelope.mailboxes`。'
- en: Still inside the `envelope.to forEach` loop, we add one final property to `envelope`
    named after the mailbox name (`rcpt`). If the mailbox exists, we create `writeStream`
    to `saveTo` (a path with a filename determined from combining `envelope.from`
    with `envelope.date)`. We now have an endpoint to each recipient's mailbox ready
    to receive data. If the mailbox doesn't exist for the recipient, we set `envelope[rcpt]`
    to `catchall. catchall` is the global we set at the top of our file. It's a `writeStream`
    with the `a` flag set so that the `caught` file accumulates orphaned emails. We
    create the `catchall writeStream` on initialization and then reuse the same `writeStream`
    for all emails addressed to non-existent mailboxes. This saves us from creating
    a `writeStream` for every badly addressed email received, thus saving resources.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `envelope.to forEach` 循环中，我们为 `envelope` 添加一个名为邮箱名称（`rcpt`）的最终属性。如果邮箱存在，我们创建
    `writeStream` 来 `saveTo`（路径和文件名由 `envelope.from` 与 `envelope.date` 组合确定）。现在我们已经准备好接收每个收件人邮箱的数据。如果收件人的邮箱不存在，我们将
    `envelope[rcpt]` 设置为 `catchall`。`catchall` 是我们在文件顶部设置的全局变量。它是一个带有 `a` 标志的 `writeStream`，以便
    `caught` 文件累积孤立的电子邮件。我们在初始化时创建 `catchall writeStream`，然后重用相同的 `writeStream` 用于所有发送到不存在邮箱的邮件。这样可以避免为每封错误寄往的电子邮件创建
    `writeStream`，从而节省资源。
- en: The `data` event is triggered for each chunk of the email body received by the
    server, giving us `envelope` and `chunk`. We save each `chunk` to its applicable
    file using `envelope[rcpt].write`, determining the `rcpt` by looping through our
    custom `envelope.mailboxes` array.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 事件会在服务器接收到电子邮件正文的每个块时触发，给我们提供 `envelope` 和 `chunk`。我们使用 `envelope[rcpt].write`
    将每个 `chunk` 保存到相应的文件中，通过循环遍历我们自定义的 `envelope.mailboxes` 数组来确定 `rcpt`。'
- en: The `dataReady` event signifies that all data has been received and the data
    is ready for processing. Since we've already stored it, we use this event to `end`
    the relevant `writeStream` for each `rcpt` in our `mailboxes`. The `dataReady`
    event also requires a callback (cb). The first parameter can be an `Error` object,
    which allows for a final rejection of an email (for instance if the content of
    the email was analyzed and found to be spam). The second parameter expects a queue
    ID to send to the mail client, in our case we simply give `Date.now`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataReady` 事件表示所有数据已经接收完毕，数据已经准备好进行处理。由于我们已经存储了数据，我们使用这个事件来结束我们 `mailboxes`
    中每个 `rcpt` 的相关 `writeStream`。`dataReady` 事件还需要一个回调（cb）。第一个参数可以是一个 `Error` 对象，允许最终拒绝电子邮件（例如，如果分析电子邮件的内容发现是垃圾邮件）。第二个参数期望一个队列
    ID 发送到邮件客户端，在我们的情况下，我们只是给出 `Date.now`。'
- en: There's more...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's take a look at how to convert our SMTP server into a public mail exchange
    handler.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将我们的 SMTP 服务器转换为公共邮件交换处理程序。
- en: Receiving emails from external SMTP servers
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从外部 SMTP 服务器接收电子邮件
- en: By removing authorization settings and remotely hosting our SMTP server, listening
    on port `25`, we can allow other mail servers to communicate with our SMTP server
    so email can be transferred from one network to another (for example, from a Gmail
    account to our hosted SMTP server).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除授权设置并远程托管我们的SMTP服务器，监听端口`25`，我们可以允许其他邮件服务器与我们的SMTP服务器通信，以便可以将电子邮件从一个网络传输到另一个网络（例如，从Gmail帐户到我们托管的SMTP服务器）。
- en: 'Let''s save our file as `mx_smtp.js` and modify the following accordingly:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将文件保存为`mx_smtp.js`，并相应地修改以下内容：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We've discarded the `users` variable and changed the `smtp` variable so the
    object with the `requireAuthentication` property and the accompanying `authorizeUser`
    event are removed. In order for an external mail program to forward to our SMTP
    server it must be able to connect. Since other mail programs don't possess authentication
    details we have to open our server to allow them to do so.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经丢弃了`users`变量，并更改了`smtp`变量，因此具有`requireAuthentication`属性和相应的`authorizeUser`事件的对象已被删除。为了使外部邮件程序转发到我们的SMTP服务器，它必须能够连接。由于其他邮件程序没有认证详细信息，我们必须打开我们的服务器以允许它们这样做。
- en: 'The `startData` data and `dataReady` events all remain the same. The final
    change is to the port:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`startData`数据和`dataReady`事件都保持不变。最终的变化是端口：'
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In order for this to work, we must have a live server which we have root access
    to (for example, an amazon EC2 micro instance), and a domain where we can alter
    the mail exchange (MX) records.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们必须拥有一个我们可以更改邮件交换（MX）记录的域的实时服务器（例如，亚马逊EC2微实例）和根访问权限。
- en: So for instance, say we're hosting our SMTP server at `mysmtpserver.net` and
    we want to receive emails for `bob@nodecookbook.com`. We point the MX records
    of `nodecookbook.com` to `mysmtpserver.net` with a priority of 10.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们将我们的SMTP服务器托管在`mysmtpserver.net`上，并且我们想要接收`bob@nodecookbook.com`的电子邮件。我们将`nodecookbook.com`的MX记录指向`mysmtpserver.net`，优先级为10。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an example of how to change DNS records with a registrar, see [http://support.godaddy.com/help/article/680](http://support.godaddy.com/help/article/680).
    For more info on MX records, take a look at [http://en.wikipedia.org/wiki/MX_record](http://en.wikipedia.org/wiki/MX_record).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何更改注册商的DNS记录的示例，请参见[http://support.godaddy.com/help/article/680](http://support.godaddy.com/help/article/680)。有关MX记录的更多信息，请查看[http://en.wikipedia.org/wiki/MX_record](http://en.wikipedia.org/wiki/MX_record)。
- en: Once changes are made they can take a while to propagate (up to 48 hours, though
    often faster). We can use `dig mx` (Mac OS X and Linux) or `nslookup set q=MX`
    (Windows) to determine if the update to our MX records has occurred.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更改完成，它们可能需要一段时间才能传播（最多48小时，尽管通常更快）。我们可以使用`dig mx`（Mac OS X和Linux）或`nslookup
    set q=MX`（Windows）来确定我们的MX记录是否已更新。
- en: We must have Node installed on our remove host, ensuring that port `25` is exposed
    and not in use by any other programs. To check whether other programs are using
    port `25`, log in with SSH and type `netstat -l`. If you see `*:smtp` in the **Active
    Internet Connections** (only servers) section, a program is already using the
    port and must be stopped (try `ps -ef` to look for any suspects).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在我们的远程主机上安装Node，并确保端口`25`是公开的，并且没有被其他程序使用。要检查其他程序是否使用端口`25`，请使用SSH登录并键入`netstat
    -l`。如果在**活动互联网连接**（仅服务器）部分中看到`*:smtp`，则表示已经有程序在使用该端口，并且必须停止（尝试`ps -ef`查找任何嫌疑人）。
- en: On the live server, we create our `mailboxes` folder containing `bob bib` and
    `susie`, copy our `mx_smtp.js` file over, and install `simplesmtp`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际服务器上，我们创建包含`bob bib`和`susie`的`mailboxes`文件夹，将我们的`mx_smtp.js`文件复制过去，并安装`simplesmtp`。
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, if everything is properly set up, and our MX records are updated, we can
    execute our `mx_smtp.js` file on the live server. Then send a test email to `<[bob@nodecookbook.com](mailto:bob@nodecookbook.com)>`
    (or `@` whatever domain we possess which we have altered the MX records for),
    wait a few seconds, and then check the `mailboxes/bob` folder. The email should
    have appeared.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一切都设置正确，并且我们的MX记录已更新，我们可以在实际服务器上执行我们的`mx_smtp.js`文件。然后向`<[bob@nodecookbook.com](mailto:bob@nodecookbook.com)>`发送测试电子邮件（或者`@`我们已更改MX记录的任何域），等待几秒钟，然后检查`mailboxes/bob`文件夹。电子邮件应该已经出现。
- en: See also
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Sending email discussed in this chapter
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件在本章中讨论
- en: '*Deploying to a server environment* discussed In [Chapter 10](ch10.html "Chapter 10. Taking
    It Live"),Taking It Live'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署到服务器环境*在[第10章](ch10.html "第10章。上线")中讨论，上线'
- en: Implementing a virtual hosting paradigm
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施虚拟托管范式
- en: 'If we wish to host multiple sites on one server, we can do so with virtual
    hosting. Virtual hosting is a way to uniquely handle multiple domain names according
    to their name. The technique is surprisingly simple: we just look at the incoming
    `Host` header and respond accordingly. In this task, we''re going to implement
    simple name based virtual hosting for static sites.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在一个服务器上托管多个站点，我们可以使用虚拟托管来实现。虚拟托管是一种根据名称独特处理多个域名的方法。这种技术非常简单：我们只需查看传入的`Host`标头并相应地做出响应。在这个任务中，我们将为静态站点实现基于名称的简单虚拟托管。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll create a folder called `sites`, with `localhost-site` and `nodecookbook`
    as subdirectories. In `localhost-site/index.html` we''ll write the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`sites`的文件夹，其中`localhost-site`和`nodecookbook`作为子目录。在`localhost-site/index.html`中，我们将编写以下内容：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And in `nodecookbook/index.html` we''ll add the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在`nodecookbook/index.html`中，我们将添加以下代码：
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For local testing, we'll want to configure our system with some extra host names
    so we can point different domains to our server. To do this, we edit `/etc/hosts`
    on Linux and Max OS X, or `%SystemRoot%\system32\drivers\etc\hosts` for Windows
    systems.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地测试，我们将希望配置我们的系统以使用一些额外的主机名，以便我们可以将不同的域指向我们的服务器。要做到这一点，我们在Linux和Max OS X上编辑`/etc/hosts`，或者在Windows系统上编辑`%SystemRoot%\system32\drivers\etc\hosts`。
- en: 'At the top of the file it maps our local loopback IP `127.0.0.1` to `localhost`.
    Let''s change this line to:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的顶部，它将我们的本地环回IP`127.0.0.1`映射到`localhost`。让我们将这一行改为：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we want to create two new files: `mappings.js` and `server.js`. The
    `mappings.js` file will provide static file servers for each domain name, and
    `server.js` will provide the virtual hosting logic.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要创建两个新文件：`mappings.js`和`server.js`。`mappings.js`文件将为每个域名提供静态文件服务器，而`server.js`将提供虚拟托管逻辑。
- en: 'We''ll be using the `node-static` module for serving our sites, our virtual
    host will only serve static websites. If we don''t already have it, we can install
    it via `npm` as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`node-static`模块来提供我们的站点，我们的虚拟主机将只提供静态网站。如果我们还没有它，我们可以通过`npm`安装它，如下所示：
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let's start with `mappings.js:`
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`mappings.js`开始：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We've used the domains laid out in our system's `hosts` file. In a production
    scenario domains would be directed to us by DNS records.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了系统`hosts`文件中列出的域。在生产场景中，域将通过DNS记录指向我们。
- en: Now for `server.js:`
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`server.js`的时候了：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now when we navigate to `http://localhost:8080` or `http://localhost.localdomain:8080`,
    we get the content in `sites/localhost-site/index.html`. Whereas, if we go to
    `http://nodecookbook:8080`, we get the big Node Cookbook welcome message.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们导航到`http://localhost:8080`或`http://localhost.localdomain:8080`时，我们会得到`sites/localhost-site/index.html`中的内容。而如果我们转到`http://nodecookbook:8080`，我们会得到大的Node
    Cookbook欢迎消息。
- en: How it works...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Any time our server receives a request, we strip the port number (which wouldn't
    be necessary with port `80` servers) to determine the `domain.`
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的服务器收到一个请求，我们都会去掉端口号（对于端口`80`服务器来说是不必要的），以确定`domain`。
- en: We then cross reference the `domain` with our `mappings.sites` object. If a
    site is found, we call its `serve` method, which is inherited from the `node-static`
    library. In `mappings.js`, each `exports.sites` property contains a `node-static
    Server` instance pointed at the relevant site directory. We've used our custom
    `staticServer` function as a wrapper to keep the code a little tidier.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`domain`与我们的`mappings.sites`对象进行交叉引用。如果找到一个站点，我们调用它的`serve`方法，该方法是从`node-static`库继承的。在`mappings.js`中，每个`exports.sites`属性都包含一个指向相关站点目录的`node-static
    Server`实例。我们使用我们的自定义`staticServer`函数作为包装器，以使代码更加整洁。
- en: To use the static `Server` instance, we call its `serve` method, passing through
    the `req` and `res` objects, as in `server.js:`
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用静态`Server`实例，我们调用其`serve`方法，通过`req`和`res`对象传递，就像在`server.js`中一样：
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `site` variable is an instance of `static.Server` pointing to the appropriate
    site folder for the given domain name.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`site`变量是指向给定域名的适当站点文件夹的`static.Server`实例。'
- en: If `server.js` fails to find a site in `mapping.js` for the requested domain,
    we simply pass a `404` error back to the client.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`server.js`在请求的域中找不到`mapping.js`中的站点，我们只需向客户端传递`404`错误。
- en: There's more...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What about going beyond static hosting into dynamic hosting, or what if we want
    to use an SSL/TLS certificate with our sites?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 超越静态托管进入动态托管，或者如果我们想要在我们的网站上使用SSL/TLS证书呢？
- en: Virtual hosting Express apps
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟托管Express应用程序
- en: Express/Connect come with the `vhost` middleware which allows us to implement
    dynamic Express-based virtual hosting with ease.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Express/Connect带有`vhost`中间件，它允许我们轻松实现基于Express的动态虚拟托管。
- en: 'First, we need to set up two Express apps. Let''s remove the `nodecookbook`
    and `localhost-site` folders and regenerate them using the `express` binary as
    follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置两个Express应用程序。让我们删除`nodecookbook`和`localhost-site`文件夹，并使用`express`二进制文件重新生成它们，如下所示：
- en: '[PRE52]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We''d also need to modify the last part of `app.js` in each site''s file, wrapping
    the `app.listen` method in an `if module.parent` conditional:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改每个站点文件中`app.js`的最后部分，将`app.listen`方法包装在`if module.parent`条件中：
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In our `nodecookbook` app, let's add the following to `index.jade:`
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`nodecookbook`应用程序中，让我们在`index.jade`中添加以下内容：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: And in the `localhost-site` app, we add this code to `index.jade:`
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在`localhost-site`应用程序中，我们将以下代码添加到`index.jade`中：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'With our sites set up, we can modify `mappings.js` as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的站点设置，我们可以修改`mappings.js`如下：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We've removed the `node-static` module since we're using Express instead. Our
    `staticServe` convenience function has been modified as `appServe`, which simply
    loads each Express app using `require` according to its mapping in `exports.servers`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经删除了`node-static`模块，因为我们改用了Express。我们的`staticServe`便利函数已被修改为`appServe`，它只是根据`exports.servers`中的映射使用`require`加载每个Express应用程序。
- en: 'And we''ll update `server.js` as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`server.js`如下：
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We create a master `app` then loop through `mappings.sites`, passing each sub-app
    into `app.use` with `express.vhost`. The `vhost` middleware takes two arguments.
    The first is the domain. We get each `domain` from the `mappings.sites` keys.
    The second is an Express app. We retrieve each Express app from the values in
    `mappings.sites`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个主`app`，然后循环遍历`mappings.sites`，将每个子应用程序传递到`app.use`中与`express.vhost`一起使用。`vhost`中间件接受两个参数。第一个是域名。我们从`mappings.sites`键中获取每个`domain`。第二个是一个Express应用程序。我们从`mappings.sites`中的值中检索每个Express应用程序。
- en: We simply request the domain and the `vhost` middleware lines up the relevant
    domain with the relevant app to deliver the correct site.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需请求域和`vhost`中间件就会将相关域与相关应用程序对齐，以提供正确的站点。
- en: Server Name Indication
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器名称指示
- en: Prior to Server Name Indication (SNI), name-based virtual hosting for sites
    served over SSL/TLS was a complex administration issue (requiring every hostname
    to be stored in a multi-domain certificate).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器名称指示（SNI）之前，基于名称的SSL/TLS虚拟托管对于网站是一个复杂的管理问题（需要将每个主机名存储在多域证书中）。
- en: This is because an encrypted connection is established based upon a certificate
    that specifies a domain name before any HTTP headers are received by the server.
    Therefore, the server cannot provide a certificate that is specific to one domain.
    As a result, the browser would vividly warn the user that the connection may be
    unsafe since the domain name listed on the certificate didn't match the domain
    being accessed. In order to avoid this scenario, a virtual host would have to
    buy a certificate containing every domain hosted, then reapply for a new certificate
    every time a new domain was added or removed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在服务器接收到任何HTTP头之前，基于指定域名的证书建立了加密连接。因此，服务器无法提供特定于一个域的证书。因此，浏览器会明确警告用户连接可能不安全，因为证书上列出的域名与正在访问的域名不匹配。为了避免这种情况，虚拟主机必须购买包含托管的每个域的证书，然后每次添加或删除新域时重新申请新证书。
- en: SNI forwards the requested domain to the server at the beginning of the SSL/TLS
    handshake, allowing our server to choose the appropriate certificate for a domain,
    and preventing the browser from telling our users that they may be under attack.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: SNI在SSL/TLS握手开始时将请求的域名转发到服务器，允许我们的服务器为域名选择适当的证书，并防止浏览器告诉我们的用户他们可能受到攻击。
- en: '`https.Server` (inheriting from `tls.Server)` has the `addContext` method,
    which allows us to specify hostname and certificate credentials for multiple individual
    domains.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`https.Server`（继承自`tls.Server`）具有`addContext`方法，允许我们为多个单独的域指定主机名和证书凭据。'
- en: Let's enable TLS-compatible virtual hosting by making a few changes. First,
    in `mappings.js`, we'll add another convenience function called `secureShare:`
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过进行一些更改来启用TLS兼容的虚拟主机。首先，在`mappings.js`中，我们将添加另一个方便函数，称为`secureShare:`
- en: '[PRE58]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Next, we'll alter the way we load the sites, calling `secureShare` instead of
    `staticServe:`
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将改变加载站点的方式，调用`secureShare`而不是`staticServe:`
- en: '[PRE59]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: For this example to work in a production scenario, we'll have to replace the
    sample domains with the ones that we control and obtain genuine certificates signed
    by a trusted Certificate Authority.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例在生产环境中工作，我们必须用我们控制的域名替换示例域名，并获得由受信任的证书颁发机构签发的真正证书。
- en: Note
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can test locally by following the instructions in the supporting code files
    for this chapter (under `secure_virtual_hosting/howto)`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过按照本章的支持代码文件中的说明（在`secure_virtual_hosting/howto`下）在本地进行测试。
- en: 'Let''s change our `sites` folder structure to conform to alterations made in
    `mappings.js` by renaming `nodecookbook` to `nodecookbook.com` and `localhost-site`
    to `davidmarkclements.com`, changing the latter''s `index.html` file to the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将`sites`文件夹结构更改为符合`mappings.js`中所做的更改，将`nodecookbook`重命名为`nodecookbook.com`，将`localhost-site`重命名为`davidmarkclements.com`，并将后者的`index.html`文件更改为以下内容：
- en: '[PRE60]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Each `site` folder also needs a `certs` folder containing our `cert.pem` and
    `key.pem` files. These files must be certificates purchased specifically for the
    domain.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`site`文件夹还需要一个包含我们的`cert.pem`和`key.pem`文件的`certs`文件夹。这些文件必须是专门为该域购买的证书。
- en: 'In `server.js`, we change the top of our script to the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中，我们将脚本顶部更改为以下内容：
- en: '[PRE61]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The filesystem (`fs`) module is required to load our credentials. As we''ve
    replaced `http` with `https`, we will alter our `createServer` call as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`fs`模块来加载我们的凭据。由于我们已经用`https`替换了`http`，我们将修改我们的`createServer`调用如下：
- en: '[PRE62]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Simply adding`'s'` to `http` does the trick. On this occasion, there's no SSL/TLS
    credentials since we'll be loading these on a per domain basis with the `addContext`
    method. Therefore, we just pass an empty object.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将`http`添加`s`即可。在这种情况下，没有SSL/TLS凭据，因为我们将使用`addContext`方法按域加载这些凭据。因此，我们只传递一个空对象。
- en: 'In `mappings.js`, our `secureShare` function returns an object containing three
    properties, `content, key`, and `cert`, where `content` holds the static server.
    So in `server.js`, we update this line:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mappings.js`中，我们的`secureShare`函数返回一个包含三个属性`content, key`和`cert`的对象，其中`content`保存静态服务器。因此，在`server.js`中，我们更新这一行：
- en: '[PRE63]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 至：
- en: '[PRE64]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As we're hosting on a live server, we expose it to incoming web connections
    by binding to `0.0.0.0:`
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在托管在实时服务器上，我们通过绑定到`0.0.0.0:`将其暴露给传入的Web连接
- en: '[PRE65]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We could also change the `port` variable to `443` to serve directly over the
    HTTPS port (we must run the server as root to do this, which has security implications
    in a live environment, see[Chapter 10](ch10.html "Chapter 10. Taking It Live"),
    *Taking It Live*, for how to do this safely).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将`port`变量更改为`443`，以直接通过HTTPS端口提供服务（我们必须以root身份运行服务器才能做到这一点，在实际环境中这具有安全风险，请参见[第10章](ch10.html
    "第10章。上线")，*上线*，了解如何安全地执行此操作）。
- en: And finally, we add the following to the bottom of `server.js:`
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`server.js`的底部添加以下内容：
- en: '[PRE66]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This loads the `key` and `cert` properties for each domain based on the settings
    laid out in `mappings.js`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据`mappings.js`中的设置加载每个域的`key`和`cert`属性。
- en: Provided we have trusted CA-certified credentials for each specified domain,
    and we're using a modern browser, we can navigate to each site using HTTPS without
    a receiving a warning.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们为每个指定的域拥有受信任的CA认证凭据，并且我们使用现代浏览器，我们就可以在不接收警告的情况下使用HTTPS访问每个站点。
- en: Tip
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The Caveat**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'There is a catch: Server Name Indication only works in modern browsers. Although
    modern browsers in this context exclude Internet Explorer 7/8 and Safari when
    run on Windows XP, as well as Android Gingerbread (versions 2.x) and Blackberry
    browsers. If we provided a default certificate via the options object of `https.createServer`,
    the user will still be able to view the site on older browsers, but they will
    receive the same warnings as if we weren''t using SNI (the older browsers don''t
    indicate the hostname in SSL/TLS negotiations so our SNI handling never occurs).
    Depending on the intended market, we may have to use alternative methods until
    these older browsers are used in sufficiently low numbers in relation to our purposes.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个问题：服务器名称指示仅适用于现代浏览器。在这种情况下，现代浏览器不包括在Windows XP上运行时的Internet Explorer 7/8和Safari，以及Android
    Gingerbread（2.x版本）和Blackberry浏览器。如果我们通过`https.createServer`的选项对象提供了默认证书，用户仍然可以在旧版浏览器上查看网站，但他们将收到与我们不使用SNI时相同的警告（旧版浏览器在SSL/TLS协商中不指示主机名，因此我们的SNI处理永远不会发生）。根据预期的市场，我们可能必须使用替代方法，直到这些旧版浏览器在与我们的目的相关的数量上使用得足够少。
- en: See also
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Serving static files* discussed In [Chapter 1](ch01.html "Chapter 1. Making
    a Web Server"),Making a Web Server'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供静态文件*在[第1章](ch01.html "第1章. 搭建Web服务器")中讨论，搭建Web服务器'
- en: '*Dynamic routing* discussed In [Chapter 6](ch06.html "Chapter 6. Accelerating
    Development with Express"),Accelerating Development with Express'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态路由*在[第6章](ch06.html "第6章. 使用Express加速开发")中讨论，使用Express加速开发'
- en: '*Setting up an HTTPS web server* discussed In [Chapter 7](ch07.html "Chapter 7. Implementing
    Security, Encryption, and Authentication"),Implementing Security, Encryption,
    and Authentication'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置HTTPS Web服务器*在[第7章](ch07.html "第7章. 实现安全、加密和认证")中讨论，实现安全、加密和认证'
- en: '*Deploying to a server environment* discussed In [Chapter 10](ch10.html "Chapter 10. Taking
    It Live"),Taking It Live'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署到服务器环境*在[第10章](ch10.html "第10章. 上线")中讨论，上线'
