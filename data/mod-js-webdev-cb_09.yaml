- en: Debugging Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试您的应用程序
- en: 'The recipes we''ll see here are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里看到的食谱是：
- en: Logging with style
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以风格记录
- en: Debugging with the React Developer Tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React开发者工具进行调试
- en: Debugging with the standalone tool
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用独立工具进行调试
- en: Logging Redux with redux-logger
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用redux-logger记录Redux
- en: Debugging Redux with the Redux Developer Tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux开发者工具调试Redux
- en: Connecting routing for debugging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接路由进行调试
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapters, we saw how to develop a basic `React` application,
    how to enhance it for a better user experience, and how to expand it, making it
    more scalable for complex and large application scopes. All this development,
    however, is sure to require both testing and debugging, so in this chapter, we'll
    be touching upon debugging recipes, and in the following chapter, we'll cover
    testing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们看到了如何开发基本的`React`应用程序，如何增强它以获得更好的用户体验，以及如何扩展它，使其更适用于复杂和大型应用程序范围。然而，所有这些开发肯定需要测试和调试，因此在本章中，我们将涉及调试食谱，在接下来的章节中，我们将涵盖测试。
- en: Logging with style
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以风格记录
- en: Logging is still a very good tool, but you cannot just depend on using tools
    such as `console.log()` or `console.error()`. Even though they do the work for
    a short debugging run, if you plan to include logging more seriously and want
    to disable it in production, you'll have a lot of work chasing down every logging
    call—or *monkey patching* the console object so `.log()` or `.error()` won't do
    their thing, and that's even worse!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 记录仍然是一个非常好的工具，但您不能仅依赖于使用`console.log（）`或`console.error（）`等工具。即使它们可以在短暂的调试运行中完成工作，但如果您计划更严肃地包括日志记录并希望在生产中禁用它，您将不得不追踪每个日志调用，或者*猴子补丁*控制台对象，以便`.log（）`或`.error（）`不起作用，这甚至更糟！
- en: Back in the *Adding logging with Winston* section of [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml),
    *Testing and Debugging Your Server*, we used `Winston` for logging (and also `Morgan`,
    but that was specific for HTTP logging, so it doesn't count) and that library
    had features that enabled us to easily start or stop logging. There's no version
    of `Winston` for browsers, but we can fall back to `debug`, an old standard (we
    referred to in the *There's more...* section at the end of the chapter we just
    mentioned) that happens to work on the web as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)的*使用Winston添加日志记录*部分，*测试和调试您的服务器*，我们使用`Winston`进行日志记录（还使用了`Morgan`，但那是特定于HTTP日志记录，所以不算），该库具有启用我们轻松启动或停止日志记录的功能。没有适用于浏览器的`Winston`版本，但我们可以退回到`debug`，这是一个旧标准（我们在刚才提到的章节末尾的*还有更多...*部分中提到的），它也可以在网络上使用。
- en: You can find the complete documentation for debug at [https://github.com/visionmedia/debug](https://github.com/visionmedia/debug).
    Note that if you wish, you could also use it with `Node`, though we think our
    earlier choice is better.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/visionmedia/debug](https://github.com/visionmedia/debug)找到调试的完整文档。请注意，如果愿意，您也可以在`Node`中使用它，尽管我们认为我们之前的选择更好。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You install `debug` in the same way as if you wanted to use it with `Node`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像在`Node`中使用它一样安装`debug`。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will also have to decide how to *namespace* your logs because with debug
    you have an easy way to select which messages (if any) get shown and which are
    not displayed. Some possible ideas are to have names like `MYAPP:SERVICE:LOGIN`,
    `MYAPP:SERVICE:COUNTRIES`, `MYAPP_SERVICE:PDF_INVOICE`, and so on for each service
    in your application, or `MYAPP_FORM:NEW_USER`, `MYAPP:FORM:DISPLAY_CART`, `MYAPP:FORM:PAY_WITH_CARD`,
    and so on for each form, or `MYAPP:COMPONENT:PERSONAL_DATA`, `MYAPP:COMPONENT_CART`,
    and the like for specific components; the list can go on for actions, reducers,
    and so on, as you wish.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须决定如何*命名空间*您的日志，因为使用调试可以轻松选择显示哪些消息（如果有的话）和哪些不显示。一些可能的想法是为应用程序中的每个服务使用名称，例如`MYAPP：SERVICE：LOGIN`，`MYAPP：SERVICE：COUNTRIES`，`MYAPP_SERVICE：PDF_INVOICE`等，或者为每个表单使用名称，例如`MYAPP_FORM：NEW_USER`，`MYAPP：FORM：DISPLAY_CART`，`MYAPP：FORM：PAY_WITH_CARD`等，或者为特定组件使用名称，例如`MYAPP：COMPONENT：PERSONAL_DATA`，`MYAPP：COMPONENT_CART`等；您可以根据需要为操作，减速器等列出清单。
- en: 'There''s a way to select afterwards which logs will be shown, by storing a
    value in `LocalStorage` (we''ll get to this) so you can set:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以在之后选择显示哪些日志，方法是在`LocalStorage`中存储一个值（我们将在此处介绍），这样您就可以设置：
- en: '`MYAPP:*` to display all logs from my app'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYAPP：*`显示来自我的应用程序的所有日志'
- en: '`MYAPP:SERVICE:*` to display all service-related logs'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYAPP：SERVICE：*`显示所有与服务相关的日志'
- en: '`MYAPP:FORM:`  and `MYAPP:COMPONENT:*` to display logs related to some forms
    or components, but omit others'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYAPP：FORM：`和`MYAPP：COMPONENT：*`显示与某些表单或组件相关的日志，但省略其他日志'
- en: '`MYAPP:SERVICE:COUNTRIES`,`MYAPP:FORM:NEW_USER` and `MYAPP:FORM:PAY_WITH_CARD`
    to display logs related to those three items'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYAPP：SERVICE：COUNTRIES`，`MYAPP：FORM：NEW_USER`和`MYAPP：FORM：PAY_WITH_CARD`来显示与这三个项目相关的日志'
- en: You can also prefix a string with `"-"` to exclude it. `MYAPP:ACTIONS:*,-MYAPP:ACTIONS:LOADING`
    will enable all actions, but not the `LOADING` one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用“-”前缀字符串来排除它。 `MYAPP：ACTIONS：*，-MYAPP：ACTIONS：LOADING`将启用所有操作，但不包括`LOADING`。
- en: 'You may wonder: why include a fixed text such as `MYAPP:` everywhere? The key
    is that many of the libraries you may use actually also use debug for logging.
    If you were to say to display everything (`*`) instead of `MYAPP:*`, you would
    get in the console every single message from all those libraries, and that''s
    not what you expected!'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想：为什么在每个地方都包含固定文本`MYAPP：`？关键在于，您可能使用的许多库实际上也使用调试进行日志记录。如果您要说显示所有内容（`*`）而不是`MYAPP：*`，则会在控制台中获得所有这些库的每条消息，这不是您预期的！
- en: You are free to decide the naming of your logs, but setting up a well-structured
    list will make it possible for you to pick and choose later which logs to display,
    meaning that you won't have to start messing around with the code to enable or
    disable any given set of messages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由决定日志的命名，但建立一个结构良好的列表将使您能够稍后选择要显示的日志，这意味着您不必开始乱弄代码以启用或禁用任何给定的消息集。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s aim to replicate what we had in `Winston`, at least in part, so it will
    be easier for you if you do full stack work, both client- and server-side. We
    want to have a logger object with methods such as `.warn()` and `.info()` that
    will display a given message in an appropriate color. Also, we don''t want logs
    to be displayed in production. This leads us to the code as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们至少在某种程度上复制我们在`Winston`中所拥有的内容，这样如果您进行全栈工作，无论是客户端还是服务器端，都会更容易。我们希望有一个带有`.warn()`和`.info()`等方法的记录器对象，它将以适当的颜色显示给定的消息。此外，我们不希望在生产中显示日志。这将导致我们的代码如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some important details:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的细节：
- en: The `WHAT_TO_LOG` constant lets you select which messages should be shown.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WHAT_TO_LOG`常量允许您选择应显示哪些消息。'
- en: The `MIN_LEVEL_TO_LOG` constant defines the lowest level that will be logged.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MIN_LEVEL_TO_LOG`常量定义了将被记录的最低级别。'
- en: The log object has a method for each severity level, as in Winston.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志对象具有每个严重级别的方法，就像Winston一样。
- en: Finally, a non-operative `log` object is returned if we are not in development
    mode; all calls to logging methods will produce exactly nothing.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果我们不处于开发模式，将返回一个无效的`log`对象；所有对日志方法的调用都将产生完全没有任何输出。
- en: Note that we used fallthrough in the `switch` statement (no `break` statements
    in it!) to correctly build up the `log` object. It's not often that you can do
    this in a good way, and we had to shut up ESLint about it!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`switch`语句中使用了fallthrough（其中没有`break`语句！）来正确构建`log`对象。这并不常见，而且我们不得不在ESLint中关闭它！
- en: We have the code we need; let's see an example of its usage.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了我们需要的代码；让我们看一个使用它的例子。
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Given that logging is not a complex concept and we have already seen it for
    the server, let''s go with a very short example. We could change the `index.js`
    file for our application to include a few example logs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于日志记录并不是一个复杂的概念，而且我们已经在服务器上看到了它，让我们来看一个非常简短的例子。我们可以更改我们应用程序的`index.js`文件，以包含一些示例日志：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running our application will produce the following output in the console; see
    the next screenshot. You should verify that only the correct messages were logged:
    `info` level and above, and only if they matched `myapp:SERVICE:*`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的应用程序将在控制台中产生以下输出；请参阅下一个截图。您应该验证只有正确的消息被记录：`info`级别及以上，并且只有它们匹配`myapp:SERVICE:*`：
- en: '![](img/0fe89aca-345f-49af-b3b2-d89d0eff1c53.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fe89aca-345f-49af-b3b2-d89d0eff1c53.png)'
- en: Using debug produces clear, understandable output in the console
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试可以在控制台中产生清晰、易懂的输出
- en: Note that, according to our specification, only the `myapp:SERVICE` related
    messages were shown.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据我们的规范，只显示了与`myapp:SERVICE`相关的消息。
- en: Debugging with the React Developer Tools
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Developer Tools进行调试
- en: When we worked with `Node` (in [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml),
    *Testing and Debugging Your Server*) we saw how to do basic debugging, but now
    we are going to focus on a `React`-specific tool, the **React Developer Tools**
    (**RDT**), which are attuned to working with components and props. In this recipe,
    let's see how to install and use the package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`Node`（在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)中，*测试和调试您的服务器*）时，我们看到了如何进行基本调试，但现在我们将专注于一个`React`-特定的工具，**React
    Developer Tools**（**RDT**），这些工具专门用于与组件和props一起使用。在这个教程中，让我们看看如何安装和使用这个工具包。
- en: Getting Ready
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The RDT are an extension for Chrome or Firefox that let you inspect components
    in the standard web developer tools. We are going to work with the Chrome version
    here, but usage is similar for Firefox. You can install the extension by going
    to the **Chrome Web Store** at [https://chrome.google.com/webstore/category/extensions](https://chrome.google.com/webstore/category/extensions)
    and searching for RDT; the extension you want is authored by Facebook. Click the
    Add to Chrome button, and when you open the Chrome Developer Tools, you'll find
    a new tab, React.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: RDT是Chrome或Firefox的扩展，可以让您在标准Web开发工具中检查组件。我们将在这里使用Chrome版本，但是Firefox的使用方式类似。您可以通过访问**Chrome
    Web Store**（[https://chrome.google.com/webstore/category/extensions](https://chrome.google.com/webstore/category/extensions)）并搜索RDT来安装该扩展；您想要的扩展是由Facebook编写的。单击“添加到Chrome”按钮，当您打开Chrome开发者工具时，您将找到一个新的选项卡，React。
- en: If you don't use Chrome or Firefox, or if you have to test a `React` application
    that will be shown in an iframe, you'll want to look at the standalone version
    of the tools; we'll get to them in the *Debugging with the standalone tool* section,
    just after this one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用Chrome或Firefox，或者如果您必须测试将显示在iframe中的`React`应用程序，您将希望查看工具的独立版本；我们将在*使用独立工具进行调试*部分中介绍它们，就在这一部分之后。
- en: How to do it…
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s see how to use RDT with the counter application we developed in the *Managing
    state with Redux* section in the previous chapter. That application was simple,
    so we''ll be able to see easily how to use the tool, but of course you can apply
    it to very complex, full-of-components pages as well. Start the application, open
    the web developer tools, select the React tab, and if you expand every component,
    you''ll see something like the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在上一章中的*使用Redux管理状态*部分中开发的计数器应用程序中使用RDT。该应用程序很简单，所以我们可以很容易地看到如何使用该工具，但当然您也可以将其应用于非常复杂、充满组件的页面。启动应用程序，打开Web开发工具，选择React选项卡，如果展开每个组件，您将看到类似以下截图的内容：
- en: '![](img/743c34cb-4cd1-4fd1-85c5-1a02994ddf51.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/743c34cb-4cd1-4fd1-85c5-1a02994ddf51.png)'
- en: The React tab in the web developer tools let you access the whole component
    hierarchy for your application
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Web开发工具中的React选项卡让您访问应用程序的整个组件层次结构
- en: 'By the way, you can use the tool with any `React`-developed application. The
    small tool''s icon will change color when it can be used, and if you click on
    it you''ll get information on whether you are running a development (red-colored
    icon) or production (green-colored icon); this screenshot shows our specific situation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，您可以将该工具与任何使用`React`开发的应用程序一起使用。当工具的小图标变色时，表示可以使用，如果单击它，您将获得有关您是运行开发（红色图标）还是生产（绿色图标）的信息；此截图显示了我们的具体情况：
- en: '![](img/3ae420c8-6a29-46b5-90d6-a085034f12ef.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ae420c8-6a29-46b5-90d6-a085034f12ef.png)'
- en: Our new tool will detect and work with any React-developed application
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新工具将检测并与任何React开发的应用程序一起工作
- en: How it works…
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We have installed our debugging tool, and we have applied it to our application;
    let's now see how it works, and what we can do with it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了我们的调试工具，并将其应用到了我们的应用程序；现在让我们看看它是如何工作的，以及我们可以用它做些什么。
- en: If you select any specific component by clicking on it, you can see which components
    and HTML elements it generates. You can also select a component in a more traditional
    way by selecting a component directly onscreen (click on the leftmost icon, to
    the left of the Memory tab) and then click on the React tab; the element you clicked
    on will be selected. You can also use the Search function to look for a specific
    component; this will be useful with large applications to avoid having to manually
    scroll through lots and lots of HTML.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过点击选择任何特定组件，您可以看到它生成的组件和HTML元素。您还可以通过在屏幕上直接选择组件（点击Memory标签左侧的最左边的图标），然后点击React标签来以更传统的方式选择组件；您点击的元素将被选中。您还可以使用搜索功能查找特定组件；这在大型应用程序中将非常有用，可以避免手动滚动大量HTML。
- en: The triangle next to each component may have two different colors, depending
    on whether it's an actual `React` component (such as `<Counter>` or `<ClicksDisplay>` ,
    in our case) or a `Redux` connection to the store. HTML elements don't have any
    triangles.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件旁边的三角形可能有两种不同的颜色，这取决于它是实际的`React`组件（例如我们的情况下的`<Counter>`或`<ClicksDisplay>`）还是与存储连接的`Redux`。HTML元素没有任何三角形。
- en: In the third panel, you can see the current props. If you edit one (try setting
    the `count` prop to a different value, for example), you'll immediately see changes
    on the left. Also, if you click on a button, you'll see how the prop values change;
    experiment a bit with the three buttons on your application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个面板中，您可以看到当前的props。如果您编辑一个（例如尝试将`count` prop设置为不同的值），您将立即在左侧看到更改。此外，如果您点击一个按钮，您将看到prop值如何更改；在您的应用程序上尝试一下三个按钮。
- en: 'If you want to interact with any component, you may notice that the currently
    selected one has `== $r` next to it. This means that there is a special JS variable,
    which points to the selected component in our case, `<Counter>`. If you open the
    Console tab, you can examine its props, by typing in `$r.props`, or experiment
    with calling the diverse methods available, such as `$r.onAdd1()` , as shown in
    the next screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想与任何组件进行交互，您可能会注意到当前选择的组件旁边有`== $r`。这意味着有一个特殊的JS变量，它指向我们的情况下所选择的组件，`<Counter>`。如果您打开Console标签，可以通过输入`$r.props`来检查其props，或者尝试调用各种可用的方法，例如`$r.onAdd1()`，如下一个截图所示：
- en: '![](img/6bc8ebab-96ed-4077-a15e-929aa0f32746.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bc8ebab-96ed-4077-a15e-929aa0f32746.png)'
- en: The `$r` variable lets you work (and experiment) with the currently selected
    component
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`$r`变量让您可以使用（和实验）当前选择的组件'
- en: 'Interestingly, in our application, as we coded it, the `.onAdd1()` method actually
    dispatches an action, and we can see it in the screenshot: an object with `type:"counter:increment"`
    and `value:1`, just as we coded it; see the *Defining Actions* section in the
    previous chapter to check.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在我们的应用程序中，当我们编写它时，`.onAdd1()`方法实际上会分派一个动作，我们可以在截图中看到：一个带有`type:"counter:increment"`和`value:1`的对象，就像我们编写的一样；请参阅上一章中的*定义动作*部分进行检查。
- en: 'If you select the `<Provider>` component, you can inspect the current state
    of the application. First you''ll have to select it (so `$r` points to it) and
    then, in the Console tab, you''ll need to enter `$r.store.getState()` to get results
    as in the next screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择`<Provider>`组件，您可以检查应用程序的当前状态。首先您需要选择它（以便`$r`指向它），然后在Console标签中，您需要输入`$r.store.getState()`来获得如下一个截图中的结果：
- en: '![](img/229f2495-f313-4896-8673-1b225ab6e9bc.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/229f2495-f313-4896-8673-1b225ab6e9bc.png)'
- en: By selecting the <Provider> component, you can inspect the application's state
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择<Provider>组件，您可以检查应用程序的状态
- en: In fact, you can even fire actions if you want; by entering something like `$r.store.dispatch({type:"counter:increment",
    value:11})` , you have full control over the application state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果您愿意，甚至可以触发动作；通过输入类似`$r.store.dispatch({type:"counter:increment", value:11})`，您可以完全控制应用程序状态。
- en: Debugging with the standalone tool
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用独立工具进行调试
- en: If you are working with other browsers such as Safari or Internet Explorer,
    or if you cannot use Chrome or Firefox for some reason, there's a standalone version
    of the tool, which you can find at [https://github.com/facebook/react-devtools/tree/master/packages/react-devtools](https://github.com/facebook/react-devtools/tree/master/packages/react-devtools).
    Be warned, though, that for web development, you won't be getting the full functionality,
    so you'll probably be better off keeping to a supported browser!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用其他浏览器，如Safari或Internet Explorer，或者由于某些原因无法使用Chrome或Firefox，那么有一个独立版本的工具，您可以在[https://github.com/facebook/react-devtools/tree/master/packages/react-devtools](https://github.com/facebook/react-devtools/tree/master/packages/react-devtools)找到。不过，需要警告的是，对于Web开发，您将无法获得完整的功能，因此最好还是使用支持的浏览器！
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We want to use the standalone tool; let''s see how to set it up. To start with,
    obviously, we need to install the package. You can do it globally, but I prefer
    working locally within the project itself:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用独立工具；让我们看看如何设置它。首先，显然，我们需要安装该软件包。您可以全局安装，但我更喜欢在项目本身内部进行本地工作：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to be able to run the new command, you could use `npx` (as we saw
    a couple of times in the book), but it''s easier to just define a new script in
    `package.json`. Add something like the following to it, and you''ll be able to
    open the standalone app with `npm run devtools`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行新命令，您可以使用`npx`（正如我们在书中看到的那样），但更容易的方法是在`package.json`中定义一个新的脚本。添加类似以下内容，您就可以使用`npm
    run devtools`打开独立应用程序：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now you are set up; let's see how to use the tool.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置好了；让我们看看如何使用这个工具。
- en: In case you are curious, this standalone application is itself written in JS
    and converted to a desktop application with `Electron`, as we'll be seeing later
    in the book in [Chapter 13](2aebad42-65b6-4cb7-bf4f-1e2e0907a70a.xhtml), *Creating
    a Desktop Application with Electron*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感兴趣，这个独立应用程序本身是用JS编写的，并使用`Electron`转换为桌面应用程序，我们将在本书的[第13章](2aebad42-65b6-4cb7-bf4f-1e2e0907a70a.xhtml)中看到*使用Electron创建桌面应用程序*。
- en: How to do it…
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We got the standalone tool; let's see how to use it. In order to use the RDT
    in a standalone fashion, you'll have to add a single line at the top of your HTML
    code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了独立工具；让我们看看如何使用它。为了以独立方式使用RDT，您需要在HTML代码的顶部添加一行。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then start the application normally, and after it''s up and running, start
    the standalone app. You''ll get something like the next screenshot. Note that
    we are seeing two separate windows: one with the RDT, and the other with the application
    (for variety) in Opera; in the same way I could have used Safari or IE or any
    other browser:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后正常启动应用程序，等它运行起来后，启动独立应用程序。您将看到类似下一个截图的东西。请注意，我们看到了两个单独的窗口：一个带有RDT，另一个带有应用程序（为了多样性）在Opera中；我也可以使用Safari或IE或任何其他浏览器：
- en: '![](img/da859f94-64d3-4da9-a779-bf2bc63a38a3.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da859f94-64d3-4da9-a779-bf2bc63a38a3.png)'
- en: The standalone RDT let you inspect React applications even if they are running
    in browsers other than Chrome or Firefox
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的RDT让您即使在非Chrome或Firefox浏览器中运行React应用程序也可以进行检查
- en: Now you are really set to go; let's finish this section by seeing what we can
    (and cannot) do.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您真的可以开始了；让我们通过查看我们可以（和不能）做什么来完成本节。
- en: For more details on how to configure the standalone application, in particular,
    if you need to use a different port, check out the official documentation at [https://github.com/facebook/react-devtools/tree/master/packages/react-devtools](https://github.com/facebook/react-devtools/tree/master/packages/react-devtools).
    For complicated cases, you may end up using a different package, `react-devtools-core`,
    over at [https://github.com/facebook/react-devtools/tree/master/packages/react-devtools-core](https://github.com/facebook/react-devtools/tree/master/packages/react-devtools-core).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何配置独立应用程序的更多详细信息，特别是如果您需要使用不同的端口，请查看官方文档[https://github.com/facebook/react-devtools/tree/master/packages/react-devtools](https://github.com/facebook/react-devtools/tree/master/packages/react-devtools)。对于复杂的情况，您可能需要使用不同的软件包`react-devtools-core`，在[https://github.com/facebook/react-devtools/tree/master/packages/react-devtools-core](https://github.com/facebook/react-devtools/tree/master/packages/react-devtools-core)。
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This version of the developer tools lets you interact with the application and
    see components and props, but you'll be restricted as to interacting with them
    through the console, as we'll see.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的开发工具让您可以与应用程序交互并查看组件和属性，但是您将受到通过控制台与它们交互的限制，我们将看到。
- en: 'First, start by checking that if you click on the buttons in the Opera window,
    you''ll automatically see the changes in the RDT, as before see the next screenshot
    for the results after some Add 1 clicks:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过检查在Opera窗口中单击按钮是否会自动在RDT中看到更改，就可以开始。在一些“添加1”点击后查看下一个截图以查看结果：
- en: '![](img/98090598-82a8-4e6b-b56b-6e7a7566f9e8.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98090598-82a8-4e6b-b56b-6e7a7566f9e8.png)'
- en: Whatever you do in the React application will be shown in the Developer Tools.
    In this example, I clicked six times on Add 1, and the updated component tree
    shows the new values
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您在React应用程序中所做的任何操作都将显示在开发工具中。在这个示例中，我点击了六次“添加1”，更新后的组件树显示了新值
- en: 'Most functions work the same way as in Chrome. You can search for a component
    by name, and if you right-click on a component, you get several options, including
    showing all the occurrences of the component''s name (as with the search) or copying
    its props; see the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数功能的工作方式与Chrome相同。您可以按名称搜索组件，如果右键单击组件，将获得多个选项，包括显示组件名称的所有出现（与搜索一样）或复制其属性；请参阅以下截图：
- en: '![](img/ab13863f-9c53-4bb8-b198-025b5f2a8276.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab13863f-9c53-4bb8-b198-025b5f2a8276.png)'
- en: The RDT let you get full information about any component
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: RDT让您获取有关任何组件的完整信息
- en: 'However, note that you won''t get *complete* values. For instance, in the preceding
    example, the copied props were as in the following code snippet; instead of a
    function, I got a string description:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，您将无法获得*完整*的值。例如，在前面的示例中，复制的属性如下代码片段所示；我得到了一个字符串描述，而不是一个函数：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another restriction is that you won't be able to use `$r` to directly access
    an object; this is beyond the tools' capabilities. However, if you are out of
    solutions for debugging, at least you'll be able to see the internal workings
    of your app, nothing to be dismissed out of hand!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个限制是您将无法使用`$r`直接访问对象；这超出了工具的能力。但是，如果您在调试时没有解决方案，至少您将能够看到应用程序的内部工作，这并不是可以随意忽视的！
- en: Logging Redux with redux-logger
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用redux-logger记录Redux
- en: One basic tool for debugging is the use of a logger. While JS already has enough
    logging features available (we already mentioned the `window.console` functions
    in the *Adding logging with Winston* section in [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml),
    *Testing and Debugging Your Server,* you will require some help in order to log
    the `Redux` actions, a key requirement. Certainly, you could add code before dispatching
    any action, but that would become too long-winded. Rather, we'll consider adding
    some middleware that will log all actions; even if we'll see better tools in the
    next *Debugging Redux with the Redux Developer Tools* section, this kind of log
    will prove quite useful. In this recipe, let's see how to add `redux-logger`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的一个基本工具是使用日志记录器。虽然JS已经有足够的日志记录功能可用（我们已经在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)的*使用Winston添加日志记录*部分中提到了`window.console`函数），但是您需要一些帮助来记录`Redux`的操作，这是一个关键要求。当然，您可以在分派任何操作之前添加代码，但那将变得太冗长。相反，我们将考虑添加一些中间件，以记录所有操作；即使我们将在接下来的*使用Redux开发者工具调试Redux*部分中看到更好的工具，这种日志也将非常有用。在这个示例中，让我们看看如何添加`redux-logger`。
- en: We have used middleware for thunks, but if you want to write your own middleware,
    you can find several examples (including a logging function) at [https://redux.js.org/advanced/middleware](https://redux.js.org/advanced/middleware).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了thunks的中间件，但是如果您想编写自己的中间件，您可以在[https://redux.js.org/advanced/middleware](https://redux.js.org/advanced/middleware)找到几个示例（包括日志函数）。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Our first step, as always, is to get the new tool. Installation is simple and
    straightforward, along the same lines we seen in most of the text:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们的第一步是获取新工具。安装简单明了，与大部分文本中看到的情况相同：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will install the new package, but you'll have to manually add it to your
    store creation code; by itself, the package won't have any effect.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装新的包，但您必须手动将其添加到您的存储创建代码中；单独使用该包不会产生任何效果。
- en: If you want to read more about the `redux-logger` features and capabilities,
    check out [https://github.com/evgenyrodionov/redux-logger](https://github.com/evgenyrodionov/redux-logger).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于`redux-logger`的功能和能力，请查看[https://github.com/evgenyrodionov/redux-logger](https://github.com/evgenyrodionov/redux-logger)。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Setting up `redux-logger` requires first creating a logger with the `createLogger()`
    function, which lets you select many options to customize the logged output, and
    then include the generated logger as middleware for `Redux`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`redux-logger`需要首先使用`createLogger()`函数创建一个记录器，该函数允许您选择许多选项来自定义记录的输出，然后将生成的记录器作为`Redux`的中间件包含。
- en: 'Out of the many available options, these are the most interesting:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多可用选项中，这些是最有趣的：
- en: '`colors` : If you wish to change how the output looks.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colors` : 如果您希望更改输出的外观。'
- en: '`diff:` : A Boolean flag to decide if you want to display the difference between
    the old state and the new state; there''s also a `diffPredicate(getState, action)`
    function that you can use to decide whether to display the differences.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`diff:` : 一个布尔标志，用于决定是否要显示旧状态和新状态之间的差异；还有一个`diffPredicate(getState, action)`函数，你可以用它来决定是否显示差异。'
- en: '`duration` : A Boolean flag to print how long it took to process an action;
    this would be interesting mainly in async actions'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration` : 一个布尔标志，用于打印处理操作所花费的时间；这主要在异步操作中会很有趣'
- en: '`predicate(getState, action)` : Can inspect the action and the current state,
    and return true or false to define whether the action should be logged or not;
    this is quite useful to restrict logging to, say, just a few action types.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`predicate(getState, action)` : 可以检查动作和当前状态，并返回true或false来定义是否应该记录动作；这对于限制日志记录到一些动作类型非常有用。'
- en: '`titleFormatter()`, `stateTransformer()`, `actionTransformer()`, and several
    other formatter functions.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`titleFormatter()`、`stateTransformer()`、`actionTransformer()`和其他几个格式化函数。'
- en: For the complete set of options, check out [https://github.com/evgenyrodionov/redux-logger](https://github.com/evgenyrodionov/redux-logger).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的选项集，请查看[https://github.com/evgenyrodionov/redux-logger](https://github.com/evgenyrodionov/redux-logger)。
- en: Setting up our counter application
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的计数器应用程序
- en: 'We''ll see how to use this logger with our counter application for the simplest
    possible case, and then with the regions browser, which will add thunks to the
    mix. You have to use the `applyMiddleware()` function (which we already saw in
    the *Doing async actions: redux-thunk* section in [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml),
    *Expanding Your Application*, when we started using `redux-thunk`) to add the
    logger to the process:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在最简单的情况下使用此记录器与我们的计数器应用程序，然后与区域浏览器一起使用，它将添加thunks到混合中。您必须使用`applyMiddleware()`函数（我们在*执行异步操作：redux-thunk*部分中已经看到了，当我们开始使用`redux-thunk`时，在[第8章](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml)中）将记录器添加到流程中：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Of course, you would probably want to enable this only for development, so
    the last line in the preceding snippet should rather be something like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可能只想在开发中启用这个功能，因此前面片段的最后一行应该是以下内容：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This sets the logger to access every single action that gets dispatched, and
    to log it including the differences between states and the processing time. We'll
    get to see how this works soon, but first let's take a look at our second application,
    which already had some middleware.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置记录器以访问每个分派的动作，并记录它，包括状态之间的差异和处理时间。我们很快就会看到这是如何工作的，但首先让我们看一下我们的第二个应用程序，它已经有一些中间件。
- en: Setting up our region application
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的区域应用程序
- en: 'When you want to apply two or more pieces of middleware, you have to specify
    in which order they will be applied. In our case, remembering that a thunk could
    either be an object (fine to list) or a function (that will get called to eventually
    produce an object) we have to place our logger right at the end of all possible
    middleware:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要应用两个或更多个中间件时，您必须指定它们将被应用的顺序。在我们的情况下，记住thunk可以是一个对象（fine to list）或一个函数（最终会被调用以产生一个对象），我们必须将我们的记录器放在所有可能的中间件的最后：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I decided to skip listing differences because we'd be getting lists that are
    a bit long (over 200 countries, for example) so output would have become too large.
    Let's now get to see how this logging works in practice.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定跳过列出差异，因为我们将得到一些有点长的列表（例如200多个国家），因此输出将变得太大。现在让我们看看这个日志是如何在实践中工作的。
- en: How it works…
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We set both our applications to log all actions, with no filtering; all we have
    to do is `npm start`, and the logger's output will appear in the web developer
    tools console.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个应用程序都设置为记录所有操作，没有过滤；我们只需要`npm start`，日志输出将出现在Web开发者工具控制台中。
- en: Logging the counter application
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录计数器应用程序
- en: 'The counter application is quite simple: the whole state had just two pieces
    of data (the current counter value and the number of clicks so far) so it''s easy
    to follow what happens during a test run; see the next screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器应用程序非常简单：整个状态只有两个数据（当前计数器值和到目前为止的点击次数），因此很容易跟踪测试运行期间发生的情况；请参见下一个屏幕截图：
- en: '![](img/4040d91b-4ca8-43af-b050-d5ba98a58b2e.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4040d91b-4ca8-43af-b050-d5ba98a58b2e.png)'
- en: A sample run of the counter application, but logging all actions with redux-logger
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器应用程序的一个示例运行，但使用redux-logger记录所有操作
- en: You can easily follow the test run, and you'll be able to see when we clicked
    each of the buttons which action was dispatched and the successive values of the
    store—if there were any problems with the reducer's logic, you'd probably find
    them easy to detect, given all the information that appears onscreen.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地跟踪测试运行，并且你将能够看到我们点击每个按钮时分派了哪个操作以及存储的连续值——如果在减速器的逻辑中有任何问题，你可能会发现它们很容易检测到，因为屏幕上显示了所有信息。
- en: Logging the region application
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录地区应用程序
- en: 'Our second application is more interesting, given that we are doing actual
    async requests, the amount of data to process is larger, and the screen display,
    while still a bit simple, is at least more complex than the counter display. When
    we start the application, the dropdown used an action to request the whole list
    of countries, as you can see in this screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个应用程序更有趣，因为我们正在进行实际的异步请求，要处理的数据量更大，而屏幕显示虽然仍然有点简单，但至少比计数器显示更复杂。当我们启动应用程序时，下拉菜单使用了一个操作来请求整个国家列表，正如你在这个截图中所看到的：
- en: '![](img/3e3c3471-b707-4727-af16-64443064975e.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e3c3471-b707-4727-af16-64443064975e.png)'
- en: The drop-down component dispatched an action to get the countries (countries:request),
    and it proved successful (countries:success) returning a list with 249 countries
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉组件分派了一个操作来获取国家（countries:request），并且证明成功（countries:success），返回了一个包含249个国家的列表
- en: 'After the countries were loaded, I decided to pick France (a very small homage
    to the FIFA Soccer World champions of 2018!), and some new actions were fired,
    as shown in the next screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 国家加载完毕后，我决定选择法国（对2018年FIFA足球世界杯冠军的一个小小的致敬！），然后一些新的操作被触发，如下一张截图所示：
- en: '![](img/7dab0e5a-6108-4a4d-ba75-5b641266a2d2.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dab0e5a-6108-4a4d-ba75-5b641266a2d2.png)'
- en: 'The results of picking a country: several actions were dispatched and the API
    was called'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 选择国家的结果：多个操作被分派并调用了API
- en: For the sake of a smaller display, I compacted the two first actions, and I
    could then expand the last one, showing the answer that was received from our
    own server. You can check that all regions are correctly displayed, though in
    alphabetic order, as we had sorted the list by name.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示更小，我压缩了前两个操作，然后扩展了最后一个操作，显示了从我们自己的服务器收到的答案。你可以检查所有地区是否正确显示，尽管按名称排序，因为我们已经按名称对列表进行了排序。
- en: With this logger, you have already a good tool to see what happens in the `React`+`Redux`
    applications—but we'll add yet another tool for a even better way of working.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个记录器，你已经有了一个很好的工具来查看`React`+`Redux`应用程序中发生的事情——但我们将添加另一个工具，以更好地工作。
- en: Debugging Redux with the Redux Developer Tools
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redux开发者工具调试Redux
- en: One of the best things to have if you are working with `React`+`Redux` are the
    `Redux` Developer Tools (or DevTools), which provide a console that lets you look
    into actions and, states, and even provide a "time machine" mode that allows you
    to go back and forth in time, so you can carefully check if everything's as it
    should be. In this recipe, let's see how to use this very powerful tool to help
    debug our code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`React`+`Redux`工作，最好的工具之一就是`Redux`开发者工具（或DevTools），它提供了一个控制台，让你查看操作和状态，甚至提供了一个“时光机”模式，让你可以来回穿梭，这样你就可以仔细检查一切是否如预期那样。在这个教程中，让我们看看如何使用这个非常强大的工具来帮助调试我们的代码。
- en: If you want to see Dan Abramov's demonstration of this tool, check out his talk
    at React Europe in 2015 at [https://www.youtube.com/watch?v=xsSnOQynTHs](https://www.youtube.com/watch?v=xsSnOQynTHs).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看Dan Abramov在2015年React Europe的演示，请查看他在[https://www.youtube.com/watch?v=xsSnOQynTHs](https://www.youtube.com/watch?v=xsSnOQynTHs)的演讲。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Installing the required `redux-devtools-extension` is easy, but be careful! Don''t
    confuse the `redux-devtools-extension` package, at [https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension),
    with `redux-devtools`, a similar but different package at [https://github.com/reduxjs/redux-devtools](https://github.com/reduxjs/redux-devtools).
    The latter is more of a "DIY" package, which requires plenty of configuration,
    though it will let you create a totally custom monitor for `Redux`, if you care
    to. For ourselves, this is what we need:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所需的`redux-devtools-extension`很容易，但要小心！不要混淆`redux-devtools-extension`包，位于[https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension)，与`redux-devtools`，一个类似但不同的包，位于[https://github.com/reduxjs/redux-devtools](https://github.com/reduxjs/redux-devtools)。后者更像是一个“自制”包，需要大量配置，尽管它可以让你为`Redux`创建一个完全定制的监视器，如果你愿意的话。对我们来说，这就是我们需要的：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will also want to install a Chrome extension, `Redux Devtools`, which works
    together with the package we just installed. This extension will add a new option
    to the web developer tools, as we'll see.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装一个Chrome扩展程序`Redux Devtools`，它与我们刚刚安装的包一起工作。这个扩展将在Web开发者工具中添加一个新选项，我们将看到。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you run the code, it will work exactly as before, but let's see how the added
    debugging functions work.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码，它将像以前一样工作，但让我们看看添加的调试功能是如何工作的。
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s fire up our region application, and then open the web developer tools
    and pick the Redux tab. You''ll get something like in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动我们的地区应用程序，然后打开Web开发者工具并选择Redux选项卡。你将得到类似下面截图的东西：
- en: '![](img/848f36e9-84ed-4eb2-bc94-bbf8ca07728d.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/848f36e9-84ed-4eb2-bc94-bbf8ca07728d.png)'
- en: 'Loading the application shows the initial state plus a couple of actions: the
    request for countries and the success of that request'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 加载应用程序会显示初始状态以及一些操作：请求国家和该请求的成功
- en: There are many features here. The following slider (you will have to click the
    clock icon on the bottom bar to see it) is probably the most interesting one,
    because it lets you go back and forth; try sliding it, and you'll see how the
    application changes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多功能。下面的滑块（你必须点击底部栏上的时钟图标才能看到）可能是最有趣的，因为它可以让你来回穿梭；尝试滑动它，你会看到应用程序的变化。
- en: 'For example, you could easily see how the screen looked when the country request
    action had been dispatched, but before the data came back; see the next screenshot.
    You''ll remember that in order to check this out, we had to add an artificial
    time delay before; now, you can examine the situation at will, with no need to
    add any special code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以轻松地看到当国家请求操作被分发时屏幕是什么样子的，但数据返回之前；请参见下一个截图。你会记得为了检查这个，我们不得不添加一个人为的时间延迟；现在，你可以随意检查情况，而无需添加任何特殊代码。
- en: '![](img/62796905-cfd8-495a-9794-8ea553c95e3f.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62796905-cfd8-495a-9794-8ea553c95e3f.png)'
- en: By using the slider, you can see how the application looked at any previous
    moment
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过滑块，你可以看到应用程序在任何以前的时刻是什么样子的
- en: 'If you select the Inspector option in the drop-down list at the top, you can
    examine actions and states. For example in the next screenshot, you can examine
    the action that was dispatched when the list of countries was retrieved from the
    server with all its data. You''ll notice that this kind of information is very
    similar to what the `Redux` logger package produced, but you can work with it
    in a more dynamic way:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在顶部的下拉列表中选择检查员选项，你可以检查操作和状态。例如，在下一个截图中，你可以检查当从服务器检索到国家列表及其所有数据时分发的操作。你会注意到这种信息与`Redux`日志记录器包生成的信息非常相似，但你可以以更动态的方式处理它。
- en: '![](img/d3f573f9-1e9d-498b-8596-51c2cf96c89c.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3f573f9-1e9d-498b-8596-51c2cf96c89c.png)'
- en: The Inspector feature lets you view actions (as here) and states, so you can
    inspect everything that happened
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 检查员功能让你查看操作（如此处）和状态，所以你可以检查发生的一切
- en: 'Let''s advance a bit; select France again, and we''ll see how the state changed
    after those regions came in. The Diff tab shows you only the differences in the
    state: in our case, the `loadingRegions` value was reset to false (it had been
    set to true when the request for region action was dispatched), and the list of
    regions got its values (all the regions of France). See the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再进一步；再次选择法国，我们将看到这些地区进来后状态发生了什么变化。Diff标签只显示状态中的差异：在我们的情况下，`loadingRegions`的值被重置为false（当请求地区操作被分发时，它被设置为true），地区列表得到了它的值（法国的所有地区）。请参见下一个截图。
- en: '![](img/85b81bbc-a823-4c88-8694-c84c74b7b8a7.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85b81bbc-a823-4c88-8694-c84c74b7b8a7.png)'
- en: The Diff tab lets you quickly see just the state changed attributes for a faster,
    simpler analysis
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Diff标签让你快速看到状态变化的属性，进行更快、更简单的分析
- en: We haven't gone through all functions, so go ahead and click everywhere to find
    what else is available. For example, the buttons on the left in the bottom bar
    let you open a separate window for debugging, so your screen won't get so cramped;
    another button lets you create and dispatch any action, so go ahead, try everything
    out!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有浏览所有的功能，所以继续点击各处，找到其他可用的功能。例如，底部栏左侧的按钮可以让你打开一个单独的调试窗口，这样你的屏幕就不会那么拥挤了；另一个按钮可以让你创建和分发任何操作，所以继续，尝试一切！
- en: You really should experiment with the tool to get a clear perspective on what
    you can achieve with it—and, in particular, try out the `time machine` function.
    You'll appreciate the fact that this kind of result is possible only because of
    the way in which `React` creates the view as a function of the state, but then
    you will eventually come to notice that something is missing; let's find out what
    is it, and how to fix it?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的应该尝试使用这个工具，以清晰地了解你可以通过它实现什么，特别是尝试`时光机`功能。你会欣赏到这种结果之所以可能，是因为`React`以状态的方式创建视图，但最终你会注意到缺少了什么；让我们找出是什么，以及如何修复它？
- en: Connecting routing for debugging
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接路由进行调试
- en: 'What did we miss? The simple applications we tried out in previous sections
    of this chapter didn''t include routing—but what would have happened if they did?
    The problem now is visible: whenever the user navigates to a new route, nothing
    in the state would keep track of that change, so the time machine functions wouldn''t
    really work. To solve this, we need to keep the router information in sync with
    the store, and that will restore full functionality to our debugging; let''s see
    here how to do that.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们错过了什么？我们在本章的前几节中尝试的简单应用程序没有包括路由——但如果包括了呢？问题现在显而易见：每当用户导航到新的路由时，状态中没有任何内容来跟踪这种变化，所以时光机功能实际上不会起作用。为了解决这个问题，我们需要让路由信息与存储同步，这样就能恢复我们的调试功能；让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'With previous versions of `react-router`, a `react-router-redux` package took
    care of linking the router and the state, but that package was recently deprecated
    and replaced by `connected-react-router`, which we''ll install. I''m mentioning
    this because there are many articles on the web that still show the usage of the
    former package; be careful:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的`react-router`版本中，一个`react-router-redux`包负责链接路由和状态，但该包最近已被弃用，由`connected-react-router`取而代之，我们将安装它。我提到这一点是因为网络上仍然有许多文章显示了前一个包的用法；要小心：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is half the solution; getting the package to work will (once more!) require
    changes in the store and in the structure of your application; let's see that.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解决方案的一半；让这个包工作将（再一次！）需要对存储和应用程序的结构进行更改；让我们看看。
- en: How to do it…
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: We want to modify our code so that the Redux time machine functionality will
    work. Let's use again the basic routing application we saw in the *Adding routing
    with react-router* section in [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml),
    *Expanding Your Application*; we had routing and also a login form that dispatched
    some actions, so we'll be able to see (on a very small scale, agreed!) all the
    kinds of things we  find in a normal application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想修改我们的代码，使Redux时光机功能能够工作。让我们再次使用我们在[第8章](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml)中看到的*使用react-router添加路由*部分中的基本路由应用程序；我们有路由，还有一个分发一些操作的登录表单，所以我们将能够（在非常小的范围内，同意！）看到在正常应用程序中找到的各种东西。
- en: 'There will be changes in two places: first, we''ll have to connect our store
    with a `history` object related to the router, and, second, we''ll have to add
    a component to our main code. The store changes are as follows—observe that we
    also added here our other debugging tools to match those in the rest of the chapter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将有两个地方发生变化：首先，我们将不得不将我们的存储与与路由器相关的`history`对象连接起来，其次，我们将不得不在我们的主代码中添加一个组件。存储更改如下-请注意，我们还在这里添加了与本章其余部分匹配的其他调试工具：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code is sort of obscure-looking, but basically:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来有点晦涩，但基本上：
- en: We create a `history` object, which we'll have to export because we'll need
    it later
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个`history`对象，我们需要导出它，因为我们以后会用到它
- en: We wrap our original `reducer` with `connectRouter()` to produce a new reducer
    that will be aware of the router state
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用`connectRouter()`包装我们原来的`reducer`，以生成一个新的`reducer`，它将意识到路由器状态
- en: We add `routerMiddleware(history)` to allow for routing methods like `push()`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了`routerMiddleware(history)`以允许像`push()`这样的路由方法
- en: 'Then we''ll have to add a `<ConnectedRouter>` component to our main JSX; this
    will require the history object that we created before:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将不得不在我们的主JSX中添加一个`<ConnectedRouter>`组件；这将需要我们之前创建的`history`对象：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Everything's set now; let's see how this works.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都设置好了；让我们看看这是如何工作的。
- en: For a fuller description of `connected-react-router`, check out its GitHub page
    at [https://github.com/supasate/connected-react-router](https://github.com/supasate/connected-react-router);
    in particular, you may be interested in the many articles listed near the bottom
    of the page with diverse tips and suggestions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`connected-react-router`的信息，请查看其GitHub页面[https://github.com/supasate/connected-react-router](https://github.com/supasate/connected-react-router)；特别是，您可能会对页面底部列出的许多文章中的各种提示和建议感兴趣。
- en: How it works…
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s start our application now, and don''t forget to run our server from
    [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml), *Implementing RESTful
    Services with Node*, as we did before. Opening the `Redux` DevTools, we see a
    single new action, `@@INIT`, and the state now includes a new router attribute;
    see the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们启动我们的应用程序，并不要忘记从[第4章](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml)运行我们的服务器，*使用Node实现RESTful服务*，就像我们以前做的那样。打开`Redux`
    DevTools，我们看到一个新的动作`@@INIT`，现在状态包括一个新的路由器属性；请参阅以下截图：
- en: '![](img/e01f59d1-f5d3-4a42-9807-cbcee3338a5c.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e01f59d1-f5d3-4a42-9807-cbcee3338a5c.png)'
- en: After connecting routing to the store, some new actions and state attributes
    appear
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将路由连接到存储后，会出现一些新的动作和状态属性
- en: 'If we click on Alpha..., we''ll see that two actions were dispatched: the first
    attempted to access `/alpha`, and the second was our redirection to the `/login`
    page, as shown in this screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击Alpha…，我们会看到有两个动作被分派：第一个尝试访问`/alpha`，第二个是我们重定向到`/login`页面，如下截图所示：
- en: '![](img/b11bbd6d-5992-4c1d-b2d2-256d78e4fecb.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11bbd6d-5992-4c1d-b2d2-256d78e4fecb.png)'
- en: Attempting to access a protected route redirects us to the login page
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问受保护的路由会将我们重定向到登录页面
- en: 'After entering user and password, we see our login:request and login:success
    actions—as we have seen since we enabled the `Redux` Developer Tools—followed
    by another action, corresponding to the redirection to the `/alpha` page appears
    after as shown in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 输入用户名和密码后，我们看到我们的login:request和login:success动作-就像我们启用`Redux`开发者工具以来看到的那样-然后是另一个动作，对应于重定向到`/alpha`页面，如下截图所示：
- en: '![](img/8acb7fa1-5e29-474b-86fb-db859607bc33.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8acb7fa1-5e29-474b-86fb-db859607bc33.png)'
- en: Our own actions are intermixed with the router actions
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的动作与路由器动作交织在一起
- en: 'But, now the time machine functionality is enabled for routing as well; for
    example, if you move the slider back to the beginning, you''ll see the home page
    again, and you can go back and forth, and the view will appropriately reflect
    everything you had earlier seen; check the next screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，现在时间机器功能也对路由启用了；例如，如果您将滑块移回到开头，您将再次看到主页，并且您可以来回移动，视图将适当地反映您之前看到的一切；请查看下一个截图：
- en: '![](img/9b15fe95-47a8-49eb-8f22-96a22251408f.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b15fe95-47a8-49eb-8f22-96a22251408f.png)'
- en: Having connected the router to the state, now we can use the slider to go back
    and see the correct pages every time
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 连接了路由器到状态后，现在我们可以使用滑块返回并每次看到正确的页面
- en: We now have a good set of debugging tools; let's move on to do automatic testing,
    as we earlier did with `Node`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一套很好的调试工具；让我们继续进行自动测试，就像我们之前在`Node`中做的那样。
