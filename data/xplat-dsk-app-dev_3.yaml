- en: Creating a Chat System with Electron and React – Planning, Designing, and Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Electron和React创建聊天系统-规划、设计和开发
- en: In the previous chapters, we worked with NW.js. It's a great framework, but
    not the only one on the market. Its counterpart Electron isn't inferior to NW.js
    in feature set and has an even larger community. To make the right choice of what
    fits best, I assume that one has to try both frameworks. So, our next example
    application will be a simple chat system and we will do it with Electron. We made
    the file explorer in plain JavaScript. We had to take care of abstractions consistency,
    data binding, templating, and such. In fact, we can delegate these tasks to a
    JavaScript framework. At the time of writing, the three solutions--React, Vue,
    and Angular--head the short list, where React seems like the most trending. I
    find it as a best fit for our next application. So, we will look into the essentials
    of React. We will set up Electron and webpack for our React-based application.
    We will not write all the CSS styles manually this time, but will use PhotonKit
    markup components. Finally, we will build the chat static prototype using React
    components and get ready to make it functional.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们使用了NW.js。这是一个很棒的框架，但并不是市场上唯一的一个。它的对手Electron在功能集方面并不逊色于NW.js，并且拥有更大的社区。为了做出最合适的选择，我认为必须尝试这两个框架。因此，我们下一个示例应用将是一个简单的聊天系统，我们将使用Electron来实现它。我们用纯JavaScript制作了文件浏览器。我们必须注意抽象的一致性，数据绑定，模板等。事实上，我们可以将这些任务委托给JavaScript框架。在撰写本文时，React、Vue和Angular这三种解决方案处于短列表的前列，其中React似乎是最流行的。我认为它最适合我们下一个应用。因此，我们将深入了解React的基本知识。我们将为基于React的应用程序设置Electron和webpack。这次我们不会手动编写所有的CSS样式，而是会使用PhotonKit标记组件。最后，我们将使用React组件构建聊天静态原型，并准备使其功能化。
- en: Application blueprint
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用蓝图
- en: 'In order to describe our application requirements, the same as previously,
    we start with user stories:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述我们的应用需求，与之前一样，我们从用户故事开始：
- en: As a user, I can introduce myself to the chat
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以向聊天室介绍自己
- en: As a user, I can see real time the list of chat participants
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以实时看到聊天参与者的列表
- en: As a user, I can enter and submit a message
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以输入并提交消息
- en: As a user, I can see messages of chat participants as they are coming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以看到聊天参与者的消息随着它们的到来
- en: 'If putting it onto wireframes, the first screen will be a simple prompt for
    a username:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将其放在线框上，第一个屏幕将是一个简单的用户名提示：
- en: '![](img/872ea775-d606-4586-90b1-e152dcea185b.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/872ea775-d606-4586-90b1-e152dcea185b.png)'
- en: 'The second screen contains a sidebar with participants and the main area with
    the conversation thread and a form to submit a message:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个屏幕包含一个带有参与者的侧边栏和一个包含对话线程和提交消息表单的主区域：
- en: '![](img/7617af7f-bbad-4525-840e-ef12a17997bb.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7617af7f-bbad-4525-840e-ef12a17997bb.png)'
- en: The second screen shares header and footer with the first one, but the main
    section consists of a participant list (on the left) and chat pane (on the right).
    The chat pane comprises incoming messages and submission form.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个屏幕与第一个屏幕共享标题和页脚，但主要部分包括参与者列表（左侧）和聊天窗格（右侧）。聊天窗格包括传入消息和提交表单。
- en: Electron
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Electron
- en: We have already become acquainted with NW.js. As you likely know, there is an
    alternative to it called Electron ([https://electron.atom.io/](https://electron.atom.io/)).
    By and large, both provide comparable feature sets ([http://bit.ly/28NW0iX](http://bit.ly/28NW0iX)).
    On the other hand, we can observe that Electron has a larger and much more active
    community ([https://electron.atom.io/community/](https://electron.atom.io/community/)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了NW.js。你可能知道，它有一个叫做Electron的替代品（[https://electron.atom.io/](https://electron.atom.io/)）。总的来说，两者提供了可比较的功能集（[http://bit.ly/28NW0iX](http://bit.ly/28NW0iX)）。另一方面，我们可以观察到Electron拥有一个更大、更活跃的社区（[https://electron.atom.io/community/](https://electron.atom.io/community/)）。
- en: Electron is also known to be the GUI framework behind notable open source projects,
    such as Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    and Atom IDE ([https://atom.io/](https://atom.io/)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Electron也是一些知名开源项目的GUI框架，比如Visual Studio Code（[https://code.visualstudio.com/](https://code.visualstudio.com/)）和Atom
    IDE（[https://atom.io/](https://atom.io/)）。
- en: From a developer perspective, the first difference one faces is that Electron's
    entry point is a JavaScript, unlike HTML in NW.js. As we launch an Electron application,
    the framework runs first the specified script (main process). The script creates
    the application window. Electron provides API split in modules. Some of them are
    available only for the main process, some for renderer processes (any scripts
    requested from web pages originated by the main script).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，我们面临的第一个区别是，Electron的入口点是JavaScript，而不是NW.js中的HTML。当我们启动一个Electron应用程序时，框架首先运行指定的脚本（主进程）。该脚本创建应用程序窗口。Electron提供了分成模块的API。其中一些只适用于主进程，一些适用于渲染进程（由主脚本发起的网页请求的任何脚本）。
- en: 'Let''s put this into practice. First of all, we will create the `./package.json`
    manifest file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们付诸实践。首先，我们将创建`./package.json`清单文件：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On the whole, this manifest doesn't differ much from the one we created in previous
    chapters for NW.js. Yet, we do not need the `window` field here and field `main`
    points at the main process script.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个清单与我们在之前的章节中为NW.js创建的清单并没有太大的区别。然而，我们这里不需要`window`字段，`main`字段指向主进程脚本。
- en: As for dependencies, we obviously need `electron`, and in addition, we will
    use the `electron-debug` package, which activates hotkeys *F12* and *F5* for DevTools
    and reload, respectively ([https://github.com/sindresorhus/electron-debug](https://github.com/sindresorhus/electron-debug)).
    We also include Electron's DevTools Extension, called Devtron ([https://electron.atom.io/devtron](https://electron.atom.io/devtron)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 至于依赖关系，显然我们需要`electron`，此外，我们还将使用`electron-debug`包，它激活了热键*F12*和*F5*，分别用于DevTools和重新加载（[https://github.com/sindresorhus/electron-debug](https://github.com/sindresorhus/electron-debug)）。我们还包括了Electron的DevTools扩展，称为Devtron（[https://electron.atom.io/devtron](https://electron.atom.io/devtron)）。
- en: 'Now, we can edit the main process script:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编辑主进程脚本：
- en: '`./app/main.js`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/main.js`'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we import `app` and `BrowserWindow` from the `electron` module. The first
    one allows us to subscribe to application lifecycle events. With the second, we
    create and control the browser window. We also obtain references to NPM modules
    `path` and `url`. The first helps to create platform-agnostic paths and the second
    helps in building a valid URL. In the last line, we declare a global reference
    for the browser window instance. Next, we will add a function that creates the
    browser window:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`electron`模块导入`app`和`BrowserWindow`。第一个允许我们订阅应用程序生命周期事件。通过第二个，我们创建和控制浏览器窗口。我们还获得了对NPM模块`path`和`url`的引用。第一个帮助创建与平台无关的路径，第二个帮助构建有效的URL。在最后一行，我们声明了浏览器窗口实例的全局引用。接下来，我们将添加一个创建浏览器窗口的函数：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Actually, the function just creates a window instance and loads `index.html`
    in it. When the window is closed, the reference to the window instance gets destroyed.
    Further, we subscribe for application events:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，该函数只是创建一个窗口实例并在其中加载`index.html`。当窗口关闭时，对窗口实例的引用将被销毁。此外，我们订阅应用程序事件：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The application event `"ready"` is fired when Electron finishes initialization;
    then we create the browser window.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序事件`"ready"`在Electron完成初始化时触发；然后我们创建浏览器窗口。
- en: The `window-all-closed` event is emitted when all the windows are closed. For
    any platform but macOS, we quit the application. OS X applications usually stay
    active until the user quit explicitly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有窗口都关闭时，将触发`window-all-closed`事件。对于除macOS之外的任何平台，我们都会退出应用程序。OS X应用程序通常会保持活动状态，直到用户明确退出。
- en: The `activate` event gets triggered only on macOS. In particular, it happens
    when we click on the application's dock or taskbar icon. If no window exists at
    that moment, we create a new one.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`activate`事件只在macOS上触发。特别是，当我们单击应用程序的Dock或任务栏图标时会发生这种情况。如果此时没有窗口存在，我们将创建一个新窗口。'
- en: 'Finally, we call `electron-debug` to activate the debug hotkeys:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`electron-debug`来激活调试热键：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we launch Electron now, it will try loading `index.html`, which we have
    to create first:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在启动Electron，它将尝试加载我们首先要创建的`index.html`：
- en: '`./app/index.html`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/index.html`'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Nothing exciting is happening here. We just declared several placeholders and
    loaded a renderer process script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么激动人的事情发生。我们只是声明了几个占位符并加载了一个渲染器进程脚本：
- en: '`./app/renderer.js`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/renderer.js`'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the renderer script, we read `package.json` into the `manifest` constant.
    We define a dictionary object to map the `process.platform` keys to meaningful
    platform names. We add a helper function, `write`, which assigns a given text
    to the element matching the given ID. Using this function, we populate the placeholders
    of the HTML.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器脚本中，我们将`package.json`读入`manifest`常量中。我们定义一个字典对象，将`process.platform`键映射到有意义的平台名称。我们添加一个辅助函数`write`，它将给定的文本分配给与给定ID匹配的元素。使用这个函数，我们填充HTML的占位符。
- en: 'At this point, we are expected to have the following file structure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们预期有以下文件结构：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we install dependencies (`npm i`) and run the (`npm start`) example. We
    will see the following window:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们安装依赖项（`npm i`）并运行（`npm start`）示例。我们将看到以下窗口：
- en: '![](img/92bb3b20-5293-4618-bea5-fb4a58f4475e.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92bb3b20-5293-4618-bea5-fb4a58f4475e.png)'
- en: React
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React
- en: React is gaining momentum. It is the most trending technology, according to
    the 2016 Stack Overflow developer survey ([http://stackoverflow.com/insights/survey/2016#technology](http://stackoverflow.com/insights/survey/2016#technology)).
    It is interesting to note that React is not even a framework. It's a JavaScript
    library for building user interfaces--very clean, concise, and powerful. The library
    implements the component-driven architecture. So, we create components (reusable,
    composable, and stateful units of UI) and then use them like Lego blocks to construct
    the intended UI. React treats the derived structure as an in-memory DOM representation
    (virtual DOM). As we bind it to the real DOM, React keeps both in sync, meaning
    that whenever any of its components change their states, React immediately reflects
    the view changes in the DOM.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: React正在蓬勃发展。根据2016年Stack Overflow开发者调查，它是最流行的技术（[http://stackoverflow.com/insights/survey/2016#technology](http://stackoverflow.com/insights/survey/2016#technology)）。有趣的是，React甚至不是一个框架。它是一个用于构建用户界面的JavaScript库--非常干净、简洁和强大。该库实现了基于组件的架构。因此，我们创建组件（可重用、可组合和有状态的UI单元），然后像乐高积木一样使用它们来构建预期的UI。React将派生结构视为内存中的DOM表示（虚拟DOM）。当我们将其绑定到真实的DOM时，React会保持两者同步，这意味着每当其组件之一改变其状态时，React会立即在DOM中反映视图的变化。
- en: Besides that, we can convert virtual DOM in the HTML string ([http://bit.ly/2oVsjVn](http://bit.ly/2oVsjVn))
    on the server side and send it with an HTTP response. The client side will automatically
    bind to the already existing HTML. Thus, we speed up page loading and allow search
    engines to crawl the content.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们可以在服务器端将虚拟DOM转换为HTML字符串（[http://bit.ly/2oVsjVn](http://bit.ly/2oVsjVn)），并通过HTTP响应发送它。客户端将自动绑定到已存在的HTML。因此，我们加快页面加载速度，并允许搜索引擎抓取内容。
- en: 'In a nutshell, the component is a function that takes in given properties and
    returns an element, where an element is a plain object representing a component
    or a DOM node. Alternatively, one can use a class extending `React.Component`,
    whose `render` method produces the element:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，组件是一个接受给定属性并返回一个元素的函数，其中元素是表示组件或DOM节点的普通对象。或者，可以使用扩展`React.Component`的类，其`render`方法产生元素：
- en: '![](img/677f98bb-ac86-41a2-9d1a-2a304acec881.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/677f98bb-ac86-41a2-9d1a-2a304acec881.png)'
- en: 'To create an Element, one can go with the API. Yet, nowadays, as a rule, it''s
    not used directly, but via syntactic sugar known as **JSX**. JSX extends JavaScript
    with a new type that looks like an HTML template:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个元素，可以使用API。然而，如今，通常不直接使用，而是通过被称为**JSX**的语法糖。JSX用一个看起来像HTML模板的新类型扩展了JavaScript：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Basically, we write HTML straight in JavaScript and JavaScript in HTML. JSX
    can be translated to plain JavaScript using the Babel compiler with preset `react`
    ([https://babeljs.io/docs/plugins/preset-react/](https://babeljs.io/docs/plugins/preset-react/)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们直接在 JavaScript 中编写 HTML，而在 HTML 中编写 JavaScript。JSX 可以使用 Babel 编译器和预设 `react`（[https://babeljs.io/docs/plugins/preset-react/](https://babeljs.io/docs/plugins/preset-react/)）转换为普通的
    JavaScript。
- en: Most of the modern IDEs support JSX syntax from the box.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代 IDE 都支持 JSX 语法。
- en: 'To have a better understanding, we fiddle a bit with React. A function-based
    component might look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们稍微调整了一下 React。一个基于函数的组件可能如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, we declare a `Header` component that generates an element representing
    a header with a heading populated from the `title` property. We can also go with
    a class. Thus, we can encapsulate component-related methods in the class scope:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们声明了一个 `Header` 组件，它生成一个表示标题的元素，标题由 `title` 属性填充。我们也可以使用类。因此，我们可以将组件相关的方法封装在类范围内：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This component creates a button and provides it with a minimalistic functionality
    (when the button is clicked, we get an alert box with the Clicked! text).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件创建一个按钮，并为其提供了最简单的功能（当单击按钮时，我们会收到一个带有“Clicked！”文本的警报框）。
- en: 'Now, we can attach our components to the DOM, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的组件附加到 DOM，如下所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can note, components imply a unidirectional flow. You can pass properties
    from parent to child, but not otherwise. Properties are immutable. When we need
    to communicate from a child, we lift the state up:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，组件意味着单向流动。您可以从父级向子级传递属性，但反之则不行。属性是不可变的。当我们需要从子级通信时，我们将状态提升：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `render` method of the `List` component, we have an array of names. Using
    the `map` array prototype method, we iterate through the name list. The method
    results in an array of elements, which JSX accepts gladly. While declaring `Item`,
    we pass in the current `name` and `onItemSelected` handler bound to the list instance
    scope. The `Item` component renders `<li>` and subscribes the passed-in handler
    to click events. Therefore, events of a child component are handled by the parent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `List` 组件的 `render` 方法中，我们有一个名称数组。使用 `map` 数组原型方法，我们遍历名称列表。该方法会产生一个元素数组，JSX
    会欣然接受。在声明 `Item` 时，我们传入当前的 `name` 和绑定到列表实例范围的 `onItemSelected` 处理程序。`Item` 组件呈现
    `<li>` 并订阅传入的处理程序以处理单击事件。因此，子组件的事件由父组件处理。
- en: Electron meets React
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Electron meets React
- en: 'Now, we have an idea about both Electron and React. What about on how to use
    them together? To get a grasp on it, we will start not with our real application,
    but with a simple, similar example. It will include a few components and a form.
    The application will reflect user input in the window title. I suggest cloning
    our last example. We can reuse the manifest and main process script. However we
    have to bring the following changes to the manifest:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对 Electron 和 React 都有了一些了解。那么如何将它们一起使用呢？为了更好地理解，我们将不从我们的真实应用程序开始，而是从一个简单的类似示例开始。它将包括一些组件和一个表单。该应用程序将在窗口标题中反映用户输入。我建议克隆我们上一个示例。我们可以重用清单和主进程脚本。但是我们必须对清单进行以下更改：
- en: '`./package.json`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ./package.json
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, we add the `react` and `react-dom` modules. The first
    is the library core and the second serves as a glue between React and DOM. The
    `prop-types` module brings us type-checking abilities (till React v.15.5, which
    was a built-in object of the library). We add `webpack` as a dev-dependency in
    addition to electron-specific modules. Webpack is a module bundler that takes
    in varying types (sources, images, markup, and CSS) of assets and produces a bundle(s)
    that can be loaded by the client. We will use webpack to bundle our React/JSX-based
    application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们添加了 `react` 和 `react-dom` 模块。第一个是库的核心，第二个用作 React 和 DOM 之间的粘合剂。`prop-types`
    模块为我们带来了类型检查能力（直到 React v.15.5，这是库的内置对象）。除了特定于 electron 的模块，我们还将 `webpack` 添加为开发依赖项。Webpack
    是一个模块打包工具，它接受各种类型（源代码、图像、标记和 CSS）的资产，并生成客户端可以加载的包。我们将使用 webpack 来打包基于 React/JSX
    的应用程序。
- en: However, webpack doesn't transpile JSX its own; it uses the Babel compiler (`babel-core`).
    We also include the `babel-loader` module, which bridges between webpack and Babel.
    The `babel-preset-react` module is a so-called Babel preset (a set of plugins)
    that allows Babel to deal with JSX. With the `babel-preset-es2017` preset, we
    make Babel compile our ES2017-compliant code into ES2016, which is greatly supported
    by Electron. What is more, I included the `babel-plugin-transform-class-properties`
    Babel plugin to unlock features of the proposal called ES Class Fields & Static
    Properties ([https://github.com/tc39/proposal-class-public-fields](https://github.com/tc39/proposal-class-public-fields)).
    So, we will be able to define class properties directly without the help of a
    constructor, which did not yet land to the specification.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，webpack 本身不会转译 JSX；它使用 Babel 编译器（`babel-core`）。我们还包括 `babel-loader` 模块，它在
    webpack 和 Babel 之间建立桥梁。`babel-preset-react` 模块是所谓的 Babel 预设（一组插件），它允许 Babel 处理
    JSX。通过 `babel-preset-es2017` 预设，我们让 Babel 将符合 ES2017 的代码编译为 ES2016，这是 Electron
    极大支持的。此外，我还包括了 `babel-plugin-transform-class-properties` Babel 插件，以解锁名为 ES Class
    Fields & Static Properties 的提案的功能（[https://github.com/tc39/proposal-class-public-fields](https://github.com/tc39/proposal-class-public-fields)）。因此，我们将能够直接定义类属性，而无需构造函数的帮助，这在规范中尚未出现。
- en: There are two extra commands in the scripts section. The `build` command bundles
    JavaScript for the client. The `dev` command sets webpack in a watch mode. So,
    whenever we change any of the sources, it automatically bundles the application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本部分有两个额外的命令。`build` 命令用于为客户端打包 JavaScript。`dev` 命令将 webpack 设置为监视模式。因此，每当我们更改任何源代码时，它会自动打包应用程序。
- en: 'Before using webpack, we will need to configure it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 webpack 之前，我们需要对其进行配置：
- en: '`./webpack.config.js`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`./webpack.config.js`'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We set `app/renderer.jsx` as the entry point. So, webpack will read it first
    and resolve any met dependencies recursively. The compiled bundle can be found
    then in `app/build/renderer.js`. So far, we have set the only rule for webpack:
    every met `.js` or `.jsx` file with the exception of the `node_modules` directory
    goes to Babel, which is configured for the `es2017` and `react` presets (and the
    `transform-class-properties` plugin, to be precise). So, if we run now, the `npm
    run build` webpack will try compiling `app/renderer.jsx` into `app/build/renderer.js`,
    which we call from the HTML.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`app/renderer.jsx`设置为入口点。因此，webpack将首先读取它并递归解析任何遇到的依赖关系。然后编译后的捆绑包可以在`app/build/renderer.js`中找到。到目前为止，我们已经为webpack设置了唯一的规则：每个遇到的`.js`或`.jsx`文件（除了`node_modules`目录）都会经过Babel处理，Babel配置了`es2017`和`react`预设（以及`transform-class-properties`插件，确切地说）。因此，如果我们现在运行`npm
    run build`，webpack将尝试将`app/renderer.jsx`编译成`app/build/renderer.js`，然后我们可以在HTML中调用它。
- en: 'The code for the `./app/index.html` file is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/index.html`文件的代码如下：'
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The main renderer script may look as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 主渲染器脚本可能如下所示：
- en: '`./app/renderer.jsx`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/renderer.jsx`'
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we import two components--`Header` and `Copycat`--and use them in a composite
    one, which we bind to the DOM custom element, `<app>`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了两个组件--`Header`和`Copycat`--并在一个复合组件中使用它们，然后将其绑定到DOM自定义元素`<app>`。
- en: 'The following is the first component we describe with a function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们用函数描述的第一个组件：
- en: '`./app/Components/Header.jsx`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/Components/Header.jsx`'
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The function in the preceding code takes one property--`title` (we passed it
    in the parent component, `<Header />`)--and renders it as a heading.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的函数接受一个属性--`title`（我们在父组件`<Header />`中传递了它），并将其呈现为标题。
- en: Note that we use `PropTypes` to validate the `title` property value. If we happen
    to set a value other than string to `title`, a warning will be shown in the JavaScript
    console.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`PropTypes`来验证`title`属性的值。如果我们设置`title`以外的其他值，将在JavaScript控制台中显示警告。
- en: 'The following second component is presented with a class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用类呈现的第二个组件：
- en: '`./app/Components/Copycat.jsx`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/Components/Copycat.jsx`'
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This component renders an input field. Whatever one is typing in the field
    gets reflected in the window title. Here, I have set a goal to show a new concept:
    children components/nodes.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件呈现一个输入字段。在字段中输入的任何内容都会反映在窗口标题中。在这里，我设定了一个目标，展示一个新概念：子组件/节点。
- en: 'Do you remember we declared `Copycat` with children nodes in the parent component?
    The code for the `Copycat` element is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在父组件中声明了带有子节点的`Copycat`吗？`Copycat`元素的代码如下：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we receive these list items in `this.props.children` and render them within
    `<ul>`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`this.props.children`中接收这些列表项，并在`<ul>`中呈现它们。
- en: Besides this, we subscribe a `this.onChange` handler for change events on the
    input element. As it changes, we obtain a current window instance from the remote
    function of electron (`remote.getCurrentWindow()`) and replace its title with
    input contents.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们为输入元素订阅了一个`this.onChange`处理程序。当它改变时，我们从electron的远程函数中获取当前窗口实例（`remote.getCurrentWindow()`），并用输入内容替换其标题。
- en: 'To see what we''ve got, we install dependencies using `npm i`, build the project
    using `npm run build`, and launch the application using `npm start`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看我们得到了什么，我们使用`npm i`安装依赖项，使用`npm run build`构建项目，并使用`npm start`启动应用程序：
- en: '![](img/d698f325-f598-4ac2-b005-b6f6e823b971.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d698f325-f598-4ac2-b005-b6f6e823b971.png)'
- en: Enabling DevTools extensions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用DevTools扩展
- en: I believe that you had no problems when running the last example. Yet, when
    we need to trace an issue in a React application, it can be tricky, as DevTools
    shows us what is happening to the real DOM; however, we want to know about the
    virtual one also. Fortunately, Facebook offers an extension for DevTools called
    React Developer Tools ([http://bit.ly/1dGLkxb](http://bit.ly/1dGLkxb)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你在运行上一个示例时没有遇到问题。然而，当我们需要跟踪React应用程序中的问题时，可能会有些棘手，因为DevTools向我们展示的是真实DOM发生的事情；然而，我们也想了解虚拟DOM的情况。幸运的是，Facebook提供了一个名为React
    Developer Tools的DevTools扩展（[http://bit.ly/1dGLkxb](http://bit.ly/1dGLkxb)）。
- en: 'We will install this extension with electron-devtools-installer ([https://www.npmjs.com/package/electron-devtools-installer](https://www.npmjs.com/package/electron-devtools-installer)).
    This tool supports a number of DevTools extensions including a few React-related:
    React Developer Tools (`REACT_DEVELOPER_TOOLS`), Redux DevTools Extension (`REDUX_DEVTOOLS`),
    React Perf (`REACT_PERF`). We will pick only the first one for now.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用electron-devtools-installer（[https://www.npmjs.com/package/electron-devtools-installer](https://www.npmjs.com/package/electron-devtools-installer)）来安装此扩展。该工具支持多个DevTools扩展，包括一些与React相关的：React
    Developer Tools（`REACT_DEVELOPER_TOOLS`），Redux DevTools Extension（`REDUX_DEVTOOLS`），React
    Perf（`REACT_PERF`）。我们现在只选择第一个。
- en: 'First we install the package:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们安装包：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then we add to the main process script the following line:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在主进程脚本中添加以下行：
- en: '`./app/main.js`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/main.js`'
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We imported from the package `installExtension` function and `REACT_DEVELOPER_TOOLS`
    constant, which represents React Developer Tools . Now we can call the function
    as soon as application is ready. On this event we already invoke our `createWindow`
    function. So we can extend the function rather than subscribe again for the event:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从包中导入了`installExtension`函数和`REACT_DEVELOPER_TOOLS`常量，它代表React Developer Tools。现在我们可以在应用程序准备就绪时调用该函数。在此事件上，我们已经调用了我们的`createWindow`函数。因此，我们可以扩展该函数，而不是再次订阅该事件：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, when I launch the application and open `DevTools` (*F12*), I can see a
    new tab, `React`, which brings me to the corresponding panel. Now, it is possible
    to navigate through the React component tree, select its nodes, and inspect the
    corresponding components, edit its props, and state:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我启动应用程序并打开`DevTools`（*F12*）时，我可以看到一个新的选项卡`React`，它将我带到相应的面板。现在，可以浏览React组件树，选择其节点，并检查相应的组件，编辑其props和state：
- en: '![](img/c6f12021-9f7e-4068-8e81-0ab6fdbd9a92.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6f12021-9f7e-4068-8e81-0ab6fdbd9a92.png)'
- en: Static prototype
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态原型
- en: At this point, we are quite ready to start with the chat application. Yet, it
    will be easier to grasp if we create first a static version and then extend it
    with the intended functionality. Nowadays, developers often do not write CSS from
    scratch, but reuse components of HTML/CSS frameworks such as Bootstrap. There
    is a framework dedicated for the Electron application--**Photonkit** ([http://photonkit.com](http://photonkit.com)).
    This framework provides us with building blocks such as layouts, panes, sidebar,
    lists, buttons, forms, table, and buttons. A UI constructed of these blocks looks
    in the style of macOS, automatically adapted for Electron and responsive to its
    viewport size. Ideally, I would go with ready PhotonKit components built with
    React ([http://react-photonkit.github.io](http://react-photonkit.github.io)),
    but we will do it with HTML. I want to show you how you can incorporate an arbitrary
    third-party CSS framework on the example of PhotonKit.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经准备好开始使用聊天应用程序了。然而，如果我们先创建一个静态版本，然后再扩展它以实现预期的功能，那么理解起来会更容易。如今，开发人员通常不会从头开始编写CSS，而是重用HTML/CSS框架（如Bootstrap）的组件。有一个专门为Electron应用程序设计的框架——**Photonkit**（[http://photonkit.com](http://photonkit.com)）。该框架为我们提供了诸如布局、窗格、侧边栏、列表、按钮、表单、表格和按钮等构建块。由这些块构建的UI看起来像macOS风格，自动适应Electron并响应其视口大小。理想情况下，我会选择使用React构建的现成的PhotonKit组件（[http://react-photonkit.github.io](http://react-photonkit.github.io)），但我们将使用HTML来完成。我想向您展示如何在PhotonKit示例中引入任意第三方CSS框架。
- en: 'First, we install it with NPM:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用NPM安装它：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What we really need from the package is CSS and fonts files from the `dist`
    subfolder. The only truly reliable way to access the package content from the
    application is the require function ([http://bit.ly/2oGu0Vn](http://bit.ly/2oGu0Vn)).
    It''s clear how to request JavaScript or JSON files, but what about other types,
    for example, CSS? With webpack, we can bundle theoretically any content. We just
    need to specify the corresponding loaders in the webpack configuration file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从包中真正需要的是`dist`子文件夹中的CSS和字体文件。从应用程序中访问包内容的唯一可靠方式是使用require函数（[http://bit.ly/2oGu0Vn](http://bit.ly/2oGu0Vn)）。请求JavaScript或JSON文件很明显，但其他类型的文件呢，例如CSS呢？使用webpack，我们理论上可以捆绑任何内容。我们只需要在webpack配置文件中指定相应的加载器：
- en: '`./webpack.config.js`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`./webpack.config.js`'
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We extended webpack configuration with a new rule that matches any files with
    extension `css`. Webpack will process such files with `style-loader` and `css-loader`.
    The first one reads the requested file and adds it to the DOM by injecting a style
    block. The second brings to the DOM any assets requested with `@import` and `url()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个新规则扩展了webpack配置，该规则匹配任何扩展名为`css`的文件。Webpack将使用`style-loader`和`css-loader`处理这些文件。第一个读取请求的文件，并通过注入样式块将其添加到DOM中。第二个将使用`@import`和`url()`请求的任何资源带到DOM中。
- en: 'After enabling this rule, we can load Photon styles directly in a JavaScript
    module:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此规则后，我们可以直接在JavaScript模块中加载Photon样式：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, the custom fonts used in this CSS still won''t be available. We can
    fix it by further extending the webpack configuration:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此CSS中使用的自定义字体仍然不可用。我们可以通过进一步扩展webpack配置来解决这个问题：
- en: '`./webpack.config.js`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`./webpack.config.js`'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This rule aims for font files and exploits `file-loader`, which takes the requested
    file from the package, stores it locally, and returns the newly created local
    path.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则旨在处理字体文件，并利用`file-loader`，它从包中获取请求的文件，将其存储在本地，并返回新创建的本地路径。
- en: So, given that the styles and fonts are handled by webpack, we can proceed with
    components. We will have two components representing the window header and footer.
    For the main section, we will use `Welcome` when the user has not yet provided
    any name, and `ChatPane` afterward. The second one is a layout for `Participants`
    and `Conversation` components. We will also have a root component, `App`, that
    connects all other components with the future chat services. Actually, this one
    works not like a presentational component, but as a container ([http://redux.js.org/docs/basics/UsageWithReact.html](http://redux.js.org/docs/basics/UsageWithReact.html)).
    So, we are going to keep it separate from others.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，鉴于样式和字体由webpack处理，我们可以继续处理组件。我们将有两个组件代表窗口的标题和页脚。对于主要部分，当用户尚未提供任何名称时，我们将使用`Welcome`，之后使用`ChatPane`。第二个是`Participants`和`Conversation`组件的布局。我们还将有一个根组件`App`，它将所有其他组件与未来的聊天服务连接起来。实际上，这个组件不像一个展示性组件那样工作，而是作为一个容器（[http://redux.js.org/docs/basics/UsageWithReact.html](http://redux.js.org/docs/basics/UsageWithReact.html)）。因此，我们将它与其他组件分开。
- en: 'As we are now done with the architecture, we can write down our start script:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了架构，我们可以编写我们的启动脚本：
- en: '`./app/renderer.jsx`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/renderer.jsx`'
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we add to the DOM the CSS of PhotonKit library (`import "photonkit/dist/css/photon.css"`)
    and bind the `App` container to the `<app>` element. The following container goes
    next:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向DOM添加了PhotonKit库的CSS（`import "photonkit/dist/css/photon.css"`），并将`App`容器绑定到`<app>`元素。接下来是以下容器：
- en: '`./app/js/Containers/App.jsx`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/js/Containers/App.jsx`'
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this stage, we just lay out other components using PhotonKit application
    layout styles (`.window` and `.window-content`). As we have agreed, we render
    either `ChatPane` or `Welcome` between header and footer, depending on the value
    of the local constant, `name`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们只需使用PhotonKit应用程序布局样式（`.window`和`.window-content`）布置其他组件。正如我们商定的，根据本地常量`name`的值，我们在标题和页脚之间渲染`ChatPane`或`Welcome`。
- en: 'By the way, both the header and footer we build from Photon mark-up component
    ([http://photonkit.com/components/](http://photonkit.com/components/)) are called
    **bar**. Besides a neat styling, it also enables the possibility to drag the application
    window around your desktop:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们从Photon标记组件（[http://photonkit.com/components/](http://photonkit.com/components/)）构建的标题和页脚都称为**bar**。除了整洁的样式，它还可以使应用程序窗口在桌面上拖动：
- en: '`./app/js/Components/Header.jsx`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/js/Components/Header.jsx`'
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can figure out from Photon CSS classes in the `Header` component (`.toolbar`
    and `.toolbar-header`), we render a bar on the top of the window. The bar accepts
    action buttons (`.toolbar-actions`). At the moment, the only button available
    is meant to close the window.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Header`组件中的Photon CSS类（`.toolbar`和`.toolbar-header`）可以看出，我们在窗口顶部渲染了一个栏。该栏接受操作按钮（`.toolbar-actions`）。目前，唯一可用的按钮是关闭窗口的按钮。
- en: 'In the `Footer` component, we render a bar positioned at the bottom (`.toolbar-footer`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Footer`组件中，我们在底部位置渲染了一个栏（`.toolbar-footer`）：
- en: '`./app/js/Components/Footer.jsx`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/js/Components/Footer.jsx`'
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It includes the project name and version from the manifest.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括了清单中的项目名称和版本。
- en: 'For the welcome screen, we a have a simple form with the input field (`input.form-control`)
    for the name and a submit button (`button.btn-primary`):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于欢迎屏幕，我们有一个简单的表单，其中包含输入字段（`input.form-control`）用于名称和一个提交按钮（`button.btn-primary`）：
- en: '`./app/js/Components/Welcome.jsx`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/js/Components/Welcome.jsx`'
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `ChatPane` component places `Participants` on the left and `Conversation`
    on the right. It''s pretty much everything what it does at the moment:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatPane`组件将`Participants`放在左侧，`Conversation`放在右侧。目前它所做的几乎就是这些：'
- en: '`./app/js/Components/ChatPane.jsx`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/js/Components/ChatPane.jsx`'
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `Participants` component, we use a layout pane of a type sidebar (`.pane.pane-sm.sidebar`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Participants`组件中，我们使用了一个侧边栏类型的布局窗格（`.pane.pane-sm.sidebar`）：
- en: '`./app/js/Components/Participants.jsx`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/js/Components/Participants.jsx`'
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It has a list of chat participants. Every name we prefix with the Entype icon
    is provided by Photon.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个聊天参与者列表。我们为每个名字添加了由Photon提供的Entype图标。
- en: 'The last component--`Conversation`--renders chat messages in a list (`.list-group`)
    and the submission form:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个组件--`Conversation`--在列表（`.list-group`）中渲染聊天消息和提交表单：
- en: '`./app/js/Components/Conversation.jsx`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/js/Components/Conversation.jsx`'
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is the first time we need to have a few custom styles:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次需要一些自定义样式：
- en: '`./app/assets/css/custom.css`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/assets/css/custom.css`'
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we make the form `(.l-form`) stick to the bottom. It has a fixed height
    (`110px`), and all the available space upward takes the message list (`.l-chat-conversation`).
    In addition, we align message time information (`.media-body__time`) to the right
    and take it out of the flow (`float: right`).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们让表单（`.l-form`）固定在底部。它有固定的高度（`110px`），并且所有向上的可用空间都被消息列表（`.l-chat-conversation`）占据。此外，我们将消息时间信息（`.media-body__time`）对齐到右侧，并将其从流中取出（`float:
    right`）。'
- en: 'This CSS can be loaded in HTML:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CSS可以在HTML中加载：
- en: '`./index.html`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`./index.html`'
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We make sure that all the dependencies are installed (`npm i`), then build
    (`npm run build`) and launch the application (`npm start`). As it''s done, we
    can see the following intended UI:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保所有依赖项都已安装（`npm i`），然后构建（`npm run build`）并启动应用程序（`npm start`）。完成后，我们可以看到以下预期的UI：
- en: '![](img/ac4a3396-1376-4a31-bf48-356c0a6f1eb8.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac4a3396-1376-4a31-bf48-356c0a6f1eb8.png)'
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Despite the fact that we do not have a functional application yet and just a
    static prototype, we have come a long way. We talked about the Electron GUI framework.
    We compared it to NW.js and went through its peculiarities. We made a simplified
    Electron demo application consisting of a main process script, renderer one, and
    HTML. We had an introduction into React basics. We focused on components and elements,
    JSX and virtual DOM, props, and state. We configured webpack to compile our ES.Next-compliant
    JSX into a JavaScript-acceptable one by Electron. To consolidate our knowledge,
    we made a small demo React application powered by Electron. What is more, we examined
    how to enable a DevTools extension (React Developer Tools) in Electron to trace
    and debug React applications. We have briefly familiarized ourselves with the
    PhotonKit frontend framework and created React components for the chat application
    using PhotonKit styles and markup. Finally, we have bundled our components together
    and rendered the application in Electron.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有一个功能性的应用程序，只有一个静态原型，但我们已经走了很长的路。我们谈论了Electron GUI框架。我们将其与NW.js进行了比较，并了解了它的特点。我们制作了一个简化的Electron演示应用程序，包括一个主进程脚本，一个渲染器脚本和HTML。我们对React基础知识进行了介绍。我们专注于组件和元素，JSX和虚拟DOM，props和state。我们配置了webpack将我们的ES.Next兼容的JSX编译成Electron可接受的JavaScript。为了巩固我们的知识，我们制作了一个由Electron驱动的小型演示React应用程序。此外，我们还研究了如何在Electron中启用DevTools扩展（React
    Developer Tools）来跟踪和调试React应用程序。我们简要介绍了PhotonKit前端框架，并使用PhotonKit样式和标记创建了聊天应用程序的React组件。最后，我们将我们的组件捆绑在一起，并在Electron中渲染应用程序。
