- en: Chapter 5. Practical – a CMS Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 实践 - 一个CMS应用
- en: In previous chapters, we explored the more theoretical side of application architecture
    as well as the cast of tools we'll use to support us. We've reviewed design patterns,
    methods of structuring our application. Now, it's time to understand how these
    can fit together to create a well-structured application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了应用架构的理论方面以及我们将使用的工具来支持我们。我们已经回顾了设计模式，以及我们应用的结构化方法。现在，是时候了解这些如何组合在一起以创建一个结构良好的应用了。
- en: In this chapter, we'll create a basic user interface for a **content management
    system** (**CMS**). While many businesses will work with an off-the-shelf CMS
    (such as Joomla! or Drupal), the vastly varying requirements from business-to-business
    means that a bespoke content management system is a fairly common project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个内容管理系统（**CMS**）的基本用户界面。虽然许多企业将使用现成的CMS（如Joomla!或Drupal），但企业间需求的巨大差异意味着定制内容管理系统是一个相当常见的项目。
- en: It's also a deceptively-complicated proposition. With such a range of business-specific
    requirements, the basic CMS can quickly become a complex application with modules
    and interface elements that are tailored for the problem at hand. This makes it
    even more important that the basics are taken care of, for example, code structure
    and naming conventions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个具有欺骗性的复杂提议。由于业务特定的需求范围很广，基本的CMS可以迅速变成一个复杂的应用，具有针对特定问题的模块和界面元素。这使得确保基础得到妥善处理变得尤为重要，例如代码结构和命名约定。
- en: 'In reflection of this, we''ll only be creating a basic starter-level CMS. We''ll
    be:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 反映这一点，我们只会创建一个基本的入门级CMS。我们将：
- en: Designing a data structure and the corresponding Ext JS model and store implementation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计数据结构和相应的Ext JS模型和存储实现
- en: Building a full class structure and mapping the interactions between them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建完整的类结构并映射它们之间的交互
- en: Sketching out pseudocode for some more complex interactions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为一些更复杂的交互绘制伪代码
- en: Fleshing out our design into a full implementation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的设计扩展到完整的实现
- en: 'This is also the general pattern that the next few chapters will take. In this
    particular chapter, our application will contain:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是接下来几章的一般模式。在本章中，我们的应用将包含：
- en: A hierarchical treeview of website structure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站结构的分层树形视图
- en: The search feature
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索功能
- en: A form panel showing page detail
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示页面详情的表单面板
- en: A create, update, read, and delete functionality
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、更新、读取和删除功能
- en: By the end of the chapter, we'll have put our knowledge to test in a basic real-world
    application using Ext JS 5's MVVM architecture to structure our code in a way
    that's clean and understandable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将使用Ext JS 5的MVVM架构将我们的知识应用于一个基本的现实世界应用，以使我们的代码结构整洁且易于理解。
- en: A content-managed system
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容管理系统
- en: 'We''re going to be producing a bare-bone, but usable implementation of a CMS,
    which uses some of the Ext JS architectural concepts we''ve already touched on,
    such as view models and view controllers, event listeners, and data binding. Here''s
    a look at the desired final product:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生产一个基本但可用的CMS实现，它使用我们已经接触过的某些Ext JS架构概念，例如视图模型和视图控制器、事件监听器和数据绑定。以下是期望的最终产品：
- en: '![A content-managed system](img/5308OT_05_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![内容管理系统](img/5308OT_05_01.jpg)'
- en: 'Architecture CMS: our first example application'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 架构CMS：我们的第一个示例应用
- en: Long before we get to this point, we need to go through the requirements for
    the application, design its various application layers, and come up with a design.
    Only then can we start talking about the code level. Let's get started with checking
    out our client's request.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们达到这个点之前，我们需要审查应用的需求，设计其各种应用层，并提出一个设计。只有这样，我们才能开始谈论代码层面。让我们从检查客户的请求开始。
- en: The requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: 'We receive two documents as our project brief from the client: a wireframe
    and a set of criteria to meet. A wireframe is the layout of our application in
    broad strokes, as shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从客户那里收到两个项目概要文件：一个线框图和一组需要满足的标准。线框图是我们应用的大致布局，如下所示：
- en: '![The requirements](img/5308OT_05_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![需求](img/5308OT_05_02.jpg)'
- en: Wireframe graphic for "Architecture CMS"
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “架构CMS”的线框图
- en: 'Immediately, we know that this is a very simple single-page application with
    a tree view, editor panel, and a search bar. The criterion fleshes out as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻，我们知道这是一个非常简单的单页应用，具有树形视图、编辑面板和搜索栏。标准如下：
- en: REST backend API provided
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供REST后端API
- en: The treeview to show all pages
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有页面的树形视图
- en: Search that will highlight the matching page in the treeview
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索功能，将在树形视图中突出显示匹配的页面
- en: The required HTML editor
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的HTML编辑器
- en: URLs that must be customizable
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须可定制的URL
- en: Pages that can be published or unpublished
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以发布或取消发布的页面
- en: User must be able to create, view, update, and delete pages
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须能够创建、查看、更新和删除页面
- en: Let's assess these criteria in terms of Ext JS. Firstly, we know that REST support
    is available in Ext JS via `Ext.data.proxy.Rest`, which we can use through our
    models and stores. However, note that the second point requires a tree view representing
    the hierarchical structure. While Ext JS provides a `TreePanel` component and
    there's a dedicated `TreeStore` to handle hierarchical data, there may be a possibility
    that loading this kind of nested data via a REST API could have some complications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Ext JS的角度来评估这些准则。首先，我们知道REST支持通过`Ext.data.proxy.Rest`在Ext JS中可用，我们可以通过我们的模型和存储来使用它。然而，请注意，第二点需要一个表示层次结构的树形视图。虽然Ext
    JS提供了一个`TreePanel`组件，并且有一个专门的`TreeStore`来处理层次数据，但通过REST API加载这种嵌套数据可能存在一些复杂性。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At this point, we could consult with our team and even write some prototype
    code to investigate this REST issue before getting fully underway with development.
    It's important to resolve any uncertainty before moving forward.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以与我们的团队协商，甚至编写一些原型代码来调查这个REST问题，然后再全面开始开发。在前进之前解决任何不确定性是很重要的。
- en: With this cleared up, we now look at the requirement for search. We know that
    `Ext.data.NodeInterface`, the class that powers nodes in a `TreePanel`, has a
    `findChildBy` method that allows you to traverse a tree from the root and perform
    an arbitrary action when we find what we need.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在澄清了这一点之后，我们现在来看一下搜索的要求。我们知道`Ext.data.NodeInterface`，这个类为`TreePanel`中的节点提供动力，有一个`findChildBy`方法，允许我们从根节点遍历树，并在找到所需内容时执行任意操作。
- en: The customer specified that an HTML editor is required, which is fine as Ext
    JS ships with a well-featured WYSIWYG HTML editor in `Ext.form.field.HtmlEditor`.
    For the URL customization, we don't have to do anything special other than be
    aware that the client has asked for this field to be included when editing; likewise
    the same with the published/unpublished flag.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 客户指定需要一个HTML编辑器，这是可以接受的，因为Ext JS自带了一个功能齐全的WYSIWYG HTML编辑器，位于`Ext.form.field.HtmlEditor`。对于URL定制，我们不需要做任何特别的事情，只需意识到客户要求在编辑时包含此字段；同样，发布/取消发布标志也是如此。
- en: Finally, we know the operations that the customer would like to perform on pages,
    which dictates how our application will interact with the existing backend. Given
    the REST API available to us, supporting the required **create, read, update,
    and delete** (**CRUD**) actions should be trivial with an implementation of `Ext.data.Model`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们知道了客户希望在页面上执行的操作，这决定了我们的应用程序如何与现有的后端交互。鉴于我们可用的REST API，通过`Ext.data.Model`的实现，支持所需的**创建、读取、更新和删除**（**CRUD**）操作应该是微不足道的。
- en: Accepting the challenge
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受挑战
- en: As we've reviewed the client's criteria against the tools available to us, we
    can confidently accept the challenge laid down for us. Without performing due
    diligence on customer requirements, we could begin a project without being 100
    percent certain of whether we could complete it, potentially risking the success
    of the project and costing valuable time and money.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将客户的准则与我们可用的工具进行了审查之后，我们可以自信地接受摆在我们面前的挑战。如果不进行充分的客户需求尽职调查，我们可能会在没有100%确定能否完成的情况下开始一个项目，这可能会危及项目的成功，并浪费宝贵的时间和金钱。
- en: Starting at the bottom
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从底部开始
- en: 'The client stated that we have a REST API available to us. In fact, they have
    other Ext JS applications to be built on top of this API and so we''re lucky.
    The data is returned as JSON that can be easily consumed by `Ext.data`. The customer
    provided documentation on how the API operates:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 客户表示我们有一个REST API可用。实际上，他们还有其他需要在上面构建的Ext JS应用程序，因此我们很幸运。数据以JSON格式返回，可以很容易地被`Ext.data`消费。客户提供了关于API如何操作的文档：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At this point, your developers will be dancing a little jig because not only
    do you have documentation, but also the API is very straightforward supports only
    a few operations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你的开发者将会跳一小段舞，因为不仅你有文档，而且API非常直接，只支持少数操作。
- en: 'Our part of the data implementation becomes easy now. We know that we want
    to implement a treeview. The data coming back from `/pages` is already formatted
    correctly for this with an array of children and both ID and text properties.
    We only need one model to represent a page, so it''ll look something like this
    in pseudo-UML:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据实现部分现在变得简单了。我们知道我们想要实现一个树形视图。从`/pages`返回的数据已经以具有子数组和ID及文本属性的正确格式进行了格式化。我们只需要一个模型来表示一个页面，所以它在伪UML中看起来可能像这样：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we''ll have a super simple store to collect these models together:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将有一个非常简单的存储来收集这些模型：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There's no custom logic hanging off the store so that's literally our full definition,
    although we know that our implementation will be configured to use our `ArchitectureCms.model.Page`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 店中没有挂载任何自定义逻辑，所以这实际上就是我们的完整定义，尽管我们知道我们的实现将配置为使用我们的`ArchitectureCms.model.Page`。
- en: The data layer is the one through which everything will be built on. Although
    our design for this layer is super simple for this application, it's worth writing
    it in case we see any glaring issues. We can now look at how these data classes
    will interact with the user interface and glue classes in the rest of our application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层是构建一切的基础。尽管我们为这个层的设计在这个应用中非常简单，但写下来还是有价值的，以防我们遇到任何明显的问题。现在我们可以看看这些数据类将如何与用户界面和应用程序其余部分的粘合类交互。
- en: Work your way up
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步提升
- en: 'Controllers are the glue that binds your application together; it''s often
    useful to look at our wireframe again and break down the aspects that represent
    view classes and will need a controller to orchestrate their actions. The basic
    wireframe can be seen in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是绑定应用程序的粘合剂；通常再次查看我们的线框图并分解代表视图类并需要控制器来协调其动作的方面是有用的。基本线框图可以在以下屏幕截图中看到：
- en: '![Work your way up](img/5308OT_05_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![逐步提升](img/5308OT_05_04.jpg)'
- en: 'The wireframe broken down: yellow, green, and blue are all identified as separate
    views'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 线框图分解：黄色、绿色和蓝色都被识别为独立的视图
- en: In this application, as we have a very straightforward layout and set of interactions
    between components, we can get away with a very simple architecture.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，由于我们有一个非常直接的布局和组件之间的交互集，我们可以使用一个非常简单的架构。
- en: While it's important to create a strong starting structure in the early days
    of an application, you should always strive to build something that is clearly
    designed and doesn't contain classes that have been added just in case they are
    needed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在应用程序的早期阶段创建一个强大的起始结构很重要，但你应该始终努力构建一个设计清晰且不包含只是为了以防万一而添加的类的结构。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**You Aren''t Going To Need it** (**YAGNI**) is a popular term with some software
    developers who believe that less is more—don''t write code based on some far-future
    assumption about what you might need. Instead, iterate on your architecture with
    every addition and take as much care with these additions as you would at the
    start of a project.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**你不会需要它**（**YAGNI**）是某些软件开发者中流行的术语，他们认为少即是多——不要基于对你可能需要的某些遥远未来的假设来编写代码。相反，随着每一次添加迭代你的架构，并像在项目开始时一样对这些添加给予足够的关注。'
- en: In the Ext JS MVVM architecture, a top-level controller is used to mediate interactions
    between other controllers. Here, we've elected to create just one controller (a
    view controller called `Main`) that will coordinate all of the actions of the
    views within its namespace.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS MVVM 架构中，顶级控制器用于调解其他控制器之间的交互。在这里，我们选择只创建一个控制器（一个名为`Main`的视图控制器），它将协调其命名空间内所有视图的动作。
- en: 'Let''s take a look at how these new classes will look when working together
    and in association with our data layer:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些新类如何协同工作，以及它们如何与我们的数据层相关联：
- en: '![Work your way up](img/5308OT_05_05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![逐步提升](img/5308OT_05_05.jpg)'
- en: 'The preceding diagram clearly shows how data flows through our application
    (from the data layer that interfaces with the client''s API to controllers and
    then down to views via view models). We can now flesh out each of these classes
    by naming them and specifying their methods and properties:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表清楚地显示了数据如何通过我们的应用程序流动（从与客户端 API 交互的数据层到控制器，然后通过视图模型下降到视图）。现在我们可以通过命名它们并指定它们的方法和属性来具体化这些类：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's break this down a bit and talk about the reasons we've designed the application
    in this way.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微分解一下，并讨论我们为什么以这种方式设计应用程序的原因。
- en: The devil is in the detail
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 细节决定成败
- en: It's immediately clear that the controller is where most of the interesting
    stuff is happening, but it's important to remember to keep your controllers slim.
    If you find yourself with lots of methods in there, it's a good sign you need
    another controller—look for the logical place one might split off.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，控制器是大多数有趣事情发生的地方，但重要的是要记住保持你的控制器精简。如果你发现自己有很多方法，那么这是一个很好的迹象，表明你需要另一个控制器——寻找可能分离开的逻辑位置。
- en: In our case, a future iteration of the application might have separate view
    controllers for the tree and for the detail panel with an overarching controller
    to enable communication between the two. For now though, we just don't need this.
    All we have in our `MainController` class is four methods that will handle actions
    from our views.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，应用的未来迭代可能需要为树和详细面板分别设置视图控制器，以及一个总控制器以实现两者之间的通信。然而，目前我们并不需要这个。在我们的 `MainController`
    类中，只有四个方法将处理来自视图的操作。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Controllers are there to support everything else. Focus on your data first,
    then your views, and use the controllers to connect them. As such, work out which
    events your views are going to fire and your controller will pretty much write
    itself—all it'll be doing is handling these events and passing off the hard work
    somewhere else.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的作用是支持其他一切。首先关注你的数据，然后是视图，并使用控制器将它们连接起来。因此，确定你的视图将要触发哪些事件，控制器基本上就会自己写出来——它所做的只是处理这些事件并将艰苦的工作传递到其他地方。
- en: This is a great opportunity to put implementation details to one side for a
    moment and think about how these classes would look if they were designed to make
    our life easy.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的机会，暂时将实现细节放在一边，思考如果这些类被设计成让我们的生活更轻松，它们会是什么样子。
- en: For example, the view model called `PageModel` has a method called `isUnsavedPage`,
    which allows you to ensure that the user doesn't navigate away before they save
    a new page, ensuring they won't lose any data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，名为 `PageModel` 的视图模型有一个名为 `isUnsavedPage` 的方法，它允许你确保用户在保存新页面之前不会导航离开，从而确保他们不会丢失任何数据。
- en: Designing like this up front enables us to think about all of the great features
    that make for a good user experience without having to get worked up about the
    code that will make it happen. Of course, every situation is different. We need
    to make sure that we don't let our imagination run away with itself and start
    dreaming up features that aren't required!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始就采用这种设计方式，使我们能够思考所有那些构成良好用户体验的出色功能，而无需担心实现这些功能的代码。当然，每种情况都是不同的。我们需要确保我们不会让我们的想象力失控，开始梦想那些不必要的功能！
- en: There's a short discussion to be had with regard to the `searchFor` method on
    the `Tree` class. In controllers, we pull together a few parts of our application
    and hand off the real work to them, not to the controller itself. That's exactly
    what we're doing here. Think of this method in the same way you would use the
    `expandPath` method on the `Ext.tree.Panel` base—a method that acts on the tree
    interface without breaking out and interacting with anything else. Its logical
    place is as an augmentation to the tree UI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Tree` 类上的 `searchFor` 方法，有一些简短的讨论。在控制器中，我们汇集了我们应用的一些部分，并将实际工作交给它们，而不是控制器本身。这正是我们在这里所做的事情。你可以用与在
    `Ext.tree.Panel` 基础上使用 `expandPath` 方法相同的方式思考这个方法——这是一个作用于树接口而不与其他任何东西交互的方法。它的逻辑位置是作为树UI的增强。
- en: Where the wild things are
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 野性的地方在哪里
- en: 'We have our design, so let''s step a little closer and examine the parts of
    the application where a little more detail may be required. For example, we have
    a controller method called `onAddClick` that will be handling the process of adding
    a new record, but what will this actually entail and are there any pain points
    hidden within? Here''s what needs to happen when this handler is done with its
    job:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有自己的设计，所以让我们稍微靠近一点，检查一下应用中可能需要更多细节的部分。例如，我们有一个名为 `onAddClick` 的控制器方法，它将处理添加新记录的过程，但实际会涉及哪些内容，以及其中是否隐藏着任何痛点？当这个处理程序完成其工作时，需要发生以下情况：
- en: Ask the user for a name for the new page
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户请求新页面的名称
- en: Create a new blank record with default values and the page name
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的空白记录，具有默认值和页面名称
- en: Add the page as a child node of the current page
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将页面作为当前页面的子节点添加
- en: Load the record in the detail panel
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在详细面板中加载记录
- en: Show the new record in the tree
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树中显示新记录
- en: 'That''s a lot for a single controller action. Let''s look at how we might code
    it to see whether we''re trying to do too much. We''ll write some pseudocode (fake
    code) to drill down into some detail:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 单个控制器动作包含的内容很多。让我们看看我们如何编写它，以确定我们是否试图做太多。我们将编写一些伪代码（假代码）来深入细节：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's no JavaScript here, no Ext JS classes in use. We're just writing the
    code we wish we could write if there weren't any language or framework constraints.
    Given that, this code looks good—it's clear what's happening and we're not doing
    too much.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有使用JavaScript，也没有使用Ext JS类。我们只是在编写我们希望在没有任何语言或框架限制的情况下能够编写的代码。鉴于这一点，这段代码看起来不错——它清楚地表明了正在发生什么，我们也没有做太多。
- en: One thing to notice is that `Ext.panel.Tree` doesn't have a native `addAndSelect`
    method. We'll need to write this, but if it makes our controller code cleaner
    and shorter, then that's a good thing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意，`Ext.panel.Tree`没有原生的`addAndSelect`方法。我们需要编写这个方法，但如果它使我们的控制器代码更简洁、更短，那么这很好。
- en: Spiky and hairy
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锐利且复杂
- en: There's a truism in software development that code is harder to read than it's
    to write. Comprehending someone else's code without having the reasoning behind
    it can be difficult. Having said that, there's a difference between code that's
    a little hairy, a little scary—something that doesn't shout out its intent via
    comments, variable naming or method naming, and code that shows consideration
    for future maintainers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中有一个普遍的真理，那就是代码的阅读难度大于编写难度。在没有理解背后的推理的情况下理解他人的代码可能会很困难。话虽如此，代码的难度在于它有点复杂、有点令人恐惧——这种代码没有通过注释、变量命名或方法命名来明确其意图，而代码则考虑到了未来的维护者。
- en: In writing pseudocode, we're trying to ensure that the concepts behind our code
    are well fleshed out beforehand and that any difficulties are taken care of before
    we really start work on our application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写伪代码时，我们试图确保我们的代码背后的概念在真正开始工作之前就已经得到了充分的阐述，并且任何困难都在我们真正开始工作之前得到了解决。
- en: 'In complex cases, pseudocode won''t go far enough. We''ll have to write some
    real code in the form of a spike. In *Kent Beck''s Guide to Better Smalltalk:
    A Sorted Collection*, *SIGS*, he talks a bit about this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的情况下，伪代码可能不足以解决问题。我们将不得不编写一些真正的代码，形式为尖峰。在*《更好的Smalltalk指南：有序集合》*中，*SIGS*谈到了这一点：
- en: '*"Sometimes I call this a "spike", because we are driving a spike through the
    entire design. […] Because people variously associate "spike" with volleyball,
    railroads, or dogs, I have begun using "architectural prototype" to describe this
    implementation."*'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"有时我称之为“尖峰”，因为我们正在整个设计中钻一个尖峰。[…]'
- en: When creating a spike, we're pushing through any assumptions we have and testing
    our design decision on a tiny prototype (the smallest code snippet or application
    we can build to prove our idea).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建尖峰时，我们正在克服任何假设，并在一个小型原型（我们能够构建的最小代码片段或应用程序）上测试我们的设计决策，以证明我们的想法。
- en: This firms up our design by eliminating further unknowns. We can be sure that
    a UI component will support the feature we require because we've actually tested
    it in a practical example. If it's an architectural code spike, we can see whether
    the various elements of our design hang together in a way that "feels right",
    if it works within the framework being used, and the design patterns that have
    been chosen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消除进一步的未知因素，这巩固了我们的设计。我们可以确信UI组件将支持我们所需的功能，因为我们已经在实际示例中对其进行了测试。如果它是架构代码尖峰，我们可以看到我们的设计元素是否以一种“感觉正确”的方式组合在一起，如果它在使用的框架中工作，以及选择的设计模式。
- en: We can perform a spike on the `addAndSelect` method described previously, but
    we know that `Ext.tree.Panel` already has an `add` method and that the underlying
    `selectionModel` will allow us to mark a node as selected. Therefore, now that
    we have alleviated our concerns with pseudocode, there's no need to continue on
    to real code until we implement the real deal. As developers working under constraints
    of time and money, we need to be pragmatic, as long as we are certain that due
    diligence has been performed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对之前描述的`addAndSelect`方法进行尖峰测试，但我们知道`Ext.tree.Panel`已经有一个`add`方法，并且底层的`selectionModel`将允许我们标记一个节点为选中状态。因此，现在我们已经通过伪代码缓解了我们的担忧，就没有必要继续编写真正的代码，直到我们实现了真正的功能。作为在时间和金钱限制下工作的开发者，我们需要务实，只要我们确信已经完成了尽职调查。
- en: The real deal
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真正的事情
- en: We've designed the data layer and the UI layer, the glue that dictates how the
    two interact, and tackled the remaining bits of the client requirements that look
    like they may cause trouble. We're in good shape to start putting our fingers
    on the keyboard in our favorite text editor and show how the design can be implemented
    in Ext JS.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设计了数据层和 UI 层，以及连接这两个层的粘合剂，并解决了可能引起麻烦的客户需求剩余部分。我们现在可以开始在我们的首选文本编辑器中敲击键盘，展示如何在
    Ext JS 中实现设计。
- en: A short interlude on data binding
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定简短中断
- en: With the introduction of view models in Ext JS, the concept of data binding
    has also been brought to prominence. In short, data binding binds one value to
    another value. When the first changes, the second updates automatically. Two-way
    data binding means that when either value changes, the other updates accordingly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Ext JS 中视图模型的引入，数据绑定的概念也得到了突出。简而言之，数据绑定将一个值绑定到另一个值。当第一个值更改时，第二个值会自动更新。双向数据绑定意味着当任一值更改时，另一个值会相应地更新。
- en: On the whole, Ext JS has implemented this idea via view models. A UI component
    may have its title bound to a value and when this value is updated by another
    part of the application, the title automatically changes. This removes the need
    for the developer to wire up change events and ensures that data will be consistent
    across an application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Ext JS 通过视图模型实现了这个想法。一个 UI 组件可能将其标题绑定到一个值上，当这个值被应用程序的另一个部分更新时，标题会自动更改。这消除了开发者设置更改事件的必要性，并确保数据在整个应用程序中保持一致性。
- en: We're going to use data binding heavily in this example application and across
    all our practical chapters. In many cases, a little bit of binding configuration
    can remove a lot of boilerplate event wiring, so we're going to take advantage
    of it where we can.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例应用程序以及我们所有的实践章节中，我们将大量使用数据绑定。在许多情况下，一点点的绑定配置可以消除大量的样板事件连接，因此我们将充分利用这一点。
- en: Creating a structure
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建结构
- en: 'Using our knowledge from previous chapters, we''ll create an application skeleton
    using Sencha Cmd and use it as a basis for our work. We''re familiar with this
    by now:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前章节的知识，我们将使用 Sencha Cmd 创建一个应用程序骨架，并将其作为我们工作的基础。现在我们已经熟悉这个过程：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With a simple command, we''re up and running with a template. Let''s fire up
    a web server and look for changes in our code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个简单的命令，我们就可以使用模板启动并运行。让我们启动一个网络服务器并查看代码中的变化：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now launch a web browser and navigate to `http://localhost:1841` to
    see the template in action. We don''t want any of the example code that''s been
    generated. So, we can remove it with the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动一个网络浏览器并导航到 `http://localhost:1841` 来查看模板的实际效果。我们不希望有任何生成的示例代码。因此，我们可以使用以下命令将其删除：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we've got a clean directory structure on which we can build our content
    management system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有一个干净的目录结构，我们可以在此基础上构建我们的内容管理系统。
- en: Data-driven design
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据驱动设计
- en: 'In the same way that we designed our application by looking at the data layer
    first, we''ll write the Ext JS model and store code first. Here''s the model,
    which we''ll build bit-by-bit to explain the thought process behind the code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们首先查看数据层来设计应用程序的方式相同，我们将首先编写 Ext JS 模型和存储代码。以下是模型，我们将逐步构建它来解释代码背后的思考过程：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's look back at our design for this class. We're defining the same fields
    we laid out there with the exception of the children field, which is a special
    case as we're using `Ext.data.TreeModel`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个类的设计。我们定义了与之前相同的字段，除了子字段，这是一个特殊情况，因为我们正在使用 `Ext.data.TreeModel`。
- en: 'Of course, this isn''t enough to drive a real-world Ext JS model. This is where
    the design now differs from the implementation. Let''s connect the model to the
    client''s API:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不足以驱动一个真实的 Ext JS 模型。这就是设计现在与实现不同的地方。让我们将模型连接到客户的 API：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Woah! The design is mostly language agnostic, but the implementation now shows
    off configuration options that are very Ext JS-specific. There are two ways of
    configuring a model. One way to configure is via its proxy and another is via
    its schema. The proxy configuration works just fine, but in larger applications,
    the schema can be shared between models and provides a central place to configure
    the base API URL and the path to fetch for a particular model.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！设计基本上是语言无关的，但实现现在展示了非常 Ext JS 特定的配置选项。配置模型有两种方式。一种是通过其代理进行配置，另一种是通过其模式进行配置。代理配置运行良好，但在大型应用程序中，模式可以在模型之间共享，并提供一个中心位置来配置基本
    API URL 和特定模型的获取路径。
- en: 'Because of this, we''re going to start off using schema even though we''re
    only dealing with a single model in this application. Let''s look at the various
    configuration options:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们将从使用模式开始，尽管在这个应用程序中我们只处理一个模型。让我们看看各种配置选项：
- en: '`namespace`: This is the segment of the model''s class name that represents
    the namespace. This means that Ext JS can remove the namespace part of the full
    class name and be left with nothing but the model, which it can then use to automatically
    build URLs. In this case, we set the namespace as `ArchitectureCms.model`, which
    allows Ext JS to work out that the model name is just `Page`. We''ll use this
    later.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespace`：这是模型类名中表示命名空间的段。这意味着 Ext JS 可以移除完整类名中的命名空间部分，只留下模型，然后它可以使用它来自动构建
    URL。在这种情况下，我们将命名空间设置为 `ArchitectureCms.model`，这使得 Ext JS 能够推断出模型名称只是 `Page`。我们稍后会用到这个。'
- en: '`urlPrefix`: This is generally the hostname or the API endpoint to use in combination
    with the path to the specific resource being consumed.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urlPrefix`：这通常是主机名或与特定资源路径结合使用的 API 端点。'
- en: '`proxy.type`: This is the type of proxy, which when dealing with the server
    will likely be `ajax` or `rest`. We know that our customer has a REST API, so
    it''s set to `rest`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy.type`：这是代理的类型，在处理服务器时很可能是 `ajax` 或 `rest`。我们知道我们的客户有一个 REST API，所以它被设置为
    `rest`。'
- en: '`proxy.url`: This uses all the preceding options to build a URL. The segments
    in curly brackets will be replaced in order to build a full URL to the resource
    being consumed. `{prefix}` is the `urlPrefix` from above, `{entityName:uncapitalize}`
    is the model''s name parsed from the class name without the namespace in lower
    case.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy.url`：它使用所有前面的选项来构建一个 URL。花括号中的段将按顺序替换，以构建一个完整的 URL 到正在消耗的资源。`{prefix}`
    是上面的 `urlPrefix`，`{entityName:uncapitalize}` 是从类名中解析出的模型名称，没有命名空间，且为小写。'
- en: Phew! At this point, we've done a pretty deep dive into Ext JS configuration
    options. This chapter, and indeed this book, is supposed to be about architecture.
    So from now on, there will be some cases where we'll skip over this kind of detail
    on the assumption that you've worked with Ext JS before and understand these configuration
    options.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！到目前为止，我们已经深入探讨了 Ext JS 的配置选项。这一章，以及整本书，本应关于架构。所以从现在开始，有些情况下我们会跳过这类细节，假设你已经使用过
    Ext JS 并且理解这些配置选项。
- en: 'We''re trying to design this application; we''re not trying to teach JavaScript
    or Ext JS. Although, we''ll look at aspects of the Ext JS framework that contribute
    to a successful application, we''re not going to regurgitate the Sencha documentation.
    With this in mind, let''s add a little bit more to our model and talk about how
    it helps us meet the customer requirements:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在尝试设计这个应用程序；我们不是在教 JavaScript 或 Ext JS。尽管如此，我们会看看 Ext JS 框架的各个方面，这些方面有助于成功应用，但我们不会重复
    Sencha 文档的内容。考虑到这一点，让我们对我们的模型添加更多内容，并讨论它是如何帮助我们满足客户需求的：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the final iteration of the `Page` class, now with an identifier configured.
    We know that we need to differentiate between a saved and an unsaved model, and
    we know that the server will return `clientId` if it's supplied, so here we explicitly
    state that it's going to have the `Unsaved-` string in the ID until the server
    supplies an auto-incremented identifier to replaced it on save.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Page` 类的最终迭代版本，现在已配置了标识符。我们知道我们需要区分已保存和未保存的模型，也知道如果提供，服务器将返回 `clientId`，所以在这里我们明确指出，ID
    将包含 `Unsaved-` 字符串，直到服务器提供一个自动递增的标识符来替换它。
- en: A model store
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型存储
- en: 'The store for this application is pretty simple:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的存储相当简单：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Everything here is self-explanatory, although there is a caveat. With the current
    version of Ext JS (5.0.1), we need to set an empty root node that allows you to
    use data binding to bind this store to a UI component. If we don't, an error will
    be thrown, so this is a simple workaround.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一切都是不言自明的，尽管有一个注意事项。在当前版本的 Ext JS（5.0.1）中，我们需要设置一个空的根节点，以便你可以使用数据绑定将此存储绑定到
    UI 组件。如果不这样做，将会抛出错误，所以这是一个简单的解决方案。
- en: A room with a view
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有景观的房间
- en: We mentioned that it was a good idea to design your application (starting with
    the data layer and then moving to the views) so that it's easier to understand
    the interactions that your controllers will have to deal with. When moving from
    the design to the code, the same applies, so we will write the user interface
    for this application and then later wire it up to the data via controllers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，设计你的应用程序（从数据层开始，然后移动到视图）是一个好主意，这样更容易理解控制器将必须处理的交互。当从设计到代码时，同样适用，因此我们将为这个应用程序编写用户界面，然后稍后通过控制器将其连接到数据。
- en: 'First up, we need a viewport. We only have one page in the CMS, so the viewport
    is the container for all of the individual subviews (such as the tree and the
    detail panel). This application is fairly focused, so we''re going to put all
    our views and associated classes under the `ArchitectureCms.view.main.* namespace`.
    Here''s the code for our `ArchictureCms.view.main.Main` viewport:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个视口。在CMS中我们只有一个页面，所以视口是所有单个子视图（如树形图和详细面板）的容器。这个应用程序相当专注，因此我们将所有的视图和关联的类放在`ArchitectureCms.view.main.*`命名空间下。下面是`ArchictureCms.view.main.Main`视口的代码：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is mostly straightforward (we extend `Ext.Panel` rather than `Ext.Container`
    to give us support for a title bar). Next up, we require the view classes we're
    going to use in the viewport.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分主要是直截了当的（我们扩展`Ext.Panel`而不是`Ext.Container`以提供标题栏的支持）。接下来，我们需要在视口中使用视图类。
- en: The `session` option is set to `true`. We'll discuss this in more detail shortly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`session`选项设置为`true`。我们稍后会详细讨论这个问题。'
- en: The view controller and view model are specified by their aliases; we'll create
    these classes later. Sencha Cmd knows that these are "auto-dependencies", so we
    will automatically require them without having to include them in the `requires`
    array.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器和视图模型通过它们的别名指定；我们稍后会创建这些类。Sencha Cmd知道这些是“自动依赖”，因此我们将自动加载它们，而无需在`requires`数组中包含它们。
- en: 'We create a default title, namely, `Architect CMS`, but in the next line, we
    have our first use of the `bind` option. Let''s break down what''s happening here.
    We''ve already specified a view model for this class and always have to bind to
    a value in a view model. Not only this, the `bind` option is only triggered when
    the view model value changes, which is why we need to specify a default value
    via the title configuration. For the bind configuration, we specify the values
    we want to bind against (in this case title) and then provide a binding expression.
    Here, it''s just a string. The segment in curly brackets determines the value
    on the view model to bind to. Later, we''ll look at `currentPage.text` and see
    how this gets set, but it will suffice for now to realize that when this value
    changes; it gets incorporated into the value for title. We''ll see something like
    this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个默认标题，即`Architect CMS`，但在下一行，我们首次使用了`bind`选项。让我们分析一下这里发生了什么。我们已为这个类指定了一个视图模型，并且总是必须绑定到视图模型中的某个值。不仅如此，`bind`选项仅在视图模型值变化时触发，这就是为什么我们需要通过标题配置指定一个默认值。对于绑定配置，我们指定我们想要绑定的值（在这种情况下是标题），然后提供一个绑定表达式。这里它只是一个字符串。花括号内的部分决定了要绑定到视图模型上的值。稍后，我们将查看`currentPage.text`并看到它是如何设置的，但现在的关键是意识到当这个值变化时，它会被纳入标题的值。我们会看到类似这样的：
- en: '![A room with a view](img/5308OT_05_06.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![有景色的房间](img/5308OT_05_06.jpg)'
- en: Note that this will happen without having to wire up any event handlers. It's
    a little sprinkle of magic that reduces the boilerplate code we have to write.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这将在不设置任何事件处理器的情况下发生。这是一点点魔法，可以减少我们必须编写的样板代码。
- en: Next up, we specify a border layout and then fill the items array with the tree
    and detail panel, referencing them by their `xtype`. Thanks to our configuration
    of the `requires` option, Ext JS is already aware of these classes, so we can
    use the aliases as shorthand.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定一个边框布局，然后将树形图和详细面板填充到项目数组中，通过它们的`xtype`引用。多亏了我们对`requires`选项的配置，Ext
    JS已经知道这些类，因此我们可以使用别名作为简写。
- en: Other than the binding configuration and a bit of auto-requiring magic, there's
    nothing special happening here. The key, in terms of application design, is the
    introduction of the binding concept in association with view models and view controllers.
    Hopefully, we've shown how these ideas can be introduced with barely any additional
    code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了绑定配置和一些自动加载的魔法之外，这里没有特别之处。从应用设计的关键来看，是引入了与视图模型和视图控制器关联的绑定概念。希望我们已经展示了如何几乎不添加额外代码的情况下引入这些想法。
- en: The tree panel and searching
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树面板和搜索
- en: 'Now that we''ve got our viewport container, we can introduce the views themselves.
    First, we''ll look at the code for the tree that shows the page hierarchy:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了我们的视口容器，我们可以介绍视图本身。首先，我们将查看显示页面层次结构的树的代码：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: More binding expressions! One important thing to realize is that a view model
    declared on a high-level component, in this case our `ArchitectureCms.view.main.Main`
    viewport, will cascade down and become available to child components. This means
    that our binding expressions in the tree will refer to the `Page` view model we
    assigned to the main viewport. What customer requirement are we trying to fulfill
    by using binding in the tree?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更多绑定表达式！一个重要的事情要意识到的是，在高级组件上声明的视图模型，在这种情况下是我们的`ArchitectureCms.view.main.Main`视口，将级联下来并可供子组件使用。这意味着我们的树中的绑定表达式将引用分配给主视口的`Page`视图模型。我们通过在树中使用绑定来满足哪些客户需求？
- en: 'We want to be able to search for a page and have it highlighted in the tree.
    To do so, when we type in `textfield`, the value has to be passed to the tree.
    A traditional way of doing this would be to listen for a change event or `keypress`
    on `textfield`, then trigger a `search` method on the tree. Rather than doing
    this manually, we can use data binding via a view model to achieve the same effect:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在树中搜索一个页面并高亮显示。为此，当我们输入`textfield`时，值必须传递给树。传统的方法是监听`textfield`上的变化事件或`keypress`，然后在树上触发`search`方法。而不是手动这样做，我们可以通过视图模型的数据绑定来实现相同的效果：
- en: '![The tree panel and searching](img/5308OT_05_03.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![树面板和搜索](img/5308OT_05_03.jpg)'
- en: Data flows between UI components through the view model
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通过视图模型在UI组件之间流动
- en: The `searchTerm` value on the view model can flow back and forth between the
    `searchFor` config on the tree and the value on `textfield`. However, in this
    case, it's only one direction (from `textfield` down to the tree).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型上的`searchTerm`值可以在树的`searchFor`配置和`textfield`的值之间来回流动。然而，在这种情况下，它只有一个方向（从`textfield`到树）。
- en: In addition, we tell the tree to bind to the pages value on the view model;
    we know we're going to need a list of pages from somewhere.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们告诉树绑定到视图模型上的页面值；我们知道我们将在某个地方需要页面列表。
- en: The missing piece in this puzzle is the part that actually does the searching
    on the tree. Thanks to the Ext JS configuration system, any `config` option that
    is specified also creates an `applyConfigName` method on the class instance and
    this is called every time the `config` option changes. This means that by creating
    `applySearchFor` on the tree, every time `searchFor` updates via its binding,
    we can run a piece of code to do something with the new value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题中缺失的部分是实际在树上执行搜索的部分。多亏了Ext JS配置系统，任何指定的`config`选项也会在类实例上创建一个`applyConfigName`方法，并且每次`config`选项更改时都会调用它。这意味着通过在树上创建`applySearchFor`，每当`searchFor`通过其绑定更新时，我们就可以运行一段代码来处理新值。
- en: 'Note that we put a function placeholder in the last code snippet (the `Ext.emptyFn`
    part). Here''s the actual code we''re going to use here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在最后一个代码片段（`Ext.emptyFn`部分）中放置了一个函数占位符。以下是我们要在这里使用的实际代码：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In brief, use a regular expression to do a case-insensitive match on the search
    term against the text of each tree node. If a match is found, expand the tree
    to this point and call its `highlight` method to produce a visual cue.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用正则表达式对搜索词与每个树节点文本进行不区分大小写的匹配。如果找到匹配项，则展开树到这一点并调用其`highlight`方法以产生视觉提示。
- en: Pages in detail
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面详情
- en: 'The tree is used to browse the hierarchy of trees in the CMS, so we now need
    a way to look at the detail of each page. The detail pane is a panel containing
    a number of form fields:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 树用于浏览CMS中的树结构，因此我们现在需要一种查看每个页面细节的方法。详情面板是一个包含多个表单字段的面板：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each of the form fields has a binding expression, which ties the field value
    to a value on the `currentPage` object of the view model. When the user changes
    the field, the view model will automatically get updated. Note that we don't have
    to specifically state the property to bind to because form fields have their `defaultBindProperty`
    set to `value`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表单字段都有一个绑定表达式，它将字段值绑定到视图模型中`currentPage`对象的值。当用户更改字段时，视图模型将自动更新。请注意，我们不必明确指定要绑定的属性，因为表单字段已将`defaultBindProperty`设置为`value`。
- en: The whole form panel has its hidden value bound to `currentPage`, so if this
    value is not set, the panel will be hidden. This allows you to hide the form when
    no page is selected. We've also got a warning message as the first item in the
    panel, which will be hidden when the view model's `isUnsavedPage` value changes
    to `false`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 整个表单面板的隐藏值绑定到`currentPage`，因此如果此值未设置，则面板将被隐藏。这允许您在未选择页面时隐藏表单。我们还在面板的第一项中有一个警告消息，当视图模型的`isUnsavedPage`值更改为`false`时，该消息将被隐藏。
- en: We've only written a little bit of code outside the UI configuration, yet with
    the addition of the view model, we'll already have a populated tree panel with
    search tied to a detail panel. Next, we'll look at the view model code itself.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在UI配置之外只编写了一小部分代码，但随着视图模型的添加，我们已经有了一个包含搜索功能并与详细面板关联的填充树面板。接下来，我们将查看视图模型代码本身。
- en: The magical page view model
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 魔法的页面视图模型
- en: 'This view model uses a simple formula to provide a calculated value to the
    view:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图模型使用一个简单的公式向视图提供计算值：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Considering the functionality that this class enables, that's very little code.
    The store definition is fairly self-explanatory, just using the `ArchitectureCms.store.Pages`
    alias to specify that the view model has a page value powered by this store.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个类所启用的功能，代码非常少。存储定义相当直观，只需使用`ArchitectureCms.store.Pages`别名来指定视图模型有一个由这个存储支持的页面值。
- en: The formulas definition is a little more interesting. It's a way of declaring
    that a value will be returned based on other values in the view model. In this
    case, as we specified on our model that newly created records would use a prefix
    of `Unsaved-`, we can look for this to determine whether the record's been saved
    to the server or not. So, `isUnsavedPage` returns `true` or `false` depending
    on whether the record's ID contains this prefix or not.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 公式定义有点更有趣。这是一种声明基于视图模型中的其他值返回值的声明方式。在这种情况下，正如我们在模型中指定的新创建的记录将使用`Unsaved-`前缀一样，我们可以查找这个前缀来确定记录是否已保存到服务器。因此，`isUnsavedPage`根据记录的ID是否包含此前缀返回`true`或`false`。
- en: 'The only missing thing here is the `currentPage` value. We can set arbitrary
    values on the view model. So, this gets set elsewhere in the controller. Before
    we talk about this, let''s jump back to discuss a new concept in Ext JS 5: `Ext.data.Session`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一缺少的是`currentPage`值。我们可以在视图模型上设置任意值。因此，这个值在其他控制器中被设置。在我们讨论这个之前，让我们回到讨论Ext
    JS 5中的新概念：`Ext.data.Session`。
- en: This data is now in session
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 此数据现在在会话中
- en: An `Ext.data.Session` is a way of centralizing data in an application, ensuring
    that stores are working with the same set of data without having redundant reloading.
    It also allows much easier batched updates and deletions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.data.Session`是一种在应用程序中集中数据的方式，确保存储与同一组数据工作，从而避免重复加载数据。它还允许更轻松地进行批量更新和删除。'
- en: In our application, we set `session`, set to `true` on our top-level viewport,
    which tells Ext JS to automatically create a session and make it available to
    any other code that requests it. This is the simplest way of constructing a session,
    although there's a lot more customization that we can do if need be.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们在顶级视图中设置`session`，将其设置为`true`，这告诉Ext JS自动创建一个会话并将其提供给任何请求它的其他代码。这是构建会话的最简单方法，尽管如果需要，我们还可以进行很多自定义。
- en: The reason we use a session in this application is to allow us to link the data
    that the tree and the detail panel uses. This helps with data binding too; we
    can use exactly the same model instance in the tree and the detail panel, which
    means that updates made in the detail panel will flow through the view model and
    into the correct page instance in the tree. In a moment, when we look at our view
    controller, we'll use the session a little more and get a glimpse of how it can
    help manage your data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个应用程序中使用会话的原因是允许我们将树和详细面板使用的数据链接起来。这也有助于数据绑定；我们可以在树和详细面板中使用完全相同的模型实例，这意味着在详细面板中进行的更新将通过视图模型流入树中的正确页面实例。当我们稍后查看我们的视图控制器时，我们将更多地使用会话，并了解它如何帮助管理您的数据。
- en: The glue controlling all
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制所有内容的粘合剂
- en: 'In previous chapters, we''ve looked at how the controller can use event domains
    to hook into anything interesting happening elsewhere in the application. Here,
    we use the same approach, which we discussed previously, and get the controller
    to hook up a bunch of event handlers to deal with user actions in the user interface:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了控制器如何使用事件域来挂钩应用程序中其他地方发生的任何有趣事件。在这里，我们使用相同的方法，我们之前讨论过，让控制器连接到一系列事件处理程序来处理用户界面中的用户操作：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This view controller handles the following four events:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图控制器处理以下四个事件：
- en: The `select` event on the tree handled by the `onPageSelect` method
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `onPageSelect` 方法处理的树上的 `select` 事件
- en: The `click` event on the detail panel's save button handled by `onSaveClick`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细面板保存按钮的 `click` 事件由 `onSaveClick` 处理
- en: The `click` event on the detail panel's add child button handled by `onAddChildClick`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细面板添加子按钮的 `click` 事件由 `onAddChildClick` 处理
- en: The `click` event on the detail panel's delete button handled by `onDeleteClick`
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细面板删除按钮的 `click` 事件由 `onDeleteClick` 处理
- en: Some of this will be self-explanatory, some relates to data binding, and some
    relates to the session. Let's break down the important parts.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些将是自解释的，一些与数据绑定相关，一些与会话相关。让我们分解重要的部分。
- en: Selecting a page
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择页面
- en: When the tree fires a `select` event, the view controller's `onPageSelect` method
    gets passed the model for the selected tree node. We mentioned earlier that we
    can set arbitrary values on the view model, specifically the `currentPage` value,
    and so this is what we do here, but with a twist.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当树触发 `select` 事件时，视图控制器的 `onPageSelect` 方法会接收到所选树节点的模型。我们之前提到过，我们可以在视图模型上设置任意值，特别是
    `currentPage` 值，所以我们在这里这样做，但有一个转折。
- en: Rather than just setting the data, we give Ext JS a hint that we want to set
    a model instance by using the links configuration. By supplying the name of the
    model class and its ID, Ext JS will use the matching instance if it's already
    available in the current `Ext.data.Session` or it'll automatically load it from
    the server. It's a handy shortcut for reducing the number of requests to the backend
    API and another example of how to use a session.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅设置数据，我们通过使用链接配置来给 Ext JS 一个提示，我们想要设置一个模型实例。通过提供模型类的名称及其ID，Ext JS 将会使用当前
    `Ext.data.Session` 中已存在的匹配实例，如果有的话，或者它会自动从服务器加载它。这是一个方便的快捷方式，可以减少对后端API的请求数量，也是如何使用会话的另一个例子。
- en: Adding a page
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加页面
- en: The view controller listens for events on a button with an item ID of `#addChild`.
    When it fires, we ask the user for the name of the new page, and the next step
    is to actually create a page record. Rather than using `Ext.create`, we call `createRecord`
    on the current `Ext.data.Session`, which allows you to continue to make Ext JS
    aware of the records we're managing. It also allows you to maintain a global understanding
    of the saved and unsaved records. This would be even more useful in an application
    where we need to do batch updates of records.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器监听一个具有项目ID `#addChild` 的按钮的事件。当它触发时，我们会询问用户新页面的名称，接下来的步骤是实际创建一个页面记录。我们不是使用
    `Ext.create`，而是在当前的 `Ext.data.Session` 上调用 `createRecord`，这允许你继续让 Ext JS 知道我们正在管理的记录。这也允许你维护对已保存和未保存记录的全局理解。这在需要批量更新记录的应用程序中会更有用。
- en: After creating a model instance, we follow the pseudocode we wrote earlier in
    the chapter, but tie it to actual Ext JS methods and add the page to the tree
    data structure before selecting it in the tree UI itself.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模型实例之后，我们遵循本章前面编写的伪代码，但将其与实际的 Ext JS 方法绑定，并在树UI中选择它之前将其添加到树数据结构中。
- en: Deleting a page
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除页面
- en: This is fairly straightforward (handle the `click` event from the `#delete`
    button and then grab the `currentPage` from the view model). We also remove the
    leftover page from the view model so that the detail panel automatically clears
    itself, rather than leaving a dead record available to edit. We display a notification
    to the user with `Ext.toast`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接（处理 `#delete` 按钮的 `click` 事件，然后从视图模型中获取 `currentPage`）。我们还从视图模型中移除了多余的页面，这样详细面板会自动清除自己，而不是留下一个可编辑的死记录。我们使用
    `Ext.toast` 向用户显示通知。
- en: Saving a page
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存页面
- en: 'This is even simpler (handling a click on the #save button, grabbing the `currentPage`
    from the view model, and then calling its `save` method). There''s nothing special
    happening here. The only thing to note is that if this is a new record, the server
    will respond with a new ID and replace the one that Ext JS automatically allocated.
    Thanks to the binding to `isUnsavedPage` on the view model, this will cause the
    "unsaved" message to disappear from the detail panel.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至更简单（处理点击#save按钮，从视图模型中获取`currentPage`，然后调用其`save`方法）。这里没有发生什么特别的事情。唯一需要注意的是，如果这是一个新记录，服务器将响应一个新的ID并替换Ext
    JS自动分配的那个。多亏了视图模型上对`isUnsavedPage`的绑定，这将导致“未保存”消息从详细面板中消失。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With our first practical application, we've taken the theoretical ideas discussed
    in previous chapters and shown how they apply to the creation of a useful code
    base. From analysis to what the customer really needs to see, whether we can fulfill
    their request to sketching out designs, and undertaking short code spikes down
    to applying the MVVM pattern via view models and their supporting infrastructure,
    we've built an application brain-first rather than code-first.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的首次实际应用，我们将前几章中讨论的理论思想应用于创建一个有用的代码库。从分析客户真正需要看到的内容，到我们能否满足他们的需求进行草图设计，再到通过视图模型及其支持的基础设施应用MVVM模式，我们首先构建了应用的大脑部分，而不是代码部分。
- en: In the next chapter, we'll create a more complicated real-world application,
    but this time, we won't have to discuss the basics of data binding in so much
    detail. We'll apply our growing knowledge to build a more complex app, a log analyzer,
    which could be used by a system administrator to monitor their infrastructure.
    This will require more thought about how to design the various moving parts that
    will make up our second application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个更复杂、更贴近现实世界的应用，但这次我们不必如此详细地讨论数据绑定的基础知识。我们将运用我们不断增长的知识来构建一个更复杂的应用程序，一个日志分析器，它可以被系统管理员用来监控他们的基础设施。这需要我们更多地思考如何设计构成我们第二个应用程序的各个部分。
