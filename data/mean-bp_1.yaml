- en: Chapter 1. Contact Manager
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 联系人管理器
- en: 'In this chapter, you''ll learn how to build a Contact manager application.
    The application will be divided into two separate parts: one part consisting of
    the backend, our Node.js API written using Express, and the client application
    crafted using Angular 2.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习如何构建联系人管理器应用程序。该应用程序将分为两个独立的部分：一部分是后端，我们使用Express编写的Node.js API，另一部分是使用Angular
    2精心制作的客户端应用程序。
- en: Don't worry! This chapter will be more of a guideline, setting up a base project
    and wrapping your head around TDD (short for **Test-driven development**) in Node.js.
    We'll also get to see Angular 2 in action. We are not going to write tests on
    the client side as there are enough things to accumulate in one chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心！这一章将更多地作为一个指南，设置一个基础项目，并在Node.js中了解TDD（即**测试驱动开发**）。我们还将看到Angular 2的实际应用。我们不会在客户端编写测试，因为一章节中已经有很多东西要积累。
- en: Setting up the base application
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本应用程序
- en: The best way to start is with a solid base. That's why we are going to focus
    on building the base structure of our application. A good base gives you modularity
    and flexibility and also files should be easily located by you and even your team
    members.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 开始的最佳方式是建立一个坚实的基础。这就是为什么我们将专注于构建我们应用程序的基础结构。一个好的基础给你模块化和灵活性，文件也应该很容易被你和你团队成员找到。
- en: Always start with something simple and start building around it. As your application
    grows, you'll probably outgrow your initial application structure, so thinking
    ahead will bring you big benefits in the long run.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总是以简单的东西开始，然后围绕它构建。随着你的应用程序增长，你可能会超出你最初的应用程序结构，所以提前思考会给你带来长远的好处。
- en: Folder structure
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: 'Before jumping in and building your features right away, you should take a
    moment and sketch out your initial application''s structure. In the planning process,
    a pen and paper should always do it, but I''ve already saved some time and come
    up with an initial version:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接开始构建你的功能之前，你应该花点时间勾勒出你初始应用程序的结构。在规划过程中，一支笔和一张纸总是足够的，但我已经节省了一些时间并提出了一个初始版本：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s take a look at a more detailed explanation of our folder structure:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们对文件夹结构的更详细解释：
- en: '`app`: This folder contains all the server files used in the application:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`: 这个文件夹包含应用程序中使用的所有服务器文件：'
- en: '`controllers`: This folder is going to store the application controllers, mainly
    the backend business logic.'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controllers`: 这个文件夹将存储应用程序控制器，主要是后端业务逻辑。'
- en: '`middlewares`: In this folder, we''ll store all our pieces of functions that
    will manipulate the request and response object. A good example would be an authentication
    middleware.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`middlewares`: 在这个文件夹中，我们将存储所有将操作请求和响应对象的函数片段。一个很好的例子就是一个身份验证中间件。'
- en: '`models`: This folder will store all the backend models.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models`: 这个文件夹将存储所有后端模型。'
- en: '`routes`: This folder will contain all the routing files, which is where we
    are going to define all Express routes.'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`: 这个文件夹将包含所有路由文件，这是我们定义所有Express路由的地方。'
- en: '`config`: All application configuration files go here:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`: 所有应用程序配置文件都放在这里：'
- en: '`environments`: This folder contains files loaded according to the current
    environment'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environments`: 这个文件夹包含根据当前环境加载的文件'
- en: '`strategies`: All your authentication strategies should go here'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategies`: 所有你的身份验证策略都应该放在这里'
- en: '`tests`: This folder contains all the tests necessary to test the application
    backend logic:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`: 这个文件夹包含测试应用程序后端逻辑所需的所有测试：'
- en: '`integration`: If something uses external modules, it''s good practice to create
    an integration test'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`integration`: 如果某些东西使用了外部模块，创建一个集成测试是个好习惯'
- en: '`unit`: This should contain tests for small units of code, such as password
    hashing'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unit`: 这应该包含对小型代码单元的测试，例如密码散列'
- en: '`public`: This should contain all the static files served by our application.
    I like this separation because it''s easy to just tell another web server to handle
    our static files. Let''s say you want nginx to handle static file serving:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`: 这个文件夹应该包含我们应用程序提供的所有静态文件。我喜欢这种分离，因为它很容易让另一个Web服务器来处理我们的静态文件。比如说，你想让nginx来处理静态文件服务：'
- en: '`app`: This is our client-side application''s folder. All compiled TypeScript
    files will go here. This folder should be automatically populated.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`: 这是我们的客户端应用程序文件夹。所有编译后的TypeScript文件都将放在这里。这个文件夹应该自动填充。'
- en: '`src`: This folder contains all the client-side files used to build our application.
    We are going to use TypeScript to build our Angular application.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：这个文件夹包含所有用于构建我们应用程序的客户端文件。我们将使用 TypeScript 来构建我们的 Angular 应用程序。'
- en: '`typings`: This contains TypeScript definitions.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typings`：这包含 TypeScript 定义。'
- en: Server-side package.json
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端 package.json
- en: 'After setting up the initial folder structure, the next thing to do is to create
    the `package.json` file. This file will hold all the application''s metadata and
    dependencies. The `package.json` file will be placed at the root of our project
    folder. The path should be `contact-manager/package.json`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置初始文件夹结构之后，接下来要做的事情是创建 `package.json` 文件。这个文件将包含所有应用程序的元数据和依赖项。`package.json`
    文件将放置在我们的项目文件夹根目录。路径应该是 `contact-manager/package.json`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We added a few scripts to our `package.json` file to run our unit and integration
    tests and compile the Less files. You can always use `npm` to directly run different
    scripts instead of using build tools such as Grunt or Gulp.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的 `package.json` 文件中添加了一些脚本以运行我们的单元和集成测试以及编译 Less 文件。你始终可以使用 `npm` 直接运行不同的脚本，而不是使用构建工具，如
    Grunt 或 Gulp。
- en: 'At the time of writing this book, we are using the defined dependencies and
    their versions. This should do it for now. Let''s install them using the following
    command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，我们正在使用定义的依赖项及其版本。现在这应该足够了。让我们使用以下命令安装它们：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You should see `npm` pulling a bunch of files and adding the necessary dependencies
    to the `node_modules` folder. Wait patiently until everything is installed and
    done. You will be returned to Command Prompt. Now you should see the `node_modules`
    folder created and with all the dependencies in place.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到 `npm` 正在拉取一些文件并将必要的依赖项添加到 `node_modules` 文件夹中。耐心等待直到一切安装完成。你将返回到命令提示符。现在你应该看到已创建的
    `node_modules` 文件夹，并且所有依赖项都已就位。
- en: The first application file
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个应用程序文件
- en: 'Before everything, we need to create a simple configuration file for our environment.
    Let''s create the file in the `config` folder at `contact-manager/config/environments/development.js`
    and add the following content:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，我们需要为我们的环境创建一个简单的配置文件。让我们在 `config` 文件夹中创建文件，位于 `contact-manager/config/environments/development.js`，并添加以下内容：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let''s create the main `server.js` file for our application. This file
    will be the heart of our application. The file should be in the root of our folder,
    `contact-manager/server.js`. Start with the following lines of code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的应用程序创建主要的 `server.js` 文件。这个文件将是我们的应用程序的核心。该文件应位于我们的文件夹根目录，`contact-manager/server.js`。从以下代码行开始：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We define some of our main dependencies and initialize the necessary modules
    of our application. To modularize things, we are going to put each package of
    our stack into a separate configuration file. These configuration files will have
    some logic in them. I like to call them smart configuration files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一些主要依赖项并初始化了应用程序必要的模块。为了模块化，我们将把我们的堆栈中的每个包放入单独的配置文件中。这些配置文件中会包含一些逻辑。我喜欢称它们为智能配置文件。
- en: Don't worry! We are going to go through each config file one by one. Finally,
    we will export our Express app instance. If our module is not loaded by another
    module, for example, a test case, then we can safely start listening to incoming
    requests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心！我们将逐个查看每个配置文件。最后，我们将导出我们的 Express 应用程序实例。如果我们的模块没有被另一个模块加载，例如，一个测试用例，那么我们可以安全地开始监听传入的请求。
- en: Creating the Express configuration file
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Express 配置文件
- en: 'We need to create a configuration file for Express. The file should be created
    in the `config` folder at `contact-manager/config/express.js` and we have to add
    the following lines of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为 Express 创建一个配置文件。该文件应创建在 `config` 文件夹中，位于 `contact-manager/config/express.js`，并且我们必须添加以下代码行：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should be familiar with many lines from the preceding code by now, for example,
    setting the desired body parser of our Express application. Also, we set up the
    session management, and just in case we set to the server static files, we define
    the path to the server files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉了前面代码中的许多行，例如，设置我们 Express 应用的期望体解析器。此外，我们还设置了会话管理，以防万一我们还需要设置服务器静态文件，我们定义了服务器文件的路径。
- en: In a production environment, you should use something different from the default
    in-memory storage for sessions. That's why we added a special session store, which
    will store data in MongoDB.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，你应该使用与默认内存存储不同的东西来存储会话。这就是为什么我们添加了一个特殊的会话存储，它将在 MongoDB 中存储数据。
- en: 'A good practice to get the global environment configuration file is to set
    a root config file that all application files will load, create a new file called
    `contact-manager/config/index.js`, and add this code to it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 获取全局环境配置文件的一个好做法是设置一个根配置文件，所有应用程序文件都将加载，创建一个名为`contact-manager/config/index.js`的新文件，并将以下代码添加到其中：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code will just load the necessary environment configuration file
    based on the `NODE_ENV` process environment variable. If the environment variable
    is not present, a default development state will be considered for the application.
    This is a good practice so that we don't make mistakes and connect to the wrong
    database.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将仅根据`NODE_ENV`进程环境变量加载必要的环境配置文件。如果环境变量不存在，则将考虑应用程序的默认开发状态。这是一个好的做法，以免我们犯错误并连接到错误的数据库。
- en: 'Usually, the `NODE_ENV` variable can be set when you start your node server;
    for example, under Unix systems, you can run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以在启动您的node服务器时设置`NODE_ENV`变量；例如，在Unix系统中，您可以运行以下命令：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Setting up mocha for testing
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置mocha进行测试
- en: Before we implement any functionality, we are going to write tests for it. Mocha
    is a testing framework built on Node.js. This approach will give us the advantage
    of knowing what code we are going to write and testing our Node.js API before
    even writing a single line of the client application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现任何功能之前，我们将为其编写测试。Mocha是一个基于Node.js的测试框架。这种方法将使我们能够知道我们将要编写的代码，并在编写客户端应用程序的任何一行代码之前测试我们的Node.js
    API。
- en: 'If you don''t have Mocha, you can install it globally. If you want Mocha to
    be globally available in your command line, run the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有Mocha，您可以在全局范围内安装它。如果您希望Mocha在您的命令行中全局可用，请运行以下命令：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Setting up Mongoose
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Mongoose
- en: In order to store data in MongoDB, we are going to use Mongoose. Mongoose provides
    an easy way to define schemas to model application data. We have already included
    mongoose in the `package.json` file, so it should be installed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在MongoDB中存储数据，我们将使用Mongoose。Mongoose提供了一个定义用于模型应用程序数据的模式的方法。我们已经在`package.json`文件中包含了mongoose，因此它应该已经安装。
- en: 'We need to create a config file for our mongoose library. Let''s create our
    config file `contact-manager/config/mongoose.js`. First, we start by loading the
    Mongoose library, getting the appropriate environment config, and establishing
    a connection with the database. Add the following code to the `mongoose.js` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的mongoose库创建一个配置文件。让我们创建我们的配置文件`contact-manager/config/mongoose.js`。首先，我们开始加载Mongoose库，获取适当的环境配置，并与数据库建立连接。将以下代码添加到`mongoose.js`文件中：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Also, we are using a `cleanup()` function to close all connections to the MongoDB
    database. The preceding code will export the necessary `init()` function used
    in the main `server.js` file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们正在使用`cleanup()`函数来关闭与MongoDB数据库的所有连接。前面的代码将导出在主`server.js`文件中使用的必要`init()`函数。
- en: Managing contacts
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理联系人
- en: Now that we have the files necessary to start development and add features,
    we can start implementing all of the business logic related to managing contacts.
    To do this, we first need to define the data model of a contact.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了启动开发和添加功能所需的文件，我们可以开始实现所有与联系人管理相关的业务逻辑。为此，我们首先需要定义联系人的数据模型。
- en: Creating the contact mongoose schema
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建联系人mongoose模式
- en: 'Our system needs some sort of functionality to store the possible clients or
    just contact persons of other companies. For this, we are going to create a contact
    schema that will represent the same collection storing all the contacts in MongoDB.
    We are going to keep our contact schema simple. Let''s create a model file in
    `contact-manager/app/models/contact.js`, which will hold the schema, and add the
    following code to it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统需要某种功能来存储可能的客户或只是其他公司的联系人。为此，我们将创建一个表示存储MongoDB中所有联系人的相同集合的联系人模式。我们将保持我们的联系人模式简单。让我们在`contact-manager/app/models/contact.js`中创建一个模型文件，它将包含模式，并将以下代码添加到其中：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following table gives a description of the fields in the schema:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格给出了模式中字段的描述：
- en: '| Field | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `email` | The e-mail of the contact |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `email` | 联系人的电子邮件地址 |'
- en: '| `name` | The full name of the contact |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 联系人的全名 |'
- en: '| `company` | The name of the company at which the contact person works |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `company` | 联系人工作的公司的名称 |'
- en: '| `phoneNumber` | The full phone number of the person or company |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `phoneNumber` | 人员的完整电话号码或公司的电话号码 |'
- en: '| `city` | The location of the contact |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `city` | 联系人的位置 |'
- en: '| `createdAt` | The date at which the contact object was created |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `createdAt` | 联系人对象被创建的日期 |'
- en: 'All our model files will be registered in the following configuration file,
    found under `contact-manager/config/models.js`. The final version of this file
    will look something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的模型文件都将注册在以下配置文件中，该文件位于 `contact-manager/config/models.js` 下。该文件的最终版本将类似于以下内容：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Describing the contact route
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述联系人路由
- en: In order to communicate with the server, we need to expose routes for client
    applications to consume. These are going to be endpoints (URIs) that respond to
    client requests. Mainly, our routes will send a JSON response.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与服务器通信，我们需要为客户端应用程序提供路由以供消费。这些将是响应客户端请求的端点（URI）。主要，我们的路由将发送 JSON 响应。
- en: 'We are going to start by describing the CRUD functionality of the contact module.
    The routes should expose the following functionalities:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先描述联系人模块的 CRUD 功能。路由应公开以下功能：
- en: Create a new contact
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的联系人
- en: Get a contact by ID
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ID 获取联系人
- en: Get all contacts
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有联系人
- en: Update a contact
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新联系人
- en: Delete a contact by ID
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ID 删除联系人
- en: We are not going to cover bulk insert and delete in this application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们不会涵盖批量插入和删除。
- en: 'The following table shows how these operations can be mapped to HTTP routes
    and verbs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了这些操作如何映射到 HTTP 路由和动词：
- en: '| Route | Verb | Description | Data |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 路由 | 动词 | 描述 | 数据 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `/contacts` | `POST` | Create a new contact | `email`, `name`, `company`,
    `phoneNumber`, and `city` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `/contacts` | `POST` | 创建新的联系人 | `email`、`name`、`company`、`phoneNumber` 和
    `city` |'
- en: '| `/contacts` | `GET` | Get all contacts from the system |   |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `/contacts` | `GET` | 从系统中获取所有联系人 |   |'
- en: '| `/contacts/<id>` | `GET` | Get a particular contact |   |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `/contacts/<id>` | `GET` | 获取特定的联系人 |   |'
- en: '| `/contacts/<id>` | `PUT` | Update a particular contact | `email`, `name`,
    `company`, `phoneNumber`, and `city` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `/contacts/<id>` | `PUT` | 更新特定的联系人 | `email`、`name`、`company`、`phoneNumber`
    和 `city` |'
- en: '| `/contacts/<id>` | `DELETE` | Delete a particular contact |   |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `/contacts/<id>` | `DELETE` | 删除特定的联系人 |   |'
- en: Following the earlier table as a guide, we are going to describe our main functionality
    and test using Mocha. Mocha allows us to describe the features that we are implementing
    by giving us the ability to use a describe function that encapsulates our expectations.
    The first argument of the function is a simple string that describes the feature.
    The second argument is a function body that represents the description.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的表格作为指南，我们将描述我们的主要功能和使用 Mocha 进行测试。Mocha 允许我们通过提供封装我们期望的 `describe()` 函数的能力来描述我们正在实施的功能。函数的第一个参数是一个简单的字符串，描述了功能。第二个参数是一个函数体，代表了描述。
- en: 'You have already created a folder called `contact-manger/tests`. In your `tests`
    folder, create another folder called `integration`. Create a file called `contact-manager/tests/integration/contact_test.js`
    and add the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经创建了一个名为 `contact-manger/tests` 的文件夹。在您的 `tests` 文件夹中，创建另一个名为 `integration`
    的文件夹。创建一个名为 `contact-manager/tests/integration/contact_test.js` 的文件，并添加以下代码：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our test file, we required our dependencies and used Chai as our assertion
    library. As you can see, besides the `describe()` function, mocha gives us additional
    methods: `before()`, `after()`, `beforeEach()`, and `afterEach()`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试文件中，我们要求了依赖项，并使用 Chai 作为我们的断言库。正如您所看到的，除了 `describe()` 函数外，mocha 还为我们提供了额外的方法：`before()`、`after()`、`beforeEach()`
    和 `afterEach()`。
- en: These are hooks and they can be async or sync, but we are going to use the async
    version of them. Hooks are useful for preparing preconditions before running tests;
    for example, you can populate your database with mock data or clean it up.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是钩子，可以是异步或同步的，但我们将使用它们的异步版本。钩子对于在运行测试之前准备先决条件非常有用；例如，您可以用模拟数据填充您的数据库或清理它。
- en: 'In the main description body, we used three hooks: `before()`, `after()`, and
    `afterEach()`. In the `before()` hook, which will run before any of the `describe()`
    functions, we set up our server to listen on a given port, and we called the `done()`
    function when the server started listening.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在主要描述主体中，我们使用了三个钩子：`before()`、`after()` 和 `afterEach()`。在 `before()` 钩子中，它将在任何
    `describe()` 函数之前运行，我们设置服务器监听指定的端口，并在服务器开始监听时调用 `done()` 函数。
- en: The `after()` function will run after all the `describe()` functions have finished
    running and will stop the server from running. Now, the `afterEach()` hook will
    run after each `describe()` function, and it will grant us the ability to remove
    all the contacts from the database after running each test.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`after()` 函数将在所有 `describe()` 函数运行完毕后执行，并将停止服务器运行。现在，`afterEach()` 钩子将在每个 `describe()`
    函数之后运行，并允许我们在每个测试运行后从数据库中删除所有联系人。'
- en: The final version can be found in the code bundle of the application. You can
    still follow how we add all the necessary descriptions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最终版本可以在应用程序的代码包中找到。您仍然可以了解我们如何添加所有必要的描述。
- en: Creating a contact
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建联系人
- en: 'We also added four to five individual descriptions that will define CRUD operations
    from the earlier table. First, we want to be able to create a new contact. Add
    the following code to the test case:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了四到五个单独的描述，这些描述将定义之前表格中的 CRUD 操作。首先，我们希望能够创建一个新的联系人。将以下代码添加到测试用例中：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Getting contacts
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取联系人
- en: 'Next, we want to get all contacts from the system. The following code should
    describe this functionality:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望从系统中获取所有联系人。以下代码应描述此功能：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we've also added a `before()` hook in the description. This
    is absolutely normal and can be done. Mocha permits this behavior in order to
    easily set up preconditions. We used a bulk insert, `Contact.collection.insert()`,
    to add data into MongoDB before getting all the contacts.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在描述中添加了一个 `before()` 钩子。这是绝对正常的，并且可以这样做。Mocha 允许这种行为以便轻松设置先决条件。我们在获取所有联系人之前，使用批量插入
    `Contact.collection.insert()` 将数据添加到 MongoDB 中。
- en: Getting a contact by ID
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 ID 获取联系人
- en: 'When getting a contact by ID, we would also want to check whether the inserted
    ID meets our `ObjectId` criteria. If a contact is not found, we will want to return
    a 404 HTTP status code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 ID 获取联系人时，我们还想检查插入的 ID 是否符合我们的 `ObjectId` 标准。如果未找到联系人，我们希望返回 404 HTTP 状态码：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We used the `.create()` method. It's more convenient to use it for single inserts,
    to prepopulate the database with data. When getting a single contact by ID we
    want to ensure that it's a valid ID, so we added a test which should reflect this
    and get a `404 Not Found` response if it's invalid, or no contact was found.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `.create()` 方法。对于单条插入，使用它更为方便，可以预先将数据填充到数据库中。当我们通过 ID 获取单个联系人时，我们想要确保这是一个有效的
    ID，因此我们添加了一个测试来反映这一点，如果 ID 无效或未找到联系人，则应返回 `404 Not Found` 响应。
- en: Updating a contact
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新联系人
- en: 'We also want to be able to update an existing contact with a given ID. Add
    the following code to describe this functionality:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够使用给定的 ID 更新现有的联系人。添加以下代码来描述此功能：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Removing a contact
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除联系人
- en: 'Finally, we''ll describe the remove contact operation (DELETE from CRUD) by
    adding the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过添加以下代码来描述删除联系人操作（CRUD 中的 DELETE）：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After deleting a contact, the server should respond with an `HTTP 204 No Content`
    status code, meaning that the server has successfully interpreted the request
    and processed it, but no content should be returned due to the fact that the contact
    was deleted successfully.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除联系人后，服务器应响应 `HTTP 204 No Content` 状态码，这意味着服务器已成功解析请求并处理它，但由于联系人已成功删除，不应返回任何内容。
- en: Running our tests
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行我们的测试
- en: 'Suppose we run the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们运行以下命令：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At this point, we will get a bunch of `HTTP 404 Not Found` status codes, because
    our routes are not implemented yet. The output should be similar to something
    like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将收到大量的 `HTTP 404 Not Found` 状态码，因为我们的路由尚未实现。输出应类似于以下内容：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implementing the contact routes
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现联系人路由
- en: 'Now, we''ll start implementing the contact CRUD operations. We''ll begin by
    creating our controller. Create a new file, `contact-manager/app/controllers/contact.js`,
    and add the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始实现联系人 CRUD 操作。我们将首先创建我们的控制器。创建一个新的文件，`contact-manager/app/controllers/contact.js`，并添加以下代码：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What the preceding code does is export all methods of the controller for CRUD
    operations. To create a new contact, we use the `create()` method from the `Contact`
    schema.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码所做的是导出控制器中所有用于 CRUD 操作的方法。为了创建一个新的联系人，我们使用 `Contact` 架构中的 `create()` 方法。
- en: We are returning a JSON response with the newly created contact. In case of
    an error, we just call the `next()` function with the error object. We will add
    a special handler to catch all of our errors later.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回一个包含新创建联系人的 JSON 响应。如果发生错误，我们只需使用错误对象调用 `next()` 函数。我们将在稍后添加一个特殊处理程序来捕获所有错误。
- en: 'Let''s create a new file for our routes, `contact-manager/app/routes/contacts.js`.
    The following lines of code should be a good start for our router:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的路由创建一个新的文件，`contact-manager/app/routes/contacts.js`。以下代码行应该是我们路由器的良好开端：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Suppose we run our test now using this, like:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在使用这个运行测试，如下所示：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We should get something similar to the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到类似以下的内容：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Adding all endpoints
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加所有端点
- en: 'Next, we will add the rest of the routes, by adding the following code into
    the `contact-manager/app/routes/contact.js` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加其余的路由，通过将以下代码添加到`contact-manager/app/routes/contact.js`文件中：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We defined all the routes and also added a callback trigger to the `contactId`
    route parameter. In Express, we can add callback triggers on route parameters
    using the `param()` method with the name of a parameter and a callback function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了所有路由，并为`contactId`路由参数添加了回调触发。在Express中，我们可以使用名为参数名称的`param()`方法添加回调触发。
- en: 'The callback function is similar to any normal route callback, but it gets
    an extra parameter representing the value of the route parameter. A concrete example
    would be as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数类似于任何正常的路由回调，但它会多一个参数，表示路由参数的值。一个具体的例子如下：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Following the preceding example, when :`contactId` is present in a route path,
    we can map a contact loading logic and provide the contact to the next handler.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的示例，当`:contactId`在路由路径中存在时，我们可以映射联系人加载逻辑，并将联系人提供给下一个处理器。
- en: Finding a contact by ID
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过ID查找联系人
- en: 'We are going to add the rest of the missing functionalities in our controller
    file, located at `contact-manager/app/controllers/contact.js`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在位于`contact-manager/app/controllers/contact.js`的控制器文件中添加其余缺失的功能：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding function is a special case. It will get four parameter, and the
    last one will be the ID matching the triggered parameters value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数是一个特殊情况。它将获取四个参数，最后一个将是与触发参数值匹配的ID。
- en: Getting contact information
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取联系人信息
- en: 'To get all contacts, we are going to query the database. We will sort our results
    based on the creation date. One good practice is to always limit your returned
    dataset''s size. For that, we use a `MAX_LIMIT` constant:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有联系人，我们将查询数据库。我们将根据创建日期对结果进行排序。一个好的做法是始终限制返回的数据集的大小。为此，我们使用`MAX_LIMIT`常量：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To return a single contact, you can use the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回单个联系人，你可以使用以下代码：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Theoretically, we'll have the :`contactId` parameter in a route definition.
    In that case, the `param` callback is triggered, populating the `req` object with
    the requested contact.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们将在路由定义中拥有`:contactId`参数。在这种情况下，`param`回调会被触发，将请求的联系人填充到`req`对象中。
- en: Updating a contact
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新联系人
- en: 'The same principle is applied when updating a contact; the requested entity
    should be populated by the `param` callback. We just need to assign the incoming
    data to the contact object and save the changes into MongoDB:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新联系人时，也应用了相同的原则；请求的实体应由`param`回调填充。我们只需将传入的数据分配给联系人对象，并将更改保存到MongoDB中：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Removing a contact
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除联系人
- en: 'Removing a contact should be fairly simple, as it has no dependent documents.
    So, we can just remove the document from the database, using the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 删除联系人应该相当简单，因为它没有依赖的文档。因此，我们可以简单地从数据库中删除文档，使用以下代码：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Running the contact test
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行联系人测试
- en: 'At this point, we should have implemented all the requirements for managing
    contacts on the backend. To test everything, we run the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该已经实现了后端管理联系人的所有要求。为了测试一切，我们运行以下命令：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output should be similar to this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means that all the tests have passed successfully and we have implemented
    all the requirements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有测试都成功通过，并且我们已经实现了所有要求。
- en: Securing your application routes
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护应用程序路由
- en: You probably don't want to let anyone see your contacts, so it's time to secure
    your endpoints. There are many strategies that we can use to authenticate trusted
    users in an application. We are going to use a classic, state-full e-mail and
    password based authentication. This means that the session will be stored on the
    server side.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不希望让任何人看到你的联系人，所以是时候保护你的端点了。我们可以使用许多策略来在应用程序中验证受信任的用户。我们将使用经典的、基于状态的全局电子邮件和密码验证。这意味着会话将存储在服务器端。
- en: Remember we discussed at the beginning of the chapter how we are going to store
    our session on the server side? We choose two integrations, one with default in-memory
    session management and one that stores sessions in MongoDB. Everything is configurable
    from the environment configuration file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在本章开头讨论了我们将如何将我们的会话存储在服务器端吗？我们选择了两个集成，一个是默认的内存会话管理，另一个是将会话存储在MongoDB中。所有这些都可以从环境配置文件中进行配置。
- en: When it comes to handling authentication in Node.js, a good go-to module is
    Passport, which is a piece of authentication middleware. Passport has a comprehensive
    set of authentication strategies using a simple username-and-password combination
    for Facebook, Google, Twitter, and many more.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在Node.js中处理认证时，一个好的选择是Passport模块，它是一块认证中间件。Passport提供了一套全面的认证策略，使用简单的用户名和密码组合来支持Facebook、Google、Twitter等许多服务。
- en: We have already added this dependency to our application and made the necessary
    initializations in the express configuration file. We still need to add a few
    things, but before that, we have to create some reusable components in our backend
    application. We are going to create a helper file that will ease our interactions
    with passwords.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将此依赖项添加到我们的应用程序中，并在express配置文件中进行了必要的初始化。我们仍然需要添加一些内容，但在那之前，我们必须在我们的后端应用程序中创建一些可重用的组件。我们将创建一个辅助文件，这将简化我们与密码的交互。
- en: Describing the password helper
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述密码辅助器
- en: Before we dive deeper into the authentication mechanism, we need to be able
    to store in MongoDB a password hash instead of the plain password. We want to
    create a helper for this task that enables us to make operations related to passwords.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨认证机制之前，我们需要能够在MongoDB中存储密码哈希而不是明文密码。我们希望创建一个辅助器来完成这个任务，使我们能够执行与密码相关的操作。
- en: 'Create a new folder in the `tests` folder, named `unit`. Add a new file, `contact-manager/tests/unit/password.test.js`,
    and then add the following code to it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tests`文件夹中创建一个新的文件夹，命名为`unit`。添加一个新文件，`contact-manager/tests/unit/password.test.js`，然后向其中添加以下代码：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In our main description body, we are going to add segments that represent our
    features in more detail. Add this code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主要描述体中，我们将添加代表我们功能的详细段。添加以下代码：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Mocha also provides an `it()` function, which we are going to use to set up
    a concrete test. The `it()` function is very similar to `describe()`, except that
    we put only what the feature is supposed to do. For assertion, we are going to
    use the Chai library. Add the following code to the `tests/unit/password.test.js`
    file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha还提供了一个`it()`函数，我们将使用它来设置一个具体的测试。`it()`函数与`describe()`非常相似，只不过我们只放置了功能应该执行的内容。对于断言，我们将使用Chai库。将以下代码添加到`tests/unit/password.test.js`文件中：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `passwordHelper` should also test whether a password matches the given
    hash and salt combo. For this, we are going to add the following describe method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`passwordHelper`还应测试密码是否与给定的哈希和盐组合匹配。为此，我们将添加以下描述方法：'
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Implementing the password helper
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现密码辅助器
- en: 'We will implement our password helper in the following file: `contact-manager/app/helpers/password.js`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下文件中实现我们的密码辅助器：`contact-manager/app/helpers/password.js`。
- en: The first description of our password helper describes a function that creates
    a hash from a plain password. In our implementation, we will use a key derivation
    function that will compute a hash from our password, also known as key stretching.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们密码辅助器的第一个描述描述了一个从明文密码创建哈希的函数。在我们的实现中，我们将使用一个密钥派生函数，它将从我们的密码计算哈希，也称为密钥拉伸。
- en: We are going to use the `pbkdf2` function from the built-in Node.js `crypto`
    library. The asynchronous version of the function takes a plain password and applies
    an HMAC digest function. We will use `sha256` to get a derived key of a given
    length, combined with a salt through a number of iterations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用内置的Node.js `crypto`库中的`pbkdf2`函数。该函数的异步版本接受一个明文密码并应用HMAC摘要函数。我们将使用`sha256`来获取给定长度的派生密钥，并通过多次迭代与盐结合。
- en: 'We want to use the same hashing function for both cases: when we already have
    a password hash and a salt and when we have only a plain password. Let''s see
    the final code for our hashing function. Add the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对于两种情况都使用相同的哈希函数：当我们已经有一个密码哈希和一个盐时，以及当我们只有明文密码时。让我们看看我们的哈希函数的最终代码。添加以下内容：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s see what we get if we run our tests now. Run the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在运行我们的测试会得到什么。运行以下命令：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output should be similar to this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we have successfully implemented our hashing function. All the
    requirements from the test case have passed. Notice that it takes up to 2 seconds
    to run the tests. Don't worry about this; it's because of the key stretching function
    taking time to generate the hash from the password.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经成功实现了我们的哈希函数。所有测试用例的要求都已通过。请注意，运行测试可能需要最多2秒钟。不用担心这个问题；这是因为密钥拉伸函数需要时间从密码生成哈希值。
- en: 'Next, we are going to implement the `verify()` function, which checks whether
    a password matches an existing user''s password-hash-and-salt combination. From
    the description in our tests, this function accepts four parameters: the plain
    password, a hash that was generated using the third salt parameter, and a callback
    function.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 `verify()` 函数，该函数检查密码是否与现有用户的密码-哈希-盐组合匹配。根据我们的测试描述，此函数接受四个参数：明文密码、使用第三个盐参数生成的哈希值，以及回调函数。
- en: 'The callback gets two arguments: `err` and `result`. The `result` can be `true`
    or `false`. This will reflect whether the password matches the existing hash or
    not. Considering the constraints from the tests and the preceding explanation,
    we can append the following code to our `password.helpr.js` file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接收两个参数：`err` 和 `result`。`result` 可以是 `true` 或 `false`。这将反映密码是否与现有的哈希值匹配。考虑到测试的约束和前面的解释，我们可以在
    `password.helpr.js` 文件中添加以下代码：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By now, we should have implemented all the specifications from our tests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该已经实现了测试中所有的规范。
- en: Creating the user Mongoose schema
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户 Mongoose 模式
- en: 'In order to grant access to users in the application, we need to store them
    in a MongoDB collection. We''ll create a new file called `contact-manager/app/models/user.model.js`
    and add the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了授予应用程序中用户的访问权限，我们需要将它们存储在 MongoDB 集合中。我们将创建一个名为 `contact-manager/app/models/user.model.js`
    的新文件，并添加以下代码：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following table gives a description of the fields in the schema:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了模式中的字段：
- en: '| Field | Description |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `email` | The e-mail of the user. This is used to identify the user. E-mails
    will be unique in the system. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `email` | 用户的电子邮件。这用于识别用户。电子邮件在系统中将是唯一的。 |'
- en: '| `name` | The full name of the user. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 用户的完整姓名。 |'
- en: '| `password` | This is the password provided by the user. It will not be stored
    in plaintext in the database but in a hashed form instead. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `password` | 这是用户提供的密码。它不会以明文形式存储在数据库中，而是以哈希形式存储。 |'
- en: '| `passwordSalt` | Every password will be generated using a unique salt for
    the given user. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `passwordSalt` | 每个密码都将为给定用户生成一个唯一的盐。 |'
- en: '| `active` | This specifies the state of the user. It can be active or inactive.
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `active` | 这指定了用户的状态。可以是活跃的或非活跃的。 |'
- en: '| `createdAt` | The date when the user was created. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `createdAt` | 用户创建的日期。 |'
- en: Describing the authentication method from the user model
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从用户模型描述身份验证方法
- en: 'We''ll describe a user authentication method. It will check whether a user
    has valid credentials. The following file, `contact-manager/tests/integration/user.model.test.js`,
    should contain all the test cases regarding the `User` model. These lines of code
    will test the `authenticate()` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述一个用户身份验证方法。它将检查用户是否有有效的凭据。以下文件 `contact-manager/tests/integration/user.model.test.js`
    应包含有关 `User` 模型的所有测试用例。以下代码行将测试 `authenticate()` 方法：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Implementing the authentication method
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现身份验证方法
- en: Mongoose lets us add static methods to compiled models from schemas. The `authenticate()`
    method will search for a user in the database by its e-mail and use the password
    helper's `verify()` function to check whether the sent password is a match.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 允许我们从模式中添加静态方法到编译后的模型。`authenticate()` 方法将通过电子邮件在数据库中搜索用户，并使用密码辅助器的
    `verify()` 函数检查发送的密码是否匹配。
- en: 'Add the following lines of code to the `contact-manager/app/models/user.js`
    file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码行添加到 `contact-manager/app/models/user.js` 文件中：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, when selecting the user from MongoDB, we explicitly selected
    the password and `passwordSalt` fields. This was necessary because we set the
    password and `passwordSalt` fields to not be selected in the query result. Another
    thing to note is that we want to remove the password and salt from the result
    when returning the user.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当从 MongoDB 中选择用户时，我们明确选择了密码和 `passwordSalt` 字段。这是必要的，因为我们设置了密码和 `passwordSalt`
    字段，使其不在查询结果中选中。另外，需要注意的是，我们希望在返回用户时从结果中移除密码和盐。
- en: Authentication routes
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证路由
- en: In order to authenticate in the system we are building, we need to expose some
    endpoints that will execute the necessary business logic to authenticate a user
    with valid credentials. Before jumping into any code, we are going to describe
    the desired behavior.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的系统中进行认证，我们需要公开一些端点来执行必要的业务逻辑以验证具有有效凭证的用户。在深入任何代码之前，我们将描述期望的行为。
- en: Describing the authentication routes
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述认证路由
- en: 'We are only going to take a look at a partial code from the integration test
    of the authentication functionality, found in `contact-manager/tests/integration/authentication.test.js`.
    It should look something like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只将查看认证功能集成测试的部分代码，该代码位于`contact-manager/tests/integration/authentication.test.js`中。它应该看起来像这样：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So, we've described an `auth/signin` endpoint; it will authenticate a user using
    an e-mail-and-password combination. We are testing two scenarios. The first one
    is when a user has valid credentials and the second is when an incorrect password
    is sent.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们描述了一个`auth/signin`端点；它将使用电子邮件和密码组合来验证用户。我们正在测试两种场景。第一种是用户具有有效凭证，第二种是发送了错误的密码。
- en: Integrating Passport
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成Passport
- en: 'We mentioned Passport earlier in the chapter and added some basic logic for
    this purpose, but we still need to make a proper integration. The Passport module
    should already be installed and the session management is already in place. So
    next, we need to create a proper configuration file, `contact-manager/config/passport.js`,
    and add the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节中提到了Passport并添加了一些基本逻辑，但我们仍然需要正确集成。Passport模块应该已经安装，会话管理也已经就绪。因此，接下来我们需要创建一个适当的配置文件，`contact-manager/config/passport.js`，并添加以下内容：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For each subsequent request, we need to serialize and deserialize the user instance
    to and from the session. We are only going to serialize the user's ID into the
    session. When subsequent requests are made, the user's ID is used to find the
    matching user and restore the data in `req.user`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个后续请求，我们需要将用户实例序列化和反序列化到会话中。我们只将用户的ID序列化到会话中。当后续请求被发起时，用户的ID被用来找到匹配的用户并在`req.user`中恢复数据。
- en: 'Passport gives us the ability to use different strategies to authenticate our
    users. We are only going to use e-mail and password to authenticate a user. To
    keep everything modular, we are going to move the strategies into separate files.
    The so-called local strategy, which will be used to authenticate users using an
    e-mail and a password, is going to be in the `contact-manager/config/strategies/local.js`
    file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Passport为我们提供了使用不同策略来验证用户的能力。我们只将使用电子邮件和密码来验证用户。为了保持模块化，我们将策略移动到单独的文件中。所谓的本地策略，将用于使用电子邮件和密码验证用户，它将位于`contact-manager/config/strategies/local.js`文件中：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Implementing the authentication routes
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现认证路由
- en: 'Now that we have passport up and running, we can define our authentication
    controller logic and a proper route to sign in users. Create a new file called
    `contact-manager/app/controllers/authentication.js`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了passport，我们可以定义我们的认证控制器逻辑和适当的登录用户路由。创建一个名为`contact-manager/app/controllers/authentication.js`的新文件：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we use the `.authenticate()` function from Passport to check a user''s
    credentials using the local strategy implemented earlier. Next, we are going to
    add the authentication route, create a new file called `contact-manager/app/routes/auth.js`,
    and add the following lines of code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Passport的`.authenticate()`函数来检查用户使用之前实现的本地策略的凭证。接下来，我们将添加认证路由，创建一个名为`contact-manager/app/routes/auth.js`的新文件，并添加以下代码行：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that we skipped the register user functionality, but don't worry! The final
    bundled project source code will have all of the necessary logic.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们跳过了注册用户的功能，但别担心！最终的捆绑项目源代码将包含所有必要的逻辑。
- en: Restricting access to contacts routes
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制对联系人路由的访问
- en: We created all the requirements to authenticate our users. Now it's time to
    restrict access to some of the routes, so technically we are going to create a
    simple ACL. To restrict access, we are going to use a piece of middleware that
    will check whether users are authenticated or not.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了所有验证用户的要求。现在，我们需要限制对一些路由的访问，因此技术上我们将创建一个简单的ACL。为了限制访问，我们将使用一个中间件来检查用户是否已认证。
- en: 'Let''s create our middleware file, `contact-manager/app/middlewares/authentication.js`.
    This should contain these lines of carefully crafted code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的中间件文件，`contact-manager/app/middlewares/authentication.js`。这个文件应该包含以下精心编写的代码：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We have already added the necessary logic to restrict users to the contact routes;
    that was when we first created them. We succeeded in adding all the necessary
    pieces of code to manage contacts and restrict access to our endpoints. Now we
    can continue and start building our Angular 2 application.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了必要的逻辑来限制用户访问联系人路由；那是在我们首次创建它们时。我们成功添加了所有必要的代码来管理联系人和限制对端点的访问。现在我们可以继续并开始构建我们的Angular
    2应用程序。
- en: Integrating Angular 2 into our application
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Angular 2 集成到我们的应用程序中
- en: The frontend application is going to be built using Angular 2\. At the time
    of writing this book, the project is still in beta, but it will come in handy
    to start playing around with Angular and have a good understanding of the environment.
    Most of the code will follow the official docs view of the tooling and integration
    methods.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用程序将使用 Angular 2 构建。在撰写本书时，该项目仍在测试版，但开始尝试使用 Angular 并对环境有良好理解将很有帮助。大部分代码将遵循官方文档中工具和集成方法的视图。
- en: 'When we first described our folder structure, we saw a `package.json` file
    for the client application too. Let''s take a look at it, found under the `contact-manager/public/package.json`
    path:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次描述我们的文件夹结构时，我们看到了客户端应用程序的 `package.json` 文件。让我们看一下它，位于 `contact-manager/public/package.json`
    路径下：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To install the necessary dependencies, just use the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装必要的依赖项，只需使用以下命令：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You will see `npm` pulling down different packages, specified in the `package.json`
    file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到 `npm` 正在拉取 `package.json` 文件中指定的不同包。
- en: 'As you can see, we''ll use TypeScript in our client-side application. If you
    have installed it globally, you can use the following command to compile and watch
    for changes to your `.ts` files:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将在客户端应用程序中使用 TypeScript。如果您已全局安装它，可以使用以下命令编译并监视 `.ts` 文件的变化：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Only the most important parts of the application will be discussed. The rest
    of the necessary files and folders can be found in the final bundled source code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 只会讨论应用程序最重要的部分。其余必要的文件和文件夹可以在最终的打包源代码中找到。
- en: Granting access to our application
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授予我们的应用程序访问权限
- en: We have restricted access to our API's endpoints, so now we have to grant users
    sign-in functionality from the client application. I like to group the Angular
    2 application files based on their domain context. So, for example, all our authentication,
    registration, and business logic should go into a separate folder; we can call
    it `auth`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经限制了我们对API端点的访问，因此现在我们必须从客户端应用程序中授予用户登录功能。我喜欢根据它们的领域上下文分组Angular 2应用程序文件。例如，所有我们的身份验证、注册和业务逻辑都应该放入一个单独的文件夹；我们可以称它为
    `auth`。
- en: If your module directory grows, it's good practice to break it down into separate
    folders based on their context by type. There is no magic number for the file
    count. Usually, you will get a good feeling when it's time to move files around.
    Your files should always be easy to locate and give you enough information from
    their placement in a certain context.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的模块目录增长，根据上下文按类型将其拆分为单独的文件夹是一种良好的做法。没有固定的文件数量。通常，当您需要移动文件时，您会有一个很好的感觉。您的文件应该始终易于定位，并从其在特定上下文中的位置提供足够的信息。
- en: AuthService
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AuthService
- en: 'We are going to use `AuthService` to implement the data access layer and make
    calls to the backend. This service is going to be the bridge between our API''s
    sign-in and register features. Create a new file called `contact-manager/src/auth/auth.service.ts`,
    and add the following TypeScript code into it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `AuthService` 来实现数据访问层并调用后端。这个服务将成为我们API的登录和注册功能之间的桥梁。创建一个名为 `contact-manager/src/auth/auth.service.ts`
    的新文件，并将以下 TypeScript 代码添加到其中：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We import the necessary modules, define the `AuthService` class, and export
    it. The Injectable marker metadata will mark our class to be available to be injected.
    In order to communicate with the backend, we use the HTTP service. Don't forget
    to add the `HTTP_PROVIDERS` when bootstrapping the application so that the service
    is available to be injected in the whole application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入必要的模块，定义 `AuthService` 类，并导出它。Injectable 标记元数据将标记我们的类以使其可供注入。为了与后端通信，我们使用HTTP服务。不要忘记在启动应用程序时添加
    `HTTP_PROVIDERS`，以便服务在整个应用程序中可用。
- en: 'To sign in a user, we are going to add the following method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要登录用户，我们将添加以下方法：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can use the `.map()` operator to transform the response into a JSON file.
    When performing HTTP requests, this will return an `Observable`. You have probably
    already figured it out—we are going to use **RxJs** (**Reactive Extensions**)
    heavily, which is a third-party library favored by Angular.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `.map()` 操作符将响应转换为 JSON 文件。在执行 HTTP 请求时，这将返回一个 `Observable`。你可能已经猜到了——我们将大量使用
    **RxJs**（**响应式扩展**），这是一个由 Angular 喜爱的第三方库。
- en: RxJs implements asynchronous observable pattern. In other words, it enables
    you to work with asynchronous data streams and apply different operators. Observables
    are used widely in Angular applications. At the time of writing this book, Angular
    2 exposes a stripped-down version of the `Observable` module from RxJs.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: RxJs 实现了异步可观察模式。换句话说，它使你能够处理异步数据流并应用不同的操作符。在 Angular 应用程序中广泛使用 Observables。在撰写本书时，Angular
    2 提供了 RxJs 的 `Observable` 模块的简化版本。
- en: 'Don''t worry; we''ll get familiar with this technique and the benefits of it
    as we dive further into the book. Now let''s continue with the rest of the missing
    methods we want to expose:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心；随着我们进一步深入本书，我们将熟悉这项技术和它的好处。现在让我们继续实现我们想要公开的其他缺失方法：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We added the `register()` method to our service, which will handle user registration.
    Also note that we moved our serialization into a separate private method. I've
    left this method in the same class so that it's easier to follow, but you can
    move it into a helper class.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的服务中添加了 `register()` 方法，它将处理用户注册。此外，请注意，我们将序列化移动到了一个单独的私有方法中。我保留了此方法在同一类中，以便更容易理解，但你也可以将其移动到辅助类中。
- en: User sign-in component
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户登录组件
- en: 'For a start, we are going to implement the sign-in component. Let''s create
    a new file called `contact-manager/public/src/auth/sigin.ts` and add the following
    lines of TypeScript code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现登录组件。让我们创建一个名为 `contact-manager/public/src/auth/sigin.ts` 的新文件，并添加以下
    TypeScript 代码行：
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We still need to add the `Component` annotation before our `Signin` class:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要在 `Signin` 类之前添加 `Component` 注解：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `Signin` component is going to be our sign-in form and it uses the `AuthService`
    to communicate with the backend. In the component's template, we are using local
    variables marked with a `#` sign for the email and password fields.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Signin` 组件将成为我们的登录表单，并使用 `AuthService` 与后端通信。在组件的模板中，我们使用带有 `#` 符号的局部变量标记电子邮件和密码字段。'
- en: As we said earlier, the HTTP service returns an `Observable` when making a request.
    This is the reason we can subscribe to the response generated by the requests
    made from our `AuthService`. On successful authentication, the user is redirected
    to the default home path.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，HTTP 服务在发起请求时返回一个 `Observable`。这就是为什么我们可以订阅由我们的 `AuthService` 发起的请求生成的响应。在成功认证后，用户将被重定向到默认的主路径。
- en: The `Register` component will look similar to the `Signin` component, so there
    is no need to detail this scenario. The final version of the `auth` module will
    be available in the source code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register` 组件将与 `Signin` 组件看起来相似，因此没有必要详细说明这一场景。`auth` 模块的最终版本将在源代码中提供。'
- en: Custom HTTP service
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 HTTP 服务
- en: In order to restrict access to our API endpoints, we have to make sure that,
    if a request is unauthorized, we redirect the user to the sign-in page. Angular
    2 has no support for Interceptors and we don't want to add a handler for each
    request we integrate into our services.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制对我们的 API 端点的访问，我们必须确保，如果请求未经授权，我们将用户重定向到登录页面。Angular 2 不支持拦截器，我们也不想为每个集成到我们服务中的请求添加处理器。
- en: A more convenient solution would be to build our own custom service on top of
    the built-in HTTP service. We could call it `AuthHttp`, from authorized HTTP requests.
    Its purpose would be to check whether a request returned a `401 Unauthorized HTTP
    status` code.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更方便的解决方案是在内置的 HTTP 服务之上构建我们自己的自定义服务。我们可以称它为 `AuthHttp`，用于授权 HTTP 请求。它的目的是检查请求是否返回了
    `401 未授权 HTTP 状态码`。
- en: I would like to take this thought even further and bring a hint of reactive
    programming, because we are already using RxJS. So, we can benefit from the full
    set of functionalities it provides. Reactive programming is oriented around data.
    Streams of data propagate in your application and it reacts to those changes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我想进一步思考这个问题，并引入一些响应式编程的提示，因为我们已经在使用 RxJS。因此，我们可以从它提供的完整功能集中受益。响应式编程围绕数据展开。数据流在你的应用程序中传播，并对这些变化做出反应。
- en: 'Let''s get to business and start building our custom service. Create a file
    called `contact-manager/public/src/auth/auth-http.ts`. We are going to add a few
    lines of code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作，开始构建我们的自定义服务。创建一个名为 `contact-manager/public/src/auth/auth-http.ts` 的文件。我们将添加几行代码：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are a few things we imported at the top of the file. We'll need all of
    them in this module. We defined a public property named `unauthorized`, which
    is a Subject. A **Subject** is both an `Observable` and `Observer`. This means
    that we can subscribe our subject to a backend data source and also all observers
    can subscribe to the subject.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文件顶部导入了一些东西。我们将在本模块中需要所有这些。我们定义了一个名为 `unauthorized` 的公共属性，它是一个 Subject。Subject
    既是 `Observable` 也是 `Observer`。这意味着我们可以将我们的主题订阅到后端数据源，并且所有观察者都可以订阅主题。
- en: In our case, the subject will be a proxy between our data source and all the
    subscribed observers. If a request is unauthorized, all subscribers get notified
    with the change. This enables us to just subscribe to the subject and redirect
    the user to the sign-in page when we detect an unauthorized request.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，主题将作为我们的数据源和所有已订阅观察者之间的代理。如果一个请求未经授权，所有订阅者都会收到变更通知。这使得我们只需订阅主题，当我们检测到未经授权的请求时，就可以将用户重定向到登录页面。
- en: 'To succeed in doing this, we have to add a few more methods to our `AuthHttp`
    service:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功做到这一点，我们必须向我们的 `AuthHttp` 服务添加几个更多的方法：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding method creates a new request with the desired `RequestOptions`
    and invokes the `request` method from the base HTTP service. Additionally, the
    `catch` method captures all requests with status code not 200-level.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法创建了一个带有所需 `RequestOptions` 的新请求，并从基本 HTTP 服务中调用 `request` 方法。此外，`catch`
    方法捕获所有状态码非 200 级别的请求。
- en: 'Using this technique, we can send the unauthorized request to all subscribers
    by using our `unauthorized` subject. Now that we have our private `request` method,
    we just need to add the rest of the public HTTP methods:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以通过我们的 `unauthorized` 主题向所有订阅者发送未经授权的请求。现在我们已经有了我们的私有 `request` 方法，我们只需要添加其余的公共
    HTTP 方法：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: I've added only the most commonly used methods; the rest is available in the
    full version. The preceding code calls our request method and sets the necessary
    options for each request type. Theoretically, we have created a façade to handle
    unauthorized requests.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我只添加了最常用的方法；其余的可以在完整版本中找到。前面的代码调用了我们的请求方法，并为每种请求类型设置了必要的选项。理论上，我们创建了一个外观来处理未经授权的请求。
- en: I think we've made good progress and it's time to move on to the rest of the
    modules of our contact manager application.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们已经取得了很好的进展，现在是时候继续我们的联系管理应用程序的其他模块了。
- en: The Contact module
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系模块
- en: This module will hold all the necessary files to manage contacts. As we discussed
    earlier, we are grouping our files by context, related to their domain. The starting
    point of our module will be the data layer, which means we'll start implementing
    the necessary service.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块将包含管理联系所需的所有文件。正如我们之前讨论的，我们根据上下文将文件分组，与它们的领域相关。我们模块的起点将是数据层，这意味着我们将开始实现必要的服务。
- en: Contact service
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联系服务
- en: Our contact service will have basic CRUD operations and Observable streams to
    subscribe to. This implementation will use the backend API built using Node.js
    and Express, but it can be converted anytime to a WebSocket-based API with little
    effort.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的联系服务将具有基本的 CRUD 操作和可订阅的 Observable 流。此实现将使用 Node.js 和 Express 构建的后端 API，但可以随时稍作努力转换为基于
    WebSocket 的 API。
- en: 'Create a new service file called `contact-manager/src/contact/contact.service.ts`
    and add the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `contact-manager/src/contact/contact.service.ts` 的新服务文件，并添加以下代码：
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the contact service, we have a few moving parts. First we defined our Observables
    so that any other component or module can subscribe and start getting the streams
    of data.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在联系服务中，我们有几个动态部分。首先，我们定义了我们的 Observables，以便任何其他组件或模块都可以订阅并开始获取数据流。
- en: Second, we declared a private data store. This is where we are going to store
    our contacts. This is good practice as you can easily return all resources from
    memory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们声明了一个私有数据存储。这就是我们将存储我们的联系信息的地方。这是一个好的实践，因为你可以轻松地从内存中返回所有资源。
- en: Also, in our service, we are going to keep private the returned Observers when
    new instances of Observables are generated. Using the Observers, we can push new
    data streams to our Observables.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们的服务中，当生成新的 Observables 实例时，我们将保留返回的 Observers。使用 Observers，我们可以将新的数据流推送到我们的
    Observables。
- en: 'In our public methods, we are going to expose the get all contacts, get one,
    update, and delete functionalities. To get all contacts, we are going to add the
    following method to our `ContactService`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的公共方法中，我们将公开获取所有联系人、获取一个、更新和删除的功能。为了获取所有联系人，我们将向我们的`ContactService`添加以下方法：
- en: '[PRE62]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We use our custom build `AuthHttp` service to load data from our Express application.
    When a response is received, we transform it into a JSON file, and after that,
    we just instantiate a new contact for each entity from the dataset.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用自定义构建的`AuthHttp`服务从我们的Express应用程序加载数据。当收到响应时，我们将它转换成JSON文件，然后，我们为数据集中的每个实体实例化一个新的联系人。
- en: Instead of returning the whole `Observable` from the HTTP service, we use our
    internal data store to persist all the contacts. After we have successfully updated
    the data store with the new data, we push the changes to our `contactsObserver`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是从HTTP服务返回整个`Observable`，而是使用我们的内部数据存储来持久化所有联系人。在我们成功更新数据存储的新数据后，我们将更改推送到我们的`contactsObserver`。
- en: Any component that is subscribed to our stream of contacts will get the new
    values from the `Observable` data stream. In this way, we always keep our components
    synced using one single point of entry.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 任何订阅我们联系人流的组件都将从`Observable`数据流中获得新值。这样，我们总是通过一个单一的入口点保持我们的组件同步。
- en: 'Much of our public method''s logic is the same, but we still have a few distinct
    elements, for example, the update method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们公共方法的逻辑大部分相同，但我们仍然有一些独特的元素，例如，更新方法：
- en: '[PRE63]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `update` method is almost the same as the `create()` method, however it
    takes the contact's ID as the URL param. Instead of pushing new values down a
    data stream, we return the `Observable` from the `Http` service, in order to apply
    operations from the caller module.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法几乎与`create()`方法相同，但它将联系人的ID作为URL参数。我们不是将新值推送到数据流中，而是从`Http`服务返回`Observable`，以便从调用模块应用操作。'
- en: 'Now, if we would like to make changes directly on the `datastore` and push
    the new values through the `contacts` data stream, we could showcase this in the
    remove contact method:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想直接在`datastore`上做出更改并通过`contacts`数据流推送新值，我们可以在删除联系人的方法中展示这一点：
- en: '[PRE64]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We simply use the `map()` function to find the contact we deleted and remove
    it from the internal store. Afterwards, we send new data to the subscribers.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地使用`map()`函数来找到我们删除的联系人并将其从内部存储中移除。之后，我们向订阅者发送新数据。
- en: Contact component
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联系人组件
- en: 'As we have moved everything related to the contact domain, we can define a
    main component in our module. Let''s call it `contact-manager/public/src/contact/contact.component.ts`.
    Add the following lines of code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们已将所有与接触域相关的功能移动到一起，我们可以在模块中定义一个主要组件。让我们称它为`contact-manager/public/src/contact/contact.component.ts`。添加以下代码行：
- en: '[PRE65]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Our component has no logic associated with it, but we used the `RouterConfig`
    annotation. The route config decorator takes an array of routes. Each path specified
    in the config will match the browser's URL. Each route will load the mounted component.
    In order to reference routes in the template, we need to give them a name.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件没有与之关联的逻辑，但我们使用了`RouterConfig`注解。路由配置装饰器接受一个路由数组。配置中指定的每个路径都将与浏览器的URL匹配。每个路由将加载挂载的组件。为了在模板中引用路由，我们需要给它们一个名称。
- en: Now, the most appealing part is that we can take this component with the configured
    routes and mount it on another component to have `Child`/`Parent` routes. In this
    case, it becomes nested routing, which is a very powerful feature added to Angular
    2.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最吸引人的部分是我们可以将这个组件和配置的路由一起使用，并将其挂载到另一个组件上以拥有`Child`/`Parent`路由。在这种情况下，它变成了嵌套路由，这是Angular
    2中添加的一个非常强大的功能。
- en: Our application's routes will have a tree-like structure; other components load
    components with their configured routes. I was pretty amazed by this feature because
    it enables us to truly modularize our application and create amazing, reusable
    modules.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的路由将具有树状结构；其他组件将加载它们配置的路由中的组件。我对这个功能感到非常惊讶，因为它使我们能够真正模块化我们的应用程序并创建令人惊叹的可重用模块。
- en: List contacts component
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出联系人组件
- en: In the previous component, we used three different components and mounted them
    on different routes. We are not going to discuss each of them, so we will choose
    one. As we have already worked with forms in the `Signin` component, let's try
    something different and implement the list contacts functionality.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的组件中，我们使用了三个不同的组件并将它们挂载到不同的路由上。我们不会讨论每个组件，所以我们将选择其中一个。因为我们已经在`Signin`组件中处理过表单，让我们尝试做一些不同的事情并实现列出联系人的功能。
- en: 'Create a new file called `contact-manager/public/src/contact/contact-list.component.ts`
    and add the following code for your component:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`contact-manager/public/src/contact/contact-list.component.ts`的新文件，并为你的组件添加以下代码：
- en: '[PRE66]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In our component's `ngOnInit()`, we subscribe to the contacts data stream. Afterwards,
    we retrieve all the contacts from the backend. In the template, we use `ngFor`
    to iterate over the dataset and display each contact.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的组件的`ngOnInit()`中，我们订阅联系人数据流。之后，我们从后端检索所有联系人。在模板中，我们使用`ngFor`遍历数据集并显示每个联系人。
- en: Creating a contact component
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建联系人组件
- en: Now that we can list contacts in our application, we should also be able to
    add new entries. Remember that earlier we used the `RouterLink` to be able to
    navigate to the `CreateContact` route.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在应用程序中列出联系人，我们也应该能够添加新条目。记住，我们之前使用`RouterLink`来导航到`CreateContact`路由。
- en: 'The preceding route will load the `CreateContactComponent`, which will enable
    us to add new contact entries into our database, through the Express API. Let''s
    create a new component file `public/src/contact/components/contact-create.component.ts`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的路由将加载`CreateContactComponent`，这将使我们能够通过Express API将新的联系人条目添加到我们的数据库中。让我们创建一个新的组件文件`public/src/contact/components/contact-create.component.ts`：
- en: '[PRE67]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Instead of using an embedded template, we are using an external template file
    that is configured using the `templateUrl` property in the component annotation.
    There are pros and cons for each situation. The benefits of using an external
    template file would be that you can reuse the same file for more than one component.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用内嵌模板，而是使用外部模板文件，该文件通过组件注解中的`templateUrl`属性进行配置。每种情况都有其优缺点。使用外部模板文件的优点是您可以重复使用同一文件为多个组件。
- en: The downfall, at the moment of writing the book, in Angular 2 is that it's hard
    to use relative paths to your template files, so this would make your components
    less portable. Also I like to keep my templates short, so they can fit easily
    inside the component, so in most cases I'll probably use embedded templates.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 写这本书的时候，Angular 2的一个缺点是难以使用相对路径到模板文件，这会使你的组件不太便携。此外，我喜欢保持我的模板简短，这样它们可以轻松地放在组件内部，所以在大多数情况下，我可能会使用内嵌模板。
- en: 'Let''s take a look at the template before further discussing the component,
    `public/src/contact/components/contact-form.html`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在进一步讨论组件之前的模板，`public/src/contact/components/contact-form.html`：
- en: '[PRE68]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the template we are using a `onSubmit()` method from the component to piggyback
    the form submission and in this case create a new contact and store the data in
    MongoDB. When we successfully create the contact we want to navigate to the `ContactList`
    route.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们使用组件的`onSubmit()`方法来处理表单提交，并在这种情况下创建一个新的联系人并将数据存储在MongoDB中。当我们成功创建联系人时，我们希望导航到`ContactList`路由。
- en: We are not using local variables, instead we are using two-way data binding
    with the `ngModel` for each input, mapped to the properties of the contact object.
    Now, each time the user changes the inputs value, this is stored in the contact
    object and on submit it's sent across the wire to the backend.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用局部变量，而是使用`ngModel`进行双向数据绑定，每个输入映射到联系人对象的属性。现在，每次用户更改输入值时，这些值都会存储在联系人对象中，并在提交时通过网络发送到后端。
- en: The `RouterLink` is used to construct the navigation to the `ContactList` component
    from the template. I've left a small improvement, the view title will be the same
    both for creating and editing, more precisely "Add new contact", and I'll let
    you figure it out.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterLink`用于从模板中构建导航到`ContactList`组件。我留下了一个小的改进，即视图标题在创建和编辑时都将相同，更确切地说，“添加新联系人”，我会让你自己想出来。'
- en: Editing an existing contact
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑现有联系人
- en: 'When editing a contact, we want to load a specific resource by ID from the
    backend API and make changes for that contact. Lucky for us this is quite simple
    to achieve in Angular. Create a new file `public/src/contact/components/contact-edit.component.ts`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑联系人时，我们希望从后端API通过ID加载特定资源，并对该联系人进行更改。幸运的是，在Angular中实现这一点相当简单。创建一个新的文件`public/src/contact/components/contact-edit.component.ts`：
- en: '[PRE69]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We are not so far away from the `ContactCreateComponent`, the structure of the
    class is almost the same. Instead of the `Router`, we are using `RouteParams`
    to load the ID from the URL and retrieve the desired contact from the Express
    application.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离`ContactCreateComponent`并不远，类的结构几乎相同。我们不是使用`Router`，而是使用`RouteParams`从URL中加载ID，并从Express应用程序中检索所需的联系人。
- en: We subscribe to the contact `Observable` returned by the `ContactService` to
    get the new data. In other words our component will react to the data stream and
    when the data is available it will display it to the user.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们订阅`ContactService`返回的联系人`Observable`以获取新数据。换句话说，我们的组件将响应数据流，当数据可用时，它将显示给用户。
- en: When submitting the form, we update the contact persisted in MongoDB and change
    the view's `contact` object with the freshly received data from the backend.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交表单时，我们更新MongoDB中持久化的联系人，并使用从后端新鲜接收的数据更改视图的`contact`对象。
- en: Finishing touch
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的润色
- en: 'We have added all the necessary modules into our application. We should also
    take a final look at our main app component, found under the following path—`contact-manager/public/src/app.component.ts`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将所有必要的模块添加到我们的应用程序中。我们还应该最终检查我们的主应用程序组件，该组件位于以下路径下—`contact-manager/public/src/app.component.ts`：
- en: '[PRE70]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We mount all the components to their specific routes. Also, when we mount the
    `Contact` component, we'll bring in all the configured routes from the component.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有组件挂载到它们特定的路由上。此外，当我们挂载`Contact`组件时，我们将引入组件中配置的所有路由。
- en: In order to be notified when a request is unauthorized, we subscribe to the
    `AuthHttp` service's `unauthorized` data stream. If a request needs authentication,
    we redirect the user to the sign-in page.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在请求未授权时得到通知，我们订阅了`AuthHttp`服务的`unauthorized`数据流。如果请求需要身份验证，我们将用户重定向到登录页面。
- en: 'The boot file for our application will look something like this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的启动文件看起来可能如下所示：
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We import and define the necessary providers and also add the operators we used
    from RxJs. This is because Angular, by default, uses only a stripped-down version
    of the Observable module.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入并定义了必要的提供者，并添加了我们从RxJs中使用的操作符。这是因为Angular默认情况下只使用Observable模块的简化版本。
- en: Through the contact module we used a custom class named `Contact`, which plays
    the role of a `Contact` model. This will be instantiated any time we want to make
    sure we are working with a contact entity. Besides, the nice thing about TypeScript
    is that it enables us to use structured code.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过联系模块，我们使用了一个名为`Contact`的自定义类，它扮演着`Contact`模型的角色。每次我们想要确保我们正在处理一个联系人实体时，它都会被实例化。此外，TypeScript的另一个优点是它使我们能够使用结构化代码。
- en: 'Classes come in handy when we want to have initial values, for example, in
    our components we used a `contact.image` property to display a contact''s profile
    image. This was not implemented in the backend, so we use a mock URL for an image.
    Let''s see the `Contact` class, `public/src/contact/contact.ts`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要初始值时，类非常有用，例如，在我们的组件中，我们使用了`contact.image`属性来显示联系人的个人资料图片。这还没有在后端实现，所以我们使用一个模拟的URL作为图片。让我们看看`Contact`类，`public/src/contact/contact.ts`：
- en: '[PRE72]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see we just define what properties a contact instance can have and
    create a default value for the `image` property. Arguments passed to the `constructor`
    marked with `?` are optional.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只定义了联系人实例可以拥有的属性，并为`image`属性创建了一个默认值。标记为`?`的构造函数参数是可选的。
- en: At this moment, we should have everything in place; in case you missed something,
    you can check out the final version of the code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们应该已经一切就绪；如果你错过了什么，你可以查看代码的最终版本。
- en: 'The key takeaways from this chapter are as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键要点如下：
- en: Building backend web services using Node.js, Express, and MongoDB
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js、Express和MongoDB构建后端Web服务
- en: Writing tests first, before actually implementing functionalities
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实际实现功能之前先编写测试
- en: Securing our API routes using Passport
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Passport保护我们的API路由
- en: Making Angular 2 and Express communicate and work together
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使Angular 2和Express通信并协同工作
- en: Getting into Reactive Extensions and reactive programming
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入反应式扩展和反应式编程
- en: Building a custom Angular HTTP service
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义的Angular HTTP服务
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This brings us to the end of this rather introductory chapter.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这一相当入门性的章节。
- en: We went full stack, right from implementing our backend logic to learning to
    write tests before actual implementations. We exposed a RESTful route for our
    resources from MongoDB. We also built a small Angular 2 frontend application that
    interacts with the web server.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从实现后端逻辑到学习在实际实现之前编写测试，全面地进行了全栈开发。我们从MongoDB资源公开了RESTful路由。我们还构建了一个小的Angular
    2前端应用程序，该应用程序与Web服务器进行交互。
- en: In the next chapter, we'll dive deeper into MongoDB and start working with monetary
    data. It should be a fun ride!
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨MongoDB，并开始处理货币数据。这将是一次有趣的旅程！
