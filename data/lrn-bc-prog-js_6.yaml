- en: Consensus Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共识算法
- en: In this chapter, we're going to build a consensus algorithm for the blockchain
    network. A consensus algorithm is a way for all of the nodes inside of the network
    to agree upon which data is correct and should be retained inside the blockchain.
    In order to build the consensus algorithm, we are first going to build a new method,
    called `chainIsValid`. This method will simply validate a blockchain by comparing
    all of the hashes of all of the blocks inside of the chain. After that, we are
    going to build a `/consensus` endpoint that we will hit whenever we want to use
    the consensus algorithm.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为区块链网络构建一个共识算法。共识算法是所有网络内的节点就哪些数据是正确的并应该保留在区块链中达成一致的一种方式。为了构建共识算法，我们首先将构建一个名为`chainIsValid`的新方法。这个方法将通过比较链中所有区块的所有哈希来简单验证区块链。之后，我们将构建一个`/consensus`端点，每当我们想使用共识算法时，我们将访问该端点。
- en: 'In this chapter, we''re going to learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: What the consensus algorithm is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共识算法是什么
- en: Building and testing the `chainIsValid` method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和测试`chainIsValid`方法
- en: Building and testing the `/consesnsus` endpoint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和测试`/consesnsus`端点
- en: So, let's get started with the consensus algorithm.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始共识算法。
- en: What is the consensus algorithm ?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共识算法是什么？
- en: When a blockchain is built, it is running across hundreds or thousands of nodes,
    and every transaction and every block that's being created is broadcast to the
    entire blockchain network. There's a possibility that during these broadcasts
    a hiccup could occur, or maybe a certain node doesn't receive a piece of information
    or a transaction that took place.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建区块链时，它正在数百或数千个节点之间运行，并且每个交易和每个被创建的区块都被广播到整个区块链网络。在这些广播过程中可能会出现问题，或者可能某个节点没有收到发生的某个信息或交易。
- en: There could even be a bad actor inside of the blockchain network, who is sending
    out false information or creating fraudulent transactions on their copy of a blockchain,
    and trying to broadcast them to the whole network to convince everybody that they
    are legitimate transactions. So, how do we solve this problem so that there are
    only legitimate blocks in the blockchain network?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在区块链网络中可能存在一个恶意行为者，他在他们的区块链副本上发送虚假信息或创建欺诈性交易，并试图将它们广播到整个网络，以说服每个人它们是合法交易。那么，我们如何解决这个问题，以便区块链网络中只有合法的区块？
- en: This is where the consensus algorithm is going to help us out. The consensus
    algorithm will provide us with a way to compare one node to all the other nodes
    inside of the network to confirm that we have the correct data on that specific
    node. There are currently many different consensus algorithms out there being
    used for different blockchain networks. For our blockchain network, we're going
    to create a consensus algorithm that implements the *longest chain rule*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是共识算法将帮助我们的地方。共识算法将为我们提供一种比较一个节点与网络中所有其他节点的方式，以确认我们在该特定节点上有正确的数据。目前有许多不同的共识算法被用于不同的区块链网络。对于我们的区块链网络，我们将创建一个实现*最长链规则*的共识算法。
- en: Basically, the *longest chain rule* takes a look at a single node and the copy
    of the blockchain on that node, comparing the length of the chains on one node
    with the length of the chains on all the other nodes. During this comparison,
    if there is a chain found that has a longer length than the chain that's present
    on the chosen node, the algorithm is going to replace the chain that's on the
    chosen node with the longest chain in the network.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，*最长链规则*会查看单个节点和该节点上的区块链副本，将该节点上的链的长度与所有其他节点上的链的长度进行比较。在这种比较中，如果发现有一条链的长度比所选节点上的链长，算法将用网络中最长的链替换所选节点上的链。
- en: The theory behind using this is that we should be able to trust the longest
    chain to hold the correct data, because the most work was put into creating that
    chain. The longest chain has the most blocks in it and each of those blocks was
    mined by using a proof of work. Consequently, we can assume that the whole network
    contributed to the longest chain because of how much work went into that chain.
    For this reason, we're going to use a consensus algorithm that implements the
    longest chain rule. The Bitcoin blockchain network itself actually implements
    this longest chain rule in real life.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法的理论是，我们应该能够相信最长的链来保存正确的数据，因为创建该链的工作量最大。最长的链中包含最多的区块，每个区块都是通过工作证明进行挖掘的。因此，我们可以假设整个网络都为最长的链做出了贡献，因为这条链需要付出很多工作。因此，我们将使用实现最长链规则的共识算法。比特币区块链网络实际上在现实生活中实现了这个最长链规则。
- en: Building the chainIsValid method
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建chainIsValid方法
- en: 'Let''s start building the consensus algorithm by creating a new method called
    `chainIsValid`. This method will validate whether or not a chain is legitimate.
    Let''s get started with building this method:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建共识算法，创建一个名为`chainIsValid`的新方法。这个方法将验证一条链是否合法。让我们开始构建这个方法：
- en: 'In the `blockchain.js` file, after the `proofOfWork` method, let''s define
    the method as follows:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`blockchain.js`文件中，在`proofOfWork`方法之后，让我们定义该方法如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, this method will take in a `blockchain` as an argument, and will return
    to us whether the `blockchain` is valid or not:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这个方法将以`blockchain`作为参数，并且将返回`blockchain`是否有效：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We're going to use this `chainIsValid` method to validate the other chains inside
    of the network when we are comparing them to the chain that is hosted on the current
    node. In order to validate that the blockchain is legitimate, we're simply going
    to iterate through every block inside of the blockchain and verify whether or
    not all of the hashes align correctly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将它们与当前节点上托管的链进行比较时，我们将使用`chainIsValid`方法来验证网络中的其他链。为了验证区块链的合法性，我们只需遍历区块链中的每个区块，并验证所有哈希是否正确对齐。
- en: 'You might recall from [Chapter 2](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml), *Building
    a Blockchain*  that when the `createNewBlock` method was defined, that method
    consisted of the `previousBlockHash` and `hash` property. This `hash` property
    is the hash of the current block . To build the `chainIsValid` method, let''s
    iterate through every block inside of the blockchain and make sure that the `previousBlockHash`
    property of a given block is exactly the same as the hash property in the previous
    block. Let''s define this condition inside of the method as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得[第2章](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml)中提到的，当定义`createNewBlock`方法时，该方法包括`previousBlockHash`和`hash`属性。这个`hash`属性是当前区块的哈希值。为了构建`chainIsValid`方法，让我们遍历区块链中的每个区块，并确保给定区块的`previousBlockHash`属性与上一个区块中的哈希属性完全相同。让我们在方法内部定义这个条件如下：
- en: 'In order to iterate through every block inside of the blockchain, we''ll use
    a `for` loop:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了遍历区块链中的每个区块，我们将使用一个`for`循环：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside of this `for` loop, let''s compare the current block to the previous
    block:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`for`循环内，让我们比较当前区块和上一个区块：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we iterate through the entire chain on every iteration, the `currentBlock`
    will be the value of `i`, and the `prevBlock` will be the value of `i - 1`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在每次迭代中遍历整个链时，`currentBlock`将是`i`的值，`prevBlock`将是`i - 1`的值。
- en: 'Next, all we want to do is compare the `previousBlockHash` property on the
    `currentBlock` with the hash property on the previous block. In order to do this,
    define the following condition in the method:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需比较`currentBlock`上的`previousBlockHash`属性与上一个区块上的哈希属性。为了做到这一点，在方法中定义以下条件：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When it comes to the preceding condition that we mentioned, if it is not satisfied,
    then we know that the chain is not valid, because the hashes are not lining up
    correctly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到我们提到的前一个条件时，如果它没有得到满足，那么我们知道链条是无效的，因为哈希值没有正确对齐。
- en: 'To satisfy the verification condition, the `previousBlockHash` on the current
    block should be equal to the hash of the previous block. We''re going to signify
    the aforementioned condition with the help of a flag inside of the method, as
    follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了满足验证条件，当前区块上的`previousBlockHash`应该等于上一个区块的哈希。我们将在方法内部使用一个标志来表示上述条件，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Initially, we have the `validChain` variable reading equal to `true`. As we
    go through the blockchain and see that the hashes don't align properly, then we
    would want to set the `validChain` variable to `false` to signify that the chain
    is not valid.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`validChain`变量的值等于`true`。当我们遍历区块链并看到哈希值没有正确对齐时，我们会将`validChain`变量设置为`false`，以表示链条无效。
- en: 'Now let''s get back to the `if` statement. Add the aforementioned condition
    to it:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们回到`if`语句。将上述条件添加到其中：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At the end of the loop, we can simply return a `validChain` variable and we''ll
    get the value returned as `true` if the chain is valid, and `false` if it is not:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环结束时，我们可以简单地返回一个`validChain`变量，如果链有效，则返回值为`true`，如果无效则返回`false`：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is one more thing that we want to do, and that is to validate that every
    single block inside of the chain has the correct data. We can do this by rehashing
    the `currentBlock` by using the `hashBlock` method. If the generated hash starts
    with four zeros as we saw in [Chapter 2](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml),
    *Building a Blockchain*, then we know that all of the data is valid. However,
    if it does not start with the four zeros then we know the data inside of the block
    is definitely not valid.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还要做的一件事是验证链中的每个区块是否都具有正确的数据。我们可以通过使用`hashBlock`方法重新计算`currentBlock`的哈希值来实现这一点。如果生成的哈希值以四个零开头，就像我们在[第2章](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml)中看到的那样，那么我们知道所有数据都是有效的。然而，如果不是以四个零开头，那么我们知道区块内的数据肯定是无效的。
- en: 'All we''re going to do is iterate through every block in the chain is to rehash
    every block and make sure that each hash starts with four zeros. So inside of
    the `for` loop let''s mention this condition by first defining a variable as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的就是遍历链中的每个区块，重新计算每个区块的哈希值，并确保每个哈希值以四个零开头。因此，在`for`循环内，让我们首先定义一个变量来提到这个条件：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `hashblock()` method accepts parameters such as: `previousBlockhash`, `currentBlockData`
    and the `nonce`. Let''s pass these parameters now:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hashblock()`方法接受参数，如：`previousBlockhash`，`currentBlockData`和`nonce`。让我们现在传递这些参数：'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we have to pass `currentBlockData` as parameter, which, as you might
    remember from the previous chapter, consists of the transactions in the `currentBlock`
    and the index of the `currentBlock`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须将`currentBlockData`作为参数传递，你可能还记得前一章中提到的，它包括`currentBlock`中的交易和`currentBlock`的索引：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, the last parameter that we have to pass is `nonce`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须传递的最后一个参数是`nonce`：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After defining these parameters, we should have the hash of `currentBlock`
    stored in the `blockHash` variable. Next, we just want to validate that the hash
    starts with the four zeros. So, inside of the `for` loop, we''ll mention the following
    condition:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义这些参数后，我们应该将`currentBlock`的哈希存储在`blockHash`变量中。接下来，我们只需验证哈希是否以四个零开头。因此，在`for`循环内，我们将提到以下条件：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we''re basically iterating through the entire blockchain and simply checking
    two things:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们基本上是在遍历整个区块链，只是简单地检查两件事：
- en: One check that we do is making sure that all of the hashes align properly. If
    they do not align properly, we indicate that the chain is not valid.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们进行的一个检查是确保所有哈希值正确对齐。如果它们没有正确对齐，我们会指出链条无效。
- en: The other check that we are doing is hashing every block, and making sure that
    the `blockHash` string starts with four zeros. If it does not start with the four
    zeros, then we indicate that the chain is not valid.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在进行的另一个检查是对每个区块进行哈希，并确保`blockHash`字符串以四个零开头。如果不是以四个零开头，那么我们指出链条无效。
- en: 'Now the `chainIsValid` method is just about done here. However, one important
    thing that you might have noticed is that we haven''t checked the genesis block
    for any of the methods yet. In the loop that we defined in the preceding block
    of code, we''re starting at position 1, and totally skipping position 0, which
    is the genesis block. The genesis block is a kind of special block, because we
    made it ourselves without doing a proof of work:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`chainIsValid`方法基本上已经完成了。然而，您可能已经注意到的一个重要的事情是，我们还没有检查创世区块是否符合任何方法。在我们在前面的代码块中定义的循环中，我们从位置1开始，完全跳过了位置0，即创世区块。创世区块是一种特殊的区块，因为我们自己制作了它，而没有进行工作证明：
- en: 'Consequently, in order to validate the genesis block, we just want to make
    sure that it has the properties that we initially put onto it. So, outside of
    the `for` loop, we''ll mention this condition as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，为了验证创世区块，我们只需确保它具有我们最初放入其中的属性。因此，在`for`循环之外，我们将如下表述这个条件：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we just want to check and verify that all of the properties on the genesis
    block are correct. If you remember in [Chapter 2](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml), *Building
    a Blockchain* where we defined the genesis block, we assigned to it values such
    as `nonce`, with a value of `100`, `previousBlockHash`, with a value `0`, and
    the `hash` of the string 0 as well. So, let''s check for these properties now
    to make sure that they''re correct. In the following snippet, we add the preceding
    line of code to the following variables:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只是想检查并验证创世区块上的所有属性是否正确。如果您还记得在[第2章](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml)中，我们定义了创世区块，我们为其分配了值，例如`nonce`，值为`100`，`previousBlockHash`，值为`0`，以及字符串0的`hash`。因此，现在让我们检查这些属性，以确保它们是正确的。在以下代码片段中，我们将上述代码添加到以下变量中：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we want to verify that the genesis block should have no transactions
    in it. So, to check this, we''ll mention the following condition:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们要验证创世区块中不应该有任何交易。因此，为了检查这一点，我们将提到以下条件：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, if we do have a legitimate genesis block, then all of these variables
    that we defined should be the value true. If any of these variables are not valid,
    then we want to change the `validChain` variable to `false` so that we know the
    blockchain is not valid. Let''s mention this condition as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们有一个合法的创世区块，那么我们定义的所有这些变量都应该是true。如果任何这些变量无效，那么我们希望将`validChain`变量更改为`false`，以便我们知道区块链无效。让我们将这个条件表述如下：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Mentioning this last condition completes the `chainIsValid` method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 提及这最后一个条件完成了`chainIsValid`方法。
- en: Testing the chainIsValid method
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试`chainIsValid`方法
- en: 'Now let''s test the `chainIsValid` method by implementing the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过实施以下步骤来测试`chainIsValid`方法：
- en: 'In the `test.js` file, let''s import the blockchain data structure and create
    a new instance of the blockchain, called `bitcoin`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test.js`文件中，让我们导入区块链数据结构并创建一个名为`bitcoin`的区块链的新实例：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, let's generate a blockchain for us to test. We'll do this by starting
    at one of the servers. So go to the terminal, type `npn run node_1` and press
    *Enter*. Then you'll receive the response, Listening on port 3001.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们生成一个用于测试的区块链。我们将通过从其中一个服务器开始来实现这一点。因此，转到终端，输入`npn run node_1`并按*Enter*。然后您将收到响应，监听端口3001。
- en: On node `3001`, now let's create a blockchain and add some data to it so that
    we can test the new blockchain. Currently, the blockchain on node `3001` only
    has the genesis block in it. So, let's add a couple more blocks to the chain by
    hitting the `/mine` endpoint. Therefore, in the browser, go to `localhost:3001/mine`
    to create a new block.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在节点`3001`上，现在让我们创建一个区块链并向其中添加一些数据，以便我们可以测试新的区块链。目前，节点`3001`上的区块链只有创世区块。因此，通过命中`/mine`端点，让我们向链中添加几个更多的区块。因此，在浏览器中，转到`localhost:3001/mine`以创建一个新的区块。
- en: 'Now, if you go to `localhost:3001/blockchain`, you should be able to observe
    the new block as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您转到`localhost:3001/blockchain`，您应该能够观察到新的区块如下：
- en: '![](img/a3128e28-2ca5-4d4c-9230-3a2d60f02ac4.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3128e28-2ca5-4d4c-9230-3a2d60f02ac4.png)'
- en: Thus, at node `3001`, we now have two blocks in the chain and one pending transaction,
    which is the mining reward transaction.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在节点`3001`，我们现在有两个区块和一个待处理的交易，即挖矿奖励交易。
- en: 'Next, let''s create some transactions to add to the blockchain. To add the
    transaction, go to Postman and just add a couple of transactions there, as seen
    in the following screenshot. Let''s send these transactions to `localhost:3001`,
    and also hit the `/transaction/broadcast` endpoint:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些要添加到区块链中的交易。要添加交易，请转到Postman，并在那里添加一些交易，如下截图所示。让我们将这些交易发送到`localhost:3001`，并且还要命中`/transaction/broadcast`端点：
- en: '![](img/c5f1ba3a-78e6-4c7f-92ea-2250f6e4c496.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5f1ba3a-78e6-4c7f-92ea-2250f6e4c496.png)'
- en: You can similarly add many other transactions to the node.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以向节点添加许多其他交易。
- en: 'Once the transactions have been added, let''s mine a new block by going to `localhost:3001/mine`.
    Once the new block has been mined, visit `localhost:3001/blockchain` in order
    to verify that the block has been added to the network. You should observe an
    output like the following:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦交易被添加，让我们通过访问`localhost:3001/mine`来挖掘一个新的区块。一旦新的区块被挖掘出来，访问`localhost:3001/blockchain`以验证该区块是否已被添加到网络中。您应该观察到以下输出：
- en: '![](img/c071524a-1a7e-4d61-a52c-2c8e8b13735a.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c071524a-1a7e-4d61-a52c-2c8e8b13735a.png)'
- en: You'll see that node `3001` consists of the third block with all the transaction
    data that we passed inside the block. We also have one pending transaction.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到节点`3001`包含了第三个区块，其中包含我们在区块中传递的所有交易数据。我们还有一个待处理的交易。
- en: 'Next, let''s add a couple more transactions to the node `3001` and then mine
    a new block on that node. You''ll get to observe the similar output as seen in
    the previous case. The new transactions data that we added is now present inside
    the fourth block that we mined. Take a look at the following screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们向节点`3001`添加几个更多的交易，然后在该节点上挖掘一个新的区块。您将看到与前面情况类似的输出。我们添加的新交易数据现在存在于我们挖掘的第四个区块中。请查看以下截图：
- en: '![](img/09d6460c-e4dd-4817-8c48-4bb9e0a44ff5.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09d6460c-e4dd-4817-8c48-4bb9e0a44ff5.png)'
- en: Next, let's mine two more blocks without any data in them. So now, we have a
    blockchain with six blocks in it. Out of these six blocks, two blocks don't have
    any transaction data present in them.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们再挖掘两个没有任何数据的块。现在，我们有一个包含六个块的区块链。在这六个块中，有两个块中没有任何交易数据。
- en: 'Copy the entire blockchain present on `localhost:3001` and paste it in the
    `test.js` file. Then, after pasting the data in the `test.js` file, let''s save
    that pasted text as a variable:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`localhost:3001`上的整个区块链并将其粘贴到`test.js`文件中。然后，在`test.js`文件中粘贴数据后，让我们将该粘贴的文本保存为一个变量：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s use the `chainIsValid` method to validate the chain. To do this, in
    the `test.js` file, let''s mention the following:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`chainIsValid`方法来验证链的有效性。为了做到这一点，在`test.js`文件中，让我们提到以下内容：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's save the `test.js` file and run it.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们保存`test.js`文件并运行它。
- en: Verifying the output of the test
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证测试的输出
- en: 'Now, when we run this file, we should receive verification of a valid blockchain,
    because we didn''t tamper with it and created it legitimately, using all of the
    correct methods. Let''s verify whether or not the `chainIsValid` method works
    correctly:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个文件时，我们应该收到一个有效区块链的验证，因为我们没有篡改它，而是合法地使用了所有正确的方法创建它。让我们验证`chainIsValid`方法是否正常工作：
- en: Head over to the Terminal and cancel the previous processes that were running
    by typing `^C` in the Terminal.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往终端并通过在终端中键入`^C`来取消之前正在运行的进程。
- en: 'Once the processes are cancelled, then in the Terminal, let''s type `node dev/test.js`
    and press *Enter*. As we haven''t tampered with the blockchain, we''ll get the
    `Valid: true` response, as seen in the following screenshot:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '一旦进程被取消，然后在终端中，让我们键入`node dev/test.js`并按*Enter*。由于我们没有篡改区块链，我们将得到`Valid: true`的反馈，如下面的截图所示：'
- en: '![](img/4f4f5aaf-f460-4123-8ab2-0208c1b89d3e.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f4f5aaf-f460-4123-8ab2-0208c1b89d3e.png)'
- en: 'Now, let''s tamper with the blockchain a little bit and see if we can get a
    false value returned:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微篡改一下区块链，看看是否可以得到一个错误的返回值：
- en: Inside of the blockchain data that we pasted into the `test.js` file, let's
    change one of the hashes on any one of the blocks to see if it invalidates the
    blockchain.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们粘贴到`test.js`文件中的区块链数据中，让我们更改任一块中的一个哈希值，看看是否会使区块链无效。
- en: 'Once you have changed the hash of any block, save the file and run the test
    again. Since the data is tampered now, you''ll get the `false` response:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你改变了任何块的哈希值，保存文件并再次运行测试。由于数据现在被篡改，你将得到`false`的反馈：
- en: '![](img/fcd7a8f5-208d-46ad-aa38-386e4ee16451.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcd7a8f5-208d-46ad-aa38-386e4ee16451.png)'
- en: Next, let's mess with some of the transaction data in one of the blocks. If
    we change any of the transaction data inside of one of the blocks, the chain should
    not be valid and we should receive a false response for the test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在一个区块的交易数据中搞一些乱。如果我们更改了一个区块中的任何交易数据，那么链就不应该是有效的，我们应该收到测试的假反馈。
- en: 'Finally, let''s test the genesis block, which is the first block in the chain:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们测试创世块，也就是链中的第一个块：
- en: '![](img/c4a37b58-6b30-4c1e-b29b-ce2e15128b60.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4a37b58-6b30-4c1e-b29b-ce2e15128b60.png)'
- en: In the `test.js` file in the blockchain data that we pasted, let's change the
    `nonce` value to 10 from 100\. After saving the file and running the test again
    in the Terminal, we should get the output returned as `false`. Since we tampered
    with the data in the blockchain in the `test.js` file, when we ran the test we
    got the response of `false`. This signifies that the blockchain is not valid or
    legitimate anymore, as the data inside it has been tampered with. So, from this
    test we can conclude that the `chainIsValid` method works perfectly, just as we
    expected it to.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们粘贴的区块链数据的`test.js`文件中，让我们将`nonce`值从100改为10。保存文件并在终端中再次运行测试，我们应该得到返回的输出为`false`。由于我们在`test.js`文件中篡改了区块链中的数据，当我们运行测试时，我们得到了`false`的反馈。这表明区块链不再有效或合法，因为其中的数据已经被篡改。因此，从这个测试中我们可以得出结论，`chainIsValid`方法完全符合我们的预期。
- en: A tiny modification to verify the results properly
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对结果进行适当的微小修改
- en: 'Now, one tiny thing that we need to do to help us understand how the `chainIsValid`
    method works is to log out the `previousBlockHash` and the `currentBlock` hash
    of every single block so that we can compare them ourselves. Consequently, in
    the `chainIsValid` method inside of the `for` loop, let''s add the following lines
    of code before the loop ends:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要做的一个小事情是帮助我们理解`chainIsValid`方法的工作原理，即记录每个块的`previousBlockHash`和`currentBlock`哈希值，以便我们自己进行比较。因此，在`chainIsValid`方法的`for`循环中，让我们在循环结束之前添加以下代码行：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s save this modification and run the test again. This time, when we run
    the test, we should see all of the hashes logged out so that we can compare them
    for ourselves and see what''s really happening inside of this method. After running
    the test, you should see the `previousBlockHash` and `currentBlockHash` values,
    as in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存这个修改并再次运行测试。这一次，当我们运行测试时，我们应该看到所有的哈希值被记录下来，这样我们就可以自己比较它们，看看这个方法内部到底发生了什么。运行测试后，你应该看到`previousBlockHash`和`currentBlockHash`的值，如下面的截图所示：
- en: '![](img/4c112ba0-73d8-4f9a-8e30-06a80fb3a2fb.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c112ba0-73d8-4f9a-8e30-06a80fb3a2fb.png)'
- en: From the preceding screenshot, you can observe that for every iteration, the
    `previousBlockHash` value matches the `currentBlockHash` value of the previous block.
    If you look at all of the hashes, you can see them logged out in pairs. From the
    screenshot, we can observe that we have many pairs of identical hashes, which
    is what makes the blockchain valid.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，你可以观察到，对于每次迭代，`previousBlockHash`的值都与前一个块的`currentBlockHash`的值匹配。如果你看所有的哈希值，你会看到它们成对地被记录下来。从截图中，我们可以观察到我们有许多对相同的哈希值，这就是使区块链有效的原因。
- en: Building the /consensus endpoint
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建/共识端点
- en: 'Now, let''s build the `/consensus` endpoint, which will use the `chainIsValid` method
    that we built in the previous section. Carry out the following steps to build
    the endpoint:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建`/consensus`端点，它将使用我们在上一节中构建的`chainIsValid`方法。执行以下步骤来构建端点：
- en: 'Let''s go to `networkNode.js` file and, after the `/register-node-bulk` endpoint,
    define the `/consensus` endpoint as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到`networkNode.js`文件，并在`/register-node-bulk`端点之后，定义`/consensus`端点如下：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, inside of the `/consensus` endpoint, let''s make a request to every other
    node inside of the blockchain network to get their copies of the blockchain and
    compare them to the copy of the blockchain that''s hosted on the current node
    that we''re currently on:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`/consensus`端点内，让我们向区块链网络中的每个其他节点发出请求，以获取它们的区块链副本，并将其与当前节点上托管的区块链副本进行比较：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inside of this `forEach` loop, let''s do the same things that we''ve done countless
    times while defining the other endpoints in the previous chapters. So, the first
    thing we have to do for the requests is define some options as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`forEach`循环内，让我们做与在前几章中定义其他端点时做过无数次的相同的事情。因此，我们首先要为请求定义一些选项，如下所示：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After defining the options, we need to `request-promise` the `requestOptions`
    and push all of these requests into a promise array because each of these requests
    returns a promise to us:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义选项之后，我们需要`request-promise` `requestOptions`，并将所有这些请求推入一个承诺数组，因为每个请求都会向我们返回一个承诺：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the `forEach` loop has ran, we''ll have an array that''s filled up with
    all of the requests. Next, let''s run the requests as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`forEach`循环运行后，我们将得到一个填满所有请求的数组。接下来，让我们按以下方式运行这些请求：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, let''s use the data that we receive from all of these promises. This
    data that we''re receiving is going to be an array of blockchains from every node
    inside of the network. So, after the preceding line of code, let''s define the
    code as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们使用从所有这些承诺中收到的数据。我们收到的这些数据将是来自网络中每个节点的区块链的数组。因此，在上述代码的后面，让我们定义如下的代码：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let''s iterate through all of these `blockchains` that came from the other
    nodes inside of the network, and see if there is a blockchain inside of the other
    node that is longer than the copy of the blockchain hosted on the current node.
    We''ll start by cycling through all of the blockchains that we got in the responses:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们遍历来自网络中其他节点的所有这些`blockchains`，并查看是否有一个比当前节点上托管的区块链副本更长的区块链。我们将从响应中获取的所有区块链中开始循环：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Basically, all we want to do inside of the `forEach` loop is identify whether
    one of the blockchains from the other nodes in the network is longer than the
    blockchain hosted on the current node. In order to do this, let''s define a couple
    of variables to keep track of all of the data, as follows. The first variable
    that we want to define is the length of the blockchain hosted on the current node:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本上，在`forEach`循环内，我们要做的就是确定网络中其他节点的区块链是否比当前节点上托管的区块链更长。为了做到这一点，让我们定义一些变量来跟踪所有数据，如下所示。我们要定义的第一个变量是托管在当前节点上的区块链的长度：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, let''s define a variable that will change if we come across a longer
    blockchain in the `blockchains` array. The first thing we want to define is the
    `maxChainLength` variable:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个变量，如果在`blockchains`数组中遇到更长的区块链，它将发生变化。我们要定义的第一件事是`maxChainLength`变量：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we want to define a variable called `newLongestChain`. Initially we''re
    going to set it as equal to null:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要定义一个名为`newLongestChain`的变量。最初，我们将把它设置为`null`：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, the last variable that we''ll define will be called `newPendingTransactions`.
    Let''s set this as equal to `null` initially, as well:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们要定义的最后一个变量将被称为`newPendingTransactions`。让我们最初将其设置为`null`：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, inside the `forEach` loop, we''re looking to see if there is a longer
    chain inside of the blockchain network than is currently on the node that we are
    on. If there is a longer chain inside the network, then change these aforementioned
    variables to reflect that. Consequently, inside of the `forEach` loop, define
    the `this` condition as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`forEach`循环内，我们要查看区块链网络中是否存在比当前节点上更长的链。如果网络中存在更长的链，那么改变上述变量以反映这一点。因此，在`forEach`循环内，定义如下的`this`条件：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, after the `forEach` loop has ran, we''ll have all of the data required
    to determine if we need to replace the chain that is hosted on this current node.
    Next, after the loop, let''s define the following conditions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`forEach`循环运行后，我们将拥有确定是否需要替换托管在当前节点上的链所需的所有数据。接下来，在循环之后，让我们定义以下条件：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Basically, what we're stating in this `if` statement is that if there is no
    `newLongestChain` meaning, then the current chain is the longest. Alternatively,
    if there is a new longest chain but that new chain is not valid, then in these
    two cases we don't want to replace the blockchain that's hosted on the current
    node. So we're going to send back the note that says 'Current chain has not been
    replaced'.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在这个`if`语句中我们要表达的是，如果没有`newLongestChain`，那么当前链就是最长的。或者，如果有一个新的最长链，但是这个新链无效，那么在这两种情况下，我们都不想替换托管在当前节点上的区块链。因此，我们将发送回一个说明“当前链未被替换”的通知。
- en: 'Otherwise, if there is a `newLongestChain` and that chain is valid, now is when
    we want to replace the blockchain that''s hosted on the current node with the
    longest chain in the network. We''ll define all this inside of the else block
    as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果有一个`newLongestChain`并且该链是有效的，那么现在我们要用网络中最长的链替换托管在当前节点上的区块链。我们将在else块中定义所有这些内容，如下所示：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Quick review of the build process
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建过程的快速回顾
- en: The first thing that we did in this endpoint is made requests to all of the
    other nodes in the network so that we could access the blockchain that is hosted
    on each of them. After we ran all of these requests, we then had access to all
    of the blockchains that are hosted on all of the other nodes inside of the network.
    We then iterate through all of the other blockchains inside of the network with
    the help of the `forEach` loop. And as we iterated through the other blockchains,
    and if we find a longer chain we then update the `maxChainLength`, `newLongestChain`,
    and `newPendingTransactions` variables to reflect that. Then, when the `forEach`
    loop is complete, we'll know if there is a chain on the network longer than the
    blockchain hosted on the current node. If there is a longer chain found inside
    of the network, we'll have access to the `pendingTransactions` of that blockchain.
    So, after the `forEach` loop has ran, we'll then have access to all of the data
    necessary to replace the erroneous blockchain that's hosted on the current node.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个端点中，我们首先向网络中的所有其他节点发出请求，以便我们可以访问每个节点上托管的区块链。在我们运行了所有这些请求之后，我们就可以访问网络中所有其他节点上托管的所有区块链。然后，我们通过`forEach`循环遍历网络中所有其他区块链。当我们遍历其他区块链时，如果我们找到了更长的链，我们就会更新`maxChainLength`、`newLongestChain`和`newPendingTransactions`变量以反映出这一点。然后，当`forEach`循环完成时，我们就会知道网络中是否存在比当前节点上托管的区块链更长的链。如果在网络中找到了更长的链，我们将能够访问该区块链的`pendingTransactions`。因此，在`forEach`循环运行后，我们将能够访问所有必要的数据，以替换当前节点上托管的错误区块链。
- en: We then state whether there is no new longer chain or if there is no chain longer
    than the blockchain hosted on the current node. If there is a longer chain inside
    of the network, but that chain is not valid, then in both of these cases we do
    not want to replace the blockchain that's hosted on the current node, so we simply
    send back a response that says the current chain has not been replaced.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们说明了是否存在新的更长链，或者是否存在比当前节点上托管的区块链更长的链。如果在网络中存在更长的链，但该链无效，那么在这两种情况下，我们都不希望替换当前节点上托管的区块链，因此我们只需发送一个响应，说明当前链未被替换。
- en: On the other hand, if there is a longer chain inside of the network and that
    chain is valid, then we'll want to replace the blockchain that's hosted on the
    current node. We simply send back a response saying that this chain has been replaced,
    as well as sending back the new blockchain.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果在网络中存在更长的链，并且该链是有效的，那么我们将希望替换当前节点上托管的区块链。我们只需发送一个响应，说明该链已被替换，并返回新的区块链。
- en: This is how the consensus algorithm and the `/consensus` endpoint will work.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是共识算法和/consensus端点的工作原理。
- en: Testing the /consensus endpoint
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试/consensus端点
- en: 'Let''s test the consensus endpoint that we just built. So, what should this
    `/consensus` endpoint do? When we call the `/consensus` endpoint on a specific
    node, it should confirm for us that that particular node has the correct blockchain
    data in it, and the node is in sync with the rest of the network. Let''s get started
    with building the test:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试刚刚构建的共识端点。因此，这个/consensus端点应该做什么？当我们在特定节点上调用/consensus端点时，它应该为我们确认该特定节点是否具有正确的区块链数据，并且该节点与网络的其余部分是同步的。让我们开始构建测试：
- en: Our first step is to make a network that consists of the first four nodes. So
    let's go to Postman and hit the register-and-broadcast-node endpoint on the node
    that's hosted on `3001`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是建立一个由前四个节点组成的网络。因此，让我们去Postman，并在托管在`3001`上的节点上点击register-and-broadcast-node端点。
- en: 'Let''s add the second node to the network, as seen in the following screenshot.
    We''ll then click on the Send button, receiving the response, New node registered
    with network successfully:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们像下面的屏幕截图中所示，将第二个节点添加到网络中。然后，我们将点击发送按钮，接收到响应，成功注册新节点到网络：
- en: '![](img/b368c45a-4c9b-49aa-ace6-1b2a3e3f4dd4.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b368c45a-4c9b-49aa-ace6-1b2a3e3f4dd4.png)'
- en: Similarly, you can register the remaining nodes, `3003` and `3004`, to the network.
    Now, if you go to the browser and check all the nodes, you will observe that all
    the nodes from `3001` to `3004` are connected to each other, but node 3005 is
    not.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，您可以将剩余的节点`3003`和`3004`注册到网络中。现在，如果您去浏览器并检查所有节点，您将观察到从`3001`到`3004`的所有节点都相互连接，但节点3005没有连接。
- en: 'Next, what we want to do is mine a couple of blocks on the blockchain network,
    except for the fifth node. So in the browser, let''s hit `localhost: 3001/mine`.
    This will mine one block for us on node `3001`.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要在区块链网络上挖掘一些区块，除了第五个节点。因此在浏览器中，让我们访问`localhost:3001/mine`。这将在节点`3001`上为我们挖掘一个区块。
- en: Similarly, let's mine two blocks on `localhost:3003` and one block on `localhost:3004`.
    Now, all of these nodes should have five blocks in them. You verify this by hitting
    `localhost:3001/blockchain` in the browser. You will get to observe all five of
    the blocks that we just added.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，让我们在`localhost:3003`上挖掘两个区块，在`localhost:3004`上挖掘一个区块。现在，所有这些节点应该都有五个区块。您可以通过在浏览器中输入`localhost:3001/blockchain`来验证这一点。您将能够观察到我们刚刚添加的所有五个区块。
- en: 'At this point, we want to connect the fifth node to the blockchain network.
    So, let''s go to Postman and send the request for 3005, as seen in the following
    screenshot:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们想要将第五个节点连接到区块链网络。因此，让我们去Postman并发送3005的请求，如下面的屏幕截图所示：
- en: '![](img/3a0f7b07-9868-4e2f-92c0-8b6130b79835.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a0f7b07-9868-4e2f-92c0-8b6130b79835.png)'
- en: 'So now, node `3005` should be connected to the network. You can verify this
    in the browser as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，节点`3005`应该已连接到网络。您可以通过浏览器验证这一点：
- en: '![](img/4deb4518-9e54-48d6-9a9e-43308078d02b.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4deb4518-9e54-48d6-9a9e-43308078d02b.png)'
- en: 'Now that `3005` is part of the network, this is where the problem arises: node
    `3005` does not have the correct blockchain data inside of the blockchain. It
    should have all of the five blocks that the other nodes have. This is where the
    `/consensus` endpoint comes into play. We should be able to hit the `/consensus`
    endpoint and resolve this issue. After we do this, we should expect the blockchain
    on node `3005` to have the same data as all the other nodes inside of the network.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`3005`是网络的一部分，问题就出现在这里：节点`3005`在区块链中没有正确的区块数据。它应该拥有其他节点拥有的所有五个区块。这就是`/consensus`端点发挥作用的地方。我们应该能够访问`/consensus`端点并解决这个问题。在这之后，我们应该期望节点`3005`上的区块链与网络中的其他所有节点具有相同的数据。
- en: 'Let''s try this now. Open another tab in the browser, and in the address bar,
    type `localhost:3005/consensus` and then run it by pressing *Enter*. You should
    observe similar output to that seen in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试一试。在浏览器中打开另一个标签，并在地址栏中输入`localhost:3005/consensus`，然后按下*Enter*运行它。您应该观察到类似于以下截图中所见的输出：
- en: '![](img/a8383833-ebe7-4d79-be6e-8b982678c0c2.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8383833-ebe7-4d79-be6e-8b982678c0c2.png)'
- en: In the preceding screenshot, we get the response, This chain has been replaced,
    and the new blockchain data then replaces the old data on this node. Let's verify
    this node by going to another tab in the browser and hitting `localhost:3005/blockchain`.
    You'll see that all the blocks that were present in the network are added to the
    node on `3005`. Thus the node on `3005` now has the correct blockchain data. We
    achieved this by hitting the `/consensus` endpoint on node `3005`. Now, all of
    the nodes inside of the blockchain network should have exactly the same data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们得到了响应，链已被替换，然后新的区块链数据取代了这个节点上的旧数据。让我们通过在浏览器中打开另一个标签并访问`localhost:3005/blockchain`来验证这个节点。您会看到网络中存在的所有区块都已经添加到节点`3005`中。因此，节点`3005`现在拥有了正确的区块链数据。我们通过访问节点`3005`上的`/consensus`端点来实现了这一点。现在，区块链网络中的所有节点应该具有完全相同的数据。
- en: 'Now, if you again try to hit the `/consensus` endpoint on the node on `3005`,
    we would get the following response:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你再次尝试在`3005`节点上访问`/consensus`端点，我们将会得到以下响应：
- en: '![](img/bab9a994-3b0a-4dd0-82dc-7ad083b82423.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bab9a994-3b0a-4dd0-82dc-7ad083b82423.png)'
- en: We received such a response because all the blocks that were present in the
    network were already added to node `3005` when we previously ran the consensus
    endpoint.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到这样的响应，是因为在之前运行共识端点时，网络中已经存在的所有区块都已经添加到节点`3005`中。
- en: From this test, we can conclude that the `/consensus` works perfectly and as
    expected. The `/consensus` endpoint has the ability to correct a node inside of
    the blockchain if it has the wrong data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个测试，我们可以得出结论，`/consensus`完美地按预期工作。`/consensus`端点有能力在区块链中纠正节点的错误数据。
- en: It is recommended that you mess around with the `/consensus` endpoint and test
    it in different ways. Add some transactions to the data and make sure that it correctly resolves
    nodes that hold the wrong data. By testing this endpoint a little bit more, you
    will become more familiar with how it is works under the hood.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您尝试使用`/consensus`端点以不同的方式进行测试。向数据添加一些交易，并确保它能够正确解决持有错误数据的节点。通过更多地测试这个端点，您将更加熟悉它在底层是如何工作的。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: All blockchains have a consensus algorithm, and in this chapter, we built our
    own consensus algorithm that implements the longest chain rule. We started by
    building the `chainIsValid` method. In this method, we simply iterated through
    every single block inside of the blockchain, and compared hashes on every block
    to make sure that they are correct. Then we moved on to test the method. In addition
    to this, we built the `/consensus` endpoint with the help of the `chainIsValid`
    method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的区块链都有共识算法，在本章中，我们构建了自己的共识算法，实现了最长链规则。我们首先构建了`chainIsValid`方法。在这个方法中，我们简单地遍历了区块链中的每一个区块，并比较了每个区块上的哈希值，以确保它们是正确的。然后我们继续测试这个方法。除此之外，我们利用`chainIsValid`方法构建了`/consensus`端点。
- en: In the next chapter, we're going to build a block explorer that we'll be able
    to access on the browser. This block explorer will allow us to interact with the
    blockchain through a user interface.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个区块浏览器，我们将能够在浏览器上访问。这个区块浏览器将允许我们通过用户界面与区块链进行交互。
