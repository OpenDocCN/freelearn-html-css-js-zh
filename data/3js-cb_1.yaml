- en: Chapter 1. Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 入门
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Getting started with the WebGL renderer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 WebGL 渲染器
- en: Getting started with the Canvas renderer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Canvas 渲染器
- en: Getting started with the CSS 3D renderer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 CSS 3D 渲染器
- en: Detecting WebGL support
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测 WebGL 支持
- en: Setting up an animation loop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置动画循环
- en: Determining the frame rate for your scene
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定场景的帧率
- en: Controlling the variables used in the scene
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制场景中使用的变量
- en: Setting up a local web server with Python
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 设置本地 Web 服务器
- en: Setting up a local web server with Node.js
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node.js 设置本地 Web 服务器
- en: Setting up a local web server using Mongoose
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mongoose 设置本地 Web 服务器
- en: Solving cross-origin-domain error messages in Chrome
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决 Chrome 中的跨域错误消息
- en: Solving cross-origin-domain error messages in Firefox
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决 Firefox 中的跨域错误消息
- en: Adding keyboard controls
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加键盘控制
- en: Loading textures asynchronously
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步加载纹理
- en: Loading models asynchronously
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步加载模型
- en: Loading models asynchronously with progress
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带进度加载模型
- en: Loading other resources asynchronously with progress
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带进度异步加载其他资源
- en: Waiting until resources are loaded
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待资源加载完成
- en: Dragging a file from the desktop to the scene
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件从桌面拖动到场景中
- en: Introduction
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter we'll show you a number of recipes that introduce the basic
    usage of Three.js. We'll start with a number of simple recipes that you can use
    as a starting point for your Three.js projects. Next, we'll show you a couple
    of features that you can add to your project, such as WebGL detection and defining
    an animation loop. We'll end with a number of more advanced features such as adding
    drag and drop support, and loading resources synchronously and asynchronously.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示一系列食谱，介绍 Three.js 的基本用法。我们将从一些简单的食谱开始，您可以用它们作为 Three.js 项目的起点。接下来，我们将向您展示您可以添加到项目中的几个功能，例如
    WebGL 检测和定义动画循环。我们将以添加拖放支持和同步和异步加载资源等更多高级功能结束。
- en: Getting started with the WebGL renderer
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 WebGL 渲染器
- en: When you want to create an initial Three.js project that uses WebGL for rendering,
    you always have to set up the same couple of variables. You need a `THREE.WebGLRenderer`
    object, a `THREE.Scene` object, a camera, and some way to render the scene. In
    this recipe, we'll provide you with a standard template that you can use in your
    own projects to quickly get started with the WebGL renderer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要创建一个使用 WebGL 进行渲染的初始 Three.js 项目时，您总是必须设置相同的几个变量。您需要一个 `THREE.WebGLRenderer`
    对象，一个 `THREE.Scene` 对象，一个相机，以及渲染场景的方法。在本食谱中，我们将为您提供您可以在自己的项目中使用的标准模板，以便快速开始使用
    WebGL 渲染器。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Make sure that you download the sources for this book. You can either do this
    in the following two ways:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您下载了本书的源代码。您可以通过以下两种方式之一来完成此操作：
- en: Firstly, you can do this by cloning the Git repo that you can find at [https://github.com/josdirksen/threejs-cookbook](https://github.com/josdirksen/threejs-cookbook).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，您可以通过克隆您可以在 [https://github.com/josdirksen/threejs-cookbook](https://github.com/josdirksen/threejs-cookbook)
    找到的 Git 仓库来完成此操作。
- en: Alternatively, you can download the sources from Packt Publishing website. When
    you extract the ZIP file or clone the repository you'll find a set of directories;
    one for each chapter of this book. For this recipe, you can use `0` as a reference.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以从 Packt Publishing 网站下载源代码。当您解压缩 ZIP 文件或克隆存储库时，您将找到一组目录；每个目录对应本书的一章。对于这个食谱，您可以使用
    `0` 作为参考。
- en: 'You can directly view the end result of this recipe by opening the previously
    mentioned file in your browser. When you open this example in the browser, you''ll
    see the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接通过在浏览器中打开之前提到的文件来查看此食谱的最终结果。当您在浏览器中打开此示例时，您将看到以下截图：
- en: '![Getting ready](img/1182OS_01_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_01_01.jpg)'
- en: This is a minimal scene, rendered with the `THREE.WebGLRenderer` object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最小化的场景，使用 `THREE.WebGLRenderer` 对象渲染。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Creating a skeleton that you can use as a base for your projects is easy. With
    a couple of simple steps, you''ll get your first WebGLRenderer-based Three.js
    scene up and running:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可以作为您项目基础的骨架很容易。通过几个简单的步骤，您将获得第一个基于 WebGLRenderer 的 Three.js 场景并开始运行：
- en: 'Let''s first define the basic HTML that we''ll use:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先定义我们将要使用的基本 HTML：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载示例代码文件，以获取您购买的所有
    Packt Publishing 书籍。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: As you can see this is use a simple page, with a `script` tag in the body that'll
    contain our Three.js code. The only interesting part is the CSS style.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这是一个简单的页面，其中包含一个 `script` 标签，它将包含我们的 Three.js 代码。唯一有趣的部分是 CSS 样式。
- en: We will add this style to the body element to make sure that our Three.js scene
    will run in fullscreen mode and won't show any scrollbars.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将此样式添加到 `body` 元素中，以确保我们的 Three.js 场景将以全屏模式运行，并且不会显示任何滚动条。
- en: 'Next, let''s start by filling in the script tag. The first thing that we will
    do is create a number of global variables that are used throughout this recipe:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们先填写 `script` 标签。我们将要做的第一件事是创建一些全局变量，这些变量将在整个配方中使用：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `renderer` variable will hold a reference to the `THREE.WebGLRenderer` object
    that we're going to create in the next step. The `scene` variable is the container
    for all the objects that we want to render, and the `camera` variable determines
    what we will see when we render the scene.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`renderer` 变量将保存对我们在下一步中将要创建的 `THREE.WebGLRenderer` 对象的引用。`scene` 变量是我们想要渲染的所有对象的容器，而
    `camera` 变量决定了渲染场景时我们将看到的内容。'
- en: 'Usually, you''d want to wait for all the HTML elements to finish loading, before
    you start running your JavaScript. For this, we use the following JavaScript:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，您希望在开始运行 JavaScript 之前等待所有 HTML 元素完成加载。为此，我们使用以下 JavaScript：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this code, we tell the browser to call the `init` function, once the complete
    page has loaded. In the next step, we'll show the content of this `init` function.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这段代码，我们告诉浏览器在完整页面加载完毕后调用 `init` 函数。在下一步中，我们将展示这个 `init` 函数的内容。
- en: 'For your skeleton to work, you need to add the `init` function, which looks
    as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使您的骨架工作，您需要添加一个 `init` 函数，其外观如下：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this `init` function, we first created a `THREE.Scene` object with the container
    for all the objects that we want to render. Next, we created a camera, which determines
    the field of the view that will be rendered. Next, we created the `THREE.WebGLRenderer`
    object, which is used to render the scene using WebGL. The `THREE.WebGLRenderer`
    object has many properties. In this recipe, we used the `setClearColor` property
    to set the background of our scene to black, and we told the renderer to use the
    complete window for its output, using the `window.innerWidth` and `window.innerHeight`
    properties. To see whether our skeleton page is working, we then added a simple
    `THREE.Mesh` object with a `THREE.BoxGeometry` object to the scene. At this point,
    we can add the output of the WebGL, as a child of the HTML body element. We do
    this by appending the renderer's DOM element to the document body. Now, all that
    is left to do is render the scene by calling `renderer.render()`.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个 `init` 函数中，我们首先创建了一个 `THREE.Scene` 对象，其中包含我们想要渲染的所有对象的容器。接下来，我们创建了一个相机，它决定了将要渲染的视图范围。接下来，我们创建了
    `THREE.WebGLRenderer` 对象，它用于使用 WebGL 渲染场景。`THREE.WebGLRenderer` 对象有许多属性。在这个配方中，我们使用了
    `setClearColor` 属性将场景的背景设置为黑色，并告诉渲染器使用整个窗口作为其输出，使用 `window.innerWidth` 和 `window.innerHeight`
    属性。为了检查我们的骨架页面是否正常工作，我们随后将一个简单的 `THREE.Mesh` 对象和一个 `THREE.BoxGeometry` 对象添加到场景中。在这个时候，我们可以将
    WebGL 的输出作为 HTML `body` 元素的一个子元素添加。我们通过将渲染器的 DOM 元素附加到文档体来实现这一点。现在，剩下的只是通过调用 `renderer.render()`
    来渲染场景。
- en: With these steps, you've created a basic `WebGLRenderer` based Three.js scene,
    which you can use as a basic starting point for all your Three.js experiments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，您已经创建了一个基于 `WebGLRenderer` 的基本 Three.js 场景，您可以用它作为所有 Three.js 实验的基本起点。
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `THREE.WebGLRenderer` object only works when your browser supports WebGL.
    Even though most modern desktop browsers (and even a large number of mobile browsers)
    support WebGL, in some cases, you might need to look for an alternative. Three.js
    provides a couple of other renderers, which you can use. To get an up-to-date
    overview of which browsers support WebGL, you can check out the information on
    this topic at [http://caniuse.com/webgl](http://caniuse.com/webgl).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.WebGLRenderer`对象仅在您的浏览器支持WebGL时才工作。尽管大多数现代桌面浏览器（甚至大量移动浏览器）支持WebGL，但在某些情况下，您可能需要寻找替代方案。Three.js提供了一些其他渲染器，您可以使用。要获取支持WebGL的浏览器最新概述，您可以查看此主题的信息[http://caniuse.com/webgl](http://caniuse.com/webgl)。'
- en: Besides using the `THREE.WebGLRenderer` object to render your scene, you can
    use the `THREE.CanvasRenderer` object, which is explained in *Getting started
    with the Canvas renderer* recipe or the `THREE.CSS3DRenderer` object, which is
    explained in the *Getting started with the CSS 3D renderer* recipe.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了使用`THREE.WebGLRenderer`对象来渲染您的场景外，您还可以使用在*Canvas渲染器入门*配方中解释的`THREE.CanvasRenderer`对象，或者在*CSS
    3D渲染器入门*配方中解释的`THREE.CSS3DRenderer`对象。
- en: Getting started with the Canvas renderer
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Canvas渲染器入门
- en: 'If your system doesn''t support WebGL, there is an alternative renderer that
    you can use to render your scenes: the `CanvasRenderer` object. This renderer
    doesn''t use WebGL to render the output, but directly uses JavaScript to draw
    the HTML5 canvas element.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统不支持WebGL，您可以使用另一个渲染器来渲染您的场景：`CanvasRenderer`对象。这个渲染器不使用WebGL来渲染输出，而是直接使用JavaScript绘制HTML5
    canvas元素。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In the r69 Version of Three.js, the canvas renderer has been removed from the
    default distribution. To use this renderer, we have to first import the following
    two files:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js的r69版本中，canvas渲染器已被从默认分发中删除。要使用此渲染器，我们首先必须导入以下两个文件：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For this recipe, you can take a look at the `01.02-canvasrenderer-skeleton.html`
    example from the sources in this chapter. If you open this example in your browser,
    you''ll see a cube, pretty much like the one in the previous recipe:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您可以查看本章源文件中的`01.02-canvasrenderer-skeleton.html`示例。如果您在浏览器中打开此示例，您将看到一个立方体，几乎就像上一个配方中的那样：
- en: '![Getting ready](img/1182OS_01_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_01_02.jpg)'
- en: This time, however, this cube is rendered with the HTML5 canvas element. HTML5
    canvas is supported on many devices, but provides less performance than the WebGL-
    based solution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次这个立方体是用HTML5 canvas元素渲染的。HTML5 canvas在许多设备上受到支持，但性能低于基于WebGL的解决方案。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To set up the WebGL renderer, you will follow exactly the same steps as we
    showed in the previous recipe, *Getting started with the WebGL renderer*, so we
    won''t go into the details in this section but we''ll just list down the differences:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置WebGL渲染器，您将遵循我们在上一个配方*WebGL渲染器入门*中展示的 exactly the same steps，因此我们不会在本节中详细介绍，但我们会列出以下差异：
- en: 'To get started with the `THREE.CanvasRenderer` object, the only thing we need
    to change is the following:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用`THREE.CanvasRenderer`对象，我们唯一需要更改的是以下内容：
- en: 'Replace the `THREE.WebGLRenderer` object in the following piece of code:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下代码片段中替换`THREE.WebGLRenderer`对象：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Replace the THREE.WebGLRenderer object with the `THREE.CanvasRenderer` object
    as follows:'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将THREE.WebGLRenderer对象替换为以下`THREE.CanvasRenderer`对象：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And that's it. With this change, we move from rendering using WebGL to rendering
    on the HTML5 canvas.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。通过这个更改，我们从使用WebGL渲染转变为在HTML5 canvas上渲染。
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main difference between the HTML5 canvas renderer and the WebGL renderer
    is that this approach uses JavaScript to directly draw to the HTML5 canvas for
    rendering your 3D scene. The main issue with this approach is the lousy performance.
    When you use the `THREE.WebGLRenderer` object, you can use hardware-accelerated
    rendering. However, with the `THREE.CanvasRenderer` object, you have to completely
    rely on software-based rendering, which will result in lower performance. An added
    disadvantage of `THREE.CanvasRenderer` is that you can't use the advanced materials
    and features of Three.js, as that relies on WebGL specific functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 canvas渲染器和WebGL渲染器之间的主要区别在于，这种方法使用JavaScript直接在HTML5 canvas上绘制以渲染您的3D场景。这种方法的
    主要问题是性能糟糕。当您使用`THREE.WebGLRenderer`对象时，可以使用硬件加速渲染。然而，使用`THREE.CanvasRenderer`对象时，您必须完全依赖基于软件的渲染，这会导致性能降低。`THREE.CanvasRenderer`的另一个缺点是，您无法使用Three.js的高级材料和功能，因为那需要WebGL特定的功能。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: If you can use the WebGL approach given in the *Getting started with the WebGL
    renderer* recipe, you should really use it. It provides more features than those
    that are available with the canvas-based approach, and has much better performance.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以使用 *CSS 3D 渲染器入门* 菜谱中给出的 WebGL 方法，你应该真的使用它。它提供了比基于画布的方法更多的功能，并且性能更好。
- en: In the following recipe, *Getting started with the CSS 3D renderer*, this will
    also show a different approach where we use the CSS 3D-based renderer to animate
    the HTML elements. CSS 3D also provides hardware accelerated rendering, but only
    has support for a limited set of Three.js features.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面的菜谱中，*CSS 3D 渲染器入门*，这也会展示一种不同的方法，其中我们使用基于 CSS 3D 的渲染器来动画化 HTML 元素。CSS 3D
    还提供了硬件加速渲染，但只支持有限的三维.js 功能。
- en: Getting started with the CSS 3D renderer
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS 3D 渲染器入门
- en: HTML and CSS are getting more and more powerful each day. Modern browsers, both
    mobile and desktop variants, have great support for these two standards. The latest
    versions of CSS also support 3D transformations. With the `THREE.CSS3DRenderer`
    object, we can directly access these CSS 3D features and transform an arbitrary
    HTML element in 3D space.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 和 CSS 每天都在变得越来越强大。现代浏览器，无论是移动版还是桌面版，都对这两个标准提供了很好的支持。CSS 的最新版本也支持 3D 变换。使用
    `THREE.CSS3DRenderer` 对象，我们可以直接访问这些 CSS 3D 功能，并在 3D 空间中变换任意 HTML 元素。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use the CSS 3D renderer, we first have to download the specific JavaScript
    file from the Three.js site, as it hasn't been included in the standard Three.js
    distribution. You can download this file directly from GitHub at [https://raw.githubusercontent.com/mrdoob/three.js/master/examples/js/renderers/CSS3DRenderer.js](https://raw.githubusercontent.com/mrdoob/three.js/master/examples/js/renderers/CSS3DRenderer.js)
    or look in the lib directory of the sources provided with this book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 CSS 3D 渲染器，我们首先必须从 Three.js 网站下载特定的 JavaScript 文件，因为它尚未包含在标准的 Three.js 分发中。你可以直接从
    GitHub 下载此文件：[https://raw.githubusercontent.com/mrdoob/three.js/master/examples/js/renderers/CSS3DRenderer.js](https://raw.githubusercontent.com/mrdoob/three.js/master/examples/js/renderers/CSS3DRenderer.js)，或者查看本书提供的源代码的
    lib 目录。
- en: 'To see the `CSS3DRenderer` scene in action, you can open the example `01.03-cssrenderer-skeleton.html`
    in your browser:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `CSS3DRenderer` 场景的实际效果，你可以在浏览器中打开示例 `01.03-cssrenderer-skeleton.html`：
- en: '![Getting ready](img/1182OS_01_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_01_03.jpg)'
- en: What you see here is a standard HTML div element, rendered in 3D with the `THREE.CSS3DRenderer`
    object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的是一个标准的 HTML div 元素，使用 `THREE.CSS3DRenderer` 对象以 3D 形式渲染。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To set up a `THREE.CSS3DRenderer` based scene, we need to perform a couple
    of simple steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个基于 `THREE.CSS3DRenderer` 的场景，我们需要执行几个简单的步骤：
- en: Before we get started with the `THREE.CSS3DRenderer` specific information, first,
    you have to set up a simple basic HTML page as we did in the *Getting started
    with the WebGL renderer* recipe. So walk through the first three steps of that
    recipe, and then continue with the next step.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始 `THREE.CSS3DRenderer` 特定信息之前，首先，你必须设置一个简单的 HTML 页面，就像我们在 *CSS 3D 渲染器入门*
    菜谱中所做的那样。所以按照那个菜谱的前三个步骤进行，然后继续下一步。
- en: 'After the initial setup, the first thing that we need to do is to add the correct
    JavaScript to our head element:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始设置之后，我们首先需要做的是在我们的 head 元素中添加正确的 JavaScript：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we''ll start with the definition of the global variables that we need:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将从定义所需的全局变量开始：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What we define here is a string representation of the element that we want to
    render. As the `THREE.CSS3DRenderer` object works with the HTML elements, we won't
    use any of the standard Three.js geometries here, but just plain HTML. The renderer,
    scene, and camera are simple variables for the corresponding Three.js elements,
    so that we can easily access them from the `render()` function, which we'll see
    later on.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里定义的是我们想要渲染的元素的字符串表示。由于 `THREE.CSS3DRenderer` 对象与 HTML 元素一起工作，我们在这里不会使用任何标准的
    Three.js 几何体，而只是纯 HTML。渲染器、场景和相机是相应的 Three.js 元素的简单变量，这样我们就可以轻松地从 `render()` 函数中访问它们，我们稍后会看到这个函数。
- en: 'Similar to the other skeletons we will initialize the scene in the `init()`
    function. The function that you need to add to the `THREE.CSS3DRenderer` object
    is shown as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他骨骼类似，我们将在 `init()` 函数中初始化场景。你需要添加到 `THREE.CSS3DRenderer` 对象中的函数如下所示：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We'll focus on the highlighted parts in this code fragment. For an explanation
    of the other parts of this function, we will take a look at the *Getting started
    with the WebGL renderer* recipe. As you can see in this fragment, this time we
    will create a `THREE.CSS3DRenderer` object. Just as we did with the other renderers,
    we also need to set the size. Since we want to fill the screen, we will use the
    `window.innerwidth` and `window.innerheight` properties. The rest of the code
    stays the same.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将关注这个代码片段中突出显示的部分。对于这个函数其他部分的解释，我们将参考 *使用 WebGL 渲染器入门* 菜谱。正如你在这个片段中看到的，这次我们将创建一个
    `THREE.CSS3DRenderer` 对象。就像我们使用其他渲染器一样，我们还需要设置大小。由于我们想要填满屏幕，我们将使用 `window.innerWidth`
    和 `window.innerHeight` 属性。其余的代码保持不变。
- en: 'Now, all we need to do to finish this skeleton is add an element. With the
    CSS 3D renderer, we can only add `THREE.CSS3DObject` elements. For this step,
    just add the following function:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要添加一个元素来完成这个骨架。使用 CSS 3D 渲染器，我们只能添加 `THREE.CSS3DObject` 元素。对于这一步，只需添加以下函数：
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function takes an HTML string as the input, converts it to an HTML element,
    sets some CSS styles, and uses this as the input to create a `THREE.CSS3DObject`
    object, which is added to the scene.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数接受一个 HTML 字符串作为输入，将其转换为 HTML 元素，设置一些 CSS 样式，并使用它作为输入创建一个 `THREE.CSS3DObject`
    对象，并将其添加到场景中。
- en: If you open this file in your browser, you'll see something that resembles the
    example we showed in the *Getting ready* section of this recipe. You can use the
    HTML page and JavaScript as a template for the entirety of your CSS 3D renderer
    project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个浏览器中打开这个文件，你会看到类似于我们在本食谱 *准备阶段* 部分展示的示例。你可以使用这个 HTML 页面和 JavaScript 作为你整个
    CSS 3D 渲染器项目的模板。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With CSS 3D, you can apply all kinds of transformations to the HTML elements.
    For instance, you can apply a specific rotation around an axis using the transform
    property. The interesting thing is that you can also apply matrix transformations.
    Three.js uses matrix transformations internally to position and rotate the elements.
    With the `THREE.CSS3DRenderer` object, Three.js hides the internal CSS 3D specific
    transformations and styles and provides a nice abstraction level, which you can
    use to work with the HTML elements in 3D.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CSS 3D，你可以对 HTML 元素应用各种变换。例如，你可以使用 transform 属性在轴周围应用特定的旋转。有趣的是，你还可以应用矩阵变换。Three.js
    使用矩阵变换在内部定位和旋转元素。通过 `THREE.CSS3DRenderer` 对象，Three.js 隐藏了内部 CSS 3D 特定的变换和样式，并提供了一个很好的抽象级别，你可以使用它来与
    3D 中的 HTML 元素一起工作。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: If you can use the WebGL approach from the *Getting started with the WebGL renderer*
    recipe, you should really use it. It provides more features than those that are
    available with the CSS-based approach, but has less support for mobile devices.
    If, on the other hand, you're looking to manipulate the HTML elements on screen,
    the `THREE.CSS3DRenderer` object is a great solution.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以使用从 *使用 WebGL 渲染器入门* 菜单中获取的 WebGL 方法，你应该真的使用它。它提供了比基于 CSS 的方法更多的功能，但移动设备支持较少。另一方面，如果你想要操作屏幕上的
    HTML 元素，`THREE.CSS3DRenderer` 对象是一个很好的解决方案。
- en: Detecting WebGL support
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测 WebGL 支持
- en: Not all browsers currently support WebGL. When you create a page that uses the
    `THREE.WebGLRenderer` object, it is a good idea to make sure that the browser
    supports WebGL. If a browser doesn't support it, this will result in all kinds
    of strange JavaScript errors in the JavaScript console and an empty screen for
    the end user. To make sure that your WebGL projects work as expected, we'll explain
    how to detect WebGL support in a browser in this recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有浏览器都支持 WebGL。当你创建一个使用 `THREE.WebGLRenderer` 对象的页面时，确保浏览器支持 WebGL 是一个好主意。如果一个浏览器不支持它，这将在
    JavaScript 控制台中导致各种奇怪的 JavaScript 错误，并且最终用户将看到一个空白的屏幕。为了确保你的 WebGL 项目按预期工作，我们将在这个菜谱中解释如何在浏览器中检测
    WebGL 支持。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备阶段
- en: 'In this recipe, as an example, we will use the `01.04-detect-webgl-support.html`
    file, which you can find in the sources provided with this book. If you open this
    file, you''ll see the following result if your browser doesn''t support WebGL:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，作为一个例子，我们将使用 `01.04-detect-webgl-support.html` 文件，你可以在这个书的源文件中找到它。如果你打开这个文件，如果你的浏览器不支持
    WebGL，你会看到以下结果：
- en: '![Getting ready](img/1182OS_01_04.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![准备阶段](img/1182OS_01_04.jpg)'
- en: Let's take a look at the recipe to create the preceding example.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看创建前面示例的菜谱。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To detect WebGL and create the message **WebGL is not-supported**, we need
    to perform the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测 WebGL 并创建消息 **WebGL is not-supported**，我们需要执行以下步骤：
- en: First, we'll create the CSS for the pop up to show when WebGL isn't supported.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建当 WebGL 不支持时的弹出窗口的 CSS。
- en: Then, we need to detect whether the browser WebGL is supported. For this, we'll
    write a method that returns the values true or false.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要检测浏览器是否支持 WebGL。为此，我们将编写一个返回 true 或 false 值的方法。
- en: Finally, we'll use the result from the previous step to either show the pop
    up or just continue.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用上一步的结果来显示弹出窗口或继续执行。
- en: 'In the following section, we''ll look at these steps in detail:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细查看这些步骤：
- en: 'The first thing you need to do is set up the CSS that we''ll use:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是设置我们将使用的 CSS：
- en: '[PRE11]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, there is nothing special in this CSS. The only thing that we
    will do here is create a number of classes that we'll use to create a pop-up message
    and hide the background. Next, we will define the HTML that is used to create
    the pop ups.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这个 CSS 中没有特别之处。我们在这里要做的唯一一件事是创建一些我们将用于创建弹出消息和隐藏背景的类。接下来，我们将定义用于创建弹出窗口的
    HTML。
- en: 'The following snippet shows you the HTML code, which will contain the message.
    Using the CSS that we previously defined we can show or hide this element:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了包含信息的 HTML 代码。使用我们之前定义的 CSS，我们可以显示或隐藏这个元素：
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we just create a number of `div` elements that are currently
    hidden. When we detect that WebGL isn't supported this will be shown by the two
    `div` elements by changing their visibility.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们只是创建了一些当前隐藏的 `div` 元素。当我们检测到 WebGL 不支持时，这两个 `div` 元素将通过改变它们的可见性来显示。
- en: 'Next, let''s take a look at the JavaScript you need to add to detect WebGL.
    We''ll create the following function for it:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看看需要添加到检测 WebGL 的 JavaScript。我们将为它创建以下函数：
- en: '[PRE13]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we create an HTML `canvas` element and then try to create a
    WebGL context with the `getContext` function. If this fails, the `gl` variable
    is set to null but if it succeeds, the `gl` variable will contain the WebGL context.
    If the `gl` variable isn't null, it will return true. On the hand, if it is, it
    will return false.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个 HTML `canvas` 元素，然后尝试使用 `getContext` 函数创建一个 WebGL 上下文。如果失败，`gl`
    变量将被设置为 null，但如果成功，`gl` 变量将包含 WebGL 上下文。如果 `gl` 变量不为 null，它将返回 true。另一方面，如果它是
    null，它将返回 false。
- en: 'Now that we''re able to detect whether a browser supports WebGL or not, we''ll
    use this function to show a pop up. For this recipe, we''ll also show you a pop
    up when WebGL is supported:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们能够检测浏览器是否支持 WebGL，我们将使用这个功能来显示一个弹出窗口。对于这个示例，当 WebGL 支持时，我们也会显示一个弹出窗口：
- en: '[PRE14]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And that is it for this recipe. If we add this to a web page, a browser that
    supports WebGL shows a pop up with **WebGL is supported**, if no WebGL is available,
    a pop up is shown with the text **WebGL isn't supported**. Besides this approach,
    you can also use the detector object provided by Three.js at [https://github.com/mrdoob/three.js/blob/master/examples/js/Detector.js](https://github.com/mrdoob/three.js/blob/master/examples/js/Detector.js).
    If you include this file in your JavaScript, you can detect WebGL by checking
    the `webgl` attribute of the `Detector` object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本示例的全部内容。如果我们把这个添加到网页中，支持 WebGL 的浏览器将显示一个包含 **WebGL is supported** 的弹出窗口，如果没有
    WebGL 可用，将显示一个包含文本 **WebGL isn't supported** 的弹出窗口。除了这种方法，您还可以使用 Three.js 提供的检测器对象，在
    [https://github.com/mrdoob/three.js/blob/master/examples/js/Detector.js](https://github.com/mrdoob/three.js/blob/master/examples/js/Detector.js)。如果您将此文件包含在您的
    JavaScript 中，您可以通过检查 `Detector` 对象的 `webgl` 属性来检测 WebGL。
- en: Setting up an animation loop
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置动画循环
- en: In the recipes at the beginning of this chapter, we showed you how to set up
    a basic Three.js scene, using one of the available renderers. If you want to add
    animations to your Three.js scene, for instance, to move the camera around or
    rotate an object, you'll need to call the `render` function multiple times. In
    the old days of JavaScript, you had to control this yourself using the `setTimeout`
    or `setInterval` JavaScript functions. The problem with these functions is that
    they don't take into account what is happening in your browser. For instance,
    your page will be hidden or the Three.js scene might be scrolled out of view.
    A better solution for animations, and the one that we'll use in this recipe, is
    `requestAnimationFrame`. With this function, your browser determines when it is
    the best time to call the animation code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头的菜谱中，我们向您展示了如何使用可用的渲染器之一设置基本的Three.js场景。如果您想为Three.js场景添加动画，例如移动相机或旋转对象，您需要多次调用`render`函数。在JavaScript的旧时代，您必须使用`setTimeout`或`setInterval`JavaScript函数自行控制此操作。这些函数的问题在于它们没有考虑到浏览器中的情况。例如，您的页面可能被隐藏，或者Three.js场景可能被滚动出视图。对于动画来说，一个更好的解决方案，也是我们在本菜谱中使用的解决方案是`requestAnimationFrame`。使用此函数，浏览器将确定何时调用动画代码的最佳时机。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we will use the `01.05-setup-animation-loop.html` example
    HTML file. To see the animation in action, just open this file in your browser:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此菜谱，我们将使用`01.05-setup-animation-loop.html`示例HTML文件。要查看动画效果，只需在浏览器中打开此文件：
- en: '![Getting ready](img/1182OS_01_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_01_05.jpg)'
- en: This example uses the WebGL renderer. You can of course apply this same recipe
    to the other renderers we've discussed in this chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用WebGL渲染器。当然，你也可以将此相同的菜谱应用于本章中讨论的其他渲染器。
- en: Let's take a look at the steps we need to take to set up such an animation loop.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看设置此类动画循环所需的步骤。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create an animation loop you don''t have to change much in your existing
    code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个动画循环，你不需要在现有代码中做太多更改：
- en: 'Let''s first look at how to use `requestAnimationFrame` for rendering. For
    this, we''ve created a render function:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用`requestAnimationFrame`进行渲染。为此，我们创建了一个渲染函数：
- en: '[PRE15]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we pass the render function as an argument to request a frame
    for animation. This will cause the `render` function to be called at a regular
    interval. In the `render` function, we will also update the rotation of the *x*
    axis of the cube to show you that the scene is re-rendered.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们将渲染函数作为参数传递以请求动画帧。这将导致`render`函数以固定间隔被调用。在`render`函数中，我们还将更新立方体的*x*轴旋转，以向你展示场景正在重新渲染。
- en: 'To use this function in the recipes, which we saw at the beginning of this
    chapter, we just have to replace this call:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用本章开头提到的这个功能，我们只需替换这个调用：
- en: '[PRE16]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will now have your own animation loop, so any changes made to your model,
    camera, or other objects in the scene can now be done from within the `render()`
    function.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将拥有自己的动画循环，因此对模型、相机或场景中的其他对象所做的任何更改现在都可以在`render()`函数内完成。
- en: See also
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: We mentioned that in this recipe, we've used the `THREE.WebGLRenderer` object
    as an example. You can of course also apply this to the skeletons from the *Getting
    started with the Canvas renderer* recipe or *Getting started with the CSS 3D renderer*
    recipe.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提到，在这个菜谱中，我们使用了`THREE.WebGLRenderer`对象作为示例。当然，你也可以将此应用于*从Canvas渲染器入门*菜谱或*从CSS
    3D渲染器入门*菜谱中的骨骼。
- en: What will be of interest to you also is the *Determining the frame rate of your
    scene* recipe, where we'll add additional functionality to the skeletons so you
    can easily see how often the render function is called by `requestAnimationFrame`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能还会对*确定场景帧率*菜谱感兴趣，我们将在此菜谱中为骨骼添加额外的功能，以便你可以轻松地看到`requestAnimationFrame`调用渲染函数的频率。
- en: Determining the frame rate for your scene
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定场景的帧率
- en: When you create large Three.js applications with many objects and animations,
    it is good to keep an eye on the frame rate at which the browser can render your
    scene. You can do this yourself using log statements from your animation loop,
    but luckily, there is already a good solution available that integrates great
    with Three.js (which isn't that strange since it was originally written for Three.js).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建包含许多对象和动画的大型Three.js应用程序时，关注浏览器可以渲染您的场景的帧率是很好的。您可以使用动画循环中的日志语句自己来做这件事，但幸运的是，已经有一个很好的解决方案可用，并且与Three.js集成得很好（这并不奇怪，因为它最初是为Three.js编写的）。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we''ll use the `stats.js` JavaScript library that you can
    download from its GitHub repository at [https://github.com/mrdoob/stats.js/](https://github.com/mrdoob/stats.js/).
    To use this library, you have to include it at the top of your HTML file such
    as this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用可以从其GitHub仓库[https://github.com/mrdoob/stats.js/](https://github.com/mrdoob/stats.js/)下载的`stats.js`
    JavaScript库。要使用这个库，您必须在HTML文件的顶部包含它，如下所示：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ve also provided a ready to use example for this recipe. If you open the
    `01.06-determine-framerate.html` file in your browser, you can directly see how
    this library shows the current framerate, which you can see at the top-left of
    the browser, as shown in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为此菜谱提供了一个现成的示例。如果您在浏览器中打开`01.06-determine-framerate.html`文件，您可以直接看到这个库如何显示当前的帧率，您可以在浏览器的左上角看到它，如下面的截图所示：
- en: '![Getting ready](img/1182OS_01_06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_01_06.jpg)'
- en: Let's take a look at the steps you need to take to add this to your Three.js
    application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您需要采取的步骤，将此功能添加到您的Three.js应用程序中。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Adding this functionality to your scene only takes a couple of small steps,
    which are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将此功能添加到您的场景中只需几个小步骤，具体如下：
- en: 'Firstly, we have to create the `stats` object and position it. For this, we
    create a simple function:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建`stats`对象并定位它。为此，我们创建了一个简单的函数：
- en: '[PRE18]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We create the statistics object by calling `new Stats()`. The `Stats.js` library
    supports two different modes that we can set with the `setMode` function. If we
    pass `0` as an argument, you see the frames rendered in the last second, and if
    we set the mode to `1`, we see the milliseconds that were needed to render the
    last frame. For this recipe, we want to see the framerate, so we set the mode
    to `0`.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过调用`new Stats()`来创建统计对象。`Stats.js`库支持两种不同的模式，我们可以使用`setMode`函数来设置这些模式。如果我们传递`0`作为参数，您会看到最后一秒内渲染的帧数，如果我们设置模式为`1`，我们会看到渲染最后一帧所需的毫秒数。对于这个菜谱，我们想看到帧率，所以我们设置模式为`0`。
- en: 'Now that we can create the statistics object, we need to append the `init`
    method we''ve seen in the skeleton recipes:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了统计对象，我们需要添加在骨架菜谱中看到的`init`方法：
- en: '[PRE19]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see we created a new global variable called `stats`, which we'll
    use to access our statistics object. In the `init` method, we use the function
    we just created, and add the `stats` object to our HTML body.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们创建了一个名为`stats`的新全局变量，我们将使用它来访问我们的统计对象。在`init`方法中，我们使用我们刚刚创建的函数，并将`stats`对象添加到我们的HTML主体中。
- en: 'We''re almost there. The only thing we need to do now is make sure that we
    update the `stats` object whenever the render function is called. This way, the
    `stats` object can calculate either the framerate or the time it took to run the
    render function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了。我们现在唯一需要做的是确保在渲染函数被调用时更新`stats`对象。这样，`stats`对象就可以计算帧率或运行渲染函数所需的时间：
- en: '[PRE20]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We mentioned that `Stats.js` provides two modes. It either shows the framerate
    or the time it took to render the last frame. The `Stats.js` library works by
    simply keeping track of the time passed between calls and its `update` function.
    If you're monitoring the framerate, it counts how often the update was called
    within the last second, and shows that value. If you're monitoring the render
    time, it just shows the time between calls and the `update` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到`Stats.js`提供了两种模式。它要么显示帧率，要么显示渲染最后一帧所需的时间。`Stats.js`库通过简单地跟踪调用之间的时间差及其`update`函数来工作。如果您正在监控帧率，它会计算在最后一秒内更新被调用的频率，并显示该值。如果您正在监控渲染时间，它只显示调用之间的时间和`update`函数。
- en: Controlling the variables used in the scene
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制场景中使用的变量
- en: When you're developing and writing JavaScript, you often need to tune some variables
    for the best visualization. You might need to change the color of a sphere, change
    the speed of an animation, or experiment with more complex material properties.
    You can just change the source code, and reload the HTML, but that becomes tedious
    and time consuming. In this recipe, we'll show you an alternative way to quickly
    and easily control the variables in your Three.js scene.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开发和编写JavaScript时，您通常需要调整一些变量以获得最佳的视觉效果。您可能需要更改球体的颜色，更改动画的速度，或者对更复杂的材质属性进行实验。您可以简单地更改源代码并重新加载HTML，但这变得繁琐且耗时。在这个菜谱中，我们将向您展示一种快速且轻松地控制Three.js场景中变量的替代方法。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we also need an external JavaScript library called `dat.gui`.
    You can download the latest version from [https://code.google.com/p/dat-gui/](https://code.google.com/p/dat-gui/),
    or look into the `libs` directory of the sources provided with this book. To use
    this library, you first have to include it in the top of your HTML file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们还需要一个名为`dat.gui`的外部JavaScript库。您可以从[https://code.google.com/p/dat-gui/](https://code.google.com/p/dat-gui/)下载最新版本，或者查看本书提供的源代码的`libs`目录。要使用这个库，您首先需要在HTML文件顶部包含它：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the source folder of this chapter, there is also a ready-to-use example,
    which we''ll explain in the following sections. When you open the `01.07-control-variables.html`
    file, you''ll see the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的源文件夹中，还有一个现成的示例，我们将在以下几节中解释。当您打开`01.07-control-variables.html`文件时，您将看到以下内容：
- en: '![Getting ready](img/1182OS_01_07.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_01_07.jpg)'
- en: As you can see in the preceding screenshot, a menu is available in the top-right
    corner that you can use to control the rotation speed and the scaling of the cube.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前一个屏幕截图中所见，右上角有一个菜单，您可以使用它来控制立方体的旋转速度和缩放。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To use this library for yourself, you only need to do a couple of small things:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要为自己使用这个库，您只需要做几件小事：
- en: 'The first thing you need to do is define a JavaScript object that contains
    the properties you want to control. In this case, you need to add it to the `init`
    function and create a new global JavaScript variable with the name, `control`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您首先需要定义一个包含您想要控制的属性的JavaScript对象。在这种情况下，您需要将其添加到`init`函数中，并创建一个名为`control`的新全局JavaScript变量：
- en: '[PRE22]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The control object in the preceding code contains two properties: `rotationSpeed`
    and `scale`. In the `addControls` function, we''ll create the UI component that
    is shown in the preceding screenshot:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一段代码中的控制对象包含两个属性：`rotationSpeed`和`scale`。在`addControls`函数中，我们将创建前一个屏幕截图所示的UI组件：
- en: '[PRE23]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this `addControls` function, we use the provided argument that contains
    the `rotationSpeed` and `scale` properties in order to create the control GUI.
    For each variable, we specify four arguments:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个`addControls`函数中，我们使用提供的包含`rotationSpeed`和`scale`属性的参数来创建控制GUI。对于每个变量，我们指定四个参数：
- en: '**Object**: The first argument is the JavaScript object that contains the variables.
    In our case, it''s the object passed to the `addControls` function.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对象**：第一个参数是包含变量的JavaScript对象。在我们的例子中，它是传递给`addControls`函数的对象。'
- en: '**Name**: The second argument is the name of the variable we want to add. This
    should point to one of the variables (or functions) available in the object that
    is provided in the first argument.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**名称**：第二个参数是我们想要添加的变量的名称。这应该指向第一个参数中提供的对象中可用的一个变量（或函数）。'
- en: '**Minimum value**: The third argument is the minimum value that should be shown
    in the GUI.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最小值**：第三个参数是GUI中应显示的最小值。'
- en: '**Maximum value**: The last argument specifies the maximum value that should
    be shown.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大值**：最后一个参数指定应显示的最大值。'
- en: At this point, we've got a GUI that can be used to control the variables, as
    you can see in the following screenshot:![How to do it...](img/1182OS_01_08.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经得到了一个可以用来控制变量的GUI，正如您在以下屏幕截图中所见：![如何操作...](img/1182OS_01_08.jpg)
- en: 'The only thing we now need to do is make sure that we update our object in
    the render loop, which is based on the variables from the GUI. We can do this
    easily in the `render` function, which is as follows:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在唯一需要做的是确保我们在渲染循环中更新我们的对象，该循环基于GUI中的变量。我们可以在`render`函数中轻松地做到这一点，如下所示：
- en: '[PRE24]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's more...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this recipe, we''ve just used `dat.gui` to change the numeric values. The
    `dat.gui` library also allows you to add controls for other types of values as
    follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们只是使用了`dat.gui`来更改数值。`dat.gui`库还允许你添加其他类型值的控件，如下所示：
- en: If the variable you add is a Boolean, a checkbox will be shown
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你添加的变量是布尔值，将显示一个复选框
- en: If the variable is a string, you can add an array of valid values
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果变量是字符串，你可以添加一个有效值的数组
- en: If the variable is a color, you can use add color to create a color picker
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果变量是颜色，你可以使用添加颜色来创建颜色选择器
- en: If the variable is a function, you get a button that fires the selected function
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果变量是函数，你会得到一个触发所选函数的按钮
- en: Besides this, you can add different kinds of event listeners to fire custom
    callbacks when a value managed by `dat.gui` changes. For more information, see
    the `dat.gui` library documentation which you can find at [http://workshop.chromeexperiments.com/examples/gui/#1--Basic-Usage](http://workshop.chromeexperiments.com/examples/gui/#1--Basic-Usage).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以添加不同类型的事件监听器，当`dat.gui`管理的值发生变化时触发自定义回调。有关更多信息，请参阅[http://workshop.chromeexperiments.com/examples/gui/#1--Basic-Usage](http://workshop.chromeexperiments.com/examples/gui/#1--Basic-Usage)上的`dat.gui`库文档。
- en: Setting up a local web server with Python
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python设置本地Web服务器
- en: 'The best way to test your Three.js applications, or any JavaScript application
    for that matter, is to run it on a local web server. This way, you have the best
    representation of how your users will eventually see your Three.js visualization.
    In this chapter, we will show you three different ways in which you can run a
    web server locally. The three different ways to set up a local web server are:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的Three.js应用程序，或者任何JavaScript应用程序，最好的方法是在本地Web服务器上运行它。这样，你可以最好地展示你的用户最终将如何看到你的Three.js可视化。在本章中，我们将向您展示三种不同的方法，您可以在本地运行Web服务器。设置本地Web服务器的三种不同方法是：
- en: One way to do this is via a Python-based approach that you can use if you've
    got Python installed
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种方法是使用基于Python的方法，如果你已经安装了Python，你可以使用
- en: Another way is to do if you use Node.js or have already played around with Node.js,
    you can use the `npm` command to install a simple web server
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是如果你使用Node.js或者已经尝试过Node.js，你可以使用`npm`命令安装一个简单的Web服务器
- en: A third option is if you don't want to use the `npm` command or Python, you
    can also use **Mongoose**, which is a simple portable web server, that runs on
    OS X and Windows
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种选择是，如果你不想使用`npm`命令或Python，你也可以使用**Mongoose**，这是一个简单的便携式Web服务器，可在OS X和Windows上运行
- en: This recipe will focus on the Python-based approach (the first bullet point).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将重点关注基于Python的方法（第一个项目符号）。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If you''ve got Python installed, you can very easily run a simple web server.
    You will first need to check whether you''ve got Python installed. The easiest
    way to do this is just type in `python` on a console and hit *enter*. If you see
    an output as follows, you are ready to begin:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了Python，你可以非常容易地运行一个简单的Web服务器。首先，你需要检查你是否已经安装了Python。最简单的方法是在控制台中输入`python`并按*回车*。如果你看到以下输出，你就可以开始了：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once Python ([http://python.org](http://python.org)) has been installed, you
    can run a simple web server by just executing the following Python command. You
    will need to do this in the directory from where you want to host the files:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装了Python ([http://python.org](http://python.org))，你只需执行以下Python命令即可运行一个简单的Web服务器。你需要在这个目录中执行此操作，即你想要托管文件的目录：
- en: '[PRE26]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following output shows the web server running on port 8000:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下输出显示了在端口8000上运行的Web服务器：
- en: '[PRE27]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you don't have Python installed, take a look at one of the following two
    recipes for alternative options.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装Python，请查看以下两个配方中的替代选项。
- en: Setting up a local web server with Node.js
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js设置本地Web服务器
- en: If you would like to test your Three.js applications, then as described in the
    *How to set up a local web server with Python* recipe, you can run it in three
    different ways. This recipe will focus on the Node.js approach.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要测试你的Three.js应用程序，那么根据*如何使用Python设置本地Web服务器*配方中的描述，你可以以三种不同的方式运行它。本配方将重点关注Node.js方法。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To run a local web server with Node.js ([https://nodejs.org](https://nodejs.org)),
    we first have to check whether we''ve got `npm` (the node package manager, which
    is installed together with Node.js) installed. You can check this by running the
    `npm` command from the command line:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Node.js 运行本地网络服务器（[https://nodejs.org](https://nodejs.org)），我们首先必须检查我们是否已经安装了
    `npm`（节点包管理器，与 Node.js 一起安装）。你可以通过在命令行中运行 `npm` 命令来检查：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the output is similar to the following code snippet, you''ve got `npm` installed
    and you are ready to begin the recipe:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出类似于以下代码片段，则表示你已经安装了 `npm`，并且可以开始食谱：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can use it to run a simple web server using:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用它来运行一个简单的网络服务器：
- en: '[PRE30]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, you are ready to install a web server by running:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你准备好通过运行以下命令来安装网络服务器：
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, you are ready to start the web server by running `http-server` from
    the command line:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以通过在命令行中运行 `http-server` 来启动网络服务器：
- en: '[PRE32]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A final recipe for running your own web server is presented in the next section.
    In that recipe you don't need Python or Node.js installed, but we will show you
    how to download a portable web server that you can run without requiring any installation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中提供了一个运行你自己的网络服务器的最终食谱。在该食谱中，你不需要安装 Python 或 Node.js，但我们将向你展示如何下载一个可携带的网络服务器，你可以在不进行任何安装的情况下运行它。
- en: Setting up a local web server using Mongoose
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mongoose 设置本地网络服务器
- en: If you would like to test your Three.js applications, then as described in the
    *How to set up a local web server with Python* recipe, you can run it in three
    different ways. If the first two approaches fail, you can always use a simple
    portable web server using Mongoose. This recipe will focus on the Mongoose approach.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要测试你的 Three.js 应用程序，那么如 *如何使用 Python 设置本地网络服务器* 食谱中所述，你可以以三种不同的方式运行它。如果前两种方法失败，你始终可以使用一个简单的
    Mongoose 可携带网络服务器。这个食谱将专注于 Mongoose 方法。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you run Mongoose, you first have to download it. You can download Mongoose
    from [https://code.google.com/p/mongoose/downloads/list](https://code.google.com/p/mongoose/downloads/list).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 Mongoose 之前，你首先必须下载它。你可以从 [https://code.google.com/p/mongoose/downloads/list](https://code.google.com/p/mongoose/downloads/list)
    下载 Mongoose。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The platform you are using will affect how you run Mongoose. If you're running
    Windows, you can just copy the downloaded file (an executable) to the folder from
    where you want to host your files from (for example, the directory where you extracted
    the sources for this book), and double-click on the executable to start the web
    server on port 8080.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你所使用的平台将影响你运行 Mongoose 的方式。如果你正在使用 Windows，你可以直接将下载的文件（一个可执行文件）复制到你想要托管文件的文件夹中（例如，你提取本书源代码的目录），然后双击可执行文件以在
    8080 端口启动网络服务器。
- en: For Linux or OS X platforms, you will also need to have a copy of the downloaded
    file in the directory where your files are located, but you have to start Mongoose
    from the command line.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Linux 或 OS X 平台，你还需要在包含你的文件的目录中有一个下载文件的副本，但你必须从命令行启动 Mongoose。
- en: See also
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you can't install a local web server, you can take a look at the *Solving
    cross-origin-domain error messages in Chrome* recipe. This recipe provides you
    with an alternative way of running the more advanced Three.js examples.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你无法安装本地网络服务器，你可以查看 *解决 Chrome 中的跨域错误信息* 食谱。这个食谱为你提供了一个运行更高级 Three.js 示例的替代方法。
- en: Solving cross-origin-domain error messages in Chrome
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决 Chrome 中的跨域错误信息
- en: 'When you are developing Three.js applications, the simplest way of testing
    your application is to just open the file in your browser. For a lot of scenarios,
    this will work, until you start loading textures and models. If you try to do
    this, you''ll be presented with an error that looks something like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发 Three.js 应用程序时，测试你的应用程序最简单的方法就是直接在浏览器中打开文件。对于许多场景，这将会工作，直到你开始加载纹理和模型。如果你尝试这样做，你会看到一个类似以下的错误：
- en: '![Solving cross-origin-domain error messages in Chrome](img/1182OS_01_09.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![解决 Chrome 中的跨域错误信息](img/1182OS_01_09.jpg)'
- en: This error, which you can easily reproduce yourself by just dragging `01.09-solve-cross-origin-issues.html`
    to your browser, will have the terms **cross-origin** or **SecurityError** in
    its message. What this error means is that the browsers prevents the current page
    loading a resource from a different domain. This is a necessary feature to avoid
    maleficent websites access to personal information. During development, however,
    this can be a bit incovenient. In this recipe, we'll show you how you can circumvent
    these kinds of errors by tweaking the security settings of your browser.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将 `01.09-solve-cross-origin-issues.html` 拖动到浏览器中来轻松地重现此错误，错误信息中会有 **跨域**
    或 **SecurityError** 等术语。这个错误意味着浏览器阻止当前页面从不同域加载资源。这是避免恶意网站访问个人信息的一个必要功能。然而，在开发过程中，这可能会有些不便。在本配方中，我们将向您展示如何通过调整浏览器的安全设置来绕过这类错误。
- en: 'We''ll take a look at how to disable the security checks for the two browsers
    that have the best support for WebGL: Chrome and Firefox. In this recipe, we''ll
    look at how to do this in Chrome, and in the next recipe, we''ll show you how
    to do this in Firefox. An important note, though, before we go on with the recipe.
    If you can, run a local web server. It''s much more secure and doesn''t result
    in low security settings in your browser.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何禁用对支持 WebGL 最好的两个浏览器的安全检查：Chrome 和 Firefox。在本配方中，我们将介绍如何在 Chrome 中实现这一点，而在下一个配方中，我们将向您展示如何在
    Firefox 中实现这一点。然而，在继续配方之前，有一个重要的注意事项。如果您能的话，请运行一个本地 web 服务器。它要安全得多，并且不会导致您的浏览器设置安全级别过低。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'After the installation of Chrome is complete, we will then need to disable
    the security settings in Chrome, for which we have to pass a command line parameter.
    Each operating system, however, does this slightly differently:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Chrome 安装完成后，我们还需要在 Chrome 中禁用安全设置，这需要传递一个命令行参数。然而，每个操作系统执行此操作的方式略有不同：
- en: 'For Windows, you call the following (from the command line):'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Windows，您需要在命令行中调用以下内容：
- en: '[PRE33]'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On Linux, do the following:'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 上，请执行以下操作：
- en: '[PRE34]'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And on Mac OS, you disable the settings by starting Chrome using:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Mac OS 上，您可以通过以下方式禁用设置：启动 Chrome。
- en: '[PRE35]'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you start Chrome this way, even running it directly from the filesystem
    will load the resources correctly to give you the following result:![How to do
    it...](img/1182OS_01_10.jpg)
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式启动 Chrome 后，即使是直接从文件系统运行它，也能正确加载资源，给您以下结果：![如何操作...](img/1182OS_01_10.jpg)
- en: Do remember to restart the browser normally after you're done experimenting
    or developing with Three.js, since you've lowered the security settings of your
    browser.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，在您完成使用 Three.js 进行实验或开发后，正常重启浏览器，因为您已经降低了浏览器的安全设置。
- en: For Firefox users, we explain how to solve these cross-origin issues for this
    browser in the following recipe.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Firefox 用户，我们将在下面的配方中解释如何解决此浏览器的跨域问题。
- en: Solving cross-origin-domain error messages in Firefox
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决 Firefox 中的跨域域错误信息
- en: 'In the previous recipe, we explained that cross-origin error messages can occur
    when you run Three.js applications from the filesystem. In this recipe, we showed
    you how to solve these kind of issues on Chrome. In this recipe, we look at how
    to solve these issues in another popular browser: Firefox.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们解释了当您从文件系统运行 Three.js 应用程序时，可能会发生跨域错误信息。在本配方中，我们向您展示了如何在 Chrome 中解决这类问题。在本配方中，我们将探讨如何在另一款流行的浏览器：Firefox
    中解决这些问题。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For Firefox, we will then need to disable the security settings directly from
    the browser. If you type `about:config` in the URL bar, you will see the following:![How
    to do it...](img/1182OS_01_11.jpg)
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Firefox，我们接下来需要直接从浏览器中禁用安全设置。如果您在地址栏中输入 `about:config`，您将看到以下内容：![如何操作...](img/1182OS_01_11.jpg)
- en: On this screen, just click on the **I'll be careful, I promise!** button. This
    will bring you to an overview page that shows you all the internal properties
    available in Firefox.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此屏幕上，只需单击 **我会小心，我保证** 按钮。这将带您到一个概述页面，显示 Firefox 中所有可用的内部属性。
- en: Following this, in the search box on this screen type `security.fileuri.strict_origin_policy`
    and change its value, as shown in the following screenshot:![How to do it...](img/1182OS_01_12.jpg)
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，在此屏幕上的搜索框中输入 `security.fileuri.strict_origin_policy` 并更改其值，如图所示：![如何操作...](img/1182OS_01_12.jpg)
- en: Now, when you open a file directly in the browser, even the resources loaded
    through one of the asynchronous loaders will work.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您直接在浏览器中打开文件时，即使是通过异步加载器加载的资源也将正常工作。
- en: Do remember to change these settings back after you're done experimenting or
    developing with Three.js, since you've lowered the security settings of your browser.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，在完成实验或使用Three.js进行开发后，将这些设置改回原来的状态，因为你已经降低了浏览器的安全设置。
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The reason we have to set these properties is that, by default, the modern browser
    checks whether you're allowed to request a resource from a different domain than
    the one you're running on. When you use Three.js to load a model or a texture,
    it uses an `XMLHTTPRequest` object to access that resource. Your browser will
    check for the availability of the correct headers, and since you're requesting
    a resource from your local system, which doesn't provide the correct headers,
    an error will occur. Even, though with this recipe, you can circumvent this restriction,
    it is better to always test with a local web server, since that will most closely
    resemble how your users will access it online.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须设置这些属性的原因是，默认情况下，现代浏览器会检查你是否被允许从运行域之外请求资源。当你使用Three.js加载模型或纹理时，它使用 `XMLHTTPRequest`
    对象来访问该资源。浏览器将检查正确头部的可用性，由于你从本地系统请求资源，而本地系统不提供正确的头部，因此会发生错误。即使在这个食谱中，你可以绕过这个限制，但最好始终使用本地Web服务器进行测试，因为这最接近你的用户在线访问的方式。
- en: For more information on CORS, refer to [http://www.w3.org/TR/cors/](http://www.w3.org/TR/cors/).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于CORS的信息，请参阅 [http://www.w3.org/TR/cors/](http://www.w3.org/TR/cors/)。
- en: See also
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: As we mentioned in the previous section, a better way to handle these kinds
    of errors is by setting up a local web server. The *Setting up a local web server
    with Python* recipe, explains how to accomplish this.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，处理这类错误的一个更好的方法是设置一个本地Web服务器。"使用Python设置本地Web服务器"食谱解释了如何完成这项工作。
- en: Adding keyboard controls
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加键盘控制
- en: If you want to create games or more advanced 3D scenes, you often need a way
    to control elements in your scene using keyboard controls. For instance, you might
    make a platform game where the user uses the arrows on the keyboard to move through
    your game. Three.js in itself doesn't provide a specific functionality to handle
    keyboard events, since it is very easy to connect the standard HTML JavaScript
    event handling to Three.js.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建游戏或更高级的3D场景，你通常需要一个方法来使用键盘控制来控制场景中的元素。例如，你可能制作一个平台游戏，用户可以使用键盘上的箭头在游戏中移动。Three.js本身并不提供处理键盘事件的具体功能，因为它非常容易将标准的HTML
    JavaScript事件处理连接到Three.js。
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we included an example where you can rotate a cube around
    its *x* and *z* axes using the arrows on your keyboard. If you first open an example
    `01.10-keyboard-controls.html` in your browser, you''ll see a simple cube:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们包含了一个示例，你可以使用键盘上的箭头旋转一个立方体，使其围绕其 *x* 和 *z* 轴旋转。如果你首先在浏览器中打开示例 `01.10-keyboard-controls.html`，你会看到一个简单的立方体：
- en: '![Getting ready](img/1182OS_01_13.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_01_13.jpg)'
- en: With the up, down, left, and right arrows on your keyboard, you can rotate this
    cube. With this file open, you are now ready to begin.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键盘上的上、下、左和右箭头，你可以旋转这个立方体。打开这个文件后，你现在就可以开始操作了。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Adding a key support in your browser is very easy; all you have to do is assign
    an event handler to `document.onkeydown`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中添加键盘支持非常简单；你所要做的就是将事件处理器分配给 `document.onkeydown`。
- en: 'To do this we need to assign a function to the `document.onkeydown` object
    This function will get called whenever a key is pressed. The following code, wrapped
    in the `setupKeyControls` function, registers this listener:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要将一个函数分配给 `document.onkeydown` 对象。这个函数将在按下任何键时被调用。以下代码，在 `setupKeyControls`
    函数中封装，注册了这个监听器：
- en: '[PRE36]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this function, we use the `keyCode` property from the passed event `e` in
    order to determine what to do. In this example, if a user presses the left arrow
    key that corresponds to key code `37`, we change the `rotation.x` property of
    the Three.js object in our scene. We apply the same principle to the up arrow
    key(`38`), the right arrow (`39`), and the down arrow (`40`).
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用传递的事件 `e` 中的 `keyCode` 属性来确定要做什么。在这个例子中，如果用户按下对应于键码 `37` 的左箭头键，我们就会改变场景中Three.js对象的
    `rotation.x` 属性。我们将同样的原则应用于上箭头键（`38`）、右箭头（`39`）和下箭头（`40`）。
- en: How it works...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using event handlers is a standard HTML JavaScript mechanism, they are a part
    of the DOM API. This API allows you to register functions for all kinds of different
    events. Whenever that specific event occurs, the provided function is called.
    In this recipe, we chose to use the `KeyDown` event. This event is triggered when
    the user presses a key. There is also a `KeyUp` event available that is triggered
    when the user releases a key, which one to use depends on your use case. Note
    that there is also a `KeyPress` event available. This event, though, is meant
    to be used with characters and doesn't register any noncharacter key press.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件处理器是标准的HTML JavaScript机制，它们是DOM API的一部分。此API允许您为所有不同的事件注册函数。每当发生特定事件时，提供的函数就会被调用。在这个菜谱中，我们选择使用`KeyDown`事件。当用户按下键时，此事件被触发。还有一个`KeyUp`事件可供使用，它在用户释放键时触发，使用哪个取决于您的用例。请注意，还有一个`KeyPress`事件可供使用。然而，此事件旨在与字符一起使用，并且不会注册任何非字符键的按下。
- en: There's more...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this recipe, we only showed the key code values for the arrows. There is,
    of course, a separate key code for each key on your keyboard. A good explanation
    of how the various keys are mapped (especially, the special ones such as the function
    keys) can be found at [http://unixpapa.com/js/key.html](http://unixpapa.com/js/key.html).
    If you want to know the key value of a specific key, and you don''t feel like
    looking up the value in a list, you can also use just the following simple handler
    to output the key codes to the JavaScript console:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们只展示了箭头的键码值。当然，每个键盘上的键都有一个单独的键码。关于各种键如何映射的详细解释（特别是特殊键，如功能键），可以在[http://unixpapa.com/js/key.html](http://unixpapa.com/js/key.html)找到。如果您想了解特定键的键值，而且不想在列表中查找值，您也可以使用以下简单的处理器将键码输出到JavaScript控制台：
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This small handler logs the complete event. In the output to the console, you
    can then see the key code that is used, as shown in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小处理器记录了完整的事件。然后，在控制台的输出中，您可以查看所使用的键码，如下面的截图所示：
- en: '![There''s more...](img/1182OS_01_14.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/1182OS_01_14.jpg)'
- en: As you can see, you also see a lot of other interesting information. For instance,
    you can see whether the *shift* or *Alt* keys were also pressed at the same time
    of the event.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您还可以看到很多其他有趣的信息。例如，您可以看到在事件发生的同时是否也按下了*Shift*或*Alt*键。
- en: See also
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you want to learn more about key events, Mozilla provides a good overview
    of all the events that are available at [https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events).
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于键事件的信息，Mozilla提供了一个关于所有可用事件的良好概述，请参阅[https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)。
- en: Loading textures asynchronously
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步加载纹理
- en: When you create Three.js scenes, you often need to load resources. There might
    be textures you want to load for your objects, you might have some external models
    you want to include in your scene, or maybe some CSV data that you want to use
    as an input for your visualization. Three.js offers a number of different ways
    of loading these resources asynchronously, which we'll explore in this and the
    following recipes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建Three.js场景时，您通常需要加载资源。您可能需要为您的对象加载纹理，您可能有一些外部模型想要包含在您的场景中，或者可能有一些CSV数据，您想要将其用作可视化的输入。Three.js提供了一系列不同的异步加载这些资源的方法，我们将在本菜谱和接下来的菜谱中探讨。
- en: To run these recipes and experiment with them, we included a simple sample in
    the source folder of this chapter that shows this loading in action. If you open
    an example `01.11-load-async-resources.html` in your browser, and open the JavaScript
    console, you'll see the progress and the result of loading resources asynchronously.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些菜谱并进行实验，我们在本章的源文件夹中包含了一个简单的示例，展示了这种加载的实际操作。如果您在浏览器中打开示例`01.11-load-async-resources.html`，并打开JavaScript控制台，您将看到加载资源的进度和结果。
- en: Please note that since we are loading files directly from the browser, you need
    to have either a local web server installed (see the *Setting up a local web server
    with Python* recipe or the *Setting up a local web server with Node.js* recipe)
    or disable some security checks as explained in the *Solving cross-origin-domain
    error messages in Chrome* recipe or the *Solving cross-origin-domain error messages
    in Firefox* recipe.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们直接从浏览器中加载文件，您需要安装本地 Web 服务器（请参阅 *使用 Python 设置本地 Web 服务器* 食谱或 *使用 Node.js
    设置本地 Web 服务器* 食谱），或者禁用 *解决 Chrome 中的跨源域错误消息* 食谱或 *解决 Firefox 中的跨源域错误消息* 食谱中解释的一些安全检查。
- en: '![Loading textures asynchronously](img/1182OS_01_15.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![异步加载纹理](img/1182OS_01_15.jpg)'
- en: In these first of the five recipes, we'll show you how you can load textures
    asynchronously with Three.js.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这五个食谱中的第一个，我们将向您展示如何使用 Three.js 异步加载纹理。
- en: Getting ready
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Before looking at the steps in this recipe, you will need to create a number
    of standard callbacks that can be used by all the different loaders. These callbacks
    are used to inform you when a resource is loaded, when loading fails and, if available,
    the progress of the current request.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看本食谱中的步骤之前，您需要创建一些标准回调，这些回调可以被所有不同的加载器使用。这些回调用于通知您资源何时加载完成、加载失败，以及如果有的话，当前请求的进度。
- en: 'So for loading resources, we need to define three different callbacks:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于加载资源，我们需要定义三个不同的回调：
- en: 'The `onload` callback: Whenever a resource is loaded, this callback will be
    called with the loaded resource as an argument.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onload` 回调：每当资源加载完成时，此回调将带加载的资源作为参数被调用。'
- en: 'The `onprogress` callback: Some loaders provide progress during the loading
    of a resource. At specific intervals, this callback will be called to inform you
    how much of the resource has been loaded.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onprogress` 回调：一些加载器在加载资源时会提供进度信息。在特定的时间间隔内，此回调将被调用以通知您已加载了多少资源。'
- en: 'The `onerror` callback: If something goes wrong during the loading of the resource,
    this callback is used to inform you about the error that occurred.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onerror` 回调：如果在加载资源的过程中出现问题，此回调将用来通知您发生的错误。'
- en: For all the recipes dealing with asynchronous loading, we'll use the same set
    of loaders. These loaders just output some information to the console, but you
    can of course customize these callbacks for your specific use case.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有处理异步加载的食谱，我们将使用相同的加载器集。这些加载器只是向控制台输出一些信息，但当然，您可以根据特定的用例自定义这些回调。
- en: 'First, we define the `onLoadCallback` function, which is called when a resource
    is loaded:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义 `onLoadCallback` 函数，它在资源加载时被调用：
- en: '[PRE38]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see from the function definition, we just output the passed argument
    to the console. The other two callbacks, `onProgressCallback` and `onErrorCallback`,
    work exactly in the same manner as they are presented:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如从函数定义中可以看出，我们只是将传递的参数输出到控制台。其他两个回调，`onProgressCallback` 和 `onErrorCallback`，与它们所展示的方式完全相同：
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the following sections and recipes, we'll reference these callbacks when
    we use the Three.js provided functionality to load resources.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节和食谱中，当我们使用 Three.js 提供的功能来加载资源时，我们将引用这些回调。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To load a texture asynchronously, we use the `loadTexture` function from `THREE.ImageUtils`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要异步加载纹理，我们使用 `THREE.ImageUtils` 中的 `loadTexture` 函数：
- en: '[PRE40]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `loadTexture` function from `THREE.ImageUtils` takes the following four
    arguments:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`THREE.ImageUtils` 中的 `loadTexture` 函数接受以下四个参数：'
- en: The first one points to the location of the image you want to load
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数指向您想要加载的图像位置
- en: The second one can be used to provide a custom UV mapping (a UV mapping is used
    to determine which part of a texture to apply to a specific face)
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数可以用来提供自定义的 UV 映射（UV 映射用于确定将纹理的哪个部分应用到特定的面上）
- en: The third argument is the callback to be used when the textures have been loaded
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是纹理加载完成后要使用的回调
- en: The final argument is the callback to be used in case of an error
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数是在发生错误时要使用的回调
- en: '![How to do it...](img/1182OS_01_16.jpg)'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1182OS_01_16.jpg)'
- en: Note that the first console output also shows a valid texture object. Three.js
    does this, so you can immediately assign this object as a texture to a material.
    The actual image inside the texture, however, is only loaded after the `onLoadCallback`
    function is called.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，第一个控制台输出还显示了一个有效的纹理对象。Three.js 会这样做，因此您可以立即将此对象作为纹理分配给材质。然而，纹理内部的实际图像只有在
    `onLoadCallback` 函数被调用后才会加载。
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Three.js provides a nice wrapper to load textures. Internally, Three.js uses
    the standard way of loading resources from an `XMLHTTPRequest` web page With an
    `XMLHTTPRequest` web page, you can make an HTTP request for a specific resource
    and process the result. If you don't want to use the Three.js provided functionality,
    you can also implement an `XMLHTTPRequest` function yourself.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了一个很好的包装器来加载纹理。内部，Three.js 使用从 `XMLHTTPRequest` 网页加载资源的标准方式。使用 `XMLHTTPRequest`
    网页，你可以为特定资源发出 HTTP 请求并处理结果。如果你不想使用 Three.js 提供的功能，你也可以自己实现一个 `XMLHTTPRequest`
    函数。
- en: See also
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To run these examples and load resources asynchronously, we need to either run
    a web server locally, as explained in the *Setting up a local web server using
    Python* recipe or the *Setting up a web server using Node.js* recipe, or disable
    some security settings, as explained in the *Solving cross-origin-domain error
    messages in Chrome* recipe or the *Solving cross-origin-domain error messages
    in Firefox* recipe.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行这些示例并异步加载资源，我们需要运行一个本地 Web 服务器，如 *使用 Python 设置本地 Web 服务器* 食谱或 *使用 Node.js
    设置 Web 服务器* 食谱中所述，或者禁用一些安全设置，如 *解决 Chrome 中的跨源域错误消息* 食谱或 *解决 Firefox 中的跨源域错误消息*
    食谱中所述。
- en: Alternatively, if you don't want to load resources asynchronously, but wait
    for all the resources to load, before you initialize your scene you can look at
    the next *Waiting until resources are loaded* recipe.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，如果你不想异步加载资源，而是等待所有资源加载完毕后再初始化场景，你可以查看下一个 *等待资源加载完成* 食谱。
- en: Loading models asynchronously
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步加载模型
- en: In the *Loading textures asynchronously* recipe, we explained that Three.js
    offers helper functions to load different types of resources asynchronously. In
    this recipe, we'll look at how you can use the `THREE.JSONLoader` object to load
    models asynchronously.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *加载纹理异步* 食谱中，我们解释了 Three.js 提供了辅助函数来异步加载不同类型的资源。在这个食谱中，我们将探讨如何使用 `THREE.JSONLoader`
    对象异步加载模型。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you get started with this recipe, make sure that you've walked through
    the steps explained in the *Getting ready* section of the *Loading textures asynchronously*
    recipe. In the following section, we'll reference the JavaScript callbacks defined
    in the *Getting ready* section of that recipe.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始这个食谱之前，请确保你已经走过了在 *加载纹理异步* 食谱的 *准备就绪* 部分中解释的步骤。在下一节中，我们将参考该食谱 *准备就绪* 部分中定义的
    JavaScript 回调。
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Three.js also allows you to easily load external models. The following function
    shows you how to do this for the JSON models'' Three.js uses. The same, however,
    applies to any of the other model loaders:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Three.js 还允许你轻松地加载外部模型。以下函数展示了如何为 Three.js 使用的 JSON 模型执行此操作。然而，同样的方法也适用于任何其他模型加载器：
- en: '[PRE41]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `jsonLoader.load` function takes the following three arguments:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jsonLoader.load` 函数接受以下三个参数：'
- en: The first one is the location of the model you want to load
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是你要加载的模型的位置
- en: The second is the callback to call when the model is successfully loaded
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是当模型成功加载时调用的回调函数
- en: The final parameter is the one that we can specify the path from where the texture
    images should be loaded
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数是我们可以指定从哪里加载纹理图像的路径
- en: When we call this function, you'll see the following output on the console:![How
    to do it...](img/1182OS_01_17.jpg)
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们调用此函数时，你将在控制台看到以下输出：![如何操作...](img/1182OS_01_17.jpg)
- en: There is more...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With this approach, the `JSONLoader` object doesn't provide any feedback on
    how much it has loaded. If you want to load large models, it is nice to know something
    about the progress. The `JSONLoader` object also provides an alternative way of
    loading models that also provides progress. In the *Load model asynchronously
    with progress* recipe, we show you how to load a model and provide feedback on
    the progress. Besides the `THREE.JSONLoader` object, which loads Three.js' own
    proprietary models, Three.js is also shipped with a large number of loaders that
    you can use for other model formats. For an overview of what is provided by Three.js,
    please refer to [https://github.com/mrdoob/three.js/tree/master/examples/js/loaders](https://github.com/mrdoob/three.js/tree/master/examples/js/loaders).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，`JSONLoader` 对象不会提供任何关于它加载了多少的反馈。如果你想要加载大型模型，了解进度情况会很好。`JSONLoader` 对象还提供了一种加载模型的方法，该方法也提供了进度信息。在
    *异步加载模型并显示进度* 菜谱中，我们展示了如何加载模型并提供进度反馈。除了加载 Three.js 自有的专有模型外，Three.js 还附带了许多可以用于其他模型格式的加载器。有关
    Three.js 提供的内容概述，请参阅 [https://github.com/mrdoob/three.js/tree/master/examples/js/loaders](https://github.com/mrdoob/three.js/tree/master/examples/js/loaders)。
- en: Loading models asynchronously with progress
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步加载模型并显示进度
- en: In the previous section, the *Loading models asynchronously* recipe, we loaded
    a model asynchronously without providing feedback about the progress. In this
    recipe, we'll explain how you can add progress feedback to that scenario.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 *异步加载模型* 菜谱中，我们加载了一个模型，但没有提供进度反馈。在这个菜谱中，我们将解释如何向该场景添加进度反馈。
- en: Getting started
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始
- en: Before you get started with this recipe, make sure that you've walked through
    the steps explained in the *Getting ready* section of the *Loading textures asynchronously*
    recipe. In the following section, we'll reference the JavaScript callbacks defined
    in the *Getting ready* section of that recipe.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个菜谱之前，请确保你已经按照 *准备就绪* 部分中 *异步加载纹理* 菜谱中解释的步骤进行了操作。在接下来的部分中，我们将参考该菜谱 *准备就绪*
    部分中定义的 JavaScript 回调函数。
- en: How to do it...
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To load models and to also show progress, we have to use a different method
    apart from `THREE.JSONLoader`. If we use the `loadAjaxJSON` function, we can also
    specify a progress callback instead of just the load callback:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了加载模型并显示进度，我们必须使用除 `THREE.JSONLoader` 之外的其他方法。如果我们使用 `loadAjaxJSON` 函数，我们也可以指定一个进度回调而不是仅仅加载回调：
- en: '[PRE42]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we now load the same model as the previous one, we see the loading progress
    as follows:![How to do it...](img/1182OS_01_18.jpg)
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在加载与之前相同的模型，我们会看到以下加载进度：![如何操作...](img/1182OS_01_18.jpg)
- en: Loading other resources asynchronously with progress
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步加载其他资源并显示进度
- en: Besides loading specific resources, Three.js also provides a simple helper object
    to load any type of resource asynchronously. In this recipe, we'll explain how
    you can use the `THREE.XHRLoader` object to load any type of resource asynchronously.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加载特定资源外，Three.js 还提供了一个简单的辅助对象来异步加载任何类型的资源。在这个菜谱中，我们将解释如何使用 `THREE.XHRLoader`
    对象异步加载任何类型的资源。
- en: Getting ready
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before you get started with this recipe, make sure that you've walked through
    the steps explained in the *Getting ready* section of the *Loading textures asynchronously*
    recipe. In the following section, we'll reference the JavaScript callbacks defined
    in the *Getting ready* section of that recipe.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个菜谱之前，请确保你已经按照 *准备就绪* 部分中 *异步加载纹理* 菜谱中解释的步骤进行了操作。在接下来的部分中，我们将参考该菜谱 *准备就绪*
    部分中定义的 JavaScript 回调函数。
- en: How to do it...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The final resource loader we want to show in this recipe is the `THREE.XHRLoader`
    object. This loader allows you to load any resource that you might need in your
    Three.js scene:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们想要展示的最后一个资源加载器是 `THREE.XHRLoader` 对象。这个加载器允许你在 Three.js 场景中加载任何你可能需要的资源：
- en: '[PRE43]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The arguments for the `XHRLoader.load` function should look pretty familiar
    by now, as it's pretty much the same as for the other loaders. First, we pass
    the location of the resource we want to load, and then we specify the various
    callbacks. The output from this function looks like this:![How to do it...](img/1182OS_01_19.jpg)
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`XHRLoader.load` 函数的参数现在应该看起来很熟悉，因为它几乎与其他加载器相同。首先，我们传递我们想要加载的资源的位置，然后我们指定各种回调函数。这个函数的输出如下：![如何操作...](img/1182OS_01_19.jpg)'
- en: In the preceding screenshot, you can also see the progress while the resource
    is being loaded.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你还可以看到资源正在加载时的进度。
- en: Waiting until resources are loaded
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待资源加载
- en: In the *Load resources asynchronously* recipe, we showed how you can load external
    Three.js resources asynchronously. For many sites and visualization, loading resources
    asynchronously is a good approach. Sometimes, however, you want to make sure that
    all the resources you require in your scene have been loaded beforehand. For instance,
    when you're creating a game, you might want to load all the data for a specific
    level beforehand. A common method of loading resources synchronously is nesting
    the asynchronous callbacks we've seen in the previous recipe. This, however, quickly
    becomes unreadable and very hard to manage. In this recipe, we'll use a different
    approach and work with a JavaScript library called Q.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *异步加载资源* 的菜谱中，我们展示了如何异步加载外部 Three.js 资源。对于许多网站和可视化，异步加载资源是一种很好的方法。有时，您可能想要确保场景中所需的所有资源都已在之前加载。例如，当您创建游戏时，您可能希望在创建特定关卡之前加载所有数据。同步加载资源的一种常见方法是将之前菜谱中看到的异步回调嵌套。然而，这很快就会变得难以阅读，并且很难管理。在这个菜谱中，我们将使用不同的方法，并使用一个名为
    Q 的 JavaScript 库。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'As for all the external libraries that we use, we need to include the Q library
    in our HTML. You can download the latest version of this library from its GitHub
    repository at [https://github.com/kriskowal/q](https://github.com/kriskowal/q),
    or use the version provided in the `libs` folder in the sources for this book.
    To include this library in your HTML page, add the following in the `head` element
    of your HTML page:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们使用的所有外部库，我们需要在我们的 HTML 中包含 Q 库。您可以从其 GitHub 仓库 [https://github.com/kriskowal/q](https://github.com/kriskowal/q)
    下载此库的最新版本，或者使用本书源代码中的 `libs` 文件夹中提供的版本。要将此库包含到您的 HTML 页面中，请在您的 HTML 页面的 `head`
    元素中添加以下内容：
- en: '[PRE44]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the sources for this chapter, you can also find an example where we load
    resources synchronously. Open `01.12-wait-for-resources.html` in your browser
    and open the JavaScript console:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的源代码中，您还可以找到一个示例，展示了如何同步加载资源。在您的浏览器中打开 `01.12-wait-for-resources.html` 并打开
    JavaScript 控制台：
- en: '![Getting ready](img/1182OS_01_20.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_01_20.jpg)'
- en: On the console output, you'll see that the required resources and models are
    loaded one after another.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台输出中，您将看到所需资源和模型一个接一个地加载。
- en: How to do it...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s first take a look at what we''re aiming for in this recipe. We want
    to load resources synchronously, using the Q library, in the following manner:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先看看在这个菜谱中我们想要达到的目标。我们希望使用 Q 库同步加载资源，如下所示：
- en: '[PRE45]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'What this code fragment means is that:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码的含义是：
- en: Firstly, we want to call `loadModel(model)`.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要调用 `loadModel(model)`。
- en: Once the model is loaded, we load, using the `then` function, a texture using
    the `loadTexture(texture)` function. Once this texture is loaded, we will then
    load the next resource and so on. In this code fragment, you can also see that
    we also call a `catch` and a `progress` function. If an error occurs during loading,
    the function provided to `catch()` will be called. The same goes for `progress()`.
    If one of the methods wants to provide information about its progress, the function
    passed into `progress()` will be called.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型加载完成后，我们使用 `then` 函数和 `loadTexture(texture)` 函数加载一个纹理。一旦这个纹理加载完成，我们将加载下一个资源，依此类推。在这段代码片段中，您还可以看到我们调用了
    `catch` 和 `progress` 函数。如果在加载过程中发生错误，提供给 `catch()` 的函数将被调用。对于 `progress()` 也是如此。如果其中一个方法想要提供有关其进度的信息，传递给
    `progress()` 的函数将被调用。
- en: 'However, you will then find out that this won''t work with the functions from
    our previous recipe. To get this to work, we have to replace the callbacks from
    these functions with a special Q construct that is called a deferred function:'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，您会发现这不会与之前菜谱中的函数一起工作。为了使其正常工作，我们必须将这些函数的回调替换为 Q 构造函数中的一个特殊函数，称为延迟函数：
- en: '[PRE46]'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this code snippet, we create a new JavaScript object with the name `deferred`.
    The `deferred` object will make sure that the results of the callbacks, this time
    defined as anonymous functions, are returned in such a way that we can use the
    `then` function we saw at the beginning of this chapter. If the resource is loaded
    successfully, we use the `deferred.resolve` function to store the result; if the
    resource was loaded unsuccessfully, we store the error using the `deferred.reject`
    function.
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们创建了一个名为`deferred`的新JavaScript对象。`deferred`对象将确保回调的结果，这次定义为匿名函数，以这种方式返回，这样我们就可以使用我们在本章开头看到的`then`函数。如果资源加载成功，我们使用`deferred.resolve`函数来存储结果；如果资源加载失败，我们使用`deferred.reject`函数来存储错误。
- en: 'We use the same approach for the `loadModel`, `loadOthers`, and `loadModelWithProgress`
    functions:'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对`loadModel`、`loadOthers`和`loadModelWithProgress`函数也采用了相同的方法：
- en: '[PRE47]'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `loadOthers` function, we are also provided with the progress information.
    To make sure that the progress callback is handled correctly, we use the `deferred.notify()`
    function and pass in the `progress` object:'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loadOthers`函数中，我们也提供了进度信息。为了确保进度回调被正确处理，我们使用`deferred.notify()`函数并传入`progress`对象：
- en: '[PRE48]'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With these changes, we can now load the resources synchronously.
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些更改，我们现在可以同步地加载资源。
- en: How it works...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To understand how this works, you have to understand what Q does. Q is a promises
    library. With promises, you can replace the nested callbacks (also called the
    Pyramid of doom at [http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/](http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/))
    with simple steps. The following example for the Q site nicely shows what this
    accomplishes:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，你必须了解Q的作用。Q是一个承诺库。使用承诺，你可以用简单的步骤替换嵌套的回调（也称为[http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/](http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/)中的“末日金字塔”）。以下Q网站的示例很好地展示了这是如何实现的：
- en: '[PRE49]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Using promises, we can flatten this to the following (just like we did in this
    recipe):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺，我们可以将其简化为以下内容（就像我们在菜谱中做的那样）：
- en: '[PRE50]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If we were to rewrite the Three.js library, we could have used promises in Three.js
    internally, but since Three.js already uses callbacks, we had to use the `Q.defer()`
    function provided by Q to convert these callbacks to promises.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要重写Three.js库，我们可以在Three.js内部使用承诺，但由于Three.js已经使用了回调，我们不得不使用Q提供的`Q.defer()`函数将这些回调转换为承诺。
- en: There is more...
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We only touched a small part of what is possible with the Q promises library.
    We used it for synchronous loading, but Q has many other useful features. A very
    good starting point is the Q wiki available at [https://github.com/kriskowal/q/wiki](https://github.com/kriskowal/q/wiki).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只接触了Q承诺库可能实现的一小部分。我们用它来同步加载，但Q还有许多其他有用的功能。一个非常好的起点是可在[https://github.com/kriskowal/q/wiki](https://github.com/kriskowal/q/wiki)找到的Q维基百科。
- en: See also
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Just like every recipe that loads resources you have to make sure that you run
    it either with a local web server, see the *Setting up a local web server using
    Python* recipe or the *Setting up a web server using Node.js* recipe, or disable
    some security settings (see the *Solving cross-origin-domain error messages in
    Chrome* recipe or the *Solving cross-origin-domain error messages in Firefox*
    recipe). If you want to load resources asynchronously, you can take a look at
    the *Load any resource asynchronously* recipe.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像每个加载资源的菜谱一样，你必须确保你使用本地Web服务器运行它，参见*使用Python设置本地Web服务器*菜谱或*使用Node.js设置Web服务器*菜谱，或者禁用一些安全设置（参见*解决Chrome中的跨源域错误消息*菜谱或*解决Firefox中的跨源域错误消息*菜谱）。如果你想异步加载资源，你可以查看*异步加载任何资源*菜谱。
- en: Dragging a file from the desktop to the scene
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件从桌面拖动到场景中
- en: When you create visualizations, it is a nice feature to let your users provide
    their own resources. For instance, you might want to let the user specify their
    own textures or models. You can implement this with a traditional upload form,
    but with HTML5, you also have the option to let the user drag and drop a resource
    directly from the desktop. In this recipe, we'll explain how to provide this drag
    and drop functionality to your users.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建可视化时，允许你的用户提供他们自己的资源是一个很好的特性。例如，你可能想让用户指定他们自己的纹理或模型。你可以通过传统的上传表单来实现这一点，但使用HTML5，你也有选项让用户直接从桌面拖放资源。在这个菜谱中，我们将解释如何向用户提供这种拖放功能。
- en: Getting ready
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: The easiest way to prepare for this recipe is by first looking at the example
    we created for you. Open an example `01.14-drag-file-to-scene.html` in your browser.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 准备这个食谱的最简单方法是先查看我们为您创建的示例。在您的浏览器中打开示例`01.14-drag-file-to-scene.html`。
- en: Note
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that this only works when running your own web server, or with security
    exceptions disabled.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这仅在运行自己的Web服务器或禁用安全异常时才有效。
- en: '![Getting ready](img/1182OS_01_21.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_01_21.jpg)'
- en: When you drag and drop an image file onto the drop area (the dashed square),
    you'll immediately see that the texture of the rotating box is changed and the
    image that you provide is used.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将图像文件拖放到掉落区域（虚线方块）时，您会立即看到旋转盒子的纹理发生了变化，并且您提供的图像被使用。
- en: In the following section, we'll explain how you can create this functionality.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将解释如何创建此功能。
- en: How to do it...
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To do this, please carry out the following steps:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此操作，请执行以下步骤：
- en: 'First, we have to set up the correct CSS and define the drop area. To create
    the dashed drop area, we add the following CSS to the `style` element in the `head`
    element of our page:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须设置正确的CSS并定义掉落区域。要创建虚线掉落区域，我们将以下CSS添加到页面`head`元素中的`style`元素：
- en: '[PRE51]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see in this CSS, we style the HTML element with ID `holder` to have
    a dashed border. The HTML for the `holder div` element is shown next:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如您在这段CSS中看到的，我们使用ID为`holder`的HTML元素来设置虚线边框。下面展示了`holder div`元素的HTML代码：
- en: '[PRE52]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The drop area has been defined, so the next step is to add drag and drop the
    functionality to it.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 已经定义了掉落区域，所以下一步是向其添加拖放功能。
- en: Then, we have to assign the correct event handlers so that we can respond to
    the various drag and drop related events.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须分配正确的事件处理器，以便我们可以响应各种拖放相关事件。
- en: 'Just as in our previous recipes, we defined a function that contains all the
    required logic:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前的食谱一样，我们定义了一个包含所有必要逻辑的函数：
- en: '[PRE53]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this code fragment, we defined three event handlers. The `holder.ondragover`
    event handler sets the class on the div element to `'hover'`. This way, the user
    can see that they are allowed to drop the file there. The `holder.ondragend` event
    handler is called when the user moves away from the drop area. In the event handler,
    we remove the class of the `div` element. Finally, if the user drops a file in
    the designated area, the `holder.ondrop` function is called, which we use to process
    the dropped image.
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们定义了三个事件处理器。`holder.ondragover`事件处理器将div元素的类设置为`'hover'`。这样，用户就可以看到他们可以在此处掉落文件。`holder.ondragend`事件处理器在用户从掉落区域移开时被调用。在事件处理器中，我们移除`div`元素的类。最后，如果用户在指定区域掉落文件，将调用`holder.ondrop`函数，我们使用它来处理掉落的图像。
- en: 'The final step is to process the dropped resource and update the material of
    our box. When a user drops a file, the following piece of code is executed:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是处理掉落的资源并更新盒子的材质。当用户掉落一个文件时，以下代码块被执行：
- en: '[PRE54]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The first thing that happens is that we call `e.preventDefault()`. We need to
    do this to make sure that the browser doesn't just show the file, since that is
    its normal behavior. Next, we look at the event and retrieve the dropped file
    using `e.dataTransfer.files[0]`. We can't really do much with the file itself,
    since Three.js can't work directly with those, so we have to convert it to an
    `img` element. For this, we use a `FileReader` object. When the reader is done
    loading, we use the content to create this `img` element. This element is then
    used to create the `THREE.Texture` object, which we set as material for our box.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发生的第一件事是我们调用`e.preventDefault()`。我们需要这样做以确保浏览器不会仅仅显示文件，因为这是它的正常行为。接下来，我们查看事件并使用`e.dataTransfer.files[0]`检索掉落的文件。由于Three.js不能直接与这些文件工作，所以我们必须将其转换为`img`元素。为此，我们使用`FileReader`对象。当读取器加载完成后，我们使用内容来创建这个`img`元素。然后，这个元素被用来创建`THREE.Texture`对象，我们将它设置为盒子的材质。
- en: '![How to do it...](img/1182OS_01_22.jpg)'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1182OS_01_22.jpg)'
- en: How it works...
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Drag and drop functionality isn't something that is supported by Three.js out
    of the box. As we saw in the previous section, we use the standard HTML5 drag
    and drop related events. A good overview of what events are available can be found
    in the official HTML5 documentation at [http://www.w3.org/TR/html5/editing.html#drag-and-drop-processing-model](http://www.w3.org/TR/html5/editing.html#drag-and-drop-processing-model).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放功能不是Three.js默认支持的功能。正如我们在上一节中看到的，我们使用标准的HTML5拖放相关事件。关于可用的哪些事件的良好概述可以在官方HTML5文档中找到，网址为[http://www.w3.org/TR/html5/editing.html#drag-and-drop-processing-model](http://www.w3.org/TR/html5/editing.html#drag-and-drop-processing-model)。
- en: One interesting thing to note is the addition of `texture.needsUpdate = true`
    to the `ondrop` event handler. The reason we need to set this property of the
    texture is to inform Three.js that our texture has changed. This is needed because
    WebGL and also Three.js caches textures for performance reasons. If we change
    a texture, we have to set this property to `true` to make sure that WebGL knows
    what to render.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在`ondrop`事件处理程序中添加了`texture.needsUpdate = true`。我们需要设置纹理的此属性的原因是通知Three.js我们的纹理已更改。这是必需的，因为WebGL和Three.js出于性能原因都会缓存纹理。如果我们更改纹理，我们必须将此属性设置为`true`，以确保WebGL知道如何渲染。
