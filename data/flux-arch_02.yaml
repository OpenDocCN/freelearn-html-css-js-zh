- en: Chapter 2. Principles of Flux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. Flux原则
- en: In the previous chapter, you were introduced at a 10,000 foot level to some
    of the core Flux principles. For example, unidirectional data-flow is central
    to Flux's existence. The aim of this chapter is to go beyond the simplistic view
    of Flux principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你以10,000英尺的高度了解了Flux的一些核心原则。例如，单向数据流是Flux存在的基础。本章的目标是超越对Flux原则的简单看法。
- en: We'll kick things off with a bit of an MVC retrospective—to identify where it
    falls apart when we're trying to scale a frontend architecture. Following this,
    we'll take a deeper look at at unidirectional data-flow and how it solves some
    of the scaling issues we've identified in MVC architectures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一点MVC回顾开始，以确定当我们试图扩展前端架构时，它在哪里失败了。在此之后，我们将更深入地探讨单向数据流以及它是如何解决我们在MVC架构中确定的一些扩展问题的。
- en: Next, we'll address some high-level compositional issues faced by Flux architectures,
    such as making everything explicit and favoring layers over deep hierarchies.
    Finally, we'll compare the various kinds of state found in a Flux architecture
    and introduce the concept of an update round.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解决Flux架构面临的一些高级组合问题，例如使一切变得明确，并优先考虑层而不是深层层次结构。最后，我们将比较Flux架构中发现的各类状态，并介绍更新轮的概念。
- en: Challenges with MV*
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MV* 的挑战
- en: MV* is the prevailing architectural pattern of frontend JavaScript applications.
    We're referring to this as MV* because there's a number of accepted variations
    on the pattern, each of which have models and views as core concepts. For our
    discussions in this book, they can all be considered the same style of JavaScript
    architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: MV* 是前端JavaScript应用程序的流行架构模式。我们称之为MV*，因为存在许多被接受的模式变体，每个变体都以模型和视图为核心概念。在我们的讨论中，它们都可以被视为同一种JavaScript架构风格。
- en: MV* didn't gain traction in the development community because it's a terrible
    set of patterns. No, MV* is popular because it works. Although Flux can be thought
    of as a sort of MV* replacement, there's no need to go out and tear apart a working
    application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: MV* 并不是因为它是一套糟糕的模式而在开发社区中获得了影响力。不，MV*之所以受欢迎，是因为它有效。尽管Flux可以被视为一种MV*的替代品，但无需去拆解一个正在运行的应用程序。
- en: There's no such thing as a perfect architecture, and Flux is by no means immune
    to this fact. The goal of this section isn't to downplay MV* and all the things
    it does well, but rather to look at some of the MV* weaknesses and see how Flux
    steps in and improves the situation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何一种架构是完美的，Flux也不例外。本节的目标不是贬低MV*及其做得好的所有事情，而是要看看MV*的一些弱点，以及Flux是如何介入并改善情况的。
- en: Separation of concerns
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离
- en: One thing MV* is really good at is establishing a clear separation of concerns.
    That is, a component has one responsibility, while another component is responsible
    for something else, and so on, all throughout the architecture. Complementary
    to the *separation of concerns* principle is the *single responsibility* principle,
    which enforces a clear separation of concerns.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: MV* 真正擅长的一件事是建立清晰的关注点分离。也就是说，一个组件有一个责任，而另一个组件负责其他事情，如此类推，贯穿整个架构。与“关注点分离”原则相辅相成的是“单一责任”原则，它强制执行清晰的关注点分离。
- en: Why do we care though? The simple answer is that when we separate responsibilities
    into different components, different parts of the system are naturally decoupled
    from one another. This means that we can change one thing without necessarily
    impacting the other. This is a desired trait of any software system, regardless
    of the architecture. But, is this really what we get with MV*, and is this actually
    something we should shoot for?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要关心这个问题呢？简单的答案是，当我们把责任分解成不同的组件时，系统的不同部分自然会相互解耦。这意味着我们可以改变一件事，而不必必然影响另一件事。这是任何软件系统都希望拥有的特性，无论其架构如何。但是，我们真的通过MV*得到了这些，这真的是我们应该追求的目标吗？
- en: 'For example, maybe there''s no clear advantage in dividing a feature into five
    distinct responsibilities. Maybe the decoupling of the feature''s behavior doesn''t
    actually achieve anything because we would have to touch all five components every
    time we want to change something anyway. So rather than help us craft a robust
    architecture, the separation of concerns principle has amounted to nothing more
    than needles indirection that hampers productivity. Here''s an example of a feature
    that''s broken down into several pieces of focused responsibility:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将一个特性划分为五个不同的职责可能并没有明显的优势。也许特性行为的解耦实际上并没有达到任何效果，因为我们每次想要更改任何东西时，都必须触及这五个组件。因此，关注点分离原则并没有帮助我们构建一个健壮的架构，反而变成了阻碍生产力的间接手段。以下是一个将特性分解为几个具有聚焦职责的部分的例子：
- en: '![Separation of concerns](img/B05419_02_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![关注点分离](img/B05419_02_01.jpg)'
- en: 'Anytime a developer needs to pull apart a feature so that they can understand
    how it works, they end up spending more time jumping between source code files.
    The feature feels fragmented, and there''s no obvious advantage to structuring
    the code like this. Here''s a look at the moving parts that make up a feature
    in a Flux architecture:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何需要拆分特性以理解其工作方式的开发者，最终都会花费更多的时间在源代码文件之间跳转。特性感觉是碎片化的，这种代码结构并没有明显的优势。以下是Flux架构中构成特性的各个运动部件的观察：
- en: '![Separation of concerns](img/B05419_02_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![关注点分离](img/B05419_02_02.jpg)'
- en: The Flux feature decomposition leaves us with a feeling of predictability. We've
    left out the potential ways in which the view itself could be decomposed, but
    that's because the views are outside Flux. All we care about in terms of our Flux
    architecture is that the correct information is always passed to our views when
    state changes occur.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Flux特性分解让我们有一种可预测的感觉。我们排除了视图本身可能被分解的潜在方式，但这是因为视图位于Flux之外。就我们的Flux架构而言，我们关心的是当状态发生变化时，始终将正确的信息传递给我们的视图。
- en: You'll note that the logic and state of a given Flux feature are tightly coupled
    with one another. This is in contrast to MV*, where we want application logic
    to be a standalone entity that can operate on any data. The opposite is true with
    Flux, where we'll find the logic responsible for change state in close proximity
    to that state. This is an intentional design trait, with the implication being
    that we don't need to get carried away with separating concerns from one another,
    and that this activity can sometimes hurt rather than help.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，给定Flux特性的逻辑和状态紧密耦合在一起。这与MV*不同，在MV*中，我们希望应用逻辑是一个独立的实体，可以在任何数据上操作。而在Flux中，情况正好相反，我们会发现负责改变状态的逻辑与该状态紧密相邻。这是一个有意的设计特性，其含义是我们不需要过分追求关注点之间的分离，而且这种活动有时可能会适得其反。
- en: As we'll see in the coming chapters, this tight coupling of data and logic is
    characteristic of Flux stores. The preceding diagram shows that with complex features,
    it's much easier to add more logic and more state, because they're always near
    the surface of the feature, rather than buried in a nested tree of components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在接下来的章节中看到的那样，这种数据和逻辑的紧密耦合是Flux存储的特征。前面的图示表明，对于复杂特性，添加更多逻辑和状态要容易得多，因为它们总是位于特性的表面，而不是隐藏在组件的嵌套树中。
- en: Cascading updates
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 级联更新
- en: 'It''s nice when we have a software component that *just works*. This could
    mean any number of things, but it''s meaning is usually centered around automatically
    handling things for us. For instance, instead of manually having to invoke this
    method, followed by that method, and so on, everything is handled by the component
    for us. Let''s take a look at the following illustration:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个“只需工作”的软件组件时，这感觉很好。这可能意味着许多事情，但通常它的意义是围绕自动为我们处理事情。例如，我们不需要手动调用这个方法，然后是那个方法，等等，所有的事情都由组件为我们处理。让我们看看以下插图：
- en: '![Cascading updates](img/B05419_02_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![级联更新](img/B05419_02_03.jpg)'
- en: When we pass input into a larger component, we can expect that it will do the
    right thing automatically for us. What's compelling about these types of components
    is that it means less code for us to maintain. After all, the component knows
    how to update itself by orchestrating the communication between any subcomponents.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将输入传递给一个更大的组件时，我们可以期望它会自动为我们做正确的事情。这些类型组件的吸引力在于，这意味着我们需要维护的代码更少。毕竟，组件知道如何通过协调任何子组件之间的通信来自动更新自己。
- en: This is where the cascading effect begins. We tell one component to perform
    some behavior. This, in turn, causes another component to react. We give it some
    input, which causes another component to react, and so on. Soon, it's very difficult
    to comprehend what's going on in our code. This is because the things that are
    *taken care of* for us are hidden from view. Intentional by design, with unintended
    consequences.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是级联效应开始的地方。我们告诉一个组件执行某些行为。这反过来又导致另一个组件做出反应。我们给它一些输入，这又导致另一个组件做出反应，以此类推。很快，就很难理解我们代码中的情况了。这是因为为我们“处理”的事情被隐藏了起来。这是有意为之的设计，但产生了意想不到的后果。
- en: 'The previous diagram isn''t too bad. Sure, it might get a little difficult
    to follow depending on how many subcomponents get added to the larger component,
    but in general, it''s a tractable problem. Let''s look at a variation of this
    diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图表并不太糟糕。当然，如果添加到较大组件中的子组件数量较多，可能会稍微难以理解，但总的来说，这是一个可处理的问题。让我们看看这个图表的一个变体：
- en: '![Cascading updates](img/B05419_02_04.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![级联更新](img/B05419_02_04.jpg)'
- en: What just happened? Three more boxes and four more lines just happened, resulting
    in an explosion of cascading update complexity. The problem is no longer tractable
    because we simply cannot handle this type of complexity, and most MV* applications
    that rely on this type of automatic updating have way more than six components.
    The best we can hope for is that once it works the way we want it to, it keeps
    working.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才发生了什么？又增加了三个框和四条线，导致级联更新复杂性的爆炸式增长。问题不再可处理，因为我们根本无法处理这种类型的复杂性，并且大多数依赖这种类型自动更新的MV*应用程序有超过六个组件。我们所能期望的最好的结果就是，一旦它按照我们想要的方式工作，它就会继续工作。
- en: This is the naive assumption that we make about automatically updating components—this
    is something we want to encapsulate. The problem is that this generally isn't
    true, at least not if we ever plan to maintain the software. Flux sidesteps the
    problem of cascading updates because only a store can change it's own state, and
    this is always in response to an action.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对自动更新组件做出的天真假设——这是我们想要封装的东西。问题是这通常并不成立，至少如果我们打算维护软件的话。Flux通过只有存储可以改变其自身状态，并且这种改变总是对动作的反应来规避级联更新的问题。
- en: Model update responsibilities
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型更新责任
- en: 'In an MV* architecture, state is stored within models. To initialize model
    state, we could fetch data from the backend API. This is clear enough: we create
    a new model, then tell that model to go fetch some data. However, MV* doesn''t
    say anything about who is responsible for updating these models. One might think
    it''s the controller component that should have total control over the model,
    but does this ever happen in practice?'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在MV*架构中，状态存储在模型中。为了初始化模型状态，我们可以从后端API获取数据。这已经很清晰了：我们创建一个新的模型，然后告诉该模型去获取一些数据。然而，MV*并没有说明谁负责更新这些模型。有人可能会认为控制器组件应该完全控制模型，但在实践中这真的会发生吗？
- en: 'For example, what happens in view event handlers, called in response to user
    interactivity? If we only allow controllers to update the state of our models,
    then the view event handler functions should talk directly to the controller in
    question. The following diagram is a visualization of a controller changing the
    state of models in different ways:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在响应用户交互而调用的视图事件处理器中会发生什么？如果我们只允许控制器更新我们模型的状态，那么视图事件处理器函数应该直接与相关的控制器通信。以下图表是控制器以不同方式更改模型状态的可视化：
- en: '![Model update responsibilities](img/B05419_02_05.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![模型更新责任](img/B05419_02_05.jpg)'
- en: At first glance, this controller setup makes perfect sense. It acts as a wrapper
    around the models that store state. It's a safe assumption the anything that wants
    to mutate any of these models needs to go through the controller. That's its responsibility
    after all—to control things. Data that comes from the API, events triggered by
    the user and handled by the view, and other models—these all need to talk to the
    controller if they want to change the state of the models.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这种控制器设置似乎非常合理。它作为存储状态的模型的包装器。假设任何想要修改这些模型中的任何模型的东西都需要通过控制器进行。毕竟，这是它的责任——控制事物。来自API的数据、由用户触发并由视图处理的事件，以及其他模型——所有这些都需要与控制器通信，如果它们想要改变模型的状态。
- en: As our controller grows, making sure that model state changes are handled by
    the controller will produce more and more methods that change the model state.
    If we step back and look at all of these methods as they accumulate, we'll start
    to notice a lot of needless indirection. What do we stand to gain by proxying
    these state changes?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的控制器增长，确保模型状态更改由控制器处理将产生越来越多的更改模型状态的方法。如果我们退后一步，看看这些方法如何累积，我们会开始注意到很多不必要的间接。通过代理这些状态更改，我们能够获得什么？
- en: Another reason the controller is a dead-end for trying to establish consistent
    state changes in MV* is the changes that models can make to themselves. For example,
    setting one property in a model could end up changing other model properties as
    a side-effect. Worse, our models could have listeners that respond to state changes,
    somewhere else in the system (the cascading updates problem).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是，控制器在尝试在 MV* 中建立一致的状态更改时是一个死胡同，因为模型可以对自己进行更改。例如，设置模型中的一个属性可能会作为副作用更改其他模型属性。更糟糕的是，我们的模型可能有监听器，它们会响应系统其他地方（级联更新问题）的状态更改。
- en: Flux stores deal with the cascading updates problem by only allowing state changes
    via actions. This same mechanism solves the MV* challenges discussed here; we
    don't have to worry about views or other stores directly changing the state of
    our store.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 存储通过仅允许通过操作进行状态更改来解决级联更新问题。这个相同的机制解决了这里讨论的 MV* 挑战；我们不必担心视图或其他存储直接更改我们存储的状态。
- en: Unidirectional data
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单向数据
- en: A cornerstone of any Flux architecture is unidirectional data-flow. The idea
    being data flows from point A to point B, or from point A to B to C, or from point
    A to C. It's the direction that's important with unidirectional data-flow, and
    to a lesser extent, the ordering. So when we say that our architecture uses a
    unidirectional data-flow, we can say that data never flows from point B to point
    A. This is an important property of Flux architectures.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Flux 架构的基石是单向数据流。其想法是数据从点 A 流向点 B，或者从点 A 流向 B 再流向 C，或者从点 A 流向 C。在单向数据流中，重要的是方向，其次是顺序。因此，当我们说我们的架构使用单向数据流时，我们可以这样说：数据永远不会从点
    B 流向点 A。这是 Flux 架构的一个重要特性。
- en: As we saw in the previous section, MV* architectures have no discernible direction
    with their data-flows. In this section, we'll talk though some of the properties
    that make a unidirectional data-flow worth implementing. We'll begin with a look
    at the starting points and completion points of our data-flows, and then we'll
    think about how side-effects can be avoided when data flows in one direction.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，MV* 架构的数据流没有明显的方向。在本节中，我们将讨论一些使单向数据流值得实施的特征。我们将从查看数据流的起点和终点开始，然后考虑如何避免数据单向流动时的副作用。
- en: From start to finish
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从开始到结束
- en: 'If data-flows in only one direction, there has to be both a starting point
    and a finish point. In other words, we can''t just have an endless stream of data,
    which arbitrarily affects the various components the data-flows through. When
    data-flows are unidirectional with clearly defined start and finish points, there''s
    no way we can have circular flows. Instead, we have one big data-flow cycle in
    Flux, as visualized here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据流仅在一个方向上，必须有起点和终点。换句话说，我们不能只有一个无限的数据流，它任意地影响数据流通过的各种组件。当数据流具有明确定义的起点和终点时，我们不可能有循环流。相反，在
    Flux 中，我们有一个大的数据流循环，如图所示：
- en: '![From start to finish](img/B05419_02_06.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![从开始到结束](img/B05419_02_06.jpg)'
- en: This is obviously an over-simplification of any Flux architecture, but it does
    serve to illustrate the start and finish points of any given data-flow. What we're
    looking at is called an **update round**. A round is atomic in the sense that
    it's run-to-completion—there's no way to stop an update round from completing
    (unless an exception is thrown).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是对任何 Flux 架构的过度简化，但它确实有助于说明任何给定数据流的起点和终点。我们所观察到的被称为**更新轮次**。一轮是原子的，意味着它运行到完成——无法停止更新轮次以完成（除非抛出异常）。
- en: JavaScript is a run-to-completion language, meaning that once a block of code
    starts running, it's going to finish. This is good because it means that once
    we start updating the UI, there's no way a callback function can interrupt our
    update. The exception to this is when our own code interrupts the updating process.
    For example, our store logic that's meant to mutate the state of the store dispatches
    an action. This would be bad news for our Flux architecture because it would violate
    the unidirectional data-flow. To prevent this, the dispatcher can actually detect
    when a dispatch takes place inside of an update round. We'll have more on this
    in later chapters.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种运行到完成的语言，这意味着一旦代码块开始运行，它就会完成。这是好事，因为它意味着一旦我们开始更新 UI，回调函数就无法中断我们的更新。例外情况是当我们的代码中断更新过程时。例如，我们打算修改存储状态的存储逻辑分发了动作。这对我们的
    Flux 架构来说是个坏消息，因为它会违反单向数据流。为了防止这种情况，调度器实际上可以检测到在更新轮次内部发生分发。我们将在后面的章节中了解更多关于这一点。
- en: 'Update rounds are responsible for updating the state of the entire application,
    not just the parts that have subscribed to a particular type of action. This means
    that as our application grows, so do our update rounds. Since an update round
    touches every store, it may start to feel as though the data is flowing sideways
    through all of our stores. Here''s an illustration of the idea:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更新轮次负责更新整个应用程序的状态，而不仅仅是订阅了特定类型动作的部分。这意味着随着我们的应用程序增长，我们的更新轮次也在增长。由于更新轮次会触及每个存储，可能会开始感觉数据似乎正通过我们所有的存储横向流动。以下是这个想法的说明：
- en: '![From start to finish](img/B05419_02_07.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![从头到尾](img/B05419_02_07.jpg)'
- en: From the perspective of unidirectional data-flow, it doesn't actually matter
    how many stores there are. The important thing to remember is that the updates
    will not be interrupted by other actions being dispatched.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从单向数据流的角度来看，实际上并不重要有多少个存储。重要的是要记住，更新不会被其他正在分发的动作所中断。
- en: No side-effects
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无副作用
- en: As we saw with MV* architectures, the nice thing about automatic state changes
    is also their demise. When we program by hidden rules, we're essentially programming
    by stitching together a bunch of side-effects. This doesn't scale well, mainly
    due to the fact that it's impossible to hold all these hidden connections in our
    head at a given point in time. Flux likes to avoid side-effects wherever possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 MV* 架构中看到的那样，自动状态变化的优点也是其终结之处。当我们通过隐藏规则编程时，本质上是在通过拼接一系列副作用来编程。这并不容易扩展，主要是因为在某个特定时间点，我们不可能在脑海中保留所有这些隐藏的连接。Flux
    喜欢尽可能避免副作用。
- en: 'Let''s think about stores for a moment. These are the arbiters of state in
    our application. When something changes state, it has the potential to cause another
    piece of code to run in response. This does indeed happen in Flux. When a store
    changes state, views may be notified about the change, if they''ve subscribed
    to the store. This is the only place where side-effects happen in Flux, which
    is inevitable since we do need to update the DOM at some point when state changes.
    But what''s different about Flux is how it avoids side-effects when there''s data
    dependencies involved. The typical approach to dealing with data dependencies
    in user interfaces is to notify the dependent model that something has happened.
    Think cascading updates, as illustrated here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时考虑一下存储。这些是我们应用程序状态的主宰。当某个东西的状态发生变化时，它有可能导致另一段代码作为响应而运行。这确实在 Flux 中发生了。当一个存储改变状态时，如果它们已经订阅了存储，视图可能会被通知变化。这是
    Flux 中发生副作用的唯一地方，这是不可避免的，因为我们在状态变化时确实需要更新 DOM。但 Flux 与之不同之处在于，当涉及数据依赖时，它如何避免副作用。处理用户界面中数据依赖的典型方法是通过通知依赖模型发生了某些事情。想想级联更新，如下所示：
- en: '![No side-effects](img/B05419_02_08.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![无副作用](img/B05419_02_08.jpg)'
- en: When there's a dependency between two stores in Flux, we just need to declare
    this dependency in the dependent store. What this does is it tells the dispatcher
    to make sure that the store we depend on is always updated first. Then, the dependent
    store can just directly use the store data it depends on. This way, all of the
    updates can still take place within the same update round.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Flux 中两个存储之间存在依赖关系时，我们只需要在依赖存储中声明这个依赖关系。这样做是告诉调度器确保我们依赖的存储始终是最先更新的。然后，依赖存储可以直接使用它所依赖的存储数据。这样，所有的更新仍然可以在同一个更新轮次内进行。
- en: Explicit over implicit
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式优于隐式
- en: With architectural patterns, the tendency is to make things easier by veiling
    them behind abstractions that grow more elaborate with time. Eventually, more
    and more of the system's data changes automatically and developer convenience
    is superseded by hidden complexity.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构模式中，趋势是通过随着时间的推移变得越来越复杂的抽象来简化事物。最终，系统中的更多数据会自动更改，开发者的便利性被隐藏的复杂性所取代。
- en: This is a real scalability issue, and Flux handles it by favoring explicit actions
    and data transformations over implicit abstractions. In this section, we'll explore
    the benefits of explicitness along with the trade-offs to be made.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个真正的可扩展性问题，Flux通过优先考虑显式动作和数据转换而不是隐式抽象来处理它。在本节中，我们将探讨显式性的好处以及需要做出的权衡。
- en: Updates via hidden side-effects
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过隐藏的副作用进行更新
- en: 'We''ve seen already, in this chapter, how difficult it can be to deal with
    hidden state changes that hide behind abstractions. They help us avoid writing
    code, but they also hurt by making it difficult to comprehend an entire work-flow
    when we come back and look at the code later. With Flux, state is kept in a store,
    and the store is responsible for changing its own state. What''s nice about this
    is that when we want to inquire about how a given store changes state, all the
    state transformation code is there, in one place. Let''s look at an example store:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经看到，处理隐藏在抽象背后的状态变化有多么困难。它们帮助我们避免编写代码，但同时也使得在稍后回顾代码时理解整个工作流程变得困难。在Flux中，状态被保存在存储中，存储负责改变自己的状态。这很好，因为当我们想要了解某个存储如何改变状态时，所有的状态转换代码都集中在一个地方。让我们看看一个示例存储：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have a store with a simple `state` object. In the constructor, the
    store registers a callback function with the `dispatcher`. All state transformations
    take place, explicitly, in one function. This is where data turns into information
    for our user interface. We don't have to hunt down the little bits and pieces
    of data as they change state across multiple components; this doesn't happen in
    Flux.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含简单`state`对象的存储。在构造函数中，存储向`dispatcher`注册了一个回调函数。所有状态转换都明确地在一个函数中发生。这就是数据变成用户界面信息的地方。我们不必在多个组件中寻找数据的小片段，因为它们的状态发生变化时，这种情况不会在Flux中发生。
- en: So the question now becomes, how do views make use of this monolithic state
    data? In other types of frontend architecture, the views get notified whenever
    any piece of state changes. In the preceding example, a view gets notified when
    the `clickable` property changes, and again when the `display` property changes.
    The view has logic to render these two changes independently of one another. However,
    views in Flux don't get fine-grained updates like these. Instead, they're notified
    when the store state changes and the state data is what's given to them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在的问题变成了，视图如何利用这种单一的状态数据？在其他类型的客户端架构中，视图会在任何状态发生变化时收到通知。在前面的例子中，当`clickable`属性发生变化时，视图会收到通知，同样，当`display`属性发生变化时，视图也会收到通知。视图有逻辑来独立渲染这两个变化。然而，在Flux中，视图不会收到这样精细的更新。相反，它们会在存储状态变化时收到通知，并且状态数据就是提供给它们的内容。
- en: The implication here is that we should lean toward view technology that's good
    at re-rendering whole components. This is what makes React a good fit for Flux
    architectures. Nonetheless, we're free to use any view technology we please, as
    we'll see later on in the book.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的含义是，我们应该倾向于使用擅长重新渲染整个组件的视图技术。这正是React适合Flux架构的原因。尽管如此，我们仍然可以自由地使用我们喜欢的任何视图技术，正如我们将在本书后面的内容中看到的。
- en: Data changes state in one place
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据状态在一个地方发生变化
- en: As we saw in the preceding section, the store transformation code is encapsulated
    within the store. This is intentional. The transformation code that mutates a
    store's state is supposed to live nearby. Close proximity drastically reduces
    the complexity of figuring out where state changes happen as systems grow more
    complex. This makes state changes explicit, instead of abstract and implicit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，存储转换代码被封装在存储中。这是故意的。那些改变存储状态的转换代码应该靠近存储。这种紧密的邻近性大大减少了随着系统变得更加复杂时确定状态变化发生位置的复杂性。这使得状态变化变得明确，而不是抽象和隐含的。
- en: One potential trade-off with having a store manage all of the state transformation
    code is that there could be a lot of it. The code we looked at used a single `switch`
    statement to handle all of the state transform logic. This would obviously cause
    a bit of a headache later on when there's a lot of cases to handle. We'll think
    about this more later in the book, when the time comes to consider large, complex
    stores. Just know that we can re-factor our stores to elegantly handle a large
    number of cases, while keeping the coupling of business logic and state tight.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 存储器管理所有状态转换代码的一个潜在权衡是可能会有很多这样的代码。我们之前看到的代码使用单个`switch`语句来处理所有的状态转换逻辑。这显然会在以后处理大量情况时引起一些头痛。我们将在本书稍后更详细地考虑这一点，当考虑大型、复杂的存储器时。只需知道我们可以重构我们的存储器，以优雅地处理大量情况，同时保持业务逻辑和状态的耦合紧密。
- en: This leads us right back to the separation of concerns principle. With Flux
    stores, the data and the logic that operates on it isn't separated at all. Is
    this actually a bad thing though? An action is dispatched, a store is notified
    about it, and it changes its state (or does nothing, ignoring the action). The
    logic that changes the state is located in the same component because there's
    nothing to gain by moving it somewhere else.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接把我们带回到了关注点分离原则。在Flux存储器中，数据和操作它的逻辑完全没有分离。但这实际上是不是一件坏事呢？一个行动被派发，存储器被通知此事，并改变其状态（或者什么都不做，忽略该行动）。改变状态的逻辑位于同一组件中，因为将其移动到其他地方没有任何好处。
- en: Too many actions?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行动太多？
- en: Actions make everything that happens in a Flux architecture explicit. By everything,
    I mean everything—if it happens, it was the result of an action being dispatched.
    This is good because it's easy to figure out where actions are dispatched from.
    Even as the system grows, action dispatches are easy to find in our code, because
    they can only come from a handful of places. For example, we won't find actions
    being dispatched within stores.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 行动使Flux架构中发生的所有事情都变得明确。通过“所有事情”，我的意思是所有事情——如果发生了，那一定是某个行动被派发的结果。这是好事，因为很容易找出行动是从哪里派发的。即使系统在增长，行动派发在我们的代码中也很容易找到，因为它们只能来自少数几个地方。例如，我们不会在存储器中找到正在派发的行动。
- en: Any feature we create has the potential to create dozens of actions, if not
    more. We tend to think that more means bad, from an architectural perspective.
    If there's more of something, it's going to be more difficult to scale and to
    program with. There's some truth to this, but if we're going to have a lot of
    something, which is unavoidable in any large system, it's good that it's actions.
    Actions are relatively lightweight in that they describe something that happens
    in our application. In other words, actions aren't heavyweight items that we need
    to fret over having a lot of.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的任何功能都有可能创建数十个甚至更多的行动。我们倾向于认为更多意味着不好，从架构的角度来看。如果某物越多，就越难进行扩展和编程。在这方面有一些真实性，但如果我们要有很多某物，这在任何大型系统中都是不可避免的，那么它是行动就很好。行动相对较轻，因为它们描述了在我们应用程序中发生的事情。换句话说，行动不是我们需要担心拥有很多的重型项目。
- en: Does having a lot of actions mean that we need to cram them all into one huge
    monolithic actions module? Thankfully, we don't have to do this. Just because
    actions are the entry point into any Flux system, doesn't mean that we can't modularize
    them to our liking. This is true of all the Flux components we develop, and we'll
    keep an eye open for ways that we can keep our code modular as we progress through
    the book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有许多行动是否意味着我们需要将它们全部塞入一个巨大的单体行动模块中？幸运的是，我们不必这样做。仅仅因为行动是进入任何Flux系统的入口点，并不意味着我们不能按我们的喜好对它们进行模块化。这对我们开发的Flux组件都适用，并且我们将保持警惕，寻找我们可以在阅读本书的过程中保持代码模块化的方法。
- en: Layers over hierarchies
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层次结构之上的层
- en: User interfaces are hierarchical in nature, partly because HTML is inherently
    hierarchical and partly because of the way that we structure the information presented
    to users. For example, this is why we have nested levels of navigation in some
    applications—we can't possibly fit everything on the screen at once. Naturally,
    our code starts to reflect this hierarchical structure by becoming a hierarchy
    itself. This is good in the sense that it reflects what the user sees. It's bad
    in the sense that deep hierarchies are difficult to comprehend.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面在本质上具有层次性，部分原因是因为HTML本身是层次化的，部分原因是因为我们构建用户所呈现信息的方式。例如，这就是为什么在一些应用程序中我们会有嵌套的导航层级——我们不可能一次性将所有内容都放在屏幕上。自然地，我们的代码开始反映这种层次结构，通过自身成为一个层次结构。这在某种程度上是好的，因为它反映了用户所看到的内容。但在另一方面，深层次的层次结构很难理解。
- en: In this section, we'll look at hierarchical structures in frontend architectures
    and how Flux is able to avoid complex hierarchies. We'll first cover the idea
    of having several top-level components, each with their own hierarchies. Then,
    we'll look at the side-effects that happen within hierarchies and how data-flows
    through Flux layers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨前端架构中的层次结构以及Flux如何避免复杂的层次结构。我们首先将介绍拥有多个顶级组件的概念，每个组件都有自己的层次结构。然后，我们将探讨在层次结构内部发生的副作用以及数据如何在Flux层中流动。
- en: Multiple component hierarchies
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个组件层次结构
- en: 'A given application probably has a handful of major features. These are often
    implemented as the top-level components or modules in our code. These aren''t
    monolithic components; they''re decomposed into smaller and smaller components.
    Perhaps some of these components share the smaller multipurpose components. For
    example, a top-level component hierarchy might be composed of models, views, and
    controllers as is illustrated here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定的应用程序可能只有几个主要功能。这些通常作为我们代码中的顶级组件或模块实现。这些不是单体组件；它们被分解成越来越小的组件。也许其中一些组件共享较小的多功能组件。例如，一个顶级组件层次结构可能由模型、视图和控制器组成，如图所示：
- en: '![Multiple component hierarchies](img/B05419_02_09.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![多个组件层次结构](img/B05419_02_09.jpg)'
- en: This makes sense in terms of the structure of our application. When we look
    at pictures of component hierarchies, it's easy to see what our application is
    made of. Each of these hierarchies, with the top-level component as their root,
    are like a little universes that exist independently of one anothers. Again, we're
    back to the notion of separation of concerns. We can develop one feature without
    impacting another.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们的应用程序结构中是有意义的。当我们查看组件层次结构的图片时，很容易看出我们的应用程序是由什么构成的。这些层次结构，以顶级组件为根，就像独立于彼此存在的小宇宙。再次，我们回到了关注点分离的概念。我们可以开发一个功能，而不会影响另一个。
- en: The problem with this approach is that user interface features often depend
    on other features. In other words, the state of one component hierarchy will likely
    depend on the state of another. How do we keep these two component trees synchronized
    with one another when there's no mechanism in place to control when state can
    change? What ends up happening is that a component in one hierarchy will introduce
    an arbitrary dependency to a component in another hierarchy. This serves a single
    purpose, so we have to keep introducing new inter-hierarchy dependencies to make
    sure everything is synchronized.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是用户界面功能通常依赖于其他功能。换句话说，一个组件层次结构的状态可能会依赖于另一个组件的状态。当没有机制来控制状态何时可以改变时，我们如何保持这两个组件树之间的同步？最终发生的情况是，一个层次结构中的组件将向另一个层次结构中的组件引入任意的依赖。这服务于单一目的，因此我们必须不断引入新的层次间依赖，以确保一切同步。
- en: Hierarchy depth and side-effects
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次深度和副作用
- en: One challenge with hierarchies is depth. That is, how far down will a given
    hierarchy extend? The features of our application are constantly changing and
    expanding in scope. This can lead to our component trees growing taller. But they
    also grow wider. For example, let's say that our feature uses a component hierarchy
    that's three levels deep.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构的一个挑战是深度。也就是说，一个特定的层次结构会延伸多深？我们应用程序的功能不断变化和扩展范围。这可能导致我们的组件树变得更高。但它们也变得更宽。例如，假设我们的功能使用的是一个三级深的组件层次结构。
- en: 'Then, we add a new level. Well, we''ll probably have to add several new components
    to this new level and in higher levels. So to build upon our hierarchies, we have
    to scale in multiple directions—horizontally and vertically. This idea is illustrated
    here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个新的层级。嗯，我们可能需要向这个新层级和更高层级添加几个新组件。因此，为了在层次结构上构建，我们必须在多个方向上进行扩展——水平和垂直。这个想法在这里得到了说明：
- en: '![Hierarchy depth and side-effects](img/B05419_02_10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![层次深度和副作用](img/B05419_02_10.jpg)'
- en: Scaling components in multiple directions is difficult, especially in component
    hierarchies where there's no data-flow direction. That is, input that ends up
    changing the state of something can enter the hierarchy at any level. Undoubtedly,
    this has some sort of side-effect, and if we're dependent on components in other
    hierarchies, all hope is lost.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个方向上扩展组件很困难，尤其是在没有数据流方向的组件层次结构中。也就是说，最终改变某个状态输入可以进入层次结构的任何级别。毫无疑问，这会有某种副作用，如果我们依赖于其他层次结构中的组件，所有的希望都破灭了。
- en: Data-flow and layers
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据流和层
- en: 'Flux has distinct architectural layers, which are more favorable to scaling
    architectures than hierarchies are. The reason is simple—we only need to scale
    components horizontally, within each layer of the architecture. We don''t need
    to add new components to a layer and add new layers. Let''s take a look at what
    scaling a Flux architecture looks like in the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Flux具有独特的架构层，这些层比层次结构更适合扩展架构。原因很简单——我们只需要在架构的每一层中水平扩展组件。我们不需要向一个层添加新组件，也不需要添加新层。让我们看看以下图中Flux架构扩展的样子：
- en: '![Data-flow and layers](img/B05419_02_11.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![数据流和层](img/B05419_02_11.jpg)'
- en: No matter how large an application gets, there's no need to add new architectural
    layers. We simply add new components to these layers. The reason we're able to
    do this without creating a tangled mess of component connections within a given
    layer is because all three layers play a part in the update round. An update round
    starts with an action and completes with the last view that is rendered. The data-flows
    through our application from layer to layer, in one direction.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 无论应用程序有多大，都不需要添加新的架构层。我们只需向这些层添加新组件。我们之所以能够这样做而不在给定层内创建组件连接的混乱，是因为这三个层都在更新轮次中发挥作用。更新轮次从动作开始，以渲染的最后一个视图结束。数据从层到层通过我们的应用程序单向流动。
- en: Application data and UI state
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序数据和UI状态
- en: When we have a separation of concerns that sticks presentation in one place
    and application data in another, we have two distinct places where we need to
    manage state. Except in Flux, the only place where there's state is within a store.
    In this section, we'll compare application data and UI data. We'll then address
    the transformations that ultimately lead to changes in the user interface. Lastly,
    we'll discuss the feature-centric nature of Flux stores.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有职责分离，将表示固定在一个地方，将应用程序数据放在另一个地方时，我们需要管理状态的两个不同的地方。但在Flux中，唯一有状态的地方是在存储中。在本节中，我们将比较应用程序数据和UI数据。然后，我们将讨论最终导致用户界面变化的转换。最后，我们将讨论Flux存储以功能为中心的特性。
- en: Two of the same thing
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两样相同的东西
- en: 'Quite often, application data that''s fetched from an API is fed into some
    kind of view layer. This is also known as the presentation layer, responsible
    for transforming application data into something of value for the user—from data
    to information in other words. In these layers, we end up with state to represent
    the UI elements. For example, is the checkbox checked? Here is an illustration
    of how we tend to group the two types of state within our components:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，从API获取的应用程序数据会被输入到某种视图层。这也被称为表示层，负责将应用程序数据转换为对用户有价值的东西——换句话说，从数据到信息。在这些层中，我们最终得到状态来表示UI元素。例如，复选框是否被勾选？以下是我们倾向于在我们组件内分组这两种状态的说明：
- en: '![Two of the same thing](img/B05419_02_12.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![两样相同的东西](img/B05419_02_12.jpg)'
- en: 'This doesn''t really fit well with Flux architectures, because stores are where
    state belongs, including the UI. So, can a store have both application and UI
    state within it? Well, there isn''t a strong argument against it. If everything
    that has a state is self-contained within a store, it should be fairly simple
    to discern between application data and state that belongs to UI elements. Here''s
    an illustration of the types of state found in Flux stores:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Flux 架构不太相符，因为存储是状态所在的地方，包括 UI。那么，存储能否同时包含应用和 UI 状态呢？好吧，对此并没有强烈的反对意见。如果所有具有状态的事物都包含在存储中，那么区分应用数据和属于
    UI 元素的状态应该相当简单。以下是在 Flux 存储中找到的状态类型的说明：
- en: '![Two of the same thing](img/B05419_02_13.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![同一事物的两个例子](img/B05419_02_13.jpg)'
- en: The fundamental misconception with trying to separate UI state from other state
    is that components often depend on UI state. Even UI components in different features
    can depend on each other's state in unpredictable ways. Flux acknowledges this
    and doesn't try to treat UI state as something special that should be split off
    from application data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 UI 状态与其他状态分开的基本误解在于，组件通常依赖于 UI 状态。即使是不同功能中的 UI 组件也可能以不可预测的方式相互依赖。Flux 认识到这一点，并不试图将
    UI 状态视为应该与应用数据分开的特殊事物。
- en: The UI state that ultimately ends up in a store can be derived from a number
    of things. Generally, two or more items from our application data could determine
    a UI state item. A UI state could be derived from another UI state, or from something
    more complex, like a UI state and other application data. In other cases, the
    application data is simple enough that it can be consumed directly by the view.
    The key is that the view has enough information that it can render itself without
    having to track its own state.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最终存储中结束的 UI 状态可以由许多因素推导而来。通常，我们应用数据中的两个或更多项可以确定一个 UI 状态项。一个 UI 状态可以由另一个 UI 状态推导而来，或者由更复杂的事物推导而来，例如
    UI 状态和其他应用数据。在其他情况下，应用数据足够简单，可以直接由视图消费。关键是视图拥有足够的信息，可以自行渲染而无需跟踪自己的状态。
- en: Tightly coupled transformations
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 紧密耦合的转换
- en: Application data and UI state are tightly coupled together in Flux stores. It
    only makes sense that the transformations that operate on this data be tightly
    coupled to the store as well. This makes it easy for us to change the state of
    the UI based on other application data or based on the state of other stores.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flux 存储中，应用数据和 UI 状态紧密耦合在一起。这个数据上操作的转换紧密耦合到存储中是有意义的。这使得我们可以根据其他应用数据或其他存储的状态轻松地更改
    UI 的状态。
- en: If our business logic code wasn't in the store, then we'd need to start introducing
    dependencies to the components containing the logic needed by the store. Sure,
    this would mean generic business logic that transforms the state, and this could
    be shared in several stores, but this seldom happens at a high level. Stores are
    better off keeping their business logic that transforms the state of the store
    tightly coupled. If we need to reduce repetitive code, we can introduce smaller,
    more fine-grained utility functions to help with data transformations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的业务逻辑代码不在存储中，那么我们就需要开始向包含存储所需逻辑的组件引入依赖。当然，这意味着通用的业务逻辑，它转换状态，并且可以在多个存储中共享，但这在高层次上很少发生。存储最好保持其转换存储状态的业务逻辑紧密耦合。如果我们需要减少重复代码，我们可以引入更小、更精细的实用函数来帮助数据转换。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can get generic with our stores as well. These stores are abstract and don't
    directly interface with views. We'll go into more detail on this advanced topic
    later in the book.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使我们的存储变得通用。这些存储是抽象的，并且不直接与视图接口。我们将在本书的后面部分更详细地介绍这个高级主题。
- en: Feature centric
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以功能为中心
- en: If the data transformations that change the state of a store are tightly coupled
    to the store itself, does this mean that the store is tailored for a specific
    feature? In other words, do we care about stores being reused for other features?
    Sure, in some cases we have generic data that doesn't make much sense in repeating
    several times across stores. But generally speaking, stores are feature specific.
    Features are synonymous with domains in Flux parlance—everyone divides up the
    capabilities of their UI in different ways.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果改变存储状态的数据转换与存储本身紧密耦合，这意味着存储是为特定功能定制的吗？换句话说，我们关心存储在其他功能中被重用吗？当然，在某些情况下，我们有通用数据，在多个存储中重复几次并没有太多意义。但一般来说，存储是针对特定功能的。在
    Flux 术语中，功能与域同义——每个人都会以不同的方式划分他们 UI 的功能。
- en: This is a departure from other architectures that base their data models on
    the data model of the API. Then, they use these models to create more specific
    view models. Any given MV* framework will have loads of features in their model
    abstractions, things like data bindings and automatic API fetching. They're only
    worried about storing state and publishing notifications when this state changes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他架构不同，这些架构基于API的数据模型构建其数据模型。然后，他们使用这些模型来创建更具体的视图模型。任何给定的MV*框架在其模型抽象中都会有大量的功能，比如数据绑定和自动API获取。他们只关心在状态改变时存储状态和发布通知。
- en: When stores encourage us to create and store new state that's specific to the
    UI, we can more easily design for the user. This is the fundamental difference
    between stores in Flux and models in other architectures—the UI data model comes
    first. The transformations within stores exist to ensure that the correct state
    is published to views—everything else is secondary.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当存储鼓励我们创建和存储特定于UI的新状态时，我们可以更容易地为用户设计。这是Flux中的存储与其他架构中的模型之间的基本区别——UI数据模型优先。存储内的转换存在是为了确保正确的状态被发布到视图中——其他一切都是次要的。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the driving principles of Flux. These should
    be in the back your mind as you work on any Flux architecture. We started the
    chapter off with a brief retrospective of MV* style architectures that permeate
    frontend development. Some challenges with this style of architecture include
    cascading model updates and a lack of data-flow direction. We then looked at the
    prize concept of Flux—unidirectional data-flow.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Flux的驱动原则。这些原则应在您处理任何Flux架构时牢记在心。我们以对前端开发中普遍存在的MV*风格架构的简要回顾开始本章。这种架构风格的一些挑战包括模型更新的级联和缺乏数据流方向。然后，我们探讨了Flux的奖赏概念——单向数据流。
- en: Next, we covered how Flux favors explicit actions over implicit abstractions.
    This makes things easier to comprehend when reading Flux code, because we don't
    have to go digging around for the root cause of a state change. We also looked
    at how Flux utilizes architectural layers to visualize how data-flows in one direction
    through the system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了Flux如何更倾向于显式动作而非隐式抽象。这使得阅读Flux代码时更容易理解，因为我们不必挖掘状态变化的原因。我们还探讨了Flux如何利用架构层来可视化数据在系统中的单向流动。
- en: Finally, we compared application data with state that's generally considered
    specific to UI elements. Flux stores tend to focus on state that's relevant to
    the feature it supports, and doesn't distinguish between application data and
    UI state. Now that we have a handle on the principles that drive Flux architectures,
    it's time for us to code one. In the next chapter, we'll implement our skeleton
    Flux architecture, allowing us to focus on information design.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们比较了应用数据与通常被认为是特定于UI元素的州。Flux存储通常关注与它所支持的功能相关的状态，并且不区分应用数据和UI状态。现在我们已经掌握了驱动Flux架构的原则，是时候我们来编写一个了。在下一章中，我们将实现我们的Flux架构骨架，这样我们可以专注于信息设计。
