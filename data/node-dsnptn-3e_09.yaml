- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Behavioral Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: In the last two chapters, we have learned patterns that aid us in the creation
    of objects and with building complex object structures. Now it's time to move
    onto another aspect of software design, which concerns the behavior of components.
    In this chapter, we will learn how to combine objects and how to define the way
    they communicate so that the behavior of the resulting structure becomes extensible,
    modular, reusable, and adaptable. Problems such as "How do I change parts of an
    algorithm at runtime?", "How can I change the behavior of an object based on its
    state?", and "How can I iterate over a collection without knowing its implementation?"
    are the typical kinds of problems solved by the patterns presented in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们学习了有助于我们创建对象和构建复杂对象结构的模式。现在，是时候转向软件设计的另一个方面了，这涉及到组件的行为。在本章中，我们将学习如何组合对象以及如何定义它们之间的通信方式，以便结果结构的行
    为变得可扩展、模块化、可重用和可适应。诸如“如何在运行时更改算法的部分？”、“我如何根据对象的状态改变其行为？”以及“我如何在不知道其实施的情况下遍历一个集合？”等问题是本章中展示的模式所解决的典型问题。
- en: You've already met a notable member of this category of patterns, and that is
    the Observer pattern, which we presented in *Chapter 3*, *Callbacks and Events*.
    The Observer pattern is one of the foundational patterns of the Node.js platform
    as it provides us with a simple interface for dealing with events and subscriptions,
    which are the life force of Node's event-driven architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经遇到了这个类别中一个显著的成员，那就是我们在*第3章*，*回调和事件*中介绍的观察者模式。观察者模式是Node.js平台的基础模式之一，因为它为我们提供了一个简单的接口来处理事件和订阅，这些是Node事件驱动架构的生命力。
- en: If you are already familiar with the **Gang of Four** (**GoF**) design patterns,
    in this chapter, you will witness once again how the implementation of some of
    those patterns can be radically different in JavaScript compared to a purer object-oriented
    approach. A great example of this thesis can be found in the Iterator pattern,
    which you will meet later in the chapter. To implement the Iterator pattern, in
    fact, we won't need to extend any class or build any complex hierarchy. Instead,
    we will just need to add a special method to a class. Moreover, one particular
    pattern in this chapter, Middleware, tightly resembles another popular GoF pattern,
    which is the Chain of Responsibility pattern, but its implementation in Node.js
    has become such a standard that it can be considered a pattern of its own.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉**四人帮**（**GoF**）设计模式，在本章中，你将再次见证这些模式在JavaScript中的实现与纯面向对象方法相比可能有多么根本的不同。这一论点的绝佳例子可以在你将在本章后面遇到的迭代器模式中找到。实际上，要实现迭代器模式，我们实际上不需要扩展任何类或构建任何复杂的层次结构。相反，我们只需要向一个类中添加一个特殊的方法。此外，本章中特别的一个模式，中间件，与另一个流行的GoF模式紧密相似，即责任链模式，但在Node.js中的实现已经变得如此标准化，以至于它可以被认为是一个独立的模式。
- en: 'Now, it''s time to roll up your sleeves and get your hands dirty with some
    behavioral design patterns. In this chapter, you will learn about the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候卷起袖子，动手实践一些行为设计模式了。在本章中，你将学习以下内容：
- en: The Strategy pattern, which helps us change parts of a component to adapt it
    to specific needs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式，它帮助我们改变组件的部分以适应特定的需求
- en: The State pattern, which allows us to change the behavior of a component based
    on its state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式，它允许我们根据组件的状态来改变其行为
- en: The Template pattern, which allows us to reuse the structure of a component
    to define new ones
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板模式，它允许我们重用组件的结构来定义新的组件
- en: The Iterator pattern, which provides us with a common interface to iterate over
    a collection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器模式，它为我们提供了一个遍历集合的通用接口
- en: The Middleware pattern, which allows us to define a modular chain of processing
    steps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件模式，它允许我们定义一个模块化的处理步骤链
- en: The Command pattern, which materializes the information required to execute
    a routine, allowing such information to be easily transferred, stored, and processed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式，它实现了执行例程所需的信息，使得此类信息可以轻松地传输、存储和处理
- en: Strategy
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略
- en: The **Strategy** pattern enables an object, called the **context**, to support
    variations in its logic by extracting the *variable* parts into separate, interchangeable
    objects called **strategies**. The context implements the common logic of a family
    of algorithms, while a strategy implements the mutable parts, allowing the context
    to adapt its behavior depending on different factors, such as an input value,
    a system configuration, or user preferences.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略模式**允许一个称为**上下文**的对象通过将*可变*部分提取到单独的可互换对象中（称为**策略**）来支持其逻辑的变化。上下文实现了一族算法的公共逻辑，而策略实现可变部分，允许上下文根据不同的因素（如输入值、系统配置或用户偏好）调整其行为。'
- en: 'Strategies are usually part of a family of solutions and all of them implement
    the same interface expected by the context. The following figure shows the situation
    we just described:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 策略通常是解决方案家族的一部分，并且它们都实现了上下文期望的相同接口。以下图示展示了我们刚刚描述的情况：
- en: '![](img/B15729_09_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15729_09_01.png)'
- en: 'Figure 9.1: General structure of the Strategy pattern'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：策略模式的一般结构
- en: '*Figure 9.1* shows you how the context object can plug different strategies
    into its structure as if they were replaceable parts of a piece of machinery.
    Imagine a car; its tires can be considered its strategy for adapting to different
    road conditions. We can fit winter tires to go on snowy roads thanks to their
    studs, while we can decide to fit high-performance tires for traveling mainly
    on motorways for a long trip. On the one hand, we don''t want to change the entire
    car for this to be possible, and on the other, we don''t want a car with eight
    wheels so that it can go on every possible road.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.1*展示了上下文对象如何将其结构中的不同策略插入其中，就像它们是机器的互换部件一样。想象一辆车；它的轮胎可以被认为是其适应不同道路条件的策略。我们可以安装冬季轮胎以适应雪地道路，因为它们有钉子，而我们可以选择安装高性能轮胎以适应长途行驶的公路。一方面，我们不想为了实现这一点而更换整个汽车，另一方面，我们也不想拥有一辆有八轮的汽车以便它能走每一条可能的道路。'
- en: We quickly understand how powerful this pattern is. Not only does it help with
    separating the concerns within a given problem, but it also enables our solution
    to have better flexibility and adapt to different variations of the same problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就能理解这个模式是多么强大。它不仅有助于分离给定问题中的关注点，而且还使我们的解决方案具有更好的灵活性和适应同一问题的不同变体。
- en: The Strategy pattern is particularly useful in all those situations where supporting
    variations in the behavior of a component requires complex conditional logic (lots
    of `if...else` or `switch` statements) or mixing different components of the same
    family. Imagine an object called `Order` that represents an online order on an
    e-commerce website. The object has a method called `pay()` that, as it says, finalizes
    the order and transfers the funds from the user to the online store.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式在所有那些需要支持组件行为变化且需要复杂条件逻辑（大量的`if...else`或`switch`语句）或混合同一家族的不同组件的情况下特别有用。想象一个名为`Order`的对象，它代表电子商务网站上的一次在线订单。该对象有一个名为`pay()`的方法，正如其名，它最终确定订单并将资金从用户转移到在线商店。
- en: 'To support different payment systems, we have a couple of options:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持不同的支付系统，我们有几种选择：
- en: Use an `if...else` statement in the `pay()` method to complete the operation
    based on the chosen payment option
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`pay()`方法中使用`if...else`语句根据选择的支付选项完成操作
- en: Delegate the logic of the payment to a strategy object that implements the logic
    for the specific payment gateway selected by the user
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将支付逻辑委托给一个实现特定支付网关逻辑的策略对象
- en: In the first solution, our `Order` object cannot support other payment methods
    unless its code is modified. Also, this can become quite complex when the number
    of payment options grows. Instead, using the Strategy pattern enables the `Order` object
    to support a virtually unlimited number of payment methods and keeps its scope
    limited to only managing the details of the user, the purchased items, and the
    relative price while delegating the job of completing the payment to another object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种解决方案中，我们的`Order`对象无法支持其他支付方式，除非修改其代码。此外，当支付选项的数量增加时，这可能会变得相当复杂。相反，使用策略模式使`Order`对象能够支持几乎无限的支付方式，同时将其范围限制在仅管理用户细节、购买项目和相对价格，并将完成支付的任务委托给另一个对象。
- en: Let's now demonstrate this pattern with a simple, realistic example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用一个简单、现实的例子来演示这个模式。
- en: Multi-format configuration objects
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多格式配置对象
- en: Let's consider an object called `Config` that holds a set of configuration parameters
    used by an application, such as the database URL, the listening port of the server,
    and so on. The `Config` object should be able to provide a simple interface to
    access these parameters, but also a way to import and export the configuration
    using persistent storage, such as a file. We want to be able to support different
    formats to store the configuration, for example, JSON, INI, or YAML.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个名为`Config`的对象，它包含一组由应用程序使用的配置参数，例如数据库URL、服务器的监听端口等。`Config`对象应该能够提供一个简单的接口来访问这些参数，同时也应该提供一种使用持久存储（例如文件）导入和导出配置的方法。我们希望能够支持不同的格式来存储配置，例如JSON、INI或YAML。
- en: By applying what we learned about the Strategy pattern, we can immediately identify
    the variable part of the `Config` object, which is the functionality that allows
    us to serialize and deserialize the configuration. This is going to be implemented
    by our strategies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用我们关于策略模式的所学，我们可以立即识别出`Config`对象的变量部分，这部分功能允许我们序列化和反序列化配置。这将由我们的策略来实现。
- en: 'Let''s create a new module called `config.js`, and let''s define the *generic* part
    of our configuration manager:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的模块，名为`config.js`，并定义我们配置管理器的*通用*部分：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is what''s happening in the preceding code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面代码中发生的事情：
- en: In the constructor, we create an instance variable called `data` to hold the
    configuration data. Then we also store `formatStrategy`, which represents the component
    that we will use to parse and serialize the data.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们创建了一个名为`data`的实例变量来保存配置数据。然后我们还存储了`formatStrategy`，它代表我们将用于解析和序列化数据的组件。
- en: We provide two methods, `set()` and `get()`, to access the configuration properties
    using a dotted path notation (for example, `property.subProperty`) by leveraging
    a library called `object-path` ([nodejsdp.link/object-path](http://nodejsdp.link/object-path)).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提供了两个方法，`set()`和`get()`，通过利用名为`object-path`的库（[nodejsdp.link/object-path](http://nodejsdp.link/object-path)）使用点路径表示法（例如，`property.subProperty`）来访问配置属性。
- en: The `load()` and `save()` methods are where we delegate, respectively, the deserialization
    and serialization of the data to our strategy. This is where the logic of the
    `Config` class is altered based on the `formatStrategy` passed as an input in
    the constructor.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`load()`和`save()`方法是我们分别委托给策略的数据反序列化和序列化的地方。这是根据在构造函数中传入的`formatStrategy`来改变`Config`类逻辑的地方。'
- en: As we can see, this very simple and neat design allows the `Config` object to
    seamlessly support different file formats when loading and saving its data. The
    best part is that the logic to support those various formats is not hardcoded
    anywhere, so the `Config` class can adapt without any modification to virtually
    any file format, given the right strategy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这种非常简单且整洁的设计使得`Config`对象在加载和保存数据时能够无缝地支持不同的文件格式。最好的部分是，支持这些各种格式的逻辑并没有硬编码在任何地方，因此`Config`类可以在不进行任何修改的情况下适应几乎任何文件格式，只要提供了正确的策略。
- en: 'To demonstrate this characteristic, let''s now create a couple of format strategies
    in a file called `strategies.js`. Let''s start with a strategy for parsing and
    serializing data using the INI file format, which is a widely used configuration
    format (more info about it here: [nodejsdp.link/ini-format](http://nodejsdp.link/ini-format)).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这一特性，我们现在在名为`strategies.js`的文件中创建几个格式策略。让我们从一个用于解析和序列化数据的策略开始，该策略使用INI文件格式，这是一个广泛使用的配置格式（更多信息请参阅：[nodejsdp.link/ini-format](http://nodejsdp.link/ini-format))。
- en: 'For the task, we will use an npm package called `ini` ([nodejsdp.link/ini](http://nodejsdp.link/ini)):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们将使用一个名为`ini`的npm包（[nodejsdp.link/ini](http://nodejsdp.link/ini))）：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nothing really complicated! Our strategy simply implements the agreed interface,
    so that it can be used by the `Config` object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并没有什么复杂的！我们的策略只是简单地实现了约定的接口，以便它能够被`Config`对象使用。
- en: 'Similarly, the next strategy that we are going to create allows us to support
    the JSON file format, widely used in JavaScript and in the web development ecosystem
    in general:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们接下来要创建的下一个策略允许我们支持JSON文件格式，这在JavaScript以及一般的Web开发生态系统中被广泛使用：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, to show you how everything comes together, let''s create a file named `index.js`,
    and let''s try to load and save a sample configuration using different formats:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了展示一切是如何结合在一起的，让我们创建一个名为`index.js`的文件，并尝试使用不同的格式加载和保存一个示例配置：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our test module reveals the core properties of the Strategy pattern. We defined
    only one `Config` class, which implements the common parts of our configuration
    manager, then, by using different strategies for serializing and deserializing
    data, we created different `Config` class instances supporting different file
    formats.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试模块揭示了策略模式的核心属性。我们只定义了一个 `Config` 类，它实现了配置管理器的公共部分，然后，通过使用不同的策略进行序列化和反序列化数据，我们创建了支持不同文件格式的不同
    `Config` 类实例。
- en: 'The example we''ve just seen showed us only one of the possible alternatives
    that we had for selecting a strategy. Other valid approaches might have been the
    following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的例子只展示了我们选择策略的可能替代方案之一。其他有效的方法可能包括以下内容：
- en: '**Creating two different strategy families**: One for the deserialization and
    the other for the serialization. This would have allowed reading from a format
    and saving to another.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建两个不同的策略家族**：一个用于反序列化，另一个用于序列化。这将允许从一个格式读取并保存到另一个格式。'
- en: '**Dynamically selecting the strategy**: Depending on the extension of the file
    provided, the `Config` object could have maintained a map `extension → strategy` and
    used it to select the right algorithm for the given extension.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态选择策略**：根据提供的文件扩展名，`Config` 对象可以维护一个映射 `extension → strategy` 并用它来选择给定扩展名的正确算法。'
- en: As we can see, we have several options for selecting the strategy to use, and
    the right one only depends on your requirements and the tradeoff in terms of features
    and the simplicity you want to obtain.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们有几种选择策略的选项，而正确的策略仅取决于你的需求和你在功能和想要获得的简单性之间的权衡。
- en: 'Furthermore, the implementation of the pattern itself can vary a lot as well.
    For example, in its simplest form, the context and the strategy can both be simple
    functions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模式的实现本身也可以有很大的变化。例如，在其最简单的形式中，上下文和策略都可以是简单的函数：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even though this may seem insignificant, it should not be underestimated in
    a programming language such as JavaScript, where functions are first-class citizens
    and used as much as fully-fledged objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能看起来微不足道，但在像JavaScript这样的编程语言中，函数是一等公民并且被大量使用，这一点不应被低估。
- en: Between all these variations, though, what does not change is the idea behind
    the pattern; as always, the implementation can slightly change but the core concepts
    that drive the pattern are always the same.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在所有这些变化，但模式背后的理念并没有改变；正如往常一样，实现可以略有变化，但驱动模式的核心理念始终相同。
- en: The structure of the Strategy pattern may look similar to that of the Adapter
    pattern. However, there is a substantial difference between the two. The adapter
    object does not add any behavior to the adaptee; it just makes it available under
    another interface. This can also require some extra logic to be implemented to
    convert one interface into another, but this logic is limited to this task only.
    In the Strategy pattern, however, the context and the strategy implement two different
    parts of an algorithm and therefore both implement some kind of logic and both
    are essential to build the final algorithm (when combined together).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式和适配器模式的结构可能看起来很相似。然而，两者之间有一个实质性的区别。适配器对象不会向适配者添加任何行为；它只是使它可以通过另一个接口使用。这也可能需要实现一些额外的逻辑来将一个接口转换为另一个接口，但这种逻辑仅限于这项任务。然而，在策略模式中，上下文和策略实现了算法的两个不同部分，因此两者都实现了一些逻辑，并且两者对于构建最终的算法（当结合在一起时）都是必不可少的。
- en: In the wild
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: Passport ([nodejsdp.link/passportjs](http://nodejsdp.link/passportjs)) is an
    authentication framework for Node.js, which allows a web server to support different
    authentication schemes. With Passport, we can provide a *login with Facebook* or
    *login with Twitter* functionality to our web application with minimal effort.
    Passport uses the Strategy pattern to separate the common logic used during an
    authentication process from the parts that can change, namely the actual authentication
    step. For example, we might want to use OAuth in order to obtain an access token
    to access a Facebook or Twitter profile, or simply use a local database to verify
    a username/password pair. For Passport, these are all different strategies for
    completing the authentication process and, as we can imagine, this allows the
    library to support a virtually unlimited number of authentication services. Take
    a look at the number of different authentication providers supported at [nodejsdp.link/passport-strategies](http://nodejsdp.link/passport-strategies) to
    get an idea of what the Strategy pattern can do.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Passport（[nodejsdp.link/passportjs](http://nodejsdp.link/passportjs)）是Node.js的一个认证框架，它允许Web服务器支持不同的认证方案。使用Passport，我们可以以最小的努力为我们Web应用程序提供*使用Facebook登录*或*使用Twitter登录*的功能。Passport使用策略模式将认证过程中使用的通用逻辑与可以改变的部分（即实际的认证步骤）分开。例如，我们可能想使用OAuth来获取访问令牌以访问Facebook或Twitter个人资料，或者简单地使用本地数据库来验证用户名/密码对。对于Passport来说，这些都是完成认证过程的不同策略，正如我们可以想象的那样，这允许库支持几乎无限数量的认证服务。看看在[nodejsdp.link/passport-strategies](http://nodejsdp.link/passport-strategies)上支持的不同认证提供者数量，以了解策略模式能做什么。
- en: State
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: The **State** pattern is a specialization of the Strategy pattern where the
    strategy changes depending on the *state* of the context.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**模式是策略模式的一种特殊化，其中策略根据上下文的*状态*而变化。'
- en: We have seen in the previous section how a strategy can be selected based on
    different variables such as a configuration property or an input parameter, and
    once this selection is done, the strategy remains unchanged for the rest of the
    lifespan of the context object. In the State pattern, instead, the strategy (also
    called the **state** in this circumstance) is dynamic and can change during the
    lifetime of the context, thus allowing its behavior to adapt depending on its
    internal state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何根据不同的变量，如配置属性或输入参数，来选择策略，一旦这个选择完成，策略在上下文对象的整个生命周期中保持不变。在状态模式中，相反，策略（在这种情况下也称为**状态**）是动态的，可以在上下文的生命周期内改变，从而允许其行为根据其内部状态进行适应。
- en: 'The following figure shows us a representation of the pattern:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了该模式的表示：
- en: '![](img/B15729_09_02.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15729_09_02.png)'
- en: 'Figure 9.2: The State pattern'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：状态模式
- en: '*Figure 9.2* shows how a context object transitions through three states (A,
    B, and C). With the State pattern, at each different context state, we select
    a different strategy. This means that the context object will adopt a different
    behavior based on the state it''s in.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.2*展示了上下文对象如何通过三个状态（A、B和C）进行转换。使用状态模式，在上下文的不同状态中，我们选择不同的策略。这意味着上下文对象将根据其所在的状态采取不同的行为。'
- en: 'To make this easier to understand, let''s consider an example: imagine we have
    a hotel booking system and an object called `Reservation` that models a room reservation.
    This is a typical situation where we have to adapt the behavior of an object based
    on its state.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更容易理解，让我们考虑一个例子：假设我们有一个酒店预订系统和一个名为`Reservation`的对象，它模拟了一个房间预订。这是一个典型的需要根据对象的状态来适应其行为的情况。
- en: 'Consider the following series of events:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下一系列事件：
- en: When the reservation is initially created, the user can confirm (using a method
    called `confirm()`) the reservation. Of course, they cannot cancel it (using `cancel()`),
    because it's still not confirmed (the caller would receive an exception, for example).
    They can, however, delete it (using `delete()`) if they change their mind before
    buying.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预订最初创建时，用户可以使用名为`confirm()`的方法确认预订。当然，他们不能取消它（使用`cancel()`），因为它还没有被确认（调用者会收到一个异常，例如）。然而，如果他们在购买前改变主意，他们可以删除它（使用`delete()`）。
- en: Once the reservation is confirmed, using the `confirm()` method again does not
    make any sense; however, now it should be possible to cancel the reservation but
    no longer delete it, because it has to be kept for the records.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦预订被确认，再次使用`confirm()`方法就没有意义了；然而，现在应该可以取消预订，但不能再删除它，因为它必须保留以供记录。
- en: On the day before the reservation date, it should not be possible to cancel
    the reservation anymore; it's too late for that.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在预订日期的前一天，不应再有可能取消预订；那时已经太晚了。
- en: Now, imagine that we have to implement the reservation system that we just described
    in one monolithic object. We can already picture all the `if...else` or `switch` statements
    that we would have to write to enable/disable each action depending on the state
    of the reservation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们必须在一个单体对象中实现我们刚才描述的预订系统。我们已经开始想象所有必要的`if...else`或`switch`语句，以便根据预订的状态启用/禁用每个操作。
- en: '![A screenshot of a cell phone  Description automatically generated](img/B15729_09_03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![手机屏幕截图  描述自动生成](img/B15729_09_03.png)'
- en: 'Figure 9.3: An example application of the State pattern'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：状态模式的一个示例应用
- en: 'As illustrated in *Figure 9.3*, the State pattern is, instead, perfect in this
    situation: there would be three strategies, all implementing the three methods
    described (`confirm()`, `cancel()`, and `delete()`) and each one implementing
    only one behavior—the one corresponding to the modeled state. By using this pattern,
    it should be very easy for the `Reservation` object to switch from one behavior
    to another; this would simply require the **activation** of a different strategy
    (state object) on each state change.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图9.3*所示，状态模式在这种情况下是完美的：将会有三种策略，所有这些策略都实现了所描述的三个方法（`confirm()`、`cancel()`和`delete()`），每个策略只实现一个行为——对应于模型化的状态。通过使用这种模式，`Reservation`对象从一个行为切换到另一个行为应该非常容易；这只需要在每个状态变化时激活不同的策略（状态对象）。
- en: The **state transition** can be initiated and controlled by the context object,
    by the client code, or by the state objects themselves. This last option usually
    provides the best results in terms of flexibility and decoupling, as the context
    does not have to know about all the possible states and how to transition between
    them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 状态转换可以由上下文对象、客户端代码或状态对象本身来启动和控制。最后一个选项通常在灵活性和解耦方面提供最佳结果，因为上下文不需要了解所有可能的状态以及如何在这些状态之间转换。
- en: Let's now work on a more concrete example so that we can apply what we learned
    about the State pattern.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理一个更具体的例子，以便我们可以应用我们关于状态模式所学到的知识。
- en: Implementing a basic failsafe socket
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个基本的容错套接字
- en: Let's build a TCP client socket that does not fail when the connection with
    the server is lost; instead, we want to queue all the data sent during the time
    in which the server is offline and then try to send it again as soon as the connection
    is reestablished. We want to leverage this socket in the context of a simple monitoring
    system, where a set of machines sends some statistics about their resource utilization
    at regular intervals. If the server that collects these resources goes down, our
    socket will continue to queue the data locally until the server comes back online.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个TCP客户端套接字，当与服务器连接丢失时不会失败；相反，我们希望在服务器离线期间发送的所有数据都排队，然后在连接重新建立后立即再次尝试发送。我们希望在简单的监控系统上下文中利用这个套接字，其中一组机器定期发送有关其资源利用率的统计数据。如果收集这些资源的服务器崩溃，我们的套接字将继续在本地排队等待数据，直到服务器重新上线。
- en: 'Let''s start by creating a new module called `failsafeSocket.js` that defines
    our context object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为`failsafeSocket.js`的新模块，该模块定义了我们的上下文对象：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `FailsafeSocket` class is made of three main elements:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`FailsafeSocket`类由三个主要元素组成：'
- en: 'The constructor initializes various data structures, including the queue that
    will contain any data sent while the socket is offline. Also, it creates a set
    of two states: one for implementing the behavior of the socket while it''s offline,
    and another one when the socket is online.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数初始化了各种数据结构，包括在套接字离线期间将包含任何发送数据的队列。它还创建了一组两个状态：一个用于实现套接字离线时的行为，另一个用于套接字在线时。
- en: The `changeState()` method is responsible for transitioning from one state to
    another. It simply updates the `currentState` instance variable and calls `activate()` on
    the target state.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`changeState()`方法负责从一个状态转换到另一个状态。它只是更新`currentState`实例变量，并在目标状态上调用`activate()`。'
- en: The `send()` method contains the main functionality of the `FailsafeSocket`
    class. This is where we want to have a different behavior based on the offline/online
    state. As we can see, this is done by delegating the operation to the currently
    active state.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`send()` 方法包含 `FailsafeSocket` 类的主要功能。这是我们想要根据离线/在线状态有不同的行为的地方。正如我们所看到的，这是通过将操作委托给当前活动状态来实现的。'
- en: 'Let''s now see what the two states look like, starting from the `offlineState.js`
    module:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看这两个状态看起来像什么，从 `offlineState.js` 模块开始：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The module that we just created is responsible for managing the behavior of
    the socket while it''s offline. This is how it works:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的模块负责在套接字离线时管理其行为。这是它的工作方式：
- en: Instead of using a raw TCP socket, we will use a little library called `json-over-tcp-2` ([nodejsdp.link/json-over-tcp-2](http://nodejsdp.link/json-over-tcp-2)).
    This will greatly simplify our work since the library will take care of all the
    parsing and formatting of the data going through the socket into JSON objects.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 `json-over-tcp-2` 的小型库（[nodejsdp.link/json-over-tcp-2](http://nodejsdp.link/json-over-tcp-2)）而不是使用原始
    TCP 套接字。这将极大地简化我们的工作，因为库将负责处理通过套接字传输到 JSON 对象的所有解析和格式化。
- en: The `send()` method is only responsible for queuing any data it receives. We
    are assuming that we are offline, so we'll save those data objects for later.
    That's all we need to do here.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`send()` 方法仅负责排队它接收到的任何数据。我们假设我们是离线的，所以我们将这些数据对象保存起来以备后用。这就是我们在这里需要做的所有事情。'
- en: The `activate()` method tries to establish a connection with the server using
    the `json-over-tcp-2` socket. If the operation fails, it tries again after one
    second. It continues trying until a valid connection is established, in which
    case the state of `failsafeSocket` is transitioned to online.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`activate()` 方法尝试使用 `json-over-tcp-2` 套接字与服务器建立连接。如果操作失败，它将在一秒后再次尝试。它将继续尝试，直到建立有效的连接，在这种情况下，`failsafeSocket`
    的状态将过渡到在线状态。'
- en: 'Next, let''s create the `onlineState.js` module, which is where we will implement the
    `OnlineState` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `onlineState.js` 模块，这是我们将在其中实现 `OnlineState` 类的地方：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `OnlineState` class models the behavior of the `FailsafeSocket` when there
    is an active connection with the server. This is how it works:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnlineState` 类模拟了 `FailsafeSocket` 在与服务器建立活动连接时的行为。这是它的工作方式：'
- en: The `send()` method queues the data and then immediately tries to write it directly
    into the socket, as we assume that we are online. It'll use the internal `_safeWrite()`
    method to do that.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`send()` 方法将数据排队，然后立即尝试直接将其写入套接字，因为我们假设我们是在线的。它将使用内部 `_safeWrite()` 方法来完成这项工作。'
- en: The `_safeWrite()` method tries to write the data into the socket writable stream
    (see the official docs at [nodejsdp.link/writable-write](http://nodejsdp.link/writable-write))
    and it waits for the data to be written into the underlying resource. If no errors
    are returned and if the socket didn't disconnect in the meantime, it means that
    the data was sent successfully and therefore we remove it from the queue.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_safeWrite()` 方法尝试将数据写入套接字的可写流（请参阅官方文档 [nodejsdp.link/writable-write](http://nodejsdp.link/writable-write)），并等待数据被写入底层资源。如果没有返回错误，并且在此期间套接字没有断开连接，这意味着数据已成功发送，因此我们将它从队列中删除。'
- en: The `activate()` method flushes any data that was queued while the socket was
    offline and it also starts listening for any `error` event; we will take this
    as a symptom that the socket went offline (for simplicity). When this happens,
    we transition to the `offline` state.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`activate()` 方法清除套接字离线期间排队的任何数据，并开始监听任何 `error` 事件；我们将此视为套接字离线的症状（为了简单起见）。当发生这种情况时，我们将过渡到
    `offline` 状态。'
- en: 'That''s it for our `FailsafeSocket`. Now we are ready to build a sample client
    and a server to try it out. Let''s put the server code in a module named `server.js`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `FailsafeSocket` 来说，这就结束了。现在我们准备构建一个客户端和一个服务器来尝试它。让我们将服务器代码放入一个名为 `server.js`
    的模块中：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, the client-side code, which is what we are really interested in, goes
    into `client.js`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，客户端代码，这是我们真正感兴趣的，将放入 `client.js`：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our server simply prints to the console any JSON message it receives, while
    our clients are sending a measurement of their memory utilization every second,
    leveraging a `FailsafeSocket` object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器简单地打印出它接收到的任何 JSON 消息，而我们的客户端每秒发送一次它们的内存利用率测量值，利用一个 `FailsafeSocket` 对象。
- en: To try the small system that we built, we should run both the client and the
    server, then we can test the features of `failsafeSocket` by stopping and then
    restarting the server. We should see that the state of the client changes between `online` and `offline` and
    that any memory measurement collected while the server is offline is queued and
    then resent as soon as the server goes back online.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试我们构建的小系统，我们应该同时运行客户端和服务器，然后我们可以通过停止并重新启动服务器来测试`failsafeSocket`的功能。我们应该看到客户端的状态在`online`和`offline`之间变化，并且在服务器离线期间收集的任何内存测量值都会排队，并在服务器重新上线后立即重新发送。
- en: This sample should be a clear demonstration of how the State pattern can help
    increase the modularity and readability of a component that has to adapt its behavior depending
    on its state.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应该清楚地展示状态模式如何帮助提高必须根据其状态调整行为的组件的模块化和可读性。
- en: The `FailsafeSocket` class that we built in this section is only for demonstrating
    the State pattern and doesn't want to be a complete and 100% reliable solution
    for handling connectivity issues with TCP sockets. For example, we are not verifying
    that all the data written into the socket stream is received by the server, which
    would require some more code not strictly related to the pattern that we wanted
    to describe. For a production alternative, you can count on ZeroMQ ([nodejsdp.link/zeromq](http://nodejsdp.link/zeromq)).
    We'll talk about some patterns using ZeroMQ later in the book in *Chapter 13*,
    *Messaging and Integration Patterns*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们构建的`FailsafeSocket`类只是为了演示状态模式，并不想成为一个完整且100%可靠的解决方案来处理TCP套接字的连接问题。例如，我们没有验证写入套接字流中的所有数据是否被服务器接收，这需要一些与我们要描述的模式不直接相关的额外代码。对于生产环境，你可以依赖ZeroMQ
    ([nodejsdp.link/zeromq](http://nodejsdp.link/zeromq))。我们将在本书的*第13章*，*消息和集成模式*中讨论一些使用ZeroMQ的模式。
- en: Template
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'The next pattern that we are going to analyze is called **Template** and it
    has a lot in common with the Strategy pattern. The Template pattern defines an
    abstract class that implements the skeleton (representing the common parts) of
    a component, where some of its steps are left undefined. Subclasses can then *fill* the
    gaps in the component by implementing the missing parts, called **template methods**.
    The intent of this pattern is to make it possible to define a family of classes
    that are all variations of a family of components. The following UML diagram shows
    the structure that we just described:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要分析的下一个模式被称为**模板**，它与策略模式有很多共同之处。模板模式定义了一个抽象类，它实现了组件的骨架（表示公共部分），其中一些步骤被留为未定义。子类可以通过实现缺失的部分，即所谓的**模板方法**，来填充组件中的空白。这个模式的目的是使定义一个类家族成为可能，这些类都是某个组件家族的变体。下面的UML图显示了我们所描述的结构：
- en: '![](img/B15729_09_04.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15729_09_04.png)'
- en: 'Figure 9.4: UML diagram of the Template pattern'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：模板模式的UML图
- en: The three concrete classes shown in *Figure 9.4*, extend the template class
    and provide an implementation for `templateMethod()`, which is *abstract* or *pure
    virtual*, to use C++ terminology. In JavaScript, we don't have a formal way to
    define abstract classes, so all we can do is leave the method undefined or assign
    it to a function that always throws an exception, indicating that the method has
    to be implemented. The Template pattern can be considered a more traditionally
    object-oriented pattern than the other patterns we have seen so far, because inheritance
    is a core part of its implementation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.4*中显示的三个具体类扩展了模板类，并为`templateMethod()`方法提供了实现，该方法在C++术语中是*抽象*或*纯虚*的。在JavaScript中，我们没有正式的方式来定义抽象类，所以我们能做的就是保留该方法未定义，或者将其分配给一个总是抛出异常的函数，以指示该方法必须实现。模板模式可以被认为比我们迄今为止看到的其他模式更传统地面向对象，因为继承是其实现的核心部分。
- en: The purpose of Template and Strategy is very similar, but the main difference
    between the two lies in their structure and implementation. Both allow us to change
    the variable parts of a component while reusing the common parts. However, while
    Strategy allows us to do it *dynamically* at runtime, with Template, the complete
    component is determined the moment the concrete class is defined. Under these
    assumptions, the Template pattern might be more suitable in those circumstances
    where we want to create prepackaged variations of a component. As always, the
    choice between one pattern and the other is up to the developer, who has to consider
    the various pros and cons for each use case.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 模板和策略的目的非常相似，但两者之间的主要区别在于它们的结构和实现。两者都允许我们在不改变公共部分的情况下改变组件的可变部分。然而，策略允许我们在运行时动态地做到这一点，而模板则是在定义具体类的那一刻就确定了完整的组件。在这些假设下，模板模式可能更适合那些我们想要创建组件预包装变体的情况。像往常一样，选择哪种模式取决于开发者，开发者必须考虑每个用例的利弊。
- en: Let's now work on an example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理一个示例。
- en: A configuration manager template
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置管理模板
- en: To have a better idea of the differences between Strategy and Template, let's
    now reimplement the `Config` object that we defined in the *Strategy* pattern
    section, but this time using Template. As in the previous version of the `Config` object,
    we want to have the ability to load and save a set of configuration properties
    using different file formats.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解策略和模板之间的区别，我们现在重新实现 *策略* 模式部分中定义的 `Config` 对象，但这次使用模板。与 `Config` 对象的前一个版本一样，我们希望能够使用不同的文件格式加载和保存一组配置属性。
- en: 'Let''s start by defining the template class. We will call it `ConfigTemplate`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义模板类。我们将称之为 `ConfigTemplate`：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `ConfigTemplate` class implements the common parts of the configuration
    management logic, namely setting and getting properties, plus loading and saving
    it to the disk. However, it leaves the implementation of `_serialize()` and `_deserialize()`
    open; those are in fact our template methods, which will allow the creation of
    concrete `Config` classes supporting specific configuration formats. The underscore
    at the beginning of the template methods' names indicates that they are for internal
    use only, an easy way to flag protected methods. Since in JavaScript we cannot
    declare a method as abstract, we simply define them as **stubs**, throwing an
    error if they are invoked (in other words, if they are not overridden by a concrete
    subclass).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigTemplate` 类实现了配置管理逻辑的公共部分，即设置和获取属性，以及将其加载和保存到磁盘。然而，它将 `_serialize()`
    和 `_deserialize()` 的实现留空；这些实际上是我们的模板方法，将允许创建支持特定配置格式的具体 `Config` 类。模板方法名称开头的下划线表示它们仅用于内部使用，这是一种标记受保护方法的简单方法。由于在
    JavaScript 中无法声明抽象方法，我们只需将它们定义为 **占位符**，如果调用它们（换句话说，如果它们没有被具体子类覆盖），则抛出错误。'
- en: 'Let''s now create a concrete class using our template, for example, one that
    allows us to load and save the configuration using the JSON format:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用我们的模板创建一个具体类，例如，一个允许我们使用 JSON 格式加载和保存配置的类：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `JsonConfig` class extends our template class, `ConfigTemplate`, and provides
    a concrete implementation for the `_deserialize()` and `_serialize()` methods.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonConfig` 类扩展了我们的模板类 `ConfigTemplate`，并为 `_deserialize()` 和 `_serialize()`
    方法提供了具体的实现。'
- en: 'Similarly, we can implement an `IniConfig` class supporting the `.ini` file
    format using the same template class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用相同的模板类实现一个支持 `.ini` 文件格式的 `IniConfig` 类：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can use our concrete configuration manager classes to load and save
    some configuration data:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的具体配置管理类来加载和保存一些配置数据：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note the difference with the Strategy pattern: the logic for formatting and
    parsing the configuration data is *baked into* the class itself, rather than being
    chosen at runtime.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意与策略模式的区别：格式化和解析配置数据的逻辑是直接嵌入到类本身中，而不是在运行时选择。
- en: With minimal effort, the Template pattern allowed us to obtain a new, fully
    working configuration manager by reusing the logic and the interface inherited
    from the parent template class and providing only the implementation of a few
    abstract methods.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最小的努力，模板模式允许我们通过重用从父模板类继承的逻辑和接口，并仅提供少量抽象方法的实现，来获得一个新的、完全工作的配置管理器。
- en: In the wild
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: This pattern should not look entirely new to us. We already encountered it in
    *Chapter 6*, *Coding with Streams*, when we were extending the different stream
    classes to implement our custom streams. In that context, the template methods were
    the `_write()`, `_read()`, `_transform()`, or `_flush()` methods, depending on
    the stream class that we wanted to implement. To create a new custom stream, we
    needed to inherit from a specific abstract stream class, providing an implementation
    for the template methods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式对我们来说不应该完全陌生。我们在*第6章*，*使用流编码*中已经遇到过它，当时我们在扩展不同的流类以实现自定义流。在那个背景下，模板方法是`_write()`、`_read()`、`_transform()`或`_flush()`方法，具体取决于我们想要实现的流类。要创建一个新的自定义流，我们需要从一个特定的抽象流类继承，并为模板方法提供实现。
- en: Next, we are going to learn about a very important and ubiquitous pattern that
    is also built into the JavaScript language itself, which is the Iterator pattern.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习一个非常重要且无处不在的模式，这个模式也内置到JavaScript语言本身中，即迭代器模式。
- en: Iterator
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: The **Iterator** pattern is a fundamental pattern and it's so important and
    commonly used that it's usually built into the programming language itself. All
    major programming languages implement the pattern in one way or another, including,
    of course, JavaScript (starting from the ECMAScript2015 specification).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器**模式是一个基本模式，它如此重要且常用，以至于通常内置到编程语言本身中。所有主要的编程语言都以某种方式实现了该模式，包括当然的JavaScript（从ECMAScript2015规范开始）。'
- en: 'The Iterator pattern defines a common interface or protocol for iterating the
    elements of a container, such as an array or a tree data structure. Usually, the
    algorithm for iterating over the elements of a container is different depending
    on the actual structure of the data. Think about iterating over an array versus
    traversing a tree: in the first situation, we need just a simple loop; in the
    second, a more complex tree traversal algorithm is required ([nodejsdp.link/tree-traversal](http://nodejsdp.link/tree-traversal)).
    With the Iterator pattern, we hide the details about the algorithm being used
    or the structure of the data and provide a common interface for iterating over
    any type of container. In essence, the Iterator pattern allows us to decouple
    the implementation of the traversal algorithm from the way we consume the results
    (the elements) of the traversal operation.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式定义了一个通用的接口或协议，用于迭代容器的元素，例如数组或树型数据结构。通常，迭代容器元素的算法取决于数据的实际结构。想想迭代数组与遍历树：在前一种情况下，我们只需要一个简单的循环；在后一种情况下，需要一个更复杂的树遍历算法（[nodejsdp.link/tree-traversal](http://nodejsdp.link/tree-traversal)）。使用迭代器模式，我们隐藏了关于正在使用的算法或数据结构的细节，并为迭代任何类型的容器提供了一个通用接口。本质上，迭代器模式允许我们将遍历算法的实现与消费遍历操作结果（元素）的方式解耦。
- en: In JavaScript, however, iterators work great even with other types of constructs,
    which are not necessarily containers, such as event emitters and streams. Therefore,
    we can say in more general terms that the Iterator pattern defines an interface
    to iterate over elements produced or retrieved in sequence.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在JavaScript中，迭代器甚至与其他类型的结构（不一定是容器）一起工作得很好，例如事件发射器和流。因此，我们可以更普遍地说，迭代器模式定义了一个接口，用于迭代按顺序产生或检索的元素。
- en: The iterator protocol
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器协议
- en: In JavaScript, the Iterator pattern is implemented through **protocols** rather
    than through formal constructs, such as inheritance. This essentially means that
    the interaction between the implementer and the consumer of the Iterator pattern
    will communicate using interfaces and objects whose shape is agreed in advance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，迭代器模式是通过**协议**而不是通过正式的结构（如继承）来实现的。这本质上意味着迭代器模式的实现者和消费者之间的交互将使用预定义形状的接口和对象进行通信。
- en: 'The starting point for implementing the Iterator pattern in JavaScript is the
    **iterator protocol**, which defines an interface for producing a sequence of
    values. So, we''ll call **iterator** an object implementing a `next()` method
    having the following behavior: each time the method is called, the function returns
    the next element in the iteration through an object, called the **iterator result**,
    having two properties—`done` and `value`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中实现迭代器模式的起点是**迭代器协议**，它定义了一个生成值序列的接口。因此，我们将实现具有以下行为的`next()`方法的对象称为**迭代器**：每次调用该方法时，函数返回迭代过程中通过一个称为**迭代器结果**的对象的下一个元素，该对象有两个属性——`done`和`value`：
- en: '`done` is set to `true` when the iteration is complete, or in other words,
    when there are no more elements to return. Otherwise, `done` will be `undefined`
    or `false`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当迭代完成时，`done` 被设置为 `true`，换句话说，当没有更多元素可以返回时。否则，`done` 将是 `undefined` 或 `false`。
- en: '`value` contains the current element of the iteration and it can be left undefined
    if `done` is `true`. If `value` is set even when `done` is `true`, then it is
    said that `value` contains the **return value** of the iteration, a value which
    is not part of the elements being iterated, but it''s related to the iteration
    itself as a whole (for example, the time spent iterating all the elements or the
    average of all the elements iterated if the elements are numbers).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` 包含迭代的当前元素，如果 `done` 是 `true`，则可以将其留为 `undefined`。如果即使在 `done` 是 `true`
    的情况下设置了 `value`，那么可以说 `value` 包含迭代的 **返回值**，这是一个不属于正在迭代的元素的值，但它与整个迭代相关（例如，迭代所有元素所花费的时间或所有迭代的元素的平均值，如果元素是数字）。'
- en: Nothing prevents us from adding extra properties to the object returned by an
    iterator. However, those properties will be simply ignored by the built-in constructs
    or APIs consuming the iterator (we'll meet those in a moment).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '没有任何东西阻止我们向迭代器返回的对象添加额外的属性。然而，这些属性将被内置构造或API消费迭代器时简单地忽略（我们稍后会遇到这些）。 '
- en: 'Let''s use a quick example to demonstrate how to implement the iterator protocol.
    Let''s implement a factory function called `createAlphabetIterator()`, which creates
    an iterator that allows us to traverse all the letters of the English alphabet.
    Such a function would look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来演示如何实现迭代器协议。让我们实现一个名为 `createAlphabetIterator()` 的工厂函数，它创建一个迭代器，允许我们遍历所有英文字母。这样的函数看起来会是这样：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The logic of the iteration is actually very straightforward; at each invocation
    of the `next()` method, we simply increment a number representing the letter's
    character code, convert it to a character, and then return it using the object
    shape defined by the iterator protocol.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代的逻辑实际上非常简单；在每次调用 `next()` 方法时，我们只是简单地增加一个表示字母字符码的数字，将其转换为字符，然后使用迭代器协议定义的对象形状返回它。
- en: 'It''s not a requirement for an iterator to ever return `done: true`. In fact,
    there can be many situations in which an iterator is **infinite**. An example
    is an iterator that returns a random number at each iteration. Another example
    is an iterator that calculates a mathematical series, such as the Fibonacci series
    or the digits of the constant `pi` (as an exercise, you can try to convert the
    following algorithm to use iterators: [nodejsdp.link/pi-js](http://nodejsdp.link/pi-js)).
    Note that even if an iterator is theoretically infinite, it doesn''t mean that
    it won''t have computational or spatial limits. For example, the number returned
    by the Fibonacci sequence will get very big very soon.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '迭代器永远返回 `done: true` 并不是必需的。实际上，存在许多迭代器是 **无限** 的情况。一个例子是每次迭代返回一个随机数的迭代器。另一个例子是计算数学级数的迭代器，例如斐波那契数列或常数
    `pi` 的位数（作为一个练习，你可以尝试将以下算法转换为使用迭代器：[nodejsdp.link/pi-js](http://nodejsdp.link/pi-js)）。请注意，即使迭代器在理论上是无界的，这并不意味着它不会有计算或空间限制。例如，斐波那契数列返回的数字会很快变得非常大。'
- en: The important aspect to note is that an iterator is very often a stateful object
    since we have to keep track in some way of the current *position* of the iteration.
    In the previous example, we managed to keep the state in a closure (the `currCode`
    variable) but this is just one of the ways we can do so. We could have, for example,
    kept the state in an instance variable. This is usually better in terms of debuggability
    since we can read the status of the iteration from the iterator itself at any
    time, but on the other side, it does not prevent external code from modifying
    the instance variable and hence tampering with the status of the iteration. It's
    up to you to decide the pros and cons of each option.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要方面是，迭代器通常是一个非常态对象，因为我们必须以某种方式跟踪迭代的当前 *位置*。在前面的例子中，我们设法在闭包（`currCode`
    变量）中保持状态，但这只是我们能够做到的一种方式。例如，我们可以在实例变量中保持状态。这在调试方面通常更好，因为我们可以在任何时间从迭代器本身读取迭代的状态，但另一方面，它并不能阻止外部代码修改实例变量，从而干扰迭代的状态。这取决于你决定每个选项的利弊。
- en: Iterators can indeed be fully stateless as well. Examples are iterators returning
    random elements and either completing randomly or never completing, and iterators
    stopping at the first iteration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器确实也可以是完全无状态的。例如，返回随机元素并随机完成或永远不会完成的迭代器，以及在第1次迭代时停止的迭代器。
- en: 'Now, let''s see how we can use the iterator we just built. Consider the following
    code fragment:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用刚刚构建的迭代器。考虑以下代码片段：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see from the previous code, the code that consumes an iterator can
    be considered a pattern itself. However, as we will see later in this section,
    it's not the only way we have to consume an iterator. JavaScript has, in fact,
    much more convenient and elegant ways to use iterators.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，消耗迭代器的代码本身可以被认为是一种模式。然而，正如我们将在本节后面看到的，这并不是我们消耗迭代器的唯一方式。实际上，JavaScript有更多方便和优雅的方式来使用迭代器。
- en: 'Iterators can optionally specify two additional methods: `return([value])`
    and `throw(error)`. The first is by convention used to signal to the iterator
    that the consumer has stopped the iteration before its completion, while the second
    is used to communicate to the iterator that an error condition has occurred. Both
    methods are rarely used by built-in iterators.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器可以可选地指定两个额外的方法：`return([value])` 和 `throw(error)`。第一个方法按照惯例用于向迭代器发出信号，消费者在迭代完成之前已经停止了迭代，而第二个方法用于向迭代器传达已发生错误条件。这两个方法在内置迭代器中很少使用。
- en: The iterable protocol
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可迭代协议
- en: The **iterable protocol** defines a standardized means for an object to return
    an iterator. Such objects are called **iterables**. Usually, an iterable is a
    container of elements, such as a data structure, but it can also be an object
    virtually representing a set of elements, such as a `Directory` object, which
    would allow us to iterate over the files in a directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**可迭代协议**定义了一种标准化的方式，使一个对象能够返回一个迭代器。这样的对象被称为**可迭代对象**。通常，一个可迭代对象是一个元素的容器，例如数据结构，但它也可以是一个虚拟表示一组元素的对象，例如`Directory`对象，这将允许我们遍历目录中的文件。'
- en: In JavaScript, we can define an iterable by making sure it implements the **@@iterator**
    **method**, or in other words, a method accessible through the built-in symbol
    `Symbol.iterator`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们可以通过确保它实现了**@@iterator**方法来定义一个可迭代对象，换句话说，一个可以通过内置符号`Symbol.iterator`访问的方法。
- en: The `@@name` convention indicates a *well-known* symbol according to the ES6
    specification. To find out more, you can check out the relative section of the
    ES6 specification at [nodejsdp.link/es6-well-known-symbols](http://nodejsdp.link/es6-well-known-symbols).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`@@name`约定根据ES6规范表示一个**已知**的符号。要了解更多信息，您可以查看ES6规范的相应部分，[nodejsdp.link/es6-well-known-symbols](http://nodejsdp.link/es6-well-known-symbols)。'
- en: 'Such an `@@iterator` method should return an iterator object, which can be
    used to iterate over the elements represented by the iterable. For example, if
    our iterable is a class, we would have something like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的`@@iterator`方法应该返回一个迭代器对象，该对象可以用来遍历可迭代对象所表示的元素。例如，如果我们的可迭代对象是一个类，我们会有以下类似的内容：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To show how this works in practice, let''s build a class to manage information
    organized in a bidimensional matrix structure. We want this class to be implementing
    the iterable protocol, so that we can scan all the elements in the matrix using
    an iterator. Let''s create a file called `matrix.js` containing the following
    content:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这在实践中是如何工作的，让我们创建一个类来管理以二维矩阵结构组织的信息。我们希望这个类实现迭代器协议，这样我们就可以使用迭代器扫描矩阵中的所有元素。让我们创建一个名为
    `matrix.js` 的文件，包含以下内容：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we can see, the class contains the basic methods for getting and setting
    values in the matrix, as well as the `@@iterator` method, implementing our iterable
    protocol. The `@@iterator` method will return an iterator, as specified by the
    iterable protocol and such an iterator adheres to the iterator protocol. The logic
    of the iterator is very straightforward: we are simply traversing the matrix''s
    cells from the top left to the bottom right, by scanning each column of each row;
    we are doing that by leveraging two indexes, `nextRow` and `nextCol`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该类包含在矩阵中获取和设置值的基本方法，以及`@@iterator`方法，实现了我们的可迭代协议。`@@iterator`方法将返回一个迭代器，正如可迭代协议所指定的，这样的迭代器遵循迭代器协议。迭代器的逻辑非常简单：我们只是简单地从左上角到右下角遍历矩阵的单元格，通过扫描每一行的每一列；我们通过利用两个索引`nextRow`和`nextCol`来实现这一点。
- en: 'Now, it''s time to try out our iterable `Matrix` class. We can do that in a
    file called `index.js`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候尝试我们的可迭代 `Matrix` 类了。我们可以在一个名为 `index.js` 的文件中这样做：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All we are doing in the previous code is creating a sample `Matrix` instance
    and then obtaining an iterator using the `@@iterator` method. What comes next,
    as we already know, is just boilerplate code that iterates over the elements returned
    by the iterator. The output of the iteration should be `'11'`, `'12'`, `'21'`,
    `'22'`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是创建了一个`Matrix`实例的样本，然后使用`@@iterator`方法获取一个迭代器。接下来，正如我们已经知道的，只是迭代器返回的元素的样板代码。迭代的输出应该是`'11'`、`'12'`、`'21'`、`'22'`。
- en: Iterators and iterables as a native JavaScript interface
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器和可迭代对象作为原生JavaScript接口
- en: 'At this point, you may ask: "what''s the point of having all these protocols
    for defining iterators and iterables?" Well, having a standardized interface allows
    third party code as well as the language itself to be modeled around the two protocols
    we''ve just seen. This way, we can have APIs (even native) as well as syntax constructs
    accepting iterables as an input.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能会有疑问：“定义迭代器和可迭代对象的这些协议有什么用呢？” 好吧，拥有一个标准化的接口允许第三方代码以及语言本身围绕我们刚刚看到的两个协议进行建模。这样，我们就可以拥有接受可迭代对象作为输入的API（甚至是原生的）以及语法结构。
- en: 'For example, the most obvious syntax construct accepting an iterable is the
    `for...of` loop. We''ve just seen in the last code sample that iterating over
    a JavaScript iterator is a pretty standard operation, and its code is mostly boilerplate.
    In fact, we''ll always have an invocation to `next()` to retrieve the next element
    and a check to verify if the `done` property of the iteration result is set to
    `true`, which indicates the end of the iteration. But, worry not, simply pass
    an iterable to the `for...of` instruction to seamlessly loop over the elements
    returned by its iterator. This allows us to process the iteration with an intuitive
    and compact syntax:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，接受可迭代对象的最明显的语法结构是`for...of`循环。我们在上一个代码示例中看到，迭代JavaScript迭代器是一个相当标准的操作，其代码主要是样板。实际上，我们总是有一个调用`next()`来检索下一个元素，以及一个检查迭代结果的`done`属性是否设置为`true`，这表示迭代结束。但是，不用担心，只需将可迭代对象传递给`for...of`指令，就可以无缝地迭代其迭代器返回的元素。这允许我们使用直观且紧凑的语法处理迭代：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another construct compatible with iterables is the spread operator:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与可迭代对象兼容的结构是扩展运算符：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Similarly, we can use an iterable with the destructuring assignment operation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以使用可迭代对象进行解构赋值操作：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following are some JavaScript built-in APIs accepting iterables:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些接受可迭代对象的JavaScript内置API：
- en: '`Map([iterable])`: [nodejsdp.link/map-constructor](http://nodejsdp.link/map-constructor)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map([iterable])`: [nodejsdp.link/map-constructor](http://nodejsdp.link/map-constructor)'
- en: '`WeakMap([iterable])`: [nodejsdp.link/weakmap-constructor](http://nodejsdp.link/weakmap-constructor)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakMap([iterable])`: [nodejsdp.link/weakmap-constructor](http://nodejsdp.link/weakmap-constructor)'
- en: '`Set([iterable])`: [nodejsdp.link/set-constructor](http://nodejsdp.link/set-constructor)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set([iterable])`: [nodejsdp.link/set-constructor](http://nodejsdp.link/set-constructor)'
- en: '`WeakSet([iterable])`: [nodejsdp.link/weakset-constructor](http://nodejsdp.link/weakset-constructor)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakSet([iterable])`: [nodejsdp.link/weakset-constructor](http://nodejsdp.link/weakset-constructor)'
- en: '`Promise.all(iterable)`: [nodejsdp.link/promise-all](http://nodejsdp.link/promise-all)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.all(iterable)`: [nodejsdp.link/promise-all](http://nodejsdp.link/promise-all)'
- en: '`Promise.race(iterable)`: [nodejsdp.link/promise-race](http://nodejsdp.link/promise-race)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.race(iterable)`: [nodejsdp.link/promise-race](http://nodejsdp.link/promise-race)'
- en: '`Array.from(iterable)`: [nodejsdp.link/array-from](http://nodejsdp.link/array-from)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.from(iterable)`: [nodejsdp.link/array-from](http://nodejsdp.link/array-from)'
- en: On the Node.js side, one notable API accepting an iterable is `stream.Readable.from(iterable,
    [options])` ([nodejsdp.link/readable-from](http://nodejsdp.link/readable-from)),
    which creates a readable stream out of an iterable object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js方面，一个接受可迭代对象的可注意的API是`stream.Readable.from(iterable, [options])` ([nodejsdp.link/readable-from](http://nodejsdp.link/readable-from))，它从一个可迭代对象创建一个可读流。
- en: 'Note that all the APIs and syntax constructs we''ve just seen accept as input
    an iterable and not an iterator. But, what can we do if we have a function returning
    an iterator, such as in our `createAlphabetIterator()` example? How can we leverage
    all the built-in APIs and syntax constructs? A possible solution is implementing
    the `@@iterator` method in the iterator object itself, which will simply return
    the iterator object itself. This way we''ll be able to write something such as
    the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们刚刚看到的所有 API 和语法结构都接受一个可迭代的输入，而不是迭代器。但是，如果我们有一个返回迭代器的函数，比如我们的`createAlphabetIterator()`示例，我们该怎么办？我们如何利用所有内置的
    API 和语法结构？一个可能的解决方案是在迭代器对象本身中实现`@@iterator`方法，这将简单地返回迭代器对象本身。这样我们就能写出如下内容：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: JavaScript itself defines many iterables that can be used with the APIs and
    constructs we've just seen. The most notable iterable is `Array`, but also other
    data structures, such as `Map` and `Set`, and even `String` all implement the
    `@@iterable` method. In Node.js land, `Buffer` is probably the most notable iterable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 本身定义了许多可迭代的，可以使用我们刚刚看到的 API 和结构。最值得注意的是`Array`，但还有其他数据结构，如`Map`和`Set`，甚至`String`都实现了`@@iterable`方法。在
    Node.js 领域，`Buffer`可能是最著名的可迭代对象。
- en: 'A trick to make sure that an array doesn''t contain duplicate elements is the
    following: `const uniqArray = Array.from(new Set(arrayWithDuplicates))`. This
    also shows us how iterables offer a way for different components to talk to each
    other using a shared interface.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 确保数组不包含重复元素的一个技巧是以下内容：`const uniqArray = Array.from(new Set(arrayWithDuplicates))`。这也展示了可迭代对象如何为不同的组件提供一种使用共享接口进行通信的方式。
- en: Generators
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: The ES2015 specification introduced a syntax construct that is closely related
    to iterators. We are talking about **generators**, also known as **semicoroutines**.
    They are a generalization of standard functions, in which there can be different
    entry points. In a standard function, we can have only one entry point, which
    corresponds to the invocation of the function itself, but a generator can be suspended
    (using the `yield` statement) and then resumed at a later time. Among other things,
    generators are very well suited to implement iterators, in fact, as we will see
    in a bit, the generator object returned by a generator function is indeed both
    an iterator and an iterable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 规范引入了一种与迭代器紧密相关的语法结构。我们谈论的是**生成器**，也称为**半协程**。它们是标准函数的泛化，其中可以有多个入口点。在标准函数中，我们只能有一个入口点，这对应于函数本身的调用，但生成器可以被挂起（使用`yield`语句），然后在稍后时间恢复。在其他方面，生成器非常适合实现迭代器，实际上，正如我们稍后将看到的，生成器函数返回的生成器对象确实既是迭代器又是可迭代的。
- en: Generators in theory
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器理论
- en: 'To define a **generator function**, we need to use the `function*` declaration
    (the `function` keyword followed by an asterisk):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个**生成器函数**，我们需要使用`function*`声明（`function`关键字后跟一个星号）：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Invoking a generator function will not execute its body immediately. Rather,
    it will return a **generator object**, which, as we already mentioned, is both
    an iterator and an iterable. But it doesn''t end here; invoking `next()` on the
    generator object will start or resume the execution of the generator until the
    `yield` instruction is invoked or the generator returns (either implicitly or
    explicitly with a `return` instruction). Within the generator, using the keyword
    `yield` followed by a value `x` is equivalent to returning `{done: false, value:
    x}` from the iterator, while returning a value `x` is equivalent to returning
    `{done: true, value: x}`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '调用一个生成器函数不会立即执行其主体。相反，它将返回一个**生成器对象**，正如我们之前提到的，这个对象既是迭代器又是可迭代的。但这还没有结束；在生成器对象上调用`next()`将启动或恢复生成器的执行，直到调用`yield`指令或生成器返回（无论是隐式还是显式地使用`return`指令）。在生成器内部，使用关键字`yield`后跟一个值`x`相当于从迭代器返回`{done:
    false, value: x}`，而返回一个值`x`相当于返回`{done: true, value: x}`。'
- en: A simple generator function
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的生成器函数
- en: 'To demonstrate what we just learned, let''s see a simple generator called `fruitGenerator()`,
    which will yield two names of fruits and return their ripening season:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示我们刚刚学到的内容，让我们看看一个简单的生成器`fruitGenerator()`，它将产生两个水果的名称并返回它们的成熟季节：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code will print the following text:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将打印以下文本：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a short explanation of what happened:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对刚刚发生的事情的简要说明：
- en: The first time `fruitGeneratorObj.next()` was invoked, the generator started
    its execution until it reached the first `yield` command, which put the generator
    on pause and returned the value `'peach'` to the caller.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第一次调用`fruitGeneratorObj.next()`时，生成器开始执行，直到它达到第一个`yield`命令，这使生成器暂停并返回值`'peach'`给调用者。
- en: At the second invocation of `fruitGeneratorObj.next()`, the generator resumed,
    starting from the second `yield` command, which in turn put the execution on pause
    again, while returning the value `'watermelon'` to the caller.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二次调用`fruitGeneratorObj.next()`时，生成器从第二个`yield`命令开始恢复，这反过来又使执行再次暂停，同时将值`'watermelon'`返回给调用者。
- en: The last invocation of `fruitGeneratorObj.next()` caused the execution of the
    generator to resume from its last instruction, a `return` statement, which terminates
    the generator, returns the value `'summer'`, and sets the `done` property to `true` in
    the `result` object.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一次调用`fruitGeneratorObj.next()`导致生成器从其最后一条指令恢复执行，即`return`语句，这终止了生成器，返回值`'summer'`，并将`result`对象中的`done`属性设置为`true`。
- en: 'Since a generator object is also an iterable, we can use it in a `for...of`
    loop. For example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成器对象也是一个可迭代对象，我们可以在`for...of`循环中使用它。例如：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding loop will print:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的循环将打印：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Why is `summer` not being printed? Well, `summer` is not yielded by our generator,
    but instead, it is returned, which indicates that the iteration is complete with
    `summer` as a return value (not as an element).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么没有打印出`summer`？嗯，`summer`并没有由我们的生成器产生，而是返回了，这表明迭代已经完成，`summer`作为返回值（而不是作为元素）。
- en: Controlling a generator iterator
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制生成器迭代器
- en: 'Generator objects are more than standard iterators, in fact, their `next()`
    method optionally accepts an argument (whereas, as specified by the iterator protocol,
    it does not need to accept one). Such an argument is passed as the return value
    of the `yield` instruction. To show this, let''s create a new simple generator:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象不仅仅是标准迭代器，实际上，它们的`next()`方法可以可选地接受一个参数（而迭代器协议规定它不需要接受一个参数）。这样的参数作为`yield`指令的返回值传递。为了展示这一点，让我们创建一个新的简单生成器：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When executed, the preceding code prints `Hello world`. This means that the
    following has happened:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，前面的代码打印出`Hello world`。这意味着以下情况发生了：
- en: The first time the `next()` method is invoked, the generator reaches the first `yield` statement
    and is then put on pause.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次调用`next()`方法时，生成器达到第一个`yield`语句，然后被暂停。
- en: When `next('world')` is invoked, the generator resumes from the point where
    it was put on pause, which is on the `yield` instruction, but this time we have
    a value that is passed back to the generator. This value will then be set to the `what` variable.
    The generator then appends the `what` variable to the string `'Hello '` and yields
    the result.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用`next('world')`时，生成器从它被暂停的点恢复，即`yield`指令，但这次我们有一个传递回生成器的值。这个值将被设置为`what`变量。然后生成器将`what`变量追加到字符串`'Hello
    '`，并产生结果。
- en: 'Two other extra features provided by generator objects are the optional `throw()`
    and `return()` iterator methods. The first behaves like `next()` but it will also
    throw an exception within the generator as if it was thrown at the point of the
    last `yield`, and returns the canonical iterator object with the `done` and `value`
    properties. The second, the `return()` method, forces the generator to terminate
    and returns an object such as the following: `{done: true, value: returnArgument}`
    where `returnArgument` is the argument passed to the `return()` method.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '生成器对象还提供了两个其他额外功能，即可选的`throw()`和`return()`迭代器方法。第一个方法的行为类似于`next()`，但它会在生成器内部抛出一个异常，就像它在最后一个`yield`点被抛出一样，并返回具有`done`和`value`属性的规范迭代器对象。第二个，`return()`方法，强制生成器终止，并返回一个如下的对象：`{done:
    true, value: returnArgument}`，其中`returnArgument`是传递给`return()`方法的参数。'
- en: 'The following code shows a demonstration of these two methods:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了这两个方法的演示：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running the previous code will print the following to the console:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将在控制台打印以下内容：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see, the `twoWayGenerator()` function will receive an exception as
    soon as the first `yield` instruction returns. This works exactly as if an exception
    was thrown from inside the generator, and this means that it can be caught and
    handled like any other exception using a `try...catch` block. The `return()` method,
    instead, will simply stop the execution of the generator causing the given value
    to be provided as a return value by the generator.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`twoWayGenerator()`函数将在第一个`yield`指令返回时立即接收到一个异常。这正好像在生成器内部抛出一个异常一样工作，这意味着它可以像任何其他异常一样被捕获和处理，使用`try...catch`块。相反，`return()`方法将简单地停止生成器的执行，导致给定的值作为生成器的返回值提供。
- en: How to use generators in place of iterators
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用生成器代替迭代器
- en: 'Generator objects are also iterators. This means that generator functions can
    be used to implement the `@@iterator` method of iterable objects. To demonstrate
    this, let''s convert our previous `Matrix` iteration example to generators. Let''s
    update our `matrix.js` file as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象也是迭代器。这意味着生成器函数可以被用来实现可迭代对象的`@@iterator`方法。为了演示这一点，让我们将之前的`Matrix`迭代示例转换为生成器。让我们更新我们的`matrix.js`文件如下：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are a few interesting aspects in the code fragment we''ve just seen.
    Let''s analyze them in more detail:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的代码片段中有几个有趣的方面。让我们更详细地分析它们：
- en: The first thing to notice is that the `@@iterator` method is now a generator
    (note the asterisk `*` before the method name).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，要注意的是`@@iterator`方法现在是一个生成器（注意方法名前的星号`*`）。
- en: The variables we use to maintain the state of the iteration are now just local
    variables for the generator, while in the previous version of the `Matrix` class,
    those two variables were part of a closure. This is possible because when a generator
    is invoked, its local state is preserved between reentries.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用来维护迭代状态的变量现在只是生成器的局部变量，而在`Matrix`类的上一个版本中，这两个变量是闭包的一部分。这是可能的，因为当生成器被调用时，它的局部状态在重新进入时被保留。
- en: We are using a standard loop to iterate over the elements of the matrix. This
    is certainly more intuitive than trying to imagine a loop that invokes the `next()`
    method of an iterator.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用一个标准的循环来遍历矩阵的元素。这肯定比试图想象一个调用迭代器`next()`方法的循环更直观。
- en: As we can see, generators are an excellent alternative to writing iterators
    from scratch. They will improve the readability of our iteration routine and will
    offer the same level of functionality (or even better).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，生成器是编写迭代器的一个很好的替代方案。它们将提高我们迭代例程的可读性，并提供相同级别的功能（甚至更好）。
- en: The **generator delegation** instruction, `yield * iterable`, is another example
    of a JavaScript built-in syntax accepting an iterable as an argument. The instruction
    will loop over the elements of the iterable and yield each element one by one.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器委托**指令`yield * iterable`是另一个接受可迭代对象作为参数的JavaScript内置语法的例子。该指令将遍历可迭代对象的元素，并逐个产生每个元素。'
- en: Async iterators
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步迭代器
- en: The iterators we've seen so far return a value synchronously from their `next()`
    method. However, in JavaScript and especially in Node.js, it's very common to
    have iterations over items that require an asynchronous operation to be produced.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的迭代器从它们的`next()`方法同步返回一个值。然而，在JavaScript和尤其是在Node.js中，迭代需要执行异步操作以产生项的情况非常常见。
- en: Imagine, for example, to iterate over the requests received by an HTTP server,
    or over the results of an SQL query, or over the elements of a paginated REST
    API. In all those situations, it would be handy to be able to return a promise
    from the `next()` method of an iterator, or even better, use the async/await construct.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，例如，迭代一个HTTP服务器接收到的请求，或者迭代一个SQL查询的结果，或者迭代分页REST API的元素。在所有这些情况下，能够从迭代器的`next()`方法返回一个Promise将非常有用，或者更好的是，使用async/await结构。
- en: Well, that's exactly what **async iterators** are; they are iterators returning
    a promise, and since that's the only extra requirement, it means that we can also
    use an async function to define the `next()` method of the iterator. Similarly,
    **async iterables** are objects that implement an `@@asyncIterator` method, or
    in other words, a method accessible through the `Symbol.asyncIterator` key, which
    returns (synchronously) an async iterator.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这正是**异步迭代器**；它们是返回一个Promise的迭代器，由于这仅是额外要求之一，这意味着我们也可以使用一个异步函数来定义迭代器的`next()`方法。同样，**异步可迭代对象**是实现了`@@asyncIterator`方法的对象，换句话说，是一个可以通过`Symbol.asyncIterator`键访问的方法，它返回（同步地）一个异步迭代器。
- en: 'Async iterables can be looped over using the `for await...of` syntax, which
    can only be used inside an async function. With the `for await...of` syntax, we
    are essentially implementing a sequential asynchronous execution flow on top of
    the Iterator pattern. Essentially, it''s just syntactic sugar for the following
    loop:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 异步可迭代可以使用 `for await...of` 语法进行迭代，这只能在异步函数内部使用。使用 `for await...of` 语法，我们实际上是在迭代器模式的基础上实现了一个顺序异步执行流程。本质上，它只是以下循环的语法糖：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means that the `for await...of` syntax can also be used to iterate over
    a simple iterable (not just async iterables) as, for example, over an array of
    promises. It will work even if not all the elements (or none) of the iterator
    are promises.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `for await...of` 语法也可以用来迭代简单的可迭代对象（不仅仅是异步可迭代对象），例如，迭代一个承诺数组。即使迭代器的所有元素（或没有）都不是承诺，它也会正常工作。
- en: 'To quickly demonstrate this, let''s build a class that takes a list of URLs
    as input and allows us to iterate over their availability status (`up`/`down`).
    Let''s call the class `CheckUrls`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速演示这一点，让我们创建一个类，它接受一个 URL 列表作为输入，并允许我们迭代它们的可用状态（`up`/`down`）。让我们把这个类叫做 `CheckUrls`：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s analyze the previous code''s most important parts:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下前面代码最重要的部分：
- en: The `CheckUrls` class constructor takes as input a list of URLs. Since we now
    know how to use iterators and iterables, we can say that this list of URLs can
    be just any iterable.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CheckUrls` 类构造函数接受一个 URL 列表作为输入。由于我们现在知道如何使用迭代器和可迭代对象，我们可以说这个 URL 列表可以是任何可迭代对象。'
- en: In our `@@asyncIterator` method, we obtain an iterator from the `this.urls`
    object, which, as we just said, should be an iterable. We can do that by simply
    invoking its `@@iterable` method.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `@@asyncIterator` 方法中，我们从 `this.urls` 对象中获取一个迭代器，正如我们刚才说的，它应该是一个可迭代对象。我们可以通过简单地调用它的
    `@@iterable` 方法来实现这一点。
- en: Note how the `next()` method is now an `async` function. This means that it
    will always return a promise, as requested by the async iterable protocol.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意现在 `next()` 方法是一个 `async` 函数。这意味着它将始终返回一个承诺，这是异步可迭代协议所要求的。
- en: 'In the `next()` method, we use the `urlsIterator` to get the next URL in the
    list, unless there are no more, in which case we simply return `{done: true}`.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `next()` 方法中，我们使用 `urlsIterator` 获取列表中的下一个 URL，除非没有更多，在这种情况下，我们只需简单地返回 `{done:
    true}`。'
- en: Note how we can now use the `await` instruction to asynchronously get the result
    of the `HEAD` request sent to the current URL.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们现在可以使用 `await` 指令异步获取发送到当前 URL 的 `HEAD` 请求的结果。
- en: 'Now, let''s use the `for await...of` syntax we mentioned earlier to iterate
    over a `CheckUrls` object:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们之前提到的 `for await...of` 语法来迭代 `CheckUrls` 对象：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, the `for await...of` syntax is a very intuitive way to iterate
    over an async iterable and, as we will see in a while, it can be used in conjunction
    with some interesting built-in iterables to obtain alternative new ways to access
    asynchronous information.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`for await...of` 语法是迭代异步可迭代的一种非常直观的方式，而且正如我们很快就会看到的，它可以与一些有趣的内置可迭代对象结合使用，以获得访问异步信息的新方法。
- en: The `for await...of` loop (as well as its synchronous version) will call the
    optional `return()` method of the iterator if it's prematurely interrupted with
    a `break`, a `return`, or an `exception`. This can be used to immediately perform
    any cleanup task that would usually be performed when the iteration completes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`for await...of` 循环（以及它的同步版本）如果因为 `break`、`return` 或 `exception` 被提前中断，将会调用迭代器的可选
    `return()` 方法。这可以用来立即执行通常在迭代完成时执行的任何清理任务。'
- en: Async generators
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步生成器
- en: 'As well as async iterators, we can also have **async generators**. To define
    an **async generator function**, simply prepend the keyword `async` to the function
    definition:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异步迭代器之外，我们还可以有 **异步生成器**。要定义一个 **异步生成器函数**，只需在函数定义前加上关键字 `async`：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can well imagine, async generators allow the use of the `await` instruction
    within their body and the return value of their `next()` method is a promise that
    resolves to an object having the canonical `done` and `value` properties. This
    way, **async generator objects** are also valid async iterators. They are also
    valid async iterables, so they can be used in `for await...of` loops.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，异步生成器允许在它们的主体中使用 `await` 指令，并且它们的 `next()` 方法的返回值是一个承诺，该承诺解析为一个具有规范 `done`
    和 `value` 属性的对象。这样，**异步生成器对象**也是有效的异步迭代器。它们也是有效的异步可迭代对象，因此可以在 `for await...of`
    循环中使用。
- en: 'To demonstrate how async generators can simplify the implementation of async
    iterators, let''s convert the `CheckUrls` class we saw in the previous example
    to use an async generator:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示异步生成器如何简化异步迭代器的实现，让我们将前一个例子中看到的 `CheckUrls` 类转换为使用异步生成器：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Interestingly, using an async generator in place of a bare async iterator allowed
    us to save a few lines of code and the resulting logic is also more readable and
    explicit.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，使用异步生成器代替裸异步迭代器使我们能够节省几行代码，并且生成的逻辑也更易于阅读和明确。
- en: Async iterators and Node.js streams
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步迭代器和 Node.js 流
- en: If we stop for a second and think about the relationship between async iterators
    and Node.js readable streams, we would be surprised by how similar they are in
    both purpose and behavior. In fact, we can say that async iterators are indeed
    a stream construct, as they can be used to process the data of an asynchronous
    resource piece by piece, exactly as it happens for readable streams.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们停下来思考一下异步迭代器和 Node.js 可读流之间的关系，我们会惊讶于它们在目的和行为上的相似性。事实上，我们可以这样说，异步迭代器确实是一种流结构，因为它们可以用来逐块处理异步资源的数据，就像可读流发生的那样。
- en: It's not a coincidence that `stream.Readable` implements the `@@asyncIterator`
    method, making it an async iterable. This provides us with an additional, and
    probably even more intuitive, mechanism to read data from a readable stream, thanks
    to the `for await...of` construct.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream.Readable` 实现了 `@@asyncIterator` 方法，使其成为一个异步可迭代对象。这为我们提供了一个额外的、可能甚至更直观的机制来从可读流中读取数据，归功于
    `for await...of` 构造。'
- en: 'To quickly demonstrate this, consider the following example where we take the
    `stdin` stream of the current process and we pipe it into the `split()` transform
    stream, which will emit a new chunk when it finds a newline character. Then, we
    iterate over each line using the `for await...of` loop:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速演示这一点，考虑以下示例，其中我们取当前进程的 `stdin` 流并将其管道输入到 `split()` 转换流中，该流将在找到换行符时发出新块。然后，我们使用
    `for await...of` 循环遍历每一行：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This sample code will print back whatever we have written to the standard input
    only after we have pressed the Return key. To quit the program, you can just press
    Ctrl + C.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这段示例代码将在我们按下回车键之后，仅将我们写入标准输入的内容打印出来。要退出程序，您只需按下 Ctrl + C。
- en: As we can see, this alternative way of consuming a readable stream is indeed
    very intuitive and compact. The previous example also shows us how similar the
    two paradigms—iterators and streams—are. They are so similar that they can interoperate
    almost seamlessly. To prove this point even further, just consider that the function
    `stream.Readable.from(iterable, [options])` takes an iterable as an argument,
    which can be both synchronous or asynchronous. The function will return a readable
    stream that wraps the provided iterable, "adapting" its interface to that of a
    readable stream (this is also a good example of the Adapter pattern, which we
    have already met in *Chapter 8*, *Structural Design Patterns*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这种消费可读流的不同方式确实非常直观和紧凑。前一个例子也展示了两个范例——迭代器和流——之间的相似性。它们如此相似，以至于它们可以几乎无缝地互操作。为了进一步证明这一点，只需考虑函数
    `stream.Readable.from(iterable, [options])` 接受一个可迭代对象作为参数，它可以是同步的或异步的。该函数将返回一个包装提供的可迭代对象的可读流，"适配"其接口以符合可读流（这也是一个很好的适配器模式示例，我们在第8章的*结构型设计模式*中已经遇到过）。
- en: 'So, if streams and async iterators as so closely related, which one should
    you actually use? This, as always, depends on the use case and many other factors;
    however, to help you with the decision, this is a list of aspects that set the
    two constructs apart:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果流和异步迭代器如此紧密相关，您实际上应该使用哪一个呢？这，像往常一样，取决于用例和许多其他因素；然而，为了帮助您做出决定，这是一个列出两个构造之间差异方面的列表：
- en: Streams are *push*, meaning that data is pushed into the internal buffers by
    the stream and then consumed from the buffers. Async iterators are *pull* by default
    (unless another logic is explicitly implemented by the iterator), meaning that
    data is only retrieved/produced on demand by the consumer.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流是*推送*，意味着数据由流推入内部缓冲区，然后从缓冲区中消费。异步迭代器默认是*拉取*（除非迭代器明确实现了其他逻辑），意味着数据仅在消费者请求时检索/生成。
- en: Streams are better suited to process binary data since they natively provide
    internal buffering and backpressure.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流更适合处理二进制数据，因为它们天生提供内部缓冲和背压。
- en: Streams can be composed using a well-known and streamlined API, `pipe()`, while
    async iterators do not offer any standardized composition method.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用一个众所周知且简化的API，`pipe()`，来组合流，而异步迭代器则不提供任何标准化的组合方法。
- en: We can iterate an `EventEmitter` as well. Using the `events.on(emitter, eventName)`
    utility function, we can in fact get an async iterable whose iterator will return
    all the events matching the specified `eventName`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以迭代一个`EventEmitter`。使用`events.on(emitter, eventName)`实用函数，我们实际上可以得到一个异步可迭代对象，其迭代器将返回所有匹配指定`eventName`的事件。
- en: In the wild
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: Iterators and, in particular, async iterators are quickly gaining popularity
    in the Node.js ecosystem. In fact, in many circumstances, they are becoming a
    preferred alternative to streams and are replacing custom-built iteration mechanisms.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器和，特别是异步迭代器，在Node.js生态系统中迅速获得人气。实际上，在许多情况下，它们正在成为流和自定义迭代机制的优选替代方案。
- en: For example, the packages `@databases/pg`, `@databases/mysql` and `@databases/sqlite`
    are popular libraries for accessing Postgres, MySQL, and SQLite databases respectively
    (more at [nodejsdp.link/atdatabases](http://nodejsdp.link/atdatabases)).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`@databases/pg`、`@databases/mysql`和`@databases/sqlite`包分别是访问Postgres、MySQL和SQLite数据库的流行库（更多信息请参阅[nodejsdp.link/atdatabases](http://nodejsdp.link/atdatabases)）。
- en: 'They all expose a function called `queryStream()`, which returns an async iterable,
    which can be used to easily iterate over the results of a query. For example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都提供了一个名为`queryStream()`的函数，该函数返回一个异步可迭代对象，可以用来轻松迭代查询结果。例如：
- en: '[PRE38]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Internally, the iterator will automatically handle the cursor for a query result,
    so all we have to do is simply loop with the `for await...of` construct.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，迭代器将自动处理查询结果的游标，所以我们只需简单地使用`for await...of`构造进行循环。
- en: Another example of a library heavily relying on iterators for its API is the
    `zeromq` package ([nodejsdp.link/npm-zeromq](http://nodejsdp.link/npm-zeromq)).
    We'll see a detailed example of it in the next section, about the Middleware pattern,
    as we move on to other behavioral patterns.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在API中大量依赖迭代器的库示例是`zeromq`包（[nodejsdp.link/npm-zeromq](http://nodejsdp.link/npm-zeromq)）。我们将在下一节中看到一个关于中间件模式的详细示例，当我们继续探讨其他行为模式时。
- en: Middleware
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: One of the most distinctive patterns in Node.js is definitely **Middleware**.
    Unfortunately, it's also one of the most confusing for the inexperienced, especially
    for developers coming from the enterprise programming world. The reason for the
    disorientation is probably connected to the traditional meaning of the term middleware,
    which in enterprise architecture jargon represents the various software suites
    that help to abstract lower-level mechanisms such as OS APIs, network communications,
    memory management, and so on, allowing the developer to focus only on the business
    case of the application. In this context, the term middleware recalls topics such
    as CORBA, enterprise service bus, Spring, JBoss, and WebSphere, but in its more
    generic meaning, it can also define any kind of software layer that acts as glue
    between lower-level services and the application (literally, the *software in
    the middle*).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，最独特的模式之一无疑是**中间件**。不幸的是，它也是对经验不足的开发者来说最令人困惑的之一，尤其是对于来自企业编程世界的开发者。这种困惑的原因可能与传统中间件术语的含义有关，在企业架构术语中，它代表各种帮助抽象底层机制（如OS
    API、网络通信、内存管理等）的软件套件，使开发者能够只关注应用程序的业务案例。在这种情况下，中间件术语会让人联想到CORBA、企业服务总线、Spring、JBoss和WebSphere等主题，但在其更通用的含义中，它也可以定义任何充当底层服务和应用程序之间粘合剂的软件层（字面上，是*中间的软件*）。
- en: Middleware in Express
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Express中的中间件
- en: Express ([nodejsdp.link/express](http://nodejsdp.link/express)) popularized
    the term middleware in the Node.js world, binding it to a very specific design
    pattern. In Express, in fact, middleware represents a set of services, typically
    functions, that are organized in a pipeline and are responsible for processing
    incoming HTTP requests and relative responses.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Express（[nodejsdp.link/express](http://nodejsdp.link/express)）在Node.js世界中普及了中间件术语，将其绑定到一个非常具体的设计模式。在Express中，实际上，中间件代表一组服务，通常是函数，它们组织在一个管道中，并负责处理传入的HTTP请求及其相关响应。
- en: Express is famous for being a very non-opinionated and minimalist web framework
    and the Middleware pattern is the main reason for that. Express middleware is,
    in fact, an effective strategy for allowing developers to easily create and distribute
    new features that can be easily added to an application, without the need to grow
    the minimalistic core of the framework.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Express因其非常非侵入性和最小化而闻名，中间件模式是主要原因。实际上，Express中间件是一种有效的策略，允许开发者轻松创建和分发新功能，这些功能可以轻松添加到应用程序中，而无需扩展框架的最小化核心。
- en: 'An Express middleware has the following signature:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Express中间件的签名如下：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, `req` is the incoming HTTP request, `res` is the response, and `next` is
    the callback to be invoked when the current middleware has completed its tasks,
    and that in turn triggers the next middleware in the pipeline.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`req` 是传入的HTTP请求，`res` 是响应，而 `next` 是当当前中间件完成其任务时被调用的回调，这反过来又触发了管道中的下一个中间件。
- en: 'Examples of the tasks carried out by Express middleware include the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Express中间件执行的任务示例包括以下内容：
- en: Parsing the body of the request
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析请求体
- en: Compressing/decompressing requests and responses
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩/解压缩请求和响应
- en: Producing access logs
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成访问日志
- en: Managing sessions
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理会话
- en: Managing encrypted cookies
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理加密的Cookies
- en: Providing **Cross-Site Request Forgery** (**CSRF**) protection
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供跨站请求伪造（**CSRF**）保护
- en: If we think about it, these are all tasks that are not strictly related to the
    main business logic of an application, nor are they essential parts of the minimal
    core of a web server. They are accessories, components providing support to the
    rest of the application and allowing the actual request handlers to focus only
    on their main business logic. Essentially, those tasks are "software in the middle."
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考，这些都是与应用程序的主要业务逻辑不严格相关的任务，也不是Web服务器最小核心的必要部分。它们是配件，为应用程序的其余部分提供支持，并允许实际的请求处理器只关注它们的主要业务逻辑。本质上，这些任务是“中间的软件。”
- en: Middleware as a pattern
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件作为一种模式
- en: The technique used to implement middleware in Express is not new, in fact, it
    can be considered the Node.js incarnation of the **Intercepting Filter** pattern and
    the **Chain of Responsibility** pattern. In more generic terms, it also represents
    a processing **pipeline**, which reminds us of streams. Today, in Node.js, the
    word middleware is used well beyond the boundaries of the Express framework, and
    indicates a particular pattern whereby a set of processing units, filters, and
    handlers, under the form of functions, are connected to form an asynchronous sequence
    in order to perform the preprocessing and postprocessing of any kind of data.
    The main advantage of this pattern is *flexibility*. In fact, the Middleware pattern
    allows us to obtain a plugin infrastructure with incredibly little effort, providing
    an unobtrusive way to extend a system with new filters and handlers.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express中实现中间件的技术并不新颖，实际上，它可以被认为是Node.js版本的拦截过滤器（**Intercepting Filter**）模式和责任链（**Chain
    of Responsibility**）模式。用更通用的术语来说，它也代表了一种处理**管道**，这让我们想起了流。今天，在Node.js中，中间件这个词的使用已经远远超出了Express框架的边界，它指代了一种特定的模式，即通过将一组处理单元、过滤器和处理程序以函数的形式连接起来，形成一个异步序列，以执行任何类型数据的预处理和后处理。这种模式的主要优势是**灵活性**。事实上，中间件模式允许我们以极小的努力获得一个插件基础设施，提供了一种无侵入性的方法来扩展系统，添加新的过滤器和处理程序。
- en: 'If you want to know more about the Intercepting Filter pattern, the following
    article is a good starting point: [nodejsdp.link/intercepting-filter](http://nodejsdp.link/intercepting-filter).
    Similarly, a nice overview of the Chain of Responsibility pattern is available
    at this URL: [nodejsdp.link/chain-of-responsibility](http://nodejsdp.link/chain-of-responsibility).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于拦截过滤器（**Intercepting Filter**）模式的信息，以下文章是一个很好的起点：[nodejsdp.link/intercepting-filter](http://nodejsdp.link/intercepting-filter)。同样，在以下URL上也有关于责任链（**Chain
    of Responsibility**）模式的良好概述：[nodejsdp.link/chain-of-responsibility](http://nodejsdp.link/chain-of-responsibility)。
- en: 'The following diagram shows the components of the Middleware pattern:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了中间件模式的组件：
- en: '![](img/B15729_09_05.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15729_09_05.png)'
- en: 'Figure 9.5: The structure of the Middleware pattern'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：中间件模式的结构
- en: 'The essential component of the pattern is the **Middleware Manager**, which
    is responsible for organizing and executing the middleware functions. The most
    important implementation details of the pattern are as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的核心组件是**中间件管理器**，它负责组织和执行中间件函数。模式最重要的实现细节如下：
- en: New middleware can be registered by invoking the `use()` function (the name
    of this function is a common convention in many implementations of the Middleware
    pattern, but we can choose any name). Usually, new middleware can only be appended
    at the end of the pipeline, but this is not a strict rule.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的中间件可以通过调用`use()`函数（这个函数的名称是许多中间件模式实现中的常见约定，但我们可以选择任何名称）进行注册。通常，新的中间件只能附加到管道的末尾，但这不是一条严格的规则。
- en: When new data is received for processing, the registered middleware is invoked
    in an asynchronous sequential execution flow. Each unit in the pipeline receives
    the result of the execution of the previous unit as input.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收到新的数据处理时，注册的中间件会在异步顺序执行流中调用。管道中的每个单元都接收前一个单元执行的结果作为输入。
- en: Each piece of middleware can decide to stop further processing of the data.
    This can be done by invoking a special function, by not invoking the callback
    (in case the middleware uses callbacks), or by propagating an error. An error
    situation usually triggers the execution of another sequence of middleware that
    is specifically dedicated to handling errors.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个中间件都可以决定停止进一步处理数据。这可以通过调用一个特殊函数、不调用回调（如果中间件使用回调的话），或者通过传播一个错误来实现。错误情况通常触发另一个专门用于处理错误的中间件序列的执行。
- en: 'There is no strict rule on how the data is processed and propagated in the
    pipeline. The strategies for propagating the data modifications in the pipeline
    include:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道中处理和传播数据没有严格的规则。在管道中传播数据修改的策略包括：
- en: Augmenting the data received as input with additional properties or functions
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为输入数据增加额外的属性或函数
- en: Maintaining the immutability of the data and always return fresh copies as the
    result of the processing
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护数据的不变性，并始终返回处理结果的新副本
- en: The right approach depends on the way the Middleware Manager is implemented
    and on the type of processing carried out by the middleware itself.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法取决于中间件管理器的实现方式以及中间件本身执行的处理类型。
- en: Creating a middleware framework for ZeroMQ
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为ZeroMQ创建一个中间件框架
- en: Let's now demonstrate the pattern by building a middleware framework around
    the **ZeroMQ** ([nodejsdp.link/zeromq](http://nodejsdp.link/zeromq)) messaging
    library. ZeroMQ (also known as ZMQ, or ØMQ) provides a simple interface for exchanging
    atomic messages across the network using a variety of protocols. It shines for
    its performance, and its basic set of abstractions are specifically built to facilitate
    the implementation of custom messaging architectures. For this reason, ZeroMQ
    is often chosen to build complex distributed systems.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过构建围绕**ZeroMQ**（[nodejsdp.link/zeromq](http://nodejsdp.link/zeromq)）消息库的中间件框架来演示这个模式。ZeroMQ（也称为ZMQ或ØMQ）提供了一种简单接口，用于使用各种协议在网络中交换原子消息。它以其性能而闻名，其基本抽象集是专门构建来简化自定义消息架构的实现。因此，ZeroMQ经常被选择来构建复杂的分布式系统。
- en: In *Chapter 13*, *Messaging and Integration Patterns*, we will have the chance
    to analyze the features of ZeroMQ in more detail.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13章“消息和集成模式”中，我们将有机会更详细地分析ZeroMQ的功能。
- en: The interface of ZeroMQ is pretty low-level as it only allows us to use strings
    and binary buffers for messages. So, any encoding or custom formatting of data
    has to be implemented by the users of the library.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroMQ的接口相当低级，因为它只允许我们使用字符串和二进制缓冲区作为消息。因此，任何编码或自定义数据格式化都必须由库的用户实现。
- en: In the next example, we are going to build a middleware infrastructure to abstract
    the preprocessing and postprocessing of the data passing through a ZeroMQ socket,
    so that we can transparently work with JSON objects, but also seamlessly compress
    messages traveling over the wire.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将构建一个中间件基础设施来抽象通过ZeroMQ套接字传输的数据的前处理和后处理，这样我们就可以透明地处理JSON对象，同时无缝压缩通过网络传输的消息。
- en: The Middleware Manager
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间件管理器
- en: 'The first step toward building a middleware infrastructure around ZeroMQ is
    to create a component that is responsible for executing the middleware pipeline
    when a new message is received or sent. For this purpose, let''s create a new
    module called `zmqMiddlewareManager.js` and let''s define it:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 建立围绕ZeroMQ的中间件基础设施的第一步是创建一个组件，当接收到或发送新消息时负责执行中间件管道。为此，让我们创建一个新的模块，命名为`zmqMiddlewareManager.js`，并定义它：
- en: '[PRE40]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s discuss in detail how we implemented our `ZmqMiddlewareManager`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论我们如何实现我们的`ZmqMiddlewareManager`：
- en: In the first part of the class, we define the constructor that accepts a ZeroMQ
    socket as an argument. In the constructor, we create two empty lists that will
    contain our middleware functions, one for inbound messages and another one for
    outbound messages. Next, we immediately start processing the messages coming from
    the socket. We do that in the `handleIncomingMessages()` method.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的第一部分，我们定义了一个构造函数，该构造函数接受一个 ZeroMQ 套接字作为参数。在构造函数中，我们创建了两个空列表，将包含我们的中间件函数，一个用于入站消息，另一个用于出站消息。接下来，我们立即开始处理来自套接字的消息。我们在
    `handleIncomingMessages()` 方法中这样做。
- en: In the `handleIncomingMessages()` method, we use the ZeroMQ socket as an async
    iterable and with a `for await...of` loop, we process any incoming message and
    we pass it down the `inboundMiddleware` list of middlewares.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `handleIncomingMessages()` 方法中，我们使用 ZeroMQ 套接字作为异步可迭代对象，并通过 `for await...of`
    循环处理任何传入的消息，并将其传递给中间件的 `inboundMiddleware` 列表。
- en: Similarly to `handleIncomingMessages()`, the `send()` method will pass the `message`
    received as an argument down the `outboundMiddleware` pipeline. The result of
    the processing is stored in the `finalMessage` variable and then sent through
    the socket.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 `handleIncomingMessages()` 类似，`send()` 方法将传入的 `message` 参数传递给 `outboundMiddleware`
    管道。处理的结果存储在 `finalMessage` 变量中，然后通过套接字发送。
- en: The `use()` method is used for appending new middleware functions to our internal
    pipelines. In our implementation, each middleware comes in pairs; it's an object
    that contains two properties, `inbound` and `outbound`. Each property can be used
    to define the middleware function to be added to the respective list. It's important
    to observe here that the inbound middleware is pushed to the end of the `inboundMiddleware`
    list, while the outbound middleware is inserted (using `unshift()`) at the beginning
    of the `outboundMiddleware` list. This is because complementary inbound/outbound
    middleware functions usually need to be executed in inverted order. For example,
    if we want to decompress and then deserialize an inbound message using JSON, it
    means that for the outbound, we should instead first serialize and then compress.
    This convention for organizing the middleware in pairs is not strictly part of
    the general pattern, but only an implementation detail of our specific example.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`use()` 方法用于将新的中间件函数添加到我们的内部管道中。在我们的实现中，每个中间件都是成对出现的；它是一个包含两个属性的对象，分别是 `inbound`
    和 `outbound`。每个属性都可以用来定义要添加到相应列表中的中间件函数。在此需要注意的是，入站中间件被推送到 `inboundMiddleware`
    列表的末尾，而出站中间件则是通过 `unshift()` 方法插入到 `outboundMiddleware` 列表的开头。这是因为互补的入站/出站中间件函数通常需要以相反的顺序执行。例如，如果我们想使用
    JSON 对入站消息进行解压缩然后反序列化，那么对于出站来说，我们应该首先进行序列化然后压缩。这种将中间件成对组织的约定并不是通用模式的严格部分，而只是我们特定示例的实现细节。'
- en: The last method, `executeMiddleware()`, represents the core of our component
    as it's the part responsible for executing the middleware functions. Each function
    in the `middleware` array received as input is executed one after the other, and
    the result of the execution of a middleware function is passed to the next. Note
    that we are using the `await` instruction on each result returned by each middleware
    function; this allows the middleware function to return a value synchronously
    as well as asynchronously using a promise. Finally, the result of the last middleware
    function is returned back to the caller.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个方法 `executeMiddleware()` 代表了我们组件的核心，因为它负责执行中间件函数。作为输入接收到的 `middleware` 数组中的每个函数依次执行，并且中间件函数执行的输出传递给下一个函数。请注意，我们在每个中间件函数返回的每个结果上使用
    `await` 指令；这允许中间件函数同步地返回一个值，也可以使用承诺异步返回。最后，最后一个中间件函数的输出返回给调用者。
- en: For brevity, we are not supporting an error middleware pipeline. Normally, when
    a middleware function propagates an error, another set of middleware functions
    specifically dedicated to handling errors is executed. This can be easily implemented
    using the same technique that we are demonstrating here. For instance, we could
    accept an extra (optional) `errorMiddleware` function in addition to `inboundMiddleware`
    and `outboundMiddleware`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我们不支持错误中间件管道。通常，当一个中间件函数传播错误时，会执行另一组专门用于处理错误的中间件函数。这可以通过我们在这里展示的相同技术轻松实现。例如，我们可以在
    `inboundMiddleware` 和 `outboundMiddleware` 之外接受一个额外的（可选的）`errorMiddleware` 函数。
- en: Implementing the middleware to process messages
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现中间件以处理消息
- en: 'Now that we have implemented our Middleware Manager, we can create our first
    pair of middleware functions to demonstrate how to process inbound and outbound
    messages. As we said, one of the goals of our middleware infrastructure is to
    have a filter that serializes and deserializes JSON messages. So, let''s create
    a new middleware to take care of this. In a new module called `jsonMiddleware.js`,
    let''s include the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了我们的中间件管理器，我们可以创建我们的第一对中间件函数来演示如何处理输入和输出消息。正如我们所说，我们中间件基础设施的一个目标是有过滤功能来序列化和反序列化
    JSON 消息。因此，让我们创建一个新的中间件来处理这个问题。在一个名为 `jsonMiddleware.js` 的新模块中，让我们包含以下代码：
- en: '[PRE41]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The inbound part of our middleware deserializes the message received as input,
    while the outbound part serializes the data into a string, which is then converted
    into a buffer.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中间件的输入部分将接收到的消息反序列化为输入，而输出部分将数据序列化为字符串，然后将其转换为缓冲区。
- en: 'In a similar way, we can implement a pair of middleware functions in a file
    called `zlibMiddleware.js`, to inflate/deflate the message using the `zlib` core
    module ([nodejsdp.link/zlib](http://nodejsdp.link/zlib)):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以在名为 `zlibMiddleware.js` 的文件中实现一对中间件函数，用于使用 `zlib` 核心模块（[nodejsdp.link/zlib](http://nodejsdp.link/zlib)）来压缩/解压缩消息：
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Compared to the JSON middleware, our zlib middleware functions are asynchronous
    and return a promise as a result. As we already know, this is perfectly supported
    by our Middleware Manager.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JSON 中间件相比，我们的 zlib 中间件函数是异步的，并返回一个 promise 作为结果。正如我们所知，这完全由我们的中间件管理器支持。
- en: You can note how the middleware used by our framework is quite different from
    the one used in Express. This is totally normal and a perfect demonstration of
    how we can adapt this pattern to fit our specific needs.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到我们框架使用的中间件与 Express 中使用的中间件相当不同。这是完全正常的，并且完美地展示了我们如何将此模式适应我们的特定需求。
- en: Using the ZeroMQ middleware framework
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ZeroMQ 中间件框架
- en: We are now ready to use the middleware infrastructure that we just created.
    To do that, we are going to build a very simple application, with a client sending
    a *ping* to a server at regular intervals and the server echoing back the message
    received.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用我们刚刚创建的中间件基础设施。为此，我们将构建一个非常简单的应用程序，其中客户端以固定的时间间隔向服务器发送一个 *ping*，服务器则回显接收到的消息。
- en: From an implementation perspective, we are going to rely on a Request/Reply
    messaging pattern using the req/rep socket pair provided by ZeroMQ ([nodejsdp.link/zmq-req-rep](http://nodejsdp.link/zmq-req-rep)).
    We will then wrap the sockets with our `ZmqMiddlewareManager` to get all the advantages
    from the middleware infrastructure that we built, including the middleware for
    serializing/deserializing JSON messages.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现的角度来看，我们将依赖于使用 ZeroMQ 提供的 req/rep 套接字对实现的请求/回复消息模式。然后我们将套接字包裹在我们的 `ZmqMiddlewareManager`
    中，以获得我们构建的中间件基础设施的所有优势，包括用于序列化和反序列化 JSON 消息的中间件。
- en: We'll analyze the Request/Reply pattern and other messaging patterns in *Chapter
    13*, *Messaging and Integration Patterns*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第 13 章*，*消息和集成模式*中分析请求/回复模式和其他消息模式。
- en: The server
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务器
- en: 'Let''s start by creating the server-side of our application in a file called
    `server.js`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `server.js` 的文件中的服务器端应用程序开始：
- en: '[PRE43]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The server-side of our application works as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的客户端部分工作如下：
- en: We first load the necessary dependencies. The `zeromq` package is essentially
    a JavaScript interface over the native ZeroMQ library. See [nodejsdp.link/npm-zeromq](http://nodejsdp.link/npm-zeromq).
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先加载必要的依赖。`zeromq` 包本质上是一个基于原生 ZeroMQ 库的 JavaScript 接口。参见 [nodejsdp.link/npm-zeromq](http://nodejsdp.link/npm-zeromq)。
- en: Next, in the `main()` function, we create a new ZeroMQ `Reply` socket and bind
    it to port `5000` on localhost.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `main()` 函数中，我们创建一个新的 ZeroMQ `Reply` 套接字并将其绑定到本地的 `5000` 端口。
- en: Then comes the part where we wrap ZeroMQ with our middleware manager and then
    add the zlib and JSON middlewares.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是包裹 ZeroMQ 和我们的中间件管理器，然后添加 zlib 和 JSON 中间件的步骤。
- en: Finally, we are ready to handle a request coming from the client. We will do this
    by simply adding another middleware, this time using it as a request handler.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们准备好处理来自客户端的请求。我们将通过简单地添加另一个中间件来完成这项工作，这次我们将使用它作为请求处理器。
- en: Since our request handler comes after the zlib and JSON middlewares, we will
    receive a decompressed and deserialized version of the received message. On the
    other hand, any data passed to `send()` will be processed by the outbound middleware,
    which in our case will serialize and then compress the data.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的请求处理程序位于zlib和JSON中间件之后，我们将收到已解压缩和反序列化的接收消息。另一方面，传递给`send()`的任何数据都将由出站中间件处理，在我们的例子中，它将序列化然后压缩数据。
- en: The client
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 客户端
- en: 'On the client-side of our little application, in a file called `client.js`,
    we will have the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小应用程序的客户端部分，在一个名为`client.js`的文件中，我们将有以下代码：
- en: '[PRE44]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Most of the code of the client application is very similar to that of the server.
    The notable differences are:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序的大部分代码与服务器非常相似。明显的差异是：
- en: We create a `Request` socket, rather than a `Reply` socket, and we connect it
    to a remote (or local) host rather than binding it on a local port. The rest of
    the middleware setup is exactly the same as in the server, except for the fact
    that our request handler now just prints any message it receives. Those messages
    should be the *pong* reply to our *ping* requests.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个`Request`套接字，而不是`Reply`套接字，并将其连接到远程（或本地）主机，而不是绑定到本地端口。中间件设置的其余部分与服务器上的设置完全相同，只是我们的请求处理程序现在只是打印它接收到的任何消息。这些消息应该是我们对`ping`请求的*pong*回复。
- en: The core logic of the client application is a timer that sends a *ping* message
    every second.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序的核心逻辑是一个定时器，每秒发送一个*ping*消息。
- en: 'Now, we''re ready to try our client/server pair and see the application in
    action. First, start the server:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好尝试我们的客户端/服务器对，并看到应用程序的实际运行。首先，启动服务器：
- en: '[PRE45]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can then start the client in another terminal with the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在另一个终端中使用以下命令启动客户端：
- en: '[PRE46]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: At this point, we should see the client sending messages and the server echoing
    them back.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该看到客户端正在发送消息，服务器正在回显它们。
- en: Our middleware framework did its job. It allowed us to decompress/compress and
    deserialize/serialize our messages transparently, leaving the handlers free to
    focus on their business logic.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的中间件框架完成了它的任务。它允许我们透明地解压缩/压缩和反序列化/序列化我们的消息，从而让处理程序可以自由地专注于它们的业务逻辑。
- en: In the wild
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: We opened this section by saying that the library that popularized the Middleware
    pattern in Node.js is Express ([nodejsdp.link/express](http://nodejsdp.link/express)).
    So, we can easily say that Express is also the most notable example of the Middleware
    pattern out there.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在介绍本节时提到，在Node.js中普及中间件模式的库是Express ([nodejsdp.link/express](http://nodejsdp.link/express))。因此，我们可以轻松地说，Express也是中间件模式最著名的例子之一。
- en: 'Two other interesting examples are:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个有趣的例子是：
- en: Koa ([nodejsdp.link/koa](http://nodejsdp.link/koa)), which is known as the successor
    of Express. It was created by the same team behind Express and it shares with
    it its philosophy and main design principles. Koa's middleware is slightly different
    than that of Express since it uses modern programming techniques such as async/await
    instead of callbacks.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Koa ([nodejsdp.link/koa](http://nodejsdp.link/koa))，被称为Express的继任者。它是由Express背后的同一团队创建的，并且与它共享其哲学和主要设计原则。Koa的中间件与Express略有不同，因为它使用现代编程技术，如async/await，而不是回调。
- en: Middy ([nodejsdp.link/middy](http://nodejsdp.link/middy)) is a classic example
    of the Middleware pattern applied to something different than a web framework.
    Middy is, in fact, a middleware engine for AWS Lambda functions.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Middy ([nodejsdp.link/middy](http://nodejsdp.link/middy))是中间件模式应用于不同于Web框架的典型例子。实际上，Middy是AWS
    Lambda函数的中间件引擎。
- en: Next, we are going to explore the Command pattern, which, as we will see shortly,
    is a very flexible and multiform pattern.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨命令模式，正如我们很快就会看到的，这是一个非常灵活和多样化的模式。
- en: Command
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: 'Another design pattern with huge importance in Node.js is **Command**. In its
    most generic definition, we can consider a command any object that encapsulates
    all the information necessary to perform an action at a later time. So, instead
    of invoking a method or a function directly, we create an object representing
    the intention to perform such an invocation. It will then be the responsibility
    of another component to materialize the intent, transforming it into an actual
    action. Traditionally, this pattern is built around four major components, as
    shown in *Figure 9.6*:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中具有巨大重要性的另一个设计模式是**命令**。在其最通用的定义中，我们可以将任何封装了在以后某个时间执行操作所需所有信息的对象视为命令。因此，我们不是直接调用方法或函数，而是创建一个表示执行此类调用的意图的对象。然后，将负责将意图具体化为实际操作的另一个组件。传统上，此模式围绕四个主要组件构建，如图
    9.6 所示：
- en: '![](img/B15729_09_06.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15729_09_06.png)'
- en: 'Figure 9.6: The components of the Command pattern'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：命令模式的组件
- en: 'The typical configuration of the Command pattern can be described as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的典型配置可以描述如下：
- en: '**Command** is the object encapsulating the information necessary to invoke
    a method or function.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**是封装了调用方法或函数所需信息的对象。'
- en: '**Client** is the component that creates the command and provides it to the
    invoker.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**是创建命令并将其提供给调用者的组件。'
- en: '**Invoker** is the component responsible for executing the command on the target.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用者**是负责在目标上执行命令的组件。'
- en: '**Target** (or **receiver**) is the subject of the invocation. It can be a
    lone function or a method of an object.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**（或**接收者**）是调用的主题。它可以是单独的函数或对象的某个方法。'
- en: As we will see, these four components can vary a lot depending on the way we
    want to implement the pattern. This should not sound new at this point.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，这四个组件可以根据我们想要实现模式的方式有很大的不同。这一点现在不应该听起来很新鲜。
- en: 'Using the Command pattern instead of directly executing an operation has several
    applications:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令模式而不是直接执行操作有几种应用：
- en: A command can be scheduled for execution at a later time.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以安排命令在以后的时间执行。
- en: A command can be easily serialized and sent over the network. This simple property
    allows us to distribute jobs across remote machines, transmit commands from the
    browser to the server, create **remote procedure call** (**RPC**) systems, and
    so on.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令可以轻松序列化并通过网络发送。这个简单的属性使我们能够将工作分配到远程机器上，从浏览器传输命令到服务器，创建 **远程过程调用**（RPC）系统等。
- en: Commands make it easy to keep a history of all the operations executed on a
    system.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令使得记录系统上执行的所有操作的历史变得容易。
- en: Commands are an important part of some algorithms for data synchronization and
    conflict resolution.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令是某些数据同步和冲突解决算法的重要组成部分。
- en: A command scheduled for execution can be canceled if it's not yet executed.
    It can also be reverted (undone), bringing the state of the application to the
    point before the command was executed.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个命令尚未执行，则可以取消其执行。它还可以被撤销（取消），将应用程序的状态恢复到命令执行之前。
- en: Several commands can be grouped together. This can be used to create atomic
    transactions or to implement a mechanism whereby all the operations in the group
    are executed at once.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将几个命令组合在一起。这可以用来创建原子事务，或者实现一种机制，使得组内的所有操作可以同时执行。
- en: Different kinds of transformation can be performed on a set of commands, such
    as duplicate removal, joining and splitting, or applying more complex algorithms
    such as **operational transformation** (**OT**), which is the base for most of
    today's real-time collaborative software, such as collaborative text editing.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对一组命令执行不同的转换，例如删除重复项、连接和拆分，或者应用更复杂的算法，如**操作转换**（OT），它是大多数今天实时协作软件（如协作文本编辑）的基础。
- en: A great explanation of how OT works can be found at [nodejsdp.link/operational-transformation](http://nodejsdp.link/operational-transformation).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [nodejsdp.link/operational-transformation](http://nodejsdp.link/operational-transformation)
    找到关于 OT（操作转换）工作原理的精彩解释。
- en: The preceding list clearly shows us how important this pattern is, especially
    on a platform such as Node.js where networking and asynchronous execution are
    essential players.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表清楚地表明了此模式的重要性，尤其是在像 Node.js 这样的平台上，网络和异步执行是关键玩家。
- en: Now, we are going to explore in more detail a couple of different implementations
    of the Command pattern, just to give you an idea of its scope.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更详细地探讨几种不同的命令模式实现，以便给您一个关于其范围的概念。
- en: The Task pattern
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务模式
- en: 'We can start off with the most basic and trivial implementation of the Command
    pattern: the **Task pattern**. The easiest way in JavaScript to create an object
    representing an invocation is, of course, by creating a closure around a function
    definition or a **bound function**:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从最基本且最简单的命令模式实现开始：**任务模式**。在JavaScript中创建一个表示调用的对象的最简单方法当然是创建一个围绕函数定义或**绑定函数**的闭包：
- en: '[PRE47]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is (mostly) equivalent to doing:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这（大部分）等同于执行：
- en: '[PRE48]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This should not look new at all. In fact, we have used this pattern already
    so many times throughout the book, and in particular in *Chapter 4*, *Asynchronous
    Control Flow Patterns with Callbacks*. This technique allowed us to use a separate
    component to control and schedule the execution of our tasks, which is essentially
    equivalent to the invoker of the Command pattern.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来一点也不新。事实上，我们在整本书中已经多次使用过这种模式，特别是在*第4章*，*使用回调的异步控制流模式*。这项技术使我们能够使用一个单独的组件来控制和调度我们的任务执行，这本质上等同于命令模式的调用者。
- en: A more complex command
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更复杂的命令
- en: 'Let''s now work on a more articulated example leveraging the Command pattern.
    This time, we want to support *undo* and *serialization*. Let''s start with the *target* of
    our commands, a little object that is responsible for sending status updates to
    a Twitter-like service. We will use a mockup of such a service for simplicity
    (the `statusUpdateService.js` file):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理一个更具体的例子，利用命令模式。这次，我们想要支持*撤销*和*序列化*。让我们从命令的*目标*开始，这是一个负责向类似Twitter的服务发送状态更新的小对象。我们将使用这样一个服务的模拟以简化（`statusUpdateService.js`文件）：
- en: '[PRE49]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `statusUpdateService` we just created represents the target of our Command
    pattern. Now, let''s implement a factory function that creates a command to represent
    the posting of a new status update. We''ll do that in a file called `createPostStatusCmd.js`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的`statusUpdateService`代表了我们的命令模式的目标。现在，让我们实现一个工厂函数，用于创建一个命令来表示发布新的状态更新。我们将在一个名为`createPostStatusCmd.js`的文件中完成这项工作：
- en: '[PRE50]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The preceding function is a factory that produces commands to model "post status"
    intentions. Each command implements the following three functionalities:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数是一个工厂，它产生命令来模拟“发布状态”意图。每个命令实现了以下三个功能：
- en: A `run()` method that, when invoked, will trigger the action. In other words,
    it implements the *Task* pattern that we have seen before. The command, when executed,
    will post a new status update using the methods of the target service.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`run()`方法，当被调用时，将触发动作。换句话说，它实现了我们之前看到的*任务*模式。命令在执行时将使用目标服务的方 法发布新的状态更新。
- en: An `undo()` method that reverts the effects of the *post* operation. In our
    case, we are simply invoking the `destroyUpdate()` method on the target service.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`undo()`方法，它将撤销*发布*操作的效果。在我们的例子中，我们只是调用目标服务的`destroyUpdate()`方法。
- en: A `serialize()` method that builds a JSON object that contains all the necessary
    information to reconstruct the same command object.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`serialize()`方法，它构建一个包含所有必要信息以重建相同命令对象的JSON对象。
- en: 'After this, we can build an invoker. We can start by implementing its constructor
    and its `run()` method (the `invoker.js` file):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以构建一个调用者。我们可以从实现其构造函数和`run()`方法（`invoker.js`文件）开始：
- en: '[PRE51]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `run()` method is the basic functionality of our `Invoker`. It is responsible
    for saving the command into the `history` instance variable and then triggering
    the execution of the command itself.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`方法是我们的`Invoker`的基本功能。它负责将命令保存到`history`实例变量中，然后触发命令本身的执行。'
- en: 'Next, we can add to the `Invoker` a new method that delays the execution of
    a command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在`Invoker`中添加一个新的方法，以延迟命令的执行：
- en: '[PRE52]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we can implement an `undo()` method that reverts the last command:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以实现一个`undo()`方法，它将撤销最后一个命令：
- en: '[PRE53]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we also want to be able to run a command on a remote server, by serializing
    and then transferring it over the network using a web service:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还想能够通过序列化和通过网络使用Web服务将其传输来在远程服务器上运行一个命令：
- en: '[PRE54]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that we have the command, the invoker, and the target, the only component
    missing is the client, which we will implement in a file called `client.js`. Let''s
    start by importing all the necessary dependencies and by instantiating `Invoker`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了命令、调用者和目标，唯一缺少的组件是客户端，我们将在一个名为`client.js`的文件中实现它。让我们首先导入所有必要的依赖项，并实例化`Invoker`：
- en: '[PRE55]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, we can create a command using the following line of code:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码行创建一个命令：
- en: '[PRE56]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We now have a command representing the posting of a status message. We can
    then decide to dispatch it immediately:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个表示发布状态消息的命令。然后我们可以决定立即分发它：
- en: '[PRE57]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Oops, we made a mistake, let''s revert our timeline to the state it was before
    posting the last message:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们犯了一个错误，让我们将时间线回滚到发布最后一条消息之前的状态：
- en: '[PRE58]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can also decide to schedule the message to be sent in 3 seconds from now:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以决定将消息发送的时间安排在3秒后：
- en: '[PRE59]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Alternatively, we can distribute the load of the application by migrating the
    task to another machine:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过将任务迁移到另一台机器来分散应用程序的负载：
- en: '[PRE60]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The little example that we have just implemented shows how wrapping an operation
    in a command can open a world of possibilities, and that's just the tip of the
    iceberg.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现的这个小例子展示了将操作封装在命令中可以开启无限可能，而这只是冰山一角。
- en: As the last remarks, it is worth noting that a fully-fledged Command pattern
    should be used only when strictly necessary. We saw, in fact, how much additional
    code we had to write to simply invoke a method of the `statusUpdateService`. If
    all that we need is only an invocation, then a complex command would be overkill.
    If, however, we need to schedule the execution of a task or run an asynchronous
    operation, then the simpler *Task pattern* offers the best compromise. If instead,
    we need more advanced features such as undo support, transformations, conflict
    resolution, or one of the other fancy use cases that we described previously,
    using a more complex representation for the command is almost necessary.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的备注是，值得注意，只有在绝对必要时才应使用完整的命令模式。实际上，我们看到为了简单地调用`statusUpdateService`的方法，我们不得不编写多少额外的代码。如果我们需要的只是调用，那么复杂的命令就过于冗余了。然而，如果我们需要安排任务的执行或运行异步操作，那么更简单的*任务模式*提供了最佳折衷方案。如果相反，我们需要更高级的功能，如撤销支持、转换、冲突解决或我们之前描述的其他一些复杂用例，那么使用更复杂的命令表示几乎是必要的。
- en: Summary
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We opened this chapter with three closely related patterns, which are Strategy,
    State, and Template.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以三个紧密相关的模式开始了这一章，它们是策略（Strategy）、状态（State）和模板（Template）。
- en: Strategy allows us to extract the common parts of a family of closely related
    components into a component called the context and allows us to define strategy
    objects that the context can use to implement specific behaviors. The State pattern
    is a variation of the Strategy pattern where the strategies are used to model
    the behavior of a component when under different states. The Template pattern,
    instead, can be considered the "static" version of the Strategy pattern, where
    the different specific behaviors are implemented as subclasses of the template
    class, which models the common parts of the component.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 策略允许我们将一组紧密相关组件的共同部分提取到一个称为上下文的组件中，并允许我们定义上下文可以使用以实现特定行为的策略对象。状态模式是策略模式的一种变体，其中策略用于模拟组件在不同状态下的行为。而模板模式，则可以被认为是策略模式的“静态”版本，其中不同的特定行为作为模板类的子类实现，该模板类模拟了组件的共同部分。
- en: Next, we learned about what has now become a core pattern in Node.js, which
    is Iterator. We learned how JavaScript offers native support for the pattern (with
    the iterator and iterable protocols), and how async iterators can be used as an
    alternative to complex async iteration patterns and even to Node.js streams.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们了解了现在已成为Node.js核心模式的迭代器（Iterator）。我们学习了JavaScript如何提供对这种模式的原生支持（通过迭代器和可迭代协议），以及如何使用异步迭代器作为复杂异步迭代模式甚至Node.js流的替代方案。
- en: Then, we examined Middleware, which is a very distinctive pattern born from
    within the Node.js ecosystem. We learned how it can be used to preprocess and
    postprocess data and requests.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了中间件（Middleware），这是一个源自Node.js生态系统的非常独特的模式。我们学习了如何使用它来预处理和后处理数据和请求。
- en: Finally, we had a taste of the possibilities offered by the Command pattern,
    which can be used to implement a myriad of functionality, from simple undo/redo
    and serialization, to more complex operational transformation algorithms.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们尝到了命令模式提供的可能性，它可以用来实现从简单的撤销/重做和序列化到更复杂的操作转换算法的无数功能。
- en: We have now arrived at the end of the last chapter dedicated to "traditional"
    design patterns. By now, you should have added to your toolbelt a series of patterns
    that will be enormously useful in your everyday programming endeavors.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经到达了最后一章“传统”设计模式的结尾。到现在为止，你应该已经为你的工具箱增加了一系列将在日常编程工作中非常有用的模式。
- en: In the next chapter, we'll shift our attention to a topic that goes beyond the
    boundaries of server-side development. Thanks to Node.js, in fact, we can create
    "Universal" JavaScript applications, or in other words, applications that can
    run as seamlessly on the server as they run on the browser. Stay tuned, then,
    to learn about the most useful Universal JavaScript patterns.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把注意力转向一个超越服务器端开发边界的主题。实际上，多亏了 Node.js，我们可以创建“通用”JavaScript 应用程序，换句话说，这些应用程序可以在服务器上无缝运行，就像在浏览器上运行一样。那么，请继续关注，了解最有用的通用
    JavaScript 模式。
- en: Exercises
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Exercise 9.1 Logging with Strategy**: Implement a logging component having
    at least the following methods: `debug()`, `info()`, `warn()`, and `error()`.
    The logging component should also accept a strategy that defines where the log
    messages are sent. For example, we might have a `ConsoleStrategy` to send the
    messages to the console, or a `FileStrategy` to save the log messages to a file.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**练习 9.1 使用策略进行日志记录**：实现一个至少包含以下方法的日志组件：`debug()`、`info()`、`warn()` 和 `error()`。日志组件还应接受一个策略，该策略定义了日志消息的发送位置。例如，我们可能有一个
    `ConsoleStrategy` 将消息发送到控制台，或者一个 `FileStrategy` 将日志消息保存到一个文件中。'
- en: '**Exercise 9.2 Logging with Template**: Implement the same logging component
    we defined in the previous exercise, but this time using the Template pattern.
    We would then obtain a `ConsoleLogger` class to log to the console or `FileLogger`
    class to log to a file. Appreciate the differences between the Template and the
    Strategy approaches.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**练习 9.2 使用模板进行日志记录**：实现与上一个练习中定义的相同日志组件，但这次使用模板模式。这样我们就可以获得一个 `ConsoleLogger`
    类来记录到控制台或 `FileLogger` 类来记录到文件。欣赏模板和策略方法之间的差异。'
- en: '**Exercise 9.3 Warehouse item**: Imagine we are working on a warehouse management
    program. Our next task is to create a class to model a warehouse item and help
    track it. Such a `WarehouseItem` class has a constructor, which accepts an `id`
    and the initial `state` of the item (which can be one of `arriving`, `stored`,
    or `delivered`). It has three public methods:'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**练习 9.3 仓库项目**：想象我们正在开发一个仓库管理程序。我们的下一个任务是创建一个类来模拟仓库项目并帮助跟踪它。这样的 `WarehouseItem`
    类有一个构造函数，它接受一个 `id` 和项目的初始 `state`（可以是 `arriving`、`stored` 或 `delivered` 之一）。它有三个公共方法：'
- en: '`store(locationId)` moves the item into the `stored` state and records the
    `locationId` where it''s stored.'
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store(locationId)` 将项目移动到 `stored` 状态，并记录其存储的 `locationId`。'
- en: '`deliver(address)` changes the state of the item to `delivered`, sets the delivery
    `address`, and clears the `locationId`.'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deliver(address)` 将项目的状态更改为 `delivered`，设置交付的 `address`，并清除 `locationId`。'
- en: '`describe()` returns a string representation of the current state of the item
    (for example, "Item 5821 is on its way to the warehouse," or "Item 3647 is stored
    in location 1ZH3," or "Item 3452 was delivered to John Smith, 1st Avenue, New
    York."'
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe()` 返回项目当前状态的字符串表示（例如，“项目 5821 正在前往仓库”，“项目 3647 存储在位置 1ZH3”，“项目 3452
    已交付给约翰·史密斯，纽约第一大道。”）。'
- en: The `arriving` state can be set only when the object is created as it cannot
    be transitioned to from the other states. An item can't move back to the `arriving`
    state once it's `stored` or `delivered`, it cannot be moved back to `stored` once
    it's `delivered`, and it cannot be `delivered` if it's not `stored` first. Use
    the State pattern to implement the `WarehouseItem` class.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`arriving` 状态只能在对象创建时设置，因为它不能从其他状态转换而来。一旦项目被存储或交付，就不能再回到 `arriving` 状态，一旦交付就不能再回到
    `stored` 状态，如果没有先存储，就不能交付。使用状态模式来实现 `WarehouseItem` 类。'
- en: '**Exercise 9.4 Logging with Middleware**: Rewrite the logging component you
    implemented for exercises 9.1 and 9.2, but this time use the Middleware pattern
    to postprocess each log message allowing different middlewares to customize how
    to handle the messages and how to output them. We could, for example, add a `serialize()`
    middleware to convert the log messages to a string representation ready to be
    sent over the wire or saved somewhere. Then, we could add a `saveToFile()` middleware
    that saves each message to a file. This exercise should highlight the flexibility
    and universality of the Middleware pattern.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**练习 9.4 使用中间件进行日志记录**：重写为练习 9.1 和 9.2 实现的日志组件，但这次使用中间件模式来后处理每个日志消息，允许不同的中间件自定义处理消息的方式以及输出方式。例如，我们可以添加一个
    `serialize()` 中间件将日志消息转换为字符串表示，以便通过网络发送或保存到某处。然后，我们可以添加一个 `saveToFile()` 中间件将每条消息保存到文件中。这个练习应该突出中间件模式的灵活性和通用性。'
- en: '**Exercise 9.5 Queues with iterators**: Implement an `AsyncQueue` class similar
    to one of the `TaskQueue` classes we defined in *Chapter 5*, *Asynchronous Control Flow
    Patterns with Promises and Async/Await*, but with a slightly different behavior
    and interface. Such an `AsyncQueue` class will have a method called `enqueue()`
    to append new items to the queue and then expose an `@@asyncIterable` method,
    which should provide the ability to process the elements of the queue asynchronously,
    one at a time (so, with a concurrency of 1). The async iterator returned from
    `AsyncQueue` should terminate only after the `done()` method of `AsyncQueue` is
    invoked *and* only after all items in the queue are consumed. Consider that the
    `@@asyncIterable` method could be invoked in more than one place, thus returning
    an additional async iterator, which would allow you to increase the concurrency
    with which the queue is consumed.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**练习 9.5 带迭代器的队列**：实现一个 `AsyncQueue` 类，类似于我们在 *第五章* 中定义的 `TaskQueue` 类之一，即
    *使用 Promises 和 Async/Await 的异步控制流模式*，但具有稍有不同的行为和接口。这样的 `AsyncQueue` 类将有一个名为 `enqueue()`
    的方法，用于将新项目添加到队列中，然后公开一个 `@@asyncIterable` 方法，该方法应提供异步处理队列元素的能力，一次处理一个元素（因此，并发度为
    1）。从 `AsyncQueue` 返回的异步迭代器应在调用 `AsyncQueue` 的 `done()` 方法后终止，并且仅在队列中的所有项目都被消耗后终止。考虑到
    `@@asyncIterable` 方法可能被调用在多个地方，从而返回一个额外的异步迭代器，这将允许你增加队列被消耗时的并发度。'
