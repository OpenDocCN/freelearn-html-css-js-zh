- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: HTML5, Canvas, and JavaScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5、Canvas和JavaScript
- en: HTML5 was released in 2012 and became standardized in 2014, which caused browsers
    to support all sorts of new features. The introduction of HTML5 impacted the realm
    of possibilities that are available through JavaScript. The options for graphics,
    videos, interaction with graphics, and a lot more with JavaScript have increased
    tremendously since the introduction of HTML5, and have been so revolutionary that
    in fact, they led to the end of support of Flash by web browsers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5于2012年发布，并于2014年成为标准，这导致浏览器支持各种新功能。HTML5的引入影响了通过JavaScript可用的可能性领域。自从HTML5引入以来，JavaScript在图形、视频、图形交互等方面的选项大大增加，并且变革如此之大，以至于实际上导致了浏览器对Flash的支持终止。
- en: HTML5 allows web page(s) to be better structured by adding new elements, such
    as `<header>`. And also the DOM has improved quite a bit, which has led to increased
    performance. There are quite a few other additions and you'll see some of them
    in the chapter. Another fun (and useful) addition worth mentioning here is the
    `<canvas>` element, which we'll cover in this chapter as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5通过添加新元素，如`<header>`，使网页结构更加合理。同时，DOM也有很大的改进，这导致了性能的提升。还有一些其他的新增功能，你将在本章中看到一些。这里值得提一下的另一个有趣（且有用）的新增功能是`<canvas>`元素，我们将在本章中介绍它。
- en: JavaScript gives us a lot of amazing features already, but together with HTML5
    there is a lot more possible when it comes to creating dynamic interactive web
    apps. This combination enables us to level up our content presentation game. We
    can work with files in the browser now, as well as drawing on the HTML5 canvas
    and adding images and text to it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript已经为我们提供了许多惊人的功能，但与HTML5结合时，在创建动态交互式Web应用方面有更多的可能性。这种组合使我们能够提升我们的内容展示水平。现在我们可以在浏览器中处理文件，以及绘制HTML5画布，并向其添加图像和文本。
- en: In this chapter, we will be examining some of the amazing things HTML5 has brought
    us. The topics don't all relate to one another directly, but they have in common
    that they were made possible by the powerful team of HTML5 and JavaScript, and
    of course, that they are all fun and useful. They will allow you to create an
    even more dynamic and interactive experience for the users of your app.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨HTML5为我们带来的令人惊叹的事物。这些主题并不直接相关，但它们有一个共同点，那就是它们都是通过强大的HTML5和JavaScript团队以及当然，它们都是有趣且有用的。它们将使你能够为你的应用程序的用户创造更加动态和交互式的体验。
- en: 'These are the topics that will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing HTML5 with JavaScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript介绍HTML5
- en: Local file reader
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地文件读取器
- en: GeoLocation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理位置信息
- en: HTML5 canvas
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5画布
- en: Dynamic canvas
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态画布
- en: Drawing on the canvas with the mouse
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标在画布上绘制
- en: Saving dynamic images
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存动态图像
- en: Media on the page
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面上的媒体内容
- en: Digital accessibility
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字无障碍
- en: 'Note: exercise, project and self-check quiz answers can be found in the *Appendix*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：练习、项目和自我检查测验的答案可以在*附录*中找到。
- en: Introducing HTML5 with JavaScript
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript介绍HTML5
- en: HTML5 is formally a version of HTML. It is a huge step up compared to its predecessor
    and enables us to make full applications in the web browser that are even accessible
    offline. When you read HTML5 in a job description, it often means more than just
    HTML. Usually, the combination of HTML5 with JavaScript, CSS, JSON, and others
    is included here as well.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5正式上是HTML的一个版本。与它的前辈相比，它是一个巨大的进步，使我们能够在网络浏览器中制作完整的应用程序，甚至可以在离线状态下访问。当你看到工作描述中的HTML5时，它通常不仅仅是指HTML。通常，HTML5与JavaScript、CSS、JSON等其他技术的组合也包括在内。
- en: Since HTML5 the structure of our page has improved. We have new elements such
    as `<header>`, `<nav>`, and `<article>`. And we can play videos with the `<video>`
    element, which means we no longer need Flash since HTML5\. And as we already mentioned
    we can work with the `<canvas>` element to create visuals on the page or to represent
    visuals such as animation, graphs, and others. Some things that had to be done
    with JavaScript in the past can now be done solely with HTML, such as adding video
    and audio to a webpage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自从HTML5以来，我们页面的结构得到了改善。我们有新的元素，如`<header>`、`<nav>`和`<article>`。我们可以使用`<video>`元素播放视频，这意味着我们不再需要Flash，因为HTML5已经提供了这些功能。正如我们之前提到的，我们可以使用`<canvas>`元素在页面上创建视觉元素或表示动画、图表等视觉内容。一些过去必须使用JavaScript完成的事情现在可以仅使用HTML完成，例如向网页添加视频和音频。
- en: Changes to the DOM also improved the loading time of web page(s). We are going
    to dive into some of the HTML5-specific features in this chapter. Let's start
    with accessing files from the browser.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 的更改也提高了网页的加载时间。在本章中，我们将深入探讨一些 HTML5 特定功能。让我们从从浏览器访问文件开始。
- en: Local file reader
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地文件读取器
- en: Since HTML5 we can finally interact with local files using the JavaScript that
    runs in our browser, which is really an amazing feature. Using this feature, we
    can upload files from our device to our web app and read from them in our app.
    This means that we can attach files to forms for example, which is great in many
    cases whenever we need to upload some sort of file for whatever purpose, for example,
    adding a résumé to your online job application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 HTML5 以来，我们终于可以使用在浏览器中运行的 JavaScript 与本地文件进行交互，这是一个真正令人惊叹的功能。使用此功能，我们可以从我们的设备上传文件到我们的
    Web 应用程序，并在应用程序中读取它们。这意味着我们可以将文件附加到表单中，例如，这在许多情况下都很好，无论我们出于何种目的需要上传某种类型的文件，例如，将简历添加到在线工作申请中。
- en: 'Let''s first make sure that the browser you are using supports this. We can
    run a simple script to check whether it does:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先确保你使用的浏览器支持此功能。我们可以运行一个简单的脚本来检查它是否支持：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you open this file in your browser it should say **Good to go!** when your
    browser supports file reading. Try updating your browser or using another one
    if it says **No FileReader :(**. Browsers that will work are, for example, Chrome
    and Firefox.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个文件中打开它，当你的浏览器支持文件读取时，它应该会显示 **一切正常**！如果它显示 **No FileReader :(**，请尝试更新你的浏览器或使用另一个浏览器。可以工作的浏览器示例包括
    Chrome 和 Firefox。
- en: Uploading files
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传文件
- en: 'Uploading files is actually easier than you might think. We indicate we want
    to upload a file by adding an input of type `file`. Here is a basic script that
    does just that:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上传文件实际上比你想象的要简单。我们通过添加一个类型为 `file` 的输入来表示我们想要上传一个文件。以下是一个基本的脚本，它就是这样做的：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It gives a blank HTML page with a **Choose file** button and the **No file chosen**
    comment behind it. Clicking on the button pops up the filesystem and you can select
    a file. After selecting the file, the JavaScript gets triggered. And as you can
    see, we are sending in the property files that are active in our body. This is
    a list of files. Therefore, we are grabbing the 0th index, the first element in
    the list. Files are represented as objects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一个带有 **选择文件** 按钮的空白 HTML 页面，以及其后的 **未选择文件** 注释。点击按钮会弹出文件系统，你可以选择一个文件。选择文件后，JavaScript
    会被触发。正如你所看到的，我们正在发送在身体中激活的属性文件。这是一个文件列表。因此，我们正在获取列表中的第 0 个索引，即列表中的第一个元素。文件以对象的形式表示。
- en: The file object gets logged to the console here, which enables you to see all
    the properties and associated values. Some of the important properties are the
    `name`, `size`, `type`, and `lastModified`, but there are many more.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象在这里被记录到控制台，这使你能够看到所有属性及其相关值。一些重要的属性是 `name`、`size`、`type` 和 `lastModified`，但还有很多其他属性。
- en: 'We are putting the name of our file in the `innerText` of our `div` message.
    So, on the screen, you will see the name of the file appear in the `div`. We can
    do something similar for multiple files. Here is how to upload multiple files
    at the same time:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件的名称放入我们的 `div` 消息的 `innerText` 中。因此，在屏幕上，你将看到文件名出现在 `div` 中。我们可以为多个文件做类似的事情。以下是同时上传多个文件的方法：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have added the multiple attribute to our input element. This changes the
    text on the button; instead of **Choose file** it now says **Choose files**, and
    we can select more than one file as a result.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将多个属性添加到我们的输入元素中。这改变了按钮上的文本；不再是 **选择文件**，而是现在说 **选择文件**，因此我们可以选择多个文件。
- en: We have changed our upload function a bit as well by adding a loop. And instead
    of `innerText`, we are now using `innerHTML`, because then we could insert a break
    using the HTML break. It will output the names of all the selected files below
    the input box on the screen.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过添加循环稍微改变了我们的上传函数。并且，我们不再使用 `innerText`，而是现在使用 `innerHTML`，因为这样我们就可以使用 HTML
    换行符插入一个换行。它将在屏幕上的输入框下方输出所有选定的文件名。
- en: Reading files
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取文件
- en: 'There is a special JavaScript object for reading files. It has a very suitable
    name: `FileReader`. Here is how we can use it to read a file.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个用于读取文件的特殊 JavaScript 对象。它有一个非常合适的名字：`FileReader`。以下是我们可以如何使用它来读取一个文件。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we have to specify what needs to happen in order to connect
    our HTML and JavaScript to a file. We do this by adding the `onload` event as
    an anonymous function that is sending on the event data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们必须指定为了将我们的 HTML 和 JavaScript 连接到文件需要发生什么。我们通过添加一个 `onload` 事件作为发送事件数据的匿名函数来完成此操作。
- en: Reading the data can then be done using one of the `readAs()` methods on the
    `FileReader` object. We have used `readAsText()` here, because we are dealing
    with a text file. This triggers the actual reading and the onload function that
    comes with it gets triggered when it's done, adding the result of the reading
    to our message. This accepts all file types, but not all file types will make
    sense.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`FileReader`对象上的`readAs()`方法之一来读取数据。我们在这里使用了`readAsText()`，因为我们正在处理文本文件。这触发了实际的读取，并在完成后触发`onload`函数，将读取的结果添加到我们的消息中。这接受所有文件类型，但并非所有文件类型都有意义。
- en: In order to see something sensible, we will have to upload something that contains
    plain text, such as `.txt`, `.json`, and `.xml`. With this we can also send a
    file to the server or process the contents of a log file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到有意义的内容，我们必须上传包含纯文本的内容，例如`.txt`、`.json`和`.xml`。有了这些，我们还可以将文件发送到服务器或处理日志文件的内容。
- en: Practice exercise 14.1
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.1
- en: 'This exercise will demonstrate the process of uploading and displaying local
    image files in your webpage. Use the following HTML and CSS as a starting template:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习将演示在您的网页中上传和显示本地图像文件的过程。使用以下HTML和CSS作为起始模板：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Take the following steps to complete the script element:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤完成脚本元素：
- en: Select your page elements as values within variable objects in your JavaScript
    code.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的JavaScript代码中，将页面元素作为变量对象中的值选择。
- en: Add an event listener to the `input` field. The event trigger should be changed
    so that it immediately invokes a reader function.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`input`字段添加事件监听器。应更改事件触发器，以便它立即调用读取器函数。
- en: Create a function to handle the reading of the selected files.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来处理所选文件的读取。
- en: Using the event object, select the target element that triggered the event.
    Get the files selected within that input and assign them to the `files` variable.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用事件对象，选择触发事件的元素。获取该输入中选择的文件，并将它们分配给`files`变量。
- en: Loop through all the files that were selected.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有选定的文件。
- en: Set the files by index within the loop to a variable named `file`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中将文件索引设置为名为`file`的变量。
- en: Set the image file as the file within the loop selected from the user input
    field files.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像文件设置为从用户输入字段中选择的循环内的文件。
- en: Add the newly created `img` tag to the page, create an area on the page that
    you can output the content to, and append the new page element to it.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的`img`标签添加到页面中，创建一个页面区域以输出内容，并将新的页面元素附加到它上。
- en: Create a new `FileReader` object.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`FileReader`对象。
- en: Add an `onload` event listener to the `fileReader` object to create and invoke
    an anonymous function that sets the source of the image as the result from the
    target element. Pass in the image object you just created as an argument into
    the function.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`fileReader`对象添加一个`onload`事件监听器，创建并调用一个匿名函数，将图像的源设置为来自目标元素的输出。将您刚刚创建的图像对象作为参数传递给该函数。
- en: Using `readAsDataURL()`, get the current file object and pass it into the file
    reader object so that it can be used once the onload completes and is added to
    the page.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`readAsDataURL()`，获取当前文件对象并将其传递到文件读取器对象中，以便在`onload`完成后使用，并将其添加到页面中。
- en: You can now select multiple image files from your computer and have them show
    on your webpage.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以从计算机中选择多个图像文件，并在网页上显示它们。
- en: Getting position data with GeoLocation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用地理位置获取位置数据
- en: 'We are going to look at the window object navigator now to see whether we can
    locate the user of the browser. This can be useful for many things, for example,
    suggesting restaurant locations nearby the user. We can have a look at the `GeoLocation`
    by inspecting `navigator.geolocation`. This is one way to do it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看窗口对象`navigator`，看看我们是否可以定位浏览器的用户。这可以用于许多事情，例如，建议用户附近的餐厅位置。我们可以通过检查`navigator.geolocation`来查看`GeoLocation`。这是其中一种方法：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you check out the log, you can see what the `GeoLocation` object contains,
    and one of these methods is to get the current position of the user. Here is how
    to use it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看日志，你可以看到`GeoLocation`对象包含的内容，其中一种方法是通过获取用户的当前位置。以下是使用方法：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This might look a bit more complicated than you'd expect, and this is because
    the `getCurrentPosition()` method takes another method as an argument. The position
    data gets sent to this function and that function will use the data as input.
    Therefore, we will have to wrap `console.dir()` in an external function (called
    `showGeoPosition()`) that takes a parameter and outputs this data so that we can
    see the data in the console. We can then send this function to the `getCurrentPosition()`
    function and see the data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能比你预期的要复杂一些，这是因为`getCurrentPosition()`方法接受另一个方法作为参数。位置数据被发送到这个函数，而这个函数将使用这些数据作为输入。因此，我们必须将`console.dir()`包裹在一个外部函数（称为`showGeoPosition()`）中，该函数接受一个参数并输出这些数据，这样我们就可以在控制台中看到这些数据。然后我们可以将这个函数发送到`getCurrentPosition()`函数，并查看数据。
- en: If you run this, you should get a `GeolocationPosition` object, with a `coords`
    property containing your latitude and longitude. The browser might prompt whether
    you're okay with sharing your location. And if it doesn't show anything, make
    sure the preferences and settings of your computer allow the browser to use your
    location.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你应该会得到一个`GeolocationPosition`对象，其中包含一个`coords`属性，包含你的纬度和经度。浏览器可能会提示你是否同意分享你的位置。如果没有任何提示，请确保你的计算机的首选项和设置允许浏览器使用你的位置。
- en: Using this, you can get the location of the user and show personalized content
    based on it or gather data about their location for other purposes, such as analyzing
    where visitors are located or displaying suggestions for the user based on their
    location.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个功能，你可以获取用户的地理位置，并根据它显示个性化的内容，或者为了其他目的收集他们的位置数据，例如分析访客的位置或根据用户的位置显示建议。
- en: HTML5 canvas
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5画布
- en: 'Did we already mention that the `<canvas>` element is new in HTML5? This is
    an amazing tool that will help you create dynamic web apps. Here is how to set
    up the canvas:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过`<canvas>`元素是HTML5中的新元素了吗？这是一个令人惊叹的工具，可以帮助你创建动态的Web应用程序。以下是设置画布的方法：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And when you open this page, you will see nothing. Why? Well, the canvas element
    is, by default, a white rectangle that you cannot see against the white background.
    You could add some CSS to add a border to the canvas or a background color to
    the body and your canvas will be revealed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开这个页面时，你将看不到任何内容。为什么？嗯，画布元素默认是一个白色的矩形，在白色背景上你无法看到它。你可以添加一些CSS来给画布添加边框或给主体添加背景颜色，这样你的画布就会显现出来。
- en: 'But, we probably want to put something on it and we need JavaScript to make
    that happen. Let''s create a "drawing" on it using JavaScript:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可能想在上面放置一些内容，并且我们需要JavaScript来实现这一点。让我们使用JavaScript在上面创建一个“绘图”：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The context of the canvas is read and stored in the `ctx` variable (a common
    shortened version of context). We need this to be able to draw on the canvas.
    We change the dimensions of the canvas to `500` by `500` pixels. This is not the
    same as using CSS for width and height; this adds the HTML attributes' `width`
    and `height`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 画布的上下文被读取并存储在`ctx`变量中（上下文的常见缩写）。我们需要这个变量来在画布上绘制。我们将画布的尺寸更改为`500`像素乘以`500`像素。这不同于使用CSS设置宽度和高度；这添加了HTML属性的`width`和`height`。
- en: 'With the `fillRect()` method on the context of the canvas, we can draw a rectangle
    on the canvas. It takes four parameters. The first two are the *x* and *y* coordinates
    of where the figure should be added to the canvas. The last two are the width
    and height of the rectangle. In our case, it''s a square. Here is what the result
    looks like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布的上下文中使用`fillRect()`方法，我们可以在画布上绘制一个矩形。它接受四个参数。前两个是图形应该添加到画布上的*x*和*y*坐标。最后两个是矩形的宽度和高度。在我们的例子中，它是一个正方形。以下是结果的样子：
- en: '![](img/B16682_14_01.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16682_14_01.png)'
- en: 'Figure 14.1: Result of the fillRect() method on our 500 px by 500 px canvas'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：fillRect()方法在我们500像素乘以500像素的画布上的结果
- en: 'We can also change the color we are drawing with. You can get a pink square
    instead by replacing the JavaScript of the previous HTML document with the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更改我们绘制的颜色。你可以通过替换上一个HTML文档中的JavaScript代码，用以下代码来得到一个粉红色的方块：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have now just used the word *pink*, but you can also work with hexadecimal
    color codes for the `fillStyle` property, which could look like this for pink:
    `#FFC0CB`. The first two characters specify the amount of red (`FF` here), the
    third and fourth the amount of green (`C0`), and the last two the amount of blue
    (`CB`). The values differ from `00` to `FF` (0 to 255 in decimal numbers).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在刚刚使用了单词 *pink*，但你也可以使用十六进制颜色代码为 `fillStyle` 属性工作，例如，对于粉红色可以是这样的：`#FFC0CB`。前两个字符指定红色量（这里为
    `FF`），第三和第四个字符指定绿色量（`C0`），最后两个字符指定蓝色量（`CB`）。这些值从 `00` 到 `FF`（十进制数中的 0 到 255）不等。
- en: There are more things you can do with the canvas than just drawing. Let's have
    a look at adding text to our canvas.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 canvas 做的事情远不止绘制。让我们看看如何将文本添加到我们的画布上。
- en: Practice exercise 14.2
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.2
- en: 'We will be implementing shapes and using the HTML5 canvas element to draw on
    a webpage with JavaScript. Draw a rectangle using JavaScript. The output will
    resemble the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现形状，并使用 HTML5 canvas 元素通过 JavaScript 在网页上绘制。使用 JavaScript 绘制一个矩形。输出将类似于以下内容：
- en: '![Shape, arrow'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状，箭头'
- en: Description automatically generated](img/B16682_14_02.png)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_14_02.png)
- en: 'Figure 14.2: Exercise outcome'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：练习结果
- en: 'Take the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤操作：
- en: Add the canvas element to the page.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 canvas 元素添加到页面中。
- en: Set the width and height to 640 px and, using CSS, add a 1 pc border to the
    element.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将宽度和高度设置为 640 像素，并使用 CSS 为元素添加 1 像素的边框。
- en: Within the JavaScript, select the canvas element and set the `Context` to `2d`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，选择 canvas 元素并将 `Context` 设置为 `2d`。
- en: Set the fill style to red.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将填充样式设置为红色。
- en: Create an output of the shape by using a rectangle.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩形创建形状的输出。
- en: Set the outline of the rectangle.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置矩形的轮廓。
- en: Clear the rectangle inside to make it transparent and the color of the background.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除矩形内部的填充，使其透明并显示背景颜色。
- en: Dynamic canvas
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态画布
- en: We can draw more advanced shapes, add images, and add text. This enables us
    to take our canvas skills to the next level.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以绘制更复杂的形状，添加图像和文本。这使得我们可以将我们的画布技能提升到下一个层次。
- en: Adding lines and circles to the canvas
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向画布添加线条和圆形
- en: 'Here we will see how to draw a line and a circle. Here is a piece of sample
    code that draws a line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将看到如何绘制线条和圆形。以下是一段示例代码，用于绘制线条：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The line width is set to `2` pixels. This first puts the focus to `0` (*x*)
    and `20` (*y*). This means it is at the very left edge of the canvas, `20` pixels
    from the top. This canvas is smaller; it is `100` by `100` pixels. The second
    point is at `50` (*x*) and `100` (*y*). This is what the line looks like:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 线宽设置为 `2` 像素。这首先将焦点放在 `0` (*x*) 和 `20` (*y*)。这意味着它位于画布的非常左侧边缘，距离顶部 `20` 像素。这个画布较小；它是
    `100` x `100` 像素。第二个点是 `50` (*x*) 和 `100` (*y*)。这就是线的样子：
- en: '![Shape, square'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状，正方形'
- en: Description automatically generated](img/B16682_14_03.png)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_14_03.png)
- en: 'Figure 14.3: Outcome of drawing a line to the canvas'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：绘制线条到画布的结果
- en: And before we move over to text, here is how to draw a circle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向文本之前，这是绘制圆形的方法。
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We use the `arc()` method to create a curve or a circle. It takes five parameters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `arc()` 方法来创建曲线或圆形。它需要五个参数：
- en: start position x on canvas
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画布上的起始位置 x
- en: start position y on canvas
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画布上的起始位置 y
- en: radius of the circle
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆的半径
- en: starting angle in radians
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始角度（以弧度为单位）
- en: ending angle in radians
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束角度（以弧度为单位）
- en: 'So, if we don''t want a circle, but a semicircle, for example, we''ll have
    to specify a different starting and end angle in radians. This time we used the
    `stroke()` method to do the actual drawing instead of the `fill()` method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们不想画圆形，而是画半圆形，例如，我们必须指定不同的起始和结束角度（以弧度为单位）。这次我们使用了 `stroke()` 方法来实际绘制，而不是
    `fill()` 方法：
- en: '![Shape, circle'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状，圆形'
- en: Description automatically generated](img/B16682_14_04.png)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_14_04.png)
- en: 'Figure 14.4: Outcome of drawing a circle using the arc() method'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：使用 arc() 方法绘制圆形的结果
- en: '`Stroke()` is only drawing the line, whereas `fill()` colors the full shape.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`stroke()` 只绘制线条，而 `fill()` 则填充整个形状。'
- en: In the canvas, the shapes and lines will be added on top of each other, based
    on the order in which they're drawn. The first one you draw is underneath the
    latter ones. Exactly what happens when you paint on a real canvas. You will be
    seeing this in the next practice exercise.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 canvas 中，形状和线条将根据它们绘制的顺序叠加。你首先绘制的形状会在后面的形状下面。当你实际在画布上绘画时，情况正是如此。你将在下一个练习中看到这一点。
- en: Practice exercise 14.3
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习14.3
- en: 'In this exercise, you will be drawing a stick person using canvas:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用画布绘制一个棒人：
- en: '![Shape'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状'
- en: Description automatically generated](img/B16682_14_05.png)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_14_05.png)
- en: 'Figure 14.5: Exercise result within the web browser canvas element'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：在网页浏览器画布元素内的练习结果
- en: Create the page elements and prepare to draw on the canvas.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建页面元素并准备在画布上绘制。
- en: Begin the path with an arc roughly at the top center of your canvas object.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的画布对象的顶部中心大致开始路径。
- en: Using `arc()`, set a position for the left eye, roughly at the top left of the
    center of the arc you just drew, then add another arc for the right eye. Create
    a half arc for the mouth (the radian angle for a semicircle is pi) and fill all.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`arc()`设置左眼的位置，大约在刚刚绘制的弧的中心顶部左侧，然后添加另一个弧来绘制右眼。创建一个半圆来代表嘴巴（半圆的弧度角是π）并填充所有。
- en: Move the draw position to the center and draw a line for the nose.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将绘制位置移动到中心并绘制一个代表鼻子的线条。
- en: Draw the body with a line down from the center of the arc, create the left arm,
    and then move the draw position to do the right arm, which will be twice the width
    of the left arm. Move back to the center and continue down to draw the left leg,
    move back to the center, and draw the line for the right leg.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用从弧的中心向下的线条绘制身体，创建左臂，然后移动绘制位置来绘制右臂，其宽度是左臂的两倍。回到中心并继续向下绘制左腿，回到中心，绘制右腿的线条。
- en: Move to the top, set the colour to blue, and draw a triangle for a hat.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到顶部，设置颜色为蓝色，并绘制一个代表帽子的三角形。
- en: Adding text to the canvas
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加文本到画布
- en: 'We can add text to the canvas in a similar fashion as well. In this example,
    we set a font and a font size, and then write our text to the canvas:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以类似的方式向画布添加文本。在这个例子中，我们设置了一个字体和字体大小，然后将文本写入画布：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `fillText()` method is used to add text. We have to specify three parameters:
    the text, the *x* position, and the *y* position. Here is the result:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fillText()`方法来添加文本。我们必须指定三个参数：文本、*x*位置和*y*位置。这里是结果：
- en: '![Shape'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状'
- en: Description automatically generated with low confidence](img/B16682_14_06.png)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述，置信度低](img/B16682_14_06.png)
- en: 'Figure 14.6: Result of using the fillText() method'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：使用`fillText()`方法的结果
- en: 'We have specified `35` px from the top for the text to start. We can specify
    other aspects of the text, for example, like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定文本从顶部开始的位置为`35`像素。我们可以指定文本的其他方面，例如，如下所示：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we use the `textAlign` property on the canvas to specify how the text
    should be aligned.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用画布上的`textAlign`属性来指定文本应该如何对齐。
- en: Practice exercise 14.4
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习14.4
- en: 'We will work with text and add text to your canvas element. The following exercise
    will demonstrate how to dynamically add text and position it within your canvas
    element. The result from the exercise code will look similar to this diagram:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理文本并在你的画布元素中添加文本。以下练习将演示如何动态添加文本并在你的画布元素内定位它。练习代码的结果将类似于这个图示：
- en: '![A picture containing table'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![包含表格的图片'
- en: Description automatically generated](img/B16682_14_07.png)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_14_07.png)
- en: 'Figure 14.7: Exercise outcome'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：练习结果
- en: 'Take the following steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 采取以下步骤：
- en: Create a simple HTML document, and add the canvas element to your page. Set
    the height and width to `640`, and add a `1` px border to the element so you can
    see it on the page.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的HTML文档，并将画布元素添加到你的页面中。将高度和宽度设置为`640`，并为元素添加一个`1`像素的边框，以便你可以在页面上看到它。
- en: Select the page elements as values within JavaScript variables.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面元素作为JavaScript变量中的值选择。
- en: Create a string variable with the message `Hello World`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含消息`Hello World`的字符串变量。
- en: Set a font style using the font property and a blue fill color using the `fillStyle`
    property. You can also align the text to the left.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`font`属性设置字体样式，使用`fillStyle`属性设置蓝色填充颜色。你还可以将文本对齐到左侧。
- en: Add the text to the canvas with `fillText` and set the *x* and *y* positions
    of the text.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fillText`将文本添加到画布上，并设置文本的*x*和*y*位置。
- en: Set a new font and color of red.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置新的字体和红色颜色。
- en: Create a loop and, using the value of the loop variable, add text to the page
    canvas element.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环，并使用循环变量的值向页面画布元素添加文本。
- en: Adding and uploading images to the canvas
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向画布添加和上传图像
- en: 'We can add an image to the canvas. We can simply get an image from our page,
    and add it to our canvas:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向画布添加一个图像。我们可以简单地从我们的页面中获取一个图像，并将其添加到我们的画布上：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We wrap it all in an `onload` event listener here because we want to be sure
    that the image is loaded before getting it from the DOM, else the canvas will
    remain empty. We use the `drawImage()` method to add an image to the canvas. It
    takes three arguments: the *image*, the *x* position, and the *y* position.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将其包裹在一个`onload`事件监听器中，因为我们想确保在从DOM中获取图像之前图像已经加载完成，否则画布将保持空白。我们使用`drawImage()`方法将图像添加到画布上。它需要三个参数：*图像*、*x*位置和*y*位置。
- en: 'We can use one canvas inside another canvas as well. We do this exactly like
    we did when we were using the image. This is a very powerful feature, because
    it enables us to use a part of the drawing from the user input, for example. Let''s
    look at an example of how to do this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在另一个画布内部使用一个画布。我们这样做的方式与使用图像时完全一样。这是一个非常强大的功能，因为它使我们能够使用用户输入的一部分绘图，例如。让我们看看如何做到这一点的一个例子：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We create three canvases, to two we add shapes, and the third one is a combination
    of the first two. Here is what it looks like:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个画布，其中两个添加了形状，第三个是前两个的组合。看起来是这样的：
- en: '![Graphical user interface, text, application'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，文本，应用程序'
- en: Description automatically generated](img/B16682_14_08.png)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_14_08.png)
- en: 'Figure 14.8: The result: three canvases with shapes'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：结果：三个带有形状的画布
- en: We also can upload images to the canvas. This can be of great use when you want
    to show a preview to your user of something that was just uploaded, for example,
    a profile picture. This is very similar to grabbing the `<img>` element from the
    webpage and using that element, but this time we need to read our data from the
    uploaded file, create a new image element, and then draw that image to the canvas.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将图像上传到画布上。当您想向用户展示刚刚上传的内容的预览时，例如个人资料图片，这非常有用。这非常类似于从网页中抓取`<img>`元素并使用该元素，但这次我们需要从上传的文件中读取数据，创建一个新的图像元素，然后将该图像绘制到画布上。
- en: 'The below code does just that:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码就是这样做：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Every time the input of the input field changes, the `upImage()` method gets
    executed. This method does a few things, so let's break them down. First of all,
    we create a new `FileReader` and add the uploaded file. There is only one in this
    case, so we use index `0`. Instead of `readAsText()` that we have already seen,
    we are now using `readAsDataURL()`, which we can use to read images.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每当输入字段的输入发生变化时，`upImage()`方法就会被执行。这个方法做了一些事情，所以让我们来分解一下。首先，我们创建一个新的`FileReader`并添加上传的文件。在这种情况下只有一个，所以我们使用索引`0`。与我们已经看到的`readAsText()`不同，我们现在使用`readAsDataURL()`，我们可以用它来读取图像。
- en: This will trigger the `onload` event. And in our case, this creates a new image
    that can be added to the canvas later. As a source, we add the result of our read
    action and when the image is loaded, we change the size of our canvas to the size
    of our picture and then add the picture in there.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发`onload`事件。在我们的情况下，这会创建一个可以稍后添加到画布中的新图像。作为一个源，我们添加我们读取操作的结果，当图像加载完成后，我们将画布的大小更改为图片的大小，然后将图片添加进去。
- en: These new skills will enable you to work with images on canvases, draw your
    own images, upload images from elsewhere, and even re-use the ones on the webpage.
    This can come in handy for many situations, for example, to create basic animation,
    or to create the functionality to upload a new profile picture to a user's profile.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新技能将使您能够在画布上处理图像，绘制自己的图像，从其他地方上传图像，甚至重用网页上的图像。这在许多情况下都很有用，例如，创建基本动画，或者创建上传新个人资料图片到用户个人资料的功能。
- en: Practice exercise 14.5
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习14.5
- en: We will practice uploading a local image to the canvas. The following exercise
    will demonstrate how to upload images from your local computer and have them displayed
    within the canvas element within your browser.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将练习将本地图像上传到画布。以下练习将演示如何从您的本地计算机上传图像，并在浏览器中的画布元素内显示它们。
- en: Set up the page elements and add an input field to upload an image. Add the
    canvas element to the page.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置页面元素，并添加一个输入字段来上传图像。将画布元素添加到页面中。
- en: In JavaScript, select the input field and the canvas elements as JavaScript
    objects.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript中，选择输入字段和画布元素作为JavaScript对象。
- en: Add an event listener to invoke an upload function once there is a change in
    the input field contents.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个事件监听器，在输入字段内容发生变化时调用上传函数。
- en: Create the aforementioned function to handle the upload of the image to the canvas.
    Using `FileReader`, create a new `FileReader` object. In the `reader.onload` event,
    create a new image object.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建上述函数来处理图像上传到画布的操作。使用 `FileReader` 创建一个新的 `FileReader` 对象。在 `reader.onload`
    事件中，创建一个新的图像对象。
- en: Add an `onload` listener to the image object so that when the image is loaded,
    set the canvas height and width to match half the image size height and width.
    Using `ctx.drawImage()`, add the image to the canvas.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `onload` 监听器添加到图像对象中，以便在图像加载时，将画布的高度和宽度设置为图像高度和宽度的一半。使用 `ctx.drawImage()`，将图像添加到画布上。
- en: Set the img source to the result from the input value.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 img 的源设置为输入值的输出结果。
- en: Use the reader object and invoke `readAsDataURL()` to convert the file input
    value to a readable format of base64 image data that can be used within the canvas.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用读取器对象并调用 `readAsDataURL()` 将文件输入值转换为可读的 base64 图像数据格式，该格式可用于画布中。
- en: Adding animations to the canvas
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向画布添加动画
- en: 'With the methods we have seen so far, we can already start creating animations.
    We do this by using loops and recursion, combined with `timeout()`. These drawings
    with (short) time intervals result in an animation. Let''s start with a basic
    animation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们迄今为止看到的方法，我们已经开始创建动画。我们通过使用循环和递归，结合 `timeout()` 来实现这一点。这些带有（短）时间间隔的绘图会导致动画。让我们从一个基本的动画开始：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will start drawing a square at position `5`, `50`. And after `50` ms, it
    will draw another square at position `10`, `50`, and after that at `15`, `50`.
    And it will keep on changing this *x* value by `5` up to the point that *x* gets
    bigger than the width of the canvas, when it is then set to zero. This way, the
    last bit of white canvas on that line gets colored black too.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从位置 `5`，`50` 开始绘制一个正方形。然后 `50` 毫秒后，它将在位置 `10`，`50` 处绘制另一个正方形，然后是 `15`，`50`。它将不断通过
    `5` 改变这个 *x* 值，直到 *x* 大于画布的宽度，此时它被设置为零。这样，该行最后一点白色画布也会被着色成黑色。
- en: 'Right now, it is more creating a line, and not a moving square. This is because
    we keep on adding the colored part to the canvas, but not resetting it to the
    previous color. We can do this with the `clearRect()` method. This method takes
    four parameters. The first two are the starting point to draw the rectangle to
    be cleared (so *x*, *y*). The third one is the `width` of the rectangle to be
    cleared and the last one is the `height`. In order to clear the full canvas, we''ll
    have to write:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它更像是创建一条线，而不是移动的正方形。这是因为我们不断将着色部分添加到画布上，但没有将其重置为之前的颜色。我们可以使用 `clearRect()`
    方法来做这件事。此方法接受四个参数。前两个参数是绘制要清除的矩形的起点（即 *x*，*y*）。第三个参数是要清除的矩形的 `width`，最后一个参数是 `height`。为了清除整个画布，我们必须编写：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Adding this to the beginning of the draw function in our previous example results
    in a moving square instead of a fat line being drawn because the previous square
    is not kept, but the canvas resets every time and the square gets drawn from scratch.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到我们之前示例中的 draw 函数的开头，结果是一个移动的正方形而不是一条粗线被绘制出来，因为之前的正方形没有被保留，但画布每次都会重置，正方形是从头开始绘制的。
- en: Practice exercise 14.6
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 14.6
- en: We will practice animating shapes and moving objects on the page. This exercise
    will demonstrate how to move an object on the page using the HTML5 canvas element
    and JavaScript.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将练习在页面上动画化形状和移动对象。这个练习将演示如何使用 HTML5 画布元素和 JavaScript 在页面上移动一个对象。
- en: '![Chart, bubble chart'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图表，气泡图'
- en: Description automatically generated](img/B16682_14_09.png)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_14_09.png)
- en: 'Figure 14.9: Red circle moving within the boundaries of the canvas object'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9：红色圆圈在画布对象边界内移动
- en: 'Take the following steps to create a red circle that will then be moved within
    the canvas boundaries, appearing to be bouncing off the sides:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤创建一个红色圆圈，然后将其移动到画布边界内，看起来像是在反弹：
- en: Create the canvas and apply a border of 1 px to it.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建画布并给它应用 1 像素的边框。
- en: Select the canvas page elements with JavaScript and prepare to draw on the canvas.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 选择画布页面元素并准备在画布上绘图。
- en: Create variables to track the *x* and *y* positions, as well as the *x*-direction
    speed and the *y*-direction speed. You can set these as a default of `1` and the
    *x* and *y* starting positions can be half of the canvas dimensions.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建变量来跟踪 *x* 和 *y* 位置，以及 *x* 方向速度和 *y* 方向速度。你可以将这些设置为默认值 `1`，而 *x* 和 *y* 的起始位置可以是画布尺寸的一半。
- en: Create a function to draw the ball. This will draw the ball as a red ball arc
    in the *x* and *y* positions. Also, the size for the ball should be set as a variable
    so that the boundaries can be calculated from it. Fill and close the path.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来绘制球。这将把球绘制成*x*和*y*位置的红色球弧。此外，球的尺寸应该作为一个变量设置，以便可以从它计算出边界。填充并关闭路径。
- en: Create a function to move the ball and set the interval on that function to
    10 milliseconds.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来移动球，并将该函数的间隔设置为10毫秒。
- en: In the aforementioned movement function, clear the current rectangle and draw
    the ball using the draw ball function.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述移动函数中，清除当前矩形并使用绘制球函数绘制球。
- en: Check the position of the ball. If the ball is outside the canvas boundaries,
    you need to change direction. This can be done by multiplying the direction by
    -1\. Update the *x* and *y* positions with the new values.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查球的位置。如果球在画布边界之外，你需要改变方向。这可以通过将方向乘以-1来实现。使用新值更新*x*和*y*的位置。
- en: Drawing on canvas with a mouse
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用鼠标在画布上绘图
- en: 'We have all the ingredients already to create a canvas on which we can draw
    with our mouse. Let''s walk you through it. We''ll start by setting up the canvas:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了所有创建一个我们可以用鼠标在上面绘图的画布的原料。让我们带你了解一下。我们将从设置画布开始：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our script element, we are going to add a method for when the window has
    loaded. When the window has loaded, we need to add some event listeners:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本元素中，我们将添加一个当窗口加载完成时的方法。当窗口加载完成后，我们需要添加一些事件监听器：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We want to draw when the mouse is moving, and we want to change the current
    position on the canvas when the mouse is moving. This is also something we want
    to do on `mouseenter`. Let''s write the code for setting the position. This will
    be added to the script element as well. We will also have to add the position
    variable, which again should be declared at the start of the script:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在鼠标移动时进行绘图，并且希望在鼠标移动时更改画布上的当前位置。这也是我们在`mouseenter`时想要做的事情。让我们编写设置位置的代码。这将添加到脚本元素中。我们还需要添加位置变量，它再次应该在脚本开始时声明：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the function for setting the position:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以及设置位置的函数：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function gets triggered on `mousemove` and on `mouseenter`. The event that
    triggers this has a `pageX` and a `pageY` property we can use to get the current
    position of the mouse.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在`mousemove`和`mouseenter`事件上被触发。触发此事件的事件具有`pageX`和`pageY`属性，我们可以使用这些属性来获取鼠标的当前位置。
- en: 'The last must-have ingredient for drawing on the canvas is the `draw()` method.
    Here is what it could look like:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘图的最后一个必备元素是`draw()`方法。下面是它可能的样子：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We start with something that might look strange, but it is a great trick to
    make sure that the mouse is actually being clicked. We don't want to be drawing
    when no button on the mouse is clicked. This method prevents that by returning
    from the method if it is not being clicked.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个可能看起来很奇怪的东西开始，但这是一个确保鼠标实际上被点击的绝佳技巧。我们不希望在没有任何鼠标按钮被点击时进行绘图。这个方法通过在未点击时从方法中返回来防止这种情况。
- en: Then we start to begin a path. We always have a current *x* and *y*, so they
    are set as coordinate one, and then we set them again and use these new coordinates
    for the line. We give it a round linecap to achieve smooth lines and a line width
    of `10`. Then we draw the line, and as long as the mouse is moving, the `draw()`
    function gets called again.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始绘制路径。我们始终有一个当前的*x*和*y*，所以它们被设置为坐标一，然后我们再次设置它们，并使用这些新坐标来绘制线条。我们给它一个圆角线条端点以实现平滑的线条，并设置线条宽度为`10`。然后我们绘制线条，只要鼠标在移动，`draw()`函数就会被再次调用。
- en: 'The app can now be opened and used as a functioning drawing tool. We can also
    give the user more options here, for example, adding a color picker to change
    the color that the user is drawing with. In order to do that, we''ll have to add
    a color picker to the HTML, like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在可以打开并作为一个功能性的绘图工具使用。我们还可以在这里为用户提供更多选项，例如，添加一个颜色选择器来更改用户绘制的颜色。为了做到这一点，我们将在HTML中添加一个颜色选择器，如下所示：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And change the selected color in JavaScript by adding an event listener for
    when the value of that input box changes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在JavaScript中通过添加一个事件监听器来更改选定的颜色，当输入框的值发生变化时：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We start with the color pink, and overwrite it with whatever the user selects
    in the color picker.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从粉红色开始，并用用户在颜色选择器中选择的颜色覆盖它。
- en: Practice exercise 14.7
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.7
- en: 'We will create an online drawing board, and include a dynamic value for width,
    color, and ability to erase the current drawing. Use the following HTML as a template
    for this project to add JavaScript code to:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个在线绘图板，并包括宽度、颜色和擦除当前绘图的动态值。使用以下HTML作为此项目的模板，以添加JavaScript代码：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Take the following steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Select the page elements as variable objects in JavaScript. Get the input field
    and select the button as an object.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript中将页面元素作为变量对象选择。获取输入字段并选择按钮作为对象。
- en: Add an event listener to the button that will run a function to clear the current
    canvas. Within the clear function, use the `confirm()` method to check if the
    user wants to erase the canvas drawing. If they then confirm using `clearRect()`,
    delete the contents of the canvas element.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加事件监听器，以运行一个函数来清除当前画布。在clear函数中，使用`confirm()`方法检查用户是否想要擦除画布绘图。如果他们确认使用`clearRect()`，则删除画布元素的内容。
- en: Set a global position object for *x* and *y* and by adding event listeners to
    the mouse events, update the position. If the mouse move is triggered, invoke
    a draw function. Set the position to update the mouse position, setting the global
    position values to that of the mouse *x* and *y*.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为*x*和*y*设置全局位置对象，并通过添加鼠标事件的事件监听器来更新位置。如果鼠标移动被触发，则调用draw函数。设置位置以更新鼠标位置，将全局位置值设置为鼠标的*x*和*y*。
- en: Within the draw function, check if the mouse button is pressed, and if not,
    then add `return`. If it is pressed, we can then draw on the canvas. Set the new
    path and move to the positions *x* and *y*. Start a new line, get the `strokestyle`
    value from the color input field, and set the `linewidth` value from the input
    width value. Add the `stroke()` method to add the new line to the page.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在draw函数中，检查鼠标按钮是否被按下，如果没有，则添加`return`。如果按下，我们就可以在画布上绘制。设置新的路径并移动到*x*和*y*的位置。开始一条新线，从颜色输入字段获取`strokestyle`值，并从输入宽度值设置`linewidth`值。添加`stroke()`方法以将新线添加到页面上。
- en: Saving dynamic images
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存动态图像
- en: 'We can convert the canvas to an image, and this image can then be saved as
    a next step. In order to convert it to an image, we need to add the following
    to our script element:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将画布转换为图像，然后作为下一步将其保存。为了将其转换为图像，我们需要在脚本元素中添加以下内容：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are changing our canvas to a data URL, which then becomes the source of
    our image. We want this to happen whenever a save button gets clicked. Here is
    the button:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将画布转换为数据URL，这将成为我们图像的来源。我们希望在点击保存按钮时发生此操作。以下是按钮：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And the event listener:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now whenever the save button gets clicked, it is going to update the image with
    the generated data URL from the canvas. Whatever content is within the canvas
    element will be turned into a base64 data image value and added to the page within
    an img tag.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每当点击保存按钮时，它将使用从画布生成的数据URL更新图像。画布元素内的任何内容都将转换为base64数据图像值，并添加到页面的img标签内。
- en: 'In the following example, there is a canvas of 200 by 200 pixels and an empty
    image of the same size. When a color gets selected, a square of 100 by 100 pixels
    in that color is drawn on the canvas. When the save button gets clicked, this
    canvas gets converted to an image. This image can then be saved. Here is the code
    for the example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，有一个200x200像素的画布和一个相同大小的空图像。当选择一种颜色时，在画布上绘制一个100x100像素的正方形。当点击保存按钮时，这个画布被转换为图像。然后可以保存这个图像。以下是示例的代码：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is what it looks like after saving the image:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是保存图像后的样子：
- en: '![Shape, square'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状，正方形'
- en: Description automatically generated](img/B16682_14_10.png)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_14_10.png)
- en: 'Figure 14.10: Result of saving the image'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10：保存图像的结果
- en: Media on the page
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面上的媒体
- en: There are special elements for media on the page. We are going to show you how
    to add audio and video and how to embed YouTube on a webpage.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上有特殊的媒体元素。我们将向您展示如何添加音频和视频，以及如何在网页上嵌入YouTube。
- en: 'Adding an audio player to a page is very simple:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将音频播放器添加到页面非常简单：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You specify the `controls` attribute if you want the user to be able to control
    pause and play and the volume. If you want it to start automatically, you'll have
    to add the attribute `autoplay`. With the source element, you specify the audio
    files that can be played. The browser will choose only one and will choose the
    first one (from top to bottom) that it supports.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望用户能够控制暂停和播放以及音量，请指定`controls`属性。如果你想让它自动播放，你必须添加`autoplay`属性。通过源元素，你指定可以播放的音频文件。浏览器将只选择一个，并且会选择它支持的第一个（从上到下）。
- en: 'Adding a video to a webpage is very similar to adding audio. Here''s how to
    do it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将视频添加到网页上与添加音频非常相似。以下是这样做的方法：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Often you would want to link to YouTube instead. Here''s how to do that:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 经常你会想要链接到YouTube。以下是这样做的方法：
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You will have to use the `iframe` element. This is a special element that allows
    another webpage inside the current webpage. And you can then add the YouTube embed
    link as a source. The last code after `embed` comes from the video URL.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不得不使用`iframe`元素。这是一个特殊的元素，它允许在当前网页内嵌入另一个网页。然后你可以将YouTube嵌入链接作为源。`embed`之后的最后一段代码来自视频URL。
- en: 'The height and width attributes of the video can be changed to make the video
    bigger or smaller. If you want to show it fullscreen, you can change the width
    and height like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 视频的高度和宽度属性可以被改变以使视频变大或变小。如果你想全屏显示，你可以这样更改宽度和高度：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you want it to be only a part of the screen, you can adjust the width and
    height attributes accordingly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想让它占据屏幕的一部分，你可以相应地调整宽度和高度属性。
- en: You can autoplay these as well with the autoplay attribute. If you use autoplay
    on more than one, none of them will autoplay to protect the visitor from getting
    all that noise from the webpage. It is typically considered annoying if your video
    starts making noise in the browser. Adding the attribute muted will avoid this.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`autoplay`属性来自动播放这些视频。如果你在多个视频上使用自动播放，那么它们都不会自动播放，以保护访客免受网页上所有噪音的干扰。如果你的视频在浏览器中开始发出噪音，这通常被认为是令人烦恼的。添加`muted`属性可以避免这种情况。
- en: Digital accessibility in HTML
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML中的数字无障碍性
- en: Digital accessibility is of huge importance for visually impaired people or
    those unable to use a mouse. In order to use the internet with little or no vision,
    screen readers are in place. This is a special piece of software that reads what
    is on the screen or converts it to braille using special devices connected to
    the computer. People that cannot use a mouse will often rely on speech to give
    the computer instructions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视觉障碍人士或无法使用鼠标的人来说，数字无障碍性非常重要。为了使用互联网，即使视力很小或没有视力，也需要屏幕阅读器。这是一款特殊的软件，它读取屏幕上的内容或使用连接到计算机的特殊设备将其转换为盲文。无法使用鼠标的人通常会依赖语音来给计算机下达指令。
- en: Early web applications were terrible in terms of accessibility. Luckily, WAI-ARIA
    created a technical specification of how to make the internet digitally accessible.
    Dynamic parts can be recognized if implemented correctly, and by adding semantics
    and metadata to the HTML, it's better useable for external tooling.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的网络应用在无障碍性方面非常糟糕。幸运的是，WAI-ARIA创建了一个技术规范，说明了如何使互联网数字无障碍。如果正确实现，动态部分可以被识别，通过向HTML添加语义和元数据，它对外部工具的使用性更好。
- en: Semantics might be one of the most important parts here. This comes down to
    using the right HTML element for the right purpose. If something should be clicked,
    it is best to make it a `<button>` element and not a `<span>`, for example. If
    it is a button, it is possible to navigate to it with the `Tab` key and click
    it using `Enter`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 语义可能是这里最重要的部分之一。这归结为使用正确的HTML元素来实现正确的目的。如果某个元素应该被点击，最好将其制作成`<button>`元素，而不是例如`<span>`。如果它是一个按钮，那么可以使用`Tab`键导航到它，并使用`Enter`键点击它。
- en: The same goes for headers. You can create something that looks like a header
    using a special class and give it a layout, but the screen readers are looking
    for `h1`, `h2`, and `h3`. You should always use the header elements for headers.
    This helps the screen readers and improves the accessibility of your website.
    And as a bonus, it helps you rank higher in Google as well because bots also check
    out the headers to see what is important on your site.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于标题。你可以使用特殊类创建看起来像标题的东西，并给它一个布局，但屏幕阅读器正在寻找`h1`、`h2`和`h3`。你应该始终使用标题元素来表示标题。这有助于屏幕阅读器并提高你网站的可用性。而且作为一个额外的好处，它还有助于你在Google上获得更高的排名，因为爬虫也会检查标题以了解你网站上什么内容是重要的。
- en: It is also important to use labels and link text that is descriptive. If the
    link part is only **Click here**, that is not helpful. Something like **Click
    here to sign up for the summer event** is much better.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用描述性的标签和链接文本也很重要。如果链接部分只是**点击此处**，那没有帮助。像**点击此处注册夏季活动**这样的描述要好得多。
- en: 'Throughout this book, we have also done something wrong with our input boxes.
    In order to make input fields accessible, you''ll have to add a label element.
    This will make it easier for screen readers to pick up on what the input box is
    about. So this is generally bad practice:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，我们也对我们的输入框做了一些错误的事情。为了使输入字段可访问，您必须添加一个标签元素。这将使屏幕阅读器更容易识别输入框的内容。所以这通常是不良的做法：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And this is much better, because now screen readers can read it too (and therefore
    visually impaired people can understand it):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多，因为现在屏幕阅读器也可以读取它了（因此视力受损的人可以理解它）：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'One last one that you may know already is the `alt` attribute for images. If
    the screen reader encounters an image, it will read the `alt` description. So
    make sure that these are descriptive, even if the image is not important. Since
    there is clearly no way to know it''s not important if you cannot see the image,
    all you''ll know is that you cannot see some picture. Here is how to add `alt`
    text:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个你可能已经知道的是图像的`alt`属性。如果屏幕阅读器遇到图像，它将读取`alt`描述。所以请确保这些描述是描述性的，即使图像不是很重要。由于显然无法知道它不是重要的，因为你无法看到图像，所以你唯一知道的是你无法看到一些图片。以下是添加`alt`文本的方法：
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These tips are not that important for practicing and testing purposes, but they
    are of great use when you are going to create professional apps. Taking accessibility
    into account will make your app more accessible for everyone. And as I said, Google
    will (currently) reward this good behavior by ranking you more highly and your
    app will be more profitable since more people can use it!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技巧对于练习和测试目的并不是很重要，但当你准备创建专业应用程序时，它们非常有用。考虑到可访问性会使你的应用程序对每个人来说都更容易访问。而且正如我所说，谷歌（目前）将通过提高你的排名来奖励这种良好的行为，你的应用程序将更有利可图，因为更多的人可以使用它！
- en: Chapter projects
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节项目
- en: Create a Matrix effect
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建矩阵效果
- en: This exercise will create a continuous animation of text moving from top to
    bottom. The final effect produced will show characters moving down the screen
    within the canvas element and appearing to disappear and fade as they approach
    the bottom of the screen as more new characters will be added to the canvas in
    their place. The random character can be either a 0 or 1, and will be in place
    in the position according to the number, which will represent the vertical position
    of where the character is drawn.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习将创建一个从顶部到底部移动的文本连续动画。最终产生的效果将显示字符在画布元素中向下移动，并在接近屏幕底部时消失和淡出，因为将会有更多的新字符添加到画布中替代它们。随机字符可以是0或1，并且将根据数字在相应位置上就位，这代表字符绘制的垂直位置。
- en: 'The canvas will be filled with a black background, which is going to use opacity
    to create the fading effect once it''s redrawn:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 画布将被填充为黑色背景，这将使用不透明度在重新绘制时创建淡出效果：
- en: '![Text'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![文本'
- en: Description automatically generated with low confidence](img/B16682_14_11.png)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 描述自动生成，置信度低](img/B16682_14_11.png)
- en: 'Figure 14.11: Matrix effect desired outcome'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11：期望的矩阵效果
- en: 'Take the following steps:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤操作：
- en: Create a simple HTML document, and in JavaScript create a canvas element and
    add the `getContent` element as `2d`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的HTML文档，并在JavaScript中创建一个画布元素，并将`getContent`元素作为`2d`添加。
- en: Select that canvas element and set the attribute height and width to 500x400\.
    Prepend it to the body of your document.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择那个画布元素，并将高度和宽度属性设置为500x400。将其添加到文档的主体中。
- en: Create an empty array named `colVal` and create a loop to add a number of items
    into the array that will have a value of 0\. The number of items you need to add
    to the array can be determined by dividing the width by ten, which should be the
    width between each column. The values in the array will be the starting vertical
    position of the content for the `fillText()` method that you will set up.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`colVal`的空数组，并创建一个循环向数组中添加若干项，这些项的值将为0。您需要添加到数组中的项数可以通过将宽度除以十来确定，这应该是每列之间的宽度。数组中的值将是您将要设置的`fillText()`方法的起始垂直位置。
- en: Create the main Matrix function to run at 50 millisecond intervals.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个主要矩阵函数，以50毫秒的间隔运行。
- en: Set the `fillStyle` to be black with .05 opacity, so that when it layers on
    top of the existing elements it will produce a fading effect.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fillStyle`设置为黑色，不透明度为.05，这样当它覆盖在现有元素上时，会产生一种渐变效果。
- en: Set the canvas font color to be green.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布字体颜色设置为绿色。
- en: Using an array map, iterate all the current items in the `colVal` array, which
    holds the vertical position for the output text.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组映射，迭代`colVal`数组中当前的所有项，该数组包含输出文本的垂直位置。
- en: Within the map, set the characters to display. We want it to alternate between
    0 and 1 so, using `Math.random()`, generate a value of either 0 or 1 for the text
    output. You can use a ternary operator to do this.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在映射中设置要显示的字符。我们希望它在0和1之间交替，因此使用`Math.random()`生成文本输出的0或1值。你可以使用三元运算符来完成此操作。
- en: Set the position of x using the index value multiplied by 10, which is the start
    of each new letter. Using the index from the `colVal` array, this will create
    separate columns of moving characters.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用索引值乘以10来设置x的位置，这是每个新字母的开始。使用`colVal`数组中的索引，这将创建移动字符的单独列。
- en: Create the character within the canvas using the ctx `fillText()` method, setting
    the output character to the random 0 or 1 value, using `posX` for the column *x*
    position, and `posY`, which is the value in the `colVal` array for the item, as
    the position of the *y* axis for the output.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用ctx `fillText()`方法在画布中创建字符，将输出字符设置为随机的0或1值，使用`posX`作为列*x*位置，以及`posY`，它是`colVal`数组中项的值，作为输出*y*轴的位置。
- en: Add a condition that checks if the position of *y* is greater than 100 plus
    a random value of 0-300\. The larger the number, the longer the number will fall
    on the *y* position. This is random so not all numbers end at the same spot. This
    will create a staggered effect after the initial drop.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个条件来检查*y*的位置是否大于100加上0-300的随机值。数字越大，它在*y*位置上的下落时间就越长。这是随机的，所以不是所有数字都结束在同一个位置。这将产生初始下落后的一种错落效果。
- en: If the position of *y* is not past the random value and 100, increment the value
    of the index item by 10\. Assign this value of *y* back to the item in the `colVal`
    array, which can then be used in the next iteration. This will move the letter
    down 10 pixels on the canvas within the next draw round.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*y*的位置没有超过随机值和100，则将索引项的值增加10。将这个*y*的值重新分配给`colVal`数组中的项，这样它就可以在下一个迭代中使用。这将使字母在下一个绘制回合中在画布上向下移动10像素。
- en: Countdown clock
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 倒计时时钟
- en: 'This exercise will produce a real-time countdown clock that will display the
    amount of time in days, hours, minutes, and seconds left until the date value
    within the input date field. Adjusting the input date field will update the countdown
    clock. It will also use local storage to capture and save the value in the input
    field, so if the page is refreshed, the input field will still retain the date
    value and the countdown clock can continue to count down to that date value from
    the input field. You can use the following HTML template:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将产生一个实时倒计时时钟，它将显示输入日期字段中剩余的天数、小时、分钟和秒。调整输入日期字段将更新倒计时时钟。它还将使用本地存储来捕获和保存输入字段的值，因此如果刷新页面，输入字段将仍然保留日期值，倒计时时钟可以继续从输入字段向下计数到该日期值。你可以使用以下HTML模板：
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have created page elements including input with a type of date, a main `clock`
    container, and added spans for `days`, `hours`, `minutes`, and `seconds`. They
    have been labeled and CSS applied as needed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了页面元素，包括类型为日期的输入，主要的`clock`容器，并为`days`、`hours`、`minutes`和`seconds`添加了span标签。它们已经根据需要进行了标记并应用了CSS样式。
- en: 'You can take the following steps:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取以下步骤：
- en: Select the page elements as JavaScript objects, as well as selecting the main
    clock output area as the value of a JavaScript object.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面元素作为JavaScript对象选择，以及将主时钟输出区域作为JavaScript对象的值。
- en: Create variables for the `timeInterval` and a global Boolean value that can
    be used to stop the clock timer.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`timeInterval`创建变量以及一个全局布尔值，该布尔值可以用来停止时钟计时器。
- en: Check the local storage if there is an item for countdown already set. If there
    is, use that value.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查本地存储中是否已经设置了倒计时项。如果有，则使用该值。
- en: Create a condition and function to start the clock as the saved value and set
    the input field date value to the local storage saved value.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个条件和函数来启动时钟，将其设置为保存的值，并将输入字段日期值设置为本地存储中保存的值。
- en: Add an event listener to invoke a function if the value of the input field is
    changed. Clear the interval if it has changed and set the new `endDate` value
    in the local storage.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个事件监听器，当输入字段的值改变时调用一个函数。如果已改变，清除间隔并设置新的`endDate`值到本地存储中。
- en: Start the clock with the start clock function from that new `endDate` input
    value.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的`endDate`输入值启动时钟的启动时钟函数。
- en: Create a function to start the clock that is used to start the counter. Within
    that function, you can create a function that updates the counter and outputs
    the new clock time values into the page clock container area.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于启动计时的函数，该函数用于启动计数器。在该函数内，你可以创建一个更新计数器并将新的时钟时间值输出到页面时钟容器区域的函数。
- en: Within this function, check if `timeLeft` is less than the counter time. Create
    a separate function to handle this. If it's less, stop the timer.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此函数内，检查`timeLeft`是否小于计数器时间。创建一个单独的函数来处理此情况。如果它更少，停止计时器。
- en: If the time left is more and has a value within the object, then output the
    object by property names and match the property names you use in the time left
    function object to the class names you use in your webpage elements so they match
    and you can save time rewriting them. Loop through all the object values and assign
    the values within the `innerHTML` page element.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果剩余时间更多且在对象内有值，则通过属性名输出对象，并将你在剩余时间函数对象中使用的属性名与你在网页元素中使用的类名匹配，以便它们匹配，你可以节省重写它们的时间。遍历所有对象值并将它们分配到`innerHTML`页面元素中。
- en: In the time left function, get the current date. Using `Date.parse()`, parse
    the date and calculate the total milliseconds left until the counter ends. Return
    the values of the total days, hours, minutes, and seconds as a response object
    to use in the update function.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在剩余时间函数中，获取当前日期。使用`Date.parse()`解析日期并计算直到计数器结束的总毫秒数。将总天数、小时数、分钟数和秒数作为响应对象返回，以便在更新函数中使用。
- en: If the counter is false and has passed the end time, then clear the interval.
    If the counter is still valid, set the interval to run the update function every
    1,000 milliseconds.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果计数器为假且已通过结束时间，则清除间隔。如果计数器仍然有效，设置间隔每1,000毫秒运行一次更新函数。
- en: Online paint app
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在线绘画应用
- en: Create a drawing application where the user can draw using their mouse in the
    canvas element. When the user is within the canvas element and clicks down on
    the mouse button, holding the button down will add lines, producing a drawing
    effect within the canvas element. The color and width of the drawing pencil can
    be changed dynamically for more functionality. In addition, this app will include
    a button to save and download the image from the canvas element, as well as clearing
    the current canvas content.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个绘图应用，用户可以在画布元素中使用鼠标绘图。当用户在画布元素内且点击鼠标按钮时，按住按钮会在画布元素内添加线条，产生绘图效果。绘图铅笔的颜色和宽度可以动态更改以增加功能。此外，此应用还将包括一个按钮来保存并从画布元素下载图像，以及清除当前画布内容。
- en: 'You can use the following template and add the JavaScript code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下模板并添加JavaScript代码：
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have created a button to save and a button to clear, an input for color using
    the HTML5 color type, and the range type to get a numeric value for the pen width.
    We have also added page elements for the canvas and an output area.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个保存按钮和一个清除按钮，一个用于颜色输入的HTML5颜色类型输入框，以及范围类型来获取笔宽度的数值。我们还添加了页面元素用于画布和输出区域。
- en: 'Take the following steps:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤操作：
- en: Using JavaScript, select all the page elements as JavaScript objects and set
    up the canvas element to draw into.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JavaScript，将所有页面元素作为JavaScript对象选择，并设置画布元素用于绘图。
- en: Set a variable to track the location of the pen.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个变量来跟踪笔的位置。
- en: On the canvas, add an event listener to track mouse movement. Update the pen
    position to the `lastX` and `lastY` positions, and then set the location position
    to `clientX` and `clientY`. Create a function to draw at the pen position and invoke
    the draw function.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上添加一个事件监听器来跟踪鼠标移动。更新笔位置到`lastX`和`lastY`位置，然后将位置设置为`clientX`和`clientY`。创建一个在笔位置绘图的函数并调用绘图函数。
- en: For `mousedown`, set `draw` to `true`, and for `mouseup` and `mouseout`, set
    `draw` to `false`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`mousedown`，将`draw`设置为`true`，对于`mouseup`和`mouseout`，将`draw`设置为`false`。
- en: Within the draw function, begin the move path at the pen location values and
    set the stroke style to the pen color and stroke width to the pen width. These
    can be changed by clicking the inputs and updating their HTML values. Add the
    stroke and close the drawing path.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在绘图函数中，从笔的位置值开始移动路径，并将笔的样式设置为笔的颜色，将笔的宽度设置为笔的宽度。这些可以通过点击输入并更新它们的HTML值来更改。添加笔的样式并关闭绘图路径。
- en: Add an event listener to the clear button. If clicked, create a function that
    confirms that the user wants to remove and clear the drawing, and then if true,
    invoke `clearRect()` to clear the canvas contents.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为清除按钮添加事件监听器。如果点击，创建一个函数来确认用户想要删除并清除绘图，然后如果确认，调用`clearRect()`来清除画布内容。
- en: Add another event listener to save the image. When clicked, it should invoke
    a function that gets the canvas object using `toDataURL` as base64 image data.
    You can log it into the console to see what it looks like.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为保存图片添加另一个事件监听器。当点击时，它应该调用一个函数，该函数使用`toDataURL`作为基于64的图像数据获取画布对象。你可以将其记录到控制台以查看其外观。
- en: Create an img element and prepend it to the output area element. Set the `src`
    path to the `dataURL` value.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个img元素并将其预置于输出区域元素。将`src`路径设置为`dataURL`值。
- en: To set a download of the image, create an anchor tag, append it to anywhere
    within the HTML page elements, and create a filename. You can generate a unique
    filename with `Math.random()`. Set the hyperlink to the download attribute and
    the `href` path to the `dataURL` path, and trigger a click with the `click()`
    method. Once clicked, remove the link element.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置图片下载，创建一个锚点标签，将其附加到HTML页面元素内的任何位置，并创建一个文件名。你可以使用`Math.random()`生成一个唯一的文件名。将超链接设置为下载属性，并将`href`路径设置为`dataURL`路径，然后使用`click()`方法触发点击。一旦点击，就删除链接元素。
- en: Self-check quiz
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我检查测验
- en: Which statements below are the correct way to prepare to draw?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种说法是准备绘图的正确方式？
- en: '[PRE40]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What will the following code do?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将做什么？
- en: '[PRE41]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Nothing, the code has errors
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有错误，代码有误
- en: Draws a red square
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画一个红色方块
- en: Draws a red circle
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画一个红色圆圈
- en: Draws half a circle
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 画半个圆
- en: What are all three methods required to draw a line within the canvas element,
    and in what order?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布元素内绘制线条需要哪三种方法，以及它们的顺序是什么？
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have discussed a lot of great additions to our JavaScript toolbox using HTML5
    in this chapter. These new skills will really enhance our capabilities to build
    interactive web apps. We started off with the local file reader, which enabled
    us to upload and read files using several methods, such as the `readAsText()`
    method. Then we saw how to get the `GeoLocation` of a user. This can be great
    to personalize suggestions, for example, for restaurants or parking spots.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多使用HTML5对我们JavaScript工具箱的改进。这些新技能将真正增强我们构建交互式Web应用的能力。我们从本地文件读取器开始，它使我们能够使用几种方法上传和读取文件，例如`readAsText()`方法。然后我们看到了如何获取用户的`GeoLocation`。这可以很好地用于个性化建议，例如，用于餐厅或停车位。
- en: The canvas was yet another amazing addition to what we can do with web page(s).
    Canvases allow us to draw, write text, add images (by drawing and uploading),
    and create complete animations. This all can be done using the methods on the
    canvas.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 画布是我们在网页上可以做到的另一项惊人的功能。画布允许我们绘图、写文本、添加图像（通过绘制和上传），以及创建完整的动画。所有这些都可以使用画布上的方法完成。
- en: We then had a look at media on the page and how to add audio and video. Finally,
    we discussed the topic of digital accessibility and how to make sure your website
    is accessible for everybody, with and without a screen reader.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后查看页面上的媒体以及如何添加音频和视频。最后，我们讨论了数字可访问性的主题以及如何确保你的网站对所有人都是可访问的，无论是否有屏幕阅读器。
- en: And at this point, we can say, you did it! You've worked your way through so
    many basic and advanced web development topics. In the final chapter, we are going
    to be exploring the next steps for you to take your skills to the next level beyond
    pure JavaScript, which is what this book has focused on.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以这么说，你已经做到了！你已经通过许多基本和高级的Web开发主题。在最后一章，我们将探讨你下一步要采取的步骤，将你的技能提升到下一个层次，超越纯JavaScript，这正是本书的重点。
