- en: Migrating to Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移到Docker
- en: So far, we have focused on developing the backend and frontend of our application,
    and have paid little attention to our infrastructure. In the next two chapters,
    we will focus on creating a scalable infrastructure using Docker and Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要集中在开发应用程序的后端和前端，对基础设施的关注很少。在接下来的两章中，我们将专注于使用Docker和Kubernetes创建可扩展的基础设施。
- en: So far, we’ve manually configured two Virtual Private Servers (VPSs), and deployed
    each of our backend APIs and client applications on them. As we continue to develop
    our applications on our local machine, we test each commit locally, on Travis
    CI, and on our own Jenkins CI server. If all tests pass, we use Git to pull changes
    from our centralized remote repository on GitHub and restart our application. While
    this approach works for simple apps with a small user base, it will not hold up
    for enterprise software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经手动配置了两个虚拟专用服务器（VPS），并将我们的后端API和客户端应用程序部署在它们上面。随着我们在本地机器上继续开发我们的应用程序，我们在本地、Travis
    CI以及我们自己的Jenkins CI服务器上测试每个提交。如果所有测试都通过，我们使用Git从GitHub上的集中式远程仓库拉取更改并重新启动我们的应用程序。虽然这种方法适用于用户基础较小的简单应用程序，但对于企业级软件来说则不可行。
- en: 'Therefore, we''ll begin this chapter by understanding why manual deployment
    should be a thing of the past, and the steps we can make towards full automation
    of the deployment process. Specifically, by following this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从理解为什么手动部署应该是过去式开始，以及我们可以采取的步骤来实现部署过程的完全自动化。具体来说，通过遵循本章，你将学习：
- en: What **Docker** and what containers in general is,
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是**Docker**以及通常的容器是什么，
- en: How to download and run Docker images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何下载和运行Docker镜像
- en: How to compose your own `Dockerfile` and use it to containerize parts of our
    application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写自己的`Dockerfile`并将其用于将应用程序的部分容器化
- en: How to optimize an image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何优化镜像
- en: Problems with manual deployment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动部署的问题
- en: 'Here are some of the weaknesses in our current approach:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前方法中存在的一些弱点包括：
- en: '**Lack of consistency**: Most enterprise-level applications are developed by
    a team. It is likely that each team member will use a different operating system,
    or otherwise configure their machine differently from others. This means that
    the environment of each team members’ local machine will be different from each
    other, and by extension, from the production servers''. Therefore, even if all
    our tests pass locally, it does not guarantee that it will pass on production.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏一致性**：大多数企业级应用程序是由一个团队开发的。很可能每个团队成员都会使用不同的操作系统，或者以与其他人不同的方式配置他们的机器。这意味着每个团队成员的本地机器的环境将彼此不同，并且由此延伸到生产服务器。因此，即使所有本地测试都通过，也不能保证在生产环境中也能通过。'
- en: '**Lack of independence**: When a few services depend on a shared library, they
    must all use the same version of the library.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏独立性**：当几个服务依赖于共享库时，它们必须都使用库的同一版本。'
- en: '**Time-consuming and error-prone**: Every time we want a new environment (staging/production)
    or the same environment in multiple locations, we need to manually deploy a new
    VPS instance and repeat the same steps to configure users, firewalls, and install
    the necessary packages. This produces two problems:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耗时且易出错**：每次我们想要一个新的环境（预发布/生产）或在多个位置使用相同的环境时，我们都需要手动部署一个新的VPS实例，并重复相同的步骤来配置用户、防火墙和安装必要的软件包。这产生了两个问题：'
- en: '**Time-consuming**: Manual setup can take anything from minutes to hours.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耗时**：手动设置可能需要几分钟到几小时不等。'
- en: '**Error-prone**: Humans are prone to errors. Even if we have carried out the
    same steps hundreds of times, a few mistakes will creep in somewhere.'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易出错**：人类容易出错。即使我们已经执行了相同的步骤数百次，也难免会有一些错误。'
- en: Furthermore, this problem scales with the complexity of the application and
    deployment process. It may be manageable for small applications, but for larger
    applications composed of dozens of microservices, this becomes too chaotic.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，这个问题随着应用程序和部署过程的复杂性而扩大。对于小型应用程序来说可能是可管理的，但对于由数十个微服务组成的大型应用程序来说，这变得过于混乱。
- en: '**Risky deployment**: Because the job of server configuration, updating, building,
    and running our application can only happen at deployment time, there’s more risk
    of things going wrong when deploying.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险性部署**：因为服务器配置、更新、构建和运行我们的应用程序只能在部署时进行，所以在部署时出错的风险更大。'
- en: '**Difficult to maintain**: Managing a server/environment does not stop after
    the application has been deployed. There will be software updates, and your application
    itself will be updated. When that happens, you’d have to manually enter into each
    server and apply the update, which is, again, time-consuming and error-prone.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**难以维护**：在应用程序部署之后，管理服务器/环境并不会停止。会有软件更新，你的应用程序本身也会更新。当这种情况发生时，你必须手动进入每个服务器并应用更新，这又是耗时且容易出错的。'
- en: '**Downtime**: Deploying our application on a single server means that there’s
    a single point of failure (SPOF). This means that if we need to update our application
    and restart, the application will be unavailable during that time. Therefore,
    applications developed this way cannot guarantee high availability or reliability.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停机时间**：将我们的应用程序部署在单个服务器上意味着存在一个单点故障（SPOF）。这意味着如果我们需要更新我们的应用程序并重新启动，应用程序将在这段时间内不可用。因此，以这种方式开发的应用程序无法保证高可用性或可靠性。'
- en: '**Lack of version control**: With our application code, if a bug was introduced
    and somehow slipped through our tests and got deployed on to production, we can
    simply rollback to the last-known-good version. The same principles should apply
    to our environment as well. If we changed our server configuration or upgraded
    a dependency that breaks our application, there’s no quick-and-easy way to revert
    these changes. The worse case is when we indiscriminately upgrade multiple packages
    without first noting down the previous version, then we won’t even know how to
    revert the changes!'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏版本控制**：对于我们的应用程序代码，如果引入了一个错误并且某种方式通过了我们的测试并部署到生产环境中，我们可以简单地回滚到最后已知的好版本。同样的原则也应该适用于我们的环境。如果我们更改了服务器配置或升级了一个破坏我们应用程序的依赖项，就没有快速简便的方法来撤销这些更改。最糟糕的情况是，如果我们没有先记录下上一个版本就无差别地升级了多个包，那么我们甚至不知道如何撤销更改！'
- en: '**Inefficient distribution of resources**: Our API, frontend client, and Jenkins
    CI are each deployed on their own VPS, running their own operating system, and
    controlling their own isolated pool of resources. First of all, running each service
    on its own server can get expensive quickly. Right now, we only have three components,
    but a substantial application may have dozens to hundreds of individual services.
    Furthermore, it’s likely that each service is not utilizing the full capabilities
    of the server. It is important to have a buffer at times of higher load, but we
    should minimize unused/idle resources as much as possible:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源分配效率低下**：我们的API、前端客户端和Jenkins CI各自部署在自己的VPS上，运行自己的操作系统，并控制自己的隔离资源池。首先，每个服务在自己的服务器上运行可能会迅速变得昂贵。目前我们只有三个组件，但一个大型应用程序可能有数十到数百个单独的服务。此外，每个服务可能并没有充分利用服务器的全部能力。在负载较高的时期，拥有一个缓冲是很重要的，但我们应尽可能减少未使用/空闲资源：'
- en: '![](img/4f9fb1b5-4f15-4c32-afd9-96feb2895d82.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f9fb1b5-4f15-4c32-afd9-96feb2895d82.png)'
- en: Introduction to Docker
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker简介
- en: Docker is an open source project that provides the tools and ecosystem for developers
    to build and run applications inside containers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个开源项目，为开发者提供构建和运行容器内应用程序的工具和生态系统。
- en: What are containers?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器是什么？
- en: Containerization is a method of virtualization. Virtualization is a method of
    running a virtual instance of a computer system inside a layer abstracted from
    the hardware. Virtualization allows you to run multiple operating systems on the
    same physical host machine.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化是一种虚拟化方法。虚拟化是一种在从硬件抽象出的层内运行计算机系统虚拟实例的方法。虚拟化允许你在同一物理主机机器上运行多个操作系统。
- en: From the view of an application running inside a virtualized system, it has
    no knowledge or interaction with the host machine, and may not even know that
    it is running in a virtual environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从运行在虚拟化系统中的应用程序的角度来看，它对主机机器没有任何知识或交互，甚至可能不知道它正在虚拟环境中运行。
- en: Containers are a type of virtual system. Each container is allocated a set amount
    of resources (CPU, RAM, storage). When a program is running inside a container,
    its processes and child processes can only manipulate the resources allocated
    to the container, and nothing more.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一种虚拟系统。每个容器都分配了一定数量的资源（CPU、RAM、存储）。当程序在容器内运行时，其进程和子进程只能操作分配给容器的资源，不能再操作其他资源。
- en: You can view a container as an isolated environment, or sandbox, on which to
    run your application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将容器视为一个隔离的环境，或沙盒，在其中运行你的应用程序。
- en: Workflow
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作流程
- en: So, what's a typical workflow for running a program (or programs) inside a container?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在容器内运行程序（或程序）的典型工作流程是什么？
- en: 'First, you''d specify the setup of your environment and application inside
    a *Dockerfile*, where each line is a step in the setup process:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在 *Dockerfile* 中指定你的环境和应用程序的设置，其中每一行都是设置过程中的一个步骤：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, you’d actually carry out the steps specified in the Dockerfile to generate
    an *image*. An image is a static, immutable file that contains the executable
    code of our application. The image is self-contained and includes our application
    code, as well as all of its dependencies such as system libraries and tools.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将实际执行 Dockerfile 中指定的步骤以生成 *镜像*。镜像是一个静态的、不可变的文件，包含我们应用程序的可执行代码。镜像自包含，包括我们的应用程序代码以及所有依赖项，如系统库和工具。
- en: Then, you'd use Docker to run the image. A running instance of an image is a
    container. Your application runs inside that container.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将使用 Docker 运行镜像。镜像的运行实例是容器。你的应用程序在容器内运行。
- en: By analogy, a Dockerfile contains the instructions on assembling an electric
    motor. You follow the instructions to generate the motor (image), and you can
    add electricity to the motor to make it run (container).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类比，Dockerfile 包含了组装电机的指令。你按照指令生成电机（镜像），然后你可以给电机添加电力使其运行（容器）。
- en: The only difference between Docker and our analogy is that many Docker containers
    can run on top of the same Docker image.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 与我们的类比之间的唯一区别是，许多 Docker 容器可以运行在同一个 Docker 镜像之上。
- en: How does Docker solve our issues?
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 如何解决我们的问题？
- en: 'Now that we know what Docker is, and have a rough idea of how to work with
    it, let’s see how Docker can patch up the flaws in our current workflow:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了 Docker 是什么，并且对如何使用它有一个大致的了解，那么让我们看看 Docker 如何修复我们当前工作流程中的缺陷：
- en: '**Provides consistency**: We can run multiple containers on the same image.
    Because setup and configuration are done on the image, all of our containers will
    have the same environment. By extension, this means that a test that passes in
    our local Docker instance would pass on production. This is also known as *reproducibility*,
    and reduce cases where a developer says “But it works on my machine!”. Furthermore,
    a Docker container should have all dependencies packaged inside it. This means
    it can be deployed anywhere, regardless of the operating system. Ubuntu Desktop,
    Red Hat Enterprise Linux Server, MacOS – it doesn’t matter.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供一致性**：我们可以在同一镜像上运行多个容器。因为设置和配置是在镜像上完成的，所以所有容器都将拥有相同的环境。进一步来说，这意味着在我们的本地
    Docker 实例上通过测试的测试也会在生产环境中通过。这也被称为 *可重复性*，减少了开发者说“但在我的机器上它工作得很好！”的情况。此外，Docker
    容器应该将所有依赖项打包在其内部。这意味着它可以部署在任何地方，无论操作系统如何。Ubuntu 桌面、Red Hat 企业 Linux 服务器、MacOS
    - 这都不重要。'
- en: '**Provides independence**: Every container includes all of its own dependencies,
    and can choose whichever version it wants to use.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供独立性**：每个容器都包含它自己的所有依赖项，可以选择它想要的任何版本。'
- en: '**Saves time and reduces errors**: Each setup and configuration step used to
    build our image is specified in code. Therefore, the steps can be carried out
    automatically by Docker, mitigating the risk of human error. Furthermore, once
    the image is built, you can reuse the same image to run multiple containers. Both
    of these factors mean a huge saving in man-hours.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节省时间和减少错误**：构建我们的镜像所使用的每个设置和配置步骤都已在代码中指定。因此，这些步骤可以由 Docker 自动执行，从而降低人为错误的风险。此外，一旦镜像构建完成，你可以重用相同的镜像来运行多个容器。这两个因素意味着节省了大量的人时。'
- en: '**Risky deployment**: Server configuration and building of our application
    happen at build time, and we can test the running of the container beforehand.
    The only difference between our local or staging environment, and the production
    environment, would be the differences in hardware and networking.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险部署**：服务器配置和应用程序构建发生在构建时间，我们可以在容器运行之前进行测试。我们本地或预发布环境与生产环境之间的唯一区别将是硬件和网络的不同。'
- en: '**Easier to maintain**: When an update to the application is required, you’d
    simply update your application code and/or Dockerfile, and build the image again.
    Then, you can run these new images and reconfigure your web server to direct requests
    at the new containers, before retiring the outdated ones.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于维护**：当需要更新应用程序时，你只需更新你的应用程序代码和/或 Dockerfile，然后重新构建镜像。然后，你可以运行这些新镜像，并重新配置你的
    web 服务器以将请求指向新的容器，在淘汰过时的容器之前。'
- en: '**Eliminate downtime**: We can deploy as many instances of our application
    as we want with ease, as all it requires is a single `docker run` command. They
    can run in parallel as our web server begins directing new traffic to the updated
    instances, while waiting for existing requests to be fulfilled by the outdated
    instances.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除停机时间**：我们可以轻松地部署我们想要的任何数量的应用程序实例，因为只需要一个`docker run`命令。它们可以并行运行，因为我们的Web服务器开始将新流量导向更新的实例，同时等待现有请求由过时的实例完成。'
- en: '**Version control**: The Dockerfile is a text file, and should be checked into
    the project repository. This means that if there’s a new dependency for our environment,
    it can be tracked, just like our code. If our environment starts to produce a
    lot of errors, rolling back to the previous version is as simple as deploying
    the last-known-good image.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：Dockerfile是一个文本文件，应该被提交到项目仓库中。这意味着如果我们的环境有新的依赖项，它可以被追踪，就像我们的代码一样。如果我们的环境开始产生大量错误，回滚到上一个版本就像部署最后一个已知良好的镜像一样简单。'
- en: '**Improve efficient usage of resources**: Since containers are standalone,
    they can be deployed on any machine. However, this also means multiple containers
    can be deployed on the same machine. Therefore, we can deploy the more lightweight
    or less mission-critical services together on the same machine:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高资源使用效率**：由于容器是独立的，它们可以部署在任何机器上。然而，这也意味着可以在同一台机器上部署多个容器。因此，我们可以将更轻量级或非关键任务的服务一起部署在同一台机器上：'
- en: '![](img/966d8339-227b-4649-ac48-407cc96aaf57.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/966d8339-227b-4649-ac48-407cc96aaf57.png)'
- en: For instance, we can deploy our frontend client and Jenkins CI on the same host
    machine. The client is lightweight as it’s a simple static web server, and Jenkins
    is used in development and is fine if it is slow to respond at times.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在同一台主机机器上部署我们的前端客户端和Jenkins CI。客户端很轻量，因为它是一个简单的静态Web服务器，而Jenkins用于开发，如果它有时响应缓慢也是可以接受的。
- en: 'This has the added benefit that two services share the same OS, meaning the
    overall overhead is smaller. Furthermore, pooling resources, leads to an overall
    more efficient use of our resources:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这还有一个额外的优点，即两个服务共享相同的操作系统，这意味着总体开销更小。此外，资源池化导致我们资源的使用更加高效：
- en: '![](img/1d4e7ed3-59b2-4bde-8012-2d1c15738b19.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d4e7ed3-59b2-4bde-8012-2d1c15738b19.png)'
- en: All of these benefits stem from the fact that our environments are now specified
    as code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些好处都源于我们的环境现在被指定为代码。
- en: Mechanics of Docker
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的工作原理
- en: So, now that you understand *why* we need Docker, and, at a high level, *how*
    to work with Docker, let’s turn our attention to *what* a Docker container and
    image actually are.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然你已经了解了*为什么*我们需要Docker，以及从高层次上*如何*与Docker一起工作，那么让我们将注意力转向*实际上*Docker容器和镜像是什么。
- en: What is a Docker container?
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Docker容器？
- en: Docker is based on Linux Containers (LXC), a containerization technology built
    into Linux. LXC itself relies on two Linux kernel mechanisms – **control groups**
    and **namespaces**. So, let's briefly examine each one in more detail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Docker基于Linux容器（LXC），这是一种内置在Linux中的容器化技术。LXC本身依赖于两个Linux内核机制——**控制组**和**命名空间**。因此，让我们更详细地简要考察每一个。
- en: Control groups
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制组
- en: 'Control groups (cgroups) separate processes by groups, and attach one or more
    subsystems to each group:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 控制组（cgroups）通过组来分离进程，并将一个或多个子系统附加到每个组：
- en: '![](img/9b2d9ba5-cda9-4fed-a028-fae6f8a8bd2b.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b2d9ba5-cda9-4fed-a028-fae6f8a8bd2b.png)'
- en: The subsystem can restrict the resource usage of each attached group. For example,
    we can place our application's process into the foo cgroup, attach the memory
    subsystem to it, and restrict our application to using, say, 50% of the host’s
    memory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 子系统可以限制每个附加组的资源使用。例如，我们可以将我们的应用程序进程放入foo cgroup中，将其内存子系统附加到它上面，并限制我们的应用程序使用，比如说，主机内存的50%。
- en: There are many different subsystems, each responsible for different types of
    resources, such as CPU, block I/O, and network bandwidth.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的子系统，每个子系统负责不同类型的资源，例如CPU、块I/O和网络带宽。
- en: Namespaces
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces package system resources, such as filesystems, network access, and
    so on, and present them to a process. From the view of the process, it does not
    even know that there are resources outside of its allocation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间将系统资源，如文件系统、网络访问等打包，并将它们呈现给一个进程。从进程的角度来看，它甚至不知道在其分配之外还有资源。
- en: One of the resources that can be namespaced is process IDs (PIDs). In Linux,
    PIDs are organized as a tree, with the system’s initiation process (`systemd`)
    given the PID 1, and located at the root of the tree.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进行命名空间化的资源之一是进程ID（PIDs）。在Linux中，PIDs组织成树状结构，系统的初始化进程（`systemd`）被赋予PID 1，位于树的根节点。
- en: 'If we namespace PIDs, we are masking a child process from the rest of the processes,
    by resetting the root of the child process to have a PID of 1\. This means descendant
    processes will treat the child process as if it is a root, and they will have
    no knowledge of any other processes past that point:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对PIDs进行命名空间化，我们就是通过将子进程的根重置为PID 1来屏蔽子进程的其他进程。这意味着后代进程将把子进程视为根，并且它们将不会知道任何其他进程。
- en: '![](img/68a3b66b-5163-4ad0-9d8b-64a34673e3fd.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68a3b66b-5163-4ad0-9d8b-64a34673e3fd.png)'
- en: You can view your system's process tree by running `pstree` in your terminal.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端中运行`pstree`来查看您系统的进程树。
- en: The combination of the two Linux kernel mechanisms described here allows us
    to have containers that are isolated from each other (using namespaces) and restricted
    in resources (using control groups). Each container can have its own filesystem,
    networks, and so on in isolation from other containers on the same host machine.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的两种Linux内核机制的组合使我们能够拥有彼此隔离的容器（使用命名空间）以及资源受限的容器（使用控制组）。每个容器都可以拥有自己的文件系统、网络等，与其他主机上的容器隔离。
- en: LXC and Docker
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LXC和Docker
- en: It’s important to note that Docker is *not* a new containerization technology—it
    is not replacing LXC. Rather, it is providing a standard way to define, build,
    and run LXCs using Dockerfile and the wider Docker toolchain.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Docker**不是**一种新的容器化技术——它并没有取代LXC。相反，它提供了一个使用Dockerfile和更广泛的Docker工具链定义、构建和运行LXCs的标准方式。
- en: 'In fact, on 22nd June 2015, Docker, CoreOS, and other leaders in the container
    industry established the Open Container Initiative (OCI: [opencontainers.org](https://www.opencontainers.org/)),
    a project that aims to create open industry standards around container formats
    and runtimes. The OCI has an open governance structure, and has support from the
    Linux Foundation.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，在2015年6月22日，Docker、CoreOS和其他容器行业的领导者建立了开放容器倡议（OCI: [opencontainers.org](https://www.opencontainers.org/)），这是一个旨在围绕容器格式和运行时创建开放行业标准的项目。OCI具有开放的治理结构，并得到了Linux基金会的支持。'
- en: 'Currently, the OCI provides two standard specifications:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，开放容器倡议（OCI）提供了两个标准规范：
- en: 'Image Specification (image-spec: [github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec)):
    This specifies how an image definition should be formatted. For instance, the
    OCI image should be composed of an *image manifest*, an *image configuration*,
    and a *filesystem (layer) serialization*.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '镜像规范（image-spec: [github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec)）：这规定了镜像定义应该如何格式化。例如，OCI镜像应由一个**镜像清单**、一个**镜像配置**和一个**文件系统（层）序列化**组成。'
- en: 'Runtime Specification (runtime-spec: [github.com/opencontainers/runtime-spec](https://github.com/opencontainers/runtime-spec))
    This specifies how a system may run an OCI-compliant image. Docker donated its
    container format and runtime, runC ([github.com/opencontainers/runc](https://github.com/opencontainers/runc)),
    to the OCI.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '运行时规范（runtime-spec: [github.com/opencontainers/runtime-spec](https://github.com/opencontainers/runtime-spec)）这规定了系统如何运行符合OCI规范的镜像。Docker将其容器格式和运行时，runC
    ([github.com/opencontainers/runc](https://github.com/opencontainers/runc)），捐赠给了OCI。'
- en: Apart from heavily contributing to the OCI standards, Docker has also made working
    with containers easier by providing tools that abstract low-level processes (like
    managing control groups) away from the end user, and providing a registry (Docker
    Hub) where developers can share and fork each other's images.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对OCI标准做出重大贡献外，Docker还通过提供工具简化了容器的工作，这些工具将底层过程（如管理控制组）抽象化，从而远离最终用户，并提供了一个注册表（Docker
    Hub），开发者可以在其中共享和分支彼此的镜像。
- en: Virtual Machines
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟机
- en: It’s also important to note that containers are not the only method of virtualization.
    Another common method to provide an isolated, virtual environment is by using
    *Virtual Machines* (VMs).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，容器并不是虚拟化的唯一方法。另一种常见的提供隔离虚拟环境的方法是使用**虚拟机**（VMs）。
- en: The purpose of a Virtual Machine is similar to that of a container—providing
    an isolated virtual environment—but the mechanics of it is quite different.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机的目的与容器类似——提供隔离的虚拟环境，但其机制却大不相同。
- en: A VM is an emulated computer system that runs on top of another computer system.
    It does this via a *hypervisor—*a program that has access to the physical hardware
    and manages the distribution and separation of resources between different VMs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机是运行在另一个计算机系统之上的模拟计算机系统。它是通过 *虚拟机管理程序* 来实现的——一个可以访问物理硬件并管理不同虚拟机之间资源分配和分离的程序。
- en: 'The hypervisor is the software that separates the hardware layer from the virtual
    environments, as shown in the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机管理程序是分离硬件层和虚拟环境的软件，如下面的图所示：
- en: '![](img/916e129e-bbd7-4270-843e-4e1def882d1e.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/916e129e-bbd7-4270-843e-4e1def882d1e.png)'
- en: Hypervisors can be embedded in the system hardware and runs directly on it,
    at which point they are known as Type 1 hypervisors, that is, native, bare-metal,
    or embedded hypervisors. They may also run on top of the host’s operating system,
    at which point they are known as Type 2 hypervisors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机管理程序可以嵌入到系统硬件中并直接在其上运行，此时它们被称为 Type 1 虚拟机管理程序，即原生、裸机或嵌入式虚拟机管理程序。它们也可以在宿主操作系统的之上运行，此时它们被称为
    Type 2 虚拟机管理程序。
- en: Type 1 hypervisor technology has been part of Linux since 2006, when it introduced
    the *Kernel-based Virtual Machine* (KVM).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Type 1 虚拟机管理程序技术自 2006 年 Linux 引入 *基于内核的虚拟机* (KVM) 以来一直是 Linux 的一部分。
- en: Containers versus Virtual Machines
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器与虚拟机
- en: 'When comparing containers with VMs, here are the major differences:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较容器和虚拟机时，以下是主要的区别：
- en: Virtual machines are an emulation of an entire computer system (full virtualization),
    including emulated hardware. This means users can interact with emulated, virtual
    hardware such as a network card, graphics adapter, CPUs, memory, and disks.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机是对整个计算机系统的模拟（全虚拟化），包括模拟硬件。这意味着用户可以与模拟的虚拟硬件进行交互，如网络卡、图形适配器、CPU、内存和磁盘。
- en: Virtual Machines use more resources because they are *hardware virtualization*,
    or *full virtualization*, as opposed to containers, which are virtualized at the
    operating system (OS) level.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机使用更多资源，因为它们是 *硬件虚拟化* 或 *全虚拟化*，与容器不同，容器是在操作系统（OS）级别虚拟化的。
- en: Processes inside a container are run directly on the host machine’s kernel.
    Multiple containers on the same machine would all shares the host’s kernel. In
    contrast, processes inside a VM runs on the VM's own virtual kernel and OS.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器内的进程直接在宿主机的内核上运行。同一台机器上的多个容器都会共享宿主机的内核。相比之下，虚拟机内的进程在自己的虚拟内核和操作系统上运行。
- en: Processes which run inside a container are isolated by namespaces and control
    group. Processes running inside a VM are separated by the emulated hardware.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器内运行的进程通过命名空间和控制组进行隔离。虚拟机内运行的进程通过模拟硬件进行分离。
- en: What is a Docker image?
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Docker 图像？
- en: We now know what a Docker container is, and how it is implemented at a high
    level. Let’s shift our focus onto Docker images, which are what containers are
    running on top of.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了 Docker 容器是什么以及它在高层次上的实现方式。让我们将重点转向 Docker 图像，这是容器在其之上运行的。
- en: Remember, a Docker image is a data file which contains our application and all
    of its dependencies, packaged into one entity. Let’s take a look at the anatomy
    of a Docker image, which will put us in good stead when we want to build our own
    image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Docker 图像是包含我们的应用程序及其所有依赖项的数据文件，打包成一个实体。让我们看看 Docker 图像的解剖结构，这将有助于我们构建自己的图像。
- en: Images are layered
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像是分层的
- en: An image is an ordered list of *layers*, where each layer is an operation used
    to set up the image and container. These operations may include setting/updating
    system configuration, environment variables, installation of libraries or programs,
    and so on. These operations are specified inside a *Dockerfile*. Therefore, every
    layer corresponds to an instruction in the image’s Dockerfile.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一张图片是一个有序的 *层* 列表，其中每一层都是一个用于设置图像和容器的操作。这些操作可能包括设置/更新系统配置、环境变量、安装库或程序等。这些操作都在
    *Dockerfile* 中指定。因此，每一层都对应于图像 Dockerfile 中的一个指令。
- en: 'For instance, if we are to generate a Docker image for our backend API, we
    need it to have the Node ecosystem installed, have our application code copied
    over, and our application built using yarn. Therefore, our image may have the
    following layers (lower layers are run first):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们需要为我们的后端 API 生成 Docker 图像，我们需要它安装 Node 生态系统，复制我们的应用程序代码，并使用 yarn 构建我们的应用程序。因此，我们的图像可能有以下层（底层先运行）：
- en: Run `yarn run build`
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `yarn run build`
- en: Copy application code inside the image
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像内复制应用程序代码
- en: Install a specific version of Node and yarn
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装特定版本的 Node 和 yarn
- en: '[Using a base Ubuntu image]'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用基础 Ubuntu 镜像]'
- en: Each of these operations produces a layer, which can be viewed as a *snapshot*
    of the image at this point of the setup process. The next layer depends on the
    previous layer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些操作都会创建一个层，这可以被视为设置过程中此点的镜像的 *快照*。下一个层依赖于前一个层。
- en: In the end, you get an ordered list of sequentially-dependent layers, which
    makes up the final image. This final image can then be used as a base layer for
    another image—an image is simply a set of sequential, dependent, read-only layers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你得到一个按顺序依赖的层列表，这些层构成了最终的镜像。这个最终镜像可以用作另一个镜像的基础层——一个镜像简单地说是一组顺序的、依赖的、只读层。
- en: Running a container
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器
- en: To tie up everything you've learned so far about containers, images, and layers,
    let’s take a look at what happens when we run a container.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结你到目前为止关于容器、镜像和层的所学内容，让我们看看当我们运行容器时会发生什么。
- en: 'When running a container, a new writable *container layer* is created on top
    of the read-only image (which is composed of read-only layers):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行容器时，会在只读镜像（由只读层组成）之上创建一个新的可写 *容器层*：
- en: '![](img/33ba984c-49f4-46cd-8cbc-ee300283bff6.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33ba984c-49f4-46cd-8cbc-ee300283bff6.jpg)'
- en: Any file changes are contained within the container layer. This means that when
    we are done with a container, we can simply exit the container (remove the writable
    container layer), and all changes will be discarded.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 任何文件更改都包含在容器层中。这意味着当我们完成一个容器时，我们可以简单地退出容器（移除可写容器层），所有更改将被丢弃。
- en: We won’t go into too much detail here, but you can persist files from a container
    by writing to a mounted volume, and you can keep the changes in your current container
    by creating a new image based on those changes using `docker commit`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们不会过多地深入细节，但你可以通过向挂载的卷写入文件来持久化容器中的文件，并且你可以通过基于这些更改创建一个新的镜像来保留当前容器中的更改，使用
    `docker commit`。
- en: Because a container is simply an isolated, writable layer on top of a stateless,
    read-only image, you can have multiple containers sharing access to the same image.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因为容器只是一个在无状态的只读镜像之上的隔离、可写层，你可以有多个容器共享对同一镜像的访问。
- en: '![](img/f65e34c1-2290-4ebe-8a01-1ef3b44ed456.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f65e34c1-2290-4ebe-8a01-1ef3b44ed456.jpg)'
- en: Setting up the Docker Toolchain
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Docker 工具链
- en: You now know the why's, what's, and how's, so it's now time to solidify our
    understanding by Dockerizing our existing application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道了为什么、是什么以及如何，所以现在是时候通过将现有应用程序 Docker 化来巩固我们的理解了。
- en: Let’s start by installing Docker. This will allow us to generate images and
    run them as containers on our local machine.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装 Docker。这将允许我们在本地机器上生成镜像并作为容器运行它们。
- en: There are two *editions* of Docker—**Community Edition** (**CE**) and **Enterprise
    Edition** (**EE**). We will be using the CE.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 有两个 *版本*——**社区版**（**CE**）和**企业版**（**EE**）。我们将使用 CE。
- en: Adding the Docker package repository
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Docker 软件包仓库
- en: Docker is on the official Ubuntu repository, but that version is likely to be
    out of date. Instead, we will download Docker from Docker's own official repository.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在官方 Ubuntu 仓库中，但那个版本可能已经过时。相反，我们将从 Docker 自己的官方仓库下载 Docker。
- en: 'First, let''s install the packages that''ll ensure `apt` can use the Docker
    repository over HTTPS:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装确保 `apt` 可以通过 HTTPS 使用 Docker 仓库的软件包：
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, add Docker''s official GPG key. This allows you to verify that the Docker
    package you have downloaded has not been corrupted:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加 Docker 的官方 GPG 密钥。这允许你验证你下载的 Docker 软件包没有被损坏：
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command uses `curl` to download the GPG key and add it to `apt`.
    We can then use `apt-key` to verify that the key has the fingerprint `9DC8 5822
    9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令使用 `curl` 下载 GPG 密钥并将其添加到 `apt`。然后我们可以使用 `apt-key` 验证密钥的指纹为 `9DC8 5822
    9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88`：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Please note that your fingerprint may be different.** Always refer to the
    latest key published publicly on the Docker website.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意，您的指纹可能不同。**始终参考 Docker 网站上公开发布的最新密钥。'
- en: 'Then, add the Docker repository to the list of repositories for the apt search
    for when it''s trying to find a package:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 Docker 仓库添加到 apt 的仓库列表中，以便在它尝试查找软件包时搜索：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, update the apt package index so that apt is aware of the packages
    in the Docker repository:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新 apt 软件包索引，以便 apt 能够了解 Docker 仓库中的软件包：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Installing Docker
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: 'Docker is now available on the official Docker package registry as docker-ce.
    But before we install docker-ce, we should remove older versions of Docker that
    may be on our machine:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Docker现在可在官方Docker软件包注册库中作为docker-ce提供。但在安装docker-ce之前，我们应该移除机器上可能存在的旧版Docker：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can install `docker-ce`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以安装`docker-ce`：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Verify if the installation is working by running `sudo docker version`. You
    should get an output similar to the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `sudo docker version` 来验证安装是否正常工作。你应该得到类似于以下输出的结果：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Docker Engine, Daemon, and Client
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker引擎、守护进程和客户端
- en: We’ve successfully installed Docker, but, as alluded to earlier, Docker is actually
    a suite of tools. When we "install Docker", we are actually installing the *Docker
    Engine*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功安装了Docker，但如前所述，Docker实际上是一套工具。当我们“安装Docker”时，我们实际上是在安装**Docker引擎**。
- en: 'The Docker Engine consists of the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎由以下部分组成：
- en: 'The Docker daemon (mysqld, which runs as a background process):'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker守护进程（mysqld，作为后台进程运行）：
- en: a lightweight container runtime that runs your container
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个轻量级的容器运行时，用于运行你的容器
- en: Tools that you need to build your images
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要构建镜像的工具
- en: Tools to handle a cluster of containers, such as networking, load balancing,
    and so on
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理容器集群的工具，例如网络、负载均衡等
- en: The Docker client (mysql), a command-line interface that allows you to interact
    with the Docker daemon
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker客户端（mysql），一个命令行界面，允许你与Docker守护进程交互
- en: The Docker daemon and client, together, make up the Docker Engine. This is similar
    to how npm and node get bundled together.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护进程和客户端共同构成了Docker引擎。这类似于npm和node是如何捆绑在一起的。
- en: Docker daemon exposes a REST API, which the Docker client uses to interact with
    the Docker daemon. This is similar to how the `mysql` client interacts with the
    `mysqld` daemon, or how your terminal shell provides you with an interface to
    interact with your machine.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护进程公开了一个REST API，Docker客户端使用该API与Docker守护进程交互。这类似于`mysql`客户端与`mysqld`守护进程的交互，或者你的终端shell如何为你提供一个与机器交互的接口。
- en: '![](img/3e08e1f7-7372-4a90-9f42-6d60978069bf.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e08e1f7-7372-4a90-9f42-6d60978069bf.png)'
- en: We now have Docker installed and are ready to use it to run our application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Docker，并准备好使用它来运行我们的应用程序。
- en: Running Elasticsearch on Docker
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker上运行Elasticsearch
- en: The easiest component of our application to Dockerize is Elasticsearch. It is
    easy because we don't need to write our own Dockerfile – the Docker image for
    the most current versions of Elasticsearch are already provided by Elastic. We
    just need to download the image and run them in place of our local Elasticsearch
    installation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中最容易Docker化的组件是Elasticsearch。这很容易，因为我们不需要编写自己的Dockerfile——Elasticsearch最新版本的Docker镜像已经由Elastic提供。我们只需要下载镜像并在本地Elasticsearch安装的替代位置运行它们。
- en: 'Elastic provides three types of Elasticsearch images:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Elastic提供了三种类型的Elasticsearch镜像：
- en: '`elasticsearch` (basic): Elasticsearch with X-Pack Basic features pre-installed
    and automatically activated with a free license'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elasticsearch`（基本）：带有X-Pack基本功能预安装并自动激活的Elasticsearch，使用免费许可证'
- en: '`elasticsearch-platinum`: Elasticsearch with all X-Pack features pre-installed
    and activated using a 30-day trial license'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elasticsearch-platinum`：带有所有X-Pack功能预安装和激活的Elasticsearch，使用30天试用许可证'
- en: '`elasticsearch-oss`: Only Elasticsearch'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elasticsearch-oss`：仅Elasticsearch'
- en: We won't be needing X-Pack, and so we will use the `elasticsearch-oss` flavor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要X-Pack，因此我们将使用`elasticsearch-oss`版本。
- en: 'Go to Elastic''s Docker Registry at `https://www.docker.elastic.co/`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Elastic的Docker仓库：`https://www.docker.elastic.co/`：
- en: '![](img/ab6712a5-c10e-441b-979d-67bf4d96c50e.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab6712a5-c10e-441b-979d-67bf4d96c50e.png)'
- en: 'Then, run the `docker pull` command to get the most recent version of Elasticsearch,
    making sure to replace `elasticsearch` with `elasticsearch-oss`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行`docker pull`命令以获取Elasticsearch的最新版本，确保将`elasticsearch`替换为`elasticsearch-oss`：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All Elasticsearch Docker images use centos:7 as the base image. Here, `469cfcc7a4b3`
    is the layer that comprises the centos:7 image, and you can see that subsequent
    layers are built on top of that.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Elasticsearch Docker镜像都使用centos:7作为基础镜像。在这里，`469cfcc7a4b3`是构成centos:7镜像的层，你可以看到后续层都是基于这个层构建的。
- en: 'We can verify that the image is downloaded properly by running `docker images`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行 `docker images` 来验证镜像是否已正确下载：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Docker stores its files under `/var/lib/docker`. The metadata for all Docker
    images can be found at `/var/lib/docker/image/overlay2/imagedb/content/sha256/`,
    and the contents of the images themselves can be found at `/var/lib/docker/overlay2`.
    For our `elasticsearch-oss` image, we can view its metadata inside the file at
    `/var/lib/docker/image/overlay2/imagedb/content/sha256/3822ba554fe95f9ef68baa75cae97974135eb6aa8f8f37cadf11f6a59bde0139`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 将其文件存储在 `/var/lib/docker` 下。所有 Docker 镜像的元数据可以在 `/var/lib/docker/image/overlay2/imagedb/content/sha256/`
    下找到，而镜像本身的 内容可以在 `/var/lib/docker/overlay2` 下找到。对于我们的 `elasticsearch-oss` 镜像，我们可以在
    `/var/lib/docker/image/overlay2/imagedb/content/sha256/3822ba554fe95f9ef68baa75cae97974135eb6aa8f8f37cadf11f6a59bde0139`
    文件中查看其元数据。
- en: '`overlay2` signifies that Docker is using OverlayFS as its storage driver.
    In earlier versions of Docker, the default storage driver was AUFS. However, it’s
    been superseded by OverlayFS as the latter is faster and has a simpler implementation.
    You can find out which storage driver Docker is using by running `docker info`
    and looking at the value of the SD field.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`overlay2` 表示 Docker 正在使用 OverlayFS 作为其存储驱动程序。在 Docker 的早期版本中，默认存储驱动程序是 AUFS。然而，由于
    OverlayFS 更快且实现更简单，它已经取代了 AUFS。您可以通过运行 `docker info` 并查看 SD 字段的值来找出 Docker 正在使用的存储驱动程序。'
- en: Running a container
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器
- en: 'To have confidence that our Dockerized Elasticsearch container is working,
    we should first stop our existing Elasticsearch daemon:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的 Docker 化 Elasticsearch 容器正在运行，我们首先应该停止现有的 Elasticsearch 守护进程：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As a test, run the E2E tests on our API repository and make sure you get errors
    similar to `Error: No Living connections`. This means Elasticsearch is not running
    and our API cannot connect to it.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '作为测试，在我们的 API 仓库上运行 E2E 测试，并确保您得到类似于 `Error: No Living connections` 的错误。这意味着
    Elasticsearch 没有运行，我们的 API 无法连接到它。'
- en: 'Now, use the `docker run` command to run the `elasticsearch-oss` image as a
    container:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `docker run` 命令以容器形式运行 `elasticsearch-oss` 镜像：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just as you can retrieve a list of Docker images available with `docker images`,
    you can retrieve a list of Docker containers using `$ docker ps`. Run the following
    command in a new terminal:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以使用 `docker images` 获取可用的 Docker 镜像列表一样，您可以使用 `$ docker ps` 获取 Docker 容器列表。在新的终端中运行以下命令：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Internally, Docker has added a writable layer on top of the `elasticsearch-oss`
    image, and stores it under a directory at `/var/lib/docker/containers`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Docker 在 `elasticsearch-oss` 镜像之上添加了一个可写层，并将其存储在 `/var/lib/docker/containers`
    目录下：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`config.v2.json` contains the metadata of the container, such as its status,
    its process ID (PID), when it was started, the image it is running from, its name,
    and its storage driver. <hash>-json.log stores the standard output when the container
    is running.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.v2.json` 包含容器的元数据，例如其状态、进程 ID (PID)、启动时间、运行镜像、名称以及其存储驱动程序。`<hash>-json.log`
    存储容器运行时的标准输出。'
- en: 'Now, with our container running, when we run our tests again, they are all
    passing! If we stop the container and run our tests again, they would, once again,
    fail:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们的容器正在运行，当我们再次运行测试时，它们都通过了！如果我们停止容器并再次运行测试，它们会再次失败：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can still view the stopped container using `docker ps`. However, by default,
    the `docker ps` command lists only running containers. You must use the `-a` flag
    to ensure that stopped containers are listed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以使用 `docker ps` 查看已停止的容器。但是，默认情况下，`docker ps` 命令只列出正在运行的容器。您必须使用 `-a` 标志以确保已停止的容器被列出：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Understanding the docker run option
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 docker run 选项
- en: 'Now that we have demonstrated our Dockerized Elasticsearch instance works,
    let’s go back and examine the `docker run` command we used to run it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经证明我们的 Docker 化 Elasticsearch 实例可以工作，让我们回顾一下我们用来运行它的 `docker run` 命令：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Identifying a container by name
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过名称识别容器
- en: 'You can identify a container using one of three identifiers:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下三种标识符之一来识别容器：
- en: The UUID long identifier, for example, `a415f4b646e3a715dc9fa446744934fc99ea33dd28761456381b9b7f6dcaf76b`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UUID 长标识符，例如，`a415f4b646e3a715dc9fa446744934fc99ea33dd28761456381b9b7f6dcaf76b`
- en: The UUID short identifier, for example, `a415f4b646e3`
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UUID 短标识符，例如，`a415f4b646e3`
- en: The name, for example, `nostalgic_euler`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称，例如，`nostalgic_euler`
- en: If you do not assign a name to a container when you run `docker run`, the Docker
    daemon will auto-generate a name for you, which has the structure `<adjective>_<noun>`.
    However, it might be more helpful to assign a name that describes the container’s
    function within the context of the whole application. We can do that through the
    `--name` flag.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `docker run` 命令时，如果没有为容器指定名称，Docker守护进程将自动为你生成一个名称，其结构为 `<形容词>_<名词>`. 然而，指定一个描述容器在整个应用程序中功能的名称可能更有帮助。我们可以通过
    `--name` 标志来实现这一点。
- en: Setting environment variables
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境变量
- en: The `-e` flag allows us to set environment variables. Environment variables
    set with the `-e` flag will override any environment variables set in the Dockerfile.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e` 标志允许我们设置环境变量。使用 `-e` 标志设置的环境变量将覆盖Dockerfile中设置的任何环境变量。'
- en: One of Elasticsearch’s biggest strengths is that it is a distributed data storage
    system, where multiple nodes form a *cluster* that collectively holds all the
    pieces of the whole dataset. When developing with Elasticsearch, however, we don’t
    need this clustering.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch最大的优势之一是它是一个分布式数据存储系统，其中多个节点形成一个 *集群*，共同持有整个数据集的所有片段。然而，在用Elasticsearch开发时，我们不需要这种集群。
- en: Therefore, we are setting the environment variable `discovery.type` to the value
    of single-node to tell Elasticsearch to run as a single node, and not attempt
    to join a cluster (because there are no clusters).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将环境变量 `discovery.type` 设置为单节点值，以告诉Elasticsearch以单节点模式运行，而不是尝试加入集群（因为没有集群）。
- en: Running as daemon
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以守护进程模式运行
- en: Since Elasticsearch acts as a database, we don’t need to keep an interactive
    terminal open, and can run it as a background daemon process instead.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Elasticsearch充当数据库，我们不需要保持交互式终端打开，而是可以将其作为后台守护进程运行。
- en: We can use the `-d` flag to run a container in the background.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `-d` 标志在后台运行容器。
- en: Network port mapping
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络端口映射
- en: 'Every container is accessible through its own IP address. For instance, we
    can find the IP address of our `elasticsearch-oss` container by running `docker
    inspect`, and looking under `NetworkSettings.IPAddress`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都可以通过其自己的IP地址访问。例如，我们可以通过运行 `docker inspect` 并在 `NetworkSettings.IPAddress`
    下查找来找到我们的 `elasticsearch-oss` 容器的IP地址。
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also use the `--format` or `-f` flag to retrieve only the field you
    are interested in:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `--format` 或 `-f` 标志来检索你感兴趣的仅有的字段：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: However, our local instance of our API assumes that Elasticsearch is available
    on localhost:9200, not 172.17.0.2\. If we are going to provide an equivalent behavior
    to our non-containerized Elasticsearch, we must make Elasticsearch available on
    localhost:9200\. That’s the job of the `-p` flag.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的API本地实例假定Elasticsearch在 localhost:9200 上可用，而不是 172.17.0.2\. 如果我们要为非容器化的Elasticsearch提供等效的行为，我们必须使Elasticsearch在
    localhost:9200 上可用。这是 `-p` 标志的任务。
- en: 'The `-p` flag *publishes* a port of the container and binds it to the host
    port:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p` 标志 *发布* 容器的一个端口并将其绑定到主机端口：'
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In our case, we are binding the 9200 port of `0.0.0.0` to the 9200 port of the
    container. `0.0.0.0` is a special address that refers to your local development
    machine.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将 `0.0.0.0` 的 9200 端口绑定到容器的 9200 端口。`0.0.0.0` 是一个特殊地址，它指向你的本地开发机器。
- en: 0.0.0.0
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 0.0.0.0
- en: You can refer to your local machine in many ways, in different contexts, locally
    within the same machine or within a private network.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用多种方式在本地机器的不同上下文中引用你的本地机器，无论是在同一台机器的本地还是在私有网络中。
- en: Within the context of our local machine, we can use the `127.0.0.0/8` *loopback
    addresses*. Anything sent to the loopback address is sent back to the sender;
    therefore, we can use `127.0.0.1` to refer to our own machine.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的本地机器的上下文中，我们可以使用 `127.0.0.0/8` *环回地址*. 任何发送到环回地址的数据都会发送回发送者；因此，我们可以使用 `127.0.0.1`
    来指代我们的机器。
- en: 'If your computer is part of a private network, your computer will be assigned
    an IP on this network. These private IP addresses have a limited range, as defined
    in [RFC 1918](http://www.ietf.org/rfc/rfc1918.txt):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的计算机是私有网络的一部分，你的计算机将在这个网络上分配一个IP地址。这些私有IP地址的范围有限，如 [RFC 1918](http://www.ietf.org/rfc/rfc1918.txt)
    中定义：
- en: '`10.0.0.0` - `10.255.255.255` (`10/8` prefix)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.0.0.0` - `10.255.255.255` (`10/8` 前缀)'
- en: '`172.16.0.0` - `172.31.255.255` (`172.16/12` prefix)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172.16.0.0` - `172.31.255.255` (`172.16/12` 前缀)'
- en: '`192.168.0.0` - `192.168.255.255` (`192.168/16` prefix)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.0.0` - `192.168.255.255` (`192.168/16` 前缀)'
- en: '`0.0.0.0` is a special address, which includes both your local loopback addresses
    and the IP address of your private network. For instance, if your private IP address
    is `10.194.33.8`, anything sent to `127.0.0.1` and `10.194.33.8` will be available
    for any services which are listening to `0.0.0.0`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`0.0.0.0` 是一个特殊地址，它包括您本地的回环地址和私有网络的 IP 地址。例如，如果您的私有 IP 地址是 `10.194.33.8`，则发送到
    `127.0.0.1` 和 `10.194.33.8` 的任何内容都将对监听 `0.0.0.0` 的任何服务可用。'
- en: Therefore, when we bind `0.0.0.0:9200` to the container’s port, `9200`, we are
    forwarding any request coming into our local machine on port 9200 to the container.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们将 `0.0.0.0:9200` 绑定到容器的端口 `9200` 时，我们将任何进入我们本地机器端口 9200 的请求转发到容器。
- en: This means that when we run our E2E tests, whenever our backend API is sending
    a request to `localhost:9200`, that request is forwarded inside the container
    via its `9200` port.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们运行我们的 E2E 测试时，每当我们的后端 API 向 `localhost:9200` 发送请求时，该请求将通过容器的 `9200` 端口内部转发。
- en: 'You can see all port mappings by using the `docker port` command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `docker port` 命令查看所有端口映射：
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Updating our test script
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的测试脚本
- en: We’ve successfully used Elasticsearch inside a Docker container rather than
    our local instance. This is great for testing, because any changes to the database
    are erased after the container is stopped and removed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地在 Docker 容器内部使用了 Elasticsearch，而不是我们的本地实例。这对于测试来说很棒，因为容器停止和删除后，对数据库的任何更改都会被擦除。
- en: 'Update `scripts/e2e.test.sh` to the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `scripts/e2e.test.sh` 更新为以下内容：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Instead of relying on the tester to manually start the Elasticsearch service,
    we are now adding that as part of the script.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再依赖测试人员手动启动 Elasticsearch 服务，现在我们将它作为脚本的一部分添加。
- en: Furthermore, we've added some echo statements to implement a progress bar.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还添加了一些 echo 语句来实现进度条。
- en: Dockerizing our backend API
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 化我们的后端 API
- en: Running Elasticsearch on Docker was easy, because the image was already generated
    for us. However, Dockerizing the rest of the application requires slightly more
    effort.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 上运行 Elasticsearch 很容易，因为镜像已经为我们生成了。然而，将应用程序的其他部分 Docker 化需要稍微多一点努力。
- en: We will start with Dockerizing the backend API, as this is a precondition for
    the frontend client.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将后端 API Docker 化，因为这是前端客户端的一个先决条件。
- en: 'Specifically, we''d need to do the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们需要做以下几步：
- en: Write a Dockerfile that sets up our environment so that we can run our API.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 Dockerfile，设置我们的环境，以便我们可以运行我们的 API。
- en: Generate the image from our Dockerfile.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的 Dockerfile 生成镜像。
- en: Run our API inside a container based on the image, while ensuring that it can
    communicate with the Elasticsearch instance that is running inside another Docker
    container.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于镜像的容器内运行我们的 API，同时确保它可以与运行在另一个 Docker 容器内的 Elasticsearch 实例通信。
- en: The next task is to write our Dockerfile, but before we dive straight in, let
    me give you an overview of the structure and syntax of a Dockerfile.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是编写我们的 Dockerfile，但在我们直接深入之前，让我先为您概述一下 Dockerfile 的结构和语法。
- en: Overview of a Dockerfile
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile 概述
- en: 'A Dockerfile is a text file, where each line consists of an *instruction* followed
    by one or more *arguments*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是一个文本文件，其中每一行由一个 *指令* 后跟一个或多个 *参数* 组成：
- en: '[PRE23]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are many types of instructions. Here, we will explain the most important
    ones.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 指令有很多种。在这里，我们将解释最重要的几种。
- en: 'For a complete reference of all instructions and arguments in a valid Dockerfile,
    refer to the Dockerfile reference at [docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有效 Dockerfile 中所有指令和参数的完整参考，请参阅 [docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    上的 Dockerfile 参考：
- en: '`FROM`: This specifies the *base image*, which is the Docker image we are basing
    our own image on. Each Dockerfile must have a `FROM` instruction as the *first*
    instruction. For example, if we want our application to run on an Ubuntu 18.04
    machine, then we’d specify `FROM` ubuntu:bionic.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`: 这指定了 *基础镜像*，这是我们基于自己的镜像构建的 Docker 镜像。每个 Dockerfile 必须有一个 `FROM` 指令作为
    *第一个* 指令。例如，如果我们想让我们的应用程序在 Ubuntu 18.04 机器上运行，那么我们会指定 `FROM ubuntu:bionic`。'
- en: '`RUN`: This specifies the command(s) to run at build time, when we run `docker
    build`. Each `RUN` command corresponds to a layer that comprises our image.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`: 这指定了在构建时运行的命令（s），当我们运行 `docker build` 时。每个 `RUN` 命令对应于包含我们的镜像的一层。'
- en: '`CMD / ENTRYPOINT`: This specifies the command to execute at runtime, after
    the container is initiated with `docker run`. At least one of the `CMD` and/or
    the `ENTRYPOINT` command should be specified. `CMD` should be used to provide
    *default* arguments for an `ENTRYPOINT` command. There should be one, and only
    one, `CMD` instruction in a Dockerfile. If multiple are provided, the last one
    will be used.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD / ENTRYPOINT`: 这指定了在容器通过 `docker run` 启动后要执行的命令。至少应指定一个 `CMD` 和/或 `ENTRYPOINT`
    命令。`CMD` 应用于为 `ENTRYPOINT` 命令提供 *默认* 参数。Dockerfile 中应只有一个 `CMD` 指令。如果提供了多个，则最后一个将被使用。'
- en: '`ADD / COPY`: This copies files, directories, or remote file URLs to a location
    inside the filesystem of the image. `COPY` is similar to `ADD` except it does
    not support remote URLs, it does not unpack archive files, and it does not invalidate
    cached `RUN` instructions (even if the contents has changed). You can look at
    `COPY` as a lightweight version of `ADD`. You should use `COPY` over `ADD` whenever
    possible.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD / COPY`: 这会将文件、目录或远程文件 URL 复制到镜像文件系统的某个位置。`COPY` 与 `ADD` 类似，但它不支持远程 URL，不展开归档文件，也不使缓存的
    `RUN` 指令失效（即使内容已更改）。您可以将 `COPY` 视为 `ADD` 的轻量级版本。在可能的情况下，您应该使用 `COPY` 而不是 `ADD`。'
- en: '`WORKDIR`: This changes the working directory for any `RUN`, `CMD`, `ENTRYPOINT`,
    `COPY`, and `ADD` instructions that come after the `WORKDIR` instruction in the
    Dockerfile'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR`: 这更改了 `WORKDIR` 指令之后的任何 `RUN`、`CMD`、`ENTRYPOINT`、`COPY` 和 `ADD` 指令的工作目录。'
- en: '`ENV`: This sets environment variables that are available during build *and*
    runtime.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`: 这设置在构建 *和* 运行时都可用的环境变量。'
- en: '`ARG`: This defines variables that can be defined at build time (not runtime)
    by passing the `--build-arg <varname>=<value>` flag into `docker build`.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARG`: 这定义了可以在构建时（而不是运行时）通过将 `--build-arg <varname>=<value>` 标志传递给 `docker
    build` 来定义的变量。'
- en: '`ENV` and `ARG` both provide variables during build time, but `ENV` values
    also persist into the built image. In cases where `ENV` and `ARG` variables share
    the same name, the `ENV` variable takes precedence:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV` 和 `ARG` 都在构建时提供变量，但 `ENV` 的值也会持久化到构建的镜像中。在 `ENV` 和 `ARG` 变量同名的情况下，`ENV`
    变量具有优先权：'
- en: '`EXPOSE`: This acts as a form of documentation that informs developers of which
    ports are being listened to by services running inside the container.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`: 这充当一种文档形式，通知开发者容器内运行的服务正在监听哪些端口。'
- en: Despite its name, EXPOSE does not expose the port from the container to the
    host. Its purpose is solely for documentation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其名称如此，`EXPOSE` 并不会将端口从容器暴露到主机。它的目的纯粹是用于文档。
- en: 'There are other, less commonly used instructions:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些不太常用的指令：
- en: '`ONBUILD`: This allows you to add commands that are to be run by child images
    (images which use the current image as a base image). The commands would be run
    immediately after the `FROM` instruction in the child image.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONBUILD`: 这允许您添加由子镜像（使用当前镜像作为基础镜像的镜像）运行的命令。这些命令将在子镜像中的 `FROM` 指令之后立即运行。'
- en: '`LABEL`: This allows you to attach arbitrary metadata, in the form of key-value
    pairs, to the image. Any containers loaded with the image would also carry that
    label. Uses for labels are very broad; for example, you can use it to enable load
    balancers to identify containers based on their labels.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LABEL`: 这允许您以键值对的形式附加任意元数据到镜像。任何加载了该镜像的容器也会携带该标签。标签的用途非常广泛；例如，您可以使用它来使负载均衡器能够根据标签识别容器。'
- en: '`VOLUME`: This specifies a mount point in the host’s filesystem where you can
    persist data, even after the container is destroyed.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME`: 这指定了主机文件系统中的一个挂载点，您可以在容器被销毁后持久化数据。'
- en: '`HEALTHCHECK`: This specifies commands that are run at regular intervals to
    check that the container is not just alive, but functional. For example, if a
    web server process is running, but unable to receive requests, it would be deemed
    unhealthy.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`: 这指定了定期运行的命令，以检查容器不仅活着，而且功能正常。例如，如果 Web 服务器进程正在运行，但不能接收请求，则会被视为不健康。'
- en: '`USER`: This specifies the username or UID to use when building/running the
    image.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`: 这指定了构建/运行镜像时要使用的用户名或 UID。'
- en: '`STOPSIGNAL`: This specifies the system call signal that will be sent to the
    container to exit.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOPSIGNAL`: 这指定了将发送到容器的系统调用信号，以使其退出。'
- en: 'Dockerfile instructions are case-insensitive. However, the convention is to
    use UPPERCASE. You can also add comments in Dockerfiles using hashes (`#`):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 指令不区分大小写。然而，惯例是使用大写。您还可以在 Dockerfile 中使用哈希符号 (`#`) 添加注释：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Writing our Dockerfile
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的Dockerfile
- en: Now that we have a broad understanding of what instructions are available in
    a Dockerfile, let’s write our own Dockerfile for our backend API.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Dockerfile中可用的指令有了广泛的了解，让我们编写我们自己的Dockerfile来构建我们的后端API。
- en: Picking a base image
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择基础镜像
- en: 'The first decision to make is to pick a base image. Normally, we would choose
    a Linux distribution as our base image. For instance, we can pick Ubuntu as our
    base image:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的决定是选择一个基础镜像。通常，我们会选择一个Linux发行版作为我们的基础镜像。例如，我们可以选择Ubuntu作为我们的基础镜像：
- en: '[PRE25]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use the `bionic` *tag* to specify the exact version of Ubuntu we want (18.04
    Long Term Support (LTS)).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`bionic`标签来指定我们想要的Ubuntu的确切版本（18.04长期支持（LTS）版本）。
- en: However, as it turns out, Node has its own official Docker image available on
    Docker Hub ([hub.docker.com/_/node/](https://hub.docker.com/_/node/)). Therefore,
    we can use the Node Docker image as our base image instead.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上，Node在Docker Hub上有一个自己的官方Docker镜像([hub.docker.com/_/node/](https://hub.docker.com/_/node/))。因此，我们可以使用Node
    Docker镜像作为我们的基础镜像。
- en: 'To use the Node Docker image as the base image, replace our `FROM` instruction
    with `FROM node:8`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Node Docker镜像作为基础镜像，将我们的`FROM`指令替换为`FROM node:8`：
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For local development, we have been using NVM to manage our Node versions. This
    is useful when working on multiple JavaScript projects because it allows us to
    switch between different versions of Node easily. However, there are no such requirements
    for our container – our backend API image will only ever run one version of Node.
    Therefore, our Docker image should have a specific version. We used the tag `8`
    because Node 8 is the latest LTS version available at the time of writing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地开发，我们一直在使用NVM来管理我们的Node版本。当我们在多个JavaScript项目上工作时，这很有用，因为它允许我们轻松地在不同的Node版本之间切换。然而，对于我们的容器没有这样的要求——我们的后端API镜像将始终只运行一个版本的Node。因此，我们的Docker镜像应该有一个特定的版本。我们使用了标签`8`，因为Node
    8是当时可用的最新LTS版本。
- en: The Node Docker image has yarn pre-installed, so there are no more dependencies
    we need to install.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Node Docker镜像已经预装了yarn，因此我们不需要安装更多的依赖项。
- en: Copying project files
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制项目文件
- en: 'Next, we need to copy in our project code into our container. We will use the
    `COPY` instruction, which has the following signature:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的项目代码复制到容器中。我们将使用`COPY`指令，它具有以下签名：
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`src` is the path on the host machine where files will be copied from. The
    src path will be resolved against the *context*, which is a directory we can specify
    when we run `docker build`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`是在主机上文件将被复制的路径。`src`路径将相对于上下文解析，上下文是我们运行`docker build`时可以指定的目录。'
- en: '`dest` is the path inside the container where the files are to be copied to.
    The `dest` path can be either absolute or relative. If relatively, it will be
    resolved against the `WORKDIR`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`dest`是在容器内部文件要复制的路径。`dest`路径可以是绝对路径或相对路径。如果是相对路径，它将相对于`WORKDIR`解析。'
- en: 'Below the `FROM` instruction, add a `WORKDIR` and `COPY` instruction:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FROM`指令下方，添加`WORKDIR`和`COPY`指令：
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This simply copies all the files from the context to the `/root/` inside the
    container.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将上下文中的所有文件复制到容器内的`/root/`。
- en: Building our application
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的应用程序
- en: 'Next, we need to install the npm packages required by our application, and
    build our application using `yarn run build`. Add the following lines after the
    `COPY` instruction:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装我们应用程序所需的npm包，并使用`yarn run build`构建我们的应用程序。在`COPY`指令之后添加以下行：
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Specifying the executable
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定可执行文件
- en: 'Every container needs to execute a command to run after the container is initialized.
    For us, this will be using the node command to run our application:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器在初始化后都需要执行一个命令来运行。对于我们来说，这将是通过使用node命令来运行我们的应用程序：
- en: '[PRE30]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Building our image
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的镜像
- en: 'Our Dockerfile is now ready, and we can use it to generate the image using
    `docker build`, which has the following signature:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Dockerfile现在准备好了，我们可以使用它通过`docker build`生成镜像，该命令具有以下签名：
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `docker build` command builds an image based on the Dockerfile and a *context*.
    The context is a directory which should contain all the files that are needed
    to build the image. In our case, it is also where our application code is to be
    copied from.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build`命令基于Dockerfile和上下文构建一个镜像。上下文是一个目录，它应该包含构建镜像所需的所有文件。在我们的例子中，它也是我们的应用程序代码要从中复制的位置。'
- en: 'For example, if we are at the project root directory, we can run the following
    command to build our image, using the current working directory as the context:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们处于项目根目录，我们可以运行以下命令来构建我们的镜像，使用当前工作目录作为上下文：
- en: '[PRE32]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By default, if you don’t specify the location of the Dockerfile, Docker would
    try to find it at the root of the context. So, if you are in the root directory
    of the context, you can simply run the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果您没有指定Dockerfile的位置，Docker会尝试在上下文的根目录中找到它。所以，如果您在上下文的根目录中，您可以简单地运行以下命令：
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, we don''t want to copy *all* of the contents of the project, because:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不想复制项目的所有内容，因为：
- en: It's generally a bad idea to add things you don't need—it makes it harder for
    someone trying to understand the logic of the application, because there's more
    noise
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常来说，添加不需要的东西是个糟糕的主意——这会让试图理解应用程序逻辑的人感到更困难，因为噪声更多。
- en: It adds to the size of the image
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加了镜像的大小
- en: For instance, there is over 320 MB inside the .git, node_modules, and docs directories—files
    which we don't need inside our container to build and run our application.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在.git、node_modules和docs目录中，有超过320 MB的内容——这些文件在我们的容器中构建和运行应用程序时并不需要。
- en: '[PRE34]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Therefore, we can use a special file called `.dockerignore`, which is similar
    to `.gitignore`, and will disregard certain files from the context.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用一个特殊的文件，称为`.dockerignore`，它类似于`.gitignore`，并将忽略上下文中的某些文件。
- en: 'But instead of specifying which files we will ignore, we’ll be more explicit
    and add a rule to ignore *all* files, and add exceptions to this rule in subsequent
    lines. Add the following lines to `.dockerignore`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不会指定要忽略哪些文件，而会更加明确地添加一个规则来忽略所有文件，并在随后的行中添加例外。将以下行添加到`.dockerignore`中：
- en: '[PRE35]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, run `$ docker build -t hobnob:0.1.0 .` and check that the image is created
    by running `docker images`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`$ docker build -t hobnob:0.1.0 .`并检查通过运行`docker images`来确认镜像是否已创建：
- en: '[PRE36]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Although the image size is still quite large (814 MB), much of this comes from
    the standard node image, which is 673 MB. Without limiting the scope of the context,
    the hobnob image size easily goes over 1 GB.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管镜像大小仍然相当大（814 MB），其中很大一部分来自标准的node镜像，该镜像大小为673 MB。如果不限制上下文的范围，hobnob镜像的大小很容易超过1
    GB。
- en: Running our image
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的镜像
- en: 'Ensure that the Elasticsearch container is running and that it has bound its
    port to our local machine. Then, run our hobnob image using `docker run`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Elasticsearch容器正在运行，并且它已经将其端口绑定到我们的本地机器。然后，使用`docker run`运行我们的hobnob镜像：
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that we are using the `--env-file` option to pass in our environment variables
    at runtime instead of build time.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用`--env-file`选项在运行时传递环境变量，而不是在构建时。
- en: 'To check that our container is running without errors, check the stdout produced
    inside the container, which we can conveniently check using `docker logs`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的容器是否在无错误的情况下运行，检查容器内产生的stdout，我们可以方便地使用`docker logs`来检查：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the container's log does not show the preceding success message, go back
    and repeat the steps closely. You may want to use `docker stop hobnob` and `docker
    rm hobnob` to stop and remove the container, and `docker rmi hobnob` to remove
    the image. You may also enter into the container (like with SSH) by executing
    `docker exec -it hobnob bash`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器的日志没有显示前面的成功消息，请返回并仔细重复这些步骤。您可能想要使用`docker stop hobnob`和`docker rm hobnob`来停止和删除容器，并使用`docker
    rmi hobnob`来删除镜像。您还可以通过执行`docker exec -it hobnob bash`进入容器（类似于SSH）。
- en: 'Assuming everything is up and running, we’d still need to check that the application
    is actually functional by querying the API using curl:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切正常，我们仍然需要通过使用curl查询API来检查应用程序是否实际上可用：
- en: '[PRE39]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This means that the request from our host has successfully reached our application,
    and that the application can successfully communicate with our database!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着来自我们主机的请求已成功到达我们的应用程序，并且应用程序可以成功与我们的数据库通信！
- en: Persisting data
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化数据
- en: The last essential step before we complete our migration to Docker is to persist
    the data inside our Elasticsearch container(s).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成迁移到Docker的最后一步之前，最重要的步骤是将我们的Elasticsearch容器内的数据持久化。
- en: Docker containers, by their nature, are ephemeral, which means after they are
    removed, the data contained inside them are lost.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器本质上是无状态的，这意味着在它们被删除后，容器内的数据将丢失。
- en: 'To persist data, or to allow containers to use existing data, we must use *Volumes*.
    Let’s use the docker CLI to create it now:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持久化数据，或者允许容器使用现有数据，我们必须使用*卷*。现在让我们使用docker CLI来创建它：
- en: '[PRE40]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can use the `-v` flag to instruct Docker to mount this named volume into
    the `/usr/share/elasticsearch/data` directory inside the `elasticsearch` container:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-v`标志来指示Docker将这个命名卷挂载到`elasticsearch`容器内的`/usr/share/elasticsearch/data`目录：
- en: '[PRE41]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, if we remove the `elasticsearch` container and deploy a new one using the
    preceding command, the data is persisted in the esdata named volume.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们删除`elasticsearch`容器并使用前面的命令部署一个新的容器，数据将持久保存在名为esdata的命名卷中。
- en: Following best practices
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循最佳实践
- en: Next, let's improve our Dockerfile by applying best practices.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过应用最佳实践来改进我们的Dockerfile。
- en: Shell versus exec forms
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell与exec形式
- en: 'The `RUN`, `CMD`, and `ENTRYPOINT` Dockerfile instructions are all used to
    run commands. However, there are two ways to specify the command to run:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`、`CMD`和`ENTRYPOINT` Dockerfile指令都用于运行命令。然而，有两种方式来指定要运行的命令：'
- en: '*shell* form; `RUN yarn run build`: The command is run inside a new shell process,
    which, by default, is `/bin/sh -c` on Linux and `cmd /S /C` on Windows'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*shell*形式；`RUN yarn run build`：命令在新的shell进程中运行，默认情况下，在Linux上是`/bin/sh -c`，在Windows上是`cmd
    /S /C`'
- en: '*exec* form; `RUN ["yarn", "run", "build"]`: The command is not run inside
    a new shell process'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*exec*形式；`RUN ["yarn", "run", "build"]`：命令不会在新的shell进程中运行'
- en: The shell form exists to allow you to use shell processing features like variable
    substitution and to chain multiple commands together. However, not every command
    requires these features. In those cases, you should use the exec form.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 壳形式存在是为了让你能够使用像变量替换这样的壳处理功能，并将多个命令连接在一起。然而，并非每个命令都需要这些功能。在这些情况下，你应该使用exec形式。
- en: When shell processing is not required, the exec form is preferred because it
    saves resources by running one less process (the shell process).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当不需要shell处理时，exec形式更受欢迎，因为它通过运行一个更少的进程（shell进程）来节省资源。
- en: 'We can demonstrate this by using ps, which is a Linux command-line tool that
    shows you a snapshot of the current processes. First, let’s enter into our container
    using `docker exec`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用ps来演示这一点，ps是一个Linux命令行工具，可以显示当前进程的快照。首先，让我们使用`docker exec`进入我们的容器：
- en: '[PRE42]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, run `ps` to get a list of currently-running processes. We are using the
    `-o` option to select only the parameters we are interested in:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`ps`以获取当前运行的进程列表。我们使用`-o`选项来选择我们感兴趣的参数：
- en: '[PRE43]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, with the shell form, `/bin/sh` is run as the root init process
    (PID 1), and it is the parent process that invokes the node.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用shell形式时，`/bin/sh`作为根init进程（PID 1）运行，并且是父进程调用node。
- en: Ignore the bash and ps processes. Bash is the process we were using to interact
    with the container when we ran `docker exec -it hobnob bash`, and ps is the process
    we ran to get the output.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略bash和ps进程。Bash是我们运行`docker exec -it hobnob bash`时与容器交互的进程，ps是我们运行以获取输出的进程。
- en: 'Now, if we update the `RUN` and `CMD` commands inside our Dockerfile to the
    exec form, we get the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们更新Dockerfile中的`RUN`和`CMD`命令到exec形式，我们得到以下结果：
- en: '[PRE44]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we run this new image and enter into the container, we can run our ps command
    again, and see that the node process is now the root process:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个新镜像并进入容器，我们可以再次运行我们的ps命令，并看到节点进程现在是根进程：
- en: '[PRE45]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Allowing Unix signaling
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许Unix信号传递
- en: One may argue that an extra process is not important in the grand scheme of
    things, but there are further implications of running commands inside a shell.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争论，在整体方案中，额外的进程并不重要，但运行命令在shell中的运行还有进一步的含义。
- en: When using the shell form for the `CMD` or `ENTRYPOINT` instruction, the executable
    is run inside an additional shell process, which means it will not be run with
    PID of 1, which means it will *not* receive Unix signals.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用shell形式进行`CMD`或`ENTRYPOINT`指令时，可执行文件将在一个额外的shell进程中运行，这意味着它将不会以PID 1运行，这意味着它将*不会*接收Unix信号。
- en: Unix signals are passed by the Docker daemon to control containers. For instance,
    when running docker stop hobnob, the daemon will send a `SIGTERM` signal to the
    hobnob container’s root process (PID 1).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Unix信号由Docker守护进程传递以控制容器。例如，当运行`docker stop hobnob`时，守护进程将向hobnob容器的根进程（PID
    1）发送`SIGTERM`信号。
- en: When using the shell form, it is the shell which receives this signal. If we
    are using sh as the shell, it will not pass the signal on to the processes it
    is running.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用shell形式时，接收这个信号的是shell。如果我们使用sh作为shell，它将不会将信号传递给它正在运行的进程。
- en: However, we have not added any code in our Node.js applications to respond to
    Unix signals. The easiest way to resolve this is to wrap it in an init system
    so that when that system receives a `SIGTERM` signal, it will terminate all of
    the container’s processes. As of Docker 1.13, a lightweight init system called
    Tini was included by default, and can be enabled by using the `--init` flag passed
    to `docker run`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有在我们的 Node.js 应用程序中添加任何代码来响应 Unix 信号。解决这个问题的最简单方法是将它包装在一个 init 系统中，这样当该系统收到
    `SIGTERM` 信号时，它将终止容器中的所有进程。截至 Docker 1.13，一个名为 Tini 的轻量级 init 系统默认包含在内，可以通过传递给
    `docker run` 的 `--init` 标志来启用。
- en: 'Therefore, when we run our hobnob image, we should use the following command
    instead:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们运行我们的 hobnob 镜像时，我们应该使用以下命令代替：
- en: '[PRE46]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Running as a non-root user
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以非root用户运行
- en: By default, Docker will run commands inside the container as the root user.
    This is a security risk. Therefore, we should run our application as a non-root
    user.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 将在容器内部以 root 用户运行命令。这是一个安全风险。因此，我们应该以非root用户运行我们的应用程序。
- en: Conveniently, the Node Docker image already has a user called node. We can use
    the USER instruction to instruct Docker to run the image as the node user instead
    of root.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 便利的是，Node Docker 镜像已经有一个名为 node 的用户。我们可以使用 USER 指令来指示 Docker 以 node 用户而不是 root
    用户运行镜像。
- en: Because of this, we should also move our application to a location accessible
    by the node user.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们也应该将我们的应用程序移动到节点用户可访问的位置。
- en: 'Update the Dockerfile with the following lines; place them immediately after
    the `FROM` instruction:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下行更新 Dockerfile；将它们放在 `FROM` 指令之后立即放置：
- en: '[PRE47]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We also need to change the `COPY` instruction:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改 `COPY` 指令：
- en: '[PRE48]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Although we have set the `USER` instruction to use the node user, the `USER`
    instruction only affects the `RUN`, `CMD`, and `ENTRYPOINT` instructions. By default,
    when we use `COPY` to add files into our container, those are added as the root
    user. To sign the copied files to another user or group, we can use the `--chown`
    flag.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经设置了 `USER` 指令以使用 node 用户，但 `USER` 指令仅影响 `RUN`、`CMD` 和 `ENTRYPOINT` 指令。默认情况下，当我们使用
    `COPY` 将文件添加到我们的容器中时，这些文件是以 root 用户添加的。要为另一个用户或组签名复制的文件，我们可以使用 `--chown` 标志。
- en: 'Change the `COPY` instruction to the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `COPY` 指令更改为以下内容：
- en: '[PRE49]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Taking advantage of the cache
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用缓存
- en: At the moment, we are copying our entire application code, installing its dependencies,
    and then building the application.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在复制整个应用程序代码，安装其依赖项，然后构建应用程序。
- en: 'But what if I make changes to my application code, but do not introduce any
    new dependencies? In our current approach, we’d have to run all three steps again,
    and the `RUN ["yarn"]` step is likely going to take a long time as it has to download
    thousands of files:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我修改了我的应用程序代码，但没有引入任何新的依赖项呢？在我们的当前方法中，我们不得不再次运行所有三个步骤，而 `RUN ["yarn"]` 步骤可能需要很长时间，因为它必须下载成千上万的文件：
- en: '[PRE50]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Fortunately, Docker implements a clever caching mechanism. Whenever Docker generates
    an image, it stores the underlying layers in the filesystem. When Docker is asked
    to build a new image, instead of blindly following the instructions again, Docker
    will check its existing cache of layers to see if there are layers it can simply
    reuse.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker 实现了一个巧妙的缓存机制。每当 Docker 生成一个镜像时，它都会在文件系统中存储其底层层。当 Docker 被要求构建一个新的镜像时，它不会盲目地再次遵循指令，而是会检查其现有的层缓存，看看是否有可以简单重用的层。
- en: 'As Docker steps through each instruction, it will try to use the cache whenever
    possible, and will only invalidate the cache under the following circumstances:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Docker 遍历每个指令时，它将尽可能使用缓存，并且仅在以下情况下才会使缓存失效：
- en: Starting from the same parent image, there are no cached layers that were built
    with *exactly* the same instruction as the next instruction in our current Dockerfile.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从相同的父镜像开始，没有与当前 Dockerfile 中下一个指令 *完全相同* 的指令构建的缓存层。
- en: If the next instruction is `ADD` or `COPY`, Docker will create a checksum for
    each file, based on the *contents* of each file. If *any* of the checksums do
    not match the ones in the cached layer, the cache is invalidated.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果下一个指令是 `ADD` 或 `COPY`，Docker 将为每个文件创建一个校验和，基于每个文件的 *内容*。如果 *任何* 校验和不匹配缓存层中的校验和，缓存将被失效。
- en: 'Therefore, we can modify the preceding three instructions (`COPY`, `RUN`, `RUN`)
    to the following four instructions:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将前面的三个指令（`COPY`、`RUN`、`RUN`）修改为以下四个指令：
- en: '[PRE51]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, if our dependencies that are specified solely inside our `package.json`,
    `package-log.json`, and `yarn.lock` files, have not changed, then the first two
    steps here will not be run again. Instead, the cached layer that we previously
    generated will be used.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们的依赖项仅在我们内部的 `package.json`、`package-lock.json` 和 `yarn.lock` 文件中指定，并且没有变化，那么这里的前两个步骤将不会再次运行。相反，我们将使用之前生成的缓存的层。
- en: Caveats
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Let’s say we have the following Dockerfile:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下的 Dockerfile：
- en: '[PRE52]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If we ran this one month ago, and have the layers stored in the cache, and went
    to build it again today, Docker will use the cached layer, even though the apt
    sources list is likely to be out of date.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一个月前运行了这个镜像，并且有层存储在缓存中，然后今天再次构建它，Docker 将会使用缓存的层，即使 apt 源列表可能已经过时。
- en: This is done so that you can have a reproducible build. Let’s imagine I made
    some changes to my code. If I build a new image and it fails, I want to be certain
    that this is because of the changes I have made, not because of a bug in one of
    the packages that was silently updated.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了确保您有一个可重复的构建。让我们想象我对我的一些代码进行了修改。如果构建新的镜像失败，我想确定这是因为我所做的更改，而不是因为某个包中静默更新的错误。
- en: If you’d like to disable the cache and build a brand new image, you can do so
    by passing the `--no-cache` flag to docker build.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想禁用缓存并构建一个新的镜像，可以通过传递 `--no-cache` 标志给 docker build 来实现。
- en: Using a lighter image
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更轻量级的镜像
- en: 'We have been using the node:8 image as the base of our Hobnob image. However,
    like Elasticsearch, Node Docker images come in many flavors:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用 `node:8` 镜像作为 Hobnob 镜像的基础。然而，就像 Elasticsearch 一样，Node Docker 镜像有多种风味：
- en: '**standard**: This uses buildpack-deps:jessie as its base image. buildpack-deps
    is an image that provides a collection of the most common build dependencies,
    such as the GNU Compiler Collection ([gcc.gnu.org](https://gcc.gnu.org/)) and
    GNU Make ([gnu.org/software/make/](https://www.gnu.org/software/make/)). The buildpack-deps:jessie
    image is, itself, based on the debian:jessie Debian 8 image.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**standard**：它使用 buildpack-deps:jessie 作为其基础镜像。buildpack-deps 是一个提供最常见构建依赖项集合的镜像，例如
    GNU 编译器集合 ([gcc.gnu.org](https://gcc.gnu.org/)) 和 GNU Make ([gnu.org/software/make/](https://www.gnu.org/software/make/))。buildpack-deps:jessie
    镜像本身是基于 debian:jessie Debian 8 镜像。'
- en: '**slim**: This is the same as the standard image, but does not contain all
    the build dependencies. Instead, it only contains curl, wget, ca-certificates,
    and the minimal set of packages that are required to work with Node.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**slim**：这与标准镜像相同，但不包含所有构建依赖项。相反，它只包含 curl、wget、ca-certificates 以及与 Node 一起工作的最小包集。'
- en: '**stretch**: This is similar to the standard flavor, but uses Debian 9 (Stretch)
    instead of Debian 8 (Jessie).'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stretch**：这与标准风味相似，但使用 Debian 9（Stretch）而不是 Debian 8（Jessie）。'
- en: '**alpine**: The standard and slim flavors use Debian as its base image. The
    alpine flavor uses Alpine Linux as its base image. Alpine is a distribution which
    is extremely lightweight, and thus its images are also smaller than others.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**alpine**：标准版和精简版使用 Debian 作为其基础镜像。alpine 版本使用 Alpine Linux 作为其基础镜像。Alpine
    是一个非常轻量级的发行版，因此其镜像也比其他镜像小。'
- en: 'If we look at the Docker images for all the popular Linux distributions, you’ll
    find that alpine is, by far, the smallest:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看所有流行 Linux 发行版的 Docker 镜像，你会发现 alpine 是迄今为止最小的：
- en: '[PRE53]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Keeping a container lightweight is important, as it affects how quickly a container
    can be deployed. Let''s pull the more lightweight Node Docker images and compare
    them:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 保持容器轻量级很重要，因为它会影响容器部署的速度。让我们拉取更轻量级的 Node Docker 镜像并进行比较：
- en: '[PRE54]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As you can see, the `node:8-alpine` image is the smallest. So, let’s use that
    as our base image. Just to recap, your Docker image should now look like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`node:8-alpine` 镜像是最小的。因此，让我们将其用作我们的基础镜像。为了回顾，您的 Docker 镜像现在应该看起来像这样：
- en: '[PRE55]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let’s remove the previous hobnob image and build a new one:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们移除之前的 hobnob 镜像并构建一个新的：
- en: '[PRE56]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, the size of our image has decreased from 814 MB to 210 MB –
    a 74% decrease!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的镜像大小已从 814 MB 减少到 210 MB - 减少了 74%！
- en: Removing obsolete files
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除过时的文件
- en: 'At the moment, we are copying the src directory into the container, and then
    using it to build our application. However, after the project is built, the src
    directory and other files like package.json and yarn.lock are not required to
    run the application:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在将 src 目录复制到容器中，然后使用它来构建我们的应用程序。然而，在项目构建完成后，src 目录以及其他文件如 package.json
    和 yarn.lock 都不再需要来运行应用程序：
- en: '[PRE57]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can see that 138.1 MB is actually being used for the Yarn cache, which we
    don’t need. Therefore, we should remove these obsolete *artifacts*, and leave
    only the dist and node_modules directories.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，实际上有 138.1 MB 被用于 Yarn 缓存，而我们不需要这些。因此，我们应该删除这些过时的 *工件*，只留下 dist 和 node_modules
    目录。
- en: 'After the RUN ["yarn", "run", "build"] instruction, add an additional instruction
    to remove the obsolete files:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RUN ["yarn", "run", "build"]` 指令之后，添加一个额外的指令来删除过时的文件：
- en: '[PRE59]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: However, if you run docker build on this new Dockerfile, you may be surprised
    to see that the size of the image has not decreased. This is because each layer
    is simply a diff on the previous layer, and once a file is added to an image,
    it cannot be removed from the history.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在这个新的 Dockerfile 上运行 docker build，你可能会惊讶地看到镜像的大小并没有减少。这是因为每个层只是对前一个层的
    diff，一旦文件被添加到镜像中，就无法从历史记录中删除。
- en: 'To minimize the image''s size, we must remove the artifacts before we finish
    with the instruction. This means that we must squash all of our installation and
    build commands into a single `RUN` instruction:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化镜像的大小，我们必须在完成指令之前删除工件。这意味着我们必须将所有的安装和构建命令压缩到一个单一的 `RUN` 指令中：
- en: '[PRE60]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, the image is just 122 MB, which is a 42% space saving!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，镜像的大小仅为 122 MB，这节省了 42% 的空间！
- en: '[PRE61]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: However, doing so will forfeit the benefits we get from caching. Luckily, Docker
    supports a feature called *multi-stage builds*, which allows us to cache our layers,
    as well as have a small file size.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做将放弃我们从缓存中获得的利益。幸运的是，Docker 支持一个名为 *多阶段构建* 的功能，它允许我们缓存我们的层，同时保持文件大小较小。
- en: Multi-stage builds
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多阶段构建
- en: Multi-stage builds is a feature that was added in Docker v17.05\. It allows
    you to use multiple `FROM` instructions to define multiple images as *stages*
    inside a single Dockerfile.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建是 Docker v17.05 版本中新增的功能。它允许你使用多个 `FROM` 指令在单个 Dockerfile 中定义多个作为 *阶段*
    的镜像。
- en: You can extract artifacts from the previous stage and add them to the next stage
    in a single instruction (and thus a single layer).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在单个指令（因此是单个层）中从上一个阶段提取工件并将其添加到下一个阶段。
- en: 'In our case, we can define two stages – one for building our application, and
    the second one that just copies the dist and `node_modules` directory and specifies
    the CMD instruction:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们可以定义两个阶段——一个用于构建我们的应用程序，第二个阶段仅复制 dist 和 `node_modules` 目录并指定 CMD 指令：
- en: '[PRE62]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We use the `as` keyword to name our stage, and refer to them in the `COPY` instructions
    using the `--from` flag.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `as` 关键字来命名我们的阶段，并在 `COPY` 指令中使用 `--from` 标志来引用它们。
- en: 'Now, if we build this using Dockerfile, we end up with two images:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用 Dockerfile 构建，最终会得到两个镜像：
- en: '[PRE63]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The one without a name, `<none>`, represents the first stage, and the hobnob:0.1.0
    image is the second stage. As you can see, our image is now only 122 MB, but we
    still benefited from our multi-layer Dockerfile and caching.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 没有命名的镜像 `<none>` 代表第一个阶段，而 hobnob:0.1.0 镜像是第二个阶段。正如你所看到的，我们的镜像现在只有 122 MB，但我们仍然从我们的多层
    Dockerfile 和缓存中受益。
- en: Security
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Lastly, the security of our Docker image is important. Conveniently, the Docker
    team has provided a tool called *Docker Bench for Security* ([github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security))
    that will analyze your running containers against a large list of common best
    practices.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们 Docker 镜像的安全性很重要。方便的是，Docker 团队提供了一个名为 *Docker Bench for Security* 的工具
    ([github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security))，它将分析你的运行容器与大量常见最佳实践的大列表进行对比。
- en: 'The tool is available as a container itself, and can be run using the following
    command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具本身就是一个容器，可以使用以下命令运行：
- en: '[PRE64]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After you’ve run the test, study each warning and see if you can improve on
    the setup.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在你运行测试后，研究每个警告，看看你是否可以改进设置。
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We have now encapsulated our application’s component services into portable,
    self-contained Docker images, which can be run as containers. In doing so, we
    have improved our deployment process by making it:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将应用程序的组件服务封装到便携的、自包含的 Docker 镜像中，这些镜像可以作为容器运行。通过这样做，我们通过以下方式改进了我们的部署流程：
- en: '**Portable:** The Docker images can be distributed just like any other file.
    They can also be run in any environment.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携性**: Docker 镜像可以像任何其他文件一样分发。它们也可以在任何环境中运行。'
- en: '**Predictable/Consistent:** The image is self-contained and pre-built, which
    means it will run in the same way wherever it is deployed.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测/一致**: 镜像是自包含的且预先构建的，这意味着它在任何部署的地方都会以相同的方式运行。'
- en: '**Automated:** All instructions are specified inside a Dockerfile, meaning
    our computer can run them like code.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化：** 所有指令都指定在 Dockerfile 中，这意味着我们的计算机可以像运行代码一样运行它们。'
- en: However, despite containerizing our application, we are still manually running
    the `docker run` commands. Furthermore, we are running single instances of these
    containers on a single server. If the server fails, our application will go down.
    Moreover, if we have to make an update to our application, there'll still be downtime
    (although now it's a shorter downtime because deployment can be automated).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管我们对应用程序进行了容器化，但我们仍然手动运行 `docker run` 命令。此外，我们在单个服务器上运行这些容器的单个实例。如果服务器故障，我们的应用程序将停止运行。此外，如果我们需要对应用程序进行更新，仍然会有停机时间（尽管现在停机时间更短，因为部署可以自动化）。
- en: Therefore, while Docker is part of the solution, it is not the whole solution.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然 Docker 是解决方案的一部分，但它并不是整个解决方案。
- en: In the next chapter, we will build on this chapter and use cluster orchestration
    systems such as Kubernetes to manage the running of these containers. Kubernetes
    allows us to create distributed clusters of redundant containers, each deployed
    on a different server, so that when one server fails, the containers deployed
    on the other servers will still keep the whole application running. This also
    allows us to update one container at a time without downtime.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将基于本章内容，并使用如 Kubernetes 这样的集群编排系统来管理这些容器的运行。Kubernetes 允许我们创建由冗余容器组成的分布式集群，每个容器都部署在不同的服务器上，这样当一台服务器故障时，其他服务器上部署的容器仍然可以保持整个应用程序的运行。这也允许我们一次更新一个容器，而无需停机。
- en: Overall, Kubernetes will allow us to scale our application to handle heavy loads,
    and allows our application to have a reliable uptime, even when we experience
    hardware failures.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Kubernetes 将使我们能够扩展应用程序以处理重负载，并允许我们的应用程序即使在经历硬件故障时也能保持可靠的正常运行时间。
