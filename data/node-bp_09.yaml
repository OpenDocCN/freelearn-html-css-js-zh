- en: Chapter 9. Automate Your Testing with Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章：使用 Node.js 自动化测试
- en: 'In the previous chapter, we learned how to work with Grunt and Gulp to automate
    our development process. These two Node.js modules have a huge collection of plugins,
    which we can use in almost every case. In this chapter, we will talk about testing,
    its importance, and how to integrate it in our workflow. The following is a list
    of topics that we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 Grunt 和 Gulp 自动化我们的开发过程。这两个 Node.js 模块拥有大量的插件，我们几乎可以在任何情况下使用它们。在本章中，我们将讨论测试的重要性以及如何将其集成到我们的工作流程中。以下是我们将要涵盖的主题列表：
- en: Popular testing methodologies
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行测试方法
- en: The Jasmine framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine 框架
- en: The Mocha framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha 框架
- en: Testing with PhantomJS and DalekJS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PhantomJS 和 DalekJS 进行测试
- en: Understanding the importance of writing tests
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解编写测试的重要性
- en: When developing software, the code we write can be put in the browser, run as
    a desktop program, or started as a Node.js script. In all these cases, we expect
    specific results. Every line of code has some significance, and we need to know
    whether the final product will do the job. Normally, we debug our applications,
    that is, we write part of the program and run it. By monitoring the output or
    its behavior, we assess whether everything is okay or whether there is a problem.
    However, this approach is time-consuming, especially if the project is big. Iterations
    through every single feature of the application costs a lot of time and money.
    Automated testing helps in such cases. From an architectural viewpoint, testing
    is very important. That's because when the system is complex and we have numerous
    relationships between the modules, it is difficult to add new features or introduce
    major changes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，我们编写的代码可以放入浏览器中运行，作为桌面程序运行，或者作为 Node.js 脚本启动。在这些所有情况下，我们都期望得到特定的结果。每一行代码都有其重要性，我们需要知道最终产品是否能够完成工作。通常，我们会调试我们的应用程序，也就是说，我们编写程序的一部分并运行它。通过监控输出或其行为，我们评估一切是否正常，或者是否存在问题。然而，这种方法很耗时，尤其是如果项目很大。对应用程序的每个功能进行迭代需要花费大量的时间和金钱。自动测试在这种情况下很有帮助。从架构的角度来看，测试非常重要。这是因为当系统复杂，模块之间存在众多关系时，添加新功能或引入重大更改就变得困难。
- en: 'We can''t really guarantee that everything will work as it worked before the
    modifications. So, instead of relying on manual testing, it is much better to
    create scripts that can do this for us. Writing tests has several major benefits,
    as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上无法保证修改后一切都会像以前一样工作。因此，与其依赖手动测试，不如创建可以为我们完成这项工作的脚本。编写测试有以下几个主要好处：
- en: This proves that our software is stable and works as expected.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这证明了我们的软件是稳定的，并且按预期工作。
- en: This saves a lot of time because we don't have to repeatedly perform manual
    testing.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可以节省大量时间，因为我们不必反复进行手动测试。
- en: A badly written code with a lot of dependencies cannot be tested easily. Writing
    tests in most of these cases leads to better code.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码编写得不好，有很多依赖关系，很难进行测试。在这些大多数情况下编写测试会导致更好的代码。
- en: If we have a solid test suite, we can extend the system without worrying about
    damaging something.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个稳固的测试套件，我们就可以在不用担心损坏任何东西的情况下扩展系统。
- en: If the tests cover all the application's features, then they can be used as
    the application's documentation.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试覆盖了应用程序的所有功能，那么它们可以用作应用程序的文档。
- en: Choosing a testing methodology
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择测试方法
- en: There are few popular ways of writing tests. Let's see which are they and the
    differences between them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 存在少数流行的编写测试的方法。让我们看看它们是什么，以及它们之间的区别。
- en: Test-driven development
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**Test-driven development** (**TDD**) is a process that relies on the repetition
    of short development cycles. In other words, we write our test while writing the
    implementation. The shorter the cycles, the better. The following diagram shows
    the TDD flow:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一个依赖于重复短周期开发过程的过程。换句话说，我们在编写实现的同时编写测试。周期越短，越好。以下图表显示了 TDD
    流程：'
- en: '![Test-driven development](img/00038.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![测试驱动开发](img/00038.jpeg)'
- en: Before we write the actual code that does the job for us, we need to prepare
    a test. Of course, after the first run, the test will fail because nothing has
    been implemented. So, we need to ensure that the test passes all the cycles. Once
    this happens, we may spend some time refactoring what has been done so far and
    continue with the next method, class, or feature. Note that everything spins around
    the test, which is a really good thing because this is where we define what our
    code should do. With this as a basis, we avoid delivering unnecessary code. We
    can also be sure that the implementation meets the requirements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写实际为我们完成工作的代码之前，我们需要准备一个测试。当然，在第一次运行后，测试将失败，因为没有实现任何内容。因此，我们需要确保测试通过所有循环。一旦发生这种情况，我们可能会花一些时间重构到目前为止所做的工作，并继续进行下一个方法、类或功能。请注意，一切围绕着测试旋转，这真的是一件好事，因为这是我们定义代码应该做什么的地方。有了这个基础，我们可以避免交付不必要的代码。我们还可以确保实现符合要求。
- en: Behavior-driven development
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: '**Behavior-driven development** (**BDD**) is similar to TDD. In fact, if the
    project is a small one, we can''t really spot the differences. The idea of this
    approach is to focus more on the specification and the application''s processes,
    rather than the actual code. For example, if we test a module that posts messages
    on Twitter with TDD, we will probably ask the following questions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）与TDD类似。事实上，如果项目很小，我们实际上无法发现它们之间的区别。这种方法的理念是更多地关注规范和应用程序的过程，而不是实际的代码。例如，如果我们用TDD测试一个在Twitter上发布消息的模块，我们可能会问以下问题：'
- en: Is the message empty?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息是否为空？
- en: Is the message length less than 140 symbols?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息长度是否小于140个符号？
- en: Is the Ajax request made properly?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ajax请求是否正确执行？
- en: Does the returned JSON contain certain fields?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的JSON是否包含某些字段？
- en: 'However with BDD, we ask only the following question:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用BDD，我们只问以下问题：
- en: Is the message sent to Twitter?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息是否已发送到Twitter？
- en: Both processes are interrelated and, as we said, sometimes there is no difference
    at all. What we should remember is that BDD focuses on what the code is doing
    and TDD on how the code is doing it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个过程是相互关联的，正如我们所说的，有时它们之间根本没有任何区别。我们应该记住的是，BDD关注代码正在做什么，而TDD关注代码是如何做的。
- en: Classifying tests
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试分类
- en: 'There are several types of tests that you may write, which evaluate our system
    by giving an input and expecting a specific output. However, they also perform
    this evaluation on different parts. It is good to know their names, which are
    listed as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要编写几种不同的测试，这些测试通过提供输入并期望特定输出来评估我们的系统。然而，它们也会在不同的部分进行这种评估。了解它们的名称是很有帮助的，如下列所示：
- en: '**Unit testing**: Unit testing performs checks on a single part of the application;
    it focuses on one unit. Often, we face difficulties in writing such tests because
    we can''t split our code into units; this is usually a bad sign. If there is no
    clearly defined module, we can''t proceed with such tests. Distributing the logic
    to different units not only helps in testing but also contributes to the overall
    stability of the program. Let''s illustrate the problem with the following diagram:![Classifying
    tests](img/00039.jpeg)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：单元测试对应用程序的单个部分进行检查；它关注一个单元。我们经常在编写此类测试时遇到困难，因为我们无法将代码拆分成单元；这通常是一个坏信号。如果没有明确定义的模块，我们就无法进行此类测试。将逻辑分配到不同的单元不仅有助于测试，还有助于程序的总体稳定性。让我们用以下图表来说明这个问题：![测试分类](img/00039.jpeg)'
- en: 'Let''s assume we have an e-commerce site that sells products to our users.
    In the preceding diagram, processes such as log in, ordering, and logout are handled
    by one class, defined in the `App.js` file. Yes, it works. We may achieve the
    goal and successfully close the circle, but this is absolutely not unit testable
    because there are no units. It is much better if we split the responsibilities
    into different classes, as shown in the following diagram:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们假设我们有一个电子商务网站，该网站向我们的用户销售产品。在上面的图表中，登录、订购和注销等流程由一个类处理，该类在`App.js`文件中定义。是的，它工作。我们可能达到目标并成功完成循环，但这绝对不是可单元测试的，因为没有单元。如果我们将责任分割到不同的类中，会更好，如下面的图表所示：
- en: '![Classifying tests](img/00040.jpeg)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![测试分类](img/00040.jpeg)'
- en: 'We continue to use `App.js` and it still controls everything. However, the
    different parts of the whole flow are divided between three classes: `Router`,
    `Users`, and `Payments`. Now, we are able to write unit tests.'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们继续使用`App.js`，它仍然控制一切。然而，整个流程的不同部分被分配到三个类中：`Router`、`Users`和`Payments`。现在，我们能够编写单元测试。
- en: '**Integration testing**: Integration tests output a result for several units
    or components. If we look at the preceding example, the integration test will
    simulate the whole process of ordering a product, that is, logging in, buying,
    and logging out. Normally, integration tests use several modules of the system
    and ensure that the modules work properly together.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：集成测试为多个单元或组件输出结果。如果我们看前面的例子，集成测试将模拟整个订购产品的过程，即登录、购买和登出。通常，集成测试会使用系统的几个模块，并确保这些模块能正确协同工作。'
- en: '**Functional testing**: The functional tests are closely related to integration
    tests and focus on a specific functionality in the system. It may involve several
    modules or components.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：功能测试与集成测试密切相关，并关注系统中的特定功能。它可能涉及多个模块或组件。'
- en: '**System testing**: The system tests test our program in different environments.
    In the context of Node.js, this could be when running our scripts on different
    operating systems and monitoring the output. Sometimes there are differences and
    if we want to globally distribute our work, we need to ensure that our program
    is compatible with the most popular systems.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**：系统测试在不同的环境中测试我们的程序。在Node.js的上下文中，这可能是在不同的操作系统上运行我们的脚本并监控输出时。有时会有差异，如果我们想全球分布我们的工作，我们需要确保我们的程序与最流行的系统兼容。'
- en: '**Stress or performance testing**: These tests evaluate our application beyond
    the defined specifications and show how our code reacts to heavy traffic or complex
    queries. They are really helpful when making a decision about the program''s architecture
    or choosing a framework.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力或性能测试**：这些测试评估我们的应用程序超出定义的规范，并显示我们的代码对高流量或复杂查询的反应。当决定程序的架构或选择框架时，它们非常有帮助。'
- en: There are some other types of testing, but the previously mentioned testing
    methods are the most popular. There is no strict policy on what tests to write.
    Of course, there are good practices, but what we should focus on is writing a
    testable code. There is nothing better than an application fully covered with
    tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些其他类型的测试，但前面提到的测试方法是最受欢迎的。没有关于要编写哪些测试的严格政策。当然，有良好的实践，但我们应该关注的是编写可测试的代码。没有任何事情比一个完全被测试覆盖的应用程序更好。
- en: 'As testing is a really important part of the development process, there are
    frameworks specifically oriented toward writing tests. In general, when we use
    a framework, we need the following two tools:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试是开发过程中的一个非常重要的部分，有一些框架专门针对编写测试。通常，当我们使用框架时，我们需要以下两个工具：
- en: '**Test runner**: This is the part of the framework that runs our tests and
    displays messages whether they pass or fail.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试运行器**：这是框架的一部分，用于运行我们的测试并显示它们是否通过或失败。'
- en: '**Assertions**: These methods are used for the actual checks, that is, if we
    need to see whether an variable is `true`, then we can write `expect(active).toBe(true)`
    instead of just `if(active === true)`. It''s better for the reader and also prevents
    some strange situations; for example, if we want to see whether a variable is
    defined or not, the `if` statement in the following code returns `true` because
    the `status` variable has a value and this value is `null`. In fact, we are asking
    whether the `status` variable initialized, and if we leave the test in this manner,
    we will get wrong results. That''s why we need an assertion library that has proper
    methods for testing. The following code is the example that shows that the `status`
    variable is actually defined and its type is `object`:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：这些方法用于实际的检查，也就是说，如果我们需要检查一个变量是否为`true`，我们可以写`expect(active).toBe(true)`而不是仅仅`if(active
    === true)`。这对读者更好，也能防止一些奇怪的情况；例如，如果我们想检查一个变量是否已定义，下面代码中的`if`语句返回`true`，因为`status`变量有一个值，而这个值是`null`。实际上，我们是在询问`status`变量是否已初始化，如果我们以这种方式留下测试，我们将得到错误的结果。这就是为什么我们需要一个具有适当测试方法的断言库。以下代码是显示`status`变量实际上已定义且其类型为`object`的示例：'
- en: '[PRE0]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using Jasmine
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jasmine
- en: Jasmine is a framework to test the JavaScript code. It is available as a Node.js
    module and also as a library, which we can use in the browser. It comes with its
    own assertion methods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个用于测试JavaScript代码的框架。它作为Node.js模块和库提供，我们可以在浏览器中使用它。它自带断言方法。
- en: Installing Jasmine
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Jasmine
- en: 'We are going to use the Node.js version of the framework. It''s a module, so
    it can be installed via the Node.js package manager, `npm`, as shown in the following
    code line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用框架的Node.js版本。它是一个模块，因此可以通过Node.js包管理器`npm`进行安装，如下面的代码行所示：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding command will set up Jasmine globally, so we can run `jasmine-node`
    in every directory of our choice. The tests could be organized into different
    files placed in one folder or in subfolders. The only requirement is to end the
    filenames with `spec.js`, for example, `testing-payments.spec.js` or `testing-authorization.spec.js`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在全局设置Jasmine，因此我们可以在我们选择的每个目录中运行`jasmine-node`。测试可以组织到放在一个文件夹或子文件夹中的不同文件中。唯一的要求是文件名以`spec.js`结尾，例如`testing-payments.spec.js`或`testing-authorization.spec.js`。
- en: Defining the module for testing
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义测试模块
- en: 'Before we write the actual test, let''s define the application we want to build.
    Let''s say we need a Node.js module that reads a file and finds specific words
    inside it. The following is the basic file structure that we are starting from:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写实际测试之前，让我们定义我们想要构建的应用程序。假设我们需要一个Node.js模块，它可以读取文件并找到其中的特定单词。以下是我们开始的基本文件结构：
- en: '![Defining the module for testing](img/00041.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![定义测试模块](img/00041.jpeg)'
- en: 'The code that tests the application will be placed in `tests/test.spec.js`,
    the implementation of the logic will be in `app.js`, and the file that we will
    read from will be `file.txt`. Let''s open the `file.txt` file and add the following
    text inside:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序的代码将放在`tests/test.spec.js`中，逻辑的实现将在`app.js`中，我们将从中读取的文件将是`file.txt`。让我们打开`file.txt`文件并在其中添加以下文本：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's a phrase used to test typewriter's keys. It contains all the letters
    from the English alphabet and is perfect for our small project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于测试打字机键的短语。它包含英语字母表中的所有字母，非常适合我们的小型项目。
- en: Following the test-driven development concept
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循测试驱动开发的概念
- en: 'The task is simple and we can probably solve it in around 20 lines of code.
    For sure, we can wrap all the code in one function and perform everything there.
    The downside is that if something goes wrong, we can''t detect where the problem
    occurs. That''s why we will split the logic into two parts and test them separately
    in the following ways:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 任务很简单，我们可能只需要大约20行代码就能解决。当然，我们可以将所有代码封装在一个函数中并执行所有操作。缺点是如果出现问题，我们无法检测问题发生的位置。这就是为什么我们将逻辑分成两部分，并以下述方式分别测试它们：
- en: Reading the file's content
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件内容
- en: Searching for a certain word inside the file's content
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件内容中搜索特定单词
- en: As we explained in the beginning of this chapter, we will write the test first,
    we will see it fail, and then will write the code for `app.js`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所解释的，我们将先编写测试，然后观察它失败，接着编写`app.js`的代码。
- en: Testing the file-reading process
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试文件读取过程
- en: Writing tests, just like any other task, can be challenging. Sometimes, we can't
    determine what to test and what to exclude. There is a certain unsaid rule that
    advices users to avoid working on features that are tested by other developers—in
    our example, we need not test whether the file is read successfully. If we do
    that, it will look like we are testing the filesystem API of Node.js, which is
    not necessary.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试，就像任何其他任务一样，可能会具有挑战性。有时，我们无法确定要测试什么以及要排除什么。存在一条未明说的规则，建议用户避免开发其他开发者已测试的功能——在我们的例子中，我们不需要测试文件是否成功读取。如果我们这样做，它将看起来像我们在测试Node.js的文件系统API，这是不必要的。
- en: 'Every test written with Jasmine starts with the `describe` clause. Add the
    following code to `tests/test.spec.js`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用Jasmine编写的测试都以`describe`子句开始。将以下代码添加到`tests/test.spec.js`中：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are adding meaningful information that tells what exactly we are going to
    test. The second argument of `it` is again a function. The difference is that
    it accepts an argument, which is another function. We need to call it once we
    are done with the checks. Many scripts in JavaScript are asynchronous, and the
    `done` callback helps us in handling such operations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在添加有意义的信息，告诉我们将要测试什么。`it`的第二个参数再次是一个函数。不同之处在于它接受一个参数，即另一个函数。我们在完成检查后需要调用它。许多JavaScript脚本都是异步的，而`done`回调帮助我们处理此类操作。
- en: The preceding code block includes the `app.js` module and verifies the result.
    The `expect` method accepts a subject of the assertion, and the following chained
    methods perform the actual check.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块包括`app.js`模块并验证结果。`expect`方法接受一个断言的主题，接下来的链式方法执行实际的检查。
- en: 'We have a test ready, so we can execute it. Run `jasmine-node ./tests` and
    you will see the following result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了测试，所以我们可以执行它。运行`jasmine-node ./tests`，你将看到以下结果：
- en: '![Testing the file-reading process](img/00042.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![测试文件读取过程](img/00042.jpeg)'
- en: 'The test case passes. The `app.js` file is empty, but even then Node.js doesn''t
    fail. The value of the `app` variable is actually an empty object. Let''s continue
    and try to imagine the methods that we will need. In the following code we are
    adding one more block testing a `read` API method of the module:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例通过了。`app.js`文件是空的，但即使如此，Node.js也不会失败。`app`变量的值实际上是一个空对象。让我们继续，并尝试想象我们需要的方法。在以下代码中，我们添加了一个额外的代码块来测试模块的`read`API方法：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first `it` runs well but the second one raises an error. That''s because
    there is nothing in `app.js`. We don''t have a `read` method there. The error
    is shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`it`运行良好，但第二个引发了一个错误。这是因为`app.js`中没有内容。我们没有在那里定义`read`方法。错误显示在下述屏幕截图：
- en: '![Testing the file-reading process](img/00043.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![测试文件读取过程](img/00043.jpeg)'
- en: Note that we can clearly see what went wrong. If someone, for some reason, deletes
    or renames the used method, this test will fail. Even if the function exists,
    we expect to see a specific result that validates the job of the module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以清楚地看到出了什么问题。如果有人出于某种原因删除或重命名了使用的方法，这个测试将失败。即使函数存在，我们也期望看到特定的结果来验证模块的工作。
- en: 'Now, we have to start writing the actual code of the application. We should
    make the test passing. Place the following code in `app.js`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须开始编写应用程序的实际代码。我们应该使测试通过。将以下代码放在`app.js`中：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run the test, it will fail but for another reason, and that''s because
    there is no logic inside the `read` method. The following screenshot is the result
    in the console:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行测试，它将失败，但原因不同，这是因为`read`方法中没有逻辑。以下屏幕截图是控制台的结果：
- en: '![Testing the file-reading process](img/00044.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![测试文件读取过程](img/00044.jpeg)'
- en: 'This time the `read` method is defined, but it doesn''t return anything and
    `expect(content).toBe("The quick brown fox jumps over the lazy dog.")` fails.
    Let''s read `file.txt` with the Node.js file API and return its content:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这次`read`方法被定义了，但它没有返回任何内容，`expect(content).toBe("The quick brown fox jumps over
    the lazy dog.")`失败了。让我们使用Node.js文件API读取`file.txt`并返回其内容：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, the color of the test is in green, which indicates that the module has
    the method we used and that method returns what we expect, as shown in the following
    screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试的颜色是绿色，这表明模块有我们使用的方法，并且该方法返回了我们期望的结果，如以下屏幕截图所示：
- en: '![Testing the file-reading process](img/00045.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![测试文件读取过程](img/00045.jpeg)'
- en: Finding strings in the file content
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文件内容中查找字符串
- en: 'By using the same methodology, we will implement the second part of our application:
    finding words inside the file. The following is the new `describe` block, which
    we will start with the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用相同的方法，我们将实现应用程序的第二部分：在文件中查找单词。以下是我们将开始的新的`describe`代码块：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We require a `check` method that accepts two arguments. The first one is the
    word we want to find, and the second one is the string that will contain it. Note
    that we are not using the `read` method. The idea is to test the function separately
    and guarantee that it works properly. This is a very important step because it
    makes our `check` method universal. It is not bound to the idea of matching the
    text inside a file; however, it does match the text inside a string. If we don''t
    use the test-driven workflow, we may end up with one function that does both the
    operations: reading the file and scanning its content. However, in our case, we
    can use the same module with the text fetched from a database or via an HTTP request.
    And, if we find that our module doesn''t find a particular word, we will know
    that the problem lies in the `check` function because it is tested as separate
    unit.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个接受两个参数的`check`方法。第一个是我们想要查找的单词，第二个是包含它的字符串。请注意，我们没有使用`read`方法。我们的想法是单独测试该函数，并确保它正常工作。这是一个非常重要的步骤，因为它使我们的`check`方法通用。它不受匹配文件内部文本的想法的限制；然而，它确实匹配字符串内部的文本。如果我们不使用测试驱动的工作流程，我们可能会得到一个同时执行这两个操作的功能：读取文件和扫描其内容。然而，在我们的情况下，我们可以使用从数据库或通过HTTP请求获取的文本的相同模块。而且，如果我们发现我们的模块没有找到特定的单词，我们将知道问题出在`check`函数上，因为它被单独作为单元测试。
- en: 'The following is the code of the new method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是新方法的代码：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The test is now passed with three assertions as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，测试现在通过了三个断言：
- en: '![Finding strings in the file content](img/00046.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![在文件内容中查找字符串](img/00046.jpeg)'
- en: Writing an integration test
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: 'The tests we have written so far were unit tests, that is, they tested the
    two units of our application. Now, let''s add an integration test. Again, we need
    a failing test that uses the module. So, we are starting with the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止编写的测试是单元测试，即它们测试了我们应用程序的两个单元。现在，让我们添加一个集成测试。同样，我们需要一个失败的测试来使用该模块。因此，我们开始于以下代码：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that we are not keeping the content of the file in a temporary variable,
    and we are not passing it to the `check` method. In fact, we are not interested
    in the actual content of the file. We are interested only if it contains a specific
    string. So, our module should handle this and keep the text in it. The preceding
    test fails and the following message is displayed:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并没有将文件内容保存在一个临时变量中，也没有将其传递给 `check` 方法。实际上，我们对文件的实际内容不感兴趣。我们只关心它是否包含特定的字符串。因此，我们的模块应该处理这种情况并保留其中的文本。前面的测试失败，并显示以下消息：
- en: '![Writing an integration test](img/00047.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![编写集成测试](img/00047.jpeg)'
- en: 'The following are the changes needed to make `app.js` work as we want it to:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们使 `app.js` 按照预期工作的所需更改：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will simply store the text in a local variable named `fileContent`. Note
    that we are making changes carefully and keeping the return logic of the `read`
    method. This is needed because there is a test that requires this functionality.
    This shows one more benefit of TDD. We ensure that the code, before including
    our modifications, works in its original form. In complex systems or applications,
    this is extremely important, and without tests, this will be really difficult
    to achieve. The final result is again a screenshot with a green message:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地将在一个名为 `fileContent` 的局部变量中存储文本。请注意，我们正在谨慎地做出更改并保留 `read` 方法的返回逻辑。这是必需的，因为有一个测试需要这个功能。这显示了
    TDD 的另一个好处。我们确保在包含我们的修改之前，代码以原始形式工作。在复杂系统或应用程序中，这一点非常重要，没有测试，这将非常难以实现。最终结果又是一个带有绿色消息的截图：
- en: '![Writing an integration test](img/00048.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![编写集成测试](img/00048.jpeg)'
- en: Testing with Mocha
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mocha 进行测试
- en: Mocha is a little more advanced testing framework than Jasmine. It is more configurable,
    supports TDD or BDD testing, and even has several types of reporters. It is also
    quite popular and portable for client-side usage in the browser, which makes it
    a good candidate for our testing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 是一个比 Jasmine 更先进的测试框架。它更可配置，支持 TDD 或 BDD 测试，并且甚至有几种类型的报告器。它也非常受欢迎，适用于在浏览器中进行客户端使用，这使得它成为我们测试的一个很好的候选者。
- en: Installation
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'Similar to Jasmine, we need the Node.js''s package manager to install Mocha.
    By running the following command, the framework will be set up globally:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Jasmine 类似，我们需要 Node.js 的包管理器来安装 Mocha。通过运行以下命令，框架将被全局设置：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the installation finishes, we can run `mocha ./tests`. By default, the
    tool searches for JavaScript files and tries to run them. Here, let's use the
    same example used with Jasmine and pass it through Mocha. It actually uses the
    same syntax of the `describe` and `it` blocks. However, it doesn't come with its
    own assertion library. In fact, there is a built-in Node.js module for such purposes
    named `assert`. There are also libraries developed by other developers, for example,
    `should.js`, `chai`, or `expect.js`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以运行 `mocha ./tests`。默认情况下，该工具会搜索 JavaScript 文件并尝试运行它们。这里，让我们使用与 Jasmine
    相同的示例并通过 Mocha 运行它。实际上，它使用相同的 `describe` 和 `it` 块语法。然而，它没有自己的断言库。实际上，有一个名为 `assert`
    的内置 Node.js 模块用于此类目的。还有其他开发者开发的库，例如 `should.js`、`chai` 或 `expect.js`。
- en: 'They differ in certain aspects but do the same job: checking actual and expected
    values and raising an error if they don''t match. After that, the framework catches
    the error and displays the results.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在某些方面有所不同，但执行相同的任务：检查实际值和预期值，如果它们不匹配则抛出错误。之后，框架捕获错误并显示结果。
- en: Translating our example using Mocha
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Mocha 翻译我们的示例
- en: 'Everything is the same but the `expect` module calls are replaced with `assert.equal`.
    We used `assert.fail` to notify the framework that there is something wrong. The
    following are the other `describe` blocks:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都相同，只是将 `expect` 模块调用替换为 `assert.equal`。我们使用了 `assert.fail` 来通知框架存在问题。以下是一些其他的
    `describe` 块：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the latest changes, the tests should pass and we should see the following
    screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 随着最新的更改，测试应该通过，我们应该看到以下截图：
- en: '![Translating our example using Mocha](img/00050.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![使用Mocha翻译我们的示例](img/00050.jpeg)'
- en: Selecting a reporter
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择报告器
- en: 'Mocha is quite flexible when we talk about reporters. The reporter is the part
    of the framework that displays the results on the screen. There are a dozen of
    options we can choose from. To set the type of the reporter, we should use the
    `-R` option in the command line, for example, the closest thing to Jasmine''s
    reporter is the `dot` type, as shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到报告器时，Mocha非常灵活。报告器是框架中显示结果的那个部分。我们有几十种选项可以选择。为了设置报告器的类型，我们应该在命令行中使用`-R`选项，例如，与Jasmine的报告器最接近的是`dot`类型，如下面的截图所示：
- en: '![Selecting a reporter](img/00051.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![选择报告器](img/00051.jpeg)'
- en: 'To see more detailed information about the passed or failed tests, we can use
    the `spec` reporter as shown in the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看有关通过或失败的测试的更详细的信息，我们可以使用`spec`报告器，如下面的截图所示：
- en: '![Selecting a reporter](img/00052.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![选择报告器](img/00052.jpeg)'
- en: 'There is also a reporter that looks like a landing plane (the `landing` type)
    as shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个看起来像着陆飞机（`landing`类型）的报告器，如下面的截图所示：
- en: '![Selecting a reporter](img/00053.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![选择报告器](img/00053.jpeg)'
- en: Testing with a headless browser
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用无头浏览器进行测试
- en: So far we learned how to test our code. We can write a module, class, or library,
    and if it has an API, we can test it. However, if we need to test a user interface,
    it gets a little bit complex. Frameworks such as Jasmine and Mocha can run the
    code we write but can't visit a page, click a button, or send a form; at least,
    not alone. For such testing, we need to use a headless browser. A headless browser
    is a web browser without a user interface. There is a way to control it programmatically
    and perform actions such as accessing DOM elements, clicking on links, and filling
    forms. We are able to do the same things as we use a real browser. This gives
    us a really nice instrument to test the user interface. In the next few pages,
    we will see how to use a headless browser.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学习了如何测试我们的代码。我们可以编写一个模块、类或库，如果它有一个API，我们就可以测试它。然而，如果我们需要测试用户界面，这会变得有点复杂。像Jasmine和Mocha这样的框架可以运行我们编写的代码，但不能访问页面、点击按钮或发送表单；至少，不能单独完成。对于这种测试，我们需要使用无头浏览器。无头浏览器是一个没有用户界面的网络浏览器。有一种方法可以程序化地控制它并执行诸如访问DOM元素、点击链接和填写表单等操作。我们能够做与使用真实浏览器相同的事情。这为我们提供了一个真正不错的工具来测试用户界面。在接下来的几页中，我们将看到如何使用无头浏览器。
- en: Writing the subject of our test
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的测试主题
- en: 'In order to explore the possibilities of such testing, we need a simple site.
    Let''s create two pages. The first one will contain an input field and a button.
    The second page will be visited when the button on the first one is clicked. The
    page''s `h1` tag title will change depending on the text written in the field.
    Create a new directory and insert the following code in the `app.js` file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这种测试的可能性，我们需要一个简单的网站。让我们创建两个页面。第一个将包含一个输入字段和一个按钮。当第一个页面上的按钮被点击时，将访问第二个页面。页面的`h1`标签标题将根据字段中写入的文本而改变。创建一个新的目录，并在`app.js`文件中插入以下代码：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We need only two of the Node.js native modules to launch our server. The `http`
    module runs the server, and the `url` module gets the `GET` parameters from the
    URL. The markup of the pages is stored in simple variables. There is a check in
    the handler of the HTTP request, which serves `pageB` if the form on `pageA` is
    submitted. If we run the server with `node app.js`, we will see how the pages
    look, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要两个Node.js原生模块来启动我们的服务器。`http`模块运行服务器，而`url`模块从URL获取`GET`参数。页面的标记存储在简单的变量中。在HTTP请求的处理程序中有一个检查，如果`pageA`上的表单被提交，则服务`pageB`。如果我们用`node
    app.js`运行服务器，我们将看到页面看起来如何，如下面的截图所示：
- en: '![Writing the subject of our test](img/00054.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![编写我们的测试主题](img/00054.jpeg)'
- en: 'Note that the text entered in the text field is set as the title of the second
    page. There is also a **back** button we can use to return to the home page. We
    have a subject to run our tests on. We''ll define the actions we need to verify
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在文本字段中输入的文本被设置为第二页的标题。我们还有一个**返回**按钮可以用来返回主页。我们有一个主题要运行我们的测试。我们将定义我们需要验证的操作如下：
- en: Is the page properly rendered? We should check whether the tags of `pageA` are
    actually on the page.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面是否正确渲染？我们应该检查`pageA`的标签是否实际上在页面上。
- en: We should add some string to the text field and submit the form.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该在文本字段中添加一些字符串并提交表单。
- en: The title of the newly loaded page should match the text that we entered.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新加载的页面的标题应该与我们输入的文本相匹配。
- en: We should be able to click on the **back** button and return to the home page.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够点击 **后退** 按钮并返回主页。
- en: Testing with PhantomJS
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PhantomJS 进行测试
- en: 'We know how our application is suppose to work, so let''s write the tests.
    The headless browser we will use is **PhantomJS**. Visit [http://phantomjs.org](http://phantomjs.org)
    and download the package suitable for your operating system. Like we did for Node.js,
    we will write our test in a JavaScript file and run it at the command line. Let''s
    say that our file structure looks like the following diagram:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的应用程序应该如何工作，所以让我们编写测试。我们将使用的无头浏览器是 **PhantomJS**。访问 [http://phantomjs.org](http://phantomjs.org)
    并下载适合您操作系统的包。就像我们对 Node.js 所做的那样，我们将编写我们的测试在 JavaScript 文件中，并在命令行中运行它。假设我们的文件结构如下所示：
- en: '![Testing with PhantomJS](img/00055.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![使用 PhantomJS 进行测试](img/00055.jpeg)'
- en: Keep in mind that PhantomJS is not a Node.js module. The JavaScript code we
    write for PhantomJS is not exactly a valid Node.js code. We can't directly use
    native modules such as `assert`. Also, there isn't a test runner or test framework
    integrated. It's a browser based on **Webkit** but controlled from the command
    line or via the code. It comes across as binary, and once it is installed, we
    will be able to run the `phantom ./tests/phantom.js` command in our terminal.
    The test code will open `http://127.0.0.1:3000` and will interact with the pages
    there. Of course, the JavaScript community developed tools to combine testing
    frameworks such as Jasmine or Mocha with PhantomJS, but we are not going to use
    them in this chapter. We will write our own small utility—that's what the `framework.js`
    file is for.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，PhantomJS 不是一个 Node.js 模块。我们为 PhantomJS 编写的 JavaScript 代码并不完全等同于有效的 Node.js
    代码。我们不能直接使用原生模块，例如 `assert`。此外，它没有集成测试运行器或测试框架。它是一个基于 **Webkit** 的浏览器，但可以通过命令行或代码进行控制。它看起来像是二进制的，一旦安装，我们就能在我们的终端中运行
    `phantom ./tests/phantom.js` 命令。测试代码将打开 `http://127.0.0.1:3000` 并与那里的页面进行交互。当然，JavaScript
    社区开发了工具，可以将测试框架如 Jasmine 或 Mocha 与 PhantomJS 结合使用，但我们在本章中不会使用它们。我们将编写自己的小型实用工具——这就是
    `framework.js` 文件的作用。
- en: Developing the micro testing framework
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发微型测试框架
- en: 'The final result should be a simple function ready to use, such as `describe`
    or `it`, in Jasmine. It should also have something similar to the assertion library
    so we don''t have to use the usual `if-else` statements or report the failing
    test manually. In the following code, we can see the proper implementation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该是一个简单的函数，可以直接使用，例如 Jasmine 中的 `describe` 或 `it`。它还应该有一个类似于断言库的东西，这样我们就不必使用常规的
    `if-else` 语句或手动报告失败的测试。在下面的代码中，我们可以看到正确的实现：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The function accepts description and function. The first argument is just printed
    out to the console, which indicates what we are going to test. Just after that,
    we call the passed `callback` function with another function as the parameter,
    which plays the role of an assertion library. It accepts the subject of testing
    and executes two methods against it: `toBe` and `toBeDefined`. The following is
    a simple usage:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受描述和函数。第一个参数只是打印到控制台，这表明我们将要测试什么。紧接着，我们调用传递的 `callback` 函数，并使用另一个函数作为参数，该函数充当断言库的角色。它接受测试的主题，并对其执行两个方法：`toBe`
    和 `toBeDefined`。以下是一个简单的用法：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we run the preceding code, the result will be as shown in the following
    screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，结果将如以下截图所示：
- en: '![Developing the micro testing framework](img/00056.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![开发微型测试框架](img/00056.jpeg)'
- en: Understanding how PhantomJS works
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 PhantomJS 的工作原理
- en: 'PhantomJS accepts instructions written in JavaScript. We can save them to a
    file and execute them via the command line by using the `phantom` command. Let''s
    look at the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS 接受用 JavaScript 编写的指令。我们可以将它们保存到文件中，并通过使用 `phantom` 命令在命令行中执行。让我们看看下面的代码片段：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `page` variable is an access to the PhantomJS API. There is a method, `open`,
    which loads a new page. We are mostly interested in two events dispatched from
    the headless browser. The first one, `onConsoleMessage`, is fired when the loaded
    page uses the `console` command, for example, `console.log` or `console.error`.
    The second event, `onLoadFinished`, is also quite important. We have a function
    that is called when the page is loaded. That''s the place where we should place
    our tests. Along with listening for events, we are going to use the following
    two other methods of PhantomJS:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`page` 变量是对 PhantomJS API 的访问。有一个 `open` 方法，它加载一个新的页面。我们主要对来自无头浏览器的两个事件感兴趣。第一个事件是
    `onConsoleMessage`，当加载的页面使用 `console` 命令时触发，例如 `console.log` 或 `console.error`。第二个事件
    `onLoadFinished` 也相当重要。我们有一个在页面加载时被调用的函数。这就是我们应该放置测试的地方。除了监听事件外，我们还将使用以下两个其他方法：'
- en: '`injectJs`: This method requires path to a file on our hard disk. The passed
    file is included on the page. We may also use `includeJs` that does the same thing,
    but it loads the file from an external source.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`injectJs`：此方法需要我们硬盘上文件的路径。传递的文件被包含在页面中。我们还可以使用 `includeJs`，它执行相同的功能，但它从外部源加载文件。'
- en: '`Evaluate`: This method accepts a function that is executed in the context
    of the currently loaded page. This is important because we need to check whether
    certain elements are in the DOM tree. We need to interact with them by filling
    in the text field and clicking on a button.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Evaluate`：此方法接受一个在当前加载的页面上下文中执行的功能。这很重要，因为我们需要检查某些元素是否在 DOM 树中。我们需要通过填写文本字段和点击按钮来与之交互。'
- en: Writing the actual test
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写实际测试
- en: 'Before we start using PhantomJS, we need to run our application with `node
    ./app.js`. By doing this, we are running a server that listens on a particular
    port. PhantomJS will make requests to that server. Now, let''s start filling in
    the `tests/phantom.js` file as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 PhantomJS 之前，我们需要用 `node ./app.js` 运行我们的应用程序。这样做，我们正在运行一个监听特定端口的服务器。PhantomJS
    将向该服务器发送请求。现在，让我们按照以下方式开始填写 `tests/phantom.js` 文件：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we have already discussed, we are able to create a `page` variable and open
    a particular URL. In our case, we are using the address of the test application.
    The `onConsoleMessage` listener just prints out the message to our terminal. When
    the page loads, we inject our micro unit testing framework. This means that we
    are able to call the `test` function in the context of the page. If we run the
    script with `phantom ./tests/phantom.js`, we will get the following result:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，我们能够创建一个 `page` 变量并打开特定的 URL。在我们的例子中，我们使用测试应用程序的地址。`onConsoleMessage`
    监听器只是将消息打印到我们的终端。当页面加载时，我们注入我们的微单元测试框架。这意味着我们能够在页面上下文中调用 `test` 函数。如果我们用 `phantom
    ./tests/phantom.js` 运行脚本，我们将得到以下结果：
- en: '![Writing the actual test](img/00057.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![编写实际测试](img/00057.jpeg)'
- en: The preceding screenshot shows exactly what should happen. The browser goes
    to the page and fires `onLoadFinished`. It's important to call `phantom.exit()`;
    otherwise, PhantomJS's process will stay active.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了确切应该发生的事情。浏览器访问页面并触发 `onLoadFinished`。调用 `phantom.exit()` 很重要；否则，PhantomJS
    的进程将保持活跃。
- en: 'The `framework.js` file is injected to the page and we can write the first
    test, that is, to check whether the title contains **First page**, fill in the
    test field, and submit the form:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`framework.js` 文件被注入到页面中，我们可以编写第一个测试，即检查标题是否包含**第一页**，填写测试字段，并提交表单：'
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The function that is executed by the `evaluate` method is run in the context
    of the page, so it gets an access to the usual document object. We are able to
    use the `getElementById`, `querySelector`, or `submit` methods. The script''s
    result obtained now is as shown in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `evaluate` 方法执行的功能是在页面上下文中运行的，因此它能够访问通常的文档对象。我们能够使用 `getElementById`、`querySelector`
    或 `submit` 方法。现在获得的脚本结果如下截图所示：
- en: '![Writing the actual test](img/00058.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![编写实际测试](img/00058.jpeg)'
- en: 'Now it gets interesting. Indeed, the form is submitted, but we immediately
    called `phantom.exit()`, which terminates our script. If we remove it, the browser
    will stay active and the `onLoadFinished` event will be fired again because a
    new page is successfully loaded. However, the script fails because there is no
    text field or a `form` element on the next page. We need to evaluate another function.
    The following is one of the possible solutions:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变得有趣了。确实，表单已经提交，但我们立即调用了 `phantom.exit()`，这终止了我们的脚本。如果我们去掉它，浏览器将保持活跃状态，并且
    `onLoadFinished` 事件将再次触发，因为新页面已成功加载。然而，脚本失败，因为下一页上没有文本框或 `form` 元素。我们需要评估另一个函数。以下是一个可能的解决方案：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `steps` array is a global variable that contains a series of functions
    that need to be evaluated. On every `onLoadFinished` event, we are fetching one
    of those functions until the `steps` array is empty. This is where we call `phantom.exit()`
    as shown in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`steps` 数组是一个全局变量，它包含了一系列需要评估的函数。在每次 `onLoadFinished` 事件发生时，我们会获取这些函数中的一个，直到
    `steps` 数组为空。这就是我们调用 `phantom.exit()` 的地方，如下面的截图所示：'
- en: '![Writing the actual test](img/00059.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![编写实际测试](img/00059.jpeg)'
- en: PhantomJS opens the home page. It enters **Phantom test** in the text field
    and submits the form. Then, on the next page, it checks whether the title contains
    the valid value, and when you click on the **back link** button, it loads the
    previous page again.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS 打开主页。它在文本框中输入 **Phantom 测试** 并提交表单。然后，在下一页，它检查标题是否包含有效值，当你点击 **返回链接**
    按钮时，它会再次加载上一页。
- en: Testing with DalekJS
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DalekJS 进行测试
- en: So far we learned how to test our JavaScript code. After that, we found out
    how to write user interface tests with Phantom.js. All these are really helpful,
    but it will be even better if we are able to run a real browser and control it.
    With DalekJS, this is possible. It's a really nice Node.js module that comes with
    a command-line interface tool and submodules for major browsers such as Google
    Chrome, Firefox, and Internet Explorer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学习了如何测试我们的 JavaScript 代码。之后，我们发现了如何使用 Phantom.js 编写用户界面测试。所有这些都非常有用，但如果我们能运行一个真实的浏览器并控制它，那就更好了。使用
    DalekJS 就可以实现这一点。这是一个非常棒的 Node.js 模块，它附带了一个命令行界面工具和针对主要浏览器（如 Google Chrome、Firefox
    和 Internet Explorer）的子模块。
- en: 'Let''s see how everything works and install the command-line tool of DalekJS
    using the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一切是如何工作的，并使用以下命令安装 DalekJS 的命令行工具：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A quick `npm install` command will create the `node_modules` directory with
    both dependencies included in it. DalekJS has a detailed documentation published
    on [http://dalekjs.com](http://dalekjs.com). It states that we can load pages,
    fill forms, and click on different DOM elements. It also comes with its own testing
    API, so we don''t have to think about this. The test we have to write is actually
    pretty short. The following is the content of `tests/dalek.js`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的 `npm install` 命令将创建一个包含所有依赖项的 `node_modules` 目录。DalekJS 在 [http://dalekjs.com](http://dalekjs.com)
    上有详细的文档。它指出我们可以加载页面、填写表单并点击不同的 DOM 元素。它还附带了自己的测试 API，因此我们不必担心这一点。我们必须编写的测试实际上非常简短。以下
    `tests/dalek.js` 的内容：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Again, we will make a request to `http://127.0.0.1:3000` and expect to see
    certain elements on the page. We will also enter some text inside the text field
    (the `type` method) and submit the form (the `submit` method). To run the test,
    we need to type in the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将向 `http://127.0.0.1:3000` 发送请求，并期望在页面上看到某些元素。我们还会在文本框中输入一些文本（使用 `type`
    方法）并提交表单（使用 `submit` 方法）。要运行测试，我们需要输入以下命令：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we skip the `-b` parameter, DalekJS will use Phantom.js. That''s the default
    browser type of the library. When the preceding command is launched at the terminal,
    a new instance of the Google Chrome browser is opened. It executes what we defined
    in the test and closes the browser. In order to get the example working, we need
    to run the application by executing `node ./app.js`. The result is reported to
    the console as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略 `-b` 参数，DalekJS 将使用 Phantom.js。这是库的默认浏览器类型。当在终端中启动前面的命令时，将打开一个新的 Google
    Chrome 浏览器实例。它执行我们在测试中定义的内容，然后关闭浏览器。为了使示例工作，我们需要通过执行 `node ./app.js` 来运行应用程序。结果将报告到控制台，如下面的截图所示：
- en: '![Testing with DalekJS](img/00061.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用 DalekJS 进行测试](img/00061.jpeg)'
- en: 'We can even make screenshots of the current browser''s screenshot. It''s simply
    calling the `screenshot` API method as shown in the following code snippet:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以截取当前浏览器的截图。这只需要简单地调用 `screenshot` API 方法，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we are making a screenshot of the second page, the one
    that is loaded after the form is submitted.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在截取第二页的屏幕截图，即表单提交后加载的页面。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how important testing is. Thankfully, there are great
    tools available in the Node.js ecosystem. Frameworks such as Jasmine and Mocha
    make our life easier. Instruments such as Phantom.js save a lot of time by automating
    the testing and putting our code in a browser context. With DalekJS, we can even
    run tests directly in Firefox, Google Chrome, or Internet Explorer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了测试的重要性。幸运的是，Node.js生态系统中提供了许多优秀的工具。例如，Jasmine和Mocha这样的框架使我们的工作更加轻松。像Phantom.js这样的工具通过自动化测试并将我们的代码置于浏览器环境中，节省了大量时间。使用DalekJS，我们甚至可以直接在Firefox、Google
    Chrome或Internet Explorer中运行测试。
- en: In the next chapter, we will see how to write flexible and modular CSS. Node.js
    has few great modules oriented for the frontend developers who write a lot of
    CSS.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何编写灵活和模块化的CSS。Node.js为编写大量CSS的前端开发者提供了几个优秀的模块。
