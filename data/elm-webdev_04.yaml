- en: Preparing a Unit Conversion Website in Elm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Elm 中准备一个单位转换网站
- en: Welcome to [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml), *Preparing
    a Unit Conversion Website in Elm*. The goal of this chapter is to prepare a website
    that will convert miles to metric system measurements, that is, to kilometers. By
    completing this chapter, you will acquire practical skills that are integral to
    how Elm works, all in a fun project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[第4章](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml)，*在 Elm 中准备一个单位转换网站*。本章的目标是创建一个网站，将英里转换为公制系统测量，即千米。通过完成本章，你将获得
    Elm 工作中不可或缺的实用技能，全部在一个有趣的项目中。
- en: 'The topics we will cover include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的主题包括：
- en: Elm language features used to make the website, which include type annotations,
    `case` expressions, union types, and messages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建网站的 Elm 语言特性，包括类型注解、`case` 表达式、联合类型和消息
- en: Understanding `Result` as a way to handle errors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `Result` 作为处理错误的方式
- en: Discussing Elm architecture, and workflow concepts to make the website
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论 Elm 架构和工作流程概念以构建网站
- en: 'After completing this chapter, you will be able to:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够：
- en: Work with type annotations, case expressions, union types, and messages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与类型注解、情况表达式、联合类型和消息一起工作
- en: What are we going to build?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要构建什么？
- en: In this chapter, we will build the core of a simple unit conversion website.
    We will introduce a lot of new concepts and use them in practice right away. To
    be able to fit everything into one chapter, we'll only set up the basic plumbing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个简单单位转换网站的核心。我们将介绍许多新概念，并立即在实践中使用它们。为了将所有内容都放入一章中，我们只设置基本的基础设施。
- en: In the next chapter, we'll expand on what we have built to create a more complex
    structure. To get started, we'll start a brand new Elm app.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展我们已构建的内容，以创建一个更复杂的结构。为了开始，我们将启动一个新的 Elm 应用。
- en: 'To do that, run the following command in your console:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请在您的控制台中运行以下命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Remember that to run your app, you need to point your console to your new app
    folder, and then use the `elm-app start` command in your console. Now that we've
    set everything up for development, it's time to start building the app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，为了运行你的应用，你需要将你的控制台指向你的新应用文件夹，然后在控制台中运行 `elm-app start` 命令。现在我们已经为开发设置了一切，是时候开始构建应用了。
- en: Building our Unit Conversion app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的单位转换应用
- en: 'To begin, let''s delete everything in `Main.elm`. Next, let''s set up a working
    bare-bones app:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们删除 `Main.elm` 中的所有内容。接下来，让我们设置一个工作基础应用：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point, we have an app that works, that is, that displays on the screen.
    However, it doesn't really do anything. Still, it is worthwhile to look at what
    each line of the preceding code actually does. We start off the usual way, by
    declaring the `main` module and importing all the other modules used in our app.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个可以工作的应用，也就是说，它在屏幕上显示。然而，它实际上并没有做什么。尽管如此，看看前面代码的每一行实际上做了什么仍然是有价值的。我们像往常一样开始，通过声明
    `main` 模块并导入我们应用中使用的所有其他模块。
- en: The `init` function is our app's initial model, which we set to an empty `Record`.
    Next, we set up a union type of `Msg`, and give it the value of `Nothing`. `Nothing`
    is simply nothing—our `Msg` union type currently has no value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 函数是我们应用的初始模型，我们将其设置为空的 `Record`。接下来，我们设置一个 `Msg` 的联合类型，并给它 `Nothing`
    的值。`Nothing` 简单地就是没有——我们的 `Msg` 联合类型目前没有任何值。'
- en: Next, we pass two parameters to our `update` function, `msg` and `model`, and
    return the `model`. The `view` function is just a `div` with a text node in its
    second `List`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向 `update` 函数传递两个参数，`msg` 和 `model`，并返回 `model`。`view` 函数只是一个包含其第二个 `List`
    中的文本节点的 `div`。
- en: Finally, let's look at the entry point of our app, the `main` function. We simply
    pass it the `beginnerProgram`, setting the `model` to the value of `init`, `view`
    to `view`, and `update` to `update`. Next, let's update the `init` function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看我们应用的入口点，即 `main` 函数。我们只需将其传递给 `beginnerProgram`，将 `model` 设置为 `init`
    的值，`view` 设置为 `view`，`update` 设置为 `update`。接下来，让我们更新 `init` 函数。
- en: Updating the init function
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 `init` 函数
- en: 'Our `init` function will be the initial state of our app. Let''s update it
    like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `init` 函数将是我们的应用初始状态。让我们这样更新它：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `init` function gets assigned the value of a `Record` that has two `Strings`
    and two `Floats`. Basically, here we are modeling the data that our app will use.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 函数被分配了一个包含两个 `Strings` 和两个 `Floats` 的 `Record` 的值。基本上，我们在这里模拟了应用将使用的数据。'
- en: Type annotations and type aliases
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型注解和类型别名
- en: 'At this point, we might want to add the type annotation above the `init` function.
    If you are using the linter with Atom, you should see the following warning in
    the editor:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可能想要在`init`函数上方添加类型注解。如果你在使用Atom中的lint工具，你应该在编辑器中看到以下警告：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that the order of named values inside the type annotation does not match
    the order we gave the `Record` we assigned to our `init` function. The reason
    is simple: records in Elm are not index-based.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型注解内部命名值的顺序与我们分配给`init`函数的`Record`的顺序不匹配。原因很简单：Elm中的记录不是基于索引的。
- en: Thus, we can choose to add the suggested type annotation above the `init` function,
    and the compiler will be happy.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以选择在`init`函数上方添加建议的类型注解，编译器将会很高兴。
- en: 'However, there is an even better thing that we can do: use a type alias instead.
    With type alias, we shorten our type annotations, making it easier to use them
    wherever needed. In this case, we need to create a type alias to use on the `init`
    function. Since the `init` function is basically just the initial model, it only
    makes sense to create a type alias called `Model`, and then use it as needed.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还可以做一件更好的事情：使用类型别名。使用类型别名，我们可以缩短类型注解，使其更容易在任何需要的地方使用。在这种情况下，我们需要创建一个类型别名来在`init`函数上使用。由于`init`函数基本上只是初始模型，因此创建一个名为`Model`的类型别名并按需使用是有意义的。
- en: 'Thus, let''s set up a type alias `Model`, just above the `init` function in
    our code, like so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在我们的代码中`init`函数上方设置一个类型别名`Model`，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, our updated `Main.elm` will look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的更新后的`Main.elm`将看起来像这样：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Looking at the preceding code, we can see that the type annotation for `init` is
    simply `init : Model`, because now we are using the type alias of `Model`. Let''s
    turn our attention to the `view` and `update` functions now.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '看看前面的代码，我们可以看到`init`的类型注解很简单，就是`init : Model`，因为我们现在正在使用`Model`的类型别名。现在让我们把注意力转向`view`和`update`函数。'
- en: Updating the view and update functions
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新视图和更新函数
- en: It's important to understand that the `view` and `update` functions are connected
    via messages. Whatever message is sent out by the `view` function is received
    by the `update` function. That's why the type of message that the `view` function
    sends should be the same type that the `update` message receives. This might seem
    obvious, but having no doubts about this will make you a better Elm developer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解`view`和`update`函数是通过消息连接的。`view`函数发送的任何消息都会被`update`函数接收。这就是为什么`view`函数发送的消息类型应该与接收到的`update`消息类型相同。这看起来可能很明显，但对此没有疑问将使你成为一个更好的Elm开发者。
- en: 'First, let''s add some more content to our `view` function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的`view`函数中添加一些更多内容：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, our `view` is displaying on the screen, and the button sends
    the message of `Nothing` to `update`. If we compile the app and run it at this
    point, we will see an improved UI on our page. However, everything is static,
    and clicking the button will not do anything at this point.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的`view`视图已经在屏幕上显示，按钮向`update`发送了`Nothing`消息。如果我们在这个时候编译并运行应用程序，我们将在页面上看到一个改进的用户界面。然而，一切仍然是静态的，点击按钮在这个阶段不会做任何事情。
- en: 'Let''s begin making the page interactive by replacing the `Nothing` value with
    a different value. We''ll call it `Swap`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将`Nothing`值替换为不同的值开始，我们将它称为`Swap`：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since our `view` function is now sending the `Swap` message `onClick` of the
    button in our `view`, let''s update our union type of `Msg`, with the value of
    `Swap`, just above the `update` function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`view`函数现在正在向按钮的`onClick`发送`Swap`消息，让我们在`update`函数上方更新我们的联合类型`Msg`，添加值为`Swap`：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, let''s tell the `update` function what to do with the message of `Swap`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们告诉`update`函数如何处理`Swap`消息：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code snippet, we are using some code that we have not seen
    before. Let''s look at how it works. If the `update` function receives a message
    of value `Swap`, it will run the following expression:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了一些之前没有见过的代码。让我们看看它是如何工作的。如果`update`函数接收到值为`Swap`的消息，它将运行以下表达式：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What does the preceding code do? Let''s start with this section of code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码做了什么？让我们从这一段代码开始：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code means—return the same model that you had previously, with
    the only update specified in the code on the right-hand side of the pipe character.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码意味着——返回与之前相同的模型，只是更新了管道字符右侧的代码中的指定更新。
- en: 'The code on the right of the pipe character does the following: it sets the
    value of `unit1` to `model.unit2`, and the value of `unit2` to `model.unit1`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 管道字符右侧的代码执行以下操作：将`unit1`的值设置为`model.unit2`，将`unit2`的值设置为`model.unit1`。
- en: 'If you save your app at this point and run it, you''ll see that after it renders
    the HTML in the browser; nothing else changes. To make sure the code actually
    does something, we need to replace the hard-coded `Strings` inside the `text`
    functions of our `view` to the appropriate `model` values, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这一点上保存你的应用并运行它，你将看到它在浏览器中渲染HTML之后，没有其他变化。为了确保代码实际上做了些什么，我们需要将`view`中的`text`函数内的硬编码`Strings`替换为适当的`model`值，如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, running our code and clicking the button will actually send the `Swap`
    message from the `view` to the `update`, which the user will see as "Kilometers"
    and "Miles" on the screen switching places on a button-click.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行我们的代码并点击按钮实际上会从`view`发送`Swap`消息到`update`，用户会在屏幕上看到“千米”和“英里”在按钮点击时交换位置。
- en: Adding the conversion logic
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加转换逻辑
- en: 'Now, we can make our app convert the inputs it receives on a button- click.
    Let''s begin by updating our `view` function so that it displays the initial converted
    value, that is, the value of 0.0, as that is the value we gave the `Record` that
    we are passing to the `init` function. Note that the following code will not compile:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使我们的应用在按钮点击时转换它接收到的输入。让我们首先更新我们的`view`函数，以便它显示初始转换值，即0.0的值，因为这是我们传递给`init`函数的`Record`的值。请注意，以下代码将无法编译：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running our app with the preceding update will result in the compiler throwing
    an error. Why? Simply because the `text` function must always receive a `String`.
    So, we need to first run the `toString` function on `model.convertedValue`, and
    then give the result of that expression to the `text` function. Like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的`update`运行我们的应用会导致编译器抛出错误。为什么？简单地说，`text`函数必须始终接收一个`String`。因此，我们需要首先在`model.convertedValue`上运行`toString`函数，然后将该表达式的结果传递给`text`函数。如下所示：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running the app at this point will only introduce a minor change on the screen.
    A zero will be displayed on the screen. However, if the user types into the input
    field, this will not affect the zero—it will still just sit there. Let's fix that
    now by improving the `input` function in our view.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上运行应用只会使屏幕上出现微小的变化。屏幕上会显示一个零。然而，如果用户在输入字段中输入，这不会影响零——它仍然会静止在那里。现在让我们通过改进`view`中的`input`函数来修复这个问题。
- en: Improving the input function
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化输入函数
- en: In order for our app to be able to convert the values entered into the input
    text field, we need to be able to do something with that input. In other words,
    we need to send the value of the input to the `update` function, and then tell
    the `update` function what to do with the message that it received.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用能够转换输入文本字段中输入的值，我们需要能够对那个输入做些什么。换句话说，我们需要将输入的值发送到`update`函数，然后告诉`update`函数如何处理它接收到的消息。
- en: 'So first, let''s add to our `view` function so that when the user types something,
    it sends a `message` of that event to the `update` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，让我们向我们的`view`函数添加一些内容，以便当用户输入某些内容时，它将发送一个包含该事件的`message`到`update`函数：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we have just added another item to the first `List` of
    the `input` function. The item we added is the `onInput` function, which receives
    a parameter we called `Convert`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是向`input`函数的第一个`List`中添加了另一个项目。我们添加的项目是`onInput`函数，它接收一个我们称之为`Convert`的参数。
- en: The stumbling block
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 障碍
- en: So far in the development of our app, we haven't had any major issues. We are
    about to hit a minor road bump, and it's important to walk through this slowly,
    just as it's laid out in the section that follows.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的应用开发中，我们没有遇到任何重大问题。我们即将遇到一个小小的障碍，并且重要的是要像后续部分中那样缓慢地走过这个障碍。
- en: 'We are done with the `view`. Now, we can change our `update` function accordingly:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了`view`。现在，我们可以相应地更改我们的`update`函数：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we ran our app right now, it would not compile. Even though the preceding
    code is perfectly valid, there is a piece missing. Have a look at the error message,
    and try to understand what the reason is for this error:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用，它将无法编译。尽管前面的代码是有效的，但还缺少一部分。看看错误信息，并尝试理解这个错误的原因：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Obviously, on line `28`, our `update` function is trying to pattern-match for
    the pattern called `Convert`, and it cannot find it. Similarly, on line `36`,
    our `view` function is trying to use a variable called `Convert`, but it cannot
    find it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在第`28`行，我们的`update`函数正在尝试对名为`Convert`的模式进行模式匹配，但它找不到它。同样，在第`36`行，我们的`view`函数正在尝试使用一个名为`Convert`的变量，但它也找不到它。
- en: To solve this error, let's briefly think about the messages that our `view`
    function can send. How many are there?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个错误，让我们简要地思考一下我们的`view`函数可以发送的消息。有多少个？
- en: 'Of course, there are only two messages: `Swap` and `Convert`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里只有两条信息：`Swap` 和 `Convert`。
- en: 'If you look at the `Swap` message, you''ll see that it''s used in three places
    in our code: in the `view` function, as a parameter of the `onClick` function.
    In the `update` function''s `case` expression, it is used as the `Swap` pattern,
    and in the union type of `Msg`, it is used as its only possible value.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`Swap`消息，你会在我们的代码中看到它在三个地方被使用：在`view`函数中，作为`onClick`函数的参数。在`update`函数的`case`表达式中，它被用作`Swap`模式，并且在`Msg`联合类型中，它被用作其唯一可能的值。
- en: 'Thus, to solve our error, we need to add the `Convert` value as another possible
    value of the `Msg` union type, like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决我们的错误，我们需要将`Convert`值作为`Msg`联合类型的另一个可能值添加进去，如下所示：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running the app now will result in another error, but the solution to this
    one should be a bit more obvious. Here is the text of the error:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序将导致另一个错误，但解决这个问题的方法应该更加明显。以下是错误文本：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see from the error message, the compiler is looking at the `Convert`
    pattern, and it sees that it has the argument we called `newValue`. But when it
    looks at the `Msg` union type, it only sees `Convert`. There are no arguments
    there!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如错误信息所示，编译器正在查看`Convert`模式，并看到它有一个我们称为`newValue`的参数。但是当它查看`Msg`联合类型时，它只看到`Convert`。那里没有参数！
- en: 'To fix the current error, we need to specify the argument that the `Convert`
    value must take along with it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复当前的错误，我们需要指定`Convert`值必须携带的参数：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Saving the preceding changes in our app will bring us one step closer to the
    fully working code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的更改保存到我们的应用程序中，将使我们更接近完全工作的代码。
- en: With the current code, even after the improvements, our app still won't compile.
    An impatient reader at this point might start getting slightly irritated with
    the compiler, helpful as it is.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 即使目前的代码经过改进，我们的应用程序仍然无法编译。此时，一个不耐烦的读者可能会开始对编译器感到有些恼火，尽管编译器很有帮助。
- en: However, what follows is probably the most important piece of knowledge in this
    entire chapter. It's about toggling primitive values in our apps - a subject that
    is rarely, if ever, discussed in online resources, perhaps because it is considered
    as another one of those *expected understandings*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，接下来的内容可能是本章中最重要的知识点。它涉及到在我们应用程序中切换原始值——这个主题在在线资源中很少讨论，也许是因为它被认为是另一种“预期的理解”。
- en: 'So, let''s work through this stumbling block. To begin, let''s revisit our
    `model`, that is, the type alias of `Model`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们解决这个难题。首先，让我们回顾一下我们的`model`，即`Model`的类型别名：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see in the preceding code, the `convertedValue` is a `Float`, not
    a `String`. We might think that the solution would be to simply change the value
    passed to `Convert` from `String` to `Float`, in our `Msg` union type:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，`convertedValue`是一个`Float`，而不是一个`String`。我们可能会认为解决方案就是简单地将传递给`Convert`的值从`String`更改为`Float`，在我们的`Msg`联合类型中：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Unfortunately, this will only result in a different error:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这只会导致另一个错误：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, obviously, our `onInput` message needs to be a `String`. Let''s try converting
    the `newValue`, which is a `String`, to a `Float`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，显然，我们的`onInput`消息需要是一个`String`。让我们尝试将`newValue`转换为`Float`，它是一个`String`：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code will throw yet another error, and this one might look a
    bit intimidating at first:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将抛出另一个错误，这个错误一开始可能会看起来有些吓人：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The reason why this message might look a bit less intuitive from what we''re
    used to is two-fold. Firstly, the message is reporting an error that has to do
    with our type alias `Model`, which was great at hiding complexity from our app,
    but now it might be hampering our efforts to understand the issue. Secondly, inside
    the error, we can see a new Elm keyword: `Result`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息可能看起来不如我们习惯的那样直观，原因有两个。首先，这个消息报告了一个与我们的类型别名`Model`相关的错误，它曾擅长隐藏应用程序的复杂性，但现在可能阻碍了我们理解问题的努力。其次，在错误信息中，我们可以看到一个新出现的Elm关键字：`Result`。
- en: 'Let''s resolve the error step by step. We''ll begin by trying to produce a
    more understandable error, by commenting out the type alias of `Model`, together
    with the `init` function''s type annotation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地解决错误。我们首先尝试通过注释掉`Model`的类型别名以及`init`函数的类型注解来产生一个更易于理解的错误：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s try recompiling the app to get a slightly different error message,
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试重新编译应用，以获得一个稍微不同的错误信息，如下所示：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding error message makes it slightly more obvious. We are having issues
    with this `Result.Result` thing. Just what is it?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误信息使问题稍微明显一些。我们遇到了这个`Result.Result`问题。它究竟是什么？
- en: Dealing with the Result.Result error
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理`Result.Result`错误
- en: '`Result` is a type. We use the `Result` type whenever we have a function that
    could possibly return an error.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`是一个类型。每当我们的函数可能返回一个错误时，我们就使用`Result`类型。'
- en: In our preceding example, we have an input field. The user types into the input
    field, and we are expecting the input to be of type `Float`. However, what if
    the user types in one or more letters, or a combination of letters and numbers,
    or any other odd character other than just numbers?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的例子中，我们有一个输入字段。用户在输入字段中输入，我们期望输入是`Float`类型。然而，如果用户输入一个或多个字母，或者字母和数字的组合，或者任何其他非数字的奇怪字符怎么办？
- en: Conceptually, it boils down to two possibilities—a function returns an *error*
    by virtue of the user typing unexpected characters into the input field, or it
    returns a *result*, by virtue of the user typing `Floats`, as we expect.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，这归结为两种可能性——一个函数通过用户在输入字段中输入意外的字符来返回一个*错误*，或者通过用户输入我们期望的`Floats`来返回一个*结果*。
- en: 'This is how the `Result` package is defined in the official documentation,
    available at: [http://package.elm-lang.org/packages/elm-lang/core/latest/Result](http://package.elm-lang.org/packages/elm-lang/core/latest/Result):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是官方文档中定义的`Result`包的样式，可在以下链接找到：[http://package.elm-lang.org/packages/elm-lang/core/latest/Result](http://package.elm-lang.org/packages/elm-lang/core/latest/Result)
- en: '"A Result is the result of a computation that may fail. This is a great way
    to manage errors in Elm."'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: “一个`Result`是可能失败的计算的结果。这是在Elm中管理错误的好方法。”
- en: 'The official documentation gives the following union type definition:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档给出了以下联合类型定义：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So, if our function succeeds, we''ll get an `Ok` with the value; otherwise,
    we''ll get an `Err` with an error. This begs the question: how do we then deal
    with errors in our programs, using `Result`?'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们的函数成功，我们将得到一个包含值的`Ok`；否则，我们将得到一个包含错误的`Err`。这引发了一个问题：我们如何在程序中使用`Result`来处理错误？
- en: 'At its core, the solution is simple and elegant, like everything else in Elm:
    if we get an `Ok`, the function should return a value; if we get an `Err`, the
    function should return a *default* value. Let''s take another example from the
    official documentation and run it in the REPL:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，解决方案简单而优雅，就像Elm中的其他一切一样：如果我们得到一个`Ok`，函数应该返回一个值；如果我们得到一个`Err`，函数应该返回一个*默认*值。让我们从官方文档中再举一个例子，并在REPL中运行它：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we are parsing the string of `"123"` to an `Int`, but
    just to be on the safe side, in case we get an `Err`, we set the default value
    to zero.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在将字符串`"123"`解析为`Int`类型，但为了安全起见，以防我们得到一个`Err`，我们将默认值设置为零。
- en: 'This is what the REPL returns:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是REPL返回的内容：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s try the second example now:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来尝试第二个例子：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'What will REPL return now? The exact same thing:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，REPL现在会返回什么？正是同样的东西：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The conclusion is, no matter what we write inside the double quotes, Elm will
    take care of it, as long as we have a default solution for `Err` values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，无论我们在双引号内写什么，只要我们为`Err`值提供一个默认解决方案，Elm都会处理它。
- en: Now that we understand what `Result.Result` is, let's go back to fixing our
    app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了`Result.Result`是什么，让我们回到修复我们的应用。
- en: Using the Result type to fix our app
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Result`类型修复我们的应用
- en: 'After getting sidetracked with a lot of error messages and some dry theory,
    let''s put our new skills in to practice by changing the `update` function to
    the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理了大量的错误信息和一些枯燥的理论之后，让我们将新技能付诸实践，通过将`update`函数更改为以下代码：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code should be a lot easier to understand now. If our `update`
    function receives a message that pattern-matches the `Convert` pattern with its
    `newValue` string, we'll execute the code after the arrow.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码现在应该更容易理解了。如果我们的`update`函数接收到与`Convert`模式匹配的消息，并且包含`newValue`字符串，我们将执行箭头后的代码。
- en: 'The code after the arrow says: use the existing model, with a change to be
    made only to the model''s `convertedValue`. The updated value to assign to `convertedValue`
    is the result of the expression:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头后面的代码表示：使用现有的模型，只需对模型的 `convertedValue` 进行更改。要分配给 `convertedValue` 的更新值是以下表达式的结果：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Elm evaluates the expression starting with the parentheses: it takes the `newValue`
    String and converts it to `Float`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 从括号开始评估表达式：它将 `newValue` 字符串转换为 `Float`。
- en: If the operation is successful, it returns the given `Float` as the value of
    the evaluated expression. If the operation is not successful, it returns number
    `10`, and that is indeed what you'll see on the screen if you type anything other
    than numbers into the input field in your running app.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作成功，它返回评估表达式的给定 `Float` 值。如果操作不成功，它返回数字 `10`，如果你在运行的应用程序中的输入字段中输入除数字以外的任何内容，你确实会在屏幕上看到这个数字。
- en: 'There is only one thing left to do: uncomment the type alias `Model` and the
    `init` function''s type annotation. With all the changes we have had, this is
    the full code of our app at this point:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一一件事是：取消注释类型别名 `Model` 和 `init` 函数的类型注解。经过我们所有的更改，这是到目前为止我们应用程序的完整代码：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the app and test it out.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并测试它。
- en: If you type a number into the input field, you'll get that same number on the
    next line. However, if you type any other characters inside the input field, you'll
    get number 10 on the next line—a clear sign that our function's `Result` was `Err`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将数字输入到输入字段中，你将在下一行看到相同的数字。然而，如果你在输入字段中输入任何其他字符，你将在下一行看到数字 10——这是一个明显的迹象，表明我们的函数的
    `Result` 是 `Err`。
- en: In the next section, we'll make our app actually convert the values it receives
    from the input field.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使我们的应用程序实际上将接收到的输入字段中的值进行转换。
- en: Calculating the conversion
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算转换
- en: 'Let''s update the `Convert` pattern in the `update` function''s `case` expression.
    Our new code will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `update` 函数的 `case` 表达式中的 `Convert` 模式。我们新的代码将如下所示：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After the update, save the app and test the behavior of the input field. Once
    you start typing a number, you'll see it immediately being converted to its converted
    value in kilometers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后，保存应用程序并测试输入字段的性能。一旦你开始输入数字，你将立即看到它被转换为千米单位的转换值。
- en: However, there is another improvement we need to make. As our `Result.withDefault`
    is now 10, whenever a user types anything else besides numbers, or even before
    they start typing, we see the number `16.08` displayed on the screen.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还需要进行另一项改进。由于我们的 `Result.withDefault` 现在是 10，所以当用户输入除数字以外的任何内容，或者在他们开始输入之前，我们都会在屏幕上看到数字
    `16.08`。
- en: 'This is an easy enough fix. Instead of 10, we''ll simply use zero as the default
    `Result`. Update the code to the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的修复。我们不再使用 10，而是简单地使用 0 作为默认的 `Result`。更新代码如下：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, the app has the expected behavior.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序具有预期的行为。
- en: However, the expression after the `->` operator is a bit unwieldy. We will make
    our code a bit nicer to look at, and learn another feature of the Elm language
    along the way, by using a `let` expression.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`->` 操作符后面的表达式有点难以处理。我们将通过使用 `let` 表达式使我们的代码看起来更美观，并在过程中学习 Elm 语言的一个新特性。
- en: Refactoring our app using a let expression
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `let` 表达式重构我们的应用程序
- en: At this point, we are ready to use a `let` expression to improve the `Convert`
    pattern of our `update` function's case expression.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已准备好使用 `let` 表达式来改进 `update` 函数的 `case` 表达式中的 `Convert` 模式。
- en: 'A `let` expression in Elm consists of two parts: `let` and `in`. The `let`
    part lets us declare variables and functions that will be used in the `in` section
    of the `let` expression. It''s important to note that the variables declared here
    are scoped to the function they are used in. The rest of our program is not aware
    of it. In other words, these variables are local, and do not exist in the rest
    of our program.  Contrast that to functions such as the `update` or the `view`
    functions, which live in the global scope.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中的 `let` 表达式由两部分组成：`let` 和 `in`。`let` 部分允许我们声明将在 `let` 表达式的 `in` 部分中使用的变量和函数。需要注意的是，这里声明的变量仅限于它们被使用的函数的作用域内。我们的程序的其他部分对此一无所知。换句话说，这些变量是局部的，并不存在于我们的程序的其他部分。 
    与 `update` 或 `view` 函数等全局作用域中的函数形成对比。
- en: The `in` section of a `let` expression should return a single value as a result
    of whatever expressions are placed there.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 表达式的 `in` 部分应该返回一个值，无论放置了什么表达式。'
- en: 'Let''s look at how we can write our `Convert` pattern as a `let` expression.
    To begin, let''s look at it again:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何将`Convert`模式写成`let`表达式。首先，让我们再次看看它：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s think about putting a part of the preceding code in a variable,
    scoped to the `let` expression. An obvious candidate would be this bit of code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑将前面代码的一部分放入一个变量中，该变量作用域为`let`表达式。一个明显的候选者是这段代码：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What name could we give to the preceding snippet of code?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能给前面的代码片段起什么名字？
- en: 'How about `floatValue`? It''s a nice, descriptive name, since we are indeed
    converting the existing `newValue` string to a `Float`, and giving it the default
    value of zero. So, our updated code will look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: “floatValue”怎么样？这是一个很好的、描述性的名字，因为我们确实将现有的`newValue`字符串转换为`Float`，并给它默认值零。因此，我们的更新后的代码将看起来像这样：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, let''s rewrite our `Convert` pattern as a `let` expression:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们的`Convert`模式重写为一个`let`表达式：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There, much better.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那里，好多了。
- en: We've reduced the cognitive load of trying to decipher that long, one-line expression
    we previously had, into a nice `let` expression that is a lot easier to reason
    about. Working with `let` expressions will soon feel so natural to you that you'll
    wonder how you ever did without them. Why? Because writing our code like this
    makes a clear separation between variables being declared in the `let` part of
    the `let` expression, and the actual expression, in its `in` part.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试解读之前那个长的一行表达式的认知负荷减少，变成一个更易于推理的`let`表达式。使用`let`表达式将很快让你觉得如此自然，以至于你会想知道在没有它们的情况下是如何做到的。为什么？因为以这种方式编写我们的代码，在`let`表达式的`let`部分声明的变量和它的`in`部分的实际表达式之间做出了清晰的分离。
- en: Making our app look nicer
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的应用看起来更美观
- en: 'In this chapter, we''ve covered a lot of theory and we''ve also put it into
    practice. Let''s look at the full code of our app at this stage:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的理论，并且也将其付诸实践。现在，让我们看看我们应用在这个阶段的完整代码：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, we'll focus on making the app look nicer by using Bootstrap 4.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过使用Bootstrap 4来使应用看起来更美观。
- en: Adding Bootstrap styles
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Bootstrap样式
- en: 'To begin, navigate to `index.html` in your project''s `public` folder and add
    the following line of code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导航到项目`public`文件夹中的`index.html`，并添加以下代码行：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The starting point of our code update will be a simple snippet of HTML, copied
    from the official Bootstrap documentation website. The code we will be using is
    for a Bootstrap-based input group:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码更新的起点将是一个简单的HTML代码片段，从官方Bootstrap文档网站复制而来。我们将使用的代码是基于Bootstrap的输入组：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s convert the preceding snippet to Elm code, using the HTML to Elm page,
    available at: [https://mbylstra.github.io/html-to-elm/](https://mbylstra.github.io/html-to-elm/).
    After our HTML gets parsed, this is what we get:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的代码片段转换为Elm代码，使用在[https://mbylstra.github.io/html-to-elm/](https://mbylstra.github.io/html-to-elm/)可用的HTML到Elm页面。在HTML被解析后，我们得到以下内容：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we need to map our existing Elm code to the preceding Elm code. To make
    it easier to work with, we will also assign it to a variable. After we''ve done
    that, our `view` function will look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将现有的Elm代码映射到前面的Elm代码。为了更容易工作，我们还将将其分配给一个变量。完成之后，我们的`view`函数将看起来像这样：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code gives a slightly different HTML structure than what we had
    so far, but it is also more semantic and nicer looking for the end user. Let''s
    look at the complete code for our app at this point:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码给出了与我们之前所用的略有不同的HTML结构，但它也更加语义化，并且对最终用户来说看起来更美观。现在，让我们看看我们应用的完整代码：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At this point, our app should look like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的应用应该看起来像这样：
- en: '![](img/31e3afa6-b64e-4975-a7b0-f09d42ab9d06.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31e3afa6-b64e-4975-a7b0-f09d42ab9d06.png)'
- en: There are a few improvements that can be made to our app at this point. For
    example, the Switch button only switches the names of units between kilometers
    and miles, but when the Switch button is pressed, it does not update the values
    that are already present in the input field. Also, the page layout and styling,
    although better than what we had, could still use a bit more improvement.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以对我们的应用进行一些改进。例如，切换按钮只切换单位名称在公里和英里之间，但当切换按钮被按下时，它不会更新输入字段中已经存在的值。此外，页面布局和样式，虽然比我们之前的好，但仍需要更多改进。
- en: In the next chapter, we will add these features and further improve the app
    so that it has multiple inputs for the conversion of multiple units. Now, we'll
    shift our focus to looking at ways to apply what we learned in this chapter and
    update our *FizzBuzz* app.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加这些功能并进一步改进应用，使其具有多个输入以转换多个单位。现在，我们将把重点转向查看如何应用本章学到的知识并更新我们的 *FizzBuzz*
    应用。
- en: Revisiting the FizzBuzz app
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视 FizzBuzz 应用
- en: 'Before we can start improving our *FizzBuzz* app, let''s remind ourselves of
    where we left off in the previous chapter:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始改进我们的 *FizzBuzz* 应用之前，让我们提醒自己上一章我们停在了哪里：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s convert the preceding app so that it works with the Elm architecture,
    and so it prints out either a number or a word based on user input. We''ll begin
    with the bare-bones app we used before, which utilizes the `beginnerProgram` function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的应用转换为使用 Elm 架构，并使其根据用户输入打印出一个数字或一个单词。我们将从之前使用的裸骨应用开始，该应用利用 `beginnerProgram`
    函数：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, let''s populate our initial model:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们填充我们的初始模型：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, let''s add a type alias of `Model`, and update the type annotation of `initModel`
    accordingly:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个 `Model` 的类型别名，并相应地更新 `initModel` 的类型注解：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, let''s give our `view` function some HTML:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们给 `view` 函数添加一些 HTML：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If we compile the app now, we'll see an input and a button in our browser. What
    we want to do in this version of the *FizzBuzz* app is we want the user to type
    a number inside the input, and after they click the button, the app will print
    out either a number or one of the words, as per the rules of the game.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在编译应用，我们将在浏览器中看到一个输入和一个按钮。在本版本的 *FizzBuzz* 应用中，我们希望用户在输入框中输入一个数字，然后点击按钮后，应用将根据游戏规则打印出一个数字或一个单词。
- en: 'Now, we can start to make the app receive user input. Let''s update the nested
    `input` function inside the `view` function by adding an `onInput` message:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始让应用接收用户输入了。让我们通过添加一个 `onInput` 消息来更新 `view` 函数内部的嵌套 `input` 函数：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we need to allow our `update` function to receive that message:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要允许 `update` 函数接收该消息：
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Of course, we still need to make changes to the `Msg` union type:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们仍然需要修改 `Msg` 联合类型：
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If we ran our app now, we'd see an input, a button, and below it, the number
    zero. If we typed letters, nothing would change; however, if we typed numbers,
    they would get displayed in place of the zero.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用，我们将看到一个输入、一个按钮，以及其下方的数字零。如果我们输入字母，则不会发生变化；然而，如果我们输入数字，它们将显示在零的位置。
- en: Giving our FizzBuzz app some logic
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给我们的 FizzBuzz 应用添加一些逻辑
- en: 'In this section, we''ll give our *FizzBuzz* app some logic so that it displays
    results based on user input. Let''s do that by adding logic to the `DisplayInput`
    patter of our update function''s `case` expression:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为我们的 *FizzBuzz* 应用添加一些逻辑，以便根据用户输入显示结果。让我们通过在更新函数的 `case` 表达式的 `DisplayInput`
    模式中添加逻辑来实现这一点：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'What we have done in the preceding code can be explained in several points:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中所做的可以解释为以下几点：
- en: We have given our `DisplayInput` pattern a scoped variable we called `condition`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经给 `DisplayInput` 模式赋予了一个我们称之为 `condition` 的作用域变量。
- en: The `condition` variable will evaluate to one of the `if` expressions inside
    of it, based on the number that the user typed into the `input` field (which was
    stored in the `newValue` variable)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`condition` 变量将根据用户输入到 `input` 字段中的数字（存储在 `newValue` 变量中）评估为其中的一个 `if` 表达式。'
- en: In the `in` part of the `let` expression, we simply return the same model plus
    the updated `outputValue`, based on the value that the condition variable equated
    to in the `let` part of the `let` expression
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `let` 表达式的 `in` 部分，我们简单地返回相同的模型加上基于条件变量在 `let` 表达式的 `let` 部分等价的价值更新的 `outputValue`。
- en: We can now save and run our app and observe how it dynamically updates the text
    node of the `div` under the input field, based on user inputs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以保存并运行我们的应用，观察它如何根据用户输入动态更新输入字段下 `div` 的文本节点。
- en: 'We can observe the following behavior:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到以下行为：
- en: Typing a number will result in a correct calculation of a number or a word from
    the *FizzBuzz* game
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入一个数字将导致从 *FizzBuzz* 游戏中正确计算出数字或单词。
- en: Typing anything else will return that exact same string in the `div` under the
    input
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入任何其他内容将在输入下方的 `div` 中返回相同的字符串
- en: This means that there is still more room for improvement for our app. We will
    improve it by simply adding another `if` expression to our condition variable,
    and resolving the rest to a message to the user telling them that they need to
    input a number, not other characters.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的应用仍有更多改进的空间。我们将通过简单地添加另一个 `if` 表达式到我们的条件变量中，并将剩余的解析为一个消息给用户，告诉他们需要输入一个数字，而不是其他字符。
- en: 'The update we need to make is easy enough:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进行的更新足够简单：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'At this point, our *FizzBuzz* app is behaving a lot nicer. Let''s see the full
    code of the app at this point:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 *FizzBuzz* 应用表现得要好得多。让我们看看这个阶段应用的完整代码：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is the welcome screen of our improved *FizzBuzz* app:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的改进版 *FizzBuzz* 应用的欢迎屏幕：
- en: '![](img/1e479343-888e-4467-9aa5-f5d9bc922d44.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e479343-888e-4467-9aa5-f5d9bc922d44.png)'
- en: 'Typing a number produces the desired result:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数字会产生期望的结果：
- en: '![](img/6a2f6929-879a-46f1-b759-0fe069fb0966.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a2f6929-879a-46f1-b759-0fe069fb0966.png)'
- en: 'Typing anything else will produce a user-friendly error message:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 输入其他任何内容都会产生一个用户友好的错误信息：
- en: '![](img/ca4b2331-2f12-4615-9ea0-9be167ccf830.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca4b2331-2f12-4615-9ea0-9be167ccf830.png)'
- en: There are still many things that we can improve, as we'll see in [Chapter 5](d141e3a8-3fa0-4e32-8804-6b1824eeff3f.xhtml),
    *Completing the Unit Conversion Website in Elm*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有很多可以改进的地方，正如我们在[第5章](d141e3a8-3fa0-4e32-8804-6b1824eeff3f.xhtml)，“在 Elm
    中完成单位转换网站”中将会看到的。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml), *Preparing a Unit
    Conversion Website in Elm*, we learned a number of important concepts, such as:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml)，“在 Elm 中准备单位转换网站”中，我们学习了许多重要的概念，例如：
- en: Working with the `Msg` union type
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Msg` 联合类型
- en: Setting up our model's data with `Records`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Records` 设置我们模型的数据
- en: Using type annotations and type aliases
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型注解和类型别名
- en: Updating only a section of our model using pipe characters in our expressions
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道字符在我们的表达式中仅更新模型的一部分
- en: Working with the `Result` union type to handle potential errors in our apps
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Result` 联合类型来处理我们应用中的潜在错误
- en: Working with `let` expressions
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `let` 表达式
- en: In the next chapter, we will improve our unit conversion website by adding multiple
    inputs for converting various units.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加多个输入来改进我们的单位转换网站，以便转换各种单位。
