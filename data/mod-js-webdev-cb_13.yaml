- en: Creating a Desktop Application with Electron
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Electron创建桌面应用程序
- en: 'We will look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看以下配方：
- en: Setting up Electron with React
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React设置Electron
- en: Adding Node functionality to your app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向您的应用程序添加Node功能
- en: Building a more windowy experience
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建更窗口化的体验
- en: Testing and debugging your app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和调试您的应用程序
- en: Making a distributable package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个可分发的软件包
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapters, we used `Node` to set up servers, and `React` to create
    web pages. In this chapter, we'll bring both together, adding another tool called `Electron`,
    and we'll see how we can use JS to write desktop apps that work exactly like any
    native executable app.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们使用`Node`来设置服务器，并使用`React`创建网页。在本章中，我们将把两者结合起来，添加另一个名为`Electron`的工具，并看看如何使用JS编写与任何本机可执行应用程序完全相同的桌面应用程序。
- en: Setting up Electron with React
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React设置Electron
- en: '`Electron` is an open source framework, created by GitHub, that lets you develop
    desktop executables that bring together Node and Chrome to provide a full GUI
    experience. `Electron` has been used for several well-known projects, including
    developer tools such as Visual Studio Code, Atom, and Light Table. Basically,
    you can define the UI with HTML, CSS, and JS (or using `React`, as we''ll be doing),
    but you can also use all of the packages and functions in `Node`, so you won''t
    be limited to a sandboxed experience, being able to go beyond what you could do
    with just a browser.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Electron`是由GitHub创建的开源框架，它允许您开发桌面可执行文件，将Node和Chrome集成在一起，提供完整的GUI体验。 `Electron`已用于几个知名项目，包括开发人员工具，如Visual
    Studio Code，Atom和Light Table。基本上，您可以使用HTML，CSS和JS（或使用`React`，就像我们将要做的那样）来定义UI，但您还可以使用`Node`中的所有软件包和功能，因此您不会受到沙箱化体验的限制，可以超越您只能使用浏览器做的事情。'
- en: You may also want to read about **Progressive Web Apps** (**PWA**) which are
    web apps that can be "installed" at your machine, very much like they were native
    apps. These apps are launched as any other app, and run in a common app window,
    without tabs or a URL bar as a browser would show. PWAs may not (yet?) have access
    to full desktop functionality, but for many cases they may be more than enough.
    Read more about PWAs at [https://developers.google.com/web/progressive-web-apps/](https://developers.google.com/web/progressive-web-apps/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想了解**渐进式Web应用程序**（**PWA**），这些是可以像本机应用程序一样“安装”在您的计算机上的Web应用程序。这些应用程序像其他应用程序一样启动，并在常见的应用程序窗口中运行，而不像浏览器那样显示标签或URL栏。
    PWA可能（尚未？）无法访问完整的桌面功能，但对于许多情况来说可能已经足够了。在[https://developers.google.com/web/progressive-web-apps/](https://developers.google.com/web/progressive-web-apps/)上阅读有关PWA的更多信息。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: For now, in this recipe, let's first install `Electron`, and then in the later
    recipes, we'll see how we can turn one of our `React` apps into a desktop program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个配方中，让我们首先安装`Electron`，然后在后续的配方中，我们将看到如何将我们的一个`React`应用程序转换为桌面程序。
- en: 'I started out with a copy of the repository from [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml),
    *Expanding Your Application*, to get the countries and regions app, the same we
    also used for an RN example. It just so happens that you can work perfectly well
    with `Electron` with a CRA-built app, without even needing to eject it, so that''s
    what we''ll do here. First, we need to install the basic `Electron` package, so
    in the same directory where we wrote our `React` app, we''ll execute the following
    command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我从[第8章](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml)的存储库副本开始，*扩展您的应用程序*，以获取国家和地区应用程序，这与我们用于RN示例的相同。恰好您可以完全使用CRA构建的应用程序与`Electron`完美地配合，甚至无需弹出它，这就是我们将在这里做的。首先，我们需要安装基本的`Electron`软件包，因此在我们编写`React`应用程序的同一目录中，我们将执行以下命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we''ll need a starter JS file. Taking some tips from the `main.js` file
    at [https://github.com/electron/electron-quick-start](https://github.com/electron/electron-quick-start),
    we''ll create the following `electron-start.js` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个启动JS文件。从[https://github.com/electron/electron-quick-start](https://github.com/electron/electron-quick-start)的`main.js`文件中获取一些提示，我们将创建以下`electron-start.js`文件：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here are some points to note regarding the preceding code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于前面代码片段的一些要点：
- en: This code runs in `Node`, so we are using `require()` instead of `import`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码在`Node`中运行，因此我们使用`require()`而不是`import`。
- en: The `mainWindow` variable will point to the browser instance where our code
    will run
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mainWindow`变量将指向浏览器实例，我们的代码将在其中运行'
- en: We'll start by running our React app, so Electron will be able to load the code
    from [http://localhost:3000](http://localhost:3000)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将首先运行我们的React应用程序，因此Electron将能够从[http://localhost:3000](http://localhost:3000)加载代码
- en: 'In our code, we also have to process the following events:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们还必须处理以下事件：
- en: '`"ready"` is called when `Electron` has finished its initialization, and can
    start creating windows.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`Electron`完成初始化并可以开始创建窗口时，将调用`"ready"`。
- en: '`"closed"` means your window was closed; your app might have several windows
    open, so at this point you should delete the closed one.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"closed"`表示您的窗口已关闭；您的应用程序可能有多个窗口打开，因此在这一点上，您应该删除已关闭的窗口。'
- en: '`"window-all-closed"` implies your whole app was closed. In Windows and Linux,
    this means quitting, but for macOS, you don''t usually quit applications, because
    of Apple'' s usual rules.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"window-all-closed"`意味着您的整个应用程序已关闭。在Windows和Linux中，这意味着退出，但对于macOS，通常不会退出应用程序，因为苹果通常的规则。'
- en: '`"activate"` is called when your app is reactivated, so if the window had been
    deleted (as in Windows or Linux), you have to create it again.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您的应用程序重新激活时，将调用`"activate"`，因此如果窗口已被删除（如在Windows或Linux中），您必须重新创建它。
- en: The complete list of events that `Electron` can emit is at [https://github.com/electron/electron/blob/master/docs/api/app.md](https://github.com/electron/electron/blob/master/docs/api/app.md);
    check it out.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Electron`可以发出的完整事件列表在[https://github.com/electron/electron/blob/master/docs/api/app.md](https://github.com/electron/electron/blob/master/docs/api/app.md)中；查看一下。'
- en: 'We already have our `React` app in place, so we just need a way to call `Electron`.
    Add the following script to `package.json`, and you''ll be ready:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了我们的`React`应用程序，所以我们只需要一种调用`Electron`的方法。将以下脚本添加到`package.json`中，你就准备好了：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are set; let's see how it all comes together.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了；让我们看看它是如何一起运作的。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To run the `Electron` app in development mode (we''ll get on to creating an
    executable file later), we have to do the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要以开发模式运行`Electron`应用程序（稍后我们将创建一个可执行文件），我们必须执行以下操作：
- en: Run our `restful_server_cors` server code from [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[第4章](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml)运行我们的`restful_server_cors`服务器代码，*使用Node实现RESTful服务*。
- en: Start the `React` app, which requires the server to be running.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`React`应用程序，需要服务器正在运行。
- en: Wait until it's loaded, and then and only then, move on to the next step.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待加载完成，然后再进行下一步。
- en: Start `Electron`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`Electron`。
- en: 'So, basically, you''ll have to run the two following commands, but you''ll
    need to do so in separate terminals, and you''ll also have to wait for the `React`
    app to show up in the browser before starting `Electron`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，您将需要运行以下两个命令，但是您需要在单独的终端中执行这些命令，并且在启动`Electron`之前还需要等待`React`应用程序在浏览器中显示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After starting `Electron`, a screen quickly comes up, and we again find our
    countries and regions app, now running independently of a browser. See the following
    screenshot—note that I resized the window from its 1024 × 768 size:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 启动`Electron`后，屏幕迅速出现，我们再次发现我们的国家和地区应用程序，现在独立于浏览器运行。请参阅以下屏幕截图-请注意，我将窗口从其1024×768大小调整为：
- en: '![](img/d82abd1a-1bbf-4d4f-b534-22deedffeebc.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d82abd1a-1bbf-4d4f-b534-22deedffeebc.png)'
- en: Our app, running as an independent executable
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序作为一个独立的可执行文件运行
- en: 'The app works as always; as an example, I selected a country, Canada, and correctly
    got its list of regions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序像往常一样工作；例如，我选择了一个国家，加拿大，并正确地得到了它的地区列表：
- en: '![](img/7a1a907c-f625-43ee-b7ee-827ed2d05df2.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a1a907c-f625-43ee-b7ee-827ed2d05df2.png)'
- en: The app works as before; pick a country, and a call to our RESTful server will
    get its regions
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序像以前一样工作；选择一个国家，然后调用我们的RESTful服务器将获取其地区
- en: We are done! You can see that everything is interconnected, as before, in the
    sense that if you make any changes to the `React` source code, they will be instantly
    reflected in the `Electron` app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！您可以看到一切都是相互关联的，就像以前一样，如果您对`React`源代码进行任何更改，它们将立即反映在`Electron`应用程序中。
- en: So far, we have seen that we can make an executable out of a web page; let's
    now see how to make it more powerful.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们可以将网页制作成可执行文件；现在让我们看看如何使其更加强大。
- en: Adding Node functionality to your app
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向您的应用程序添加Node功能
- en: In the previous recipe, we saw that with just a few small configuration changes,
    we can turn our web page into an application. However, you're still restricted
    in terms of what you can do, because you are still using only those features available
    in a sandboxed browser window. You don't have to think this way, for you can add
    basically all `Node` functionality using functions that let you go beyond the
    limits of the web. Let's see how to do it in this recipe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们看到只需进行一些小的配置更改，我们就可以将我们的网页变成一个应用程序。但是，您仍然受到限制，因为您仍然只能使用沙盒浏览器窗口中可用的功能。您不必这样想，因为您可以使用让您超越网络限制的功能来添加基本所有`Node`功能。让我们在本教程中看看如何做到这一点。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We want to add some functionality to our app of the kind that a typical desktop
    would have. Let's see how can we do that. The key to adding `Node` functions to
    your app is to use the `remote` module in `Electron`. With it, your browser code
    can invoke methods of the main process, and thus gain access to extra functionality.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要为我们的应用程序添加一些典型桌面应用程序的功能。让我们看看如何做到这一点。向您的应用程序添加`Node`功能的关键是使用`Electron`中的`remote`模块。借助它，您的浏览器代码可以调用主进程的方法，从而获得额外的功能。
- en: See [https://github.com/electron/electron/blob/master/docs/api/remote.md](https://github.com/electron/electron/blob/master/docs/api/remote.md) for
    more on the remote module. There is also extra information that might come in
    handy at [https://electronjs.org/docs/api/remote](https://electronjs.org/docs/api/remote).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关远程模块的更多信息，请参见[https://github.com/electron/electron/blob/master/docs/api/remote.md](https://github.com/electron/electron/blob/master/docs/api/remote.md)。还有一些额外的信息可能会在[https://electronjs.org/docs/api/remote](https://electronjs.org/docs/api/remote)中派上用场。
- en: 'Let''s say we wanted to add the possibility of saving the list of a country''s
    regions to a file. We''d require access to the `fs` module to be able to write
    a file, and we''d also need to open a dialog box to select what file to write
    to. In our `serviceApi.js` file, we would add the following functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要添加将国家地区列表保存到文件的可能性。我们需要访问`fs`模块以便能够写入文件，并且我们还需要打开对话框来选择要写入的文件。在我们的`serviceApi.js`文件中，我们将添加以下功能：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Having added this, we can now write files and show dialog boxes from our main
    code. To use this functionality, we could add a new action to our `world.actions.js`
    file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这个之后，我们现在可以从我们的主代码中写文件和显示对话框。要使用此功能，我们可以在我们的`world.actions.js`文件中添加一个新的操作：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the `saveRegionsToDisk()` action is dispatched, it will show a dialog
    to prompt the user to select what file is to be written, and will then write the
    current set of regions, taken from `getState().regions`, to the selected file
    in JSON format. We just have to add the appropriate button to our `<RegionsTable>`
    component to be able to dispatch the necessary action:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当调度`saveRegionsToDisk()`操作时，它将显示一个对话框，提示用户选择要写入的文件，然后将当前的地区集合（从`getState().regions`中获取）以JSON格式写入所选文件。我们只需向我们的`<RegionsTable>`组件添加适当的按钮，以便能够调度必要的操作：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We are almost done! When we connect this component to the store, we''ll simply
    add the new action, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了！当我们将此组件连接到存储时，我们只需添加新的操作，如下所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, everything's ready—let's see it working.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切准备就绪-让我们看看它是如何工作的。
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The code we added showed how we could gain access to a `Node` package (`fs`,
    in our case) and some extra functions, such as showing a Save to disk dialog.
    (The latter function has more to do with the native look of your app, and we''ll
    see more about it in the upcoming *Building a more windowy experience* section.)
    When we run our updated app and select a country, we''ll see our newly added button,
    as in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的代码显示了我们如何访问`Node`包（在我们的情况下是`fs`）和一些额外的功能，比如显示一个保存到磁盘的对话框。（后一个功能与您的应用程序的本机外观更相关，我们将在即将到来的*构建更窗口化的体验*部分中看到更多相关内容。）当我们运行更新后的应用程序并选择一个国家时，我们将看到我们新添加的按钮，就像以下截图中的那样：
- en: '![](img/d8572940-7b7d-43e5-8ee0-a80168759e00.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8572940-7b7d-43e5-8ee0-a80168759e00.png)'
- en: We now have a Save regions to disk button after the regions list
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在区域列表后面有一个“保存区域到磁盘”按钮
- en: 'Clicking on the button will pop up a dialog, allowing you to select the destination
    for the data:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 单击按钮将弹出对话框，允许您选择数据的目标：
- en: '![](img/d5ae729f-5ea2-44c1-a4d4-98046a461102.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5ae729f-5ea2-44c1-a4d4-98046a461102.png)'
- en: Clicking on the button brings up a Save screen, to specify to which file to
    save the results
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 单击按钮会弹出一个保存屏幕，指定要将结果保存到哪个文件
- en: 'If you click Save, the list of regions will be written in JSON format, as we
    specified earlier in our `writeRegionsToDisk()` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单击“保存”，区域列表将以JSON格式编写，就像我们在`writeRegionsToDisk()`函数中指定的那样：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A final detail to note is that your app won''t be able to run in a browser
    now, and you''ll have to get used to seeing something as in the following screenshot,
    even though your code will run fine with `Electron`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的细节是，您的应用程序现在无法在浏览器中运行，您将不得不习惯看到以下截图中的内容，即使您的代码在`Electron`中运行良好：
- en: '![](img/98c69b03-212c-4156-8085-84a9468a6f5a.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98c69b03-212c-4156-8085-84a9468a6f5a.png)'
- en: If you use Node's or Electron's functions, your code will no longer run in the
    browser, though it will perform perfectly well with Electron
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用Node或Electron的功能，您的代码将不再在浏览器中运行，尽管它在Electron中的表现良好
- en: That's it! Without much hassle, we were able to go beyond the limits of normal
    browser apps. You can see that there's practically no limit to what you can do
    in an `Electron` app.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！毫不费力地，我们能够超越普通浏览器应用的限制。您可以看到在`Electron`应用程序中几乎没有限制。
- en: Building a more windowy experience
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建更窗口化的体验
- en: 'In the previous recipe, we added the possibility of using any and all of the
    functions provided by `Node`. In this recipe, let''s now focus on making our app
    more window-like, with icons, menus, and so on. We want the user to really believe
    that they''re using a native app, with all the features that they would be accustomed
    to. The following list of interesting subjects from [https://electronjs.org/docs/api](https://electronjs.org/docs/api)
    is just a short list of highlights, but there are many more available options:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们添加了使用`Node`提供的任何和所有功能的可能性。在这个示例中，让我们专注于使我们的应用程序更像窗口，具有图标、菜单等。我们希望用户真的相信他们正在使用一个本地应用程序，具有他们习惯的所有功能。以下是来自[https://electronjs.org/docs/api](https://electronjs.org/docs/api)的有趣主题列表的一些亮点，但还有许多其他可用选项：
- en: '| `clipboard` | To do copy and paste operations using the system''s clipboard
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `clipboard` | 使用系统剪贴板进行复制和粘贴操作 |'
- en: '| `dialog` | To show native system dialogs for messages, alerts, opening and
    saving files, and so on |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `dialog` | 显示用于消息、警报、打开和保存文件等的本机系统对话框 |'
- en: '| `globalShortcut` | To detect keyboard shortcuts |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `globalShortcut` | 检测键盘快捷键 |'
- en: '| `Menu`, `MenuItem` | To create a menu bar with menus and submenus |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `Menu`，`MenuItem` | 创建带有菜单和子菜单的菜单栏 |'
- en: '| `Notification` | To add desktop notifications |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `Notification` | 添加桌面通知 |'
- en: '| `powerMonitor`, `powerSaveBlocker` | To monitor power state changes, and
    to disable entering sleep mode |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `powerMonitor`，`powerSaveBlocker` | 监控电源状态变化，并禁用进入睡眠模式 |'
- en: '| `screen` | To get information about the screen, displays, and so on |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `screen` | 获取有关屏幕、显示器等的信息 |'
- en: '| `Tray` | To add icons and context menus to the system''s tray |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Tray` | 向系统托盘添加图标和上下文菜单 |'
- en: Let's add a few of these functions so that we can get a better-looking app that
    is more integrated to the desktop.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些这些功能，以便我们可以获得一个外观更好、更与桌面集成的应用程序。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Any decent app should probably have at least an icon and a menu, possibly with
    some keyboard shortcuts, so let's add those features now, and just for the sake
    of it, let's also add some notifications for when regions are written to disk.
    Together with the Save dialog we already used, this means that our app will include
    several native windowing features. Let's implement the following steps and understand
    how to add these extras.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 任何体面的应用程序可能至少应该有一个图标和一个菜单，可能还有一些键盘快捷键，所以让我们现在添加这些功能，并且仅仅是为了这个缘故，让我们也为区域写入磁盘时添加一些通知。连同我们已经使用的保存对话框，这意味着我们的应用程序将包括几个本机窗口功能。让我们实施以下步骤，并了解如何添加这些额外功能。
- en: 'To start with, let''s add an icon. Showing an icon is the simplest thing, because
    it just requires an extra option when creating the `BrowserWindow()` object. I''m
    not very *graphics-visual-designer* oriented, so I just downloaded the Alphabet,
    letter, r Icon Free file from the Icon-Icons website, at [https://icon-icons.com/icon/alphabet-letter-r/62595](https://icon-icons.com/icon/alphabet-letter-r/62595).
    Implement the icon as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个图标。显示图标是最简单的事情，因为在创建`BrowserWindow()`对象时只需要一个额外的选项。我不太擅长*图形视觉设计*，所以我只是从Icon-Icons网站上下载了Alphabet,
    letter, r Icon Free文件，网址是[https://icon-icons.com/icon/alphabet-letter-r/62595](https://icon-icons.com/icon/alphabet-letter-r/62595)。实现图标如下：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can also choose icons for the system tray, although there's no way of using
    our regions app in that context, but you may want to look into it nonetheless.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为系统托盘选择图标，尽管在该上下文中无法使用我们的区域应用程序，但您可能仍然希望了解一下。
- en: There's another way of adding an icon to your app when you do the build, by
    adding an extra configuration item to the `"build"` entry in `package.json`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时，还有另一种方法可以向应用程序添加图标，即在`package.json`的`“build”`条目中添加额外的配置项。
- en: 'To continue, the second feature we''ll add is a menu, with some global shortcuts
    to boot. In our `App.regions.js` file, we''ll need to add a few lines to access
    the `Menu` module, and to define our menu itself:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加的第二个功能是一个菜单，还有一些全局快捷键。在我们的`App.regions.js`文件中，我们需要添加几行来访问`Menu`模块，并定义我们自己的菜单：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using a template is a simple way to create a menu, but you can also do it manually,
    adding item by item. I decided to have a Countries menu with two options to show
    the regions for Uruguay (where I was born) and Hungary (from where my father''s
    father came). The `click` property dispatches the appropriate action. I also used
    the `accelerator` property to define global shortcuts. See [https://github.com/electron/electron/blob/master/docs/api/accelerator.md](https://github.com/electron/electron/blob/master/docs/api/accelerator.md)
    for the list of possible key combinations to use, including the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板是创建菜单的一种简单方法，但您也可以手动执行，逐个添加项目。我决定有一个国家菜单，有两个选项，可以显示乌拉圭（我出生的地方）和匈牙利（我父亲的父亲来自的地方）的地区。`click`属性会分派适当的操作。我还使用`accelerator`属性来定义全局快捷键。请参阅[https://github.com/electron/electron/blob/master/docs/api/accelerator.md](https://github.com/electron/electron/blob/master/docs/api/accelerator.md)以获取可以使用的可能键组合的列表，包括以下内容：
- en: '*Command keys*, such as `Command` (or `Cmd`), `Control` (or `Ctrl`), or both
    (`CommandOrControl` or `CmdOrCtrl`)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令键*，如`Command`（或`Cmd`），`Control`（或`Ctrl`），或两者（`CommandOrControl`或`CmdOrCtrl`）'
- en: '*Alternate keys*, such as `Alt`, `AltGr`, or `Option`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*备用键*，如`Alt`，`AltGr`或`Option`'
- en: '*Common keys*, such as `Shift`, `Escape` (or `Esc`), `Tab`, `Backspace`, `Insert`,
    or `Delete`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*常用键*，如`Shift`，`Escape`（或`Esc`），`Tab`，`Backspace`，`Insert`或`Delete`'
- en: '*Function keys*, such as `F1` to `F24`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*功能键*，如`F1`到`F24`'
- en: '*Cursor keys*, including `Up`, `Down`, `Left`, `Right`, `Home`, `End`, `PageUp`,
    and `PageDown`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光标键，包括`上`，`下`，`左`，`右`，`Home`，`End`，`PageUp`和`PageDown`
- en: '*Media keys*, such as `MediaPlayPause`, `MediaStop`, `MediaNextTrack`, `MediaPreviousTrack`, `VolumeUp`,
    `VolumeDown`, and `VolumeMute`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*媒体键*，如`MediaPlayPause`，`MediaStop`，`MediaNextTrack`，`MediaPreviousTrack`，`VolumeUp`，`VolumeDown`和`VolumeMute`'
- en: 'I also want to be able to quit the application (never mind that the window
    created by `Electron` already has an × icon to close it!)—that''s a predefined
    *role* for which you don''t need to do anything special. A complete list of roles
    is available at [https://electronjs.org/docs/api/menu-item#roles](https://electronjs.org/docs/api/menu-item#roles).
    With these roles, you can do a huge amount, including some specific macOS functions,
    along with the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我还希望能够退出应用程序（不要紧，`Electron`创建的窗口已经有一个×图标来关闭它！）-这是一个预定义的*角色*，您不需要做任何特殊的事情。可以在[https://electronjs.org/docs/api/menu-item#roles](https://electronjs.org/docs/api/menu-item#roles)找到完整的角色列表。有了这些角色，您可以做很多事情，包括一些特定的macOS功能，以及以下内容：
- en: Work with the clipboard (`cut`, `copy`, `paste`, and `pasteAndMatchStyle`)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用剪贴板（`剪切`，`复制`，`粘贴`和`粘贴并匹配样式`）
- en: Handle the window (`minimize`, `close`, `quit`, `reload`, and `forceReload`)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理窗口（`最小化`，`关闭`，`退出`，`重新加载`和`强制重新加载`）
- en: Zoom (`zoomIn`, `zoomOut`, and `resetZoom`)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放（`放大`，`缩小`和`重置缩放`）
- en: 'To finish, and really just for the sake of it, let''s add a notification trigger
    for when a file is written. `Electron` has a `Notification` module, but I opted
    to use `node-notifier` from [https://github.com/mikaelbr/node-notifier](https://github.com/mikaelbr/node-notifier),
    which is quite simple to use. First, we''ll add the package in the usual fashion:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也只是为了这个缘故，让我们为文件写入时添加一个通知触发器。`Electron`有一个`Notification`模块，但我选择使用`node-notifier`，这个模块非常简单易用。首先，我们将以通常的方式添加这个包：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `serviceApi.js`, we''ll have to export the new function, so we''ll able
    to import from elsewhere, as we''ll see shortly:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`serviceApi.js`中，我们将不得不导出新的函数，这样我们就可以从其他地方导入，我们很快就会看到：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, let''s use this in our `world.actions.js` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在我们的`world.actions.js`文件中使用它：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With all our setup, actually sending a notification is quite simple, requiring
    very little code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有的设置，实际发送通知非常简单，需要的代码很少：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are set! Let's see what our more *windowy* app looks like now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好了！让我们看看我们更*窗口化*的应用现在是什么样子。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First, we can easily check that the icon appears. See the following screenshot,
    and compare it with the very first screenshot in this chapter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以轻松检查图标是否出现。请参阅以下屏幕截图，并将其与本章的第一个屏幕截图进行比较：
- en: '![](img/20c41f3f-3f44-4cfa-a477-2fa53e2a844e.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20c41f3f-3f44-4cfa-a477-2fa53e2a844e.png)'
- en: Our app now has its own icon, possibly not too exclusive or original, but better
    than nothing
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在有了自己的图标，可能不是太独特或原创，但总比没有好
- en: 'Now, let''s look at the menu. It has our options, including the shortcuts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看菜单。它有我们的选项，包括快捷键：
- en: '![](img/cdff7282-3cd4-426c-a3f8-f0826f616e04.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdff7282-3cd4-426c-a3f8-f0826f616e04.png)'
- en: Our app now also has a menu, as any self-respecting app should
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在也有一个菜单，就像任何值得尊敬的应用程序一样
- en: 'Then, if we select an option (let''s say Uruguay) with either the mouse or
    the global shortcut, the screen correctly loads the expected regions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们选择一个选项（比如乌拉圭），无论是用鼠标还是全局快捷键，屏幕都会正确加载预期的区域：
- en: '![](img/0fcc9fda-b118-4eb9-8416-658f01cf18bb.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fcc9fda-b118-4eb9-8416-658f01cf18bb.png)'
- en: The menu entries work as expected; we can use the Uruguay option to see my country's
    19 departments
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单项按预期工作；我们可以使用乌拉圭选项来查看我的国家的19个部门
- en: 'Finally, let''s see if the notifications work as expected. If we click on the
    Save regions to disk button and select a file, we''ll see a notification, as in
    the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看通知是否按预期工作。如果我们点击“保存区域到磁盘”按钮并选择一个文件，我们将看到一个通知，如下面的屏幕截图所示：
- en: '![](img/95d43e2b-5b57-45fc-a614-26e9fe26c9fc.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95d43e2b-5b57-45fc-a614-26e9fe26c9fc.png)'
- en: Saving a file now shows a notification; in this case, for Linux with KDE
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存文件会显示通知；在这种情况下，是为了Linux与KDE
- en: We've now seen how to expand our browser page to include `Node` features and
    windowing native functions. Now, let's go back to more basic requirements, and
    learn how to test and debug our code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何扩展我们的浏览器页面以包括`Node`功能和窗口本地函数。现在，让我们回到更基本的要求，学习如何测试和调试我们的代码。
- en: Testing and debugging your app
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和调试您的应用程序
- en: 'Now, we get to a common requirement: testing and debugging your app. The first
    thing I''ll have to tell you is that there''s no news in regards to testing! All
    the techniques we saw for testing browser and `Node` code still apply, since your
    `Electron` app is essentially just a browser app (albeit possibly with some extra
    functions) that you''ll mock in the same way you did earlier, so there''s nothing
    new to be learned here.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了一个常见的要求：测试和调试您的应用程序。我必须告诉您的第一件事是，关于测试方面没有什么新闻！我们为测试浏览器和`Node`代码所看到的所有技术仍然适用，因为您的`Electron`应用程序本质上只是一个浏览器应用程序（尽管可能具有一些额外功能），您将以与之前相同的方式模拟它，因此在这里没有新东西需要学习。
- en: However, with regard to debugging, there will be some new requirements, since
    your code is not running in a browser. In a similar way as with `React Native`,
    we'll have to use some tools in order to be able to look into our code as it runs.
    Let's see, in this recipe, how to go about all of this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就调试而言，由于您的代码不是在浏览器中运行，因此将会有一些新的要求。与`React Native`类似，我们将不得不使用一些工具，以便能够在代码运行时查看我们的代码。让我们在本节中看看如何处理所有这些。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We want to install and configure all the necessary tools for debugging. Let''s
    do that in this section. The key tool for debugging will be `electron-devtools-installer`,
    which you can get from [https://github.com/MarshallOfSound/electron-devtools-installer](https://github.com/MarshallOfSound/electron-devtools-installer).
    We''ll install it, as well as the `Redux Devtools` extension we used before, with
    a simple command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要安装和配置所有必要的调试工具。让我们在本节中完成这些。调试的关键工具将是`electron-devtools-installer`，您可以从[https://github.com/MarshallOfSound/electron-devtools-installer](https://github.com/MarshallOfSound/electron-devtools-installer)获取。我们将使用一个简单的命令安装它，以及之前使用过的`Redux
    Devtools`扩展：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To use the `Redux Devtools`, we''ll have to start by fixing the store, as we
    did earlier; nothing new here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Redux Devtools`，我们将首先修复存储，就像我们之前做的那样；这里没有什么新东西：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the tools themselves, we''ll also have to tweak our starter code a bit:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工具本身，我们还需要稍微调整我们的起始代码：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The good thing is that you can add all the tools from code, with no special
    installation or any other procedure. After these simple changes, you are done;
    now, let's see it work!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，您可以从代码中添加所有工具，无需特殊安装或其他程序。进行这些简单的更改后，您就完成了；现在，让我们看看它的工作原理！
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'If you start the modified code, you''ll see that the `Electron` window now
    includes the classic Chrome tools, including `React` and `Redux`. See the following
    screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您启动修改后的代码，您将看到`Electron`窗口现在包括经典的Chrome工具，包括`React`和`Redux`。请参阅以下屏幕截图：
- en: '![](img/8f6658a1-4e0d-4ea0-81b4-def111922f9f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f6658a1-4e0d-4ea0-81b4-def111922f9f.png)'
- en: The electron-devtools-installer package lets you add all the tools you need,
    with a simple procedure
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: electron-devtools-installer包让您通过简单的程序添加所需的所有工具
- en: 'Apart from the console, you can use the `React Devtools` to inspect components:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了控制台，您还可以使用`React Devtools`来检查组件：
- en: '![](img/db13bb2d-99c6-4601-9f08-6d07073d3f41.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db13bb2d-99c6-4601-9f08-6d07073d3f41.png)'
- en: The React Devtools can be used to inspect components and their props
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: React Devtools可用于检查组件及其属性
- en: 'Similarly, the `Redux DevTools` let you inspect actions and the store. See
    the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`Redux DevTools`让您检查操作和存储。请参阅以下屏幕截图：
- en: '![](img/ba5cb884-220b-4ea3-86f5-44d5615ca827.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba5cb884-220b-4ea3-86f5-44d5615ca827.png)'
- en: You also installed the Redux developer tools, which let you inspect everything
    Redux-related
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您还安装了Redux开发者工具，可以让您检查与Redux相关的所有内容
- en: As you can see, we've got all the tools we were accustomed to, with one exception—what
    about network calls? Let's see to that now.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经习惯的所有工具都有了，只有一个例外——网络调用呢？让我们现在来看看。
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You may have noticed that the Network tab doesn''t show the API calls done
    from the app. With RN, we solved that because the tools we used included the ability
    to inspect all network traffic, but that doesn''t happen here. So, instead of
    an easy, automated solution, we''ll have to do a bit of extra work. If you do
    all of your API calls with `axios`, you can simply modify its original methods
    to produce logging:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，网络选项卡不显示应用程序发出的API调用。在RN中，我们解决了这个问题，因为我们使用的工具包括检查所有网络流量的功能，但在这里不会发生这种情况。因此，我们将不得不做一些额外的工作，而不是一个简单的自动化解决方案。如果您使用`axios`进行所有API调用，您可以简单地修改其原始方法以生成日志：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The change shown will cause every successful `GET` to log everything you need,
    as in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的更改将导致每个成功的`GET`都记录您需要的所有内容，就像以下屏幕截图中所示：
- en: '![](img/b31c2611-d73b-4458-b211-a0664279de46.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b31c2611-d73b-4458-b211-a0664279de46.png)'
- en: Our changed `axios.get()` method produces a satisfying log
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改后的`axios.get()`方法产生了令人满意的日志
- en: Of course, this is just the tip of the required changes. You'll have to add
    code for a failed call (so, add some logging in `.catch()`, too) and you'll also
    want to do this sort of change for the other methods (`.post()`, `.delete()`,
    and so on), but the necessary code is simple, so I'll leave it as an exercise
    for the reader!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是所需更改的冰山一角。您将不得不为失败的调用添加代码（因此，在`.catch()`中添加一些日志），您还将希望对其他方法（`.post()`、`.delete()`等）进行此类更改，但必要的代码很简单，所以我将把它作为读者的练习留下！
- en: Making a distributable package
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作可分发的软件包
- en: Now that we have a full app, all that's left to do is package it up so that
    you can deliver it as an executable file for Windows, Linux, or macOS users. Let's
    finish the chapter by looking at how to do that in this recipe.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个完整的应用程序，剩下的就是将其打包，以便您可以将其作为可执行文件交付给Windows、Linux或macOS用户。让我们通过本节来看看如何做到这一点。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: There are many ways of packaging an app, but we'll use a tool, `electron-builder`,
    that will make it even easier, if you can get its configuration right!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多打包应用程序的方法，但我们将使用一个名为`electron-builder`的工具，如果您能正确配置它，将使这一切变得更加容易！
- en: You can read more about `electron-builder`, its capabilities, and its configuration
    at [https://www.electron.build/](https://www.electron.build/).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.electron.build/](https://www.electron.build/)上阅读有关`electron-builder`、其功能和配置的更多信息。
- en: 'Let''s take a look at the necessary steps. First of all, we''ll have to begin
    by defining the build configuration, and our initial step will be, as always,
    to install the tool:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看必要的步骤。首先，我们将不得不开始定义构建配置，我们的初始步骤将是，像往常一样，安装工具：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To access the added tool, we''ll require a new script, which we''ll add in
    `package.json`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问添加的工具，我们需要一个新的脚本，我们将在`package.json`中添加：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll also have to add a few more details to `package.json`, which are needed
    for the build process and the produced app. In particular, the `homepage` change
    is required, because the CRA-created `index.html` file uses absolute paths that
    won''t work later with `Electron`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向`package.json`添加一些更多的细节，这些细节对于构建过程和生成的应用程序是必需的。特别是，需要更改`homepage`，因为CRA创建的`index.html`文件使用绝对路径，这些路径将无法与`Electron`后来一起使用：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, some specific building configuration will be required. You cannot
    build for macOS with a Linux or Windows machine, so I''ll leave that configuration
    out. We have to specify where the files will be found, what compression method
    to use, and so on:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将需要一些特定的构建配置。您不能在Linux或Windows机器上构建macOS，因此我将不包括该配置。我们必须指定文件的位置，要使用的压缩方法等等：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Read more about building for different platforms at [https://www.electron.build/multi-platform-build](https://www.electron.build/multi-platform-build).
    For more on all of the configuration options, see [https://www.electron.build/configuration/configuration#configuration](https://www.electron.build/configuration/configuration#configuration).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://www.electron.build/multi-platform-build](https://www.electron.build/multi-platform-build)上阅读有关为不同平台构建的更多信息。有关所有配置选项的更多信息，请参阅[https://www.electron.build/configuration/configuration#configuration](https://www.electron.build/configuration/configuration#configuration)。
- en: 'We have completed the required configuration, but there are also some changes
    to do in the code itself, and we''ll have to adapt the code for building the package.
    When the packaged app runs, there won''t be any webpack server running; the code
    will be taken from the built `React` package. Also, you won''t want to include
    debugging tools. So, the starter code will require the following changes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了所需的配置，但代码本身也需要做一些更改，我们将不得不调整代码以构建包。当打包的应用程序运行时，将不会有webpack服务器运行；代码将从构建的`React`包中获取。此外，您不希望包含调试工具。因此，起始代码将需要以下更改：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Mainly, we are taking icons and code from the `build/` directory. An `npm run
    build` command will take care of generating that directory, so we can proceed
    with creating our executable app.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是，我们正在从`build/`目录中获取图标和代码。`npm run build`命令将负责生成该目录，因此我们可以继续创建我们的可执行应用程序。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After doing this setup, building the app is essentially trivial. Just do the
    following, and all the distributable files will be found in the `dist/` directory:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此设置后，构建应用程序基本上是微不足道的。只需执行以下操作，所有可分发文件将在`dist/`目录中找到：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You may want to add a new line to the `.gitignore` file so that the distribution
    directory won't be committed. I included a `**/dist` line to mine, paralleling
    the previous `**/node_modules` and `**/dist` existing lines.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望在`.gitignore`文件中添加一行，以便不提交分发目录。我在我的文件中包含了`**/dist`行，与之前的`**/node_modules`和`**/dist`现有行相对应。
- en: 'Now that we have the Linux app, we can run it by unzipping the `.zip` file
    and clicking on the `chapter13` executable. (The name came from the `"name"` attribute
    in `package.json`, which we modified earlier.) The result should be like what''s
    shown in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Linux应用程序，我们可以通过解压`.zip`文件并单击`chapter13`可执行文件来运行它。（名称来自`package.json`中的`“name”`属性，我们之前修改过。）结果应该像下面的截图所示：
- en: '![](img/0d4b11ce-77df-40c5-81c9-7a860b8375c4.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d4b11ce-77df-40c5-81c9-7a860b8375c4.png)'
- en: The Linux executable runs as a native app, showing the same screen as we saw
    earlier
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Linux可执行文件作为本机应用程序运行，显示与我们之前看到的相同的屏幕。
- en: I also wanted to try out the Windows `EXE` file. Since I didn't have a Windows
    machine, I made do by downloading a free `VirtualBox` virtual machine from [https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/)—they
    only work for 90 days, but I needed it for just a few minutes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想尝试一下Windows的`EXE`文件。由于我没有Windows机器，我通过从[https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/)下载免费的`VirtualBox`虚拟机来实现，它们只能使用90天，但我只需要几分钟。
- en: 'After downloading the virtual machine, setting it up in `VirtualBox`, and finally
    running it, the result that was produced was the same as for Linux, as shown in
    the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下载虚拟机，将其设置在`VirtualBox`中，并最终运行它后，产生的结果与Linux的结果相同，如下面的截图所示：
- en: '![](img/c2ccbf1b-74d5-430b-a6f3-d88513be4cf8.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2ccbf1b-74d5-430b-a6f3-d88513be4cf8.png)'
- en: Our native Windows app runs equally in a Windows machine
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的本机Windows应用程序在Windows机器上同样运行
- en: So, we've managed to develop a `React` app, enhanced it with the `Node` and
    `Electron` features, and finally packaged it for different operating systems.
    With that, we are done!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经成功开发了一个`React`应用程序，增强了`Node`和`Electron`功能，并最终为不同的操作系统打包了它。有了这个，我们就完成了！
