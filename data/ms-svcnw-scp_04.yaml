- en: Advanced Client-Side Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级客户端脚本编程
- en: In this chapter, we will explore the advanced side of client-side scripting.
    Here, we will take a deeper look into scripting on the client and using some of
    the more advanced techniques that are available.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索客户端脚本的高级方面。在这里，我们将更深入地研究客户端脚本以及使用一些更高级的技术。
- en: 'The topics we will cover in this chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: UI actions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 动作
- en: AJAX calls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AJAX 调用
- en: Advanced client script examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级客户端脚本示例
- en: UI actions
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 动作
- en: UI actions are generally considered to be a server-side script, but they can
    also run as client-side script, too. We will cover an introduction to UI actions
    and their basic usage in the server-side basics in the next chapter. Here, though,
    we will look at the more advanced techniques of running UI actions on the client
    side.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: UI 动作通常被认为是服务器端脚本，但它们也可以作为客户端脚本运行。我们将在下一章中介绍 UI 动作及其在服务器端基础中的基本用法。然而，在这里，我们将探讨在客户端运行
    UI 动作的更高级技术。
- en: Client-side UI actions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端 UI 动作
- en: To change a UI action to run client-side script, we first need to check the
    client field tick box. This brings up some additional fields, including the checkboxes
    to select which list versions the UI actions will be compatible with, but the
    main new field we are interested in is called `onClick`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 UI 动作更改为运行客户端脚本，我们首先需要检查客户端字段复选框。这将带来一些额外的字段，包括选择 UI 动作将与之兼容的列表版本的复选框，但我们最感兴趣的新的主要字段被称为
    `onClick`。
- en: The `onClick` field runs the client code contained inside it when the UI action
    is selected. Visually, this is only a small field, and not that appropriate for
    code, so most developers call a function in this field and define the function
    in the main script field.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择 UI 动作时，`onClick` 字段会运行其中包含的客户端代码。从视觉上看，这只是一个很小的字段，并不适合代码，因此大多数开发者会在该字段中调用一个函数，并在主脚本字段中定义该函数。
- en: 'Let''s look at an example of this usage. For the code in the `onClick` field,
    we only need to call the following function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个用法的例子。对于 `onClick` 字段中的代码，我们只需要调用以下函数：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, in the script field, we can define the function and contain the code
    we want to run inside it:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在脚本字段中，我们可以定义函数并包含我们想要在其中运行的代码：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method of calling a function that resides in the script field is used by
    ServiceNow UI actions that are provided with the out-of-the-box platform.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用位于脚本字段中的函数的方法被 ServiceNow UI 动作使用，这些动作是随平台提供的。
- en: 'We can see what these UI actions would look like in *Figure 4.1*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *图 4.1* 中看到这些 UI 动作的外观：
- en: '![](img/d8c8edf6-706f-482a-aefd-058f26360ec6.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8c8edf6-706f-482a-aefd-058f26360ec6.png)'
- en: 'Figure 4.1: Example UI action containing client-side script'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：包含客户端脚本的示例 UI 动作
- en: In our example in *Figure 4.1*, we can see the UI action as a form button, as
    that is the checkbox that has been selected. The call in the `Onclick` field to
    the `onClick` function allows us to write as much code as we need in the script
    field inside our `onClick` function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例 *图 4.1* 中，我们可以看到 UI 动作作为一个表单按钮，因为那是被选中的复选框。在 `Onclick` 字段中对 `onClick`
    函数的调用使我们能够在 `onClick` 函数内部的脚本字段中编写我们需要的任何代码。
- en: Calling server-side script
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用服务器端脚本
- en: Now that we have seen how to use client-side scripts in UI actions, we can look
    at taking this a step further and using client- and server-side script in the
    same UI action.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在 UI 动作中使用客户端脚本，我们可以进一步探讨在同一个 UI 动作中使用客户端和服务器端脚本。
- en: This can be achieved by first calling client-side script in the UI action, which
    then calls the UI action in the code, and therefore runs the server-side script.
    This is a slightly strange concept to imagine at first, so let's see how it works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过首先在 UI 动作中调用客户端脚本，然后该脚本在代码中调用 UI 动作，从而运行服务器端脚本来实现。一开始想象这个概念可能有点奇怪，所以让我们看看它是如何工作的。
- en: 'First, we need to take a look at the line of code that calls the UI action
    from the client-side code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要查看从客户端代码调用 UI 动作的代码行：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding line of code calls the UI action, but this time, it will run it
    on the server side. When using this technique, you must ensure that the Action
    name field of the UI action is the same as the name referenced in the script.
    The first argument of `gsftSubmit` is for a control, but seeing as we don't want
    to use this, we just pass null. This second argument is to get the form; in our
    case, we just want to get the current HTML form. The third argument is the action
    name, so this needs to be our UI action action name.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码调用 UI 动作，但这次它将在服务器端运行。当使用这种技术时，你必须确保 UI 动作的“动作名称”字段与脚本中引用的名称相同。`gsftSubmit`
    的第一个参数用于控制，但由于我们不希望使用它，所以我们只传递 null。第二个参数是为了获取表单；在我们的情况下，我们只想获取当前的 HTML 表单。第三个参数是动作名称，因此这需要是我们的
    UI 动作动作名称。
- en: 'Next, let''s look at the server side of the script:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看脚本的服务器端：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first part of this code is an `if` statement to check that we are running
    on the server side and not the client side anymore. This little piece of code
    also ensures that we do not receive browser errors. If the `if` statement evaluates
    to true, we then call a function to run our server-side code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分是一个 `if` 语句，用于检查我们是否不再在服务器端运行而是在客户端运行。这段小代码还确保我们不会收到浏览器错误。如果 `if` 语句评估为真，那么我们就调用一个函数来运行我们的服务器端代码。
- en: 'We can use the preceding example and call the `onClick` function in our script
    field:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的示例并在我们的脚本字段中调用 `onClick` 函数：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This now gives us a UI action that is running client- and server-side code.
    We will look at some further examples later on in the chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在给我们一个同时运行客户端和服务器端代码的 UI 动作。我们将在本章后面进一步探讨一些示例。
- en: This type of script can be very useful, often being used on the client side
    to ensure certain fields are filled in or conditions are met before submission
    and the server-side code is run.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的脚本非常有用，通常在提交之前确保某些字段已填写或满足条件，并在运行服务器端代码之前在客户端使用。
- en: AJAX calls
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX 调用
- en: The AJAX call is a way of calling server-side script from the client side in
    an efficient way. It is possible to simply use `GlideRecord` on the client side,
    but this is not considered best practice. It is worth remembering that every time
    we call the server from the client side, we have to make a round-trip from the
    client to the server and back again. This takes time and shows as a delay in front
    of the user. Therefore, we want to reduce the amount of server calls we make,
    and ensure that any we do are as efficient as possible.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX 调用是一种从客户端以高效方式调用服务器端脚本的方法。虽然可以在客户端简单地使用 `GlideRecord`，但这并不被视为最佳实践。值得记住的是，每次我们从客户端调用服务器时，我们都需要从客户端到服务器再返回客户端的往返，这需要时间，并在用户面前表现为延迟。因此，我们希望减少我们进行的服务器调用数量，并确保任何进行的调用都尽可能高效。
- en: An AJAX call can perform multiple `GlideRecord` queries on the server, which
    saves us having to perform multiple calls to the server. For the AJAX call to
    work, we need to have some client-side script and some server-side script. This
    is most commonly a client script and a script include; we'll look at script includes
    further in a later chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX 调用可以在服务器上执行多个 `GlideRecord` 查询，这节省了我们多次调用服务器的需要。为了使 AJAX 调用工作，我们需要一些客户端脚本和一些服务器端脚本。这通常是一个客户端脚本和一个脚本包含；我们将在后面的章节中进一步探讨脚本包含。
- en: Client-side AJAX
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端 AJAX
- en: 'The client side of the AJAX call needs to set up the AJAX call and pass the
    relevant parameters to the server side. Once a response is received from the server,
    we can use the returned value or values to decide what changes to make. Let''s
    have a look at how the client side of the AJAX call works:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX 调用的客户端需要设置 AJAX 调用并向服务器端传递相关参数。一旦从服务器收到响应，我们可以使用返回的值或值来决定要做出哪些更改。让我们看看
    AJAX 调用的客户端是如何工作的：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding example covers the calling of the AJAX call and the return function,
    based on the results that are returned. In the first line, we create a new AJAX
    call and give it the name of our script include. Following on from this, we can
    add parameters to send to the server.  The first one we need to include every
    time, as the `sysparm_name` parameter is the name of the function we want to call
    on the server side.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上一示例涵盖了基于返回结果的 AJAX 调用和返回函数的调用。在第一行，我们创建一个新的 AJAX 调用并给它我们脚本的包含名称。在此基础上，我们可以添加要发送到服务器的参数。第一个我们需要每次都包含，因为
    `sysparm_name` 参数是我们想在服务器端调用的函数的名称。
- en: After that, we can send as many parameters as we like to the server side to
    use in the server-side script. In the example, we are sending the current caller
    in the `sysparm_user_id` parameter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以向服务器端发送我们喜欢的任何参数，以便在服务器端脚本中使用。在示例中，我们通过 `sysparm_user_id` 参数发送当前调用者。
- en: Finally, we use a `callback` function, which has the result returned to it using
    the `getXML` function. This allows the AJAX call to work asynchronously, and the
    client-side code can continue to run. You can use `getXMLWait` as a synchronous
    call instead, but this will stop the client from running code until the server-side
    code has completed, so is not best practice.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用一个 `callback` 函数，该函数使用 `getXML` 函数返回结果。这允许 AJAX 调用异步工作，客户端代码可以继续运行。您也可以使用
    `getXMLWait` 作为同步调用，但这将停止客户端运行代码，直到服务器端代码完成，因此这不是最佳实践。
- en: In the `callback` function, we make the answer variable the returned value of
    our server-side code. In this example, we are just showing an alert to the user
    of the result of our server-side script.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `callback` 函数中，我们将答案变量设置为服务器端代码的返回值。在这个例子中，我们只是向用户显示我们的服务器端脚本的执行结果。
- en: Server-side AJAX
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端 AJAX
- en: Now that we have seen the client aspect of an AJAX call, let's have a look at
    the the server-side code that is required to make this work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 AJAX 调用的客户端方面，让我们看看实现这一功能所需的服务器端代码。
- en: 'As mentioned before, we need to call the script include the same name as our
    AJAX call and make sure it contains a function with the name in the `sysparm_name`
    parameter. We also need to ensure we make the script include the client callable
    for the AJAX call to work, and we can do this by checking the client callable
    tick box on the script include:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要调用与我们的 AJAX 调用具有相同名称的脚本，并确保它包含一个具有 `sysparm_name` 参数中名称的函数。我们还需要确保脚本包含客户端可调用的，以便
    AJAX 调用可以工作，我们可以通过在脚本包含上检查客户端可调用复选框来完成此操作：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are using the `getUserLocation` function to return the caller's location
    back to the client. By using `GlideRecord` and the `get` method to obtain the
    user record, we can then return the location from that user record back to the
    client. We are using the display value to display to the user on the client; otherwise,
    we simply display the location record `sys_id`, which does not mean much to an
    end user.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `getUserLocation` 函数将调用者的位置返回给客户端。通过使用 `GlideRecord` 和 `get` 方法获取用户记录，然后我们可以从该用户记录返回位置给客户端。我们使用显示值在客户端向用户显示；否则，我们简单地显示位置记录
    `sys_id`，这对于最终用户来说意义不大。
- en: By using AJAX calls, we can pass back single values like in our example, or
    multiple values if needed. An array is a good way to pass multiple values back,
    but you can use other methods, too, as the response is an XML document.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 AJAX 调用，我们可以传递回单个值，如我们的示例所示，或者如果需要，可以传递多个值。数组是传递多个值的好方法，但您也可以使用其他方法，因为响应是一个
    XML 文档。
- en: Script examples
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本示例
- en: Now that we have seen some more advanced ways of using client-side script, let's
    look at some examples of how to use these newly learned techniques.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些更高级的客户端脚本使用方法，让我们看看如何使用这些新学的技术的一些示例。
- en: Let's first look at UI actions. We may want to use a UI action to progress states
    in a change record, but we want to make sure certain fields are filled in before
    we progress on to other states. We can use client- and server-side code to achieve
    this. First we use the client-side code to validate the form, and then the server-side
    code to perform changes to the record.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 UI 操作。我们可能想使用 UI 操作来推进变更记录的状态，但我们希望在推进到其他状态之前确保某些字段已填写。我们可以使用客户端和服务器端代码来实现这一点。首先，我们使用客户端代码来验证表单，然后使用服务器端代码对记录进行更改。
- en: 'We can have a look at how this would work:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看看这是如何工作的：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the example, on the client-side script, we are setting the field we want
    populated to `Mandatory` in the script to ensure that it is populated before the
    form is submitted. This is a good way of notifying the user of the additional
    field to fill in, as it uses the ServiceNow `Mandatory` functionality, rather
    than popups appearing to the user. You will notice that after the submission,
    we stop the field being `Mandatory`. This is so that if the user wants to simply
    save the form or change different field values, they are not stopped by the `justification`
    field still being `Mandatory`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，在客户端脚本中，我们正在将我们想要填充的字段在脚本中设置为`Mandatory`，以确保在表单提交之前填充。这是一种很好的通知用户填写额外字段的方法，因为它使用了ServiceNow的`Mandatory`功能，而不是向用户弹出窗口。你将注意到在提交之后，我们停止字段为`Mandatory`。这样做是为了如果用户只想简单地保存表单或更改不同的字段值，他们不会被`justification`字段仍然为`Mandatory`所阻止。
- en: For submitting the form, we use `gsftSubmit` and the action name of our UI action,
    which, in this example, is `authorize`. This allows the server-side script to
    run our server function, `setToAuthorize`. As the `state` field uses numbers as
    its values, we set the field to `-3`, and, as in the example, it is good practice
    to add comments to let other developers know what the value equates to; and it
    can be a good reminder for yourself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提交表单，我们使用`gsftSubmit`和我们的UI操作的动作名称，在这个例子中是`authorize`。这允许服务器端脚本运行我们的服务器函数`setToAuthorize`。由于`state`字段使用数字作为其值，我们将字段设置为`-3`，并且，正如示例中所示，添加注释以让其他开发者知道该值代表什么是一种良好的实践；这也可以作为你自己的良好提醒。
- en: 'We can take a look at what this UI action would look like in *Figure 4.2*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看看这个UI操作在*图4.2*中会是什么样子：
- en: '![](img/4ca383de-7ef6-4d03-b4ac-d72cb7c0965c.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ca383de-7ef6-4d03-b4ac-d72cb7c0965c.png)'
- en: 'Figure 4.2: Authorizing UI action with client- and server-side script'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：使用客户端和服务器端脚本授权UI操作
- en: This method of using client script to validate and server script to perform
    actions is very useful and works very nicely for UI actions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端脚本进行验证和服务器脚本执行操作的方法非常有用，并且对于UI操作来说效果非常好。
- en: Now let's take a look at an AJAX call example. For this example, we are going
    to look at a catalog item with dependencies on the variables in the catalog item.
    Sometimes users may have certain access that needs to be revoked, perhaps when
    they leave the company. When we select the user, we want to ensure that they have
    some kind of access; otherwise, there will be nothing for them to pick in the
    remaining fields, resulting in a poor user experience.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一个AJAX调用的示例。在这个例子中，我们将查看一个依赖于目录项中变量的目录项。有时用户可能需要撤销某些访问权限，例如当他们离开公司时。当我们选择用户时，我们想确保他们有一些形式的访问权限；否则，在剩余字段中他们将没有选择，这会导致用户体验不佳。
- en: 'Let us take a look at the client-side script we would put into a catalog client
    script:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将放入目录客户端脚本中的客户端脚本：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This would be put inside a catalog client script as an `onChange` script, and
    therefore dictates our function name. When we use catalog items and variables,
    we have to prefix our variable names with `variables` and then the variable name
    to use `g_form` methods. In the example, we are using a `user` and `access` variable,
    and as you can see, we clear the `access` variable when the user changes so that
    we don't end up with a mismatch of data on the screen where a user picks some
    access and then back fills the user.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被放入一个目录客户端脚本中作为一个`onChange`脚本，因此决定了我们的函数名称。当我们使用目录项和变量时，我们必须在变量名称前加上`variables`，然后使用`g_form`方法来使用变量名称。在示例中，我们使用了一个`user`和`access`变量，并且正如你所看到的，当用户更改时我们清除`access`变量，这样我们就不会在屏幕上出现数据不匹配的情况，其中用户选择了一些访问权限然后又回填用户。
- en: Before we initiate the AJAX call, we check that the new value of the user field
    is not blank. If it is, there is no use making a round-trip to the server, so
    we use `return`, essentially exiting the script. If the value is not blank, then
    we use an AJAX call, calling our script include and sending a user parameter containing
    the new value in the user field.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发起AJAX调用之前，我们检查用户字段的新值不是空的。如果是空的，就没有必要往返服务器，所以我们使用`return`，实际上退出脚本。如果值不为空，那么我们使用AJAX调用，调用我们的脚本包含并发送一个包含用户字段中新值的用户参数。
- en: When a response comes back from the server, if the result is that the user has
    no access, then we can assume there will be no access to select and remove for
    the user. Therefore there would be no selections to pick in the access variable.
    Rather than give the user nothing to select, we can clear the user field and let
    the user know the user they selected has no access to remove.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当从服务器返回响应时，如果结果是用户没有访问权限，那么我们可以假设用户将无法选择和删除访问权限。因此，在访问变量中不会有任何选择。与其让用户没有任何选择，我们可以清除用户字段，并让用户知道他们所选的用户没有访问权限来删除。
- en: 'Now that we have taken a look at the client side of this example, let''s have
    a look at the server-side code. Remember that the script include name and function
    need to match up with the client code making the AJAX call:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了这个例子的客户端部分，让我们看看服务器端代码。记住，脚本包含名称和函数需要与发起 AJAX 调用的客户端代码相匹配：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the server script, we are using a `GlideRecord` to check a custom access
    table, hence the `u_ prefix` using the `sysparm_user` parameter we passed to filter
    the result down to only records containing that user. If we find a record of access,
    we return `true` back to the client and `false` if no record can be found.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器脚本中，我们使用 `GlideRecord` 来检查一个自定义访问表，因此使用 `sysparm_user` 参数，通过过滤结果仅包含该用户的记录。如果我们找到一个访问记录，我们将向客户端返回
    `true`，如果没有找到记录，则返回 `false`。
- en: By returning `false` back to the client-side script, we clear the user variable
    on the form and show an error message so that the logged-in user knows that the
    user they selected has no access. If we assume a suitable reference qualifier
    has been set up, this would stop the logged-in user selecting the access variable
    after selecting a user and finding no records to select.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向客户端脚本返回 `false`，我们清除表单上的用户变量并显示错误消息，以便登录用户知道他们所选的用户没有访问权限。如果我们假设已经设置了合适的引用限定符，这将阻止登录用户在选择用户后找不到记录时选择访问变量。
- en: Since AJAX calls are so widely used, let's take a look at another example. In
    this example, we will notify a user on the incident form whether the change they
    have selected related to the incident that still has open tasks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 AJAX 调用被广泛使用，让我们看看另一个例子。在这个例子中，我们将通知事件表单上的用户，他们所选的更改是否与仍有打开任务的事件相关。
- en: 'This time, we''ll use a client script to make the AJAX call. We need it to
    run when the change request field changes on the incident form, so we''ll use
    an `onChange` script. Let''s have a look at how this client script code will look:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用客户端脚本发起 AJAX 调用。我们需要它在事件表单上的更改请求字段更改时运行，因此我们将使用 `onChange` 脚本。让我们看看这个客户端脚本代码将如何看起来：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we see an AJAX call again, this time sending the change request
    selected as a parameter. We do not need to run the AJAX call when the `change`
    field value or `newValue` is empty, but this time, we do want our script to run
    on load, so we have removed the `isLoading` check from the beginning of the script.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们再次看到了 AJAX 调用，这次是将所选更改请求作为参数发送。当 `change` 字段值或 `newValue` 为空时，我们不需要运行
    AJAX 调用，但这次我们确实希望我们的脚本在加载时运行，因此我们从脚本开头移除了 `isLoading` 检查。
- en: When we return from the AJAX call, we are using `g_form` to show a field message
    which appears just below the field to show whether the change request selected
    has open tasks or not.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 AJAX 调用返回时，我们使用 `g_form` 来显示一个字段消息，该消息出现在字段下方，以显示所选更改请求是否有打开的任务。
- en: 'Now we''ll take a look at the server-side script that makes this AJAX call
    work. A script include will be used to hold the code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看使这个 AJAX 调用工作的服务器端脚本。将使用脚本包含来保存代码：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the server-side script for this example, we are using a `GlideRecord` to
    find all the change tasks that are still open for the change request we passed
    in as a parameter. In the preceding script, we are using an `addQuery` line for
    the `GlideRecord` where the state is not `3` or `4`, which equates to closed and
    canceled. This allows us to treat any other state as open, even if further active
    states have been added from the out-of-the-box setup.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子的服务器端脚本中，我们使用 `GlideRecord` 来查找所有仍为传递的更改请求打开的更改任务。在前面的脚本中，我们使用 `addQuery`
    行为 `GlideRecord` 添加查询，其中状态不是 `3` 或 `4`，这相当于关闭和取消。这允许我们将任何其他状态视为打开，即使从开箱即用的设置中添加了更多的活动状态。
- en: This means that if any record is found, we can return `true` immediately, as
    we only need to know that at least one task is still open. There is no point in
    running through other change tasks if we find one that is still open, and this
    keeps the processing time down and the code more efficient.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果找到任何记录，我们可以立即返回 `true`，因为我们只需要知道至少有一个任务仍然是开放的。如果我们找到一个仍然开放的记录，就没有必要运行其他更改任务，这可以降低处理时间并提高代码效率。
- en: Once the return value is sent back, the corresponding field message will display
    to the user using the client-side code. This type of AJAX call can be very useful
    for giving users extra detail on forms about the data they are entering.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦返回值被发送回，相应的字段消息将通过客户端代码显示给用户。这种类型的 AJAX 调用对于向用户提供他们输入数据的额外详细信息非常有用。
- en: The AJAX call is widely used, and I would certainly recommend becoming acquainted
    with it as early as possible for scripting in ServiceNow, as many requirements
    will need an AJAX call so they can be fulfilled.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX 调用被广泛使用，我肯定会建议尽早熟悉它，以便在 ServiceNow 中进行脚本编写，因为许多需求将需要一个 AJAX 调用来满足。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the advanced side of client scripting. We saw
    how we can use UI actions to run client-side code and run client- and then server-side
    code. We also took a look at the all-important AJAX call for an efficient way
    to call server-side code from the client. Lastly, we had a look at some examples
    of how to use these advanced client-side techniques.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了客户端脚本的进阶方面。我们看到了如何使用 UI 动作来运行客户端代码，并运行客户端和服务器端代码。我们还研究了至关重要的 AJAX
    调用，这是一种从客户端高效调用服务器端代码的方法。最后，我们查看了一些如何使用这些高级客户端技术的示例。
- en: We will move on to the server side in the next chapter and see how to get started
    writing server-side script. This includes business rules, UI actions, and access
    controls. We'll also look at when these scripts should be written, how to test
    them, and some practical examples to help you get started.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转向服务器端，并了解如何开始编写服务器端脚本。这包括业务规则、UI 动作和访问控制。我们还将探讨这些脚本应该在何时编写，如何测试它们，以及一些实用示例来帮助您入门。
