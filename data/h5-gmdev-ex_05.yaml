- en: Chapter 5. Building a Canvas Game's Masterclass
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 构建Canvas游戏进阶课程
- en: '*In the previous chapter, we explored some basic Canvas context drawing APIs
    and created a game named Untangle. In this chapter, we are going to enhance the
    game by using some other context drawing APIs.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们探索了一些基本的画布上下文绘制API，并创建了一个名为Untangle的游戏。在这一章中，我们将通过使用一些其他的上下文绘制API来增强这个游戏。*'
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习以下内容：
- en: Implement the Untangle game logic
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Untangle游戏逻辑
- en: Fill text in the Canvas with a custom web font
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布中使用自定义网络字体填充文本
- en: Draw images in the Canvas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布中绘制图像
- en: Animate a sprite sheet image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画精灵图集图像
- en: Build multiple Canvas layers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建多个画布层
- en: 'The following screenshot is a preview of the final result that we are going
    to build through this chapter. It is a Canvas-based Untangle game with an animated
    game guideline and several subtle details:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是我们将通过本章构建的最终结果的预览。这是一个基于Canvas的Untangle游戏，具有动画游戏指南和几个细微之处：
- en: '![Building a Canvas Game''s Masterclass](img/B04290_05_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![构建Canvas游戏的进阶课程](img/B04290_05_01.jpg)'
- en: 'You can also try the final game example at: [http://makzan.net/html5-games/untangle/](http://makzan.net/html5-games/untangle/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试最终的游戏示例：[http://makzan.net/html5-games/untangle/](http://makzan.net/html5-games/untangle/)。
- en: So let's get on with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们就开始吧。
- en: Making the Untangle puzzle game
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作Untangle谜题游戏
- en: Now that we have created an interactive Canvas, we can drag the circles, and
    the lines connecting the circles which are intersecting with other lines. How
    about we make it a game? There are some predefined circles and lines and our aim
    is to drag the circles so that there are no lines intersecting with others. This
    is called an **Untangle puzzle game**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个交互式的画布，我们可以拖动圆圈，以及与其它线条交叉的连接圆圈的线条。我们为什么不把它变成一个游戏呢？有一些预定义的圆圈和线条，我们的目标是拖动圆圈，使得没有线条交叉。这被称为**Untangle解谜游戏**。
- en: Time for action – making the Untangle puzzle game in Canvas
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 在Canvas中制作Untangle谜题游戏
- en: 'Let''s add the game logic to our line intersection code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的线交叉代码中添加游戏逻辑：
- en: We need two more files for the game logic. Create two new files named `untangle.game.js`
    and `untangle.levels.js` file. Put them into the `js` folder.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要两个用于游戏逻辑的文件。创建两个新的文件，命名为`untangle.game.js`和`untangle.levels.js`，并将它们放入`js`文件夹中。
- en: 'Open the `index.html` file in a text editor. Add the following code to include
    our newly created file. Put the code in the file before including the `js/untangle.js`
    file:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`index.html`文件。添加以下代码以包含我们新创建的文件。将代码放在包含`js/untangle.js`文件之前：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Still in the `index.html` file, we add the following code after the `canvas`
    element. It displays the game level information:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`index.html`文件中，我们在`canvas`元素之后添加以下代码。它显示了游戏级别信息：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open the `untangle.levels.js` file. Put the following level data definition
    code into the file. It is a predefined level data for the players to play. It
    is a collection of data that defines where the circles are placed and how they
    connect to each other initially:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`untangle.levels.js`文件。将以下级别数据定义代码放入文件中。这是为玩家提供的预定义级别数据，它是一组定义圆圈放置位置及其初始连接方式的集合：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open the `untangle.game.js` file in text editor. We will put game logic into
    this file.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`untangle.game.js`文件。我们将把游戏逻辑放入这个文件。
- en: 'This is a new file, so we define the `untangleGame` object at the beginning
    of the file:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个新文件，所以我们定义`untangleGame`对象在文件的开始部分：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Continue in the `untangle.game.js` file. Add the following variables to the
    file. They store the current level and level progress of the game:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续在`untangle.game.js`文件中。将以下变量添加到文件中。它们存储游戏的当前级别和进度：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When starting on each level, we need to set up the initial level data. To help
    make the code more readable, we create a function. Append the following code to
    the `untangle.game.js` JavaScript file:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始每个级别时，我们需要设置初始级别数据。为了使代码更易于阅读，我们创建了一个函数。将以下代码追加到`untangle.game.js` JavaScript文件中：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is a game with several levels. We need to check whether the player solves
    the puzzle in the current level and jumps to the next puzzle. Add the following
    function to the end of the `untangle.game.js` file:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个包含多个级别的游戏。我们需要检查玩家是否解决了当前级别的谜题，并跳转到下一个谜题。将以下函数添加到`untangle.game.js`文件的末尾：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We need another function to update the game progress. Add the following function
    to the end of `untangle.game.js` file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个额外的函数来更新游戏进度。将以下函数添加到`untangle.game.js`文件的末尾：
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open the `untangle.input.js` file. We add the following code to the mouse move
    event handler, which updates the level progress:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `untangle.input.js` 文件。我们在鼠标移动事件处理程序中添加以下代码，以更新级别进度：
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We add the following code to the mouse up event handler to check whether the
    player completes the level:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在鼠标抬起事件处理程序中添加以下代码来检查玩家是否完成了级别：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now open the `untangle.js` file in an editor. Inside the jQuery document''s
    `ready` function, we had code to set up the circles and lines. They are now replaced
    by our level setup code. Delete the call to `untangleGame.createRandomCircles`
    and `untangleGame.connectCircles` functions. Replace them with the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在编辑器中打开 `untangle.js` 文件。在 jQuery 文档的 `ready` 函数内部，我们有一些设置圆和线的代码。它们现在被我们的级别设置代码所替换。删除对
    `untangleGame.createRandomCircles` 和 `untangleGame.connectCircles` 函数的调用。用以下代码替换它们：
- en: '[PRE10]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, open the `untangle.drawing.js` file in the code editor. We replace
    the `connectCircles` function to connect circles based on the level data:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在代码编辑器中打开 `untangle.drawing.js` 文件。我们将 `connectCircles` 函数替换为根据级别数据连接圆的函数：
- en: '[PRE11]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save all files and test the game in the browser. We can drag the circles and
    the line thickness will indicate whether it is intersected with other lines. During
    the mouse dragging, the level completeness percentage should change when more
    or less line intersections are detected. If we solve the puzzle, that is when
    no lines are intersected, the game will jump to the next level. When the game
    reaches the last level, it will keep showing the last level again. This is because
    we have not yet added the game over screen.![Time for action – making the Untangle
    puzzle game in Canvas](img/B04290_05_02.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件并在浏览器中测试游戏。我们可以拖动圆圈，线宽将指示是否与其他线相交。在鼠标拖动过程中，当检测到更多或更少的线相交时，级别完成百分比应发生变化。如果我们解开了谜题，即没有线相交时，游戏将跳到下一级。当游戏达到最后一级时，它将不断显示最后一级。这是因为我们还没有添加游戏结束界面。![动手实践
    – 在 Canvas 中制作 Untangle 拼图游戏](img/B04290_05_02.jpg)
- en: '*What just happened?*'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'We have added the game logic to our Canvas so that we can play our circle dragging
    code that has been created throughout this chapter. This section changes quite
    a lot of code. You may find the working example with uncompressed source code
    at: [http://makzan.net/html5-games/untangle-wip-gameplay/](http://makzan.net/html5-games/untangle-wip-gameplay/).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将游戏逻辑添加到我们的画布中，以便我们可以玩本章中创建的圆形拖拽代码。这一节更改了相当多的代码。您可以在以下链接找到带有未压缩源代码的工作示例：[http://makzan.net/html5-games/untangle-wip-gameplay/](http://makzan.net/html5-games/untangle-wip-gameplay/)。
- en: 'Let''s recall the variables we added to the `untangleGame` object. The following
    table lists the description and usage of these:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们添加到 `untangleGame` 对象中的变量。以下表格列出了这些变量的描述和用法：
- en: '| Variable | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `circleRadius` | The radius setting of all drawing circles. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `circleRadius` | 所有绘制圆的半径设置。 |'
- en: '| `thinLineThickness` | The line thickness when drawing thin lines. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `thinLineThickness` | 绘制细线时的线宽。 |'
- en: '| `boldLineThickness` | The line thickness when drawing bold lines. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `boldLineThickness` | 绘制粗线时的线宽。 |'
- en: '| `circles` | An array to store all drawn circles in the Canvas. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `circles` | 一个数组，用于在画布中存储所有绘制的圆。 |'
- en: '| `lines` | An array to store all drawn lines in the Canvas. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `lines` | 一个数组，用于在画布中存储所有绘制的线。 |'
- en: '| `targetCircle` | Keeps track of the circle that we are dragging. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `targetCircle` | 跟踪我们正在拖动的圆。 |'
- en: '| `levels` | Stores all initial data of each level in the JSON format. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `levels` | 以 JSON 格式存储每个级别的所有初始数据。 |'
- en: '| `currentLevel` | A number to help you remember the current level. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `currentLevel` | 一个数字，帮助您记住当前级别。 |'
- en: '| `levelProgress` | The percentage of non-intersected lines over all the lines.
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `levelProgress` | 所有线中非相交线的百分比。 |'
- en: Defining the leveling data
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义级别数据
- en: 'In each level, we have an initial position of the circles for the Untangle
    puzzle. The level data is designed as an array of objects. Each object contains
    every level''s data. Inside each level''s data, there are three properties: level
    number, circles, and lines connecting the circles. The following table shows the
    properties in each level''s data:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个级别中，我们都有一个 Untangle 拼图的圆的初始位置。级别数据设计为一个对象的数组。每个对象包含每个级别的数据。在每个级别的数据内部，有三个属性：级别编号、圆和连接圆的线。以下表格显示了每个级别数据中的属性：
- en: '| Level property | Definition | Discussion |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 级别属性 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `circles` | An array of circles'' positions in the level. | This defines
    how the circles are placed initially when the level is set up. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `circles` | 定义级别中圆圈位置的数组。 | 这定义了当设置级别时圆圈的初始放置方式。 |'
- en: '| `relationships` | An array of relationships defining which circles connect
    to each other. | There are some lines connecting the circles in each level. We
    design the line connections so that there is a solution in each level. The array
    index of each relationship indicates the target circle. The value of the line
    relationship defines which circle connects to the target circle. For example,
    the following code means the target circle is connected to both circle 1 and circle
    2:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '| `relationships` | 定义哪些圆圈相互连接的关系数组。 | 每个级别中都有一些连接圆圈的线条。我们设计线条连接方式，以确保每个级别都有一个解决方案。每个关系数组的索引表示目标圆圈。线条关系的值定义了哪个圆圈连接到目标圆圈。例如，以下代码表示目标圆圈连接到圆圈1和圆圈2：'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Determining level-up
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定升级
- en: 'The level is complete when there are no lines intersecting with each other.
    We loop through each line and see how many lines are thin. Thin lines mean they
    are not intersected with others. We can use the thin lines for all line ratios
    to get the percentage of the level of completeness:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有线条相互交叉时，级别就完成了。我们遍历每条线，看看有多少线条是细的。细线意味着它们没有与其他线条交叉。我们可以使用细线来计算所有线条的比例，以获得级别的完成百分比：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can then simply determine that the level has been completed when the progress
    is 100 percent.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当进度达到100%时，我们可以简单地确定级别已经完成。
- en: Displaying the current level and completeness progress
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示当前级别和完成进度
- en: 'We have displayed a sentence below the Canvas game describing the current level
    status and progress. It is used to display the game status to the players so they
    know that they are making progress in the game:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Canvas游戏下方显示了一句话，描述当前级别的状态和进度。它用于向玩家显示游戏状态，让他们知道他们在游戏中正在取得进展：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We use the jQuery `text` function that we discussed in [Chapter 2](ch02.html
    "Chapter 2. Getting Started with DOM-based Game Development"), *Getting Started
    with DOM-based Game Development*, to update the completeness progress:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在[第2章](ch02.html "第2章. 基于DOM的游戏开发入门")中讨论的jQuery `text` 函数，*基于DOM的游戏开发入门*，来更新完成进度：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Have a go hero
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: We have only defined three levels in the example Untangle puzzle game so far.
    But it is not fun enough to play with just three levels. How about adding more
    levels to the game? If you cannot come up with a level, try searching for similar
    untangle games on the Internet and get some inspiration on the levels.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在示例Untangle谜题游戏中只定义了三个级别。但只有三个级别玩起来还不够有趣。为什么不给游戏添加更多级别呢？如果你想不出级别，试着在互联网上搜索类似的untangle游戏，并从中获得一些灵感。
- en: Drawing text in the Canvas
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Canvas上绘制文本
- en: Imagine that now we want to show the progress level directly inside the Canvas.
    Canvas provides us with methods to draw text inside the Canvas.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，现在我们想在Canvas内部直接显示进度级别。Canvas为我们提供了在Canvas内部绘制文本的方法。
- en: Time for action – displaying the progress level text inside the canvas element
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 – 在canvas元素内显示进度级别文本
- en: 'We will continue using our Untangle game. Open the `untangle.drawing.js` JavaScript
    file in text editor. Add the following code after the Canvas drawing code in the
    `gameloop` function, which draws the current level and progress text inside the
    Canvas:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续使用我们的Untangle游戏。在文本编辑器中打开`untangle.drawing.js` JavaScript文件。在`gameloop`函数中的Canvas绘制代码之后添加以下代码，该代码在Canvas内部绘制当前级别和进度文本：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open the `untangle.js` file. We put the following code inside the `gameloop`
    function:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`untangle.js`文件。我们在`gameloop`函数中放入以下代码：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save the file and preview the `index.html` in a web browser. We will see that
    the text is now drawn inside the Canvas.![Time for action – displaying the progress
    level text inside the canvas element](img/B04290_05_03.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在网页浏览器中预览`index.html`。我们会看到文本现在被绘制在Canvas内部。![操作时间 – 在canvas元素内显示进度级别文本](img/B04290_05_03.jpg)
- en: '*What just happened?*'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We have just drawn the title and the level progress text in our Canvas-based
    game. We draw text in the Canvas by using the `fillText` function. The following
    table shows how we use the function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在基于Canvas的游戏中绘制了标题和级别进度文本。我们通过使用`fillText`函数在Canvas上绘制文本。以下表格显示了如何使用该函数：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| Argument | Definition |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `String` | The text that we are going to draw |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 我们将要绘制的文本 |'
- en: '| `X` | The *x* coordinate that the text draws |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `X` | 文本绘制的*x*坐标 |'
- en: '| `Y` | The *y* coordinate that the text draws |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `Y` | 文本绘制的*y*坐标 |'
- en: 'This is the basic setting to draw some text. There are several more drawing
    context properties to set up the text drawing:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是绘制文本的基本设置。还有更多绘图上下文属性可以设置文本绘制：
- en: '| Context properties | Definition | Discussion |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 上下文属性 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `context.font` | The font style of the text | This shares the same syntax
    we used to declare the font style in CSS. For example, the following code sets
    the font style to 20 pixels bold with the Arial typeface:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '| `context.font` | 文本的字体样式 | 这与我们用于在CSS中声明字体样式的语法相同。例如，以下代码将字体样式设置为20像素粗体，使用Arial字体：'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `context.textAlign` | The text alignment | The **alignment** defines how
    the text is aligned. It can be one of the following values:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '| `context.textAlign` | 文本对齐 | **对齐方式**定义了文本的对齐方式。它可以有以下值之一：'
- en: '`start`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`'
- en: '`end`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`'
- en: '`left`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`'
- en: '`right`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right`'
- en: '`center`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`'
- en: For instance, if we are going to place some text on the right edge of the Canvas,
    using the `left` alignment means we need to calculate the text's width in order
    to know the x coordinate of the text.When using right alignment in this case,
    all we need to do is set the x position directly to the Canvas width. The text
    will then automatically be placed on the right edge of the Canvas. |
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在Canvas的右边缘放置一些文本，使用`left`对齐意味着我们需要计算文本的宽度，以便知道文本的x坐标。在这种情况下使用右对齐，我们只需直接将x位置设置为Canvas宽度。文本将自动放置在Canvas的右边缘。|
- en: '| `context.textBaseline` | The text baseline | The following lists the common
    value of a `textBaseline` property:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '| `context.textBaseline` | 文本基线 | 以下列出了`textBaseline`属性的常见值：'
- en: '`top`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`'
- en: '`middle`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`middle`'
- en: '`bottom`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`'
- en: '`alphabet`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alphabet`'
- en: Similar to text alignment, the `bottom` baseline is useful when we want to place
    our text at the bottom of the Canvas. The *y* position of the `fillText` function
    is based on the bottom baseline of the text instead of the top.The `alphabet`
    baseline aligns the y position based on the lowercase alphabet. The following
    screenshot shows our text drawing with the **alphabet** baseline. |
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与文本对齐类似，当我们要将文本放置在Canvas底部时，`bottom`基线非常有用。`fillText`函数的`y`位置基于文本的底部基线而不是顶部。`alphabet`基线根据小写字母对齐y位置。以下截图显示了使用**alphabet**基线的文本绘制效果。|
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please be aware that the text drawing in Canvas is treated as bitmap image data.
    This means visitors cannot select the text; search engines cannot index the text;
    we cannot search the text. For this reason, we should think carefully about whether
    we want to draw the text inside the Canvas or just place it directly in the DOM.
    Alternatively, we should change the fallback text inside the `canvas` element
    to reflect the drawing text.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Canvas中的文本绘制被视为位图图像数据。这意味着访客无法选择文本；搜索引擎无法索引文本；我们无法搜索文本。因此，我们应该仔细考虑是否要在Canvas内绘制文本，或者直接将其放置在DOM中。或者，我们应该将`canvas`元素内的备用文本更改为反映绘制文本。
- en: Pop quiz – drawing text in the Canvas
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 - 在Canvas中绘制文本
- en: Q1\. If we are going to draw some text close to the bottom-right corner of the
    Canvas, which alignment and baseline setting is better?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 如果我们要在Canvas的右下角附近绘制一些文本，哪种对齐和基线设置更好？
- en: Left alignment, bottom baseline.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左对齐，底部基线。
- en: Center alignment, alphabet baseline.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 居中对齐，字母基线。
- en: Right alignment, bottom baseline.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右对齐，底部基线。
- en: Center alignment, middle baseline.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 居中对齐，中间基线。
- en: Q2\. We are going to make a realistic book with a flipping effect with the latest
    open web standard. Which of the following settings is better?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 我们将使用最新的开放网络标准制作一本具有翻页效果的逼真书籍。以下哪个设置更好？
- en: Draw the realistic book in Canvas, including all the text and the flipping effect.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Canvas中绘制逼真的书籍，包括所有文本和翻页效果。
- en: Put all text and content in the DOM and draw the realistic page-flipping effect
    in Canvas.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有文本和内容放入DOM中，并在Canvas中绘制逼真的翻页效果。
- en: Using embedded web font inside the Canvas
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Canvas中使用嵌入的Web字体
- en: We used a custom font in our memory, matching the game in the previous chapter.
    Custom font embedding also works in the Canvas. Let's conduct an experiment on
    drawing a custom font in our Untangle game in the Canvas.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在记忆中使用了自定义字体，与上一章中的游戏相匹配。自定义字体嵌入在Canvas中同样有效。让我们在我们的Untangle游戏中进行一个在Canvas中绘制自定义字体的实验。
- en: Time for action – embedding a Google web font into the canvas element
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践时间 - 将Google网络字体嵌入到canvas元素中
- en: 'Let''s draw the Canvas texts with a handwriting style font:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用手写风格的字体绘制Canvas文本：
- en: First, go to the Google font directory and choose a handwriting style font.
    I used the font **Rock Salt** and you can get it from the following URL:[http://www.google.com/fonts/specimen/Rock+Salt](http://www.google.com/fonts/specimen/Rock+Salt).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，前往Google字体目录并选择一种手写风格的字体。我使用了**Rock Salt**字体，您可以从以下网址获取它：[http://www.google.com/fonts/specimen/Rock+Salt](http://www.google.com/fonts/specimen/Rock+Salt)。
- en: 'The Google font directory provides a CSS link code that we can add to our game
    in order to embed the font. Add the following CSS link to the head of `index.html`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google字体目录提供了一个CSS链接代码，我们可以将其添加到游戏中以嵌入字体。将以下CSS链接添加到`index.html`的头部：
- en: '[PRE20]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next thing is to use the font. We open the `untangle.drawing.js` JavaScript
    file and modify the context `font` property in the `drawLevelProgress` function
    to the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用字体。我们打开`untangle.drawing.js`JavaScript文件，并在`drawLevelProgress`函数中将上下文的`font`属性修改为以下内容：
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is time to open our game in the web browser to test the result. The text
    drawn in the Canvas is now using the font we chose in the Google font directory.![Time
    for action – embedding a Google web font into the canvas element](img/B04290_05_04.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候在我们的网页浏览器中打开游戏以测试结果了。Canvas中绘制的文本现在使用的是我们在Google字体目录中选择的字体。![动手时间 – 将Google网络字体嵌入到canvas元素中](img/B04290_05_04.jpg)
- en: '*What just happened?*'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just chose a web font and embedded it into the Canvas when drawing text.
    This shows that we can style the font family of the filled text in the Canvas
    just like other DOM elements.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是选择了一个网络字体并将其嵌入到Canvas中绘制文本。这表明我们可以在Canvas中填充文本的字体家族中像其他DOM元素一样进行样式设置。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Sometimes the width of the text varies in different font families although
    they have the same word count. In this case, we can use the `measureText` function
    to get the width of the text we draw. The Mozilla Developer Network explains how
    we can use the function at: [https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText()](https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText()).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，尽管单词数量相同，不同字体的文本宽度也会有所不同。在这种情况下，我们可以使用`measureText`函数来获取我们绘制的文本宽度。Mozilla开发者网络解释了如何使用该函数，请参阅：[https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText()](https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText())。
- en: Drawing images in the Canvas
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Canvas中绘制图像
- en: We have drawn some text inside the Canvas. What about drawing an image? Yes.
    Drawing images and image manipulation is a big feature of the Canvas.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Canvas内部绘制了一些文本。那么绘制图像呢？是的。绘制图像和图像处理是Canvas的一个大特性。
- en: Time for action – adding graphics to the game
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 – 向游戏中添加图形
- en: 'We are going to draw a blackboard background to the game:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要为游戏绘制一个黑板背景：
- en: 'Download the graphics files from the code example bundle or the following URL:
    [http://mak.la/book-assets](http://mak.la/book-assets). The graphics files include
    all the graphics that we need in this chapter.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码示例包或以下网址下载图形文件：[http://mak.la/book-assets](http://mak.la/book-assets)。图形文件包括我们本章需要的所有图形。
- en: Put the newly downloaded graphics files into a folder named `images`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新下载的图形文件放入一个名为`images`的文件夹中。
- en: 'Now it is time to really load the image. There is a `board.png` file in the
    graphics file we just downloaded. It is a blackboard graphic that we will draw
    in the Canvas as a background. Add the following code after the code we just added
    in the previous step:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是真正加载图像的时候了。在我们刚刚下载的图形文件中有一个`board.png`文件。这是一个黑板图形，我们将它绘制在Canvas上作为背景。在上一步骤中添加的代码之后添加以下代码：
- en: '[PRE22]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since the image loading takes time, we also need to ensure it is loaded before
    drawing it:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于图像加载需要时间，我们还需要确保在绘制之前它已经被加载：
- en: '[PRE23]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Open the `untangle.js` file, in the jQuery document `ready` function:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`untangle.js`文件，在jQuery文档的`ready`函数中：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `gameloop` function in the `untangle.js` file, we draw the image in
    the Canvas after clearing the context and before drawing anything else:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`untangle.js`文件中的`gameloop`函数里，我们在清除上下文之后、绘制其他任何内容之前，在Canvas上绘制图像：
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, we do not want a background color set to the Canvas because we have a
    PNG background with a transparent border. Open the `untangle.css` file and remove
    the background property in Canvas.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们不希望Canvas设置背景颜色，因为我们有一个带有透明边框的PNG背景。打开`untangle.css`文件并移除Canvas中的背景属性。
- en: Now, save all files and open the `index.html` file in the web browser. The background
    should be there and the handwritten fonts should match our blackboard theme.![Time
    for action – adding graphics to the game](img/B04290_05_05.jpg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存所有文件并在网络浏览器中打开 `index.html` 文件。背景应该在那里，手写字体应该与我们的黑板主题相匹配。![添加图形到游戏的时间 -
    添加图形](img/B04290_05_05.jpg)
- en: '*What just happened?*'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We just drew an image inside the `canvas` element. You can find the working
    example at the following URL:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在 `canvas` 元素内部绘制了一个图像。您可以在以下 URL 中找到工作示例：
- en: '[http://makzan.net/html5-games/untangle-wip-graphics1/](http://makzan.net/html5-games/untangle-wip-graphics1/)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://makzan.net/html5-games/untangle-wip-graphics1/](http://makzan.net/html5-games/untangle-wip-graphics1/)'
- en: There are two common ways to draw an image in the Canvas. We can either reference
    an existing `<img>` tag or load the image on the fly in JavaScript.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制图像有两种常见方法。我们可以引用现有的 `<img>` 标签，或者动态地在 JavaScript 中加载图像。
- en: 'Here is how we reference the existing image tag in `canvas`, assuming that
    we have the following `img` tag in HTML:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在 `canvas` 中引用现有的图像标签的，假设我们有以下 `img` 标签在 HTML 中：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can draw the image in the Canvas by using the following JavaScript code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 JavaScript 代码在画布上绘制图像：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is another code snippet to load the image without attaching the `<img>`
    tag into the DOM. If we load the image inside JavaScript, we need to make sure
    the image is loaded before drawing it in the Canvas. Therefore, we draw the image
    after the `onload` event of the image:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个代码片段，用于在不将 `<img>` 标签附加到 DOM 中的情况下加载图像。如果我们将在 JavaScript 中加载图像，我们需要确保图像在画布上绘制之前已经加载。因此，我们在图像的
    `onload` 事件之后绘制图像：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The order matters when setting the `onload` event handler and assigning the
    image `src`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `onload` 事件处理程序和分配图像 `src` 时，顺序很重要。
- en: When we assign the `src` property to the image and if the image is cached by
    the browser, some browsers fire the `onload` event immediately. If we place the
    `onload` event handler after assigning the `src` property, we may miss it because
    it is fired before we set the event handler.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `src` 属性分配给图像，并且如果图像被浏览器缓存，一些浏览器会立即触发 `onload` 事件。如果我们把 `onload` 事件处理程序放在分配
    `src` 属性之后，我们可能会错过它，因为它在我们设置事件处理程序之前被触发。
- en: In our example, we used the latter approach. We create an `Image` object and
    loaded the background.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了后一种方法。我们创建了一个 `Image` 对象并加载了背景。
- en: 'Another event that we should handle when loading the image is the `onerror`
    event. It is especially useful when we are accessing extra network data. We use
    the following code snippet to check the errors in our example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载图像时，我们还应该处理另一个事件，即 `onerror` 事件。当我们访问额外的网络数据时，它特别有用。我们使用以下代码片段来检查我们示例中的错误：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Have a go hero
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: The error loading now only displays a message in the console. The console is
    normally not viewed by players. How about writing a message to the Canvas to tell
    players that the game failed to load the game's assets?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载错误现在只会在控制台中显示一条消息。通常玩家不会查看控制台。我们是否可以向画布写入一条消息，告诉玩家游戏未能加载游戏资源？
- en: Using the drawImage function
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `drawImage` 函数绘制图像
- en: There are three ways to draw an image in the Canvas using the `drawImage` function.
    We can draw the image without any modification on a given coordinate, we can also
    draw the image with a scaling factor on a given coordinate, or we can even crop
    the image and draw only the clipping region.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `drawImage` 函数在画布上绘制图像有三种方法。我们可以在给定的坐标上不进行任何修改地绘制图像，我们也可以在给定的坐标上使用缩放因子绘制图像，或者甚至裁剪图像并只绘制剪切区域。
- en: 'The `drawImage` function accepts several arguments:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawImage` 函数接受多个参数：'
- en: 'Every argument present in `drawImage(image, x, y);` is explained in the following
    table:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `drawImage(image, x, y);` 中出现的每个参数都在以下表格中解释：
- en: '| Argument | Definition | Discussion |'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `image` | The reference of the image that we are going to draw. | We either
    get the image reference by using an existing `img` element or creating a JavaScript
    `Image` object. |'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `image` | 我们将要绘制的图像的引用。 | 我们可以通过使用现有的 `img` 元素或创建 JavaScript `Image` 对象来获取图像引用。
    |'
- en: '| `x` | The position of *x* where the image will be placed in the Canvas coordinates.
    | The *x* and *y* coordinate is where we place the image with respect to its top-left
    corner. |'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `x` | 图像将在画布坐标中放置的 *x* 位置。 | *x* 和 *y* 坐标是我们放置图像相对于其左上角的位置。 |'
- en: '| `y` | The position of *y* where the image will be placed in the Canvas coordinates.
    |'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `y` | 图像将在画布坐标中放置的 *y* 位置。 |'
- en: 'Every argument present in `drawImage(image, x, y, width, height);` is explained
    in the following table:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `drawImage(image, x, y, width, height);` 函数中出现的每个参数都在以下表格中进行了说明：
- en: '| Argument | Definition | Discussion |'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `image` | The image reference that we are going to draw. | We either get
    the image reference by using an existing `img` element or creating a JavaScript
    `Image` object. |'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `image` | 我们将要绘制的图像引用。 | 我们可以通过获取现有的 `img` 元素或创建 JavaScript `Image` 对象来获取图像引用。
    |'
- en: '| `x` | The position of *x* where the image will be placed in the Canvas coordinates.
    | The *x* and *y* coordinate is where we place the image with respect to its top-left
    corner. |'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `x` | 图像在 Canvas 坐标系中放置的**x**位置。 | **x** 和 **y** 坐标是相对于图像的左上角放置图像的位置。 |'
- en: '| `y` | The position of *y* where the image will be placed in the Canvas coordinates.
    |'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `y` | 图像在 Canvas 坐标系中放置的**y**位置。 |'
- en: '| `width` | The width of the final drawn image. | We apply scale to the image
    if the width and height is not the same as the original image. |'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `width` | 最终绘制图像的**宽度**。 | 如果宽度和高度与原始图像不同，我们将对图像应用缩放。 |'
- en: '| `height` | The height of the final drawn image. |'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `height` | 最终绘制图像的**高度**。 |'
- en: 'Every argument present in `drawImage(image, sx, sy, sWidth, sHeight, dx, dy,
    width, height);` is explained in the following table:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `drawImage(image, sx, sy, sWidth, sHeight, dx, dy, width, height);` 函数中出现的每个参数都在以下表格中进行了说明：
- en: '| Argument | Definition | Discussion |'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `image` | The image reference that we are going to draw. | We either get
    the image reference by getting an existing `img` element or creating a JavaScript
    `Image` object. |'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `image` | 我们将要绘制的图像引用。 | 我们可以通过获取现有的 `img` 元素或创建 JavaScript `Image` 对象来获取图像引用。
    |'
- en: '| `sx` | The *x* coordinate of the top-left corner of the clipping region.
    | Clipping *x*, *y*, width, height together defines a rectangular clipping area.
    The given image is clipped by this rectangle. |'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `sx` | 剪裁区域左上角的**x**坐标。 | 通过将剪裁区域的**x**、**y**、宽度、高度一起定义，可以确定一个矩形剪裁区域。给定的图像将通过这个矩形进行剪裁。
    |'
- en: '| `sy` | The *y* coordinate of the top-left corner of the clipping region.
    |'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `sy` | 剪裁区域左上角的**y**坐标。 |'
- en: '| `sWidth` | The width of the clipping region. |'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `sWidth` | 剪裁区域的**宽度**。 |'
- en: '| `sHeight` | The height of the clipping region. |'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `sHeight` | 剪裁区域的**高度**。 |'
- en: '| `dx` | The position of *x* where the image will be placed in the Canvas coordinates.
    | The *x* and *y* coordinate is where we place the image with respect to its top-left
    corner. |'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `dx` | 图像在 Canvas 坐标系中放置的**x**位置。 | **x** 和 **y** 坐标是相对于图像的左上角放置图像的位置。 |'
- en: '| `dy` | The position of *y* where the image will be placed in the Canvas coordinates.
    |'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `dy` | 图像在 Canvas 坐标系中放置的**y**位置。 |'
- en: '| `width` | The width of the final drawn image. | We are applying scale to
    the clipped image if the width and height is not the same as the clipping dimension.
    |'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `width` | 最终绘制图像的**宽度**。 | 如果剪裁的宽度和高度与剪裁维度不同，我们将对剪裁的图像应用缩放。 |'
- en: '| `height` | The height of the final drawn image. |'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `height` | 最终绘制图像的**高度**。 |'
- en: Have a go hero – optimizing the background image
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试 – 优化背景图像
- en: In the example, we draw the blackboard image as the background in every call
    to the `gameloop` function. Since our background is static and does not change
    with time, clearing it and redrawing it again and again is wasting CPU resources.
    How can we optimize this performance issue? In a later section, we will divide
    the game into multiple layers to avoid redrawing the static background image.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们在每次调用 `gameloop` 函数时将黑板图像作为背景绘制。由于我们的背景是静态的，并且不会随时间变化，因此不断清除并重新绘制它是在浪费
    CPU 资源。我们如何优化这个问题？在后面的部分，我们将游戏分成多个层级，以避免重新绘制静态的背景图像。
- en: Decorating the Canvas-based game
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰基于 Canvas 的游戏
- en: We have enhanced the Canvas game with gradients and images. Before moving forward,
    let's decorate the web page of our Canvas game.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经增强了 Canvas 游戏，添加了渐变和图像。在继续前进之前，让我们装饰我们的 Canvas 游戏网页。
- en: Time for action – adding CSS styles and image decoration to the game
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施动作 – 为游戏添加 CSS 样式和图像装饰
- en: 'We are going to build a center-aligned layout with a game title:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个居中对齐的布局，包含游戏标题：
- en: 'Open `index.html` in a text editor. It is easier for us to style the layout
    with one grouping DOM element. We put all the elements inside the body into a
    section with the `id` page. Replace the contents of the HTML file with the following:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 `index.html` 文件。使用一个分组 DOM 元素来设置布局样式对我们来说更容易。我们将所有元素放入一个具有 `id` 页面的部分中。用以下内容替换
    HTML 文件的内容：
- en: '[PRE30]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s apply CSS to the page layout. Replace existing content in the `untangle.css`
    file with the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `untangle.css` 文件中应用 CSS 到页面布局。用以下代码替换现有内容：
- en: '[PRE31]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is time to save all the files and preview the game in a web browser. We should
    see a title ribbon and a well-styled layout that is center-aligned. The following
    screenshot shows the result:![Time for action – adding CSS styles and image decoration
    to the game](img/B04290_05_06.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候保存所有文件并在网页浏览器中预览游戏了。我们应该看到一个标题带和一个居中对齐的精美布局。以下截图显示了结果：![行动时间 – 为游戏添加 CSS
    样式和图像装饰](img/B04290_05_06.jpg)
- en: '*What just happened?*'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just decorated the web page that contains our Canvas-based game. Although
    our game is based on a Canvas drawing, it does not restrict us from decorating
    the whole web page with graphics and CSS styles.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚装饰了包含我们的基于 Canvas 的游戏的网页。尽管我们的游戏基于 Canvas 绘图，但这并不限制我们用图形和 CSS 样式装饰整个网页。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Default background of the canvas element**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**canvas 元素的默认背景**'
- en: The default background of the `canvas` element is transparent. If we do not
    set any background CSS style for the Canvas, it will be transparent. This is useful
    when our drawing is not a rectangle. In this example, the textured layout background
    shows within the Canvas region.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas` 元素的默认背景是透明的。如果我们不对 Canvas 设置任何背景 CSS 样式，它将是透明的。当我们的绘图不是矩形时，这很有用。在这个例子中，纹理布局背景显示在
    Canvas 区域内。'
- en: Pop quiz – styling a Canvas background
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 – 设置 Canvas 背景
- en: Q1\. How can we set the Canvas background to be transparent?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 我们如何设置 Canvas 背景为透明？
- en: Set the background color to `#ffffff`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将背景颜色设置为 `#ffffff`。
- en: Do nothing. It is transparent by default.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不做任何事情。默认情况下它是透明的。
- en: Animating a sprite sheet in Canvas
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Canvas 中动画化精灵图集
- en: We first used **sprite sheet** images in [Chapter 3](ch03.html "Chapter 3. Building
    a Card-matching Game in CSS3"), *Building a Card-matching Game in CSS3*, when
    displaying a deck of playing cards.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 [第 3 章](ch03.html "第 3 章。使用 CSS3 构建纸牌匹配游戏") 中使用了 **精灵图集** 图像，*使用 CSS3
    构建纸牌匹配游戏*，当显示一副扑克牌时。
- en: Time for action – making a game guide animation
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 制作游戏指南动画
- en: There is a graphics file named `guide_sprite.png` in the images folder. It is
    a game guideline graphic that contains each step of the animation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片文件夹中有一个名为 `guide_sprite.png` 的图形文件。它是一个包含动画每个步骤的游戏指南图形。
- en: '![Time for action – making a game guide animation](img/B04290_05_07.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 制作游戏指南动画](img/B04290_05_07.jpg)'
- en: 'Let''s draw this guide into our game with **animations**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 **动画** 将这个指南绘制到我们的游戏中：
- en: Open the `untangle.drawing.js` JavaScript file in the text editor.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 `untangle.drawing.js` JavaScript 文件。
- en: 'In the `untangleGame.loadImages` function, add the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `untangleGame.loadImages` 函数中，添加以下代码：
- en: '[PRE32]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Still in the `untangleGame.drawing.js` file, we add the following function
    to move the current frame to the next frame every 500 milliseconds:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `untangleGame.drawing.js` 文件中，我们添加以下函数，每500毫秒将当前帧移动到下一帧：
- en: '[PRE33]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we define the `drawGuide` function in the `untangleGame.drawing.js` file.
    This function draws the guide animation according to the current frame:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在 `untangleGame.drawing.js` 文件中定义 `drawGuide` 函数。这个函数根据当前帧绘制指南动画：
- en: '[PRE34]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's switch to the `untangle.js` file. In the `gameloop` function, we call
    the guide drawing function before ending the `gameloop` function.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们切换到 `untangle.js` 文件。在 `gameloop` 函数中，我们在结束 `gameloop` 函数之前调用指南绘图函数。
- en: '[PRE35]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's watch the animation in the web browser by opening the `index.html` file.
    The following screenshot demonstrates the animation of the game guideline. The
    guideline animation will play and loop until the player levels up:![Time for action
    – making a game guide animation](img/B04290_05_08.jpg)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在网页浏览器中通过打开 `index.html` 文件来观看动画。以下截图展示了游戏指南的动画。指南动画将在玩家升级前播放并循环：![行动时间 –
    制作游戏指南动画](img/B04290_05_08.jpg)
- en: '*What just happened?*'
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We can draw only a region of an image when using the `drawImage` context function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `drawImage` 上下文函数时，我们只能绘制图像的一个区域。
- en: 'The following screenshot demonstrates the process of animation step by step.
    The rectangle is the clipping region:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图逐步展示了动画过程。矩形是剪切区域：
- en: '![What just happened?](img/B04290_05_09.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04290_05_09.jpg)'
- en: 'We used a variable named `guideFrame` to control which frame to show. The width
    of each frame is 80\. Therefore, we get the x position of the clipping region
    by multiplying the width and the current frame number:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用名为`guideFrame`的变量来控制显示哪个帧。每个帧的宽度是80。因此，我们通过乘以宽度和当前帧号来获取剪切区域的x位置：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `guideFrame` variable is updated every 500 milliseconds by the following
    `guideNextFrame` function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`guideFrame`变量通过以下`guideNextFrame`函数每500毫秒更新一次：'
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Animating a sprite is a commonly used technique when developing games. There
    are some benefits of using sprite animation when developing traditional video
    games. The reasons may not apply to web game development but there are other benefits
    of using sprite sheet animation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发游戏时，动画精灵是一种常用的技术。在开发传统视频游戏时使用精灵动画有一些好处。这些原因可能不适用于网络游戏开发，但使用精灵表动画还有其他好处：
- en: All frames are loaded as one file so the whole animation is ready once the sprite
    file is loaded.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有帧都作为一个文件加载，所以一旦精灵文件被加载，整个动画就准备好了。
- en: Putting all frames into one file means we can reduce the HTTP request from the
    web browser to the server. If each frame is a file, the browser requests the file
    many times, while now it just requests one file and uses one HTTP request.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有帧放入一个文件意味着我们可以减少从网络浏览器到服务器的HTTP请求。如果每个帧都是一个文件，浏览器会多次请求该文件，而现在它只需请求一个文件并使用一个HTTP请求。
- en: Putting different images into one file also reduces the duplication of files,
    which helps to reduce the duplicate file's header, footer, and metadata.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不同的图像放入一个文件也减少了文件的重复，这有助于减少重复文件的头部、尾部和元数据。
- en: Putting all frames into one image means we can easily clip the image to display
    any frame without complex code to change the image source.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有帧放入一个图像中意味着我们可以轻松地剪切图像以显示任何帧，而无需复杂的代码来更改图像源。
- en: Sprite sheet animation is usually used in character animation. The following
    screenshot is a **sprite animation** of an angry cat that I used in an HTML5 game
    named **Neighbours**.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵表动画通常用于角色动画。以下截图是我在一个名为**邻居**的HTML5游戏中使用的愤怒猫的**精灵动画**。
- en: '![What just happened?](img/B04290_05_10.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04290_05_10.jpg)'
- en: We built the sprite sheet animation by clipping the frame and setting up the
    timer ourselves in this example. When working with a lot of animations, we may
    want to use a third-party sprite animation plugin or create our own Canvas sprite
    animation to better reuse and manage the logic code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们通过剪切帧并自行设置计时器来构建精灵表动画。当处理大量动画时，我们可能希望使用第三方精灵动画插件或创建自己的Canvas精灵动画，以更好地重用和管理逻辑代码。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Sprite animation is an important topic in HTML5 games development and there
    are many online resources discussing this topic. The following links are some
    of them:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵动画是HTML5游戏开发中的一个重要主题，有许多在线资源讨论了这个主题。以下是一些链接：
- en: The sprite animation tutorial ([http://simurai.com/blog/2012/12/03/step-animation/](http://simurai.com/blog/2012/12/03/step-animation/))
    by Simurai discusses how we can make a sprite animation with CSS only.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Simurai的精灵动画教程([http://simurai.com/blog/2012/12/03/step-animation/](http://simurai.com/blog/2012/12/03/step-animation/))讨论了我们可以如何仅使用CSS制作精灵动画。
- en: Spritely ([http://www.spritely.net/](http://www.spritely.net/)), on the other
    hand, provides sprite animation over the DOM element with CSS. It is useful when
    we want to animate a sprite without using Canvas.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Spritely ([http://www.spritely.net/](http://www.spritely.net/))，另一方面，通过CSS在DOM元素上提供精灵动画。当我们想要在不使用Canvas的情况下动画化精灵时，这很有用。
- en: Creating a multilayer Canvas game
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多层Canvas游戏
- en: Now all things are drawn into the context, which has no other state to distinguish
    the items drawn. We may split the Canvas game into different layers and code the
    logic to control and draw each layer at a time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有东西都绘制到了没有其他状态来区分绘制项的上下文中。我们可能将Canvas游戏分成不同的层，并编写逻辑来控制一次绘制一个层。
- en: Time for action – dividing the game into four layers
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 将游戏分为四层
- en: 'We are going to separate our Untangle game into four layers:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的Untangle游戏分为四层：
- en: 'In `index.html`, we need to change or replace the current `canvas` tag with
    the following code. It should contain several Canvases within a section:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`中，我们需要更改或替换当前的`canvas`标签，如下所示。它应该在部分内包含几个Canvas：
- en: '[PRE38]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We also need to apply some styles to the Canvases so they overlap with each
    other to create a multiple layers effect. Also we have to prepare a `fadeout`
    class and a `dim` class to make the target transparent. Add the following code
    into the `untangle.css` file:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将一些样式应用到画布上，以便它们相互重叠，从而创建多层效果。同时，我们必须准备一个`fadeout`类和一个`dim`类，以便使目标透明。将以下代码添加到`untangle.css`文件中：
- en: '[PRE39]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Open the `untangle.js` JavaScript file. We modify the code to support the layers
    feature. First, we add an array to store the context reference of each Canvas.
    Add it at the beginning of the file, before the jQuery document ready function
    and after the `untangleGame` definition:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`untangle.js` JavaScript文件。我们修改代码以支持层功能。首先，我们添加一个数组来存储每个Canvas的上下文引用。在文件的开始处添加它，在jQuery文档就绪函数之前，并在`untangleGame`定义之后：
- en: '[PRE40]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Then, we remove the following lines of code in the jQuery document ready function.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在jQuery文档就绪函数中删除以下代码行。
- en: '[PRE41]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We replace the code we deleted with the following code. We get the context
    reference of each Canvas layer and store them in the array:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用以下代码替换我们删除的代码。我们获取每个Canvas层的上下文引用并将它们存储在数组中：
- en: '[PRE42]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let's switch to `untangle.drawing.js` file. We are going to update the context
    references at several places to support multilayers.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们切换到`untangle.drawing.js`文件。我们将在几个地方更新上下文引用以支持多层。
- en: 'There are now four Canvas contexts that we may clear. Find the existing `clear`
    function and replace it with the following:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在有四个Canvas上下文，我们可以清除。找到现有的`clear`函数，并将其替换为以下内容：
- en: '[PRE43]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `drawCircle` and `drawLine` function, replace `var ctx = untangleGame.ctx;`
    with the following code:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`drawCircle`和`drawLine`函数中，将`var ctx = untangleGame.ctx;`替换为以下代码：
- en: '[PRE44]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `drawLevelProgress` function, replace `var ctx = untangleGame.ctx;`
    with the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`drawLevelProgress`函数中，将`var ctx = untangleGame.ctx;`替换为以下代码：
- en: '[PRE45]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `drawBackground` function, we replace the existing code with the following,
    which draws on the background layer with index `0`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`drawBackground`函数中，我们将现有代码替换为以下代码，该代码在索引为`0`的背景层上绘制：
- en: '[PRE46]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we move to the `loadImages` function. Add the following code to the function.
    It draws the background once:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们转到`loadImages`函数。向函数中添加以下代码。它绘制一次背景：
- en: '[PRE47]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `drawGuide` function, replace `var ctx = untangleGame.ctx;` with the
    following code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`drawGuide`函数中，将`var ctx = untangleGame.ctx;`替换为以下代码：
- en: '[PRE48]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Actually, we fade out the guide layer in this function too. So we replace the
    entire `drawGuide` function with the following:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，我们也在这个函数中淡出指南层。因此，我们将整个`drawGuide`函数替换为以下内容：
- en: '[PRE49]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Inside the `guideNextFrame` function, we clear the guide layer and redraw it.
    Add the following code to the end of the function:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`guideNextFrame`函数内部，我们清除指南层并重新绘制它。向函数末尾添加以下代码：
- en: '[PRE50]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'During the circle dragging, we don''t want our progress text layer to block
    the game elements. So we will define an extra function that dims the opacity of
    the progress layer when there are any game circles overlapping the layer:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在圆形拖动过程中，我们不希望我们的进度文本层阻挡游戏元素。因此，我们将定义一个额外的函数，在有任何游戏圆形重叠层时降低进度层的透明度：
- en: '[PRE51]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We are done with the `untangle.drawing.js` file. Let''s switch back to the
    `untangle.js` file. In the `gameloop` function, we remove the calls to the `drawBackground`
    and `drawGuide` functions. Then, we call the `dimUILayerIfNeeded` function. We
    also clear the layer 2 game elements and layer 3 level progress in every game
    loop. Now the `gameloop` function becomes the following:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了`untangle.drawing.js`文件。让我们切换回`untangle.js`文件。在`gameloop`函数中，我们删除对`drawBackground`和`drawGuide`函数的调用。然后，我们调用`dimUILayerIfNeeded`函数。我们还在每个游戏循环中清除层2游戏元素和层3关卡进度。现在`gameloop`函数变为以下内容：
- en: '[PRE52]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, open the `untangle.input.js` file. We had mouse down, move, and up
    event listeners on the `#game` Canvas. Since the game Canvases are now overlapping,
    the mouse event listener we had in the `game` Canvas does not fire anymore. We
    can change the listener to listen to the events from its parent `#layers` DIV,
    which has the same position and dimension of the Canvas:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开`untangle.input.js`文件。我们曾在`#game` Canvas上设置了鼠标按下、移动和抬起事件监听器。由于游戏Canvas现在是重叠的，我们之前在`game`
    Canvas上的鼠标事件监听器不再触发。我们可以将监听器更改为监听其父`#layers` DIV的事件，该DIV具有与Canvas相同的定位和尺寸：
- en: '[PRE53]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Save all the files and check our code changes in the web browser. The game should
    be displayed as if we haven't changed anything. Try dragging the circle down close
    to the bottom edge of the blackboard. The level progress text should dim to a
    low opacity. When you finish the first level, the guideline animation will fade
    out gracefully. The following screenshot shows the level progress in half opacity:![Time
    for action – dividing the game into four layers](img/B04290_05_11.jpg)
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件，并在网页浏览器中检查我们的代码更改。游戏应该显示得好像我们没有做任何改变一样。尝试将圆圈拖动到黑板底部边缘附近。关卡进度文本应该变暗到低透明度。当你完成第一关时，指南动画将优雅地淡出。以下截图显示了半透明度的关卡进度：![行动时间
    – 将游戏分为四层](img/B04290_05_11.jpg)
- en: '*What just happened?*'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We divided our working game into four layers. There are quite a lot of changes
    in this section. You may try the working example at: [http://makzan.net/html5-games/untangle/](http://makzan.net/html5-games/untangle/).
    By observing the source code, you can view the uncompressed code example.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的工作游戏分为四层。在这一节中有相当多的变化。你可以尝试在：[http://makzan.net/html5-games/untangle/](http://makzan.net/html5-games/untangle/)上的工作示例。通过观察源代码，你可以查看未压缩的代码示例。
- en: There are four Canvases in total now. Each Canvas is in charge of one layer.
    The layers are divided into the background, game guideline, game itself, and the
    user interface showing the level progress.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在总共有四个Canvas。每个Canvas负责一个层。层被分为背景、游戏指南、游戏本身以及显示关卡进度的用户界面。
- en: By default, the Canvases, like other elements, are placed one after the other.
    In order to overlap all Canvases to construct the layer effect, we applied the
    `absolute` position to them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Canvas，就像其他元素一样，是依次放置的。为了重叠所有Canvas以构建层效果，我们应用了`absolute`定位。
- en: 'The following screenshots show the four layers in our game. By default, the
    DOM that was added later is on top of the one added before. Therefore, the `bg`
    Canvas is at the bottom and `ui` is on the top:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的游戏中的四个层。默认情况下，后来添加的DOM位于先添加的DOM之上。因此，`bg` Canvas位于底部，`ui` 位于顶部：
- en: '![What just happened?](img/B04290_05_12.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04290_05_12.jpg)'
- en: By using different layers, we can create specific logic for each layer. For
    example, the background in this game is static. We only draw it once. The guide
    layer is a 6-frames animation with 500 milliseconds for each frame. We redraw
    the guide layer in 500 milliseconds intervals. The game layer and UI layer are
    the core game logic, which we draw 30 times per second.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用不同的层，我们可以为每一层创建特定的逻辑。例如，这个游戏中的背景是静态的。我们只绘制一次。指南层是一个6帧动画，每帧500毫秒。我们在500毫秒的间隔中重新绘制指南层。游戏层和UI层是核心游戏逻辑，我们每秒绘制30次。
- en: Mixing a CSS technique with Canvas drawing
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将CSS技术与Canvas绘图混合
- en: We are creating a Canvas-based game but we are not restricted to use only a
    Canvas drawing API. Each layer is an individual Canvas layer. We can apply a CSS
    technique to any layer. The level progress information is now in another Canvas
    with the ID `ui`. In this example, we mixed the CSS technique we discussed in
    [Chapter 3](ch03.html "Chapter 3. Building a Card-matching Game in CSS3"), *Building
    a Card-matching Game in CSS3*.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个基于Canvas的游戏，但我们并不局限于仅使用Canvas绘图API。每个层都是一个独立的Canvas层。我们可以将CSS技术应用于任何层。现在，关卡进度信息在另一个具有ID
    `ui` 的Canvas中。在这个例子中，我们混合了我们在[第3章](ch03.html "第3章。使用CSS3构建匹配卡片游戏")中讨论的CSS技术，*使用CSS3构建匹配卡片游戏*。
- en: When we drag the circles around the Canvas, they may overlap the level information.
    When drawing the UI Canvas layer, we check whether any circle's coordinate is
    too low and is overlapping the text. We then fade the UI Canvas CSS opacity so
    it does not distract the player from the circles.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Canvas周围拖动圆圈时，它们可能会覆盖关卡信息。在绘制UI Canvas层时，我们检查是否有任何圆圈的坐标太低且与文本重叠。然后我们降低UI
    Canvas CSS的透明度，以免分散玩家对圆圈的注意力。
- en: 'We also fade out the guideline animation after the player levels up. This is
    done by fading out the whole `guide` Canvas with CSS transition easing to 0 opacity.
    Since the `guide` Canvas is only in charge of that animation, hiding that Canvas
    does not affect other elements:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家升级后，我们也淡出指南动画。这是通过使用CSS过渡渐变将整个`guide` Canvas的透明度淡出到0来完成的。由于`guide` Canvas只负责那个动画，隐藏该Canvas不会影响其他元素：
- en: '[PRE54]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Tip
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Clearing only the changed region to boost the canvas performance**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅清除更改区域以提升Canvas性能**'
- en: We can use the clear function to only clear part of the Canvas context. This
    will give the performance some boost because it avoids redrawing the entire Canvas
    context every time. This is achieved by marking the 'dirty' region of the context
    that has changed state since last drawn.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用清除函数来仅清除Canvas上下文的一部分。这将提高性能，因为它避免了每次都重绘整个Canvas上下文。这是通过标记自上次绘制以来状态已更改的上下文的'脏'区域来实现的。
- en: In the guide Canvas layer in our example, we may consider clearing only the
    region of the sprite sheet image drawing instead of the whole Canvas.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，在指南Canvas层中，我们可能考虑仅清除精灵表图像绘制的区域，而不是整个Canvas。
- en: We may not see significant differences in simple Canvas examples but it helps
    boost the performance when we have a complex Canvas game that includes many sprite
    image animations and complex shape drawings.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的Canvas示例中，我们可能看不到显著的区别，但当我们有一个包含许多精灵图像动画和复杂形状绘制的复杂Canvas游戏时，它有助于提高性能。
- en: Have a go hero
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: We fade out the guide when the players advance to level 2\. How about we fade
    out the guide animation once the player drags any circles? How can we do that?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家进入第2级时，我们淡出指南。那么，当玩家拖动任何圆圈时，我们是否应该淡出指南动画？我们该如何做到这一点？
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about drawing gradients, text, and images
    in a Canvas. Specifically, we built the Untangle game logic and used several advanced
    Canvas techniques, including sprite sheet animation using the clipping function
    when drawing images. We divided the game into several layers by stacking several
    `canvas` elements. This allows us to handle different parts of the game rendering
    in separated and specific logic. Finally, we mixed the CSS transition animation
    in a Canvas-based game.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在Canvas中绘制梯度、文本和图像。具体来说，我们构建了Untangle游戏逻辑，并使用了几个高级Canvas技术，包括在绘制图像时使用裁剪功能进行精灵表动画。我们通过堆叠几个`canvas`元素将游戏分为几个层级。这使我们能够分别和具体地处理游戏渲染的不同部分。最后，我们在基于Canvas的游戏中混合了CSS过渡动画。
- en: One thing we haven't mentioned in this book is the bitmap manipulation in Canvas.
    Canvas context is a bitmap data where we can apply an operation on each pixel.
    For instance, we may draw an image in the Canvas and apply Photoshop-like filters
    to the image. We will not cover this in the book because image manipulation is
    an advanced topic and the application may not relate to game development.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们没有提到的是Canvas中的位图操作。Canvas上下文是一个位图数据，我们可以对每个像素应用操作。例如，我们可以在Canvas中绘制一个图像，并应用类似Photoshop的滤镜到图像上。我们不会在书中涵盖这一点，因为图像操作是一个高级主题，其应用可能不与游戏开发相关。
- en: Now that you've learned about building games in Canvas and making animation
    for game objects, such as game character, we are ready to add audio components
    and sound effects to our games in the next chapter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了在Canvas中构建游戏以及为游戏对象（如游戏角色）制作动画，我们准备在下一章中为我们的游戏添加音频组件和音效。
- en: We will get back to Canvas-based games in [Chapter 9](ch09.html "Chapter 9. Building
    a Physics Car Game with Box2D and Canvas"), *Building a Physics Car Game with
    Box2D and Canvas*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](ch09.html "第9章。使用Box2D和Canvas构建物理赛车游戏")中回到基于Canvas的游戏，*使用Box2D和Canvas构建物理赛车游戏*。
