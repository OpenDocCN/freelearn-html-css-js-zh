- en: Chapter 5. CoffeeScript and Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。CoffeeScript和Node.js
- en: Ryan Dahl created Node.js in 2009\. His goal was to create a system with which
    one can write network server applications having high performance, using JavaScript.
    At that time, JavaScript was mostly run inside browsers, so a server-side framework
    needed some way to run JavaScript without it. Node uses Google's V8 JavaScript
    engine, originally written for the Chrome browser, but since it's a separate piece
    of software, it can run JavaScript code anywhere. Node.js lets you write JavaScript
    code that can be executed on the server. It can make full use of your operating
    system, databases, and other external network resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ryan Dahl于2009年创建了Node.js。他的目标是创建一个可以使用JavaScript编写高性能网络服务器应用程序的系统。当时，JavaScript主要在浏览器中运行，因此需要一种在没有浏览器的情况下运行JavaScript的服务器端框架。Node使用了Google的V8
    JavaScript引擎，最初是为Chrome浏览器编写的，但由于它是一个独立的软件，因此可以在任何地方运行JavaScript代码。Node.js允许您编写可以在服务器上执行的JavaScript代码。它可以充分利用您的操作系统、数据库和其他外部网络资源。
- en: Let's talk about some of the features of Node.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈Node.js的一些特性。
- en: Node is event-driven
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node是事件驱动的
- en: The Node.js framework only allows non-blocking, asynchronous I/O. This means
    that any I/O operation that is accessing an external resource, such as the operating
    system, a database, or a network resource must happen asynchronously. This works
    by using events, or callbacks that are fired once the operation succeeds or fails.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js框架只允许非阻塞的异步I/O。这意味着任何访问外部资源（如操作系统、数据库或网络资源）的I/O操作必须以异步方式进行。这是通过使用事件或回调来实现的，一旦操作成功或失败，就会触发这些事件或回调。
- en: The benefit of this is that your application becomes much more scalable, because
    requests don't have to wait around for slow I/O operations to finish and can instead
    handle more incoming requests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，您的应用程序变得更加可扩展，因为请求不必等待慢速I/O操作完成，而是可以处理更多的传入请求。
- en: Similar frameworks do exist in other languages, such as **Twisted** and **Tornado**
    in Python, and **EventMachine** in Ruby. A big problem with these frameworks is
    that all I/O libraries they use must also be non-blocking. Often, one can end
    up accidentally using code that blocks an I/O operation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言中也存在类似的框架，比如Python中的**Twisted**和**Tornado**，以及Ruby中的**EventMachine**。这些框架的一个大问题是，它们使用的所有I/O库也必须是非阻塞的。通常，人们可能会意外地使用阻塞I/O操作的代码。
- en: Node.js was built from the ground up with an event-driven philosophy and only
    allows non-blocking I/O, thus avoiding this problem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是从头开始以事件驱动的理念构建的，并且只允许非阻塞I/O，因此避免了这个问题。
- en: Node is fast and scalable
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node快速且可扩展
- en: The V8 JavaScript engine used by Node.js is highly optimized for performance,
    thus making Node.js applications very fast. The fact that Node is non-blocking
    will ensure that your applications will be able to handle many concurrent client
    requests without using a lot of system resources.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js使用的V8 JavaScript引擎经过高度优化，因此使Node.js应用程序非常快速。Node是非阻塞的事实将确保您的应用程序能够处理许多并发客户端请求，而不会使用大量系统资源。
- en: Node is not Rails
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node不是Rails
- en: Although Node and Rails are often used to build similar types of applications,
    they are in fact, quite different. Rails strives to be a full-stack solution to
    building web applications, whereas Node.js is more of a low-level system for writing
    any type of fast and scalable network application. It does not make a lot of assumptions
    on how your application should be structured at all, except for the fact that
    you'll use an event-based architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Node和Rails经常用于构建类似类型的应用程序，但它们实际上是非常不同的。Rails致力于成为构建Web应用程序的全栈解决方案，而Node.js更像是一种用于编写任何类型的快速和可扩展网络应用程序的低级系统。它对应用程序的结构几乎没有做出太多假设，除了您将使用基于事件的架构。
- en: Because of this, Node developers often choose from a variety of frameworks and
    modules that have been built on top of Node for writing web applications, such
    as Express or Flatiron.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Node开发人员通常可以从许多在Node之上构建的用于编写Web应用程序的框架和模块中进行选择，比如Express或Flatiron。
- en: Node and CoffeeScript
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node和CoffeeScript
- en: As we've seen before, CoffeeScript is available as an npm module. Therefore,
    writing Node.js applications with CoffeeScript couldn't be much easier. In fact,
    the `coffee` command that we discussed earlier will run `.coffee` scripts using
    Node by default. To get Node installed with CoffeeScript, see [Chapter 2](ch02.html
    "Chapter 2. Running CoffeeScript"), *Running CoffeeScript*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，CoffeeScript作为一个npm模块是可用的。因此，使用CoffeeScript编写Node.js应用程序变得非常容易。事实上，我们之前讨论过的`coffee`命令将默认使用Node运行`.coffee`脚本。要使用CoffeeScript安装Node，请参阅[第2章](ch02.html
    "第2章。运行CoffeeScript") *运行CoffeeScript*。
- en: '"Hello World" in Node'
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node中的“Hello World”
- en: 'Let''s write the simplest Node app we can using CoffeeScript. Create a file
    named `hello.coffee` and enter the following code in it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用CoffeeScript编写最简单的Node应用程序。创建一个名为`hello.coffee`的文件，并输入以下代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This uses the `http` module of Node.js, which provides capabilities for building
    an HTTP server. The `require('http')` function will return an instance of the
    `http` module, which exports a `createServer` function. This function takes a
    `requestListener` argument, which is a function that will respond to client requests.
    In this case, we respond with an HTTP status code `200` and end the response with
    `Hello World` as the request body. Finally, we call the `listen` method on the
    returned server to start it up. When this method is called, the server will listen
    for and handle requests until we stop it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了Node.js的`http`模块，该模块提供了构建HTTP服务器的功能。`require('http')`函数将返回`http`模块的一个实例，该实例导出了一个`createServer`函数。这个函数接受一个`requestListener`参数，这是一个响应客户端请求的函数。在这种情况下，我们以HTTP状态码`200`做出响应，并以`Hello
    World`作为请求体结束响应。最后，我们调用返回的服务器的`listen`方法来启动它。当调用这个方法时，服务器将监听并处理请求，直到我们停止它。
- en: 'We can run this file with the coffee command, as shown in the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用coffee命令运行这个文件，如下命令所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can test our server by browsing to `http://localhost:8080/`. We should see
    a simple page with only the text as **Hello World**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过浏览`http://localhost:8080/`来测试我们的服务器。我们应该看到一个只有**Hello World**文本的简单页面。
- en: Express
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express
- en: As you can see, Node out of the box is very low-level and bare-boned. Building
    web applications basically means writing a raw HTTP server. Luckily, a bunch of
    libraries has been developed over the last few years to help out with writing
    web applications on Node and to abstract away a lot of the low-level details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Node默认是非常低级和基本的。构建Web应用程序基本上意味着编写原始的HTTP服务器。幸运的是，在过去几年中已经开发了许多库来帮助在Node上编写Web应用程序，并抽象掉许多低级细节。
- en: Arguably, the most popular of these is **Express** ([http://expressjs.com/](http://expressjs.com/)).
    Similar to Rails, it has quite a lot of nice features that make it easier to perform
    common web application tasks, such as routing, rendering views, and hosting static
    resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，其中最受欢迎的是**Express**（[http://expressjs.com/](http://expressjs.com/)）。类似于Rails，它具有许多很好的功能，使得执行常见的Web应用程序任务更容易，比如路由、渲染视图和托管静态资源。
- en: In this chapter, we'll be writing a web application in Express using CoffeeScript.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用CoffeeScript在Express中编写Web应用程序。
- en: WebSocket
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket
- en: Since I would like to show off some of the scalability features of Node and
    the types of applications that it's normally used for, we'll be making use of
    another interesting modern web technology, known as **WebSocket**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我想展示一些Node的可伸缩性特性以及它通常用于的应用程序类型，我们将利用另一种有趣的现代网络技术，称为**WebSocket**。
- en: The WebSocket protocol is a standard for allowing raw, bi-directional, and full-duplex
    (simultaneous in both directions) TCP connections over the standard HTTP port
    **80**. This allows for a client and server to establish a long-running TCP connection
    with which the server can perform push operations, which has traditionally not
    been possible with HTTP. It is often used in applications where there needs to
    be lots of low-latency interaction between the client and server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议是允许在标准HTTP端口**80**上进行原始、双向和全双工（同时双向）TCP连接的标准。这允许客户端和服务器建立长时间运行的TCP连接，服务器可以执行推送操作，这在传统的HTTP中通常是不可能的。它经常用于需要在客户端和服务器之间进行大量低延迟交互的应用程序中。
- en: Jade
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jade
- en: Jade is a lightweight, markup templating language that lets you write elegant
    and short HTML in a syntax that closely resembles CoffeeScript. It uses quite
    a few features such as syntactical whitespace to reduce the number of keystrokes
    you need to write HTML documents. It is usually installed by default when you
    run Express, and we'll be using it in this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Jade是一种轻量级的标记模板语言，它让你以类似于CoffeeScript的语法编写优雅而简短的HTML。它使用了许多功能，比如语法空白，以减少你编写HTML文档所需的按键次数。通常在运行Express时默认安装，我们将在本书中使用它。
- en: Our application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的应用程序
- en: In this chapter, we're going to build a collaborative to-do list application.
    This means that you'll be able to share your to-do list with other people in real
    time. One or more people will be able to add, complete, or remove to-do list items
    at the same time. Changes to the to-do list will be automatically propagated to
    all users. This is the type of application that Node is perfect for.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个协作待办事项列表应用程序。这意味着你将能够实时与其他人分享你的待办事项列表。一个或多个人将能够同时添加、完成或删除待办事项列表项目。待办事项列表的更改将自动传播到所有用户。这是Node非常适合的应用类型。
- en: Our Node.js code will consist of two distinct parts, the normal web application
    that will serve static HTML, CSS, and JavaScript, and a WebSocket server that
    handles the real-time updating of all the to-do list clients. Together with this,
    we'll have a jQuery-driven client that will look very similar to our application
    in [Chapter 3](ch03.html "Chapter 3. CoffeeScript and jQuery"), *CoffeeScript
    and jQuery*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Node.js代码将包括两个不同的部分，一个是正常的Web应用程序，将提供静态HTML、CSS和JavaScript，另一个是处理实时更新所有待办事项列表客户端的WebSocket服务器。除此之外，我们还将有一个由jQuery驱动的客户端，看起来与我们在[第3章](ch03.html
    "第3章。CoffeeScript和jQuery")中的应用程序非常相似，*CoffeeScript和jQuery*。
- en: We'll use some of the assets (stylesheets and images) from our existing to-do
    list applications. We'll also re-use the client-side jQuery code from [Chapter
    3](ch03.html "Chapter 3. CoffeeScript and jQuery"), *CoffeeScript and jQuery*
    and tweak it to fit our application. If you weren't following along in the previous
    chapters, you should be able to just copy assets from the code for this chapter
    as needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用现有待办事项列表应用程序的一些资源（样式表和图像）。我们还将重用[第3章](ch03.html "第3章。CoffeeScript和jQuery")中的客户端jQuery代码，并对其进行调整以适应我们的应用程序。如果你之前没有跟着前几章的内容，你应该可以根据需要从本章的代码中复制资源。
- en: Let's get started
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始吧
- en: 'To get going, we''ll do the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将执行以下步骤：
- en: Create a folder for our application.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建一个文件夹。
- en: Specify our app dependencies using a `package.json` file.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`package.json`文件指定我们的应用程序依赖项。
- en: Install our dependencies.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装我们的依赖项。
- en: Create an `app.coffee` file.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`app.coffee`文件。
- en: Run our app for the first time.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次运行我们的应用程序。
- en: package.json
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: package.json
- en: 'Create a new folder named `todo`. Inside this folder, we''ll create a file
    with the name `package.json`. Add the following code to this file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`todo`的新文件夹。在这个文件夹中，我们将创建一个名为`package.json`的文件。将以下代码添加到这个文件中：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a simple JSON file that serves as an application manifest and is used
    to tell npm which dependencies you rely on in your application. Here, we're using
    Express as our web framework and Jade as our templating language. Since we're
    going to use WebSocket, we'll pull in `socket.io`. We can also make sure that
    CoffeeScript is installed by adding it to our file. Lastly, we'll use `connect-assets`,
    a module that manages client-side assets in much the same way as the Rails asset
    pipeline.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的JSON文件，用作应用程序清单，并用于告诉npm您的应用程序依赖哪些。在这里，我们将Express用作我们的Web框架，Jade用作我们的模板语言。由于我们将使用WebSocket，我们将引入`socket.io`。我们还可以通过将其添加到我们的文件中来确保CoffeeScript已安装。最后，我们将使用`connect-assets`，这是一个管理客户端资产的模块，其方式与Rails资产管道非常相似。
- en: When dealing with the Node.js framework, you'll notice that applications are
    often weaved together out of npm modules in this manner. A good place to look
    for npm modules is the Node toolbox site ([nodetoolbox.com](http://nodetoolbox.com)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Node.js框架时，您会注意到应用程序通常是以这种方式由npm模块编织在一起的。查找npm模块的好地方是Node工具箱网站（[nodetoolbox.com](http://nodetoolbox.com)）。
- en: Installing our modules
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装我们的模块
- en: 'To install the dependencies in our `package.json` file, navigate to the project
    folder on the command-line tool and run the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`package.json`文件中的依赖项，请在命令行工具上导航到项目文件夹并运行以下命令：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If all went well, then we should now have all our project dependencies installed.
    To verify this or just to see what npm did, you can run the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，那么我们现在应该已经安装了所有项目依赖项。要验证这一点，或者只是查看npm的操作，您可以运行以下命令：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will output a list of installed modules with their dependencies in a tree-like
    format.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以树状格式输出已安装模块及其依赖关系的列表。
- en: Creating our app
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: 'All we need to run our application is to create a main, entry point file, which
    is used to hook up our Express application and specify our routes. In the root
    folder, create a file named `app.coffee`, and add the following code to it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要运行我们的应用程序是创建一个主入口文件，用于连接我们的Express应用程序并指定我们的路由。在根文件夹中，创建一个名为`app.coffee`的文件，并将以下代码添加到其中：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This looks very similar to our "Hello World" example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们的“Hello World”示例非常相似。
- en: First, we load the Express module using the `require` function. Node modules
    are simple; each module corresponds to a single file. Each module can declare
    code, which will be exported when it is required. When you call `require`, and
    the module's name is not that of a native module or a file path, Node will automatically
    look for the file in the `node_modules` folder. This is of course where npm installs
    modules.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`require`函数加载Express模块。Node模块很简单；每个模块对应一个单独的文件。每个模块都可以声明代码，在需要时导出。当您调用`require`时，如果模块的名称不是原生模块或文件路径，Node将自动在`node_modules`文件夹中查找文件。当然，这就是npm安装模块的地方。
- en: On the next line, we create our Express app by calling the `express` function
    and assigning it to an `app` variable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，通过调用`express`函数并将其分配给`app`变量来创建我们的Express应用程序。
- en: We then create an index route for our application using the `get` method. We
    specify the path to be `'/'` and then pass in an anonymous function to handle
    the request. It takes two parameters, the `req` and `res` parameters. Right now,
    we just write `Hello Express` to the response and return.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`get`方法为我们的应用程序创建一个索引路由。我们指定路径为`'/'`，然后传入一个匿名函数来处理请求。它接受两个参数，`req`和`res`参数。现在，我们只需向响应中写入`Hello
    Express`并返回。
- en: We then start our app using the `listen` method and tell it to run on port `3000`.
    Lastly, we write to the standard output so that we'll know the app has started.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`listen`方法启动我们的应用程序，并告诉它在端口`3000`上运行。最后，我们将写入标准输出，以便我们知道应用程序已启动。
- en: As you can see, the Express magic comes in with setting up routes declaratively.
    With Express you can easily create routes by specifying an HTTP method, URL path,
    and a function to handle the request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Express的魔力在于声明性地设置路由。使用Express，您可以通过指定HTTP方法、URL路径和处理请求的函数轻松创建路由。
- en: Running our application
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的应用程序
- en: 'Let''s run our application to see if everything worked. Inside our app folder,
    type the following on the command-line tool:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的应用程序，看看是否一切正常。在我们的应用程序文件夹中，在命令行工具上键入以下内容：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should see the output as **Listening on port 3000**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到输出为**Listening on port 3000**。
- en: Point your browser to `http://localhost:3000/`. You should see the text **Hello
    Express**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将浏览器指向`http://localhost:3000/`。您应该会看到文本**Hello Express**。
- en: To stop the Node process on the command-line tool, just use *Ctrl* + *C*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在命令行工具上停止Node进程，只需使用*Ctrl* + *C*。
- en: Creating a view
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个视图
- en: Similar to other web frameworks such as Rails, Express has the concepts of views,
    which let you separate your UI from your application using separate files. Usually,
    these are written using a templating language such as Jade. Let's create a view
    for our root action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Web框架（如Rails）类似，Express具有视图的概念，它可以让您使用单独的文件将UI与应用程序分离开来。通常，这些是使用Jade等模板语言编写的。让我们为我们的根操作创建一个视图。
- en: 'To do this, we''ll need to:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要：
- en: Create a `views` folder and add a Jade view file.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`views`文件夹并添加一个Jade视图文件。
- en: Configure our Express application to be aware of a folder where the views will
    be stored, and which templating library we're using.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置我们的Express应用程序以了解存储视图的文件夹，并使用的模板库。
- en: Change our index route to render our view.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改我们的索引路由以呈现我们的视图。
- en: 'Let''s create a new folder in our project root called `views`. Inside this
    folder, we create a new file named `index.jade`. This is how it should look:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目根目录中创建一个名为`views`的新文件夹。在此文件夹中，我们创建一个名为`index.jade`的新文件。它应该如下所示：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, Jade offers a very clean and terse syntax for normal HTML. You
    don't have enclosing tags in angle brackets. Similar to CoffeeScript, it also
    uses indentation to delimit blocks, so that you don't have to enter closing tags.
    The line `p= message` creates a `<p>` tag whose contents will be evaluated to
    be the value of the `message` field, which should be passed into our view options.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Jade为普通HTML提供了非常干净简洁的语法。你不需要用尖括号来包围标签。与CoffeeScript类似，它还使用缩进来界定块，这样你就不必输入闭合标签。`p=
    message`这一行创建了一个`<p>`标签，其内容将被评估为`message`字段的值，这个值应该被传递到我们的视图选项中。
- en: 'In our `app.coffee` file, we''ll add the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`app.coffee`文件中，我们将添加以下代码：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we set the `views` folder using the `set` function and assigning the `'views'`
    key. We use the `path` module that we included at the top of the file to create
    and join our current folder name to the `views` subfolder. `__dirname` is a global
    variable that refers to the currently working folder. We also set the view engine
    to `'jade'`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`set`函数设置`views`文件夹，并分配`'views'`键。我们使用在文件顶部包含的`path`模块来创建和连接我们当前文件夹名到`views`子文件夹。`__dirname`是一个全局变量，指的是当前工作文件夹。我们还将视图引擎设置为`'jade'`。
- en: Next up, we change our `get '/'` route to render the index template and pass
    in a hash of options, containing the message. This is the value that then gets
    rendered in our view.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将改变我们的`get '/'`路由，渲染index模板并传递一个包含消息的哈希选项。这个值将在我们的视图中被渲染出来。
- en: Once we run our application again and refresh the page, we should now see that
    our page has been updated with the new text.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们再次运行我们的应用程序并刷新页面，我们应该能够看到我们的页面已经更新了新的文本。
- en: node-supervisor
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: node-supervisor
- en: By now, you might be wondering if you'll need to restart our Node application
    each time we make a change to our code. Ideally in development, we would like
    our code to be reloaded automatically each time we make a change, similar to how
    it works in Rails.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能会想知道每次更改代码时是否需要重新启动我们的Node应用程序。在开发中，我们希望我们的代码在每次更改时都能自动重新加载，类似于Rails的工作方式。
- en: 'Luckily, there is a neat, open source library that we can use that does exactly
    that: **node-supervisor** ([https://github.com/isaacs/node-supervisor](https://github.com/isaacs/node-supervisor)).
    We install it like any other npm module, we just make sure to pass the `-g` flag
    to install it globally, as shown in the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个整洁的开源库可以做到这一点：**node-supervisor**（[https://github.com/isaacs/node-supervisor](https://github.com/isaacs/node-supervisor)）。我们像安装其他npm模块一样安装它，只是要确保传递`-g`标志来全局安装它，如下面的命令所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the terminal, you should now be able to run the supervisor by using the
    following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，你现在应该能够通过以下命令运行监督者：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Keep this process running in a separate window. To see if this worked, let''s
    edit our message that gets sent to our view; the edited message is highlighted
    in the following code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的窗口中保持这个过程运行。为了查看这是否起作用，让我们编辑发送到我们视图的消息；在下面的代码片段中，高亮显示了编辑后的消息：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we now refresh our page, we'll see that it has been updated. From here on,
    we can make sure to keep the supervisor running and we shouldn't need to restart
    our Node process to make changes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在刷新页面，我们将看到它已经更新了。从现在开始，我们可以确保监督者在运行，并且我们不需要重新启动我们的Node进程来进行更改。
- en: The to-do list view
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项列表视图
- en: 'Now let''s expand our view to look like our real to-do application. Edit the
    `index.jade` file to look like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们扩展我们的视图，使其看起来像我们真正的待办事项应用程序。编辑`index.jade`文件如下所示：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is some new Jade syntax that we haven''t seen before. Tag IDs are denoted
    by the `#` symbol, so `header#header` becomes `<header id="header">`. Tag attributes
    are specified within brackets, like so: `tag(name="value")`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些我们以前没有见过的新的Jade语法。标签ID由`#`符号表示，所以`header#header`变成了`<header id="header">`。标签属性在括号内指定，就像这样：`tag(name="value")`。
- en: 'Since we''re not using the `message` variable in our template anymore, we''ll
    remove it from our `render` call in the `app.coffee` file, as shown in the following
    code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再在模板中使用`message`变量，我们将从`app.coffee`文件的`render`调用中删除它，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our page will now be updated, but it won't look too good. We'll use the same
    stylesheet that we used in the previous project to style our page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面现在将被更新，但看起来不太好。我们将使用在上一个项目中使用的相同样式表来为我们的页面设置样式。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Not working as expected?**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有按预期工作？**'
- en: Remember to keep an eye on the output of the supervisor process to see if you
    have any syntax errors in your CoffeeScript or Jade template, especially if you're
    not seeing the expected output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记得要留意监督者进程的输出，看看你的CoffeeScript或Jade模板中是否有语法错误，特别是如果你没有看到预期的输出。
- en: 'Before we use the stylesheet, we need to set up Express to serve static files
    for us. Modify the `app.coffee` file to look like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用样式表之前，我们需要设置Express为我们提供静态文件服务。修改`app.coffee`文件如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So what's happening in the previous code snippet? We've added support for serving
    static files in a single line, but how does this work? The answer lies in how
    Node uses middleware.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中发生了什么？我们添加了一行支持为静态文件提供服务，但这是如何工作的呢？答案在于Node如何使用中间件。
- en: Middleware
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: The Express framework is built on top of a lower-level framework called **Connect**
    ([http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)). The
    basic idea of Connect is to provide middleware for web requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Express框架是建立在一个名为**Connect**的低级框架之上的（[http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)）。Connect的基本思想是为Web请求提供中间件。
- en: Middleware can be chained together to produce a web application stack. Each
    piece of middleware is only concerned in providing a small set of functionality
    by modifying the output response or the control flow of the request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以链接在一起形成一个Web应用程序堆栈。每个中间件只关心通过修改输出响应或请求的控制流来提供一小部分功能。
- en: In our example, we tell our application to use the middleware created by the
    `express.static` function. This function will create a static file server for
    the provided file path.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们告诉我们的应用程序使用`express.static`函数创建的中间件。这个函数将为提供的文件路径创建一个静态文件服务器。
- en: Our stylesheet
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的样式表
- en: 'Create a folder named `public` with a subfolder named `css`. Save the stylesheet
    as `todo.css` in this folder. We still need to include the stylesheet in our `index`
    view. Add the following line—highlighted in the code snippet—to the `index.jade`
    file in the `views` folder:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`public`的文件夹，其中包含一个名为`css`的子文件夹。将样式表保存为此文件夹中的`todo.css`。我们仍然需要在我们的`index`视图中包含样式表。在`views`文件夹中的`index.jade`文件中添加以下行-在代码片段中突出显示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once we have linked to our stylesheet, we should be able to refresh our view.
    It should now look much nicer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们链接到我们的样式表，我们应该能够刷新我们的视图。现在它应该看起来更好。
- en: The client side
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: To make our to-do application work, we're going to copy the client-side jQuery
    code that we created in [Chapter 3](ch03.html "Chapter 3. CoffeeScript and jQuery"),
    *CoffeeScript and jQuery*. We're going to put it in a file named `todo.coffee`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的待办事项应用程序工作，我们将复制在[第3章](ch03.html "第3章。CoffeeScript和jQuery")中创建的客户端jQuery代码，*CoffeeScript和jQuery*。我们将把它放在一个名为`todo.coffee`的文件中。
- en: Our next decision is, where shall we put this file? How will we compile and
    use its output in our application?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的决定是，我们应该把这个文件放在哪里？我们如何编译和在我们的应用程序中使用它的输出？
- en: We could do the same thing as we did when we built our application in [Chapter
    3](ch03.html "Chapter 3. CoffeeScript and jQuery"), *CoffeeScript and jQuery*,
    that is, create a `src` folder containing the client-side offeeScript code, then
    compile it using the `coffee` command with the `--watch` flag. The outputted JavaScript
    could then go in our `public` folder where we can include it as normal. But this
    would mean we would have two separate background tasks running, the supervisor
    task for running our server and another for compiling our client-side code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做与我们在[第3章](ch03.html "第3章。CoffeeScript和jQuery")中构建应用程序时一样的事情，也就是创建一个包含客户端CoffeeScript代码的`src`文件夹，然后使用`coffee`命令和`--watch`标志进行编译。输出的JavaScript然后可以放在我们的`public`文件夹中，我们可以像平常一样包含它。但这意味着我们将有两个独立的后台任务运行，一个是运行我们的服务器的监督任务，另一个是编译我们的客户端代码的任务。
- en: Luckily there is a better way. You might recall that we had a reference to the
    `connect-assets` module in our `package.json` file. It provides us with an asset
    pipeline that is very similar to what you get in Rails. It will take care of compilation
    and dependency management transparently.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是有更好的方法。您可能还记得我们在`package.json`文件中有一个对`connect-assets`模块的引用。它为我们提供了一个类似于Rails的资产管道。它将透明地处理编译和依赖管理。
- en: 'We''ll need to use the middleware in our `app.coffee` file, as highlighted
    in the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的`app.coffee`文件中使用中间件，如下面的代码片段中所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `connect-assets` module will, by default, use the `assets` folder to manage
    and serve assets from. Let''s create a folder named `assets/js` inside our root
    folder. We''ll create a new file in this folder named `todo.coffee`, containing
    the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect-assets`模块将默认使用`assets`文件夹来管理和提供资产。让我们在我们的根文件夹内创建一个名为`assets/js`的文件夹。我们将在这个文件夹中创建一个名为`todo.coffee`的新文件，其中包含以下代码：'
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you were following along in [Chapter 3](ch03.html "Chapter 3. CoffeeScript
    and jQuery"), *CoffeeScript and jQuery*, then this code should be familiar. It's
    our complete, client-side application that displays to-do items and creates, updates,
    and destroys items in `localStorage`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在[第3章](ch03.html "第3章。CoffeeScript和jQuery")中跟着做，*CoffeeScript和jQuery*，那么这段代码应该很熟悉。这是我们完整的客户端应用程序，显示待办事项并在`localStorage`中创建、更新和销毁项目。
- en: To use this file in our HTML we still need to include a `script` tag. Since
    we're using jQuery, we'll also need to include the library in our HTML.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的HTML中使用这个文件，我们仍然需要包含一个`script`标签。因为我们使用了jQuery，我们还需要在我们的HTML中包含这个库。
- en: 'Add the following code to the bottom of the `index.jade` file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.jade`文件的底部添加以下代码：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we include a link to jQuery using the Google CDN. We then use
    the `js` helper function, which is provided by `connect-assets`, to create a `script`
    tag that points to our compiled `todo.js` file (the `connect-assets` module will
    have compiled our CoffeeScript transparently). The `!=` notation is Jade's syntax
    for running a JavaScript function along with its result.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用Google CDN包含了一个指向jQuery的链接。然后我们使用`connect-assets`提供的`js`辅助函数创建一个指向我们编译后的`todo.js`文件的`script`标签（`connect-assets`模块会透明地编译我们的CoffeeScript）。`!=`符号是Jade语法中用来运行JavaScript函数及其结果的表示方式。
- en: If all went well, we should be able to refresh the page and have a working,
    client-side page for our app. Try adding new items, marking items as complete,
    deleting items, and clearing completed items.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该能够刷新页面并拥有一个工作的客户端页面应用程序。尝试添加新项目，标记项目为完成，删除项目和清除已完成的项目。
- en: Adding collaboration
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加协作
- en: Now we're ready to add collaboration to our to-do list application. We need
    to create a page where multiple users can connect to the same to-do list and can
    edit it simultaneously, seeing the results in real time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备为我们的待办事项列表应用程序添加协作。我们需要创建一个页面，多个用户可以连接到同一个待办事项列表，并可以同时编辑它，实时看到结果。
- en: We would like to support the idea of named lists, which you can join with others
    to collaborate on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望支持命名列表的概念，您可以加入其他人一起协作。
- en: Before we dive into the functionality, let's tweak our UI a bit to support all
    of this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入功能之前，让我们稍微调整一下我们的UI，以支持所有这些。
- en: Creating the collaboration UI
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建协作UI
- en: First, we'll add an input field to specify a list name and a button to join
    the specified list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个输入字段来指定一个列表名称和一个按钮来加入指定的列表。
- en: 'Make the following changes (highlighted in the code snippet) to our `index.jade`
    file, which will add an `input` element and a `button` element to specify our
    list name and join it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的`index.jade`文件进行以下更改（在代码片段中突出显示），将添加一个`input`元素和一个`button`元素来指定我们的列表名称并加入它：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our page should now look like the page displayed in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面现在应该看起来像以下截图中显示的页面：
- en: '![Creating the collaboration UI](img/9588_05_01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建协作UI](img/9588_05_01.jpg)'
- en: WebSocket on the client
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端上的WebSocket
- en: Now let's add an event handler to connect to a room when the user clicks the
    **Join** button.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为用户点击**加入**按钮时连接到一个房间添加一个事件处理程序。
- en: 'In our `todo.coffee` file, we''ll add the following code to our `cacheElements`
    and `bindEvents` functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`todo.coffee`文件中，我们将在`cacheElements`和`bindEvents`函数中添加以下代码：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We grab the `join-list-name` input and `join` button elements and store them
    in two instance variables. We then set up the `click` handler on the `@$join`
    button to call a new function called `joinList` . Let''s go ahead and define this
    function now. Add it to the end of the class after the `bindEvents` function is
    defined:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取`join-list-name`输入和`join`按钮元素，并将它们存储在两个实例变量中。然后我们在`@$join`按钮上设置`click`处理程序，以调用一个名为`joinList`的新函数。让我们继续定义这个函数。在定义`bindEvents`函数之后，将其添加到类的末尾：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is where we start to use Socket.IO. The Socket.IO library comes in two
    parts: the client-side library for opening a WebSocket connection, making requests,
    and receiving responses, as well as the server-side node module for handling the
    requests.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始使用Socket.IO的地方。Socket.IO库分为两部分：用于打开WebSocket连接、发出请求和接收响应的客户端库，以及用于处理请求的服务器端节点模块。
- en: In the preceding code, the `joinList` function opens a new socket using the
    `io.connect` function and passing in the URL. It then uses the `on` function to
    pass a handler function that will run after the WebSocket connection has been
    made.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`joinList`函数使用`io.connect`函数打开一个新的套接字，并传入URL。然后它使用`on`函数传递一个处理程序函数，在WebSocket连接建立后运行。
- en: The successful connection handler function will in turn use the `socket.emit`
    function, which allows us to send a custom message to the server using `joinList`
    as the identifier. We pass the value of the `@joinListName` input as its value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 成功连接处理程序函数将反过来使用`socket.emit`函数，这允许我们使用`joinList`作为标识符向服务器发送自定义消息。我们将`@joinListName`输入的值作为其值传递。
- en: 'Before we can start implementing the server-side code, we still need to include
    a `script` tag to use the `socket.io` client library. Add the following highlighted
    `script` tag at the bottom of the `index.jade` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现服务器端代码之前，我们仍然需要包含一个`script`标签来使用`socket.io`客户端库。在`index.jade`文件的底部添加以下突出显示的`script`标签：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You might be wondering where this file comes from. Next, we'll set up the Socket.IO
    middleware in our `app.coffee` file. This will host the client-side library for
    us.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道这个文件是从哪里来的。接下来，我们将在`app.coffee`文件中设置Socket.IO中间件。这将为我们托管客户端库。
- en: WebSocket on the server
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端的WebSocket
- en: We have our client-side code ready to make WebSocket requests; now we can move
    on to our Node backend. First, we'll need to set up our Socket.IO middleware.
    There is a small caveat to this, in that we cannot use Socket.IO as a middleware
    of the Express application directly, since Socket.IO expects a Node.js HTTP server
    and has no direct support for Express. Instead, we'll create a web server using
    the built-in Node.js HTTP module, passing our Express application as `requestListener`
    . We can then use the `listen` function in Socket.IO to connect to the server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端代码已准备好发出WebSocket请求；现在我们可以转向我们的Node后端。首先，我们需要设置Socket.IO中间件。这有一个小问题，即我们不能直接将Socket.IO用作Express应用程序的中间件，因为Socket.IO需要一个Node.js
    HTTP服务器，并且不直接支持Express。相反，我们将使用内置的Node.js HTTP模块创建一个Web服务器，将我们的Express应用程序作为`requestListener`传递。然后我们可以使用Socket.IO的`listen`函数连接到服务器。
- en: 'The following is how the code looks in our `app.coffee` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`app.coffee`文件中代码的样子：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `io.sockets.on 'connection'` function handles the event when a client connects.
    Here, we log to the console that we're connected to and then set up the `joinList`
    message handler. Right now, we'll just log the value that we receive from the
    client to the console.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.sockets.on ''connection''`函数处理客户端连接时的事件。在这里，我们记录到控制台我们已连接，并设置`joinList`消息处理程序。现在，我们将只是将从客户端接收到的值记录到控制台。'
- en: 'We should now be able to test connecting to a list. Refresh our to-do list
    home page and enter a list name to join. After you clicked the **Join** button,
    head over to our background supervisor task. You should see something similar
    to the following message:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够测试连接到一个列表。刷新我们的待办事项列表主页并输入要加入的列表名称。点击**加入**按钮后，转到我们的后台监督任务。您应该会看到类似以下消息的内容：
- en: '**connected**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接**'
- en: '**Joining list Michael''s List**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**加入列表迈克尔的列表**'
- en: It worked! We've successfully created a bi-directional WebSocket connection.
    We still haven't really joined a list so far, so let's go ahead and do that now.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我们已成功创建了双向WebSocket连接。到目前为止，我们还没有真正加入任何列表，所以让我们继续做这件事。
- en: Joining a list
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入列表
- en: To join a list, we'll use a feature of Socket.IO called **rooms** . It allows
    the Socket.IO server to segment its clients and emit messages to subsets of all
    the connected clients. On the server, we'll keep track of the to-do lists of each
    room and then tell the client to sync its local list when connected.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入列表，我们将使用Socket.IO的一个特性叫做**rooms**。它允许Socket.IO服务器对其客户端进行分段，并向所有连接的客户端的子集发出消息。在服务器端，我们将跟踪每个房间的待办事项列表，然后告诉客户端在连接时同步其本地列表。
- en: 'We''ll update the `app.coffee` file with the highlighted code shown in the
    following code snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`app.coffee`文件中添加以下突出显示的代码：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We initialize the `@todos` instance variable to be an empty hash. It will hold
    the to-do lists for each room, using the list name as a key. In the `joinList`
    handler function, we set the `list` property of the `socket` variable to equal
    the list name that the client passed in.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`@todos`实例变量初始化为空哈希。它将使用列表名称作为键，保存每个房间的待办事项列表。在`joinList`处理程序函数中，我们将`socket`变量的`list`属性设置为客户端传入的列表名称。
- en: We then use the `socket.join` function that will join our list to a room with
    that name. If the room doesn't exist yet, it will be created. We then assign an
    empty array value to the item in `@todos` with the key equal to `list`. The `?=`
    operator will only assign the value on the right-hand side to the object on the
    left-hand side if it's `null`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`socket.join`函数将我们的列表加入到具有该名称的房间中。如果房间尚不存在，它将被创建。然后，我们将空数组值分配给`@todos`中键等于`list`的项目。`?=`运算符只会在右侧的值为`null`时将右侧的值分配给左侧的对象。
- en: Lastly, we send a message to the client using the `socket.emit` function. The
    `syncItems` identifier will tell it to sync its local data with the to-do list
    items that we're passing it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`socket.emit`函数向客户端发送消息。`syncItems`标识符将告诉它将其本地数据与我们传递给它的待办事项列表同步。
- en: 'To handle the `syncItems` message, we''ll need to update the `todo.coffee`
    file with the following highlighted code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理`syncItems`消息，我们需要使用以下突出显示的代码更新`todo.coffee`文件：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After joining a list, we set up our client connection to handle the `syncItems`
    message. We expect to receive all the to-do items for the list that we have just
    joined. The `syncItems` function will clear all the current items in `localStorage`,
    add all the new items, and then display them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 加入列表后，我们设置客户端连接以处理`syncItems`消息。我们期望接收刚刚加入的列表的所有待办事项。`syncItems`函数将清除`localStorage`中的所有当前项目，添加所有新项目，然后显示它们。
- en: The UI
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI
- en: 'Lastly, let''s update our UI so that the user will know when they''ve joined
    a list and let them leave it. We''ll modify our `#footer div` tag as follows in
    our `index.jade` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新我们的UI，以便用户知道他们何时加入了列表，并让他们离开。我们将在我们的`index.jade`文件中修改我们的`#footer div`标记如下：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the previous markup, we've added two new sections to our `footer div` tag.
    Each section will either be hidden or visible depending on which state we are
    in, `connected` or `disconnected` from a list. The `connect` section is the same
    as before. The `disconnect` section will display which list you are currently
    connected to and has a **Leave** button.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的标记中，我们已经在`footer div`标记中添加了两个新部分。每个部分将根据我们所处的状态（`connected`或`disconnected`）而隐藏或显示。`connect`部分与以前相同。`disconnect`部分将显示您当前连接到的列表，并有一个**Leave**按钮。
- en: Now we'll add code to our `todo.coffee` file to update the UI when a list is
    joined.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在`todo.coffee`文件中添加代码，以便在加入列表时更新UI。
- en: 'First, we''ll cache the new elements in our `cacheElements` function, as highlighted
    in the following code snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在我们的`cacheElements`函数中缓存新元素，如下面的代码段所示：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we''ll change the UI to display that we''re in a `connected` state when
    `syncItems` have been called (which gets fired by the server after successfully
    joining a list). We use the `@currentList` function, which we''ll set in the `joinList`
    function; add the code highlighted in the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改UI以显示在调用`syncItems`（在成功加入列表后由服务器触发）时我们处于`connected`状态。我们使用`@currentList`函数，我们将在`joinList`函数中设置；添加以下代码段中突出显示的代码：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `displayConnected` function will just hide the `connect` section and show
    the `disconnect` section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayConnected`函数将隐藏`connect`部分并显示`disconnect`部分。'
- en: Leaving a list
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离开列表
- en: Leaving a list should be quite easy. We disconnect the current socket connection
    and then update the UI.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 离开列表应该很容易。我们断开当前的socket连接，然后更新UI。
- en: 'To handle the `disconnect` action when a button is clicked, we add a handler
    in our `bindEvents` function, as shown in the following code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击按钮时处理`disconnect`操作，我们在我们的`bindEvents`函数中添加一个处理程序，如下面的代码段所示：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, the handler we''ve added will just call a `leaveList` function.
    We still need to implement it. Add the following two functions to the end of the
    class after the last function defined in our `TodoApp` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们添加的处理程序将只调用一个`leaveList`函数。我们仍然需要实现它。在我们的`TodoApp`类中最后一个函数之后，添加以下两个函数：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing it all
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试全部
- en: 'Now let''s test our list joining and leaving code. To see it all in action,
    follow these steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试我们的列表加入和离开代码。要看到所有操作，请按照以下步骤进行：
- en: Open `http://localhost:3000/` in your browser.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:3000/`。
- en: In the browser window, type a list name and hit **Join List**. The UI should
    update as expected.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，输入一个列表名称，然后点击**Join List**。UI应该如预期般更新。
- en: Once you've joined a list, add a few to-do items.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加入列表后，添加一些待办事项。
- en: Now open the site again, this time using a second browser. Since `localStorage`
    is unique to a browser, we do this to have a clean list of to-do items.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次打开网站，这次使用第二个浏览器。由于`localStorage`是特定于浏览器的，我们这样做是为了拥有一个干净的待办事项列表。
- en: Once again, type the same list name as you did in the other browser and hit
    **Join List**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在另一个浏览器中输入与之前相同的列表名称，然后点击**Join List**。
- en: As the list is synced, you should now see the list items you've added in before
    showing up.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当列表同步时，您现在应该看到之前添加的列表项显示出来。
- en: Lastly, disconnect from a list using the **Leave** button.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用**Leave**按钮从列表中断开。
- en: '![Testing it all](img/9588_05_02.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![测试全部](img/9588_05_02.jpg)'
- en: Two lists synced from different browsers
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同浏览器同步的两个列表
- en: This is great! We can now see the power of WebSockets in action. Our client
    is notified when it should sync items without having to poll the server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在可以看到WebSockets的威力。我们的客户端在无需轮询服务器的情况下，会在应该同步项目时收到通知。
- en: However, once we're connected to the list, we still cannot add new items to
    have them show up in all the other clients in the room. Let's implement that.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们连接到列表，我们仍然无法添加新项目以使其显示在房间中的所有其他客户端中。让我们实现这一点。
- en: Adding to-do items to a shared list
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向共享列表添加待办事项
- en: 'First, we''ll handle adding new items on the server. The best place to handle
    this would be in the existing `create` function for creating to-do items. Instead
    of just adding them to `localStorage`, we''ll also emit a message to the server
    telling it that a new to-do item has been created, and pass it as a parameter.
    Modify the `create` function to look like the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在服务器上处理添加新项目。处理这个的最佳位置是现有的用于创建待办事项的`create`函数。我们不仅将它们添加到`localStorage`中，还会向服务器发出消息，告诉它已创建新的待办事项，并将其作为参数传递。修改`create`函数如下所示：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We need to handle the `newItem` message on the server. We'll set up the code
    to do so when a client joins a list, in `app.coffee`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在服务器上处理`newItem`消息。当客户端加入列表时，我们将设置代码来处理这个消息，在`app.coffee`中。
- en: 'Let''s modify the `joinList` event handler that we added before; add the highlighted
    code in the following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前添加的`joinList`事件处理程序；在以下代码片段中添加突出显示的代码：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code snippet, we set up yet another `socket` event when a user joins
    a list. In this case, it's for the `newItem` event. We add the new to-do item
    to our `@todos` array using the `push` function. Then we emit a new `itemAdded`
    message to all the clients in the current list.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，当用户加入列表时，我们设置了另一个`socket`事件。在这种情况下，是为了`newItem`事件。我们使用`push`函数将新的待办事项添加到我们的`@todos`数组中。然后我们向当前列表中的所有客户端发出一个新的`itemAdded`消息。
- en: What will happen with this `itemAdded` message? You guessed it; it will get
    handled in the client again. This kind of back and forth messaging is very common
    in WebSocket applications and does take some getting used to. Don't fret though;
    it gets easier once you get the hang of it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`itemAdded`消息会发生什么？你猜对了；它将再次在客户端处理。这种来回的消息传递在WebSocket应用程序中非常常见，需要一些时间来适应。不过不要担心；一旦掌握了，就会变得更容易。
- en: 'Meanwhile let''s handle the `itemAdded` event on the client. We also set up
    this code in our `joinList` method by adding the highlighted code in the following
    code snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，让我们在客户端处理`itemAdded`事件。我们还通过在我们的`joinList`方法中添加以下代码来设置这个代码片段：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We handle the `itemAdded` event by calling `localStorage.setObject` with the
    item ID and value. This will either create a new to-do item if it's not present
    in `localStorage`, or it will update the existing value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`localStorage.setObject`处理`itemAdded`事件，其中包括项目ID和值。这将在`localStorage`中创建一个新的待办事项，如果它在`localStorage`中不存在，或者更新现有值。
- en: 'And that''s it! We should now be able to add items to all the clients in the
    list. To test it, we''ll follow similar steps to what we did earlier:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们应该能够向列表中的所有客户端添加项目。要测试它，我们将按照之前的类似步骤进行：
- en: Open `http://localhost:3000/` in your browser.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:3000/`。
- en: In the browser window, type a list name and hit **Join List**. The UI should
    update as expected.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，输入一个列表名称，然后点击**加入列表**。UI应该如预期般更新。
- en: Now open the site again, this time using a second browser.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次打开网站，这次使用第二个浏览器。
- en: Once again, type the same list name as you did in the other browser and hit
    **Join List**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次输入与另一个浏览器中相同的列表名称，然后点击**加入列表**。
- en: Add new to-do items in either browser. You'll see the to-do items appear in
    the other browser immediately.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任一浏览器中添加新的待办事项。你会立即看到待办事项出现在另一个浏览器中。
- en: Wow! Isn't this impressive?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这不是很令人印象深刻吗？
- en: Removing to-do items from a shared list
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从共享列表中移除待办事项
- en: 'To remove to-do items from a shared list, we''ll follow a similar pattern to
    adding items. In the `destroy` function in `todo.coffee`, we''ll emit a `removeItem`
    message to our socket to let the server know that a item should be removed, as
    shown in the following code snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要从共享列表中移除待办事项，我们将遵循与添加项目类似的模式。在`todo.coffee`的`destroy`函数中，我们将向我们的socket发出一个`removeItem`消息，让服务器知道应该移除一个项目，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once again, we set up the server-side code to handle this message by removing
    the item from the shared list in memory, and then notify all clients connected
    to the list that the item has been removed:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们设置了服务器端代码来处理这个消息，通过从内存中的共享列表中移除项目，然后通知连接到列表的所有客户端项目已被移除：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `removeItem` socket event handler gets the ID of the to-do item to remove
    the task passed into it. It removes the to-do item from the list by assigning
    the current value of the shared list to a new value that we create using JavaScript's
    array `filter` function. This will select all the items that don't have the passed
    ID. It then calls `emit` on all the client socket connections in the shared list
    with the `itemRemoved` message.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeItem` socket事件处理程序获取要移除的任务的ID。它通过使用JavaScript的数组`filter`函数将共享列表的当前值分配给我们创建的新值来从列表中移除待办事项。这将选择所有不具有传递ID的项目。然后，它通过共享列表中的所有客户端socket连接调用`emit`，发送`itemRemoved`消息。'
- en: 'Lastly, we''ll need to handle the `itemRemoved` message in our client. Similar
    to when we added items, we''ll set this up in the `joinList` function in `todo.coffee`,
    as shown in the following code snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在客户端处理`itemRemoved`消息。与添加项目时类似，我们将在`todo.coffee`的`joinList`函数中设置这个消息，如下面的代码片段所示：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We remove the item from `localStorage` and update the UI.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`localStorage`中移除项目并更新UI。
- en: 'To test removing items, follow these steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试移除项目，请按照以下步骤操作：
- en: Open `http://localhost:3000/` in your browser.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:3000/`。
- en: In the browser window, type a list name and hit **Join List**. The UI should
    update as expected.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，输入一个列表名称，然后点击**加入列表**。UI应该如预期般更新。
- en: Once you've connected to the shared list, add a few to-do items.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦连接到共享列表，添加一些待办事项。
- en: Now open the site again, this time using a second browser.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次打开网站，这次使用第二个浏览器。
- en: Once again, type the same list name as you did in the other browser and hit
    **Join List**. Your to-do list will be synced with the shared list and will contain
    the items that you have added in the other browser.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次输入与另一个浏览器中相同的列表名称，然后点击**加入列表**。您的待办事项列表将与共享列表同步，并包含您在另一个浏览器中添加的项目。
- en: Click the remove icon to delete to-do items in either browser. You'll see the
    deleted to-do items disappear in the other browser immediately.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击删除图标以删除浏览器中的待办事项。您将立即看到另一个浏览器中已删除的待办事项消失。
- en: Now, it's your turn
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在轮到你了
- en: As a final exercise to you, I will ask you to make the **Clear completed** button
    work. As a hint, you should be able to use the existing `destroyItem` method functionality.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对您的最后一项练习，我将要求您使“清除已完成”按钮起作用。作为提示，您应该能够使用现有的`destroyItem`方法功能。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we completed our tour of the CoffeeScript ecosystem by exploring
    Node.js as a fast, event-driven platform that lets you use JavaScript or CoffeeScript
    to write server applications. I hope that you have been given a glimpse of the
    joy of being able to write web applications using CoffeeScript on the server as
    well as in the browser at the same time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过探索Node.js作为一个快速、事件驱动的平台，让您可以使用JavaScript或CoffeeScript来编写服务器应用程序，完成了对CoffeeScript生态系统的巡回。我希望您已经对能够同时在服务器和浏览器上使用CoffeeScript编写Web应用程序的乐趣有所了解。
- en: We also spent some time with some of the wonderful open source libraries and
    frameworks that have been written for Node.js, like expressjs, connect, and Socket.IO
    and have seen how we can successfully use npm to manage dependencies and modules
    in our applications.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还花了一些时间使用一些为Node.js编写的精彩开源库和框架，比如expressjs、connect和Socket.IO，并看到了我们如何成功地使用npm来管理应用程序中的依赖项和模块。
- en: Our sample application was exactly the kind of thing that you would use Node.js
    for, and we saw how its event-driven model lends itself to writing applications
    where there are lots of constant interactions between the client and server.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序恰好是您可以使用Node.js的类型，我们看到它的事件驱动模型适用于编写客户端和服务器之间有大量常量交互的应用程序。
- en: Now that we've come to an end to our journey, I hope to have instilled in you
    the eagerness and skills to go out and use CoffeeScript to change the world. We've
    spent some time exploring not just the language but also the wonderful tools,
    libraries, and frameworks that enable us to develop powerful applications more
    rapidly using less code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的旅程已经结束，我希望已经在您心中灌输了渴望和技能，让您走出去使用CoffeeScript改变世界。我们花了一些时间不仅探索语言，还有让我们能够更快速地开发强大应用程序的精彩工具、库和框架。
- en: The future of CoffeeScript and the JavaScript ecosystem is bright, and hopefully
    you'll be a part of it!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript和JavaScript生态系统的未来是光明的，希望您能成为其中的一部分！
