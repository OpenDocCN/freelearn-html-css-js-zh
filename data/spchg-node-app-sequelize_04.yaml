- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Associating Models
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型关联
- en: Other than using validations to ensure consistency within our database, we can
    also create associations between two tables to ensure symbiotic relationships
    are maintained and updated. Databases maintain these relationships by creating
    **foreign key references** that hold metadata as to which table and column the
    foreign key is associated with. This metadata is what maintains integrity for
    the database. If we were to update a foreign key’s value without a proper reference,
    we would have to perform a separate query to update all of the rows that contained
    a reference to the foreign key to its new value.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用验证来确保数据库内部的一致性之外，我们还可以在两个表之间创建关联，以确保共生关系得到维护和更新。数据库通过创建**外键引用**来维护这些关系，这些引用包含有关外键关联的表和列的元数据。这些元数据维护数据库的完整性。如果我们不进行适当的引用更新外键的值，我们就必须执行一个单独的查询来更新所有引用外键的新值的行。
- en: 'For instance, we have three tables: `customers`, `products`, and `receipts`.
    The `receipts` table would have two columns (in addition to others) with each
    referencing a column on the `customers` and `products` table, respectively. If
    we wanted to update a product’s identification column, we would have to just modify
    the applicable product’s identification value. Then, the rows referencing the
    product within `receipts` would update automatically. Without a foreign reference,
    we would have to explicitly update the `receipts` table after updating the product’s
    identification.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有三张表：`customers`、`products`和`receipts`。`receipts`表将有两个列（除了其他列之外），分别引用`customers`和`products`表上的列。如果我们想更新产品的标识列，我们只需修改相关产品的标识值。然后，引用`receipts`表中产品的行将自动更新。如果没有外键引用，我们必须在更新产品的标识后显式更新`receipts`表。
- en: Note
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Traditionally, foreign keys would reference a primary key column or some form
    of identification column, but you are not limited to just those columns.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，外键会引用主键列或某种形式的标识列，但你并不局限于这些列。
- en: Relations between models can be managed by Sequelize automatically, or in a
    configurable way, for adopting pre-existing databases. Mapping relations between
    models can help ORMs form efficient queries depending on the environment by **eager
    loading** or **lazy loading**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 模型之间的关系可以通过 Sequelize 自动管理，或者以可配置的方式管理，以采用现有的数据库。映射模型之间的关系可以帮助 ORM 根据环境通过**预加载**或**延迟加载**形成高效的查询。
- en: 'This chapter will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Association methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联方法
- en: Relationship patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系模式
- en: Querying associations with eager loading and lazy loading
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预加载和延迟加载查询关联
- en: Using advanced association options
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级关联选项
- en: Applying associations to Avalon Airlines
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将关联应用于 Avalon Airlines
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter at [https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch4](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch4)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码文件：[https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch4](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch4)
- en: Association methods
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联方法
- en: 'There are a few options for creating relational mappings with ORMs. Defining
    the relations through an ORM can help build your database with the proper attributes
    and columns automatically, manage associated validations (for example, checking
    to see whether there is strictly only one related record), and perform optimization
    patterns on queries when fetching or inserting data. Sequelize offers support
    for four association patterns:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ORM 中创建关系映射有几个选项。通过 ORM 定义关系可以帮助自动构建具有正确属性和列的数据库，管理关联验证（例如，检查是否严格只有一个相关记录），并在检索或插入数据时执行查询优化模式。Sequelize
    支持四种关联模式：
- en: '**HasOne** – A one-to-one association where the *foreign key references the
    child* model. The attribute is defined on the parent model.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HasOne** – 一种一对一关联，其中*外键引用子*模型。该属性在父模型中定义。'
- en: '**BelongsTo** – A one-to-one association where the *foreign key references
    the parent* model. The attribute is defined on the child model.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BelongsTo** – 一种一对一关联，其中*外键引用父*模型。该属性在子模型中定义。'
- en: '**HasMany** – A one-to-many association where the *foreign key references the
    parent* model. The attribute is defined on the child model.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HasMany** – 一种一对一关联，其中*外键引用父*模型。该属性在子模型中定义。'
- en: '**BelongsToMany** – A many-to-many association where a separate model (called
    a *junction table*) will store the references of the associated models.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BelongsToMany** – 一种多对多关联，其中将使用单独的模型（称为 *连接表*）存储关联模型的引用。'
- en: Sequelize will follow a pattern for creating methods on models with associations.
    Depending on the relationship, there can be `get`, `set`, `add`, `create`, `remove`,
    and `count` as the prefix for the method’s name following with the association’s
    name (singular or pluralized wherever applicable).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 将遵循在具有关联的模型上创建方法的模式。根据关系，方法名称前缀可以是 `get`、`set`、`add`、`create`、`remove`
    和 `count`，后面跟着关联的名称（在适用的情况下可以是单数或复数形式）。
- en: In this section, we will go over the list of associations with their corresponding
    methods. Once we have gone through the association overview, then we can begin
    with the patterns for the relationships overview. Throughout this section, we
    will be using the concept of actors and plays/movies/jobs to help us grasp the
    fundamentals of associative properties and behavior on models. These examples
    are for illustrative purposes only and should not be included within our project’s
    code base.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍关联及其对应方法的列表。一旦我们完成了关联概述，我们就可以开始关系概述的模式。在本节中，我们将使用演员和戏剧/电影/职位的概念来帮助我们掌握模型关联属性和行为的基本原理。这些示例仅用于说明目的，不应包含在我们的项目代码库中。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can add a `where` clause statement (along with other finder parameters)
    within the `get` association methods, such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `get` 关联方法中添加 `where` 子句语句（以及其他查找参数），如下所示：
- en: '`Actor.getJobs({`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Actor.getJobs({`'
- en: '`where: { category: ''Action'' },`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`where: { category: ''Action'' },`'
- en: '`limit: 10, offset: 20, /* etc. */`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit: 10, offset: 20, /* etc. */`'
- en: '`});`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: hasOne
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: hasOne
- en: 'The `hasOne` association will generate `get`, `set`, and `create` methods for
    the associating model. Suppose we had the following association and instance:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasOne` 关联将为关联模型生成 `get`、`set` 和 `create` 方法。假设我们有以下关联和实例：'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can use the `createJob` method to insert and set the job with the actor:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `createJob` 方法来插入并设置与演员相关的职位：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `setJob` method will update the association of the actor and the job from
    a `Job` instance:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`setJob` 方法将更新演员和职位之间的关联，从 `Job` 实例：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You may use the `set` prefix method to remove an association as well with a
    `null` value:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `set` 前缀方法通过 `null` 值来移除关联：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: belongsTo
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: belongsTo
- en: 'Let’s change our previous example’s model to this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变之前示例中的模型为以下内容：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `belongsTo` association will generate the exact same methods on the same
    model as the `hasOne` association. For further explanation, this association will
    not create `setActor` on the `Job` model but will create the `setJob` method on
    the `Actor` model still.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`belongsTo` 关联将在与 `hasOne` 关联相同的模型上生成完全相同的方法。为了进一步解释，此关联不会在 `Job` 模型上创建 `setActor`，但仍然会在
    `Actor` 模型上创建 `setJob` 方法。'
- en: hasMany
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: hasMany
- en: 'The `hasMany` association will generate the following prefixed methods: `get`,
    `set`, `create`, `count`, `has`, `add`, and `remove`. The `get` and `set` methods
    are similar to the previous example except that the suffix of the method’s name
    will be a pluralized version of the model’s name:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasMany` 关联将生成以下前缀方法：`get`、`set`、`create`、`count`、`has`、`add` 和 `remove`。`get`
    和 `set` 方法与之前的示例类似，除了方法名称的后缀将是模型名称的复数形式：'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `create` prefix method will still only create one record at a time and
    therefore the model’s name is still singular-cased:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 前缀方法仍然一次只创建一条记录，因此模型名称仍然是单数形式：'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also check to see whether a relationship already exists with the `has`
    method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `has` 方法检查是否存在关系：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can add one or multiple associations using the `add` method like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `add` 方法添加一个或多个关联，如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To retrieve how many associations we have for a model, we can invoke the `count`
    method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索模型有多少关联，我们可以调用 `count` 方法：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Removing the associations can be done with the `remove` methods:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `remove` 方法可以移除关联：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: belongsToMany
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: belongsToMany
- en: 'Next, we change the association to `belongsToMany`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将关联更改为 `belongsToMany`：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `belongsToMany` association will generate the same methods on the same model
    as the previous `hasMany` example, similar to how `belongsTo` generated the same
    methods as the `hasOne` association.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`belongsToMany` 关联将在与之前 `hasMany` 示例相同的模型上生成相同的方法，类似于 `belongsTo` 生成与 `hasOne`
    关联相同的方法。'
- en: Renaming associations
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重命名关联
- en: 'You can modify how Sequelize will generate the method names by creating an
    alias to the association using the `as` parameter:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `as` 参数创建关联的别名来修改 Sequelize 生成的方法名：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can manually set the identifier of a relationship directly to the attribute
    and Sequelize will update the value with the `save` method. However, if you have
    made any changes within the associated records, their information will not be
    updated by calling the associating instance’s `save` method. Changes to the actual
    associations would need to be done from their own instance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接将关系的标识符设置为属性，Sequelize 将使用 `save` 方法更新该值。然而，如果您在关联记录中进行了任何更改，通过调用关联实例的
    `save` 方法，它们的信息将不会被更新。对实际关联的更改需要从它们自己的实例中进行。
- en: Now that we know how to apply association methods to our models, we can go over
    the various relationship patterns to help us get a better understanding of where,
    and when, these associations are coupled. In the next section, we will go into
    detail on the relationship patterns that Sequelize supports along with examples
    for each pattern.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何将关联方法应用于我们的模型，我们可以回顾各种关系模式，以帮助我们更好地理解这些关联在哪里以及何时被耦合。在下一节中，我们将详细介绍 Sequelize
    支持的关系模式以及每个模式的示例。
- en: Relationship patterns
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联模式
- en: In this section, we will go over the details of each type of relation (except
    Super-Many-To-Many, which is discussed in a later section), and how to use Sequelize
    to define the associations. After that, we will update the Avalon Airlines project’s
    models with associations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细介绍每种类型的关系（除了将在下一节中讨论的超多对多关系），以及如何使用 Sequelize 定义关联。之后，我们将更新 Avalon
    Airlines 项目的模型以包含关联。
- en: 'We can combine several association patterns to define a relationship pattern.
    Sequelize supports four relationship patterns:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将几个关联模式组合起来定义一个关系模式。Sequelize 支持四种关系模式：
- en: '**One-to-One** – We would use the *hasOne* and *belongsTo* associations together.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一** – 我们将一起使用 *hasOne* 和 *belongsTo* 关联。'
- en: '**One-to-Many** – The *hasMany* and *belongsTo* associations are used for this
    pattern.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多** – 使用 *hasMany* 和 *belongsTo* 关联来实现此模式。'
- en: '**Many-to-Many** – Two *belongsToMany* associations are used for this pattern.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多** – 使用两个 *belongsToMany* 关联来实现此模式。'
- en: '**Super-Many-to-Many** – Two *One-to-Many* relations where the *One* models
    are still considered symbiotic. This relationship will be explained in further
    detail in the *Creating Super Many-to-Many relationships* section.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超多对多** – 两个 *One-to-Many* 关系，其中 *One* 模型仍然被认为是相互依存的。这种关系将在 *创建超多对多关系* 部分中进一步详细说明。'
- en: One-to-One
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一
- en: The One-to-One relational pattern involves the `hasOne` and `belongsTo` associations
    for the models. The difference between the two associations is which table will
    have the identification column.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一关系模式涉及模型之间的 `hasOne` 和 `belongsTo` 关联。这两个关联之间的区别在于哪个表将包含标识列。
- en: As an example, we have an `Airplane` and `BoardingTicket` model. Since the `Airplane`
    model would no longer be involved with `BoardingTicket`, after the flight has
    been completed, we can omit the memorization of the boarding ticket from the `Airplane`
    model’s table. This means that `Airplane` would not need a `hasOne` association,
    but `BoardingTicket` will still need a `belongsTo` association.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个 `Airplane` 和 `BoardingTicket` 模型。由于 `Airplane` 模型在航班完成后将不再与 `BoardingTicket`
    相关，我们可以从 `Airplane` 模型的表中省略对登机牌的记忆。这意味着 `Airplane` 不需要 `hasOne` 关联，但 `BoardingTicket`
    仍然需要一个 `belongsTo` 关联。
- en: 'To define a One-to-One relationship, we would define our models like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一对一关系，我们会这样定义我们的模型：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using Sequelize’s `sync` command would yield the following queries:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sequelize 的 `sync` 命令会产生以下查询：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Without calling `A.hasOne(B)`, Sequelize would not know how to eager load from
    model A to B (but would be able to eager load from model B to A).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不调用 `A.hasOne(B)`，Sequelize 将不知道如何从模型 A 到 B 进行预加载（但可以从模型 B 到 A 进行预加载）。
- en: 'There are several options that you can pass as a second parameter for tuning
    the behavior of the associations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种选项可以作为第二个参数传递以调整关联的行为：
- en: '`onUpdate` – Tells the DBMS how to handle updated foreign relationships. Possible
    values are `CASCADE`, `RESTRICT`, `NO ACTION`, `SET DEFAULT`, and `SET NULL`.
    The default value for this option is `CASCADE`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onUpdate` – 告诉数据库管理系统如何处理更新的外键关系。可能的值有 `CASCADE`、`RESTRICT`、`NO ACTION`、`SET
    DEFAULT` 和 `SET NULL`。此选项的默认值为 `CASCADE`。'
- en: '`onDelete` – Same as `onUpdate` but for handling deleted foreign relationships.
    The default for this option is `SET NULL`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDelete` – 与 `onUpdate` 相同，但用于处理已删除的外部关系。此选项的默认值为 `SET NULL`。'
- en: '`foreignKey` – Accepts a literal string value or an object with the same options
    as an attribute when defining models (`name`, `allowNull`, `unique`, etc.).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foreignKey` – 接受一个字面字符串值或一个对象，该对象在定义模型时具有与属性相同的选项（`name`、`allowNull`、`unique`
    等）。'
- en: '`sourceKey` – The name of the column, from the source table, to use as identification
    for the foreign key column’s value. By default, Sequelize will use the source
    table’s attribute that has a `primaryKey: true` parameter. If your model contains
    no explicit `primaryKey` attribute, then Sequelize will use the default `id` attribute.
    Applicable to `hasOne` and `hasMany` associations.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sourceKey` – 用于识别外键列值的源表列的名称。默认情况下，Sequelize 将使用具有 `primaryKey: true` 参数的源表属性。如果您的模型不包含显式的
    `primaryKey` 属性，则 Sequelize 将使用默认的 `id` 属性。适用于 `hasOne` 和 `hasMany` 关联。'
- en: '`targetKey` – Similar to `sourceKey` except this value will reference the column
    from the target table as opposed to the source table. Applicable to `belongsTo`
    associations.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetKey` – 与 `sourceKey` 类似，但此值将引用目标表中的列，而不是源表中的列。适用于 `belongsTo` 关联。'
- en: 'Here are a few examples of how to use these options:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些如何使用这些选项的示例：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can use the second options interchangeably between models A and B:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模型 A 和 B 之间互换使用第二个选项：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By default, Sequelize will make One-to-One relations optional, but if we wanted
    to require a relationship between the two models, then we would define `allowNull`
    as `false` in the association options like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Sequelize 会将一对一关系设置为可选，但如果我们想要在两个模型之间强制关系，那么我们会在关联选项中将 `allowNull` 定义为
    `false`，如下所示：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One-to-Many
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多
- en: This relational pattern will only create a foreign reference column on the `belongsTo`
    model. Defining an attribute with the `hasMany` association helps Sequelize with
    data retrieval optimization and adding helper functions to the parent model. The
    options in the second parameter are the same as a One-to-One relationship.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系模式将仅在 `belongsTo` 模型上创建外键引用列。使用 `hasMany` 关联定义属性有助于 Sequelize 进行数据检索优化，并为父模型添加辅助函数。第二个参数中的选项与一对一关系相同。
- en: 'Suppose we had `Employees` that belonged to `Organization`. With Sequelize,
    the code would be similar to the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `Employees` 模型属于 `Organization`。使用 Sequelize，代码将类似于以下内容：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This would execute these couple of queries:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行以下几个查询：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Many-to-Many
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多
- en: This relationship will use an associative entity to keep references between
    two models. Some other names for an associative entity are junction table, junction
    model, cross-reference table, and pairing table. With `sequelize.sync()`, Sequelize
    will automatically create a junction model for you, but we still have the option
    of defining our own junction table for situations where we want to add more attributes,
    constraints, life cycle events, and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系将使用关联实体来保持两个模型之间的引用。关联实体的其他名称包括连接表、连接模型、交叉引用表和配对表。使用 `sequelize.sync()`，Sequelize
    将自动为您创建连接模型，但我们仍然可以选择定义自己的连接表，以便在需要添加更多属性、约束、生命周期事件等情况下使用。
- en: 'In this example, we have employees that have tasks assigned to them. Employees
    can work on multiple tasks and tasks can require many employees:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们有一些员工被分配了任务。员工可以处理多个任务，而任务可能需要多个员工：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will execute the following query:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行以下查询：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Many-to-Many relationships will use `CASCADE` as the default behavior for managing
    foreign keys and relationships on both updates and deletions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系将使用 `CASCADE` 作为默认行为来管理更新和删除时的外键和关系。
- en: 'If we wanted to be more explicit in our definitions or wanted to add a custom
    attribute to the junction model, we can define the junction model and relations
    like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在定义中更加明确，或者想要为连接模型添加自定义属性，我们可以这样定义连接模型和关系：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Other than the `through` parameter, Many-to-Many offers a parameter called `uniqueKey`,
    which will allow you to name a reference column. By default, Sequelize will create
    the junction table with a unique key composed of both referencing columns (`employeeId`
    and `taskId`). If you wish to change this behavior, you may set the `unique` attribute
    parameter to `false` in the junction model’s definition.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `through` 参数外，多对多关联还提供了一个名为 `uniqueKey` 的参数，这将允许你命名一个引用列。默认情况下，Sequelize
    将创建一个由引用列（`employeeId` 和 `taskId`）组成的唯一键的连接表。如果你希望改变这种行为，你可以在连接模型定义中将 `unique`
    属性参数设置为 `false`。
- en: Using custom foreign key definitions
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义外键定义
- en: When, and how, to use `sourceKey` and `targetKey` properly can be confusing
    at first. The `hasOne` and `hasMany` associations will reference themselves from
    the Parent model (target model) to the Child model (source model); another way
    of saying this is, “This child is mine through name, marriage, and so on.” The
    `belongsTo` association will reference the Parent model, or “I belong to this
    parent through name, marriage, and so on.”
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在何时以及如何正确使用 `sourceKey` 和 `targetKey` 可能一开始会让人困惑。`hasOne` 和 `hasMany` 关联将从父模型（目标模型）引用到子模型（源模型）；另一种说法是，“这个孩子通过名字、婚姻等是我的。”`belongsTo`
    关联将引用父模型，或者说，“我通过名字、婚姻等属于这个父模型。”
- en: We reference these models as *source* and *target* models since parent and child
    could be misleading and would imply some form of hierarchy. Associations do not
    require a hierarchy; they just form relationships.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些模型称为 *源* 和 *目标* 模型，因为父亲和子代可能会产生误导，并暗示某种形式的层次结构。关联不需要层次结构；它们只是形成关系。
- en: Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Attributes that are defined as references are required to have a unique constraint
    applied to them. This can be done by adding `unique: true` to the attribute’s
    options and using Sequelize’s `sync()` method.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '被定义为引用的属性必须应用唯一约束。这可以通过在属性选项中添加 `unique: true` 并使用 Sequelize 的 `sync()` 方法来实现。'
- en: 'For an example of how to configure the source and target keys, we will first
    define our models:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何配置源和目标键，我们首先定义我们的模型：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using these roles, we will go through examples of using `hasOne`, `hasMany`,
    `belongsTo`, and `belongsToMany` separately.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些角色，我们将分别通过 `hasOne`、`hasMany`、`belongsTo` 和 `belongsToMany` 的示例来展示。
- en: Using hasOne
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 hasOne
- en: 'The following code will create an attribute called `actorName` on the `Roles`
    model, and the value for that attribute will be associated with the actor’s name
    (instead of the actor’s ID attribute):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在 `Roles` 模型上创建一个名为 `actorName` 的属性，该属性的值将与演员的名字相关联（而不是演员的 ID 属性）：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using hasMany
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 hasMany
- en: 'We would use the same options for the `hasMany` association. The following
    code will create an attribute called `roleTitle` on the `Costumes` model, which
    will be associated with the role’s title:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 `hasMany` 关联使用相同的选项。以下代码将在 `Costumes` 模型上创建一个名为 `roleTitle` 的属性，它将与角色的标题相关联：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using belongsTo
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 belongsTo
- en: 'The `belongsTo` association works a bit differently. Instead of referencing
    from the source model, `belongsTo` will reference from the target model like so
    (this would yield the same results as the previous `Actors.hasOne(Roles, ...)`
    code):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`belongsTo` 关联的工作方式略有不同。它不是从源模型引用，而是从目标模型引用，如下所示（这将产生与之前 `Actors.hasOne(Roles,
    ...)` 代码相同的结果）：'
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In other words, the foreign keys will be placed on the model that is creating
    the association when using `belongsTo`, and for the `hasOne`/`hasMany` associations,
    the foreign keys are placed on the other model that is not invoking the association
    method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当使用 `belongsTo` 时，外键将放置在创建关联的模型上，而对于 `hasOne`/`hasMany` 关联，外键将放置在未调用关联方法的另一个模型上。
- en: Using belongsToMany
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 belongsToMany
- en: 'The `belongsToMany` association accepts both the target and the source keys
    as parameters to configure the references. On the movie set, an actor could have
    multiple costumes for all of their different scenes. We can illustrate this relationship
    in Sequelize like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`belongsToMany` 关联接受目标和源键作为参数来配置引用。在电影场景中，一个演员可能为他们的所有不同场景拥有多个服装。我们可以在 Sequelize
    中这样表示这种关系：'
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will create a junction table called `actor_costumes` with two reference
    columns being `actorsName` and `costumesWardrobe`, referencing the Actor and Costume
    model, respectively.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `actor_costumes` 的连接表，其中包含两个引用列 `actorsName` 和 `costumesWardrobe`，分别引用
    Actor 和 Costume 模型。
- en: Now that we have gone over definitions, options, use cases, and examples for
    Sequelize’s association patterns, and the main three relational patterns, we can
    start practicing including those relations for when we select or modify records.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经讨论了 Sequelize 关联模式、选项、用例和示例的定义、选项、用例和示例，以及主要的三种关系模式，我们可以开始练习在选择或修改记录时包含这些关系。
- en: Querying associations with eager loading and lazy loading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用急加载和懒加载查询关联
- en: 'Sequelize offers two different methods of querying associations depending on
    how you wish to query the data: eager loading and lazy loading. With eager loading,
    you would load all of the associated data at once. The lazy loading method will
    load the associations per query as they are called upon from the code. It is easier
    to explain eager loading than lazy loading but to see the benefits of eager loading,
    we will need to go over lazy loading first.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 根据您希望如何查询数据提供两种不同的查询关联方法：急加载和懒加载。使用急加载，您将一次性加载所有关联数据。懒加载方法将根据代码中的调用逐个加载关联。与懒加载相比，急加载更容易解释，但要看到急加载的好处，我们首先需要了解懒加载。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may have heard of the “N+1 select problem” with other ORM frameworks; this
    is referring to the lazy loading method (although, not mutually exclusive) and
    how selecting an association per row could be hazardous to your application’s
    performance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能听说过其他 ORM 框架中的“N+1 查询问题”；这指的是懒加载方法（尽管不是相互排斥）以及逐行选择关联如何可能对应用程序的性能造成危害。
- en: Lazy loading
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载
- en: 'Sequelize tries to make no presumptions about your intent and will initially
    select only the model’s data. We will need to explicitly call the associations
    if we want to transverse through the model’s related data. A good use case for
    lazy loading would be querying related data conditionally (for example, we may
    not want to fetch movie reviews until after the movie is released). Lazy loading
    would look similar to this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 尽量不对您的意图做出假设，并且最初只选择模型数据。如果我们想遍历模型的相关数据，我们需要明确调用关联。懒加载的一个良好用例是条件查询相关数据（例如，我们可能不想在电影发布后获取电影评论）。懒加载看起来可能如下所示：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Eager loading
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 急加载
- en: 'Usually, you would use this form of loading when you have a lot of associations
    or a lot of rows returned from the main table. Referencing the previous example,
    let’s say we replaced `getJob` with `getJobs` and called `getReviews` per job,
    like so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会在有很多关联或主表返回大量行时使用这种加载形式。参考之前的示例，假设我们用 `getJobs` 替换了 `getJob`，并且对每个工作调用
    `getReviews`，如下所示：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the actor ever became too famous and had hundreds of jobs, we could see
    how quickly the number of queries could become too cumbersome for the system.
    One way to prevent this is by using the eager loading method, which will include
    the associated data at the top-level query using `JOIN` statements. Let us convert
    the previous example into an eager-loaded query with Sequelize by beginning to
    define our completed jobs association:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果演员变得过于著名并且有数百个工作，我们可以看到查询数量如何迅速变得对系统来说过于繁琐。防止这种情况的一种方法是通过使用急加载方法，该方法将使用 `JOIN`
    语句在顶级查询中包含关联数据。让我们通过开始定义我们的已完成工作关联来将之前的示例转换为 Sequelize 的急加载查询：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This first `include` parameter will load the `Job` model, set an alias to `CompletedJobs`,
    add a `where` clause for the `completed` flag, and then call a nested association
    from `Job` to `Review` (along with a `published` `where` clause for the review).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个 `include` 参数将加载 `Job` 模型，设置别名为 `CompletedJobs`，添加一个针对 `completed` 标志的
    `where` 子句，然后从 `Job` 到 `Review` 的嵌套关联调用（以及针对评论的 `published` `where` 子句）。
- en: 'Next, we need to define our incomplete jobs association:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们的不完整工作关联：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The second parameter is a simpler alias association for `Job` with an inverted
    `where` clause from `CompletedJobs`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个更简单的 `Job` 别名关联，它从 `CompletedJobs` 中反转了 `where` 子句。
- en: 'The idea here is to query the completed and incomplete jobs separately since
    we only want to include reviews from jobs that are done. Now, we can query our
    actor with the jobs and reviews:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是分别查询已完成和未完成的工作，因为我们只想包括已完成的工作的评论。现在，我们可以使用工作和评论来查询我们的演员：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will generate an SQL query similar to this (some selected columns have
    been omitted for brevity):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个类似的 SQL 查询（为了简洁，省略了一些选定的列）：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, concatenate the completed and incomplete jobs:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将已完成和未完成的工作连接起来：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can iterate through jobs and display the reviews if applicable:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以遍历工作，并在适用的情况下显示评论：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we have the fundamentals of the two load types for Sequelize, we can
    now start venturing into more advanced concepts when associating data. In the
    next section, we will go over more advanced query patterns for associations: Super
    Many-to-Many associations and polymorphic associations.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Sequelize两种加载类型的基础，我们可以开始探索在关联数据时更高级的概念。在下一节中，我们将讨论关联的更高级查询模式：超级多对多关联和多态关联。
- en: Using advanced association options
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级关联选项
- en: Sequelize offers a variety of tricks to help communicate with your database’s
    relations properly. Some of these methods will help query associations in a more
    organized and ergonomic way. Other methods will offer us a way to compose the
    database’s schematics for more advanced relationship patterns. In this section,
    we will be going over examples of how to manage complex many-to-many relationships
    using the Super Many-to-Many pattern, define scoped associations, and query polymorphic
    associations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize提供了一系列技巧来帮助正确地与数据库的关系进行通信。其中一些方法将帮助以更有组织和更舒适的方式查询关联。其他方法将为我们提供一种方式来组合数据库的架构，以实现更高级的关系模式。在本节中，我们将讨论如何使用超级多对多模式管理复杂的多对多关系、定义作用域关联以及查询多态关联的示例。
- en: Using scopes with associations
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用关联的作用域
- en: Scopes are a way to define a namespace with a default set of parameters, or
    parameters that override previously applied scopes to a query. Associations may
    have defined scopes to help with organization of the code base. A key difference
    between scopes for associations and models is that the association scope’s parameters
    are applicable for the `WHERE` clause. Model scopes can define the `WHERE`, `LIMIT`,
    and `OFFSET` clauses, for example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域是一种定义命名空间的方式，它包含一组默认参数，或者覆盖之前应用于查询的参数。关联可以定义作用域以帮助组织代码库。关联作用域与模型作用域之间的一个关键区别是，关联作用域的参数适用于`WHERE`子句。模型作用域可以定义`WHERE`、`LIMIT`和`OFFSET`子句等。
- en: 'The following is an example of querying associations with scopes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个查询具有作用域的关联的示例：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Sequelize will add a mixin for the `worker` instance called `getCompletedTasks()`,
    which would invoke a query similar to this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize将为`worker`实例添加一个名为`getCompletedTasks()`的混入，该混入将执行一个类似于以下查询的操作：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `` `task`.`completed` = true `` part was automatically added from Sequelize
    from the scope’s definition. An alternative way of defining the same scope is
    shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`task.completed = true`这一部分是Sequelize根据作用域定义自动添加的。定义相同作用域的另一种方式如下所示：'
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When creating scoped associations, Sequelize will automatically add default
    values for those parameters when calling the `create` or `add` mixins. As an example,
    we know a worker has already completed a task and wanted to insert the association
    like so:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建具有作用域的关联时，Sequelize会在调用`create`或`add`混入函数时自动为这些参数添加默认值。例如，我们知道一个工人已经完成了一个任务，并希望插入关联，如下所示：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Sequelize will execute a similar query when creating a completed task via `worker`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过`worker`创建一个完成的任务时，Sequelize将执行一个类似的查询：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `completed` attribute has been automatically set to `true` for when we want
    to add a completed task. The same behavior would be exhibited if we were to use
    the `add` mixin.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要添加一个完成的任务时，`completed`属性已被自动设置为`true`。如果我们使用`add`混入，也会表现出相同的行为。
- en: 'Using the scope parameter on a `belongsToMany` association would apply the
    scope to the target model instead of the junction mode. If you wish to apply a
    scope on the junction model instead, you would add the scope parameter inside
    of the `through` configuration like so:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`belongsToMany`关联中使用作用域参数会将作用域应用于目标模型而不是连接模型。如果您希望将作用域应用于连接模型，您可以在`through`配置内部添加作用域参数，如下所示：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Creating Super Many-to-Many relationships
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建超级多对多关系
- en: Suppose we owned a store and wanted to maintain lists of associations between
    employees and customers through transactions. Typically, we can define this sort
    of relationship by adding a `belongsToMany` association on the `Employee` and
    `Customer` model using the `Transaction` model as the junction table.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们拥有一家商店，并希望通过事务维护员工与客户之间的关联列表。通常，我们可以通过在`Employee`和`Customer`模型上添加一个`belongsToMany`关联，并使用`Transaction`模型作为连接表来定义这种关系。
- en: 'Let us start with the definitions of these models to use throughout this section:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本节中使用的这些模型定义开始：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You may have noticed that the `Transaction` model has the `id` attribute explicitly
    defined as the primary key. This will prevent Sequelize from using the composition
    keys of `employeeId` and `customerId` as the primary key, which is required for
    establishing Super Many-to-Many relationships.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`Transaction` 模型的 `id` 属性被明确定义为主键。这将防止 Sequelize 使用 `employeeId` 和
    `customerId` 的组合键作为主键，这对于建立超级多对多关系是必需的。
- en: 'There are two ways to create a Many-to-Many relationship with these three models.
    The common way would be to use the `belongsToMany` association like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以创建这三个模型之间的多对多关系。常见的方法是使用 `belongsToMany` 关联，如下所示：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The other method is to use `hasMany` and `belongsTo` on both of the associating
    models:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是同时在关联模型上使用 `hasMany` 和 `belongsTo`：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These two methods will yield the same schematic result for the junction table
    (creating `employeeId` and `customerId` on the junction model). However, when
    you try to eager load the data, you may run into several issues depending on how
    you are trying to query the data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法将为连接表产生相同的图示结果（在连接模型上创建 `employeeId` 和 `customerId`）。然而，当你尝试预加载数据时，可能会遇到几个问题，具体取决于你如何查询数据。
- en: 'With the `belongsToMany` associations, we may query our models in the following
    way (however, this will not work for the `hasMany` and `belongsTo` method):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `belongsToMany` 关联，我们可以按以下方式查询我们的模型（然而，这不会对 `hasMany` 和 `belongsTo` 方法起作用）：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Including the junction model from the associated models would not work for
    the `belongsToMany` approach, but the following code would work for the `hasMany`
    and `belongsTo` method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从关联模型中包含连接模型对于 `belongsToMany` 方法不起作用，但以下代码对于 `hasMany` 和 `belongsTo` 方法是有效的：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Trying to include associated models through the junction model will only work
    with the `hasMany` and `belongsTo` method. The following code will not work for
    the `belongsToMany` pattern:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过连接模型包含关联模型仅适用于 `hasMany` 和 `belongsTo` 方法。以下代码对 `belongsToMany` 模式不起作用：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In order to be able to use all of the various forms of eager loading for these
    models, we can implement the Super Many-to-Many pattern by combining the two associated
    methods such as the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用这些模型的所有各种预加载形式，我们可以通过组合两种关联方法（如下所示）来实现超级多对多模式：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Declaring our associations like this would allow us to query associative data
    via the junction model, or the associated models themselves, without constraint
    or stipulations. Deeply nested includes are also supported natively with the Super
    Many-to-Many relationship.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式声明我们的关联将允许我们通过连接模型或关联模型本身查询关联数据，而不受约束或规定。深度嵌套的包含也通过超级多对多关系原生支持。
- en: Using polymorphic associations
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多态关联
- en: When we have two or more associative models targeting the same foreign key on
    a junction table we can use a polymorphic association pattern for that scenario.
    You may think of polymorphic associations as some type of generic interfacing
    for associated data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有两个或更多关联模型针对连接表上的同一外键时，我们可以为该场景使用多态关联模式。你可以将多态关联视为关联数据的某种通用接口。
- en: Suppose we owned an online retail store and wanted to store reviews for both
    widgets and gizmos under one review table. Initially, we would want to use `hasMany`
    and `belongsTo` associations, but this would cause Sequelize to generate two columns
    on the junction model (`widgetId` and `gizmoId`) instead of one for a generic
    pattern. Semantically, this would not make sense either since a review is not
    associated with a widget *and* a gizmo product.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们拥有一家在线零售店，并希望将 widget 和 gizmo 的评论存储在一个评论表中。最初，我们可能想使用 `hasMany` 和 `belongsTo`
    关联，但这会导致 Sequelize 在连接模型上生成两个列（`widgetId` 和 `gizmoId`），而不是一个通用的模式。从语义上讲，这也不合理，因为评论既不与
    widget 相关，也不与 gizmo 产品相关。
- en: 'First, we will need to define our `Widget` and `Gizmo` models:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义我们的 `Widget` 和 `Gizmo` 模型：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we will define our `Review` model like so:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义我们的 `Review` 模型如下：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `instanceMethods` parameter will create a `getEntity` function per instance,
    which will check to see whether `entityType` is null. If there is an entity type,
    then we can call the associated mixin function by adding a `get` prefix to the
    entity type’s value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceMethods` 参数将为每个实例创建一个 `getEntity` 函数，该函数将检查 `entityType` 是否为空。如果有实体类型，则可以通过在实体类型的值前添加
    `get` 前缀来调用关联的混合函数。'
- en: 'Now we can establish our relationships as shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以建立我们的关系，如下所示：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For each association, we will use `entityId` as `foreignKey`, and since the
    junction model references more than one table, we cannot set a reference constraint
    on that table (which is why we set `constraints` to `false`):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个关联，我们将使用`entityId`作为`foreignKey`，由于连接模型引用了多个表，我们无法在该表上设置引用约束（这就是为什么我们将`constraints`设置为`false`）：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To query the associations, do the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询关联，请执行以下操作：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Polymorphism allows us to retrieve the widget or gizmo without being pre-deterministic
    in our queries by calling our instance method, `getEntity`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 多态允许我们通过调用实例方法`getEntity`来检索小部件或小玩意，而无需在我们的查询中预先确定：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In order to load our data eagerly, we would include the associated models like
    any other eager-loaded query:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了懒加载我们的数据，我们将包括关联模型，就像任何其他懒加载查询一样：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `afterFind` hook will automatically associate the `create` instance to the
    `entity` key for each review.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`afterFind`钩子将自动将`create`实例关联到每个评论的`entity`键。'
- en: 'Since we are referencing more than one table to one target column, we will
    need to be extra careful when querying the junction model. For instance, if both
    `Widget` and `Gizmo` had an ID of `5` and a review had `entityType` of `Gizmo`,
    and we queried reviews with `Review.findAll({ include: Widget })`, then the `Widget`
    instance would be eager loaded into `Review` regardless of `entityType`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们引用了多个表到一个目标列，所以在查询连接模型时需要格外小心。例如，如果`Widget`和`Gizmo`都有一个ID为`5`，并且一个评论有`entityType`为`Gizmo`，如果我们查询带有`Review.findAll({
    include: Widget })`的评论，那么`Widget`实例将被懒加载到`Review`中，无论`entityType`是什么。'
- en: Sequelize will not automatically infer the entity’s type from the model’s name.
    Luckily, our `afterFind` life cycle event will assign the entity value properly.
    It is recommended to always use the abstracted methods (for example, `getEntity`)
    over Sequelize’s mixins (for example, `getWidget`, `getGizmo`, etc.) in order
    to avoid ambiguity.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize不会自动从模型名称中推断实体的类型。幸运的是，我们的`afterFind`生命周期事件将正确分配实体值。建议始终使用抽象方法（例如，`getEntity`）而不是Sequelize的混入（例如，`getWidget`、`getGizmo`等），以避免歧义。
- en: 'So far, we have shown an example of a One-to-Many relationship, but what about
    a Many-to-Many? Using the previous example models, we can add an associated model
    called `Categories`, which would look like the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了一个一对多关系的示例，但多对多关系呢？使用之前的示例模型，我们可以添加一个名为`Categories`的关联模型，其外观如下：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we can create our junction model for a Many-to-Many relationship by assigning
    two foreign key columns:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过分配两个外键列来创建用于多对多关系的连接模型：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `ce_unique_constraint` lines will tell Sequelize that all three of these
    attributes belong to the same composited unique key. The null reference for `entityId`
    will ensure that Sequelize will not create a reference constraint for that column.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`ce_unique_constraint`行将告诉Sequelize这三个属性属于同一个复合唯一键。`entityId`的空引用将确保Sequelize不会为该列创建引用约束。'
- en: 'Next, we can define our relations for `Widget` and `Gizmo` along with a helper
    method. We will assign a common parameter configuration along with a function
    for amending a scope to the parameter:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以定义`Widget`和`Gizmo`的关系以及一个辅助方法。我们将分配一个公共参数配置以及一个用于修改作用域的函数：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, we can assign our relationships to the applicable models:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的关系分配给适用的模型：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Calling a method such as `widget.getCategories()` would execute a similar query
    to this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个方法，例如`widget.getCategories()`，将执行一个类似于以下查询的操作：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now that we have learned how to operate with associations and relationships
    for Sequelize, we can begin making some modifications to our Avalon Airlines project.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用Sequelize操作关联和关系，我们可以开始对我们的Avalon航空公司项目进行一些修改。
- en: Applying associations to Avalon Airlines
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将关联应用于Avalon航空公司
- en: Luckily, the models for the project are simple and won’t require the amount
    of effort as defining a Super Many-to-Many relationship. Within these next several
    model updates, this book will demonstrate what to modify only for the `class`
    model block (the rest of the contents within each file should remain the same).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个项目的模型很简单，不需要像定义一个超级多对多关系那样付出大量的努力。在接下来的几个模型更新中，这本书将展示只需要修改`class`模型块的内容（每个文件中的其余内容应保持不变）。
- en: 'Starting in alphabetical order, we will begin modifying the `models/airplane.js`
    file’s `class` block by adding a relationship to `FlightSchedule`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从字母顺序开始，我们将通过添加与`FlightSchedule`的关系来修改`models/airplane.js`文件的`class`块：
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we can edit the `models/boardingticket.js` file’s `class` block and add
    a `Customer` and `FlightSchedule` relationship:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以编辑 `models/boardingticket.js` 文件的 `class` 块并添加 `Customer` 和 `FlightSchedule`
    关联：
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Customers will now have many boarding tickets; the `models/customer.js` file’s
    `class` block should now look like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 客户现在将有许多登机牌；`models/customer.js` 文件的 `class` 块现在应该看起来像这样：
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Flight schedules will belong to a specific airplane, and they will have many
    boarding tickets. We can edit the `models/flightschedule.js` file’s `class` block
    to match the following example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行计划将属于特定的飞机，并且将有许多登机牌。我们可以编辑 `models/flightschedule.js` 文件的 `class` 块以匹配以下示例：
- en: '[PRE64]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Since we are not executing `sync({ force: true })` when initializing Sequelize,
    we will need to generate a migrations file and add the necessary references for
    their respective models. We can use the Sequelize CLI tool to generate a new migrations
    file using the `migration:generate` subcommand:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们在初始化 Sequelize 时没有执行 `sync({ force: true })`，我们需要生成一个迁移文件并为相应的模型添加必要的引用。我们可以使用
    Sequelize CLI 工具通过 `migration:generate` 子命令来生成一个新的迁移文件：'
- en: '[PRE65]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Sequelize will notify you on the new file that it has generated a migration
    file with a message similar to this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 将通过类似以下的消息通知你它已生成迁移文件：
- en: '[PRE66]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The prefixed number on the filename will be different from what appears on your
    screen, but if we look into the `migrations` directory, then we will see a newly
    generated file. We can quickly overwrite the file’s contents.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名上的前缀数字将不同于你屏幕上显示的数字，但如果我们查看 `migrations` 目录，我们将看到一个新的生成文件。我们可以快速覆盖文件的内容。
- en: 'At the top of the file, we will want to include `DataTypes` and start our migration’s
    `up` block:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，我们将希望包含 `DataTypes` 并开始迁移的 `up` 块：
- en: '[PRE67]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can now add the `FlightSchedule` model’s reference for the `Airplane` model
    by adding a column first and then adding the constraint:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过先添加列然后添加约束来为 `FlightSchedule` 模型添加对 `Airplane` 模型的引用：
- en: '[PRE68]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, we will want to do the same for `BoardingTicket` and its related models,
    `Customer` and `FlightSchedule`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望对 `BoardingTicket` 及其相关模型 `Customer` 和 `FlightSchedule` 做同样的处理：
- en: '[PRE69]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can close the `up` block and start our `down` block for migration reversal
    support:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以关闭 `up` 块并开始我们的 `down` 块以支持迁移反转：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We will need to remove the constraints first, then the columns, and finally,
    close the `down` block and exported object like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先删除约束，然后是列，最后关闭 `down` 块和导出对象，如下所示：
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In our console, we can migrate these new changes with the following command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制台中，我们可以使用以下命令来迁移这些新更改：
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Sequelize will confirm that the migration has been completed, and our models
    are officially related to each other through associations. Throughout this book,
    we will use the lessons learned from this chapter for including associated data
    within our queries, but for now, we will move on to the next lesson.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 将确认迁移已完成，并且我们的模型通过关联正式相互关联。在本书的整个过程中，我们将使用本章学到的知识在查询中包含关联数据，但到目前为止，我们将继续进行下一课。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went over defining relations of models using associative
    properties along with some advanced options and relational patterns, and we went
    over the differences between eager loading and lazy loading. At the end of this
    chapter, we took our lessons from the previous chapter, *Validating Models*, and
    added validations, associations, and migrations for our Avalon Airlines project.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用关联属性以及一些高级选项和关系模式来定义模型的关系，并探讨了 eager loading 和 lazy loading 之间的区别。在本章的结尾，我们从前一章的“验证模型”中汲取经验，为
    Avalon Airlines 项目添加了验证、关联和迁移。
- en: Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you ever get stuck on associations and need a quick reference, the related
    material can be found here: [https://sequelize.org/docs/v6/core-concepts/assocs/](https://sequelize.org/docs/v6/core-concepts/assocs/).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾在关联上遇到困难并需要快速参考，相关材料可以在这里找到：[https://sequelize.org/docs/v6/core-concepts/assocs/](https://sequelize.org/docs/v6/core-concepts/assocs/)。
- en: In the next chapter, we will go over Sequelize’s hook feature (also known as
    a life cycle event), how to define hooks for models, and what would be some good
    use cases for life cycle events.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Sequelize 的钩子功能（也称为生命周期事件），如何为模型定义钩子，以及生命周期事件的一些良好用例。
