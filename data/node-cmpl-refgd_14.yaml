- en: Using NoSQL Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NoSQL数据库
- en: 'In the last chapter, we implemented a sample application exposing a read-only
    service that provided catalog data. For the sake of simplicity, we introduced
    a performance bottleneck in this implementation by using file storage. This storage
    is not suitable for web applications. It relies on 33 physical files, preventing
    our application from servicing heavy loads, as file storage lacks multitenant
    support due to disc I/O operations. In other words, we definitely need to look
    for a better storage solution, which scales easily, when needed, following the
    demands of our REST-enabled application. NoSQL databases are now heavily used
    in web and in cloud environments, ensuring zero downtime and high availability.
    They have the following advantages over traditional transactional SQL databases:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了一个示例应用程序，它提供了一个只读服务，提供了目录数据。为了简化，我们在这种实现中引入了性能瓶颈，使用了文件存储。这种存储不适合Web应用程序。它依赖于33个物理文件，阻止我们的应用程序处理重负载，因为文件存储由于磁盘I/O操作而缺乏多租户支持。换句话说，我们绝对需要寻找一个更好的存储解决方案，当需要时，它可以轻松扩展，以满足我们REST启用应用程序的需求。现在，NoSQL数据库在Web和云环境中被广泛使用，确保零停机时间和高可用性。与传统的交易性SQL数据库相比，它们有以下优势：
- en: They **support schema versions**; that is, they can work with object representations
    rather than filling the object state based on definitions of one or several tables.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们**支持模式版本**；也就是说，它们可以与对象表示一起工作，而不是根据一个或多个表的定义来填充对象状态。
- en: They are **extensible**, because they store an actual object. Data evolution
    is supported implicitly, so all you need to do is call the operation that stores
    the modified object.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是**可扩展的**，因为它们存储实际的对象。数据演变是隐式支持的，所以你只需要调用存储修改后对象的操作。
- en: They are designed to be **highly distributed** and **scalable**.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们被设计成**高度分布式**和**可扩展**的。
- en: 'Nearly all modern NoSQL solutions out there support clustering and can scale
    further, along with the load of your application. Additionally, most of them have
    REST-enabled interfaces over HTTP, which eases their usage over a load balancer
    in high-availability scenarios. Classical database drivers are usually not available
    for traditional client-side languages, such as JavaScript, because they require
    native libraries or drivers. However, the idea of NoSQL originated from using
    document data stores. Thus, most of them support the JSON format, which is native
    to JavaScript. Last but not least, most NoSQL solutions are open source and are
    available for free, with all the benefits that open source projects offer: community,
    examples, and freedom!'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的现代NoSQL解决方案都支持集群，并且可以进一步扩展，包括你的应用程序的负载。此外，它们中的大多数都有通过HTTP的REST启用接口，这简化了在高可用性场景中使用负载均衡器的使用。传统的数据库驱动程序通常不可用于传统的客户端语言，如JavaScript，因为它们需要本地库或驱动程序。然而，NoSQL的想法源于使用文档数据存储。因此，它们中的大多数都支持JSON格式，这是JavaScript的本地格式。最后但同样重要的是，大多数NoSQL解决方案都是开源的，并且可以免费使用，提供了开源项目提供的所有好处：社区、示例和自由！
- en: In this chapter, we will take a look at the MongoDB NoSQL database and the Mongoose
    module that interacts with it. We will see how to design and implement automated
    tests for the database models. Finally, at the end of the chapter, we will remove
    the file storage bottleneck and will move our application to an almost ready for
    production state.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨MongoDB NoSQL数据库及其与之交互的Mongoose模块。我们将了解如何为数据库模型设计并实现自动化测试。最后，在本章的结尾，我们将移除文件存储瓶颈，并将我们的应用程序移动到几乎可以投入生产的状态。
- en: MongoDB – a document store database
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB – 文档存储数据库
- en: MongoDB is an open source document database with built-in support for the JSON
    format. It provides a full index support, based on any of the available attributes
    in a document. It is ideal for high-availability scenarios due to its scalability
    features. MongoDB, available at [https://mms.mongodb.com](https://mms.mongodb.com/),
    is cloud-ready with its management services, **MongoDB Management Services** (**MMS**).
    They utilize and automate most development operations that need to be carried
    out to keep your cloud database in good shape, taking care of upgrades, further
    scaling, backups, recovery, performance, and security alerts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一个开源的文档数据库，内置了对 JSON 格式的支持。它提供了基于文档中任何可用属性的完整索引支持。由于其可扩展性功能，它非常适合高可用性场景。MongoDB
    可在 [https://mms.mongodb.com](https://mms.mongodb.com/) 上使用，其管理服务为 **MongoDB 管理服务**（**MMS**）。它们利用并自动化大多数需要执行的开发操作，以保持您的云数据库处于良好状态，包括升级、进一步扩展、备份、恢复、性能和安全警报。
- en: Let's move forward and install MongoDB. Installers for Windows, Linux, macOS,
    and Solaris are available at [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads).
    Linux users can find MongoDB in all popular distribution repositories, while Windows
    users can make use of a user-friendly wizard which will guide you through the
    installation steps, where, for a typical installation, all you need to do is accept
    the license agreement and provide an installation path.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进并安装 MongoDB。Windows、Linux、macOS 和 Solaris 的安装程序可在 [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)
    获取。Linux 用户可以在所有流行的发行版仓库中找到 MongoDB，而 Windows 用户可以利用一个用户友好的向导，该向导将引导您完成安装步骤，在典型安装中，您只需接受许可协议并提供安装路径即可。
- en: 'After a successful installation, execute the following command to start MongoDB.
    If you want to specify a custom location for your data, you have to use the `--dbpath`
    argument. Optionally, you can start the MongoDB HTTP console via the `--rest`
    argument:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，执行以下命令以启动 MongoDB。如果您想指定数据存储的特定位置，您必须使用 `--dbpath` 参数。可选地，您可以通过 `--rest`
    参数启动 MongoDB HTTP 控制台：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The default port for communicating with MongoDB is `27017`, and its HTTP console
    is implicitly configured to use a port higher than the data port by a value of
    1,000\. Therefore, the default port of the console will be `28017`. The HTTP console
    provides useful information about the database, such as logs, health status, available
    databases, and so on. I strongly advise you to spend some time with it. The console
    can also be used as a RESTful health check service of the database, because it
    provides JSON-encoded information about the running database services and the
    last error that occurred:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MongoDB 通信的默认端口是 `27017`，其 HTTP 控制台默认配置为使用比数据端口高 1,000 的端口。因此，控制台的默认端口将是 `28017`。HTTP
    控制台提供了有关数据库的有用信息，例如日志、健康状态、可用数据库等。我强烈建议您花些时间熟悉它。控制台还可以用作数据库的 RESTful 健康检查服务，因为它提供了关于运行数据库服务和最后发生的错误的
    JSON 编码信息：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This REST interface can be used in a script or an application to automate altering
    notifications providing the current state of the database engine and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此 REST 接口可用于脚本或应用程序中，以自动化提供数据库引擎当前状态的更改通知等。
- en: The log section of the console shows that your server is running successfully
    (if it is). Now we are ready to move further and see how to connect Node.js to
    MongoDB.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台的日志部分显示您的服务器正在成功运行（如果正在运行的话）。现在我们准备进一步了解如何将 Node.js 连接到 MongoDB。
- en: Database modeling with Mongoose
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mongoose 进行数据库建模
- en: '**Mongoose** is a module that connects Node.js to MongoDB in an **object document
    mapper** (**ODM**) style. It offers the **Create, Read, Update, and Delete** (also
    known as **CRUD**) functionalities for documents stored in the database. Mongoose
    defines the structure of the used documents using schemas. The schema is the smallest
    unit of data definition in Mongoose. A model is built out of a schema definition.
    It is a constructor-like function that can be used to create or query documents.
    Documents are instances of a model and represent one-to-one mapping to the documents
    stored in MongoDB. The schema-model-document hierarchy provides a self-descriptive
    way of defining objects and allows easy data validation.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mongoose** 是一个模块，它以对象文档映射器（**ODM**）风格将 Node.js 连接到 MongoDB。它为存储在数据库中的文档提供了
    **创建、读取、更新和删除**（也称为 **CRUD**）功能。Mongoose 使用模式定义了使用的文档的结构。模式是 Mongoose 中数据定义的最小单元。模型是由模式定义构建的。它是一个类似于构造函数的函数，可以用来创建或查询文档。文档是模型的实例，代表与存储在
    MongoDB 中的文档一对一的映射。模式-模型-文档层次结构提供了一种自我描述的方式来定义对象，并允许轻松的数据验证。'
- en: 'Let''s start by installing Mongoose with `npm`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 `npm` 安装 Mongoose 开始：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have the Mongoose module installed, our first step will be to define
    a schema that will represent an item in the catalog:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Mongoose 模块，我们的第一步将是定义一个将代表目录中项目的模式：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code snippet creates a schema definition of an item. Defining
    a schema is straightforward and is quite similar to JSON schema definition; you
    have to describe and attribute with its type and optionally provide additional
    properties for each key. In the case of the catalog application, we need to use
    the `itemId` as a unique index in order to avoid having two different items with
    the same ID. Thus, apart from defining its type as `String`, we also use the `index`
    attribute to describe that the value of the `itemId` field must be unique for
    each individual item.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段创建了一个项目模式的定义。定义模式是直接的，并且相当类似于 JSON 模式定义；你必须描述和属性化其类型，并可选地为每个键提供额外的属性。在目录应用程序的情况下，我们需要使用
    `itemId` 作为唯一索引以避免有两个具有相同 ID 的不同项目。因此，除了将其类型定义为 `String` 之外，我们还使用 `index` 属性来描述
    `itemId` 字段的值必须对每个单独的项目是唯一的。
- en: 'Mongoose introduces the term **model**. A model is a constructor-like function
    compiled out of a schema definition. An instance of a model represents a document
    that can be saved to or read from the database. Creating a model instance is done
    by calling the `model` function of a `mongoose` instance and passing the schema
    that the model should use:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 引入了术语 **模型**。模型是从模式定义编译出的类似于构造函数的函数。模型的实例代表可以保存到或从数据库中读取的文档。创建模型实例是通过调用
    `mongoose` 实例的 `model` 函数并传递模型应使用的模式来完成的：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A model also exposes functions for querying and data manipulations. Assuming
    that we have initialized a schema and created a model, storing a new item to MongoDB
    is as simple as creating a new `model` instance and invoking its `save` function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模型还公开了用于查询和数据操作的功能。假设我们已经初始化了一个模式并创建了一个模型，将新项目存储到 MongoDB 中就像创建一个新的 `model`
    实例并调用其 `save` 函数一样简单：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is how to use the model in order to query for documents representing a
    sports watch belonging to the `Watches` group named `Sports Watches`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用模型来查询代表属于 `Watches` 组并命名为 `Sports Watches` 的运动手表的文档：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The model also exposes a `findOne` function, a convenient way of finding an
    object by its unique index and then performing some data manipulation on it, that
    is, for delete or update operations. The following example deletes an item:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 模型还公开了一个 `findOne` 函数，这是一种方便的方式，通过其唯一索引查找对象，然后对其进行一些数据操作，即进行删除或更新操作。以下示例删除了一个项目：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Testing a Mongoose model with Mocha
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mocha 测试 Mongoose 模型
- en: 'Mocha is one of the most popular testing frameworks for JavaScript; its main
    goal is to provide an easy way to test asynchronous JavaScript code. Let''s install
    Mocha globally so that we can make it available to any Node.js application that
    we may develop in the future:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 是 JavaScript 最受欢迎的测试框架之一；其主要目标是提供一个简单的方式来测试异步 JavaScript 代码。让我们全局安装 Mocha，以便我们可以在未来开发的任何
    Node.js 应用程序中使用它：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will also need an assertion library that can be used together with Mocha.
    The assertion library provides functions for validating actual values, against
    expected ones, when they are not equal, the assertion library will cause test
    failure.  `Should.js` assertion library module is easy to use and it will be our
    choice, so let''s install it globally too:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个可以与 Mocha 一起使用的断言库。断言库提供了验证实际值与预期值的功能，当它们不相等时，断言库将导致测试失败。`Should.js`
    断言库模块易于使用，它将成为我们的选择，因此让我们也全局安装它：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have our testing modules installed, we need to specify our `testcase`
    file path in the `package.json` file. Let''s modify it by adding a `test` element
    pointing to Mocha and the `testcase` file in the script node:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了我们的测试模块，我们需要在 `package.json` 文件中指定我们的 `testcase` 文件路径。让我们通过在脚本节点中添加一个指向
    Mocha 和 `testcase` 文件的 `test` 元素来修改它：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will tell the npm package manager to trigger Mocha when the `npm` test
    is executed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 npm 包管理器在执行 `npm` 测试时触发 Mocha。
- en: 'Automation of Mongoose tests must not be affected by the current state of the
    database. To ensure that the results are predictable at each test run, we need
    to ensure that the database state is exactly as we would expect it. We will implement
    a module called `prepare.js` in the `test` directory. It will clear the database
    before each test run:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 测试的自动化不应受数据库当前状态的影响。为了确保每次测试运行的结果都是可预测的，我们需要确保数据库状态与我们预期的完全一致。我们将在
    `test` 目录中实现一个名为 `prepare.js` 的模块。它将在每次测试运行之前清除数据库：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will implement a Mocha test, which creates a new item:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个 Mocha 测试，该测试创建一个新项目：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Executing the `npm test` now results in a call against the MongoDB database
    creating an item out of the passed JSON object. After insertion, the assert callback
    will be executing, ensuring that values passed to by Mongoose are the same as
    the returned ones from the database. Give it a try and break the test—simply change
    the expected value in the assert with an invalid one—you will see the test failing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行 `npm test` 将导致 MongoDB 数据库被调用，从传递的 JSON 对象中创建一个项目。插入后，断言回调将执行，确保 Mongoose
    传递的值与数据库返回的值相同。试一试并破坏测试——只需在断言中更改期望值为一个无效值——你会看到测试失败。
- en: Creating a user-defined model around a Mongoose model
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Mongoose 模型周围创建用户定义的模型
- en: 'After seeing how a model works, it is time to create a user-defined module
    that wraps all CRUD operations for the catalog. Since we intend to use that module
    in a RESTful web application, it seems logical to leave the schema definition
    and the model creation outside the module and have them provided as arguments
    of each module function. The same schema definition is used in the unit tests,
    ensuring stability of the module. Now let''s add an implementation for each CRUD
    function, starting with a `remove()` function. It looks up an item based on its
    `id` and deletes it from the database, if it exists:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到模型如何工作之后，是时候创建一个用户定义的模块，该模块封装了目录的所有 CRUD 操作。由于我们打算在一个 RESTful 网络应用程序中使用该模块，因此将模式定义和模型创建放在模块外部，并将它们作为每个模块函数的参数提供似乎是合理的。相同的模式定义在单元测试中使用，确保模块的稳定性。现在让我们为每个
    CRUD 函数添加一个实现，从 `remove()` 函数开始。它根据其 `id` 查找项目，如果存在，则从数据库中删除：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `saveItem()` function takes the request body payload as an argument. A
    valid update request will contain the new state of an `item` object, represented
    in JSON format. First, the `itemId` is parsed out of the JSON object. Next, lookup
    is done. If an item exists, it gets updated. Otherwise, a new one gets created:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveItem()` 函数将请求体有效负载作为参数。有效的更新请求将包含一个 `item` 对象的新状态，该对象以 JSON 格式表示。首先，从
    JSON 对象中解析出 `itemId`。然后执行查找。如果存在项目，则对其进行更新。否则，创建一个新的项目：'
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `toItem()` function converts the JSON payload to a `CatalogItem` model
    instance, that is, an item document:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`toItem()` 函数将 JSON 有效负载转换为 `CatalogItem` 模型实例，即项目文档：'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will also need to provide a means of querying data, so let''s implement
    a function that queries for all items in a category:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供一种查询数据的方法，因此让我们实现一个查询特定类别中所有项目的函数：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similar to `findItemsByCategory`, the following is a function that finds an
    item by its ID:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `findItemsByCategory` 类似，以下是一个根据 ID 查找项目的函数：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, there''s a function that lists all the catalog items stored in the
    database. It uses the Mongoose model `find` function that looks for all documents
    of the model, and uses its first arguments as a filter. We want a function that
    returns all existing documents; that''s why we provide an empty object. This will
    return all available items. The results are available in the `callback` function,
    which is the second argument of the model''s `find` function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个函数可以列出存储在数据库中的所有目录项。它使用Mongoose模型的`find`函数来查找模型的所有文档，并使用其第一个参数作为过滤器。我们想要一个返回所有现有文档的函数；这就是为什么我们提供了一个空对象。这将返回所有可用的项目。结果在`callback`函数中可用，这是模型`find`函数的第二个参数：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `catalog` module will be the foundation of our RESTful service. It is responsible
    for all data manipulation operations, as well as for different kinds of queries.
    It encapsulates all operations in a reusable way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`catalog`模块将是我们的RESTful服务的基石。它负责所有数据操作操作，以及不同类型的查询。它以可重用的方式封装了所有操作。'
- en: Wiring up a NoSQL database module to Express
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将NoSQL数据库模块连接到Express
- en: Now we have automated tests for the model and a user-defined module which makes
    use of them. This ensures the stability of the module and makes it ready for wider
    adoption.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了针对模型和用户定义模块的自动化测试，这确保了模块的稳定性，并使其准备好更广泛的应用。
- en: 'It is time to build a new Express-based application and add a route, exposing
    the new module to it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候构建一个新的基于Express的应用程序并添加一个路由，将新模块公开给该应用程序：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To sum up, we routed each function of the catalog data service module to an
    operation of a RESTful service:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们将目录数据服务模块的每个功能路由到了RESTful服务的操作：
- en: '`GET /catalog/item/:itemId`: This calls `catalog.findItemById()`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /catalog/item/:itemId`: 这将调用 `catalog.findItemById()`'
- en: '`POST /catalog`: This calls `catalog.saveItem()`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /catalog`: 这将调用 `catalog.saveItem()`'
- en: '`PUT /catalog`: This calls `catalog.saveItem()`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /catalog`: 这将调用 `catalog.saveItem()`'
- en: '`DELETE / catalog/item/:id`: This calls `catalog.remove()`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE / catalog/item/:id`: 这将调用 `catalog.remove()`'
- en: '`GET /catalog/:category`: This calls `catalog.findItemsByCategory()`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /catalog/:category`: 这将调用 `catalog.findItemsByCategory()`'
- en: '`GET /catalog/`: This calls `catalog.findAllItems()`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /catalog/`: 这将调用 `catalog.findAllItems()`'
- en: 'As we have our operations exposed, we are ready to perform some more serious
    REST testing. Let''s start Postman and test the newly exposed endpoints:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经公开了我们的操作，我们现在可以执行一些更严肃的REST测试。让我们启动Postman并测试新公开的端点：
- en: '![](img/fa808c10-b5e3-43d7-9733-d6811b64510e.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa808c10-b5e3-43d7-9733-d6811b64510e.png)'
- en: Spend some time testing each operation thoroughly. This will help you gain confidence
    that the catalog data service module really works, and also will make you more
    comfortable with how HTTP responses are served and read. As a RESTful API developer,
    you should be able to read HTTP dumps, which show different request payloads and
    status codes, fluently.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间彻底测试每个操作。这将帮助你建立信心，确保目录数据服务模块确实有效，同时也会让你更熟悉HTTP响应的提供和读取方式。作为一个RESTful API开发者，你应该能够流畅地阅读HTTP转储，这些转储显示了不同的请求负载和状态码。
- en: Self-test questions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试问题
- en: 'Go through the following questions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题：
- en: How would you perform a query with Mongoose for a single value of a multivalued
    attribute?
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会如何使用Mongoose对多值属性的单一值执行查询？
- en: Define a strategy for testing a Node.js module manipulating a NoSQL database.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个测试Node.js模块操作NoSQL数据库的策略。
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at MongoDB, a powerful document-oriented database.
    We utilized it and made use of Mocha to implement an automated test for the database
    layer. Now it is time to build a fully-fledged RESTful web service. In the next
    chapter, we will extend the user-defined module by including support for searching
    via document attributes, and add filtering and pagination capabilities that will
    finally evolve into full-fledged RESTful service implementation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了MongoDB，一个强大的面向文档的数据库。我们使用了它，并利用Mocha实现了数据库层的自动化测试。现在是时候构建一个完整的RESTful
    Web服务了。在下一章中，我们将通过包括通过文档属性进行搜索的支持来扩展用户定义的模块，并添加过滤和分页功能，这将最终演变成完整的RESTful服务实现。
