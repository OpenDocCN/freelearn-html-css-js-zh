- en: Chapter 7. Monitoring Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。监控微服务
- en: 'Monitoring servers is always a controversial subject. It usually falls under
    system administration, and software engineers don''t even go near it, but we are
    losing one of the huge benefits of monitoring: *the ability to react quickly to
    failures*. By monitoring our system very closely, we can be aware of problems
    almost immediately so that the actions to correct the problem may even save us
    from impacting the customers. Along with monitoring, there is the concept of performance.
    By knowing how our system behaves during load periods, we will be able to anticipate
    the necessity of scaling the system. In this chapter, we will discuss how to monitor
    servers, and specifically microservices, in order to maintain the stability of
    our system.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 监控服务器总是一个有争议的话题。它通常属于系统管理范畴，软件工程师甚至不会接触它，但我们正在失去监控的一个巨大好处：*快速对故障做出反应的能力*。通过非常密切地监控我们的系统，我们几乎可以立即意识到问题，以便采取纠正问题的行动，甚至可能使我们免受影响客户的影响。除了监控，还有性能的概念。通过了解我们的系统在负载期间的行为，我们将能够预测扩展系统的必要性。在本章中，我们将讨论如何监控服务器，特别是微服务，以维护我们系统的稳定性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Monitoring services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控服务
- en: Monitoring using PM2 and Keymetrics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PM2和Keymetrics进行监控
- en: Monitoring metrics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控指标
- en: Simian Army – the active monitoring from Spotify
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Simian Army - Spotify的主动监控
- en: Throughput and performance degradation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吞吐量和性能下降
- en: Monitoring services
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控服务
- en: 'When monitoring a microservice, we are interested in a few different types
    of metrics. The first big group of metrics is the hardware resources, which are
    described as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控微服务时，我们对几种不同类型的指标感兴趣。第一大组指标是硬件资源，如下所述：
- en: '**Memory metrics**: This indicates how much memory is left in our system or
    consumed by our application'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存指标**：这表明系统中还剩多少内存或被应用程序占用了多少内存'
- en: '**CPU utilization**: As the name suggests, this indicates how much CPU are
    we using at a given time'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU利用率**：顾名思义，这表明我们在某个时间点上使用了多少CPU'
- en: '**Disk utilization**: This indicates the I/O pressure in the physical hard
    drives'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘利用率**：这表明物理硬盘的I/O压力'
- en: 'The second big group is the application metrics, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二大组是应用程序指标，如下所示：
- en: Number of errors per time unit
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个时间单位的错误次数
- en: Number of calls per time unit
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个时间单位的调用次数
- en: Response time
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应时间
- en: Even though both groups are connected and a problem in the hardware will impact
    the application performance (and the other way around), knowing all of them is
    a must.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个组是相互关联的，硬件出现问题将影响应用程序性能（反之亦然），了解它们都是必须的。
- en: Hardware metrics are easy to query if our server is a Linux machine. On Linux,
    all the magic of hardware resources happens in the `/proc` folder. This folder
    is maintained by the kernel of the system and contains files about how the system
    behaves regarding a number of aspects in the system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件指标很容易查询，如果我们的服务器是一台Linux机器。在Linux上，所有硬件资源的魔力都发生在`/proc`文件夹中。这个文件夹由系统的内核维护，包含有关系统行为的文件。
- en: Software metrics are harder to collect and we are going to use **Keymetrics**
    from the creators of PM2 to monitor our Node.js applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件指标更难收集，我们将使用来自PM2创建者的**Keymetrics**来监控我们的Node.js应用程序。
- en: Monitoring using PM2 and Keymetrics
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PM2和Keymetrics进行监控
- en: PM2, as we've seen before, is a very powerful instrument to run Node applications,
    but it is also very good at monitoring standalone applications in production servers.
    However, depending on your business case, it is not always easy to get access
    to the production.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，PM2是一个非常强大的工具，可以运行Node应用程序，但它也非常擅长监控生产服务器中的独立应用程序。然而，根据您的业务情况，要想访问生产环境并不总是容易。
- en: 'The creators of PM2 have solved this problem by creating Keymetrics. Keymetrics
    is a **Software as a service** (**SaaS**) component that allows PM2 to send monitoring
    data across the network to its website, as shown in the following image (as found
    at [https://keymetrics.io/](https://keymetrics.io/)):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PM2的创建者通过创建Keymetrics来解决了这个问题。Keymetrics是一个**软件即服务**（**SaaS**）组件，允许PM2将监控数据发送到其网站，如下图所示（在[https://keymetrics.io/](https://keymetrics.io/)找到）：
- en: '![Monitoring using PM2 and Keymetrics](img/B04889_07_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2和Keymetrics进行监控](img/B04889_07_01.jpg)'
- en: Even though Keymetrics is not free, it provides a free tier to demonstrate how
    it works. We are going to use it in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Keymetrics不是免费的，但它提供了一个免费的层次来演示它的工作原理。我们将在本章中使用它。
- en: 'The very first thing that we need to do is register a user. Once we get access
    to our account, we should see something similar to the following screen:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是注册一个用户。一旦我们获得了账户访问权限，我们应该看到类似以下屏幕的内容：
- en: '![Monitoring using PM2 and Keymetrics](img/B04889_07_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2和Keymetrics进行监控](img/B04889_07_02.jpg)'
- en: This screen is asking us to create a bucket. Keymetrics uses the bucket concept
    to define a context. For example, if our organization has different areas (payments,
    customer service, and so on) with different servers on each area, we could monitor
    all the servers in one bucket. There are no restrictions on how many servers you
    can have in one bucket. It is even possible to have all the organization in the
    same bucket so that everything is easy to access.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕要求我们创建一个bucket。Keymetrics使用bucket概念来定义上下文。例如，如果我们的组织有不同的领域（支付、客户服务等），每个领域都有不同的服务器，我们可以在一个bucket中监控所有服务器。在一个bucket中可以拥有多少服务器都没有限制。甚至可以将整个组织放在同一个bucket中，这样一切都很容易访问。
- en: 'Let''s create a bucket called `Monitoring Test`, as shown in the following
    image:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`监控测试`的bucket，如下图所示：
- en: '![Monitoring using PM2 and Keymetrics](img/B04889_07_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2和Keymetrics进行监控](img/B04889_07_03.jpg)'
- en: 'Easy, once we tap on **Create Bucket**, Keymetrics will show us a screen with
    the information needed to start monitoring our app, as shown in the following
    image:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，一旦我们点击**创建Bucket**，Keymetrics将显示一个屏幕，其中包含开始监控我们的应用程序所需的信息，如下图所示：
- en: '![Monitoring using PM2 and Keymetrics](img/B04889_07_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2和Keymetrics进行监控](img/B04889_07_04.jpg)'
- en: As you can see, the screen displays information about the private key used by
    Keymetrics. Usually, it is a very bad idea to share this key with anyone.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，屏幕显示了Keymetrics使用的私钥信息。通常，与任何人分享此密钥都是一个非常糟糕的主意。
- en: 'As shown on the screen, the next step is to configure PM2 to push data into
    Keymetrics. There is also useful information about the networking needed to make
    Keymetrics work:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如屏幕所示，下一步是配置PM2将数据推送到Keymetrics。还有关于使Keymetrics工作所需的网络的有用信息：
- en: PM2 will be pushing data to the port **80** on Keymetrics
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PM2将向Keymetrics的端口**80**推送数据
- en: Keymetrics will be pushing data back to us on the port **43554**
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keymetrics将通过端口**43554**向我们推送数据
- en: Usually, in large organizations, there are restrictions about the networking,
    but if you are testing this from home, everything should work straightaway.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在大型组织中，有关网络的限制，但如果您是在家中进行测试，一切都应该立即运行。
- en: 'In order to make PM2 able to send metrics to Keymetrics, we need to install
    one PM2 module called `pm2-server-monit`. This is a fairly easy task:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使PM2能够将指标发送到Keymetrics，我们需要安装一个名为`pm2-server-monit`的PM2模块。这是一个相当简单的任务：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will result in an output similar to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致类似以下的输出：
- en: '![Monitoring using PM2 and Keymetrics](img/B04889_07_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2和Keymetrics进行监控](img/B04889_07_05.jpg)'
- en: 'Let''s run the advised command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行建议的命令：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, I have replaced `[server name]` with `my-server`. There are no
    restrictions on the server name; however, when rolling out Keymetrics into a real
    system, it is recommended to choose a descriptive name in order to easily identify
    the server in the dashboard.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我已将`[服务器名称]`替换为`my-server`。服务器名称没有限制；但是，在将Keymetrics部署到真实系统时，建议选择一个描述性名称，以便在仪表板中轻松识别服务器。
- en: 'The preceding command will produce an output similar to the following image:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将产生类似以下图像的输出：
- en: '![Monitoring using PM2 and Keymetrics](img/B04889_07_16.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2和Keymetrics进行监控](img/B04889_07_16.jpg)'
- en: 'This is an indication that everything went well and our application is ready
    to be monitored from Keymetrics that can be checked on [https://app.keymetrics.io/](https://app.keymetrics.io/),
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明一切进行顺利，我们的应用程序已准备好从Keymetrics进行监控，可以在[https://app.keymetrics.io/](https://app.keymetrics.io/)上进行检查，如下所示：
- en: '![Monitoring using PM2 and Keymetrics](img/B04889_07_06.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2和Keymetrics进行监控](img/B04889_07_06.jpg)'
- en: Now, our server is showing up in the interface. As we previously stated, this
    bucket could monitor different servers. A simple virtual machine is created, and
    as you can see at the bottom of the screen, Keymetrics provides us with the command
    to be executed in order to add another server. In this case, as we are using the
    free access to Keymetrics, so we can only monitor one server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的服务器显示在界面上。正如我们之前所述，这个桶可以监控不同的服务器。创建了一个简单的虚拟机，正如您在屏幕底部所看到的，Keymetrics为我们提供了要执行的命令，以添加另一个服务器。在这种情况下，由于我们正在使用Keymetrics的免费访问，所以我们只能监控一个服务器。
- en: Let's see what Keymetrics can offer us. At first sight, we can see interesting
    metrics such as CPU usage, memory available, disk available, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Keymetrics能为我们提供什么。乍一看，我们可以看到有趣的指标，如CPU使用率、可用内存、可用磁盘等。
- en: All these are hardware metrics that indicate how our system is behaving. Under
    pressure, they are the perfect indicator to point out the need for more hardware
    resources.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是硬件指标，表明了我们的系统的行为。在压力下，它们是指出需要更多硬件资源的完美指标。
- en: Usually, the hardware resources are the main indicator of failure in an application.
    Now, we are going to see how to use Keymetrics to diagnose the problem.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，硬件资源是应用程序失败的主要指标。现在，我们将看看如何使用Keymetrics来诊断问题。
- en: Diagnosing problems
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 诊断问题
- en: A memory leak is usually a difficult problem to solve due to the nature of the
    flaw. Take a look at the following code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏通常是一个难以解决的问题，因为缺陷的性质。看一下以下代码。
- en: 'Let''s run the program using a simple `seneca.act()` action:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用简单的`seneca.act()`操作运行程序：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This program has a very obvious memory leak, and by obvious, I mean that it
    is written to be obvious. The `names` array will keep growing indefinitely. In
    the preceding example, it is not a big deal due to the fact that our application
    is a script that will start and finish without keeping the state in memory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有一个非常明显的内存泄漏，我指的是它被写成明显的。`names`数组将无限增长。在前面的例子中，由于我们的应用程序是一个将在不保留内存状态的情况下启动和完成的脚本，所以这并不是什么大问题。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that JavaScript allocates variables in the global scope if the `var`
    keyword is not used.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果未使用`var`关键字，JavaScript会在全局范围内分配变量。
- en: The problem comes when someone else reutilizes our code in a different part
    of the application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他人在应用程序的不同部分重用我们的代码时，问题就出现了。
- en: 'Let''s assume that our system grows to a point that we need a microservice
    to greet new customers (or deliver the initial payload of personal information
    such as name, preferences, configuration, and so on). The following code could
    be a good example on how to build it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的系统发展到需要一个微服务来向新客户打招呼（或传递个人信息的初始负载，如姓名、偏好、配置等）的程度。以下代码可能是如何构建它的一个很好的例子：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, Seneca will be listening over HTTP for requests from Seneca
    clients or other types of systems such as **curl**. When we run the application:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Seneca将通过HTTP监听来自Seneca客户端或其他类型系统（如**curl**）的请求。当我们运行应用程序时：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then from another terminal, we use curl to act as a client of our microservice,
    everything will work smoothly and our memory leak will go unnoticed:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从另一个终端，我们使用curl作为我们微服务的客户端，一切都将顺利进行，我们的内存泄漏将不会被注意到：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, we are going to use Keymetrics to find the problem. The first thing
    we need to do is run our program using PM2\. In order to do it so, we run the
    following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将使用Keymetrics来找到问题。我们需要做的第一件事是使用PM2运行我们的程序。为了这样做，我们运行以下命令：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This command will produce the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将产生以下输出：
- en: '![Diagnosing problems](img/B04889_07_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![诊断问题](img/B04889_07_07.jpg)'
- en: 'Let''s explain the output in the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释一下以下的输出：
- en: The first line gives us information about the integration with Keymetrics. Data
    such as public key, server name, and the URL to access Keymetrics.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行提供了与Keymetrics的集成信息。诸如公钥、服务器名称和访问Keymetrics的URL等数据。
- en: In the first table, we can see the name of the application running, as well
    as few statistics on memory, uptime, CPU, and so on.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个表中，我们可以看到正在运行的应用程序的名称，以及有关内存、正常运行时间、CPU等方面的一些统计数据。
- en: In the second table, we can see the information relevant to the `pm2-server-monit`
    PM2 module.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个表中，我们可以看到与`pm2-server-monit` PM2模块相关的信息。
- en: 'Now, let''s go to Keymetrics and see what has happened:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们去Keymetrics看看发生了什么：
- en: '![Diagnosing problems](img/B04889_07_08.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![诊断问题](img/B04889_07_08.jpg)'
- en: The application is now registered in Keymetrics as it can be seen in the control
    panel
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在已经在Keymetrics中注册，可以在控制面板中看到。
- en: As you can see, now our application is showing up in Keymetrics.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，现在我们的应用程序出现在Keymetrics中。
- en: Straightaway, we can see the very useful things about our app. One of these
    is the memory used. This is the metric that will indicate a memory leak, as it
    will keep growing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立刻就能看到我们的应用程序非常有用的东西。其中之一是内存使用情况。这是一个指示内存泄漏的度量标准，因为它会不断增长。
- en: 'Now, we are going to force the memory leak to cause a problem in our application.
    In this case, the only thing that we need to do is start our server (the small
    application that we wrote before) and issue a significant number of requests:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将强制内存泄漏导致我们应用程序出现问题。在这种情况下，我们唯一需要做的就是启动我们的服务器（之前编写的小应用程序）并发出大量的请求：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As simple as the small bash script, this is all it takes to open Pandora''s
    Box in our application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这个小的bash脚本一样，这就是打开我们应用程序潘多拉魔盒所需要的全部：
- en: '![Diagnosing problems](img/B04889_07_09.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![诊断问题](img/B04889_07_09.jpg)'
- en: The application is now showing a high load (36% of CPU and an increased use
    of memory up to 167 MB)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在显示出高负载（36%的CPU使用率和内存使用增加到167 MB）
- en: 'The preceding image shows the impact of running the loop of requests in our
    system. Let''s explain it in the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图片显示了在我们系统中运行请求循环的影响。让我们来解释一下：
- en: The CPU in our application has gone to **11%** with an average loop delay of
    **1.82** milliseconds. Regarding our system, the overall CPU utilization has gone
    up to **36.11%** due to the fact that both the application and bash script use
    a significant amount of resources.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序的CPU已经恢复到11%，平均循环延迟为1.82毫秒。关于我们的系统，由于应用程序和bash脚本都使用了大量资源，整体CPU利用率已经上升到36.11%。
- en: The memory consumption has soared from **81.9 MB** to **167.6 MB**. As you can
    see, the line on the graph of memory allocation is not going straight up, and
    that is due to garbage collections. A garbage collection is an activity within
    the Node.js framework where unreferenced objects are freed from the memory, allowing
    our system to reuse the hardware resources.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存消耗从81.9 MB飙升到167.6 MB。正如你所看到的，内存分配图上的线并不是直线上升的，这是由于垃圾回收造成的。垃圾回收是Node.js框架内的一项活动，它会释放内存中的未引用对象，使我们的系统能够重用硬件资源。
- en: Regarding the errors, our application has been stable with **0** errors (we'll
    come back to this section later).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于错误，我们的应用程序一直稳定，没有错误（我们稍后会回到这一部分）。
- en: 'Now, once our bash script is finished (I stopped it manually, as it can take
    a significant amount of resources and time to finish), we can again see what happened
    to our system in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们的bash脚本完成（我手动停止了它，因为它可能需要大量资源和时间才能完成），我们可以再次看到我们系统发生了什么，如下截图所示：
- en: '![Diagnosing problems](img/B04889_07_10.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![诊断问题](img/B04889_07_10.jpg)'
- en: We can see that the CPU has gone back to normal, but what about the memory?
    The memory consumed by our application hasn't been freed due to the fact that
    our program has a memory leak, and as long as our variable is referencing the
    memory consumed (remember the `names` array is accumulating more and more names),
    it won't be freed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到CPU已经恢复正常，但内存呢？由于我们的程序存在内存泄漏，导致应用程序消耗的内存没有被释放，只要我们的变量引用了已消耗的内存（记住`names`数组正在积累越来越多的名字），它就不会被释放。
- en: In this case, we have a very simple example that clearly shows where the memory
    leak is, but in complex applications, it is not always obvious. This error, in
    particular, could never show up as a problem due to the fact that we probably
    deploy new versions of our app often enough to not realize it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个非常简单的例子，清楚地显示了内存泄漏的位置，但在复杂的应用程序中，情况并不总是那么明显。特别是这种错误可能永远不会成为问题，因为我们可能经常部署新版本的应用程序而没有意识到它。
- en: Monitoring application exceptions
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控应用程序异常
- en: Application errors are events that occur when our application can't handle an
    unexpected situation. Things such as dividing a number by zero or trying to access
    an undefined property of our application usually leads to these type of problems.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序错误是在我们的应用程序无法处理意外情况时发生的事件。诸如将一个数字除以零或尝试访问应用程序的未定义属性通常会导致这类问题。
- en: When working on a multithreaded framework (language) such as Tomcat, the fact
    that one of our threads dies due to an exception usually only affects to one customer
    (the one holding the thread). However, in Node.js, a bubbled exception could be
    a significant problem as our application dies.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用多线程框架（语言）如Tomcat时，一个线程由于异常而死亡通常只会影响一个客户（持有该线程的客户）。然而，在Node.js中，一个冒泡的异常可能是一个重大问题，因为我们的应用程序会死掉。
- en: PM2 and Seneca do a very good job at keeping it alive as PM2 will restart our
    app if something makes it stop, and Seneca won't let the application die if an
    exception occurs in one of the actions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: PM2和Seneca在保持应用程序运行方面做得非常好，如果有什么原因导致应用程序停止，PM2会重新启动我们的应用程序，而Seneca则不会让应用程序在某个操作发生异常时死掉。
- en: 'Keymetrics has developed a module called **pmx** that we can use to programmatically
    get alerts on errors:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Keymetrics开发了一个名为**pmx**的模块，我们可以使用它来以编程方式获取错误警报：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is easy and self-descriptive: an action that sends an exception to Keymetrics
    if the number sent as a parameter is zero. If we run it, we will get the following
    output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易且自我描述：如果作为参数发送的数字为零，则会向Keymetrics发送异常的操作。如果我们运行它，我们将得到以下输出：
- en: '![Monitoring application exceptions](img/B04889_07_11.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![监控应用程序异常](img/B04889_07_11.jpg)'
- en: 'Now we need to hit the server in order to cause the error. As we did earlier,
    we will do this using curl:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要访问服务器以引发错误。与之前一样，我们将使用curl来执行：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, when we go to Keymetrics, we can see that there is an error logged, as
    shown in the following image:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们转到Keymetrics时，我们可以看到有一个错误日志，如下图所示：
- en: '![Monitoring application exceptions](img/B04889_07_12.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![监控应用程序异常](img/B04889_07_12.jpg)'
- en: Another interesting point of Keymetrics is the configuration of alerts. As PM2
    sends data about pretty much every metric in our system, we have the ability to
    configure Keymetrics on the thresholds that we consider healthy for our application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Keymetrics的另一个有趣之处是警报的配置。由于PM2发送了关于系统中几乎每个指标的数据，我们有能力根据我们认为对我们的应用程序健康的阈值来配置Keymetrics。
- en: This is very handy as we could get the notifications integrated in our corporate
    chat (something similar to **Slack**) and be alerted real time when something
    is not going correctly in our application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，因为我们可以将通知集成到我们的企业聊天中（类似于**Slack**），并在我们的应用程序出现问题时实时收到警报。
- en: Custom metrics
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义指标
- en: Keymetrics also allows us to use **probes**. A probe is a custom metric that
    is sent programmatically by the application to Keymetrics.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Keymetrics还允许我们使用**探针**。探针是应用程序通过编程方式发送到Keymetrics的自定义指标。
- en: There are different types of values that the native library from Keymetrics
    allows us to push directly. We are going to see the most useful ones.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Keymetrics的本机库允许我们直接推送不同类型的值。我们将看到最有用的值。
- en: Simple metric
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单指标
- en: 'A simple metric is, as its name indicates, a very basic metric where the developer
    can set the value to the data sent to Keymetrics:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 简单指标就像其名称所示，是一个非常基本的指标，开发人员可以将值设置为发送到Keymetrics的数据：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, the metric will send the time when the action was called for
    the last time to the Keymetrics:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，该指标将发送上次调用操作的时间给Keymetrics：
- en: '![Simple metric](img/B04889_07_13.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![简单指标](img/B04889_07_13.jpg)'
- en: 'The configuration for this metric is non-existent:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该指标的配置不存在：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is no complexity in this metric.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指标没有复杂性。
- en: Counter
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计数器
- en: 'This metric is very useful to count how many times an event occurred:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该指标非常有用，可以计算事件发生的次数：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we can see how the counter is incremented for every single
    call to the action counter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以看到每次调用操作计数器都会递增。
- en: 'This metric will also allow us to decrement the value calling the `dec()` method
    on the counter:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该指标还允许我们通过在计数器上调用`dec()`方法来递减值：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Average calculated values
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 平均计算值
- en: 'This metric allows us to record when an event occurs, and it will automatically
    calculate the number of events per time unit. It is quite useful to calculate
    averages and is a good tool to measure the load in the system. Let''s see a simple
    example, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该指标允许我们记录事件发生的时间，并将自动计算每个时间单位的事件数量。它非常有用于计算平均值，并且是衡量系统负载的好工具。让我们看一个简单的例子，如下所示：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code creates a probe and sends a new metric called `Calls per
    minute` to Keymetrics.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个探针，并将一个名为`每分钟调用`的新指标发送到Keymetrics。
- en: 'Now, if we run the application and the following command a few times, the metric
    is shown in the following Keymetrics interface:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行应用程序并多次运行以下命令，该指标将显示在以下Keymetrics界面中：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Average calculated values](img/B04889_07_14.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![平均计算值](img/B04889_07_14.jpg)'
- en: 'As you can see, there is a new metric called `Calls per minute` in the UI.
    The key to configure this metric is in the following initialization:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，UI中有一个名为`每分钟调用`的新指标。配置此指标的关键在以下初始化中：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, the name of the metric is in the configuration dictionary as
    well as in two parameters: `samples` and `timeframe`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，指标的名称在配置字典中，以及在两个参数中：`samples`和`timeframe`。
- en: The `samples` parameter correspond to the interval where we want to rate the
    metric; in this case, it is the number of calls per minute so that rate is `60`
    seconds.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`samples`参数对应于我们希望对指标进行评分的间隔；在这种情况下，是每分钟的调用次数，因此速率是`60`秒。'
- en: The `timeframe` parameter, on the other hand, is for how long we want Keymetrics
    to hold the data for, or to express in simpler words, it is the timeframe over
    which the metric will be analyzed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`timeframe`参数是我们希望Keymetrics保存数据的时间，或者简单地说，它是分析指标的时间范围。
- en: Simian Army – the active monitoring from Spotify
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猿人军队 - Spotify的主动监控
- en: '**Spotify** is one of the companies of reference when building microservices-oriented
    applications. They are extremely creative and talented when it boils down to coming
    up with new ideas.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spotify**是构建面向微服务的应用程序时的参考公司之一。他们在提出新想法时非常有创意和才华横溢。'
- en: One of my favourite ideas among them is what they call the **Simian Army**.
    I like to call it **active monitoring**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我最喜欢的想法之一是他们所谓的**猿人军队**。我喜欢称之为**主动监控**。
- en: In this book, I have talked a lot times about how humans fail at performing
    different tasks. No matter how much effort you put in to creating your software,
    there are going to be bugs that will compromise the stability of the system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我多次谈到人类在执行不同任务时的失败。无论你付出多少努力来创建你的软件，都会有bug会影响系统的稳定性。
- en: This is a big problem, but it becomes a huge deal when, with the modern cloud
    providers, your infrastructure is automated with a script.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大问题，但当您的基础设施与现代云提供商自动化时，它变得非常重要。
- en: Think about it, what happens if in a pool of thousand servers, three of them
    have the *time zone out of sync* with the rest of the servers? Well, depending
    on the nature of your system, it could be fine or it could be a big deal. Can
    you imagine your bank giving you a statement with disordered transactions?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看，如果在一千台服务器中，有三台的时区与其他服务器不同步会发生什么？嗯，根据你的系统性质，这可能没问题，也可能是个大问题。你能想象你的银行给你提供了一份交易混乱的对账单吗？
- en: Spotify has solved (or mitigated) the preceding problem by creating a number
    of software agents (a program that moves within the different machines of our
    system), naming them after different species of monkeys with different purposes
    to ensure the robustness of their infrastructure. Let's explain it a bit further.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Spotify通过创建一系列软件代理（在我们系统的不同机器中移动的程序）来解决（或减轻）上述问题，给它们取了不同种类的猴子的名字，目的是确保他们基础设施的稳健性。让我们进一步解释一下。
- en: 'As you are probably aware, if you have worked before with Amazon Web Services,
    the machines and computational elements are divided in to regions (EU, Australia,
    USA, and so on) and inside every region, there are availability zones, as shown
    in the following diagram:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，如果你之前使用过亚马逊网络服务，机器和计算元素被划分到了不同的区域（欧盟、澳大利亚、美国等），每个区域内有可用区，如下图所示：
- en: '![Simian Army – the active monitoring from Spotify](img/B04889_07_15.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Simian Army – the active monitoring from Spotify](img/B04889_07_15.jpg)'
- en: This enables us, the engineers, to create software and infrastructure without
    hitting what we call a single point of failure.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们工程师能够创建软件和基础设施，而不会遇到我们所说的单点故障。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注：
- en: A **single point of failure** is a condition in a system where the failure of
    a single element will cause the system to misbehave.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**单点故障**是系统中的一个条件，其中一个元素的故障会导致系统运行不正常。'
- en: 'This configuration raised a number of questions to the engineers in Spotify,
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置给Spotify的工程师们提出了一些问题，如下：
- en: What happens if we blindly trust our design without testing whether we actually
    have any point of failures or not?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们盲目相信我们的设计，而没有测试我们是否真的有任何单点故障，会发生什么？
- en: What happens if a full availability zone or region goes down?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个完整的可用区或区域宕机会发生什么？
- en: How is our application going to behave if there is an abnormal latency for some
    reason?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由于某种原因出现异常延迟，我们的应用程序会如何表现？
- en: 'To answer all these questions, Netflix has created various agents. An agent
    is a software that runs on a system (in this case, our microservices system) and
    carries on different operations such as checking the hardware, measuring the network
    latency, and so on. The idea of agent is not new, but until now, its application
    was nearly a futuristic subject*.* Let''s take a look at the following agents
    created by Netflix:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答所有这些问题，Netflix创建了各种代理。代理是在系统上运行的软件（在这种情况下，是我们的微服务系统），并进行不同的操作，比如检查硬件，测量网络延迟等。代理的概念并不新鲜，但直到现在，它的应用几乎是一个未来主题。让我们来看看Netflix创建的以下代理：
- en: '**Chaos Monkey**: This agent disconnects healthy machines from the network
    in a given availability zone. This ensures that there are *no single points of
    failures within an availability zone*. So that if our application is balanced
    across four nodes, when the Chaos Monkey kicks in, it will disconnect one of these
    four machines.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混沌猴**：这个代理会在给定的可用区中断开健康的机器与网络的连接。这确保了在一个可用区内没有单点故障。所以，如果我们的应用程序在四个节点之间平衡，当混沌猴出现时，它会断开这四台机器中的一台。'
- en: '**Chaos Gorilla**: This is similar to Chaos Monkey, Chaos Gorilla will disconnect
    a full availability zone in order to verify that Netflix services rebalance to
    the other available zones. In other words, Chaos Gorilla is the big brother of
    Chaos Monkey; instead of operating at the server level, it operates at the partition
    level.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混沌大猩猩**：这类似于混沌猴，混沌大猩猩会断开一个完整的可用区，以验证Netflix服务是否会重新平衡到其他可用区。换句话说，混沌大猩猩是混沌猴的大哥；它不是在服务器级别操作，而是在分区级别操作。'
- en: '**Latency Monkey**: This agent is responsible for introducing artificial latencies
    in the connections. Latency is usually something that is hardly considered when
    developing a system, but it is a very delicate subject when building a microservices
    architecture: latency in one node could compromise the quality of the full system.
    When a service is running out of resources, usually the first indication is the
    latency in the responses; therefore, Latency Monkey *is a good way to find out
    how our system will behave under pressure*.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟猴**：这个代理负责在连接中引入人为的延迟。在开发系统时，通常很少考虑延迟，但在构建微服务架构时，延迟是一个非常微妙的问题：一个节点的延迟可能会影响整个系统的质量。当一个服务资源不足时，通常第一个迹象就是响应的延迟；因此，延迟猴是一个很好的方法，可以找出我们的系统在压力下会如何表现。'
- en: '**Doctor Monkey**: A health check is an endpoint in our application that returns
    an HTTP 200 if everything is correct and 500 error code if there is a problem
    within the application. Doctor Monkey is an agent that will randomly execute the
    health check of nodes in our application and report the faulty ones in order to
    replace them.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**医生猴**：健康检查是我们应用程序中的一个端点，如果一切正常就返回HTTP 200，如果应用程序内部出现问题就返回500错误代码。医生猴是一个代理，会随机执行我们应用程序中节点的健康检查，并报告有问题的节点以便替换它们。'
- en: '**10-18 Monkey**: Organizations such as Netflix are global, so they need to
    be language-aware (certainly, you don''t want to get a website in German when
    your mother tongue is Spanish). The 10-18 Monkey reports on instances that are
    misconfigured.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10-18 Monkey**：像Netflix这样的组织是全球性的，因此它们需要具备语言意识（当然，如果你的母语是西班牙语，你肯定不希望在德语网站上）。10-18
    Monkey报告了配置错误的实例。'
- en: There are a few other agents, but I just want to explain active monitoring to
    you. Of course, this type of monitoring is out of reach of small organizations,
    but it is good to know about their existence so that we can get inspired to set
    up our monitoring procedures.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他代理，但我只想向你解释一下主动监控。当然，这种类型的监控对于小型组织来说是难以企及的，但了解它们的存在是很好的，这样我们就可以受到启发，建立我们自己的监控程序。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code is available under Apache License in the following repository:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码在以下存储库中以Apache许可证提供：
- en: '[https://github.com/Netflix/SimianArmy](https://github.com/Netflix/SimianArmy).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Netflix/SimianArmy](https://github.com/Netflix/SimianArmy)。'
- en: In general, this active monitoring follows the philosophy of *fail early*, of
    which, I am a big adept. No matter how big the flaw in your system is or how critical
    it is, you want to find it sooner than later, and ideally, without impacting any
    customer.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这种主动监控遵循“尽早失败”的理念，我非常赞同。无论你的系统有多大的缺陷或者有多重要，你都希望尽早发现它，理想情况下，不影响任何客户。
- en: Throughput and performance degradation
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 吞吐量和性能下降
- en: Throughput is to our application what the monthly production is to a factory.
    It is a unit of measurement that gives us an indication about how our application
    is performing and answers the *how many* question of a system.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量对我们的应用程序来说就像月度生产对工厂一样。这是一个衡量单位，可以让我们了解我们的应用程序的表现，并回答系统的“有多少”问题。
- en: 'Very close to throughput, there is another unit that we can measure: **latency**.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在吞吐量附近，还有另一个我们可以衡量的单位：延迟。
- en: Latency is the performance unit that answers the question of *how long*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是回答“多长时间”的性能单位。
- en: 'Let''s consider the following example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下例子：
- en: 'Our application is a microservices-based architecture that is responsible for
    calculating credit ratings of applicants to withdraw a mortgage. As we have a
    large volume of customers (a nice problem to have), we have decided to process
    the applications in batches. Let''s draw a small algorithm around it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序是基于微服务架构的，负责计算申请人的信用评级以提取抵押贷款。由于我们有大量的客户（这是一个很好的问题），我们决定批量处理申请。让我们围绕它画一个小算法：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a small and simple Seneca application (this is only theoretical, don''t
    try to run it as there is a lot of code missing!) that acts as a client for two
    other microservices, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小而简单的Seneca应用程序（这只是理论上的，不要试图运行它，因为缺少很多代码！），它作为另外两个微服务的客户端，如下所示：
- en: The first one gets the list of pending applications for mortgages
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个获取待处理的抵押贷款申请列表
- en: The second one gets the list of credit rating for the customers that we have
    requested
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个获取我们请求的客户的信用评级列表
- en: This could be a real situation for processing mortgage applications. In all
    fairness, I worked on a very similar system in the past, and even though it was
    a lot more complex, the workflow was very similar.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是处理抵押贷款申请的真实情况。说实话，我过去曾经在一个非常类似的系统上工作过，即使它更加复杂，工作流程也非常相似。
- en: 'Let''s talk about throughput and latency. Imagine that we have a fairly big
    batch of mortgages to process and the system is misbehaving: the network is not
    being as fast as it should and is experiencing some dropouts.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈吞吐量和延迟。想象一下，我们有一大批抵押贷款要处理，但系统表现不佳：网络速度不如预期快，出现了一些中断。
- en: Some of these applications will be lost and will need to be retried. In ideal
    conditions, our system is producing a throughput of 500 applications per hour
    and takes an average of 7.2 seconds on latency to process every single application.
    However, today, as we stated before, the system is not at its best; we are processing
    only 270 applications per hour and takes on average 13.3 seconds to process a
    single mortgage application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些应用程序将丢失并需要重试。在理想条件下，我们的系统每小时产生500个应用程序的吞吐量，并且平均需要7.2秒的延迟来处理每个应用程序。然而，今天，正如我们之前所述，系统并不处于最佳状态；我们每小时只处理270个应用程序，并且平均需要13.3秒来处理一个抵押贷款申请。
- en: As you can see, with latency and throughput, we can measure how our business
    transactions are behaving with respect to the previous experiences; we are operating
    at 54% of our normal capacity.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过延迟和吞吐量，我们可以衡量我们的业务交易相对于以前的经验表现如何；我们的运行能力只有正常能力的54%。
- en: This could be a serious issue. In all fairness, a drop off like this should
    ring all the alarms in our systems as something really serious is going on in
    our infrastructure; however, if we have been smart enough while building our system,
    the performance will be degraded, but our system won't stop working. This can
    be easily achieved by the usage of circuit breakers and queueing technologies
    such as **RabbitMQ**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个严重的问题。说实话，这种中断应该在我们的系统中引起所有警报，因为我们的基础设施中确实发生了非常严重的问题；然而，如果我们在构建系统时足够聪明，性能会下降，但系统不会停止工作。这可以通过使用断路器和队列技术（如RabbitMQ）轻松实现。
- en: Queueing is one of the best examples to show how to apply human behavior to
    an IT system. Seriously, the fact that we can easily decouple our software components
    having a simple message as a joint point, which our services either produce or
    consume, gives us a big advantage when writing complex software.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一个很好的例子，展示了如何将人类行为应用到IT系统中。说真的，我们可以很容易地解耦我们的软件组件，只需一个简单的消息作为连接点，我们的服务要么产生，要么消费，这在编写复杂软件时给我们带来了很大的优势。
- en: Other advantage of queuing over HTTP is that an HTTP message is lost if there
    is a network drop out.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 队列与HTTP相比的另一个优势是，如果网络中断，HTTP消息就会丢失。
- en: 'We need to build our application around the fact that it is either full success
    or error. With queueing technologies such as RabbitMQ, our messaging delivery
    is asynchronous so that we don''t need to worry about intermittent failures: *as
    soon as we can deliver the message to the appropriate queue, it will get persisted
    until the client is able to consume it (or the message timeout occurs)*.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要围绕这样一个事实构建我们的应用程序，即它要么完全成功，要么出现错误。使用RabbitMQ等排队技术，我们的消息传递是异步的，因此我们不需要担心间歇性故障：*一旦我们能够将消息传递到适当的队列，它将被持久化，直到客户端能够消费它（或者消息超时发生）*。
- en: This enables us to account for intermittent errors in the infrastructure and
    build even more robust applications based on the communication around queues.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够考虑基础设施中的间歇性错误，并基于队列周围的通信构建更加健壮的应用程序。
- en: 'Again, Seneca makes our life very easy: the plugin system on which the Seneca
    framework is built makes writing a transport plugin a fairly simple task.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Seneca让我们的生活变得非常简单：Seneca框架构建的插件系统使编写传输插件成为一项相当简单的任务。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'RabbitMQ transport plugin can be found in the following GitHub repository:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ传输插件可以在以下GitHub存储库中找到：
- en: '[https://github.com/senecajs/seneca-rabbitmq-transport](https://github.com/senecajs/seneca-rabbitmq-transport)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/senecajs/seneca-rabbitmq-transport](https://github.com/senecajs/seneca-rabbitmq-transport)'
- en: There are quite few transport plugins and we can also create our own ones (or
    modify the existing ones!) to satisfy our needs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有相当多的传输插件，我们也可以创建我们自己的插件（或修改现有的插件！）来满足我们的需求。
- en: 'If you take a quick look at the RabbitMQ plugin (just as an example), the only
    thing that we need to do to write a transport plugin is overriding the following
    two Seneca actions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你快速浏览一下RabbitMQ插件（只是举个例子），我们需要做的唯一一件事就是覆盖以下两个Seneca操作：
- en: '`seneca.add({role: ''transport'', hook: ''listen'', type: ''rabbitmq''}, ...)`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seneca.add({role: ''transport'', hook: ''listen'', type: ''rabbitmq''}, ...)`'
- en: '`seneca.add({role: ''transport'', hook: ''client'', type: ''rabbitmq''}, ...)`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seneca.add({role: ''transport'', hook: ''client'', type: ''rabbitmq''}, ...)`'
- en: Using queueing technologies, our system will be *more resilient against intermittent
    failures* and we would be able to degrade the performance instead of heading into
    a catastrophic failure due to missing messages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用排队技术，我们的系统将*更加抗干扰*，我们将能够降低性能而不是因为丢失消息而陷入灾难性的故障。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we deep dived into PM2 monitoring through Keymetrics. We learned
    how to put tight monitoring in place so that we are quickly informed about the
    failures in our application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了通过Keymetrics进行PM2监控。我们学会了如何进行严格的监控，以便我们能够迅速了解应用程序中的故障。
- en: 'In the software development life cycle, the **QA** phase is, in my opinion,
    one of the most important one: no matter how good your code looks, if it does
    not work, it is useless. However, if I have to choose another phase where engineers
    should put more emphasis, it would be the deployment, and more specifically, the
    monitoring that is carried out after every deployment. If you receive error reports
    immediately, chances are that the reaction can be quick enough to avoid bigger
    problems such as corrupted data or customers complaining.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发生命周期中，**QA**阶段，在我看来，是最重要的阶段之一：无论你的代码看起来多么好，如果它不起作用，那就是无用的。然而，如果我必须选择另一个阶段，工程师应该更加重视的是部署，更具体地说，是在每次部署后进行的监控。如果你立即收到错误报告，那么很有可能能够迅速做出反应，避免更大的问题，比如数据损坏或客户抱怨。
- en: We also saw an example of active monitoring carried out by Netflix on their
    systems, which even though might be out of the reach of your company, it can spark
    good ideas and practices in order to monitor your software.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了Netflix在其系统上进行的主动监控的例子，尽管这可能超出了你公司的范围，但它可以激发出对监控软件的好想法和实践。
- en: Keymetrics is just an example that fits the bill for Node.js as it is extremely
    well integrated with PM2, but there are also other good monitoring systems such
    as **AppDynamics**, or if you want to go for an in-house software, you could use
    Nagios. The key is being clear about what you need to monitor in the application,
    and then, find the best provider.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Keymetrics只是一个符合Node.js要求的例子，因为它与PM2集成非常好，但也有其他好的监控系统，比如**AppDynamics**，或者如果你想使用内部软件，你可以使用Nagios。关键是要清楚地知道需要监控应用程序中的内容，然后找到最好的提供者。
- en: Another two good options for monitoring Node.js apps are StrongLoop and New
    Relic. They are both on the same line with Keymetrics, but they work better for
    large-scale systems, especially StrongLoop, which is oriented to applications
    written in Node.js and oriented to microservices.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 监控Node.js应用程序的另外两个好选择是StrongLoop和New Relic。它们与Keymetrics处于同一水平线，但对于大规模系统来说效果更好，特别是StrongLoop，它专门针对使用Node.js编写的应用程序和微服务。
