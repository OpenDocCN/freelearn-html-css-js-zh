- en: Chapter 3. Giving Forms the Knockout Touch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 给表单添加Knockout触摸感
- en: 'Two of the oldest uses of the web are sharing and gathering information. This
    exchange includes the use of form and non-form elements. In this chapter, we will
    learn how to streamline coding and user interaction using the following focus
    areas:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上最古老的使用之一是分享和收集信息。这种交换包括表单和非表单元素的使用。在本章中，我们将学习如何通过以下重点领域来简化编码和用户交互：
- en: Event binding
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件绑定
- en: Text binding
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本绑定
- en: The textInput binding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本输入绑定
- en: Web 3.0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 3.0
- en: Radio and checkbox binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单选框和复选框绑定
- en: Select binding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择绑定
- en: Grid forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格表单
- en: Event binding
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件绑定
- en: Let me start off by saying that I have not tested every type of event that can
    be bound to Knockout, but there are tons of events in HTML, or rather DOM, that
    can be tested. It seems with HTML5-friendly browsers the number of the browsers
    available to us has increased. I would suggest that you make sure that you test
    to validate if any newer events are actually available on the platform you are
    targeting.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先说，我没有测试Knockout可以绑定的每种类型的事件，但HTML（或者更确切地说，DOM）中有大量的事件可以测试。似乎随着HTML5友好浏览器的增加，我们可用的浏览器数量也在增加。我建议你确保测试以验证是否有任何新事件实际上在目标平台上可用。
- en: When we bind an event it requires a handler. These handlers are either functions
    or methods on objects. The functions can be part of the ViewModel or external
    to the scope of the ViewModel. As a reminder, when functions are part of the ViewModel
    we can assign the function method without `( )`. If we are passing arguments then
    we would, of course, use them, even if they were part of the ViewModel.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绑定一个事件时，它需要一个处理程序。这些处理程序要么是函数，要么是对象上的方法。函数可以是ViewModel的一部分，也可以在ViewModel的作用域之外。提醒一下，当函数是ViewModel的一部分时，我们可以不使用`(
    )`来分配函数方法。如果我们传递参数，当然我们会使用它们，即使它们是ViewModel的一部分。
- en: Common events we would look for in the View would include `click`, `keypress`,
    `mouseover`, and `mouseout`. There are many other events, but that is enough of
    a list to give you an idea of what events are, if this is a new concept to you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中我们可能会寻找的常见事件包括`click`、`keypress`、`mouseover`和`mouseout`。还有很多其他事件，但这个列表已经足够让你了解事件是什么，如果你对这个概念是新手的话。
- en: The binding markup
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定标记
- en: 'We will start by creating the HTML for our page. Create a file named `enable.html`
    for this example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建我们页面的HTML。为这个示例创建一个名为`enable.html`的文件：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We see the `data-bind` attribute has an event declaration in this code. We are
    going to bind the two first elements to the `mouseover` event. `oneLeft` is a
    function that the binding calls when the mouse is over the element. We see again
    that `( )` is not needed because we will be creating the function as part of the
    ViewModel.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到在这段代码中`data-bind`属性有一个事件声明。我们将把前两个元素绑定到`mouseover`事件上。`oneLeft`是一个当鼠标悬停在元素上时绑定会调用的函数。我们再次看到`(
    )`是不需要的，因为我们将会在ViewModel的一部分创建这个函数。
- en: 'The middle two `div` tags here have the element''s class, the CSS attribute,
    set by the Knockout `data-bind` attribute. This would be a good time for us to
    create our extra classes before we do the code side of the work. Here is the CSS
    code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里中间的两个`div`标签具有元素的类，CSS属性，由Knockout的`data-bind`属性设置。这可能是我们创建额外类的好时机，在我们进行代码方面的工作之前。以下是CSS代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are two very simple float classes. The first two declarations in our ViewModel
    will be observables holding the value of our classes assigned to these elements.
    Note that we are declaring these as classes, so do not start the class name with
    a period. The CSS assumes this is the case.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是两个非常简单的浮动类。在ViewModel中的前两个声明将是观察者，它们持有分配给这些元素的类的值。注意，我们声明这些为类，所以不要以点开始类名。CSS假设这是这种情况。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we look back at our HTML markup code, we see the events are not mouseover
    but rather mousedown and mouseup. These ViewModel event handlers, also known as
    functions, will call the methods to manage the **(Two)** item in the box on the
    browser page. Let''s add the code for both sets of handlers:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾我们的HTML标记代码，我们看到事件不是mouseover，而是mousedown和mouseup。这些ViewModel事件处理程序，也称为函数，将调用方法来管理浏览器页面上的框中的**(Two**)项。让我们添加这两组处理程序的代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All we are doing is changing the text of the ViewModel elements as this will
    change the bound CSS to match. This will, of course, shift the assigned element
    to float left or right on the page. Here is the complete code for this example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是更改ViewModel元素的文本，因为这会更改绑定的CSS以匹配。当然，这将使分配的元素在页面上浮动到左边或右边。以下是这个示例的完整代码：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now run the code in the browser and you should see the **(One)** element shifting
    left and right when hovering over the items above the box. You will have to actually
    click the items below the box to get them to take action.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中运行代码，你应该会看到当鼠标悬停在盒子上面的项目上时，**(One**) 元素会左右移动。你将需要实际点击盒子下面的项目来使它们执行动作。
- en: '![The binding markup](img/1028OS_03_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![绑定标记](img/1028OS_03_01.jpg)'
- en: It would be great if we could get the book to show you the results. Perhaps
    in e-books in the future that will be possible, but for now we will stay old school
    and actually enter the code and test it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能拿到这本书来展示结果给您看那就太好了。也许在未来的电子书中这将变得可能，但就目前而言，我们将保持传统方式，实际上输入代码并测试它。
- en: The binding checkbox with visibility
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定可见性的复选框
- en: In this example we will create a file named `event.html` and copy the `_base.html`
    to save time. We will be looking at parameters and doing something in a very elegant
    way that was too much work for a simple task in JavaScript. jQuery made JavaScript
    coding better but Knockout brings binding simplicity that we all needed from the
    start.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个名为 `event.html` 的文件，并将 `_base.html` 复制过来以节省时间。我们将查看参数，并以一种非常优雅的方式完成任务，这在
    JavaScript 中是一个过于繁琐的任务。jQuery 让 JavaScript 编码变得更好，但 Knockout 带来了我们从一开始就需要的绑定简单性。
- en: Next, we will create the markup for our example. We see the `data-bind` this
    time is connected to the checked value changing. The second input box is tied
    to the same ViewModel item, `bringingSpouse`. The second input stores the value
    entered into the ViewModel item, `spouseName`. When first loading the page it
    will not store anything because the input box will be disabled.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的示例创建标记。这次我们看到 `data-bind` 与复选框的值变化相关联。第二个输入框与同一个 ViewModel 项目 `bringingSpouse`
    相关联。第二个输入框存储输入到 ViewModel 项目 `spouseName` 中的值。当首次加载页面时，它不会存储任何内容，因为输入框将被禁用。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![The binding checkbox with visibility](img/1028OS_03_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![绑定可见性的复选框](img/1028OS_03_02.jpg)'
- en: This is the code to drive the automated logic. It just takes two observables;
    one to hold the value for the spouse's name and the other to handle true or false,
    to toggle the input box when the user has a spouse.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是驱动自动化逻辑的代码。它只需要两个可观察对象；一个用于保存配偶的名字的值，另一个用于处理真或假，当用户有配偶时切换输入框。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can test our code to see how this works. It is as simple as clicking
    on the checkbox, following which the input box should become usable and ready
    for you to enter your spouse''s name, if that applies to you, of course:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试我们的代码，看看它是如何工作的。这就像点击复选框一样简单，之后输入框应该变得可使用，并准备好让您输入配偶的名字，当然，如果适用的话：
- en: '![The binding checkbox with visibility](img/1028OS_03_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![绑定可见性的复选框](img/1028OS_03_03.jpg)'
- en: Modifier keys
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修饰键
- en: 'We are going to revisit our `enable.html` file and learn a little how to deal
    with some modified events. In our case, we will be looking at spotting the event
    when the *Shift* key is pressed. If *Shift* is pressed we will handle the event
    one way and if not, we will handle it another way. First, let''s add a reset button
    to the screen with this HTML code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新访问我们的 `enable.html` 文件，并学习如何处理一些修改过的事件。在我们的例子中，我们将关注当按下 *Shift* 键时检测事件。如果按下
    *Shift* 键，我们将以一种方式处理事件，如果没有按下，我们将以另一种方式处理。首先，让我们使用以下 HTML 代码在屏幕上添加一个重置按钮：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will add the highlighted code in the `script` section of the page:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加页面 `script` 部分中高亮的代码：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we hover the mouse over the new button with the *Shift* key pressed, it
    will pull up an alert box similar to this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下 *Shift* 键并将鼠标悬停在新的按钮上时，它将弹出一个类似于这样的警告框：
- en: '![Modifier keys](img/1028OS_03_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![修饰键](img/1028OS_03_04.jpg)'
- en: Default actions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认动作
- en: By default, Knockout prevents the built-in standard browser events from taking
    place. If you want to let these events run, just bind a handler to the event that
    returns true.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Knockout 阻止内置的标准浏览器事件发生。如果你想让这些事件运行，只需绑定一个返回 true 的处理程序到该事件。
- en: Preventing bubbling
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻止冒泡
- en: Another thing you may want to do is to prevent event bubbling. **Bubbling**
    means that an element on the web page, also called the DOM element, has a chain
    relationship with what we will call higher-level elements. After an item has had
    an opportunity to handle an event, the events are then passed up the chain to
    allow a higher element an opportunity to respond to the event.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想防止事件冒泡。**冒泡**意味着网页上的一个元素，也称为 DOM 元素，与我们所说的更高级元素之间存在链式关系。在项目有机会处理事件之后，事件随后会沿着链向上传递，以便允许更高层级的元素有机会对事件做出响应。
- en: In our mouseover example, there could have been an area of the page wrapping
    the button that also had a mouseover handler. If there was, after the button handled
    the event, the event would have been passed to the higher element to allow it
    to respond to the event as well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的鼠标悬停示例中，页面上可能有一个包含按钮的鼠标悬停处理器的区域。如果有，在按钮处理事件后，事件会被传递给更高层元素，以便它也能响应该事件。
- en: Control is actually very simple. We only need to prevent the event by telling
    our button handler to return false. Of course, in a different scenario, for the
    event action which you don't want to go beyond, you would have set its handler
    return false value just like the button in our use case example we are discussing
    here.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 控制实际上非常简单。我们只需要通过告诉我们的按钮处理程序返回false来阻止事件。当然，在不同的场景中，对于你不希望超出的事件操作，你会在其处理程序中设置返回false值，就像我们在这里讨论的使用案例中的按钮一样。
- en: The textInput binding
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: textInput绑定
- en: 'We have obviously done a number of bindings to textboxes already. Now, we are
    going to do something new with them. We are going to put a text input and a text
    area on the page together. Here is our HTML markup, where we will put in a new
    file called `text.html`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然已经对文本框做了很多绑定。现在，我们将对它们做一些新的操作。我们将在页面上放置一个文本输入和一个文本区域。以下是我们的HTML标记，我们将在这里放入一个名为`text.html`的新文件：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we were using the value binding we would only get an update when the input
    element lost focus. Using the `textInput` binding let us have character by character
    feedback. Let''s add our code so we can try it out:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用值绑定，我们只有在输入元素失去焦点时才会得到更新。使用`textInput`绑定，我们可以逐个字符得到反馈。让我们添加我们的代码，以便我们可以尝试它：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![The textInput binding](img/1028OS_03_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![The textInput binding](img/1028OS_03_05.jpg)'
- en: 'We see the page content updating character by character as we type but there
    is an issue. The text in the **Post** is coming into the page as text. There is
    a simple way to fix that. We just change the content target from `text` to `html`.
    Oh, and make sure you use small letters or you will have an issue. Now, run it
    again and it should look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当我们输入时，页面内容逐个字符更新，但存在一个问题。**Post**中的文本是以文本形式进入页面的。有一个简单的方法可以解决这个问题。我们只需将内容目标从`text`更改为`html`。哦，并且确保你使用小写字母，否则你会遇到问题。现在，再次运行它，它应该看起来像这样：
- en: '![The textInput binding](img/1028OS_03_06.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![The textInput binding](img/1028OS_03_06.jpg)'
- en: Dynamic focus
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态焦点
- en: 'There are many opportunities to enhance user experience when doing dynamic
    AJAX style sites. Years ago, a website was a dead experience compared to the power
    you could add to a desktop application. Today, the more dynamic application is
    left up to the creative ability of the designers and developers on each platform.
    Changing the user interface to be more responsive creates a virtual relationship
    between the user and your page. Make use of the following steps to make your page
    dynamic:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行动态AJAX风格网站时，有许多机会可以增强用户体验。多年前，与桌面应用程序相比，网站是一个死气沉沉的体验。今天，更动态的应用主要取决于每个平台的设计师和开发者的创造力。将用户界面改为更响应式，在用户和你的页面之间建立了一种虚拟关系。利用以下步骤使你的页面动态化：
- en: 'The first thing we will do is change the `data-bind` attribute on the title
    of the text input. By adding a comma we can have more than one data binding on
    an element. We will add the `hasFocus` binder to the input, and target the event
    to call the handler that we will name `lookAtTitleBox`. Our input box should now
    look like this in the code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将更改文本输入的`data-bind`属性。通过添加逗号，我们可以在一个元素上添加多个数据绑定。我们将向输入添加`hasFocus`绑定器，并将事件目标指向名为`lookAtTitleBox`的处理程序。现在，我们的输入框在代码中应该看起来像这样：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will add a button after this input box to show the ability to dynamically
    control the focus from code. This means we need to tie an event handler, our function,
    to the click event of the button. Then, we will let the code take care of passing
    control back to the title input box. Add this markup right after our title input
    box:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在这个输入框后面添加一个按钮，以展示从代码中动态控制焦点的功能。这意味着我们需要将事件处理器，我们的函数，绑定到按钮的点击事件上。然后，我们将让代码负责将控制权交还给标题输入框。在标题输入框后添加以下标记：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we will need to add our output text for the View to be displayed when
    the title input has the focus:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加输出文本，以便在标题输入获得焦点时在视图中显示：
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last thing we need to do is modify our ViewModel to make our form more
    interactive. We will add two items: an observable attribute on our ViewModel and
    a method to be called by our View element:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后需要做的是修改我们的ViewModel，使我们的表单更具交互性。我们将添加两个项目：ViewModel上的一个可观察属性和一个由视图元素调用的方法：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the page is reloaded, our title field has the focus, by default. Click
    inside **Post** to remove the focus from the title element. You should see the
    focus text after the button is visible and when the title element has focus. Now,
    when the title element does not have focus, click on the **Focus On Title** button.
    You will see through Knockout that we are able to designate the focus of an element
    by toggling a variable in the ViewModel. This is another example of what makes
    ViewModels in MVVM oriented applications powerful. Here is the output we get when
    the page is reloaded:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面重新加载时，我们的标题字段默认具有焦点。点击**帖子**以从标题元素中移除焦点。你应该在按钮可见后和标题元素具有焦点时看到焦点文本。现在，当标题元素没有焦点时，点击**聚焦于标题**按钮。通过Knockout，你会看到我们能够通过在ViewModel中切换变量来指定元素的焦点。这是ViewModel在MVVM导向的应用程序中强大功能的另一个例子。以下是页面重新加载时我们得到的输出：
- en: '![Dynamic focus](img/1028OS_03_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![动态焦点](img/1028OS_03_07.jpg)'
- en: 'Our complete code for this logic should look like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此逻辑的完整代码如下所示：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Take a moment and look at the elegant simplicity of this code. This is why many
    Knockout coders feel like what jQuery did for JavaScript, Knockout does as much
    to enhance the design and development experience.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 抽空看看这段代码的优雅简洁。这就是为什么许多Knockout程序员感觉Knockout对JavaScript所做的，就像jQuery对JavaScript所做的，Knockout在增强设计和开发体验方面也做了同样多的工作。
- en: 'Well, that is not good enough. If the goal is improved user experience why
    don''t we copy this file, `text.html`, as `text3.html` and create a Web 3.0 level
    experience? We will just show all the code at once and talk through it. We will
    be creating the click-to-edit experience here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这还不够好。如果目标是提升用户体验，为什么我们不复制这个文件，`text.html`，作为`text3.html`并创建一个Web 3.0级别的体验呢？我们将一次性展示所有代码，并对其进行讲解。我们将在以下地方创建点击编辑体验：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What we have done is put the input element for the title with a span that displays
    the contents of the title value. You will notice they both have the same item
    starting the `data-bind` attribute. The order is not important as far as the code
    is stable; this is just the order we happen to code in. The visible item in the
    text has parentheses because the `!` (not) symbol means we have entered JavaScript
    code into the attribute value. Whenever we do that we need to enter parentheses
    for it to function correctly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是将标题的输入元素与一个显示标题值内容的span元素放在一起。你会注意到它们两者都有相同的项开始`data-bind`属性。就代码稳定性而言，顺序并不重要；这仅仅是我们的编码顺序。文本中的可见项有括号，因为`!`（非）符号意味着我们已经在属性值中输入了JavaScript代码。每次我们这样做时，都需要输入括号以使其正确运行。
- en: 'We also have added a click event handler to the label and the title content.
    The reason we have added the label is that there will be times when you may have
    a page load without the title prepopulated. This was just an example to show that
    you still have access to calling the edit box by clicking on the title. When the
    page loads it will look like this at first (remember to complete the ViewModel
    before so that it will work correctly):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向标签和标题内容添加了点击事件处理器。我们添加标签的原因是，有时你可能遇到页面加载而没有预先填充标题的情况。这只是一个示例，以表明你仍然可以通过点击标题来访问编辑框。页面加载时，它最初看起来是这样的（记得在之前完成ViewModel，以便它能正确工作）：
- en: '![Dynamic focus](img/1028OS_03_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![动态焦点](img/1028OS_03_08.jpg)'
- en: 'We want the same functionality for the **Post** box so you can see our code
    in the markup is identical, except it is a `textArea` field for the post versus
    the title. Now, let''s look at our ViewModel code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望**帖子**框也有相同的功能，这样你就可以看到我们的代码在标记中的相同之处，只是它是一个`textArea`字段，用于帖子而不是标题。现在，让我们看看我们的ViewModel代码：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We see that our values for the title and the visibility of the title editor
    are simple observable attributes on our ViewModel. The only thing we need the
    `editTitle` event handler to do is toggle the visible state of the title input
    box to true. Knockout will set the visibility of our View and edit elements correctly
    for us with hardly any code. We did the same thing for the post element. Now,
    when we click either on the title content or the title label, we will see the
    edit box for the title display as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到标题和标题编辑器的可见性值只是ViewModel上的简单可观察属性。我们只需要让`editTitle`事件处理程序切换标题输入框的可见状态为true。Knockout会为我们正确设置视图和编辑元素的可见性，几乎不需要写代码。我们为帖子元素也做了同样的事情。现在，当我们点击标题内容或标题标签时，我们会看到标题的编辑框如下显示：
- en: '![Dynamic focus](img/1028OS_03_09.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![动态焦点](img/1028OS_03_09.jpg)'
- en: Radio and checkbox binding
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无线电和复选框绑定
- en: 'Radio and checkbox handling in forms can be a pain. This is another area where
    Knockout just makes things simple. Our example will start by creating a file named
    `radio.html` this time. Let''s start with the markup for our checkbox:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单中处理单选按钮和复选框可能会很麻烦。这是Knockout使事情变得简单化的另一个领域。我们的例子将首先创建一个名为`radio.html`的文件。让我们从复选框的标记开始：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Radio and checkbox binding](img/1028OS_03_10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![无线电和复选框绑定](img/1028OS_03_10.jpg)'
- en: 'Now, add this code in a `script` tag on the bottom of the page, as we have
    done for the other pages. We will need an array to hold the contents of the selected
    items and that is basically all we need in our ViewModel for this functionality:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在页面的底部添加一个`script`标签，就像我们在其他页面上做的那样。我们需要一个数组来保存选中项的内容，这就是我们在ViewModel中实现此功能所需的所有内容：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By binding the checked handler in the `data-bind` attributes, we will see that
    the `colors` attribute is automatically populated. The `colors` attribute in the
    `span` tag will show all of the currently selected checkbox elements. You might
    even try clicking earlier items on and off and you will see it always puts the
    last selected item at the end of the list:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`data-bind`属性中绑定选中处理程序，我们会看到`colors`属性会自动填充。`span`标签中的`colors`属性将显示所有当前选中的复选框元素。你甚至可以尝试点击前面的项目来打开和关闭，你会发现它总是将最后选中的项目放在列表的末尾：
- en: '![Radio and checkbox binding](img/1028OS_03_11.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![无线电和复选框绑定](img/1028OS_03_11.jpg)'
- en: 'The markup for a radio button is very similar. We are going to create our code
    the same way to show the difference in function between a radio button collection
    and a checkbox collection of elements, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮的标记非常相似。我们将以相同的方式创建我们的代码，以展示单选按钮集合和复选框集合元素在功能上的差异，如下所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Radio and checkbox binding](img/1028OS_03_12.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![无线电和复选框绑定](img/1028OS_03_12.jpg)'
- en: 'All we need to is just add this single line of code in `function VM()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在`function VM()`中添加这一行代码：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Radio and checkbox binding](img/1028OS_03_13.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![无线电和复选框绑定](img/1028OS_03_13.jpg)'
- en: With the radio button it does not matter how many items are clicked, as radio
    buttons always limit themselves to a single item being selected. In common HTML,
    we would have needed to put a name on each of the radio buttons to make sure the
    DOM knew how to achieve this functionality. In this example, we can plainly see
    again that Knockout is taking care of business for us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单选按钮，点击多少个项目并不重要，因为单选按钮总是限制自己只选择一个项目。在常见的HTML中，我们需要给每个单选按钮都加上一个名称，以确保DOM知道如何实现这种功能。在这个例子中，我们可以清楚地看到Knockout正在为我们处理这些事情。
- en: Enhanced event integration
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强的事件集成
- en: The radio and checkbox binding, which we explained earlier, is useful and many
    seasoned developers likely think that HTML coding is far too heavy with the manual
    entering of all the details of colors or shapes right in the markup or the View
    part of the document. This type of thing is the best practice to place in a data
    collection of some sort. And this is exactly what we will do with the another
    set of checkboxes that we will label as **Foods**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前解释过的单选按钮和复选框绑定非常有用，许多经验丰富的开发者可能认为HTML编码过于繁琐，需要手动在标记或文档的视图部分输入所有颜色或形状的详细信息。这种类型的事情最好是放在某种数据集合中。这正是我们将要做的，我们将使用另一组复选框，我们将它们标记为**食物**。
- en: 'In this example, we will add an attribute to our ViewModel called `foodItems`.
    We will also go another step forward and set some preselected values in a variable
    called `foods`. You will notice that our `foodItems` attribute has a structured
    collection with two nested items: `item` and `itemDisplay`. Make sure your preselected
    items are using the `item` value. If you put in `Milk` instead of `milk` you will
    be confused about why it did not appear to work correctly. Items have to have
    a 100 percent match so lower case and upper case make all the difference here.
    Add the following code in `function VM()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将向我们的ViewModel添加一个名为`foodItems`的属性。我们还将更进一步，在名为`foods`的变量中设置一些预选值。您会注意到我们的`foodItems`属性有一个结构化的集合，包含两个嵌套项：`item`和`itemDisplay`。确保您的预选项使用`item`值。如果您输入`Milk`而不是`milk`，您可能会困惑为什么它看起来没有正确工作。项目必须有一个100%的匹配，所以大小写在这里都至关重要。在`function
    VM()`中添加以下代码：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can add in another set of checkboxes for the foods in the View section
    of our code. We will also be using the foreach binding in this set. Here, we can
    pass a JSON style structure to allow us to create an alias of "food" for our internal
    `$data` item. Each item inside `foreach` is designated as `$data`. Adding the
    `as` key allows us to set an alias for the `$data` as food. We show both approaches
    in use here by using `$data.item` and by using `food.itemDisplay` for the more
    dynamic example. Here is the code to add in the markup:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在代码的视图部分添加另一组用于食物的复选框。我们也将在这个集合中使用foreach绑定。在这里，我们可以传递一个类似JSON的结构，以便我们可以为内部的`$data`项创建“食物”的别名。`foreach`内部的每个项目都被指定为`$data`。添加`as`键允许我们为`$data`设置别名“食物”。我们在这里展示了两种使用方法，通过使用`$data.item`和通过使用`food.itemDisplay`（在更动态的示例中）。以下是添加到标记中的代码：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Enhanced event integration](img/1028OS_03_14.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![增强事件集成](img/1028OS_03_14.jpg)'
- en: This is our complete code, in case it would help you to see all in one place.
    Knockout again has shown a simpler and powerful advantage to the way it works.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们完整的代码，以防它有助于您在一个地方看到所有内容。Knockout再次展示了它工作方式上的简单和强大优势。
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Select binding
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择绑定
- en: 'Our first example of using Knockout with a `select` element will be for single
    item selection. This is the markup where we will put `colors` into the options:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Knockout与`select`元素的第一例将是用于单项选择。这是我们将在其中放入`colors`的标记：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In our code we will be doing one more special thing at this time. After we
    create the ViewModel we will modify one of its attributes and add another color
    to the `colorOptions` array using the `push` function, common to JavaScript. This
    means that some parts of JavaScript are great already and we should continue to
    use them. Here is the `script` code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们现在将做一件特别的事情。在我们创建ViewModel之后，我们将修改其一个属性，并使用JavaScript中常见的`push`函数向`colorOptions`数组添加另一个颜色。这意味着JavaScript的一些部分已经非常出色，我们应该继续使用它们。以下是`script`代码：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Select binding](img/1028OS_03_15.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![选择绑定](img/1028OS_03_15.jpg)'
- en: If we select the last added item, **Orange**, we will see the selector and the
    display span both showing the value as in the preceding screenshot. Using the
    code you can set the value of the ViewModel `color` attribute and it will automatically
    set the select box to the matching value. You should try it from the browser developer
    tools console. Don't forget to match the case of the value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择最后添加的项目，**橙子**，我们将看到选择器和显示span都显示与前面截图中的值相同。使用这段代码，您可以设置ViewModel的`color`属性值，它将自动将选择框设置为匹配的值。您应该在浏览器开发者工具控制台中尝试它。别忘了匹配值的大小写。
- en: 'Now, we will use a multi-select element. We don''t need the options caption
    in this case. What we do need is to change the values of the `data-bind` handler
    to the `selectedOptions` handler. This allows us to capture multiple items. Just
    remember that a value is singular and selected options are plural. I am not saying
    that we always have to think of singular and plural, but we do in this case. Add
    the following code to the markup:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用多选元素。在这种情况下，我们不需要选项标题。我们需要做的是更改`data-bind`处理程序的值到`selectedOptions`处理程序。这允许我们捕获多个项目。只需记住，一个值是单数，而所选选项是复数。我并不是说我们总是必须考虑单数和复数，但在这个情况下我们必须这样做。将以下代码添加到标记中：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, it's time to add in a little bit of code to work with the new select element.
    There is no pragmatic difference between the data coding of a single select and
    the multi-select element in the ViewModel.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候添加一些代码来处理新的选择元素了。在ViewModel中，单选和复选元素的数据编码在实用上没有差异。
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see in the following screenshot, this works really well by allowing
    us to select multiple elements:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下屏幕截图中所见，这通过允许我们选择多个元素而工作得非常好：
- en: '![Select binding](img/1028OS_03_16.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![绑定选择](img/1028OS_03_16.jpg)'
- en: Selecting elements with the object collections
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象集合选择元素
- en: 'Sometimes our data comes with the value and the displayed item representing
    the value as two different items. Here is an example of how to code when this
    is the case:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们的数据会以值和表示值的显示项目作为两个不同的项目。以下是一个示例，说明在这种情况下如何进行编码：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And in the `script` tag, inside `MyModel()`, add the following line of code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`script`标签内，在`MyModel()`中，添加以下代码行：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice `optionsText` is not a variable but is the value of the structure element
    inside the collection item. We are using an individual result here so we use the
    value handler to hold the results. If it were multiple selections, we would use
    the `selectedOptions` binding. Here is what the initial display will look like
    after our code is added. Notice that the type is set to `undeclared`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`optionsText`不是一个变量，而是集合项目中的结构元素的值。在这里我们使用单个结果，因此我们使用值处理器来保存结果。如果是多个选择，我们将使用`selectedOptions`绑定。以下是添加我们的代码后初始显示的样子。注意类型被设置为`undeclared`：
- en: '![Selecting elements with the object collections](img/1028OS_03_17.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![使用对象集合选择元素](img/1028OS_03_17.jpg)'
- en: 'Also take note of the logic inside our text binding. If there is no item selected,
    the budget item will be a null item. This works in JavaScript as a false result.
    It will then display the contents of the item after the colon. Otherwise it returns
    the results of the item before the colon. In that case we will return the structure
    element from the budget item for the type, which you will see in our script; we
    coded it as `budgetType`. Let''s take a look at the `script` code now:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 也要注意我们文本绑定中的逻辑。如果没有选择任何项目，预算项目将是一个空项目。在JavaScript中，这会返回一个假的结果。然后它会显示冒号后面的项目内容。否则，它将返回冒号前面的项目结果。在这种情况下，我们将从预算项目返回结构元素，用于类型，您将在我们的脚本中看到；我们将其编码为`budgetType`。现在让我们看看`script`代码：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code segment above will come before we declare the structure of our ViewModel.
    We will use it to declare the items within our budget collection as follows. We
    use a simple observable versus an observableArray because we are only returning
    a single item. It is a structured item with nested attributes but it is a single
    item at that level and thus, this is the correct logic:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码段将在我们声明ViewModel的结构之前出现。我们将使用它来声明预算集合中的项目，如下所示。我们使用简单的可观察对象而不是可观察数组，因为我们只返回单个项目。这是一个具有嵌套属性的结构化项目，但在那个级别上它是一个单一的项目，因此这是正确的逻辑：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, let's look at the results once we select an item. If we select the **Rental
    House** item we see that the budget type changes to **income**. This makes for
    nice dynamic interaction with far less manual coding of our automated systems.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看选择一个项目后的结果。如果我们选择**出租房屋**项目，我们会看到预算类型变为**收入**。这使得与我们的自动化系统进行动态交互变得非常方便，而且手动编码的工作量大大减少。
- en: Listing the management Knockout style
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出管理Knockout风格
- en: 'Now we can take our budget system just a little further. We will make a list
    editor that will let us add, delete, and sort our list. While most of what we
    have done so far has been very simple, this one is going to be different. This
    example is going to be simplified. It does a lot more so it will take a little
    more. Yet, through the power of Knockout, we will see that simplicity is still
    intact:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的预算系统进一步扩展。我们将创建一个列表编辑器，允许我们添加、删除和排序我们的列表。虽然我们迄今为止所做的大部分工作都非常简单，但这个例子将会不同。这个例子将会简化。它做了更多的事情，所以需要更多的时间。然而，通过Knockout的力量，我们将看到简洁性仍然保持不变：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In our first section of code we use something that we have not used so far.
    We use a `form` tag. Normally forms are not used when coding with Knockout. So
    why the change in this example? The change is because we are going to use the
    `submit` function of the form to act as our trigger to add the new budget items
    to our budget. This is done with the `addBudget` handler in our code. Here is
    our `script` code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一段代码中，我们使用了一些之前没有使用过的东西。我们使用了一个`form`标签。通常在使用Knockout进行编码时不会使用表单。那么为什么在这个例子中会有所改变？改变的原因是我们将使用表单的`submit`函数作为我们的触发器，以将新的预算项目添加到我们的预算中。这是通过我们的代码中的`addBudget`处理器完成的。以下是我们的`script`代码：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Most of the rest of the code looks familiar. The only part that might be new
    for some is the sorting of budgets. We do this using the standard JavaScript style
    sorting and a custom function we created outside the ViewModel. The custom function
    is the `bCompare` function. Here is the code for that:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码看起来都很熟悉。可能对一些人来说，唯一可能新的部分是预算的排序。我们使用标准的JavaScript样式排序和我们在ViewModel外部创建的自定义函数来完成这个操作。自定义函数是
    `bCompare` 函数。以下是该函数的代码：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is a simple compare function used by JavaScript to interact with the natural
    flow to make sure that all the items are in order. Again, we see that the code
    behind this edit form is simple enough. Let''s take a look at the list editor
    we are building. We did not make it fancy but we are certainly building some sweet
    functionality into it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的比较函数，JavaScript用它来与自然流程交互，以确保所有项目都是有序的。再次，我们看到这个编辑表单背后的代码足够简单。让我们看看我们正在构建的列表编辑器。我们没有让它变得花哨，但我们确实在它里面构建了一些很棒的功能：
- en: '![Listing the management Knockout style](img/1028OS_03_18.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![以Knockout风格列出管理](img/1028OS_03_18.jpg)'
- en: 'There is a little more special markup in the View side of the code to make
    sure things are bound correctly, shown as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的视图部分有一些特殊的标记，以确保正确绑定，如下所示：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, if you are looking at the code you may be wondering what is special about
    the code. It''s just Knockout making things simple and powerful. This is all it
    takes to get the job done. Oh, did you figure out that I am pretty impressed with
    Knockout? I am. Knockout is what makes it special because it is doing so much
    for us so that we can concentrate on the programming goals instead of how to achieve
    them. Here is a screenshot after we add **Entertainment** as an expense, sort
    the list, and delete **Gas** from it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你正在查看代码，你可能想知道代码有什么特别之处。这只是Knockout使事情变得简单和强大。这就是完成这项工作所需的一切。哦，你发现我对Knockout印象深刻了吗？我是。Knockout是使其特殊的地方，因为它为我们做了很多事情，这样我们就可以专注于编程目标，而不是如何实现它们。以下是我们在添加**娱乐**作为支出、排序列表和从列表中删除**汽油**后的截图：
- en: '![Listing the management Knockout style](img/1028OS_03_19.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![以Knockout风格列出管理](img/1028OS_03_19.jpg)'
- en: The uniqueName binding
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 唯一名称绑定
- en: 'IE6 does not allow radio buttons to be checked if they don''t have a `name`
    attribute. Most of the time this is irrelevant because your radio button elements
    will have the `name` attributes to put them into mutually-exclusive groups. However,
    if you didn''t add a `name` attribute because it''s unnecessary in your case,
    Knockout will internally use `uniqueName` on those elements to ensure they can
    be checked. Hopefully, none of us will have to use IE6 but just in case, add the
    `uniqueName` handler to the `data-bind` attribute, something like this if needed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: IE6不允许在没有 `name` 属性的情况下检查单选按钮。大多数时候这无关紧要，因为你的单选按钮元素将具有 `name` 属性，以便将它们放入互斥组中。然而，如果你没有添加
    `name` 属性，因为在你情况下它是多余的，Knockout将内部使用 `uniqueName` 在这些元素上以确保它们可以被检查。希望我们中没有人需要使用IE6，但以防万一，将
    `uniqueName` 处理程序添加到 `data-bind` 属性中，如果需要的话，可以像这样：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Grid forms
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格表单
- en: 'Now we will take our budget form just one step further. We will combine a number
    of the features we have been learning to this point into an editable grid. We
    will wrap the grid in a form this time also, but you will see in the code a dual
    option for how you use the form. Create a file called `grid.html` for this example.
    Enter the following in the markup:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把我们的预算表单再向前推进一步。我们将把到目前为止我们已经学习到的多个功能组合成一个可编辑的表格。这次我们也将表格包裹在表单中，但你在代码中会看到如何使用表单的双向选项。为这个示例创建一个名为
    `grid.html` 的文件。在标记中输入以下内容：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you want to use Knockout just as an automated editor and still submit the
    form, you could fill in the details on the `action` attribute of the form and
    still submit it in the old-school approach. This might be useful if you are working
    with an older system and your business logic is still form-submission based. This
    will also allow you to enter the realm of Knockout more gradually. It could also
    allow you to test out the functionality without having to totally rewrite your
    systems during testing this way.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想将Knockout用作自动化的编辑器，并且仍然提交表单，你可以在表单的 `action` 属性中填写详细信息，并仍然以传统的方式提交它。如果你正在与较旧的系统合作，并且你的业务逻辑仍然是基于表单提交的，这可能很有用。这将还允许你逐步进入Knockout的世界。这也可能允许你在测试过程中测试功能，而无需完全重写你的系统。
- en: 'Notice we are using the `foreach` markup binding to manage a row in our grid
    for every data row on the model of our data. The ViewModel smartly keeps all of
    this tied together and up to date. We have also added in the `uniqueName` logic
    that one would add into an application that needs to support IE6\. Now let''s
    look at the script code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用 `foreach` 标记绑定来管理网格中的每一行，对于数据模型中的每一行数据。ViewModel 智能地保持所有这些内容紧密相连并保持最新。我们还添加了
    `uniqueName` 逻辑，这是需要在支持 IE6 的应用程序中添加的。现在让我们看看脚本代码：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We created a standard ViewModel named BudgetModel in this example. Once again,
    we are using the JavaScript array `push` method to stack another budget item in
    our array collection. We also have handlers for removing a budget item. If we
    look back at our markup you will see it uses the scope-based variable `$root.removeBudget`.
    The rows are added using the foreach functionality so Knockout once again does
    the heavy lifting for us and it will know which row you are trying to delete.
    Don't get stressed out trying to figure it out. Think of it like a smartphone.
    You don't need to know how it works. What you need to know is how to use it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 BudgetModel 的标准 ViewModel。再次强调，我们正在使用 JavaScript 数组的 `push`
    方法在我们的数组集合中堆叠另一个预算项。我们还有移除预算项的处理程序。如果我们回顾我们的标记，您会看到它使用基于作用域的变量 `$root.removeBudget`。行是通过
    `foreach` 功能添加的，因此 Knockout 再次为我们承担了繁重的工作，并且它会知道您正在尝试删除哪一行。不要因为试图弄清楚它而感到压力。把它想象成一部智能手机。您不需要知道它是如何工作的。您需要知道的是如何使用它。
- en: 'The save method handler is set to show the results in an alert box. You could
    have easily used jQuery AJAX to send these results back to a server for persistent
    data storage. You will also see there is, as stated previously, the ability to
    just send it as a form. The choice is there for you to pick the one that best
    suits your needs. Here is the screenshot for the previous code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 保存方法处理程序被设置为在警告框中显示结果。您本可以使用 jQuery AJAX 将这些结果发送回服务器以进行持久数据存储。您还会看到，正如之前所述，您可以选择将其作为表单发送。选择权在您手中，您可以选择最适合您需求的方法。以下是之前代码的截图：
- en: '![Grid forms](img/1028OS_03_20.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![网格表单](img/1028OS_03_20.jpg)'
- en: Now play around with this example. Add some rows. Delete some rows. Click **Submit**
    with data and you will see the results in an alert box. Click it without any rows
    and you will see it is smart enough to just ignore the user trying to submit nothing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试这个例子。添加一些行。删除一些行。带有数据的点击 **提交** 按钮，您将在警告框中看到结果。如果没有行而点击它，您会看到它足够智能，可以忽略试图提交空内容的用户。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When working with forms and grids, and keeping the data up to date, anytime
    you touch it, anywhere, is what Knockout has been about from the start. I hope
    you are enjoying coding web forms with the simple but powerful advances this technology
    offers. It makes focusing on business logic much easier with less code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理表单和网格，并保持数据更新时，无论何时何地触及它，这正是 Knockout 从一开始就关注的内容。我希望您正在享受使用这项技术提供的简单但强大的进步来编写网页表单。它使得关注业务逻辑变得更加容易，代码更少。
- en: In the next chapter, we will learn to integrate data management in Knockout
    using JSON and mapping.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 JSON 和映射在 Knockout 中集成数据管理。
