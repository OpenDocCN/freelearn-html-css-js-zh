- en: Chapter 5. The Socket.IO Protocol
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. Socket.IO协议
- en: Socket.io provides a very simple API that is easy to use but exposes a lot of
    functionality. Moreover, this functionality works uniformly across browsers and
    the various transport mechanisms provided by socket.io. To achieve this, a socket.io
    client and server do a lot of work in the background. In this chapter, we will
    examine and try to understand the communication in socket.io as well as some socket.io
    internals.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.io提供了一个非常简单但易于使用的API，同时暴露了大量的功能。此外，这些功能在所有浏览器和socket.io提供的各种传输机制中都是统一的。为了实现这一点，socket.io客户端和服务器在后台做了很多工作。在本章中，我们将检查并尝试理解socket.io中的通信以及一些socket.io内部机制。
- en: Why do we need another protocol?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们需要另一个协议？
- en: The first question to people familiar with WebSocket is, why do we need another
    protocol when we already have WebSocket? The answer is twofold; socket.io works
    in a uniform manner across browsers (dating back to Internet Explorer 6), and
    socket.io provides a much richer API
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉WebSocket的人来说，第一个问题是，为什么我们已经有WebSocket了，还需要另一个协议？答案是双重的；socket.io在所有浏览器中都以统一的方式工作（追溯到Internet
    Explorer 6），并且socket.io提供了一个功能更丰富的API
- en: The WebSocket specification is still under development and is not supported
    on many of the browsers that are in use. In fact, any version of Internet Explorer
    prior to IE10 doesn't have support for WebSocket. There are still many people
    out there using old browsers that don't support WebSocket.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket规范仍在开发中，并且不支持许多正在使用的浏览器。事实上，任何版本的Internet Explorer 10之前的版本都没有WebSocket支持。仍然有很多人在使用不支持WebSocket的旧浏览器。
- en: Another problem for WebSocket is firewalls and proxies. Most of the firewalls
    block any communication (apart from standard HTTP 1.0/1.1), and may not allow
    a WebSocket connection to be established. The same applies to most proxy servers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于WebSocket来说，另一个问题是防火墙和代理。大多数防火墙会阻止任何通信（除了标准的HTTP 1.0/1.1），并且可能不允许建立WebSocket连接。同样适用于大多数代理服务器。
- en: So, if we decide to use just the WebSocket protocol, we have to understand that
    there will be many people who may not be able to use our application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们决定只使用WebSocket协议，我们必须理解会有很多人可能无法使用我们的应用程序。
- en: 'Contrary to this, when we build our application using socket.io, the people
    who can use WebSocket will continue using it, but those who can''t will fall back
    on the next best available transport mechanism and then the next and so on, until
    they find one that works in the browser, even through the firewalls and proxies,
    all the way down to iframes (which is rarely used). The default order is as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，当我们使用socket.io构建应用程序时，能够使用WebSocket的人将继续使用它，而那些不能使用的人将退而求其次，使用下一个最好的可用传输机制，然后是下一个，直到他们在浏览器中找到一个可以工作的机制，即使是通过防火墙和代理，一直到iframe（很少使用）。默认顺序如下：
- en: WebSocket
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket
- en: FlashSocket
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FlashSocket
- en: XHR long polling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHR长轮询
- en: XHR multipart streaming
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHR多部分流式传输
- en: XHR polling
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHR轮询
- en: JSONP polling
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSONP轮询
- en: iframe
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iframe
- en: 'It''s also worth noting that using JSONP polling, socket.io provides support
    for cross-domain communication without the need for any special configuration
    on the server or any special code on the client:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，使用JSONP轮询，socket.io提供了跨域通信的支持，而无需在服务器上进行任何特殊配置或客户端上的任何特殊代码：
- en: Now, let us take a look at the differences in the API. For this, we will see
    only the JavaScript client-side API, as any server will have its own implementation
    and API depending on the programming language used.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看API中的差异。为此，我们将只看到JavaScript客户端API，因为任何服务器都将根据使用的编程语言有自己的实现和API。
- en: The WebSocket API
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket API
- en: 'Let us begin by taking a quick look at a code snippet showing the skeleton
    of a WebSocket cliet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从快速查看一个显示WebSocket客户端骨架的代码片段开始：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first step, as can be seen in the previous code snippet, is to create a
    new instance of WebSocket; in this, we have to pass the URI for the WebSocket
    server. This URI, like any other, has a part that specifies the protocol, which
    in this case can be either `ws` (unsecured) or `wss` (secured); the server address
    (the server's IP address or valid domain name); and finally, the port.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，如前一个代码片段所示，是创建一个新的WebSocket实例；在这里，我们必须传递WebSocket服务器的URI。这个URI，像任何其他URI一样，有一个指定协议的部分，在这个情况下可以是`ws`（未加密）或`wss`（加密）；服务器地址（服务器的IP地址或有效的域名）；最后，端口。
- en: Ideally, we also need to check if WebSocket is supported on the browser that
    the user has, but I have skipped that part to focus on the API.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们还需要检查用户所使用的浏览器是否支持WebSocket，但我已经跳过了这部分内容，以专注于API。
- en: 'Following the creation of the WebSocket object, we can attach event handlers
    to it. There are three events exposed by WebSocket, with their corresponding event
    handlers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建WebSocket对象之后，我们可以向其附加事件处理器。WebSocket公开了三个事件，以及它们对应的事件处理器：
- en: '`open`: The `onopen` event handler'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`：`onopen`事件处理器'
- en: '`message`: The `onmessage` event handler'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：`onmessage`事件处理器'
- en: '`close`: The `onclose` event handler'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close`：`onclose`事件处理器'
- en: As is evident by their names, these handlers will be called on the opening of
    a socket connection, when there is a new message on the socket, and on closing
    the socket connection, respectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，这些处理器将在套接字连接打开时、套接字上有新消息时以及关闭套接字连接时分别被调用。
- en: For every event, the client receives the event data. In case the event is a
    message, it contains that message along with other data. The WebSocket client
    doesn't try to interpret the message or its type, that is to say, it treats all
    messages as plain text and it is left to the application to interpret and understand
    it. Also, there is no mention of the namespacing of messages or the multiplexing
    of socket connections.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个事件，客户端都会接收到事件数据。如果事件是消息，它将包含该消息以及其他数据。WebSocket客户端不会尝试解释消息或其类型，也就是说，它将所有消息视为纯文本，并且由应用程序负责解释和理解。此外，没有提及消息的命名空间或套接字连接的多路复用。
- en: If you see the `onopen` handler, you will notice the `send` method, which is
    used by the client to send messages. Again, it can send only plain text, so you
    have to take care of serialization and deserialization.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到`onopen`处理器，您会注意到`send`方法，这是客户端用来发送消息的方法。同样，它只能发送纯文本，因此您必须负责序列化和反序列化。
- en: Finally, we have the `close` method, which, as the name suggests, can be used
    to close the socket connection from the client.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`close`方法，正如其名称所暗示的，可以用来从客户端关闭套接字连接。
- en: The Socket.IO API
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket.IO API
- en: 'Let us see the same code using sockt.io:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用sockt.io的相同代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The above code snippet looks similar to the one with WebSockets and, not surprisingly,
    does the same work as the previous code. However, there are some minor changes:
    instead of using `onopen`, `onmessage`, and `onclose`, we use socket.io''s `on`
    method to attach the handlers. The advantage is that when we use socket.io''s
    custom events functionality, the API to handle the event remains the same.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段看起来与WebSocket的代码相似，并且不出所料，与之前的代码执行相同的工作。然而，有一些细微的变化：我们不是使用`onopen`、`onmessage`和`onclose`，而是使用socket.io的`on`方法来附加处理器。优点是，当我们使用socket.io的自定义事件功能时，处理事件的API保持不变。
- en: 'As we have already seen, you can emit a new event using the following line
    of code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，您可以使用以下代码行来发出新事件：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And then receive it using the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下方式接收它：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, in this case, we are passing a JSON object for the data; socket.io
    will take care of serializing and deserializing it for us.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，我们正在传递一个JSON对象作为数据；socket.io将为我们处理序列化和反序列化。
- en: Moreover, socket.io provides support for namespacing of messages, multiplexing
    of connections, disconnection detection, reconnection, and an API to broadcast
    messages to all clients.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，socket.io提供了对消息命名空间、连接多路复用、断开检测、重新连接以及向所有客户端广播消息的API支持。
- en: Considering everything covered in this section, it is not difficult to conclude
    that socket.io will need its own protocol and mechanism to work.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到本节中涵盖的所有内容，我们可以得出结论，socket.io将需要自己的协议和机制来工作。
- en: The Socket.IO socket
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO套接字
- en: 'The socket.io socket emulates a network socket over different transport mechanisms.
    Just as any other socket, it has various stages in its lifecycle, depending on
    the status of the connection. These are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: socket.io套接字通过不同的传输机制模拟网络套接字。就像任何其他套接字一样，它在其生命周期中有各种阶段，这取决于连接的状态。以下是这些阶段：
- en: connecting
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在连接
- en: connected
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已连接
- en: disconnecting
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在断开连接
- en: disconnected
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断开连接
- en: The socket is established when the client sends a connection request to the
    server and a handshake is initiated.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向服务器发送连接请求并开始握手时，套接字建立。
- en: Once the handshake is complete, a connection is opened using the transport negotiated
    during the handshake, and the state of the socket is set to *connected*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦握手完成，将使用握手期间协商的传输方式打开连接，并将套接字的状态设置为*已连接*。
- en: To check the liveliness of the socket depending on the server configuration,
    the server may require heartbeat messages to be sent from the client to the server
    in regular intervals. In the absence of such a message, or the failure of the
    underlying transport, the socket will be disconnected.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据服务器配置检查套接字的活动性，服务器可能需要客户端定期向服务器发送心跳消息。如果没有这样的消息，或者底层传输失败，套接字将被断开连接。
- en: In this case, the client will initiate a reconnect. If the connection is restored
    within the connection termination time or the timeout agreed at the time of the
    handshake, the buffered messages are sent across. In case the connection is not
    restored, the client will start a new connection request, beginning with a new
    handshake.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，客户端将发起一个重新连接。如果连接在连接终止时间或握手时同意的超时时间内恢复，则缓冲的消息将被发送。如果连接未恢复，客户端将启动一个新的连接请求，从新的握手开始。
- en: Also, optionally, to ensure message delivery over the socket, we can make it
    compulsory for the socket to acknowledge the message delivery.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可选地，为了确保通过套接字的消息传递，我们可以强制套接字确认消息传递。
- en: The socket is terminated when the `close` method is called on either the client
    or the server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当在客户端或服务器上调用`close`方法时，套接字将被终止。
- en: The Socket.IO connection
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO连接
- en: The socket.io connection begins with the handshake. This makes the handshake
    a special part of the protocol. Apart from the handshake, all the other events
    and messages in the protocol are transferred over the socket.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: socket.io连接从握手开始。这使得握手成为协议的一个特殊部分。除了握手之外，协议中的所有其他事件和消息都是通过套接字传输的。
- en: Socket.io is intended for use with web applications, and therefore it is assumed
    that these applications will always be able to use HTTP. It is because of this
    reasoning that the socket.io handshake takes place over HTTP.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.io旨在与Web应用程序一起使用，因此假设这些应用程序始终能够使用HTTP。正因为如此，socket.io的握手才发生在HTTP上。
- en: 'To initiate the connection and hence perform the handshake, the client performs
    a `POST` request on the handshake URI (built from the URI passed to the `connect`
    method). Let us take the same socket.io connection URI and try to understand its
    various parts. Let us say that the URI is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发起连接并执行握手，客户端在握手URI（由传递给`connect`方法的URI构建）上执行一个`POST`请求。让我们以相同的socket.io连接URI为例，尝试理解其各个部分。假设URI如下：
- en: '[http://myhost.com:8080/socket.io/1/](http://myhost.com:8080/socket.io/1/)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://myhost.com:8080/socket.io/1/](http://myhost.com:8080/socket.io/1/)'
- en: Let us break down and understand this URI.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解并理解这个URI。
- en: '`http` is the protocol being used. We can set it to use `https`, using `https`
    in the client''s `connect` `ct` method.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`http` 是正在使用的协议。我们可以将其设置为使用`https`，在客户端的`connect` `ct`方法中使用`https`。'
- en: '`myhost.com` again comes from the `connect` method and is the name or IP address
    of the host you want to connect to. The default i `localhost`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`myhost.com` 再次来自`connect`方法，是你想要连接的主机的名称或IP地址。默认值为`localhost`。'
- en: '`8080` is the port over which your server is listening. This is also passed
    to the `connect` method when we are invoking it. The default is `80`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`8080` 是服务器监听的端口。当我们调用它时，这也传递给了`connect`方法。默认值为`80`。'
- en: '`socket.io` is the namespace that handles all the connect requests.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io` 是处理所有连接请求的命名空间。'
- en: '`1` is the socket.io protocol version number.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`1` 是socket.io协议版本号。'
- en: 'The server can respond to this in one of thee three ways:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以通过以下三种方式之一对此做出响应：
- en: '`200 OK` – This will be the server''s response when the handshake is successful.
    In addition to the status, the body of the response should be a colon-separated
    list of the session ID given to this connection, the heartbeat timeout, the connection
    closing timeout, and the list of supported transports separated by commas. A sample
    response body looks like this:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 OK` – 当握手成功时，服务器将给出此响应。除了状态外，响应体应该是一个冒号分隔的列表，包含分配给此连接的会话ID、心跳超时、连接关闭超时以及通过逗号分隔的支持的传输列表。一个示例响应体如下：'
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`401 Unauthorized` – This will be the response from the server in case the
    authorization handler fails to authorize the client. As we saw in the previous
    chapter, this is the handler we attach to the `authorize` event on the server,
    and it uses the connection and cookie information to authorize the user.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401 Unauthorized` – 如果授权处理程序未能授权客户端，服务器将给出此响应。正如我们在上一章中看到的，这是我们附加到服务器上`authorize`事件的处理器，它使用连接和cookie信息来授权用户。'
- en: '`503 Service Unavailable` – When the server has any other reason, including
    errors, to deny service to the client.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`503 服务不可用` – 当服务器有任何其他原因（包括错误）拒绝向客户端提供服务时。'
- en: If the handshake is successful, based on the transports provided by the server
    and the one supported by the client the socket.io client will start communicating
    with the server on a particular URI. This URI has the form `[scheme]://[host]/[namespace]/[version]/[transportId]/[sessionId]`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果握手成功，基于服务器提供的传输和客户端支持的传输，socket.io客户端将开始在特定的URI上与服务器通信。此URI的形式为`[scheme]://[host]/[namespace]/[version]/[transportId]/[sessionId]`。
- en: '`[scheme]` is the protocol the client will be using to communicate. In the
    case of WebSockets, this is either `ws` or `wss`, while in the case of XHR, it
    is either `http` or `https`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[scheme]` 是客户端将用于通信的协议。在WebSocket的情况下，这将是`ws`或`wss`，而在XHR的情况下，则是`http`或`https`。'
- en: '`[host]` is the server name or IP Address.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[host]` 是服务器名称或IP地址。'
- en: '`[namespace]` is the socket.io namespace we want to send the message to.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[namespace]` 是我们想要发送消息的socket.io命名空间。'
- en: '`[version]` is the version of the socket.io protocol that we are using, currently
    `1`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[version]` 是我们使用的socket.io协议版本，目前为`1`。'
- en: '`[transportId]` is the the name of the transport mechanism chosen for the communication.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[transportId]` 是为通信选择的传输机制名称。'
- en: '`[sessionId]` is the session ID given to the client by the server during the
    handshake.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[sessionId]` 是服务器在握手期间分配给客户端的会话ID。'
- en: In the case of bidirectional transport, such as WebSocket, the connection opened
    at this URI will be used to send and receive messages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向传输的情况下，例如WebSocket，在此URI上打开的连接将用于发送和接收消息。
- en: For unidirectional transports such as XHR long polling, the client will perform
    a `GET` request on this URI, which the server will keep on hold till it has some
    data to send, while the client will perform a `POST` request on this URI whenever
    it has to send a message or an event to the server.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单向传输，如XHR长轮询，客户端将在此URI上执行`GET`请求，服务器将保持此请求直到有数据要发送，而客户端将在此URI上执行`POST`请求，每当它需要向服务器发送消息或事件时。
- en: Socket.IO messages
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO消息
- en: Once the transport's connection is established, all the communication between
    the client and server happens using messaging over the socket. The messages need
    to be encoded in the format specified by socket.io.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了传输的连接，客户端和服务器之间的所有通信都通过套接字上的消息进行。消息需要按照socket.io指定的格式进行编码。
- en: 'This format enables socket.io to determine the type of the message and the
    data sent in the message, and some metadata useful for operation. The message
    format is `[type] : [id (''+'')] : [endpoint] (: [data])`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '此格式使socket.io能够确定消息的类型和消息中发送的数据，以及一些对操作有用的元数据。消息格式为`[type] : [id (''+'')] :
    [endpoint] (: [data])`。'
- en: '`type` is a single digit integer, specifying what type of message it is.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type` 是一个单数字整数，指定消息的类型。'
- en: '`id` is the message ID, which is an incremental integer; it is used for ACKs.
    It is optional.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id` 是消息ID，它是一个递增整数；它用于ACK。它是可选的。'
- en: The `+` sign, if present, tells socket.io not to handle the ACKs, as the application
    intends to handle it.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在`+`符号，它告诉socket.io不要处理ACK，因为应用程序打算自己处理它。
- en: '`endpoint` is the socket endpoint that the message is intended to be delivered
    to. This is optional and is used when multiplexing the socket for namespacing.
    If omitted, the message will be sent to the default socket.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoint` 是消息打算发送到的socket端点。这是可选的，用于在命名空间中复用套接字。如果省略，消息将发送到默认套接字。'
- en: '`data` is the associated data to be delivered to the socket. In the case of
    messages, it is treated as plain text, while in the case of events, it will be
    parsed as JSON.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 是要发送到套接字的相关数据。在消息的情况下，它被视为纯文本，而在事件的情况下，它将被解析为JSON。'
- en: In the coming section, we will see what the types of messages are.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到消息的类型。
- en: Disconnect (0)
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断开连接（0）
- en: 'When the type is zero (`0`), the message is a disconnect signal. This will
    tell socket.io to close the connection and the mentioned socket. If the endpoint
    is not specified, the message will be sent to the default socket, which will cause
    the whole socket to be closed and all the endpoints on that socket will be terminated.
    For example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型为零（`0`）时，消息是一个断开信号。这将告诉socket.io关闭连接和提到的套接字。如果未指定端点，消息将发送到默认套接字，这将导致整个套接字关闭，并且该套接字上的所有端点都将终止。例如：
- en: 'Message: `0` – The result is that the socket is closed and all the connections/endpoints
    are terminated.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`0` – 结果是套接字被关闭，所有连接/端点都被终止。
- en: 'Message: `0::/endpoint` – The socket connection to `/endpoint` will be closed
    and no messages can be sent to or from that endpoint. Other endpoints will continue
    to operate.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`0::/endpoint` – 将关闭到 `/endpoint` 的套接字连接，并且无法向该端点发送或接收消息。其他端点将继续运行。
- en: Connect (1)
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接（1）
- en: 'This message is only used for multiplexing, and is sent from the client to
    the server to open a new connection. Thus, this message must always have an endpoint.
    The first (default) socket connection is established by the handshake explained
    earlier. The endpoint may be followed by query parameters in a URL query format.
    If the connection is successful, the server will echo the same message, else the
    server can send an error message. For example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息仅用于多路复用，并由客户端发送到服务器以打开新的连接。因此，此消息必须始终包含一个端点。第一个（默认）套接字连接是通过前面解释的手 shake 建立的。端点可能后跟
    URL 查询格式的查询参数。如果连接成功，服务器将回显相同的消息，否则服务器可以发送错误消息。例如：
- en: 'Message: `1::/endpoint` – Requests the server to open a multiplexed socket
    to the endpoint.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`1::/endpoint` – 请求服务器打开一个到端点的多路复用套接字。
- en: 'Message: `0::/endpoint?param=one` – Requests the server to open a multiplexed
    socket to the endpoint, passing a parameter called `param` with the value `one`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`0::/endpoint?param=one` – 请求服务器打开一个到端点的多路复用套接字，传递一个名为 `param` 的参数，其值为 `one`。
- en: Heartbeat (2)
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 心跳（2）
- en: 'This is the heartbeat message. It must be sent from the client to the server
    within the timeout negotiated during the handshake. The server will reply with
    a heartbeat message too. In this case, we don''t have an endpoint and nor is any
    other information required. This is because it serves the whole socket. For example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是心跳消息。必须在握手期间协商的超时时间内从客户端发送到服务器。服务器也将回复心跳消息。在这种情况下，我们没有端点，也不需要任何其他信息。这是因为它服务于整个套接字。例如：
- en: 'Message: `2` – Sends a heartbeat message to the other end.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`2` – 向另一端发送心跳消息。
- en: Message (3)
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息（3）
- en: 'This is the message sent over the socket. In the API, this message will be
    sent when you are using `socket.send`, and will result in a message event on the
    receiving end. This message will carry data, treating it as plan text. For example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过套接字发送的消息。在 API 中，此消息将在您使用 `socket.send` 时发送，并在接收端引发消息事件。此消息将携带数据，将其视为纯文本。例如：
- en: 'Message: `3:1::Some message` – This will send a message to the other end, where
    the message event handler will be triggered with the `Some message` message in
    the event data.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`3:1::Some message` – 这将向另一端发送消息，其中消息事件处理程序将触发事件数据中的 `Some message` 消息。
- en: 'Message: `3:1:/endpoint:Some message` – Again, the message will be sent to
    other end of the socket, but on the multiplexed endpoint.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`3:1:/endpoint:Some message` – 再次，消息将被发送到套接字的另一端，但是在多路复用端点上。
- en: JSON message (4)
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 消息（4）
- en: 'This is similar to sending the message, but in this case the message has to
    be serialized using JSON, and it will be parsed at the other end before being
    sent to the handler. In version 0.6, this was done using the same API as `send()`
    for message, just passing a JSON message instead of a string message. But since
    this introduces a performance penalty over sending plain text from version 0.7
    onwards, we have to use the `json` flag to send a JSON message; for example, `socket.json.send`.
    For example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这与发送消息类似，但在此情况下，消息必须使用 JSON 进行序列化，并在发送到处理程序之前在另一端进行解析。在版本 0.6 中，这是使用与 `send()`
    消息相同的 API 实现的，只是传递一个 JSON 消息而不是字符串消息。但从版本 0.7 开始，由于这引入了比发送纯文本更高的性能开销，我们必须使用 `json`
    标志来发送 JSON 消息；例如，`socket.json.send`。例如：
- en: 'Message: `4:1::{"some":"content"}` – Sends the JSON message to the other end
    of the socket.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`4:1::{"some":"content"}` – 将 JSON 消息发送到套接字的另一端。
- en: Event (5)
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件（5）
- en: The Event message is a special kind of JSON message that is used to send events
    over the socket. In events, the data payload is of the form `{"name":"eventName",
    "args":{"some":"content"}}`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 事件消息是一种特殊的 JSON 消息，用于通过套接字发送事件。在事件中，数据负载的形式为 `{"name":"eventName", "args":{"some":"content"}}`。
- en: Here, `name` is the name of the event and `args` are the parameters to be sent
    to the handler. The `socket.emit` call is used to send events in the applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name` 是事件的名称，`args` 是要发送到处理程序的参数。`socket.emit` 调用用于在应用程序中发送事件。
- en: 'The following event names are reserved and cannot be used in applications:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下事件名称是保留的，不能在应用程序中使用：
- en: '`message`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`'
- en: '`connect`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect`'
- en: '`disconnect`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnect`'
- en: '`open`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`'
- en: '`close`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close`'
- en: '`error`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`'
- en: '`retry`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retry`'
- en: '`reconnect`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reconnect`'
- en: 'For example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Message: `5:1::{"name": "myEvent", "args":{"some": "data"}` – The result is
    that the event will be sent to the other end and the appropriate event handler
    will be invoked, passing the args to it.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '消息：`5:1::{"name": "myEvent", "args":{"some": "data"}}` – 结果是事件将被发送到另一端，并且将调用适当的事件处理器，并将参数传递给它。'
- en: ACK (6)
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACK (6)
- en: 'The acknowledgment (ACK) message will be sent when the message is received,
    with ACK request enabled; or, it can be sent out by the application. The data
    section in the ACK message can be the message ID for the message that is being
    acknowledged. If the message ID is followed by `+` and additional data, it is
    treated as an event packet. For example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息被接收并且启用了ACK请求时，将发送确认（ACK）消息；或者，它也可以由应用程序发送。ACK消息中的数据部分可以是正在确认的消息的ID。如果消息ID后面跟着`+`和附加数据，它被视为一个事件包。例如：
- en: 'Message: `6:::1` – Sends an acknowledgment for the receipt of a message with
    ID `1`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`6:::1` – 发送对ID为`1`的消息的接收确认。
- en: 'Message: `6:::1+["A", "B"]` – This will send an acknowledgment for the message
    along with the data.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`6:::1+["A", "B"]` – 这将发送包含数据的消息确认。
- en: Error (7)
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误 (7)
- en: 'This is sent by the server in case there''s an error, such as failure during
    the processing of a `connect` request to an endpoint. The data section of this
    message will contain the error message and, optionally, advice, separated by the
    `+` sign. For example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器在处理连接到端点的`connect`请求时出现错误等情况时，会发送此消息。此消息的数据部分将包含错误消息和可选的建议，由`+`符号分隔。例如：
- en: 'Message: `7:::Unauthorized` – The result is that the error will be sent to
    the client.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：`7:::Unauthorized` – 结果是将错误发送到客户端。
- en: NOOP (8)
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NOOP (8)
- en: This message implies no operation, and is used to close a poll after the polling
    times out.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息表示没有操作，用于在轮询超时后关闭轮询。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we saw the communication mechanism for the socket.io server
    and client. Understanding the working and the message formats, helps us in debugging
    the issues we face during the development of socket.io applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了socket.io服务器和客户端的通信机制。理解其工作原理和消息格式，有助于我们在开发socket.io应用程序时调试遇到的问题。
- en: In the next chapter we will learn to deploy and scale socket.io applications
    in production. Also, we will get a few tips on how to minimize our troubles on
    the production server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在生产环境中部署和扩展socket.io应用程序。同时，我们还将获得一些关于如何最小化生产服务器上麻烦的提示。
