- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Exploring Advanced Geometries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索高级几何形状
- en: In [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081), *Learning to Work with Geometries*,
    we showed you all the basic geometries provided by Three.js. Besides these basic
    geometries, Three.js also offers a set of more advanced and specialized objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B18726_05.xhtml#_idTextAnchor081)《学习与几何形状一起工作》中，我们向您展示了Three.js提供的所有基本几何形状。除了这些基本几何形状之外，Three.js还提供了一套更高级和专业的对象。
- en: 'In this chapter, we’ll show you these advanced geometries:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示这些高级几何形状：
- en: How to use advanced geometries such as `THREE.ConvexGeometry`, `THREE.LatheGeometry`,
    `THREE.BoxLineGeometry`, `THREE.RoundeBoxGeometry`, `THREE.TeapotGeometry`, and
    `THREE.TubeGeometry`.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`THREE.ConvexGeometry`、`THREE.LatheGeometry`、`THREE.BoxLineGeometry`、`THREE.RoundeBoxGeometry`、`THREE.TeapotGeometry`和`THREE.TubeGeometry`等高级几何形状。
- en: How to create 3D shapes from 2D shapes using `THREE.ExtrudeGeometry`. We’ll
    create a 3D shape from a 2D SVG image, and we will extrude from 2D Three.js shapes
    to create novel 3D shapes.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`THREE.ExtrudeGeometry`从2D形状创建3D形状。我们将从一个2D SVG图像创建一个3D形状，并将从2D Three.js形状中拉伸以创建新颖的3D形状。
- en: If you want to create custom shapes yourself, you can continue playing with
    the ones we’ve discussed in the previous chapters. Three.js, however, also offers
    a `THREE.ParametricGeometry` object. With parametric geometry, you can create
    geometry with parameters you can change to effect the shape of the geometry.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想自己创建自定义形状，您可以继续玩我们之前章节中讨论的那些。然而，Three.js还提供了一个`THREE.ParametricGeometry`对象。使用参数化几何，您可以使用可以更改以影响几何形状形状的参数来创建几何形状。
- en: We’ll also show how you can create 3D text effects using `THREE.TextGeometry`,
    and show you how to use the Troika library for when you want to add 2D text labels
    to your scene.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将展示如何使用`THREE.TextGeometry`创建3D文字效果，并展示如何使用Troika库在场景中添加2D文字标签。
- en: Additionally, we’ll show you how you can use two helper geometries, `THREE.WireframeGeometry`
    and `THREE.EdgesGeometry`. These helpers allow you to see more details about other
    geometries.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们还将向您展示如何使用两个辅助几何形状，`THREE.WireframeGeometry`和`THREE.EdgesGeometry`。这些辅助工具允许您查看其他几何形状的更多细节。
- en: We’ll start with the first one from this list, `THREE.ConvexGeometry`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从列表中的第一个开始，`THREE.ConvexGeometry`。
- en: Learning advanced geometries
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习高级几何形状
- en: In this section, we’ll look at a number of advanced Three.js geometries. We
    will start with `THREE.ConvexGeometry`, which you can use to create convex hulls.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨几个高级Three.js几何形状。我们将从`THREE.ConvexGeometry`开始，您可以使用它来创建凸包。
- en: THREE.ConvexGeometry
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.ConvexGeometry
- en: 'With `THREE.ConvexGeometry`, we can create a convex hull from a set of points.
    A convex hull is the minimal shape that encompasses all these points. The easiest
    way to understand this is by looking at an example. If you open up the `convex-geometry.html`
    example, you’ll see the convex hull for a random set of points. The following
    screenshot shows this geometry:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.ConvexGeometry`，我们可以从一组点中创建一个凸包。凸包是包含所有这些点的最小形状。理解这一点最简单的方法是查看一个示例。如果您打开`convex-geometry.html`示例，您将看到一组随机点的凸包。以下截图显示了该几何形状：
- en: '![Figure 6.1 – The convex hull encompassing all the points](img/Figure_6.1_B18726.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 包含所有点的凸包](img/Figure_6.1_B18726.jpg)'
- en: Figure 6.1 – The convex hull encompassing all the points
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 包含所有点的凸包
- en: In this example, we generate a random set of points, and based on these points,
    we create `THREE.ConvexGeometry`. In the example, you can use the `1` to see the
    points that are used to create this geometry. These points are created as small
    `THREE.SphereGeometry` objects for this example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们生成一组随机点，并根据这些点创建`THREE.ConvexGeometry`。在示例中，您可以使用`1`来查看用于创建此几何形状的点。为了这个示例，这些点被创建为小的`THREE.SphereGeometry`对象。
- en: 'To create `THREE.ConvexGeometry`, we need a set of points. The following code
    fragment shows how we do this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`THREE.ConvexGeometry`，我们需要一组点。以下代码片段显示了我们是如何做到这一点的：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see in this snippet of code, we create 20 random points (`THREE.Vector3`),
    which we push into an array. Next, we iterate this array and create `THREE.SphereGeometry`,
    whose position we set to one of these points (`position.copy(point)`). All the
    points are added to a group, so we can easily replace them once we do a redraw.
    Once you have this set of points, creating a `THREE.ConvexGeometry` from them
    is very easy, as shown in the following code snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，我们创建了20个随机点（`THREE.Vector3`），并将它们推入一个数组中。接下来，我们遍历这个数组，创建 `THREE.SphereGeometry`，并将位置设置为这些点中的一个（`position.copy(point)`）。所有点都被添加到一个组中，这样我们就可以在重绘时轻松地替换它们。一旦你有了这组点，从它们创建
    `THREE.ConvexGeometry` 就非常简单，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An array containing vertices (of the `THREE.Vector3` type) is the only argument
    `THREE.ConvexGeometry` takes. Note that if you want to render a smooth `THREE.ConvexGeometry`,
    you should call `computeVertexNormals`, as we explained in [*Chapter 2*](B18726_02.xhtml#_idTextAnchor028),
    *The Basic Components that Make up a* *Three.js Application*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含顶点（`THREE.Vector3` 类型）的数组是 `THREE.ConvexGeometry` 唯一的参数。请注意，如果你想渲染一个平滑的
    `THREE.ConvexGeometry`，你应该调用 `computeVertexNormals`，正如我们在 [*第2章*](B18726_02.xhtml#_idTextAnchor028)，*组成
    Three.js 应用程序的基本组件* 中所解释的。
- en: The next complex geometry is `THREE.LatheGeometry`, which, for example, can
    be used to create vase-like shapes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个复杂的几何形状是 `THREE.LatheGeometry`，它可以用来创建类似花瓶的形状。
- en: THREE.LatheGeometry
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.LatheGeometry
- en: '`THREE.LatheGeometry` allows you to create shapes from a set of points that
    together form a curve. If you look at *Figure 6**.2*, you can see that we created
    a number of points (the red dots), which Three.js uses to create `THREE.LatheGeometry`.
    Once again, the easiest way to understand what `THREE.LatheGeometry` looks like
    is by looking at an example. This geometry is shown in `lathe-geometry.html`.
    The following screenshot taken from the example shows this geometry:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.LatheGeometry` 允许你从一组点创建形状，这些点共同形成一个曲线。如果你看 *图6.2**，你可以看到我们创建了许多点（红色圆点），Three.js
    使用这些点来创建 `THREE.LatheGeometry`。再次强调，了解 `THREE.LatheGeometry` 的最佳方式是查看一个示例。这个几何形状在
    `lathe-geometry.html` 中显示。以下是从示例中截取的屏幕截图，显示了此几何形状：'
- en: '![Figure 6.2 – A lathe for vase-like meshes](img/Figure_6.2_B18726.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 用于类似花瓶网格的车床](img/Figure_6.2_B18726.jpg)'
- en: Figure 6.2 – A lathe for vase-like meshes
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 用于类似花瓶网格的车床
- en: 'In the preceding screenshot, you can see the points used to create this geometry
    as a set of small red spheres. The positions of these points are passed into `THREE.LatheGeometry`,
    together with arguments that define the shape of the geometry. Before we look
    at all the arguments, let’s look at the code used to create the individual points
    and how `THREE.LatheGeometry` uses these points:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，你可以看到创建这个几何形状所用的点，它们以一组小红球的形式呈现。这些点的位置被传递到 `THREE.LatheGeometry` 中，同时还有定义几何形状形状的参数。在我们查看所有参数之前，让我们看看创建单个点所用的代码以及
    `THREE.LatheGeometry` 如何使用这些点：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this piece of JavaScript, we can see that we generate 25 points whose *x*
    coordinate is based on a combination of sine and cosine functions, while the *y*
    coordinate is based on the `i` and `count` variables. This creates a spline visualized
    by the red dots in the preceding screenshot. Based on these points, we can create
    `THREE.LatheGeometry`. Besides the array of vertices, `THREE.LatheGeometry` takes
    a couple of other arguments. The following list explains these properties:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段JavaScript代码中，我们可以看到我们生成了25个点，其 *x* 坐标基于正弦和余弦函数的组合，而 *y* 坐标基于 `i` 和 `count`
    变量。这在前面的截图中的红色圆点可视化为样条线。基于这些点，我们可以创建 `THREE.LatheGeometry`。除了顶点数组之外，`THREE.LatheGeometry`
    还接受一些其他参数。以下列表解释了这些属性：
- en: '`points`: These are the points that make up the spline used to generate the
    bell/vase shape.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`points`：这些是构成生成钟形/花瓶形状的样条线的点。'
- en: '`segments`: These are the number of segments used when creating the shape.
    The higher this number, the more round and smooth the resulting shape will be.
    The default value for this is `12`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`segments`：这些是在创建形状时使用的段数。这个数字越高，最终形状就越圆滑。默认值是 `12`。'
- en: '`phiStart`: This determines where to start on a circle when generating the
    shape. This can range from `0` to `2*PI`. The default value is `0`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phiStart`：这决定了在生成形状时从圆的哪个位置开始。这可以从 `0` 到 `2*PI`。默认值是 `0`。'
- en: '`phiLength`: This defines how fully generated the shape is. For instance, a
    quarter shape will be `0.5*PI`. The default value is the full 360 degrees or `2*PI`.
    This shape will start at the position of the `phiStart` property.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phiLength`：这定义了形状生成的完整程度。例如，四分之一形状将是`0.5*PI`。默认值是完整的360度或`2*PI`。这个形状将从`phiStart`属性的起始位置开始。'
- en: In [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081), we’ve already seen `BoxGeometry`.
    Three.js also provides two other box-like geometries, which we’ll discuss next.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18726_05.xhtml#_idTextAnchor081)中，我们已经看到了`BoxGeometry`。Three.js还提供了另外两个类似盒子的几何体，我们将在下一节讨论。
- en: BoxLineGeometry
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BoxLineGeometry
- en: 'If you just want to show the outline, you can use `THREE.BoxLineGeometry`.
    This geometry works exactly like `THREE.BoxGeometry`, but instead of rendering
    a solid object, it renders the box using lines like this (from `box-line-geometry.html`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想显示轮廓，可以使用`THREE.BoxLineGeometry`。这个几何体与`THREE.BoxGeometry`完全一样，但它不是渲染一个实体对象，而是使用线条渲染盒子，如下所示（来自`box-line-geometry.html`）：
- en: '![Figure 6.3 – A box rendered using lines](img/Figure_6.3_B18726.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 使用线条渲染的盒子](img/Figure_6.3_B18726.jpg)'
- en: Figure 6.3 – A box rendered using lines
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 使用线条渲染的盒子
- en: 'You use this geometry in the same way as `THREE.BoxGeometry`, but instead of
    creating `THREE.Mesh`, we need to create `THREE.LineSegments`, using one of the
    available line-specific materials:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用这个几何体的方式与`THREE.BoxGeometry`相同，但不是创建`THREE.Mesh`，我们需要创建`THREE.LineSegments`，使用可用的线特定材料之一：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For an explanation of the properties you can pass into this geometry, refer
    to the `THREE.BoxGeometry` section of [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于您可以传递给这个几何体的属性的说明，请参阅[*第五章*](B18726_05.xhtml#_idTextAnchor081)中的`THREE.BoxGeometry`部分。
- en: Three.js also provides a slightly more advanced `THREE.BoxGeometry`, where you
    can have nicely rounded corners. You can do this with `RoundedBoxGeometry`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js还提供了一个稍微高级一点的`THREE.BoxGeometry`，您可以使用它来获得漂亮的圆角。您可以使用`RoundedBoxGeometry`来实现这一点。
- en: THREE.RoundedBoxGeometry
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.RoundedBoxGeometry
- en: 'This geometry uses the same properties as `THREE.BoxGeometry`, but it also
    allows you to specify how round the corners should be. In the `rounded-box-geometry`
    example, you can see how this looks:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个几何体使用与`THREE.BoxGeometry`相同的属性，但它还允许您指定圆角应该有多圆。在`rounded-box-geometry`示例中，您可以查看它看起来如何：
- en: '![Figure 6.4 – A box with rounded corners](img/Figure_6.4_B18726.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 带有圆角的盒子](img/Figure_6.4_B18726.jpg)'
- en: Figure 6.4 – A box with rounded corners
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 带有圆角的盒子
- en: 'For this geometry, we can specify the dimensions of the box by specifying `width`,
    `height`, and `depth`. Besides these properties, this geometry provides two additional
    ones:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个几何体，我们可以通过指定`width`、`height`和`depth`来指定盒子的尺寸。除了这些属性之外，这个几何体还提供了两个额外的属性：
- en: '`radius`: This is the size of the rounded corners. The higher this value, the
    more rounded the corners will be.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radius`：这是圆角的大小。这个值越高，圆角就越圆。'
- en: '`segments`: This property defines how detailed the corners will be. If this
    is set to a low value, Three.js will use fewer vertices for the definition of
    the rounded corners.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`segments`：这个属性定义了圆角将有多详细。如果这个值设置得较低，Three.js将使用较少的顶点来定义圆角。'
- en: Before we move on to showing how you can create 3D geometries from a 2D object,
    we’ll look at the final geometry provided by Three.js, `TeapotGeometry`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们展示如何从二维对象创建三维几何体之前，我们将查看Three.js提供的最终几何体，`TeapotGeometry`。
- en: TeapotGeometry
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TeapotGeometry
- en: '`TeapotGeometry` is a geometry that you can use to render, not very surprisingly,
    a teapot. This teapot is a standard reference model for 3D renders and has been
    used since 1975\. More information on the history of this model can be found here:
    [https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206](https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`TeapotGeometry`是一种可以用来渲染茶壶的几何体。这个茶壶是3D渲染的标准参考模型，自1975年以来一直被使用。关于这个模型历史的更多信息可以在这里找到：[https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206](https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206)。'
- en: 'Using this model works in exactly the same way as all the other models we’ve
    seen so far:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个模型的工作方式与迄今为止我们看到的所有其他模型完全相同：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You specify the specific properties and then create the geometry, which you
    assign to `THREE.Mesh`. The result, depending on the properties, looks like this
    (in the `teapot-geometry.html` example):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您指定特定的属性然后创建几何体，将其分配给`THREE.Mesh`。根据属性，结果看起来像这样（在`teapot-geometry.html`示例中）：
- en: '![Figure 6.5 – The Utah teapot](img/Figure_6.5_B18726.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 犹他茶壶](img/Figure_6.5_B18726.jpg)'
- en: Figure 6.5 – The Utah teapot
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 犹他茶壶
- en: 'To configure this geometry, you can use the following properties:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置此几何形状，您可以使用以下属性：
- en: '`size`: This is the size of the teapot.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`: 这是茶壶的大小。'
- en: '`segments`: This defines how many segments are used to create the wireframe
    of this teapot. The more segments you use, the more smooth the teapot will look.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`segments`: 这定义了用于创建茶壶线框的段数。您使用的段数越多，茶壶看起来就越平滑。'
- en: '`bottom`: If set to `true`, the bottom of the teapot will be rendered. If `false`,
    the bottom won’t be rendered, which you could use when the teapot is located on
    a surface and there is no need to render the bottom of it.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`: 如果设置为`true`，茶壶的底部将被渲染。如果为`false`，底部将不会被渲染，这可以在茶壶位于表面且不需要渲染其底部时使用。'
- en: '`lid`: If set to `true`, the lid of the teapot will be rendered. If `false`,
    the lid won’t be rendered.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lid`: 如果设置为`true`，茶壶的盖子将被渲染。如果为`false`，盖子将不会被渲染。'
- en: '`body`: If set to `true`, the body of the teapot will be rendered. If `false`,
    the body won’t be rendered.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`: 如果设置为`true`，茶壶的主体将被渲染。如果为`false`，主体将不会被渲染。'
- en: '`fitLid`: If set to `true`, the lid will exactly fit the teapot. If `false`,
    there will be a small space between the lid and the body of the teapot.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fitLid`: 如果设置为`true`，盖子将正好适合茶壶。如果为`false`，盖子和茶壶主体之间将有一个小间隙。'
- en: '`blinn`: This defines whether to use the same aspect ratio of the teapot as
    the original 1975 model this teapot is based on.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blinn`: 这定义了是否使用与茶壶基于的原始1975年模型的相同纵横比。'
- en: In the next sections, we’ll look at an alternative way of creating geometries
    by extracting a 3D geometry from a 2D shape.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨一种通过从2D形状中提取3D几何形状来创建几何形状的替代方法。
- en: Creating a geometry by extruding a 2D shape
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过挤出2D形状创建几何形状
- en: Three.js provides a way in which we can extrude a 2D shape into a 3D shape.
    By extruding, we mean stretching out a 2D shape along its *z* axis to convert
    it to 3D. For instance, if we extrude `THREE.CircleGeometry`, we get a shape that
    looks like a cylinder, and if we extrude `THREE.PlaneGeometry`, we get a cube-like
    shape. The most versatile way of extruding a shape is using `THREE.ExtrudeGeometry`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了一种方法，我们可以通过挤出2D形状到3D形状。通过挤出，我们指的是沿着其*z*轴拉伸2D形状以将其转换为3D。例如，如果我们挤出`THREE.CircleGeometry`，我们得到一个看起来像圆柱体的形状，如果我们挤出`THREE.PlaneGeometry`，我们得到一个类似立方体的形状。挤出形状最灵活的方法是使用`THREE.ExtrudeGeometry`。
- en: THREE.ExtrudeGeometry
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.ExtrudeGeometry
- en: 'With `THREE.ExtrudeGeometry`, you can create a 3D object from a 2D shape. Before
    we dive into the details of this geometry, let’s first look at an example, `extrude-geometry.html`.
    The following screenshot taken from the example shows this geometry:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.ExtrudeGeometry`，您可以从2D形状创建3D对象。在我们深入探讨这个几何形状的细节之前，让我们先看看一个例子，`extrude-geometry.html`。以下是从例子中截取的屏幕截图，显示了此几何形状：
- en: '![Figure 6.6 – Creating a 3D geometry from a 2D shape](img/Figure_6.6_B18726.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 从2D形状创建3D几何形状](img/Figure_6.6_B18726.jpg)'
- en: Figure 6.6 – Creating a 3D geometry from a 2D shape
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 从2D形状创建3D几何形状
- en: 'In this example, we took the 2D shape we created in the *2D geometries* section
    in [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081), and used `THREE.ExtrudeGeometry`
    to convert it to 3D. As you can see in the preceding screenshot, the shape is
    extruded along the *z* axis, which results in a 3D shape. The code to create `THREE.ExtrudeGeometry`
    is very easy:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了在[*第5章*](B18726_05.xhtml#_idTextAnchor081)中“2D几何形状”部分创建的2D形状，并使用`THREE.ExtrudeGeometry`将其转换为3D。正如您在前面的屏幕截图中看到的，形状沿着*z*轴被挤出，从而形成了一个3D形状。创建`THREE.ExtrudeGeometry`的代码非常简单：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this code, we created the shape with the `drawShape()` function, just as
    we did in [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081). This shape is passed
    on to the `THREE.ExtrudeGeometry` constructor together with a set of properties.
    With these properties, you can define exactly how the shape should be extruded.
    The following list explains the options you can pass into `THREE.ExtrudeGeometry`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用`drawShape()`函数创建了形状，就像我们在[*第5章*](B18726_05.xhtml#_idTextAnchor081)中所做的那样。这个形状与一组属性一起传递给`THREE.ExtrudeGeometry`构造函数。通过这些属性，您可以精确地定义形状应该如何被挤出。以下列表解释了您可以传递给`THREE.ExtrudeGeometry`的选项：
- en: '`shapes`: One or more shapes (`THREE.Shape` objects) are required to extrude
    the geometry. See [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081), on how to create
    such a shape.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shapes`: 为了挤出几何形状，需要一个或多个形状（`THREE.Shape` 对象）。请参阅[*第5章*](B18726_05.xhtml#_idTextAnchor081)，了解如何创建此类形状。'
- en: '`depth`: This determines how far the shape should be extruded (the depth).
    The default value is 100.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depth`: 这决定了形状应该被拉伸多远（深度）。默认值是 100。'
- en: '`bevelThickness`: This determines the depth of the bevel. The bevel is the
    rounded corner between the front and back faces and the extrusion. This value
    defines how deep into the shape the bevel goes. The default value is `6`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevelThickness`: 这决定了斜面的深度。斜面是前后面和拉伸之间的圆角。此值定义斜面进入形状的深度。默认值是 `6`。'
- en: '`bevelSize`: This determines the height of the bevel. This is added to the
    normal height of the shape. The default value is `bevelThickness -` `2`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevelSize`: 这决定了斜面的高度。这被添加到形状的正常高度上。默认值是 `bevelThickness - 2`。'
- en: '`bevelSegments`: This defines the number of segments that will be used by the
    bevel. The more the number of segments used, the smoother the bevel will look.
    The default value is `3`. Note that if you add more segments, you’re also increasing
    the vertex count, which could have an adverse effect on performance.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevelSegments`: 这定义了斜面将使用的段数。使用的段数越多，斜面看起来越平滑。默认值是 `3`。注意，如果你添加更多段，你也在增加顶点数，这可能会对性能产生不利影响。'
- en: '`bevelEnabled`: If this is set to `true`, a bevel is added. The default value
    is `true`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevelEnabled`: 如果设置为 `true`，则添加斜面。默认值是 `true`。'
- en: '`bevelOffset`: The distance from the outline of the shape where the bevel starts.
    The default value is `0`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevelOffset`: 这是斜面开始处的形状轮廓距离。默认值是 `0`。'
- en: '`curveSegments`: This determines how many segments will be used when extruding
    the curves of shapes. The higher the number of segments used, the smoother the
    curves will look. The default value is `12`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curveSegments`: 这决定了在拉伸形状的曲线时将使用多少个段。使用的段数越多，曲线看起来越平滑。默认值是 `12`。'
- en: '`steps`: This defines the number of segments the shape will be divided into
    along the extrusion depth. The default value is `1`, which means it will have
    a single segment along its depth, without unnecessary additional vertices.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steps`: 这定义了形状在拉伸深度上将被分割成多少个段。默认值是 `1`，这意味着它在其深度上只有一个段，没有不必要的额外顶点。'
- en: '`extrudePath`: This is the path (`THREE.CurvePath`) along which the shape should
    be extruded. If this isn’t specified, the shape is extruded along the *z* axis.
    Note that if you’ve got a curving path, you also need to make sure to set a higher
    value for the `steps` property so that it can follow the curve accurately.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extrudePath`: 这是形状应该拉伸的路径（`THREE.CurvePath`）。如果没有指定，形状将沿着 *z* 轴拉伸。注意，如果你有一个弯曲的路径，你还需要确保为
    `steps` 属性设置一个更高的值，以便它可以准确地跟随曲线。'
- en: '`uvGenerator`: When you use a texture with your material, the UV mapping determines
    what part of a texture is used for a specific face. With the `uvGenerator` property,
    you can pass in your own object, which will create the UV settings for the faces
    that are created for the passed-in shapes. More information on UV settings can
    be found in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171), *Loading and Working
    with Textures*. If nothing is specified, `THREE.ExtrudeGeometry.WorldUVGenerator`
    is used.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uvGenerator`: 当你使用材质与纹理一起使用时，UV 映射决定了纹理的哪个部分用于特定的面。通过 `uvGenerator` 属性，你可以传入自己的对象，这将为传入的形状创建面的
    UV 设置。有关 UV 设置的更多信息，请参阅 [*第 10 章*](B18726_10.xhtml#_idTextAnchor171)，*加载和使用纹理*。如果没有指定，则使用
    `THREE.ExtrudeGeometry.WorldUVGenerator`。'
- en: If you want to use a different material for the faces and the sides, you can
    pass in an array of materials to `THREE.Mesh`. The first material passed in will
    be applied to the face, and the second material will be used for the sides. You
    can experiment with these options using the menu from the `extrude-geometry.html`
    example. In this example, we extruded the shape along its *z* axis. As you can
    see in the options listed earlier in this section, you can also extrude a shape
    along a path with the `extrudePath` option. In the following geometry, `THREE.TubeGeometry`,
    we’ll do just that.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为面和侧面使用不同的材质，你可以向 `THREE.Mesh` 传递一个材质数组。传入的第一个材质将应用于面，第二个材质将用于侧面。你可以通过
    `extrude-geometry.html` 示例中的菜单来实验这些选项。在这个例子中，我们沿着其 *z* 轴拉伸了形状。正如你在本节前面列出的选项中可以看到，你也可以使用
    `extrudePath` 选项沿着路径拉伸形状。在下面的几何体 `THREE.TubeGeometry` 中，我们将这样做。
- en: THREE.TubeGeometry
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.TubeGeometry
- en: '`THREE.TubeGeometry` creates a tube that extrudes along a 3D spline. You specify
    the path using a number of vertices, and `THREE.TubeGeometry` will create the
    tube. An example that you can experiment with can be found in the sources for
    this chapter (`tube-geometry.html`). The following screenshot shows this example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.TubeGeometry`创建了一个沿着3D样条曲线拉伸的管状体。您使用多个顶点指定路径，`THREE.TubeGeometry`将创建管状体。您可以在本章的源代码中找到一个可以实验的示例（`tube-geometry.html`）。以下截图显示了此示例：'
- en: '![Figure 6.7 – TubeGeometry based on random 3D vertices](img/Figure_6.7_B18726.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 基于随机3D顶点的TubeGeometry](img/Figure_6.7_B18726.jpg)'
- en: Figure 6.7 – TubeGeometry based on random 3D vertices
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 基于随机3D顶点的TubeGeometry
- en: 'As you can see in this example, we generate a number of random points and use
    those points to draw the tube. With the controls in the menu, we can define how
    the tube looks. The code needed to create a tube is very simple, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个示例中所看到的，我们生成了一些随机点，并使用这些点来绘制管状体。通过菜单中的控件，我们可以定义管状体的外观。创建管状体所需的代码非常简单，如下所示：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What we need to do first is get a set of vertices (the `points` variable) of
    the `THREE.Vector3` type, just like we did for `THREE.ConvexGeometry` and `THREE.LatheGeometry`.
    Before we can use these points, however, to create the tube, we first need to
    convert these points to `THREE.Curve`. In other words, we need to define a smooth
    curve through the points we defined. We can do this simply by passing in the array
    of vertices to the constructor of `THREE.CatmullRomCurve3`, or any of the other
    `Curve` implementations provided by Three.js. With this curve and the other arguments
    (which we’ll explain in this section), we can create the tube and add it to the
    scene.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要获取一组顶点（`points`变量），这些顶点是`THREE.Vector3`类型，就像我们为`THREE.ConvexGeometry`和`THREE.LatheGeometry`所做的那样。然而，在我们能够使用这些点来创建管状体之前，我们首先需要将这些点转换为`THREE.Curve`。换句话说，我们需要定义一条通过我们定义的点的平滑曲线。我们可以通过将顶点数组传递给`THREE.CatmullRomCurve3`的构造函数，或者任何由Three.js提供的其他`Curve`实现来实现这一点。有了这条曲线和其他参数（我们将在本节中解释），我们可以创建管状体并将其添加到场景中。
- en: 'In this example, we’ve used `THREE.CatmullRomCurve3`. Three.js provides a number
    of other curves you can use as well that take slightly different arguments, but
    they can be used to create different curve implementations. Out of the box, Three.js
    comes with the following curves: `ArcCurve`, `CatmullRomCurve3`,`CubicBezierCurve`,`Cub``icBezierCurve3`,`EllipseCurve`,`LineCurve`,`LineCurve3`,`QuadraticBezierCurve`,     `QuadraticBezierCurve3`, and `SplineCurve`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`THREE.CatmullRomCurve3`。Three.js提供了一些其他曲线，您也可以使用，它们接受略微不同的参数，但它们可以用来创建不同的曲线实现。开箱即用，Three.js提供了以下曲线：`ArcCurve`、`CatmullRomCurve3`、`CubicBezierCurve`、`CubicBezierCurve3`、`EllipseCurve`、`LineCurve`、`LineCurve3`、`QuadraticBezierCurve`、`QuadraticBezierCurve3`和`SplineCurve`。
- en: '`THREE.TubeGeometry` takes some other arguments besides the curve. The following
    lists all the arguments for `THREE.TubeGeometry`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.TubeGeometry`除了曲线之外还接受一些其他参数。以下列出了`THREE.TubeGeometry`的所有参数：'
- en: '`path`: This is `THREE.SplineCurve3`, which describes the path this tube should
    follow.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：这是`THREE.SplineCurve3`，它描述了管状体应该遵循的路径。'
- en: '`tubularSegments`: These are the segments used to build up the tube. The default
    value is `64`. The longer the path, the more segments you should specify.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tubularSegments`：这些是构建管状体所使用的段数。默认值为`64`。路径越长，您应该指定的段数就越多。'
- en: '`radius`: This is the radius of the tube. The default value is `1`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radius`：这是管状体的半径。默认值为`1`。'
- en: '`radiusSegments`: This is the number of segments to be used along the length
    of the tube. The default value is `8`. The more you use, the more round the tube
    will look.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radiusSegments`：这是沿管状体长度使用的段数。默认值为`8`。您使用的越多，管状体看起来就越圆。'
- en: '`closed`: If this is set to `true`, the start and the end of the tube will
    be connected. The default value is `false`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closed`：如果设置为`true`，管状体的起始和结束将连接起来。默认值为`false`。'
- en: The last extrude example we’ll show in this chapter isn’t really a different
    type of geometry, but we’ll use `THREE.ExtrudeGeometry` to create extrusions from
    an SVG image.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将展示的最后一个是拉伸示例，它实际上并不是一种不同的几何类型，但我们将使用`THREE.ExtrudeGeometry`从SVG图像创建拉伸体。
- en: What is SVG?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是SVG？
- en: SVG is an XML-based standard that can be used to create vector-based 2D images
    for the web. This is an open standard that is supported by all modern browsers.
    Directly working with SVG and manipulating it from JavaScript, however, isn’t
    very straightforward. Luckily, there are a couple of open source JavaScript libraries
    that make working with SVG a lot easier. `Paper.js`, `Snap.js`, `D3.js`, and `Raphael.js`
    are some of the best. If you want a graphical editor, you can also use the open
    source Inkscape product.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 是一种基于 XML 的标准，可以用于在网络上创建基于矢量的 2D 图像。这是一个由所有现代浏览器支持的开源标准。然而，直接使用 SVG 并从 JavaScript
    中操作它并不是非常直接。幸运的是，有几个开源 JavaScript 库使得处理 SVG 变得容易得多。`Paper.js`、`Snap.js`、`D3.js`
    和 `Raphael.js` 是其中一些最好的。如果你需要一个图形编辑器，你还可以使用开源的 Inkscape 产品。
- en: Extruding 3D shapes from an SVG element
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 SVG 元素拉伸 3D 形状
- en: 'When we discussed `THREE.ShapeGeometry` in [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081),
    we mentioned that SVG follows pretty much the same approach to drawing shapes.
    In this section, we’ll look at how you can use SVG images together with `THREE.SVGLoader`
    to extrude SVG images. We’ll use the Batman logo as an example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [*第 5 章*](B18726_05.xhtml#_idTextAnchor081) 中讨论 `THREE.ShapeGeometry` 时，我们提到
    SVG 遵循几乎相同的绘图形状方法。在本节中，我们将探讨如何使用 SVG 图像与 `THREE.SVGLoader` 一起拉伸 SVG 图像。我们将使用蝙蝠侠标志作为示例：
- en: '![Figure 6.8 – The Batman SVG base image](img/Figure_6.8_B18726.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 蝙蝠侠 SVG 基础图像](img/Figure_6.8_B18726.jpg)'
- en: Figure 6.8 – The Batman SVG base image
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 蝙蝠侠 SVG 基础图像
- en: 'First, let’s look at what the original SVG code looks like (you can also see
    this for yourself when looking at the source code of the `assets/svg/batman.svg`
    file):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看原始 SVG 代码的样子（你还可以在查看 `assets/svg/batman.svg` 文件的源代码时自己查看）：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unless you’re an SVG guru, this probably won’t mean too much to you. Basically
    though, what you see here is a set of drawing instructions. For instance, `C 277.987
    119.348 279.673 116.786 279.673 115.867` tells the browser to draw a cubic Bezier
    curve, and `L 489.242 111.787` tells us that we should draw a line to that specific
    position. Luckily though, we won’t have to write the code to interpret this ourselves
    and can use `THREE.SVGLoader` instead, as you can see in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你是 SVG 大师，否则这对你来说可能意义不大。不过，基本上，你在这里看到的是一组绘图指令。例如，`C 277.987 119.348 279.673
    116.786 279.673 115.867` 告诉浏览器绘制一个三次贝塞尔曲线，而 `L 489.242 111.787` 告诉我们应该绘制到那个特定位置。幸运的是，我们不需要自己编写代码来解释这些，可以使用
    `THREE.SVGLoader`，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code fragment, you can see that we use `SVGLoader` to load the SVG file.
    We use `loadAsync` here, which will return a JavaScript `Promise`. When that `Promise`
    resolves, we get access to the loaded `svg` data. This data can contain a list
    of `path` elements, each representing the `path` element of the original SVG.
    In our example, we’ve only got one, so we use `svg.paths[0]` and pass it into
    `SVGLoader.createShapes` to convert it into an array of `THREE.Shape` objects.
    Now that we’ve got the shapes, we can use the same approach we used earlier when
    we extruded our custom-created 2D geometry and use `THREE.ExtrudeGeometry` to
    create a 3D model from the 2D-loaded SVG shapes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，你可以看到我们使用 `SVGLoader` 来加载 SVG 文件。我们在这里使用 `loadAsync`，它将返回一个 JavaScript
    `Promise`。当这个 `Promise` 解决时，我们可以访问加载的 `svg` 数据。这些数据可以包含一个 `path` 元素列表，每个元素代表原始
    SVG 的 `path` 元素。在我们的例子中，我们只有一个，所以我们使用 `svg.paths[0]` 并将其传递给 `SVGLoader.createShapes`
    以将其转换为 `THREE.Shape` 对象的数组。现在我们有了这些形状，我们可以使用之前当我们拉伸自定义创建的 2D 几何形状时使用的方法，并使用 `THREE.ExtrudeGeometry`
    从加载的 2D SVG 形状创建 3D 模型。
- en: 'The final result can be seen when you open the `extrude-svg.html` example in
    the browser:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果可以在浏览器中打开 `extrude-svg.html` 示例时看到：
- en: '![Figure 6.9 – A 3D-created Batman logo extruded from a 2D SVG image](img/Figure_6.9_B18726.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 从 2D SVG 图像拉伸创建的 3D 蝙蝠侠标志](img/Figure_6.9_B18726.jpg)'
- en: Figure 6.9 – A 3D-created Batman logo extruded from a 2D SVG image
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 从 2D SVG 图像拉伸创建的 3D 蝙蝠侠标志
- en: The last geometry we’ll discuss in this section is `THREE.ParametricGeometry`.
    With this geometry, you can specify a couple of functions that are used to programmatically
    create geometries.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论的最后一种几何形状是 `THREE.ParametricGeometry`。使用这种几何形状，你可以指定几个函数，这些函数用于程序化地创建几何形状。
- en: THREE.ParametricGeometry
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.ParametricGeometry
- en: With `THREE.ParametricGeometry`, you can create a geometry based on an equation.
    Before we dive into our own example, a good thing to start with is to look at
    the examples already provided by Three.js. When you download the Three.js distribution,
    you get the `examples/js/ParametricGeometries.js` file. In this file, you can
    find a couple of examples of equations you can use together with `THREE.ParametricGeometry`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.ParametricGeometry`，你可以根据一个方程创建一个几何体。在我们自己的例子深入之前，一个好的开始是查看 Three.js
    已经提供的示例。当你下载 Three.js 分发版时，你会得到 `examples/js/ParametricGeometries.js` 文件。在这个文件中，你可以找到一些你可以与
    `THREE.ParametricGeometry` 一起使用的方程示例。
- en: 'The most basic example is the function to create a plane:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的例子是创建平面的函数：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function is called by `THREE.ParametricGeometry`. The `u` and `v` values
    will range from `0` to `1` and will be called a large number of times, for all
    the values from `0` to `1`. In this example, the `u` value is used to determine
    the `x` coordinate of the vector, and the `v` value is used to determine the `z`
    coordinate. When this is run, you’ll have a basic plane with a width of `width`
    and a depth of `depth`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是由 `THREE.ParametricGeometry` 调用的。`u` 和 `v` 值将在 `0` 到 `1` 之间变化，并且将被多次调用，涵盖从
    `0` 到 `1` 的所有值。在这个例子中，`u` 值用于确定向量的 `x` 坐标，而 `v` 值用于确定 `z` 坐标。运行后，你将得到一个宽度为 `width`，深度为
    `depth` 的基本平面。
- en: 'In our example, we do something similar. However, instead of creating a flat
    plane, we create a wave-like pattern, as you can see in the `parametric-geometry.html`
    example. The following screenshot shows this example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们做了类似的事情。然而，我们不是创建一个平面，而是创建了一个波状图案，正如你在 `parametric-geometry.html`
    示例中看到的那样。以下截图显示了此示例：
- en: '![Figure 6.10 – A wave-like plane using a parametric geometry](img/Figure_6.10_B18726.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 使用参数化几何创建的波状平面](img/Figure_6.10_B18726.jpg)'
- en: Figure 6.10 – A wave-like plane using a parametric geometry
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 使用参数化几何创建的波状平面
- en: 'To create this shape, we passed the following function to `THREE.ParametricGeometry`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个形状，我们将以下函数传递给了 `THREE.ParametricGeometry`：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see in this example, with a few lines of code, we can create some
    really interesting geometries. In this example, you can also see the arguments
    we can pass to `THREE.ParametricGeometry`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本例中看到的，通过几行代码，我们可以创建一些非常有趣的几何体。在本例中，你还可以看到我们可以传递给 `THREE.ParametricGeometry`
    的参数：
- en: '`function`: This is the function that defines the position of each vertex based
    on the `u` and `v` values provided'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`：这是一个函数，它根据提供的 `u` 和 `v` 值定义每个顶点的位置'
- en: '`slices`: This defines the number of parts the `u` value should be divided
    into'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slices`：这定义了 `u` 值应该被分成多少部分'
- en: '`stacks`: This defines the number of parts the `v` value should be divided
    into'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stacks`：这定义了 `v` 值应该被分成多少部分'
- en: 'By changing the function, we can easily use the exact same approach to render
    a completely different object:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变函数，我们可以轻松地使用完全相同的方法渲染一个完全不同的对象：
- en: '![Figure 6.11 – A Klein bottle rendered using a parametric geometry](img/Figure_6.11_B18726.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 使用参数化几何渲染的克莱因瓶](img/Figure_6.11_B18726.jpg)'
- en: Figure 6.11 – A Klein bottle rendered using a parametric geometry
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 使用参数化几何渲染的克莱因瓶
- en: 'Here’s a final note on how to use the `slices` and `stacks` properties before
    moving on to the next part of this chapter. We mentioned that the `u` and `v`
    properties are passed into the function argument provided and that the values
    of these two properties range from `0` to `1`. With the `slices` and `stacks`
    properties, we can define how often the passed-in function is called. If, for
    instance, we set `slices` to `5` and `stacks` to `4`, the function will be called
    with the following values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章下一部分之前，关于如何使用 `slices` 和 `stacks` 属性的最后一点说明。我们提到 `u` 和 `v` 属性被传递到提供的函数参数中，并且这两个属性的值范围从
    `0` 到 `1`。通过 `slices` 和 `stacks` 属性，我们可以定义传递的函数被调用的频率。例如，如果我们把 `slices` 设置为 `5`，`stacks`
    设置为 `4`，函数将使用以下值被调用：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, the higher these values are, the more vertices you get to specify and the
    smoother your created geometry will be. You can use the menu at the right of the
    `parametric-geometry.html` example to see this effect.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些值越高，你可以指定更多的顶点，你创建的几何体将越平滑。你可以使用 `parametric-geometry.html` 示例右侧的菜单来查看这种效果。
- en: 'For more examples, you can look at the `examples/js/ParametricGeometries.js`
    file in the Three.js distribution. This file contains functions to create the
    following geometries:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多示例，你可以查看 Three.js 分发版中的 `examples/js/ParametricGeometries.js` 文件。这个文件包含创建以下几何体的函数：
- en: Klein bottle
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克莱因瓶
- en: Plane
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面
- en: Flat Mobius strip
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面莫比乌斯带
- en: 3D Mobius strip
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D 莫比乌斯带
- en: Tube
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Torus knot
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环面结
- en: Sphere
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球体
- en: Plane
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面
- en: Sometimes, you need to see more details about your geometry, and you don’t care
    too much about materials and how the mesh will be rendered. If you want to look
    at the vertices and the faces, or even just the outline, Three.js provides a couple
    of geometries that can help you with this (besides enabling the `wireframe` property
    of the material you use for the mesh). We’ll explore these in the following section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要看到更多关于你的几何体的细节，而你并不太关心材质以及网格如何渲染。如果你想查看顶点和面，或者仅仅是轮廓，Three.js 提供了一些几何体可以帮助你实现这一点（除了启用你用于网格的材质的
    `wireframe` 属性）。我们将在下一节中探讨这些内容。
- en: Geometries you can use for debugging
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可以用于调试的几何体
- en: 'Three.js comes with two helper geometries out of the box that make it easier
    to see the details or just the outline of a geometry:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 默认提供了两个辅助几何体，这使得查看几何体的细节或仅仅是轮廓变得更加容易：
- en: '`THREE.EdgesGeometry`, which provides a geometry that only renders the edges
    of a geometry'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.EdgesGeometry` 提供了一个只渲染几何体边的几何体'
- en: '`THREE.WireFrameGeometry`, which renders just the geometry without showing
    any faces'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.WireFrameGeometry`，它只渲染几何体而不显示任何面'
- en: First, let’s look at `THREE.EdgesGeometry`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `THREE.EdgesGeometry`。
- en: THREE.EdgesGeometry
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.EdgesGeometry
- en: 'With `THREE.EdgesGeometry`, you wrap an existing geometry, which is then rendered
    by just showing the edges and not the individual vertices and faces. An example
    of this is shown in the `edges-geometry.html` example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.EdgesGeometry`，你包裹一个现有的几何体，然后通过只显示边而不是单独的顶点和面来渲染。一个例子可以在 `edges-geometry.html`
    示例中看到：
- en: '![Figure 6.12 – EdgesGeometry only showing the edges, not the individual faces](img/Figure_6.12_B18726.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 只显示边而不显示单独面的 EdgesGeometry](img/Figure_6.12_B18726.jpg)'
- en: Figure 6.12 – EdgesGeometry only showing the edges, not the individual faces
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 只显示边而不显示单独面的 EdgesGeometry
- en: In the previous screenshot, you can see that the outline of `RoundedBoxGeometry`
    is shown, where we just see the edges. Since `RoundedBoxGeometry` has smooth corners,
    those are shown when using `THREE.EdgesGeometry`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到 `RoundedBoxGeometry` 的轮廓被显示出来，我们只看到了边。由于 `RoundedBoxGeometry`
    有平滑的角落，这些角落在使用 `THREE.EdgesGeometry` 时会被显示出来。
- en: 'To use this geometry, you just wrap an existing geometry like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个几何体，你只需将现有的几何体像这样包裹起来：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only property `THREE.EdgesGeometry` takes is `thresholdAngle`. With this
    property, you can determine when this geometry draws an edge. In `edges-geometry.html`,
    you can control this property to see the effect.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.EdgesGeometry` 只接受一个属性 `thresholdAngle`。通过这个属性，你可以确定何时这个几何体绘制边。在 `edges-geometry.html`
    中，你可以控制这个属性以查看效果。'
- en: 'If you’ve got an existing geometry and want to see the wireframe, you can configure
    a material to show this wireframe:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个现有的几何体并且想查看线框，你可以配置一个材质来显示这个线框：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Three.js also provides a different way of using `THREE.WireFrameGeometry`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 还提供了一种使用 `THREE.WireFrameGeometry` 的不同方式。
- en: THREE.WireFrameGeometry
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.WireFrameGeometry
- en: 'This geometry simulates the behavior you see when you set the `wireframe` property
    of a material to `true`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个几何体模拟了当你将材质的 `wireframe` 属性设置为 `true` 时看到的行为：
- en: '![Figure 6.13 – Wireframe geometry showing all the individual faces of a geometry](img/Figure_6.13_B18726.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 显示几何体所有单独面的线框几何体](img/Figure_6.13_B18726.jpg)'
- en: Figure 6.13 – Wireframe geometry showing all the individual faces of a geometry
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 展示几何体所有单独面的线框几何体
- en: 'Using this material works in the same way as using `THREE.EdgesGeometry`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个材质的方式与使用 `THREE.EdgesGeometry` 相同：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This geometry doesn’t take any additional properties.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个几何体不接收任何额外的属性。
- en: The last part of this chapter deals with creating 3D text objects. We’ll show
    you two different approaches, one with the `THREE.Text` object and one where we
    use an external library.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分将处理创建 3D 文本对象。我们将展示两种不同的方法，一种使用 `THREE.Text` 对象，另一种则使用外部库。
- en: Creating a 3D text mesh
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 3D 文本网格
- en: In this section, we’ll have a quick look at how you can create 3D text. First,
    we’ll look at how to render text using the fonts provided by Three.js, and how
    you can use your own fonts for this. Then, we’ll show a quick example of using
    an external library called Troika ([https://github.com/protectwise/troika](https://github.com/protectwise/troika))
    that makes it really easy to create labels and 2D text elements and add them to
    your scene.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速查看如何创建 3D 文本。首先，我们将查看如何使用 Three.js 提供的字体渲染文本，以及如何使用你自己的字体。然后，我们将展示一个使用外部库
    Troika ([https://github.com/protectwise/troika](https://github.com/protectwise/troika))
    的快速示例，该库使得创建标签和 2D 文本元素并将其添加到场景中变得非常容易。
- en: Rendering text
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染文本
- en: 'Rendering text in Three.js is very easy. All you have to do is define the font
    you want to use and use the same extrude properties we saw when we discussed `THREE.ExtrudeGeometry`.
    The following screenshot shows a `text-geometry.html` example of how to render
    text in Three.js:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 中渲染文本非常简单。你只需要定义你想要使用的字体，并使用我们在讨论 `THREE.ExtrudeGeometry` 时看到的相同拉伸属性。以下截图显示了
    `text-geometry.html` 示例，展示了如何在 Three.js 中渲染文本：
- en: '![Figure 6.14 – Rendering text in Three.js](img/Figure_6.14_B18726.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – 在 Three.js 中渲染文本](img/Figure_6.14_B18726.jpg)'
- en: Figure 6.14 – Rendering text in Three.js
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 在 Three.js 中渲染文本
- en: 'The code required to create this 3D text is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此 3D 文本所需的代码如下：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code fragment, you can see that we first have to load the font. For
    this, Three.js provides `FontLoader()`, where we provide the name of the font
    to load, just like we did with `SVGLoader`, where we get back a JavaScript `Promise`.
    Once that `Promise` resolves, we use the loaded font to create `TextGeometry`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，你可以看到我们首先必须加载字体。为此，Three.js 提供了 `FontLoader()`，我们提供要加载的字体名称，就像我们在 `SVGLoader`
    中做的那样，我们得到一个 JavaScript `Promise`。一旦该 `Promise` 解决，我们使用加载的字体来创建 `TextGeometry`。
- en: 'The options we can pass into `THREE.TextGeometry` match those that we can pass
    into `THREE.ExtrudeGeometry`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递给 `THREE.TextGeometry` 的选项与我们可以传递给 `THREE.ExtrudeGeometry` 的选项相同：
- en: '`font`: The loaded font to use for the text.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font`：用于文本的加载字体。'
- en: '`size`: This is the size of the text. The default value is `100`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：这是文本的大小。默认值是 `100`。'
- en: '`height`: This is the length (depth) of the extrusion. The default value is
    `50`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`：这是拉伸的长度（深度）。默认值是 `50`。'
- en: '`curveSegments`: This defines the number of segments used when extruding the
    curves of shapes. The more segments there are, the smoother the curves will look.
    The default value is `4`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curveSegments`：这定义了在拉伸形状的曲线时使用的段数。段数越多，曲线看起来越平滑。默认值是 `4`。'
- en: '`bevelEnabled`: If this is set to `true`, a bevel is added. The default value
    is `false`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevelEnabled`：如果设置为 `true`，则添加斜面。默认值是 `false`。'
- en: '`bevelThickness`: This is the depth of the bevel. The bevel is the rounded
    corner between the front and back faces and the extrusion. The default value is
    `10`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevelThickness`：这是斜面的深度。斜面是前后面和拉伸之间的圆角。默认值是 `10`。'
- en: '`bevelSize`: This is the height of the bevel. The default value is `8`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevelSize`：这是斜面的高度。默认值是 `8`。'
- en: '`bevelSegments`: This defines the number of segments that will be used by the
    bevel. The more segments there are, the smoother the bevel will look. The default
    value is `3`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevelSegments`：这定义了斜面将使用的段数。段数越多，斜面看起来越平滑。默认值是 `3`。'
- en: '`bevelOffset`: This is the distance from the outline of the shape where the
    bevel starts. The default value is `0`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bevelOffset`：这是斜面开始处的形状轮廓的距离。默认值是 `0`。'
- en: Since `THREE.TextGeometry` is also `THREE.ExtrudeGeometry`, the same approach
    applies if you want to use a different material for the front and the sides of
    the material. If you pass in an array of two materials when creating `THREE.Mesh`,
    Three.js will apply the first material to the front and the back of the text,
    and the second one to the sides.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `THREE.TextGeometry` 也是 `THREE.ExtrudeGeometry`，因此如果你想要为材质的前面和侧面使用不同的材质，则适用相同的方法。如果你在创建
    `THREE.Mesh` 时传入一个包含两种材质的数组，Three.js 将将第一种材质应用于文本的前面和背面，第二种材质应用于侧面。
- en: It’s also possible to use other fonts with this geometry, but you first need
    to convert them to JSON – how to do this is shown in the next section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此几何形状也可以使用其他字体，但首先需要将它们转换为 JSON – 如何进行此操作将在下一节中展示。
- en: Adding custom fonts
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义字体
- en: There are a couple of fonts provided by Three.js that you can use in your scenes.
    These fonts are based on the fonts provided by the `TypeFace.js` library. `TypeFace.js`
    is a library that can convert TrueType and OpenType fonts to JavaScript. The resulting
    JavaScript file or JSON file can be included in your page, and the font can then
    be used in Three.js. In older versions, the JavaScript file was used, but in later
    Three.js versions, Three.js switched to using the JSON file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了一些字体，你可以在场景中使用这些字体。这些字体基于 `TypeFace.js` 库提供的字体。`TypeFace.js` 是一个可以将
    TrueType 和 OpenType 字体转换为 JavaScript 的库。生成的 JavaScript 文件或 JSON 文件可以包含在你的页面中，然后该字体就可以在
    Three.js 中使用。在旧版本中，使用了 JavaScript 文件，但在后来的 Three.js 版本中，Three.js 转向使用 JSON 文件。
- en: 'To convert an existing OpenType or TrueType font, you can use the web page
    at [https://gero3.github.io/facetype.js/](https://gero3.github.io/facetype.js/):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要将现有的 OpenType 或 TrueType 字体转换为字体支持的格式，你可以使用网页 [https://gero3.github.io/facetype.js/](https://gero3.github.io/facetype.js/)：
- en: '![Figure 6.15 – Converting a font to a typeface-supported format](img/Figure_6.15_B18726.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – 将字体转换为字体支持的格式](img/Figure_6.15_B18726.jpg)'
- en: Figure 6.15 – Converting a font to a typeface-supported format
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 将字体转换为字体支持的格式
- en: 'On this page, you can upload a font, and it will be converted to JSON for you.
    Note that this won’t work so well for all types of fonts. The simpler the font
    (more straight lines), the better the chance that it will be rendered correctly
    when used in Three.js. The resulting file looks like this, where each of the characters
    (or glyphs) is described:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，你可以上传一个字体，它将为你转换为 JSON。请注意，这并不适用于所有类型的字体。字体越简单（直线越多），在 Three.js 中使用时正确渲染的机会就越大。生成的文件看起来像这样，其中每个字符（或符号）都被描述：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once you’ve got the JSON file, you can use `FontLoader` (as we showed previously
    in the *Rendering text* section) to load this font and assign it to the `font`
    property of the options you can pass into `TextGeometry`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 JSON 文件，你可以使用 `FontLoader`（如我们在 *渲染文本* 部分之前所展示的）来加载这个字体，并将其分配给可以传递给 `TextGeometry`
    的选项中的 `font` 属性。
- en: For the final example of this chapter, we’re going to look at a different way
    to create text with Three.js.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个例子中，我们将探讨使用 Three.js 创建文本的另一种方法。
- en: Creating text using the Troika library
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Troika 库创建文本
- en: 'If you want to create labels or 2D text marks for certain parts of your scene,
    there is an alternative option to using the `THREE.Text` geometry. You can also
    use an external library called Troika: [https://github.com/protectwise/troika](https://github.com/protectwise/troika).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为场景的某些部分创建标签或 2D 文本标记，有一个替代选项是使用 `THREE.Text` 几何体。你还可以使用一个名为 Troika 的外部库：[https://github.com/protectwise/troika](https://github.com/protectwise/troika)。
- en: 'This is a fairly big library that provides lots of functionalities to add interactivity
    to your scenes. For this example, we’ll only look at the text module of that library.
    An example of what we’re going to create is shown in the `troika-text.html` example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当大的库，提供了许多功能来为你的场景添加交互性。对于这个例子，我们只关注该库的文本模块。我们将创建的示例在 `troika-text.html`
    示例中展示：
- en: '![Figure 6.16 – Troika text for 2D labels](img/Figure_6.16_B18726.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – Troika 文本用于 2D 标签](img/Figure_6.16_B18726.jpg)'
- en: Figure 6.16 – Troika text for 2D labels
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 2D 标签的 Troika 文本
- en: 'To use this library, we first have to install it (if you followed the instructions
    from [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D
    Scene with Three.js*, you can already use this library): `$ yarn add troika-three-text`.
    Once installed, we can import it and use it just like we do with the rest of the
    modules provided by Three.js:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个库，我们首先必须安装它（如果你遵循了 [*第 1 章*](B18726_01.xhtml#_idTextAnchor014)，*使用 Three.js
    创建你的第一个 3D 场景* 的说明，你现在已经可以使用这个库了）：`$ yarn add troika-three-text`。一旦安装，我们就可以导入它并像使用
    Three.js 提供的其他模块一样使用它：
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the previous code fragment, we showed how you can use Troika to create a
    simple text element. You only need to call the `Text()` constructor and set the
    properties. One thing to keep in mind, however, is that whenever you change a
    property in the `Text()` object, you have to call `troikaText.sync()`. That will
    make sure that the changes are also applied to the model rendered on the screen.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们展示了如何使用 Troika 创建一个简单的文本元素。你只需要调用 `Text()` 构造函数并设置属性。然而，需要注意的是，每次你在
    `Text()` 对象中更改属性时，都必须调用 `troikaText.sync()`。这将确保更改也应用于屏幕上渲染的模型。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We saw a lot in this chapter. We introduced a couple of advanced geometries
    and showed you how you can create and render text elements with Three.js. We showed
    you how you can create really beautiful shapes using advanced geometries such
    as `THREE.ConvexGeometry`, `THREE.TubeGeometry`, and `THREE.LatheGeometry` and
    how can you experiment with these geometries to get the results you’re looking
    for. A very nice feature is that we can also convert existing SVG paths to Three.js
    using `THREE.ExtrudeGeometry`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了很多内容。我们介绍了几种高级几何形状，并展示了如何使用Three.js创建和渲染文本元素。我们展示了如何使用高级几何形状，如`THREE.ConvexGeometry`、`THREE.TubeGeometry`和`THREE.LatheGeometry`来创建非常漂亮的形状，以及如何通过实验这些几何形状来获得你想要的结果。一个非常棒的功能是，我们还可以使用`THREE.ExtrudeGeometry`将现有的SVG路径转换为Three.js。
- en: We’ve also quickly looked at a couple of geometries that are very useful for
    debugging purposes. `THREE.EdgesGeometry` shows just the edges of another geometry,
    and `THREE.WireframeGeometry` can be used to show the wireframe of some other
    geometry.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还快速查看了几种非常有用的调试几何形状。`THREE.EdgesGeometry`仅显示另一个几何形状的边，而`THREE.WireframeGeometry`可以用来显示某些其他几何形状的线框。
- en: Finally, if you want to create 3D text, Three.js provides `TextGeometry`, where
    you can pass in a font that you want to use. Three.js comes with a couple of fonts,
    but you can also create your own fonts. However, remember that complex fonts often
    won’t convert correctly. An alternative to using `TextGeometry` is using the Troika
    library, which makes it very easy to create 2D text labels and place them anywhere
    in the scene.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想创建3D文本，Three.js提供了`TextGeometry`，你可以传入你想要使用的字体。Three.js自带了一些字体，但你也可以创建自己的字体。然而，请记住，复杂的字体通常无法正确转换。使用`TextGeometry`的替代方案是使用Troika库，它使得创建2D文本标签并将其放置在场景中的任何位置变得非常容易。
- en: Until now, we looked at solid (or wireframe) geometries, where vertices are
    connected to each other to form faces. In the upcoming chapter, we’ll look at
    an alternative way of visualizing geometries using something called particles
    or points. With particles, we don’t render complete geometries — we just render
    the individual vertices as points in space. This allows you to create great-looking
    3D effects that perform well.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们查看的是实体（或线框）几何形状，其中顶点相互连接以形成面。在下一章中，我们将探讨一种使用称为粒子或点的东西来可视化几何形状的替代方法。使用粒子，我们不渲染完整的几何形状——我们只是将单个顶点作为空间中的点进行渲染。这允许你创建看起来很棒且性能良好的3D效果。
