- en: Chapter 2. Your First Spec
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 你的第一个规范
- en: This chapter is about the basics, and we are going to guide you through how
    to write your first spec, think in test-first terms for development, and also
    show you all the available global Jasmine functions. By the end of the chapter,
    you should know how Jasmine works and be ready to start doing your first tests
    by yourself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于基础知识的，我们将指导你如何编写你的第一个规范，以测试优先的思维方式进行开发，并展示所有可用的全局 Jasmine 函数。到本章结束时，你应该了解
    Jasmine 的工作原理，并准备好开始自己进行第一次测试。
- en: The Investment Tracker application
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投资跟踪器应用程序
- en: 'To get you started, we need an example scenario: consider that you are developing
    an application to track investments in the stock market.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你开始，我们需要一个示例场景：假设你正在开发一个用于跟踪股票市场投资的程序。
- en: 'The following screenshot of the form illustrates how a user might create a
    new investment on this application:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的表格截图说明了用户如何在这个应用程序上创建一个新的投资：
- en: '![The Investment Tracker application](img/B04138_02_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![投资跟踪器应用程序](img/B04138_02_01.jpg)'
- en: This is a form to add investments
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个添加投资的表格
- en: 'This form will allow the input of three values that define an investment:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格将允许输入定义投资的三个值：
- en: First, we will input **Symbol**, which represents which company (stock) the
    user is investing in
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将输入**符号**，它代表用户正在投资的公司（股票）
- en: Then, we will input how many **Shares** the user has bought (or invested in)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将输入用户购买的**股票**数量（或投资的数量）
- en: Finally, we will input how much the user has paid for each share (**Share price**)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将输入用户为每份股票支付的价格（**股票价格**）
- en: 'If you are unfamiliar with how the stock market works, imagine you are shopping
    for groceries. To make a purchase, you must specify what you are buying, how many
    items you are buying, and how much you are going to pay. These concepts translate
    to an investment as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对股市的工作方式不熟悉，想象你正在购买杂货。为了购买，你必须指定你要买什么，你要买多少件，以及你打算支付多少钱。这些概念在投资中可以转化为：
- en: A stock, which is defined by a symbol, such as `PETO`, can be understood to
    be a grocery type
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由符号定义的股票，例如`PETO`，可以理解为一种杂货类型
- en: The number of shares is the quantity of items you have purchased
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票数量是你所购买的物品数量
- en: The share price is the unit price of each item
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票价格是每个项目的单价
- en: 'Once the user has added an investment, it must be listed along with their other
    investments, as shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户添加了投资，它必须与其他投资一起列出，如下面的屏幕截图所示：
- en: '![The Investment Tracker application](img/B04138_02_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![投资跟踪器应用程序](img/B04138_02_02.jpg)'
- en: This is a form and list of investments
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个投资表格和列表
- en: The idea is to display how well their investments are going. Since the prices
    of the stocks fluctuate over time, the difference between the price the user has
    paid and the current price indicates whether it is a good (profit) or a bad (loss)
    investment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目的是显示他们的投资进展得如何。由于股票价格随时间波动，用户支付的价格与当前价格之间的差额表明这是一项好（盈利）的投资还是一项坏（亏损）的投资。
- en: 'In the preceding screenshot, we can see that the user has two investments:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到用户有两个投资：
- en: One is in the `AOUE` stock, which is scoring a profit of `101.80%`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个是`AOUE`股票，盈利了`101.80%`
- en: Another is in the `PETO` stock, which is scoring a loss of `-42.34%`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个是`PETO`股票，损失了`-42.34%`
- en: This is a very simple application, and we will get a deeper understanding of
    its functionality as we go on with its development.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的应用程序，随着我们继续其开发，我们将对其功能有更深入的了解。
- en: Jasmine basics and thinking in BDD
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jasmine 基础知识和 BDD 思维
- en: 'Based on the application presented previously, we can start writing acceptance
    criteria that define investment:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基于之前提出的应用，我们可以开始编写定义投资的验收标准：
- en: Given an investment, it should be of a stock
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一项投资，它应该是股票
- en: Given an investment, it should have the invested shares' quantity
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一项投资，它应该有投资的股票数量
- en: Given an investment, it should have the share price paid
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一项投资，它应该有支付的股票价格
- en: Given an investment, it should have a cost
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一项投资，它应该有一个成本
- en: 'Using the standalone distribution downloaded in the previous chapter, the first
    thing we need to do is create a new spec file. This file can be created anywhere,
    but it is a good idea to stick to a convention, and Jasmine already has a good
    one: specs should be in the `/spec` folder. Create an `InvestmentSpec.js` file
    and add the following lines:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一章下载的独立分发版，我们首先需要创建一个新的规范文件。此文件可以创建在任何位置，但坚持一种约定是个好主意，Jasmine 已经有一个很好的约定：规范应该放在`/spec`文件夹中。创建一个`InvestmentSpec.js`文件，并添加以下行：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `describe` function is a global Jasmine function used to define test contexts.
    When used as the first call in a spec, it creates a new test suite (a collection
    of test cases). It accepts two parameters, which are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`函数是一个全局 Jasmine 函数，用于定义测试上下文。当在规范中作为第一个调用时，它创建一个新的测试套件（一组测试用例）。它接受两个参数，如下所述：'
- en: The name of the test suite—in this case, `Investment`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试套件的名称——在这个例子中，是`Investment`
- en: A `function` that will contain all its specs
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将包含所有其规范的`function`
- en: 'Then, to translate the first acceptance criterion (given an investment, it
    should be of a stock) into a Jasmine spec (or test case), we are going to use
    another global Jasmine function called `it`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了将第一个验收标准（给定一项投资，它应该是股票）翻译成 Jasmine 规范（或测试用例），我们将使用另一个全局 Jasmine 函数`it`：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It also accepts two parameters, which are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它也接受两个参数，如下所述：
- en: The title of the spec—in this case, `should be of a stock`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范的标题——在这个例子中，是`should be of a stock`
- en: A function that will contain the spec code
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将包含规范代码的`function`
- en: 'To run this spec, add it to the runner, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此规范，将其添加到运行器中，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute the spec by opening the runner on the browser. The following output
    can be seen:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在浏览器上打开运行器来执行规范。可以看到以下输出：
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine 基础和 BDD 思维](img/B04138_02_03.jpg)'
- en: This is the first spec's passing result on the browser
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个规范在浏览器上的通过结果
- en: It might sound strange to have an empty spec passing, but in Jasmine, as with
    other test frameworks, a failed assertion is required to make the spec fail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 空规范通过可能听起来很奇怪，但在 Jasmine 中，就像其他测试框架一样，需要失败的断言来使规范失败。
- en: An **assertion** (or expectation) is a comparison between two values that must
    result in a boolean value. The assertion is only considered a success if the result
    of the comparison is true.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言**（或期望）是两个值之间的比较，必须得到一个布尔值。只有当比较的结果为真时，断言才被认为是成功的。'
- en: In Jasmine, assertions are written using the global Jasmine function `expect`,
    along with a **matcher** that indicates what comparison must be made with the
    values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jasmine 中，断言是通过全局 Jasmine 函数`expect`以及一个**匹配器**来编写的，该匹配器指示必须对值进行何种比较。
- en: 'Regarding the current spec (it is expected that the investment is of a stock),
    in Jasmine this translates to the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于当前规范（预期这是一项股票投资），在 Jasmine 中这会转换为以下代码：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Add the preceding highlighted code to the `InvestmentSpec.js` file. The `expect`
    function takes only one parameter, which defines the **actual value**, or in other
    words, what is going to be tested—`investment.stock`—and expects the chaining
    call to a matcher function, which in this case is `toBe`. That defines the **expected
    value**, `stock`, and the comparison method to be performed (to be the same).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面高亮的代码添加到`InvestmentSpec.js`文件中。`expect`函数只接受一个参数，该参数定义了**实际值**，换句话说，将要测试的内容——`investment.stock`——并期望链式调用到一个匹配器函数，在这种情况下是`toBe`。这定义了**预期值**`stock`以及要执行的比较方法（相同）。
- en: Behind the scenes, Jasmine makes a comparison to check whether the actual value
    (`investment.stock`) and expected value (`stock`) are the same, and if they are
    not, the test fails.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Jasmine 会进行一个比较，检查实际值（`investment.stock`）和预期值（`stock`）是否相同，如果不相同，测试就会失败。
- en: 'With the assertion written, the spec that previously passed has now failed,
    as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 写下断言后，之前通过的规范现在失败了，如下截图所示：
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine 基础和 BDD 思维](img/B04138_02_04.jpg)'
- en: This shows the first spec's failure results
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了第一个规范的失败结果
- en: This spec failed because, as the error message states, `investment is not defined`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范失败了，因为，正如错误信息所述，`investment`未定义。
- en: 'The idea here is to do only what the error is indicating us to do, so although
    you might feel the urge to write something else, for now let''s just create this
    `investment` variable with an `Investment` instance in the `InvestmentSpec.js`
    file, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要思想是只做错误指示我们做的事情，所以尽管你可能想写其他内容，但现在让我们先在`InvestmentSpec.js`文件中创建一个名为`investment`的`Investment`实例变量，如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Don''t worry that the `Investment()` function doesn''t exist yet; the spec
    is about to ask for it on the next run, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心`Investment()`函数还不存在；规范将在下一次运行时请求它，如下所示：
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和基于BDD的思考](img/B04138_02_05.jpg)'
- en: Here the spec asks for an Investment class
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里规范要求一个`Investment`类
- en: 'You can see that the error has changed to `Investment is not defined`. It now
    asks for the `Investment` function. So, create a new `Investment.js` file in the
    `src` folder and add it to the runner, as shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到错误已经变成了`Investment is not defined`。现在它要求`Investment`函数。因此，在`src`文件夹中创建一个新的`Investment.js`文件，并将其添加到运行器中，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To define `Investment`, write the following constructor function in the `Investment.js`
    file inside the `src` folder:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义`Investment`，在`src`文件夹内的`Investment.js`文件中写入以下构造函数：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This makes the error change. It now complains about the missing `stock` variable,
    as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得错误改变。现在它抱怨缺少`stock`变量，如下面的截图所示：
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和基于BDD的思考](img/B04138_02_06.jpg)'
- en: This shows a missing stock error
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了缺少股票的错误
- en: 'One more time, we feed the code it is asking for into the `InvestmentSpec.js`
    file, as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将它请求的代码放入`InvestmentSpec.js`文件中，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The error changes again; this time it is about the missing `Stock` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 错误再次改变；这次是关于缺少`Stock`函数：
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和基于BDD的思考](img/B04138_02_07.jpg)'
- en: Here the spec asks for a Stock class
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里规范要求一个`Stock`类
- en: 'Create a new file in the `src` folder, name it `Stock.js`, and add it to the
    runner. Since the `Stock` function is going to be a dependency of `Investment`,
    we should add it just before `Investment.js`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个新的文件，命名为`Stock.js`，并将其添加到运行器中。由于`Stock`函数将是`Investment`的依赖项，我们应该在`Investment.js`之前添加它：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Write the `Stock` constructor function to the `Stock.js` file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Stock`构造函数写入`Stock.js`文件：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, the error is about the expectation, as shown in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，错误是关于预期的，如下面的截图所示：
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和基于BDD的思考](img/B04138_02_08.jpg)'
- en: The expectation is undefined to be Stock
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 预期未定义，应为`Stock`
- en: 'To fix this and complete this exercise, open the `Investment.js` file inside
    the `src` folder, and add the reference to the `stock` parameter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题并完成这个练习，打开`src`文件夹内的`Investment.js`文件，并添加对`stock`参数的引用：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the spec file, pass `stock` as a parameter to the `Investment` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范文件中，将`stock`作为参数传递给`Investment`函数：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, you will have a passing spec:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将有一个通过规范：
- en: '![Jasmine basics and thinking in BDD](img/B04138_02_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和基于BDD的思考](img/B04138_02_09.jpg)'
- en: This shows an Investment spec that passes
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了通过的投资规范
- en: This exercise was meticulously conducted to show how a developer works by feeding
    the spec with what it wants when doing test-first development.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习被精心设计，以展示开发者如何在测试驱动开发中通过向规范提供所需的内容来工作。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The drive to write code must come from a spec that has failed. You must not
    write code unless its purpose is to fix a failed spec.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码的动力必须来自失败的规范。除非其目的是修复失败的规范，否则你不应该编写代码。
- en: Setup and teardown
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和清理
- en: 'There are three more acceptance criteria to be implemented. The next in the
    list is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个更多可接受的标准需要实现。列表中的下一个如下：
- en: '"Given an investment, it should have the invested shares'' quantity."'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '"给定一个投资，它应该有已投资股份的数量。"'
- en: 'Writing it should be as simple as the previous spec was. In the `InvestmentSpec.js`
    file inside the `spec` folder, you can translate this new criterion into a new
    spec called `should have the invested shares'' quantity`, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 编写它应该和之前的规范一样简单。在`spec`文件夹内的`InvestmentSpec.js`文件中，你可以将这个新标准转换成一个新的规范，称为`should
    have the invested shares' quantity`，如下所示：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see that apart from having written the new spec, we have also changed
    the call to the `Investment` constructor to support the new `shares` parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，除了编写了新的规范外，我们还更改了对`Investment`构造函数的调用，以支持新的`shares`参数。
- en: To do so, we used an object as a single parameter in the constructor to simulate
    named parameters, a feature JavaScript doesn't have natively.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们在构造函数中使用了对象作为单个参数来模拟命名参数，这是JavaScript本身不具备的功能。
- en: 'Implementing this in the `Investment` function is pretty simple—instead of
    having multiple parameters on the function declaration, it has only one, which
    is expected to be an object. Then, the function probes each of its expected parameters
    from this object, making the proper assignments, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Investment`函数中实现这一点相当简单——在函数声明上不再有多个参数，只有一个，它期望是一个对象。然后，函数从这个对象中探测每个期望的参数，进行适当的分配，如下所示：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code is now refactored. We can run the tests to see that only the new spec
    fails, as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在已重构。我们可以运行测试来查看只有新的规格失败，如下所示：
- en: '![Setup and teardown](img/B04138_02_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![设置和拆卸](img/B04138_02_10.jpg)'
- en: This shows the failing shares spec
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了失败的份额规格
- en: 'To fix this, change the `Investment` constructor to make the assignment to
    the `shares` property, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，将`Investment`构造函数更改为将分配给`shares`属性，如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, everything on your screen is green:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，屏幕上的所有内容都是绿色的：
- en: '![Setup and teardown](img/B04138_02_11.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![设置和拆卸](img/B04138_02_11.jpg)'
- en: This shows the passing shares spec
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了通过股票的份额规格
- en: 'But as you can see, the following code, which instantiates `Stock` and `Investment`,
    is duplicated on both specs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你所看到的，以下代码，它实例化了`Stock`和`Investment`，在两个规格中都是重复的：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To eliminate this duplication, Jasmine provides another global function called
    `beforeEach` that, as the name states, is executed once before each spec. So,
    for these two specs, it will run twice—once before each spec.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这种重复，Jasmine提供了一个名为`beforeEach`的另一个全局函数，正如其名称所示，它在每个规格之前执行一次。因此，对于这两个规格，它将运行两次——在每个规格之前各运行一次。
- en: 'Refactor the previous specs by extracting the setup code using the `beforeEach`
    function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`beforeEach`函数提取设置代码来重构先前的规格：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This looks much cleaner; we not only removed the code duplication, but also
    simplified the specs. They became much easier to read and maintain since their
    only responsibility now is to fulfill the expectation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更干净；我们不仅消除了代码重复，还简化了规格。由于它们现在的唯一责任是满足期望，因此它们变得更容易阅读和维护。
- en: There is also a **teardown** function (`afterEach`) that sets the code to be
    executed after each spec. It is very useful in situations where a cleanup is required
    after each spec. We will see an example of its application in [Chapter 6](ch06.html
    "Chapter 6. Light Speed Unit Testing"), *Light Speed Unit Testing*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个**拆卸**函数（`afterEach`），它在每个规格之后执行代码。在需要在每个规格之后进行清理的情况下非常有用。我们将在[第6章](ch06.html
    "第6章。光速单元测试")中看到其应用的示例，*光速单元测试*。
- en: 'To finish the specification of `Investment`, add the remaining two specs to
    the `InvestmentSpec.js` file, inside the `spec` folder:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成`Investment`的规格说明，请将剩余的两个规格添加到`spec`文件夹中的`InvestmentSpec.js`文件中：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the specs to see them fail, as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行规格以查看它们失败，如下面的截图所示：
- en: '![Setup and teardown](img/B04138_02_12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![设置和拆卸](img/B04138_02_12.jpg)'
- en: This shows the failing cost and price specs
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了失败的代价和价格规格
- en: 'Add the following code to fix them in the `Investment.js` file inside the `src`
    folder:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`src`文件夹中的`Investment.js`文件中，以修复它们：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the specs for the last time to see them pass:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次运行规格以查看它们通过：
- en: '![Setup and teardown](img/B04138_02_13.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![设置和拆卸](img/B04138_02_13.jpg)'
- en: This shows all four Investment specs passing
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了所有四个投资规格都通过
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is important to always see a spec fail before writing the code to fix it;
    otherwise, how would you know that you really need to fix it? Imagine this as
    a way to test the test.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写修复代码之前始终看到规格失败是很重要的；否则，你怎么知道你真的需要修复它？想象一下这是一种测试测试的方法。
- en: Nested describes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套描述
- en: '**Nested describes** are useful when you want to describe similar behavior
    between specs. Suppose we want the following two new acceptance criteria:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌套描述**在您想要描述规格之间相似行为时很有用。假设我们想要以下两个新的验收标准：'
- en: Given an investment, when its stock share price valorizes, it should have a
    positive **return on investment** (**ROI**)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个投资，当其股票股价增值时，它应该有一个正的**投资回报率**（**ROI**）
- en: Given an investment, when its stock share price valorizes, it should be a good
    investment
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个投资，当其股票股价增值时，它应该是一个好的投资
- en: Both these criteria share the same behavior when the investment's stock share
    price valorizes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个标准在投资的股票股价增值时具有相同的行为。
- en: 'To translate this into Jasmine, you can nest a call to the `describe` function
    inside the existing one in the `InvestmentSpec.js` file (I removed the rest of
    the code for the purpose of demonstration; it is still there):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此转换为Jasmine，你可以在`InvestmentSpec.js`文件中嵌套对`describe`函数的调用（为了演示目的，我移除了其余代码；它仍然在那里）：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It should behave just like the outer one, so you can add specs (`it`) and use
    the setup and teardown functions (`beforeEach`, `afterEach`).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该表现得像外部的一个，因此你可以添加规范（`it`）并使用设置和清理函数（`beforeEach`，`afterEach`）。
- en: Setup and teardown
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和清理
- en: 'When using the setup and teardown functions, Jasmine respects the outer setup
    and teardown functions as well, so that they are run as expected. For each spec
    (`it`), the following actions are performed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用设置和清理函数时，Jasmine也会尊重外部的设置和清理函数，以便它们按预期运行。对于每个规范（`it`），执行以下操作：
- en: Jasmine runs all setup functions (`beforeEach`) from the outside in
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine从外向内运行所有设置函数（`beforeEach`）
- en: Jasmine runs a spec code (`it`)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine运行规范代码（`it`）
- en: Jasmine runs all the teardown functions (`afterEach`) from the inside out
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine从内向外运行所有清理函数（`afterEach`）
- en: 'So, we can add a setup function to this new `describe` function that changes
    the share price of the stock, so that it''s greater than the share price of the
    investment:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以向这个新的`describe`函数添加一个设置函数，该函数会改变股票的股价，使其高于投资的股价：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Coding a spec with shared behavior
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用共享行为编写规范
- en: 'Now that we have the shared behavior implemented, we can start coding the acceptance
    criteria described earlier. Each is, just as before, a call to the global Jasmine
    function `it`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了共享行为，我们可以开始编写之前描述的验收标准。每个都是，就像之前一样，对全局Jasmine函数`it`的调用：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After adding the missing functions to `Investment` in the `Investment.js` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Investment.js`文件中添加缺失的功能后：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can run the specs and see that they pass:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行规范并查看它们是否通过：
- en: '![Coding a spec with shared behavior](img/B04138_02_14.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用共享行为编写规范](img/B04138_02_14.jpg)'
- en: This shows the nested describe specs pass
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了嵌套的描述规范传递
- en: Understanding matchers
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解匹配器
- en: By now, you've already seen plenty of usage examples for matchers and probably
    can feel how they work.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经看到了许多匹配器的使用示例，可能已经感受到了它们是如何工作的。
- en: You have seen how to use the `toBe` and `toEqual` matchers. These are the two
    base built-in matchers available in Jasmine, but we can extend Jasmine by writing
    matchers of our own.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用`toBe`和`toEqual`匹配器。这些是Jasmine中可用的两个基本内置匹配器，但我们可以通过编写自己的匹配器来扩展Jasmine。
- en: So, to really understand how Jasmine matchers work, we need to create one ourselves.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了真正理解Jasmine匹配器是如何工作的，我们需要自己创建一个。
- en: Custom matchers
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义匹配器
- en: 'Consider this expectation from the previous section:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑上一节中的这个期望：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Although it works, it is not very expressive. Imagine if we could instead rewrite
    it as:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它工作，但表达性不强。想象一下，如果我们能将其重写为：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This creates a much better relation with the acceptance criterion:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这与验收标准建立了更好的关系：
- en: So, here "should be a good investment" becomes "expect investment to be a good
    investment".
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里“应该是一个好的投资”变为“期望投资是一个好的投资”。
- en: Implementing it is quite simple. You do so by calling the `jasmine.addMatchers`
    function—ideally inside a setup step (`beforeEach`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实现它相当简单。你可以通过调用`jasmine.addMatchers`函数来完成，理想情况下在设置步骤（`beforeEach`）中。
- en: Although you can put this new matcher definition inside the `InvestmentSpec.js`
    file, Jasmine already has a default place to add custom matchers, the `SpecHelper.js`
    file, inside the `spec` folder. If you are using Standalone Distribution, it already
    comes with a sample custom matcher; delete it and let's start from scratch.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以将这个新的匹配器定义放在`InvestmentSpec.js`文件中，但Jasmine已经在`spec`文件夹内的`SpecHelper.js`文件中提供了一个默认位置来添加自定义匹配器。如果你使用的是独立发行版，它已经包含了一个示例自定义匹配器；删除它，让我们从头开始。
- en: 'The `addMatchers` function accepts a single parameter—an object where each
    attribute corresponds to a new matcher. So, to add the following new matcher,
    change the contents of the `SpecHelper.js` file to the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`addMatchers`函数接受一个单一参数——一个对象，其中每个属性都对应一个新匹配器。因此，要添加以下新匹配器，将`SpecHelper.js`文件的内容更改为以下内容：'
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The function being defined here is not the matcher itself but a factory function
    to build the matcher. Its purpose, once called is to return an object containing
    a compare function, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里定义的函数不是匹配器本身，而是一个用于构建匹配器的工厂函数。一旦调用，它的目的是返回一个包含比较函数的对象，如下所示：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `compare` function will contain the actual matcher implementation, and as
    can be observed by its signature, it receives both values being compared (the
    `actual` and `expected` values).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`compare`函数将包含实际的匹配器实现，并且可以通过其签名观察到，它接收两个被比较的值（`actual`和`expected`值）。'
- en: For the given example, the `investment` object will be available in the `actual`
    argument.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的示例，`investment`对象将在`actual`参数中可用。
- en: Then, Jasmine expects, as the result of this `compare` function, an object with
    a `pass` attribute with a boolean value `true` to indicate that the expectation
    passes and `false` if the expectation fails.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Jasmine期望，作为此`compare`函数的结果，一个具有`pass`属性的布尔值`true`的对象，以指示期望通过，如果期望失败则为`false`。
- en: 'Let''s have a look at the following valid implementation of the `toBeAGoodInvestment`
    matcher:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下`toBeAGoodInvestment`匹配器的有效实现：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By now, this matcher is ready to be used by the specs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个匹配器已经准备好供规格说明使用：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After the change, the specs should still pass. But what happens if a spec fails?
    What is the error message that Jasmine reports?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改后，规格说明应该仍然通过。但如果一个规格说明失败了怎么办？Jasmine报告的错误信息是什么？
- en: 'We can see it by deliberately breaking the `investment.isGood` implementation
    in the `Investment.js` file, in the `src` folder to always return `false`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过故意在`src`文件夹中的`Investment.js`文件中打破`investment.isGood`的实现，使其始终返回`false`来看到这一点：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When running the specs again, Jasmine generates an error message stating `Expected
    { stock: { sharePrice: 40 }, shares: 100, sharePrice: 20, cost: 2000 } to be a
    good investment`, as shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '再次运行规格说明时，Jasmine生成一个错误信息，指出`Expected { stock: { sharePrice: 40 }, shares:
    100, sharePrice: 20, cost: 2000 } to be a good investment`，如下面的截图所示：'
- en: '![Custom matchers](img/B04138_02_15.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![自定义匹配器](img/B04138_02_15.jpg)'
- en: This is the custom matcher's message
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义匹配器的消息
- en: 'Jasmine does a great job generating this error message, but it also allows
    its customization via the `result.message` property of the object returned as
    the result of the matcher. Jasmine expects this property to be a string with the
    following error message:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine在生成此错误信息方面做得很好，但它还允许通过匹配器返回的对象的`result.message`属性进行自定义。Jasmine期望此属性是一个包含以下错误信息的字符串：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the specs again and the error message should change:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行规格说明，错误信息应该会改变：
- en: '![Custom matchers](img/B04138_02_16.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![自定义匹配器](img/B04138_02_16.jpg)'
- en: This is the custom matcher's custom message
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义匹配器的自定义消息
- en: 'Now, let''s consider another acceptance criterion:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个验收标准：
- en: '"Given an investment, when its stock share price devalorizes, it should be
    a bad investment."'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '"给定一项投资，当其股票股价贬值时，它应该是一项不良投资。"'
- en: Although it is possible to create a new custom matcher (`toBeABadInvestment`),
    Jasmine allows the negation of any matcher by chaining `not` before the matcher
    call. So, we can write that "a bad investment" is "not a good investment"
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以创建一个新的自定义匹配器（`toBeABadInvestment`），但Jasmine允许通过在匹配器调用之前链式`not`来否定任何匹配器。因此，我们可以写出“一项不良投资”是“不是一个好投资”。
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement this new acceptance criterion in the `InvestmentSpec.js` file inside
    the `spec` folder by adding new and nested `describe` and `spec`, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`spec`文件夹内的`InvestmentSpec.js`文件中添加新的嵌套`describe`和`spec`，实现这个新的验收标准，如下所示：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But there is a catch! Let''s break the `investment` implementation in the `Investment.js`
    file code so that it is always a good investment, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个问题！让我们打破`Investment.js`文件中的`investment`实现代码，使其始终是一项良好的投资，如下所示：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After running the specs again, you can see that this new spec fails, but the
    error message, `Expected investment to be a good investment`, is wrong, as shown
    in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行规格说明后，你可以看到这个新的规格说明失败了，但错误信息`Expected investment to be a good investment`是错误的，如下面的截图所示：
- en: '![Custom matchers](img/B04138_02_17.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![自定义匹配器](img/B04138_02_17.jpg)'
- en: This is the custom matcher's wrong custom negated message
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义匹配器的错误自定义否定消息
- en: That is the message that was hardcoded inside the matcher. To fix this, you
    need to make the message dynamic.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 那是匹配器内部硬编码的消息。要修复它，你需要使消息动态化。
- en: 'Jasmine only shows the message if the matcher fails, so the proper way of making
    this message dynamic is to consider what message is supposed to be shown when
    the given comparison is invalid:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine仅在匹配器失败时显示消息，因此使此消息动态化的正确方法是在给定比较无效时考虑应显示什么消息：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This fixes the message, as shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的截图所示，这修复了消息：
- en: '![Custom matchers](img/B04138_02_18.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![自定义匹配器](img/B04138_02_18.jpg)'
- en: This shows the custom matcher's custom dynamic message
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了自定义匹配器的自定义动态消息
- en: Now this matcher can be used anywhere.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个匹配器可以在任何地方使用。
- en: 'Before continuing in the chapter, change the `isGood` method back again to
    its correct implementation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章之前，将`isGood`方法再次更改为正确的实现：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'What this example lacked was a way to show how to pass an expected value to
    a matcher like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子缺少的是展示如何将期望值传递给像这样的匹配器的方法：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It turns out that a matcher can receive any number of expected values as parameters.
    So, for instance, the preceding matcher could be implemented in the `SpecHelper.js`
    file, inside the `spec` folder, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，匹配器可以接收任何数量的期望值作为参数。所以，例如，前面的匹配器可以在`SpecHelper.js`文件中实现，在`spec`文件夹内，如下所示：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By implementing any matcher, check first whether there is one available that
    already does what you want.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现任何匹配器，首先检查是否已经有一个可以完成你想要的功能的匹配器。
- en: For more information, check the official documentation at the Jasmine website
    [http://jasmine.github.io/2.1/custom_matcher.html](http://jasmine.github.io/2.1/custom_matcher.html).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请查看Jasmine网站上的官方文档[http://jasmine.github.io/2.1/custom_matcher.html](http://jasmine.github.io/2.1/custom_matcher.html)。
- en: Built-in matchers
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置匹配器
- en: Jasmine comes with a bunch of default matchers covering the basis of value checking
    in the JavaScript language. To understand how they work and where to use them
    properly is a journey of how JavaScript handles type.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine附带了一些默认匹配器，涵盖了JavaScript语言中值检查的基础。要了解它们是如何工作的以及在哪里正确使用它们，就是了解JavaScript如何处理类型的旅程。
- en: The toEqual built-in matcher
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`toEqual`内置匹配器'
- en: The `toEqual` matcher is probably the most commonly used matcher, and you should
    use it whenever you want to check equality between two values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`toEqual`匹配器可能是最常用的匹配器，每次你想检查两个值之间的相等性时都应该使用它。'
- en: 'It works for all primitive values (number, string, and boolean) as well as
    any object (including arrays), as shown in the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它适用于所有原始值（数字、字符串和布尔值）以及任何对象（包括数组），如下面的代码所示：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The toBe built-in matcher
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`toBe`内置匹配器'
- en: The `toBe` matcher has a very similar behavior to the `toEqual` matcher; in
    fact, it gives the same result while comparing primitive values, but the similarities
    stop there.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBe`匹配器的行为与`toEqual`匹配器非常相似；事实上，在比较原始值时，它们给出相同的结果，但相似之处到此为止。'
- en: While the `toEqual` matcher has a complex implementation (you should take a
    look at the Jasmine source code) that checks whether all attributes of an object
    and all elements of an array are the same, here it is a simple use of the **strict
    equals operator** (`===`).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`toEqual`匹配器有一个复杂的实现（你应该看看Jasmine的源代码），它会检查一个对象的所有属性和数组的所有元素是否相同，但这里它只是简单使用了**严格的等于操作符**（`===`）。
- en: If you are unfamiliar with the strict equals operator, its main difference from
    the **equals operator** (`==`) is that the latter performs type coercion if the
    compared values aren't of the same type.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉严格的等于操作符，它与**等于操作符**（`==`）的主要区别在于后者如果比较的值不是同一类型，则会执行类型转换。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The strict equals operator always considers false any comparison between values
    of distinct types.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的等于操作符始终认为不同类型的值之间的比较是false。
- en: 'Here are some examples of how this matcher (and the strict equals operator)
    works:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些这个匹配器（以及严格的等于操作符）的工作示例：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is advised that you use the `toEqual` operator in most cases and resort to
    the `toBe` matcher only when you want to check whether two variables reference
    the same object.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在大多数情况下使用`toEqual`操作符，只有在你想检查两个变量是否引用同一个对象时才使用`toBe`匹配器。
- en: The toBeTruthy and toBeFalsy matchers
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`toBeTruthy`和`toBeFalsy`匹配器'
- en: Besides its primitive boolean type, everything else in the JavaScript language
    also has an inherent boolean value, which is generally known to be either **truthy**
    or **falsy**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JavaScript语言中的原始布尔类型之外，其他所有内容也都有固有的布尔值，通常被认为是**truthy**或**falsy**。
- en: 'Luckily in JavaScript, there are only a few values that are identified as falsy,
    as shown in the following examples for the `toBeFalsy` matcher:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在JavaScript中，只有少数值被识别为falsy，以下是一些`toBeFalsy`匹配器的示例：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Everything else is considered truthy, as demonstrated by the following examples
    of the `toBeTruthy` matcher:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有内容都被认为是truthy，如下面的`toBeTruthy`匹配器的示例所示：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: But, if you want to check whether something is equal to an actual boolean value,
    it might be a better idea to use the `toEqual` matcher.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想检查某个值是否等于实际的布尔值，使用`toEqual`匹配器可能是个更好的主意。
- en: The toBeUndefined, toBeNull, and toBeNaN built-in matchers
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内置的`toBeUndefined`、`toBeNull`和`toBeNaN`匹配器
- en: 'These matchers are pretty straightforward and should be used to check for `undefined`,
    `null`, and `NaN` values:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些匹配器非常直接，应用于检查`undefined`、`null`和`NaN`值：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both `toBeNull` and `toBeUndefined` can be written as `toBe(null)` and `toBe(undefined)`
    respectively, but that is not the case with `toBeNaN`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBeNull`和`toBeUndefined`都可以写成`toBe(null)`和`toBe(undefined)`，但`toBeNaN`不是这样。'
- en: 'In JavaScript, the `NaN` value is not equal to any value, not even `NaN`. So,
    trying to compare it to itself is always `false`, as shown in the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`NaN`值不等于任何值，甚至不等于`NaN`。因此，尝试将其与自身比较总是返回`false`，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As good practice, try to use these matchers instead of their `toBe` counterparts
    whenever possible.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好实践，尽可能使用这些匹配器而不是它们的`toBe`对应物。
- en: The toBeDefined built-in matcher
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内置的`toBeDefined`匹配器
- en: 'This matcher is useful if you want to check whether a variable is defined and
    you don''t care about its value, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想检查一个变量是否已定义，而不关心其值，则此匹配器很有用，如下所示：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Anything except `undefined` will pass under this matcher, even `null`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`undefined`之外，任何东西都会通过此匹配器，即使是`null`。
- en: The toContain built-in matcher
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内置的`toContain`匹配器
- en: 'Sometimes, it is desirable to check whether an array contains an element, or
    whether a string can be found inside another string. For these use cases, you
    can use the `toContain` matcher, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，检查数组是否包含元素，或者字符串是否可以在另一个字符串中找到是有用的。对于这些用例，您可以使用`toContain`匹配器，如下所示：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The toMatch built-in matcher
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内置的`toMatch`匹配器
- en: 'Although the `toContain` and `toEqual` matchers can be used in most string
    comparisons, sometimes the only way to assert whether a string value is correct
    is through a regular expression. For these cases, you can use the `toMatch` matcher
    along with a regular expression, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`toContain`和`toEqual`匹配器可以在大多数字符串比较中使用，但有时唯一断言字符串值是否正确的方法是通过正则表达式。对于这些情况，您可以使用`toMatch`匹配器与正则表达式一起使用，如下所示：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The matcher works by testing the actual value (`"My big matched string"`) against
    the expected regular expression (`/My(.+)string/`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器通过将实际值（`"My big matched string"`）与预期正则表达式（`/My(.+)string/`）进行比较来工作。
- en: The toBeLessThan and toBeGreaterThan built-in matchers
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内置的`toBeLessThan`和`toBeGreaterThan`匹配器
- en: 'The `toBeLessThan` and `toBeGreaterThan` matchers are simple and used to perform
    numeric comparisons—something that is best described by the following examples:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBeLessThan`和`toBeGreaterThan`匹配器简单，用于执行数值比较——这最好通过以下示例来描述：'
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The toBeCloseTo built-in matcher
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内置的`toBeCloseTo`匹配器
- en: 'This is a special matcher used to compare floating-point numbers with a defined
    set of precision—something that is best explained by this example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊的匹配器，用于比较具有定义精度的浮点数——这最好通过以下示例来解释：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first parameter is the number being compared, and the second is the precision
    in the number of decimal cases.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要比较的数字，第二个参数是数字的小数位数精度。
- en: The toThrow built-in matcher
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内置的`toThrow`匹配器
- en: Exceptions are a language's way of demonstrating when something goes wrong.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是语言展示出错的方式。
- en: So, for example, while coding an API, you might decide to throw an exception
    when a parameter is passed incorrectly. So, how do you test this code?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在编写API时，您可能会决定在参数传递错误时抛出异常。那么，您如何测试这段代码呢？
- en: Jasmine has the built-in `toThrow` matcher that can be used to verify that an
    exception has been thrown.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine内置的`toThrow`匹配器可以用来验证是否抛出了异常。
- en: The way it works is a little bit different from the other matchers. Since the
    matcher has to run a piece of code and check whether it throws an exception, the
    matcher's **actual** value must be a function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与其他匹配器略有不同。由于匹配器必须运行一段代码并检查是否抛出异常，因此匹配器的**实际**值必须是一个函数。
- en: 'Here is an example of how it works:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何工作的例子：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When the test is run, the anonymous function is executed, and if it throws the
    `Some exception` exception, the test passes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行时，匿名函数被执行，如果它抛出`Some exception`异常，则测试通过。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to think in BDD and drive your code from your
    specs. You also became acquainted with the basic Jasmine global functions (`describe`,
    `it`, `beforeEach`, and `afterEach`) and have a good understanding of what is
    required to create a spec in Jasmine.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你学习了如何用行为驱动开发（BDD）的思维来驱动你的代码从你的规范出发。你还熟悉了Jasmine的基本全局函数（`describe`、`it`、`beforeEach`和`afterEach`），并对在Jasmine中创建规范所需的内容有了良好的理解。
- en: You got familiar with Jasmine matchers and know how powerful they are in describing
    a spec intent. You even learned to create a matcher of your own.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉了Jasmine匹配器，并知道它们在描述规范意图方面的强大功能。你甚至学会了创建自己的匹配器。
- en: By now, you should be familiar with creating new specs and driving the development
    of your new application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉了创建新的规范并驱动你新应用程序的开发。
- en: In the next chapter, we are going to take a look at how we can use the concepts
    learned in this chapter to start testing web applications, which are most commonly
    jQuery and HTML forms.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何利用本章学到的概念来开始测试网络应用程序，这些应用程序最常见的是jQuery和HTML表单。
