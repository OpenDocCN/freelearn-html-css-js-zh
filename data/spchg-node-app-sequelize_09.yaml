- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Using and Creating Adapters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用和创建适配器
- en: After developing for several years, you may have a set of common utility functions,
    a collection of other frameworks, and a library of your own scripts. Maintaining
    all of these moving parts may become too entropic for an enterprise project or
    a fleet of microservices. We can restructure our common code into a more generic
    interface, or pattern, and reclassify those scripts as an “adapter” (also known
    as a “plugin”).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几年的开发，您可能已经积累了一套常见的实用函数、其他框架的集合以及您自己的脚本库。维护所有这些动态部分可能对于一个企业项目或一系列微服务来说过于复杂。我们可以将通用代码重构为更通用的接口或模式，并将这些脚本重新分类为“适配器”（也称为“插件”）。
- en: Using adapters can save us development time, prevent us from repeating ourselves,
    and help centralize collaboration by maintaining its code base. A few examples
    of an adapter would be transforming text into a specific character ruleset, scaffolding
    a sidecar project such as an administrative dashboard, or providing a caching
    layer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器可以节省我们开发时间，防止我们重复工作，并通过维护其代码库来帮助集中协作。适配器的一些例子包括将文本转换为特定的字符规则集、构建一个辅助项目，如行政仪表板，或提供缓存层。
- en: Sequelize offers a way to extend its behavior by allowing the integration of
    adapters and plugins through a mixture of object prototyping and its lifecycle
    events. Once we become familiar with using pre-existing adapters, we will create
    our own adapter/extension for Sequelize that will generate “slug URLs” for each
    instance within a model.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 通过允许通过对象原型化和其生命周期事件集成适配器和插件来扩展其行为。一旦我们熟悉了使用现有的适配器，我们将为 Sequelize 创建自己的适配器/扩展，为模型中的每个实例生成“slug
    URL”。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing, configuring, and integrating AdminJS with Sequelize
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装、配置和集成 AdminJS 与 Sequelize
- en: Integrating Sequelize with GraphQL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Sequelize 与 GraphQL 集成
- en: Creating our own adapter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己的适配器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files of this chapter on GitHub at [https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch9](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch9)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件，位于 [https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch9](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch9)
- en: Installing, configuring, and integrating AdminJS with Sequelize
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装、配置和集成 AdminJS 与 Sequelize
- en: AdminJS is an administrative dashboard that can integrate into various database
    management systems, ORMs, and web frameworks. In addition to AdminJS being able
    to generate charts and tables for your data, it can also create roles and access
    control lists, export reports, and centralize the modeling of **Create, Read,
    Update, Delete** (**CRUD**) operations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: AdminJS 是一个可以集成到各种数据库管理系统、ORM 和 Web 框架的行政仪表板。除了 AdminJS 能够为您的数据生成图表和表格之外，它还可以创建角色和访问控制列表、导出报告，并集中管理
    **创建、读取、更新、删除** （**CRUD**） 操作的建模。
- en: Avalon Airline’s investors want us to have a dashboard that allows us to manage
    flights and tickets, and show basic reporting numbers, such as the total number
    of planes and gross profit. AdminJS seems to be a perfect fit here; we can begin
    by installing the necessary components within Avalon Airline’s root directory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Avalon Airline 的投资者希望我们有一个仪表板，允许我们管理航班和机票，并显示基本报告数字，例如飞机总数和毛利润。AdminJS 似乎非常适合这里；我们可以从在
    Avalon Airline 的根目录中安装必要的组件开始。
- en: 'Within the terminal, we can install the packages by executing the following
    command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们可以通过执行以下命令来安装包：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `express-formidable` module is required as a peer dependency for the `@adminjs/express`
    package. The `formidable` module is a fast-streaming multipart parser with a low
    memory footprint. For more information on formidable and its capabilities, you
    can refer to its GitHub repository, located at [https://github.com/node-formidable/formidable](https://github.com/node-formidable/formidable).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`express-formidable` 模块是 `@adminjs/express` 包的依赖项。`formidable` 模块是一个具有低内存占用的高速流式多部分解析器。有关
    formidable 及其功能的更多信息，您可以参考其位于 [https://github.com/node-formidable/formidable](https://github.com/node-formidable/formidable)
    的 GitHub 仓库。'
- en: Depending on which version of `npm` you have installed (eight or above), and
    which version of `@adminjs/sequelize` is installed, you may run into legacy peer
    dependency issues. Due to one of our packages (`@adminjs/sequelize`) requiring
    an old module path for Sequelize (`sequelize` versus `@sequelize/core`) we will
    run into missing dependency issues which could be resolved by enabling `legacy-peer-deps`
    or using the `override` option.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您安装的 `npm` 版本（8 或更高版本）以及安装的 `@adminjs/sequelize` 版本，您可能会遇到遗留依赖问题。由于我们的一个包（`@adminjs/sequelize`）需要一个旧的
    Sequelize 模块路径（`sequelize` 与 `@sequelize/core`），我们可能会遇到缺失依赖问题，这些问题可以通过启用 `legacy-peer-deps`
    或使用 `override` 选项来解决。
- en: 'Typically, we would want to avoid using the `legacy-peer-deps` option to avoid
    breaking changes. We could use the `override` option in *package.json* for resolving
    packages which is explained more at [https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides](https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides).
    Within the *package.json* file, below the `scripts` block, we will want to add
    another block with the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们想要避免使用 `legacy-peer-deps` 选项以避免破坏性更改。我们可以在 *package.json* 中使用 `override`
    选项来解决问题，这将在 [https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides](https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides)
    中解释得更详细。在 *package.json* 文件中，在 `scripts` 块下方，我们希望添加另一个块，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the previous npm installation step failed, we can retry after the *package.json*
    updates which will resolve `@adminjs/sequelize` package’s `sequelize` version
    requirements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前的 npm 安装步骤失败，我们可以在更新 *package.json* 后重试，这将解决 `@adminjs/sequelize` 包的 `sequelize`
    版本要求。
- en: 'Now, we can start integrating AdminJS into our application. Within the `index.js`
    file, at the very top, we can add the following lines, which will load the necessary
    AdminJS modules:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始将 AdminJS 集成到我们的应用程序中。在 `index.js` 文件中，在最顶部，我们可以添加以下行，这将加载必要的 AdminJS
    模块：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Below the `const models = require("./models");` line, we can now add the following
    line, which will register the Sequelize adapter for AdminJS:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `const models = require("./models");` 行下方，我们现在可以添加以下行，这将注册 Sequelize 适配器用于
    AdminJS：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Below that line, we can add our AdminJS instance and build the Express router:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在该行下方，我们可以添加我们的 AdminJS 实例并构建 Express 路由器：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`model.sequelize` is the instance that we created from `models/index.js`. This
    will instruct AdminJS to use Sequelize for our connection. The `resources` key
    holds a list of all of the models that should be exposed/applicable to AdminJS.
    `rootPath` will be AdminJS’ URL prefix for our web application.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`model.sequelize` 是我们从 `models/index.js` 创建的实例。这将指示 AdminJS 使用 Sequelize 进行我们的连接。`resources`
    键包含所有应暴露/适用于 AdminJS 的模型列表。`rootPath` 将是 AdminJS 的 Web 应用程序 URL 前缀。'
- en: 'Within `index.js`, below the `app.use(bodyParser.json({ type: ''application/json''
    }));` line, we can now add the AdminJS middleware to help integrate into Express:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `index.js` 文件中，在 `app.use(bodyParser.json({ type: ''application/json'' }));`
    行下方，我们现在可以添加 AdminJS 中间件以帮助集成到 Express：'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, when we launch our browser to `http://localhost:3000/admin`, we should
    see a similar page to *Figure 9.1*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们启动浏览器到 `http://localhost:3000/admin` 时，我们应该看到类似于 *图 9.1* 的页面。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter, *Deploying a Sequelize Application*, we will cover how
    to password-protect your application to prevent an unwanted guest from modifying
    the database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，*部署 Sequelize 应用程序*中，我们将介绍如何通过密码保护应用程序来防止不受欢迎的访客修改数据库。
- en: '![Figure 9.1 – AdminJS welcome dashboard ](img/Figure_9.01_B17841.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – AdminJS 欢迎仪表板](img/Figure_9.01_B17841.jpg)'
- en: Figure 9.1 – AdminJS welcome dashboard
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – AdminJS 欢迎仪表板
- en: 'On the left-side navigation, we should see our database labeled as **airline**.
    Clicking on that link will reveal our exposed Sequelize models. Clicking on **Airplanes**
    will show a brief table with our model’s data, similar to *Figure 9.2*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧导航栏中，我们应该看到标记为**airline**的数据库。点击该链接将显示我们暴露的 Sequelize 模型。点击**Airplanes**将显示一个包含我们模型数据的简短表格，类似于*图
    9.2*：
- en: '![Figure 9.2 – The Airplanes model table ](img/Figure_9.02_B17841.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 飞机模型表格](img/Figure_9.02_B17841.jpg)'
- en: Figure 9.2 – The Airplanes model table
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 飞机模型表格
- en: There is a small caveat with AdminJS; at the time of writing, AdminJS does not
    support Sequelize’s virtual data types, which are not text values. Our `BoardingTickets`
    model contains a virtual type as a Boolean value. When we click on the **Boarding
    Tickets** menu item, we will be greeted with an error similar to *Figure 9.3*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: AdminJS有一个小的限制；在撰写本文时，AdminJS不支持Sequelize的虚拟数据类型，这些类型不是文本值。我们的`BoardingTickets`模型包含一个作为布尔值的虚拟类型。当我们点击**登机牌**菜单项时，我们会遇到类似于*图9.3*的错误。
- en: '![Figure 9.3 – AdminJS Displaying an Error From Virtual Types ](img/Figure_9.03_B17841.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – AdminJS显示来自虚拟类型的错误](img/Figure_9.03_B17841.jpg)'
- en: Figure 9.3 – AdminJS Displaying an Error From Virtual Types
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – AdminJS显示来自虚拟类型的错误
- en: 'To fix this issue, we can remove the property’s visibility by extending our
    options for AdminJS’ resources. In the new `AdminJS(…)` block, under the resources
    key, replace the `models.BoardingTicket` line with the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以通过扩展AdminJS资源的选项来移除属性的可见性。在新`AdminJS(…)`块中，在`resources`键下，将`models.BoardingTicket`行替换为以下内容：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will instruct AdminJS to disable the `isEmployee` attribute’s visibility
    to `false`. Now, when we refresh the page, the error should no longer be displayed,
    as shown in *Figure 9.4*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示AdminJS将`isEmployee`属性的可见性设置为`false`。现在，当我们刷新页面时，错误应该不再显示，如*图9.4*所示。
- en: '![Figure 9.4 – Resolving AdminJS’ error with virtual types ](img/Figure_9.04_B17841.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 使用虚拟类型解决AdminJS的错误](img/Figure_9.04_B17841.jpg)'
- en: Figure 9.4 – Resolving AdminJS’ error with virtual types
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 使用虚拟类型解决AdminJS的错误
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a complete reference on what kind of settings are tunable for AdminJS’
    property configuration, you can refer to the API documentation here: [https://docs.adminjs.co/PropertyOptions.xhtml](https://docs.adminjs.co/PropertyOptions.xhtml).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解AdminJS属性配置中可调整的设置类型，你可以参考以下API文档：[https://docs.adminjs.co/PropertyOptions.xhtml](https://docs.adminjs.co/PropertyOptions.xhtml)。
- en: AdminJS will also automatically integrate into Sequelize’s validation system.
    So, if we were to edit one of our flight schedules and entered an invalid airport,
    we would be presented with an error like the one shown in *Figure 9.5*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: AdminJS还会自动集成到Sequelize的验证系统中。因此，如果我们编辑我们的航班计划并输入了一个无效的机场，我们会看到一个类似于*图9.5*的错误。
- en: '![Figure 9.5 – AdminJS validation integration ](img/Figure_9.05_B17841.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – AdminJS验证集成](img/Figure_9.05_B17841.jpg)'
- en: Figure 9.5 – AdminJS validation integration
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – AdminJS验证集成
- en: When we initialized our application with AdminJS, you may have noticed a new
    folder was automatically created called `.adminjs` within the project’s root directory.
    The files within this directory are local to your instance only and are neither
    applicable to deployments nor to other team members.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用AdminJS初始化应用程序时，你可能会注意到在项目根目录中自动创建了一个名为`.adminjs`的新文件夹。这个目录中的文件仅适用于你的实例，不适用于部署或其他团队成员。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed a `.gitignore` file that contains `.adminjs` as part of
    its content. The `.gitignore` file is for preventing folders, files, matching
    paths, and so on from being committed within the git’s object space. If you are
    working within a project using version control, such as Git, then it is recommended
    to ignore the `.adminjs` directory from being committed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到一个包含`.adminjs`作为其内容的`.gitignore`文件。`.gitignore`文件用于防止文件夹、文件、匹配路径等被提交到git的对象空间中。如果你在一个使用版本控制的项目中工作，例如Git，那么建议忽略`.adminjs`目录的提交。
- en: Whether adding, deleting, modifying, or validating records, AdminJS offers a
    very convenient way of managing models. Sometimes, convenience can get in the
    way, and we would need to view or modify our records in ways that AdminJS cannot.
    One way to achieve this is to use a GraphQL library.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是添加、删除、修改还是验证记录，AdminJS都提供了一个非常方便的方式来管理模型。有时，方便可能会成为障碍，我们需要以AdminJS无法实现的方式查看或修改我们的记录。实现这一目标的一种方法是用一个GraphQL库。
- en: Integrating Sequelize with GraphQL
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Sequelize与GraphQL集成
- en: GraphQL offers a few advantages over alternatives such as REST. We can declare
    data shapes with strong types, associate relational hierarchies, and reduce the
    number of requests required when querying data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL相对于REST等替代方案提供了一些优势。我们可以使用强类型声明数据形状，关联关系层次结构，并在查询数据时减少请求的数量。
- en: GraphQL is a query language that is data storage-agnostic. You can associate
    a GraphQL model with a typical **Database Management System** (**DBMS**), or just
    as an abstraction for model validation and shaping.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是一种数据存储无关的查询语言。您可以将GraphQL模型与典型的**数据库管理系统**（**DBMS**）相关联，或者将其作为模型验证和塑形的抽象。
- en: 'Here is an example of a GraphQL schema definition:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个GraphQL模式定义的示例：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `User` type has three attributes, with the `name` and `roles` being required
    (indicated with the exclamation mark), while the `bio` definition is an optional
    string. Within this example, the `User` type’s roles attributes will always return
    an array with zero or more items from the exclamation mark that sits outside of
    the brackets (`[…]!`), and the other exclamation mark indicates that each item
    within the set will be non-nullable and return a `Role` type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类型有三个属性，其中`name`和`roles`是必需的（用感叹号表示），而`bio`定义是一个可选的字符串。在这个例子中，`User`类型的`roles`属性将始终返回一个包含零个或多个项的数组，这些项位于括号外的感叹号（`[...]!`）之外，而另一个感叹号表示集合中的每个项都将是非空值并返回一个`Role`类型。'
- en: A type just references an object, but there are two types that are reserved
    for GraphQL itself, the `Query` and the `Mutation` type. The query types are reserved
    for defining input parameters and relations, and associations, of a collection
    of types. `Mutation` types are utilized when we want to modify our data. You can
    think of queries as `GET` requests and mutation queries as a combination of `POST`
    and `PUT` HTTP methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类型仅引用一个对象，但有两个类型是为GraphQL本身保留的，即`Query`和`Mutation`类型。查询类型保留用于定义类型集合的输入参数和关系以及关联。`Mutation`类型用于我们想要修改数据时。您可以将查询视为`GET`请求，将突变查询视为`POST`和`PUT`HTTP方法的组合。
- en: 'To query the previous example’s types, we will invoke a query type like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询前面示例的类型，我们将调用一个查询类型，如下所示：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This example will generate a function called `usersByName` with an input parameter
    of a required string. The function would yield any `User` types whose name matches
    the `$name` variable. Each record would return the name, bio, and an array of
    roles associated with that user. The data shape that is returned would look similar
    to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将生成一个名为`usersByName`的函数，该函数有一个必需的字符串输入参数。该函数将产生任何名称与`$name`变量匹配的`User`类型。每条记录将返回名称、bio以及与该用户关联的角色数组。返回的数据形状将类似于以下内容：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Mick Hansen, one of the original maintainers of Sequelize, created an NPM package
    called sequelize-graphql that will help bridge our models with a GraphQL type
    definition. To get started on using GraphQL with Sequelize in our current project,
    we will need to install the following NPM modules:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Mick Hansen，Sequelize的原始维护者之一，创建了一个名为sequelize-graphql的NPM包，该包将帮助我们通过GraphQL类型定义桥接我们的模型。要在我们的当前项目中开始使用GraphQL与Sequelize，我们需要安装以下NPM模块：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `graphql-sequelize` library may require old, or conflicting, versions for
    the `graphql` and `graphql-relay` library. We would need to modify our `override`
    object within the *package.json* file to the following to resolve those issues:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`graphql-sequelize`库可能需要旧版本或冲突版本的`graphql`和`graphql-relay`库。我们需要修改`package.json`文件中的`override`对象，如下所示，以解决这些问题：'
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `graphql-yoga` package is a GraphQL server framework dedicated to performance
    and ease of use. Its GitHub repository can be found here: [https://github.com/dotansimha/graphql-yoga](https://github.com/dotansimha/graphql-yoga).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`graphql-yoga`包是一个专注于性能和易用性的GraphQL服务器框架。其GitHub仓库可在此处找到：[https://github.com/dotansimha/graphql-yoga](https://github.com/dotansimha/graphql-yoga)。'
- en: The first step is to add a static constant called `tableName` for each model,
    with the value being the model’s table name for the `sequelize-graphql` plugin.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是为每个模型添加一个静态常量，称为`tableName`，其值应为`sequelize-graphql`插件中模型的表名。
- en: 'We will start with the `models/airplane.js` file; under the `class Airplane
    extends Model` line, add the following variable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`models/airplane.js`文件开始；在`class Airplane extends Model`行下，添加以下变量：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Within `models/boardingticket.js`, under the `class BoardingTicket extends
    Model` line, add the following variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models/boardingticket.js`文件中，在`class BoardingTicket extends Model`行下，添加以下变量：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Within `models/customer.js`, under the `class Customer extends Model` line,
    add the following variable:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models/customer.js`文件中，在`class Customer extends Model`行下，添加以下变量：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Within `models/flightschedule.js`, under the `class FlightSchedule extends
    Model` line, add the following variable:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models/flightschedule.js`文件中，在`class FlightSchedule extends Model`行下，添加以下变量：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Within `models/receipts.js`, under the `class Receipts extends Model` line,
    add the following variable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `models/receipts.js` 文件中，在 `class Receipts extends Model` 行下面，添加以下变量：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can begin with declaring our type definitions and query resolver patterns
    for the GraphQL server. Within the project’s root directory, add a new file called
    `graphql.js`, starting with the following `require` commands:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始声明我们的类型定义和查询解析器模式，用于 GraphQL 服务器。在项目根目录下，添加一个名为 `graphql.js` 的新文件，从以下
    `require` 命令开始：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we want to start defining our query interface for when we want to execute
    queries later. You may think of this as something similar to a header file in
    a “C” language project:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要开始定义我们用于以后执行查询的查询接口。你可以把它想象成“C”语言项目中类似头文件的东西：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While keeping the `typeDef` variable open, we can add a simple `Mutation` query
    example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持 `typeDef` 变量打开的同时，我们可以添加一个简单的 `Mutation` 查询示例：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we can add our model schematics to the definitions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将我们的模型模式添加到定义中：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we will want to set our resolvers to associate the type definitions with
    the correct Sequelize model associations. Let’s start with the query resolvers:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望设置我们的解析器以将类型定义与正确的 Sequelize 模型关联关联起来。让我们从查询解析器开始：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we can add a `Mutation` resolver example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加一个 `Mutation` 解析器示例：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we can resolve our model associations and close the variable:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以解析我们的模型关联并关闭变量：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we can create our server with the schema definitions and export it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用模式定义创建我们的服务器并将其导出：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Within the `index.js` file, in the project’s root directory, we can add the
    following line under our `var models = require("./models")` line:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录下的 `index.js` 文件中，在我们的 `var models = require("./models")` 行下面，我们可以添加以下一行：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After we have mounted the AdminJS router, `app.use(adminJs.options.rootPath,
    router)`, add the following line:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们挂载了 AdminJS 路由后，`app.use(adminJs.options.rootPath, router)`，添加以下一行：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After we have finished our `index.js` modifications, we can start our application:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成 `index.js` 的修改后，我们可以启动我们的应用程序：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the server is up and running, we can access GraphQL Yoga’s dashboard interface
    (*Figure 9.6*) by visiting the following URL within a browser: [`http://localhost:3000/graphql`](http://localhost:3000/graphql):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动并运行，我们可以在浏览器中通过访问以下 URL 来访问 GraphQL Yoga 的仪表板界面（*图 9.6*）：[`http://localhost:3000/graphql`](http://localhost:3000/graphql)：
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a production deployment, we would either want to disable this route based
    on the value of `process.env.NODE_ENV` or add authentication-based middleware
    to the `/graphql` route in `index.js`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产部署中，我们可能希望根据 `process.env.NODE_ENV` 的值禁用此路由，或者在 `index.js` 中的 `/graphql`
    路由上添加基于身份验证的中间件。
- en: '![ Figure 9.6 – The GraphQL Yoga dashboard ](img/Figure_9.06_B17841.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – GraphQL Yoga 仪表板](img/Figure_9.06_B17841.jpg)'
- en: Figure 9.6 – The GraphQL Yoga dashboard
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – GraphQL Yoga 仪表板
- en: 'We can test our queries and resolvers by executing queries within this dashboard.
    Remove all of the current content on the notepad section of the dashboard and
    enter the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在仪表板中执行查询来测试我们的查询和解析器。删除仪表板记事本部分的所有当前内容，并输入以下内容：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There should be a “play button” at the top that will execute your query (alternatively,
    hitting the *Ctrl* and *Enter* keys simultaneously will do the same), which should
    yield results similar to the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部应该有一个“播放按钮”，点击它将执行您的查询（或者，同时按下 *Ctrl* 和 *Enter* 键也可以达到同样的效果），这将产生类似于以下的结果：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we wanted to update our airplane’s model name, we could use a `mutation`
    query:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更新飞机的模型名称，我们可以使用一个 `mutation` 查询：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will return the following result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下结果：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Within the GraphQL Yoga dashboard, there should be a **< Docs** link at the
    top right (refer to *Figure 9.6*), which will open a drawer panel. There will
    then be a **Query** link, which will expose our queries and type definitions.
    This should help make queries easier within the dashboard.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL Yoga 仪表板中，顶部右方应该有一个 **< Docs** 链接（参见图 9.6*），点击它将打开一个抽屉面板。然后会有一个 **Query**
    链接，这将暴露我们的查询和类型定义。这应该有助于在仪表板中使查询更加容易。
- en: Now that we have established a connection between a GraphQL server and our Sequelize
    models and integrated another adapter that provides an easy-to-use admin dashboard,
    it is time for us to build our own adapter for Sequelize.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个 GraphQL 服务器和我们的 Sequelize 模型之间的连接，并集成了另一个提供易于使用的管理仪表板的适配器，是时候为我们自己的
    Sequelize 构建适配器了。
- en: Creating our own adapter
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的适配器
- en: Sequelize is fairly extensible through its class properties, lifecycle events,
    and configurations. For the example of creating our own adapter for Sequelize,
    we will integrate a new data type that will automatically convert values, using
    a specific set of rules, to what is called a “slug URL.” A slug URL usually consists
    of hyphens instead of spaces, lowercase lettering, and removes all special characters.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 通过其类属性、生命周期事件和配置相当可扩展。对于创建 Sequelize 自定义适配器的示例，我们将集成一个新的数据类型，该类型将自动使用一组特定的规则将值转换为所谓的“slug
    URL”。slug URL 通常由连字符代替空格、小写字母，并移除所有特殊字符。
- en: 'Let’s look at the steps to create our adapter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建我们的适配器的步骤：
- en: 'We’ll begin by installing any necessary packages. Keeping a copy of a character
    map of special characters can be a daunting task, so we will use an `npm` package
    called, `github-slugger` to help us:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始安装任何必要的包。保留特殊字符字符映射的副本可能是一项艰巨的任务，因此我们将使用一个名为 `github-slugger` 的 `npm` 包来帮助我们：
- en: '[PRE32]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will want to create a couple of directories and a file with `plugins/slug/index.js`
    as the path from the project’s root directory. Before we can begin coding within
    that file, we will need to add the `slug` column to a table within the database.
    We will use the Airplane model for this example; using the `sequelize-cli` command,
    we can create a new migration event:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望创建几个目录和一个文件，其路径为从项目根目录到 `plugins/slug/index.js`。在我们能够开始在该文件中编码之前，我们需要将
    `slug` 列添加到数据库中的一个表中。我们将使用 Airplane 模型作为此示例；使用 `sequelize-cli` 命令，我们可以创建一个新的迁移事件：
- en: '[PRE33]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This command should generate a new file within the `migrations` directory ending
    in `add_slug_to_airplanes.js`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应在 `migrations` 目录中生成一个以 `add_slug_to_airplanes.js` 结尾的新文件。
- en: 'Replace the file’s contents with the following:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件内容替换为以下内容：
- en: '[PRE34]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will instruct Sequelize to create a new column in the `Airplanes` table
    called `slug` as a text value, along with a unique index that is associated with
    that column.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示 Sequelize 在 `Airplanes` 表中创建一个名为 `slug` 的新列，作为文本值，并关联一个与该列相关的唯一索引。
- en: 'To perform the latest migration, we will run the `db:migrate` command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行最新的迁移，我们将运行 `db:migrate` 命令：
- en: '[PRE35]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After the column has been added to the Airplanes table, we will need to add
    the attribute manually to the `models/airplanes.js` file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在列被添加到 Airplanes 表之后，我们还需要手动将其属性添加到 `models/airplanes.js` 文件中。
- en: 'Replace the `totalSeats` attribute block with the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `totalSeats` 属性块替换为以下内容：
- en: '[PRE36]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `graphql.js` file, we will want to add the `slug` column to the `Airplane`
    type definition as well:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `graphql.js` 文件中，我们希望将 `slug` 列添加到 `Airplane` 类型定义中：
- en: '[PRE37]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we can begin editing the `plugins/slug/index.js` file, starting with the
    following lines of code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编辑 `plugins/slug/index.js` 文件，从以下代码行开始：
- en: '[PRE38]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will create a `SlugPlugin` class with one method called `use`. The input
    parameters are the `model` class, a couple of options, and their defaults.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `SlugPlugin` 的类，其中有一个名为 `use` 的方法。输入参数是 `model` 类、一些选项及其默认值。
- en: 'Underneath those blocks, we will create our `generateSlug` method:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些块下面，我们将创建我们的 `generateSlug` 方法：
- en: '[PRE39]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will want to ensure that a slug does not exist prior to updating.
    We will want to create some sort of finder method and an increment method for
    funding a unique value. We can start with the finder method shown here:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望确保在更新之前 slug 不存在。我们希望创建一种查找方法和一个增量方法来找到一个唯一的值。我们可以从下面的查找方法开始：
- en: '[PRE40]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now for the incremental method; this function will run in a loop until a unique
    match is found using a combination of the slug’s value and an integer. Ideally,
    in a real production environment, we would come up with a cleverer way of finding
    unique values (for example, appending a hash instead of an incremental variable),
    but for brevity, we will create this function:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是增量方法；此函数将循环运行，直到使用 slug 的值和整数组合找到一个唯一的匹配项。理想情况下，在真实的生产环境中，我们会想出一种更聪明的方法来找到唯一的值（例如，附加一个哈希而不是增量变量），但为了简洁，我们将创建此函数：
- en: '[PRE41]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now begin creating the main event function. First, we will check whether
    our slug’s applicable attributes (the `planeModel` attribute, in this example)
    have been modified. If they have not been changed, then we will skip the entire
    event, since there is nothing to be done:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以开始创建主要事件函数。首先，我们将检查我们的 slug 的适用属性（在这个例子中是 `planeModel` 属性）是否已被修改。如果没有被更改，那么我们将跳过整个事件，因为没有事情要做：
- en: '[PRE42]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we will compare the current value with the newly generated value. If
    they are the same (for example, a letter casing change), then simply skip the
    event:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将比较当前值与新生成的值。如果它们相同（例如，字母大小写的变化），则简单地跳过事件：
- en: '[PRE43]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we can check and see whether the newly generated value is unique and,
    if so, set the instance’s `slug` attribute to that value and return the instance:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以检查新生成的值是否唯一，如果是，则将实例的`slug`属性设置为该值并返回实例：
- en: '[PRE44]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Otherwise, we will want to use our `incrementSuffix` method and return the
    instance afterward:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们将想要使用我们的`incrementSuffix`方法，并在之后返回实例：
- en: '[PRE45]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Afterward, we can close our `event` method, attach the method to the model’s
    lifecycle events, and close the `SlugPlugin` class:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以关闭`event`方法，将其附加到模型的生存周期事件上，并关闭`SlugPlugin`类：
- en: '[PRE46]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we can export an instance of our plugin as well as the class definition
    itself:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以导出我们插件的一个实例以及类定义本身：
- en: '[PRE47]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Within the `models/airplanes.js` file, we will want to integrate our new plugin
    with the model. At the top of the file, we can include the plugin like so:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`models/airplanes.js`文件中，我们希望将我们的新插件与模型集成。在文件顶部，我们可以像这样包含插件：
- en: '[PRE48]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After the model’s definition, and before the `return Airplane` line, we can
    associate the `slug` plugin with the model:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模型的定义之后，在`return Airplane`行之前，我们可以将`slug`插件与模型关联：
- en: '[PRE49]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will tell our plugin to use the `planeModel` attribute as the source field
    when generating the slug’s value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉我们的插件在生成slug值时使用`planeModel`属性作为源字段。
- en: 'In order to test our plugin, we can go to our GraphQL dashboard located at
    `http://localhost:3000/graphql` and enter the following command:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的插件，我们可以前往位于`http://localhost:3000/graphql`的GraphQL仪表板，并输入以下命令：
- en: '[PRE50]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will find, and update, our A321 airplane’s `planeModel` value along with
    setting a `slug` value, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到并更新我们的A321飞机的`planeModel`值，同时设置一个`slug`值，如下所示：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This finalizes our custom Sequelize adapter section. You can use the `plugins/slug/index.js`
    adapter in any other project using Sequelize. Feel free to add `slug` columns
    to other models, but make sure to follow the necessary steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的自定义Sequelize适配器部分。您可以在使用Sequelize的任何其他项目中使用`plugins/slug/index.js`适配器。请随意将`slug`列添加到其他模型中，但请确保遵循必要的步骤：
- en: Generate a migration file and migrate the column changes to the database.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成迁移文件并将列更改迁移到数据库。
- en: Update the `graphql.js` file with the appropriate type definitions.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`graphql.js`文件，添加适当的数据类型定义。
- en: Include the `plugin` library within the applicable models’ files and associate
    the plugin with the models using the `use` method.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在适用模型的文件中包含`plugin`库，并使用`use`方法将插件与模型关联。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the process of installing a dashboard that
    integrates with a database, integrating GraphQL using a third-party library, and
    creating our own Sequelize adapter that will automatically add slug values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了安装与数据库集成的仪表板的过程，使用第三方库集成GraphQL，以及创建我们自己的Sequelize适配器，该适配器将自动添加slug值。
- en: In the next chapter, we will start developing our website to be more production-ready
    and feature-complete. Some of these features include listing schedules, ordering
    tickets, and entering customer information.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始开发我们的网站，使其更具生产准备性和功能完整性。这些功能包括列出时间表、订购票务和输入客户信息。
