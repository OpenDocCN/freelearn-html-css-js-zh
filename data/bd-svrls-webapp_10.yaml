- en: Testing, Deploying, and Monitoring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试、部署和监控
- en: We are approaching the end of this book, but we can't finish without discussing
    some aspects that are beyond coding a solution. We need to understand how you
    can test functions that run in an environment that you don't own, what is a good
    development workflow to deploy and deliver new versions of your solution, and,
    although we don't need to worry about servers when building a serverless project,
    we need to understand what is the minimal monitoring that we need to configure
    to provide a cost-efficient and reliable solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接近本书的结尾，但在讨论一些超出编写解决方案编码的方面之前，我们无法结束。我们需要了解您如何测试运行在您不拥有的环境中的函数，一个好的开发工作流程来部署和交付您解决方案的新版本，以及尽管在构建无服务器项目时我们不需要担心服务器，但我们仍需要了解我们需要配置的最小监控，以提供成本效益和可靠的解决方案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Testing a serverless solution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试无服务器解决方案
- en: Defining how to handle the deployment and delivery of new versions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义如何处理新版本的部署和交付
- en: Monitoring errors, performance, and costs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控错误、性能和成本
- en: After this chapter, you'll have completed the book and will be prepared to build
    your next solution with serverless components or enhance an existing one benefiting
    from the serverless concept.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章后，您将完成本书，并准备好使用无服务器组件构建您的下一个解决方案或增强现有的解决方案，从中受益于无服务器概念。
- en: Testing your solution
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的解决方案
- en: Testing a serverless project can be a challenging experience, since we rely
    on many different cloud services that are hard to emulate locally and, besides
    testing individual services, we need to test how they work together.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试无服务器项目可能是一个具有挑战性的经验，因为我们依赖于许多不同的云服务，这些服务在本地很难模拟，并且除了测试单个服务之外，我们还需要测试它们如何协同工作。
- en: However, the practices that you have already used in traditional projects can
    all be used for serverless applications. To improve the quality of your software,
    you may use **Test-Driven Development** (**TDD**), **Behavior-Driven Development**
    (**BDD**), or any other development process that fundamentally relies on automating
    tests. Although we don't have access to the machines that will execute the code,
    we can simulate many things locally and we can run integrations tests from time
    to time to assert that everything works as expected.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您已经在传统项目中使用的所有实践都可以用于无服务器应用程序。为了提高您软件的质量，您可以使用 **测试驱动开发**（**TDD**）、**行为驱动开发**（**BDD**）或任何本质上依赖于自动化测试的开发流程。尽管我们没有访问将执行代码的机器，但我们可以在本地模拟许多事情，并且我们可以不时运行集成测试，以断言一切按预期工作。
- en: In the following sections, we are going to see how to create tests for the backend
    and frontend. To make this topic simpler, we are going to create tests for trivial
    functions. If you want more extensive examples, you can browse the code files
    of this chapter to see how the serverless store was tested.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将看到如何为后端和前端创建测试。为了使这个主题更简单，我们将为简单的函数创建测试。如果您想查看更广泛的示例，可以浏览本章的代码文件，以了解无服务器存储是如何被测试的。
- en: Unit testing Lambda functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 函数的单元测试
- en: Since a Lambda function is defined in a common JavaScript file, you just need
    to set your testing tool to load this file and test the function locally. To simulate
    the input data that is set by the API Gateway or another trigger, you need to
    set the `event` variable of your test according to the expected input.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Lambda 函数是在一个公共 JavaScript 文件中定义的，您只需将您的测试工具设置为加载此文件并测试本地函数。为了模拟由 API 网关或其他触发器设置的输入数据，您需要根据预期的输入设置您的测试中的
    `event` 变量。
- en: 'Let''s perform the following steps to see how to unit test a Lambda function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，看看如何对 Lambda 函数进行单元测试：
- en: 'First, let''s create a new serverless project by running the following command:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过运行以下命令创建一个新的无服务器项目：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s modify the `serverless.yml` file to the following:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修改 `serverless.yml` 文件，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this project, we have only one Lambda function, and this `hello` function
    is defined by a `greetings.js` file inside a folder named `functions`. Consider
    the following simple implementation:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个项目中，我们只有一个 Lambda 函数，这个 `hello` 函数是由位于 `functions` 文件夹内的 `greetings.js` 文件定义的。考虑以下简单的实现：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This `hello` function is the function that we want to test. Now, let''s create
    our testing code. In the following screenshot, we show the project tree, where
    a folder named `test` was created and it contains a `mocha.opts` file, along with
    two other folders, `unit` and `integration`. Since this sample code doesn''t interact
    with any other service, we can call it a `unit` test and the file `test-greetings.js`
    is where it will be implemented:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 `hello` 函数是我们想要测试的函数。现在，让我们创建我们的测试代码。在下面的屏幕截图中，我们展示了项目树，其中创建了一个名为 `test`
    的文件夹，它包含一个 `mocha.opts` 文件，以及另外两个文件夹，`unit` 和 `integration`。由于这个示例代码不与任何其他服务交互，我们可以将其称为
    `unit` 测试，而 `test-greetings.js` 文件就是它将被实现的地方：
- en: '![](img/292f8892-ccf8-47e1-b638-6efa46ddc8e2.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/292f8892-ccf8-47e1-b638-6efa46ddc8e2.png)'
- en: 'We can exclude this `test` folder and all of its contents from the deployment
    package by adding an exclude rule at the end of the `serverless.yml` file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在 `serverless.yml` 文件的末尾添加一个排除规则来排除这个 `test` 文件夹及其所有内容，从而将其从部署包中排除：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Regarding the `mocha.opts` file, it was included to configure the options for
    the Mocha test framework ([https://mochajs.org/](https://mochajs.org/)), but you
    can use any other testing tool.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于 `mocha.opts` 文件，它被包含进来是为了配置 Mocha 测试框架（[https://mochajs.org/](https://mochajs.org/))
    的选项，但你也可以使用任何其他的测试工具。
- en: 'In this `mocha.opts` file, I''ve added only one line of code to specify which
    folder must be used to run tests:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个 `mocha.opts` 文件中，我只添加了一行代码来指定必须使用哪个文件夹来运行测试：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `unit` folder will hold unit tests, which are tests that must execute in
    milliseconds so that the developer can immediately assert the state of the code
    with each modification. The `integration` folder holds tests that access external
    services and are allowed to complete in seconds/minutes. These are designed to
    execute occasionally, usually once a day, and not as frequently as unit tests.
    So, they were not included in the options.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`unit` 文件夹将包含单元测试，这些测试必须在毫秒内执行，以便开发者可以在每次修改后立即断言代码的状态。`integration` 文件夹包含访问外部服务的测试，允许它们在秒/分钟内完成。这些测试设计为偶尔执行，通常每天执行一次，而不是像单元测试那样频繁。因此，它们没有被包含在选项中。'
- en: 'Mocha is installed through npm, so we need to add a `package.json` file and
    execute the following command:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mocha 通过 npm 安装，因此我们需要添加一个 `package.json` 文件并执行以下命令：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `package.json` file, add a `test` command with the `mocha` value in
    the `scripts` field. It will be helpful later, since you can run the `npm test`
    command to execute the unit tests:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `package.json` 文件中，在 `scripts` 字段中添加一个 `test` 命令，其值为 `mocha`。这将很有帮助，因为你可以运行
    `npm test` 命令来执行单元测试：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have properly set up the test environment, we can implement the
    test file named `test-greetings.js`. To use Mocha, we need to use the `describe`
    function to list the test cases and the `it` function to implement a test case:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经正确设置了测试环境，我们可以实现名为 `test-greetings.js` 的测试文件。要使用 Mocha，我们需要使用 `describe`
    函数来列出测试用例，以及 `it` 函数来实现测试用例：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For this Lambda function, we can implement the following test:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个 Lambda 函数，我们可以实现以下测试：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To execute the tests, run `npm test`. You should receive the following output:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行测试，请运行 `npm test`。你应该会收到以下输出：
- en: '![](img/389eeef3-3b6f-443d-b14d-61c686f7bee0.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/389eeef3-3b6f-443d-b14d-61c686f7bee0.png)'
- en: 'As a good practice, you should always *test* the test. You can do this by changing
    the expected result from `Hello, John!` to `Bye, John!`, which will obviously
    make the assert fail, resulting in the following output:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一种良好的实践，你应该始终对测试进行测试。你可以通过将预期结果从 `Hello, John!` 更改为 `Bye, John!` 来做到这一点，这显然会导致断言失败，并产生以下输出：
- en: '![](img/a49fc326-18c0-4f40-9688-3e49dbba583a.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a49fc326-18c0-4f40-9688-3e49dbba583a.png)'
- en: Mocking external services
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟外部服务
- en: Sometimes, you can't unit test a Lambda function directly simply because, sometimes,
    you can't consider the function as a *unit*. If the function interacts with external
    services, like sending a notification or persisting some data in a database, you
    can't consider it as a unit of logic. In this case, you can only unit test the
    function if you remove such dependencies from the test, and you do so by *mocking*
    them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你无法直接对 Lambda 函数进行单元测试，仅仅是因为有时候你不能将函数视为一个 *单元*。如果函数与外部服务交互，比如发送通知或在数据库中持久化一些数据，你就不能将其视为逻辑单元。在这种情况下，只有在你从测试中移除这些依赖项的情况下，你才能对函数进行单元测试，而你这样做是通过
    *模拟* 它们来实现的。
- en: Mocking is the act of building an object to simulate the behavior of another
    object. When we need to test a complex service, there are many underlying behaviors
    that we may not be interested in testing. For example, if I use an external service
    to process credit card payments and I want to test whether it processes correctly
    for a given input, I don't want to handle unexpected events such as connectivity
    issues. In this case, I could create a fake object that would imitate the expected
    behavior and my test case would return success or failure if a specific condition
    is met.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是指构建一个对象来模拟另一个对象的行为。当我们需要测试一个复杂的服务时，有许多底层行为我们可能不感兴趣测试。例如，如果我使用外部服务处理信用卡支付，并且我想测试它是否对给定的输入处理正确，我不希望处理意外事件，例如连接问题。在这种情况下，我可以创建一个模拟对象来模仿预期的行为，如果满足特定条件，我的测试用例将返回成功或失败。
- en: To be able to mock services, we need to separate the business logic from external
    services. With this approach, we can write unit tests and keep the solution less
    dependent of cloud services, which helps if one day you need to migrate from one
    cloud provider to another.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够模拟服务，我们需要将业务逻辑与外部服务分离。采用这种方法，我们可以编写单元测试，并保持解决方案对云服务的依赖性较低，这有助于有一天你需要从一家云服务提供商迁移到另一家。
- en: 'The following code shows an example where there **isn''t** a clear separation
    of the business logic and services. Therefore, it is harder to test:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一个例子，其中**没有**清晰的业务逻辑和服务分离。因此，测试起来更困难：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example receives an order information, saves it in a database, and sends
    an e-mail notification. There are two main problems here such as the code is bound
    to the input (how it handles the `event` object) and you can't unit test the inner
    contents of the Lambda function without triggering requests to the database and
    the notification service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子接收订单信息，将其保存到数据库中，并发送电子邮件通知。这里有两个主要问题，比如代码绑定到输入（它如何处理 `event` 对象），并且你不能在不触发对数据库和通知服务的请求的情况下对
    Lambda 函数的内部内容进行单元测试。
- en: 'A better implementation is to create a separated module that will control the
    business logic, and to build this module allowing you to inject the dependencies:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的实现方式是创建一个独立的模块来控制业务逻辑，并且构建这个模块时允许你注入依赖：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, this code can be unit tested since the database and notifier services are
    passed as input values, so they can be mocked.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于数据库和通知服务作为输入值传递，这段代码可以进行单元测试，因此它们可以被模拟。
- en: 'Regarding the Lambda code, it becomes much simpler:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Lambda 代码，它变得简单得多：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using Sinon.JS for mocking
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sinon.JS 进行模拟
- en: In the previous example, we improved the Lambda function by creating an external
    module, named `Order`, to handle all actions related to orders. This was necessary
    because we can only mock the objects that we have access to. We won't be able
    to test the Lambda function directly because we don't have access to the services
    that it uses (database and notifications), but at least we will be able to test
    the `Order` class, since it allows the services to be injected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过创建一个名为 `Order` 的外部模块来改进 Lambda 函数，以处理所有与订单相关的操作。这是必要的，因为我们只能模拟我们能够访问的对象。我们无法直接测试
    Lambda 函数，因为我们无法访问它使用的服务（数据库和通知），但至少我们可以测试 `Order` 类，因为它允许注入服务。
- en: 'For our mocking example, we are going to use Sinon.JS. It can be installed
    with the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模拟示例，我们将使用 Sinon.JS。可以使用以下命令进行安装：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Sinon will be used along with Mocha. So, we will need to create a test case
    like the following one:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon 将与 Mocha 一起使用。因此，我们需要创建一个如下所示的测试用例：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can implement this test as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以下这样实现这个测试：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example shows that you can use Sinon.JS to check whether your dependencies
    are being called as expected and with the correct parameters. You can improve
    this example, adding fake responses and testing different behaviors, but we won't
    go deeper into this subject because those features are not strictly related to
    serverless. The objective here is to show that common testing frameworks can be
    used with serverless without needing anything special to configure them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，你可以使用 Sinon.JS 来检查你的依赖是否按预期和正确的参数被调用。你可以改进这个例子，添加假响应并测试不同的行为，但我们不会深入这个主题，因为这些功能与无服务器架构不是严格相关的。这里的目的是展示常见的测试框架可以在无服务器架构中使用，而不需要特殊配置。
- en: Testing the frontend
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试前端
- en: We have developed the frontend using React, so we will build a simple example
    to show how you can test it. The objective is to see if a simple component renders
    correctly and if it displays a text as expected.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 React 开发了前端，因此我们将构建一个简单的示例来展示你如何测试它。目标是查看一个简单的组件是否正确渲染，并且是否如预期那样显示文本。
- en: 'Let''s take a look at the following steps to create this example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤来创建这个示例：
- en: 'We will start by creating a new React project executing the following command:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先通过执行以下命令创建一个新的 React 项目：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create React App uses Jest as its test runner. As a convention, it will always
    looks for files that end with `.test.js` to execute the tests. In the default
    template, we have the `App.js` and `App.test.js` files. If you run `npm test`,
    Jest will execute the sample test that was created in `App.test.js` and it will
    output the following result:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Create React App 使用 Jest 作为其测试运行器。按照惯例，它将始终寻找以 `.test.js` 结尾的文件来执行测试。在默认模板中，我们有
    `App.js` 和 `App.test.js` 文件。如果你运行 `npm test`，Jest 将执行在 `App.test.js` 中创建的示例测试，并将输出以下结果：
- en: '![](img/cbdf4bfd-3d05-4442-8927-ae6063c0af4e.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbdf4bfd-3d05-4442-8927-ae6063c0af4e.png)'
- en: After running `npm test`, Jest will be watching for changes, so you can continue
    developing your frontend and Jest will execute all test cases whenever you save
    a file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm test` 后，Jest 将监视更改，因此你可以继续开发你的前端，并且每当保存文件时，Jest 都将执行所有测试用例。
- en: 'Inside `App.js`, we have an `App` component defined by the following code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App.js` 中，我们定义了一个 `App` 组件，其代码如下：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And `App.test.js` is defined by the following code, which is just a smoke test
    to see if the component can be rendered without crashing:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且 `App.test.js` 的定义如下，它只是一个烟雾测试，用于查看组件是否可以渲染而不崩溃：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we are going to improve this test case and we will need to install two
    helper tools such as Enzyme and react-test-renderer:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将改进这个测试用例，并且我们需要安装两个辅助工具，如 Enzyme 和 react-test-renderer：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With Enzyme, we can simplify the previous example by using the `mount` function
    instead of `ReactDOM.render`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Enzyme，我们可以通过使用 `mount` 函数而不是 `ReactDOM.render` 来简化前面的示例：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To finish this example, we are going to add another test case to see if a given
    element, `<h2>Welcome to React</h2>`, was rendered within this component as we
    are expecting:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个示例，我们将添加另一个测试用例来查看是否如预期那样，给定的元素 `<h2>Welcome to React</h2>` 已在组件中渲染：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Simulating AWS services locally
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地模拟 AWS 服务
- en: One of the drawbacks of using cloud services is that they offer products that
    you can't install on your own machine. If you could install them, your development
    speed would increase because testing locally is faster them connecting to them
    through the Internet.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云服务的缺点之一是它们提供的产品你不能安装在自己的机器上。如果你能安装它们，你的开发速度将会提高，因为本地测试比通过互联网连接它们要快。
- en: 'To solve this limitation, there are many tools that have been created by the
    community to help you to simulate AWS services by running them locally. You can
    find some of them in the following links:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个限制，社区已经创建了多个工具来帮助你通过在本地运行来模拟 AWS 服务。你可以在以下链接中找到一些：
- en: '**Lambda functions**: [https://github.com/lambci/docker-lambda](https://github.com/lambci/docker-lambda)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda 函数**：[https://github.com/lambci/docker-lambda](https://github.com/lambci/docker-lambda)'
- en: '**API Gateway and Lambda**: [https://github.com/dherault/serverless-offline](https://github.com/dherault/serverless-offline)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API Gateway 和 Lambda**：[https://github.com/dherault/serverless-offline](https://github.com/dherault/serverless-offline)'
- en: '**Scheduled Lambda functions**: [https://github.com/ajmath/serverless-offline-scheduler](https://github.com/ajmath/serverless-offline-scheduler)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划中的 Lambda 函数**：[https://github.com/ajmath/serverless-offline-scheduler](https://github.com/ajmath/serverless-offline-scheduler)'
- en: '**DynamoDB**: [https://github.com/mhart/dynalite](https://github.com/mhart/dynalite)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DynamoDB**：[https://github.com/mhart/dynalite](https://github.com/mhart/dynalite)'
- en: 'There are some benefits and drawbacks with this strategy. Particularly, I don''t
    buy this idea and I don''t use them. You can find my view of the pros and cons
    as follows and decide for yourself if those tools may improve your development
    workflow:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种策略有一些优点和缺点。特别是，我不认同这个观点，并且我不会使用它们。你可以通过以下内容找到我对优缺点的看法，并自行决定这些工具是否可能改善你的开发工作流程：
- en: '**Pros:**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点：**'
- en: '**Speed**: It is faster to run locally than using the Internet.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：在本地运行比使用互联网更快。'
- en: '**Tests**: Some tools are just mocks that simulate the behavior of a real service
    without making any I/O operations, which means that you can test your services
    without changing your code. Others are similar implementations that allows you
    to debug your code.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：有些工具只是模拟器，它们模拟真实服务的行怍而不进行任何I/O操作，这意味着你可以测试你的服务而不必更改你的代码。其他工具是类似实现，允许你调试你的代码。'
- en: '**Costs**: You can run them for free using your own machine.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：你可以使用自己的机器免费运行它们。'
- en: '**Cons:**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: '**Speed**: Most services need extra configuration steps. For a small project,
    you may take more time configuring and troubleshooting issues with the fake services
    than you will benefit from faster tests.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：大多数服务都需要额外的配置步骤。对于一个小型项目，你可能会花费更多的时间来配置和调试假服务的问题，这比你从更快的测试中获得的收益要多。'
- en: '**Tests**: It is hard to feel confident in your tests if you are using only
    simulated services. You need to run integration tests with real services from
    time to time. Also, you may not be able to do some tests. For example, simulating
    IAM permissions is really hard.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：如果你只使用模拟服务，你很难对自己的测试有信心。你需要时不时地运行与真实服务集成的测试。此外，你可能无法进行某些测试。例如，模拟IAM权限是非常困难的。'
- en: '**Costs**: You may spend more developer-hours configuring those tools than
    you will save on cloud costs. Most cloud providers have adopted a pricing schema
    where they offer a free tier that allows developers to build and test their products
    for free and the providers just start to charge money when the service is used
    intensively.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：你可能会在配置这些工具上花费比你在云成本上节省的更多开发者时间。大多数云提供商已经采用了定价模式，他们提供免费层，允许开发者免费构建和测试他们的产品，并且只有在服务被密集使用时才开始收费。'
- en: Deploying your application
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署你的应用程序
- en: In this section, we will discuss the deployment of a serverless application.
    I'm not referring to just running the `serverless deploy` command, what I mean
    is that you need to know and define how to handle and manage new versions of your
    application in the production environment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论无服务器应用程序的部署。我并不是指仅仅运行`serverless deploy`命令，我的意思是你需要知道并定义如何在生产环境中处理和管理应用程序的新版本。
- en: Can you hit the deploy button at any time of the day? What are the implications?
    How can you create a replica of the production environment just for testing? Those
    are the kind of things that will be discussed in this section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否可以在任何时间点击部署按钮？这有什么影响？你如何只为测试创建生产环境的副本？这些都是本节将要讨论的内容。
- en: Development workflow
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工作流程
- en: Deploying a new version of a Lambda function is a simple task. We run a command
    and the framework is responsible for packaging the contents and uploading them
    to AWS. However, running the `serverless deploy` command usually takes a couple
    of minutes. The problem is not the time to upload the ZIP file, but what the framework
    needs to update using CloudFormation. A new CloudFormation template needs to be
    issued asking AWS to update all related resources of a specific zone, which takes
    time. As our codebase grows, we may need to create dozens of API Gateway endpoints,
    many different IAM roles, or other kinds of AWS resources. Managing them can be
    troublesome, as they increase the deployment time to an unpleasant duration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 部署Lambda函数的新版本是一个简单的任务。我们运行一个命令，框架负责打包内容并将它们上传到AWS。然而，运行`serverless deploy`命令通常需要几分钟。问题不在于上传ZIP文件的时间，而在于框架需要使用CloudFormation更新的内容。需要发布一个新的CloudFormation模板，要求AWS更新特定区域的全部相关资源，这需要时间。随着我们的代码库增长，我们可能需要创建数十个API
    Gateway端点，许多不同的IAM角色或其他类型的AWS资源。管理它们可能会很麻烦，因为它们会增加部署时间到一个不愉快的长度。
- en: 'Reducing this time can be achieved using selective deployment. If you have
    modified just a specific function, you can make a fast deploy by referencing it
    using the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选择性部署可以减少这种时间。如果你只修改了特定的功能，你可以通过以下命令快速部署：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Blue-green deployment
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: Blue-green deployment is a common technique to deploy a new version of software
    without generating unavailability. Consider that you're running an application
    of the 3.0 version and you want to deploy the new 3.1 version. Before you start
    updating your machines, all of them are using the 3.0 version and we say that
    they are in a *blue* state. We start by creating new machines with the updated
    code, version 3.1, and these machines are in a *green* state. The next step is
    to modify the load balancer to redirect all new connections to the new machines
    (green) while it keeps on running requests to the old machines (blue). After the
    previous calls finish running, the *blue* machines won't receive any new requests,
    and they can be shutdown.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署是一种常见的部署新版本软件的技术，它可以避免产生不可用性。假设你正在运行3.0版本的软件，并且你想要部署新的3.1版本。在你开始更新你的机器之前，所有的机器都在使用3.0版本，我们称它们处于*蓝色*状态。我们首先创建带有更新代码的新机器，版本号为3.1，这些机器处于*绿色*状态。下一步是修改负载均衡器，将所有新的连接重定向到新机器（绿色），同时继续处理旧机器（蓝色）的请求。在之前的请求处理完成后，*蓝色*机器将不会收到任何新的请求，它们可以被关闭。
- en: Blue-green is important because, in the past, as we usually had just one web
    server machine to handle an application, the common practice was to stop the web
    server, update the code, and start it again. Those few seconds of unavailability
    were acceptable in the past, but today, with automation and the possibility of
    distributing the load among multiple servers, it is not necessary anymore to disrupt
    the service for an update or maintenance routine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署之所以重要，是因为在过去，我们通常只有一个用于处理应用的Web服务器机器，常见的做法是停止Web服务器，更新代码，然后重新启动。过去，那几秒钟的不可用性是可以接受的，但今天，随着自动化和将负载分配到多个服务器的可能性，更新或维护流程中不再需要中断服务。
- en: 'This concept is equivalent in the serverless world. When you update the code
    of a Lambda function, AWS will use it to handle new incoming requests while the
    previous one will keep running with the previous code. The API Gateway will also
    handle modifications in the endpoints behaviors without causing unavailability:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器世界中，这个概念是等效的。当你更新Lambda函数的代码时，AWS会使用它来处理新的请求，而之前的版本将继续使用之前的代码运行。API网关也将处理端点行为的修改，而不会造成不可用性：
- en: '![](img/72c5f8ca-50f5-46d6-a1d2-335823f3dde2.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72c5f8ca-50f5-46d6-a1d2-335823f3dde2.png)'
- en: 'So, answering the previous question: can you hit the deploy button at any time
    of the day? Yes, you can deploy new versions of your application without worrying
    about availability. However, during the deployment of a new version, we can have
    different versions running simultaneously. You should pay attention to this case,
    especially regarding versions that require changes to the database model.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回答之前的问题：你可以在任何时间点点击部署按钮吗？是的，你可以部署你应用的新的版本，无需担心可用性。然而，在部署新版本的过程中，我们可能会同时运行不同的版本。你应该注意这种情况，特别是关于需要更改数据库模型的版本。
- en: Deploying new versions with a different database model
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同数据库模型的部署新版本
- en: In serverless, we usually run code that executes in fractions of a second. So,
    running two different versions simultaneously may take less than a second, but
    how do we apply databases changes in a model? Renaming a column may break the
    execution of a previous version.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器中，我们通常运行执行时间仅为几秒钟的代码。因此，同时运行两个不同的版本可能不到一秒钟，但我们如何在一个模型中应用数据库更改？重命名一个列可能会破坏旧版本的执行。
- en: Ideally, we would all be using NoSQL databases with flexible schemas, but that's
    not true. Some business cases are better handled by relational databases or NoSQL
    databases with a restrict schema.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们都会使用具有灵活模式的NoSQL数据库，但这并不现实。有些业务案例更适合由关系数据库或具有限制性模式的NoSQL数据库来处理。
- en: When modifying a schema, there are three operations that require our attention
    such as create, rename, and drop.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当修改模式时，有三个操作需要我们注意，如创建、重命名和删除。
- en: Creating a new table or column
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新表或列
- en: Adding a table or a column in a pre-existing table shouldn't break any kind
    of application. However, there are some ORM tools, such as the Entity Framework
    (for .NET), that associates each schema version with a migration ID. In this case,
    when you run a migrate command to upgrade a database schema, it adds a new migration
    ID that will be checked by the application code. If you run the previous version
    of the code, the ID will not match and it will return an error.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有的表中添加表或列不应该破坏任何应用程序。然而，有一些 ORM 工具，如 Entity Framework（用于 .NET），将每个架构版本与迁移
    ID 关联。在这种情况下，当你运行迁移命令以升级数据库架构时，它会添加一个新的迁移 ID，该 ID 将由应用程序代码检查。如果你运行之前的代码版本，ID 将不匹配，并且会返回错误。
- en: This kind of restriction was created as a safety measure to avoid a deprecated
    code from running in production and causing inconsistencies when the expected
    model is different. Though, if you have proper control over your deployments,
    you can disable this restriction to avoid unavailabilities while upgrading versions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制是为了安全措施而创建的，以避免过时的代码在生产环境中运行，当预期的模型不同时造成不一致。尽管如此，如果你对你的部署有适当的控制，你可以禁用这个限制，以避免在升级版本时出现不可用的情况。
- en: Also, we need to pay attention when we add constraints or foreign keys. If you
    modify a table with thousands of rows to add a new foreign key, the alter table
    command may need some significant time to process. While processing, the table
    will be locked for selects and this can lead to some query timeouts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要注意当我们添加约束或外键时。如果你修改包含数千行数据的表以添加一个新的外键，`ALTER TABLE` 命令可能需要一些显著的时间来处理。在处理过程中，表将锁定以供选择，这可能导致一些查询超时。
- en: Renaming a table or column
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名表或列
- en: Suppose you need to rename a column from name `A` to `B`. If you make this change,
    the previous code may not work properly, since it won't find the column with name
    `A` and the newest code may not work if deployed before the rename happens.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要将一个列名从 `A` 改为 `B`。如果你进行这个变更，之前的代码可能无法正常工作，因为它找不到名为 `A` 的列，而最新的代码如果在重命名之前部署，也可能无法正常工作。
- en: 'The proposed solution here is to make this change by performing the following
    steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的解决方案是通过执行以下步骤来实施这一变更：
- en: Run a script to create a new column named `B`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个脚本以创建一个名为 `B` 的新列。
- en: Add a temporary trigger that will execute every time that you modify some data
    in the `A` column to apply the same modifications to the `B` column.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个临时触发器，每次修改 `A` 列中的数据时都会执行，以将相同的修改应用到 `B` 列。
- en: Duplicate all contents from `A` to `B`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `A` 到 `B` 的所有内容进行复制。
- en: Deploy a new code version that is exactly like the previous one, but read/write
    using the column `B` and not `A`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署一个与之前版本完全相同的新代码版本，但使用列 `B` 而不是 `A` 进行读写。
- en: Wait a bit to ensure that all requests are using the new Lambda code and not
    the previous one. You may need to wait for the maximum timeout of your Lambda
    functions.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍等片刻以确保所有请求都在使用新的 Lambda 代码，而不是之前的版本。你可能需要等待 Lambda 函数的最大超时时间。
- en: Run another script that will remove column `A` and the temporary trigger.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行另一个脚本，该脚本将删除列 `A` 和临时触发器。
- en: Deploy your up-to-date code that uses column `B` and adds new features to your
    application.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署使用列 `B` 并添加新功能的最新代码。
- en: Dropping a table or column
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除表或列
- en: Dropping a table or column is a little bit easier. You just need to deploy a
    new application code that doesn't use the table or field that you want to remove.
    After waiting a little bit to ensure that the previous code has finished being
    executed, you can safely execute a script that will delete the table or remove
    the field.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 删除表或列稍微容易一些。你只需要部署一个新的应用程序代码，该代码不使用你想要删除的表或字段。在等待一段时间以确保之前的代码已执行完毕后，你可以安全地执行一个脚本，该脚本将删除表或移除字段。
- en: Rollback a deployment
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回滚部署
- en: 'Sometimes, we deploy a new version of an application that may introduce a buggy
    feature. Depending on the error severity, you may need to rollback the application
    before starting to fix the error for a new deployment. You have two options for
    this rollback:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们部署的应用程序的新版本可能会引入有缺陷的功能。根据错误的严重程度，在开始修复错误并进行新部署之前，你可能需要回滚应用程序。为此回滚你有两种选择：
- en: Version control all deployments in tags. When you need to rollback, select the
    code from the previous tag and run `serverless deploy` again.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标签对所有的部署进行版本控制。当你需要回滚时，选择之前标签中的代码，然后再次运行 `serverless deploy`。
- en: Use the `serverless rollback` command to change your functions to a previous
    version.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `serverless rollback` 命令将你的函数更改为之前的版本。
- en: 'AWS has a versioning system for our deployments, so using the `serverless rollback`
    command is safe and fast. This command should be used passing a `timestamp` parameter,
    like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: AWS为我们部署有一个版本控制系统，因此使用`serverless rollback`命令是安全且快速的。此命令应通过传递`timestamp`参数来使用，如下所示：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To find the timestamp information of our last deploy, we need to run the following
    command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到我们上次部署的时间戳信息，我们需要运行以下命令：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It will give you the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它将给出以下输出：
- en: '![](img/4d947e54-8d26-4d11-8dd3-42d6b1edabf9.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d947e54-8d26-4d11-8dd3-42d6b1edabf9.png)'
- en: In the previous screenshot, we would use the value `1499216616127` for the `timestamp`
    parameter. Note that we need to select the penultimate version and not the last
    one.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，我们会使用值`1499216616127`作为`timestamp`参数。请注意，我们需要选择倒数第二个版本，而不是最后一个版本。
- en: The command `serverless rollback` will rollback all functions for a previous
    deployment that was done with the command `serverless deploy`. If you used `serverless
    deploy function`, this change won't be versioned.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`serverless rollback`将回滚使用`serverless deploy`命令所做的先前部署的所有函数。如果您使用了`serverless
    deploy function`，则此更改不会进行版本控制。
- en: Creating staging environments
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建预发布环境
- en: 'Best practice says that we must have different environments for development
    and production. You can also add a third environment, usually named *staging*,
    for testing:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践表明，我们必须为开发和生产环境拥有不同的环境。您还可以添加第三个环境，通常命名为*预发布*，用于测试：
- en: '**Development**: This is where you deploy code as a work in progress, testing
    that it works together with other services'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发环境**：这是您部署作为工作进度的代码的地方，测试它是否与其他服务一起工作'
- en: '**Staging**: This is usually necessary to validate the build by customers or
    a quality assurance team'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预发布环境**：通常需要客户或质量保证团队验证构建'
- en: '**Production**: This is where your application is visible by end users'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产环境**：这是您的应用程序对最终用户可见的地方'
- en: All software that we develop is highly dependent on the environment, such as
    the operating system, runtime version, installed modules and dlls, external services,
    configuration files, and others. Therefore, it was a pretty common excuse, at
    least some years ago, for a developer to explain production errors saying that
    "it works on my machine". Mirroring the development environment with the production
    setting was a very difficult task. Sometimes, changes applied to one were not
    reflected to the other, causing strange errors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的全部软件都高度依赖于环境，例如操作系统、运行时版本、已安装的模块和dlls、外部服务、配置文件以及其他。因此，至少在几年前，开发者解释生产错误时说“在我的机器上它运行正常”是一个相当常见的借口。将开发环境与生产设置相匹配是一个非常困难的任务。有时，对其中一个所做的更改并没有反映到另一个上，导致出现奇怪的错误。
- en: With virtual machines, and more recently with Docker containers, this issue
    has greatly diminished, since we can now trust that we can perfectly reproduce
    production errors in our development machines and that what we build will work
    exactly as expected, regardless of the machine that executes it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟机，以及最近使用Docker容器，这个问题已经大大减少，因为我们现在可以相信我们可以在我们的开发机器上完美地重现生产错误，并且我们构建的内容将按预期工作，无论在哪个机器上执行它。
- en: 'With cloud providers, all of our infrastructure can be scripted. So, we can
    automate how an environment can be created through code. In this case, you just
    need to change a variable value and deploy it again to mirror your development
    code with the production code. In your `serverless.yml` file, there is an option
    under `provider` that allows you to name your current environment and easily mirror
    it to others simply by choosing a new name for the `stage` property:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云提供商，我们所有的基础设施都可以通过脚本进行。因此，我们可以通过代码来自动化创建环境的方式。在这种情况下，您只需更改一个变量的值，然后再次部署，就可以将您的开发代码与生产代码进行镜像。在您的`serverless.yml`文件中，`provider`下有一个选项允许您命名当前环境，并且只需通过为`stage`属性选择一个新名称，就可以轻松地将它镜像到其他环境：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Being careful with the production environment
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小心使用生产环境
- en: Being able to easily mirror the development environment to production is a very
    powerful feature that needs to be used wisely. In my earlier days as a developer,
    I had the unfortunate habit of having the staging and production virtual machines
    open simultaneously. Which, of course, I stopped doing the day I messed with a
    production service thinking that I was changing the staging version.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 能够轻松地将开发环境镜像到生产环境是一个非常强大的功能，需要明智地使用。在我作为开发者的早期，我有同时打开预发布和生产虚拟机的坏习惯。当然，当我误操作生产服务，以为我在更改预发布版本时，我就停止这样做。
- en: What I recommend is to use the staging option to mirror the *development* environment
    with the *testing* environment. You can easily deploy a new version for your customer
    or for your quality assurance team, but you should *never* use your development
    machine to apply updates in production to avoid the associated risks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用预发布选项来将*开发*环境与*测试*环境进行镜像。您可以轻松地为您的客户或质量保证团队部署新版本，但您应该*永远*不要使用您的开发机器在生产环境中应用更新，以避免相关的风险。
- en: Creating a new environment is as simple as choosing a new name for the `stage`.
    So, you can name it with things like `test-2017-08-02` or `test-feature-x` to
    create new endpoints with a specific test environment.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的环境就像为新`阶段`选择一个新名称一样简单。因此，您可以将其命名为`test-2017-08-02`或`test-feature-x`等，以创建具有特定测试环境的新端点。
- en: You can designate someone in the team who will be the only person responsible
    for deploying a new production version. Restricting the responsibility to just
    one person will reduce the chance of accidents. Another option is to have one
    machine with the sole purpose of production deployments. Needing an extra step,
    which is to connect with the machine, helps because it forces you to be focused
    on the task and you won't accidentally select the wrong environment.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在团队中指定一个人，他将是唯一负责部署新生产版本的人。将责任限制在一个人身上将减少事故发生的可能性。另一种选择是拥有一台专门用于生产部署的机器。需要额外一步，即连接到该机器，有助于您专注于任务，并且不会意外选择错误的环境。
- en: Furthermore, I also recommend that you have two different AWS accounts, one
    for development and testing, and another one exclusively for production. Although
    it is possible to configure the IAM roles to protect your environment and prevent
    the same user from modifying both environments, it is still risky. The IAM restrictions
    may be incorrectly configured, or you could add a new resource and forget to set
    the proper access, allowing undesired changes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还建议您拥有两个不同的AWS账户，一个用于开发和测试，另一个专门用于生产。虽然可以配置IAM角色来保护您的环境并防止同一用户修改两个环境，但这仍然是有风险的。IAM限制可能配置不正确，或者您可能添加了新的资源而忘记设置适当的访问权限，从而导致不希望的变化。
- en: Test data
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试数据
- en: When you have your entire infrastructure scripted, the only difference between
    the development and production environments is the associated data. The test environment
    usually has its own fabricated data, but sometimes we can't reproduce errors,
    for example, performance issues or inconsistencies, because the underlying data
    is different.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的整个基础设施都脚本化时，开发和生产环境之间的唯一区别是相关数据。测试环境通常有自己的模拟数据，但有时我们无法重现错误，例如性能问题或不一致性，因为底层数据不同。
- en: 'However, making a backup of the production data and directly restoring a copy
    into the testing environment can be a bad practice for the following reasons:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了以下原因，将生产数据备份并直接将其复制到测试环境中可能是一种不良做法：
- en: Production data contains real e-mails. Running test code may send accidental
    e-mails to real people.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产数据包含真实电子邮件。运行测试代码可能会意外地向真实的人发送电子邮件。
- en: Production data contains sensitive data such as real names, e-mails, phone numbers,
    and addresses. Sharing this data with all developers is unnecessary and risky.
    The developer machine is much more unsafe and susceptible to being hacked than
    the production environment.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产数据包含敏感数据，如真实姓名、电子邮件、电话号码和地址。与所有开发者共享这些数据是不必要的，也是危险的。开发机器比生产环境更不安全，更容易受到黑客攻击。
- en: In this case, I recommend using fabricated data for most of the tests, and when
    you need to make performance tests or analyze a specific issue, you use a production
    backup but you need to have a procedure in place to modify the content, removing
    sensitive data before sharing the data with all developers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我建议在大多数测试中使用模拟数据，当您需要进行性能测试或分析特定问题时，您可以使用生产备份，但您需要有一个程序来修改内容，在将数据与所有开发者共享之前删除敏感数据。
- en: Keeping your functions warm
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持您的函数活跃
- en: As we have discussed in past chapters, one of the problems with serverless functions
    is the cold starts. When your Lambda function is triggered, AWS will find its
    package, unzip, and install it in a container to be executed. These steps takes
    some time (usually 5 seconds) and they delay the execution of your function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的章节中讨论过的，无服务器函数的一个问题就是冷启动。当您的Lambda函数被触发时，AWS会找到其包，解压并安装到容器中以执行。这些步骤需要一些时间（通常5秒），并且会延迟您的函数执行。
- en: After executing a function, AWS will keep it in a suspended state for a while.
    If a new request is done a few minutes later, it won't suffer from the cold start
    delay because the package will be readily available. After 15 minutes of inactivity,
    it will *freeze* again.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 执行函数后，AWS 将将其保持一段时间挂起状态。如果几分钟后收到新的请求，它不会受到冷启动延迟的影响，因为包将随时可用。在 15 分钟的不活动后，它将再次“冻结”。
- en: If your application needs to ensure low response times, you can deploy them
    with a configuration to keep them *warm*. There is a plugin for the Serverless
    Framework called **WarmUP** ([https://github.com/FidelLimited/serverless-plugin-warmup](https://github.com/FidelLimited/serverless-plugin-warmup))
    that will create a scheduled Lambda function that will be responsible by invoking
    the other functions from time to time (default it to 5 minutes).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序需要确保低响应时间，您可以通过配置将其部署为“预热”状态。有一个名为 **WarmUP** 的 Serverless Framework
    插件（[https://github.com/FidelLimited/serverless-plugin-warmup](https://github.com/FidelLimited/serverless-plugin-warmup)），它将创建一个定时
    Lambda 函数，负责不时调用其他函数（默认为 5 分钟）。
- en: 'Let''s follow the following steps to see how to use it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来了解如何使用它：
- en: 'Create a new serverless project by executing the following command:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令创建一个新的无服务器项目：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Create a `package.json` file.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `package.json` 文件。
- en: 'Install the WarmUP plugin by executing the following command:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令安装 WarmUP 插件：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following reference to the end of the `serverless.yml` file:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `serverless.yml` 文件的末尾添加以下引用：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For each function that you want to keep warm, add the `warm: true` pair:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '对于您想要保持“预热”的每个函数，添加 `warm: true` 配对：'
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This plugin will invoke other functions, so we need to give it the necessary
    permission:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此插件将调用其他函数，因此我们需要给它必要的权限：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last step is to modify the Lambda function to ignore requests created by
    this plugin:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是修改 Lambda 函数以忽略由该插件创建的请求：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Monitoring the operation
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控操作
- en: The serverless concept is defined as running your code without worrying about
    the infrastructure that will be responsible for supporting it. This still holds
    true, but there are some DevOps tasks that may improve your application's efficiency
    and stability. Therefore, you should not confuse serverless with NoOps. You just
    don't need to worry *that* much about the infrastructure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器概念被定义为运行您的代码而不必担心支持它的基础设施。这仍然成立，但有一些 DevOps 任务可能会提高您应用程序的效率和稳定性。因此，您不应将无服务器与
    NoOps 混淆。您只需不必过多担心基础设施即可。
- en: 'Since we are using AWS, we are going to use its monitoring tool: Amazon CloudWatch.
    There are some other paid and free tools that can also be used for this task,
    so feel free to compare them before selecting your own tool.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 AWS，我们将使用其监控工具：Amazon CloudWatch。还有一些其他付费和免费工具也可以用于此任务，所以在选择自己的工具之前请随意比较。
- en: 'To use CloudWatch, open the Management Console at [https://console.aws.amazon.com/cloudwatch](https://console.aws.amazon.com/cloudwatch),
    and let''s see in the following subsections how we can monitor our Lambda functions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 CloudWatch，请打开管理控制台 [https://console.aws.amazon.com/cloudwatch](https://console.aws.amazon.com/cloudwatch)，以下小节将展示我们如何监控我们的
    Lambda 函数：
- en: '![](img/d0d1718b-80e4-409a-840d-da3bd62dc665.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0d1718b-80e4-409a-840d-da3bd62dc665.png)'
- en: Monitoring costs
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控成本
- en: Estimating costs in serverless is a difficult task, since it depends highly
    on usage. Also, deploying a new function may result in unexpected costs due to
    programming errors. For example, consider that you set a function with a timeout
    of 5 minutes and 1 GB of RAM. Maybe it is supposed to execute in a few milliseconds
    95% of the time, but due to an error, it may freeze every time and run indefinitely,
    just stopping after the timeout is reached.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器中估算成本是一项困难的任务，因为它高度依赖于使用情况。此外，由于编程错误，部署新函数可能会导致意外的成本。例如，假设您设置了一个具有 5 分钟超时和
    1 GB RAM 的函数。也许它应该 95% 的时间在几毫秒内执行，但由于错误，它可能每次都会冻结并无限期运行，直到超时后停止。
- en: Another scenario is when you use a Lambda function to call another Lambda function,
    but a programming error may create an endless loop causing your Lambda functions
    to execute constantly. In fact, AWS has some limits and measures to prevent these
    kind of errors, but that's something that we should pay attention to avoiding.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种场景是当您使用 Lambda 函数调用另一个 Lambda 函数时，但编程错误可能会创建一个无限循环，导致您的 Lambda 函数持续执行。实际上，AWS
    有一些限制和措施来防止这类错误，但这是我们应关注避免的事情。
- en: You can always open your AWS Billing dashboard to track your monthly expenses,
    but when these kind of issues occur, you want to be at least warned as soon as
    possible. In this case, you can set a billing alert to send an e-mail if the monthly
    cost reaches an unexpected level.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您始终可以打开您的 AWS 计费仪表板来跟踪您的月度支出，但当出现这类问题时，您至少希望尽快收到警告。在这种情况下，您可以设置计费警报，如果月度成本达到意外水平，则发送电子邮件。
- en: 'Let''s monitor the costs by performing the following steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来监控成本：
- en: 'Open your CloudWatch console and browse the Billing link in the left-hand side
    menu, followed by Create Alarm:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的 CloudWatch 控制台，浏览左侧菜单中的计费链接，然后点击创建警报：
- en: '![](img/04986da6-29f8-48dc-80d5-24dd225f4392.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04986da6-29f8-48dc-80d5-24dd225f4392.png)'
- en: 'On the next screen, select Billing Metrics:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，选择计费指标：
- en: '![](img/087d4c19-bcd6-49e3-94ac-840b177937d2.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/087d4c19-bcd6-49e3-94ac-840b177937d2.png)'
- en: 'CloudWatch allows you to create a billing alert for the entire account or to
    filter the alert by service. In this case, you can select the AWSLambda service
    and click on Next:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CloudWatch 允许您为整个账户创建计费警报，或者根据服务过滤警报。在这种情况下，您可以选择 AWSLambda 服务并点击下一步：
- en: '![](img/74d52908-9f99-4ad0-b034-a8abf94b97f2.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74d52908-9f99-4ad0-b034-a8abf94b97f2.png)'
- en: 'On the last screen, you can set a threshold for the alarm and define which
    persons it should notify if it goes beyond an acceptable value:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一屏，您可以设置警报的阈值并定义当它超过可接受值时应该通知哪些人员：
- en: '![](img/b500d879-faea-4a3e-b93c-deb69078cbb0.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b500d879-faea-4a3e-b93c-deb69078cbb0.png)'
- en: Monitoring errors
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控错误
- en: 'Going back to the CloudWatch console home screen, click on the Browse Metrics
    button located at the center. It will redirect you to another page where you can
    select all the metrics available to your Lambda functions. You can choose to monitor
    by function name, resource, or across all functions. The available metrics are
    as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 CloudWatch 控制台主屏幕，点击位于中心的浏览指标按钮。它将带您到另一个页面，您可以在其中选择所有可用的 Lambda 函数指标。您可以选择按函数名称、资源或跨所有函数进行监控。可用的指标如下：
- en: '**Errors**: This is the metric of the number of times that the Lambda function
    stopped prematurely due to an error, or it has stopped after reaching the timeout
    limit. This is an important metric because, ideally, you expect to see zero errors
    in production and will want to be warned when an error is detected.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：这是 Lambda 函数因错误而提前停止或达到超时限制后停止的次数指标。这是一个重要的指标，因为理想情况下，您希望在生产环境中看到零错误，并且当检测到错误时，您希望收到警告。'
- en: '**Invocations**: This is the metric of the number of times that your Lambda
    function was invoked. If this function is executed by a schedule, you may want
    to be notified if it executes more times than expected. Also, using this metric,
    you may track when executions go out of control if the function is executed more
    times than a reasonable value.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用次数**：这是您的 Lambda 函数被调用的次数指标。如果这个函数是由计划执行的，那么当它执行次数超过预期时，您可能希望收到通知。此外，使用这个指标，您可以跟踪当函数执行次数超过合理值时，执行是否失控。'
- en: '**Duration**: With this metric, you can track if your function is taking longer
    than expected to execute.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续时间**：使用这个指标，您可以跟踪您的函数是否执行时间超过了预期。'
- en: '**Throttles**: This metric is counted every time the function is not executed
    because the limit of concurrent Lambda functions is reached. This value can be
    increased if you open a support ticket to AWS, but the default value is 1,000
    and it can be very low for some use cases.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**：这个指标在每次函数因为达到并发 Lambda 函数限制而没有执行时都会计数。如果您向 AWS 提交支持工单，这个值可以增加，但默认值是
    1,000，对于某些用例来说可能非常低。'
- en: As you can see, these metrics are automatically monitored and you can build
    some graphs with historical data. If you want to set alarms, go back to the Console
    Home page and click on Alarms in the left-hand side menu, followed by Create Alarms,
    and configure the recipients as you wish.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些指标是自动监控的，并且您可以使用历史数据构建一些图表。如果您想设置警报，请返回到控制台主页，点击左侧菜单中的警报，然后点击创建警报，并按您的意愿配置收件人。
- en: Retrieving metrics with the Serverless Framework
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Serverless Framework 检索指标
- en: You can use the Serverless Framework to retrieve CloudWatch metrics. It can
    be a useful feature to take a quick look at the application's operation without
    browsing the CloudWatch console.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Serverless Framework 来检索 CloudWatch 指标。这可以是一个查看应用程序操作的好功能，而不必浏览 CloudWatch
    控制台。
- en: 'The following screenshot shows the output of the `serverless metrics` command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`serverless metrics`命令的输出：
- en: '![](img/f8d5f14a-037d-4baa-aec9-69adc9cb745d.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8d5f14a-037d-4baa-aec9-69adc9cb745d.png)'
- en: This command can be used to see the combined operation of all functions (`serverless
    metrics`) or the stats of just one function (`serverless metrics --function <your-function>`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令可用于查看所有功能（`serverless metrics`）的合并操作或单个功能的统计信息（`serverless metrics --function
    <your-function>`）。
- en: 'Also, you can filter by a date range using the arguments `--startTime` and
    `--endTime`. The following command will include only stats related to events that
    happened in the last 30 minutes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用`--startTime`和`--endTime`参数按日期范围进行过滤。以下命令将仅包括与过去30分钟内发生的事件相关的统计信息：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Streaming Lambda logs
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式传输Lambda日志
- en: 'When an error occurs in a Lambda execution, the error message is usually insufficient.
    For example, consider the following error message:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当Lambda执行中出现错误时，错误消息通常是不够的。例如，考虑以下错误消息：
- en: '![](img/b78b9183-cac1-472a-8997-04f807e15abf.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b78b9183-cac1-472a-8997-04f807e15abf.png)'
- en: 'You can retrieve more details about the error message by streaming logs to
    the terminal. You can hook to a specific function and receive the history of error
    messages and live errors. For this, run the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将日志流式传输到终端来检索有关错误消息的更多详细信息。您可以连接到特定功能并接收错误消息的历史记录和实时错误。为此，请运行以下命令：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `--tail` argument indicates that you want to listen to new error messages.
    You can also use `--filter word` to show only messages that match the filter or
    `--startTime` to specify the range of logs that you want to see. For example,
    `--startTime 2h` shows logs from the last two hours.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`--tail`参数表示您想监听新的错误消息。您还可以使用`--filter word`来显示仅匹配过滤器的消息或使用`--startTime`来指定您想查看的日志范围。例如，`--startTime
    2h`将显示过去两小时的日志。'
- en: 'The log messages show the stack trace of the errors, which is much more useful
    to understand the root cause of an issue:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息显示了错误的堆栈跟踪，这对于理解问题的根本原因非常有用：
- en: '![](img/cf8b7e30-4d5f-46fa-bfef-c425b09b59cc.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf8b7e30-4d5f-46fa-bfef-c425b09b59cc.png)'
- en: Handling errors
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: When a function executes with errors, Lambda offers two handlers such as SNS
    and SQS. You can use them to handle events that have failed, so you may try them
    again later or retrieve additional information to understand what caused the issue.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个功能执行出错时，Lambda提供了两个处理程序，如SNS和SQS。您可以使用它们来处理失败的事件，因此您可以稍后重试或检索更多信息以了解导致问题的原因。
- en: 'SNS is used to notify on errors and SQS is used to create a queue of failed
    Lambda tasks that can be processed by another service:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: SNS用于在错误发生时发出通知，SQS用于创建一个队列，其中包含失败的Lambda任务，这些任务可以由另一个服务处理：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You should set the ARN of the SNS topic as SQS queue.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您应将SNS主题的ARN设置为SQS队列。
- en: SQS is currently not supported due to a bug in the Serverless Framework v.1.18,
    but this error is already a known issue and should be fixed soon.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Serverless Framework v.1.18中的一个错误，目前不支持SQS，但这个错误已经是一个已知问题，应该很快得到修复。
- en: Monitoring performance
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控性能
- en: As we already discussed, you can find how long it takes for a function to execute
    through the duration metric in the CloudWatch option or by running the `serverless
    logs` command of the framework. Ideally, there is no difference if the code is
    executed during work hours, at midnight, or on weekends. AWS strives to always
    provide a constant experience at any time of the day.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，您可以通过CloudWatch选项中的持续时间指标或运行框架的`serverless logs`命令来找到函数执行所需的时间。理想情况下，无论代码是在工作时间、午夜还是周末执行，都没有差异。AWS致力于在任何时间都提供一致的经验。
- en: In practice, this is not always true. There is no known pattern for this behavior,
    but you can expect large differences in the execution time. Without considering
    cold start delays, your function can take 50 milliseconds to execute, and 1 minute
    later, it can take 400 milliseconds to execute the same code with the same input.
    It is much more difficult to provide a constant experience in serverless sites
    than when using a traditional infrastructure. This is because your infrastructure
    is always shared between other customers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这并不总是正确的。没有已知的行为模式，但您可能期望执行时间存在很大差异。不考虑冷启动延迟，您的函数可能需要50毫秒来执行，而1分钟后，它可能需要400毫秒来执行相同的代码和相同的输入。在无服务器站点中提供一致的经验比使用传统基础设施要困难得多。这是因为您的基础设施始终与其他客户共享。
- en: Though you can see discrepancies, it is a good practice to monitor the duration.
    Instead of setting an alarm considering the *maximum* duration, you can set the
    *average* or *percentile*, where a percentile is a statistic unit, which means
    the percentage of observations that fall in a category. For example, a p90 of
    100 milliseconds means that you expect that 90% of the requests will take less
    than 100 milliseconds to execute and you should receive an alarm message if this
    is not true for a given period of time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以看到差异，但监控持续时间是一个好习惯。与其根据*最大*持续时间设置警报，不如设置*平均*或*百分位数*，其中百分位数是一个统计单位，表示落在某个类别中的观测值的百分比。例如，p90为100毫秒意味着你预计90%的请求将在100毫秒内执行，如果在一个给定的时间段内这不是事实，你应该收到一个警报信息。
- en: Setting alarms is especially important when our Lambda function relies on external
    services. If the function reads data from a database table, it may take 200 milliseconds
    if the table has 10 records and 1 minute if it has 1,000,000 records. In this
    case, an alarm may be useful to alert you that it's time to clean some old data
    or improve the query.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的Lambda函数依赖于外部服务时，设置警报尤为重要。如果函数从数据库表中读取数据，当表中有10条记录时可能需要200毫秒，而当表中有1,000,000条记录时可能需要1分钟。在这种情况下，警报可能很有用，可以提醒你该清理一些旧数据或改进查询了。
- en: Monitoring efficiency
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控效率
- en: Monitoring the efficiency means that you want to certify that you are using
    your resources in the best way possible. When you create a new Lambda function,
    there are two important options to configure such as the timeout value and the
    RAM memory to allocate.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 监控效率意味着你希望确保以最佳方式使用你的资源。当你创建一个新的Lambda函数时，有两个重要的配置选项，如超时值和分配的RAM内存。
- en: Having a long timeout value will not impact the efficiency, but setting the
    wrong RAM memory will really affect the function performance and costs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个长的超时值不会影响效率，但设置错误的RAM内存确实会影响功能性能和成本。
- en: 'For example, consider the logs of the function executed in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下截图中的函数日志：
- en: '![](img/86c851be-c6af-4a61-9fac-b45127998a62.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86c851be-c6af-4a61-9fac-b45127998a62.png)'
- en: It has an allocated memory size of 1,024 MB (default) while `Max Memory Used`
    was only `19 MB`. In this case, it clearly shows that you can reduce the allocated
    memory to minimize costs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它分配的内存大小为1,024 MB（默认），而`Max Memory Used`仅为`19 MB`。在这种情况下，很明显你可以减少分配的内存以最小化成本。
- en: I recommend that you always test your code with different memory sizes and track
    the duration time. Running with less memory than needed results in much higher
    times to process. If your Lambda function is used to answer user requests, you
    may think of paying for a little more memory to process the requests faster while,
    if it is a background task, you may use the minimum necessary to save money.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你始终用不同的内存大小测试你的代码，并跟踪持续时间。使用比所需更少的内存运行会导致处理时间大大增加。如果你的Lambda函数用于响应用户请求，你可能想多支付一点内存以更快地处理请求，而如果是后台任务，你可能可以使用最少的必要内存以节省金钱。
- en: Also, when benchmarking your own code to see how fast it is for different memory
    sizes, pay attention to which scenario it is running. If your project architecture
    is a Monolith, it may be very fast to retrieve some user data using just a few
    megabytes of memory, but it may have trouble processing the sales report of a
    given period.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当对您的代码进行基准测试以查看不同内存大小下的运行速度时，请注意它正在运行的场景。如果您的项目架构是单体（Monolith），使用仅几兆内存检索一些用户数据可能非常快，但它可能难以处理特定时间段的销售报告。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how you can test serverless code in the frontend
    and backend. Also, we have discussed some key concepts that you must consider
    in your deployment workflow, and showed how you can monitor serverless applications
    using Amazon CloudWatch.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在前端和后端测试无服务器代码。我们还讨论了一些你在部署工作流程中必须考虑的关键概念，并展示了如何使用Amazon CloudWatch监控无服务器应用程序。
- en: Now the book has finished. I hope that you have enjoyed reading through the
    chapters and have learned enough to build your next awesome application using
    serverless. You can use the serverless store demo as a reference for your future
    projects, but don't feel limited to it. Use your own preferred tools to test,
    to develop the frontend, and to access the database. My objective with this book
    is not to define a strict pattern of how you should build a serverless application,
    but to give you an example to prove that the concept is valid and may be a good
    one for many applications.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在本书已经完成。我希望您在阅读章节的过程中感到愉快，并且学到了足够多的知识来构建您下一个令人惊叹的无服务器应用程序。您可以将无服务器商店演示作为您未来项目的参考，但不要局限于它。使用您自己的首选工具进行测试、开发前端和访问数据库。我的目标不是定义一个严格的模式来指导您如何构建无服务器应用程序，而是提供一个例子来证明这个概念是有效的，并且可能适用于许多应用程序。
- en: Finally, I encourage you to try other cloud providers. This book focuses on
    AWS due to my own positive experiences, but there are other excellent services
    out there. When evaluating a provider, don't just pay attention to the price tag.
    Look at the tools that are offered that will make it easier for you to build your
    application. Mixing services from different providers is also viable. Good luck!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我鼓励您尝试其他云服务提供商。本书之所以专注于AWS，是因为我有积极的个人经验，但还有其他优秀的服务。在评估提供商时，不要只关注价格标签。看看提供的工具，这些工具将使您构建应用程序变得更加容易。混合来自不同提供商的服务也是可行的。祝您好运！
