- en: Chapter 4. Making It More Fun!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：让它更有趣！
- en: In the previous chapter, we created a chat room. In this chapter, we are going
    to improve on that chat room by giving our users a name, having multiple chat
    rooms, and integrating the express and socket.io sessions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个聊天室。在本章中，我们将通过给我们的用户提供名字、拥有多个聊天室以及集成express和socket.io会话来改进这个聊天室。
- en: Giving names to users
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为用户命名
- en: Without a name for our users, chatting becomes difficult. It is impossible to
    identify who sent the message. So let us provide our users with a method by which
    they can set a nickname for themselves, so that a message from them can be identified
    with their name.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的用户没有名字，聊天就会变得困难。无法识别谁发送了消息。所以让我们提供一个方法，让我们的用户可以为自己设置昵称，这样他们的消息就可以通过他们的名字来识别。
- en: We have already worked with the `message` event in socket.io to send and receive
    messages. We also saw the socket.io module's predefined events. In this section,
    we will learn more about those events and also see how we can work with our own
    events. We will also see how we can save some information for the session.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用socket.io的`message`事件来发送和接收消息。我们还看到了socket.io模块的预定义事件。在本节中，我们将了解更多关于这些事件的信息，并了解我们如何处理我们自己的事件。我们还将了解如何为会话保存一些信息。
- en: 'Let us start by creating the user interface required for accepting a name from
    the user when they come to our chat room. To do this, we will modify the `index.jade`
    file by adding the following code to it:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个用户界面，当用户来到我们的聊天室时，可以接受他们的名字。为此，我们将通过向其中添加以下代码来修改`index.jade`文件：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What we are doing here is adding a new section for the `modal` overlay. This
    section has a backdrop `div` tag and then a `div` tag for the actual form. The
    look and feel of this will again be defined in the `style.css` file, so let''s
    update that too. Refer to the following code block while modifying the stylesheet:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是在`modal`覆盖层中添加一个新的部分。这个部分有一个背景`div`标签，然后是一个实际的表单`div`标签。这个外观和感觉将在`style.css`文件中定义，所以让我们也更新一下。在修改样式表时，请参考以下代码块：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now when we refresh the UI, it will look like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们刷新UI，它将看起来像这样：
- en: '![Giving names to users](img/0786_04_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![为用户命名](img/0786_04_02.jpg)'
- en: The username form
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名表单
- en: 'Next, what we will want to do is when the user enters a name and clicks on
    the **Set Name** button, send the name to the server, store it there, and prefix
    it to every message sent by that user. First, we will change the document ready
    handler to attach an event handler to the **Set Name** button. For this, edit
    `public/javascripts/chat.js`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要做的是，当用户输入一个名字并点击**设置名字**按钮时，将名字发送到服务器，将其存储在那里，并在该用户发送的每条消息前加上名字前缀。首先，我们将更改文档就绪处理程序，为**设置名字**按钮附加一个事件处理器。为此，编辑`public/javascripts/chat.js`：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the previous code, we see a new socket.io API and concept, namely `socket.emit`.
    This is used to trigger custom events. The call for `emit` is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们看到了一个新的socket.io API和概念，即`socket.emit`。这是用来触发自定义事件的。对`emit`的调用如下：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We trigger a `set_name` event and pass on the value entered in the username
    box by the user. We also remove the send message event handler from the `socket.emit`
    declaration. We will come back to this later.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们触发一个`set_name`事件，并将用户在用户名框中输入的值传递过去。我们还从`socket.emit`声明中移除了发送消息的事件处理器。我们稍后会回到这个话题。
- en: 'The events emitted on a socket on one side (server) will be handled on the
    other side of the socket (client). In our case, that is, in the previous code
    snippet, we trigger the `set_name` event on the client, so we will handle it on
    the server. To do this, we will edit `routes/sockets.js` as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个socket上发出的事件（服务器端）将在socket的另一侧（客户端）被处理。在我们的案例中，即在之前的代码片段中，我们在客户端触发`set_name`事件，所以我们将它在服务器端处理。为此，我们将编辑`routes/sockets.js`如下：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the practice of keeping it simple, socket.io uses the same `socket.on` API,
    which we used earlier to handle the `connection` or `message` events, to handle
    custom events. The data passed to the handler function will contain the data we
    had sent when we triggered the event.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持简单易用的实践中，socket.io使用了相同的`socket.on` API，这是我们之前用来处理`connection`或`message`事件的，来处理自定义事件。传递给处理函数的数据将包含我们在触发事件时发送的数据。
- en: 'This brings us to a new feature of socket.io, that is, attaching additional
    information to the socket for the session. This is achieved using the `socket.set`
    function. The call for this function is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到了socket.io的一个新特性，即向会话中的socket附加额外的信息。这是通过使用`socket.set`函数实现的。对该函数的调用如下：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding line of code, `<name>` is the name of the key we want to set
    and `<value>` is the value we want to set. The call to `set` is asynchronous;
    it won't be blocked till the value has been set. To perform an action where you
    want to ensure that the value has been set, we can pass a callback to the `set`
    method. In the previous code, we are passing the `callback` function that will
    emit another `name_set` custom event, and will also send the welcome message.
    Like the `set_name` event, the `name_set` event will be handled on the other side
    of the socket, which in this case is the client.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，`<name>` 是我们想要设置的键的名称，而 `<value>` 是我们想要设置的值。对 `set` 的调用是异步的；它不会在值被设置之前阻塞。为了执行一个需要确保值已经被设置的动作，我们可以向
    `set` 方法传递一个回调函数。在之前的代码中，我们传递了一个 `callback` 函数，该函数将触发另一个 `name_set` 自定义事件，并且还会发送欢迎信息。就像
    `set_name` 事件一样，`name_set` 事件将在套接字的另一端被处理，在这种情况下是客户端。
- en: This is great. Now that the name is set, let us put it to some real use by showing
    it with every message so that people in our chat room know who sent the message.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了。现在名字已经设置，让我们通过在每条消息中显示它来真正地使用它，这样我们聊天室中的人就知道是谁发送了消息。
- en: To get a value set on the socket, socket.io provides a `get` method. We will
    use this `get` method to get the username from the socket and append it to the
    previous message.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要从套接字获取设置的值，socket.io 提供了一个 `get` 方法。我们将使用这个 `get` 方法从套接字获取用户名并将其附加到之前的消息上。
- en: 'Let us rework `public/javscripts/chat.js` to handle the `name_set` event and
    then start the actual communication:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新整理 `public/javscripts/chat.js` 以处理 `name_set` 事件，然后开始实际的通信：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous code snippet, we add two new lines of code to hide the overlay
    and to append the greeting to the `messages` area. Apart from this, we have also
    moved the code to handle the sending and receiving of messages to this handler,
    so that it is set up only after the user has set the name and avoids people from
    just hiding the overlay using Firebug or other similar tools. There is one last
    change in the message received handler; we need to check for the presence of a
    username in the incoming data and prefix it to the displayed message if it is.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们添加了两行新代码来隐藏覆盖层并将问候语附加到 `messages` 区域。除此之外，我们还把处理发送和接收消息的代码移动到这个处理器中，这样它就只在用户设置了名字之后设置，避免了人们使用
    Firebug 或其他类似工具仅隐藏覆盖层。在消息接收处理器中还有一个最后的更改；我们需要检查传入数据中是否存在用户名，如果存在，则将其作为前缀附加到显示的消息中。
- en: 'To see the code in action, let''s restart our node server and refresh the browser.
    Once you enter the name, it will bring up the chat room and show the greeting
    with the name you just entered along with the welcome message:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到代码的实际效果，让我们重新启动我们的 node 服务器并刷新浏览器。一旦你输入名字，它就会弹出聊天室并显示你刚刚输入的名字以及欢迎信息：
- en: '![Giving names to users](img/0786_04_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![给用户命名](img/0786_04_03.jpg)'
- en: Greeting with name
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用名字打招呼
- en: 'Open our chat room in another browser window and sign in as **Friend** this
    time. Enter a message in the new message box and click **Send**. The message appears
    in the message area in both the browsers. Try it from the first chat room you
    have opened:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个浏览器窗口中打开我们的聊天室，这次以 **Friend** 的身份登录。在新消息框中输入一条消息并点击 **发送**。消息会出现在两个浏览器中的消息区域。从你打开的第一个聊天室尝试：
- en: '![Giving names to users](img/0786_04_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![给用户命名](img/0786_04_04.jpg)'
- en: Chat with names
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 命名聊天
- en: More on events
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于事件
- en: In the previous section, we saw how we can use custom events over a socket.
    The interesting thing is that just like your messages, events can also be broadcast.
    Let us see how we can use an event broadcast to announce the entry of a participant
    in our chat room.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何通过套接字使用自定义事件。有趣的是，就像你的消息一样，事件也可以被广播。让我们看看我们如何使用事件广播来宣布聊天室中参与者的加入。
- en: For this, the first thing we will do is start emitting a new `user_entered`
    event from the server, with the name of the user in the data once the user has
    joined the chat. Let us change our `routes/socket.js` file to do this. We will
    add our code to broadcast the `user_entered` event once the username is set.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，我们首先要做的事情是从服务器开始触发一个新的 `user_entered` 事件，一旦用户加入聊天，数据中就包含用户的名字。让我们将我们的 `routes/socket.js`
    文件更改一下以实现这一点。我们将在用户名设置后添加代码来广播 `user_entered` 事件。
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To send a broadcast to all the clients connected on this socket, we use the
    `emit` method, but on `socket.broadcast` rather than on `socket` itself. The signature
    of the method is the same.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要向连接到这个套接字的所有客户端发送广播，我们使用 `emit` 方法，但是在 `socket.broadcast` 而不是在 `socket` 本身上。该方法的签名是相同的。
- en: Now, the `user_entered` event will be sent to all the connected clients, so
    we will need to add an event handler in the client `chat.js` file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`user_entered`事件将被发送给所有已连接的客户端，因此我们需要在客户端的`chat.js`文件中添加一个事件处理器。
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we are adding an event handler for the `user_entered` event and then
    displaying the message to the user. Let us start our server once again and log
    in to our chat room:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为`user_entered`事件添加了一个事件处理器，并向用户显示消息。让我们再次启动我们的服务器并登录到我们的聊天室：
- en: '![More on events](img/0786_04_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![更多关于事件的信息](img/0786_04_05.jpg)'
- en: The first user's chat room
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用户的聊天室
- en: 'Now open another browser window and log in with a different name:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开另一个浏览器窗口，并使用不同的名字登录：
- en: '![More on events](img/0786_04_06.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![更多关于事件的信息](img/0786_04_06.jpg)'
- en: The second user's chat room
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个用户的聊天室
- en: As you will notice, in the first user's window, we will see the entrance message
    for both **Friend001** and **Friend002**, and for **Friend002** in the second
    user's (**Friend001**) window.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如您将注意到的，在第一个用户的窗口中，我们将看到**Friend001**和**Friend002**的进入消息，以及在第二个用户（**Friend001**）的窗口中的**Friend002**。
- en: Working with namespaces
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与命名空间一起工作
- en: In this section, we won't be adding any new functionality to our chat room,
    but instead we will just use a feature of socket.io to make our application design
    better and our code easier to maintain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会向我们的聊天室添加任何新的功能，而是仅仅使用socket.io的一个特性来使我们的应用程序设计更好，代码更容易维护。
- en: We are sending different messages between the client and the server and differentiating
    them by `type`. Wouldn't it be better that we send different messages on different
    messaging channels? Our current approach also doesn't play well and may cause
    conflicts when our application or module is part of a larger system. But then
    there are questions, what will be the cost of opening multiple connections? What
    will be the effect on performance?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在客户端和服务器之间发送不同的消息，并通过`type`来区分它们。如果我们能在不同的消息通道上发送不同的消息会更好吗？我们当前的方法也并不完美，可能会在应用程序或模块是更大系统的一部分时引起冲突。但是，也存在一些问题，打开多个连接的成本是什么？这将对性能产生什么影响？
- en: This is where namespaces come to the rescue. A namespace provides a way to multiply
    a socket.io connection, so that we get different channels for different types
    of messages without adding a big overhead to the system and its performance. Let
    us see how we can use namespaces in our chat system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是命名空间发挥作用的地方。命名空间提供了一种方式来扩展socket.io连接，这样我们就可以为不同类型的消息获得不同的通道，而不会给系统及其性能带来很大的开销。让我们看看我们如何在我们的聊天系统中使用命名空间。
- en: In our chat application, we have two different types of messages or events being
    sent. These are infrastructural, such as setting the name and welcome messages,
    and communication between the users.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的聊天应用程序中，我们发送了两种不同类型的消息或事件。这些是基础设施性的，例如设置名字和欢迎消息，以及用户之间的通信。
- en: 'So let us go ahead and create two namespaces, namely `chat_com` and `chat_infra`.
    We will send the communication messages (user messages) on `chat_com` and the
    infrastructural messages (welcome, user entry, and so on) on `chat_infra`. For
    this, let us first edit the `socket.js` file, which is on the server:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续创建两个命名空间，即`chat_com`和`chat_infra`。我们将在`chat_com`上发送通信消息（用户消息），在`chat_infra`上发送基础设施消息（欢迎、用户进入等）。为此，让我们首先编辑服务器上的`socket.js`文件：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see from the preceding code, most of the code remains the same, apart
    from the highlighted snippets and some code reorganization.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看出，大部分代码保持不变，除了突出显示的片段和一些代码重组。
- en: What we are doing here is separating the messages and events into two code blocks
    corresponding to their namespaces. We use the `io.of` method to create a new namespace.
    Upon creation of the namespace, it can be used as any socket's object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的，是将消息和事件分离成两个与它们的命名空间相对应的代码块。我们使用`io.of`方法创建一个新的命名空间。在命名空间创建后，它可以像任何socket对象一样使用。
- en: 'In our case, we are creating two namespaces and adding a `connection` event
    handler to both of them. One for `chat_infra`, as shown in the following code
    snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们创建了两个命名空间，并为它们各自添加了一个`connection`事件处理器。一个用于`chat_infra`，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And another for `chat_com`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以及另一个用于`chat_com`：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the connection is established, we will get a `socket` object in the `connection`
    event handler, which we will use just as we did earlier. In case of `chat_infra`,
    we add all the messaging and events that are not part of the user-to-user communication:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，我们将在`connection`事件处理程序中获得一个`socket`对象，我们将像之前一样使用它。对于`chat_infra`，我们添加所有不属于用户间通信的消息和事件：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, we are moving the `set_name` handler, the event emitter for `name_set`,
    messaging for `serverMessage`, and the event broadcaster for `user_entered` to
    the `chat_infra` namespace.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将`set_name`处理程序、`name_set`的事件发射器、`serverMessage`的消息以及`user_entered`的事件广播器移动到`chat_infra`命名空间。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This leaves only the standard `User` messaging components on the `chat_com`
    namespace.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就只留下了`chat_com`命名空间上的标准`User`消息组件。
- en: 'Let us now see how this affects our client code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看这如何影响我们的客户端代码：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first and the most important thing we see in the previous code is that
    we are connecting two sockets:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到的第一件和最重要的事情是我们正在连接两个套接字：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In fact, socket.io will establish a single socket connection and multiplex the
    two namespaces over it. But establishing these two connections will give us the
    ability to handle the `chat_infra` and `chat_com` namespaces' messages or events
    separately.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，socket.io将建立一个单一的套接字连接，并在其上多路复用两个命名空间。但建立这两个连接将使我们能够分别处理`chat_infra`和`chat_com`命名空间的消息或事件。
- en: 'In the following code snippet, we are adding the handlers that correspond to
    the emitters for `chat_infra` that we added on the server. The `name_set` handler
    will be on the `chat_infra` namespace:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们添加了对应于我们在服务器上添加的`chat_infra`发射器的处理程序。`name_set`处理程序将位于`chat_infra`命名空间：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will also do the same for the `user_entered` handler:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将对`user_entered`处理程序做同样的事情：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we add the `on` handler to listen for the messages on `chat_infra`; this
    will receive all the server messages:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`on`处理程序以监听`chat_infra`上的消息；这将接收所有服务器消息：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also emit the `set_name` event on `chat_infra`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`chat_infra`上发射`set_name`事件：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On the `chat_com` namespace, we send the user message, as shown in the following
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat_com`命名空间上，我们发送用户消息，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, we will attach the handler to receive the user messages relayed from
    the server by using the following code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用以下代码片段将处理程序附加到接收从服务器中继的用户消息：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we understand namespaces and have made use of them to clean up our
    design and code, let us go ahead and add some new features.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了命名空间并利用它们来清理我们的设计和代码，让我们继续添加一些新功能。
- en: Rooms
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 房间
- en: 'In this section we will use another multiplexing feature of socket.io, called
    **rooms**. And we will use it to do just what the name says, create rooms. A chat
    room will be very noisy and confusing if everyone in the network is chatting in
    the same room. So as the first step, let''s move our chat away from the landing
    page of our website to `/chatroom`. For this, we should move our code from `index.jade`
    to `chatroom.jade` and put the following code in `index.jade`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用socket.io的另一个多路复用功能，称为**房间**。我们将使用它来完成名字所描述的事情，创建房间。如果网络中的每个人都同一个聊天室聊天，聊天室将会非常嘈杂和混乱。因此，作为第一步，让我们将我们的聊天从网站首页移动到`/chatroom`。为此，我们应该将我们的代码从`index.jade`移动到`chatroom.jade`，并在`index.jade`中放入以下代码：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Basically, we will create a landing page with a welcome message and a link
    to go to the chat room. Let''s also add the following styles for the landing page
    in `style.css`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将创建一个带有欢迎信息和进入聊天室链接的首页。让我们也在`style.css`中添加以下样式：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now our landing page will look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的首页将如下所示：
- en: '![Rooms](img/0786_04_07.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![房间](img/0786_04_07.jpg)'
- en: The landing page
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首页
- en: 'The **Start now** link will send you to the chat room, but there is nothing
    there yet. So let us modify our `routes/index.js` file to serve `chatroom`. Add
    the following snippet to the end of the file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**立即开始**链接将带您进入聊天室，但目前那里还没有任何内容。因此，让我们修改我们的`routes/index.js`文件以提供`chatroom`服务。将以下片段添加到文件末尾：'
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will also have to add the mapping to `app.js`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在`app.js`中添加映射：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have a landing page, we are ready to add multiple rooms. We will
    now add support for the chat room page so that it can accept a `room` parameter
    and will connect to that room when requested. So the call to connect to enter
    the chat room will look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了首页，我们准备添加多个房间。我们现在将添加对聊天室页面的支持，使其能够接受一个`room`参数，并在请求时连接到该房间。因此，连接到聊天室以进入的调用将如下所示：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For this we need to edit our `chat.js` client script file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要编辑我们的`chat.js`客户端脚本文件：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first thing is to parse the URL query to get the room name, here is how
    this is done:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是解析URL查询以获取房间名称，以下是这样做的方式：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, in the preceding code, we are creating a regex to parse out the value
    between `room=` and `&` or to the end of the content. In the next line, we check
    if a room name was provided and once the user has entered the name, we will join
    the room.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个正则表达式来解析出`room=`和`&`之间或内容末尾之间的值。在下一行中，我们检查是否提供了房间名称，一旦用户输入了名称，我们就会加入房间。
- en: 'To join the room, we emit the `join_room` event with `roomName` as a parameter.
    This event will be handled on the server:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入房间，我们通过`roomName`作为参数发出`join_room`事件。此事件将在服务器上被处理：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since we will use the room only to restrict the broadcast messages (others are
    anyhow sent only to the recipient's socket), this is all we need to do on the
    client.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只使用房间来限制广播消息（其他消息无论如何只发送到接收者的套接字），所以这就是我们在客户端需要做的所有事情。
- en: 'Now we will edit the `sockets.js` file on our server to handle the `join_room`
    event on `chat_infra` and to change the broadcasts to send messages in the room
    they are meant for. Let us take a look at the changes in `sockets.js`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑服务器上的`sockets.js`文件，以处理`chat_infra`上的`join_room`事件，并将广播更改以发送到它们打算发送的房间。让我们看看`sockets.js`中的更改：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So this brings in some minor structural changes. Since we will need to refer
    `chatCom` in `chatInfra`, we add them both to the current object, which is also
    stored as itself, so that they are accessible in the closures. In the `chat_infra`
    connection handler, we register a new event handler for `join_room`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这带来了一些小的结构变化。由于我们需要在`chatInfra`中引用`chatCom`，我们将它们两个都添加到当前对象中，该对象也存储为自身，以便在闭包中可以访问。在`chat_infra`连接处理器中，我们为`join_room`注册了一个新的事件处理器：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the handler, we are receiving the `room` object, which will in turn have
    the name of the room to join. Next we connect the `chat_infra` socket to the room.
    This is done using the `join` method of the `socket` object:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理器中，我们接收到的`room`对象将包含要加入的房间名称。接下来，我们将`chat_infra`套接字连接到该房间。这是通过使用`socket`对象的`join`方法来完成的：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `join` method takes a name string for the room. The room will be created
    if not present, else the socket will be connected to an existing room.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`方法接受一个表示房间的名称字符串。如果不存在，房间将被创建，否则套接字将连接到现有房间。'
- en: 'Now, once our client joins the room, it will get all the messages intended
    for the specific room in the `chat_infra` namespace. But, this will not be useful
    until we also join the room in the `chat_com` namespace. For this, we will need
    to obtain the `socket` object, corresponding to the current `socket` object in
    the `chat_com` namespace and then call the same `join` method on it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们的客户端加入房间，它将获取`chat_infra`命名空间中针对特定房间的所有消息。但是，这在我们也在`chat_com`命名空间中加入房间之前是没有用的。为此，我们需要获取与`chat_com`命名空间中当前`socket`对象相对应的`socket`对象，然后在其上调用相同的`join`方法：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To get the corresponding `socket` object on `chat_com`, we fetch it using the
    current `socket` object''s ID (as it will be similar) from the `sockets` array
    in the `chatCom` namespace object. The next line simply calls the `join` method
    on it. Now both have joined the room in both the namespaces. But when we receive
    the messages in the `chat_com` namespace, we will need the name of the room this
    socket is connected to. For this, we will set the `room` property on the `comSocket`
    object to the room it is connected to:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`chat_com`上的相应`socket`对象，我们使用当前`socket`对象的ID（因为它将是相似的）从`chatCom`命名空间对象的`sockets`数组中检索它。下一行只是调用它的`join`方法。现在，在两个命名空间中，两者都已加入房间。但是，当我们从`chat_com`命名空间接收消息时，我们需要知道这个套接字连接到的房间名称。为此，我们将`room`属性设置在`comSocket`对象上，指向它连接到的房间：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that all is set up, we will announce in the room that the user has joined:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了，我们将在房间中宣布用户已加入：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we did earlier, we still use `broadcast.emit`, but instead of calling it
    on the socket, we restrict it to be sent only in the room, using `in(room.name)`.
    Another change we make will be that of broadcasting the user messages again by
    restricting them to the room:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们仍然使用`broadcast.emit`，但不是在套接字上调用它，而是限制它只发送到房间中，使用`in(room.name)`。我们做出的另一个改变将是通过限制广播消息只发送到房间来再次广播用户消息：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now you can open the chat room by going to the following URL:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过访问以下URL来打开聊天室：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Open this in two browser windows and log in with different names. Open another
    chat room in another browser window using the following URL:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个浏览器窗口中打开此链接并使用不同的名称登录。在另一个浏览器窗口中使用以下链接打开另一个聊天房间：
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The messages and alerts sent only in the room `test001` will be visible in
    the first two browsers, while the one connected to `test002` will not be able
    to see them:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 只在房间 `test001` 中发送的消息和警报将在前两个浏览器中可见，而连接到 `test002` 的用户将无法看到它们：
- en: '![Rooms](img/0786_04_08.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![房间](img/0786_04_08.jpg)'
- en: User one connected to the room test001
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用户一连接到房间 test001
- en: 'Here is the second user connected to the room `test001`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个用户连接到房间 `test001` 的截图：
- en: '![Rooms](img/0786_04_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![房间](img/0786_04_09.jpg)'
- en: User two connected to the room test001
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 用户二连接到房间 test001
- en: 'Here, in the following screenshot, the third user is shown connected to the
    room `test002`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，可以看到第三个用户已连接到房间 `test002`：
- en: '![Rooms](img/0786_04_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![房间](img/0786_04_10.jpg)'
- en: User three connected to the room test002
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 用户三连接到房间 test002
- en: Listing the rooms
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出房间
- en: 'Now that we have support for creating multiple rooms, let us go ahead and add
    a page to list, join, and create new rooms. We will begin by adding a Jade view
    named `rooms.jade` with the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们支持创建多个房间，让我们继续添加一个页面来列出、加入和创建新的房间。我们将首先添加一个名为 `rooms.jade` 的 Jade 视图，其代码如下：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This view has an input box to accept a new room name and a `div` tag to add
    the list of existing rooms. We are also adding scripts for `socket.io.js` and
    a new script file for our client-side code for listing rooms, namely `rooms.js`.
    Next, create the `rooms.js` script file with the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图有一个输入框用于接受新的房间名称，以及一个 `div` 标签用于添加现有房间的列表。我们还添加了 `socket.io.js` 的脚本以及一个新的客户端代码脚本文件，用于列出房间，名为
    `rooms.js`。接下来，创建 `rooms.js` 脚本文件，其代码如下：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code, we are connecting based on the `chat_infra` namespace,
    requesting the chat rooms on it, and rendering them in the view. Let us take a
    quick look at an important step happening here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们基于 `chat_infra` 命名空间进行连接，请求其上的聊天房间，并在视图中渲染它们。让我们快速看一下这里发生的一个重要步骤：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As shown in the preceding code, the first thing we do after connecting is emit
    an event to `get_rooms`. This will request the list of rooms from the server.
    Next, we set a listener to receive the list of rooms and render them:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，连接后我们首先向 `get_rooms` 发射一个事件。这将请求从服务器获取房间列表。接下来，我们设置一个监听器来接收房间列表并将其渲染：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the handler, as shown in the following code block, we are looping over the
    map of rooms and number of users in them and appending it to the room list:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序中，如以下代码块所示，我们正在遍历房间及其中的用户数量映射，并将其追加到房间列表中：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we have the code to create a new room. To create a new room, all we
    need to do is redirect to the chat room, with the name for the new room in the
    URL parameters:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有创建新房间的代码。要创建新房间，我们只需将聊天房间重定向到带有新房间名称的 URL 参数：
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we need to add a `get_rooms` handler on the server to return the list
    of the rooms. For this, we will add the handler on the `chat_infra` namespace
    in `sockets.js`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在服务器上添加一个 `get_rooms` 处理程序来返回房间列表。为此，我们将在 `sockets.js` 中的 `chat_infra`
    命名空间上添加处理程序：
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can get the list of all the rooms using `io.sockets.manager` and then we
    can build the map expected by our client by looping over the list. In our case,
    we filter to get rooms only from `chat_infra` as they will also be created in
    `chat_com`, and we don''t want duplicates. Once we have the map, we will emit
    it as `rooms_list`. Following this we will need to add the entry to our `routes/index.js`
    file, as shown here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `io.sockets.manager` 获取所有房间的列表，然后我们可以通过遍历列表来构建客户端期望的映射。在我们的例子中，我们过滤以仅获取
    `chat_infra` 中的房间，因为它们也将创建在 `chat_com` 中，我们不希望有重复。一旦我们有了映射，我们将将其作为 `rooms_list`
    发射。在此之后，我们需要将条目添加到我们的 `routes/index.js` 文件中，如下所示：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also need to add the mapping in `app.js` to server rooms at `/rooms`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `app.js` 中添加映射，以便将服务器房间添加到 `/rooms`：
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, let us add some CSS styling for our new room''s page in `style.css`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在我们的新房间页面 `style.css` 中添加一些 CSS 样式：
- en: '[PRE48]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Go to `/rooms` and create a few rooms, and then when you open the room''s page
    in a new browser, you''ll see something similar to this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 `/rooms` 并创建一些房间，然后当你在新浏览器中打开房间页面时，你会看到如下类似的内容：
- en: '![Listing the rooms](img/0786_04_11.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![列出房间](img/0786_04_11.jpg)'
- en: List of rooms on our chat server
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们聊天服务器上的房间列表
- en: Sharing the session
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享会话
- en: Now we have support for multiple rooms, but it is very clumsy to enter a nickname
    every time we enter a room. Let us modify our system to accept the nickname once
    when entering the system and use it in all the rooms.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们支持多个房间，但每次进入房间时都输入昵称非常麻烦。让我们修改我们的系统，在进入系统时只接受一次昵称，并在所有房间中使用它。
- en: 'For this, let us start by modifying the landing page to add an input box to
    accept a nickname and add a JavaScript file to add the logic:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，让我们首先修改登录页面，添加一个输入框来接受昵称，并添加一个 JavaScript 文件来添加逻辑：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, in the preceding code, we are adding a script entry to add `landing.js`
    and replacing the **Start now** button with the field to enter a name and a **Login**
    button. Next, let us take a look at `landing.js`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在之前的代码中，我们添加了一个脚本条目来添加 `landing.js`，并将**立即开始**按钮替换为输入名字的字段和**登录**按钮。接下来，让我们看一下
    `landing.js`：
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the previous code, we are attaching a `click` handler to the `startchat`
    button. In the handler, we are adding the nickname entered by the user to the
    cookie and redirecting the user to `/rooms`. We will be reading this cookie information
    while connecting the socket and then setting it on the socket. Before this cookie
    information can be accessed in the socket connection, we need to lay down some
    ground work to enable cookies in the Express.js application. For this, edit the
    `app.js` code by referring to the following code block:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们为 `startchat` 按钮附加了一个 `click` 处理器。在处理器中，我们将用户输入的昵称添加到 cookie 中，并将用户重定向到
    `/rooms`。在连接 socket 时，我们将读取这个 cookie 信息，并将其设置在 socket 上。在 socket 连接中可以访问这个 cookie
    信息之前，我们需要做一些准备工作来在 Express.js 应用程序中启用 cookies。为此，通过以下代码块编辑 `app.js` 代码：
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The first step is to add `connect` as a dependency in the `package.json` file
    and the `require` keyword in `app.js`. The `connect` keyword is used to create
    a session store; in this case, an in-memory session store:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在 `package.json` 文件中添加 `connect` 作为依赖项，并在 `app.js` 中添加 `require` 关键字。`connect`
    关键字用于创建会话存储；在这种情况下，一个内存会话存储：
- en: '[PRE52]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We also enable the `cookieParser` middleware and the `session` module in the
    express application. Express'' `cookieParser` middleware will take a `secret`
    parameter, which will be used to encrypt the cookies. The express'' `session`
    module is initialized along with passing it the key (`express.sid` is the key
    for a session) and a store where the session should be maintained. In the following
    code, we are passing it an in-memory store, which we created in the previous step:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 Express 应用程序中启用了 `cookieParser` 中间件和 `session` 模块。Express 的 `cookieParser`
    中间件将接受一个 `secret` 参数，该参数将用于加密 cookies。Express 的 `session` 模块在传递给它密钥（`express.sid`
    是会话的密钥）和会话应该维护的存储位置时初始化。在下面的代码中，我们传递给它一个内存存储，这是我们之前步骤中创建的：
- en: '[PRE53]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'One important point to note about the previous code is the order of adding
    these two middleware components. These should be added after adding the `bodyParser`
    middleware and before adding the `router` middleware. If you open the browser
    and browse to the landing page now, you can see the cookie with the `express.sid`
    key in the browser''s debugging tools under the **Cookies** tab. If you enter
    a name and click the **Enter** button, you will again see a new cookie, named
    after your nickname, being set:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 关于之前代码的一个重要注意事项是添加这两个中间件组件的顺序。这些应该在添加 `bodyParser` 中间件之后和添加 `router` 中间件之前添加。如果你现在打开浏览器并浏览到登录页面，你可以在浏览器调试工具的
    **Cookies** 选项卡下看到带有 `express.sid` 键的 cookie。如果你输入一个名字并点击**进入**按钮，你将再次看到一个新的 cookie，其名称为你的昵称：
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The first change in the preceding code block introduces us to a new feature
    in socket.io; this change is shown in the following highlighted code block:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码块中的第一个更改介绍了 socket.io 中的一个新功能；这个更改在以下突出显示的代码块中显示：
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this code snippet, we are setting an `authorization` method for the socket.
    This method will get two parameters, the data that contains all the HTTP request
    information and the `accept` method callback. The `authorization` method is called
    when a socket.io connection is requested but before it is established.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们为 socket 设置了一个 `authorization` 方法。这个方法将获取两个参数，包含所有 HTTP 请求信息的数据和
    `accept` 方法回调。当请求 socket.io 连接但尚未建立连接时，将调用 `authorization` 方法。
- en: We can use this method for actually performing an authorization, but in our
    case we will just use it to get the nickname from the cookies, as this is the
    only socket.io method that will have the HTTP data available with it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个方法来实际执行授权，但在这个案例中，我们只是用它来从 cookies 中获取昵称，因为这是唯一一个带有 HTTP 数据的 socket.io
    方法。
- en: We are reading the cookie headers from the HTTP data and are parsing it using
    the `cookie` module's `parse` method. From the cookie, we are extracting the `sessionID`
    value and the nickname and setting it to the `data` object. This object is available
    on the socket as the `handshake` property. Finally, we will call the `accept`
    callback, which accepts two parameters, first a message and another a Boolean
    variable, indicating whether the authorization was successful or not.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从HTTP数据中读取cookie头信息，并使用`cookie`模块的`parse`方法对其进行解析。从cookie中，我们提取`sessionID`值和昵称，并将其设置到`data`对象中。这个对象作为`handshake`属性在socket上可用。最后，我们将调用`accept`回调函数，该函数接受两个参数，第一个是消息，另一个是布尔变量，指示授权是否成功。
- en: 'We will remove the `set_name` handler, as this handler need not be called because
    we already have the name with us. We will move the logic from the `set_name` handler
    to the `join_room` handler:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将移除`set_name`处理器，因为这个处理器不需要被调用，因为我们已经拥有了这个名字。我们将把`set_name`处理器中的逻辑移动到`join_room`处理器：
- en: '[PRE56]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the `join_room` handler, we will fetch the nickname from the `socket.handshake`
    map and set it as a property on the socket. On setting the `nickname` property,
    we will still trigger the `name_set` event so as to keep the changes on the client
    to a minimum:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`join_room`处理器中，我们将从`socket.handshake`映射中获取昵称，并将其设置为socket上的一个属性。在设置`nickname`属性时，我们仍然会触发`name_set`事件，以将客户端上的更改保持在最小：
- en: '[PRE57]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As the `join_room` handler is the initializer for the room on the server, we
    will take it out of the `name_set` handler and directly call it during the page
    load. The rest of the code remains as is.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`join_room`处理器是服务器上房间的初始化器，我们将它从`name_set`处理器中移除，并在页面加载期间直接调用它。其余的代码保持不变。
- en: To try this code, you will have to open two different browsers or browsers in
    different incognito sessions as the cookies/sessions will be shared for the same
    browser.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这段代码，您需要打开两个不同的浏览器或在不同匿名会话中的浏览器，因为对于同一浏览器，cookie/sessions将会被共享。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to set data for a session, how to work with namespaces
    and rooms, and how to integrate with the express sessions. Here we have completed
    a good and working chat system. It will be a nice exercise for you to build more
    functionality in this, based on the concepts we learned here. Some interesting
    features to build can be user exist alert, user list for the rooms, private chats,
    and so on. In the next chapter, we will take a look at the socket.io protocol
    and understand its workings.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何为会话设置数据，如何处理命名空间和房间，以及如何与express会话集成。在这里，我们已经完成了一个良好且可工作的聊天系统。基于我们在这里学到的概念，构建更多功能将是一个很好的练习。可以构建的一些有趣的功能包括用户存在警报、房间用户列表、私密聊天等。在下一章中，我们将探讨socket.io协议及其工作原理。
