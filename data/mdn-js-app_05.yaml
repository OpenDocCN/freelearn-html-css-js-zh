- en: Chapter 5. Bidirectional Communication in Real Time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 实时双向通信
- en: We have been using COMET techniques to implement bidirectional communication
    between a web browser and web server. Long polling is the most popular technique
    of achieving bidirectional communication between a web browser and web server
    because it works without compromising user experience and without any extra server
    configuration, and it works on all web browsers that support AJAX. Long polling
    can easily be implemented in any existing HTTP server. But the problem with long
    polling and other comet techniques is that none of them are suitable for building
    real-time apps because of HTTP overhead. This means that every time an HTTP request
    is made, a bunch of headers and cookie data is transferred to the server, which
    in turn increases the latency, therefore making it unsuitable for creating applications
    such as multiplayer games, chat apps, social networks, and live score websites,
    which require bidirectional communication in real time. Therefore, a new protocol
    called **WebSocket** was introduced, which was designed to enable bidirectional
    communication in real time between a web browser and WebSocket server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用COMET技术来实现浏览器和Web服务器之间的双向通信。长轮询是实现浏览器和Web服务器之间双向通信的最流行技术，因为它在不影响用户体验和无需额外服务器配置的情况下工作，并且适用于所有支持AJAX的Web浏览器。长轮询可以轻松地集成到任何现有的HTTP服务器中。但是，长轮询和其他COMET技术的缺点是，由于HTTP开销，它们都不适合构建实时应用程序。这意味着每次发起HTTP请求时，都会将大量头部和cookie数据传输到服务器，这反过来又增加了延迟，因此不适合创建需要实时双向通信的应用程序，如多人游戏、聊天应用、社交网络和实时比分网站。因此，引入了一种名为**WebSocket**的新协议，该协议旨在实现浏览器和WebSocket服务器之间实时双向通信。
- en: 'In this chapter, we''ll cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: An overview of WebSocket
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket概述
- en: The relationship between WebSocket and HTTP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket与HTTP的关系
- en: The interaction of WebSocket with proxy servers and firewalls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket与代理服务器和防火墙的交互
- en: Implementing WebSocket using Socket.IO
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Socket.IO实现WebSocket
- en: The Socket.IO API in depth
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解Socket.IO API
- en: Many other important things related to WebSocket and Socket.IO
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与WebSocket和Socket.IO相关的许多其他重要事项
- en: Introducing WebSocket
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WebSocket
- en: '**WebSocket** is an application-layer protocol designed to facilitate bidirectional
    (either the client or server can send a message to the other party whenever a
    message is available) and full-duplex communication (both the client and server
    can send messages to each other simultaneously) between a web browser and WebSocket
    server in real time.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSocket** 是一种应用层协议，旨在促进浏览器和WebSocket服务器之间实时双向（客户端或服务器可以在有消息可用时向对方发送消息）和全双工通信（客户端和服务器可以同时向对方发送消息）。'
- en: WebSocket is a binary protocol; therefore, it is faster than the HTTP protocol,
    which is a text-based protocol.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是一种二进制协议；因此，它比基于文本的HTTP协议更快。
- en: WebSocket has gained popularity and is already being used by many websites due
    to its real-time and full-duplex features. Due to overhead caused by comet techniques,
    it was not suitable for real-time bidirectional message transfer, and it was also
    not possible to establish a full-duplex communication system between a web browser
    and web server using comet. That is, comet techniques let us achieve only half-duplex
    communication system (only the client or server can send messages to the other
    party at a given time).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于COMET技术造成的开销，WebSocket因其实时和全双工特性而受到欢迎，并且已经被许多网站使用。由于COMET技术造成的开销，它不适合实时双向消息传输，并且使用COMET也无法在浏览器和Web服务器之间建立全双工通信系统。也就是说，COMET技术只能实现半双工通信系统（在给定时间内，客户端或服务器只能向对方发送消息）。
- en: WebSocket is designed to facilitate bidirectional communication between a web
    browser and WebSocket server, but it can be used by any client. In this chapter,
    we will only concentrate on how it's implemented in a web browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket旨在促进浏览器和WebSocket服务器之间的双向通信，但它可以被任何客户端使用。在本章中，我们将仅关注它在浏览器中的实现方式。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What is the WebSocket API?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是WebSocket API？
- en: Web browsers provide an API for creating and managing a WebSocket connection
    to a WebSocket server as well as for sending and receiving data on the connection.
    We won't use this API for implementing WebSocket; instead, we will use the Socket.IO
    library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Web浏览器提供了一个API，用于创建和管理与WebSocket服务器的WebSocket连接，以及在该连接上发送和接收数据。我们不会使用此API来实现WebSocket；相反，我们将使用Socket.IO库。
- en: The relationship between WebSocket and HTTP
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket 和 HTTP 之间的关系
- en: The only relationship between WebSocket and HTTP is that a WebSocket handshake
    between a web browser and WebSocket server is done using HTTP. Therefore, a WebSocket
    server is also an HTTP server. Once the handshake is successful, the same TCP
    connection is used for WebSocket communication, that is, communication switches
    to the bidirectional binary protocol, which does not conform to the HTTP protocol.
    The default port number for WebSocket is 80, same as for HTTP.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 和 HTTP 之间的唯一关系是，Web 浏览器和 WebSocket 服务器之间的 WebSocket 握手是通过 HTTP 实现的。因此，WebSocket
    服务器也是一个 HTTP 服务器。一旦握手成功，相同的 TCP 连接就会用于 WebSocket 通信，即通信切换到双向二进制协议，该协议不符合 HTTP
    协议。WebSocket 的默认端口号是 80，与 HTTP 相同。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why is the default WebSocket port 80?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 WebSocket 的默认端口号是 80？
- en: The main reason for integrating HTTP and WebSocket so tightly and making WebSocket
    share the HTTP port is to prevent firewalls from blocking non-web content.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HTTP 和 WebSocket 集成得如此紧密，并让 WebSocket 共享 HTTP 端口的主要原因是为了防止防火墙阻止非网页内容。
- en: Although you can implement your own WebSocket handshake mechanism if you are
    using WebSocket outside a web browser environment, the official WebSocket documentation
    only states the HTTP handshake mechanism because WebSocket is designed to enable
    bidirectional communication between web browsers and WebSocket servers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果你在 Web 浏览器环境之外使用 WebSocket，你可以实现自己的 WebSocket 握手机制，但官方 WebSocket 文档仅说明了
    HTTP 握手机制，因为 WebSocket 是设计用来在 Web 浏览器和 WebSocket 服务器之间实现双向通信的。
- en: You can integrate a WebSocket server into your main web server that serves your
    HTML pages, or you can use a separate web server for WebSocket communication.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 WebSocket 服务器集成到为主 HTML 页面提供服务的 Web 服务器中，或者你可以为 WebSocket 通信使用单独的 Web 服务器。
- en: Sending and receiving data on a WebSocket connection
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 WebSocket 连接上发送和接收数据
- en: Data is transferred through a WebSocket connection as messages, each of which
    consists of one or more frames containing the data you are sending (called the
    payload). In order to ensure that the message can be properly reconstructed when
    it reaches the other party, each frame is prefixed with 4-12 bytes of data about
    the payload. Using this frame-based messaging system helps reduce the amount of
    non-payload data that is transferred, leading to significant reductions in latency,
    therefore making it possible to build real-time components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通过 WebSocket 连接作为消息传输，每个消息包含一个或多个帧，这些帧包含你要发送的数据（称为有效载荷）。为了确保消息在到达对方时可以正确重建，每个帧都带有
    4-12 字节的有效载荷信息。使用基于帧的消息系统有助于减少非有效载荷数据的传输量，从而显著降低延迟，这使得构建实时组件成为可能。
- en: We won't get into the exact data format and other details of the WebSocket handshake,
    data framing, and sending and receiving data as this is only required if you are
    planning to create your own WebSocket server. We will use Socket.IO JavaScript
    library to implement WebSocket in our application, which takes care of all the
    internal details of WebSocket and provides an easy-to-use API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨 WebSocket 握手、数据帧定界以及发送和接收数据的精确数据格式和其他细节，因为这仅在你计划创建自己的 WebSocket 服务器时才是必需的。我们将使用
    Socket.IO JavaScript 库在我们的应用程序中实现 WebSocket，该库处理所有 WebSocket 的内部细节，并提供一个易于使用的
    API。
- en: WebSocket schemes
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket 方案
- en: WebSocket protocol specifications have introduced two new URL schemes, called
    **ws** and **wss**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议规范引入了两种新的 URL 方案，称为 **ws** 和 **wss**。
- en: '`ws` represents an unencrypted connection whereas `wss` represents an encrypted
    connection. Encrypted connections use TLS to encrypt messages.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ws` 代表一个未加密的连接，而 `wss` 代表一个加密的连接。加密连接使用 TLS 加密消息。'
- en: So, when making a WebSocket handshake request using HTTP, we need to use `ws`
    or `wss` instead of `http` or `https`, respectively.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用 HTTP 进行 WebSocket 握手请求时，我们需要分别使用 `ws` 或 `wss` 而不是 `http` 或 `https`。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why `ws` and `wss` instead of `http` and `https`?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用 `ws` 和 `wss` 而不是 `http` 和 `https`？
- en: You must be wondering what the point of introducing a new scheme instead of
    just using `http`. Well, the reason behind this is that WebSocket can also be
    used outside a web browser environment, and a handshake can be negotiated via
    a non-HTTP server. Therefore, a different scheme is required when not using HTTP
    for the handshake.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道引入新方案而不是仅仅使用 `http` 的目的是什么。背后的原因是 WebSocket 也可以在 Web 浏览器环境之外使用，握手可以通过非
    HTTP 服务器进行协商。因此，在不使用 HTTP 进行握手时，需要不同的方案。
- en: The interaction of WebSocket with proxy servers, load balancers, and firewalls
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket 与代理服务器、负载均衡器和防火墙的交互
- en: The WebSocket protocol is unaware of proxy servers by itself. When a WebSocket
    connection is established behind a proxy server, the WebSocket connection can
    fail or work properly, depending on whether the proxy server is transparent or
    explicit and also whether we have established a secure or unsecure connection.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议本身并不了解代理服务器。当 WebSocket 连接在代理服务器后面建立时，WebSocket 连接可能会失败或正常工作，这取决于代理服务器是否透明或明确，以及我们是否建立了安全或不安全的连接。
- en: If the browser is configured to use an explicit proxy server, then it will first
    issue an `HTTP CONNECT` method to that proxy server when establishing the WebSocket
    connection. The `CONNECT` method is used to tell a proxy to make a connection
    to another host and simply reply with the content, without attempting to parse
    or cache it. A browser issues the `HTTP CONNECT` method regardless of whether
    the connection is encrypted or unencrypted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器配置为使用明确的代理服务器，那么在建立 WebSocket 连接时，它将首先向该代理服务器发出一个 `HTTP CONNECT` 方法。`CONNECT`
    方法用于告诉代理服务器连接到另一个主机，并简单地回复内容，而不尝试解析或缓存它。浏览器无论连接是加密的还是未加密的，都会发出 `HTTP CONNECT`
    方法。
- en: If we are using a transparent proxy server (that is, a proxy server that the
    web browser is unaware of) and the connection is encrypted, then the browser doesn't
    issue an `HTTP CONNECT` method because it's unaware of the proxy server. But as
    the connection is encrypted, the proxy server will most probably let all the encrypted
    data through, therefore causing no problems to the WebSocket connection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是透明代理服务器（即浏览器不知道的代理服务器）且连接加密，那么浏览器不会发出 `HTTP CONNECT` 方法，因为它不知道代理服务器。但是，由于连接加密，代理服务器很可能会让所有加密数据通过，因此不会对
    WebSocket 连接造成问题。
- en: If we are using a transparent proxy server and the connection is unencrypted,
    then the browser doesn't issue an `HTTP CONNECT` method because it's unaware of
    the proxy server. But as the connection is unencrypted, the proxy server is likely
    to try to cache, parse, or block the data, therefore causing issues for the WebSocket
    connection. In this case, the proxy server should be upgraded or explicitly configured
    to support WebSocket connections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是透明代理服务器且连接未加密，那么浏览器不会发出 `HTTP CONNECT` 方法，因为它不知道代理服务器。但是，由于连接未加密，代理服务器可能会尝试缓存、解析或阻止数据，因此可能会对
    WebSocket 连接造成问题。在这种情况下，代理服务器应该升级或显式配置以支持 WebSocket 连接。
- en: The WebSocket protocol is unaware of load balancers by itself. If you are using
    a TCP load balancer, it is unlikely to cause any problems for a WebSocket connection.
    But if you are using an HTTP load balancer, it's likely to cause problems; therefore,
    it needs to be upgraded or explicitly configured to handle WebSocket connections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议本身并不了解负载均衡器。如果你使用的是 TCP 负载均衡器，它不太可能对 WebSocket 连接造成任何问题。但是，如果你使用的是
    HTTP 负载均衡器，它很可能会引起问题；因此，需要升级或显式配置以处理 WebSocket 连接。
- en: The WebSocket protocol is unaware of firewalls by itself. Firewalls are unlikely
    to cause any problems for a WebSocket connection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议本身并不了解防火墙。防火墙不太可能对 WebSocket 连接造成任何问题。
- en: The same-origin policy for WebSocket
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket 的同源策略
- en: Browsers as well as WebSocket instances can perform cross-domain communication,
    that is, they are not restricted by any same-origin policy.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器以及 WebSocket 实例都可以执行跨域通信，即它们不受任何同源策略的限制。
- en: While making an HTTP request for a handshake, the browser sends an `Origin`
    header assigned to the webpage origin.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行握手请求的 HTTP 请求时，浏览器会发送一个分配给网页源的 `Origin` 标头。
- en: If a WebSocket server wants to restrict communication to a particular domain,
    it can read the `Origin` HTTP header of the handshake HTTP request and block or
    allow the handshake accordingly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 WebSocket 服务器想要限制通信到特定域名，它可以读取握手 HTTP 请求的 `Origin` HTTP 标头，并根据情况阻止或允许握手。
- en: Introduction to Socket.IO
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO 简介
- en: Socket.IO is a combination of the client-side JavaScript library and Node.js
    library used to integrate bidirectional communication between a browser and Node.js
    backend.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO 是一个客户端 JavaScript 库和 Node.js 库的组合，用于在浏览器和 Node.js 后端之间集成双向通信。
- en: The Socket.IO client-side library is used to create a Socket.IO client whereas
    the Socket.IO Node.js library is used to create a Socket.IO server. The Socker.IO
    client and server can communicate with each other bidirectionally. Socket.IO primarily
    uses WebSocket to achieve bidirectional communication.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO 客户端库用于创建 Socket.IO 客户端，而 Socket.IO Node.js 库用于创建 Socket.IO 服务器。Socket.IO
    客户端和服务器可以双向通信。Socket.IO 主要使用 WebSocket 来实现双向通信。
- en: The main reason for using the Socket.IO client-side library instead of using
    the WebSocket API is that WebSocket is a relatively new protocol at the time of
    writing and not all browsers support the API. If Socket.IO sees that the browser
    doesn't support WebSocket, then it jumps to one of the other mechanisms, such
    as Flash sockets, long polling, multipart streaming, iframes, or JSONP polling,
    to implement bidirectional communication between browsers and servers. Therefore,
    we can say that Socket.IO is guaranteed to work on every browser. The Socket.IO
    backend library provides APIs to create namespaces and rooms, broadcast messages,
    and so on, which are very useful in some cases. Therefore, Socket.IO is the best
    way to implement bidirectional communication between a browser and Node.js server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Socket.IO 客户端库而不是使用 WebSocket API 的主要原因在于，WebSocket 在撰写本文时是一个相对较新的协议，并且并非所有浏览器都支持该
    API。如果 Socket.IO 发现浏览器不支持 WebSocket，那么它会跳转到其他机制之一，例如 Flash sockets、长轮询、多部分流、iframe
    或 JSONP 轮询，以实现浏览器和服务器之间的双向通信。因此，我们可以断言 Socket.IO 在每个浏览器上都能保证工作。Socket.IO 后端库提供了创建命名空间和房间、广播消息等
    API，这在某些情况下非常有用。因此，Socket.IO 是在浏览器和 Node.js 服务器之间实现双向通信的最佳方式。
- en: Setting up your project
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的项目
- en: Before we start learning about the Socket.IO API, let's first set up our project
    directory and files. Create a directory named `SocketIO-Example`. Inside the directory,
    create files called `package.json`, `app.js`, and `socket.js`, and a directory
    called `public`. Inside the `public` directory, create two directories, `html`
    and `js`. Inside the `html` directory, create a file called `index.html`. Finally,
    in the `js` directory, download and place the Socket.IO library from [https://cdn.socket.io/socket.io-1.3.7.js](https://cdn.socket.io/socket.io-1.3.7.js).
    At the time of writing, the latest version of Socket.IO is 1.3.7; therefore, we
    will be using that version.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习 Socket.IO API 之前，让我们首先设置我们的项目目录和文件。创建一个名为 `SocketIO-Example` 的目录。在该目录内，创建名为
    `package.json`、`app.js` 和 `socket.js` 的文件，以及一个名为 `public` 的目录。在 `public` 目录内，创建两个目录，`html`
    和 `js`。在 `html` 目录内，创建一个名为 `index.html` 的文件。最后，在 `js` 目录内，下载并放置从 [https://cdn.socket.io/socket.io-1.3.7.js](https://cdn.socket.io/socket.io-1.3.7.js)
    的 Socket.IO 库。在撰写本文时，Socket.IO 的最新版本是 1.3.7；因此，我们将使用该版本。
- en: Inside the `app.js` file, we will write code for the web server, and inside
    the `socket.js` file, we will write code for the Socket.IO server. For now, we
    will run two different servers, that is, a separate web server serving the website,
    and another server for bidirectional communication. In the next chapter, we will
    learn how to integrate the Socket.IO server with the Express server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.js` 文件中，我们将编写用于网页服务器的代码，而在 `socket.js` 文件中，我们将编写用于 Socket.IO 服务器的代码。目前，我们将运行两个不同的服务器，即一个单独的网页服务器用于提供网站，另一个服务器用于双向通信。在下一章中，我们将学习如何将
    Socket.IO 服务器与 Express 服务器集成。
- en: 'Inside the `package.json` file, place this code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `package.json` 文件中，放置以下代码：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, run the `npm install` command inside the `SocketIO-Example` directory in
    order to download and install Express and the Socket.IO Node.js library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `SocketIO-Example` 目录内运行 `npm install` 命令，以便下载并安装 Express 和 Socket.IO Node.js
    库。
- en: 'Now, inside the `index.html` file, place this HTML code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `index.html` 文件中，放置以下 HTML 代码：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the second `<script>` tag, you will be placing the Socket.IO client-side
    code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个 `<script>` 标签内，你需要放置 Socket.IO 的客户端代码。
- en: 'Now, place this code in the `app.js` file to serve the `index.html` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码放置在 `app.js` 文件中以提供 `index.html` 文件：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are listening on port `8080`. Run the `app.js` file and visit the `http://localhost:8080/`
    URL to load the `index.html` page.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们监听端口 `8080`。运行 `app.js` 文件，并访问 `http://localhost:8080/` URL 来加载 `index.html`
    页面。
- en: We are done with setting up the files and directories. Now, let's learn about
    the Socket.IO client-side and server-side APIs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了文件和目录的设置。现在，让我们学习 Socket.IO 的客户端和服务器端 API。
- en: Diving into the Socket.IO API
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入 Socket.IO API
- en: Let's first look at an overview of the Socket.IO API. After that, we will get
    into the advanced features one by one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看Socket.IO API的概述。之后，我们将逐一介绍高级功能。
- en: 'Let''s first build a Socket.IO server. The following is the code to create
    a Socket.IO server instance and listen to new Socket.IO client handshake requests.
    Place it in the `socket.js` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先构建一个Socket.IO服务器。以下是在`socket.js`文件中创建Socket.IO服务器实例并监听新的Socket.IO客户端握手请求的代码：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is how the code works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的工作方式：
- en: First, we import the Socket.IO Node.js library.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入Socket.IO Node.js库。
- en: Then, we create a new instance of the Socket.IO server using the `Server` constructor.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`Server`构造函数创建Socket.IO服务器的新实例。
- en: Then, while creating a new instance, we pass the HTTP path to which the Socket.IO
    client will make a handshake request. If we don't pass the path, it defaults to
    /`socket.io`
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在创建新实例时，我们传递Socket.IO客户端将发起握手请求的HTTP路径。如果我们不传递路径，则默认为`/socket.io`。
- en: Finally, we listen on port `3000`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在端口`3000`上监听。
- en: I created a single Socket.IO server in the code, but we have the freedom to
    create multiple servers listening on different ports.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我在代码中创建了一个单独的Socket.IO服务器，但我们有自由创建多个服务器，它们在不同的端口上监听。
- en: 'Now, Socket.IO clients can send a handshake request, and the Socket.IO server
    can establish a Socket.IO connection with its clients. Let''s write some code
    to do something on a Socket.IO server after a Socket.IO connection has been established.
    Place this code in the `socket.js` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Socket.IO客户端可以发送一个握手请求，并且Socket.IO服务器可以与其客户端建立Socket.IO连接。让我们编写一些代码，在Socket.IO连接建立后，在Socket.IO服务器上执行一些操作。将此代码放置在`socket.js`文件中：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see how this code works and what the `send()`, `on()`, and `emit()`
    methods do:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码是如何工作的，以及`send()`、`on()`和`emit()`方法的作用：
- en: The `on()` method of the `io` object is used to attach event handlers to events
    triggered on the Socket.IO server by itself.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io`对象上的`on()`方法用于将事件处理器附加到由Socket.IO服务器本身触发的事件。'
- en: We first attach an event handler for the `connection` event. As soon as a Socket.IO
    connection has been established, the `connection` event is fired. The event handler
    has a single parameter, which is an object representing the Socket.IO client.
    Here, we've named the parameter `socket`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先为`connection`事件附加一个事件处理器。一旦Socket.IO连接建立，就会触发`connection`事件。事件处理器有一个单一参数，它是一个表示Socket.IO客户端的对象。在这里，我们将该参数命名为`socket`。
- en: The `on()` method of the `socket` object is used to attach event handlers to
    the events emitted by the Socket.IO client to the server.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`对象上的`on()`方法用于将事件处理器附加到由Socket.IO客户端触发的、发送到服务器的事件。'
- en: The `send()` method of the `socket` object is used to send a message to the
    Socket.IO client. We are sending a string here, but you can also send an instance
    of `ArrayBuffer`, `Blob Node.js Buffer`, and even `File`. You can also send a
    simple JavaScript object.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`对象上的`send()`方法用于向Socket.IO客户端发送消息。我们在这里发送一个字符串，但也可以发送`ArrayBuffer`、`Blob`、Node.js
    `Buffer`的实例，甚至`File`。你还可以发送一个简单的JavaScript对象。'
- en: Then, we attached an event handler for the `message` event, which is triggered
    when the Socket.IO client sends a message to the Socket.IO server.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们附加了一个事件处理器来处理`message`事件，该事件在Socket.IO客户端向Socket.IO服务器发送消息时触发。
- en: After that, we attached an event handler to the `disconnect` event, which is
    triggered when the Socket.IO client disconnects from the Socket.IO server.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们附加了一个事件处理器来处理`disconnect`事件，该事件在Socket.IO客户端从Socket.IO服务器断开连接时触发。
- en: The `emit` method of the `socket` object is used to send custom events to the
    Socket.IO client. It can take an infinite number of arguments. The first argument
    it takes is the event name, and the rest of the arguments are the parameters of
    the event handler, which is triggered on the Socket.IO client.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`对象上的`emit`方法用于向Socket.IO客户端发送自定义事件。它可以接受无限数量的参数。它接受的第一个参数是事件名称，其余参数是触发在Socket.IO客户端上的事件处理器的参数。'
- en: Finally, we use the `on()` method of the `socket` object to register an event
    handler for a custom event named `custom-event`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用`socket`对象的`on()`方法注册一个名为`custom-event`的自定义事件的事件处理器。
- en: So now, we have finished creating a very simple Socket.IO server that lets Socket.IO
    clients establish a connection with it. It is also listening to `message` and
    `custom-event` events. It also sends a message and emits a custom event to the
    Socket.IO clients as soon as they are connected.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经完成了一个非常简单的 Socket.IO 服务器，它允许 Socket.IO 客户端与其建立连接。它也在监听 `message` 和
    `custom-event` 事件。一旦 Socket.IO 客户端连接，它就会立即向 Socket.IO 客户端发送消息并触发自定义事件。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As every Socket.IO client gets a separate `socket` object on the Socket.IO server,
    if we want a `socket` object to be able to access the `socket` object of another
    Socket.IO client, then we can keep a reference to the `socket` objects of every
    Socket.IO client in a global array. This can be useful if we are creating a chat
    app in which a `socket` object needs to access another `socket` object to send
    messages to it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 Socket.IO 客户端在 Socket.IO 服务器上都会获得一个独立的 `socket` 对象，如果我们想让一个 `socket` 对象能够访问另一个
    Socket.IO 客户端的 `socket` 对象，那么我们可以在全局数组中保留每个 Socket.IO 客户端的 `socket` 对象引用。如果我们正在创建一个聊天应用，其中
    `socket` 对象需要访问另一个 `socket` 对象以向其发送消息，这可能会很有用。
- en: You can now run the Socket.IO server using the `node socket.js` command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用 `node socket.js` 命令运行 Socket.IO 服务器。
- en: 'Now, let''s build the Socket.IO client. The following is the code to create
    a Socket.IO client instance and establish a Socket.IO connection with the Socker.IO
    server. Place this code in the `<script>` tag of the `index.html` file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建 Socket.IO 客户端。以下是在 `index.html` 文件的 `<script>` 标签中创建 Socket.IO 客户端实例并与
    Socket.IO 服务器建立连接的代码：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are first creating a Socket.IO client instance and establishing a connection
    with the Socket.IO server using the `io` constructor. The first argument is the
    base URL of the Socket.IO server. The second argument is an optional object to
    which we have passed the URL path that the handshake request should be made to.
    If we don't pass the path, then the default path will be `/socket.io`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建一个 Socket.IO 客户端实例，并使用 `io` 构造函数与 Socket.IO 服务器建立连接。第一个参数是 Socket.IO
    服务器的基本 URL。第二个参数是一个可选对象，我们向其中传递了握手请求应该进行的 URL 路径。如果我们不传递路径，则默认路径为 `/socket.io`。
- en: We created a single Socket.IO client instance here, but we have the freedom
    to create multiple Socket.IO client instances if we want to connect to multiple
    Socket.IO servers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个单独的 Socket.IO 客户端实例，但如果我们需要连接到多个 Socket.IO 服务器，我们也有自由创建多个 Socket.IO
    客户端实例。
- en: We are using the `http` scheme instead of the `ws` scheme here because Socket.IO
    can use any technique or protocol other than WebSocket to achieve bidirectional
    communication. If Socket.IO chooses to use WebSocket, then it will automatically
    replace `http` with `ws`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `http` 方案而不是 `ws` 方案，因为 Socket.IO 可以使用除 WebSocket 之外的技术或协议来实现双向通信。如果
    Socket.IO 选择使用 WebSocket，那么它将自动将 `http` 替换为 `ws`。
- en: 'Let''s write some code to do something on a Socket.IO client after a Socket.IO
    connection has been established. Place this code in the `<script>` tag of `index.html`
    file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，在建立 Socket.IO 连接后，在 Socket.IO 客户端上执行某些操作。将此代码放置在 `index.html` 文件的
    `<script>` 标签中：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s understand how this code works and what the `send()`, `on()`, and `emit()`
    methods do:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这段代码的工作原理以及 `send()`、`on()` 和 `emit()` 方法的作用：
- en: The `on()` method of the `socket` object is used to attach event handlers to
    the events triggered on the Socket.IO client by itself.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket` 对象的 `on()` 方法用于将事件处理器附加到由 Socket.IO 客户端本身触发的事件。'
- en: We first attach an event handler to the `connect` event. As soon as a Socket.IO
    connection has been established, the `connect` event is fired.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先向 `connect` 事件附加了一个事件处理器。一旦建立了 Socket.IO 连接，就会触发 `connect` 事件。
- en: The `send()` method's `socket` object is used to send a message to the Socket.IO
    server. We are sending a string here, but you can also send an instance of `ArrayBuffer`,
    `Blob`, or even `File`. You can also send a simple JavaScript object.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send()` 方法的 `socket` 对象用于向 Socket.IO 服务器发送消息。我们在这里发送一个字符串，但你也可以发送 `ArrayBuffer`、`Blob`
    或甚至 `File` 的实例。你也可以发送一个简单的 JavaScript 对象。'
- en: Then, we attached an event handler to the `message` event, which is triggered
    when the Socket.IO server sends a message to the Socket.IO client.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们向 `message` 事件附加了一个事件处理器，该事件在 Socket.IO 服务器向 Socket.IO 客户端发送消息时触发。
- en: We then attached an event handler to the `disconnect` event, which is triggered
    when the Socket.IO client disconnects from the Socket.IO server. As soon as a
    Socket.IO connection breaks, the Socket.IO client keeps trying to connect again
    automatically.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将事件处理器附加到`disconnect`事件，该事件在Socket.IO客户端从Socket.IO服务器断开连接时触发。一旦Socket.IO连接中断，Socket.IO客户端会自动尝试重新连接。
- en: After that, we use the `on()` method of the `socket` object to register an event
    handler for a custom event named `custom-event`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们使用`socket`对象的`on()`方法为名为`custom-event`的自定义事件注册事件处理器。
- en: The `emit` method of the `socket` object is used to send custom events to the
    Socket.IO server. It can take an infinite number of arguments. The first argument
    it takes is the event name, and the rest of the arguments are the parameters of
    the event handler, which is triggered in the Socket.IO client.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`对象的`emit`方法用于向Socket.IO服务器发送自定义事件。它可以接受无限数量的参数。它接受的第一个参数是事件名称，其余参数是事件处理器的参数，该处理器在Socket.IO客户端中被触发。'
- en: 'Now, open the URL `http://localhost:8080/` in your browser, and you should
    see the following console output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的浏览器中打开URL `http://localhost:8080/`，您应该看到以下控制台输出：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And you will see the following output in the shell running the Socket.IO server:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 并且您将在运行Socket.IO服务器的shell中看到以下输出：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Restricting connections based on origin
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据来源限制连接
- en: By default, a Socket.IO server lets Socket.IO clients from any origin establish
    a Socket.IO connection with it. Socket.IO provides a way to restrict connections
    to a particular origin.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Socket.IO服务器允许来自任何来源的Socket.IO客户端与其建立Socket.IO连接。Socket.IO提供了一种限制连接到特定来源的方法。
- en: To restrict connections to a particular origin or set of origins, we can use
    the `origins` method of the `Server` instance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要限制连接到特定来源或一组来源，我们可以使用`Server`实例的`origins`方法。
- en: 'Place this code in the `socket.js` file to only allow Socket.IO clients running
    on the `localhost` domain and port number `8080` to connect to the Socket.IO server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放置在`socket.js`文件中，以仅允许运行在`localhost`域和端口号`8080`上的Socket.IO客户端连接到Socket.IO服务器：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We cannot simply pass any `origin` to the `origins` method. Here are examples
    of some valid `origins`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将任何`origin`传递给`origins`方法。以下是一些有效的`origins`示例：
- en: '`testsite.com:80`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testsite.com:80`'
- en: '`http://testsite.com:80`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://testsite.com:80`'
- en: '`http://*:8080` (* is a wildcard)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://*:8080` (*是一个通配符)'
- en: '`*:8080`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*:8080`'
- en: '`testsite.com:* http://someotherdomain.com:8080` (multiple origins separated
    by spaces)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testsite.com:* http://someotherdomain.com:8080` (通过空格分隔的多个来源)'
- en: '`testsite.com:*/somepath` (Socket.IO will ignore /somepath)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testsite.com:*/somepath` (Socket.IO将忽略/somepath)'
- en: '`*:*`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*:*`'
- en: In the previous list, every origin has a port number associated with it because
    it is compulsory to provide a port number or * in place of the port number, indicating
    any port.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的列表中，每个来源都与一个端口号相关联，因为提供端口号或*（表示任何端口号）是强制性的。
- en: 'Here are some examples of invalid origins:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些无效来源的示例：
- en: '`testsite.com`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testsite.com`'
- en: '`http://testsite.com`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://testsite.com`'
- en: '`http://testsite.com/somepath`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://testsite.com/somepath`'
- en: These are invalid because they don't have port numbers associated with them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是无效的，因为它们没有与端口号相关联。
- en: Also note that if you specify `sub.testsite.com` as the `origins` value, `testsite.com`
    will be a valid origin.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，如果您将`sub.testsite.com`指定为`origins`值，则`testsite.com`将是一个有效的来源。
- en: Namespaces in Socket.IO
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socket.IO中的命名空间
- en: A Socket.IO server is actually divided into child servers called **namespaces**.
    A Socket.IO client always connects to a namespace. Every namespace has a name,
    which looks like an HTTP path.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器实际上被划分为称为**命名空间**的子服务器。Socket.IO客户端始终连接到命名空间。每个命名空间都有一个名称，看起来像HTTP路径。
- en: In the previous code, when we created a Socket.IO server, a default namespace
    was created. The default namespace is identified by the `/` path. If we don't
    mention a namespace when creating a Socket.IO client, then it connects to the
    default namespace. So, the `connection` event is specific to a particular namespace,
    that is, for every namespace, we have to register a different `connection` event
    handler.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，当我们创建一个Socket.IO服务器时，会创建一个默认的命名空间。默认命名空间由`/`路径标识。如果我们创建Socket.IO客户端时不提及命名空间，那么它将连接到默认命名空间。因此，`connection`事件是特定于特定命名空间的，也就是说，对于每个命名空间，我们必须注册不同的`connection`事件处理器。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**What is the benefit of namespaces?**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间的好处是什么？**'
- en: You must be wondering what the point of introducing namespaces is. Well, namespaces
    make writing complex code easier. Let's look at an example to understand this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道引入命名空间的意义是什么。好吧，命名空间使得编写复杂的代码变得更加容易。让我们通过一个例子来理解这一点。
- en: Suppose you have a web page that has multiple components that update in real
    time. You would then either create multiple Socket.IO servers for a component
    or use a single Socket.IO server and rely on the data format of a message or custom
    event to find which data belongs to which component. Both of these techniques
    have demerits, that is, creating multiple Socket.IO servers occupies multiple
    ports, so it's not suitable for a large number of components, and relying on the
    data formats of messages and custom events make it difficult to move frontend
    components to a separate application, as the new application will get a lot of
    unnecessary messages and events, causing bandwidth issues on both sides. Therefore,
    namespaces were introduced, which combine the benefits of both techniques while
    omitting their demerits.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含多个实时更新的组件的网页。那么，你可能需要为每个组件创建多个Socket.IO服务器，或者使用单个Socket.IO服务器，并依赖于消息或自定义事件的数据格式来找到哪些数据属于哪个组件。这两种技术都有缺点，也就是说，创建多个Socket.IO服务器会占用多个端口，因此不适合大量组件，而依赖于消息和自定义事件的数据格式会使将前端组件移动到单独的应用程序变得困难，因为新的应用程序将接收到大量不必要的消息和事件，导致双方带宽问题。因此，引入了命名空间，它结合了两种技术的优点，同时避免了它们的缺点。
- en: 'Here is how to create a custom namespace. Place this code in the `socket.js`
    file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何创建自定义命名空间的方法。将此代码放置在`socket.js`文件中：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On adding this code to the `socket.js` file, we will have two namespaces, that
    is, the default one, which we created earlier, and this one, called `/custom-namespace`.
    Here, you can see that we registered a new connection event handler for this namespace.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到`socket.js`文件后，我们将有两个命名空间，即我们之前创建的默认命名空间，以及这个名为`/custom-namespace`的命名空间。在这里，你可以看到我们为这个命名空间注册了一个新的连接事件处理器。
- en: 'Now, let''s create another Socket.IO client, one which connects to the `/custom-namespace`
    namespace. Place this code in the `<script>` tag of `index.html` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个Socket.IO客户端，一个连接到`/custom-namespace`命名空间的客户端。将此代码放置在`index.html`文件的`<script>`标签中：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are creating another Socket.IO client; this one connects to the `/custom-namespace`
    namespace.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建另一个Socket.IO客户端；这个客户端连接到`/custom-namespace`命名空间。
- en: 'Now, rerun the `socket.js` file and visit `http://localhost:8080/`. This will
    be the browser console output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新运行`socket.js`文件并访问`http://localhost:8080/`。这将是在浏览器控制台中的输出：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And this will be the new shell output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是新的shell输出：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we restrict access based on origin using the `origins()` method, it is
    applied to all namespaces.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`origins()`方法根据来源限制访问时，它将应用于所有命名空间。
- en: Referring to all connected Socket.IO clients
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指向所有连接的Socket.IO客户端
- en: The Socket.IO server API also provides us with a way of sending a message or
    custom event to everyone in a namespace.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器API还为我们提供了一种向命名空间中的所有人发送消息或自定义事件的方法。
- en: 'Let''s look at an example of how to do this. Place the following code in the
    `socket.js` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这个例子。将以下代码放置在`socket.js`文件中：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, to send a message or custom event to all the Socket.IO clients connected
    to the default namespace, we use the `io` object. And to send to Socker.IO clients
    connected to a custom namespace, we use the object returned by the `of()` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，要向连接到默认命名空间的Socket.IO客户端发送消息或自定义事件，我们使用`io`对象。要向连接到自定义命名空间的Socket.IO客户端发送，我们使用`of()`方法返回的对象。
- en: Here, we are simply sending a message and custom event to everyone in both the
    namespaces every `5` seconds.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是每`5`秒向两个命名空间中的所有人发送一个消息和自定义事件。
- en: Rooms in Socket.IO
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socket.IO中的房间
- en: A **room** simply represents a group of Socket.IO clients connected to a particular
    namespace. A room belongs to a particular namespace.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**房间**简单地表示连接到特定命名空间的一组Socket.IO客户端。房间属于特定的命名空间。'
- en: A namespace cannot have two rooms with the same name, but two different namespaces
    can have rooms with the same name. Rooms with the same name on different namespaces
    are different rooms entirely.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间不能有两个同名房间，但不同的命名空间可以有同名房间。不同命名空间中同名房间是完全不同的房间。
- en: Every Socket.IO client connected to a namespace must belong to one or more groups.
    By default, when a Socket.IO client is connected, a new group is created and the
    client is added to it. Therefore, every Socket.IO client belongs to a unique group
    by default.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接到命名空间的Socket.IO客户端都必须属于一个或多个组。默认情况下，当Socket.IO客户端连接时，会创建一个新的组，并将客户端添加到该组。因此，每个Socket.IO客户端默认属于一个唯一的组。
- en: 'Here is the code that prints the unique group name of a Socket.IO client after
    it has connected. Place it inside the default and `/custom-namespace` namespaces''
    `connection` event handlers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是打印Socket.IO客户端连接后的唯一组名的代码。将其放置在默认和`/custom-namespace`命名空间的`connection`事件处理器中：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `id` property of the `socket` object holds the unique room name.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket`对象的`id`属性持有唯一的房间名称。'
- en: Joining and leaving a room
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加入和离开房间
- en: To add a Socket.IO client to a custom room, we need to use the `socket.use()`
    method. To remove a Socket.IO client from a custom room, we need to use the `socket.leave()`
    method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Socket.IO客户端添加到自定义房间，我们需要使用`socket.use()`方法。要移除Socket.IO客户端从自定义房间，我们需要使用`socket.leave()`方法。
- en: 'The following code adds every Socket.IO client connected to the default and
    `/custom-namespace` servers to a room called `my-custom-room`. Place it inside
    the default and `/custom-namespace` namespaces'' `connection` event handlers:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将连接到默认和`/custom-namespace`服务器的所有Socket.IO客户端添加到名为`my-custom-room`的房间中。将其放置在默认和`/custom-namespace`命名空间的`connection`事件处理器中：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similarly, to remove a user from `my-custom-room`, you can use this code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要移除`my-custom-room`中的用户，你可以使用以下代码：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Referring to all connected Socket.IO clients in a room
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引用房间中的所有连接Socket.IO客户端
- en: The Socket.IO server API also provides us with a way to send a message or custom
    event to everyone in a room.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器API还为我们提供了一种向房间中的所有人发送消息或自定义事件的方法。
- en: 'Let''s look at an example of how to do this. Place the following code in the
    `socket.js` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这个例子。将以下代码放置在`socket.js`文件中：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, to send a message or custom event to all the Socket.IO clients in the
    `my-custom-room` room of the default namespace, we need to use the `io.to().send()`
    method. And to send a message or custom event to all the Socket.IO clients in
    the `my-custom-room` room of the `/custom-namespace` namespace, we need to use
    the `nsp.to().send()` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，要向默认命名空间中`my-custom-room`房间的所有Socket.IO客户端发送消息或自定义事件，我们需要使用`io.to().send()`方法。而要向`/custom-namespace`命名空间中`my-custom-room`房间的所有Socket.IO客户端发送消息或自定义事件，我们需要使用`nsp.to().send()`方法。
- en: Broadcasting messages and custom events to namespaces and rooms
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向命名空间和房间广播消息和自定义事件
- en: Broadcasting is a feature of the Socket.IO server API that lets a `socket` object
    send a message or custom event to everyone in the namespace or room except itself.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 广播是Socket.IO服务器API的一个功能，允许`socket`对象向命名空间或房间中的所有人发送消息或自定义事件，但不能发送给自己。
- en: Broadcasting to a namespace
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向命名空间广播
- en: To broadcast a message to all Socket.IO clients in a namespace, we need to use
    the `socket.broadcast.send()` method, and to broadcast a custom event, we need
    to use the `socket.broadcast.emit()` method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要向命名空间中的所有Socket.IO客户端广播消息，我们需要使用`socket.broadcast.send()`方法，而要广播自定义事件，我们需要使用`socket.broadcast.emit()`方法。
- en: 'Let''s look at an example. Place the following code in the `connection` event
    handler of the default namespace to broadcast a message every time a new Socket.IO
    client joins:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。将以下代码放置在默认命名空间的`connection`事件处理器中，以便每次新的Socket.IO客户端加入时广播一条消息：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, open `http://localhost:8080/` in two different tabs. In the first tab''s
    console, you will see this output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在两个不同的标签页中打开`http://localhost:8080/`。在第一个标签页的控制台中，你会看到以下输出：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the second tab''s console, you will see this output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个标签页的控制台中，你会看到以下输出：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Broadcasting to a room
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向房间广播
- en: To broadcast a message to all Socket.IO clients in a room, we need to use the
    `socket.broadcast.to().send()` method, and to broadcast a custom event, we need
    to use the `socket.broadcast.to.emit()` method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要向房间中的所有Socket.IO客户端广播消息，我们需要使用`socket.broadcast.to().send()`方法，而要广播自定义事件，我们需要使用`socket.broadcast.to.emit()`方法。
- en: 'Place this code inside the default and `/custom-namespace` namespaces'' `connection`
    event handlers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放置在默认和`/custom-namespace`命名空间的`connection`事件处理器中：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, as soon as a Socket.IO client is connected, it sends a message to everyone
    else in the room.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一旦Socket.IO客户端连接，它就会向房间中的其他人发送消息。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that a Socket.IO client doesn't have to be a member of a room to broadcast
    a message to its Socket.IO clients.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Socket.IO客户端不必是房间的成员即可向其客户端广播消息。
- en: Middleware in Socket.IO
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socket.IO中的中间件
- en: Middleware in Socket.IO server is a callback that's executed when a Socket.IO
    client makes a handshake request, before the Socket.IO server replies to it. Middleware
    allows us to allow or reject handshakes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器中的中间件是一个在Socket.IO客户端发起握手请求时执行的回调，在Socket.IO服务器回复它之前。中间件允许我们允许或拒绝握手。
- en: The middleware concept of Socket.IO is similar to that of Express, but the difference
    is that the middleware doesn't get access to the HTTP response object; also, the
    `parameter` signature is different. Therefore, Express middleware cannot be used
    in Socket.IO.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO的中间件概念与Express类似，但不同之处在于中间件无法访问HTTP响应对象；此外，`parameter`签名也不同。因此，Express中间件不能在Socket.IO中使用。
- en: 'An instance of middleware is attached to a specific namespace. Here is a basic
    example that demonstrates how to register a middleware instance with all namespaces.
    Place this code in the `Socket.IO` file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的一个实例附加到特定的命名空间。以下是一个基本示例，演示了如何将中间件实例注册到所有命名空间中。将此代码放置在`Socket.IO`文件中：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we can see that we need to use the `io.use()` method to register a middleware
    instance with all namespaces. To attach middleware to the `/custom-namespace`
    namespace, we can use the `nsp.use()` method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们需要使用`io.use()`方法将中间件实例注册到所有命名空间中。要将中间件附加到`/custom-namespace`命名空间，我们可以使用`nsp.use()`方法。
- en: Disconnecting manually
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动断开连接
- en: You can also manually disconnect a Socket.IO connection. To disconnect from
    the client side, you need to use the `disconnect()` method of the `io` instance.
    To disconnect from the server side, you need to use the `socket.disconnect()`
    method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以手动断开Socket.IO连接。要从客户端断开连接，你需要使用`io`实例的`disconnect()`方法。要从服务器端断开连接，你需要使用`socket.disconnect()`方法。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the fundamentals of the WebSocket protocol. We learned
    about its relationship with HTTP and how it behaves with proxies, load balancers,
    and firewalls. Then, we jumped into the Socket.IO library, which primarily uses
    WebSocket to achieve bidirectional full-duplex communication in real time. You
    should be comfortable with implementing bidirectional communication between a
    browser and a Node.js server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了WebSocket协议的基础知识。我们了解了它与HTTP的关系以及它与代理、负载均衡器和防火墙的交互方式。然后，我们深入了解了Socket.IO库，该库主要使用WebSocket在实时中实现双向全双工通信。你应该能够舒适地实现浏览器和Node.js服务器之间的双向通信。
- en: In the next chapter, we will build a real-world application using Socket.IO.
    You will learn more advanced things, such as integrating a Socket.IO server with
    an Express server and checking authentication before connecting to a WebSocket
    server.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Socket.IO构建一个真实世界的应用程序。你将学习更多高级的内容，例如将Socket.IO服务器与Express服务器集成，并在连接到WebSocket服务器之前检查身份验证。
