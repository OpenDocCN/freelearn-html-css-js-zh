- en: Setting up Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Node.js
- en: Before getting started with using Node.js, you must set up your development
    environment. In the following chapters, we'll use this for development and for non-production
    deployment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用Node.js之前，你必须设置你的开发环境。在接下来的章节中，我们将使用它进行开发和非生产部署。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to install Node.js from source and prepackaged binaries on Linux, macOS,
    or Windows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Linux、macOS或Windows上从源代码和预包装的二进制文件安装Node.js
- en: How to install **Node Package Manager** (**NPM**) and some popular tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装**Node包管理器**（**NPM**）和一些流行工具
- en: The Node.js module system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js模块系统
- en: Node.js and JavaScript language improvements from the ECMAScript committee
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js和JavaScript语言从ECMAScript委员会的改进
- en: So let's get on with it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧。
- en: System requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统要求
- en: Node.js runs on POSIX-like operating systems, various UNIX derivatives (Solaris,
    for example) or workalikes (Linux, macOS, and so on), as well as on Microsoft
    Windows. It can run on machines both large and small, including the tiny ARM devices
    such as the Raspberry Pi microscale embeddable computer for DIY software/hardware
    projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js运行在POSIX-like操作系统上，包括各种UNIX衍生版本（例如Solaris）或类似系统（Linux、macOS等），以及Microsoft
    Windows。它可以在大小不同的机器上运行，包括微小的ARM设备，如用于DIY软件/硬件项目的Raspberry Pi微嵌入式计算机。
- en: Node.js is now available via package management systems, limiting the need to
    compile and install from source.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js现在可以通过包管理系统获得，这减少了从源代码编译和安装的需求。
- en: Because many Node.js packages are written in C or C++, you must have a C compiler
    (such as GCC), Python 2.7 (or later), and the `node-gyp` package. If you plan
    to use encryption in your networking code, you will also need the OpenSSL cryptographic
    library. The modern UNIX derivatives almost certainly come with these, and Node.js's
    configure script, used when installing from source, will detect their presence.
    If you need to install them, Python is available at [http://python.org](http://python.org)
    and OpenSSL is available at [http://openssl.org](http://openssl.org).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多Node.js包是用C或C++编写的，你必须有一个C编译器（如GCC），Python 2.7（或更高版本）和`node-gyp`包。如果你计划在网络代码中使用加密，你还需要OpenSSL加密库。现代UNIX衍生版本几乎都包含这些，Node.js的配置脚本，在从源代码安装时使用，将检测它们的存在。如果你需要安装它们，Python可以在[http://python.org](http://python.org)获取，OpenSSL可以在[http://openssl.org](http://openssl.org)获取。
- en: Installing Node.js using package managers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包管理器安装Node.js
- en: The preferred method for installing Node.js, now, is to use the versions available
    in package managers, such as `apt-get`, or MacPorts. Package managers simplify
    your life by helping to maintain the current version of the software on your computer,
    ensuring to update dependent packages as necessary, all by typing a simple command
    such as `apt-get update`. Let's go over this first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装Node.js的首选方法是使用包管理器中可用的版本，例如`apt-get`或MacPorts。包管理器通过帮助维护计算机上软件的当前版本，确保按需更新依赖包，通过输入简单的命令（如`apt-get
    update`）来简化你的生活。让我们首先来了解一下这一点。
- en: Installing on macOS with MacPorts
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MacPorts在macOS上安装
- en: 'The MacPorts project ([http://www.macports.org/](http://www.macports.org/))
    has for years been packaging a long list of open source software packages for
    macOS, and they have packaged Node.js. After you have installed MacPorts using
    the installer on their website, installing Node.js is pretty much this simple:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MacPorts项目([http://www.macports.org/](http://www.macports.org/))多年来一直在为macOS打包大量开源软件包，他们也打包了Node.js。在你使用他们网站上的安装程序安装MacPorts之后，安装Node.js基本上是这样的简单：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing on macOS with Homebrew
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Homebrew在macOS上安装
- en: 'Homebrew is another open source software package manager for macOS, which some
    say is the perfect replacement for MacPorts. It is available through their home
    page at [http://brew.sh/](http://brew.sh/). After installing Homebrew using the
    instructions on their website and ensuring that Homebrew is correctly set up,
    use the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew是另一个适用于macOS的开源软件包管理器，有人说它是MacPorts的完美替代品。它可以通过他们的主页[http://brew.sh/](http://brew.sh/)获取。按照他们网站上的说明安装Homebrew，并确保Homebrew正确设置后，使用以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, install it this way:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式安装：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once installed this way, the Node.js command can be run as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以这种方式安装，就可以按照以下方式运行Node.js命令：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Installing on Linux, *BSD, or Windows from package management systems
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从包管理系统在Linux、*BSD或Windows上安装
- en: Node.js is now available through most of the package management systems. Instructions
    on the Node.js website currently list packaged versions of Node.js for a long
    list of Linux, as well as FreeBSD, OpenBSD, NetBSD, macOS, and even Windows. Visit
    [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)
    for more information.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 现在通过大多数包管理系统提供。Node.js 网站上的说明目前列出了适用于大量 Linux、FreeBSD、OpenBSD、NetBSD、macOS
    甚至 Windows 的 Node.js 打包版本。有关更多信息，请访问 [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)。
- en: 'For example, on Debian and other Debian-based Linux distro''s (such as Ubuntu),
    use the following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Debian 和其他基于 Debian 的 Linux 发行版（如 Ubuntu）上，使用以下命令：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To download other Node.js versions (this example shows version 10.x), modify
    the URL to suit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载其他 Node.js 版本（此示例显示版本 10.x），修改 URL 以适应。
- en: Installing Node.js in the Windows Subsystem for Linux (WSL)
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows Subsystem for Linux (WSL) 中安装 Node.js
- en: The **Windows Subsystem for Linux** (**WSL**) lets you install Ubuntu, openSUSE,
    or SUSE Linux Enterprise on Windows. All three are available via the Store built
    into Windows 10\. You may need to update your Windows for the installation to
    work.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows Subsystem for Linux** (**WSL**) 允许您在 Windows 上安装 Ubuntu、openSUSE
    或 SUSE Linux Enterprise。这三个都可通过 Windows 10 内置的商店获得。您可能需要更新 Windows 以使安装生效。'
- en: Once installed, the Linux-specific instructions will install Node.js within
    the Linux subsystem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，Linux 特定的说明将在 Linux 子系统中安装 Node.js。
- en: To install the WSL, see [https://msdn.microsoft.com/en-us/commandline/wsl/install-win10](https://msdn.microsoft.com/en-us/commandline/wsl/install-win10).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 WSL，请参阅 [https://msdn.microsoft.com/en-us/commandline/wsl/install-win10](https://msdn.microsoft.com/en-us/commandline/wsl/install-win10)。
- en: Opening an administrator-privileged PowerShell on Windows
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上打开具有管理员权限的 PowerShell
- en: Some of the commands you'll run while installing tools on Windows are to be
    executed in a PowerShell window with elevated privileges. We mention this because
    the process of enabling the WSL includes a command to be run in such a PowerShell
    window.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装工具时，您将运行的某些命令需要在具有提升权限的 PowerShell 窗口中执行。我们提到这一点是因为启用 WSL 的过程包括在这样一个
    PowerShell 窗口中运行的命令。
- en: 'The process is simple:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程很简单：
- en: In the Start menu, enter PowerShell in the applications search box.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始菜单中，在应用程序搜索框中输入 PowerShell。
- en: The resultant menu will list PowerShell.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果菜单将列出 PowerShell。
- en: Right-click the PowerShell entry.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 PowerShell 条目。
- en: The context menu that comes up will have an entry Run as Administrator. Click
    on that.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出的上下文菜单将有一个“以管理员身份运行”的条目。点击它。
- en: 'The resultant command window will have administrator privileges, and the title
    bar will say Administrator: Windows PowerShell.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果命令窗口将具有管理员权限，标题栏将显示为管理员：Windows PowerShell。
- en: Installing the Node.js distribution from nodejs.org
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 nodejs.org 安装 Node.js 发行版
- en: 'The [https://nodejs.org/en/](https://nodejs.org/en/) website offers built-in
    binaries for Windows, macOS, Linux, and Solaris. We can simply go to the website,
    click on the Install button, and run the installer. For systems with package managers,
    such as the ones we''ve just discussed, it''s preferable to use the package management
    system. That''s because you''ll find it easier to stay up-to-date with the latest
    version. But, that doesn''t serve all people because:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://nodejs.org/en/](https://nodejs.org/en/) 网站为 Windows、macOS、Linux 和
    Solaris 提供了内置的二进制文件。我们只需访问网站，点击安装按钮，然后运行安装程序。对于具有包管理器的系统，例如我们刚才讨论的系统，最好使用包管理系统。这是因为你会发现保持最新版本更容易。但是，这并不适用于所有人，因为：'
- en: Some will prefer to install a binary rather than deal with the package manager
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人可能更愿意安装二进制文件而不是处理包管理器
- en: Their chosen system doesn't have a package management system
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的系统没有包管理器
- en: The Node.js implementation in their package management system is out-of-date
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的包管理系统中的 Node.js 实现已过时
- en: 'Simply go to the Node.js website and you''ll see something like the following
    screenshot. The page does its best to determine your OS and supply the appropriate
    download. If you need something different, click on the DOWNLOADS link in the
    header for all possible downloads:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地访问 Node.js 网站，您会看到如下截图。页面会尽力确定您的操作系统并提供相应的下载。如果您需要其他内容，请点击页眉中的“下载”链接以获取所有可能的下载：
- en: '![](img/ffdbcc7f-0d3c-4da4-8ecf-62b4826a0a24.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffdbcc7f-0d3c-4da4-8ecf-62b4826a0a24.png)'
- en: For macOS, the installer is a `PKG` file giving the typical installation process.
    For Windows, the installer simply takes you through the typical Install Wizard
    process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS，安装程序是一个 `PKG` 文件，提供了典型的安装过程。对于 Windows，安装程序只是带你通过典型的安装向导过程。
- en: Once finished with the installer, you have command-line tools, such as `node`
    and `npm`, with which you can run Node.js programs. On Windows, you're supplied
    with a version of the Windows command shell preconfigured to work nicely with
    Node.js.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序完成后，你将拥有命令行工具，如 `node` 和 `npm`，你可以使用它们运行 Node.js 程序。在 Windows 上，你将获得一个预先配置好的
    Windows 命令行版本，以便与 Node.js 一起使用。
- en: Installing from source on POSIX-like systems
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 POSIX 类似系统上从源代码安装
- en: 'Installing the prepackaged Node.js distributions is the preferred installation
    method. However, installing Node.js from source is desirable in a few situations:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装预包装的 Node.js 发行版是首选的安装方法。然而，在几种情况下，从源代码安装 Node.js 是可取的：
- en: It can let you optimize the compiler settings as desired
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以让你根据需要优化编译器设置
- en: It can let you cross-compile, say, for an embedded ARM system
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以让你交叉编译，例如，用于嵌入式 ARM 系统
- en: You might need to keep multiple Node.js builds for testing
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能需要保留多个 Node.js 构建，以便进行测试
- en: You might be working on Node.js itself
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能正在处理 Node.js 本身
- en: Now that you have the high-level view, let's get our hands dirty mucking around
    in some build scripts. The general process follows the usual `configure`, `make`,
    and `make install` routine that you may already have performed with other open
    source software packages. If not, don't worry, we'll guide you through the process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对整体有了了解，让我们动手处理一些构建脚本。一般过程遵循你可能已经对其他开源软件包执行过的常规 `configure`、`make` 和 `make
    install` 流程。如果没有，不要担心，我们会引导你完成这个过程。
- en: The official installation instructions are in the `README.md` contained within
    the source distribution at [https://github.com/nodejs/node/blob/master/README.md](https://github.com/nodejs/node/blob/master/README.md).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 官方安装说明包含在源代码分布中的 `README.md` 文件中，地址为 [https://github.com/nodejs/node/blob/master/README.md](https://github.com/nodejs/node/blob/master/README.md)。
- en: Installing prerequisites
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装先决条件
- en: 'There are three prerequisites: a C compiler, Python, and the OpenSSL libraries.
    The Node.js compilation process checks for their presence and will fail if the
    C compiler or Python is not present. The specific method of installing these is
    dependent on your operating system.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个先决条件：C 编译器、Python 和 OpenSSL 库。Node.js 编译过程会检查它们的存在，如果 C 编译器或 Python 不存在，则会失败。安装这些软件的具体方法取决于你的操作系统。
- en: 'These sorts of commands will check for their presence:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这类命令将检查它们的存在：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See this for details: [https://github.com/nodejs/node/blob/master/BUILDING.md](https://github.com/nodejs/node/blob/master/BUILDING.md).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息请参阅：[https://github.com/nodejs/node/blob/master/BUILDING.md](https://github.com/nodejs/node/blob/master/BUILDING.md)。
- en: The Node.js build tools do not support Python 3.x.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 构建工具不支持 Python 3.x。
- en: Installing developer tools on macOS
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 macOS 上安装开发者工具
- en: Developer tools (such as GCC) are an optional installation on macOS. Fortunately,
    they're easy to acquire.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者工具（如 GCC）在 macOS 上是可选安装。幸运的是，它们很容易获取。
- en: 'You start with Xcode, which is available for free through the Mac App Store.
    Simply search for Xcode and click on the Get button. Once you have Xcode installed,
    open a Terminal window and type the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你从 Xcode 开始，它可以通过 Mac App Store 免费获取。只需搜索 Xcode 并点击获取按钮。安装 Xcode 后，打开一个终端窗口并输入以下命令：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This installs the Xcode command-line tools:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 Xcode 命令行工具：
- en: '![](img/3094a2d2-ccb5-4c1b-8234-878a78d6463a.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3094a2d2-ccb5-4c1b-8234-878a78d6463a.png)'
- en: For additional information, visit [http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/](http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多信息，请访问 [http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/](http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/)。
- en: Installing from source for all POSIX-like systems
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在所有 POSIX 类似系统上从源代码安装
- en: 'Compiling Node.js from source follows this process:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码编译 Node.js 的过程如下：
- en: Download the source from
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下地址下载源代码：
- en: '[http://nodejs.org/download.](http://nodejs.org/download)Configure the source
    for building using `./configure`.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[http://nodejs.org/download.](http://nodejs.org/download) 使用 `./configure`
    配置源代码以进行构建。'
- en: Run `make`, then `make install`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `make`，然后 `make install`。
- en: 'The source bundle can be downloaded with your browser, or as follows, substituting
    your preferred version:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包可以通过浏览器下载，或者如下所示，替换为你喜欢的版本：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we configure the source so that it can be built. This is just like many
    other open source packages, and there are a long list of options to customize
    the build:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们配置源，以便可以构建。这就像许多其他开源软件包一样，有一长串选项可以自定义构建：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To cause the installation to land in your home directory, run it this way:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使安装位于你的主目录中，请按以下方式运行：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you''re going to install multiple Node.js versions side by side, it''s useful
    to put the version number in the path like this. That way, each version will sit
    in a separate directory. It''s a simple matter of switching between Node.js versions
    by changing the `PATH` variable appropriately:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算并行安装多个 Node.js 版本，将版本号放入路径中很有用，如下所示。这样，每个版本都将位于单独的目录中。通过适当地更改 `PATH` 变量，可以简单地切换
    Node.js 版本：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A simpler way to install multiple Node.js versions is the `nvm` script described
    later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装多个 Node.js 版本的更简单方法是后面描述的 `nvm` 脚本。
- en: If you want to install Node.js in a system-wide directory, simply leave off
    the `--prefix` option and it will default to installing in `/usr/local`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在系统目录中安装 Node.js，只需省略 `--prefix` 选项，它将默认安装到 `/usr/local`。
- en: After a moment, it'll stop and will likely have successfully configured the
    source tree for installation in your chosen directory. If this doesn't succeed,
    the error messages that are printed will describe what needs to be fixed. Once
    the configure script is satisfied, you can go on to the next step.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，它将停止，并且很可能已成功配置源树以在所选目录中安装。如果这没有成功，打印的错误信息将描述需要解决的问题。一旦配置脚本满意，你可以继续下一步。
- en: 'With the configure script satisfied, you compile the software:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 配置脚本满意后，编译软件：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you are installing into a system-wide directory, do the last step this way
    instead:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在系统目录中安装，请按以下方式执行最后一步：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once installed, you should make sure that you add the installation directory
    to your `PATH` variable as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你应该确保将安装目录添加到你的 `PATH` 变量中，如下所示：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, for `csh` users, use this syntax to make an exported environment
    variable:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `csh` 用户，使用以下语法来创建一个导出的环境变量：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This should result in some directories, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成以下目录：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Installing from source on Windows
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上从源安装
- en: 'The `BUILDING.md` document referenced previously has instructions. One uses
    the build tools from Visual Studio, or else the full Visual Studio 2017 product:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前引用的 `BUILDING.md` 文档中有说明。一种方法是使用 Visual Studio 的构建工具，或者使用完整的 Visual Studio
    2017 产品：
- en: Visual Studio 2017: [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017: [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)
- en: Build tools: [https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具: [https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
- en: 'Three additional tools are required:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 需要三个额外的工具：
- en: Git for Windows: [http://git-scm.com/download/win](http://git-scm.com/download/win)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git for Windows: [http://git-scm.com/download/win](http://git-scm.com/download/win)
- en: Python: [https://www.python.org/](https://www.python.org/)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python: [https://www.python.org/](https://www.python.org/)
- en: OpenSSL: [https://www.openssl.org/source/](https://www.openssl.org/source/) and [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL: [https://www.openssl.org/source/](https://www.openssl.org/source/) 和 [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)
- en: Then, run the included `.\vcbuild` script to perform the build.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行包含的 `.\vcbuild` 脚本来执行构建。
- en: Installing multiple Node.js instances with nvm
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nvm 安装多个 Node.js 实例
- en: Normally, you won't install multiple versions of Node.js and doing so adds complexity
    to your system. But if you are hacking on Node.js itself, or are testing your
    software against different Node.js releases, you may want to have multiple Node.js
    installations. The method to do so is a simple variation on what we've already
    discussed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会安装多个 Node.js 版本，这样做会增加系统的复杂性。但是，如果你正在修改 Node.js 本身，或者正在针对不同的 Node.js 发布版测试你的软件，你可能希望拥有多个
    Node.js 安装。这样做的方法是我们已经讨论过的简单变体。
- en: Earlier, while discussing building Node.js from source, we noted that one can
    install multiple Node.js instances in separate directories. It's only necessary
    to build from source if you need a customized Node.js build, and most folks will
    be satisfied with pre-built Node.js binaries. They, too, can be installed into
    separate directories.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论从源代码构建 Node.js 时，我们提到可以在不同的目录中安装多个 Node.js 实例。只有当你需要自定义 Node.js 构建，大多数人会满足于预构建的
    Node.js 二进制文件。它们也可以安装到不同的目录中。
- en: 'To switch between Node.js versions is simply a matter of changing the `PATH`
    variable (on POSIX systems), as follows, using the directory where you installed
    Node.js:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Node.js 版本之间切换，只需更改 `PATH` 变量（在 POSIX 系统上），如下所示，使用你安装 Node.js 的目录：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It starts to be a little tedious to maintain this after a while. For each release,
    you have to set up Node.js, NPM, and any third-party modules you desire in your
    Node.js installation. Also, the command shown to change your `PATH` is not quite
    optimal. Inventive programmers have created several version managers to simplify
    managing multiple Node.js/NPM releases and providing commands to change your `PATH`
    the smart way:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一段时间后，维护这些内容开始变得有点繁琐。对于每个发布版，你都必须在你的 Node.js 安装中设置 Node.js、NPM 以及你想要的任何第三方模块。此外，显示用于更改
    `PATH` 的命令并不十分理想。富有创造力的程序员们已经创建了几个版本管理器，以简化管理多个 Node.js/NPM 发布版，并提供智能方式更改 `PATH`
    的命令：
- en: Node version manager: [https://github.com/tj/n](https://github.com/tj/n)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 版本管理器：[https://github.com/tj/n](https://github.com/tj/n)
- en: Node version manager: [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 版本管理器：[https://github.com/creationix/nvm](https://github.com/creationix/nvm)
- en: Both maintain multiple simultaneous versions of Node and let you easily switch
    between versions. Installation instructions are available on their respective
    websites.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都维护多个同时运行的 Node 版本，并允许你轻松地在版本之间切换。安装说明可在它们各自的网站上找到。
- en: 'For example, with `nvm`, you can run commands like these:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 `nvm`，你可以运行以下命令：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This demonstrates that you can have a system-wide Node.js installed, keep multiple
    private Node.js versions managed by `nvm`, and switch between them as needed.
    When new Node.js versions are released, they are simple to install with `nvm`
    even if the official packaged version for your OS doesn't immediately update.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你可以安装一个系统范围内的 Node.js，同时使用 `nvm` 管理多个私有 Node.js 版本，并在需要时切换它们。当新的 Node.js
    版本发布时，使用 `nvm` 安装它们非常简单，即使你的操作系统官方打包版本没有立即更新。
- en: Installing nvm on Windows
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 nvm
- en: 'Unfortunately, `nvm` does not support Windows. Fortunately, a couple of Windows-specific
    clones of the `nvm` concept exist:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`nvm` 不支持 Windows。幸运的是，存在几个针对 Windows 的 `nvm` 概念的特定克隆：
- en: '[https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)'
- en: '[https://github.com/marcelklehr/nodist](https://github.com/marcelklehr/nodist)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/marcelklehr/nodist](https://github.com/marcelklehr/nodist)'
- en: Another route is to use the WSL. Because in WSL you're interacting with a Linux
    command line, you can use `nvm` itself.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 WSL。因为在 WSL 中，你是在与 Linux 命令行交互，所以你可以使用 `nvm` 本身。
- en: Many of the examples in this book were tested using the `nvm-windows` application.
    There are slight behavior differences, but it acts largely the same as `nvm` for
    Linux and macOS. The biggest change is the version number specifier in the `nvm
    use` and `nvm install` commands.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多示例都是使用 `nvm-windows` 应用程序测试的。它们的行为略有不同，但与 Linux 和 macOS 上的 `nvm` 大致相同。最大的变化是
    `nvm use` 和 `nvm install` 命令中的版本号指定符。
- en: With `nvm` for Linux and macOS one can type a simple version number, like `nvm
    use 8`, and it will automatically substitute the latest release of the named Node.js
    version. With `nvm-windows` the same command acts as if you typed "`nvm use 8.0.0`".
    In other words, with `nvm-windows` you must use the exact version number. Fortunately,
    the list of supported versions is easily available using the "`nvm list available`"
    command.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 上使用 `nvm`，你可以输入一个简单的版本号，例如 `nvm use 8`，它将自动替换指定 Node.js 版本的最新发布版。使用
    `nvm-windows`，相同的命令会像你输入了 "`nvm use 8.0.0`" 一样执行。换句话说，使用 `nvm-windows`，你必须使用确切的版本号。幸运的是，使用
    "`nvm list available`" 命令可以轻松地获取支持的版本列表。
- en: Native code modules and node-gyp
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生代码模块和 node-gyp
- en: While we won't discuss native code module development in this book, we do need
    to make sure that they can be built. Some modules in the NPM repository are native
    code, and they must be compiled with a C or C++ compiler to build the corresponding `.node` files 
    (the `.node` extension is used for binary native-code modules).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这本书中不会讨论原生代码模块的开发，但我们确实需要确保它们可以被构建。NPM仓库中的一些模块是原生代码，它们必须使用C或C++编译器编译以生成相应的`.node`文件（`.node`扩展名用于二进制原生代码模块）。
- en: The module will often describe itself as a wrapper for some other library. For
    example, the `libxslt` and `libxmljs` modules are wrappers around the C/C++ libraries
    of the same name. The module includes the C/C++ source code, and when installed,
    a script is automatically run to do the compilation with `node-gyp`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通常会将自己描述为其他库的包装器。例如，`libxslt`和`libxmljs`模块是同名C/C++库的包装器。模块包含C/C++源代码，并且在安装时，会自动运行一个脚本来使用`node-gyp`进行编译。
- en: The `node-gyp` tool is a cross-platform command-line tool written in Node.js
    for compiling native add-on modules for Node.js. We've mentioned native code modules
    several times, and it is this tool that compiles them for use with Node.js.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`node-gyp`工具是一个用Node.js编写的跨平台命令行工具，用于编译Node.js的原生插件模块。我们已经多次提到原生代码模块，这正是用于将它们编译用于Node.js的工具。'
- en: 'You can easily see this in action by running these commands:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令轻松看到这一过程：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is done in a temporary directory, so you can delete it afterward. If your
    system does not have the tools installed to compile native code modules, you'll
    see error messages. Otherwise, you'll see in the output a `node-gyp` execution,
    followed by many lines of text obviously related to compiling C/C++ files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在一个临时目录中完成的，因此您可以在之后删除它。如果您的系统没有安装用于编译原生代码模块的工具，您将看到错误信息。否则，您将在输出中看到一个`node-gyp`执行过程，后面跟着许多与编译C/C++文件明显相关的文本行。
- en: 'The `node-gyp` tool has prerequisites similar to those for compiling Node.js
    from source. Namely, a C/C++ compiler, a Python environment, and other build tools
    such as Git. For Unix/macOS/Linux systems those are easy to come by. For Windows,
    you should install:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`node-gyp`工具的先决条件类似于从源代码编译Node.js的先决条件。具体来说，需要一个C/C++编译器、一个Python环境以及其他构建工具，如Git。对于Unix/macOS/Linux系统，这些工具很容易获得。对于Windows系统，您应该安装：'
- en: Visual Studio Build Tools: [https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio构建工具：[https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
- en: Git for Windows: [http://git-scm.com/download/win](http://git-scm.com/download/win)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows版的Git：[http://git-scm.com/download/win](http://git-scm.com/download/win)
- en: Python for Windows: [https://www.python.org/](https://www.python.org/)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows版的Python：[https://www.python.org/](https://www.python.org/)
- en: Normally, you won't need to worry about installing `node-gyp`. That's because
    it is installed behind the scenes as part of NPM. That's done so that NPM can
    automatically build native code modules.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不需要担心安装`node-gyp`。这是因为它作为NPM的一部分在幕后安装。这样做是为了让NPM能够自动构建原生代码模块。
- en: Its GitHub repository contains documentation at [https://github.com/nodejs/node-gyp](https://github.com/nodejs/node-gyp).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它的GitHub仓库包含在[https://github.com/nodejs/node-gyp](https://github.com/nodejs/node-gyp)上的文档。
- en: Reading the `node-gyp` documentation, in its repository, will give you a clearer
    understanding of the compilation prerequisites discussed previously, as well as
    of developing native code modules.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读其仓库中的`node-gyp`文档，将使您对之前讨论的编译先决条件以及原生代码模块的开发有更清晰的理解。
- en: Node.js versions policy and what to use
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js版本策略和应使用哪个版本
- en: We just threw around so many different Node.js version numbers in the previous
    section that you may have become confused over which version to use. This book
    is targeting Node.js version 10.x, and it's expected that everything we'll cover
    is compatible with Node.js 10.x and any subsequent release.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到了许多不同的Node.js版本号，您可能对应该使用哪个版本感到困惑。本书的目标是Node.js版本10.x，并且预计我们将涵盖的所有内容都与Node.js
    10.x及其后续版本兼容。
- en: Starting with Node.js 4.x, the Node.js team is following a dual-track approach.
    The even-numbered releases (4.x, 6.x, 8.x, and so on) are what they're calling
    **Long Term Support** (**LTS**), while the odd-numbered releases (5.x, 7.x, 9.x,
    and so on) are where current new feature development occurs. While the development
    branch is kept stable, the LTS releases are positioned as being for production
    use and will receive updates for several years.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Node.js 4.x 开始，Node.js 团队采用了一种双轨方法。偶数版本的发布（4.x、6.x、8.x 等等）被称为**长期支持**（**LTS**），而奇数版本的发布（5.x、7.x、9.x
    等等）是当前新功能开发的地方。虽然开发分支保持稳定，但 LTS 发布版定位为生产使用，并将接收多年的更新。
- en: At the time of writing, Node.js 8.x is the current LTS release; Node.js 9.x
    was just released and will eventually become Node.js 10.x, which in turn will
    eventually become the LTS release. For complete details about the release schedule,
    refer to [https://github.com/nodejs/LTS/](https://github.com/nodejs/LTS/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Node.js 8.x 是当前的长期支持（LTS）版本；Node.js 9.x 刚刚发布，最终将成为 Node.js 10.x，而 Node.js
    10.x 最终将成为 LTS 版本。关于发布计划的完整详情，请参阅 [https://github.com/nodejs/LTS/](https://github.com/nodejs/LTS/)。
- en: A major impact of each new Node.js release, beyond the usual performance improvements
    and bug fixes, is bringing in the latest V8 JavaScript engine release. In turn,
    this means bringing in more of the ES-2015/2016/2017 features as the V8 team implements
    those features. In Node.js 8.x, `async/await` functions arrived, and in Node.js
    10.x support for the standard ES6 module format has arrived.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每次新的 Node.js 发布都会带来重大影响，除了通常的性能改进和错误修复之外，还会引入最新的 V8 JavaScript 引擎版本。反过来，这也意味着随着
    V8 团队实现这些功能，将引入更多的 ES-2015/2016/2017 特性。在 Node.js 8.x 中，`async/await` 函数出现，而在
    Node.js 10.x 中，对标准 ES6 模块格式的支持也出现了。
- en: A practical consideration is whether a new Node.js release will break your code.
    New language features are always being added as V8 catches up with ECMA Script,
    and the Node.js team sometimes makes breaking changes in the Node.js API. If you've
    tested on one Node.js version, will it work on an earlier version? Will a Node.js
    change break some assumptions we made?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际的考虑因素是新的 Node.js 发布是否会破坏您的代码。随着 V8 追上 ECMAScript，新的语言特性始终在添加，Node.js 团队有时会在
    Node.js API 中进行破坏性更改。如果您在一个 Node.js 版本上进行了测试，它会在更早的版本上工作吗？Node.js 的更改是否会破坏我们做出的某些假设？
- en: The NPM Package Manager helps us ensure that our packages execute on the correct
    Node.js version. This means that we can specify in the `package.json` file, which
    we'll explore in Chapter 3, *Node.js Modules*, the compatible Node.js versions
    for a package.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: NPM 包管理器帮助我们确保我们的包能够在正确的 Node.js 版本上执行。这意味着我们可以在第 3 章中将要探讨的 `package.json` 文件中指定一个包的兼容
    Node.js 版本。
- en: 'We can add an entry to `package.json` as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `package.json` 中添加如下条目：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This means exactly what it implies—that the given package is compatible with
    Node.js version 6.x or later.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它确实意味着所提供的包与 Node.js 6.x 或更高版本兼容。
- en: Of course, your development machine(s) could have several Node.js versions installed.
    You'll need the version your software is declared to support, plus any later versions
    you wish to evaluate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您的开发机器可能安装了多个 Node.js 版本。您需要您的软件声明的支持版本，以及您希望评估的任何后续版本。
- en: Editors and debuggers
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器和调试器
- en: Since Node.js code is JavaScript, any JavaScript-aware editor will be useful.
    Unlike some other languages that are so complex that an IDE with code completion
    is a necessity, a simple programming editor is perfectly sufficient for Node.js
    development.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 代码是 JavaScript，任何具有 JavaScript 意识的编辑器都将是有用的。与一些其他语言如此复杂，以至于需要一个具有代码补全功能的
    IDE 一样，一个简单的编程编辑器对于 Node.js 开发来说就足够了。
- en: 'Two editors are worth calling out because they are written in Node.js: Atom
    and Microsoft Visual Studio Code.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个编辑器值得特别提及，因为它们是用 Node.js 编写的：Atom 和 Microsoft Visual Studio Code。
- en: Atom ([https://atom.io/](https://atom.io/)) bills itself as a hackable editor
    for the 21st century. It is extendable by writing Node.js modules using the Atom
    API, and the configuration files are easily editable. In other words, it's hackable
    in the same way plenty of other editors have been, going back to Emacs, meaning
    one writes a software module to add capabilities to the editor. The Electron framework
    was invented in order to build Atom, and Electron is a super easy way to build
    desktop applications using Node.js.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Atom ([https://atom.io/](https://atom.io/)) 自称为 21 世纪的 hackable 编辑器。它可以通过编写使用
    Atom API 的 Node.js 模块进行扩展，配置文件也易于编辑。换句话说，它以与其他许多编辑器相同的方式 hackable，追溯到 Emacs，这意味着编写一个软件模块来添加编辑器的功能。Electron
    框架是为了构建 Atom 而发明的，Electron 是使用 Node.js 构建桌面应用程序的一个超级简单的方法。
- en: Microsoft Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    is also a hackable editor—well, the home page says extensible and customizable,
    which means the same thing—that is also open source, and is also implemented in
    Electron. But it's not a hollow me-too editor, aping Atom while adding nothing
    of its own.  Instead, Visual Studio Code is a solid programmers editor in its
    own right, bringing interesting functionality to the table.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    也是一个可修改的编辑器——嗯，主页上说是可扩展和可定制的，这意味着相同的意思——它也是开源的，并且是用 Electron 实现的。但它不是一个空洞的模仿编辑器，模仿
    Atom 而不添加任何自己的东西。相反，Visual Studio Code 是一个真正的程序员编辑器，本身就有很多有趣的功能。
- en: As for debuggers, there are several interesting choices. Starting with Node.js
    6.3, the `inspector` protocol made it possible to use the Google Chrome debugger.
    Visual Studio Code has a built-in debugger that also uses the `inspector` protocol.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于调试器，有几个有趣的选择。从 Node.js 6.3 开始，`inspector` 协议使得可以使用 Google Chrome 调试器。Visual
    Studio Code 内置了一个也使用 `inspector` 协议的调试器。
- en: For a full list of debugging options and tools, see [https://nodejs.org/en/docs/guides/debugging-getting-started/](https://nodejs.org/en/docs/guides/debugging-getting-started/).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看调试选项和工具的完整列表，请参阅 [https://nodejs.org/en/docs/guides/debugging-getting-started/](https://nodejs.org/en/docs/guides/debugging-getting-started/)。
- en: Running and testing commands
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和测试命令
- en: Now that you've installed Node.js, we want to do two things—verify that the
    installation was successful, and familiarize you with the command-line tools.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了 Node.js，我们想做两件事——验证安装是否成功，并让你熟悉命令行工具。
- en: Node.js's command-line tools
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 的命令行工具
- en: The basic installation of Node.js includes two commands, `node` and `npm`. We've
    already seen the `node` command in action. It's used either for running command-line
    scripts or server processes. The other, `npm`, is a package manager for Node.js.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的基本安装包括两个命令，`node` 和 `npm`。我们已经看到了 `node` 命令的使用。它用于运行命令行脚本或服务器进程。另一个，`npm`，是
    Node.js 的包管理器。
- en: 'The easiest way to verify that your Node.js installation works is also the
    best way to get help with Node.js. Type the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 验证你的 Node.js 安装是否正常工作的最简单方法也是获取 Node.js 帮助的最佳方式。输入以下命令：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that there are options for both Node.js and V8 (not shown in the previous
    command line). Remember that Node.js is built on top of V8; it has its own universe
    of options that largely focus on details of bytecode compilation or garbage collection
    and heap algorithms. Enter `node --v8-options` to see the full list of them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Node.js 和 V8（在之前的命令行中未显示）都有选项。记住，Node.js 是建立在 V8 之上的；它拥有自己的选项宇宙，主要关注字节码编译或垃圾回收和堆算法的细节。输入
    `node --v8-options` 来查看它们的完整列表。
- en: On the command line, you can specify options, a single script file, and a list
    of arguments to that script. We'll discuss script arguments further in the next
    section, *Running a simple script with Node.js*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，你可以指定选项、单个脚本文件以及该脚本的参数列表。我们将在下一节 *使用 Node.js 运行简单脚本* 中进一步讨论脚本参数。
- en: 'Running Node.js with no arguments plops you into an interactive JavaScript
    shell:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不带参数运行 Node.js 会让你进入一个交互式 JavaScript 命令行界面：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Any code you can write in a Node.js script can be written here. The command
    interpreter gives a good Terminal-oriented user experience and is useful for interactively
    playing with your code. You do play with your code, don't you? Good!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Node.js 脚本中编写的任何代码都可以在这里编写。命令解释器提供了一个良好的面向终端的用户体验，并且对于交互式地玩弄你的代码很有用。你确实在玩你的代码，不是吗？很好！
- en: Running a simple script with Node.js
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 运行简单脚本
- en: Now, let's see how to run scripts with Node.js. It's quite simple; let's start
    by referring to the help message shown previously. The command-line pattern is
    just a script filename and some script arguments, which should be familiar to
    anyone who has written scripts in other languages.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 Node.js 运行脚本。这很简单；让我们先参考之前显示的帮助信息。命令行模式只是一个脚本文件名和一些脚本参数，这对于任何在其他语言中编写过脚本的人来说应该很熟悉。
- en: Creating and editing Node.js scripts can be done with any text editor that deals
    with plain text files, such as VI/VIM, Emacs, Notepad++, Atom, Visual Studio Code,
    Jedit, BB Edit, TextMate, or Komodo. It's helpful if it's a programmer-oriented
    editor, if only for the syntax coloring.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何处理纯文本文件的文本编辑器都可以创建和编辑 Node.js 脚本，例如 VI/VIM、Emacs、Notepad++、Atom、Visual Studio
    Code、Jedit、BB Edit、TextMate 或 Komodo。如果它是一个面向程序员的编辑器，那么语法高亮就很有帮助。
- en: For this and other examples in this book, it doesn't truly matter where you
    put the files. However, for the sake of neatness, you can start by making a directory
    named `node-web-dev` in the home directory of your computer, and inside that creating
    one directory per chapter (for example, `chap02` and `chap03`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的这个和其他示例，文件的位置实际上并不重要。然而，为了整洁起见，你可以在计算机的 home 目录中创建一个名为 `node-web-dev`
    的目录，并在其中为每一章创建一个目录（例如，`chap02` 和 `chap03`）。
- en: 'First, create a text file named `ls.js` with the following content:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `ls.js` 的文本文件，内容如下：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, run it by typing the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过输入以下命令来运行它：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is a pale cheap imitation of the Unix `ls` command (as if you couldn't
    figure that out from the name). The `readdir` function is a close analog to the
    Unix `readdir` system call (type `man 3 readdir` in a Terminal window to learn
    more) and is used to list the files in a directory.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 Unix `ls` 命令的一个肤浅的廉价模仿（好像你从名字中看不出来一样）。`readdir` 函数是 Unix `readdir` 系统调用的近似（在终端窗口中输入
    `man 3 readdir` 以了解更多信息）并用于列出目录中的文件。
- en: We have written this using an inline `async` function, the `await` keyword,
    and an ES2015 `for..of` loop. Using `util.promisify`, we can convert any callback-oriented
    function so it returns a Promise, so that the Promise plays well with the `await`
    keyword.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内联 `async` 函数、`await` 关键字和 ES2015 的 `for..of` 循环来编写这个。使用 `util.promisify`，我们可以将任何回调函数转换为返回
    Promise 的函数，这样 Promise 就可以很好地与 `await` 关键字配合使用。
- en: By default `fs` module functions use the callback paradigm, as does most Node.js
    modules. But within `async` functions it is more convenient if functions instead
    return promises. Using `util.promisify` we can make it so.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`fs` 模块函数使用回调模式，这与大多数 Node.js 模块相同。但在 `async` 函数中，如果函数返回 promises 则更为方便。使用
    `util.promisify` 我们可以实现这一点。
- en: This script is hardcoded to list files in the current directory. The real `ls`
    command takes a directory name, so let's modify the script a little.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本硬编码为列出当前目录中的文件。真正的 `ls` 命令需要一个目录名，所以让我们稍微修改一下脚本。
- en: 'Command-line arguments land in a global array named `process.argv`. Therefore
    we can modify `ls.js`, copying it as `ls2.js`, as follows to see how this array
    works:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数存储在名为 `process.argv` 的全局数组中。因此，我们可以修改 `ls.js`，将其复制为 `ls2.js`，如下所示，以查看这个数组的工作方式：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can run it as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式运行它：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We simply checked if a command-line argument was present, `if (process.argv[2])`.
    If it was, we overrode the value of the `dir` variable, `dir = process.argv[2]`,
    and we then used that as the `readdir` argument.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是检查了命令行参数是否存在，`if (process.argv[2])`。如果存在，我们覆盖了 `dir` 变量的值，`dir = process.argv[2]`，然后我们使用它作为
    `readdir` 参数。
- en: 'If you give it a non-existent directory pathname, an error will be thrown and
    printed using the `catch` clause. That looks like so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给它一个不存在的目录路径名，将会抛出一个错误，并使用 `catch` 子句打印出来。看起来是这样的：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Conversion to async functions and the Promise paradigm
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为异步函数和 Promise 模式
- en: In the previous section we discussed the `util.promisify` and its ability to
    convert a callback-oriented function into one that returns a Promise. The latter
    play well within async functions and therefore it is preferable for functions
    to return a Promise.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了 `util.promisify` 以及其将回调函数转换为返回 Promise 的能力。后者在异步函数中表现良好，因此函数返回 Promise
    是更可取的。
- en: To be more precise, `util.promisify` is to be given a function that uses the
    error-first-callback paradigm. The last argument of such functions is a callback
    function whose first argument is interpreted as an error indicator, hence the
    phrase error-first-callback. What `util.promisify` returns is another function
    that returns a Promise.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，`util.promisify`需要提供一个使用错误优先回调范式的函数。这些函数的最后一个参数是一个回调函数，其第一个参数被解释为错误指示器，因此得名错误优先回调。`util.promisify`返回的函数将返回一个Promise。
- en: The Promise serves the same purpose as the error-first-callback. If an error
    is indicated, the Promise resolves to the rejected status, while if success is
    indicated the Promise resolves to a success status. As we see in these examples,
    within an `async` function the Promise is handled very nicely.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Promise与错误优先回调具有相同的目的。如果指示有错误，Promise将解析为拒绝状态，而如果指示成功，Promise将解析为成功状态。正如我们在这些示例中看到的那样，在`async`函数中，Promise被处理得非常好。
- en: The Node.js ecosystem has a large body of functions using the error-first-callback.
    The community has begun a conversion process where functions will return a Promise,
    and possibly also take an error-first-callback for API compatibility.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js生态系统拥有大量使用错误优先回调的错误处理函数。社区已经开始了一个转换过程，其中函数将返回一个Promise，并且可能也会为了API兼容性而采用错误优先回调。
- en: 'One of the new features in Node.js 10 is an example of such a conversion. Within
    the `fs` module is a submodule, named `fs.promises`, with the same API but producing
    Promise objects. We could rewrite the previous example as so:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 10中的新特性之一就是这样的转换示例。在`fs`模块中有一个子模块，名为`fs.promises`，它具有相同的API但生成Promise对象。我们可以将前面的示例重写如下：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, the functions in the `fs.promises` module returns a Promise
    without requiring a callback function. The new program, which you can save as
    `ls2-promises.js`, is run as so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`fs.promises`模块中的函数在不需要回调函数的情况下返回一个Promise。你可以将新程序保存为`ls2-promises.js`，然后按照以下方式运行：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The API is currently in an experimental state and therefore we're shown this
    warning.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: API目前处于实验状态，因此我们看到了这个警告。
- en: Another choice is a 3rd party module, `fs-extra`. This module has an extended
    API beyond the standard `fs` module. On the one hand its functions return a Promise
    if no callback function is provided, or else invokes the callback. In addition
    it includes several useful functions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是第三方模块`fs-extra`。此模块在标准`fs`模块之外具有扩展的API。一方面，如果未提供回调函数，则其函数返回一个Promise，否则调用回调。此外，它还包括几个有用的函数。
- en: In the rest of this book we will be using `fs-extra` because of those additional
    functions. For documentation of the module, see: [https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用`fs-extra`，因为这些额外的函数。有关模块的文档，请参阅：[https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra)。
- en: Launching a server with Node.js
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js启动服务器
- en: Many scripts that you'll run are server processes. We'll be running lots of
    these scripts later on. Since we're still in the dual mode of verifying the installation
    and familiarizing you with using Node.js, we want to run a simple HTTP server.
    Let's borrow the simple server script on the Node.js home page ([http://nodejs.org](http://nodejs.org)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要运行的许多脚本都是服务器进程。我们将在稍后运行很多这样的脚本。由于我们仍然处于验证安装和让你熟悉使用Node.js的双重模式，我们想要运行一个简单的HTTP服务器。让我们借用Node.js主页上的简单服务器脚本（[http://nodejs.org](http://nodejs.org)）。
- en: 'Create a file named `app.js` containing the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`app.js`的文件，包含以下内容：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run it as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式运行：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is the simplest of web servers you can build with Node.js. If you''re
    interested in how it works, flip forward to [Chapter 4](2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml),
    *HTTP Servers and Clients*; [Chapter 5](e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml),
    *Your First Express Application*; and Chapter 6, *Implementing the Mobile-First
    Paradigm*. For the moment, just visit `http://127.0.0.1:8124` in your browser
    to see the Hello, World! message:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以用Node.js构建的最简单的Web服务器。如果你对它是如何工作的感兴趣，请翻到第4章[2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml]，*HTTP服务器和客户端*；第5章[e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml]，*你的第一个Express应用程序*；以及第6章，*实现移动优先范式*。目前，只需在你的浏览器中访问`http://127.0.0.1:8124`，即可看到Hello,
    World!消息：
- en: '![](img/2e7c2753-e616-42e7-99ac-1ecad972774c.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e7c2753-e616-42e7-99ac-1ecad972774c.png)'
- en: A question to ponder is why this script did not exit when `ls.js` did exit.
    In both cases, execution of the script reaches the end of the script; the Node.js
    process does not exit in `app.js`, while in `ls.js` it does.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得思考的问题是为什么当 `ls.js` 退出时，这个脚本没有退出。在这两种情况下，脚本的执行都达到了脚本的末尾；在 `app.js` 中，Node.js
    进程没有退出，而在 `ls.js` 中则退出了。
- en: The reason is the presence of active event listeners. Node.js always starts
    up an event loop, and in `app.js`, the `listen` function creates an event `listener`
    that implements the HTTP protocol. This event listener keeps `app.js` running
    until you do something such as typing *Ctrl* + *C* in the Terminal window. In
    `ls.js`, there is nothing that creates a long-running event listener, so when
    `ls.js` reaches the end of its script, the `node` process will exit.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于存在活跃的事件监听器。Node.js 总是启动一个事件循环，在 `app.js` 中，`listen` 函数创建了一个实现 HTTP 协议的事件
    `listener`。这个事件监听器使 `app.js` 保持运行，直到你做某些事情，例如在终端窗口中输入 *Ctrl* + *C*。在 `ls.js` 中，没有创建长时间运行的事件监听器的代码，因此当
    `ls.js` 到达其脚本的末尾时，`node` 进程将退出。
- en: NPM – the Node.js package manager
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPM - Node.js 包管理器
- en: Node.js by itself is a pretty basic system, being a JavaScript interpreter with
    a few interesting asynchronous I/O libraries. One of the things that makes Node.js
    interesting is the rapidly growing ecosystem of third-party modules for Node.js.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 本身是一个相当基础的系统，它是一个带有一些有趣的异步 I/O 库的 JavaScript 解释器。使 Node.js 有趣的事情之一是
    Node.js 第三方模块生态系统的快速增长。
- en: At the center of that ecosystem is NPM. While Node.js modules can be downloaded
    as source and assembled manually for use with Node.js programs, that's tedious
    and it's difficult to implement a repeatable build process. NPM gives us a simpler
    way; NPM is the de facto standard package manager for Node.js and it greatly simplifies
    downloading and using these modules. We will talk about NPM at length in the next
    chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个生态系统中心的是 NPM。虽然 Node.js 模块可以作为源代码下载并手动组装以供 Node.js 程序使用，但这很繁琐，并且很难实现可重复的构建过程。NPM
    给我们提供了一个更简单的方法；NPM 是 Node.js 的既定标准包管理器，它极大地简化了下载和使用这些模块的过程。我们将在下一章详细讨论 NPM。
- en: The sharp-eyed will have noticed that `npm` is already installed via all the
    installation methods discussed previously. In the past, `npm` was installed separately,
    but today it is bundled with Node.js.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 留意的人会注意到 `npm` 已经通过之前讨论的所有安装方法安装了。过去，`npm` 是单独安装的，但今天它已经与 Node.js 打包在一起。
- en: 'Now that we have `npm` installed, let''s take it for a quick spin. The **hexy** program
    is a utility for printing hex dumps of files. That''s a very 1970 thing to do,
    but is still extremely useful. It serves our purpose right now in giving us something
    to quickly install and try out:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 `npm`，让我们快速试用一下。**hexy** 程序是一个用于打印文件十六进制转储的实用工具。这是一件非常 1970 年代的事情，但仍然非常有用。它现在为我们提供了快速安装和尝试的东西：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Adding the `-g` flag makes the module available globally, irrespective of the
    present-working-directory of your command shell. A global install is most useful
    when the module provides a command-line interface. When a package provides a command-line
    script, `npm` sets that up. For a global install, the command is installed correctly
    for use by all users of the computer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `-g` 标志可以使模块在命令行 shell 的当前工作目录之外全局可用。全局安装当模块提供命令行界面时最有用。当一个包提供命令行脚本时，`npm`
    会设置它。对于全局安装，命令被正确安装，以便所有计算机用户使用。
- en: 'Depending on how Node.js is installed for you, that may need to be run with
    `sudo`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的 Node.js 安装方式，可能需要使用 `sudo` 运行：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once it is installed, you''ll be able to run the newly–installed program this
    way:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以这样运行新安装的程序：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Again, we'll be doing a deep dive into NPM in the next chapter. The `hexy` utility
    is both a Node.js library and a script for printing out these old-style hex dumps.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将在下一章深入探讨 NPM。**hexy** 实用工具既是 Node.js 库，也是用于打印这些旧式十六进制转储的脚本。
- en: Node.js, ECMAScript 2015/2016/2017, and beyond
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js、ECMAScript 2015/2016/2017 以及更远
- en: In 2015, the ECMAScript committee released a long-awaited major update of the
    JavaScript language. The update brought in many new features to JavaScript, such
    as Promises, arrow functions, and Class objects. The language update set the stage
    for improvements. since that should dramatically improve our ability to write
    clean, understandable JavaScript code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年，ECMAScript 委员会发布了 JavaScript 语言期待已久的重大更新。这次更新为 JavaScript 带来了许多新特性，如
    Promises、箭头函数和类对象。语言更新为改进奠定了基础。这应该会极大地提高我们编写清晰、可理解的 JavaScript 代码的能力。
- en: The browser makers are adding those much-needed features, meaning the V8 engine
    is adding those features as well. These features are making their way into Node.js
    starting with version 4.x.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器制造商正在添加这些迫切需要的特性，这意味着V8引擎也在添加这些特性。这些特性从4.x版本开始进入Node.js。
- en: To learn about the current status of ES-2015 in Node.js, visit [https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Node.js中ES-2015的当前状态，请访问[https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/)。
- en: By default, only the ES-2015/2016/2017 features that V8 considers stable are
    enabled by Node.js. Further features can be enabled with command-line options.
    The almost-complete features are enabled with the `--es_staging` option. The website
    documentation gives more information.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Node.js只启用了V8认为稳定的ES-2015/2016/2017特性。可以通过命令行选项启用更多特性。几乎完整的特性可以通过`--es_staging`选项启用。网站文档提供了更多信息。
- en: The Node green website ([http://node.green/](http://node.green/)) has a table
    listing the status of a long list of features in Node.js versions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Node green网站([http://node.green/](http://node.green/))列出了Node.js版本中大量特性的状态。
- en: 'The ES2017 language spec is published at:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ES2017语言规范发布在：
- en: '[https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm)。'
- en: The TC-39 committee does its work on GitHub [https://github.com/tc39](https://github.com/tc39).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: TC-39委员会在GitHub上完成其工作[https://github.com/tc39](https://github.com/tc39)。
- en: The ES-2015 features make a big improvement in the JavaScript language. One
    feature, the `Promise` class, should mean a fundamental rethinking of common idioms
    in Node.js programming. In ES-2017, a pair of new keywords, `async` and `await`,
    will simplify writing asynchronous code in Node.js, and it should encourage the
    Node.js community to further rethink the common idioms of the platform.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ES-2015特性在JavaScript语言中做出了重大改进。其中一个特性，`Promise`类，应该意味着对Node.js编程中常见惯用的根本性重新思考。在ES-2017中，一对新的关键字`async`和`await`将简化Node.js中的异步代码编写，并应该鼓励Node.js社区进一步重新思考平台上的常见惯用。
- en: There's a long list of new JavaScript features, but let's quickly go over two
    of them that we'll use extensively.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多新的JavaScript特性，但让我们快速浏览其中两个我们将广泛使用的特性。
- en: 'The first is a lighter-weight function syntax called the arrow function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个更轻量级的函数语法，称为箭头函数：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is more than the syntactic sugar of replacing the `function` keyword with
    the fat arrow. Arrow functions are lighter-weight as well as being easier to read.
    The lighter weight comes at the cost of changing the value of `this` inside the
    arrow function. In regular functions, `this` has a unique value inside the function.
    In an arrow function, `this` has the same value as the scope containing the arrow
    function. This means that, when using an arrow function, we don't have to jump
    through hoops to bring `this` into the callback function because `this` is the
    same at both levels of the code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是用肥箭头替换`function`关键字这种语法糖。箭头函数不仅更轻量级，而且更容易阅读。轻量级的代价是改变箭头函数内部`this`的值。在常规函数中，`this`在函数内部有一个独特的值。在箭头函数中，`this`与包含箭头函数的作用域具有相同的值。这意味着，当使用箭头函数时，我们不需要跳过任何障碍来将`this`带入回调函数，因为`this`在代码的两个级别上都是相同的。
- en: 'The next feature is the `Promise` class, which is used for deferred and asynchronous
    computations. Deferred code execution to implement asynchronous behavior is a
    key paradigm for Node.js, and it requires two idiomatic conventions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个特性是`Promise`类，它用于延迟和异步计算。将代码执行延迟以实现异步行为是Node.js的一个关键范式，它需要两个惯用约定：
- en: The last argument to an asynchronous function is a callback function, which
    is called when an asynchronous execution is to be performed
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数的最后一个参数是一个回调函数，当需要进行异步执行时会被调用
- en: The first argument to the callback function is an error indicator
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数的第一个参数是一个错误指示器
- en: 'While convenient, these conventions resulted in multilayer code pyramids that
    can be difficult to understand and maintain:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然方便，但这些约定导致了多层代码金字塔，这可能难以理解和维护：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Depending on how many steps are required for a specific task, a code pyramid
    can get quite deep. Promises will let us unravel the code pyramid and improve
    reliability, because error handling is more straightforward and easily captures
    all errors.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 根据特定任务所需的步骤数量，代码金字塔可以变得相当深。`Promise` 将使我们解开代码金字塔并提高可靠性，因为错误处理更直接且易于捕获所有错误。
- en: 'A `Promise` class is created as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Promise` 类的方式如下：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Rather than passing in a callback function, the caller receives a `Promise`
    object. When properly utilized, the preceding pyramid can be coded as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是传递回调函数，调用者接收一个 `Promise` 对象。当正确使用时，前面的金字塔可以编码如下：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This works because the `Promise` class supports chaining if a `then` function
    returns a `Promise` object.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 `Promise` 类支持链式调用，如果 `then` 函数返回一个 `Promise` 对象。
- en: 'The `async/await` feature implements the promise of the Promise class to simplify
    asynchronous coding. This feature becomes active within an `async` function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`async/await` 特性实现了 `Promise` 类的承诺，以简化异步编程。此特性在 `async` 函数内激活：'
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'An `async` arrow function is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 箭头函数如下：'
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It''s used as so:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方式如下：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Isn't this a breath of fresh air compared to the nested structure we started
    with?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们最初使用的嵌套结构相比，这难道不是一股清新的空气吗？
- en: The `await` keyword is used with a Promise. It automatically waits for the Promise
    to resolve. If the Promise resolves successfully then the value is returned, and
    if it resolves with an error then that error is thrown. Both handling results
    and throwing errors are handled in the natural manner.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 关键字与 `Promise` 一起使用。它自动等待 `Promise` 解决。如果 `Promise` 成功解决，则返回值，如果它以错误解决，则抛出该错误。处理结果和抛出错误都以自然的方式处理。'
- en: 'This example also shows another ES2015 feature: destructuring. The fields of
    an object can be extracted using the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还展示了另一个 ES2015 特性：解构。可以使用以下方式提取对象的字段：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have an object with three fields, but extract only two of the fields.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含三个字段的对象，但只提取其中的两个字段。
- en: Using Babel to use experimental JavaScript features
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Babel 来使用实验性的 JavaScript 特性
- en: The Babel transpiler ([http://babeljs.io/](http://babeljs.io/)) is a great way
    to use cutting-edge JavaScript features on older implementations. The word **transpile**
    means Babel rewrites JavaScript code into other JavaScript code, specifically
    to rewrite ES-2015 or ES-2016 features to older JavaScript code. Babel converts
    JavaScript source to an abstract syntax tree, then manipulates that tree to rewrite
    the code using older JavaScript features, and then writes that tree to a JavaScript
    source code file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 转译器（[http://babeljs.io/](http://babeljs.io/））是使用旧实现上的前沿 JavaScript 特性的绝佳方式。**转译**一词意味着
    Babel 将 JavaScript 代码重写为其他 JavaScript 代码，具体来说，是将 ES-2015 或 ES-2016 特性重写为旧 JavaScript
    代码。Babel 将 JavaScript 源代码转换为抽象语法树，然后操作该树以使用旧 JavaScript 功能重写代码，然后将该树写入 JavaScript
    源代码文件。
- en: Put another way, Babel rewrites JavaScript code into JavaScript code, applying
    desired transformations such as converting ES2015/2016 features into ES5 code
    that can run in a web browser.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Babel 将 JavaScript 代码重写为 JavaScript 代码，应用所需的转换，例如将 ES2015/2016 特性转换为可以在网页浏览器中运行的
    ES5 代码。
- en: Many use Babel to experiment with new JavaScript feature proposals working their
    way through the TC-39 committee. Others use Babel to use new JavaScript features
    in projects on JavaScript engines that do not support those features.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人使用 Babel 来尝试 TC-39 委员会正在推进的新 JavaScript 特性提案。其他人使用 Babel 在不支持这些特性的 JavaScript
    引擎的项目中使用新的 JavaScript 特性。
- en: The Node Green website makes it clear that Node.js supports pretty much all
    of the ES2015/2016/2017 features. Therefore, as a practical matter, we no longer
    need to use Babel for Node.js projects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Node Green 网站明确指出，Node.js 几乎支持所有 ES2015/2016/2017 特性。因此，从实际的角度来看，我们不再需要为 Node.js
    项目使用 Babel。
- en: For web browsers, there is a much longer time lag between a set of ECMAScript
    features and when we can reliably use those features in browser-side code. It's
    not that the web browser makers are slow in adopting new features, because the
    Google, Mozilla, and Microsoft teams are proactive about adopting the latest features.
    Apple's Safari team seems slow to adopt new features, unfortunately. What's slower,
    however, is the penetration of new browsers into the fleet of computers in the
    field.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网页浏览器来说，一组 ECMAScript 特性从提出到我们可以在浏览器端代码中可靠地使用它们之间有一个更长的时间滞后。这并不是因为网页浏览器的制造商在采用新特性方面缓慢，因为
    Google、Mozilla 和 Microsoft 团队都是积极采用最新特性的。不幸的是，苹果的 Safari 团队似乎在采用新特性方面较慢。然而，更慢的是新浏览器在现有计算机群体中的渗透率。
- en: Therefore, modern JavaScript programmers need to familiarize themselves with
    Babel.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现代 JavaScript 程序员需要熟悉 Babel。
- en: We're not ready to show example code for these features, but we can go ahead
    and document the setup of the Babel tool. For further information on setup documentation,
    visit [http://babeljs.io/docs/setup/](http://babeljs.io/docs/setup/), and then
    click on the CLI button.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还没有准备好展示这些功能的示例代码，但我们可以继续记录 Babel 工具的设置。有关设置文档的更多信息，请访问 [http://babeljs.io/docs/setup/](http://babeljs.io/docs/setup/)，然后点击
    CLI 按钮。
- en: To get a brief introduction to Babel, we'll use it to transpile the scripts
    we saw earlier to run on Node.js 6.x. In those scripts we used async functions,
    which are not supported in Node.js 6.x.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简要了解 Babel，我们将使用它来转换我们之前看到的脚本，以便在 Node.js 6.x 上运行。在这些脚本中，我们使用了异步函数，这些函数在 Node.js
    6.x 中不受支持。
- en: 'In the directory containing `ls.js` and `ls2.js`, type these commands:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含 `ls.js` 和 `ls2.js` 的目录中，输入以下命令：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This installs the Babel software, along with a couple of transformation plugins.
    Babel has a plugin system so that you enable the transformations required by your
    project. Our primary goal in this example is converting the `async` functions
    shown earlier into Generator functions. Generators are a new sort of function
    introduced with ES2015, which form the foundation for implementation of `async`
    functions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 Babel 软件，以及一些转换插件。Babel 有一个插件系统，这样您就可以启用项目所需的转换。在这个例子中，我们的主要目标是把之前展示的 `async`
    函数转换为 Generator 函数。Generators 是 ES2015 中引入的一种新类型的函数，它是 `async` 函数实现的基础。
- en: 'Because Node.js 6.x does not have `util.promisify`, we need to make one substitution:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 6.x 没有提供 `util.promisify`，我们需要进行一项替换：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This structure is more or less what the `util.promisify` function does.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构大致就是 `util.promisify` 函数所做的事情。
- en: 'Next, create a file named `.babelrc` containing the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `.babelrc` 的文件，包含以下内容：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This file instructs Babel to use the named transformation plugins that we installed
    earlier.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件指示 Babel 使用我们之前安装的命名转换插件。
- en: 'Because we installed `babel-cli`, a `babel` command is installed such that
    we can type the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们安装了 `babel-cli`，因此安装了一个 `babel` 命令，这样我们就可以输入以下内容：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To transpile your code, run the following command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换您的代码，请运行以下命令：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This command transpiles the named file, producing a new file. The new file
    is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将转换指定的文件，生成一个新文件。新文件如下：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code isn't meant to be easy to read by humans. Instead, it's meant that
    you edit the original source file, and then convert it for your target JavaScript
    engine. The main thing to notice is that the transpiled code uses a Generator
    function in place of the `async` function, and the `yield` keyword in place of
    the `await` keyword. The `_asyncToGenerator` function implements functionality
    similar to async functions.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不是为了让人容易阅读。相反，它是为了编辑原始源文件，然后将其转换为您的目标 JavaScript 引擎。需要注意的是，转换后的代码使用 Generator
    函数代替了 `async` 函数，并使用 `yield` 关键字代替了 `await` 关键字。`_asyncToGenerator` 函数实现了与异步函数类似的功能。
- en: 'The transpiled script is run as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的脚本如下运行：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In other words, it runs the same as the `async` version, but on an older Node.js
    release.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它运行方式与 `async` 版本相同，但是在较旧的 Node.js 版本上。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about installing Node.js, using its command-line
    tools, and running a Node.js server. We also breezed past a lot of details that
    will be covered later in the book, so be patient.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了关于安装 Node.js、使用其命令行工具以及运行 Node.js 服务器的大量知识。我们还快速浏览了许多将在本书后面章节中详细讲解的细节，所以请耐心等待。
- en: Specifically, we covered downloading and compiling the Node.js source code,
    installing Node.js either for development use in your home directory or for deployment
    in system directories and installing NPM—the de facto standard package manager
    used with Node.js. We also saw how to run Node.js scripts or Node.js servers.
    We then took a look at the new features in ES-2015/2016/2017\. Finally, we saw
    how to use Babel to implement those features in your code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了下载和编译 Node.js 源代码，安装 Node.js，无论是用于个人目录中的开发还是部署在系统目录中，以及安装 NPM——与 Node.js
    一起使用的既定标准包管理器。我们还看到了如何运行 Node.js 脚本或 Node.js 服务器。然后，我们查看了一下 ES-2015/2016/2017
    的新特性。最后，我们看到了如何使用 Babel 在你的代码中实现这些特性。
- en: Now that we've seen how to set up the basic system, we're ready to start working
    on implementing applications with Node.js. First, you must learn the basic building
    blocks of Node.js applications and modules, which we will cover in the next chapter.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何设置基本系统，我们就可以开始使用 Node.js 实现应用程序了。首先，你必须学习 Node.js 应用程序和模块的基本构建块，这些内容我们将在下一章中进行讲解。
