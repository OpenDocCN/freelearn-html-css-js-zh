- en: Web Servers in Node
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node中的Web服务器
- en: We'll cover a ton of exciting stuff in this chapter. We'll learn how to make
    a web server and how to integrate version control into Node applications. Now
    to get all this done, we will look at a framework called Express. It's one of
    the most popular npm libraries, and for good reason. It makes it really easy to
    do stuff such as creating a web server or an HTTP API. It's kind of similar to
    the Dark Sky API we used in the last chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖大量令人兴奋的内容。我们将学习如何创建Web服务器，以及如何将版本控制集成到Node应用程序中。现在，为了完成所有这些工作，我们将看一下一个叫做Express的框架。它是最受欢迎的npm库之一，原因很充分。它使得诸如创建Web服务器或HTTP
    API之类的工作变得非常容易。这有点类似于我们在上一章中使用的Dark Sky API。
- en: Now most courses start with Express, and that can be confusing because it blurs
    the line between what is Node and what is Express. We'll kick things off by adding
    Express to a brand new Node app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数课程都是从Express开始的，这可能会让人困惑，因为它模糊了Node和Express之间的界限。我们将通过将Express添加到全新的Node应用程序来开始。
- en: 'Specifically, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: Introducing Express
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Express
- en: Static server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态服务器
- en: Rendering templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染模板
- en: Advanced templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级模板
- en: Middleware
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件
- en: Introducing Express
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Express
- en: In this section, you'll make your very first Node.js web server, which means
    you'll have a whole new way for users to access your app. Instead of having them
    run it from the Terminal passing in arguments, you'll be able to give them a URL
    they can visit to view your web app or a URL they can make an HTTP request to
    to fetch some data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建自己的第一个Node.js Web服务器，这意味着您将有一种全新的方式让用户访问您的应用程序。而不是让他们从终端运行它并传递参数，您可以给他们一个URL，他们可以访问以查看您的Web应用程序，或者一个URL，他们可以发出HTTP请求以获取一些数据。
- en: This will be similar to what we did when we used the geocode API in the previous
    chapters. Instead of using an API though, we'll be able to create our own. We'll
    also be able to set up a static website for something like a portfolio site. Both
    are really valid use cases. Now all of this will be done using a library called
    **Express**, which is the most popular npm library. It's actually one of the reasons
    that Node got so popular because it was so easy to make REST APIs and static web
    servers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这将类似于我们在之前的章节中使用地理编码API时所做的。不过，我们将能够创建自己的API，而不是使用API。我们还将能够为诸如作品集网站之类的静态网站设置一个静态网站。这两者都是非常有效的用例。现在，所有这些都将使用一个叫做**Express**的库来完成，这是最受欢迎的npm库之一。实际上，这是Node变得如此受欢迎的原因之一，因为它非常容易制作REST
    API和静态Web服务器。
- en: Configuring Express
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Express
- en: Express is a no-nonsense library. Now there are a lot of different ways to configure
    it. So it can get pretty complex. That's why we'll be using it throughout the
    next couple of chapters. To get started, let's make a directory where we can store
    all of the code for this app. This app will be our web server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Express是一个直截了当的库。现在有很多不同的配置方式。所以它可能会变得非常复杂。这就是为什么在接下来的几章中我们将使用它的原因。首先，让我们创建一个目录，我们可以在其中存储这个应用程序的所有代码。这个应用程序将是我们的Web服务器。
- en: 'On the desktop let''s us make a directory called `node-web-server`, by running
    the `mkdir node-web-server` command in the Terminal:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面上，让我们通过在终端中运行`mkdir node-web-server`命令来创建一个名为`node-web-server`的目录：
- en: '![](img/a662a1c0-9b49-4917-b238-f538d270a209.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a662a1c0-9b49-4917-b238-f538d270a209.png)'
- en: 'Once this directory is created, we''ll navigate into it using `cd`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了这个目录后，我们将使用`cd`进入其中：
- en: '![](img/6e79ccf4-fe81-4cc3-a8ae-5f3562f4c0b1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e79ccf4-fe81-4cc3-a8ae-5f3562f4c0b1.png)'
- en: 'And we''ll also open it up inside Atom. In Atom, we''ll open it up from the
    desktop:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在Atom中打开它。在Atom中，我们将从桌面打开它：
- en: '![](img/9e35a36f-c099-4baa-848d-27aed99c5b2a.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e35a36f-c099-4baa-848d-27aed99c5b2a.png)'
- en: 'Now before going further, we''ll run the `npm init` command so we can generate
    the `package.json` file. As shown in the following code, we''ll run `npm init`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将运行`npm init`命令，以便生成`package.json`文件。如下所示，我们将运行`npm init`：
- en: '![](img/3bb36f99-9a07-444b-964e-1082a4c91ba9.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bb36f99-9a07-444b-964e-1082a4c91ba9.png)'
- en: 'Then, we''ll use the default value just by pressing *enter* through all of
    the options shown in the following screenshot. There''s no need to customize any
    of these as of now:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过在以下截图中显示的所有选项中按*enter*来使用默认值。目前没有必要自定义任何选项：
- en: '![](img/409f3209-e35c-4464-95f1-c0b6539ddc61.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/409f3209-e35c-4464-95f1-c0b6539ddc61.png)'
- en: 'Then we''ll type `yes` in the last statement `Is this ok? (yes)` and the `package.json`
    file goes in place:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将在最后一个语句`Is this ok? (yes)`中输入`yes`，`package.json`文件就位了：
- en: '![](img/cf2525fd-c1cf-4a0b-9431-0784f2bd46f9.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf2525fd-c1cf-4a0b-9431-0784f2bd46f9.png)'
- en: Express docs website
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express文档网站
- en: 'As mentioned earlier, Express is a really big library. There''s an entire website
    dedicated to the Express docs. Instead of a simple `README.md` file, you can go
    to [www.expressjs.com](http://expressjs.com/) to view everything the website have
    to offer:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Express是一个非常庞大的库。有一个专门的网站专门用于Express文档。您可以访问[www.expressjs.com](http://expressjs.com/)查看网站提供的所有内容，而不是简单的`README.md`文件：
- en: '![](img/76c08a9b-7416-4ed5-afd9-b62f9f8ecde0.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76c08a9b-7416-4ed5-afd9-b62f9f8ecde0.png)'
- en: We'll find Getting started, help articles, and many more. The website has the Guide option
    to help you do things such as Routing, Debugging, Error handling, and an API reference,
    so we can look into exactly what methods we have access to and what they do. It's
    a very handy website.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将找到入门、帮助文章等。该网站有一个“指南”选项，可以帮助您执行诸如路由、调试、错误处理和API参考之类的操作，因此我们可以准确了解我们可以访问的方法以及它们的作用。这是一个非常方便的网站。
- en: Installing Express
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Express
- en: 'Now that we have our `node-web-server` directory, we''ll install Express so
    we can get started making our web server. In the Terminal we''ll run the `clear`
    command first to clear the output. Then we''ll run the `npm install` command.
    The module name is `express` and we''ll be using the latest version, `@4.16.0`.
    We''ll also provide the `save` flag to update the dependencies inside of our `package.json`
    file as shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`node-web-server`目录，我们将安装Express，这样我们就可以开始制作我们的Web服务器。在终端中，我们将首先运行`clear`命令以清除输出。然后我们将运行`npm
    install`命令。模块名称是`express`，我们将使用最新版本`@4.16.0`。我们还将提供`save`标志来更新我们的`package.json`文件中的依赖项，如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/107b4ff8-819a-4a01-ae06-60b1af04e99e.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/107b4ff8-819a-4a01-ae06-60b1af04e99e.png)'
- en: Once again we'll use the `clear` command to clear the Terminal output.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用`clear`命令来清除终端输出。
- en: 'Now that we have `Express` installed, we can actually create our web server
    inside Atom. In order to run the server, we will need a file. I''ll call this
    file `server.js`. It will sit right in the root of our application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了`Express`，我们可以在Atom中创建我们的Web服务器。为了运行服务器，我们需要一个文件。我会把这个文件叫做`server.js`。它将直接放在我们应用程序的根目录中：
- en: '![](img/bf797c36-afaf-4e5f-aa29-af9a1d4ae371.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf797c36-afaf-4e5f-aa29-af9a1d4ae371.png)'
- en: This is where we'll configure the various routes, things like the root of the
    website, pages like `/about`, and so on. It's also where we'll start the server,
    binding it to a port on our machine. Now we'll be deploying to a real server.
    Later we'll talk about how that works. For now, most of our server examples will
    happen on our localhost.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将配置各种路由的地方，像网站的根目录，像`/about`这样的页面等。这也是我们将启动服务器的地方，将其绑定到我们机器上的端口。现在我们将部署到一个真正的服务器。稍后我们将讨论这是如何工作的。现在，我们大部分的服务器示例将发生在我们的本地主机上。
- en: 'Inside `server.js`, the first thing we''ll do is load in Express by making
    a constant called `express` and setting it equal to `require(''express'')`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中，我们要做的第一件事是通过创建一个常量`express`并将其设置为`require('express')`来加载Express：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next up, what we''ll do is make a new Express app. To do this we''ll make a
    variable called app and we''ll set it equal to the return result from calling
    `express` as a function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是创建一个新的Express应用程序。为此，我们将创建一个名为app的变量，并将其设置为从调用`express`作为函数返回的结果：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now there are no arguments we need to pass into `express`. We will do a ton
    of configuration, but that will happen in a different way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不需要传递任何参数到`express`中。我们将进行大量的配置，但这将以不同的方式进行。
- en: Creating an app
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个应用程序
- en: In order to create an app, all we have to do is call the method. Next to the
    variable `app` we can start setting up all of our HTTP route handlers. For example,
    if someone visits the root of the website we're going to want to send something
    back. Maybe it's some JSON data, maybe it's an HTML page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个应用程序，我们只需要调用这个方法。在变量`app`旁边，我们可以开始设置所有我们的HTTP路由处理程序。例如，如果有人访问网站的根目录，我们将想要发送一些东西回去。也许是一些JSON数据，也许是一个HTML页面。
- en: 'We can register a handler using `app.get` function. This will let us set up
    a handler for an HTTP get request. There are two arguments we have to pass into
    `app.get`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用`app.get`函数注册一个处理程序。这将让我们为HTTP get请求设置一个处理程序。我们必须传入`app.get`的两个参数： '
- en: The first argument is going to be a URL
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数将是一个URL
- en: The second argument is going to be the function to run; the function that tells
    Express what to send back to the person who made at the request
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数将是要运行的函数；告诉Express要发送什么回去给发出请求的人的函数
- en: 'In our case we''re looking for the root of the app. So we can just use forward
    slash (`/`) for the first argument. In the second argument, we''ll use a simple
    arrow function (`=>`) as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们正在寻找应用程序的根。所以我们可以只使用斜杠（`/`）作为第一个参数。在第二个参数中，我们将使用一个简单的箭头函数（`=>`）如下所示：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now the arrow function (`=>`) will get called with two arguments. These are
    really important to how Express works:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在箭头函数（`=>`）将被调用两个参数。这对于Express的工作方式非常重要：
- en: The first argument is request (`req`) stores a ton of information about the
    request coming in. Things like the headers that were used, any body information,
    or the method that was made with a request to the path. All of that is stored
    in request.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是请求（`req`），存储了关于进来的请求的大量信息。像使用的标头、任何主体信息，或者用请求到路径的方法。所有这些都存储在请求中。
- en: The second argument, respond (`res`), has a bunch of methods available so we
    can respond to the HTTP request in whatever way we like. We can customize what
    data we send back and we could set our HTTP status codes.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数，respond（`res`），有很多可用的方法，所以我们可以以任何我们喜欢的方式响应HTTP请求。我们可以自定义发送回去的数据，还可以设置我们的HTTP状态码。
- en: 'We''ll explore both of these in detail. For now though, we''ll use one method,
    `res.send`. This will let us respond to the request, sending some data back. In
    `app.get` function, let''s call `res.send`, passing in a string. In the parenthesis
    we''ll add `Hello Express!`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨这两者。不过现在，我们将使用一个方法，`res.send`。这将让我们响应请求，发送一些数据回去。在`app.get`函数中，让我们调用`res.send`，传入一个字符串。在括号中，我们将添加`Hello
    Express!`：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the response for the HTTP request. So when someone views the website
    they will see this string. If they make a request from an application, they will
    get back `Hello Express!` as the body data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTTP请求的响应。所以当有人查看网站时，他们将看到这个字符串。如果他们从应用程序发出请求，他们将得到`Hello Express!`作为主体数据。
- en: 'Now at this point we''re not quite done. We have one of our routes set up,
    but the app is never going to actually start listening. What we need to do is
    call `app.listen`. The `app.listen` function will bind the application to a port
    on our machine. In this case for our local host app, we will use port `3000`,
    a really common port for developing locally. Later in the chapter, we''ll talk
    about how to customize this depending on whatever server you use to deploy your
    app to production. For now though, a number like `3000` works:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这一点上，我们还没有完全完成。我们已经设置了其中一个路由，但是应用程序实际上永远不会开始监听。我们需要做的是调用`app.listen`。`app.listen`函数将在我们的机器上将应用程序绑定到一个端口。在这种情况下，对于我们的本地主机应用程序，我们将使用端口`3000`，这是一个非常常见的用于本地开发的端口。在本章的后面，我们将讨论如何根据您用于将应用程序部署到生产环境的服务器来自定义此设置。不过，像`3000`这样的数字是有效的：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this in place we are now done. We have our very first Express server.
    We can actually run things from the Terminal, and view it in the browser. Inside
    the Terminal, we''ll use `nodemon server.js` to start up our app:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在完成了。我们有了我们的第一个Express服务器。我们实际上可以从终端运行它，并在浏览器中查看它。在终端中，我们将使用`nodemon
    server.js`来启动我们的应用程序：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will start up the app and you''ll see that the app never really finishes
    as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动应用程序，并且您将看到应用程序从未真正完成，如下所示：
- en: '![](img/93379da7-8160-4b76-a3f2-f8d4dd461451.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93379da7-8160-4b76-a3f2-f8d4dd461451.png)'
- en: Right now it's hanging. It's waiting for requests to start coming in. The apps
    that use `app.listen`, they will never stop. You'll have to shut them down manually
    with *control* + *C*, like we've done before. It might crash if you have an error
    in your code. But it'll never stop normally, since we have that binding set up
    here. It will listen to requests until you tell it to stop.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它正在挂起。它正在等待请求开始进来。使用`app.listen`的应用程序永远不会停止。您必须手动使用*control* + *C*关闭它们，就像我们以前做过的那样。如果您的代码中有错误，它可能会崩溃。但是它通常不会停止，因为我们在这里设置了绑定。它将监听请求，直到您告诉它停止。
- en: 'Now that the server is up, we can move into the browser and open up a new tab
    visiting the website, `localhost:` followed by the port `3000`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器已经启动，我们可以进入浏览器，打开一个新标签，访问网站，`localhost:`后跟端口`3000`：
- en: '![](img/3cefbc29-a9e1-4959-87bb-6a673b2efa25.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cefbc29-a9e1-4959-87bb-6a673b2efa25.png)'
- en: This will load up the root of the website, and we specify the handler for that
    route. Hello Express! shows up, which is exactly what we expected. Now there's
    no thrills. There's no formatting. We're just sending a string from the server
    back to the client that made the request.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载网站的根目录，并且我们指定了该路由的处理程序。Hello Express!显示出来，这正是我们所期望的。现在没有花哨。没有格式。我们只是从服务器向发出请求的客户端发送一个字符串。
- en: Exploring the developer tools in the browser for the app request
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中探索应用程序请求的开发者工具
- en: 'What we''d like to do next is open up the developer tools, so we can explore
    exactly what happened when that request was made. Inside Chrome you can get to
    the Developer Tools using Settings| More Tools| Developer Tools:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想打开开发者工具，以便我们可以探索在发出请求时发生了什么。在Chrome中，您可以使用设置|更多工具|开发者工具来打开开发者工具：
- en: '![](img/d408ab4a-be5b-4f3f-a06d-5e760c27780d.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d408ab4a-be5b-4f3f-a06d-5e760c27780d.png)'
- en: Or you can use the keyboard shortcut shown along with Developer Tools for the
    operating system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用与操作系统的开发者工具一起显示的键盘快捷键。
- en: I would highly recommend memorizing that keyboard shortcut because you'll use
    the `Developer Tools` a ton in your career with Node.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您记住这个键盘快捷键，因为在使用Node时，您将大量使用`开发者工具`。
- en: 'We''ll now open up the Developer Tools, which should look similar to the ones
    we used when we ran the Node Inspector debugger. They''re a little different,
    but the idea is the same:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将打开开发者工具，它应该看起来与我们运行Node Inspector调试器时使用的工具类似。它们有点不同，但是思想是一样的：
- en: '![](img/54afeb85-d1bd-49b1-8ecb-721dc33b4c82.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54afeb85-d1bd-49b1-8ecb-721dc33b4c82.png)'
- en: 'We have a bunch of tabs up top, and then we have our tab specific information
    down following on the page. In our case, we want to go to the Network tab, and
    currently we have nothing. So we''ll refresh the page with the tab open, and what
    we see right here is our localhost request:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在顶部有一堆标签，然后我们在页面下方有我们特定标签的信息。在我们的情况下，我们想转到网络标签，目前我们什么都没有。因此，我们将在打开标签的情况下刷新页面，我们在这里看到的是我们的本地主机请求：
- en: '![](img/82180d8c-58ad-43c9-9dc7-a91b9f2478b2.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82180d8c-58ad-43c9-9dc7-a91b9f2478b2.png)'
- en: 'This is the request that''s responsible for showing Hello Express! to the screen.
    We can actually click the request to view its details:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是负责在屏幕上显示Hello Express!的请求。实际上，我们可以单击请求以查看其详细信息：
- en: '![](img/1e91be78-a106-47a6-9285-94d8720ea76d.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e91be78-a106-47a6-9285-94d8720ea76d.png)'
- en: This page can be a little overwhelming at first. There is a a lot of information.
    Up on top we have some general info, such as the URL that was requested, the method
    that the client wanted; in this case, we made a GET request, and the status code
    that came back. The default status code being 200, meaning that everything went
    great. We'd like to point the attention to is one response header.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面一开始可能有点压倒性。有很多信息。在顶部，我们有一些一般信息，例如被请求的URL，客户端想要的方法；在这种情况下，我们发出了一个GET请求，并且返回的状态代码。默认状态代码为200，表示一切顺利。我们想要指出的是一个响应头。
- en: Under Response Headers we have a header called Content-Type. This header tells
    the client what type of data came back. Now this could be something like an HTML
    website, some text, or some JSON data and the client could be a web browser, an
    iPhone, an Android device, or any other computer with network capabilities. In
    our case, we're telling the browser that what came back is some HTML, so why don't
    you render it as such. We use the text/html Content-Type. And this automatically
    got set by Express, which is one of the reasons it's so popular. It handles a
    lot of that mundane stuff for us.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应标头下，我们有一个叫做Content-Type的标头。这个标头告诉客户端返回了什么类型的数据。现在这可能是像HTML网站、一些文本或一些JSON数据，而客户端可能是一个网络浏览器、iPhone、安卓设备或任何其他具有网络功能的计算机。在我们的情况下，我们告诉浏览器返回的是一些HTML，所以为什么不按照这样的方式进行渲染呢。我们使用了text/html
    Content-Type。这是由Express自动设置的，这也是它如此受欢迎的原因之一。它为我们处理了很多这样的琐事。
- en: Passing HTML to res.send
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HTML传递给res.send
- en: 'Now that we have a very basic example, we want to step things up a notch. Inside
    Atom, we can actually provide some HTML right inside of send by wrapping our `Hello
    Express!` message in an `h1` tag. Later in this section, we''ll be setting up
    a static website that has HTML files that get served up. We''ll also look at templating
    to create dynamic web pages. But for now, we can actually just pass in some HTML
    to `res.send`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个非常基本的例子，我们想要把事情提升到一个新的水平。在Atom中，我们实际上可以通过将我们的`Hello Express!`消息放在一个`h1`标签中，直接在send中提供一些HTML。在本节的后面，我们将设置一个包含HTML文件的静态网站。我们还将研究模板化以创建动态网页。但现在，我们实际上可以只是将一些HTML传递给`res.send`：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll save the server file, which should restart things in the browser. When
    we give the browser a refresh, we get Hello Express! printing to the screen:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存服务器文件，这应该会重新启动浏览器。当我们刷新浏览器时，我们会看到Hello Express!打印到屏幕上：
- en: '![](img/95e4efcb-addd-43c0-9878-a0052aaf297a.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95e4efcb-addd-43c0-9878-a0052aaf297a.png)'
- en: 'This time though, we have it in an `h1` tag, which means it''s formatted by
    the default browser styles. In this case it looks nice and big. With this in place
    we can now open up the request inside the Network tab, and what we get is the
    exact same thing we had before. We''re still telling the browser that it''s HTML.
    Only one difference this time: we actually have an HTML tag, so it gets rendered
    using the browser''s default styles.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不过这一次，我们把它放在了一个`h1`标签中，这意味着它是由默认的浏览器样式格式化的。在这种情况下，它看起来很漂亮而且很大。有了这个，我们现在可以在网络选项卡中打开请求，我们得到的是和之前完全一样的东西。我们仍然告诉浏览器它是HTML。这一次唯一的区别是：我们实际上有一个HTML标签，所以它会使用浏览器的默认样式进行渲染。
- en: Sending JSON data back
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送JSON数据回去
- en: 'The next thing we''d look into is how we can send some JSON data back. Sending
    JSON is really easy with Express. To illustrate how we can do it we''ll comment
    out our current call to `res.send` and add a new one. We''ll call `res.send` passing
    in an object:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要看的是如何发送一些JSON数据回去。使用Express发送JSON非常容易。为了说明我们如何做到这一点，我们将注释掉当前对`res.send`的调用，并添加一个新的调用。我们将调用`res.send`，传入一个对象：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On this object we can provide whatever we like. We can create a `name` property,
    setting it equal to the string version of any name, say `Andrew`. We can make
    a property called `likes`, setting it equal to an array, and we can specify some
    things we may like. Let''s add `Biking` as one of them, and then add `Cities`
    as another:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对象上，我们可以提供任何我们喜欢的东西。我们可以创建一个`name`属性，将它设置为任何名字的字符串版本，比如`Andrew`。我们可以创建一个名为`likes`的属性，将它设置为一个数组，并且可以指定一些我们可能喜欢的东西。让我们把`Biking`添加为其中之一，然后再添加`Cities`作为另一个：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we call `res.send` passing in an object, Express notices that. Express
    takes it, converts it into JSON, and sends it back to the browser. When we save
    `server.js` and nodemon refreshes, we can refresh the browser, and what we get
    is my data formatted using JSON view:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`res.send`并传入一个对象时，Express会注意到。Express会将其转换为JSON，并发送回浏览器。当我们保存`server.js`并且nodemon刷新时，我们可以刷新浏览器，我们得到的是我的数据使用JSON视图格式化的结果：
- en: '![](img/265798fa-1fb0-4233-aac6-d8f51e573ef8.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/265798fa-1fb0-4233-aac6-d8f51e573ef8.png)'
- en: This means we can collapse the properties and quickly navigate the JSON data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以折叠属性并快速导航JSON数据。
- en: '![](img/a8ab4046-fd65-44d3-bc10-a17341a80e4f.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8ab4046-fd65-44d3-bc10-a17341a80e4f.png)'
- en: 'Now the only reason JSON view picked up on this is because that Content-Type
    header that we explored in our last request it actually changed. If I open up
    `localhost`, a lot of things look the same. But now Content-Type has an application/json
    Content-Type:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在JSON视图之所以能够捕捉到这一点，是因为我们在上一个请求中探索的Content-Type标头实际上发生了变化。如果我打开`localhost`，很多东西看起来都一样。但现在Content-Type变成了application/json
    Content-Type：
- en: '![](img/d9205712-9724-496a-8c78-e6b6954bae4f.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9205712-9724-496a-8c78-e6b6954bae4f.png)'
- en: This Content-Type tells the requester whether it's an Android phone, an iOS
    device, or the browser that JSON data is coming back, and it should parse it as
    such. That's exactly what the browser does in this case.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Content-Type告诉请求者，它是一个安卓手机、一个iOS设备，还是浏览器，JSON数据正在返回，它应该解析为这样。这正是浏览器在这种情况下所做的。
- en: 'Express also makes it really easy to set up other routes aside from the root
    route. We can explore that inside Atom by calling `app.get` a second time. We''ll
    call `app.get`. We''ll create a second route. We''ll call this one `about`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Express还可以很容易地设置除根路由之外的其他路由。我们可以在Atom中调用`app.get`来探索这一点。我们将调用`app.get`。我们将创建第二个路由。我们将这个叫做`about`：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that we just used `/about` as the route. It''s important to keep that
    forward slash in place, but after that you can type whatever you like. In this
    case we''ll have a `/about` page that someone can visit. Then I''ll provide the
    handler. The handler will take the `req` and the `res` object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们只是使用了`/about`作为路由。保持斜杠的位置很重要，但在那之后你可以输入任何你喜欢的东西。在这种情况下，我们将有一个`/about`页面供某人访问。然后我会提供处理程序。处理程序将接收`req`和`res`对象：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will let us figure out what kind of request came in, and it will let us
    respond to that request. For now just to illustrate we can create more pages,
    we''ll keep the response simple, `res.send`. Inside the string we''re going to
    print `About Page`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让我们弄清楚是什么样的请求进来了，以及让我们对该请求做出响应。现在，为了说明我们可以创建更多页面，我们将保持响应简单，`res.send`。在字符串内部，我们将打印`About
    Page`：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now when we save the `server.js` file, the server is going to restart. In the
    browser we can visit `localhost:3000/about`. At `/about` we should now see our
    new data, and that''s exactly what we get back, About Page shows up as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们保存`server.js`文件时，服务器将重新启动。在浏览器中，我们可以访问`localhost:3000/about`。在`/about`处，我们现在应该看到我们的新数据，这正是我们得到的，About
    Page显示如下：
- en: '![](img/8e3f1986-c5ee-4b56-9984-35ec3ad84fab.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e3f1986-c5ee-4b56-9984-35ec3ad84fab.png)'
- en: Using `app.get` we're able to specify as many routes as we like. For now we
    just have an `about` route and a `/` route, which is also referred to as the root
    route. The root route returns some data, which happens to be JSON, and the about
    route returns a little bit of HTML. Now that we have this in place and we have
    a very basic understanding about how we can set up routes in Express, we'd like
    you to create a new route `/bad`. This is going to simulate what happens when
    a request fails.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`app.get`，我们可以指定尽可能多的路由。目前我们只有一个`about`路由和一个`/`路由，也被称为根路由。根路由返回一些数据，恰好是JSON，而about路由返回一点HTML。现在我们已经有了这个设置，并且对于如何在Express中设置路由有了一个非常基本的理解，我们希望你创建一个新的路由`/bad`。这将模拟当请求失败时会发生什么。
- en: Error handling in the JSON request
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON请求中的错误处理
- en: 'To show the error handling request with JSON, we''re going to call `app.get`.
    This `app.get` is going to let us register another handler for a get HTTP request.
    In our case the route we''re looking for inside of quotes is going to be `/bad`.
    When someone makes a request for this page, what we want to do is going to be
    specified in the callback. The callback will take our two arguments, `req` and
    `res`. We''ll use an arrow function (`=>`), which I''ve used for all of the handlers
    so far:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示JSON的错误处理请求，我们将调用`app.get`。这个`app.get`将让我们为get HTTP请求注册另一个处理程序。在我们的情况下，我们正在寻找的路由将在引号内，即`/bad`。当有人请求这个页面时，我们想要做的将在回调中指定。回调将使用我们的两个参数，`req`和`res`。我们将使用一个箭头函数(`=>`)，这是我到目前为止所有处理程序都使用的：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inside the arrow function (`=>`), we''ll send back some JSON by calling `res.send`.
    But instead of passing in a string, or some string HTML, we''ll pass in an object:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数(`=>`)内部，我们将通过调用`res.send`发送一些JSON。但我们不是传递一个字符串，或一些字符串HTML，而是传递一个对象：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have our object in place we can specify the properties we want
    to send back. In this case we''ll set one `errorMessage`. We''ll set my error
    message property equal to a string, `Unable to handle request`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的对象，我们可以指定要发送回去的属性。在这种情况下，我们将设置一个`errorMessage`。我们将把我的错误消息属性设置为一个字符串，`无法处理请求`：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next up we''ll save the file, restarting it in nodemon, and visit it in the
    browser. Make sure our error message showed up correctly. In the browser, we''ll
    visit `/bad`, hit *enter*, and this is what we get:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将保存文件，在nodemon中重新启动它，并在浏览器中访问它。确保我们的错误消息正确显示。在浏览器中，我们将访问`/bad`，按下*enter*，我们会得到以下内容：
- en: '![](img/e824edc3-7898-469e-9ac5-b63ce1f6f5c5.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e824edc3-7898-469e-9ac5-b63ce1f6f5c5.png)'
- en: 'We get our JSON showing up using JSON view. We have our error message, and
    we have the message showing up: Unable to handle request. Now if you are using
    JSON view and you want to view the raw JSON data, you can actually click on View
    source, and it will show it in a new tab. Here, we''re looking at the raw JSON
    data, where everything is wrapped in those double quotes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JSON数据显示出来了。我们有错误消息，还有消息显示出来：无法处理请求。现在，如果你正在使用JSON视图，并且想查看原始的JSON数据，你实际上可以点击“查看源代码”，它会在新标签页中显示出来。在这里，我们正在查看原始的JSON数据，所有内容都用双引号括起来。
- en: '![](img/db28133e-200d-41d9-a6a3-2ba01543c9ed.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db28133e-200d-41d9-a6a3-2ba01543c9ed.png)'
- en: 'I''ll stick to the JSON view data because it''s a lot easier to navigate and
    view. We now have a very basic Express application up and running. It listens
    on port `3000` and it currently has handlers for 3 URLs: when we get the root
    of the page, when we get `/about`, and when we make a get request for `/bad`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我将坚持使用JSON视图数据，因为它更容易导航和查看。我们现在有一个非常基本的Express应用程序正在运行。它在端口`3000`上监听，并且目前有3个URL的处理程序：当我们获取页面的根目录时，当我们获取`/about`时，以及当我们对`/bad`发出get请求时。
- en: The static server
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态服务器
- en: In this section, we'll learn how to set up a static directory. So if we have
    a website with HTML, CSS, JavaScript, and images, we can serve that up without
    needing to provide a custom route for every single file, which would be a real
    burden. Now setting this up is really simple. But before we make any updates to
    `server.js`, we'd create some static assets inside of our project that we can
    actually serve up.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何设置一个静态目录。因此，如果我们有一个包含HTML、CSS、JavaScript和图像的网站，我们可以提供这些内容，而不需要为每个文件提供自定义路由，这将是一个真正的负担。现在设置这个非常简单。但在我们对`server.js`进行任何更新之前，我们需要在项目中创建一些静态资产，这样我们才能提供服务。
- en: Making an HTML page
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作一个HTML页面
- en: In this case we'll make one HTML page that we'll be able to view in the browser.
    Before we get started, we do need to create a new directory, and everything inside
    this directory will be accessible via the web server, so it's important to not
    put anything in here that you don't want prying eyes to see.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将制作一个HTML页面，我们将能够在浏览器中查看。在我们开始之前，我们需要创建一个新的目录，这个目录中的所有内容都可以通过网络服务器访问，所以重要的是不要在这里放任何你不希望别人看到的东西。
- en: 'Everything in the directory should be intended to be view able by anybody.
    We''ll create a public folder to store all of our static assets, and inside here
    we''ll make an HTML page. We''ll create a help page for our example project by
    creating a file called `help.html`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 目录中的所有内容都应该是任何人都可以查看的。我们将创建一个公共文件夹来存储所有静态资产，在这里我们将创建一个HTML页面。我们将通过创建一个名为`help.html`的文件为我们的示例项目创建一个帮助页面：
- en: '![](img/fafc28c3-1bd3-44e4-b17b-4f38525aa727.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fafc28c3-1bd3-44e4-b17b-4f38525aa727.png)'
- en: Now in `help.html` we will make a quick basic HTML file, although we'll not
    touch on all of the subtleties of HTML, since this is not really an HTML book.
    Instead, we'll just set up a basic page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`help.html`中，我们将创建一个快速的基本HTML文件，尽管我们不会涉及HTML的所有微妙之处，因为这不是一本真正的HTML书。相反，我们将只设置一个基本页面。
- en: 'The first thing we need to do is create a `DOCTYPE` which lets the browser
    know what version of HTML we''re using. That will look something like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个`DOCTYPE`，让浏览器知道我们正在使用的HTML版本。看起来会像这样：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After the opening tag, and the exclamation mark, we''d type `DOCTYPE` in uppercase.
    Then, we provide the actual `DOCTYPE` for HTML5, the latest version. Then we can
    use the greater than sign to close things up. In the next line, we''ll open up
    our `html` tag so we can define our entire HTML file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在开标签和感叹号之后，我们会输入大写的`DOCTYPE`。然后，我们提供HTML5的实际`DOCTYPE`，最新版本。然后我们可以使用大于号来关闭事物。在下一行，我们将打开我们的`html`标签，以便定义整个HTML文件：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Inside `html`, there are two tags we''ll use: the `head` tag which lets us
    configure our doc, and the `body` tag which contains everything we want to render
    to the screen.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`html`内部，有两个标签我们将使用：`head`标签让我们配置我们的文档，和`body`标签包含我们想要呈现在屏幕上的所有内容。
- en: The head tag
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: head标签
- en: 'We''ll create the `head` tag first:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建`head`标签：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside `head`, we''ll provide two pieces of info, `charset` and `title` tag:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`head`中，我们将提供两个信息，`charset`和`title`标签：
- en: First up we have to set up the `charset` which lets the browser know how to
    render our characters.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们必须设置`charset`，让浏览器知道如何呈现我们的字符。
- en: Next up we'll provide the `title` tag. The `title` tag lets the browser know
    what to render in that title bar, where the new tab usually is.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来我们将提供`title`标签。`title`标签让浏览器知道在标题栏中呈现什么内容，通常是新标签。
- en: 'As shown in the following code snippet, we''ll set `meta`. And on `meta`, we''ll
    set the `charset` property using equals, and provide the value `utf-8`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的代码片段所示，我们将设置`meta`。在`meta`上，我们将使用等号设置`charset`属性，并提供值`utf-8`：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the `title` tag, we can set it to whatever we like; `Help Page` seems appropriate:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`title`标签，我们可以将其设置为任何我们喜欢的内容；`Help Page`似乎很合适：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The body tag
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: body标签
- en: 'Now that our `head` is configured, we can add something to the body of our
    website. This is the stuff that''s actually going to be viewable inside the viewport.
    Next to the head, we''ll open and close the `body` tag:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`head`已经配置好，我们可以在网站的正文中添加一些内容。这些内容实际上将在视口内可见。在`head`旁边，我们将打开和关闭`body`标签：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside `body` again, we''ll provide two things: an `h1` title and a `p` paragraph
    tag.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`body`中，我们将再次提供两个内容：一个`h1`标题和一个`p`段落标签。
- en: 'The title is going to match the `title` tag we used in the `head`, Help Page,
    and the paragraph will just have some filler text—`Some text here`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 标题将与我们在`head`中使用的`title`标签匹配，Help Page，段落将只有一些填充文本——`这里有一些文本`：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have an HTML page and the goal is to be able to serve this page up in
    our Express app without having to manually configure it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个HTML页面，目标是能够在Express应用程序中提供此页面，而无需手动配置。
- en: Serving the HTML page in the Express app
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Express应用程序中提供HTML页面
- en: We'll serve our HTML page in the Express app using a piece of Express middleware.
    Middleware lets us configure how our Express application works, and it's something
    we'll use extensively throughout the book. For now, we can think of it kind of
    like a third-party add-on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Express中间件来在Express应用程序中提供我们的HTML页面。中间件让我们配置我们的Express应用程序的工作方式，并且在整本书中我们将广泛使用它。现在，我们可以将其视为第三方附加组件。
- en: 'In order to add some middleware, we''ll call `app.use`. The `app.use` takes
    the middleware function we want to use. In our case, we''ll use a built-in piece
    of middleware. So inside `server.js`, next to the variable `app` statement, we''ll
    provide the function off of the `express` object:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加一些中间件，我们将调用`app.use`。`app.use`接受我们想要使用的中间件函数。在我们的情况下，我们将使用内置的中间件。因此，在`server.js`中，在`app`变量语句旁边，我们将提供`express`对象的函数：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will be making our own middleware in the next chapter, so it''ll become
    clear exactly what''s getting passed into use in a little bit. For now, we''ll
    pass in `express.static` and to call it as a function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将制作自己的中间件，所以很快就会清楚究竟传递了什么。现在，我们将传递`express.static`并将其作为一个函数调用：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now `express.static` takes the absolute path to the folder you want to serve
    up. If we want to be able to serve up `/help`, we''ll need to provide the path
    to the `public` folder. This means we need to specify the path from the root of
    our hard drive, which can be tricky because your projects move around. Luckily
    we have the `__dirname` variable:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`express.static`需要获取要提供的文件夹的绝对路径。如果我们想要提供`/help`，我们需要提供`public`文件夹的路径。这意味着我们需要指定从硬盘根目录开始的路径，这可能会很棘手，因为您的项目会移动。幸运的是，我们有`__dirname`变量：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is the variable that gets passed into our file by the wrapper function
    we explored. The `__dirname` variable stores the path to your projects directory.
    In this case, it stores the path to `node-web-server`. All we have to do is concatenate
    `/public` to tell it to use this directory for our server. We''ll concatenate
    using the plus sign and the string, `/public`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由我们探索的包装函数传递给我们文件的变量。`__dirname`变量存储着您项目的目录路径。在这种情况下，它存储着`node-web-server`的路径。我们只需连接`/public`，告诉它使用这个目录作为我们的服务器。我们将使用加号和字符串`/public`进行连接：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With this in place, we are now done. We have our server set up and there''s
    nothing else to do. Now we should be able to restart our server and access `/help.html`.
    We should now see the HTML page we have. In the Terminal we can now start the
    app using `nodemon server.js`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在已经完成了。我们的服务器已经设置好，没有其他事情要做。现在我们应该能够重新启动我们的服务器并访问`/help.html`。我们现在应该能够看到我们的HTML页面。在终端中，我们现在可以使用`nodemon
    server.js`来启动应用程序：
- en: '![](img/16d84c8b-973b-49b3-96b7-8cb4546c7269.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16d84c8b-973b-49b3-96b7-8cb4546c7269.png)'
- en: 'Once the app is up and running we can visit it in the browser. We''ll start
    by going to `localhost:3000`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序运行起来，我们就可以在浏览器中访问它。我们将首先转到`localhost:3000`：
- en: '![](img/cdc5f64a-0aba-48d4-897e-fd0c14f4e71e.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdc5f64a-0aba-48d4-897e-fd0c14f4e71e.png)'
- en: 'Here we get our JSON data, which is exactly what we expect. And if we change
    that URL to `/help.html` we should get our Help Page rendering:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了我们的JSON数据，这正是我们所期望的。如果我们将该URL更改为`/help.html`，我们应该会看到我们的帮助页面渲染：
- en: '![](img/63d0b4c0-6781-4689-93e2-96a4b69adc01.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63d0b4c0-6781-4689-93e2-96a4b69adc01.png)'
- en: 'And that is exactly what we get, we have our Help Page showing to the screen.
    We have the Help Page title as the head, and the Some text here paragraph following
    as body. Being able to set up a static directory that easily has made Node the
    go-to choice for simple projects that don''t really require a backend. If you
    want to create a Node app for the sole purpose of serving up a directory you can
    do it in about four lines of code: the first three lines and the last line in
    the `server.js` file.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们得到的，我们的帮助页面显示在屏幕上。我们将帮助页面标题设置为标题，然后是一些文本段落作为正文。能够轻松设置静态目录已经使Node成为简单项目的首选，这些项目实际上并不需要后端。如果您想创建一个仅用于提供目录的Node应用程序，您可以在`server.js`文件中用大约四行代码完成：前三行和最后一行。
- en: The call to app.listen
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对`app.listen`的调用
- en: 'Now one more thing we''d discuss is the call to `app.listen(3000)`. The `app.listen`
    does take a second argument. It''s optional. It''s a function. This will let us
    do something once the server is up because it can take a little bit of time to
    get started. In our case we''ll assign `console.log` a message: `Server is up
    on port 3000`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要讨论的另一件事是对`app.listen(3000)`的调用。`app.listen`确实需要第二个参数。这是可选的。这是一个函数。这将让我们在服务器启动后执行某些操作，因为启动可能需要一点时间。在我们的情况下，我们将为`console.log`分配一条消息：`服务器已在3000端口上启动`：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now it''s really clear to the person who started the app that the server is
    actually ready to go because the message will print to the screen. If we save
    `server.js`, and go back into the Terminal we can see `Server is up on port 3000`
    prints:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于启动应用程序的人来说，服务器实际上已经准备就绪，因为消息将打印到屏幕上。如果我们保存`server.js`，并返回到终端，我们可以看到`服务器已在3000端口上启动`打印出来：
- en: '![](img/3eb224ed-caec-4a93-ac40-e3e77b73a815.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3eb224ed-caec-4a93-ac40-e3e77b73a815.png)'
- en: 'Back inside the browser we can refresh and we get the exact same results:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 回到浏览器，我们可以刷新，得到完全相同的结果：
- en: '![](img/1340f888-eea5-480e-a997-b060ded511c1.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1340f888-eea5-480e-a997-b060ded511c1.png)'
- en: That's it for this section. We now have a static directory where we can include
    JavaScript, CSS, images, or any other file types we like.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本节的全部内容。我们现在有一个静态目录，可以在其中包含JavaScript、CSS、图像或任何其他文件类型。
- en: Rendering templates
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染模板
- en: In the last couple sections, we looked at multiple ways that we can render HTML
    using Express. We passed some HTML into `response.send`, but obviously that was
    not ideal. It's a real pain to write the markup in a string. We also created a
    public directory where we can have our static HTML files, such as our `help` file,
    and we can serve these up to the browser. Both of those work great but there is
    a third solution, and that will be the topic in this section. The solution is
    a templating engine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几节中，我们看了多种使用Express渲染HTML的方法。我们将一些HTML传递给`response.send`，但显然这并不理想。在字符串中编写标记是真正痛苦的。我们还创建了一个公共目录，可以在其中放置我们的静态HTML文件，例如我们的`help`文件，并将其提供给浏览器。这两种方法都很好，但还有第三种解决方案，这将是本节的主题。解决方案是模板引擎。
- en: A templating engine will let you render HTML but do it in a dynamic way, where
    we can inject values, such as a username or the current date, inside the template,
    kind of like we would in Ruby or PHP. Using this templating engine, we'll also
    be able to create reusable markup for things such as a header or a footer, which
    is going to be the same on a lot of your pages. This templating engine, handlebars,
    will be the topic of this section and the next, so let's get started.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎将允许您以动态方式呈现HTML，我们可以在模板中注入值，例如用户名或当前日期，就像我们在Ruby或PHP中所做的那样。使用这个模板引擎，我们还将能够为诸如页眉或页脚之类的可重用标记创建可重用的标记，这将在您的许多页面上都是相同的。这个模板引擎，handlebars，将是本节和下一节的主题，所以让我们开始吧。
- en: Installing the hbs module
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装hbs模块
- en: The first thing we'll do is install the `hbs` module. This is a handlebars view
    engine for Express. Now there are a ton of other view engines for Express, for
    example EJS or Pug. We'll go with handlebars because its syntax is great. It's
    a great way to get started.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是安装`hbs`模块。这是Express的handlebars视图引擎。现在有很多其他Express视图引擎，例如EJS或Pug。我们将选择handlebars，因为它的语法很棒。这是一个很好的开始方式。
- en: Now we'll see a few things inside of the browser. First up we will visit [handlebarsjs.com](http://handlebarsjs.com/).
    This is the documentation for handlebars. It shows you exactly how to use all
    of its features, so if we want to use anything, we can always go here to learn
    how to use it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在浏览器中看到一些内容。首先，我们将访问[handlebarsjs.com](http://handlebarsjs.com/)。这是handlebars的文档。它向您展示了如何使用其所有功能，因此如果我们想使用任何内容，我们总是可以在这里学习如何使用它。
- en: Now we'll install a module that's a wrapper around handlebars. It will let us
    use it as an Express view engine. To view this, we'll go to [npmjs.com/package/hbs](https://www.npmjs.com/package/hbs).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将安装一个包装在handlebars周围的模块。它将让我们将其用作Express视图引擎。要查看此内容，我们将转到[npmjs.com/package/hbs](https://www.npmjs.com/package/hbs)。
- en: This is the URL structure for all packages. So if you ever want to find a packages
    page, you simply type `npmjs.com/package/ the package name`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有软件包的URL结构。因此，如果您想找到软件包页面，只需键入`npmjs.com/package/软件包名称`。
- en: 'This module is pretty popular. It''s a really great view engine. They have
    a lot of documentation. I just want to let you know this exists as well. Now we
    can install and integrate it into our application. In the Terminal, we''ll install
    `hbs` using `npm install`, the module name is `hbs`, and the most recent version
    is `@4.0.1`. I will use the `save` flag to update `package.json`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块非常受欢迎。这是一个非常好的视图引擎。他们有很多文档。我只是想让你知道这也存在。现在我们可以安装并将其集成到我们的应用程序中。在终端中，我们将使用`npm
    install`安装`hbs`，模块名称是`hbs`，最新版本是`@4.0.1`。我将使用`save`标志来更新`package.json`：
- en: '![](img/82996805-a5fc-4fbe-9920-db7a0c963951.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82996805-a5fc-4fbe-9920-db7a0c963951.png)'
- en: Now actually configuring Express to use this handlebars view engine is super
    simple. All we have to do is import it and add one statement to our Express configuration.
    We'll do just that inside Atom.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在实际上配置Express使用这个handlebars视图引擎非常简单。我们所要做的就是导入它并在我们的Express配置中添加一个语句。我们将在Atom中做到这一点。
- en: Configuring handlebars
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置handlebars
- en: 'Inside Atom, let''s get started by loading in handlebars `const hbs = require
    hbs`, as shown and from here we can add that one line:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，让我们开始加载handlebars `const hbs = require hbs`，如所示，从这里我们可以添加一行：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, let''s call `app.set` where we call `app.use` for Express static:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调用`app.set`，在那里我们为Express静态调用`app.use`：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This lets us set some various Express-related configurations. There''s a lot
    of built-in ones. We''ll be talking about more of them later. For now, about what
    we''ll do is pass in a key-value pair, where the key is the thing you want to
    set and the value is the value you want to use. In this case, the key we''re setting
    is `view engine`. This will tell Express what view engine we''d like to use and
    we''ll pass in inside of quotes `hbs`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们设置一些与Express相关的配置。有很多内置的配置。我们稍后会谈论更多。现在，我们要做的是传入一个键值对，其中键是你想要设置的东西，值是你想要使用的值。在这种情况下，我们设置的键是`view
    engine`。这将告诉Express我们想要使用的视图引擎，并且我们将在引号内传入`hbs`：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is all we need to do to get started.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的一切。
- en: Our first template
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个模板
- en: Now in order to create our very first template, what we'd like to do is make
    a directory in the project called `views`. The `views` is the default directory
    that Express uses for your templates. So what we'll do is add the `views` directory
    and then we'll add a template inside it. We'll make a template for our About Page.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建我们的第一个模板，我们想要做的是在项目中创建一个名为`views`的目录。`views`是Express用于模板的默认目录。所以我们将添加`views`目录，然后在其中添加一个模板。我们将为我们的关于页面创建一个模板。
- en: Inside views, we'll add a new file and the file name will be `about.hbs`. The
    `hbs` handlebars extension is important. Make sure to include it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在views中，我们将添加一个新文件，文件名将是`about.hbs`。`hbs` handlebars扩展名很重要。确保包含它。
- en: Now Atom already knows how to parse `hbs` files. At the bottom of the `about.hbs`
    file, where it shows the current language it's using, HTML in parentheses mustache.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Atom已经知道如何解析`hbs`文件。在`about.hbs`文件的底部，显示当前语言的地方，使用括号内的HTML mustache。
- en: Mustache is used as the name for this type of handlebars syntax because when
    you type the curly braces (`{`) I guess they kind of look like mustaches.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache被用作这种类型的handlebars语法的名称，因为当你输入大括号（`{`）时，它们看起来有点像胡须。
- en: 'What we''ll do to get started though is take the contents of `help.html` and
    copy it directly. Let''s copy this file so we don''t have to rewrite that boilerplate,
    and we''ll paste it right in the `about.hbs`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是开始使用`help.html`的内容并直接复制它。让我们复制这个文件，这样我们就不必重写那个样板，然后我们将它粘贴到`about.hbs`中：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we can try to render this page. We''ll change the `h1` tag from help page
    to about page:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试渲染这个页面。我们将把`h1`标签从帮助页面改为关于页面：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We'll talk about how to dynamically render stuff inside this page later. Before
    that we'd like to just get this rendering.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论如何在此页面内动态渲染内容。在那之前，我们只想让它渲染。
- en: Getting the static page for rendering
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取静态页面进行渲染
- en: 'Inside `server.js`, we already have a root for `/about`, which means we can
    render our hbs template instead of sending back this about page string. We will
    remove our call to `res.send` and we''ll replace it with `res.render`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中，我们已经有了一个`/about`的根目录，这意味着我们可以渲染我们的hbs模板，而不是发送回这个关于页面字符串。我们将删除我们对`res.send`的调用，并将其替换为`res.render`：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Render will let us render any of the templates we have set up with our current
    view engine `about.hbs` file. We do indeed have the about template and we can
    pass that name, `about.hbs`, in as the first and only argument. We''ll render
    `about.hbs`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Render将让我们使用我们当前视图引擎设置的任何模板进行渲染`about.hbs`文件。我们确实有关于模板，我们可以将该名称`about.hbs`作为第一个且唯一的参数传递。我们将渲染`about.hbs`：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will be enough to get that static page rendering. We''ll save `server.js`
    and in the Terminal, we''ll clear the output and we''ll run our server using `nodemon
    server.js`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足以让静态页面渲染。我们将保存`server.js`，在终端中清除输出，然后使用`nodemon server.js`运行我们的服务器：
- en: '![](img/212008be-1d6d-4b32-bc02-3864d93dace6.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/212008be-1d6d-4b32-bc02-3864d93dace6.png)'
- en: 'Once the server is up and running, it is showing on port `3000`. We can open
    up this `/about` URL and see what we get. We''ll head into Chrome and open up
    `localhost:3000 /about`, and when we do that, we get the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器运行起来，它就会显示在端口`3000`上。我们可以打开`/about` URL并查看我们得到了什么。我们将进入Chrome并打开`localhost:3000
    /about`，当我们这样做时，我们得到以下结果：
- en: '![](img/f1db99d7-ade4-4a43-8694-2a0e3ee4317d.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1db99d7-ade4-4a43-8694-2a0e3ee4317d.png)'
- en: We get my about page rendered just like we'd expect it. We've got an `h1` tag,
    which shows up nice and big, and we have our paragraph tag, which shows up the
    following. So far we have used hbs but we haven't actually used any of its features.
    Right now, we're rendering a dynamic page, so we might as well have not even included
    it. What I want to do is talk about how we can inject data inside of our templates.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我的关于页面的渲染，就像我们期望的那样。我们有一个`h1`标签，显示得很大，我们有一个段落标签，显示如下。到目前为止，我们已经使用了hbs，但实际上我们还没有使用它的任何功能。现在，我们正在渲染一个动态页面，所以我们可能根本不需要它。我想要做的是讨论一下我们如何在模板中注入数据。
- en: Injecting data inside of templates
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板中注入数据
- en: 'Let''s come up with some things that we want to make dynamic inside our handlebars
    file. First up, we''ll make this `h1` tag dynamic so the page name gets passed
    into the template in `about.hbs` page, and we''ll also add a footer. For now,
    we''ll just make that a simple `footer` tag:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想一些我们想要在handlebars文件中使动态的东西。首先，我们将使这个`h1`标签动态，以便页面名称传递到`about.hbs`页面中，我们还将添加一个页脚。现在，我们只需将其设置为一个简单的`footer`标签：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Inside of the `footer`, we''ll add a paragraph and that paragraph will have
    the copyright for our website. We''ll just say something like copyright followed
    by the year, which is 2018:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`footer`内，我们将添加一个段落，这个段落将包含我们网站的版权。我们只是说版权，然后是年份，2018年：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now year should also be dynamic, so that as the years change, we don't have
    to manually update our markup. We'll look at how to make both the 2018 and the
    about page dynamic, which means they're getting passed in instead of being typed
    in the handlebars file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在年份也应该是动态的，这样当年份变化时，我们不必手动更新我们的标记。我们将看看如何使2018年和关于页面都是动态的，这意味着它们被传递而不是在handlebars文件中输入。
- en: 'In order to do this, we''ll have to do two things:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要做两件事：
- en: We'll have to pass some data into the template. This will be an object a set
    of key value pairs, and
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将不得不将一些数据传递到模板中。这将是一个对象，一组键值对，
- en: We'll have to learn how to pull off some of those key-value pairs inside of
    our handlebars file
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将不得不学习如何在handlebars文件中提取一些键值对
- en: 'Passing in data is pretty simple. All we have to do is specify a second argument
    to `res.render` in `server.js`. This will take an object, and on this object we
    can specify whatever we like. We might have a `pageTitle` that gets set equal
    to `About Page`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 传递数据非常简单。我们所要做的就是在`server.js`中的`res.render`指定第二个参数。这将接受一个对象，在这个对象上，我们可以指定任何我们喜欢的东西。我们可能有一个`pageTitle`，它被设置为`About
    Page`：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have one piece of data getting injected in the template. It''s not used
    yet but it is indeed getting injected. We could also add another one like `currentYear`.
    We''ll put `currentYear` next to the `pageTitle` and we''ll set `currentYear`
    equal to the actual year off of the date JavaScript constructor. This will look
    something like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个数据片段被注入到模板中。虽然还没有被使用，但确实被注入了。我们也可以添加另一个，比如`currentYear`。我们将把`currentYear`放在`pageTitle`旁边，并将`currentYear`设置为JavaScript构造函数的实际年份。这将看起来像这样：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We'll create a new date which makes a new instance of the date object. Then,
    we'll use a method called `getFullYear`, which returns the year. In this case,
    it would return `2018`, just like this `.getFullYear`. Now we have a `pageTitle`
    and a `currentYear`. These are both getting passed in, and we can use them.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的日期，它将创建一个日期对象的新实例。然后，我们将使用一个叫做`getFullYear`的方法，它返回年份。在这种情况下，它将返回`2018`，就像这样`.getFullYear`。现在我们有了`pageTitle`和`currentYear`。这两者都被传递进来了，我们可以使用它们。
- en: 'In order to use these pieces of data, what we have to do inside of our template
    is use that handlebars syntax which looks a little bit like shown in the following
    code. We start by opening up two curly braces in the `h1` tag, then we close two
    curly braces. Inside the curly braces, we can reference any of the props we passed
    in. In this case, let''s use `pageTitle`, and inside our copyright paragraph,
    we''ll use, inside of double curly braces, `currentYear`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这些数据，我们在模板内部要使用handlebars语法，看起来有点像下面的代码。我们首先在`h1`标签中打开两个大括号，然后关闭两个大括号。在大括号内，我们可以引用我们传入的任何props。在这种情况下，让我们使用`pageTitle`，在我们的版权段落内，我们将使用双大括号内的`currentYear`：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With this in place, we now have two pieces of dynamic data getting injected
    inside our application. Now nodemon should have restarted in the background, so
    there''s no need to manually do anything there. When we refresh the page, we do
    still get About Page, which is great:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有两个动态数据片段被注入到我们的应用程序中。现在nodemon应该在后台重新启动了，所以没有必要手动做任何事情。当我们刷新页面时，我们仍然会得到About
    Page，这很好：
- en: '![](img/c7fde0ed-6f7e-46af-bb85-696c8299893f.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7fde0ed-6f7e-46af-bb85-696c8299893f.png)'
- en: This comes from the data we defined in `server.js`, and we get Copyright 2018
    showing up. Well this web page is pretty simple and doesn't look that interesting.
    At least you know how to create those servers and inject that data inside your
    web page. All you have to do from here is add some custom styles to get things
    looking nice.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这来自我们在`server.js`中定义的数据，我们得到了版权2018年。嗯，这个网页非常简单，看起来并不那么有趣。至少你知道如何创建那些服务器并将数据注入到你的网页中。从这里开始，你只需要添加一些自定义样式，让事情看起来不错。
- en: 'Before we go ahead, let''s move into the about file and swap out the title.
    Currently, it says `Help Page`. That''s left over from the public folder. Let''s
    change it to `Some Website`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们进入about文件并替换标题。目前，它说`Help Page`。这是从公共文件夹中留下的。让我们把它改成`Some Website`：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have this in place. Next, we''ll create a brand new template and
    that template is going to get rendered when someone visits the root of our website,
    the `/` route. Now currently, we render some JSON data:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这个位置。接下来，我们将创建一个全新的模板，当有人访问我们网站的根目录`/`时，这个模板将被渲染。现在，我们当前渲染一些JSON数据：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What we want to do is replace this with a call to `response.render`, rendering
    a brand new view.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是用`response.render`来替换这个，渲染一个全新的视图。
- en: Rendering the template for the root of the website
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染网站根目录的模板
- en: 'To get started, we''ll duplicate the `about.hbs` file so we can start customizing
    it for our needs. We''ll duplicate it, and call this one `home.hbs`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将复制`about.hbs`文件，这样我们就可以开始根据我们的需求定制它。我们将复制它，并将其命名为`home.hbs`：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now from here most things are going to stay the same. We''ll keep the `pageTitle`
    in place. We''ll also keep the `Copyright` and `footer` following. What we want
    to change though is this paragraph. It was fine that the `About Page` as a static
    one, but for the `home` page, we''ll set it equal to, inside curly braces, the
    `welcomeMessage` property:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，大部分事情都将保持不变。我们将保持`pageTitle`不变。我们还将保持`Copyright`和`footer`不变。但我们想要改变的是这个段落。`About
    Page`作为静态的是可以的，但对于`home`页面，我们将把它设置为，双大括号内的`welcomeMessage`属性：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now `welcomeMessage` is only going to be available on `home.hbs`, which is why
    we have specifying it in `home.hbs` but not in `about.hbs`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`welcomeMessage`只能在`home.hbs`上使用，这就是为什么我们在`home.hbs`中指定它而不在`about.hbs`中指定它。
- en: 'Next up, we needed to call response render inside of the callback. This will
    let us actually render the page. We''ll add `response.render`, passing in the
    template name we want to render. This one is called `home.hbs`. Then we''ll pass
    in our data:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在回调函数中调用response render。这将让我们实际渲染页面。我们将添加`response.render`，传入我们要渲染的模板名称。这个叫做`home.hbs`。然后我们将传入我们的数据：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now to get started, we can pass in the page title. We''ll set this equal to
    `Home Page` and we''ll pass in some sort of generic welcome message - `Welcome
    to my website`. Then we''ll pass in the `currentYear`, and we already know how
    to fetch the `currentYear: new Date()`, and on the date object, we''ll call the
    `getFullYear` method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '现在开始，我们可以传入页面标题。我们将把这个设置为`主页`，然后我们将传入一些通用的欢迎消息 - `欢迎来到我的网站`。然后我们将传入`currentYear`，我们已经知道如何获取`currentYear:
    new Date()`，并且在日期对象上，我们将调用`getFullYear`方法：'
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this in place, all we needed to do is save the file, which is automatically
    going to restart the server using nodemon and refresh the browser. When we do
    that, we get the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们所需要做的就是保存文件，这将自动使用nodemon重新启动服务器并刷新浏览器。当我们这样做时，我们会得到以下结果：
- en: '![](img/068646af-60ac-4dab-bef7-ba1ef545af9f.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/068646af-60ac-4dab-bef7-ba1ef545af9f.png)'
- en: 'We get our Home Page title, our Welcome to my website message, and my copyright
    with the year 2018\. And if we go to `/about`, everything still looks great. We
    have our dynamic page title and copyright and we have our static `some text here`
    text:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到我们的主页标题，我们的欢迎来到我的网站的消息，以及我的2018年版权。如果我们去到`/about`，一切看起来仍然很棒。我们有我们的动态页面标题和版权，以及我们的静态`some
    text here`文本：
- en: '![](img/ca92f075-3fb3-4cc9-91cc-920d441e035c.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca92f075-3fb3-4cc9-91cc-920d441e035c.png)'
- en: With this in place, we are now done with the very basics of handlebars. We see
    how this can be useful inside of a real-world web app. Aside from a realistic
    example such as the copyright, other reasons you might use this is to inject some
    sort of dynamic user data - things such as a username and email or anything else.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在已经完成了handlebars的基础知识。我们看到了这在现实世界的web应用中是如何有用的。除了像版权这样的现实例子，您可能使用它的其他原因是为了注入某种动态用户数据
    - 诸如用户名和电子邮件或其他任何东西。
- en: Now that we have a basic understanding about how to use handlebars to create
    static pages, we'll look at some more advanced features of hbs inside the next
    section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了如何使用handlebars创建静态页面，我们将在下一部分中看一些hbs的更高级功能。
- en: Advanced templates
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级模板
- en: In this section, we'll learn a few more advanced features that handlebars has
    to offer. This will make it easier to render our markup, especially markup that's
    used in multiple places, and it will make it easier to inject dynamic data into
    your web pages.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习一些更高级的功能，这些功能可以更容易地渲染我们的标记，特别是在多个地方使用的标记，它将更容易地将动态数据注入到您的网页中。
- en: 'In order to illustrate the first thing we''ll talk about, I want to open up
    both `about.hbs` and `home.hbs`, and you''ll notice down at the bottom that they
    both have the exact same footer code as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们将要谈论的第一件事，我想打开`about.hbs`和`home.hbs`，你会注意到底部它们都有完全相同的页脚代码如下：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We have a little copyright message for both and they both have the same header
    area, which is the `h1` tag.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两者都有一个小版权消息，它们都有相同的头部区域，即`h1`标签。
- en: Now this really isn't a problem because we have two pages, but as you add more
    and more pages it's going to become a real pain to update your header and your
    footer. You'll have to go into every file and manage the code there, but what
    we'll talk about instead is something called a partial.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这并不是问题，因为我们有两个页面，但随着您添加更多页面，更新页眉和页脚将变得非常麻烦。您将不得不进入每个文件并在那里管理代码，但我们将讨论的是另一种叫做partial的东西。
- en: Adding partials
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加partials
- en: A partial is a partial piece of your website. It's something you can reuse throughout
    your templates. For example, we might have a footer partial that renders the footer
    code. You can include that partial on any page you need a footer. You could do
    the same thing for header. In order to get started, the first thing we need to
    do is set up our `server.js` file just a little bit to let handlebars know that
    we want to add support for partials.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Partial是您网站的部分片段。这是您可以在模板中重复使用的东西。例如，我们可能有一个页脚partial来渲染页脚代码。您可以在任何需要页脚的页面上包含该partial。您也可以对页眉做同样的事情。为了开始，我们需要做的第一件事是稍微调整我们的`server.js`文件，让handlebars知道我们想要添加对partials的支持。
- en: 'In order to do this, we''ll add one line of code in the `server.js` file where
    we declared our view engine previously, and it will look something like this (`hbs.registerPartials`):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在`server.js`文件中添加一行代码，这是我们之前声明视图引擎的地方，它看起来会像这样（`hbs.registerPartials`）：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now `registerPartials` is going to take the directory you want to use for all
    of your handlebar partial files, and we''ll be specifying that directory as the
    first and only argument. Once again, this does need to be the absolute directory,
    so I''ll use the `__dirname` variable:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`registerPartials`将使用您想要用于所有handlebar部分文件的目录，并且我们将指定该目录作为第一个和唯一的参数。再次强调，这确实需要是绝对目录，所以我将使用`__dirname`变量：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Then we can concatenate the rest of the path, which will be `/views`. In this
    case, I want you to use `/partials`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以连接路径的其余部分，即`/views`。在这种情况下，我希望您使用`/partials`。
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We'll store our `partial` files right inside a directory in the `views` folder.
    Now we can create that folder right in views called `partials`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的`partial`文件直接放在`views`文件夹中的一个目录中。现在我们可以在views中创建一个名为`partials`的文件夹。
- en: 'Inside `partials`, we can put any of the handlebars partials we like. To illustrate
    how they work, we''ll create a file called `footer.hbs`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在`partials`中，我们可以放置任何我们喜欢的handlebars部分。为了说明它们是如何工作的，我们将创建一个名为`footer.hbs`的文件：
- en: '![](img/ba84974e-6997-4b86-8e65-909dd7912add.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba84974e-6997-4b86-8e65-909dd7912add.png)'
- en: 'Inside `footer.hbs`, we''ll have access to the same handlebars features, which
    means we can write some markup, we can inject variables, we can do whatever we
    like. For now, what we''ll do is copy the `footer` tag exactly, pasting it inside
    `footer.hbs`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在`footer.hbs`中，我们将可以访问相同的handlebars功能，这意味着我们可以编写一些标记，我们可以注入变量，我们可以做任何我们喜欢的事情。现在，我们将做的是粘贴`footer`标签，粘贴到`footer.hbs`中：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we have our `footer.hbs` file, this is the partial and we can include it
    in both `about.hbs` and `home.hbs`. In order to do that, we''ll delete the code
    that we already have in the partial and we''ll replace it with opening and closing
    two curly braces. Now instead of injecting data, we want to inject a template
    and the syntax for that is to add a greater than symbol with a space, followed
    by the partial name. In our case that partial is called `footer`, so we can add
    this right here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`footer.hbs`文件，这就是部分，我们可以在`about.hbs`和`home.hbs`中包含它。为了做到这一点，我们将删除部分中已有的代码，并用两个大括号打开和关闭它。现在，我们不再想要注入数据，而是想要注入一个模板，其语法是添加一个大于符号和一个空格，然后是部分名称。在我们的情况下，该部分称为`footer`，所以我们可以在这里添加它：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Then I can save about and do the same thing over in `home.hbs`. We now have
    our footer partial. It's rendering on both pages.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以保存`about`并在`home.hbs`中做同样的事情。我们现在有了我们的页脚部分。它在两个页面上都渲染出来了。
- en: Working of partial
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分的工作
- en: 'To illustrate how this works, I''ll fire up my server and by default `nodemon`;
    it''s not going to watch your handlebars files. So if you make a change, the website''s
    not going to render as you might expect. We can fix this by running `nodemon`,
    passing in `server.js` and providing the `-e` flag. This lets us specify all of
    the extensions we want to watch. In our case, we''ll watch the JS extension for
    the server file, and after the comma, the `hds` extension:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这是如何工作的，我将启动我的服务器，默认情况下是`nodemon`；它不会监视你的handlebars文件。所以如果你做出了更改，网站不会像你期望的那样渲染。我们可以通过运行`nodemon`，传入`server.js`并提供`-e`标志来解决这个问题。这让我们可以指定我们想要监视的所有扩展名。在我们的情况下，我们将监视服务器文件的JS扩展名，逗号后是`hds`扩展名：
- en: '![](img/004348dd-260d-4ad0-a181-cc8bbf7a467e.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/004348dd-260d-4ad0-a181-cc8bbf7a467e.png)'
- en: 'Now our app is up and running, we can refresh things over in the browser, and
    they should look the same. We have our about page with our footer:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序已经启动，我们可以在浏览器中刷新一下，它们应该看起来一样。我们有关于页面和页脚：
- en: '![](img/ed69beb8-6b66-417f-9b86-80b7f071f7e6.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed69beb8-6b66-417f-9b86-80b7f071f7e6.png)'
- en: 'We have our home page with the exact same footer:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主页上有完全相同的页脚：
- en: '![](img/cdb964aa-0e0c-4ab4-a6a6-0b566d19f7d7.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdb964aa-0e0c-4ab4-a6a6-0b566d19f7d7.png)'
- en: The advantage now is if we want to change that footer, we just do it in one
    place, in the `footer.hbs` file.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的优势是，如果我们想要更改页脚，我们只需在`footer.hbs`文件中进行更改。
- en: 'We can add something to our `footer` paragraph tag. Let''s add a little message
    created by `Andrew Mead` with a `-`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的`footer`段落标签中添加一些内容。让我们添加一个由`Andrew Mead`创建的小消息，带有一个`-`：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, save the file and when we refresh the browser, we have our brand new footer
    for Home Page:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存文件，当我们刷新浏览器时，我们有了全新的主页页脚：
- en: '![](img/3f195019-b92c-4349-8791-faa99b8c8804.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f195019-b92c-4349-8791-faa99b8c8804.png)'
- en: 'We have our brand new footer for About Page:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了关于页面的全新页脚：
- en: '![](img/c310e4de-e690-44d2-99f9-960964edaa74.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c310e4de-e690-44d2-99f9-960964edaa74.png)'
- en: It will show up for both the home page and the about page. There's no need to
    do you anything manual in either of these pages, and this is the real power of
    partials. You have some code, you want to reuse it inside your website, so you
    simply create a partial and you inject it wherever you like.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示在主页和关于页面上。在这两个页面中都不需要手动做任何事情，这就是部分的真正力量。你有一些代码，想要在网站内重用它，所以你只需创建一个部分，然后在你喜欢的地方注入它。
- en: The Header partial
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部部分
- en: Now that we have the footer partial in place, let's create the header partial.
    That means we'll need to create a brand new file `header.hbs`. We'll want to add
    the `h1` tag inside that file and then we'll render the partial in both `about.hbs`
    and `home.hbs`. Both pages should still look the same.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了页脚部分，让我们创建头部部分。这意味着我们需要创建一个全新的文件`header.hbs`。我们将想要在该文件中添加`h1`标签，然后在`about.hbs`和`home.hbs`中渲染部分。两个页面应该看起来一样。
- en: We'll get started by creating a new file in the partials folder called `header.hbs`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从头部文件夹中创建一个名为`header.hbs`的新文件。
- en: 'Inside `header.hbs`, we''ll take the `h1` tag from our website, paste it right
    inside and save it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在`header.hbs`中，我们将从我们的网站中取出`h1`标签，粘贴到里面并保存：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now we can use this header partial in both `about` and `home` files. Inside
    of `about`, we need to do this using the syntax, the double curly braces with
    the greater than sign, followed by the partial name `header`. We''ll do the exact
    same thing for the `home` page. In the `home` page, we''ll delete our `h1` tag,
    inject the `header` and save the file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`about`和`home`文件中使用这个头部部分。在`about`中，我们需要使用双大括号和大于符号的语法，然后是部分名称`header`。我们将在`home`页面上做完全相同的事情。在`home`页面上，我们将删除我们的`h1`标签，注入`header`并保存文件：
- en: '![](img/1d0cfc47-2614-44ef-8e51-d47e70a0c554.png)![](img/a934ac3e-cb8e-4907-b2a9-e117eedb29c3.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d0cfc47-2614-44ef-8e51-d47e70a0c554.png)![](img/a934ac3e-cb8e-4907-b2a9-e117eedb29c3.png)'
- en: 'Now we''d create something slightly different just so we can test that it actually
    is using the partial. We''ll type `123` right after the `h1` tag in `header.hbs`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一些略有不同的东西，以便我们可以测试它是否真的在使用部分。我们将在`header.hbs`中的`h1`标签后面输入`123`：
- en: '[PRE54]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that all the files are saved, we should be able to refresh the browser,
    and we see `about` page with 123 printing, which is fantastic:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有文件都已保存，我们应该可以刷新浏览器，看到打印的`about`页面上有123，这太棒了：
- en: '![](img/9d7c7b9a-77b3-4582-a586-c7f0ec7adf7f.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d7c7b9a-77b3-4582-a586-c7f0ec7adf7f.png)'
- en: 'This means the `header` partial is indeed working, and if I go back to the
    `home` page, everything still looks great:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`header`部分确实起作用，如果我回到`home`页面，一切看起来仍然很棒：
- en: '![](img/f84e2173-76d2-4852-b033-7ce62f5be9a4.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f84e2173-76d2-4852-b033-7ce62f5be9a4.png)'
- en: 'Now that we have the header broken out into its own file, we can do all sorts
    of things. We can take our `h1` tag and put it inside of a `header tag`, which
    is the appropriate way to declare your header inside of HTML. As shown, we add
    an opening and closing `header` tag. We can take the `h1` and we can move it right
    inside:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将标题拆分为自己的文件，我们可以做很多事情。我们可以将我们的`h1`标签放入`header标签`中，这是在HTML中声明标题的适当方式。如图所示，我们添加了一个打开和关闭的`header`标签。我们可以取出`h1`，然后将其放在里面：
- en: '[PRE55]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We could also add some links to the other pages on our website. We could add
    an anchor tag for the homepage by adding an `a` tag:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向我们网站的其他页面添加一些链接。我们可以通过添加`a`标签为主页添加一个锚标签：
- en: '[PRE56]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Inside the `a` tag, we''ll specify the link text we''d like to show up. I''ll
    go with `Home`, then inside the `href` attribute, we can specify the path the
    link should take you to, which would just be `/`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`a`标签内，我们将指定我们想要显示的链接文本。我会选择“主页”，然后在`href`属性内部，我们可以指定链接应该带您去的路径，即`/`：
- en: '[PRE57]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then we can take the same paragraph tag, copy it and paste it in the next line
    and make a link for the `about` page. I''ll change the page text to `About`, the
    link text, and the URL instead of going to `/` will go to `/about`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用相同的段落标签，复制它并粘贴到下一行，并为“about”页面创建一个链接。我会将页面文本更改为“关于”，链接文本和URL，而不是转到“/”，将转到“/about”：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we''ve made a change to our `header` file and it will be available on all
    of the pages of our website. I''m on the `home` page. If I refresh it, I get Home
    and About page links:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对我们的`header`文件进行了更改，并且它将在我们网站的所有页面上都可用。我在“home”页面。如果我刷新它，我会得到主页和关于页面的链接：
- en: '![](img/fc1ba9b1-502f-46ac-af10-ef18c95ff52f.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc1ba9b1-502f-46ac-af10-ef18c95ff52f.png)'
- en: 'I can click on the About to go to the About Page:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以点击“关于”去关于页面：
- en: '![](img/069951c9-aa95-4915-99a5-053cb121590b.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/069951c9-aa95-4915-99a5-053cb121590b.png)'
- en: Similarly, I can click on Home to come right back. All of this is much easier
    to manage now that we have partials inside of our website.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我可以点击主页直接返回。现在我们网站内部的所有这些都更容易管理。
- en: The Handlebars helper
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Handlebars助手
- en: Now before we go further, there is one more thing I want to talk about, that
    is, a handlebars helper. Handlebars helpers are going to be ways for us to register
    functions to run to dynamically create some output. For example, inside `server.js`,
    we currently inject the current year inside of both of our `app.get` templates
    and that's not really necessary.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们继续之前，我想谈谈另一件事，那就是handlebars助手。 Handlebars助手将是我们注册函数以动态创建一些输出的方式。例如，在`server.js`中，我们当前在我们的`app.get`模板中注入当前年份，这实际上并不是必要的。
- en: There is a better way to pass this data in, and this data shouldn't need to
    be provided because we'll always use the exact same function. We'll always take
    the new date `getfullYear` return value passing it in. Instead, we'll use a partial,
    and we'll set ours up right now. Now a partial is nothing more than a function
    you can run from inside of your handlebars templates.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更好的方法来传递这些数据，并且不需要提供这些数据，因为我们将始终使用完全相同的函数。我们将始终获取新日期`getfullYear`返回值并将其传递。相反，我们将使用部分，并且我们将立即设置我们的部分。现在，部分只不过是您可以从handlebars模板内部运行的函数。
- en: 'All we need to do is register it and I''ll do that in the `server.js`, following
    on from where we set up our Express middleware. As shown in the following code,
    we''ll call `hbs.register` and we''ll be registering a helper, so we''ll call
    a `registerHelper`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是注册它，我将在`server.js`中执行此操作，从我们设置Express中间件的位置继续。如下所示，我们将调用`hbs.register`，并且我们将注册一个助手，因此我们将调用`registerHelper`：
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now `registerHelper` takes two arguments:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`registerHelper`接受两个参数：
- en: The name of the helper as the first argument
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 助手的名称作为第一个参数
- en: The function to run as the second argument.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为第二个参数运行的函数。
- en: 'The first argument right here will be `getCurrentYear` in our case. We''ll
    create a helper that returns that current year:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个参数将是我们的`getCurrentYear`。我们将创建一个助手，返回当前年份：
- en: '[PRE60]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The second argument will be our function. I''ll use an arrow function (`=>`):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数将是我们的函数。我将使用箭头函数（`=>`）：
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Anything we return from this function will get rendered in place of the `getCurrentYear`
    call. That means if we call `getCurrentYear` inside the `footer`, it will return
    the year from the function, and that data is what will get rendered.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从此函数返回的任何内容都将在`getCurrentYear`调用的位置呈现。这意味着，如果我们在`footer`内部调用`getCurrentYear`，它将从函数返回年份，并且该数据将被呈现。
- en: 'In the `server.js`, we can return the year by using `return` and having the
    exact same code we have `app.get` object:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中，我们可以通过使用`return`并且具有与我们`app.get`对象完全相同的代码来返回年份：
- en: '[PRE62]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We''ll make a new date and we''ll call its `getFullYear` method. Now that we
    have a helper, we can remove this data from every single one of our rendering
    calls:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新日期，并调用其`getFullYear`方法。现在我们有了一个助手，我们可以从我们的每一个渲染调用中删除这些数据：
- en: '[PRE63]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This is going to be really fantastic because there really is no need to compute
    it for every page since it''s always the same. Now that we''ve removed that data
    from the individual calls to render, we will have to use `getCurrentYear` inside
    the `footer.hbs` file:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这将非常棒，因为实际上没有必要为每个页面计算它，因为它总是相同的。现在我们已经从渲染的各个调用中删除了这些数据，我们将不得不在`footer.hbs`文件中使用`getCurrentYear`：
- en: '[PRE64]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Instead referencing the current year, we will use the helper `getCurrentYear`,
    and there's no need for any special syntax. When you use something inside curly
    braces that clearly isn't a partial, handlebars is first going to look for a helper
    with that name. If there is no helper, it'll look for a piece of data with that
    `getCurrentYear` name.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是引用当前年份，我们将使用助手`getCurrentYear`，并且不需要任何特殊语法。当您在花括号内使用某些东西时，显然不是部分，handlebars首先会查找具有该名称的助手。如果没有助手，它将查找具有`getCurrentYear`名称的数据片段。
- en: 'In this case, it will find the helper, so everything will work as expected.
    We can now save `footer.hbs`, move into the browser, and give things a refresh.
    When I refresh the page, we still get Copyright 2018 in Home Page:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它将找到辅助程序，因此一切都将按预期工作。现在我们可以保存`footer.hbs`，返回浏览器，然后刷新。当我刷新页面时，我们仍然在主页上得到版权2018：
- en: '![](img/3f8c5249-9726-429a-91a2-e4174faecd99.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f8c5249-9726-429a-91a2-e4174faecd99.png)'
- en: 'If I go to the About Page, everything looks great:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我去关于页面，一切看起来都很好：
- en: '![](img/9b2adade-57f5-471e-9eb1-6e080dbe07b9.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b2adade-57f5-471e-9eb1-6e080dbe07b9.png)'
- en: 'We can prove that data is coming back from our helper by simply returning something
    else. Let''s comment out our helper code in `server.js` and before the comment,
    we can use `return test`, just like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地返回其他内容来证明数据是从我们的辅助程序返回的。让我们在`server.js`中注释掉我们的辅助程序代码，并在注释之前，我们可以使用`return
    test`，就像这样：
- en: '[PRE65]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can now save `server.js`, refresh the browser, and we get tests showing
    up as shown here:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存`server.js`，刷新浏览器，然后我们会看到测试显示如下：
- en: '![](img/b006455a-30e6-4c48-89c2-4458f2c4ce80.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b006455a-30e6-4c48-89c2-4458f2c4ce80.png)'
- en: So the data that renders right after the Copyright word is indeed coming from
    that helper. Now we can remove the code so we return the proper year.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在版权词之后呈现的数据确实来自该辅助程序。现在我们可以删除代码，以便返回正确的年份。
- en: Arguments in Helper
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助程序中的参数
- en: Helpers can also take arguments, and this is really useful. Let's create a second
    helper that's going to be a capitalization helper. We'll call the helper `screamIt`
    and its job will be to take some text and it will return that text in uppercase.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助程序还可以接受参数，这真的很有用。让我们创建一个将成为大写辅助程序的第二个辅助程序。我们将称之为`screamIt`辅助程序，它的工作是获取一些文本，并以大写形式返回该文本。
- en: 'In order to do this, we will be calling `hbs.registerHelper` again. This helper
    will be called `screamIt`, and it will take a function because we do need to run
    some code in order to do anything useful:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将再次调用`hbs.registerHelper`。这个辅助程序将被称为`screamIt`，它将接受一个函数，因为我们确实需要运行一些代码才能做任何有用的事情：
- en: '[PRE66]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now `screamIt` is going to take `text` to scream and all it will do is call
    on that string the `toUpperCase` method. We''ll return `text.toUpperCase`, just
    like this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`screamIt`将接受要大声喊出的`text`，它将只是调用该字符串的`toUpperCase`方法。我们将返回`text.toUpperCase`，就像这样：
- en: '[PRE67]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now we can actually use `screamIt` in one of our files. Let's move into `home.hbs`.
    Here, we have our welcome message in the `p` tag. We'll remove it and we'll scream
    the welcome message. In order to pass data into one of our helpers, we first have
    to reference the helper by name, `screamIt`, then after a space we can specify
    whatever data we want to pass in as arguments.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的文件中实际使用`screamIt`。让我们进入`home.hbs`。在这里，我们在`p`标签中有我们的欢迎消息。我们将删除它，然后大声喊出欢迎消息。为了将数据传递给我们的辅助程序之一，我们首先必须按名称引用辅助程序`screamIt`，然后在空格后，我们可以指定要作为参数传递的任何数据。
- en: 'In this case, we''ll pass in the welcome message, but we could also pass in
    two arguments by typing a space and passing in some other variable which we don''t
    have access to:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将传递欢迎消息，但我们也可以通过键入一个空格并传递一些其他我们无法访问的变量来传递两个参数：
- en: '[PRE68]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For now, we''ll use it like this, which means we''ll call the `screamIt` helper,
    passing in one argument `welcomeMessage`. Now we can save `home.hbs`, move back
    into the browser, go to the Home Page and as shown following, we get WELCOME TO
    MY WEBSITE in all uppercase:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将像这样使用它，这意味着我们将调用`screamIt`辅助程序，传入一个参数`welcomeMessage`。现在我们可以保存`home.hbs`，返回浏览器，转到主页，如下所示，我们得到了WELCOME
    TO MY WEBSITE的全大写：
- en: '![](img/6d8cf895-07da-4939-ac78-a68c68bcae60.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d8cf895-07da-4939-ac78-a68c68bcae60.png)'
- en: Using handlebars helpers, we can create both functions that don't take arguments
    and functions that do take arguments. So when you need to do something to the
    data inside of your web page, you can do that with JavaScript. Now that we have
    this in place, we are done.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用handlebars辅助程序，我们可以创建既不带参数的函数，也带参数的函数。因此，当您需要在网页内部对数据执行某些操作时，可以使用JavaScript。现在我们已经做到了。
- en: Express Middleware
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express中间件
- en: 'In this section, you''ll learn how to use Express middleware. Express middleware
    is a fantastic tool. It allows you to add on to the existing functionality that
    Express has. So if Express doesn''t do something you''d like it to do, you can
    add some middleware and teach it how to do that thing. Now we''ve already used
    a little bit of middleware. In `server.js` file, we used some middleware and we
    teach Express how to read from a `static` directory, which is shown here:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用Express中间件。Express中间件是一个很棒的工具。它允许您添加到Express现有功能中。因此，如果Express没有做您想要做的事情，您可以添加一些中间件并教它如何做这件事。现在我们已经使用了一点中间件。在`server.js`文件中，我们使用了一些中间件，并教Express如何从`static`目录中读取，如下所示：
- en: '[PRE69]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We called `app.use`, which is how you register middleware, and then we provided
    the middleware function we want to use.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了`app.use`，这是您注册中间件的方式，然后我们提供了要使用的中间件函数。
- en: Now middleware can do anything. You could just execute some code such as logging
    something to the screen. You could make a change to the request or the response
    object. We'll do just that in the next chapter when we add API authentication.
    We'll want to make sure the right header is sent. That header will be expected
    to have an API token. We can use middleware to determine whether or not someone's
    logged in. Basically, it will determine whether or not they should be able to
    access a specific route, and we can also use middleware to respond to a request.
    We could send something back from the middleware, just like we would anywhere
    else, using `response.render` or `response.send`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在中间件可以做任何事情。您可以执行一些代码，例如将某些内容记录到屏幕上。您可以对请求或响应对象进行更改。在下一章中，当我们添加API身份验证时，我们将这样做。我们将确保发送正确的标头。该标头将期望具有API令牌。我们可以使用中间件来确定某人是否已登录。基本上，它将确定他们是否应该能够访问特定路由，我们还可以使用中间件来响应请求。我们可以像在任何其他地方一样，使用`response.render`或`response.send`从中间件发送一些内容回来。
- en: Exploring middleware
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索中间件
- en: 'In order to explore middleware, we''ll create some basic middleware. Just following
    where we call `app.use` registering our Express static middleware, we''ll call
    `app.use` again:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索中间件，我们将创建一些基本的中间件。在我们调用`app.use`注册我们的Express静态中间件之后，我们将再次调用`app.use`：
- en: '[PRE70]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now `app.use` is how you register middleware, and it takes a function. So,
    we''ll pass in an arrow function (`=>`):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`app.use`是用来注册中间件的方法，它接受一个函数。因此，我们将传递一个箭头函数（`=>`）：
- en: '[PRE71]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `use` function takes just one function. There is no need to add any other
    arguments. This function will get called with the request (`req`) object, the
    response (`res`) object and a third argument, `next`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`use`函数只接受一个函数。不需要添加任何其他参数。将使用此函数调用请求（`req`）对象，响应（`res`）对象和第三个参数`next`：'
- en: '[PRE72]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now request and response objects, these should seem familiar by now. They're
    the exact same arguments we get whenever we register a handler. The `next` argument
    is where things get a little trickier. The `next` argument exists so you can tell
    Express when your middleware function is done, and this is useful because you
    can have as much middleware as you like registered to a single Express app. For
    example, I have some middleware that serves up a directory. We'll write some more
    that logs some request data to the screen, and we could have a third piece that
    helps with application performance, keeping track of response times, all of that
    is possible.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请求和响应对象，现在应该看起来很熟悉。这些正是我们注册处理程序时得到的完全相同的参数。`next`参数是让事情变得有点棘手的地方。`next`参数存在是为了告诉Express何时完成您的中间件函数，这很有用，因为您可以将尽可能多的中间件注册到单个Express应用程序中。例如，我有一些中间件用于提供目录。我们将编写一些日志，将一些请求数据记录到屏幕上，我们还可以编写第三个部分，用于帮助应用程序性能，跟踪响应时间，所有这些都是可能的。
- en: 'Now inside `app.use` function, we can do anything we like. We might log something
    to the screen. We might make a database request to make sure a user is authenticated.
    All of that is perfectly valid and we use the `next` argument to tell Express
    when we''re done. So if we do something asynchronous, the middleware is not going
    to move on. Only when we call `next`, will the application continue to run, like
    this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`app.use`函数内部，我们可以做任何我们喜欢的事情。我们可以将一些东西记录到屏幕上。我们可能会进行数据库请求，以确保用户已经通过身份验证。所有这些都是完全有效的，我们使用`next`参数告诉Express我们何时完成。因此，如果我们执行一些异步操作，中间件将不会继续。只有当我们调用`next`时，应用程序才会继续运行，就像这样：
- en: '[PRE73]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now this means if your middleware doesn''t call next, your handlers for each
    request, they''re never going to fire. We can prove this. Let''s call `app.use`,
    passing in an empty function:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果您的中间件不调用`next`，则每个请求的处理程序都不会触发。我们可以证明这一点。让我们调用`app.use`，传入一个空函数：
- en: '[PRE74]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s save the file and in the Terminal, we''ll run our app using `nodemon`
    with `server.js`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存文件，在终端中，我们将使用`server.js`运行我们的应用程序，使用`nodemon`：
- en: '[PRE75]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '![](img/786125db-b49b-4204-a886-583995fdfe2e.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/786125db-b49b-4204-a886-583995fdfe2e.png)'
- en: 'I''ll move into the browser and I''ll make a request for the home page. I''ll
    refresh the page and you can see that up top, it is trying to load but it''s never
    going to finish:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我将进入浏览器，然后请求主页。我将刷新页面，您可以看到顶部正在尝试加载，但永远不会完成：
- en: '![](img/af33b302-3460-4c7e-a230-c3fbf7165343.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af33b302-3460-4c7e-a230-c3fbf7165343.png)'
- en: 'Now it''s not that it can''t connect to the server. It connects to the server
    just fine. The real problem is that inside our app, we have middleware that doesn''t
    call next. To fix this, all we''ll do is call `next` like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题不是它无法连接到服务器。它可以很好地连接到服务器。真正的问题是在我们的应用程序内部，我们有一些不调用`next`的中间件。为了解决这个问题，我们只需这样调用`next`：
- en: '[PRE76]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now when things refresh over inside the browser, we get our Home Page exactly
    as we expect it:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当浏览器内部刷新时，我们得到了我们期望的主页：
- en: '![](img/ae177c74-2938-4f73-93a5-24a69c4240ba.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae177c74-2938-4f73-93a5-24a69c4240ba.png)'
- en: The only difference is now we have a place where we can add on some functionality.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是现在我们有一个地方可以添加一些功能。
- en: Creating a logger
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建记录器
- en: Inside `app.use`, we're going to get started by creating a logger that will
    log out all of the requests that come in to the server. We'll store a timestamp
    so we can see exactly when someone made a request for a specific URL.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.use`内部，我们将开始创建一个记录器，记录所有发送到服务器的请求。我们将存储一个时间戳，以便我们可以看到某人何时请求特定URL。
- en: 'To get started inside the middleware, let''s get the current time. I''ll make
    a variable called now, setting it equal to `newDate`, creating a new instance
    of our date object, and I''ll call it `toString` method:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件内部开始，让我们获取当前时间。我将创建一个名为`now`的变量，将其设置为`newDate`，创建我们的日期对象的一个新实例，并调用`toString`方法：
- en: '[PRE77]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `toString` method creates a nice formatted date, a human-readable timestamp.
    Now that we have our now variable in place, we can start creating the actual logger
    by calling `console.log`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString`方法创建一个格式良好的日期，一个可读的时间戳。现在我们有了我们的`now`变量，我们可以通过调用`console.log`来开始创建实际的记录器。'
- en: 'Let''s call `console.log`, passing in whatever I like. Let''s pass in inside
    of ticks the `now` variable with a colon after:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用`console.log`，传入我喜欢的任何内容。让我们在反引号内传入`now`变量，并在后面加上一个冒号：
- en: '[PRE78]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now if I save my file, things are going to restart in the Terminal because
    `nodemon` is running. When we make a request for the site again and we go into
    the Terminal, we should see the log:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我保存我的文件，因为`nodemon`正在运行，终端中的东西将重新启动。当我们再次请求网站并进入终端时，我们应该看到日志：
- en: '![](img/5019d745-4ca5-4c65-bfd7-5ad13577dc09.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5019d745-4ca5-4c65-bfd7-5ad13577dc09.png)'
- en: Currently it's just a timestamp, but we are on the right track. Now everything
    is working because we called `next`, so after this `console.log` call prints to
    the screen, our application continues and it serves up the page.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 目前只是一个时间戳，但我们正在正确的轨道上。现在一切都正常，因为我们调用了`next`，所以在这个`console.log`调用打印到屏幕后，我们的应用程序会继续并提供页面。
- en: Inside middleware, we can add on more functionality by exploring the request
    object. On the request object, we have access to everything about the request—the
    HTTP method, the path, query parameters, and anything that comes from the client.
    Whether the client is an app, a browser, or an iPhone, it is all going to be available
    in that request object. Two things we'll pull off now are the HTTP method and
    the path.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件中，我们可以通过探索请求对象添加更多功能。在请求对象上，我们可以访问有关请求的一切内容-HTTP方法、路径、查询参数以及来自客户端的任何内容。无论客户端是应用程序、浏览器还是iPhone，所有这些都将在请求对象中可用。现在我们要提取的是HTTP方法和路径。
- en: 'If you want to look at a full list of the things you have access to, you can
    go to [expressjs.com](http://expressjs.com/), and go to API reference:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看您可以访问的所有内容的完整列表，可以转到[expressjs.com](http://expressjs.com/)，并转到API参考：
- en: '![](img/b8dfc130-d80e-4dc5-a326-3f6e706eff44.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8dfc130-d80e-4dc5-a326-3f6e706eff44.png)'
- en: 'We happen to be using a 4.x version of Express, so we''ll click that link:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们碰巧使用的是Express的4.x版本，因此我们将点击该链接：
- en: '![](img/7e612137-1291-4772-b708-fba531456141.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e612137-1291-4772-b708-fba531456141.png)'
- en: 'On the right-hand side of this link, we have both Request and Response. We''ll
    look for the request objects, so we''ll click that. This''ll lead us to the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在此链接的右侧，我们有请求和响应。我们将查找请求对象，因此我们将点击它。这将引导我们到以下内容：
- en: '![](img/07ed8d23-0f1d-49c2-b06c-4454be7ab31e.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07ed8d23-0f1d-49c2-b06c-4454be7ab31e.png)'
- en: 'We''ll be using two request properties: `req.url` and `req.method`. Inside
    Atom, we can start implementing those, adding them into `console.log`. Right after
    the timestamp, we''ll print the HTTP method. We''ll be using other methods later.
    For now we''ve only used the `get` method. Right inside the `console.log`, I''ll
    inject `request.method` printing it to the console:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个请求属性：`req.url`和`req.method`。在Atom中，我们可以开始实现这些，将它们添加到`console.log`中。在时间戳之后，我们将打印HTTP方法。稍后我们将使用其他方法。目前我们只使用了`get`方法。在`console.log`中，我将注入`request.method`，将其打印到控制台：
- en: '[PRE79]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next up we can print the path so we know exactly what page the person requested.
    I''ll do that by injecting another variable, `req.url`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以打印路径，以便我们确切知道用户请求的是哪个页面。我将通过注入另一个变量`req.url`来实现：
- en: '[PRE80]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'With this in place, we now have a pretty useful piece of middleware. It takes
    the request object, it spits out some information and then it moves on, letting
    the server process that request which was added. If we save the file and rerun
    the app from the browser, we should be able to move into the Terminal and see
    this new logger printing to the screen, and as shown following we get just that:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有一个相当有用的中间件。它获取请求对象，输出一些信息，然后继续让服务器处理该请求。如果我们保存文件并从浏览器重新运行应用程序，我们应该能够进入终端并看到这个新的记录器打印到屏幕上，如下所示：
- en: '![](img/ba650386-32a1-40b2-8293-741d8abe62a8.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba650386-32a1-40b2-8293-741d8abe62a8.png)'
- en: 'We have our timestamp, the HTTP method which is `GET`, and the path. If we
    change the path to something more complicated, such as `/about`, and we move back
    into the Terminal, we''ll see the `/about` where we accessed `req.url`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的时间戳、HTTP方法是`GET`，以及路径。如果我们将路径更改为更复杂的内容，例如`/about`，然后我们返回到终端，我们将看到我们访问`req.url`的`/about`：
- en: '![](img/ff7dc6f1-8c40-40b2-a8ea-33cff4af309b.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff7dc6f1-8c40-40b2-a8ea-33cff4af309b.png)'
- en: Now this is a pretty basic example of some middleware. We can take it a step
    further. Aside from just logging a message to the screen, we'll also print the
    message to a file.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当基本的中间件示例。我们可以再进一步。除了只是将消息记录到屏幕上，我们还将把消息打印到文件中。
- en: Printing message to file
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将消息打印到文件
- en: 'To print the message to a file, let''s load in `fs` up in the `server.js` file.
    We''ll create a constant. Call that `const fs` and set that equal to the return
    result from requiring the module:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 要将消息打印到文件中，让我们在`server.js`文件中加载`fs`。我们将创建一个常量。将其命名为`const fs`，并将其设置为从模块中获取的返回结果：
- en: '[PRE81]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we can implement this down following in the `app.use`. We''ll take our
    template string, which is currently defined inside `console.log`. We''ll cut it
    out and instead store in a variable. We''ll make a variable called `log`, setting
    it equal to that template string as shown here:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`app.use`中实现这一点。我们将使用当前在`console.log`中定义的模板字符串。我们将把它剪切出来，而是存储在一个变量中。我们将创建一个名为`log`的变量，将其设置为如下所示的模板字符串：
- en: '[PRE82]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now we can pass that `log` variable into both `console.log` and into an `fs`
    method to write to our file system. For `console.log`, we will call log like this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`log`变量传递给`console.log`和`fs`方法，以便写入我们的文件系统。对于`console.log`，我们将像这样调用log：
- en: '[PRE83]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'For `fs`, I''ll call `fs.appendFile`. Now as you remember, `appendFile` lets
    you add on to a file. It takes two arguments: the file name and the thing we want
    to add. The file name we''ll use is `server.log`. We''ll create a nice log file
    and the actual contents will just be the `log` message. We will need to add one
    more thing: we also want to move on to the next line after every single request
    gets logged, so I''ll concatenate the new line character, which will be `\n`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`fs`，我将调用`fs.appendFile`。现在您记得，`appendFile`允许您添加到文件中。它需要两个参数：文件名和我们要添加的内容。我们将使用的文件名是`server.log`。我们将创建一个漂亮的日志文件，实际内容将只是`log`消息。我们需要添加一件事：我们还希望在每个请求被记录后继续下一行，因此我将连接新行字符，即`\n`：
- en: '[PRE84]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If you're using Node V7 or greater, you will need to make a small tweak to this
    line. As shown in the following code, we added a third argument to `fs.appendFile`.
    This is a callback function. It's now required.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Node V7或更高版本，则需要对此行进行微小调整。如下面的代码所示，我们向`fs.appendFile`添加了第三个参数。这是一个回调函数。现在是必需的。
- en: '`fs.appendFile(''server.log'', log + ''\n'', (err) => {`'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.appendFile(''server.log'', log + ''\n'', (err) => {`'
- en: '`  if (err) {`'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`  if (err) {`'
- en: '`    console.log(''Unable to append to server.log.'')`'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`    console.log(''Unable to append to server.log.'')`'
- en: '`  }`'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`  }`'
- en: '`});` If you don''t have a callback function, you''ll get a deprecation warning
    over inside the console. Now as you can see, our callback function here takes
    an error argument. If there is an error, we just print a message to the screen.
    If you change your line to look like this, regardless of your Node version, you''ll
    be future proof. If you''re on Node V7 or greater, the warning in the console
    will go away. Now the warning is going to say something such as deprecation warning.
    Calling an asynchronous function without callback is deprecated. If you see that
    warning, make this change.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`如果你没有回调函数，你会在控制台中得到一个弃用警告。现在你可以看到，我们的回调函数在这里接受一个错误参数。如果有错误，我们只是在屏幕上打印一条消息。如果你将你的行改成这样，无论你的Node版本如何，你都将是未来的保障。如果你使用的是Node
    V7或更高版本，控制台中的警告将消失。现在警告将会说一些诸如弃用警告。调用异步函数而没有回调是被弃用的。如果你看到这个警告，做出这个改变。'
- en: 'Now that we have this in place, we can test things out. I save the file, which
    should be restarting things inside of `nodemon`. Inside Chrome, we can give the
    page a refresh. If we head back into the Terminal, we do still get my log, which
    is great:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪，我们可以测试一下。我保存文件，这应该重新启动`nodemon`中的东西。在Chrome中，我们可以刷新页面。如果我们回到终端，我们仍然可以得到我的日志，这很棒：
- en: '![](img/8784f004-8b24-4050-930b-229304d7d367.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8784f004-8b24-4050-930b-229304d7d367.png)'
- en: Notice we also have a request for a `favicon.ico`. This is usually the icon
    that's shown in the browser tab. I have one cached from a previous project. There
    actually is no icon file defined, which is totally fine. The browser still makes
    the request anyway, which is why that shows up as shown in the previous code snippet.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还有一个对`favicon.ico`的请求。这通常是在浏览器标签中显示的图标。我从以前的项目中缓存了一个。实际上并没有定义图标文件，这完全没问题。浏览器仍然会发出请求，这就是为什么它显示在前面的代码片段中。
- en: 'Inside Atom, we now have our `server.log` file, and if we open it up, we have
    a log of all the requests that were made:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，我们现在有了我们的`server.log`文件，如果我们打开它，我们可以看到所有已经发出的请求的日志：
- en: '![](img/9f3671b8-59e9-4f0a-87ce-94914298c519.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f3671b8-59e9-4f0a-87ce-94914298c519.png)'
- en: We have timestamps, HTTP methods, and paths. Using `app.use`, we were able to
    create some middleware that helps us keep track of how our server is working.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时间戳，HTTP方法和路径。使用`app.use`，我们能够创建一些中间件，帮助我们跟踪服务器的工作情况。
- en: Now there are times where you might not want to call next. We learned that we
    could call next after we do something asynchronous, such as a read from a database,
    but imagine something goes wrong. You can avoid calling next to never move on
    to the next piece of middleware. We would like to create a new view inside the
    `views` folder. We'll call this one `maintenance.hbs`. This will be a handlebars
    template that will render when the site is in maintenance mode.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有时候你可能不想调用next。我们学到了在做一些异步操作后可以调用next，比如从数据库中读取，但想象一下出了问题。你可以避免调用next来阻止移动到下一个中间件。我们想在`views`文件夹中创建一个新的视图。我们将称之为`maintenance.hbs`。这将是一个handlebars模板，当网站处于维护模式时将进行渲染。
- en: The maintenance middleware without the next object
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有next对象的维护中间件
- en: 'We''ll start with making the `maintenance.hbs` file by duplicating `home.hbs`.
    Inside `maintenance.hbs`, all we''ll do is wipe the body and add a few tags:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从复制`home.hbs`开始制作`maintenance.hbs`文件。在`maintenance.hbs`中，我们将擦除body并添加一些标签：
- en: '[PRE85]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'As shown in the following code, we''ll add an `h1` tag to print a little message
    to the user:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，我们将添加一个`h1`标签来向用户打印一条小消息：
- en: '[PRE86]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We''re going to use something like `We''ll be right back`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类似`我们马上回来`的东西：
- en: '[PRE87]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, I can add a paragraph tag:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我可以添加一个段落标签：
- en: '[PRE88]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now we will be able to use `p` followed by the tab. This is a shortcut inside
    Atom for creating an HTML tag. It works for all tags. We could type body and hit
    *enter* or I could type `p` and press *enter*, and the tag will be created.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将能够使用`p`后跟制表符。这是Atom中用于创建HTML标签的快捷方式。它适用于所有标签。我们可以输入body并按*enter*，或者我可以输入`p`并按*enter*，标签就会被创建。
- en: 'Inside the paragraph, I''ll leave a little message: `The site is currently
    being updated`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在段落中，我会留下一条小消息：`网站目前正在更新`：
- en: '[PRE89]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now that we have our template file in place, we can define our maintenance middleware.
    This is going to bypass all of our other handlers, where we render other files
    and print JSON, and instead it'll just render this template to the screen. We'll
    save the file, move into `server.js`, and define that middleware.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了模板文件，我们可以定义我们的维护中间件。这将绕过我们的所有其他处理程序，其中我们渲染其他文件并打印JSON，而是直接将此模板呈现到屏幕上。我们保存文件，进入`server.js`，并定义该中间件。
- en: 'Right next to the previously-defined middleware, we can call `app.use` passing
    in our function. The function will take those three arguments: request (`req`),
    response (`res`), and `next`:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 就在之前定义的中间件旁边，我们可以调用`app.use`，传入我们的函数。该函数将使用这三个参数：请求（`req`），响应（`res`）和`next`：
- en: '[PRE90]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Inside the middleware, all we''ll need to do is call `res.render`. We''ll add
    `res.render` passing in the name of the file we want to render; in this case,
    it''s `maintenance.hbs`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件中，我们需要做的就是调用`res.render`。我们将添加`res.render`，传入我们想要渲染的文件的名称；在这种情况下，它是`maintenance.hbs`：
- en: '[PRE91]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: That is all you needed to do to set up our main middleware. This middleware
    will stop everything after it from executing. We don't call next, so the actual
    handlers in the `app.get` function, they will never get executed and we can test
    this.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要做的一切来设置我们的主要中间件。这个中间件将阻止它之后的一切执行。我们不调用next，所以实际的处理程序在`app.get`函数中，它们将永远不会被执行，我们可以测试这一点。
- en: Testing the maintenance middleware
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试维护中间件
- en: 'Inside the browser, we''ll refresh the page, and we will get the following
    output:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们将刷新页面，然后我们将得到以下输出：
- en: '![](img/15cdba39-3814-4d5c-91b8-8469871735bf.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15cdba39-3814-4d5c-91b8-8469871735bf.png)'
- en: 'We get the maintenance page. We can go to the home page and we get the exact
    same thing:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了维护页面。我们可以转到主页，然后得到完全相同的东西：
- en: '![](img/31b494e9-7a29-4e75-92d3-bf6a7ad5b1ef.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31b494e9-7a29-4e75-92d3-bf6a7ad5b1ef.png)'
- en: 'Now there''s one more really important piece to middleware we haven''t discussed
    yet. Remember inside the `public` folder, we have a `help.html` file as shown
    here:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在还有一个非常重要的中间件部分我们还没有讨论。请记住，在`public`文件夹中，我们有一个`help.html`文件，如下所示：
- en: '![](img/e3635d59-628c-4081-b745-dd4e9fbc077a.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3635d59-628c-4081-b745-dd4e9fbc077a.png)'
- en: 'If we visit this in the browser by going to `localhost:3000/help.html`, we''ll
    still get the help page. We''ll not get the maintenance page:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过在浏览器中访问`localhost:3000/help.html`来查看这个问题，我们仍然会得到帮助页面。我们不会得到维护页面：
- en: '![](img/5e1d306a-d8c2-4e18-a5b9-850007ada37c.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e1d306a-d8c2-4e18-a5b9-850007ada37c.png)'
- en: 'That is because middleware is executed in the order you call `app.use`. This
    means the first thing we do is we set up our Express static directory, then we
    set up our logger, and finally we set up our `maintenance.hbs` logger:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为中间件是按照调用`app.use`的顺序执行的。这意味着我们首先设置Express静态目录，然后设置日志记录器，最后设置`maintenance.hbs`日志记录器：
- en: '[PRE92]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is a pretty big problem. If we also want to make the `public` directory
    files such as `help.html` private, we'll have to reorder our calls to `app.use` because
    currently the Express server is responding inside of the Express static middleware,
    so our maintenance middleware doesn't get a chance to execute.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当大的问题。如果我们还想使`public`目录文件（如`help.html`）私有，我们将不得不重新调整我们对`app.use`的调用，因为当前Express服务器正在Express静态中间件内响应，因此我们的维护中间件没有机会执行。
- en: 'To resolve this, we''ll take the `app.use` Express static call, remove it from
    the file, and add it after we render the maintenance file to the screen. The resultant
    code is going to look like this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将采取`app.use` Express静态调用，从文件中删除，并在呈现维护文件到屏幕后添加。结果代码将如下所示：
- en: '[PRE93]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, everything will work as expected, no matter what we''re going to log the
    request. Then we''ll check if we''re in maintenance mode if the maintenance middleware
    function is in place. If it is, we''ll render the maintenance file. If it''s not,
    we''ll ignore it because it''ll be commented out or something like that, and finally
    we''ll be using Express static. This is going to fix all those problems. If I
    re-render the app now, I get the maintenance page on `help.html`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论我们要记录请求的内容，一切都将按预期工作。然后我们将检查是否处于维护模式，如果维护中间件函数已经就位。如果是，我们将呈现维护文件。如果不是，我们将忽略它，因为它将被注释掉或类似的情况，最后我们将使用Express静态。这将解决所有这些问题。如果我现在重新渲染应用程序，我会在`help.html`上看到维护页面：
- en: '![](img/68cc0afb-4c03-45d0-b33f-633917f27264.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68cc0afb-4c03-45d0-b33f-633917f27264.png)'
- en: 'If I go back to the root of the website, I still get the maintenance page:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我回到网站的根目录，我仍然会看到维护页面：
- en: '![](img/eed3d7c1-d744-4eac-8a19-c6cb715f7e0f.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eed3d7c1-d744-4eac-8a19-c6cb715f7e0f.png)'
- en: Now once we're done with the maintenance middleware, we can always comment it
    out. This will remove it from being executed, and the website will work as expected.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们完成了维护中间件，我们总是可以将其注释掉。这将使其不再被执行，网站将按预期工作。
- en: This has been a quick dive into Express middleware. We'll be using it a lot
    more throughout the book. We'll be using middleware to check if our API requests
    are actually authenticated. Inside the middleware, we'll be making a database
    request, checking if the user is indeed who they say they are.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Express中间件的一个快速潜入。我们将在整本书中更多地使用它。我们将使用中间件来检查我们的API请求是否真的经过了身份验证。在中间件内部，我们将进行数据库请求，检查用户是否确实是他们所说的那个人。
- en: Summary
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you learned about Express and how it can be used to easily create
    websites. We looked at how we can set up a static web server, so when we have
    an entire directory of JavaScript, images, CSS, and HTML. We can serve that up
    easily without needing to provide routes for everything. This will let us create
    all sorts of applications, which we'll be doing throughout the rest of the book.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了Express以及如何使用它轻松创建网站。我们看了如何设置静态Web服务器，因此当我们有整个目录的JavaScript、图像、CSS和HTML时，我们可以轻松地提供这些内容而无需为每个内容提供路由。这将让我们创建各种应用程序，这将贯穿整本书的内容。
- en: Next, we continued on learning how to use Express. We took a look at how we
    can render dynamic templates, kind of like we would with a PHP or Ruby on Rails
    file. We have some variables and we rendered a template injecting those variables.
    Then we learned a little bit about handlebars partials, which let us create reusable
    chunks of code like headers and footers. We also learned about Handlebars helpers,
    which is a way to run some JavaScript code from inside of your handlebars templates.
    Lastly, we moved back to talking about Express and how it can customize our requests,
    responses, our server.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们继续学习如何使用Express。我们看了一下如何呈现动态模板，有点像我们在PHP或Ruby on Rails文件中所做的那样。我们有一些变量，我们呈现了一个模板并注入了这些变量。然后我们学习了一些关于handlebars部分的知识，它让我们可以创建可重用的代码块，比如头部和页脚。我们还学习了关于Handlebars助手的知识，这是一种从handlebars模板内部运行一些JavaScript代码的方法。最后，我们回到了关于Express以及如何定制我们的请求、响应和服务器的讨论。
- en: In the next chapter, we'll look into deploying applications to the web.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将应用程序部署到网络上。
