- en: Scoping Variables with Different Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同模式的作用域变量
- en: In this chapter, we see the most basic concept that is a variable. Knowing what
    is the exact type, from a primitive to an object, is essential for accessing specific
    members. Scoping down the exact type at runtime and design time is crucial, to
    have consistency between the two environments and to have feedback about what
    is possible and what is not. The variety of configurations among the different
    types of variable requires many different patterns that are covered in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到最基本的概念是变量。知道确切类型，从原始类型到对象，对于访问特定成员至关重要。在运行时和设计时缩小确切类型至关重要，以确保两个环境之间的一致性，并了解可能性和不可能性。不同类型变量之间的配置多样性需要许多不同的模式，这些模式在本章中都有介绍。
- en: 'This chapter will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: How to compare at runtime and design time with `typeof`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `typeof` 在运行时和设计时进行比较
- en: How to check with a guarantee for `undefined` and `null`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保 `undefined` 和 `null` 的检查
- en: Do I need to check every possibility of a union to have the right type?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否需要检查联合的所有可能性以获得正确的类型？
- en: What is the limitation of `instanceof`?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instanceof` 的局限性是什么？'
- en: Why a discriminator is essential for type identification
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么区分器对于类型识别是必不可少的
- en: Why using `user` defined `guard`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用用户定义的 `guard`
- en: How and why to cast
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以及为什么进行类型转换
- en: What is a type assertion?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类型断言？
- en: How to compare classes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何比较类
- en: How to narrow type for function with a union in signatures
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在签名中具有联合类型的函数中缩小类型
- en: Comparing at runtime and design time with typeof
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 typeof 在运行时和设计时的比较
- en: TypeScript brings type in JavaScript, but this is mostly true at design type.
    TypeScript during compilation removes all the type. This is the reason that the
    code produced is purely JavaScript and does not contain any trace of interfaces
    or types. The purity of respect for JavaScript makes type comparison harder because
    it cannot rely on the name of the type to perform a type check. However, we can
    use all JavaScript's tricks to know whether a value is from a different type.
    The first feature answers the main question of this section about how to compare
    runtime and design type. The use of the JavaScript `typeof` operator that is present
    in JavaScript is also working the same way in TypeScript. The `typeof` operator returns
    the type of a primitive, or it returns `object`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将类型引入 JavaScript，但这主要是在设计类型时才成立。TypeScript 在编译过程中移除所有类型。这就是生成的代码是纯
    JavaScript 并且不包含任何接口或类型痕迹的原因。对 JavaScript 的纯粹尊重使得类型比较更加困难，因为它不能依赖于类型的名称来执行类型检查。然而，我们可以使用所有
    JavaScript 的技巧来知道一个值是否来自不同的类型。第一个特性回答了本节关于如何比较运行时和设计类型的主要问题。JavaScript 中存在的 `typeof`
    操作符在 TypeScript 中也是以相同的方式工作的。`typeof` 操作符返回原始类型的类型，或者返回 `object`。
- en: 'The usage is simple: call `typeof` followed by the variable that you want to
    compare it with. Most of the time, you will compare it to the name of the type
    that requires being written in a string:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用很简单：调用 `typeof` 后跟您想要比较的变量。大多数时候，您会将其与需要以字符串形式编写的类型名称进行比较：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `typeof` operator is especially used when having a union type where an
    object can be from many primitives. In fact, it can be used even with a union
    that has a complex object (interface or type) because `typeof` returns `object`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 操作符在具有联合类型时特别有用，其中对象可以来自多个原始类型。实际上，它甚至可以与具有复杂对象（接口或类型）的联合一起使用，因为 `typeof`
    返回 `object`：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To know which type of object the object is will require the use of other mechanisms
    that we will cover in this chapter. Before moving on, even if `typeOf` is comparable
    to a string, the result of the operation can be set a type:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道对象是哪种类型，将需要使用我们在本章中将要介绍的其他机制。在继续之前，即使 `typeOf` 可以与字符串比较，操作的结果可以设置一个类型：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that `typeOf` works on primitive types but behaves strangely with `undefined`
    or `null`. However, `undefined` will return `undefined` and null will return `object`.
    The best approach to check for `undefined` or `null` is to not use `typeof`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`typeOf` 在原始类型上工作，但与 `undefined` 或 `null` 交互时表现得很奇怪。然而，`undefined` 将返回 `undefined`，而
    `null` 将返回 `object`。检查 `undefined` 或 `null` 的最佳方法是不使用 `typeof`：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Differentiating undefined from null
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分 undefined 和 null
- en: 'While  `typeof` returns the `undefined` string when performing against an undefined
    type, it returns `object` against `null`. This inconsistency becomes an issue
    when you forget which case can use `typeof` by performing the wrong operation
    for the wrong `no type` type. However, `undefined` and `null` do not require the
    use of `typeof` to do a type check. It is possible to compare directly the variable
    against `undefined` or  `null`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `typeof` 对未定义类型执行时，它返回 `undefined` 字符串，而当它对 `null` 执行时，它返回 `object`。这种不一致性在你忘记哪个情况可以使用
    `typeof` 通过对错误的 `no type` 类型执行错误操作时成为一个问题。然而，`undefined` 和 `null` 不需要使用 `typeof`
    来进行类型检查。可以直接将变量与 `undefined` 或 `null` 进行比较：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In a situation where a variable can be undefined or null or any other primitive,
    the best way is to check for the nullability of the type and carry on with further
    type comparisons.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个变量可以是未定义、null 或任何其他原始类型的情况下，最好的方法是检查类型的可空性，并继续进行进一步的类型比较。
- en: Getting the type of element in a union
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取联合类型中的元素类型
- en: The TypeScript inference system gets better with every version. In the most
    recent version, TypeScript uses a control flow to find out in a smart way the
    type depending on how the code is written. If a check is performed in one code
    path, TypeScript knows that for the closure of the type validation that the type
    is as checked. If an *else* code path exists to a type check, it knows that it
    is the reverse of the type comparison.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的推理系统随着每个版本的更新而变得更好。在最新版本中，TypeScript 使用控制流以智能的方式根据代码的编写方式找出类型。如果一个检查在一个代码路径中执行，TypeScript
    就知道对于类型验证的闭包，类型就是检查过的。如果一个 `else` 代码路径存在到类型检查，它知道它是类型比较的反面。
- en: 'The following code example shows that depending on the position of the execution
    the type changes. It starts as a number or undefined. The value check against
    `undefined` makes the value narrow down to an undefined value for the scope of
    the `if`. The `else` can only be everything else than undefined in the union.
    In that particular case, it can only be a number. After `if` and `else`, TypeScript
    cannot know what the type is; thus, the value is back to both potential types:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示，根据执行的位置，类型会发生变化。它最初是数字或未定义。对 `undefined` 的值进行检查使得值缩小到 `if` 范围内的未定义值。`else`
    只能在联合类型中是除了未定义之外的所有值。在特定情况下，它只能是一个数字。在 `if` 和 `else` 之后，TypeScript 无法知道类型是什么；因此，值又回到了两种潜在类型：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'TypeScript understands the code flow. It is smart to freeze the type from a
    particular type check. In the following code example, a value equals to undefined
    force the function to return. It means that passing that point, there is no way
    to have an undefined value. The subtraction of `undefined` in the set of potential
    values diminishes the possibility to only a number:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 理解代码流。它很聪明，可以从特定的类型检查中冻结类型。在以下代码示例中，一个等于 `undefined` 的值迫使函数返回。这意味着通过那个点，就不可能有一个未定义的值。从潜在值的集合中减去
    `undefined` 减少了只有数字的可能性：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: TypeScript narrows down the union from your conditional check for more than
    a primitive. You can also use this behavior with a discriminator and a user-defined
    type guard, which are two patterns that we will see in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 会根据你的条件检查缩小联合类型，不仅仅是原始类型。你还可以使用这个行为与一个区分器和用户定义的类型守卫一起使用，这两种模式我们将在本章中看到。
- en: The limitations of instanceof
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`instanceof` 的限制'
- en: 'Similar to `typeof`, there is in JavaScript the `instanceof` operator. The
    limitation of `instanceof` is that it can be only used on a type with a prototype
    chain: a class. Like `typeof`, `instanceof` works at design and runtime and is
    native to JavaScript:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `typeof` 类似，JavaScript 中有 `instanceof` 操作符。`instanceof` 的限制是它只能用于具有原型链的类型：一个类。像
    `typeof` 一样，`instanceof` 在设计和运行时工作，并且是 JavaScript 的原生功能：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Contrary to `typeof`, the result of `instanceof` is not a string and cannot
    be used in the `console.log` function; it is possible to set the value in a type
    or in a variable. It can only be used for comparison purposes. The next example
    does not compile:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `typeof` 不同，`instanceof` 的结果不是一个字符串，不能用于 `console.log` 函数；它只能用于设置值在类型或变量中。它只能用于比较目的。下一个示例无法编译：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `instanceOf` limitations are beyond just being focused on class. The `instanceOf` operator
    also does not distinguish which class is exactly used in the situation of inheritance.
    In the next code example, the variable ` c` is of type `MyClass3`, which inherits
    `MyClass2`.  `InstanceOf` identifies the variable to be of both types. In the
    following code, both `if` are entered:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceOf` 限制不仅限于关注类。`instanceOf` 操作符也不区分在继承情况下确切使用了哪个类。在下一个代码示例中，变量 ` c`
    的类型是 `MyClass3`，它继承自 `MyClass2`。  `InstanceOf` 识别变量为两种类型。在以下代码中，两个 `if` 都被进入：'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using of a discriminator for type identification
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用判别器进行类型识别
- en: 'TypeScript is a structural language, which means that it does not rely on the
    name of the type like a nominal language. JavaScript doesn''t have a type; hence,
    it is a structural language. C# or Java are both nominal languages. The difference
    is important because it means that TypeScript doesn''t check for the name of the
    interface or type to take any decision. This makes sense when we think about how
    TypeScript compiles the code. During compilation, all types are stripped out of
    the code to produce a clean JavaScript. This symbiosis is in respect to JavaScript;
    thus, giving TypeScript the honor of being a superset of JavaScript. However,
    at runtime for TypeScript and design time for JavaScript, we need to know which
    type we are manipulating. In structural code, the approach is to analyze, compare,
    and infer type by looking at the structure. If specific members exist, it gives
    a hint of what we are working on. The following code example shows two identical
    interfaces with the same body, a type with the same structure as well, and the
    first variable with an anonymous type. The object can be of each type because
    it respects the contract of each one:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是一种结构化语言，这意味着它不像命名语言那样依赖于类型的名称。JavaScript 没有类型；因此，它是一种结构化语言。C# 或
    Java 都是命名语言。这种差异很重要，因为它意味着 TypeScript 不会检查接口或类型的名称来做出任何决定。当我们思考 TypeScript 如何编译代码时，这一点是有意义的。在编译过程中，所有类型都会从代码中剥离，以生成干净的
    JavaScript。这种共生关系是针对 JavaScript 的；因此，赋予 TypeScript 作为 JavaScript 超集的荣誉。然而，在 TypeScript
    的运行时和 JavaScript 的设计时，我们需要知道我们正在操作哪种类型。在结构化代码中，方法是通过分析、比较和通过观察结构来推断类型。如果存在特定的成员，它将给出我们正在处理的内容的提示。以下代码示例显示了两个具有相同主体的相同接口，一个与相同结构相同的类型，以及一个具有匿名类型的第一个变量。该对象可以是每种类型，因为它尊重每种类型的契约：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the previous example, the way to make every type different is with the concept
    of a discriminator. A **discriminator** is a member with a shared name between
    a group of a common type that needs to be distinguished. This group is often a
    union. The idea is to have a unique `string literal` per type with the same name.
    Having `string literal` as a type member requires the implementation to implement
    the same `string`. It means that each instance of a specific type will have the
    same `string`. TypeScript can then infer the type by looking at `string literal`.
    The following code example applies this principle. The common member is named
    `kind`*,* and each interface and type has a unique one. The anonymous type tries
    to impersonate `Type1` but fails because the type inferred is a `string` and not
    a `string literal`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使每种类型不同的方法是使用判别器的概念。**判别器**是在需要区分的一组共同类型之间具有共享名称的成员。这个组通常是一个联合。想法是每个类型都有一个具有相同名称的唯一
    `string literal`。将 `string literal` 作为类型成员需要实现实现相同的 `string`。这意味着特定类型的每个实例都将具有相同的
    `string`。TypeScript 可以通过查看 `string literal` 来推断类型。以下代码示例应用了这个原则。共同的成员被命名为 `kind`*，*每个接口和类型都有一个独特的
    `kind`。匿名类型试图模仿 `Type1`，但失败了，因为推断的类型是 `string` 而不是 `string literal`：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The discriminator proves to be useful not only for avoid cross type but also
    for narrowing down a type. In a union of many types, when comparing against the
    discriminator, TypeScript will know exactly the type and hence the scope of the
    comparison. The following code allows reducing to the exact type. In that particular
    case, the m1 member is a member that is in all three types and thus does not require
    to be narrowed down to a single type to be used:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 判别器证明不仅对于避免交叉类型有用，而且对于缩小类型范围也很有用。在许多类型的联合中，当与判别器进行比较时，TypeScript 将确切知道类型以及比较的范围。以下代码允许减少到确切类型。在特定情况下，m1
    成员是所有三种类型中都有的成员，因此不需要缩小到单个类型来使用：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we have an interface with completely different members, the distinction
    is primordial to have access to a member that is unique to one interface or another.
    The following code narrows down the interface, allowing it to use a member from
    the proper type, depending on the comparison:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个具有完全不同成员的接口，区分它们对于访问一个仅属于一个接口或另一个接口的成员是至关重要的。以下代码缩小了接口的范围，使其能够根据比较使用适当类型的成员：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The usage of a string literal as a discriminator is often named the **literal
    type guard** or the **tagged** **union**. It is powerful for functional programming
    and provides a quick way to identify a type without having to develop specific
    conditions as needed in other techniques such as a user-defined guard.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串字面量用作判别器的用法通常被称为**字面量类型守卫**或**标记** **联合体**。它在函数式编程中非常强大，提供了一种快速识别类型的方法，而无需像其他技术（如用户定义守卫）那样根据需要开发特定的条件。
- en: The user-defined guard pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义守卫模式
- en: 'Knowing the type of an interface or type can be challenging. We saw in this
    chapter the use of a discriminator. However, there is a drawback with the commonly
    named `string literal` approach, which is with inheritance and intersection. The
    following code does not compile:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 确定接口或类型的类型可能具有挑战性。在本章中，我们看到了判别器的使用。然而，对于通常称为`字符串字面量`的方法，存在一个缺点，即与继承和交集相关。以下代码无法编译：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The same is true with an intersection:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交集来说，情况也是如此：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last code example creates for the member kind a type that requires to be
    both `strings literal` at the same time make it impossible to fulfill and not
    practical. With that information to hand, we can see that the discriminator pattern
    works well when inheritance is avoided as well as intersecting. The idea is to
    use a custom user-defined guard per type. This can be cumbersome to create but
    will ensure you the type at design and runtime. The idea is to check for fields
    and see whether they are defined. This technique works well for a type with no
    optional field, since you need to check whether fields exist. As the author of
    the function and the type, you do not need to check every field. You should know
    which field is enough to identify the type. In the following code, both types
    exist, and one type extends the other. Two type user-defined guards are created—one
    for each interface:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个代码示例为成员类型创建了一个类型，这个类型要求同时是`字符串字面量`，这在实际操作中既不可能实现，也不实用。有了这些信息在手，我们可以看到，当避免继承和交集时，判别器模式工作得很好。这个想法是使用每个类型的自定义用户定义守卫。虽然创建起来可能有些繁琐，但可以确保你在设计和运行时都能得到该类型。这个想法是检查字段，看它们是否被定义。这种技术对于没有可选字段的类型工作得很好，因为你需要检查字段是否存在。作为函数和类型的作者，你不需要检查每个字段。你应该知道哪个字段足以识别类型。在下面的代码中，存在两种类型，其中一种类型扩展了另一种类型。创建了两个类型用户定义守卫——一个用于每个接口：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The function must know which of the two types are passed, and it checks by using
    the user-defined guard. The return type of the defined guard is unique. It uses
    the name of the parameter followed by *is* and the type we are expecting if the
    value is `true`. It allows to automatically narrow down to the expected type by
    comparing the structure. If everything is present and defined, it returns `true`,
    but the function will not return an actual `boolean` value. It returns the object
    cast to the type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 函数必须知道传递了两种类型中的哪一种，并且通过使用用户定义守卫来检查。定义守卫的返回类型是唯一的。它使用参数名称后跟*is*和如果我们期望的值是`true`，则期望的类型。它允许通过比较结构自动缩小到期望的类型。如果一切都在场并且已定义，它将返回`true`，但函数不会返回实际的`boolean`值。它返回将对象转换为该类型的对象。
- en: The reason to cast a type
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换的原因
- en: '**Casting** is the act of taking one type and transposing it onto something
    else. It is dangerous and should be used seldomly. The reason casting can have
    side effects is that you are taking manual control of coercing a variable into
    another type. The type may be creating an incompatible and unexpected result.
    A cast is possible for any kind of variable, from a primitive to a more-complex
    object.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型转换**是将一个类型转换到另一个类型上的行为。这是危险的，应该很少使用。类型转换可能产生副作用的原因是你正在手动控制将变量强制转换为另一种类型。类型可能创建不兼容和意外的结果。类型转换对于任何类型的变量都是可能的，从原始类型到更复杂的对象。'
- en: 'The most basic cast scenario is getting a value that is from `any` and to type
    it. The following code shows a number that is set in `any` and then cast to a
    variable of type number. You can notice two different ways to cast. One with the
    smaller and bigger symbol `<>` and one with `as`. The latter is the recommended
    way because it does not confuse code using TSX syntax, which uses the symbols
    for a component:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的类型转换场景是从 `any` 获取一个值并将其类型化。下面的代码显示了一个在 `any` 中设置的数字，然后将其转换为数字类型的变量。你可以注意到两种不同的转换方式。一种使用较小的和较大的符号
    `<>`，另一种使用 `as`。后者是推荐的方式，因为它不会混淆使用 TSX 语法（它使用组件的符号）的代码：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous code works because the cast went from `any` to `number`. Casting
    a number to a string does not work. The reason is that cast only works if you
    are working with a subtype. Furthermore, `any` is a subtype of everything, which
    allows casting to every type. However, the following code does not compile because
    `variable1` is a number that is cast to a string:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码之所以有效，是因为转换是从 `any` 到 `number`。将数字转换为字符串是不行的。原因是转换仅在您与子类型一起工作时才有效。此外，`any`
    是所有类型的子类型，这允许将类型转换为任何类型。然而，下面的代码无法编译，因为 `variable1` 是一个被转换为字符串的数字：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'TypeScript is also present to avoid casting between objects that miss fields.
    In the following code, both types cannot be cast to each other. TypeScript cannot
    find `m2` in `Type1`, and the second cast cannot find `m1` in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 也存在以避免在缺少字段的对象之间进行类型转换。在下面的代码中，这两种类型不能相互转换。TypeScript 在 `Type1` 中找不到
    `m2`，而在下面的代码中第二次转换找不到 `m1`：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, adding `m1` to `Type2` changes the whole situation and allows casting
    in both sides without any compilation errors. The reason is that `Type1` is a
    subtype of `Type2` by its structure, which is what matters in TypeScript:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将 `m1` 添加到 `Type2` 中会改变整个情况，并允许在两侧进行类型转换而不产生任何编译错误。原因是 `Type1` 通过其结构是 `Type2`
    的子类型，这是 TypeScript 中最重要的：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What is interesting about the last code is that the last cast is useless. The
    reason is that Type2 has all the structure of `Type1`, and `Type1` is a subtype
    of `Type2`. It means that they are structurally equivalent at a minimum point
    in their structure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码有趣的地方在于最后的转换是无用的。原因是 Type2 拥有 `Type1` 的所有结构，而 `Type1` 是 `Type2` 的子类型。这意味着它们在结构上的最小点是结构上等效的：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The casting is required for `t1` to `Type2` because `t1` doesn't fulfil the
    contract (it misses `m2` and `m3`). The cast produces a `false` `Type2` because
    `m2` and `m3` are not there, which means they are undefined. `Type2` does not
    have any undefined type for these members, which makes it problematic for future
    usage, since TypeScript will allow `m2` to use any string's function while this
    one is undefined. The casting comes with great responsibilities, and the tampering
    type will make TypeScript unable to perform safe validation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换对于 `t1` 到 `Type2` 是必需的，因为 `t1` 不满足合同（它缺少 `m2` 和 `m3`）。转换产生了一个 `false` 的
    `Type2`，因为 `m2` 和 `m3` 不存在，这意味着它们是未定义的。`Type2` 对于这些成员没有未定义的类型，这使得它在未来的使用中变得有问题，因为
    TypeScript 将允许 `m2` 使用任何字符串的函数，而此处的 `m2` 是未定义的。类型转换伴随着巨大的责任，而篡改类型将使 TypeScript
    无法执行安全验证。
- en: The slippery slope is steeper when a cast is affecting an object that is `any`.
    It's hard to avoid all  `any`. For example, when data is crossing between systems.
    An Ajax request returns a JSON object, which is an inevitability, as `any`. The
    response is not typed, and to introduce the value into TypeScript, a crucial cast
    is performed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型转换影响一个 `any` 类型的对象时，滑坡效应会更陡峭。很难避免所有的 `any`。例如，当数据在系统之间传递时。一个 Ajax 请求返回一个
    JSON 对象，这是不可避免的，因为它是一个 `any`。响应未进行类型化，要将值引入 TypeScript，必须执行一个关键的类型转换。
- en: 'A bad pattern is to cast to `any` and then to the desired type. This is a way
    to short-circuit TypeScript, finding that the cast is not a valid one. Everything
    can be cast to `any` and from any cast to everything else:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型转换为 `any` 然后转换为所需类型是一个坏的模式。这是绕过 TypeScript 的方法，发现转换不是有效的。任何东西都可以转换为 `any`，并且可以从任何类型转换到其他任何类型：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What is a type assertion?
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型断言是什么？
- en: There are scenarios where you know that a type is not undefined or null but
    that TypeScript will hint that it might be. When this happens, you can perform
    a check against `undefined` or `null` and within the closure of the condition
    will be a guarantee that the type is not nullable. However, three scenarios can
    benefit from having a shorter syntax.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '有一些场景，你知道一个类型不是未定义或 null，但 TypeScript 会暗示它可能是。当这种情况发生时，你可以对 `undefined` 或 `null`
    进行检查，并在条件的作用域内将保证类型不是可空的。然而，有三种场景可以从更短的语法中受益。 '
- en: 'The first scenario is with a deep-nesting object. In that case, you may have
    several levels of nullable fields and if you are sure that they are not undefined
    or null, this will be great to avoid having a nested `if` structure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景是深层嵌套的对象。在这种情况下，您可能有多个级别的可空字段，如果您确信它们不是undefined或null，这将有助于避免嵌套的`if`结构：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The conditional check is the safest way to ensure that nothing is undefined.
    However, in some cases, the check may have been made prior to accessing the data,
    but an access to the value is needed outside the scope of the check, which makes
    TypeScript nervous about `if` meanwhile, the state has changed. That would be
    the case if we tried to access `myNumber` right after the previous code. This
    is where `assertion` type comes into play. A `assertion` type is the bang operator,
    or exclamation point, after a member that specifies that the member is not null
    or undefined. You are asserting that this is the case and take the responsibility
    to *un-undefined* or to *un-nullable* to field.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 条件检查是确保没有未定义内容的最安全方式。然而，在某些情况下，检查可能是在访问数据之前进行的，但需要在检查范围之外访问值，这使得TypeScript对`if`语句感到不安，同时状态已发生变化。如果我们试图在之前的代码之后立即访问`myNumber`，就会发生这种情况。这就是`断言`类型发挥作用的地方。`断言`类型是成员后面的感叹号（或称为叹号），它指定该成员不是null或undefined。您正在断言这是事实，并承担起将字段*未定义*或*可空*的责任。
- en: 'It means that you can access the member by using a single line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以使用单行来访问成员：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is crucial to understand that this can lead to a potential runtime error
    if used at the wrong time. For some reason, any nullable field can become nullable
    if applied at the wrong time or place. There is no guarantee that the execution
    will succeed but will soothe TypeScript error saying that you are accessing a
    nullable field without narrowing it down to the type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点至关重要，因为如果在不恰当的时间使用，可能会导致潜在的运行时错误。由于某种原因，任何可空字段如果在错误的时间或位置应用，都可能变为可空。无法保证执行将成功，但会缓解TypeScript错误，指出您在未将其缩小到特定类型的情况下访问了可空字段。
- en: 'The second case of using type `assertion` is when you are defining a field
    in a class. If TypeScript is set to have the compilation strictness to avoid an
    uninitialized field, then you will have an error when defining a field and not
    specifying a value at the declaration or in the constructor. This is a great validation,
    but, in some rare cases, the value may come later in an `initialize` function.
    In that case, you can assert the class''s field to say that you are taking care
    of the value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型`断言`的第二种情况是在类中定义字段时。如果TypeScript设置为具有编译严格性以避免未初始化的字段，则在定义字段且未在声明或构造函数中指定值时，您将遇到错误。这是一个很好的验证，但在某些罕见情况下，值可能在`initialize`函数中稍后出现。在这种情况下，您可以断言类的字段，表明您正在处理该值：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once again, this should be used with parsimony, because it can bring some issues.
    For example, you can now access the member and use it without TypeScript validating
    that the value was assigned before accessing the value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这应该谨慎使用，因为它可能会带来一些问题。例如，现在您可以访问成员并使用它，而无需TypeScript验证在访问值之前值已被分配：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This might seem like a trifle, since you know that you will not do such a thing.
    But it can be less obvious. A case of error is that you are accessing the member
    from another public function that might be called before the `init` function causing
    any usage of the variable to be undefined. Type asserting forces TypeScript to
    close its eyes about uninitialized value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来微不足道，因为您知道您不会这样做。但有时可能不那么明显。一个错误的情况是，您从另一个可能在`init`函数之前被调用的公共函数中访问成员，这可能导致对变量的任何使用都未定义。类型断言迫使TypeScript对未初始化的值视而不见。
- en: 'The last scenario is also dangerous to use and should be coded only with a
    lot of care. You can at any time use the exclamation point to erase the nullability.
    It means that it works with a simple variable as well. The following code declares
    a variable of type string or undefined. It sets its value using a function that
    is immediately invoked. The function has a return type of also `string | undefined`.
    TypeScript concludes that this function may return one or both types, and hence
    could legally return something undefined. However, we know that it is not the
    case, and hence can use the exclamation point to remove the undefined possibility
    and use the string''s functions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况也是危险的，应该非常小心地编码。你可以在任何时候使用感叹号来消除可空性。这意味着它也适用于简单变量。以下代码声明了一个类型为字符串或 `undefined`
    的变量。它使用一个立即调用的函数来设置其值。该函数的返回类型也是 `string | undefined`。TypeScript 推断这个函数可能返回一个或两个类型，因此可以合法地返回
    `undefined`。然而，我们知道情况并非如此，因此可以使用感叹号来消除 `undefined` 的可能性，并使用字符串的函数：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, this is dangerous and a better way around it could be employed. The first
    thing is to avoid having a union with `undefined` or `null`. If this is out of
    your control, avoiding functions such as one of the last code examples that aslo
    return undefined. The same code with the return type of string would have solved
    the problem gracefully.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是危险的，可以采用更好的方法来避免。首先，要避免使用包含 `undefined` 或 `null` 的联合。如果这超出了你的控制范围，应避免使用像最后一个代码示例中那样也返回
    `undefined` 的函数。如果将返回类型改为字符串，问题就可以优雅地解决。
- en: Comparing classes
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类的比较
- en: 'Classes are different than interfaces, types, or primitives. They have a prototype
    chain and obey different rules. For example, two different classes can be interchangeable
    if they have the same structure. The following classes, `C1` and `C2`, are identical
    in terms of structure and can be swapped in the function that requires `C1`. You
    can even instantiate `C2` in a `C1` variable:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类与接口、类型或原始类型不同。它们有一个原型链并遵循不同的规则。例如，如果两个不同的类具有相同的结构，它们可以互换。以下类 `C1` 和 `C2` 在结构上是相同的，可以在需要
    `C1` 的函数中互换使用。你甚至可以在 `C1` 变量中实例化 `C2`：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we add in the `private` field in `C1` or `C2`, then it won''t be the same:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `C1` 或 `C2` 中添加 `private` 字段，那么它们就不会相同：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `private` and `protected` fields make each class unique. TypeScript continues
    to compare the structure but does make an exception with regard to these two visibility
    modifiers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` 和 `protected` 字段使每个类独一无二。TypeScript 继续比较结构，但在这些两个可见性修饰符方面会做出例外。'
- en: 'The reason is when using inheritance and assigning a child class to a base
    type it must be from the same hierarchy and not something with a similar shape
    that is not from the same hierarchy. The following code shows how without a `private`
    or a `protected` field the base class can be substituted by a single class that
    has the structure of the child and the base:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是当使用继承并将子类赋值给基类时，它必须来自相同的层次结构，而不是来自不同层次结构但形状相似的东西。以下代码展示了如果没有 `private` 或
    `protected` 字段，基类可以被具有子类和基类结构的单个类所替代：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, adding a `private` field at the base class `B1` and the same in `C2`
    makes them different, which stops `C2` being addressable to the variable `C2`
    of type `B1`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在基类 `B1` 中添加一个 `private` 字段，并在 `C2` 中添加相同的字段，这使得它们变得不同，阻止了 `C2` 被赋值给类型为 `B1`
    的变量 `C2`：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Narrowing type for function with a union in signatures
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数签名中使用联合类型的类型收缩
- en: 'Complex functions can be hard to work with. This is often the case with a function
    with one or many parameters of different types, which can also return one or several
    types. TypeScript allows stitching any type together:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的函数可能难以处理。这种情况通常发生在函数有一个或多个不同类型的参数，并且可以返回一个或多个类型时。TypeScript 允许将任何类型拼接在一起：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the previous code, the code is not compiling. The reason is because the
    function returns a union that must narrow down. However, if we add the overloads
    above the function, we can match the union to one particular set of parameters
    to a single return type. The previous code was not compiling because it was returning
    a union into a single type variable. With a change specifying that when a parameter
    is a number, then the function returns `boolean`, and when it is a string it returns
    a date, no casting or anything is required:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，代码无法编译。原因是函数返回一个必须缩小的联合类型。然而，如果我们在上面的函数中添加重载，我们可以将联合类型与单一返回类型的特定参数集匹配。前面的代码无法编译，因为它将联合类型返回到一个单一类型变量中。通过指定当参数是数字时函数返回`boolean`，而当它是字符串时返回日期，就不需要任何类型转换或其它操作：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is beyond just associating a single parameter to a return type. For example,
    in the following code, we make sure we can only send all number parameters together
    or all strings together:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是将单个参数关联到返回类型。例如，在下面的代码中，我们确保只能一起发送所有数字参数或所有字符串参数：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to have a better sense of the type of a variable.
    Not only does it help to take decisions, but it narrows down to a single type,
    giving the possibility to access specific members that are specific to a particular
    type.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何更好地理解变量的类型。这不仅有助于做出决策，而且可以将变量缩小到单一类型，从而有机会访问特定类型特有的特定成员。
- en: In the next chapter, we will see how to generalize a type by using a generic
    variable. Generic variables increase the reusability of objects and variables
    in your code, which reduces the necessity of creating trivial types.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何通过使用泛型变量来泛化类型。泛型变量增加了你代码中对象和变量的可重用性，从而减少了创建平凡类型的必要性。
