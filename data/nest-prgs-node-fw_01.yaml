- en: Chapter 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。介绍
- en: 'Every web developer relies heavily on one web framework or another (sometimes
    more if their services have different requirements) and companies will rely on
    many frameworks, but each has its own pros and cons. These frameworks provide
    just that, a frame for developers to build on top of, providing the basic functionality
    that any web framework must provide in order to be considered as a good choice
    for a developer or company to use in their tech stack. In this book, we will talk
    about many of those parts of the framework you would expect to see in a progressive
    framework such as Nest. These include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web开发人员都严重依赖于一个或多个Web框架（有时如果他们的服务有不同的要求，会使用更多），而公司将依赖于许多框架，但每个框架都有其优缺点。这些框架正是为开发人员提供一个框架，提供基本功能，任何Web框架必须提供这些功能，才能被认为是开发人员或公司在其技术栈中使用的一个好选择。在本书中，我们将讨论您期望在像Nest这样的先进框架中看到的框架的许多部分。这些包括：
- en: Dependency Injection
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Authentication
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证
- en: ORM
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ORM
- en: REST API
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST API
- en: Websockets
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Websockets
- en: Microservices
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务
- en: Routing
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由
- en: Explanation of Nest specific tools
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nest特定工具的解释
- en: OpenApi (Swagger) Documentation
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenApi（Swagger）文档
- en: Command Query Responsibility Segregation (CQRS)
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）
- en: Testing
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试
- en: Server-side rendering with Universal and Angular.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Universal和Angular进行服务器端渲染。
- en: 'Nest provides more of these features because it is a modern web framework built
    on top of a Node.js Express server. By leveraging the power of modern ES6 JavaScript
    for flexibility and TypeScript to enforce type safety during compile time, Nest
    helps bring scalable Node.js servers to a whole new level when designing and building
    server-side applications. Nest combines three different techniques into a winning
    combination that allows for highly testable, scalable, loosely coupled and maintainable
    applications. These are:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Nest提供了更多这些功能，因为它是建立在Node.js Express服务器之上的现代Web框架。通过利用现代ES6 JavaScript的弹性和TypeScript在编译时强制类型安全，Nest在设计和构建服务器端应用程序时将可扩展的Node.js服务器提升到一个全新的水平。Nest将三种不同的技术结合成一个成功的组合，允许高度可测试、可扩展、松散耦合和可维护的应用程序。这些技术包括：
- en: 'Object-Oriented Programming (OOP): A model that builds around objects instead
    of actions and reusability rather than niche functionality.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）：一个围绕对象而不是动作和可重用性而不是利基功能构建的模型。
- en: 'Functional Programming (FP): The designing of determinate functionality that
    does not rely upon global states, ie. a function f(x) returns the same result
    every time for some set parameters that do not change.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程（FP）：设计不依赖于全局状态的确定功能，即函数f(x)对于一些不变的参数每次返回相同的结果。
- en: 'Functional Reactive Programming (FRP): An extension of FP from above and Reactive
    programming. Functional Reactive Programming is at its core Functional Programming
    that accounts for a flow across time. It is useful in applications such as UI,
    simulations, robotics and other applications where the exact answer for a specific
    time period may differ from that of another time period.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式响应式编程（FRP）：是上述FP和响应式编程的扩展。函数式响应式编程在其核心是考虑时间流的函数式编程。它在UI、模拟、机器人和其他应用程序中非常有用，其中特定时间段的确切答案可能与另一个时间段的答案不同。
- en: Topics discussed
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论的主题
- en: Each of the topics below will be discussed in more detail in the following chapters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下每个主题将在接下来的章节中详细讨论。
- en: Nest CLI
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nest CLI
- en: 'New in version 5 of Nest there is a CLI that allows for command line generation
    of projects and files. The CLI can be installed globally with:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nest的第5版中，有一个CLI可以允许通过命令行生成项目和文件。可以通过以下命令全局安装CLI：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or through Docker with:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过Docker：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A new Nest project can be generated with the command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令生成新的Nest项目：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This process will create the project from a [typescript-starter](https://github.com/nestjs/typescript-starter)
    and will ask for the `name`, `description`, `version` (defaults to 0.0.0), and
    `author` (this would be your name). After this process is finished you will have
    a fully setup Nest project with the dependencies installed in your `node_modules`
    folder. The `new` command will also ask what package manager you would like to
    use, in the same way that either `yarn` or `npm` can be used. Nest gives you this
    choice during creation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将从[typescript-starter](https://github.com/nestjs/typescript-starter)创建项目，并将要求输入`name`，`description`，`version`（默认为0.0.0）和`author`（这将是您的名字）。完成此过程后，您将拥有一个完全设置好的Nest项目，并且依赖项已安装在您的`node_modules`文件夹中。`new`命令还将询问您想要使用哪种包管理器，就像`yarn`或`npm`一样。Nest在创建过程中为您提供了这个选择。
- en: 'The most used command from the CLI will be the `generate` (g) command, this
    will allow you to create new `controllers`, `modules`, `servies` or any other
    components that Nest supports. The list of available components is:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CLI中最常用的命令将是`generate`（g）命令，这将允许您创建Nest支持的新的`controllers`，`modules`，`servies`或任何其他组件。可用组件的列表如下：
- en: '`class` (cl)'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`class`（cl）'
- en: '`controller` (co)'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`controller`（co）'
- en: '`decorator` (d)'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`decorator`（d）'
- en: '`exception` (e)'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`exception`（e）'
- en: '`filter` (f)'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`filter`（f）'
- en: '`gateway` (ga)'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gateway`（ga）'
- en: '`guard` (gu)'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`guard`（gu）'
- en: '`interceptor` (i)'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interceptor`（i）'
- en: '`middleware` (mi)'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`middleware`（mi）'
- en: '`module` (mo)'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`module`（mo）'
- en: '`pipe` (pi)'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pipe`（pi）'
- en: '`provider` (pr)'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`provider`（pr）'
- en: '`service` (s)'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`service`（s）'
- en: 'Note that the string in the brackets is the alias for that specific command.
    This means that instead of typing:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，括号中的字符串是该特定命令的别名。这意味着您可以输入：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In your console, you can enter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，您可以输入：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lastly, the Nest CLI provides the `info` (i) command to display information
    about your project. This command will output information that looks something
    like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Nest CLI提供了`info`（i）命令来显示关于您的项目的信息。此命令将输出类似以下内容的信息：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Dependency Injection
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Dependency Injection is the technique of supplying a dependent object, such
    as a module or component, with a dependency like a service, thereby injecting
    it into the component’s constructor. An example of this taken from the sequelize
    chapter is below. Here we are injecting the `UserRespository` service into the
    constructor of the `UserService`, thereby providing access to the User Database
    repository from inside the `UserService` component.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种技术，它通过将依赖对象（如服务）注入到组件的构造函数中，从而将依赖对象（如模块或组件）提供给依赖对象。下面是来自sequelize章节的一个示例。在这里，我们将`UserRespository`服务注入到`UserService`的构造函数中，从而在`UserService`组件内部提供对用户数据库存储库的访问。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In turn this `UsersService` will be injected into the UsersController in the
    `src/users/users.controller.ts` file, which will provide access to the `UsersService`
    from the routes that point to this controller. More about Routes and Dependency
    injection in later chapters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，这个`UsersService`将被注入到`src/users/users.controller.ts`文件中的`UsersController`中，这将为指向该控制器的路由提供对`UsersService`的访问。更多关于路由和依赖注入的内容将在后面的章节中讨论。
- en: Authentication
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: Authentication is one of the most important aspects of developing. As developers,
    we always want to make sure that users can only access the resources they have
    permission to access. Authentication can take many forms, from showing your drivers
    license or passport to providing a username and password for a login portal. In
    recent years these authentication methods have expanded out to become more complicated,
    but we still need the same server-side logic to make sure that these authenticated
    users are always who they say they are and persist this authentication so they
    do not need to reauthenticate for every single call to a REST API or Websocket
    because that would provide a pretty terrible user experience. The chosen library
    for this is ironically named Passport as well, and is very well known and used
    in the Node.js ecosystem. When integrated into Nest it uses a JWT (JSON Web Token)
    strategy. Passport is a Middleware that the HTTP call is passed through before
    hitting the endpoint at the controller. This is the `AuthenticationMiddleware`
    written for the example project that extends `NestMiddleware`, authenticating
    each user based on the email in the request payload.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是开发中最重要的方面之一。作为开发人员，我们始终希望确保用户只能访问他们有权限访问的资源。认证可以采用多种形式，从展示您的驾驶执照或护照到为登录门户提供用户名和密码。近年来，这些认证方法已经扩展到变得更加复杂，但我们仍然需要相同的服务器端逻辑，以确保这些经过认证的用户始终是他们所说的那个人，并保持这种认证，这样他们就不需要为每次对REST
    API或Websocket的调用重新进行认证，因为那将提供非常糟糕的用户体验。选择的库恰好也被命名为Passport，并且在Node.js生态系统中非常知名和使用。在Nest中集成时，它使用JWT（JSON
    Web Token）策略。Passport是一个中间件，HTTP调用在到达控制器端点之前会经过它。这是为示例项目编写的`AuthenticationMiddleware`，它扩展了`NestMiddleware`，根据请求负载中的电子邮件对每个用户进行认证。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Nest also implements Guards, which are decoratorated with the same `@Injectable()`
    as other providers. Guards restrict certain endpoints based on what the authenticated
    user has access to. Guards will be discussed more in the Authentication chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Nest还实现了守卫，它们与其他提供者一样使用`@Injectable()`进行装饰。守卫基于经过认证的用户所拥有的访问权限来限制某些端点。守卫将在认证章节中进一步讨论。
- en: ORM
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ORM
- en: 'An ORM is an Object-relational mapping and is one of the most important concepts
    when dealing with communication between a server and a database. An ORM provides
    a mapping between objects in memory (Defined classes such a `User` or `Comment`)
    and Relational tables in a database. This allows you to create a Data Transfer
    Object that knows how to write objects stored in memory to a database, and read
    the results from an SQL or another query language, back into memory. In this book,
    we will talk about three different ORMs: two relational and one for a NoSQL database.
    TypeORM is one of the most mature and popular ORMs for Node.js and thus has a
    very wide and flushed out feature set. It is also one of the packages that Nest
    provides its own packages for: `@nestjs/typeorm`. It is incredibly powerful and
    has support for many databases like MySQL, PostgreSQL, MariaDB, SQLite, MS SQL
    Server, Oracle, and WebSQL. Along with TypeORM, Sequelize is also another ORM
    for relational data.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ORM是对象关系映射，是处理服务器和数据库之间通信时最重要的概念之一。ORM提供了内存中对象（如`User`或`Comment`这样的定义类）与数据库中的关系表之间的映射。这使您可以创建一个数据传输对象，它知道如何将存储在内存中的对象写入数据库，并从SQL或其他查询语言中读取结果，再次存入内存。在本书中，我们将讨论三种不同的ORM：两种关系型数据库和一种NoSQL数据库。TypeORM是Node.js中最成熟和最流行的ORM之一，因此具有非常广泛和完善的功能集。它也是Nest提供自己的包之一：`@nestjs/typeorm`。它非常强大，并支持许多数据库，如MySQL、PostgreSQL、MariaDB、SQLite、MS
    SQL Server、Oracle和WebSQL。除了TypeORM，Sequelize也是另一个用于关系数据的ORM。
- en: If TypeORM is one of the most popular ORMs, then Sequelize is THE most popular
    in the Node.js world. It is written in plain JavaScript but has TypeScript bindings
    through the `sequelize-typescript` and `@types/sequelize` packages. Sequelize
    boasts strong transaction support, relations, read replication and many more features.
    The last ORM covered in this book is one that deals with a non-relational, or
    NoSQL, database. The package `mongoose` handles object relations between MongoDB
    and JavaScript. The actual mapping between the two is much closer than with relational
    databases, as MongoDB stores its data in JSON format, which stands for JavaScript
    Object Notation. Mongoose is also one of the packages that has a `@nestjs/mongoose`
    package and provides the ability to query the database through query chaining.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果TypeORM是最受欢迎的ORM之一，那么Sequelize就是Node.js世界中最受欢迎的ORM。它是用纯JavaScript编写的，但通过`sequelize-typescript`和`@types/sequelize`包具有TypeScript绑定。Sequelize拥有强大的事务支持、关系、读取复制和许多其他功能。本书涵盖的最后一个ORM是处理非关系型或NoSQL数据库的ORM。包`mongoose`处理了MongoDB和JavaScript之间的对象关系。实际的映射比与关系数据库更接近，因为MongoDB以JSON格式存储其数据，JSON代表JavaScript对象表示法。Mongoose也是具有`@nestjs/mongoose`包的包之一，并提供通过查询链接查询数据库的能力。
- en: REST API
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API
- en: REST is one of the main design paradigms for creating APIs. It stands for Representative
    State Transfer, and uses JSON as a transfer format, which is in line with how
    Nest stores objects, thus it is a natural fit for consuming and returning HTTP
    calls. A REST API is a combination of many techniques that are talked about in
    this book. They are put together in a certain way; a client makes an HTTP call
    to a server. That server will Route the call to the correct Controller based on
    the URL and HTTP verb, optionally passing it through one or more Middlewares prior
    to reaching the Controller. The Controller will then hand it off to a Service
    for processing, which could include communication with a Database through an ORM.
    If all goes well, the server will return an OK response to the client with an
    optional body if the client requested resources (GET request), or just a 200/201
    HTTP OK if it was a POST/PUT/DELETE and there is no response body.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: REST是创建API的主要设计范式之一。它代表着表现状态转移，并使用JSON作为传输格式，这与Nest存储对象的方式一致，因此它是用于消费和返回HTTP调用的自然选择。REST
    API是本书讨论的许多技术的组合。它们以一定的方式组合在一起；客户端向服务器发起HTTP调用。服务器将根据URL和HTTP动词路由调用到正确的控制器，可选择性地通过一个或多个中间件传递到控制器之前。控制器然后将其交给服务进行处理，这可能包括通过ORM与数据库通信。如果一切顺利，服务器将向客户端返回一个OK响应，如果客户端请求资源（GET请求），则可能包含一个可选的主体，或者如果是POST/PUT/DELETE，则只返回一个200/201
    HTTP OK，而没有响应主体。
- en: WebSockets
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSockets
- en: WebSockets are another way to connect to and send/receive data from a server.
    With WebSockets, a client will connect to the server and then subscribe to certain
    channels. The clients can then push data to a subscribed channel. The server will
    receive this data and then broadcast it to every client that is subscribed to
    that specific channel. This allows multiple clients to all receive real-time updates
    without having to make API calls manually, potentially flooding the server with
    GET requests. Most chat apps use WebSockets to allow for real-time communication,
    and everyone in a group message will receive the message as soon as one of the
    other members sends one. Websockets allow for more of a streaming approach to
    data transfer than traditional Request-Response API’s, because Websockets broadcast
    data as it’s received.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets是连接到服务器并发送/接收数据的另一种方式。使用WebSockets，客户端将连接到服务器，然后订阅特定的频道。然后客户端可以将数据推送到已订阅的频道。服务器将接收这些数据，然后将其广播给订阅了特定频道的每个客户端。这允许多个客户端都实时接收更新，而无需手动进行API调用，可能会通过GET请求向服务器发送大量请求。大多数聊天应用程序使用WebSockets来实现实时通信，群组消息中的每个成员发送消息后，所有成员都会立即收到消息。Websockets允许更多地以流式传输数据的方式来传输数据，而不是传统的请求-响应API，因为Websockets会在接收到数据时广播数据。
- en: Microservices
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: Microservices allow for a Nest application to be structured as a collection
    of loosely coupled services. In Nest, microservices are slightly different, because
    they are an application that uses a different transport layer other than HTTP.
    This layer can be TCP or Redis pub/sub, among others. Nest supports TCP and Redis,
    although if you are married to another transport layer it can be implemented by
    using the `CustomTransportStrategy` interface. Microservices are great because
    they allow a team to work on their own service within the global project and make
    changes to the service without affecting the rest of the project since it is loosely
    coupled. This allows for continuous delivery and continuous integration independent
    of other teams microservices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务允许Nest应用程序以一组松散耦合的服务的形式进行结构化。在Nest中，微服务略有不同，因为它们是使用除HTTP之外的不同传输层的应用程序。这一层可以是TCP或Redis
    pub/sub等。Nest支持TCP和Redis，尽管如果您使用其他传输层，可以通过使用`CustomTransportStrategy`接口来实现。微服务很棒，因为它们允许团队在全局项目中独立于其他团队的微服务进行工作，并对服务进行更改，而不会影响项目的其他部分，因为它是松散耦合的。这允许持续交付和持续集成，而不受其他团队微服务的影响。
- en: GraphQL
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL
- en: 'As we saw above, REST is one paradigm when designing APIs, but there is a new
    way to think about creating and consuming APIs: GraphQL. With GraphQL, instead
    of each resource having its own URL pointing to it, a URL will accept a query
    parameter with a JSON object in it. This JSON object defines the type and format
    of the data to return. Nest provides functionality for this through the `@nestjs/graphql`
    package. This will include the `GraphQLModule` in the project, which is a wrapper
    around the Apollo server. GraphQL is a topic that could have an entire book written
    about it, so we don’t go into it any further in this book.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上面看到的，REST是设计API时的一种范式，但现在有一种新的方式来考虑创建和使用API：GraphQL。使用GraphQL，每个资源都不再有自己指向它的URL，而是URL将接受一个带有JSON对象的查询参数。这个JSON对象定义了要返回的数据的类型和格式。Nest通过`@nestjs/graphql`包提供了这方面的功能。这将在项目中包括`GraphQLModule`，它是Apollo服务器的包装器。GraphQL是一个可以写一整本书的主题，所以我们在本书中不再深入讨论它。
- en: Routing
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Routing is one of the core principles when discussing web frameworks. Somehow
    the clients need to know how to access the endpoints for the server. Each of these
    endpoints describes how to retrieve/create/manipulate data that is stored on the
    server. Each `Component` that describes an API endpoint must have a `@Controller(‘prefix’)`
    decorator that describes the API prefix for this component’s set of endpoints.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是讨论Web框架的核心原则之一。客户端需要知道如何访问服务器的端点。这些端点中的每一个描述了如何检索/创建/操作存储在服务器上的数据。描述API端点的每个`Component`必须具有一个`@Controller('prefix')`装饰器，用于描述此组件端点集的API前缀。
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The above Controller is the API endpoint for `GET /hello/world` and will return
    an `HTTP 200 OK` with `Hello World` in the body. This will be discussed more in
    the Routing chapter where you will learn about using URL params, Query params,
    and the Request object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述控制器是`GET /hello/world`的API端点，将返回一个带有`Hello World`的`HTTP 200 OK`。这将在路由章节中进一步讨论，您将了解如何使用URL参数、查询参数和请求对象。
- en: Nest specific tools
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nest特定工具
- en: 'Nest provides a set of Nest.js specific tools that can be used throughout the
    application to help with writing reusable code and following SOLID principles.
    These decorators will be used in each of the subsequent chapters, as they define
    a specific functionality:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Nest提供了一组特定于Nest.js的工具，可以在整个应用程序中使用，帮助编写可重用的代码并遵循SOLID原则。这些装饰器将在后续的每一章中使用，因为它们定义了特定的功能：
- en: '@Module: The definition for this reusable package of code within the project,
    it accepts the following parameters to define its behavior. ⋅⋅ *Imports: These
    are the modules that contain the components used within this module. ⋅⋅* Exports:
    These are the components that will be used in other modules, that import this
    module. ⋅⋅ *Components: These are the components that will be available to be
    shared across at least this module through the Nest Injector. ⋅⋅* Controllers:
    The controllers created within this module, these will define the API endpoints
    based on the routes defined.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '@Module：项目中可重用代码的定义，它接受以下参数来定义其行为。⋅⋅ *导入：这些是包含在此模块中使用的组件的模块。⋅⋅*导出：这些是将在其他模块中使用的组件，导入此模块的模块。⋅⋅
    *组件：这些组件将可供至少通过Nest注入器共享此模块。⋅⋅*控制器：在此模块中创建的控制器，这些控制器将根据定义的路由定义API端点。'
- en: '@Injectable: Almost everything in Nest is a provider that can be injected through
    constructors. Providers are annotated with `@Injectable()`. .. *Middleware: A
    function that is run before a request is passed to the route handler. In this
    chapter, we will talk about the difference between Middleware, Async Middlewares
    and Functional Middleware. ..* Interceptor: Similar to Middleware, they bind extra
    logic before and after the execution of a method, and they can both transform
    or completely override a function. Interceptors are inspired by Aspect-Oriented
    Programming (AOP). .. *Pipe: Similar to part of an Interceptors functionality,
    Pipe transforms input data to the desired output. ..* Guard: A smarter and more
    niche Middleware, Guards have the singular purpose of determining if a request
    should be handled by the router handler or not. ..* Catch: Tell an `ExceptionFilter`
    what exception to look for and then bind data to it.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '@Injectable：Nest中几乎所有东西都是可以通过构造函数注入的提供者。提供者使用`@Injectable()`进行注释。.. *中间件：在请求传递到路由处理程序之前运行的函数。在本章中，我们将讨论中间件、异步中间件和功能中间件之间的区别。..*拦截器：类似于中间件，它们在方法执行前后绑定额外的逻辑，并且可以转换或完全覆盖函数。拦截器受面向方面的编程（AOP）的启发。..
    *管道：类似于拦截器功能的一部分，管道将输入数据转换为所需的输出。..*守卫：更智能、更专业的中间件，守卫的唯一目的是确定请求是否应该由路由处理程序处理。..*Catch：告诉`ExceptionFilter`要查找的异常，然后将数据绑定到它。'
- en: '@Catch: Binds metadata to the exception filter and tells Nest that a filter
    is looking only for the exceptions listed in the `@Catch`.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '@Catch：将元数据绑定到异常过滤器，并告诉Nest过滤器仅寻找`@Catch`中列出的异常。'
- en: 'Note: In Nest Version 4 not everything under `@Injectable()` listed above uses
    the `@Injectable()` decorator. Components, Middlewares, Interceptors, Pipes, and
    Guards each have their own decorator. In Nest Version 5 these have all been combined
    to `@Injectable()` to reduced the differences between Nest and Angular.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Nest版本4中，上面列出的`@Injectable()`下的不是所有东西都使用`@Injectable()`装饰器。组件、中间件、拦截器、管道和守卫各自都有自己的装饰器。在Nest版本5中，这些都已合并为`@Injectable()`，以减少Nest和Angular之间的差异。
- en: OpenAPI (Swagger)
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenAPI（Swagger）
- en: Documentation is very important when writing a Nest server, and is especially
    so when creating an API that will be consumed by others, otherwise the developer
    writing the clients that will eventually be consuming the API do not know what
    to send or what they get back. One of the most popular documentation engines out
    there is Swagger. Like with others, Nest provides a dedicated module for the OpenAPI
    (Swagger) spec, `@nestjs/swagger`. This module provides decorators to help describe
    the inputs/outputs and endpoints of your API. This documentation is then accessible
    through an endpoint on the server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Nest服务器时，文档非常重要，特别是在创建将被其他人使用的API时，否则最终将使用API的客户端的开发人员不知道该发送什么或者他们会得到什么。其中最流行的文档引擎之一是Swagger。与其他文档引擎一样，Nest提供了专门用于OpenAPI（Swagger）规范的模块`@nestjs/swagger`。该模块提供装饰器来描述API的输入/输出和端点。然后可以通过服务器上的端点访问此文档。
- en: Command Query Responsibility Segregation (CQRS)
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）
- en: Command Query Responsibility Segregation (CQRS) is the idea that each method
    should either be one that performs an action (command) or requests data (query),
    but not both. In the context of our sample app, we would not have the database
    access code directly within the Controller for an endpoint, but rather create
    a Component (Database Service) that has a method such as `getAllUsers()` that
    will return all the users that the Controllers Service can call, thus separating
    the question and the answer into different Components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）是每个方法应该是执行操作（命令）或请求数据（查询）的想法，但不能两者兼而有之。在我们示例应用程序的上下文中，我们不会在端点的控制器中直接使用数据库访问代码，而是创建一个组件（数据库服务），该组件具有诸如`getAllUsers()`的方法，该方法将返回控制器服务可以调用的所有用户，从而将问题和答案分离到不同的组件中。
- en: Testing
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'Testing your Nest server will be imperative so that once it is deployed their
    are no unforseen issure and it all runs smoothly. There are two different kinds
    of tests you will learn about in this book: Unit Tests and E2E Tests (End-to-end
    Tests). Unit Testing is the art of testing small snippets or blocks of code, and
    this could be as granular as testing individual functions or writing a test for
    a `Controller`, `Interceptor`, or any other `Injectable`. There are many popular
    unit testing frameworks out there, and `Jasmine` and `Jest` are two popular ones.
    Nest provides special packages, `@nestjs/testing` specifically, for writing unit
    tests in `*.spec.ts` and `*.test.ts` classes.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您的Nest服务器将是至关重要的，以便一旦部署，就不会出现意外问题，并且一切都能顺利运行。在本书中，您将了解两种不同类型的测试：单元测试和E2E测试（端到端测试）。单元测试是测试小片段或代码块的艺术，这可能是测试单个函数或为`Controller`、`Interceptor`或任何其他`Injectable`编写测试。有许多流行的单元测试框架，`Jasmine`和`Jest`是其中两个流行的框架。Nest提供了专门的包，特别是`@nestjs/testing`，用于在`*.spec.ts`和`*.test.ts`类中编写单元测试。
- en: E2E Testing is the other form of testing that is commonly used and is different
    from unit testing only in that it tests entire functionality rather than individual
    functions or components, which is where the name end-to-end testing came from.
    Eventually applications will become so large that it is hard to test absolutely
    every piece of code and endpoint. In this case you can use E2E tests to test the
    application from beginning to the end to make sure everything works along the
    way. For E2E testing a Nest application can use the `Jest` library again to mock
    up components. Along with `Jest` you can use the `supertest` library to simulate
    HTTP requests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: E2E测试是常用的另一种测试形式，与单元测试不同之处在于它测试的是整个功能，而不是单个函数或组件，这就是所谓的端到端测试的由来。最终，应用程序会变得如此庞大，以至于很难测试每一行代码和端点。在这种情况下，您可以使用E2E测试来测试应用程序从开始到结束，以确保一切顺利进行。对于E2E测试，Nest应用程序可以再次使用`Jest`库来模拟组件。除了`Jest`，您还可以使用`supertest`库来模拟HTTP请求。
- en: Testing is a very important part of writing applications and should not be ignored.
    This is a chapter that will be relevant no matter what language or framework you
    end up working with. Most large scale development companies have entire teams
    dedicated to writing tests for the code that is pushed to production applications,
    and these are called QA developers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是编写应用程序的非常重要的一部分，不应被忽视。无论您最终使用什么语言或框架，这都是一个相关的章节。大多数大型开发公司都有专门的团队负责为推送到生产应用程序的代码编写测试，这些团队被称为QA开发人员。
- en: Server-side rendering with Angular Universal
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular Universal进行服务器端渲染
- en: Angular is a client side application development framework and Angular Universal
    is a technology that allows our Nest server to pre-render the webpages and serve
    them to the client, which has numerous benefits that will be discussed in the
    Server-side Rendering with Angular Universal chapter. Nest and Angular pair very
    well together due to both using TypeScript and Node.js. Many of the packages that
    can be used in the Nest server can also be used in the Angular app because they
    both compile to JavaScript.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个客户端应用程序开发框架，而Angular Universal是一种技术，允许我们的Nest服务器预渲染网页并将其提供给客户端，这有许多好处，将在“使用Angular
    Universal进行服务器端渲染”章节中讨论。Nest和Angular非常搭配，因为它们都使用TypeScript和Node.js。许多可以在Nest服务器中使用的包也可以在Angular应用程序中使用，因为它们都编译为JavaScript。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Throughout this book, you will go through each of the above topics in more detail,
    continuously building on top of prior concepts. Nest provides a clean well-organized
    framework that implements each of these concepts in a simple yet efficient way
    that is consistent across all modules because of the modular design of the framework.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将更详细地了解上述每个主题，不断构建在先前概念的基础上。Nest提供了一个清晰、组织良好的框架，以简单而高效的方式实现每个概念，这是因为框架的模块化设计在所有模块中都是一致的。
