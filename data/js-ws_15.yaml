- en: 15\. Asynchronous Tasks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. 异步任务
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to implement asynchronous programming
    and its different techniques; explore the pitfalls of callback hell and the pyramid
    of doom; illustrate the use of promises to execute code upon operation completion;
    use the new `async`/`await` syntax to make asynchronous code look and feel almost
    sequential; and apply the Fetch API to make remote service calls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够实现异步编程及其不同的技术；探索回调地狱和灾难金字塔的陷阱；展示如何使用promises在操作完成后执行代码；使用新的`async`/`await`语法使异步代码看起来和感觉上几乎像是顺序代码；并应用Fetch
    API来执行远程服务调用。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Asynchronous tasks allow the execution of the main thread of a program to proceed
    even while waiting for data, an event, or the result of another process, and achieve
    snappier UIs as well as allowing some types of multitasking.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 异步任务允许程序的主线程在等待数据、事件或另一个进程的结果时继续执行，从而实现更快的UI响应，并允许某些类型的并行处理。
- en: Unlike other languages that can have many concurrent threads executing, JavaScript
    typically runs in a single thread. So far, you have already learned in detail
    about how JavaScript's single-threaded model is enabled by the **event loop**
    and the associated **event queue**. Under the hood, the browser or the Node.js
    runtime has background threads that listen for events or issue service calls,
    and when a new event is captured or a service call responds, it is pushed into
    the event queue. JavaScript continually scans the event queue and triggers the
    handlers for those events when available. Event handlers are most commonly callback
    methods, but there are other types as well, such as *Promises*, which you will
    learn about in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他可以有许多并发线程执行的语言不同，JavaScript通常在单个线程上运行。到目前为止，你已经详细学习了JavaScript的单线程模型是如何通过**事件循环**和相关的**事件队列**来实现的。在底层，浏览器或Node.js运行时都有后台线程，它们监听事件或发出服务调用。当捕获到新事件或服务调用响应时，它会被推入事件队列。JavaScript不断地扫描事件队列，并在可用时触发这些事件的处理器。事件处理器最常见的是回调方法，但还有其他类型，例如*Promises*，你将在本章中学习到。
- en: Some threads take longer than others. In a restaurant, preparing a steak takes
    more time than fulfilling an order for a glass of wine. However, since there is
    no dependency between these items, they can each be performed concurrently. But
    even if the wine was ordered minutes after the steak, there is a good chance the
    wine will be brought over before the steak, even by the same worker. This is essentially
    the idea of asynchronous processing. (To take the analogy a bit further, when
    each item is ready to be served to the customer, they will be placed in the worker's
    *queue* by the kitchen staff. The worker constantly checks their queue for more
    things to bring to the restaurant's patrons.)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一些线程的执行时间比其他线程长。在餐厅里，准备牛排比点一杯酒需要更多的时间。然而，由于这些项目之间没有依赖关系，它们可以并行执行。即使酒是在牛排点单后几分钟内点的，也有很大的可能性酒会比牛排先送到，甚至可能是由同一个服务员送来的。这本质上就是异步处理的概念。（为了进一步说明这个类比，当每个项目准备好提供给顾客时，厨房工作人员会将它们放入服务员的*队列*中。服务员会不断检查他们的队列，以寻找更多需要带给餐厅顾客的东西。）
- en: The early versions of JavaScript mostly used callbacks to achieve asynchrony,
    but the negative consequences of creating callback hell soon became apparent,
    as you will see. Then, in ECMAScript 2015, an alternative was introduced, called
    Promises, which helped a lot but still left a bit to be desired. More recently,
    new keywords and syntax known as `async`/`await` were added in ECMAScript 2017,
    which simplified asynchronous code even further and made it resemble regular sequential
    code in many respects. You will explore each of these in the sections that follow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的早期版本主要使用回调函数来实现异步，但创建回调地狱的负面影响很快就会显现，正如你将看到的。然后，在ECMAScript 2015中，引入了一种替代方案，称为Promises，这非常有帮助，但仍然还有一些不足。最近，在ECMAScript
    2017中，添加了新的关键字和语法，称为`async`/`await`，这进一步简化了异步代码，并在许多方面使其看起来更像是常规顺序代码。你将在接下来的章节中探索这些内容。
- en: In this chapter, you will also revisit *TheSportsAPI* that was introduced in
    *Chapter 10*, *Accessing External Resources*, which you used to query and retrieve
    sports-related data regarding teams, game scores, players, and upcoming events.
    It may be a good idea to reread that chapter to refresh your memory, as we will
    be expanding upon the material there.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你还将回顾在第 10 章 *访问外部资源* 中引入的 *TheSportsAPI*，你曾用它查询和检索有关球队、比赛得分、球员和即将发生的事件的体育相关数据。重新阅读那一章以刷新记忆可能是个好主意，因为我们将在此基础上扩展内容。
- en: Callbacks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: 'As you explored in *Chapter 10*, *Accessing External Resources*, callbacks
    are the oldest and simplest means of executing asynchronous functionality in JavaScript.
    A callback is a specified function to be called once the result of an operation
    is ready. You saw this with the jQuery `$.ajax()` and `$.getJSON()` methods, where
    a function is called once a successful service call response is available; for
    example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在第 10 章 *访问外部资源* 中所探索的，回调是 JavaScript 中执行异步功能最古老和最简单的方法。回调是在操作结果准备好后要调用的指定函数。你可以在
    jQuery 的 `$.ajax()` 和 `$.getJSON()` 方法中看到这一点，在这些方法中，一旦成功的服务调用响应可用，就会调用一个函数；例如：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Another area where callbacks are heavily used is for event handlers. Events
    can be considered asynchronous, as they can happen at unpredictable times and
    in any order. The callbacks to handle events are typically registered with the
    browser runtime and added to the event queue when calling `addEventListener()`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个回调被大量使用的领域是事件处理器。事件可以被视为异步的，因为它们可以在不可预测的时间以任何顺序发生。处理事件的回调通常在调用 `addEventListener()`
    时注册并添加到事件队列中。
- en: setTimeout()
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: setTimeout()
- en: The `setTimeout()` function is the traditional way of scheduling code to run
    asynchronously at some point in the future. It is most commonly called with a
    parameter that specifies the number of milliseconds to wait before execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()` 函数是传统的方式，用于在未来的某个时间点异步调度代码执行。它通常使用一个参数来指定在执行之前要等待的毫秒数。'
- en: 'Exercise 15.01: Asynchronous Execution with setTimeout()'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.01：使用 setTimeout() 进行异步执行
- en: 'This exercise demonstrates how execution flows when using `setTimeout()` if
    that parameter is specified as `0` or just omitted:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习演示了当 `setTimeout()` 参数指定为 `0` 或省略时，执行流程是如何的：
- en: In the Google Chrome browser, go into `Developer Tools` (the menu with three
    dots at the upper-right corner of the screen) | `More Tools` | `Developer Tools`,
    or just hit the *F12* key).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Google Chrome 浏览器中，进入“开发者工具”（屏幕右上角带有三个点的菜单）| “更多工具”| “开发者工具”，或者直接按 *F12* 键）。
- en: In the `Console` tab, paste the code from the following file, but do not hit
    *Enter* yet. You can find the code in the file `exercise1.js`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“控制台”标签页中，粘贴以下文件的代码，但不要按 *Enter* 键。你可以在文件 `exercise1.js` 中找到代码。
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Consider the code you pasted. You might think the function in the `setTimeout()`
    block would execute right away since it was specified to execute after zero milliseconds.
    But, in fact, this is not what happens. So, let's see the output.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑你粘贴的代码。你可能认为 `setTimeout()` 块中的函数会立即执行，因为它被指定在零毫秒后执行。但实际上，情况并非如此。所以，让我们看看输出结果。
- en: 'Press the *Enter* key in the console to execute the code. The output will be
    the following:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中按 *Enter* 键执行代码。输出将如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Due to the way asynchronous processing works, the callback in `setTimeout()`
    is placed in the event queue to schedule it for later processing, while the execution
    of the main code proceeds. The callback will not get executed until the main code
    completes.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于异步处理的方式，`setTimeout()` 中的回调被放置在事件队列中以安排稍后处理，而主代码的执行继续进行。回调将在主代码完成后才会执行。
- en: The overuse of `setTimeout()` can also lead to bad coding practices, as we will
    see in the next section.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 过度使用 `setTimeout()` 也会导致不良的编码实践，我们将在下一节中看到。
- en: Callback Hell and the Pyramid of Doom
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调地狱与死亡金字塔
- en: Callbacks are perhaps the simplest and most straightforward approach to handling
    asynchronous requests, but if you are not careful, your code can get messy and
    unmanageable very quickly. This is especially true if you need to make a series
    of nested asynchronous service calls that depend on data returned from the previous
    call.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回调可能是处理异步请求最简单、最直接的方法，但如果你不小心，你的代码可能会很快变得混乱且难以管理。这尤其适用于你需要进行一系列嵌套的异步服务调用，而这些调用依赖于前一个调用的返回数据。
- en: Recall *TheSportsDB* from *Chapter 10*, *Accessing External Resources*. Let's
    say you have a requirement to obtain a list of honors granted to the players of
    your favorite team.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第10章中的 *TheSportsDB*，在 *访问外部资源* 中。假设你有一个需求，需要获取你最喜欢的球队所获得的荣誉列表。
- en: In most cases, you would not know the identifiers for the player `id` parameter
    required by the API in advance. Consequently, you would need to first use an API
    service call to look at the team ID up, in order to obtain the player list. But
    there's a further caveat, it turns out that in order to do that, you now need
    to also know the identifier for the league of which the team is a part. Since
    you don't know the league ID, you need to find the league ID itself using yet
    another service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你事先并不知道 API 所需的 `id` 参数的标识符。因此，你首先需要使用 API 服务调用查看团队 ID，以便获取球员列表。但还有一个进一步的注意事项，结果是，为了做到这一点，你现在还需要知道该团队所属联赛的标识符。由于你不知道联赛
    ID，你需要使用另一个服务来找到联赛 ID 本身。
- en: 'For such requirements, you may end up with code that looks like the following
    code snippet (don''t worry if you don''t understand the code yet, as it will be
    covered in depth later). You will find the code of file `pyramid_of_doom_example.html`
    on GitHub in the following location:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的需求，你可能会得到如下代码片段（如果你现在还不理解这段代码，不要担心，因为稍后会有深入的解释）。你可以在以下位置找到文件 `pyramid_of_doom_example.html`
    的代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In other words, here is a case where, in order to get one piece of data in one
    call, there are dependencies on the results of other calls. Each callback uses
    the result of the previous call to invoke further calls.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这是一个案例，为了在一次调用中获取一块数据，依赖于其他调用的结果。每个回调都使用前一个调用的结果来调用进一步的调用。
- en: 'Notice all the nested blocks that resulted from using callbacks. It starts
    with one function, which then includes another function, and then multiple levels
    of more functions within functions, and this results in a series of unruly end-bracket
    and end-parenthesis characters. The shape of this code resembles a pyramid rotated
    on its side, and therefore has the slang term of the *pyramid of doom*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有由使用回调产生的嵌套块。它从一个函数开始，然后包含另一个函数，然后是函数内的多个级别的更多函数，这导致了一系列无序的结束括号和结束括号字符。这段代码的形状类似于侧向旋转的金字塔，因此有“*末日金字塔*”这个俚语：
- en: In this section, you revisited how asynchronous logic is traditionally implemented
    in JavaScript, and how using callbacks can get you into trouble and result in
    hard-to-manage spaghetti code. You also familiarized yourself with *TheSportsDB*
    API and implemented some new functionality that makes requests of it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你回顾了 JavaScript 中异步逻辑的传统实现方式，以及使用回调可能会让你陷入困境并导致难以管理的乱糟糟的代码。你还熟悉了 *TheSportsDB*
    API，并实现了对其的一些新功能。
- en: There are several alternatives to using callbacks for asynchronous processing
    that have been developed in recent years, including promises and the new `async`/`await`
    syntax. The next section will explore promises, which are a major improvement
    over callbacks, as you will see.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，已经开发出几种用于异步处理的回调替代方案，包括 promises 和新的 `async`/`await` 语法。下一节将探讨 promises，它是对回调的重大改进，你将会看到。
- en: Promises and the Fetch API
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises 和 Fetch API
- en: In a nutshell, a promise is an object that wraps asynchronous logic and provides
    methods to access the results or errors once operation completes. It is a proxy
    for the result value until it is known, and allows you to associate handler functions
    rather than using callbacks. It is a *promise* to supply the value once it is
    known and available.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，promise 是一个封装异步逻辑的对象，它提供方法在操作完成后访问结果或错误。它是对结果值的代理，直到它被知晓，并允许你关联处理函数而不是使用回调。它是对提供已知和可用值的
    *承诺*。
- en: To get a good feel for how promises are used, you will first be introduced to
    the Fetch API, which uses promises heavily. Then, we will backtrack and dive into
    a detailed description of the promises themselves.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解如何使用 promises，你首先将介绍 Fetch API，它大量使用了 promises。然后，我们将回溯并深入探讨 promises
    本身的详细描述。
- en: Fetch is another API that enables you to make network requests and REST service
    calls, similar to jQuery's AJAX methods or the native `XMLHttpRequest`. The main
    difference is that the Fetch API uses promises, which has a cleaner and more concise
    syntax that helps you avoid callback hell.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch 是另一个允许你进行网络请求和 REST 服务调用的 API，类似于 jQuery 的 AJAX 方法或原生的 `XMLHttpRequest`。主要区别在于
    Fetch API 使用了承诺（这有助于你避免回调地狱）。
- en: 'Typical Fetch API usage for a JSON request looks something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 Fetch API 用于 JSON 请求的使用方法看起来像这样：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `fetch()` call invokes the service call in the URL. Once a valid response
    is available, the function in the first `then()` block is executed. It receives
    the response as an argument, and, in this case, runs the `json()` method on it
    to convert the text into an object. The result of this method call is then made
    available to subsequent `then()` methods down the chain. Errors can also be handled
    by `catch()` methods.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 调用会触发 URL 中的服务调用。一旦有有效的响应可用，第一个 `then()` 块中的函数就会被执行。该函数接收响应作为参数，在这种情况下，对它运行
    `json()` 方法将文本转换为对象。然后，这个方法调用的结果会被传递给链中的后续 `then()` 方法。错误也可以通过 `catch()` 方法来处理。'
- en: Using the Fetch API to Get Player Honors
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Fetch API 获取球员荣誉
- en: In this section, we will discard the jQuery callback methods used earlier to
    obtain player honor data and instead take an approach that utilizes promises (this
    gets us out of the callback Pyramid of Doom).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将放弃之前用于获取球员荣誉数据的 jQuery 回调方法，转而采用利用承诺的方法（这使我们摆脱了回调地狱的金字塔）。
- en: 'The Fetch API is relatively low-level and does not offer as many freebies as
    jQuery''s `$.ajax()` and `$.getJSON()` functions, so we''ll create a wrapper function
    called `myFetch()` to make the usage a bit nicer for our use case; specifically:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch API 相对较低级，并不像 jQuery 的 `$.ajax()` 和 `$.getJSON()` 函数那样提供许多免费功能，因此我们将创建一个名为
    `myFetch()` 的包装函数，以便在我们的用例中使使用更加方便；具体来说：
- en: Fetch only takes a full URL and does not encode parameters for you. The `myFetch()`
    function will include an optional second parameter for params as key-value pairs,
    which, if specified, will encode the parameter values and append the resulting
    query string to the URL.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fetch 只接受完整的 URL，并且不会为你编码参数。`myFetch()` 函数将包括一个可选的第二个参数 `params`，作为键值对，如果指定，将编码参数值并将结果查询字符串附加到
    URL 上。
- en: Fetch does not automatically parse the JSON response, so you'll include this
    in `myFetch()`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fetch 不会自动解析 JSON 响应，所以你将包括这个在 `myFetch()` 中。
- en: Fetch does not consider an HTTP status code as an error condition unless the
    code is 500 or above. But for our purposes, any response other than `200 (OK)`
    should be considered an error. You'll add a check for this.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fetch 不会将 HTTP 状态码视为错误条件，除非代码是 500 或更高。但就我们的目的而言，任何不是 `200 (OK)` 的响应都应被视为错误。你将添加一个检查。
- en: Note
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: This wrapper is not appropriate for all use cases. You should tailor it to your
    particular needs.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此包装器并不适用于所有用例。你应该根据你的特定需求进行定制。
- en: 'Exercise 15.02: Refactoring the Honors List to Use the Fetch API'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.02：重构荣誉名单以使用 Fetch API
- en: 'In this exercise, we will refactor the code to obtain a list of honors granted
    to the players of your favorite team. We will refactor it to use the Fetch API:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将重构代码以获取你最喜欢的球队的球员所获得的荣誉名单。我们将重构它以使用 Fetch API：
- en: 'First, we will create a file that contains common pieces of code that will
    be used throughout this chapter. In a text editor or IDE, enter the following
    initial chunk of code. You can also find the code of file `players.js` on GitHub
    in the file location: [https://packt.live/2KUdBY4](https://packt.live/2KUdBY4)'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个包含将在本章中使用的常见代码片段的文件。在文本编辑器或 IDE 中输入以下初始代码块。你还可以在 GitHub 上找到文件 `players.js`
    的代码，文件位置为：[https://packt.live/2KUdBY4](https://packt.live/2KUdBY4)
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code has the URLs and data values for remote services we will be calling
    of *TheSportsDB* API.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码包含了我们将要调用的 *TheSportsDB* API 的远程服务的 URL 和数据值。
- en: 'Enter the following `myFetch()` method:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下 `myFetch()` 方法：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the implementation of the wrapper function to `fetch()` that was mentioned
    earlier.  First, if one or more or more parameter key-value pairs are specified,
    they are encoded into a query string and appended to the URL.  After this, the
    `fetch()` function is called, and `then()` is executed when the response is available.
    If the HTTP status code is anything other than `200 (OK)`, an error is thrown.
    This causes it to be caught by the `catch()` function (if defined in the promise
    call chain). Finally, if all is okay, it calls `response.json()` to parse the
    JSON response into an object, which is returned as another promise to be passed
    along and resolved in the subsequent `then()` function.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是之前提到的 `fetch()` 包装函数的实现。首先，如果指定了一个或多个参数键值对，它们将被编码为查询字符串并附加到URL上。然后，调用 `fetch()`
    函数，当响应可用时执行 `then()`。如果HTTP状态码不是 `200 (OK)`，则会抛出错误。这会导致它被 `catch()` 函数（如果已在承诺调用链中定义）捕获。最后，如果一切顺利，它调用
    `response.json()` 将JSON响应解析为对象，并将其作为另一个承诺返回，以便在后续的 `then()` 函数中传递和解析。
- en: 'Use the following helper function, which encodes the key-value pair parameters
    to be appended to the query string of the URL:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下辅助函数，将键值对参数编码为附加到URL查询字符串的参数：
- en: '[PRE7]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, write the `findLeagueId()` function:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写 `findLeagueId()` 函数：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code takes the result of the `ALL_LEAGUES_URL` service call and utilizes
    `find()` to locate the result that matches the desired league name. Once found,
    it returns the ID for that league (or `null` if there was no match found).
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码使用 `ALL_LEAGUES_URL` 服务调用的结果，并利用 `find()` 来定位与所需联赛名称匹配的结果。一旦找到，就返回该联赛的ID（如果没有找到匹配项，则返回
    `null`）。
- en: 'Write the `findTeamId()` function as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式编写 `findTeamId()` 函数：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similar to the last function, this code takes the result of the `ALL_TEAMS_URL`
    service call and uses `find()` to locate the desired team.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与上一个函数类似，此代码使用 `ALL_TEAMS_URL` 服务调用的结果，并使用 `find()` 来定位所需的球队。
- en: 'Enter the `printHonors()` function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `printHonors()` 函数：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function takes the result of the `PLAYER_HONORS_URL` service call and creates
    a list of player honors comprising the `<ul>` and `<li>` HTML tags.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数使用 `PLAYER_HONORS_URL` 服务调用的结果创建一个包含 `<ul>` 和 `<li>` HTML 标签的球员荣誉列表。
- en: We have now completed the common functions. Save this file with the filename
    `players.js`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经完成了常用功能。将此文件保存为文件名 `players.js`。
- en: 'Create a new file in your editor or IDE. Enter the initial chunk of code from
    the following file. You can find the code on GitHub in the file location: [https://packt.live/2XRGLMO](https://packt.live/2XRGLMO)'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器或IDE中创建一个新文件。输入以下文件中的初始代码块。您可以在GitHub上找到代码，文件位置为：[https://packt.live/2XRGLMO](https://packt.live/2XRGLMO)
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enter the following, which starts to replace the jQuery `$.getJSON` code with
    calls to the Fetch API:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下内容，开始用Fetch API的调用替换jQuery的 `$.getJSON` 代码：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Processing begins with calling the `myFetch()` wrapper function to invoke the
    service call that retrieves a list of all leagues. Once the response is available,
    the function specified in the `then()` method is invoked.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 处理开始于调用 `myFetch()` 包装函数来调用检索所有联赛列表的服务调用。一旦响应可用，就调用 `then()` 方法中指定的函数。
- en: Note
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: There is no need to check for HTTP errors and you can assume the response was
    valid since error checking was already done in the implementation of the `myFetch()`
    function call outlined above. You also do not need to parse the JSON to an object.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有必要检查HTTP错误，并且可以假设响应是有效的，因为在上面的 `myFetch()` 函数调用实现中已经进行了错误检查。您也不需要将JSON解析为对象。
- en: The `findLeagueId()` function is then called to find the ID of the league you
    are interested in, which is needed for the next service call to get the teams
    in the league. Once found, `myFetch()` is then called again. The promise returned
    by the `myFetch()` function call is then returned, to be passed along for processing
    by the following `then()` block.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后调用 `findLeagueId()` 函数来查找您感兴趣的联赛的ID，这是获取联赛中球队的下一次服务调用所需的。一旦找到，就再次调用 `myFetch()`。`myFetch()`
    函数调用返回的承诺随后被返回，以便在后续的 `then()` 块中传递和处理。
- en: 'Enter the next `then()` clause to obtain the team ID:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入下一个 `then()` 子句以获取球队ID：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In a similar fashion, once the response to the second service call is available,
    the function in the `then()` block is invoked. The response is searched to find
    the team ID needed for the next call, and `myFetch()` is called again to get all
    the players on the team.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以类似的方式，一旦第二个服务调用的响应可用，`then()` 块中的函数就会被调用。响应被搜索以找到下一个调用所需的团队ID，然后再次调用 `myFetch()`
    来获取球队中的所有球员。
- en: 'Enter the next `then()` block to acquire the list of players on the team, which
    is needed to then query the honors of each player in turn:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入下一个 `then()` 块以获取球队球员名单，这是查询每位球员荣誉所需的信息：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The browser (and JavaScript runtime) is more than capable of handling the invocation
    of multiple service calls simultaneously.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 浏览器（以及JavaScript运行时）完全能够同时处理多个服务调用的调用。
- en: Note
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: A naive approach would be to invoke all the service calls in a serial or synchronous
    fashion one after another, but doing this would cause the browser (or JavaScript
    runtime) to lock up until all the service calls are done since JavaScript has
    a single-threaded model.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一种简单的方法是按顺序或同步方式依次调用所有服务调用，但这样做会导致浏览器（或JavaScript运行时）锁定，直到所有服务调用完成，因为JavaScript具有单线程模型。
- en: 'The `map()` function is called on the `playerData.player` list, which results
    in the list being iterated and a `myFetch()` call being invoked on each player
    on the list, and, hence, a number of new REST calls to *TheSportsDB* API. The
    resulting promises from each service call are collected in the `honorRequests`
    variable:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `playerData.player` 列表上调用 `map()` 函数，这会导致列表被迭代，并为列表中的每位球员调用 `myFetch()`，因此会向
    *TheSportsDB* API 发起多个新的REST调用。每个服务调用的结果承诺被收集在 `honorRequests` 变量中：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Promise.all()` method waits for all the service calls to complete before
    the associated promises are returned to be processed in the next `then()` block.
    Once available, the promises are returned as an array in the order the service
    calls were invoked. This array is iterated upon via `forEach()` to call `printHonors()`
    for each response:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Promise.all()` 方法在将关联的承诺返回以在下一个 `then()` 块中处理之前，会等待所有服务调用完成。一旦可用，承诺将按服务调用调用的顺序以数组的形式返回。这个数组通过
    `forEach()` 进行迭代，为每个响应调用 `printHonors()`：'
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, there is a `catch()` method in case errors occur during the processing
    of the promise:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，有一个 `catch()` 方法，以防在处理承诺期间发生错误：
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This simply logs the error to the console (in a real application, you should
    consider somehow indicating to the user that an error occurred, such as by showing
    an error message in the UI).
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只是将错误记录到控制台（在实际应用中，你应该考虑以某种方式向用户指示发生了错误，例如在UI中显示错误消息）。
- en: 'Closeout the file with the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容关闭文件：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The code from the exercise has resulted in the browser such as the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 练习中的代码导致浏览器出现如下情况：
- en: '![Figure 15.1: Sample output of player honors'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.1：玩家荣誉的示例输出'
- en: '](img/C14377_15_01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_15_01.jpg]'
- en: 'Figure 15.1: Sample output of player honors'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：玩家荣誉的示例输出
- en: In this exercise, we refactored the code to use the Fetch API. This was processed
    differently. *TheSportsDB* API only offers a service call to retrieve the honors
    for one player at a time. Consequently, to get the honors of all players on the
    team, you need to invoke many service calls, one for each player on the team.
    Here's where asynchrony comes in handy. Thus, the browser (and JavaScript runtime)
    is more than capable of handling the invocation of multiple service calls simultaneously.
    We will improve this in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们重构了代码以使用Fetch API。这被处理得不同。*TheSportsDB* API一次只能提供一个服务调用以检索一个玩家的荣誉。因此，要获取球队所有球员的荣誉，你需要对球队中的每位球员调用多个服务调用。这就是异步变得有用的地方。因此，浏览器（以及JavaScript运行时）完全能够同时处理多个服务调用的调用。我们将在下一节中改进这一点。
- en: An Improvement for Better Performance
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能改进
- en: The preceding code works, but there is still another improvement worth making.
    As a consequence of using `Promise.all()`, no results will display until all the
    requests to get player honors have returned. This produces a pause longer than
    necessary when loading the list.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是有效的，但仍有另一个值得改进的地方。由于使用了 `Promise.all()`，直到获取玩家荣誉的所有请求都返回结果之前，都不会显示任何结果。这导致在加载列表时产生了比必要的更长时间的暂停。
- en: You can improve perceived performance if you begin to display the list entries
    the moment the honor data of the first player is available, then the honors of
    the second player, and so on. You can do this even if the data for the rest of
    the players have not arrived yet, as long as you maintain the correct player order
    while displaying the list of entries.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在第一个玩家的荣誉数据可用时开始显示列表条目，然后是第二个玩家的荣誉，依此类推，您就可以提高感知性能。即使其他玩家的数据尚未到达，您也可以这样做，只要在显示条目列表时保持正确的玩家顺序即可。
- en: 'To accomplish this, the basic approach is to create a promise to which a sequence
    of events are attached. You would take the promises returned by `myFetch()` for
    the respective players and attach them one by one to the sequence, as in the following
    pseudo-code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，基本方法是为一个承诺创建一个承诺，将一系列事件附加到该承诺上。您将使用 `myFetch()` 返回的相应玩家的承诺，并将它们逐个附加到序列中，如下面的伪代码所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our actual implementation will use `forEach()` to loop over the players to add
    them to the sequence. The promise for the sequence itself is created with `Promise.resolve()`,
    which results in a promise that resolves right away with no return value. But
    that's fine since this promise just serves as a placeholder to chain other items
    with a series of `then()` calls.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现将使用 `forEach()` 来遍历玩家并将他们添加到序列中。序列本身的承诺是通过 `Promise.resolve()` 创建的，这导致一个立即解决且没有返回值的承诺。但这没关系，因为这个承诺只是作为一个占位符，以便通过一系列
    `then()` 调用来链接其他项目。
- en: 'The earlier code that looked like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前看起来是这样的代码：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Is now replaced with the following. You can find the code on GitHub in the file
    `other/fetch_example_improved.html`
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已被以下内容替换。你可以在 GitHub 上的文件 `other/fetch_example_improved.html` 中找到代码。
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The resulting sequence will end up with a chain of `then()` clauses to fetch
    and print the honor data for each player, in the manner explained in the preceding
    pseudo-code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列将最终以一系列 `then()` 子句结束，用于获取并打印每位玩家的荣誉数据，正如前面伪代码中解释的那样。
- en: For those more inclined to functional-style code, here is an alternate implementation.
    I'll let you decide which one of the two is more straightforward and clear.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些更倾向于函数式代码的人来说，这里有一个替代实现。我将让您决定这两个中哪一个更直接、更清晰。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tidying Up Fetch Code
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整理 Fetch 代码
- en: The preceding code presented to process promises with the `then()` and `catch()`
    methods executes correctly but is admittedly rather verbose and unwieldy. Could
    we do better? Let's try to make each `then()` and `catch()` into one-liners by
    refactoring the processing of each block into its own method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面展示的代码使用 `then()` 和 `catch()` 方法处理承诺，执行正确，但确实相当冗长且难以操作。我们能做得更好吗？让我们尝试通过重构每个块的处理为每个
    `then()` 和 `catch()` 创建单行代码。
- en: The following code replaces the promise code that starts with `myFetch()` contained
    above. You can find the code on GitHub in the file `other/fetch_tidied.html`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码替换了上面包含的以 `myFetch()` 开始的承诺代码。你可以在 GitHub 上的文件 `other/fetch_tidied.html`
    中找到代码。
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note how much more clean the code now reads, and you can more clearly see the
    progression of what the code is doing just from how the functions are named (that
    is, first get all leagues, then the correct league, then the right team, and so
    on).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在代码的整洁程度提高了，你可以更清楚地看到代码执行的过程，仅从函数的命名（即，首先获取所有联赛，然后是正确的联赛，然后是正确的球队，依此类推）就可以看出。
- en: 'The supporting functions you need to add are as follows. These basically have
    the code that was formerly in each corresponding `then()` block, which is restructured
    into their own functions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加的支持函数如下。这些基本上是以前在每个相应的 `then()` 块中的代码，现在被重构为它们自己的函数：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Stay tuned for the activity at the end of the chapter, where this code will
    be cleaned up and simplified even further using other advanced techniques such
    as currying.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请关注章节末尾的活动，届时将使用其他高级技术，如 currying，进一步清理和简化此代码。
- en: Some Fetch API Usage Details
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些 Fetch API 使用细节
- en: This section briefly summarizes some details of the Fetch API, which was introduced
    earlier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要总结了之前介绍过的 Fetch API 的某些细节。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the settings are noteworthy, but their full details are not within the
    scope of this chapter. These settings will be indicated since they might be important
    for you if your use case requires them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设置值得关注，但它们的全部细节并不在本章的范围内。这些设置将会被指出，因为如果您的用例需要它们，它们可能对您很重要。
- en: 'The full method signature for the `fetch()` method is the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 方法的完整方法签名如下：'
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `init` parameter allows you to assign certain custom settings to the request.
    Some of the available options include:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`参数允许你为请求分配某些自定义设置。一些可用的选项包括：'
- en: '`method`: The request method, for example, `GET` and `POST`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`: 请求方法，例如`GET`和`POST`。'
- en: '`headers`: Any headers that should be sent along with your request, contained
    within a `Headers` object (as shown in the following code snippet).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`: 应随请求一起发送的任何头部信息，包含在一个`Headers`对象中（如下面的代码片段所示）。'
- en: '`body`: Anything, such as a `string`, `Blob`, or `BufferSource`, that you want
    to add to your request. Typically used for `POST` requests.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`: 你想要添加到请求中的任何内容，例如一个`string`、`Blob`或`BufferSource`。通常用于`POST`请求。'
- en: '`credentials`: If the resource you are accessing requires credentials for authentication/authorization,
    you would specify this setting. Possible values are `omit`, `same-origin`, and
    `include` (the full details of `credentials` are not within the scope of this
    chapter).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`credentials`: 如果你访问的资源需要用于身份验证/授权的凭据，你会指定此设置。可能的值包括`omit`、`same-origin`和`include`（`credentials`的完整细节不在本章范围内）。'
- en: '`cache`: The cache mode to be used for the request. Valid values are `default`,
    `no-cache`, `no-store`, `reload`, `force-cache`, and `only-if-cached` (the full
    details of caching are not within the scope of this chapter).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache`: 请求要使用的缓存模式。有效值包括`default`、`no-cache`、`no-store`、`reload`、`force-cache`和`only-if-cached`（缓存的完整细节不在本章范围内）。'
- en: 'An example usage for a `POST` request is as follows:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个`POST`请求的示例用法如下：
- en: '[PRE26]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `fetch()` method returns a promise that resolves to a `response` object
    that represents details pertaining to the response returned from the request.
    The following are the most important properties of the `response` object; all
    the properties are read-only:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fetch()`方法返回一个解析为`response`对象的promise，该对象表示请求返回的响应的详细信息。以下是最重要的`response`对象属性；所有属性都是只读的：'
- en: '`Response.headers`: Contains the headers associated with the response as an
    object with key-value pairs. The `headers` object contains methods to access them,
    such as using `Headers.get()` to retrieve the value for a given key, or `Headers.forEach()`
    to iterate over the key/value entries and call a function for each; for example:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response.headers`: 包含与响应相关的头部信息，作为一个键值对的对象。`headers`对象包含访问它们的方法，例如使用`Headers.get()`获取给定键的值，或使用`Headers.forEach()`遍历键/值条目并对每个调用一个函数；例如：'
- en: '[PRE27]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For cross-domain requests, there are restrictions on what headers are visible.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于跨域请求，对可见的头部信息有所限制。
- en: '`Response.ok`: A `Boolean` indicating whether the response was successful.
    A response is considered successful if the status code is in the range of `200-299`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response.ok`: 一个表示响应是否成功的布尔值。如果状态码在`200-299`范围内，则认为响应是成功的。'
- en: '`Response.status`: The status code of the response, such as `404` to indicate
    a `Not Found` error.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response.status`: 响应的状态码，例如`404`表示`未找到`错误。'
- en: '`Response.statusText`: The status message text that corresponds to the status
    code, such as `OK` for `200`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response.statusText`: 与状态码相对应的状态消息文本，例如`200`对应`OK`。'
- en: In this section, you were introduced to promises and how they are used in the
    Fetch API. You saw how to retrieve remote data and how to handle errors.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了Promise及其在Fetch API中的应用。你看到了如何检索远程数据以及如何处理错误。
- en: Some developers feel that Fetch is a bit low-level and prefer other alternatives
    for remote requests. One popular library is the Axios library. As an example,
    where they feel Fetch is not ideal, Axios automatically transforms JSON responses
    to objects, whereas the transformation must be done explicitly in Fetch. There
    are also differences as to what statuses are considered errors to be handled in
    the `catch()` blocks (as Fetch only considers status codes of `500` or above to
    be errors, but for many use cases, any status code that is not `200` should be
    an error condition).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者觉得Fetch比较底层，因此更喜欢其他远程请求的替代方案。一个流行的库是Axios库。例如，他们认为Fetch不理想的地方，Axios会自动将JSON响应转换为对象，而Fetch则需要显式地进行转换。在`catch()`块中处理错误的状态方面也存在差异（因为Fetch只认为状态码为`500`或以上的情况为错误，但对于许多用例，任何不是`200`的状态码都应被视为错误条件）。
- en: In most cases, there is no need to introduce another dependency into our code.
    The shortcomings mentioned can be overcome by creating simple wrappers around
    Fetch specific for your use cases, such as how you implemented the `myFetch()`
    wrapper function. Accessing the API though the wrapper offers most of the same
    functionality Axios would provide, however, you have more control.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们不需要在我们的代码中引入另一个依赖项。提到的缺点可以通过创建针对您的特定用例的简单包装器来克服，例如您如何实现了 `myFetch()`
    包装器函数。通过包装器访问 API 提供了 Axios 大多数相同的功能，但是您有更多的控制权。
- en: In the next section, you will explore promises in detail.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将详细了解 Promise。
- en: Some Details Concerning Promises
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 Promise 的详细信息
- en: You will now dig into the details of what promises are and how they are used
    in general, not necessarily in the context of service calls.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将深入了解承诺的细节以及它们通常是如何被使用的，不一定是在服务调用的上下文中。
- en: 'The constructor of a promise looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 的构造函数看起来像这样：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You would pass in an executor function that takes two arguments: `resolve`
    and (optionally) `reject`. When the promise is instantiated, this function is
    executed immediately. Your implementation of the executor function would typically
    initiate some asynchronous operation. Once the return value is available, it should
    then call the passed-in `resolve` function or `reject` if there is an error or
    other invalid condition. If an error is thrown in the executor function, it also
    causes the promise to be rejected (even if `reject` is not called explicitly).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您将传递一个执行器函数，该函数接受两个参数：`resolve` 和（可选的）`reject`。当承诺被实例化时，此函数会立即执行。您对执行器函数的实现通常会启动一些异步操作。一旦返回值可用，它应该调用传入的
    `resolve` 函数或 `reject`（如果有错误或其他无效条件）。如果在执行器函数中抛出错误，它也会导致承诺被拒绝（即使没有显式调用 `reject`）。
- en: 'Put into pseudo-code, this is similar to the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 用伪代码表示，这类似于以下内容：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A promise can be in one of three possible states: **fulfilled**, **rejected**,
    or **pending** (not yet fulfilled or rejected). A promise is said to be settled
    once it is no longer in the pending state (either fulfilled or rejected).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 可以处于三种可能的状态之一：**已解决**、**已拒绝**或**挂起**（尚未解决或拒绝）。一旦承诺不再处于挂起状态（无论是已解决还是已拒绝），就称承诺已解决。
- en: 'As a simple example, consider a promise whose purpose is to introduce a deliberate
    3-second delay to your processing. You could implement this using `setTimeout()`
    as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的例子，考虑一个承诺，其目的是在处理过程中引入故意的 3 秒延迟。您可以使用以下方式使用 `setTimeout()` 实现：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This would result in the message `Called after three seconds` printing to the
    console. Note that `reject()` is not explicitly called in this instance (and the
    `reject` parameter can actually even be omitted if you wish).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致消息 `Called after three seconds` 打印到控制台。请注意，在此实例中未显式调用 `reject()`（并且如果您愿意，`reject`
    参数甚至可以省略）。
- en: 'Now for some details concerning what happens depending on the return value
    of the executor function. If the function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们详细了解一下根据执行器函数的返回值会发生什么。如果函数：
- en: '`then` gets resolved with the returned value as its value.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then` 使用返回的值解决。'
- en: '`then` gets resolved with an `undefined` value.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then` 使用 `undefined` 值解决。'
- en: '`then` gets rejected with the thrown error as its value.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then` 使用抛出的错误作为其值拒绝。'
- en: 'Exercise 15.03: Creating a Utility Function to Delay Execution'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.03：创建一个用于延迟执行的实用函数
- en: 'In this exercise, you will produce a utility function for the creation of a
    promise to add a delay after another promise completes before the execution proceeds.
    This can be used if you want to do an async operation such as a service call,
    but do not want to process the result right away. This function will then be tested
    by making a service call and printing the result after a delay:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将生成一个用于在另一个承诺完成后添加延迟的承诺创建实用函数。如果您想要执行异步操作，如服务调用，但又不想立即处理结果，这很有用。然后，通过进行服务调用并在延迟后打印结果来测试此函数：
- en: In the Google Chrome browser, go into `Developer Tools` (the menu with three
    dots at the upper-right corner of the screen) | `More Tools` | `Developer Tools`,
    or just hit the *F12* key).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Google Chrome 浏览器中，进入 `开发者工具`（屏幕右上角有三个点的菜单）| `更多工具` | `开发者工具`，或者直接按 *F12*
    键）。
- en: 'In the `Console` tab, paste in the following and hit *Enter*: You can find
    the code on GitHub in the file location: [https://packt.live/2XM98vE](https://packt.live/2XM98vE)'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `控制台` 选项卡中粘贴以下内容并按 *Enter*：您可以在 GitHub 上的文件位置找到代码：[https://packt.live/2XM98vE](https://packt.live/2XM98vE)
- en: '[PRE31]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is our first attempt at a solution for this simple case, and the implementation
    resembles the preceding `timeoutPromise` code.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们对这个简单案例的第一个解决方案尝试，其实现与前面的 `timeoutPromise` 代码相似。
- en: You will test it by calling the service in *TheSportsDB* that gets the next
    event for a league and print the result to the console (the league ID is hardcoded
    in the URL for the purposes of this test). Paste the following code into the console
    and hit *Enter*.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将通过调用 *TheSportsDB* 中的服务来测试它，该服务获取一个联赛的下一场比赛，并将结果打印到控制台（为了测试目的，联赛 ID 已硬编码在
    URL 中）。将以下代码粘贴到控制台并按 *Enter*。
- en: '[PRE32]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code results in the message `Bournemouth vs Norwich` in the console
    after 3 seconds, though your event will likely be different.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码在 3 秒后在控制台中显示消息 `Bournemouth vs Norwich`，尽管你的事件可能不同。
- en: Note
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You could have used the more robust `myFetch()` wrapper from the previous sections
    rather than `fetch()` as well.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以使用前面章节中更健壮的 `myFetch()` 包装器而不是 `fetch()`。
- en: '![Figure 15.2: Screenshot of the result'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.2：结果截图'
- en: '](img/C14377_15_02.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_15_02.jpg]'
- en: 'Figure 15.2: Screenshot of the result'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2：结果截图
- en: In this exercise, we learned how to add a delay to processing using the `addDelay()`
    function. This can be used if you want to do an `async` operation such as a service
    call, but do not want to process the result right away. In the next section, we
    will refine this function further.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用 `addDelay()` 函数添加处理延迟。如果你想要执行一个 `async` 操作，比如服务调用，但又不想立即处理结果，这可以派上用场。在下一节中，我们将进一步改进这个函数。
- en: Further Refinements to addDelay()
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 addDelay() 的进一步改进
- en: Now, by way of a bonus, let's see if you can think of different use cases for
    the `addDelay()` utility function presented in the preceding exercise, and how
    you can specify different parameter options to support these use cases.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为额外的奖励，让我们看看你是否可以想到前面练习中 `addDelay()` 实用函数的不同用例，以及你如何指定不同的参数选项来支持这些用例。
- en: 'The code in the preceding exercise works fine, but what if you wanted to make
    it more seamless and simply introduce a delay instruction as one of the `then()`
    clauses? For example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的练习中的代码运行良好，但如果你想要使其更加无缝，并且只想将延迟指令作为 `then()` 子句之一引入，会怎样？例如：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This form is a bit cleaner and easier to see the flow (that is, fetch the response,
    add a delay of 1 second, and then process).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式更简洁，更容易看到流程（即获取响应，添加 1 秒的延迟，然后处理）。
- en: 'In order to support this, you now have two ways in which the parameters can
    be specified:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，你现在有两种方式可以指定参数：
- en: If two parameters are present, this is a simple case and a promise is returned
    that completes when the delay is over.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有两个参数存在，这是一个简单的情况，返回的承诺将在延迟结束后完成。
- en: If only one parameter is present, there was no promise passed in at all. Here,
    rather than returning a promise, you will return a function that takes the promise
    as a parameter, with the expectation that the `then()` invocation will supply
    the promise when invoking the function. This function then makes a recursive call
    to the same `addDelay()` function with two parameters.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只有一个参数存在，实际上并没有传递任何承诺。在这里，你将返回一个函数，该函数接受承诺作为参数，预期在调用函数时 `then()` 调用将提供承诺。然后这个函数将对相同的
    `addDelay()` 函数进行递归调用，带有两个参数。
- en: 'Our code now becomes the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码如下：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is one other use case you should consider that would make the utility
    function even more versatile. Let's say you don't start out with a promise at
    all and just want to return a value after a delay.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑另一个用例，这将使这个实用函数更加灵活。假设你一开始根本不使用承诺，只想在延迟后返回一个值。
- en: You can support this by calling `Promise.resolve()` with the value to convert
    it to a promise, which essentially treats it as an immediately fulfilled promise
    for that value. In the case that the value is already a promise, this call would
    have no effect.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `Promise.resolve()` 并传递要转换的值来支持这一点，这本质上将这个值视为一个立即满足的承诺。如果该值已经是承诺，这个调用将没有效果。
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Calling `Promise.resolve()` on promise parameters is mentioned as a best practice
    anyway in the promise specification guide.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在承诺规范指南中提到，在承诺参数上调用 `Promise.resolve()` 是一种最佳实践。
- en: In general, when an argument is expected to be a promise, you should also allow
    thenables and non-promise values by resolving the argument to a promise before
    using it. You should never do type detection on the incoming value, overload between
    promises and other values, or put promises in a union type.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当期望一个参数是promise时，也应该允许thenables和非promise值，在使用之前将参数解析为promise。你不应该对传入的值进行类型检测，在promise和其他值之间重载，或者将promise放入联合类型中。
- en: The final code looks like the following. You can find the code on GitHub in
    the file `other/addDelay.js`
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的代码如下。你可以在GitHub上的文件`other/addDelay.js`中找到这段代码。
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this case, only one parameter was specified. Since you don''t have the promise
    yet, return a function with the promise as a parameter and call `addDelay()` recursively
    with two parameters:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只指定了一个参数。由于你还没有promise，返回一个带有promise作为参数的函数，并使用两个参数递归地调用`addDelay()`：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you reached this far, there were two parameters:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经读到这儿，有两个参数：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And here''s the code to test the three scenarios:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是测试三个场景的代码：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Use case one is where two parameters are specified, so it executes a promise
    after a delay:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 用例一是指定了两个参数，因此它在延迟后执行promise：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use case two is where only one parameter is specified, so it returns a function
    that takes the promise as a parameter with the expectation that the `then()` invocation
    will supply the promise when invoking the function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 用例二是只指定了一个参数，因此它返回一个函数，该函数接受promise作为参数，并期望在调用函数时`then()`调用将提供promise：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use case three is where we just want to return a value after a delay:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 用例三是我们只想在延迟后返回一个值的情况：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output `All done!` should be written as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 输出`All done!`应该写成以下形式：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The order of the output from the preceding code would be as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出顺序如下：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The expected output will be as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出将如下所示：
- en: '![Figure 15.3: Screenshot of output'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.3：输出截图'
- en: '](img/C14377_15_03.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_15_03.jpg)'
- en: 'Figure 15.3: Screenshot of output'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：输出截图
- en: 'Remember, this is not a sequential code, even though it reads that way. It
    is important to wrap your head around this when working with asynchronous logic:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这不是一个顺序代码，尽管它看起来是这样。在处理异步逻辑时，理解这一点很重要：
- en: When the code that sets up `Use 1` executes, it schedules the function to be
    called back after three seconds. But the main thread of execution continues immediately
    to set up `Use 2` and does not wait for 3 seconds to complete.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置`Use 1`的代码执行时，它安排了函数在3秒后回调和执行。但主执行线程立即继续设置`Use 2`，并不会等待3秒完成。
- en: '`Use 2` is then scheduled for 1 second in the future and will end up being
    triggered way before `Use 1`, so it is output first. Before this even happens,
    though, once again, the main thread of execution continues immediately to `Use
    3`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Use 2`被安排在未来的1秒后执行，并且最终会在`Use 1`之前触发，因此它首先输出。然而，在此发生之前，主执行线程再次立即继续到`Use 3`。'
- en: '`Use 3` is then scheduled for 2 seconds in the future. This is the second one
    to trigger and produce output, as `Use 1` won''t trigger until 3 seconds have
    passed.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Use 3`被安排在未来的2秒后执行。这是第二个触发并产生输出的用例，因为`Use 1`不会在3秒后触发。'
- en: 'Finally, `Use 1` triggers and outputs when the third second is reached:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当达到第三个秒时，`Use 1`触发并输出：
- en: '![Figure 15.4: Use cases shown in a diagram'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.4：用例在图中的展示'
- en: '](img/C14377_15_04.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_15_04.jpg)'
- en: 'Figure 15.4: Use cases shown in a diagram'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：用例在图中的展示
- en: In this section, you learned the details of how promises are created and used.
    Promises have become an important part of JavaScript and many libraries and APIs
    use them. Promises have also become a basis for extending the language further
    and supporting them directly with new keywords, as you will soon see.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何创建和使用promise的细节。Promise已经成为JavaScript的一个重要部分，许多库和API都使用它们。Promise也成为了进一步扩展语言和直接通过新关键字支持它们的基础，正如你很快就会看到的。
- en: The next section will explore `async/await`, which expands the use of promises
    with a new syntax.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将探讨`async/await`，它通过新的语法扩展了promise的使用。
- en: Async/Await
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Async/Await
- en: New additions to recent versions of JavaScript (since ES2017-ES8) make working
    with asynchronous logic easier, more transparent, and result in your code looking
    almost as if it were synchronous. This is the `async/await` syntax, which is one
    of the most exciting and useful additions to the language in recent years. We'll
    just dive right in and get a feel for how the `async` and `await` keywords are
    used by way of an example.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最近版本（自ES2017-ES8以来）的新增功能使处理异步逻辑变得更加容易、更加透明，并且使你的代码看起来几乎像是同步的。这是 `async/await`
    语法，这是近年来语言中最令人兴奋和有用的新增功能之一。我们将直接深入探讨并通过示例了解 `async` 和 `await` 关键字的使用。
- en: 'We will now present the changes you would make to refactor the promise code
    as you left it in the *Further Refinements to addDelay()* section to use `async/await`
    instead. Firstly, recall the main processing code that looked like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示你将如何修改承诺代码，以便将其从 *Further Refinements to addDelay()* 部分中留下的样子重构为使用 `async/await`。首先，回忆一下看起来像这样的主要处理代码：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When refactored to use the `await` syntax, it will look like the following.
    You can find the code on GitHub in the file `other/async_await.html`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当重构为使用 `await` 语法时，它将看起来像以下这样。你可以在GitHub上的文件 `other/async_await.html` 中找到代码。
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `await` keyword indicates that the function that follows returns a promise,
    and signals to the browser or JavaScript runtime to wait until the promise resolves
    and returns a result.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 关键字表示随后的函数返回一个承诺，并指示浏览器或JavaScript运行时等待承诺解决并返回结果。'
- en: Using `await` is really just syntactic sugar as an alternative to calling `promise.then()`,
    and the result is the same as the value that would be passed as a parameter if
    `promise.then()` were called. But using `await` allows you to capture the result
    in a variable and looks as if you were writing synchronous code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `await` 实际上只是作为调用 `promise.then()` 的替代的语法糖，结果与如果调用 `promise.then()` 会传递的值相同。但使用
    `await` 允许你在变量中捕获结果，看起来就像你正在编写同步代码。
- en: Also, notice how error handling is done using a typical `try...catch` block
    rather than a `catch()` function. This is another way in which `await` enables
    asynchronous code to be more seamless.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意错误处理是如何使用典型的 `try...catch` 块而不是 `catch()` 函数来完成的。这是 `await` 使异步代码更加无缝的另一种方式。
- en: 'Another method we will refactor is `myFetch()`. Previously, it looked like
    this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将重构另一个方法：`myFetch()`。之前，它看起来像这样：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Refactored, it will now look like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 重新重构后，它将看起来像这样：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `async` keyword before the function definition indicates that the function
    always returns a promise. Even if the actual value the function returns is not
    a promise, JavaScript will take care of wrapping that value in a promise automatically.
    In this case, the return value is the object resulting from the `response.json()`
    call, but what actually gets returned is a promise that wraps this. (The `await`
    keyword on the caller end would typically be used to unwrap the value again, but
    there are use cases where there is a need to work with the promise directly as
    well.)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义前的 `async` 关键字表示该函数始终返回一个承诺。即使函数实际返回的值不是一个承诺，JavaScript也会自动将其包装在一个承诺中。在这种情况下，返回值是
    `response.json()` 调用的结果对象，但实际上返回的是一个包装了这个对象的承诺。（调用端的 `await` 关键字通常用于再次解包值，但也有一些用例需要直接与承诺一起工作。）
- en: Also notice how the `fetch()` function call now has an `await` keyword in front
    of it, rather than processing it utilizing the typical promise API with `then()`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，`fetch()` 函数调用现在前面有一个 `await` 关键字，而不是使用 `then()` 函数的典型承诺API来处理它。
- en: 'There is another function you can refactor as well from a previous section:
    `getPlayerHonors()`. This is what it looked like before:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从前面的部分重构另一个函数：`getPlayerHonors()`。这是它之前的样子：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Remember that the purpose of this code is to make a REST service call to get
    player honor data for multiple players. Refactoring the code to use `async/await`,
    you can simplify it a bit and remove the sequence. Here''s the new code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这段代码的目的是对多个玩家的玩家荣誉数据进行REST服务调用。使用 `async/await` 重构代码可以稍微简化它并删除序列。以下是新代码：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `array.map()` function affects an iteration of all the players and calls
    `myFetch()` for each to get the honor data, resulting in an array of promises.
    Notice that you used the `async` keyword on the left of the arrow function. This
    is perfectly valid and just signals to `array.map()` that the function returns
    a promise. During processing, the execution of `array.map()` will not wait for
    the first function to complete before calling the next one. This makes the technique
    of utilizing `array.map()` with `async` well suited for launching concurrent requests.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`array.map()` 函数影响所有玩家的迭代，并为每个玩家调用 `myFetch()` 来获取荣誉数据，从而产生一个承诺数组。注意，你在箭头函数的左侧使用了
    `async` 关键字。这是完全有效的，并且只是向 `array.map()` 信号该函数返回一个承诺。在处理过程中，`array.map()` 的执行不会等待第一个函数完成后再调用下一个函数。这使得利用
    `array.map()` 与 `async` 的技术非常适合并发请求的启动。'
- en: Afterward, there is a second iteration using a standard `for...loop`, this time,
    of the promises produced earlier. The `await` keyword when calling `printHonors`
    would result in the execution waiting until the promise resolves before printing
    the available result. Also, since you are in a loop, you ensure the output is
    printed in the correct order.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用标准的 `for...loop` 进行第二次迭代，这次是对之前产生的承诺进行迭代。在调用 `printHonors` 时使用 `await`
    关键字会导致执行等待承诺解决后再打印可用的结果。此外，由于你在一个循环中，你确保输出以正确的顺序打印。
- en: Note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is another important caveat to be aware of when using the `await` keyword:
    it only works if it is used within a function that is marked with the `async`
    keyword in front of it. Attempting to use it in a regular function or in top-level
    code will result in a syntax error. (For this reason, in the code that follows,
    notice that you will place the main processing code in an anonymous `async` function.)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `await` 关键字时，还有一个重要的注意事项：它只能在前面带有 `async` 关键字的函数中使用。尝试在普通函数或顶层代码中使用它会导致语法错误。（因此，在接下来的代码中，请注意你将主要处理代码放在一个匿名的
    `async` 函数中。）
- en: Asynchronous Generators and Iterators
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步生成器和迭代器
- en: There is another implementation technique for the preceding `getPlayerHonors()`
    function to consider using it. This makes use of generator functions, which were
    described in *Chapter 5*, *Beyond the Fundamentals*. Generators, in general, are
    a recent and rather complex addition to the JavaScript language, and iterators
    are even newer, so not all browsers and runtime environments support them yet.
    We will therefore not spend a lot of time explaining them. But we just want to
    touch on them and explain very briefly how generators and iterators could be used
    with `async`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面提到的 `getPlayerHonors()` 函数，还有一种实现技术可以考虑使用。这种方法利用了生成器函数，这在 *第五章*，*超越基础* 中有描述。一般来说，生成器是
    JavaScript 语言中较新的且相对复杂的功能扩展，而迭代器则更为新颖，因此并非所有浏览器和运行时环境都支持它们。因此，我们不会花费太多时间来解释它们。但我们只是想简要地提及它们，并解释一下如何使用
    `async` 与生成器和迭代器一起使用。
- en: Here's the implementation. You can fnd the code on GitHub in the file `other/async_generator_impl.html`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是具体的实现。你可以在 GitHub 上的文件 `other/async_generator_impl.html` 中找到代码。
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first `getPlayerHonorsGenerator()` function should look mostly familiar,
    as it is similar to the previous implementation, but with some important differences.
    The asterisk (`*`) that follows the `function` keyword indicates that it is a
    generator function, which means it returns multiple values via subsequent calls.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `getPlayerHonorsGenerator()` 函数看起来应该很熟悉，因为它与之前的实现类似，但有一些重要的区别。在 `function`
    关键字后面的星号 (`*`) 表示它是一个生成器函数，这意味着它通过后续调用返回多个值。
- en: Notice the `yield` keyword in the loop. When `yield` is reached, execution passes
    back to the caller (which is actually the second function). When the generator
    function is called again, the execution picks up from where it left off in the
    middle of the loop and returns the next value. Once the loop ends, all the values
    have been returned, and the generator signals that it is done.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意循环中的 `yield` 关键字。当遇到 `yield` 时，执行权会返回给调用者（实际上就是第二个函数）。当再次调用生成器函数时，执行会从循环中间的断点处继续，并返回下一个值。一旦循环结束，所有值都已返回，生成器会发出完成信号。
- en: The second function calls the generator function using the `for-await...of`
    iterator syntax. The `await` keyword right after `for` makes it an `async` iterator.
    While performing the iteration, the execution will wait for each promise returned
    by the generator (via `yield`) to resolve in turn before executing the body of
    the loop.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数使用 `for-await...of` 迭代器语法调用生成器函数。紧跟在 `for` 之后的 `await` 关键字使其成为一个 `async`
    迭代器。在执行迭代时，执行将等待生成器（通过 `yield`）返回的每个 Promise 依次解析，然后再执行循环体。
- en: Generators are a complex topic. However, by adopting this technique, you are
    able to access the results of multiple asynchronous calls in a clean looping syntax.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一个复杂的话题。然而，通过采用这种技术，你能够以干净的循环语法访问多个异步调用的结果。
- en: 'Activity 15.01: Refactoring Promise Code to await/async Syntax'
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 15.01：将 Promise 代码重构为 await/async 语法
- en: Over the course of this chapter, you have explored how to take synchronous code
    and refactor it to use callbacks, promises, and `async/await` syntax. This activity
    will tie up some loose ends and challenge you to make some aspects of the code
    even better, partially by using the skills you learned in previous chapters.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经探讨了如何将同步代码重构为使用回调、Promise 和 `async/await` 语法。本活动将解决一些悬而未决的问题，并挑战你通过使用之前章节中学到的技能使代码的一些方面变得更好。
- en: 'The steps for completion are as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤如下：
- en: Firstly, recall the following code from *Exercise 15.03*, *Creating a Utility
    Function to Delay Execution* of this chapter, which uses promises to test three
    different uses of our `addDelay` function.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，回想一下本章 *练习 15.03*，*创建一个用于延迟执行的实用函数* 中的以下代码，该代码使用 Promise 测试了我们的 `addDelay`
    函数的三个不同用途。
- en: Rewrite it to use the `async/await` syntax.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重写为使用 `async/await` 语法。
- en: For the purposes of this activity, you are not permitted to use `Promise.all()`
    (even though, in normal programming, it would be a good way to wait for the completion
    of multiple promises).
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本活动的目的下，你不得使用 `Promise.all()`（尽管在常规编程中，这可能是等待多个 Promise 完成的好方法）。
- en: Hint
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: Be careful where you place your `await` keywords, as the three cases do not
    resolve in order.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意你放置 `await` 关键字的位置，因为这三个案例的解析顺序并不一致。
- en: 'The expected output is:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是：
- en: '![Figure 15.5: Sample output of player honors'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.5：玩家荣誉的示例输出'
- en: '](img/C14377_15_05.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_15_05.jpg)'
- en: 'Figure 15.5: Sample output of player honors'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5：玩家荣誉的示例输出
- en: Note
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 763.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 763 页找到。
- en: Before we move on to the next activity, we will review briefly what currying
    is. Currying is taking a function with multiple arguments and breaking it down
    into one or more additional functions that take just one argument and eventually
    resolve to a value. The initial function call does not take all the arguments
    but returns a function whose input is the remaining arguments and whose output
    is the intended result of all the arguments.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一个活动之前，我们将简要回顾一下柯里化是什么。柯里化是将一个带有多个参数的函数分解为一个或多个额外的函数，这些函数只接受一个参数，并最终解析为一个值。初始函数调用不接收所有参数，而是返回一个函数，该函数的输入是剩余的参数，其输出是所有参数的预期结果。
- en: 'Activity 15.02: Further Simplifying Promise Code to Remove Function Parameters'
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 15.02：进一步简化 Promise 代码以移除函数参数
- en: 'Shifting back to promises, we concluded the `async/await` section by tidying
    up the promise code to make the `then()` clauses one-liners. Here''s the code
    again to refresh your memory:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Promise，我们在整理 Promise 代码以使 `then()` 子句成为单行语句后，结束了 `async/await` 部分。以下是代码再次刷新你的记忆：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is pretty good, but could you do even better?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经相当不错了，但你还能做得更好吗？
- en: 'Now, we need to think of a way to simplify the code and remove the function
    parameters entirely, so it would look like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要考虑一种简化代码并完全移除函数参数的方法，使其看起来像这样：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Hint
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Think about how you might defer the processing of the first parameter of `getTeamsInLeague()`
    and `getPlayersOnTeam()`. Refactor those functions to return another function
    that finally processes this parameter instead using currying techniques, which
    you learned about in *Chapter 14*, *Understanding Functional Programming*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 思考一下你如何可能推迟 `getTeamsInLeague()` 和 `getPlayersOnTeam()` 的第一个参数的处理。重构这些函数以返回另一个函数，该函数最终处理此参数，而不是使用你在
    *第 14 章*，*理解函数式编程* 中学到的柯里化技术。
- en: 'The original code is repeated here for your convenience (the `getPlayerHonors()`
    function already takes only one parameter and, therefore, has no need to be further
    simplified for this purpose):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，原始代码在此重复（`getPlayerHonors()` 函数已经只接受一个参数，因此无需进一步简化以实现此目的）：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The steps for completion are as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤如下：
- en: 'In technique #1, refactor `getTeamsInLeague` so that it now only takes one
    parameter, `(leagueName)`, rather than two parameters that are actually needed
    to determine the full result `(leagueData, leagueName)`. The other parameter is
    deferred till later.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在技术 #1 中，重构 `getTeamsInLeague` 使其现在只接受一个参数 `(leagueName)`，而不是两个参数，这两个参数实际上需要来确定完整的结果
    `(leagueData, leagueName)`。另一个参数将延迟到以后。'
- en: 'In technique #1, instead of returning the promise from `myFetch` directly,
    you return another curried function that takes `leagueData` as its parameter.
    It is only a partially applied function at this point.'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在技术 #1 中，你不再直接从 `myFetch` 返回承诺，而是返回另一个以 `leagueData` 作为参数的柯里化函数。此时它只是一个部分应用函数。'
- en: 'Technique #2 is really the same idea but uses a function variable and multiple
    levels of arrow functions rather than a regular function.'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '技术 #2 实际上与第一个想法相同，但使用函数变量和多层箭头函数而不是常规函数。'
- en: Finally, when `getTeamsInLeague(LEAGUE_NAME)` is invoked in the `then()` clause,
    the function returned above would be fully applied, with the resolved value from
    the previous promise passed in as the implied `leagueData` parameter.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当在 `then()` 子句中调用 `getTeamsInLeague(LEAGUE_NAME)` 时，上面返回的函数将被完全应用，前一个承诺解析的值作为隐含的
    `leagueData` 参数传入。
- en: The process when calling `getTeamsInLeague(LEAGUE_NAME)` is incomplete at that
    point and returns another function to complete it. So, call a partially applied
    function.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `getTeamsInLeague(LEAGUE_NAME)` 时，该过程在那时是不完整的，并返回另一个函数来完成它。因此，调用一个部分应用函数。
- en: The expected output of the activity is the same as in *Exercise 15.02*, *Refactoring
    the Honors List to Use the Fetch API*, which gives a sample output of player honors.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的预期输出与 *练习 15.02*，*使用 Fetch API 重构荣誉列表* 相同，它提供了一个玩家荣誉的示例输出。
- en: Note
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 765.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第 765 页找到。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Like promises, `async/await` has become very important in JavaScript. You saw
    how this syntax helps your code appear almost like a synchronous code and can
    make your code clearer with regard to your desired intent. It even enables error
    handling in a more standard way with `try/catch`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就像承诺一样，`async/await` 在 JavaScript 中变得非常重要。你看到了这种语法如何帮助你的代码看起来几乎像是同步代码，并且可以使你的代码更清晰地表达你的意图。它甚至可以通过
    `try/catch` 以更标准的方式处理错误。
- en: But this is sometimes deceptive and can get you into trouble if you are not
    careful. It is important to understand how an asynchronous code differs from sequential
    code, in particular, how asynchronous code is triggered by event loops and does
    not block the main execution thread. The same is true with promises themselves,
    but with `async/await` looking so similar to synchronous code, it could be easy
    to forget this fact.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 但这有时具有欺骗性，如果不小心可能会给你带来麻烦。了解异步代码与顺序代码的不同，特别是异步代码是如何由事件循环触发的以及它不会阻塞主执行线程，这一点非常重要。对于承诺本身也是如此，但由于
    `async/await` 看起来与同步代码如此相似，很容易忘记这个事实。
- en: That said, `async/await` is still very powerful and worth using. We have reached
    the end of this book. By now, you have gained a comprehensive understanding of
    the foundations and basics of JavaScript. You have also fully understood JavaScript
    syntax and structures for the web and beyond. Now, you are ready to build out
    intellectually challenging development problems to apply in everyday work.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，`async/await` 仍然非常强大且值得使用。我们已经到达了这本书的结尾。到现在为止，你已经全面了解了 JavaScript 的基础和基础知识。你也已经完全理解了
    JavaScript 的语法和结构，无论是用于网页还是其他方面。现在，你准备好构建具有挑战性的智力开发问题，并将其应用于日常工作。
