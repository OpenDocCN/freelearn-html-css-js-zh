- en: Chapter 6. Store data in the Browser
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章 存储浏览器中的数据
- en: Backbone was mainly designed to work with RESTful API servers; however, you
    don't want to always store the data in a server for offline applications or to
    bust application loading storing cache data in the browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 主要被设计用来与 RESTful API 服务器一起工作；然而，你并不总是想在服务器上存储数据以供离线应用程序使用，或者为了打破应用程序加载，将缓存数据存储在浏览器中。
- en: 'We have two choices to store data in the user browser: use localStorage or
    the new IndexedDB API. While localStorage has wide support on major browsers,
    IndexedDB is the new specification that is yet to be supported in the near future.
    Another option that is available currently; however, in deprecated status is Web
    SQL. If you are developing modern web applications, you should avoid using Web
    SQL.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户浏览器中存储数据，我们有两种选择：使用 localStorage 或新的 IndexedDB API。虽然 localStorage 在主流浏览器中得到了广泛的支持，但
    IndexedDB 是一个尚未在近期得到支持的全新规范。目前还有一个可用的选项，但已处于弃用状态，那就是 Web SQL。如果你正在开发现代网络应用程序，你应该避免使用
    Web SQL。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Basics of localStorage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: localStorage 基础
- en: Basics of IndexedDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IndexedDB 基础
- en: Using localStorage instead of a RESTful server to store information
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 localStorage 而不是 RESTful 服务器来存储信息
- en: Using IndexedDB instead of a RESTful server to store information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IndexedDB 而不是 RESTful 服务器来存储信息
- en: The localStorage
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: localStorage
- en: 'The localStorage is the simplest and the most supported browser data store.
    At the moment of writing this book, it is supported in almost all the major browsers.
    As shown in the figure below, the only browser that does not support localStorage
    is Opera Mini:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: localStorage 是最简单且支持最广泛的浏览器数据存储。在撰写本书时，它几乎在所有主流浏览器中都得到了支持。如图所示，唯一不支持 localStorage
    的浏览器是 Opera Mini：
- en: '![The localStorage](img/B01962_06_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![localStorage](img/B01962_06_01.jpg)'
- en: Figure 6.1 Browser support of localStorage
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 localStorage 的浏览器支持
- en: 'The localStorage is a simple key/value database that is able to only store
    text. In localStorage, you have three main methods to access the data: `setItem()`,
    `getItem()`,and `removeItem()`. With these three functions, you can manage the
    data in the store pretty well.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: localStorage 是一个简单的键/值数据库，只能存储文本。在 localStorage 中，你有三个主要方法来访问数据：`setItem()`、`getItem()`
    和 `removeItem()`。有了这三个函数，你可以很好地管理存储中的数据。
- en: The downside of localStorage is that it does not have tables or collections,
    therefore, all the data is mixed; another issue with localStorage is that it is
    limited to 5 Mb of information. If your storage requirements are bigger than that,
    you will need IndexedDB.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: localStorage 的缺点是它没有表或集合，因此所有数据都是混合的；localStorage 的另一个问题是它限制在 5 Mb 的信息量。如果你的存储需求超过这个量，你将需要使用
    IndexedDB。
- en: Starting with localStorage
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 localStorage 开始
- en: 'To store the data in the localStorage store, you need to call the `setItem()`
    method in the `localStorage` global object:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 localStorage 中存储数据，你需要调用 `localStorage` 全局对象中的 `setItem()` 方法：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That''s it, this would store the information in the browser. We can explore
    the result of these instructions in Google Chrome as seen in the following figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，这些指令会在浏览器中存储信息。我们可以在以下图中探索这些指令的结果：
- en: '![Starting with localStorage](img/B01962_06_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![从 localStorage 开始](img/B01962_06_02.jpg)'
- en: Figure 6.2 Google Chrome and localStorage
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 Google Chrome 和 localStorage
- en: The data stored in localStorage is organized by site, which means that can you
    can only access the data stored on your site. In the above figure, you can see
    the available sites (`http://localhost:4000`) on the left-hand side. On the right-hand
    side, you can explore the data that we have stored with the `setItem()` method
    for the given site.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 localStorage 中的数据是按站点组织的，这意味着你只能访问存储在你站点上的数据。在上面的图中，你可以看到左侧可用的站点（`http://localhost:4000`）。在右侧，你可以探索我们使用
    `setItem()` 方法为给定站点存储的数据。
- en: 'To retrieve the information from localStorage, you have to use the `getItem()`
    method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 localStorage 中检索信息，你必须使用 `getItem()` 方法：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To delete an item from the store, we can use the `removeItem()` method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要从存储中删除一个项目，我们可以使用 `removeItem()` 方法：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As mentioned earlier, localStorage only stores strings on it. However, we want
    to store objects, how do we do that?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，localStorage 只能存储字符串。然而，我们想要存储对象，我们该如何做呢？
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Oops…that''s not what we expected. The localStorage automatically converts
    the object into string before storing the object. You can serialize objects with
    the `JSON.stringify()` function so that localStorage receives a string instead
    of an object:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀……这不是我们预期的结果。localStorage在存储对象之前会自动将其转换为字符串。你可以使用`JSON.stringify()`函数序列化对象，这样localStorage接收到的就是一个字符串而不是对象：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get the stored object back, you can use the `JSON.parse()` inverse function
    that converts a string into an object:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取存储的对象，你可以使用`JSON.parse()`的逆函数，它将字符串转换为对象：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is how you can store and retrieve objects from localStorage. You will need
    to encode and decode objects as you go. It is not recommended to store big objects
    in localStorage due to the heavy use of JSON functions; every time you encode
    or decode an object, the JavaScript thread will block that object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何在localStorage中存储和检索对象的方法。在存储和检索对象时，你需要进行编码和解码。由于JSON函数的使用非常频繁，不建议在localStorage中存储大对象；每次编码或解码对象时，JavaScript线程都会阻塞该对象。
- en: Backbone and localStorage
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone和localStorage
- en: To store Backbone models in localStorage, you can use the `ID` attribute as
    key and the serialized data as the value. However, remember that all the data
    in localStorage is mixed and this strategy will lead to identifier collisions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要在localStorage中存储Backbone模型，你可以使用`ID`属性作为键，将序列化数据作为值。然而，请记住，localStorage中的所有数据都是混合的，这种策略会导致标识符冲突。
- en: Consider that you have two different models (contacts and invoices) with the
    same `ID`; when you store one of them in the localStorage, it will overwrite the
    other.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个不同的模型（联系人和发票）具有相同的`ID`；当你将其中一个存储在localStorage中时，它会覆盖另一个。
- en: Another issue with localStorage is that when you want to retrieve data from
    the store before getting an item from the store, you need to know which key does
    it have. However, in localStorage, we don't have a clue about what IDs are currently
    in the store, therefore, we need a way to keep track of the IDs that are in the
    store at a given time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: localStorage的另一个问题是，当你想在从存储中获取项目之前从存储中检索数据时，你需要知道它具有哪个键。然而，在localStorage中，我们没有关于当前存储中ID的信息，因此，我们需要一种方法来跟踪在给定时间存储中的ID。
- en: 'To deal with these issues, you can create a well-known key in the store as
    an index of the IDs that are available for a given collection. See how it works
    in the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些问题，你可以在存储中创建一个已知键作为给定集合可用ID的索引。以下是如何工作的示例：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To prevent collision between collections of models with the same ID, you can
    generate prefixed keys for the collection items so that instead of having number
    keys such as `1`, you can use keys such as `contacts-1`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止具有相同ID的模型集合之间的冲突，你可以为集合项生成前缀键，这样你就可以使用像`contacts-1`这样的键，而不是像`1`这样的数字键：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Store models in localStorage
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在localStorage中存储模型
- en: Now that you know how to store and retrieve data from localStorage, it's time
    to store your models. In the following figure, you can see how to make data storage
    in local instead of a remote server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何从localStorage存储和检索数据，是时候存储你的模型了。在下面的图中，你可以看到如何将数据存储在本地而不是远程服务器。
- en: By default, when you call the `save()` method on a model Backbone, it transforms
    the action into an HTTP request for a RESTFul server. To store the data in local,
    you need to change the default behavior in order to use localStorage instead of
    making HTTP requests; you will learn how to do this in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你对一个Backbone模型调用`save()`方法时，它会将操作转换为对RESTFul服务器的HTTP请求。为了在本地存储数据，你需要更改默认行为，以便使用localStorage而不是发起HTTP请求；你将在下一节中学习如何做到这一点。
- en: 'To make the storage layer maintainable, you will need to create a Backbone
    driver for localStorage first. The responsibility of the driver is to store and
    retrieve data from localStorage so that the connection between Backbone and localStorage
    is simpler:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使存储层易于维护，你首先需要为localStorage创建一个Backbone驱动器。驱动器的职责是从localStorage存储和检索数据，以便Backbone和localStorage之间的连接更加简单：
- en: '![Store models in localStorage](img/B01962_06_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![在localStorage中存储模型](img/B01962_06_03.jpg)'
- en: Figure 6.3 Store models in localStorage
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 在localStorage中存储模型
- en: In the next section, I will show you how to construct the `DataStore` driver
    to store the Backbone models in localStorage.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向你展示如何构建`DataStore`驱动器，以便在localStorage中存储Backbone模型。
- en: Store Backbone models in localStorage
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在localStorage中存储Backbone模型
- en: 'It''s time to use what you have learned about `localStorage` to store and retrieve
    objects. The `DataStore` object is responsible to transform models into strings
    to be stored in localStorage:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用你关于 `localStorage` 的知识来存储和检索对象了。`DataStore` 对象负责将模型转换为字符串以便存储在 localStorage
    中：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The DataStore object needs a name to be used as a collection index prefix.
    The first use case is to create a new item:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: DataStore 对象需要一个名称作为集合索引的前缀。第一个用例是创建一个新的条目：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When a new model is created, it assigns a new ID with a `generateId()`function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的模型时，它使用 `generateId()` 函数分配一个新的 ID：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `itemName()` function generates a key that is to be used in localStorage
    given the model ID; the `serialize()`method transforms a model into a JSON string
    that is ready to be stored in localStorage. Finally, the `index` attribute in
    DataStore tracks all the available IDs so that we should push the model ID in
    the index.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemName()` 函数根据模型 ID 生成一个在 localStorage 中使用的键；`serialize()` 方法将模型转换为一个准备存储在
    localStorage 中的 JSON 字符串。最后，DataStore 中的 `index` 属性跟踪所有可用的 ID，因此我们应该将模型 ID 推送到索引中。'
- en: 'For the update method, we will overwrite the current value of the model:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新方法，我们将覆盖模型的当前值：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you call the `setItem()` method with an existent key on localStorage, the
    previous value is overwritten with the new one, the net effect is an update operation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `setItem()` 方法在 localStorage 中对一个已存在的键进行操作，原来的值会被新的值覆盖，这实际上是一个更新操作。
- en: 'When you are looking for a model, you need to set the ID of the model and call
    the `fetch()` method on it in order to retrieve the data from a server. In our
    DataStore, we can call this operation `find`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在寻找一个模型时，你需要设置模型的 ID，并在其上调用 `fetch()` 方法以从服务器检索数据。在我们的 DataStore 中，我们可以将此操作称为
    `find`：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `find()` method is very simple, it tries to get the data from localStorege
    with an ID built with the `itemName()` method; if the model is not found, it will
    return a `null` value. While returning a single model is very simple, retrieving
    a list of them is a more complex operation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 方法非常简单，它尝试使用 `itemName()` 方法构建的 ID 从 localStorege 中获取数据；如果找不到模型，它将返回一个
    `null` 值。虽然返回单个模型非常简单，但检索它们的列表是一个更复杂的操作：'
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method loops over all the available keys for the given collection; for
    each item in the list, it converts it from string to a JSON object. All items
    are aggregated in a single array that returns as a result.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历给定集合的所有可用键；对于列表中的每个项目，它将其从字符串转换为 JSON 对象。所有项目都聚合到一个数组中，并作为结果返回。
- en: 'To remove an item from DataStore, you will need to remove its value from localStorage
    and drop the index that is related to it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 DataStore 中删除一个项目，你需要从 localStorage 中删除其值并丢弃与其相关的索引：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We use the `updateIndex()` method when the collection of models is altered
    in localStorage; it should store a list of IDs as strings:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 localStorage 中修改模型集合时，我们使用 `updateIndex()` 方法；它应该存储一个 ID 列表作为字符串：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Model IDs are generated with the name of the collection and its ID:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 模型 ID 使用集合名称及其 ID 生成：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `DataStore` class, by itself, can store and retrieve models from localStorage;
    however, it is not fully integrated with Backbone. In the next section, we will
    examine how Backbone stores and retrieves models from a RESTful API and how to
    change this behavior to use the `DataStore` driver.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataStore` 类本身可以存储和检索 localStorage 中的模型；然而，它并没有完全集成到 Backbone 中。在下一节中，我们将探讨
    Backbone 如何从 RESTful API 存储和检索模型，以及如何更改此行为以使用 `DataStore` 驱动程序。'
- en: Backbone.sync
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone.sync
- en: 'This is responsible to handle connections between a RESTful server and the
    Backbone application is the Backbone.sync module. It transforms the `fetch()`
    and `save()` operations into HTTP requests:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 负责处理 RESTful 服务器与 Backbone 应用程序之间连接的是 Backbone.sync 模块。它将 `fetch()` 和 `save()`
    操作转换为 HTTP 请求：
- en: '`fetch()` is mapped as a `read` operation. This will make `GET` to the the
    `urlRoot` attribute with the model ID for a model or the `url` attribute for a
    collection.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch()` 被映射为一个 `read` 操作。这将使得对具有模型 ID 的模型或集合的 `urlRoot` 属性执行 `GET` 请求。'
- en: '`save()` is mapped as a `create` or `update` operation; it depends on the `isNew()`
    method:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save()` 被映射为 `create` 或 `update` 操作，这取决于 `isNew()` 方法：'
- en: This will be mapped as `create` if the model does not have an ID (`isNew()`
    method return `true`). A POST request is executed.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模型没有 ID（`isNew()` 方法返回 `true`），这将映射为 `create` 操作。执行一个 POST 请求。
- en: This will be mapped as `update` if the model already has an ID (`isNew()` method
    returns `false`). A PUT request is executed.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模型已经有一个ID（`isNew()` 方法返回 `false`），这将映射为 `update`。执行PUT请求。
- en: '`destroy()` is mapped as a `delete` operation. This will make DELETE to the
    the `urlRoot` attribute with the model ID for a model or the `url` attribute for
    a collection.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy()` 被映射为 `delete` 操作。这将导致对具有模型ID的模型或集合的 `urlRoot` 属性执行DELETE操作。'
- en: 'To better understand how Backbone.sync does its job, consider the following
    examples:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 `Backbone.sync` 是如何工作的，考虑以下示例：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can read in the Backbone documentation, `Backbone.sync` has the following
    signature:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在Backbone文档中所读到的，`Backbone.sync` 有以下签名：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, the method is the operation that is to be issued (`read`, `create`, `update`,
    or `delete`). You can easily overwrite this function in order to redirect the
    requests to localStorage instead of a RESTful server:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，方法是将要执行的操作（`read`、`create`、`update` 或 `delete`）。你可以轻松地覆盖这个函数，以便将请求重定向到localStorage而不是RESTful服务器：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While the localStorage API is synchronous, it does not need to use callbacks
    or promises; however, in order to be compatible with the default implementation,
    we need to create a `Deferred` object and return a `promise`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然localStorage API是同步的，但它不需要使用回调或承诺；然而，为了与默认实现兼容，我们需要创建一个 `Deferred` 对象并返回一个
    `promise`。
- en: If you don't know what a promise or `Deferred` objects are, please refer to
    the jQuery documentation for more information about it. The explanation of how
    promises work is out of the scope of this book.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道什么是承诺或 `Deferred` 对象，请参阅jQuery文档以获取更多关于它的信息。承诺如何工作的解释超出了本书的范围。
- en: 'The previous `Backbone.sync` implementation is looking for a `dataStore` attribute
    in the models/collections. The attribute should be included in these objects in
    order to be stored correctly. As you may guess, it should be an instance of our
    DataStore driver:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `Backbone.sync` 实现正在寻找模型/集合中的 `dataStore` 属性。为了正确存储，这些对象应包含该属性。正如你可能猜到的，它应该是我们DataStore驱动程序的实例：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The implementation that we made earlier for localStorage is inspired from the
    Backbone.localStorage plugin. If you want to store all your models in the browser,
    please use the plugin that has the support of the community.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前为localStorage所做的实现受到了Backbone.localStorage插件的启发。如果你想将所有模型存储在浏览器中，请使用社区支持的插件。
- en: Due the limitations of localStorage, it is not suitable to store avatar images
    on it as we will reach the limits with only a few records.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于localStorage的限制，不适合在上面存储头像图片，因为我们只需存储少量记录就会达到限制。
- en: Using localStorage as cache
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用localStorage作为缓存
- en: The Datastore driver is useful to develop small applications that do not need
    to fetch and store the data in a remote server. It can be enough to prototype
    small web applications or store configuration data in the browser.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储驱动程序对于开发不需要从远程服务器获取和存储数据的小型应用程序很有用。它足以原型化小型Web应用程序或存储配置数据在浏览器中。
- en: 'However, another use for the driver can be cache server response in order to
    speed up the application performance:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，驱动程序的另一个用途可以是缓存服务器响应以加快应用程序性能：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the application needs to read the data, it tries to read the data from
    localStorage first. If no model is found, it will use the original Backbone.sync
    function to fetch the data from the server.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要读取数据时，它首先尝试从localStorage中读取数据。如果没有找到模型，它将使用原始的 `Backbone.sync` 函数从服务器获取数据。
- en: 'When the server responds, it will store the response in localStorage for future
    use. To cache a server response, it should store the server response or drop the
    model from the cache when the model is deleted:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器响应时，它将响应存储在localStorage中供将来使用。为了缓存服务器响应，当模型被删除时，应该存储服务器响应或从缓存中删除模型：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Dropping the model from the cache is quite simple:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从缓存中删除模型相当简单：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To store and retrieve the data in the cache is more complex; you should have
    a cache expiration policy. For this project, we will expire the cached responses
    after 15 minutes, which means that we will remove the cached data and then make
    a `fetch`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存中存储和检索数据更为复杂；你应该有一个缓存过期策略。对于这个项目，我们将缓存响应在15分钟后过期，这意味着我们将删除缓存数据然后进行 `fetch`：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `fetchedAt` attribute is used to show the time we fetched the data from
    the server. When the cache expires, it removes the model from the cache and returns
    `null` to force a server `fetch`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchedAt`属性用于显示我们从服务器获取数据的时间。当缓存过期时，它会从缓存中删除模型并返回`null`以强制服务器`fetch`。'
- en: 'When a model is cached, it should set the `fetchedAt` attribute for the first
    time when it is fetched:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模型被缓存时，它应该在第一次获取时设置`fetchedAt`属性：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we need to replace the original Backbone.sync function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要替换原始的Backbone.sync函数：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: IndexedDB
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IndexedDB
- en: 'As you have seen in the previous sections, localStorage is very easy; however,
    it has the limitation of 5 MB of storage capacity. IndexedDB, on the other hand,
    does not have this limitation; however, it has a complex API. The main downside
    of IndexedDB is that it is not fully supported on all major browsers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所示，localStorage非常简单；然而，它有5MB存储容量的限制。另一方面，IndexedDB没有这个限制；然而，它有一个复杂的API。IndexedDB的主要缺点是它不是在所有主要浏览器上完全受支持：
- en: '![IndexedDB](img/B01962_06_04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![IndexedDB](img/B01962_06_04.jpg)'
- en: 'Figure 6.4: Browser support for IndexedDB'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：IndexedDB的浏览器支持
- en: At the moment of writing this book, IndexedDB is fully supported by Chrome and
    Firefox, while Safari and IE have partial support.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，IndexedDB在Chrome和Firefox上完全受支持，而Safari和IE有部分支持。
- en: A big difference between localStorage and IndexedDB is that IndexedDB is not
    a key/value store; IndexedDB has collections (tables) and a query API. If you
    have worked with MongoDB, you will be familiar with the way IndexedDB stores data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: localStorage和IndexedDB之间的一大区别是IndexedDB不是一个键/值存储；IndexedDB有集合（表）和查询API。如果你使用过MongoDB，你将熟悉IndexedDB存储数据的方式。
- en: Getting started with IndexedDB
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用IndexedDB
- en: An IndexedDB database is composed of one or more stores. A store is like a JSON
    container, it contains a collection of JSON. If you have worked with SQL, then
    a store is like a table. If you have worked with MongoDB, a store is a like a
    collection. In the same way as MongoDB, IndexedDB is schemaless, which means that
    you don't need to define the schema of the records (JSONs).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个IndexedDB数据库由一个或多个存储组成。存储就像一个JSON容器，它包含一组JSON。如果你使用过SQL，那么存储就像一个表。如果你使用过MongoDB，存储就像一个集合。与MongoDB相同，IndexedDB是无模式的，这意味着你不需要定义记录（JSON）的模式。
- en: One of the consequences of schemaless is that the data in the collections is
    not heterogeneous, you can have different types JSON objects in the same store.
    For example, you can store contact and invoice data in the same store.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 无模式的一个后果是集合中的数据不是异构的，你可以在同一个存储中存储不同类型的JSON对象。例如，你可以在同一个存储中存储联系人和发票数据。
- en: 'IndexedDB is more flexible and powerful than localStorage; however, with great
    power comes great responsibility. You will have to deal with stores, cursors,
    indexes, transactions, migrations, and asynchronous API:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB比localStorage更灵活、更强大；然而，强大的力量伴随着巨大的责任。你将不得不处理存储、游标、索引、事务、迁移和异步API：
- en: '![Getting started with IndexedDB](img/B01962_06_05.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用IndexedDB](img/B01962_06_05.jpg)'
- en: 'Figure 6.5: IndexedDB'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：IndexedDB
- en: Database versions
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库版本
- en: Databases usually change with time; maybe a new feature needs a new store or
    adds an index. All IndexedDB databases have a version number. The first time that
    you create a new database, it starts with version 1\. With the help of each version
    number, you can define the stores and indexes as you need.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通常随时间而变化；可能需要一个新的存储或添加一个索引来适应新功能。所有IndexedDB数据库都有一个版本号。当你第一次创建一个新的数据库时，它从版本1开始。借助每个版本号，你可以根据需要定义存储和索引。
- en: IndexedDB does not allow you to create new stores or indexes, unless you have
    changed the version number. When a new version number is detected, IndexedDB enters
    a `versionchange` state and calls the `onupgradedneeded()` callback, which you
    can use to modify the database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB不允许你创建新的存储或索引，除非你更改了版本号。当检测到新的版本号时，IndexedDB进入`versionchange`状态并调用`onupgradedneeded()`回调，你可以使用它来修改数据库。
- en: 'Every time you change the version number, you have the opportunity to run database
    migrations in the `onupgradedneeded()` callback. Every time you open a connection
    with IndexedDB, you can specify a version number:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你更改版本号时，你都有机会在`onupgradedneeded()`回调中运行数据库迁移。每次你使用IndexedDB打开连接时，你都可以指定一个版本号：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first time you open a database, IndexedDB enters the `versionchange` state
    and calls the `onupgradedneeded()`callback.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次打开数据库时，IndexedDB进入`versionchange`状态并调用`onupgradedneeded()`回调。
- en: Creating stores
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建存储
- en: 'To create stores on IndexedDB, you need to put the database on the version
    change state, which you can do in the following two ways:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要在IndexedDB上创建存储，你需要将数据库置于版本更改状态，你可以通过以下两种方式之一来完成：
- en: Create a new database.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的数据库。
- en: Change the version number of the database.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改数据库的版本号。
- en: 'In the following example, we are creating a new database named library:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们正在创建一个名为library的新数据库：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the `open()` method is called, it returns a request object that we can
    use to register the `onscuccess()`callback called when the database is successfully
    opened and is ready to be used. As we are creating a new database, the `onupgradeneeded()`callback
    is called.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`open()`方法时，它返回一个请求对象，我们可以使用它来注册当数据库成功打开并准备好使用时调用的`onsuccess()`回调。由于我们正在创建一个新的数据库，所以会调用`onupgradeneeded()`回调。
- en: 'The database handler is in the `result` attribute of the `request` object.
    You can use the `createObjectStore()` method of the database handler in order
    to create a new store:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库处理程序位于`request`对象的`result`属性中。你可以使用数据库处理程序的`createObjectStore()`方法来创建一个新的存储：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first argument of the `createObjectStore()` method is the name of the store,
    in our example it is library. The `options` arguments should be a plain object
    where the available fields are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`createObjectStore()`方法的第一个参数是存储的名称，在我们的例子中是library。`options`参数应该是一个普通对象，其中可用的字段如下：'
- en: '| Option name | Description | Default value |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 选项名称 | 描述 | 默认值 |'
- en: '| --- | --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **autoIncrement** | This auto increments the `primary key` attribute | `false`
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **autoIncrement** | 这会自动增加`主键`属性 | `false` |'
- en: '| **keyPath** | This is the attribute name in the objects that is to be used
    as `primary key` | `null` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **keyPath** | 这是对象中用作`主键`的属性名称 | `null` |'
- en: 'After the object store creation, a store handler is returned, which you can
    use to insert new records in the recently created object store. The `put()`method
    is used to insert new records in the store it accepts as argument the JSON to
    be stored:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象存储创建之后，会返回一个存储处理程序，你可以使用它来在最近创建的对象存储中插入新记录。`put()`方法用于在存储中插入新记录，它接受要存储的JSON作为参数：
- en: '![Creating stores](img/B01962_06_06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![创建存储](img/B01962_06_06.jpg)'
- en: 'Figure 6.6: IndexedDB in Google Chrome'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：Google Chrome中的IndexedDB
- en: As you can see in the preceding image, the object store has the objects that
    we insert with the `put()` method in the `onupgradeneeded` event.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，对象存储具有我们使用`put()`方法在`onupgradeneeded`事件中插入的对象。
- en: Delete a database
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除数据库
- en: 'You can always delete a database with the `deleteDatabse()` method. If you
    did something wrong and want to start over, just delete the database:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你始终可以使用`deleteDatabase()`方法删除数据库。如果你做错了什么并且想从头开始，只需删除数据库：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Add elements to an object store
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向对象存储添加元素
- en: 'You have seen how to create and delete stores. Now, you will see how to connect
    to a database and add records to an object store outside of the `onupgradeneeded()`
    callback:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何创建和删除存储。现在，你将看到如何在`onupgradeneeded()`回调之外连接到数据库并向对象存储添加记录：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that we are creating an IndexedDB transaction. The IndexedDB specification
    by W3C defines a transaction as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在创建一个IndexedDB事务。W3C的IndexedDB规范将事务定义为如下：
- en: '*A transaction is used to interact with the data in a database. Whenever data
    is read or written to the database it is done by using a transaction.*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*事务用于与数据库中的数据进行交互。每当数据被读取或写入数据库时，都是通过使用事务来完成的。*'
- en: '*Transactions offer some protection from application and system failures. A
    transaction may be used to store multiple data records or to conditionally modify
    certain data records. A transaction represents an atomic and durable set of data
    access and data mutation operations.*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*事务提供了一些防止应用程序和系统失败的保护。可以使用事务来存储多个数据记录或条件性地修改某些数据记录。事务代表了一组原子且持久的对数据访问和数据修改操作。*'
- en: 'The `transaction()`method of the `indexedDB` object has two arguments: scope
    and mode, as shown in the following table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexedDB`对象的`transaction()`方法有两个参数：作用域和模式，如下表所示：'
- en: '| Argument | Description | Examples |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **scope** | The store or stores where the transaction interacts | ''books'',[''contacts'',
    ''invoices''] |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **作用域** | 事务与之交互的存储或存储 | ''books'',[''contacts'', ''invoices''] |'
- en: '| **mode** | This states what type of interaction will be done | ''readonly'',
    ''readwrite'' |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | 这表示将要进行的交互类型 | ''readonly'', ''readwrite'' |'
- en: When the transaction is created, you can access the stores with the `objectStore()`method
    of the transaction object, which returns an object store handler that you can
    use to add or remove records.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当事务创建时，您可以通过事务对象的 `objectStore()` 方法访问存储，该方法返回一个对象存储处理程序，您可以使用它来添加或删除记录。
- en: The `put()` method is used to insert objects into the store; however, the method
    is asynchronous, which means that the records are not stored immediately like
    in localStorage. You should register an `oncomplete()` callback in the transaction
    object that will be called when the operations are done.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`put()` 方法用于将对象插入到存储中；然而，该方法是非同步的，这意味着记录不会像在 localStorage 中那样立即存储。您应该在事务对象中注册一个
    `oncomplete()` 回调函数，当操作完成时将被调用。'
- en: Performing queries
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行查询
- en: 'To query the data in an object store, you need to open a `readonly` transaction:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询对象存储中的数据，您需要打开一个 `readonly` 事务：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Queries are to be done by opening cursors with the `openCursor()` method. The
    first argument of the `openCursor()` method is a query that should be an `IDBKeyRange`
    object:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 查询应通过使用 `openCursor()` 方法打开游标来完成。`openCursor()` 方法的第一个参数是一个查询，它应该是一个 `IDBKeyRange`
    对象：
- en: '`only(value)`: It looks for the value, such as an == operation'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`only(value)`: 它查找该值，例如一个 == 操作'
- en: '`lower(value)`: It looks for the values lower or equal to the value, such as
    a <= operation'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower(value)`: 它查找小于或等于该值的值，例如一个 <= 操作'
- en: '`lowerOpen(value)`: It looks for values lower than the value, such as a < operation'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lowerOpen(value)`: 它查找小于该值的值，例如一个 < 操作'
- en: '`upper(value)`: It looks for values greater than or equal to the value, such
    as a >= operation'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upper(value)`: 它查找大于或等于该值的值，例如一个 >= 操作'
- en: '`upperOpen(value)`: It looks for values greater than the value, such as a >
    operation'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upperOpen(value)`: 它查找大于该值的值，例如一个 > 操作'
- en: These are some of the queries that are available; please refer to the IndexedDB
    specification for a complete list of all the available queries. IndexedDB uses
    the query to compare the values that are passed as an argument with the objects
    in the store; however, which attribute in the store is compared? The answer is
    the key that is specified in `keyPath`. In our example, the `isbn` attribute will
    be used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些可用的查询；请参阅 IndexedDB 规范以获取所有可用查询的完整列表。IndexedDB 使用查询来比较作为参数传递的值与存储中的对象；然而，存储中比较的是哪个属性？答案是
    `keyPath` 中指定的键。在我们的例子中，将使用 `isbn` 属性。
- en: The cursor will call the `onsuccess()` callback repeatedly for every object
    found, you should call the `continue()` method on the cursor object to fetch the
    next object. The result will be `null` when no more objects are found.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 游标将为每个找到的对象重复调用 `onsuccess()` 回调，您应该在游标对象上调用 `continue()` 方法以获取下一个对象。当没有更多对象时，结果将是
    `null`。
- en: 'If you want to query the objects by a different attribute, you should create
    indexes in the store for the attributes that you need. Use a different version
    number to add new indexes to the object stores:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想根据不同的属性查询对象，您应该在存储中为所需的属性创建索引。使用不同的版本号向对象存储添加新索引：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see in the preceding example, you can use an index to query objects.
    The same `onsuccess()` method is invoked every time that the index finds a result.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，您可以使用索引来查询对象。每次索引找到结果时，都会调用相同的 `onsuccess()` 方法。
- en: Delete objects in the store
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除存储中的对象
- en: 'To delete objects, you should call the `delete()` method in the object store
    with a query argument for these objects that you want to remove:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除对象，您应该在对象存储中调用 `delete()` 方法，并传递一个查询参数，用于移除这些对象：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: IndexedDB in Backbone
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone 中的 IndexedDB
- en: As the IndexedDB API is more complex than localStorage, it will be more difficult
    to create an IndexedDB driver for Backbone as we did with localStorage; in this
    section, you will use what you have learned about IndexedDB in order to build
    a driver for Backbone.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 IndexedDB API 比localStorage更复杂，因此创建一个与 Backbone 相似的 IndexedDB 驱动器会更困难；在本节中，您将使用您所学的
    IndexedDB 知识来构建一个 Backbone 驱动器。
- en: 'The driver should open a database and initialize the stores when it is created
    for the first time:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动器在第一次创建时应打开数据库并初始化存储。
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the connection is opened, it creates the contacts store and puts the first
    records in the store. After that it caches the database handler in the `db` attribute
    to reuse the connection for future requests.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接打开时，它创建联系人存储并将第一条记录放入存储中。之后，它将数据库处理程序缓存在 `db` 属性中以重用连接进行未来的请求。
- en: 'Now, we should create the necessary method to create, update, delete, and read
    the data from the store:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该创建必要的创建、更新、删除和从存储中读取数据的方法：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When a record is created, we should ensure that the model has an ID. We can
    generate it for the models that do not have an ID assigned. The `store()` method
    will put the record in the indexedDB database:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建记录时，我们应该确保模型有一个 ID。我们可以为没有分配 ID 的模型生成它。`store()` 方法将记录放入 indexedDB 数据库：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `store()` method obtains the name of the store from the `modelstore` attribute
    and then, creates a `readwrite` transaction for the given store name to put the
    record on it. The `update()` method uses the same `store()` method to save the
    record:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`store()` 方法从 `modelstore` 属性获取存储的名称，然后为给定的存储名称创建一个 `readwrite` 事务，以便将记录放在上面。`update()`
    方法使用相同的 `store()` 方法来保存记录：'
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The update method does not assign an ID to the model, it completely replaces
    the previous record with the new model data. To delete a record, you can use the
    `delete()` method of the object store handler:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 更新方法不会为模型分配 ID，它完全用新的模型数据替换了之前的记录。要删除记录，可以使用对象存储处理器的 `delete()` 方法：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To get all the models stored on an object store, you need to open a cursor
    and put all the items in an array, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取对象存储上存储的所有模型，你需要打开一个游标并将所有项目放入一个数组中，如下所示：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note how this time the transaction opened is in the `readonly` mode. A single
    object can be obtained by querying the model ID:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次打开的事务是在 `readonly` 模式下。可以通过查询模型 ID 获取单个对象：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the same way as we did with localStorage, this IndexedDB driver can be used
    to overwrite the `Backbone.sync` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们处理 localStorage 的方式相同，这个 IndexedDB 驱动程序可以用作覆盖 `Backbone.sync` 函数：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, models should add the `store` attribute to indicate in which object store
    the model will be saved:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，模型应该添加 `store` 属性来指示模型将在哪个对象存储中保存：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'IndexedDB allows you to store more data than localStorage; therefore, you can
    use it to store the avatar image too. Just make sure that the `avatar` attribute
    is set so that an image is always selected:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB 允许你存储比 localStorage 更多的数据；因此，你也可以用它来存储头像图片。只需确保 `avatar` 属性被设置，以便始终选择一个图片：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Do not try to upload the image:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试上传图片：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You have learned two ways to store data in the browser and use them as a replacement
    for a RESTful API server. The localStorage method has a simple API and it is widely
    supported for all major browsers; this is going to be your first choice if you
    want support old browsers; however, it has the limitation that you can only store
    five megabytes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了两种在浏览器中存储数据并用作 RESTful API 服务器替代的方法。localStorage 方法有一个简单的 API，并且被所有主流浏览器广泛支持；如果你想要支持旧浏览器，这将是你首选的选择；然而，它有一个限制，就是你只能存储五兆字节。
- en: IndexedDB is powerful; however, its API is more complicated than localStorage.
    You need to learn some concepts before you start working with it. Once you know
    how it works, you should write your app asynchronously.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB 功能强大；然而，它的 API 比localStorage更复杂。在开始使用它之前，你需要学习一些概念。一旦你知道它是如何工作的，你应该异步地编写你的应用程序。
