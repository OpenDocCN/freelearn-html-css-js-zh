- en: Chapter 6. Scaling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。扩展
- en: In this chapter we will look at options for scaling Express. Our current solution
    will not scale beyond a single process/server; introducing a few simple changes
    will allow us to scale Vision both horizontally and vertically. We will also take
    a look at an alternative web architecture, and examine how decoupling our application
    can improve our application and help us scale Express further.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨扩展 Express 的选项。我们的当前解决方案无法扩展到单个进程/服务器；引入一些简单的更改将允许我们水平扩展和垂直扩展 Vision。我们还将查看一种替代的
    Web 架构，并检查解耦我们的应用程序如何改进我们的应用程序并帮助我们进一步扩展 Express。
- en: Scaling Express sessions with Redis
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redis 扩展 Express 会话
- en: 'Running our Express application with the `NODE_ENV` set to `production` will
    output the following message:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `NODE_ENV` 设置为 `production` 运行我们的 Express 应用程序将输出以下消息：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The default session store for Express is an in-memory store; tying sessions
    to a single process does not scale.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Express 的默认会话存储是一个内存存储；将会话绑定到单个进程无法扩展。
- en: Also, if the server crashes then we lose those sessions. If we want to scale
    the Express application to more than one server, we will need a memory store that
    is decoupled from the Express application. Express has a couple of optional stores;
    here we will use Redis via `connect-redis`. Let's configure the vision application
    to use Redis as a session store.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果服务器崩溃，我们将丢失那些会话。如果我们想将 Express 应用程序扩展到多个服务器，我们需要一个与 Express 应用程序解耦的内存存储。Express
    有几个可选的存储方案；在这里，我们将使用 `connect-redis` 通过 Redis。让我们配置视觉应用程序以使用 Redis 作为会话存储。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will now make a couple of changes to the Express server `./lib/express/index.js`.
    We start by bringing in the `Redis` module we previously created, that configures
    and connects to a Redis server. We instantiate one of these into `redis`. We then
    require `connect-redis` which returns `RedisStore`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对 Express 服务器 `./lib/express/index.js` 进行一些更改。我们首先引入我们之前创建的 `Redis` 模块，该模块配置并连接到
    Redis 服务器。我们将其中一个实例化为 `redis`。然后我们引入 `connect-redis`，它返回 `RedisStore`。
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have in place an existing `sessionStore` which is configured to use `MemoryStore`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个现有的 `sessionStore`，配置为使用 `MemoryStore`：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s replace this with our new `RedisStore`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用新的 `RedisStore` 替换它：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our application is now ready to use Redis to store sessions. We can monitor
    Redis session activity via `redis-cli` by running the following commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在可以使用 Redis 存储会话。我们可以通过运行以下命令来通过 `redis-cli` 监控 Redis 会话活动：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Scaling Socket.IO with Redis
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redis 扩展 Socket.IO
- en: Socket.IO also uses an in-memory store to store its events. There are a couple
    of issues with this; the first being that if the server fails we lose those messages
    stored in memory. The second is if we attempt to scale our application by adding
    more servers, the Socket.IO in-memory store will be tied to a single server; the
    servers we add will not know which Socket.IO connections are open on other servers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO 也使用内存存储来存储其事件。这里有几个问题；第一个是如果服务器失败，我们将丢失存储在内存中的那些消息。第二个是如果我们尝试通过添加更多服务器来扩展我们的应用程序，Socket.IO
    的内存存储将绑定到单个服务器；我们添加的服务器将不知道其他服务器上哪些 Socket.IO 连接是打开的。
- en: 'We can solve these problems by using the Socket.IO `RedisStore`. We start by
    requiring a `RedisStore`, which is a `redis` module from the Socket.IO namespace.
    We can also use the vision `Redis` module to create three redis clients: `pub`,
    `sub`, and `client`. In order to configure Socket.IO to use the `RedisStore`,
    we set the Socket.IO `''store''` to a `RedisStore`, which passes `redis`, `pub`,
    `sub`, and `client` as the arguments.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 Socket.IO 的 `RedisStore` 解决这些问题。我们首先引入一个 `RedisStore`，它是 Socket.IO
    命名空间中的 `redis` 模块。我们还可以使用视觉的 `Redis` 模块来创建三个 Redis 客户端：`pub`、`sub` 和 `client`。为了配置
    Socket.IO 使用 `RedisStore`，我们将 Socket.IO 的 `'store'` 设置为 `RedisStore`，并将 `redis`、`pub`、`sub`
    和 `client` 作为参数传递。
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Scaling Express horizontally
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平扩展 Express
- en: Our current application architecture has coupled together an API; a consuming
    web client and a worker which populates a Redis cache. This approach works for
    many applications and will allow it to scale horizontally with the help of a load
    balancer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的应用程序架构将 API、消费型网络客户端和填充 Redis 缓存的工人耦合在一起。这种方法适用于许多应用程序，并将在负载均衡器的帮助下允许其水平扩展。
- en: But let's say for example, we would like our API to support clients other than
    web, say for example, we introduced a mobile client that used our API; ideally
    we would like to scale our API in isolation and remove anything related to the
    web client.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但比如说，如果我们希望我们的API支持除了Web以外的客户端，比如说，我们引入了一个使用我们API的移动客户端；理想情况下，我们希望独立扩展我们的API并移除与Web客户端相关的所有内容。
- en: Scaling our worker horizontally would simply mean replicating the same work
    over and over again, which would be pointless. Later, we will discuss how to scale
    the worker.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展我们的工作器意味着简单地重复相同的工作，这将是毫无意义的。稍后，我们将讨论如何扩展工作器。
- en: 'In the rest of this chapter we will outline how to split apart our application
    in order to scale horizontally. We will use the source code from the `chapter-6`
    version of the vision application. We will, of course, document anything of interest
    which is required to achieve our goal. We will create four new projects: `vision-core`,
    `vision-web`, `vision-api`, and `vision-worker`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将概述如何拆分我们的应用程序以实现水平扩展。我们将使用`vision`应用程序的`chapter-6`版本的源代码。当然，我们将记录任何有助于实现我们目标的有兴趣的内容。我们将创建四个新的项目：`vision-core`、`vision-web`、`vision-api`和`vision-worker`。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Download the source code for this chapter here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处下载本章的源代码：
- en: '[https://github.com/AndrewKeig/vision-core](https://github.com/AndrewKeig/vision-core)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/AndrewKeig/vision-core](https://github.com/AndrewKeig/vision-core)'
- en: '[https://github.com/AndrewKeig/vision-web](https://github.com/AndrewKeig/vision-web)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/AndrewKeig/vision-web](https://github.com/AndrewKeig/vision-web)'
- en: '[https://github.com/AndrewKeig/vision-api](https://github.com/AndrewKeig/vision-api)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/AndrewKeig/vision-api](https://github.com/AndrewKeig/vision-api)'
- en: '[https://github.com/AndrewKeig/vision-worker](https://github.com/AndrewKeig/vision-worker)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/AndrewKeig/vision-worker](https://github.com/AndrewKeig/vision-worker)'
- en: vision-core
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: vision-core
- en: Our first task is to extract everything that can be shared between the `vision-web`,
    `vision-api`, and `vision-worker` projects into a new `vision-core` project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是提取`vision-web`、`vision-api`和`vision-worker`项目之间可以共享的所有内容，并将其放入一个新的`vision-core`项目中。
- en: 'This includes the following sections: `./cache`, `./lib/configuration`, `./lib/db`,
    `./lib/github`, `./lib/logger`, `./lib/models`, and `./lib/project`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括以下部分：`./cache`、`./lib/configuration`、`./lib/db`、`./lib/github`、`./lib/logger`、`./lib/models`和`./lib/project`。
- en: 'The `vision-core` project is not an application so we remove everything in
    the root of the project, including `./app.js` and our `./gruntfile.js`, and add
    a `./index.js` file, which simply exports all of the functionalities shown:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`vision-core`项目不是一个应用程序，所以我们从项目的根目录中移除了所有内容，包括`./app.js`和我们的`./gruntfile.js`，并添加了一个`./index.js`文件，该文件简单地导出了所有显示的功能：'
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to share the private `vision-core` project with visions other private
    projects, we add a GitHub dependency to config: `./config/packge.json`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与其他私有项目共享私有的`vision-core`项目，我们在配置中添加了一个GitHub依赖项：`./config/packge.json`：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: vision-api
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: vision-api
- en: 'Let''s create a `vision-api` project which contains the web API. Here we need
    to reuse everything related to the API that includes the following middleware:
    `./lib/middleware/id`, `./lib/middleware/notFound`, the routes for `./lib/routes/project`,
    `./lib/routes/github`, and `./lib/routes/heartbeat`. We also include the config
    files `./config` and all the tests `./test`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含Web API的`vision-api`项目。在这里，我们需要重用与API相关的所有内容，包括以下中间件：`./lib/middleware/id`、`./lib/middleware/notFound`、`./lib/routes/project`、`./lib/routes/github`和`./lib/routes/heartbeat`的路线。我们还包含了`./config`配置文件和所有测试`./test`。
- en: 'In order to secure `vision-api`, we will use basic authentication, which uses
    a username and password to authenticate a user. These credentials are transported
    in plain text, so you are advised to use HTTPS. We have already shown you how
    to setup HTTPS, hence, this part will not be repeated. In order to set up basic
    authentication, we can use the `passport-http`; let''s install it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`vision-api`的安全性，我们将使用基本身份验证，它使用用户名和密码来验证用户。这些凭据以纯文本形式传输，因此建议您使用HTTPS。我们已经向您展示了如何设置HTTPS，因此这部分将不会重复。为了设置基本身份验证，我们可以使用`passport-http`；让我们安装它：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We start by adding a username and password to `./config/*.json`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将用户名和密码添加到`./config/*.json`中：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are now ready to implement an `ApiAuth` strategy into `./lib/auth/index.js`.
    We start by defining a function, `ApiAuth`, then we import the `passport` and
    `passport-http` modules. We instantiate a `BasicStrategy` function and add it
    to `passport`, passing a verify function. Inside this verify function, we have
    the option of rejecting the user by passing false out of the callback. We call
    `findUser` and check if `username` and `password` are the same as those stored
    in `./config/*.json`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备在 `./lib/auth/index.js` 中实现一个 `ApiAuth` 策略。我们首先定义一个函数 `ApiAuth`，然后导入
    `passport` 和 `passport-http` 模块。我们实例化一个 `BasicStrategy` 函数并将其添加到 `passport` 中，传递一个验证函数。在这个验证函数内部，我们有通过在回调中传递
    `false` 来拒绝用户的选择。我们调用 `findUser` 并检查 `username` 和 `password` 是否与存储在 `./config/*.json`
    中的相同。
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `vision-api` project will need a new Express server `./express/index.js`.
    We start by requiring `config` via `vision-core`. We require the `apiAuth` module
    which handles authentication, then we apply the passport basic middleware to all
    of the routes using `app.all`. We set `session:false` as basic authentication
    is stateless.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`vision-api` 项目需要一个新的 Express 服务器 `./express/index.js`。我们首先通过 `vision-core`
    引入 `config`，然后引入处理身份验证的 `apiAuth` 模块。接着，我们使用 `app.all` 将 passport 基本中间件应用到所有路由上。我们将
    `session:false` 设置为 `false`，因为基本身份验证是无状态的。'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we are moving to multiple Express servers to support our application, we
    will move `vision-api` onto port `3001`. Let''s configure this into `./config/*.json`,
    as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在转向多个 Express 服务器以支持我们的应用程序，我们将 `vision-api` 移至端口 `3001`。让我们在 `./config/*.json`
    中配置它，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: vision-worker
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: vision-worker
- en: Let's continue and create a new project called `vision-worker`, which consists
    of two scripts `./populate.js` script and `./lib/cache/populate.js`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并创建一个新的项目 `vision-worker`，它包括两个脚本 `./populate.js` 和 `./lib/cache/populate.js`。
- en: Of course we could scale this worker with something such as **RabbitMQ.** This
    would allow us to spawn multiple producers and consumers, and from this respect,
    the solution we have is not optimum. If you are interested in improving this part
    of the application, please refer to Packt's *Instant RabbitMQ Message Application
    Development*. This book explains how you can implement a worker pattern with RabbitMQ.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用 **RabbitMQ** 这样的东西来扩展这个工作进程。这将允许我们产生多个生产者和消费者，从这个角度来看，我们目前的解决方案并不是最优的。如果您有兴趣改进这个应用程序的这部分，请参阅
    Packt 的 *Instant RabbitMQ Message Application Development*。这本书解释了如何使用 RabbitMQ
    实现工作模式。
- en: vision-web
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: vision-web
- en: Finally, we create a new project called `vision-web` which will include everything
    related to the web client ; simply include everything from `chapter 6` and remove
    everything we moved to `core` and reference core from `./package.json`. Our current
    set of `routes` require some significant changes; now that we have decoupled our
    service layer into its own repository called `vision-api`. vision-web will no
    longer make service calls directly into the project and github services; these
    services now exist in the vision-api project, instead we will call the API services
    exposed on vision-api.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个新的项目 `vision-web`，它将包括与网络客户端相关的所有内容；简单地将 `第 6 章` 中的所有内容包含进来，并从 `core`
    中移除所有内容，从 `./package.json` 中引用 `core`。我们当前的 `routes` 需要一些重大的更改；现在，我们已经将服务层解耦到其自己的存储库中，称为
    `vision-api`。`vision-web` 将不再直接调用项目中的服务调用和 github 服务；这些服务现在存在于 `vision-api` 项目中，我们将调用在
    `vision-api` 上公开的 API 服务。
- en: Let's add the configuration to `./config/*.json` for our `vision-api` project.
    The `vision-api` project has been configured to run on port `3001` and uses basic
    authentication for security, so we include the `username` and `password` in the
    `url`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将配置添加到 `./config/*.json` 中，以供我们的 `vision-api` 项目使用。`vision-api` 项目已配置为在端口
    `3001` 上运行，并使用基本身份验证来保证安全，因此我们在 `url` 中包含了 `username` 和 `password`。
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to call services on our `vision-api` project , we will simplify things
    by using `Request` module. Request is a simple client that allows us to make HTTP
    requests; lets install it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的 `vision-api` 项目上调用服务，我们将通过使用 `Request` 模块来简化操作。Request 是一个简单的客户端，允许我们发起
    HTTP 请求；让我们安装它：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With our configuration in place, we move onto our project route `./lib/routes/project.js`.
    Here we simply replace all calls to our Project service with the corresponding
    calls in vision-api. We start by pulling in the configuration we defined in the
    code snippet above. Each route constructs a URL using this configuration, we use
    the Request module to call into the API. We return a response which consists of
    the `response.statusCode` and the body of the response:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置就绪后，我们转向我们的项目路由 `./lib/routes/project.js`。在这里，我们只是用 vision-api 中的相应调用替换了对我们项目服务的所有调用。我们首先引入上面代码片段中定义的配置。每个路由使用此配置构造一个
    URL，我们使用 Request 模块调用 API。我们返回一个响应，该响应由 `response.statusCode` 和响应体组成：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s repeat the same process for our GitHub route `./lib/routes/github.js`;
    removing calls to the GitHub service with calls to the corresponding endpoints
    on our `vision-api` project:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 GitHub 路由 `./lib/routes/github.js` 重复相同的流程；移除对 GitHub 服务的调用，并替换为对我们 `vision-api`
    项目相应端点的调用：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lets update our tests `./test/project.js`, `./test/github.js`. We now remove
    anything Mongoose related with direct calls using `Request` module to vision-api
    in order to seed test data to MongoDB:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的测试 `./test/project.js`、`./test/github.js`。我们现在移除与 Mongoose 相关的所有内容，使用
    `Request` 模块直接调用 vision-api 以将测试数据种入 MongoDB：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Vertical scale with Cluster
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集群进行垂直扩展
- en: 'Our `vision-web` and `vision-api` Express applications currently run in a single
    thread. In order to scale our application vertically, in order to take advantage
    of multi-core systems, and provide redundancy in case of failure, we can use the
    cluster module and spread the load over multiple processes. Lets add the Cluster
    module to vision-core `./lib/cluster/index.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的 `vision-web` 和 `vision-api` Express 应用程序在单个线程中运行。为了垂直扩展我们的应用程序，为了利用多核系统，并在出现故障时提供冗余，我们可以使用集群模块并将负载分散到多个进程上。让我们将
    Cluster 模块添加到 vision-core `./lib/cluster/index.js`：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s export the cluster module out of `vision-core`; by adding the following
    to `./index.js`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将集群模块从 `vision-core` 中导出；通过在 `./index.js` 中添加以下内容：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s change our Express application in `vision-web` and `vision-api ./app.js`,
    and add a third option for running our application, that is, running with cluster
    support:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改 `vision-web` 和 `vision-api ./app.js` 中的 Express 应用程序，并添加一个运行我们应用程序的第三个选项，即使用集群支持运行：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Balancing load with Hipache
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hipache 进行负载均衡
- en: '**Hipache** is a distributed proxy designed to route high volumes of HTTP and
    WebSocket traffic. Hipache supports dynamic configuration via Redis, so changing
    the configuration and adding vhosts does not require a restart. Based on the node-http-proxy
    library, Hipache provides support for load balancing websockets, SSL, dead backend
    detection, and is clustered for failover. Let''s install it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hipache** 是一个设计用于路由大量 HTTP 和 WebSocket 流量的分布式代理。Hipache 支持通过 Redis 进行动态配置，因此更改配置和添加虚拟主机不需要重启。基于
    node-http-proxy 库，Hipache 提供了对负载均衡 WebSocket、SSL、检测后端死亡以及集群以实现故障转移的支持。让我们安装它：'
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s setup a host for both `vision-web` and `vision-api` by editing the `hosts`
    file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编辑 `hosts` 文件为 `vision-web` 和 `vision-api` 设置一个主机：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add two new entries:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个新条目：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And then flush the cache for these changes to take effect:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后刷新缓存以使这些更改生效：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to configure a server, we will need a configuration file for each
    application we want to load balance. In our case, it is `vision-web` and `vision-api`.
    Here is the configuration file for `vision-api`, `./config/server.json`. Importantly,
    we are running `vision-api` on port `8443`. We configure an SSL certificate under
    the HTTPS section as Hipache will terminate SSL not our Express server:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置服务器，我们需要为每个我们想要进行负载均衡的应用程序创建一个配置文件。在我们的例子中，是 `vision-web` 和 `vision-api`。以下是
    `vision-api` 的配置文件，`./config/server.json`。重要的是，我们正在端口 `8443` 上运行 `vision-api`。我们在
    HTTPS 部分配置了一个 SSL 证书，因为 Hipache 会终止 SSL，而不是我们的 Express 服务器：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's make a change to the Express server `./lib/express/server.js`, and return
    a standard HTTP server when running in production; Hipache will now terminate
    SSL.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 Express 服务器 `./lib/express/server.js` 进行更改，并在生产环境中返回一个标准的 HTTP 服务器；Hipache
    现在将终止 SSL。
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We now add Hipache configuration for the `vision-api ./config/server.json`.
    Please note that we are running `vision-api` on port `3001`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为 `vision-api ./config/server.json` 添加 Hipache 配置。请注意，我们正在端口 `3001` 上运行
    `vision-api`。
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will need to revisit GitHub and change the urls under `settings/applications/developer
    applications/vision` to `https://web.vision.net:8443`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新访问 GitHub，并将 `settings/applications/developer applications/vision` 下的
    URL 更改为 `https://web.vision.net:8443`。
- en: Let's update the `vision-web` configuration `./config/*.json`, and change the
    GitHub authentication urls to `web.vision.net`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `vision-web` 的配置 `./config/*.json`，并将 GitHub 认证 URL 更改为 `web.vision.net`。
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s also update the API `url` configuration in the same set of config files:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更新同一组配置文件中的 API `url` 配置：
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our final change will allow us to support multiple ports for each application;
    we will change the port setting in the Express server `./lib/express/index.js`,
    so that it checks `process.env.PORT` for a port number:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的更改将使我们能够支持每个应用程序的多个端口；我们将更改 Express 服务器中的端口设置 `./lib/express/index.js`，以便它检查
    `process.env.PORT` 以获取端口号：
- en: '[PRE31]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now start the process of running our application under a load balancer.
    In order to start the Hipache load balancer for `vision-api`, run the following
    commands:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始运行应用程序在负载均衡器下的过程。为了启动 `vision-api` 的 Hipache 负载均衡器，运行以下命令：
- en: '[PRE32]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to start the Hipache load balancer for `vision-web`, we run the following
    commands:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动 `vision-web` 的 Hipache 负载均衡器，我们运行以下命令：
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So, we now have a running Hipache instance for `vision-api` and another for
    `vision-web`. Let''s create a vhost in Redis and associate the Hipache instance
    with a series of servers. Now run the redis command line interface:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在为 `vision-api` 和 `vision-web` 运行了一个正在运行的 Hipache 实例。让我们在 Redis 中创建一个虚拟主机，并将
    Hipache 实例与一系列服务器关联。现在运行 redis 命令行界面：
- en: '[PRE34]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First off, let''s get the `vision-web` application up and running and assign
    a backend running on port `3003` to `web.vision`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们让 `vision-web` 应用程序运行起来，并将运行在端口 `3003` 的后端分配给 `web.vision`：
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s review the configuration for `web.vision`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾 `web.vision` 的配置：
- en: '[PRE36]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s get the `vision-api` application up and running and assign a backend
    running on port `3005` to `api.vision`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让 `vision-api` 应用程序运行起来，并将运行在端口 `3005` 的后端分配给 `api.vision`：
- en: '[PRE37]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s review the configuration for `api.vision`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾 `api.vision` 的配置：
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s run the application under a load balancer, set the `PORT` environment
    variable and set NODE_ENV to `production` when running `npm start`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在负载均衡器下运行应用程序，设置 `PORT` 环境变量，并在运行 `npm start` 时将 NODE_ENV 设置为 `production`：
- en: '[PRE39]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We now have a vision application running under a load balancer, go visit `https://web.vision.net:844`
    `3`. In order to add more backends to our load balancer, let''s start `vision-api`
    and `vision-web` under another port:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个在负载均衡器下运行的视觉应用，请访问 `https://web.vision.net:844` `3`。为了向我们的负载均衡器添加更多后端，让我们在另一个端口下启动
    `vision-api` 和 `vision-web`：
- en: '[PRE40]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When we run the following commands, the backends running on ports `3004` and
    `3006` will be added to the load balancer:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行以下命令时，运行在端口 `3004` 和 `3006` 的后端将被添加到负载均衡器中：
- en: '[PRE41]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Scaling a Web application is nontrivial. Node; using the cluster module allows
    us to scale it vertically. Scaling horizontally requires us to reach out to the
    wider community. In our application we have chosen Hipache; a node based load
    balancer. In the next chapter we will discuss production-level improvements that
    we can make to our application when we look at performance and reliability issues.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Web 应用程序并非易事。Node；使用集群模块允许我们垂直扩展。水平扩展需要我们向更广泛的社区寻求帮助。在我们的应用程序中，我们选择了 Hipache；一个基于
    Node 的负载均衡器。在下一章中，我们将讨论在考虑性能和可靠性问题时，我们可以对应用程序进行的生产级改进。
