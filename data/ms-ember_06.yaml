- en: Chapter 6. Views and Event Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。视图和事件管理
- en: 'We discussed templates and controllers in the previous two chapters. We noted
    that controllers present models that templates render to users. We also learned
    that when users interact with applications, templates usually propagate these
    events back to controllers using action template helpers. In reality, these action
    expressions are views that delegate the events initially to controllers, and later
    to routes. Therefore, in this chapter, we will learn how to integrate views right
    into templates, especially when the following application needs arise:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前两章讨论了模板和控制器。我们注意到控制器呈现模型，这些模型由模板渲染给用户。我们还了解到，当用户与应用程序交互时，模板通常会使用动作模板助手将这些事件传播回控制器。实际上，这些动作表达式是视图，最初将事件委托给控制器，然后委托给路由。因此，在本章中，我们将学习如何将视图直接集成到模板中，特别是当出现以下应用程序需求时：
- en: A section of the application requires sophisticated event management
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的一个部分需要复杂的事件管理
- en: There's a need to build reusable components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要构建可重用的组件
- en: The application needs to integrate third-party libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序需要集成第三方库
- en: 'Therefore, by the end of this chapter, you should be able to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到本章结束时，你应该能够：
- en: Define a view
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义视图
- en: Create a view instance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建视图实例
- en: Customize a view
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义视图
- en: Manage events in views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中管理事件
- en: Use built-in views
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置视图
- en: Use third-party libraries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方库
- en: As mentioned in the first chapter, we will rarely need to define views unless
    we really need a tight control over the DOM structure. In the next chapter, we
    will discuss how to use ember components that are a higher level construct of
    views.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如第一章所述，我们很少需要定义视图，除非我们确实需要严格控制 DOM 结构。在下一章中，我们将讨论如何使用 ember 组件，它是视图的高级结构。
- en: Defining views
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义视图
- en: 'Views in an application manage templates through data binding and delegation
    of user-initiated events. Just like controllers, a view class is defined from
    the base `Ember.View` class as:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的视图通过数据绑定和委托用户发起的事件来管理模板。就像控制器一样，视图类是从基类 `Ember.View` 定义的：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An instance of the preceding view can then be created by calling the view''s
    `create` method:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用视图的 `create` 方法可以创建先前视图的实例：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can still create additional views from the already defined class, as illustrated
    in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以从已经定义的类中创建额外的视图，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By now, we already know that Ember.js classes can accept any number of mixins
    as shown in the preceding example. However, instances created with mixins always
    use the `createWithMixins` method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们已经知道 Ember.js 类可以接受任何数量的混合，如前例所示。然而，使用混合创建的实例始终使用 `createWithMixins`
    方法：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Accessing a view's controller
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问视图的控制器
- en: 'Views are usually backed by an instance of the corresponding controller. Once
    a view is inserted into the DOM, the corresponding controller can be accessed
    by the `controller` property, as shown in the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 视图通常由相应控制器的实例支持。一旦视图被插入到 DOM 中，相应的控制器可以通过 `controller` 属性访问，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Specifying a view's template
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定视图的模板
- en: 'Every view renders a template into the DOM. Views can be assigned the template
    to use in a number of ways. For example, let''s consider the following router:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都将模板渲染到 DOM 中。视图可以通过多种方式分配要使用的模板。例如，让我们考虑以下路由：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Ember.js will expect a defined `App.NewRoute` class for the new route as:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 预期新路由将有一个定义的 `App.NewRoute` 类：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Any visit to this route will use the following Ember.js objects, if defined:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了此路由，任何访问此路由的操作都将使用以下 Ember.js 对象：
- en: The `App.NewController` object
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.NewController` 对象'
- en: The `Ember.TEMPLATES.new` template
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ember.TEMPLATES.new` 模板'
- en: The `App.NewView` object
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.NewView` 对象'
- en: 'The default behavior is where the name of the template dictates the view to
    use. If we wish to use a different template, say `Ember.TEMPLATES.form`, we will
    need to implement it in the `renderTemplates` hook of the route as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为是模板的名称决定了要使用的视图。如果我们希望使用不同的模板，例如 `Ember.TEMPLATES.form`，我们将在路由的 `renderTemplates`
    钩子中实现它，如下所示：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As expected, this route will use the `App.FormView` view class. The template
    used is usually included into the application as a script tag. For example, we
    can define the new template that will be used by an `App.NewView` as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，此路由将使用 `App.FormView` 视图类。使用的模板通常作为脚本标签包含在应用程序中。例如，我们可以定义将用于 `App.NewView`
    的新模板，如下所示：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that the previous template can still be accessed as `Ember.TEMPLATES.new`.
    Therefore, an alternative way to specify a view''s template is to pragmatically
    update its value with the desired compiled template, as shown in the following
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前的模板仍然可以通过 `Ember.TEMPLATES.new` 访问。因此，指定视图模板的另一种方法是通过实用地更新其值来使用所需的编译模板，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In a production environment, it''s advised to compile these templates server
    side, and then bundle them up for performance reasons. We can still specify the
    template using the `templateName` property on the view class, for example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，建议在服务器端编译这些模板，然后为了性能原因将它们捆绑起来。我们仍然可以通过视图类上的 `templateName` 属性指定模板，例如：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Specifying a view's element tag
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定视图的元素标签
- en: 'A view''s template is usually wrapped in a `div` element by default, as shown
    in the following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的模板通常默认包裹在一个 `div` 元素中，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This yields the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下结果：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This element type can be altered using the `tagName` property of the `view`
    class, as shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `view` 类的 `tagName` 属性来更改元素类型，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding snippet will yield something like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段将产生类似以下的结果：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Updating a view's element class attribute
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新视图的元素类属性
- en: 'In the previous section, we learned that views are usually wrapped in a configurable
    DOM element. The element''s class attribute can also be specified statically using
    the view''s `classNames` array property. For example, a Twitter Bootstrap button
    can be created as:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到视图通常被包裹在一个可配置的 DOM 元素中。元素的类属性也可以使用视图的 `classNames` 数组属性静态指定。例如，可以创建一个
    Twitter Bootstrap 按钮，如下所示：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will yield something like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下的结果：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The element''s classes can also be altered dynamically using the view''s `classNameBindings`
    array property, as shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的类也可以使用视图的 `classNameBindings` 数组属性动态更改，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This example yields the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例会产生以下结果：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These class names are dasherized as per the Ember.js naming conventions. Hence,
    the `btnWarning` property is mapped to the `btn-warning` class name.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类名按照 Ember.js 命名约定进行了连字符化。因此，`btnWarning` 属性映射到 `btn-warning` 类名。
- en: 'Sometimes, you might want to specify the class name to be used based on a given
    state. This is something we learned in [Chapter 4](part0044_split_000.html#page
    "Chapter 4. Writing Application Templates"), *Writing Application Templates*,
    for example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望根据给定的状态指定要使用的类名。例如，我们在[第4章](part0044_split_000.html#page "第4章. 编写应用模板")中学习了这一点，*编写应用模板*：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, the `btn-warning` class will be added to the class
    attribute of the element, based on the view's `warn` property.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`btn-warning` 类将被添加到元素的类属性中，这是基于视图的 `warn` 属性。
- en: 'Lastly, we can add different classes depending on a certain state. For example,
    imagine we want to display different states of our Bootstrap button. This is possible
    with the following signature:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以根据某种状态添加不同的类。例如，假设我们想要显示 Bootstrap 按钮的不同状态。这可以通过以下签名实现：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding example, when the view controller''s `warn` property becomes
    `true`, the following will be yielded:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当视图控制器的 `warn` 属性变为 `true` 时，将产生以下结果：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Otherwise, the other class will be used instead:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，将使用其他类：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By now, you will have noticed that the binding behavior is similar to the one
    we learned in [Chapter 4](part0044_split_000.html#page "Chapter 4. Writing Application
    Templates"), *Writing Application Templates*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能会注意到绑定行为与我们之前在[第4章](part0044_split_000.html#page "第4章. 编写应用模板")中学习的类似。
- en: Updating other views' element attributes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新其他视图的元素属性
- en: 'In addition to class attributes, all other attributes of a view''s element
    can be altered dynamically. For example, let''s create a thumbnail view, as shown
    in the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类属性之外，视图元素的其余属性也可以动态更改。例如，让我们创建一个缩略图视图，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This yields the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下结果：
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The attributes'' presence can be altered using bound Boolean properties. For
    example, we can disable a `save` button of a form if the corresponding input has
    not been filled, as shown in the following example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用绑定的布尔属性来改变属性的存在性。例如，我们可以禁用表单中相应输入未填写时的 `save` 按钮，如下面的示例所示：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When the model''s `title` property is undefined, the view''s disabled property
    will come true. Hence, the view''s element will acquire the disabled attribute
    and vice versa. This example lets users submit the form only when it''s valid.
    Note that the defined view can be reimplemented as:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型的 `title` 属性未定义时，视图的禁用属性将为真。因此，视图的元素将获得禁用属性，反之亦然。这个例子允许用户仅在表单有效时提交表单。请注意，定义的视图可以重新实现为：
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This example shows that any property, in this case, `modelIsValid`, can be
    used to provide the attribute to show or hide when the state changes, as long
    as it''s specified using the following signature:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，任何属性，在这个例子中是 `modelIsValid`，都可以用来提供在状态改变时显示或隐藏的属性，只要它使用以下签名指定：
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inserting views into DOM
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将视图插入到 DOM 中
- en: 'We just learned that views have templates that they render into DOM. Applications
    that need to do this manually will need to utilize the view instance `appendTo`
    method, as shown in the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解到，视图有模板，它们将渲染到 DOM 中。需要手动执行此操作的应用程序需要利用视图实例的 `appendTo` 方法，如下面的示例所示：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This method takes a jQuery query selector that we are already used to, as shown
    in the following examples:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个 jQuery 查询选择器，这是我们已经在以下示例中熟悉的，如下所示：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that only one matched element is used. Therefore, in the third example,
    the view will be inserted into the last `header` element found.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只使用了一个匹配的元素。因此，在第三个例子中，视图将被插入到最后找到的 `header` 元素中。
- en: 'As a convenience, views have an `append` method that can be used to insert
    the views directly into the body section of DOM:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，视图有一个 `append` 方法，可以直接将其插入到 DOM 的主体部分：
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You might also want to remove a view from DOM using the `remove` method as:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望使用 `remove` 方法从 DOM 中移除视图，如下所示：
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that a view is automatically removed from DOM if destroyed, as shown in
    the following line of code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果视图被销毁，它将自动从 DOM 中移除，如下面的代码行所示：
- en: '[PRE33]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Inserting views into templates
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将视图插入到模板中
- en: 'Views are hierarchical, and hence, they can be inserted into the templates
    of other views constituting the template hierarchy we discussed in [Chapter 4](part0044_split_000.html#page
    "Chapter 4. Writing Application Templates"), *Writing Application Templates*.
    For example, consider the following application template:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是分层的，因此它们可以插入到构成模板层次结构的其他视图的模板中，这是我们讨论过的[第4章](part0044_split_000.html#page
    "第4章。编写应用程序模板")，*编写应用程序模板*。例如，考虑以下应用程序模板：
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As shown, defined views are inserted into a desired template using the `view`
    expression. These `view` expressions can also be wrapped into block clauses, as
    shown in the following code. Additional views can then be inserted into these
    block expressions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，定义的视图使用 `view` 表达式插入到所需的模板中。这些 `view` 表达式也可以被包裹在块子句中，如下面的代码所示。然后可以在此块表达式中插入额外的视图：
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Specifying view layouts
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定视图布局
- en: 'We already learned that a view''s template is wrapped in an element, which
    is usually specified by the `tagName` property. In addition, this template can
    be wrapped by another template, as illustrated in the following figure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，视图的模板被包裹在一个元素中，这通常由 `tagName` 属性指定。此外，此模板还可以被另一个模板包裹，如下面的图所示：
- en: '![Specifying view layouts](img/00010.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![指定视图布局](img/00010.jpeg)'
- en: 'A template is marked as a layout by adding a `yield` expression, as shown in
    the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `yield` 表达式，可以将模板标记为布局，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Just like the `outlet` expression, the `yield` expression serves as the portion
    that the template being wrapped will be inserted into. We then specify this layout
    in the view as:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `outlet` 表达式一样，`yield` 表达式充当被包裹的模板将被插入的部分。然后我们在视图中指定此布局：
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Suppose our `book` template is:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的 `book` 模板如下：
- en: '[PRE38]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will yield the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE39]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is important to note that views with self-closing HTML elements cannot have
    layouts. These views include `<input>` and `<img>`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，具有自闭合 HTML 元素的视图不能有布局。这些视图包括 `<input>` 和 `<img>`。
- en: Registering event handlers in views
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图中注册事件处理器
- en: 'Views can register event handlers on events emitted from elements in their
    rendered templates, in addition to the use of the `action` template expressions.
    For example, let''s reuse an example from [Chapter 4](part0044_split_000.html#page
    "Chapter 4. Writing Application Templates"), *Writing Application Templates*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以在它们渲染的模板中的元素上注册事件处理器，除了使用 `action` 模板表达式。例如，让我们重用[第4章](part0044_split_000.html#page
    "第4章。编写应用程序模板")的一个例子，*编写应用程序模板*：
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This example can easily be reimplemented as a view, as shown in the following
    code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以轻松地重新实现为一个视图，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, we created a custom button view that registers a click event
    handler.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了一个自定义按钮视图，注册了一个点击事件处理程序。
- en: Every view manages only the events invoked from their templates. However, child
    views usually bubble events to parent views up to the root element up until the
    events get handled.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图仅管理从其模板调用的事件。然而，子视图通常将事件冒泡到父视图，直到根元素，直到事件被处理。
- en: 'Ember.js supports the following events:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 支持以下事件：
- en: '| Touch events | Keyboard events | Mouse events | Form events | HTML5 drag-and-drop
    events |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 触摸事件 | 键盘事件 | 鼠标事件 | 表单事件 | HTML5 拖放事件 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `touchStart` | `keyDown` | `mouseDown` | `submit` | `dragStart` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `touchStart` | `keyDown` | `mouseDown` | `submit` | `dragStart` |'
- en: '| `touchMove` | `keyUp` | `mouseUp` | `change` | `drag` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `touchMove` | `keyUp` | `mouseUp` | `change` | `drag` |'
- en: '| `touchEnd` | `keyPress` | `contextMenu` | `focusIn` | `dragEnter` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `touchEnd` | `keyPress` | `contextMenu` | `focusIn` | `dragEnter` |'
- en: '| `touchCancel` |   | `click` | `focusOut` | `dragLeave` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `touchCancel` |   | `click` | `focusOut` | `dragLeave` |'
- en: '|   |   | `doubleClick` | `input` | `drop` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `doubleClick` | `input` | `drop` |'
- en: '|   |   | `mouseMove` |   | `dragEnd` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `mouseMove` |   | `dragEnd` |'
- en: '|   |   | `focusIn` |   |   |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `focusIn` |   |   |'
- en: '|   |   | `focusOut` |   |   |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `focusOut` |   |   |'
- en: '|   |   | `mouseEnter` |   |   |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `mouseEnter` |   |   |'
- en: '|   |   | `mouseLeave` |   |   |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `mouseLeave` |   |   |'
- en: Now is a good opportunity to try and write views that use some of these events.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是尝试编写使用这些事件之一的视图的好机会。
- en: Emitting actions from views
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从视图中发出动作
- en: 'We already learned that views have a reference to the context controller via
    the `controller` property. A view can use the controller''s `send` method to delegate
    user-initiated events to the corresponding routes, as shown in the following example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，视图通过 `controller` 属性引用上下文控制器。视图可以使用控制器的 `send` 方法将用户发起的事件委派给相应的路由，如下面的示例所示：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using built-in views (components)
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置视图（组件）
- en: In [Chapter 4](part0044_split_000.html#page "Chapter 4. Writing Application
    Templates"), *Writing Application Templates*, we promised to discuss the built-in
    views that Ember.js provides. Most of these are high-level views (components)
    from controls that guarantee painless design of forms.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](part0044_split_000.html#page "第 4 章。编写应用程序模板")，*编写应用程序模板*中，我们承诺要讨论
    Ember.js 提供的内置视图。其中大部分是高级视图（组件），从控件中保证了表单设计的无痛苦。
- en: Textfields
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本字段
- en: 'The textfield view is used to create a bound text input in a form. It''s usually
    created from the `Ember.TextField` class. We can subscribe to the input''s value
    changes by implementing the view''s `change` event handler, as shown in the following
    code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字段视图用于在表单中创建一个绑定文本输入。它通常由 `Ember.TextField` 类创建。我们可以通过实现视图的 `change` 事件处理程序来订阅输入值的变化，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Just like any other view, we can insert this view into a template as:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他视图一样，我们可以将此视图插入到模板中，如下所示：
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we created a text input that updated the context controller's
    name property whenever its value changes. This is one of the many use cases of
    such views.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了一个文本输入框，每当其值发生变化时，都会更新上下文控制器的名称属性。这是此类视图的许多用例之一。
- en: Textareas
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本区域
- en: 'A textarea is very similar to a textfield, both accept some additional attributes
    such as `rows` and `cols`, for example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 文本区域与文本字段非常相似，两者都接受一些额外的属性，例如 `rows` 和 `cols`，例如：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Select menus
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择菜单
- en: 'Another common form control is the select menu. Ember.js provides an `Ember.Select`
    class that can be used to create this control. For example, let''s create a select
    menu that prompts a user to choose their favorite fruit in this control:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的表单控件是选择菜单。Ember.js 提供了一个 `Ember.Select` 类，可以用来创建此控件。例如，让我们创建一个选择菜单，提示用户在此控件中选择他们最喜欢的水果：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding example, the user is presented with two fruits to select from.
    They are first prompted with a **Select a fruit** prompt that was passed during
    definition. The view''s `content` property is usually an array of the choices
    that should be displayed, and the `selection` property holds the selected choice.
    Often, these choices are usually objects rather than strings, as seen in the preceding
    example. Therefore, additional customization needs to be done using two properties:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，用户被提供了两种水果进行选择。他们首先会看到一个**选择一个水果**的提示，该提示是在定义时传递的。视图的`content`属性通常是应显示的选择项的数组，而`selection`属性则持有选中的选项。通常，这些选择项通常是对象而不是字符串，如前面的示例所示。因此，需要使用两个属性进行额外的自定义：
- en: 'The `optionLabelPath` property: This specifies the choice''s label'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optionLabelPath`属性：此属性指定选项的标签'
- en: 'The `optionValuePath` property: This specifies the value to be looked up for
    the selected choice'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optionValuePath`属性：此属性指定要查找的选中选项的值'
- en: Therefore, the preceding example specified the fruit's name as the property
    to display and the ID as the property to determine the selection.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的示例指定了水果的名称作为要显示的属性，以及ID作为确定选择的属性。
- en: Checkboxes
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复选框
- en: 'Checkboxes can also be implemented in the same way using the `Ember.Cechkbox`
    view class. These controls enable the user to select various choices from a given
    set, for example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框也可以使用`Ember.Checkbox`视图类以相同的方式进行实现。这些控件使用户能够从给定集合中选择各种选项，例如：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will yield something like the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下所示的结果：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The bound value of an instance of this view is usually a Boolean.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图实例的绑定值通常是一个布尔值。
- en: The container view
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器视图
- en: 'We already learned that a view can be inserted into other views using the `view`
    template helper, as shown in the following lines of code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，可以使用`view`模板助手将视图插入到其他视图中，如下面的代码行所示：
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In some cases, we might want the parent view, in this case, `App.ContentView`,
    to be able to manually manage child views. `Ember.ContainerView` is an enumerable
    view that an application can pragmatically add or remove child views from, as
    shown in the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望父视图，在这种情况下是`App.ContentView`，能够手动管理子视图。`Ember.ContainerView`是一个可枚举的视图，应用程序可以实用地添加或从其中移除子视图，如下面的示例所示：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'These child views are usually contained in the `childViews` property. You can,
    therefore, implement the preceding example as:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子视图通常包含在`childViews`属性中。因此，你可以将前面的示例实现如下：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This yields something like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生如下所示的结果：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It is important to note that since container views house other views, they cannot
    have templates or layouts. Therefore, specified templates or layouts will be ignored.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，由于容器视图包含其他视图，它们不能有模板或布局。因此，指定的模板或布局将被忽略。
- en: Other HTML form controls can be abstracted to achieve simpler views. Therefore,
    as an exercise, create an `Ember.Radios` view class that displays a set of HTML
    radio buttons. Note that the implementation will be very similar to that of `Ember.Select`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 其他HTML表单控件可以抽象出来以实现更简单的视图。因此，作为一个练习，创建一个`Ember.Radios`视图类，该类显示一组HTML单选按钮。请注意，实现将与`Ember.Select`非常相似。
- en: Integrating with third-party DOM manipulation libraries
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与第三方DOM操作库集成
- en: 'Many jQuery libraries primarily manipulate DOM in order to achieve a desired
    effect. We all know that you need to initialize these libraries only when DOM
    is ready:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 许多jQuery库主要操纵DOM以实现所需的效果。我们都知道，只有在DOM准备好时才需要初始化这些库：
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'jQuery is an Ember.js dependency, and it''s thus very easy to integrate such
    libraries into applications. Imagine we had a menu view that we wanted to apply
    to this plugin. Views have the `willInsertElement` and `didInsertElement` hooks
    that we can use to implement such needs, as shown in the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是Ember.js的依赖项，因此将此类库集成到应用程序中非常容易。想象一下，我们有一个想要应用到这个插件上的菜单视图。视图有`willInsertElement`和`didInsertElement`钩子，我们可以使用这些钩子来实现这样的需求，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `didInsertElement` hooks guarantee that the view has been inserted into
    DOM, and therefore, we might apply any plugin to it. Note that calling `this.$()`
    returns a jQuery element selector relative to the view. Also, note that we take
    care to call the `_super` method, as there can be parent implementations we cannot
    afford to lose. We also *schedule* this code to be run after the element is rendered
    into DOM.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`didInsertElement` 钩子确保视图已插入到 DOM 中，因此，我们可以将其应用于任何插件。请注意，调用 `this.$()` 返回相对于视图的
    jQuery 元素选择器。另外，请注意我们确保调用 `_super` 方法，因为可能存在我们无法失去的父实现。我们还将此代码**安排**在元素渲染到 DOM
    之后运行。'
- en: 'At a later point in time, we might decide to remove the view from DOM. It will,
    therefore, be necessary that we remove any event that the plugin set up before
    removing the view. Ember.js provides the `willDestroy` hook that can be used to
    accomplish this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后的某个时间点，我们可能会决定从 DOM 中移除视图。因此，在移除视图之前，我们需要移除插件设置的所有事件。Ember.js 提供了 `willDestroy`
    钩子，可用于完成此操作：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how views are defined and created as well as how
    they can be customized. We also learned how events in these views can be managed.
    Lastly, we explored the different components Ember.js provides and how third-party
    libraries such as jQuery plugins can be integrated into an application through
    views.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了视图的定义和创建方式，以及如何自定义它们。我们还学习了如何管理这些视图中的事件。最后，我们探讨了 Ember.js 提供的不同组件以及如何通过视图将第三方库（如
    jQuery 插件）集成到应用程序中。
- en: 'The end of this chapter marked the completion of the core concepts of Ember.js.
    In the next chapters, we''ll start building complete sample applications as we
    explore more features. You should, therefore, be well versed in the following
    Ember.js concepts and objects:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结尾标志着 Ember.js 核心概念的完成。在接下来的章节中，我们将开始构建完整的示例应用程序，同时探索更多功能。因此，你应该熟悉以下 Ember.js
    概念和对象：
- en: Objects
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Routes
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Templates
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: Controllers
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: Views
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
