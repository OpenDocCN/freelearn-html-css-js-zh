- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: You have seen quite a lot of JavaScript already, and now you are ready for functions.
    Soon you will see that you have been using functions already, but now it is time
    to learn how to start writing your own. Functions are a great building block that
    will reduce the amount of code you will need in your app. You can call a function
    whenever you need it, and you can write it as a kind of template with variables.
    So, depending on how you've written it, you can reuse it in many situations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了很多JavaScript，现在你准备好学习函数了。很快你就会发现你已经在使用函数了，但现在是你学习如何开始编写自己的函数的时候了。函数是一个很好的构建块，它将减少你应用中所需的代码量。你需要函数时就可以调用它，你可以将其编写为一种带有变量的模板。所以，根据你如何编写它，你可以在许多情况下重用它。
- en: They do require you to think differently about the structure of your code and
    this can be hard, especially in the beginning. Once you have got the hang of this
    way of thinking, functions will really help you to write nicely structured, reusable,
    and low-maintenance code. Let's dive into this new abstraction layer!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实要求你以不同的方式思考代码的结构，这可能会很困难，尤其是在开始的时候。一旦你习惯了这种思维方式，函数将真正帮助你编写结构良好、可重用和易于维护的代码。让我们深入这个新的抽象层！
- en: 'Along the way, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将涵盖以下主题：
- en: Basic functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本函数
- en: Function arguments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数
- en: Return
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回
- en: Variable scope in functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数中的变量作用域
- en: Recursive functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归函数
- en: Nested functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套函数
- en: Anonymous functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Function callbacks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数回调
- en: 'Note: exercise, project and self-check quiz answers can be found in the *Appendix*.'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：练习、项目和自我检查测验的答案可以在*附录*中找到。
- en: Basic functions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本函数
- en: We have been calling functions for a while already. Remember `prompt()`, `console.log()`,
    `push()`, and `sort()` for arrays? These are all functions. Functions are a group
    of statements, variable declarations, loops, and so on that are bundled together.
    Calling a function means an entire group of statements will get executed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经调用函数有一段时间了。还记得`prompt()`、`console.log()`、`push()`和`sort()`数组函数吗？这些都是函数。函数是一组语句、变量声明、循环等捆绑在一起的内容。调用函数意味着整个语句组将被执行。
- en: First, we are going to have a look at how we can invoke functions, and then
    we will see how to write functions of our own.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看如何调用函数，然后我们将看看如何编写我们自己的函数。
- en: Invoking functions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'We can recognize functions by the parentheses at the end. We can invoke functions
    like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过末尾的括号来识别函数。我们可以这样调用函数：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is invoking a function called `nameOfTheFunction` with no arguments, and
    a function called `functionThatTakesInput` with three required arguments. Let's
    have a look at what functions can look like when we start writing them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在没有参数的情况下调用一个名为`nameOfTheFunction`的函数，以及一个名为`functionThatTakesInput`的函数，它需要三个必需的参数。让我们看看当我们开始编写函数时，函数可以看起来像什么。
- en: Writing functions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写函数
- en: 'Writing a function can be done using the `function` keyword. Here is the template
    syntax to do so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`function`关键字可以编写函数。以下是编写函数的模板语法：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The above function can be called like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的函数可以这样调用：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s write a function that asks for your name and then greets you:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数，询问你的名字，然后问候你：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We add a space after the question mark to ensure the user starts typing their
    answer one space away from the question mark, rather than directly afterward.
    We call this function like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在问号后添加一个空格，以确保用户在问号后一个空格开始输入答案，而不是直接在其后。我们这样调用这个函数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It will prompt:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它将提示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s go ahead and enter our name. The output will be:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续输入我们的名字。输出将是：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Take a moment to consider the relationship between functions and variables.
    As you have seen, functions can contain variables, which shape how they operate.
    The opposite is also true: variables can contain functions. Still with me? Here
    you can see an example of a variable containing a function (`varContainingFunction`)
    and a variable inside a function (`varInFunction`):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间考虑函数和变量之间的关系。正如你所看到的，函数可以包含变量，这些变量决定了它们的操作方式。相反的情况也是正确的：变量可以包含函数。你还在吗？这里你可以看到一个包含函数的变量（`varContainingFunction`）和一个函数内部的变量（`varInFunction`）的例子：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Variables contain a certain value and *are* something; they do not *do* anything.
    Functions are actions. They are a bundle of statements that can be executed when
    they get called. JavaScript will not run the statements when the functions do
    not get invoked. We will return to the idea of storing functions in variables,
    and consider some of the benefits, in the *Anonymous functions* section, but for
    now let's move on to look at the best way to name your functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 变量包含一定的值并且*是*某物；它们不*做*任何事情。函数是动作。它们是一组可以在被调用时执行的语句。JavaScript不会在函数未被调用时运行这些语句。我们将在*匿名函数*部分回到将函数存储在变量中的想法，并考虑一些好处，但现在让我们继续看看命名函数的最佳方式。
- en: Naming functions
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数命名
- en: 'Giving your function a name might seem like a trivial task, but there are some
    best practices to keep in mind here. To keep it short:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的函数命名可能看起来是一个微不足道的事情，但这里有一些最佳实践需要记住。为了保持简洁：
- en: 'Use camelCase for your functions: this means that the first word starts with
    a lowercase letter and new words start with a capital. That makes it a lot easier
    to read and keeps your code consistent.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用驼峰式命名法为你的函数命名：这意味着第一个单词以小写字母开头，新单词以大写字母开头。这使得阅读更容易，并保持你的代码一致性。
- en: 'Make sure that the name describes what the function is doing: it''s better
    to call a number addition function `addNumbers` than `myFunc`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保名称描述了函数正在做什么：将数字加法函数命名为`addNumbers`比`myFunc`更好。
- en: 'Use a verb to describe what the function is doing: make it an action. So instead
    of `hiThere`, call it `sayHi`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个动词来描述函数正在做什么：使其成为一个动作。所以，而不是`hiThere`，可以将其命名为`sayHi`。
- en: Practice exercise 6.1
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习第6.1节习题
- en: See if you can write a function for yourself. We want to write a function that
    adds two numbers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能否为自己编写一个函数。我们希望编写一个可以添加两个数字的函数。
- en: Create a function that takes two parameters, adds the parameters together, and
    returns the result.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数接受两个参数，将参数相加，并返回结果。
- en: Set up two different variables with two different values.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置两个不同的变量，并赋予它们不同的值。
- en: Use your function on the two variables, and output the result using `console.log`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的函数对两个变量进行操作，并使用`console.log`输出结果。
- en: Create a second call to the function using two more numbers as arguments sent
    to the function.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个更多的数字作为参数调用该函数的第二个调用。
- en: Practice exercise 6.2
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习第6.2节习题
- en: We are going to create a program that will randomly describe an inputted name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个程序，该程序将随机描述输入的名字。
- en: Create an array of descriptive words.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述性单词的数组。
- en: Create a function that contains a prompt asking the user for a name.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含提示用户输入名字的函数。
- en: Select a random value from the array using `Math.random`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Math.random`从数组中选择一个随机值。
- en: Output into the console the prompt value and the randomly selected array value.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出提示值和随机选择的数组值。
- en: Invoke the function.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用该函数。
- en: Parameters and arguments
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数和参数
- en: 'You may have noticed that we are talking about parameters and arguments. Both
    terms are commonly used to mean the information that is passed into a function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在谈论参数和参数。这两个术语通常用来表示传递给函数的信息：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A parameter is defined as the variable listed inside the parentheses of the
    function definition, which defines the scope of the function. They are declared
    like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 参数定义为函数定义中括号内的变量，它定义了函数的作用域。它们是这样声明的：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A practical example could be the following, which takes `x` and `y` as parameters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际例子可以是以下内容，它将`x`和`y`作为参数：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When called, this function will simply add the parameters and log the result.
    However, to do this, we can call the function with arguments:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，这个函数将简单地添加参数并记录结果。然而，为了做到这一点，我们可以用参数调用函数：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have seen various examples of arguments; for example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了各种参数的例子；例如：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Depending on the arguments you are calling with the function, the outcome of
    the function can change, which makes the function a very powerful and flexible
    building block. A practical example using our `addTwoNumbers()` function looks
    like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你调用函数时使用的参数，函数的结果可以改变，这使得函数成为一个非常强大和灵活的构建块。使用我们的`addTwoNumbers()`函数的一个实际例子如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the function has a different outcome for both calls. This is
    because we call it with different arguments, which take the place of `x` and `y`,
    that are sent to the function to be used within the function scope.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数对两次调用都有不同的结果。这是因为我们用不同的参数调用它，这些参数取代了发送到函数中并在函数作用域内使用的`x`和`y`。
- en: Practice exercise 6.3
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习第6.3题
- en: Create a basic calculator that takes two numbers and one string value indicating
    an operation. If the operation equals add, the two numbers should be added. If
    the operation equals subtract, the two numbers should be subtracted from one another.
    If there is no option specified, the value of the option should be `add`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个基本的计算器，它接受两个数字和一个表示操作的字符串值。如果操作等于加法，则应将两个数字相加。如果操作等于减法，则应从其中一个数字中减去另一个数字。如果没有指定选项，则选项的值应为`add`。
- en: The result of this function needs to be logged. Test your function by invoking
    it with different operators and no operator specified.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的结果需要被记录。通过使用不同的运算符和未指定运算符来调用该函数来测试你的函数。
- en: Set up two variables containing number values.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置两个包含数字值的变量。
- en: Set up a variable to hold an operator, either + or -.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个变量来保存一个运算符，可以是加号（+）或减号（-）。
- en: Create a function that retrieves the two values and the operator string value
    within its parameters. Use those values with a condition to check if the operator
    is + or -, and add or subtract the values accordingly (remember if not presented
    with a valid operator, the function should default to addition).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，它在其参数中检索两个值和运算符字符串值。使用这些值通过条件检查运算符是加号（+）还是减号（-），并相应地添加或减去值（记住如果没有提供有效的运算符，函数应默认为加法）。
- en: Within `console.log()`, call the function using your variables and output the response
    to the console.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`console.log()`中，使用你的变量调用该函数，并将响应输出到控制台。
- en: Update the operator value to be the other operator type—either plus or minus—and
    call to the function again with the new updated arguments.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将运算符值更新为另一种运算符类型——加号或减号——然后再次使用新更新的参数调用该函数。
- en: Default or unsuitable parameters
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认或不合适的参数
- en: 'What happens if we call our `addTwoNumbers()` function without any arguments?
    Take a moment and decide what you think this should do:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不传递任何参数就调用我们的`addTwoNumbers()`函数，会发生什么？花点时间决定你认为它应该做什么：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Some languages might crash and cry, but not JavaScript. JavaScript just gives
    the variables a default type, which is undefined. And `undefined` + `undefined`
    equals:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言可能会崩溃并哭泣，但JavaScript不会。JavaScript只是给变量赋予一个默认类型，即未定义。而`undefined` + `undefined`等于：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instead, we could tell JavaScript to take different default parameters. And
    that can be done like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以告诉JavaScript使用不同的默认参数。这可以这样做：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you call the function with no arguments now, it will automatically assign
    `2` to `x` and `3` to `y`, unless you override them by calling the function with
    arguments. The values that are used for invoking are prioritized over hardcoded
    arguments. So, given the above function, what will the output of these function
    calls be?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在调用该函数而不传递任何参数，它将自动将`2`赋值给`x`，将`3`赋值给`y`，除非你通过传递参数来覆盖它们。用于调用的值优先于硬编码的参数。因此，给定上述函数，以下函数调用的输出将是什么？
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output will be:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first one has the default values, so `x` is `2` and `y` is `3`. The second
    one assigns `6` to both `x` and `y`. The last one is a bit less obvious. We are
    only giving one argument, so which one will be given this value? Well, JavaScript
    does not like to overcomplicate things. It simply assigns the value to the first
    parameter, `x`. Therefore, `x` becomes `10` and `y` gets its default value `3`,
    and together that makes `13`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个具有默认值，因此`x`是`2`，`y`是`3`。第二个将`6`赋值给`x`和`y`。最后一个有点不明显。我们只提供了一个参数，所以哪个参数会被赋予这个值？嗯，JavaScript不喜欢过于复杂化。它只是将值赋给第一个参数，`x`。因此，`x`变为`10`，`y`得到其默认值`3`，两者相加为`13`。
- en: 'If you call a function with more arguments than parameters, nothing will happen.
    JavaScript will just execute the function using the first arguments that can be
    mapped to parameters. Like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用一个函数的参数多于参数，则不会发生任何事情。JavaScript将仅使用可以映射到参数的第一个参数来执行函数。就像这样：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is just adding 1 and 2 and ignoring the last two arguments (`3` and `4`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将1和2相加，并忽略最后两个参数（`3`和`4`）。
- en: Special functions and operators
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊函数和运算符
- en: There are a few special ways of writing functions, as well as some special operators
    that will come in handy. We are talking about arrow functions and the spread and
    rest operators here. Arrow functions are great for sending functions around as
    parameters and using shorter notations. The spread and rest operators make our
    lives easier and are more flexible when sending arguments and working with arrays.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的编写方式有一些特殊的方法，以及一些有用的特殊运算符。我们在这里讨论的是箭头函数和扩展运算符以及剩余运算符。箭头函数非常适合作为参数传递函数和使用更短的表示法。扩展运算符和剩余运算符使我们的工作更加容易，并且在传递参数和处理数组时更加灵活。
- en: Arrow functions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Arrow functions are a special way of writing functions that can be confusing
    at first. Their use looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是一种特殊的函数编写方式，一开始可能会让人感到困惑。它们的用法如下：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or for no parameters:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于没有参数的情况：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or for one parameter (no parentheses are needed here):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于单个参数（这里不需要括号）：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or for a multiline function with two parameters:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于具有两个参数的多行函数：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Arrow functions are useful whenever you want to write an implementation on
    the spot, such as inside another function as an argument. This is because they
    are a shorthand notation for writing functions. They are most often used for functions
    that consist of only one statement. Let''s start with a simple function that we
    will rewrite to an arrow function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数在你想要即时编写实现的地方非常有用，比如在另一个函数作为参数时。这是因为它们是编写函数的简写表示法。它们最常用于只包含一个语句的函数。让我们从一个简单的函数开始，我们将将其重写为箭头函数：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To rewrite this as an arrow function, you will have to store it in a variable
    or send it in as an argument if you want to be able to use it. We use the name
    of the variable to execute the arrow function. In this case we only have one parameter,
    so it''s optional to surround it with parentheses. We can write it like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这段代码重写为箭头函数，你必须将其存储在变量中，或者作为参数传入，以便能够使用它。我们使用变量的名称来执行箭头函数。在这种情况下，我们只有一个参数，所以没有必要将其括在括号中。我们可以这样写：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And invoke it like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这样调用它：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will log `Great!` to the console. If there is more than one argument,
    we will have to use parentheses, like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台记录`Great!`。如果有多个参数，我们必须使用括号，如下所示：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can call it like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样称呼它：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And then it will log `8` to the console. If there are no arguments, you must
    use the parentheses, like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它会在控制台记录`8`。如果没有参数，你必须使用括号，如下所示：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we call `sayHi()`, it will log `hi` to the console.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`sayHi()`，它将在控制台记录`hi`。
- en: 'As a final example, we can combine the arrow function with certain built-in
    methods. For example, we can use the `foreach()` method on an array. This method
    executes a certain function for every element in the array. Have a look at this
    example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，我们可以将箭头函数与某些内置方法结合起来。例如，我们可以在数组上使用`forEach()`方法。这个方法对数组中的每个元素执行一个特定的函数。看看这个例子：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It outputs:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它会输出：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For every element in the array, it takes the element as input and executing
    the arrow function for it. In this case, the function is to log the element. So
    the output is every single element in the array.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组中的每个元素，它都会将其作为输入，并对其执行箭头函数。在这种情况下，函数是记录元素。因此，输出是数组中的每个单独元素。
- en: Using arrow functions combined with built-in functions is very powerful. We
    can do something for every element in the array, without counting or writing a
    complicated loop. We'll see more examples of great use cases for arrow functions
    later on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将箭头函数与内置函数结合使用非常强大。我们可以对数组中的每个元素执行某些操作，而无需计数或编写复杂的循环。我们将在稍后看到箭头函数的更多有用示例。
- en: Spread operator
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展运算符
- en: The spread operator is a special operator. It consists of three dots used before
    a referenced expression or string, and it spreads out the arguments or elements
    of an array.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符是一个特殊运算符。它由在引用表达式或字符串之前使用的三个点组成，它将参数或数组的元素展开。
- en: 'This might sound very complicated, so let''s look at a simple example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来非常复杂，所以让我们看看一个简单的例子：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The value of this array becomes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组的值变为：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, the elements of the spread operator become individual elements
    in the array. The spread operator spreads the array to individual elements in
    the new array. It can also be used to send multiple arguments to a function, like
    this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，扩展运算符的元素成为数组中的单独元素。扩展运算符将数组扩展为新数组中的单独元素。它也可以用来向函数传递多个参数，如下所示：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will log `14` to the console, since it is the same as calling the function
    with:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出`14`，因为它等同于调用函数的方式：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This operator avoids having to copy a long array or string into a function,
    which saves time and reduces code complexity. You can call a function with multiple
    spread operators. It will use all the elements of the arrays as input. Here''s
    an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符避免了需要将长数组或字符串复制到函数中，这节省了时间并减少了代码复杂性。你可以用多个展开运算符调用一个函数。它将使用数组的所有元素作为输入。这里有一个例子：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will output `27` to the console, calling the function like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出`27`，调用函数的方式如下：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Rest parameter
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剩余参数
- en: 'Similar to the spread operator, we have the rest parameter. It has the same
    symbol as the spread operator, but it is used inside the function parameter list.
    Remember what would happen if we were to send an argument too many times, as here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与展开运算符类似，我们还有剩余参数。它具有与展开运算符相同的符号，但它用于函数参数列表中。记住如果我们像这里一样发送过多的参数会发生什么：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That''s right. Nothing really: it would just pretend we only sent in two arguments
    and log `hi there!`. If we use the rest parameter, it allows us to send in any
    number of arguments and translate them into a parameter array. Here is an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 没错。实际上什么也没有：它只是假装我们只传入了两个参数并记录了`hi there!`。如果我们使用剩余参数，它允许我们传入任何数量的参数并将它们转换为参数数组。这里有一个例子：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will log:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, the second parameter has changed into an array, containing our
    second and third arguments. This can be useful whenever you are not sure what
    number of arguments you will get. Using the rest parameter allows you to process
    this variable number of arguments, for example, using a loop.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第二个参数已变为一个数组，包含我们的第二个和第三个参数。这在你不确定将获得多少参数时非常有用。使用剩余参数允许你处理这个可变数量的参数，例如，使用循环。
- en: Returning function values
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回函数值
- en: 'We are still missing a very important piece to make functions as useful as
    they are: the return value. Functions can give back a result when we specify a
    return value. The return value can be stored in a variable. We have done this
    already – remember `prompt()`?'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还缺少一个非常重要的部分，使函数像它们一样有用：返回值。当我们指定返回值时，函数可以返回一个结果。返回值可以存储在变量中。我们已经这样做过了——还记得`prompt()`吗？
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We are storing the result of our `prompt()` function in the variable `favoriteSubject`,
    which in this case would be whatever the user specifies. Let''s see what happens
    if we store the result of our `addTwoNumbers()` function and log that variable:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`prompt()`函数的结果存储在变量`favoriteSubject`中，在这个例子中，它将是用户指定的任何内容。让我们看看如果我们存储`addTwoNumbers()`函数的结果并将其记录下来会发生什么：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You may or may not have guessed it—this logs the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了——这将记录以下内容：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The value `9` is written to the console because `addTwoNumbers()` contains
    a `console.log()` statement. The `console.log(result)` line outputs `undefined`,
    because nothing is inserted into the function to store the result, meaning our
    function `addTwoNumbers()` does not send anything back. Since JavaScript does
    not like to cause trouble and crash, it will assign `undefined`. To counter this,
    we can rewrite our `addTwoNumbers()` function to actually return the value instead
    of logging it. This is much more powerful because we can store the result and
    continue working with the result of this function in the rest of our code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 值`9`被写入控制台，因为`addTwoNumbers()`包含一个`console.log()`语句。`console.log(result)`行输出`undefined`，因为没有将任何内容插入函数以存储结果，这意味着我们的函数`addTwoNumbers()`没有返回任何内容。由于JavaScript不喜欢引起麻烦和崩溃，它会分配`undefined`。为了解决这个问题，我们可以重新编写我们的`addTwoNumbers()`函数，使其真正返回值而不是记录它。这要强大得多，因为我们可以在代码的其余部分存储这个函数的结果并继续使用它：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`return` ends the function and sends back whatever value comes after `return`.
    If it is an expression, like the one above, it will evaluate the expression to
    one result and then return that to where it was called (the `result` variable,
    in this instance):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`结束函数并返回`return`之后的所有值。如果它是一个表达式，就像上面的一样，它将计算表达式的结果并将其返回到调用它的地方（在这个例子中是`result`变量）：'
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: What do you think this code does?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这段代码做什么？
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It logs an array of all the results to the screen. The function is being called
    in a loop. The first iteration, `i`, equals `0`. Therefore, the result is `0`.
    The last iteration, `i`, equals `9`, and therefore the last value of the array
    equals `27`. Here are the results:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它将所有结果记录到屏幕上。该函数正在循环中被调用。第一次迭代，`i`等于`0`。因此，结果是`0`。最后一次迭代，`i`等于`9`，因此数组的最后一个值等于`27`。以下是结果：
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Practice exercise 6.4
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习题6.4
- en: Modify the calculator that you made in *Practice exercise 6.2* to return added
    values instead of printing them. Then, call the function 10 or more times in a
    loop, and store the results in an array. Once the loop finishes, output the final
    array into the console.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将你在*练习题6.2*中制作的计算器修改为返回加法值而不是打印它们。然后在循环中调用该函数10次或更多次，并将结果存储在数组中。一旦循环结束，将最终数组输出到控制台。
- en: Set up an empty array to store the values that will be calculated within the
    loop.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个空数组来存储循环中要计算的所有值。
- en: Create a loop that runs 10 times, incrementing by 1 each time, creating two
    values each iteration. For the first value, multiply the value of the loop count
    by 5\. For the second value, multiply the value of the loop counter by itself.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环，运行10次，每次递增1，每次迭代创建两个值。对于第一个值，将循环计数值乘以5。对于第二个值，将循环计数器的值自乘。
- en: Create a function that returns the value of the two parameters passed into the
    function when it is called. Add the values together, returning the result.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，当调用该函数时返回传入的两个参数的值。将值相加，返回结果。
- en: Within the loop, call the calculation function, passing in the two values as
    arguments into the function and storing the returned result in a response variable.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中调用计算函数，将两个值作为参数传递给函数，并将返回的结果存储在响应变量中。
- en: Still within the loop, push the result values into the array as it iterates
    through the loop.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在循环中，随着循环的迭代，将结果值推入数组。
- en: After the loop is complete, output the value of the array into the console.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环完成后，将数组的值输出到控制台。
- en: You should see the values `[0, 6, 14, 24, 36, 50, 66, 84, 104, 126]` for the
    array in the console.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在控制台看到数组`[0, 6, 14, 24, 36, 50, 66, 84, 104, 126]`的值。
- en: Returning with arrow functions
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用箭头函数返回
- en: 'If we have a one-line arrow function, we can return without using the keyword
    `return`. So if we want to rewrite the function, we can write it like this to
    make an arrow function out of it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个单行箭头函数，我们可以不使用关键字`return`来返回。所以如果我们想重写这个函数，我们可以这样写，将其转换为箭头函数：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And we can call it and store the result like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样调用并存储结果：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will then log `27` to the console. If it''s a multiline function, you
    will have to use the keyword `return` as demonstrated in the previous section.
    So, for example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出`27`。如果是一个多行函数，你将不得不使用关键字`return`，就像在上一节中演示的那样。例如：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Variable scope in functions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数中的变量作用域
- en: In this section, we will discuss a topic that is often considered challenging.
    We will talk about scope. Scope defines where you can access a certain variable.
    When a variable is *in scope*, you can access it. When a variable is *out of scope*,
    you cannot access the variable. We will discuss this for both local and global
    variables.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一个经常被认为具有挑战性的主题。我们将讨论作用域。作用域定义了你可以访问某个变量的地方。当变量在作用域内时，你可以访问它。当变量不在作用域内时，你不能访问该变量。我们将对局部变量和全局变量进行讨论。
- en: Local variables in functions
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数中的局部变量
- en: 'Local variables are only in scope within the function they are defined. This
    is true for `let` variables and `var` variables. There is a difference between
    them, which we will touch upon here as well. The function parameters (they do
    not use `let` or `var`) are also local variables. This might sound very vague,
    but the next code snippet will demonstrate what this means:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量仅在其定义的函数中有效。这对于`let`变量和`var`变量都适用。它们之间有一个区别，我们也会在这里简要提及。函数参数（它们不使用`let`或`var`）也是局部变量。这听起来可能很模糊，但下一个代码片段将演示这是什么意思：
- en: '[PRE54]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When called inside the function, `x` will be logged. The statement outside of
    the function fails, because `x` is a local variable to the function `testAvailability()`.
    This is showing that the function parameters are not accessible outside of the
    function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数内部调用时，`x`将被记录。函数外的语句失败，因为`x`是`testAvailability()`函数的局部变量。这表明函数参数在函数外部是不可访问的。
- en: 'They are out of scope outside the function and in scope inside the function.
    Let''s have a look at a variable defined inside a function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在函数外部不可用，在函数内部可用。让我们看看函数内部定义的变量：
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This shows the following on the console:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台显示了以下内容：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Variables defined inside the function are not available outside the function
    either.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部定义的变量在函数外部也是不可用的。
- en: 'For beginners, it can be confusing to combine local variables and `return`.
    Right now, we''re telling you the local variables declared inside a function are
    not available outside of the function, but with `return` you can make their values
    available outside the function. So if you need their values outside a function,
    you can return the values. The key word here is *values*! You cannot return the
    variable itself. Instead, a value can be caught and stored in a different variable,
    like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，将局部变量和 `return` 结合起来可能会令人困惑。现在，我们告诉你函数内部声明的局部变量在函数外部不可用，但通过 `return`，你可以使它们的值在函数外部可用。所以如果你需要在函数外部使用它们的值，你可以返回这些值。这里的关键词是
    *值*！你不能返回变量本身。相反，一个值可以被捕获并存储在不同的变量中，如下所示：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: So, the returned value `I'll return` that was assigned to local variable `y`
    gets returned and stored in variable `z`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，分配给局部变量 `y` 的返回值 `I'll return` 被返回并存储在变量 `z` 中。
- en: This variable `z` could actually also have been called `y`, but that would have
    been confusing since it still would have been a different variable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量 `z` 实际上也可以被称为 `y`，但那样会让人困惑，因为它仍然是一个不同的变量。
- en: 'The output of this code snippet is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: let versus var variables
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`let` 与 `var` 变量'
- en: The difference between `let` and `var` is that `var` is function-scoped, which
    is the concept we described above. `let` is actually not function-scoped but block-scoped.
    A block is defined by two curly braces `{ }`. The code within those braces is
    where `let` is still available.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 和 `var` 的区别在于 `var` 是函数作用域，这是我们上面描述的概念。实际上 `let` 不是函数作用域，而是块作用域。一个块由两个大括号
    `{}` 定义。那些大括号内的代码是 `let` 仍然可用的地方。'
- en: 'Let''s see this distinction in action:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个区别在实际中的应用：
- en: '[PRE60]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output of this snippet will be:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出将是：
- en: '[PRE61]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If we use `var`, the variable becomes function-scoped and is available anywhere
    in the function block (even before defining with the value undefined). Thus, after
    the `if` block has ended, `x` can still be accessed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `var`，变量将成为函数作用域，并在函数块中的任何地方（甚至在定义之前值为 `undefined` 的情况下）可用。因此，在 `if`
    块结束后，`x` 仍然可以被访问。
- en: 'Here is what happens with `let`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `let` 发生的情况：
- en: '[PRE62]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This will produce the following output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here we get the error that `x is not defined`. Since `let` is only block-scoped,
    `x` goes out of scope when the `if` block ends and can no longer be accessed after
    that.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们得到一个错误，提示 `x` 未定义。由于 `let` 只能是块作用域，当 `if` 块结束时 `x` 就会超出作用域，并且之后不能再访问。
- en: 'A final difference between `let` and `var` relates to the order of declaration
    in a script. Try using the value of `x` before having defined it with `let`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 和 `var` 之间的最后一个区别与脚本中声明的顺序有关。尝试在定义 `let` 之前使用 `x` 的值：'
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This will give a `ReferenceError` that `x` is not initialized. This is because
    variables declared with `let` cannot be accessed before being defined, even within
    the same block. What do you think will happen for a `var` declaration like this?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出一个 `ReferenceError`，提示 `x` 未初始化。这是因为使用 `let` 声明的变量在定义之前不能被访问，即使在同一个块内部。你认为这样的
    `var` 声明会发生什么？
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This time, we won't get an error. When we use a `var` variable before the `define`
    statement, we simply get `undefined`. This is due to a phenomenon called hoisting,
    which means using a `var` variable before it's been declared results in the variable
    being `undefined` rather than giving a `ReferenceError`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不会得到错误。当我们使用 `var` 变量在 `define` 语句之前时，我们只是得到 `undefined`。这是由于一个称为提升的现象，这意味着在使用
    `var` 变量之前声明它会导致变量变为 `undefined` 而不是抛出 `ReferenceError`。
- en: Hoisting, and how to negate its effects if needed, are more complex topics that
    we will cover in *Chapter 12*, *Intermediate JavaScript*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 提升和如何在不必要的情况下消除其影响是更复杂的话题，我们将在 *第12章*，*中级JavaScript* 中介绍。
- en: const scope
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`const` 作用域'
- en: 'Constants are block-scoped, just like `let`. This is why the scope rules here
    are similar to those for `let`. Here is an example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是块作用域的，就像 `let` 一样。这就是为什么这里的范围规则与 `let` 的规则相似。以下是一个示例：
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will produce the following output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE67]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Using a `const` variable before having defined it will also give a `ReferenceError`,
    just as it does for a `let` variable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义它之前使用一个`const`变量也会引发一个`ReferenceError`，就像对`let`变量所做的那样。
- en: Global variables
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'As you might have guessed, global variables are variables declared outside
    a function and not in some other code block. Variables are accessible in the scope
    (either function or block) where they''re defined, plus any "lower" scopes. So,
    a variable defined outside of a function is available within the function as well
    as inside any functions or other code blocks inside that function. A variable
    defined at the top level of your program is therefore available everywhere in
    your program. This concept is called a global variable. You can see an example
    here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，全局变量是在函数外部声明的，不在其他代码块中。变量在其定义的作用域（函数或代码块）内是可访问的，以及任何“较低”的作用域。因此，在函数外部定义的变量在函数内部以及该函数内部任何其他函数或其他代码块中都是可用的。因此，在程序顶层定义的变量在程序中的任何地方都是可用的。这个概念被称为全局变量。你可以在下面看到示例：
- en: '[PRE68]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This will output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE69]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you can see, global variables are accessible from everywhere because they
    are not declared in a block. They are *always* in scope after they have been defined—it
    doesn't matter where you use them. However, you can hide their accessibility inside
    a function by specifying a new variable with the same name inside that scope;
    this can be done for `let`, `var`, and `const`. (This is not changing the value
    of the `const` variable; you are creating a new `const` variable that is going
    to override the first one in the inner scope.) In the same scope, you cannot specify
    two `let` or two `const` variables with the same name. You can do so for `var`,
    but you shouldn't do so, in order to avoid confusion.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，全局变量因为不在代码块中声明，所以可以从任何地方访问。它们在定义后总是处于作用域内——无论你在哪里使用它们。然而，你可以在该作用域内通过指定一个具有相同名称的新变量来隐藏它们的可访问性；这可以用于`let`、`var`和`const`。（这不会改变`const`变量的值；你正在创建一个新的`const`变量，它将在内部作用域中覆盖第一个。）在同一个作用域中，你不能指定两个具有相同名称的`let`或两个`const`变量。你可以为`var`这样做，但你不应该这样做，以避免混淆。
- en: 'If you create a variable with the same name inside a function, that variable''s
    value will be used whenever you refer to that variable name within the scope of
    that particular function. Here you can see an example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个函数内部创建了一个具有相同名称的变量，那么在特定函数的作用域内引用该变量名称时，将使用该变量的值。这里有一个示例：
- en: '[PRE70]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This will output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE71]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As you can see, the value of `x` inside the `doingStuff()` function is `local`.
    However, outside the function the value is still `global`. This means that you'll
    have to be extra careful about mixing up names in local and global scopes. It
    is usually better to avoid this.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`doingStuff()`函数内部的`x`的值是`局部`的。然而，在函数外部，值仍然是`全局`的。这意味着你必须非常小心，不要在局部和全局作用域中混淆名称。通常最好避免这样做。
- en: 'The same is also true for parameter names. If you have the same parameter name
    as a global variable, the value of the parameter will be used:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称也是如此。如果你有一个与全局变量相同的参数名称，将使用参数的值：
- en: '[PRE72]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will log `param`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录`param`。
- en: There is a danger in relying on global variables too much. This is something
    you will come across soon when your applications grow. As we just saw, local variables
    override the value of global variables. It is best to work with local variables
    in functions; this way, you have more control over what you are working with.
    This might be a bit vague for now, but it will become clear when coding in the
    wild as things get bigger and more lines and files of code get involved.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 过度依赖全局变量存在风险。当你的应用程序增长时，你很快就会遇到这个问题。正如我们刚才看到的，局部变量会覆盖全局变量的值。最好在函数中使用局部变量；这样，你就能更好地控制你所处理的内容。现在这可能会有些模糊，但当你在实际编码中遇到更大、更多行和文件代码时，它将变得清晰。
- en: 'There is only one more very important point to be made about scopes for now.
    Let''s start with an example and see if you can figure out what this should log:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 目前关于作用域还有一个非常重要的点需要说明。让我们从一个例子开始，看看你是否能弄清楚应该记录什么：
- en: '[PRE73]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Answer ready? Here is the output:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？以下是输出结果：
- en: '[PRE74]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Do not close the book—we'll explain what is going on. If you look carefully,
    the `x` in the function gets defined without the keyword `let` or `var`. There
    is no declaration of `x` above the code; this is all the code of the program.
    JavaScript does not see `let` or `var` and then decides, "this must be a global
    variable." Even though it gets defined inside the function, the declaration of
    `x` within the function gets global scope and can still be accessed outside of
    the function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 不要关闭这本书——我们将解释正在发生的事情。如果你仔细观察，函数中的 `x` 在没有 `let` 或 `var` 关键字的情况下被定义。在代码上方没有
    `x` 的声明；这是整个程序的代码。JavaScript 不看到 `let` 或 `var`，然后决定，“这必须是一个全局变量。”即使它是在函数内部定义的，函数内部
    `x` 的声明具有全局作用域，并且仍然可以在函数外部访问。
- en: We really want to emphasize that this is a terrible practice. If you need a
    global variable, declare it at the top of your file.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的想强调，这是一个糟糕的做法。如果你需要一个全局变量，请在文件顶部声明它。
- en: Immediately invoked function expression
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立即调用的函数表达式
- en: The **immediately invoked function expression** (**IIFE**) is a way of expressing
    a function so that it gets invoked immediately. It is anonymous, it doesn't have
    a name, and it is self-executing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**立即调用的函数表达式**（**IIFE**）是一种表达函数的方式，使其立即被调用。它是匿名的，没有名字，并且是自我执行的。'
- en: This can be useful when you want to initialize something using this function.
    It is also used in many design patterns, for example, to create private and public
    variables and functions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用此函数初始化某些内容时，这很有用。它也被用于许多设计模式中，例如，创建私有和公共变量和函数。
- en: This has to do with where functions and variables are accessible from. If you
    have an IIFE in the top-level scope, whatever is in there is not accessible from
    outside even though it is top level.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这与函数和变量可访问的位置有关。如果你在顶层作用域中有一个 IIFE，即使它位于顶层，其中的内容也无法从外部访问。
- en: 'Here is how to define it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何定义它的：
- en: '[PRE75]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The function itself is surrounded by parentheses, which makes it create a function
    instance. Without these parentheses around it, it would throw an error because
    our function does not have a name (this is worked around by assigning the function
    to a variable, though, where the output can be returned to the variable).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身被括号包围，这使得它创建一个函数实例。如果没有这些括号，它会抛出一个错误，因为我们的函数没有名字（尽管可以通过将函数赋给一个变量来解决这个问题，这样输出就可以返回到变量中）。
- en: '`();` executes the unnamed function—this must be done immediately following
    a function declaration. If your function were to require a parameter, you would
    pass it in within these final brackets.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`();` 执行一个未命名的函数——这必须在函数声明之后立即完成。如果你的函数需要参数，你可以在这些最后的括号内传递它。'
- en: 'You could also combine IIFE with other function patterns. For example, you
    could use an arrow function here to make the function even more concise:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 IIFE 与其他函数模式结合使用。例如，你可以在这里使用箭头函数来使函数更加简洁：
- en: '[PRE76]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Again, we use `();` to invoke the function that you created.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用 `();` 来调用你创建的函数。
- en: Practice exercise 6.5
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 6.5
- en: Use IIFE to create a few immediately invoked functions and observe how the scope
    is affected.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IIFE 创建几个立即调用的函数，并观察作用域是如何受到影响的。
- en: Create a variable value with `let` and assign a string value of 1000 to it.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `let` 创建一个变量值，并将其赋值为字符串 1000。
- en: Create an IIFE function and within this function scope assign a new value to
    a variable of the same name. Within the function, print the local value to the
    console.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 IIFE 函数，并在该函数作用域内将新值赋给同名变量。在函数内部，将局部值打印到控制台。
- en: 'Create an IIFE expression, assigning it to a new `result` variable, and assign
    a new value to a variable of the same name within this scope. Return this local
    value to the `result` variable and invoke the function. Print the `result` variable,
    along with the variable name you''ve been using: what value does it contain now?'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 IIFE 表达式，将其赋给新的 `result` 变量，并在该作用域内将新值赋给同名变量。将此局部值返回到 `result` 变量，并调用该函数。打印
    `result` 变量，以及你一直在使用的变量名：现在它包含什么值？
- en: Lastly, create an anonymous function that has a parameter. Add logic that will
    assign a passed-in value to the same variable name as the other steps, and print
    it as part of a string sentence. Invoke the function and pass in your desired
    value within the rounded brackets.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个带有参数的匿名函数。添加逻辑，将传递的值赋给与其他步骤相同的变量名，并将其作为字符串句子的一部分打印出来。调用该函数，并在圆括号内传递你希望的价值。
- en: Recursive functions
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: In some cases, you want to call the same function from inside the function.
    It can be a beautiful solution to rather complex problems. There are some things
    to keep in mind though. What do you think this will do?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要在函数内部调用同一个函数。这可能是解决相对复杂问题的美丽解决方案。但是也有一些需要注意的事情。你认为这会做什么？
- en: '[PRE77]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It prints `3` and then counts down and never stops. Why is it not stopping?
    Well, we are not saying when it should stop. Look at our improved version:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印`3`然后开始倒计时并且永远不会停止。为什么它不会停止呢？好吧，我们并没有说它应该在什么时候停止。看看我们改进的版本：
- en: '[PRE78]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This function is going to call itself until the value of the parameter is no
    longer bigger than `0`. And then it stops.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将会一直调用自己，直到参数的值不再大于`0`。然后它才会停止。
- en: 'What happens when we call a function recursively is that it goes one function
    deeper every time. The first function call is done last. For this function it
    goes like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们递归地调用一个函数时会发生什么？每次都会进入一个函数的更深层次。第一次函数调用是最后完成的。对于这个函数，它的过程是这样的：
- en: '`getRecursive(3)`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRecursive(3)`'
- en: '`getRecursive(2)`'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRecursive(2)`'
- en: '`getRecursive(1)`'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRecursive(1)`'
- en: '`getRecursive(0)`'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRecursive(0)`'
- en: done with `getRecursive(0)` execution
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRecursive(0)`执行完成'
- en: done with `getRecursive(1)` execution
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRecursive(1)`执行完成'
- en: done with `getRecursive(2)` execution
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRecursive(2)`执行完成'
- en: done with `getRecursive(3)` execution
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRecursive(3)`执行完成'
- en: 'The next recursive function will demonstrate that:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个递归函数将演示：
- en: '[PRE79]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'It will output:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出：
- en: '[PRE80]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Recursive functions can be great in some contexts. When you feel the need to
    call the same function over and over again in a loop, you should probably consider
    recursion. An example could also be searching for something. Instead of looping
    over everything inside the same function, you can split up inside the function
    and call the function repeatedly from the inside.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，递归函数可以非常出色。当你觉得需要在循环中反复调用同一个函数时，你可能应该考虑使用递归。一个例子也可以是搜索某物。你不需要在同一个函数内部循环遍历所有内容，你可以在函数内部分割，并从内部反复调用函数。
- en: However, it must be kept in mind that in general, the performance of recursion
    is slightly worse than the performance of regular iteration using a loop. So if
    this causes a bottleneck situation that would really slow down your application,
    then you might want to consider another approach.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，必须记住的是，通常情况下，递归的性能略低于使用循环的常规迭代的性能。所以如果这会导致瓶颈情况，真正地减慢你的应用程序，那么你可能需要考虑另一种方法。
- en: Have a look at calculating the factorial using recursive functions in the following
    exercise.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下练习中如何使用递归函数计算阶乘。
- en: Practice exercise 6.6
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.6
- en: A common problem that we can solve with recursion is calculating the factorial.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用递归解决的一个常见问题是计算阶乘。
- en: 'Quick mathematics refresher about factorials:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 关于阶乘的快速数学复习：
- en: The factorial of a number is the product of all positive integers bigger than
    0, up to the number itself. So for example, the factorial of seven is 7 * 6 *
    5 * 4 * 3 * 2 * 1\. You can write this as 7!.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数的阶乘是所有大于0的正整数的乘积，直到这个数本身。例如，7的阶乘是7 * 6 * 5 * 4 * 3 * 2 * 1。你可以写成7!。
- en: How are recursive functions going to help us calculate the factorial? We are
    going to call the function with a lower number until we reach 0\. In this exercise,
    we will use recursion to calculate the factorial result of a numeric value set
    as the argument of a function.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数如何帮助我们计算阶乘？我们将用较小的数字调用函数，直到达到0。在这个练习中，我们将使用递归来计算函数参数设置的数值的阶乘结果。
- en: Create a function that contains a condition within it checking if the argument
    value is `0`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，在其中包含一个条件，检查参数值是否为`0`。
- en: If the parameter is equal to `0`, it should return the value of `1`. Otherwise,
    it should return the value of the argument multiplied by the value returned from
    the function itself, subtracting one from the value of the argument that is provided.
    This will result in running the block of code until the value reaches `0`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果参数等于`0`，它应该返回`1`的值。否则，它应该返回参数值乘以函数自身返回的值，并从提供的参数值中减去`1`。这将导致代码块运行，直到值达到`0`。
- en: Invoke the function, providing an argument of whatever number you want to find
    the factorial of. The code should run whatever number is passed initially into
    the function, decreasing all the way to `0` and outputting the results of the
    calculation to the console. It could also contain a `console.log()` call to print
    the current value of the argument in the function as it gets invoked.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用函数，提供一个你想要找到阶乘的数字作为参数。代码应该运行最初传递到函数中的任何数字，一直减少到`0`，并将计算结果输出到控制台。它也可以包含一个`console.log()`调用，以打印函数被调用时的当前参数值。
- en: Change and update the number to see how it affects the results.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改并更新数字，看看它如何影响结果。
- en: Nested functions
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套函数
- en: 'Just as with loops, `if` statements, and actually all other building blocks,
    we can have functions inside functions. This phenomenon is called nested functions:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 就像循环、`if`语句以及实际上所有其他构建块一样，我们可以在函数内部有函数。这种现象称为嵌套函数：
- en: '[PRE81]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This will output:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE82]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'As you can see, the outer function is calling its nested function. This nested
    function has access to the variables of the parent. The other way around, this
    is not the case. Variables defined inside the inner function have function scope.
    This means they are accessible inside the function where they are defined, which
    is in this case the inner function. Thus, this will throw a `ReferenceError`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，外部函数正在调用其嵌套函数。这个嵌套函数可以访问父函数的变量。反过来，情况并非如此。在内部函数内部定义的变量具有函数作用域。这意味着它们可以在定义它们的函数内部访问，在这种情况下是内部函数。因此，这将抛出一个`ReferenceError`：
- en: '[PRE83]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: What do you think this will do?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这会做什么？
- en: '[PRE84]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This will also throw a `ReferenceError`. Now, `doInnerFunctionStuff()` is defined
    inside the outer function, which means that it is only in scope inside `doOuterFunctionStuff()`.
    Outside this function, it is out of scope.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会抛出一个`ReferenceError`。现在，`doInnerFunctionStuff()`是在外部函数中定义的，这意味着它只在外部函数`doOuterFunctionStuff()`的作用域内有效。在这个函数外部，它就不再有效。
- en: Practice exercise 6.7
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习题6.7
- en: Create a countdown loop starting at a dynamic value of `10`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个动态值`10`开始创建一个倒计时循环。
- en: Set the `start` variable at a value of `10`, which will be used as the starting
    value for the loop.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`start`变量设置为`10`，这将是循环的起始值。
- en: Create a function that takes one argument, which is the countdown value.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，它接受一个参数，即倒计时值。
- en: Within the function, output the current value of the countdown into the console.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，将倒计时的当前值输出到控制台。
- en: Add a condition to check if the value is less than 1; if it is, then return
    the function.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个条件来检查值是否小于1；如果是，则返回该函数。
- en: Add a condition to check if the value of the countdown is not less than 1, then
    continue to loop by calling the function within itself.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个条件来检查倒计时的值是否不小于1，然后通过在函数内部调用函数来继续循环。
- en: Make sure you add a decrement operator on the countdown so the preceding condition
    eventually will be true to end the loop. Every time it loops, the value will decrease
    until it reaches 0.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在倒计时上添加一个递减运算符，这样前面的条件最终会变为真以结束循环。每次循环时，值都会减少，直到达到`0`。
- en: Update and create a second countdown using a condition if the value is greater
    than 0\. If it is, decrease the value of the countdown by 1.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值大于0，则使用条件更新和创建第二个倒计时。如果是，则将倒计时的值减1。
- en: Use `return` to return the function, which then invokes it again and again until
    the condition is no longer true.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`return`返回函数，然后再次调用它，直到条件不再为真。
- en: Make sure, when you send the new countdown value as an argument into the function,
    that there is a way out of the loop by using the `return` keyword and a condition
    that continues the loop if met.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保当你将新的倒计时值作为参数发送到函数中时，有一个方法通过使用`return`关键字和一个条件来退出循环，如果满足条件则继续循环。
- en: Anonymous functions
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'So far, we have been naming our functions. We can also create functions without
    names if we store them inside variables. We call these functions anonymous. Here
    is a non-anonymous function:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在给我们的函数命名。如果我们将它们存储在变量中，我们也可以创建没有名称的函数。我们称这些函数为匿名函数。以下是一个非匿名函数：
- en: '[PRE85]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Here is how to turn the previous function into an anonymous function:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何将前面的函数转换为匿名函数的方法：
- en: '[PRE86]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you can see, our function has no name. It is anonymous. So you may wonder
    how you can invoke this function. Well actually, you can't like this!
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的函数没有名称。它是匿名的。所以你可能想知道你如何调用这个函数。实际上，你不能这样调用！
- en: 'We will have to store it in a variable in order to call the anonymous function;
    we can store it like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将其存储在变量中才能调用匿名函数；我们可以这样存储：
- en: '[PRE87]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'An anonymous function can be called using the variable name, like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数可以通过变量名来调用，如下所示：
- en: '[PRE88]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: It will simply output `Not so secret though.`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 它将简单地输出 `Not so secret though.`。
- en: This might seem a bit useless, but it is a very powerful JavaScript construct.
    Storing functions inside variables enables us to do very cool things, like passing
    in functions as parameters. This concept adds another abstract layer to coding.
    This concept is called callbacks, and we will discuss it in the next section.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点无用，但它是一个非常强大的 JavaScript 构造。将函数存储在变量中使我们能够做非常酷的事情，比如将函数作为参数传递。这个概念为编程添加了另一个抽象层。这个概念被称为回调，我们将在下一节中讨论它。
- en: Practice exercise 6.8
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.8
- en: Set a variable name and assign a function to it. Create a function expression
    with one parameter that outputs a provided argument to the console.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个变量名并将一个函数分配给它。创建一个带有一个参数的函数表达式，该参数将提供的参数输出到控制台。
- en: Pass an argument into the function.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参数传递给函数。
- en: Create the same function as a normal function declaration.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相同的函数创建为一个正常的函数声明。
- en: Function callbacks
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数回调
- en: 'Here is an example of passing a function as an argument to another function:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个将函数作为参数传递给另一个函数的例子：
- en: '[PRE89]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If we call this new function with our previously made anonymous function, `functionVariable`,
    like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用之前创建的匿名函数 `functionVariable` 调用这个新函数，如下所示：
- en: '[PRE90]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'It will output:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出：
- en: '[PRE91]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: But we can also call it with another function, and then our `doFlexibleStuff`
    function will execute this other function. How cool is that?
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以用另一个函数来调用它，然后我们的 `doFlexibleStuff` 函数将执行这个其他函数。这有多酷？
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This will produce the following output:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE93]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: So what happened? We created a function and stored it in the `anotherFunctionVariable`
    variable. We then sent that in as a function parameter to our `doFlexibleStuff()`
    function. And this function is simply executing whatever function gets sent in.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么？我们创建了一个函数，并将其存储在 `anotherFunctionVariable` 变量中。然后我们将它作为函数参数传递给我们的 `doFlexibleStuff()`
    函数。这个函数只是简单地执行被传递进来的任何函数。
- en: At this point you may wonder why the writers are so excited about this callback
    concept. It probably looks rather lame in the examples you have seen so far. Once
    we get to asynchronous functions later on, this concept is going to be of great
    help. To still satisfy your need for a more concrete example, we will give you
    one.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道为什么作者对这种回调概念如此兴奋。在你迄今为止看到的例子中，这可能看起来相当平淡无奇。一旦我们稍后讨论异步函数，这个概念将会非常有帮助。为了满足你对更具体例子的需求，我们将给你一个例子。
- en: In JavaScript, there are many built-in functions, as you may know by now. One
    of them is the `setTimeout()` function. It is a very special function that is
    executing a certain function after a specified amount of time that it will wait
    first. It is also seemingly responsible for quite a few terribly performing web
    pages, but that is definitely not the fault of this poor misunderstood and misused
    function.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，JavaScript 中有很多内置函数。其中之一是 `setTimeout()` 函数。这是一个非常特殊的函数，它会在等待一段指定的时间后执行某个函数。它似乎也负责很多性能极差的网页，但这绝对不是这个可怜的、被误解和误用的函数的错。
- en: 'This code is really something you should try to understand:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码真的是你应该尝试理解的东西：
- en: '[PRE94]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'It is going to wait for `1000`ms (one second) and then print:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 它将等待 `1000`ms（一秒）然后打印：
- en: '[PRE95]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If you need more encouragement, you can use the `setInterval()` function instead.
    It works very similarly, but instead of executing the specified function once,
    it will keep on executing it with the specified interval:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多的鼓励，你可以使用 `setInterval()` 函数。它的工作方式非常相似，但与只执行一次指定的函数不同，它会在指定的间隔内持续执行：
- en: '[PRE96]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In this case, it will print our encouraging message every second until you kill
    the program.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它将每秒打印一次鼓励信息，直到你终止程序。
- en: This concept of the function executing the function after having been called
    itself is very useful for managing asynchronous program execution.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在函数被调用后执行函数的概念对于管理异步程序执行非常有用。
- en: Chapter projects
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节项目
- en: Create a recursive function
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个递归函数
- en: Create a recursive function that counts up to 10\. Invoke the function with
    different start numbers as the arguments that are passed into the function. The
    function should run until the value is greater than 10.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个递归函数，该函数从10开始计数。用不同的起始数字作为传递给函数的参数来调用该函数。函数应运行到值大于10为止。
- en: Set timeout order
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置超时顺序
- en: Use the arrow format to create functions that output the values `one` and `two`
    to the console. Create a third function that outputs the value `three` to the
    console, and then invokes the first two functions.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头格式创建函数，将值`one`和`two`输出到控制台。创建一个第三个函数，将值`three`输出到控制台，然后调用前两个函数。
- en: Create a fourth function that outputs the word `four` to the console and also
    use `setTimeout()` to invoke the first function immediately and then the third
    function.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个第四个函数，该函数将单词`four`输出到控制台，并使用`setTimeout()`立即调用第一个函数，然后调用第三个函数。
- en: 'What does your output look like in the console? Try to get the console to output:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出在控制台看起来是什么样子？尝试让控制台输出：
- en: '[PRE97]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Self-check quiz
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我检查测验
- en: What value is output into the console?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出到控制台的是什么值？
- en: '[PRE98]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: What will be output into the console by the below code?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将输出到控制台的内容是什么？
- en: '[PRE99]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: What will be output to the console?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台将输出什么？
- en: '[PRE100]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: What will be output to the console?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台将输出什么？
- en: '[PRE101]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: What will be output to the console?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台将输出什么？
- en: '[PRE102]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Summary
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have covered functions. Functions are a great JavaScript
    building block that we can use to reuse lines of code. We can give our functions
    parameters, so that we can change the code depending on the arguments a function
    gets invoked with. Functions can return a result; we do so using the `return`
    keyword. And we can use `return` at the place where we call a function. We can
    store the result in a variable or use it in another function, for example.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了函数。函数是JavaScript的一个强大构建块，我们可以用它来重用代码行。我们可以给函数传递参数，这样我们就可以根据函数被调用的参数来改变代码。函数可以返回一个结果；我们使用`return`关键字来这样做。我们还可以在调用函数的地方使用`return`。我们可以将结果存储在变量中或在另一个函数中使用，例如。
- en: We then met with variable scopes. The scope entails the places from where variables
    are accessible. Default `let` and `const` variables can be accessed inside the
    block where they're defined (and the inner blocks of that block) and `var` is
    just accessible from the line where it was defined.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遇到了变量作用域。作用域包括变量可访问的地方。默认的`let`和`const`变量可以在定义它们的块（及其内部块）内访问，而`var`则仅可以从定义它的行访问。
- en: We can also use recursive functions to elegantly solve problems that can be
    solved recursively by nature, such as calculating the factorial. Nested functions
    were the next topic we studied. They are not a big deal, just functions inside
    functions. Basic functions inside functions are not considered very pretty, but
    anonymous functions and arrow functions are not uncommon to see. Anonymous functions
    are functions without a name and arrow functions are a special case of anonymous
    functions, where we use an arrow to separate the parameters and the body.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用递归函数优雅地解决那些本质上可以递归解决的问题，例如计算阶乘。嵌套函数是我们接下来研究的下一个主题。它们并不是什么大问题，只是函数内部的函数。函数内部的简单函数并不被认为很漂亮，但匿名函数和箭头函数并不少见。匿名函数是没有名称的函数，箭头函数是匿名函数的一种特殊情况，其中我们使用箭头分隔参数和主体。
- en: In the next chapter, we'll consider classes, another powerful programming construct!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑类，这是另一种强大的编程结构！
