- en: Chapter 7. Constructing Common UI Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 构建常见的UI小部件
- en: One of the biggest features that draws developers to Ext JS is the vast array
    of UI widgets available out of the box. The ease with which they can be integrated
    with each other and the attractive and consistent visuals each of them offers
    is also a big attraction. No other framework can compete on this front, and this
    is a huge reason Ext JS leads the field of large-scale web applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 吸引开发者使用Ext JS的最大特点之一是开箱即用的丰富UI小部件。它们可以轻松集成，并且每个小部件提供的吸引力和一致性视觉效果也是一个很大的吸引力。没有其他框架能在这一方面竞争，这也是Ext
    JS在大型Web应用领域领先的一个巨大原因。
- en: In this chapter, we will look at how UI widgets fit into the framework's structure,
    how they interact with each other, and how we can retrieve and reference them.
    We will then delve under the surface and investigate the lifecycle of a component
    and the stages it will go through during the lifetime of an application. Finally,
    we will add the first UI components to our BizDash application in the form of
    data grids, trees, data views, and forms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨UI小部件如何适应框架的结构，它们如何相互交互，以及我们如何检索和引用它们。然后，我们将深入探讨组件的生命周期以及它在应用程序生命周期中将要经历的各个阶段。最后，我们将以数据网格、树、数据视图和表单的形式将第一个UI组件添加到我们的BizDash应用程序中。
- en: Anatomy of a UI widget
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI小部件的解剖结构
- en: Every UI element in Ext JS extends from the base component class `Ext.Component`.
    This class is responsible for rendering UI elements to the HTML document. They
    are generally sized and positioned by layouts used by their parent components
    and participate in the automatic component lifecycle process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS中的每个UI元素都扩展自基本组件类`Ext.Component`。这个类负责将UI元素渲染到HTML文档中。它们通常由父组件使用的布局来设置尺寸和定位，并参与自动组件生命周期过程。
- en: You can imagine an instance of `Ext.Component` as a single section of the user
    interface in a similar way that you might think of a DOM element when building
    traditional web interfaces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`Ext.Component`的实例想象成用户界面中的一个单独部分，就像您在构建传统Web界面时可能会想到DOM元素一样。
- en: Each subclass of `Ext.Component` builds upon this simple fact and is responsible
    for generating more complex HTML structures or combining multiple Ext.Components
    to create a more complex interface.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Ext.Component`的子类都基于这个简单的事实，并负责生成更复杂的HTML结构或组合多个`Ext.Component`以创建更复杂的界面。
- en: '`Ext.Component` classes, however, can''t contain other Ext.Components. To combine
    components, one must use the `Ext.container.Container` class, which itself extends
    from `Ext.Component`. This class allows multiple components to be rendered inside
    it and have their size and positioning managed by the framework''s layout classes
    (see [Chapter 6](ch06.html "Chapter 6. Combining UI Widgets into the Perfect Layout"),
    *Combining UI Widgets into the Perfect Layout*, for more details).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Ext.Component`类不能包含其他`Ext.Component`。要组合组件，必须使用`Ext.container.Container`类，该类本身扩展自`Ext.Component`。这个类允许多个组件在其中渲染，并且它们的尺寸和定位由框架的布局类管理（有关更多详细信息，请参阅第6章[Chapter
    6](ch06.html "Chapter 6. Combining UI Widgets into the Perfect Layout")，*将UI小部件组合成完美的布局*）。
- en: Components and HTML
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件和HTML
- en: Creating and manipulating UIs using components requires a slightly different
    way of thinking than you may be used to when creating interactive websites with
    libraries such as jQuery.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件创建和操作UI需要一种与您在创建带有jQuery等库的交互式网站时可能习惯的略有不同的思维方式。
- en: The `Ext.Component` class provides a layer of abstraction from the underlying
    HTML and allows us to encapsulate additional logic to build and manipulate this
    HTML. This concept is different from the way other libraries allow you to manipulate
    UI elements and provides a hurdle for new developers to get over.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.Component`类从底层HTML提供了一层抽象，使我们能够封装额外的逻辑来构建和操作这个HTML。这个概念与其他库允许您操作UI元素的方式不同，也为新开发者提供了一个需要克服的障碍。'
- en: 'The `Ext.Component` class generates HTML for us, which we rarely need to interact
    with directly; instead, we manipulate the configuration and properties of the
    component. The following code and screenshot show the HTML generated by a simple
    `Ext.Component` instance:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.Component`类为我们生成HTML，我们很少需要直接与之交互；相反，我们操作组件的配置和属性。以下代码和截图显示了简单`Ext.Component`实例生成的HTML：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Components and HTML](img/3717_07_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![组件和HTML](img/3717_07_01.jpg)'
- en: As you can see, a simple `<DIV>` tag is created, which is given some CSS classes
    and an autogenerated ID, and has the HTML config displayed inside it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建了一个简单的 `<DIV>` 标签，它被赋予了某些CSS类和一个自动生成的ID，并在其中显示了HTML配置。
- en: This generated HTML is created and managed by the `Ext.dom.Element` class, which
    wraps a DOM element and its children, offering us numerous helper methods to interrogate
    and manipulate it. After it is rendered, each `Ext.Component` instance has the
    element instance stored in its `el` property. You can then use this property to
    manipulate the underlying HTML that represents the component.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成的HTML是由 `Ext.dom.Element` 类创建和管理的，它包装了一个DOM元素及其子元素，为我们提供了许多辅助方法来查询和操纵它。渲染后，每个
    `Ext.Component` 实例都将元素实例存储在其 `el` 属性中。然后你可以使用这个属性来操纵代表组件的底层HTML。
- en: As mentioned earlier, the `el` property won't be populated until the component
    has been rendered to the DOM. You should put logic dependent on altering the raw
    HTML of the component in an `afterrender` event listener or override the `afterRender`
    method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`el` 属性将在组件被渲染到DOM中之前不会被填充。你应该在 `afterrender` 事件监听器中将依赖于更改组件原始HTML的逻辑放入，或者覆盖
    `afterRender` 方法。
- en: 'The following example shows how you can manipulate the underlying HTML once
    the component has been rendered. It will set the background color of the element
    to red:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了组件渲染后如何操纵底层HTML。它将元素的背景色设置为红色：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is important to understand that digging into and updating the HTML and CSS
    that Ext JS creates for you is a dangerous game to play and can result in unexpected
    results when the framework tries to update things itself. There is usually a *framework
    way* to achieve the manipulations you want to include, which we recommend you
    use first.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，深入挖掘和更新Ext JS为你创建的HTML和CSS是一个危险的游戏，当框架尝试自己更新内容时，可能会导致意外结果。通常有一个 *框架方式*
    来实现你想要包含的操纵，我们建议你首先使用它。
- en: We always advise new developers to try not to fight the framework too much when
    starting out. Instead, we encourage them to follow its conventions and patterns,
    rather than having to wrestle it to do things in the way they may have previously
    done when developing traditional websites and web apps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是建议新开发者开始时尽量不要与框架过多对抗。相反，我们鼓励他们遵循其约定和模式，而不是强迫它以他们可能以前在开发传统网站和Web应用时的方式做事。
- en: The component lifecycle
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: When a component is created, it follows a lifecycle process that is important
    to understand, so as to have an awareness of the order in which things happen.
    By understanding this sequence of events, you will have a much better idea of
    where your logic will fit and ensure you have control over your components at
    the right points.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件被创建时，它会遵循一个重要的生命周期过程，了解这一点很重要，以便了解事情发生的顺序。通过理解这一系列事件，你将更好地了解你的逻辑将适合何处，并确保你在正确的点上对组件有控制权。
- en: The creation lifecycle
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建生命周期
- en: The following process is followed when a new component is instantiated and rendered
    to the document by adding it to an existing container. When a component is shown
    explicitly (for example, without adding to a parent, such as a floating component)
    some additional steps are included. These have been denoted with a * in the following
    process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的组件通过将其添加到现有容器中实例化和渲染到文档时，会遵循以下过程。当一个组件被显式显示（例如，没有添加到父组件，如浮动组件）时，会包含一些额外的步骤。这些步骤在以下过程中用
    * 表示。
- en: constructor
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: First, the class' constructor function is executed, which triggers all of the
    other steps in turn. By overriding this function, we can add any setup code required
    for the component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，执行类的构造函数，这会依次触发其他所有步骤。通过重写这个函数，我们可以为组件添加任何所需的设置代码。
- en: Config options processed
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理配置选项
- en: The next thing to be handled is the config options that are present in the class
    (see [Chapter 2](ch02.html "Chapter 2. Mastering the Framework's Building Blocks"),
    *Mastering the Framework's Building Blocks*, for details). This involves each
    option's `apply` and `update` methods being called, if they exist, meaning the
    values are available via the getter from now onwards.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步要处理的是类中存在的配置选项（有关详细信息，请参阅[第2章](ch02.html "第2章. 掌握框架的构建块")，*掌握框架的构建块*）。这涉及到每个选项的
    `apply` 和 `update` 方法被调用（如果存在），这意味着值现在可以通过getter获取。
- en: initComponent
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化组件
- en: The `initComponent` method is now called and is generally used to apply configurations
    to the class and perform any initialization logic.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在会调用 `initComponent` 方法，通常用于应用配置并执行任何初始化逻辑。
- en: render
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: render
- en: Once added to a container, or when the `show` method is called, the component
    is rendered to the document.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加到容器中，或者当调用 `show` 方法时，组件就会被渲染到文档中。
- en: boxready
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: boxready
- en: At this stage, the component is rendered and has been laid out by its parent's
    layout class, and is ready at its initial size. This event will only happen once
    on the component's first layout.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，组件已经被渲染并由其父布局类布局，并且以初始大小准备好。此事件仅在组件的第一次布局时发生。
- en: activate (*)
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: activate (*)
- en: If the component is a floating item, then the activate event will fire, showing
    that the component is the active one on the screen. This will also fire when the
    component is brought back to focus, for example, in a **Tab** panel when a tab
    is selected.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件是一个浮动项，则激活事件将会触发，表明该组件是屏幕上的活动组件。当组件被带回焦点时，例如在 **Tab** 面板中选中标签时，这也会触发。
- en: show (*)
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: show (*)
- en: Similar to the previous step, the show event will fire when the component is
    finally visible on screen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一步类似，当组件最终在屏幕上可见时，show 事件会被触发。
- en: '![show (*)](img/3717_07_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![show (*)](img/3717_07_02.jpg)'
- en: The destruction process
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁过程
- en: When we are removing a component from the Viewport and want to destroy it, it
    will follow a destruction sequence that we can use to ensure things are cleaned
    up sufficiently, so as to avoid memory leaks and so on. The framework takes care
    of the majority of this cleanup for us, but it is important that we tidy up any
    additional things we instantiate.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从视图中移除组件并想要销毁它时，它将遵循一个销毁序列，我们可以使用这个序列来确保充分清理，以避免内存泄漏等问题。框架会为我们处理大部分清理工作，但重要的是我们也要整理好我们实例化的任何额外事物。
- en: hide (*)
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hide (*)
- en: When a component is manually hidden (using the hide method), this event will
    fire and any additional hide logic can be included here.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被手动隐藏（使用 hide 方法）时，此事件将会触发，并且可以在此处包含任何额外的隐藏逻辑。
- en: deactivate (*)
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: deactivate (*)
- en: Similar to the activate step, this is fired when the component becomes inactive.
    As with the activate step, this will happen when floating and nested components
    are hidden and are no longer the items under focus.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与激活步骤类似，当组件变得不活跃时，此事件会被触发。与激活步骤一样，这将在浮动和嵌套组件被隐藏且不再是焦点下的项目时发生。
- en: destroy
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: destroy
- en: This is the final step in the teardown process and is implemented when the component
    and its internal properties and objects are cleaned up. At this stage, it is best
    to remove event handlers, destroy subclasses, and ensure any other references
    are released.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是拆解过程的最后一步，在组件及其内部属性和对象被清理时实现。在这个阶段，最好移除事件处理器、销毁子类，并确保释放任何其他引用。
- en: '![destroy](img/3717_07_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![destroy](img/3717_07_03.jpg)'
- en: Component Queries
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件查询
- en: Ext JS boasts a powerful system to retrieve references to components called
    Component Queries. This is a CSS/XPath style query syntax that lets us target
    broad sets or specific components within our application. For example, within
    our controller, we may want to find a button with the text "Save" within a component
    of type MyForm.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 自带一个强大的系统来检索组件引用，称为组件查询。这是一个类似于 CSS/XPath 的查询语法，允许我们针对应用中的广泛集合或特定组件进行定位。例如，在我们的控制器中，我们可能想要找到一个类型为
    MyForm 的组件中的“保存”按钮。
- en: In this section, we will demonstrate the Component Query syntax and how it can
    be used to select components. We will also go into details about how it can be
    used within `Ext.container.Container` classes to scope selections.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示组件查询语法以及如何使用它来选择组件。我们还将详细介绍如何在 `Ext.container.Container` 类中使用它来限定选择范围。
- en: xtypes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: xtypes
- en: 'Before we dive in, it is important to understand the concept of xtypes in Ext
    JS. An xtype is a shorthand name for an `Ext.Component` that allows us to identify
    its declarative component configuration objects. For example, we can create a
    new `Ext.Component` as a child of an `Ext.container.Container` using an xtype
    with the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨之前，了解 Ext JS 中的 xtypes 概念非常重要。xtype 是 `Ext.Component` 的简称，允许我们识别其声明性组件配置对象。例如，我们可以使用以下代码创建一个新的
    `Ext.Component` 作为 `Ext.container.Container` 的子组件，并使用 xtype：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using xtypes allows you to lazily instantiate components when required, rather
    than having them all created upfront.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 xtypes 可以在需要时延迟实例化组件，而不是一开始就创建所有组件。
- en: 'Common component xtypes include:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的组件 xtypes 包括：
- en: '| Classes | xtypes |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | xtypes |'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Ext.tab.Panel` | `tabpanel` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Ext.tab.Panel` | `tabpanel` |'
- en: '| `Ext.container.Container` | `container` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Ext.container.Container` | `container` |'
- en: '| `Ext.grid.Panel` | `gridpanel` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Ext.grid.Panel` | `gridpanel` |'
- en: '| `Ext.Button` | `button` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `Ext.Button` | `button` |'
- en: xtypes form the basis of our Component Query syntax in the same way that element
    types (for example, `div`, `p`, `span`, and so on) do for CSS selectors. We will
    use these heavily in the following examples.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: xtypes以与元素类型（例如，`div`、`p`、`span`等）在CSS选择器中的作用相同的方式构成了我们的组件查询语法的基石。我们将在以下示例中大量使用这些。
- en: Sample component structure
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样例组件结构
- en: 'We will use the following sample component structure—a panel with a child tab
    panel, form, and buttons—to perform our example queries on:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下样本组件结构——一个包含子标签页面板、表单和按钮的面板——来执行我们的示例查询：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Queries with Ext.ComponentQuery
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ext.ComponentQuery的查询
- en: 'The `Ext.ComponentQuery` class is used to perform Component Queries, with the
    `query` method primarily used. This method accepts two parameters: a query string
    and an optional `Ext.container.Container` instance to use as the root of the selection
    (that is, only components below this one in the hierarchy will be returned). The
    method will return an array of components or an empty array if none are found.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.ComponentQuery`类用于执行组件查询，其中`query`方法是主要使用的。此方法接受两个参数：一个查询字符串和一个可选的`Ext.container.Container`实例，用作选择的根（即，只有层次结构中此组件以下的组件将被返回）。该方法将返回一个组件数组或一个空数组，如果没有找到任何组件。'
- en: We will work through a number of scenarios and use Component Queries to find
    a specific set of components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过几个场景，并使用组件查询来找到一组特定的组件。
- en: Finding components based on xtype
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于xtype查找组件
- en: 'As we have seen, we use xtypes like element types in CSS selectors. We can
    select all the `Ext.panel.Panel` instances using its xtype—`panel`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们使用xtypes，就像在CSS选择器中使用元素类型一样。我们可以使用其xtype——`panel`来选择所有`Ext.panel.Panel`实例：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also add the concept of hierarchy by including a second xtype separated
    by a space. The following code will select all `Ext.Button` instances that are
    descendants (at any level) of an `Ext.panel.Panel` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过包含一个用空格分隔的第二个xtype来添加层次结构的概念。以下代码将选择所有是`Ext.panel.Panel`类后代的`Ext.Button`实例：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We could also use the `>` character to limit it to buttons that are direct descendants
    of a `panel`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`>`字符将其限制为直接是`panel`后代的按钮。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finding components based on attributes
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于属性查找组件
- en: 'It is simple to select a component based on the value of a property. We use
    the XPath syntax to specify the attribute and the value. The following code will
    select buttons with an action attribute of `saveUser`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的值选择组件很简单。我们使用XPath语法来指定属性和值。以下代码将选择具有`saveUser`动作属性的按钮：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finding components based on itemIds
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于itemIds查找组件
- en: 'ItemIds are commonly used to retrieve components, and they are specially optimized
    for performance within the `ComponentQuery` class. They should be unique only
    within their parent container and not globally unique like the `id` config. To
    select a component based on itemId, we prefix the itemId with a `#` symbol:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ItemIds通常用于检索组件，并且在`ComponentQuery`类中对性能进行了特别优化。它们只在其父容器内是唯一的，而不是全局唯一，就像`id`配置一样。要基于itemId选择一个组件，我们需要在itemId前加上一个`#`符号：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finding components based on member functions
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于成员函数查找组件
- en: 'It is also possible to identify matching components based on the result of
    a function of that component. For example, we can select all text fields whose
    values are valid (that is, when a call to the `isValid` method returns `true`):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以根据该组件的函数的结果来识别匹配的组件。例如，我们可以选择所有值有效的文本字段（即，当调用`isValid`方法返回`true`时）：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Scoped Component Queries
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域组件查询
- en: All of our previous examples will search the entire component tree to find matches,
    but often we may want to keep our searches local to a specific container and its
    descendants. This can help reduce the complexity of the query and improve the
    performance, as fewer components have to be processed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的所有示例都会搜索整个组件树以找到匹配项，但通常我们可能希望将搜索限制在特定的容器及其后代中。这可以帮助减少查询的复杂性并提高性能，因为需要处理的组件更少。
- en: 'Ext.Containers have three handy methods to do this: `up`, `down`, and `query`.
    We will take each of these in turn and explain their features.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Ext容器有三个方便的方法来做这件事：`up`、`down`和`query`。我们将逐一介绍这些方法及其功能。
- en: up
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: up
- en: 'This method accepts a selector and will traverse up the hierarchy to find a
    single matching parent component. This can be useful to find the grid panel that
    a button belongs to, so an action can be taken on it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个选择器，并将遍历层次结构以找到单个匹配的父组件。这可以用来找到按钮所属的网格面板，以便对其执行操作：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: down
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: down
- en: 'This returns the first descendant component that matches the given selector:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回第一个匹配给定选择器的子组件：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: query
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询
- en: The `query` method performs much like `Ext.ComponentQuery.query` but is automatically
    scoped to the current container. This means that it will search all descendant
    components of the current container and return all matching ones as an array.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`query`方法与`Ext.ComponentQuery.query`类似，但它是自动限定在当前容器的作用域内。这意味着它将搜索当前容器的所有子组件，并返回所有匹配的组件作为一个数组。'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Hierarchical data with trees
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用树表示分层数据
- en: Now that we know and understand components, their lifecycle, and how to retrieve
    references to them, we will move on to more specific UI widgets.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解并理解了组件、它们的生命周期以及如何获取它们的引用，我们将继续介绍更具体的UI小部件。
- en: The tree panel component allows us to display hierarchical data in a way that
    reflects the data's structure and relationships.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 树面板组件允许我们以反映数据结构和关系的方式显示分层数据。
- en: In our application, we are going to use a tree panel to represent our navigation
    structure to allow users to see how the different areas of the app are linked
    and structured.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将使用树面板来表示我们的导航结构，使用户能够看到应用程序的不同区域是如何链接和组织的。
- en: Binding to a data source
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定到数据源
- en: Like all other data-bound components, tree panels must be bound to a data store—in
    this particular case it must be an `Ext.data.TreeStore` instance or subclass,
    as it takes advantage of the extra features added to this specialist store class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他数据绑定组件一样，树面板必须绑定到一个数据存储——在这个特定情况下，它必须是一个`Ext.data.TreeStore`实例或子类，因为它利用了添加到这个专业存储类中的额外功能。
- en: We will make use of the `BizDash.store.Navigation` TreeStore we created in [Chapter
    5](ch05.html "Chapter 5. Modeling Data Structures for Your UI"), *Modeling Data
    Structures for Your UI*, to bind to our tree panel.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在[第5章](ch05.html "第5章。为您的UI建模数据结构")中创建的`BizDash.store.Navigation` TreeStore来绑定到我们的树面板。
- en: Defining a tree panel
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义树面板
- en: 'The tree panel is defined in the `Ext.tree.Panel` class (which has an xtype
    of `treepanel`), which we will extend to create a custom class called `BizDash.view.navigation.NavigationTree`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 树面板定义在`Ext.tree.Panel`类中（它有一个`xtype`为`treepanel`），我们将扩展它来创建一个名为`BizDash.view.navigation.NavigationTree`的自定义类：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We configure the tree to be bound to our TreeStore by using its storeId, in
    this case, Navigation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用其`storeId`配置树绑定到我们的TreeStore，在这种情况下，是Navigation。
- en: A tree panel is a subclass of the `Ext.panel.Table` class (similar to the `Ext.grid.Panel`
    class), which means it must have a columns configuration present. This tells the
    component what values to display as part of the tree. In a simple, *traditional*
    tree, we might only have one column showing the item and its children; however,
    we can define multiple columns and display additional fields in each row. This
    would be useful if we were displaying, for example, files and folders and wanted
    to have additional columns to display the file type and file size of each item.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 树面板是`Ext.panel.Table`类的一个子类（类似于`Ext.grid.Panel`类），这意味着它必须有一个列配置。这告诉组件显示树的部分值。在一个简单的、*传统*的树中，我们可能只有一个列显示项目及其子项；然而，我们可以定义多个列，并在每一行显示额外的字段。如果我们显示文件和文件夹，并希望有额外的列来显示每个项目的文件类型和文件大小，这将非常有用。
- en: In our example, we are only going to have one column, displaying the Label field.
    We do this by using the `treecolumn` xtype, which is responsible for rendering
    the tree's navigation elements. Without defining `treecolumn`, the component won't
    display correctly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只将有一个列，显示标签字段。我们通过使用`treecolumn` xtype来实现这一点，它负责渲染树的导航元素。如果没有定义`treecolumn`，组件将无法正确显示。
- en: 'The `treecolumn` xtype''s configuration allows us to define which of the attached
    data model''s fields to use (`dataIndex`), the column''s header text (`text`),
    and the fact that the column should fill the horizontal space (flex: see the *Using
    the VBox layout* and *Using the HBox layout* sections in [Chapter 6](ch06.html
    "Chapter 6. Combining UI Widgets into the Perfect Layout"), *Combining UI Widgets
    into the Perfect Layout*, for more details on this concept).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`treecolumn` xtype 的配置允许我们定义要使用的数据模型字段（`dataIndex`）、列的标题文本（`text`），以及列应该填充水平空间的事实（flex：参见[第6章](ch06.html
    "第6章。将UI小部件组合成完美布局")中的*使用VBox布局*和*使用HBox布局*部分，*将UI小部件组合成完美布局*，了解更多关于这个概念的信息）。'
- en: Additionally, we set the `rootVisible` to `false`, so the data's root is hidden,
    as it has no real meaning other than holding the rest of the data together. Finally,
    we set `useArrows` to `true`, so the items with children use an arrow instead
    of the +/- icon.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将 `rootVisible` 设置为 `false`，因此数据的根被隐藏，因为它除了将其他数据组合在一起外没有实际意义。最后，我们将 `useArrows`
    设置为 `true`，因此带有子项的项目使用箭头而不是 +/- 图标。
- en: '![Defining a tree panel](img/3717_07_04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![定义树面板](img/3717_07_04.jpg)'
- en: Displaying tabular data
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示表格数据
- en: The grid component is one of the biggest reasons Ext JS is selected by developers.
    Its performance, features, and flexibility make it a powerful feature. In this
    section, we will work through an example of creating a grid to display our product
    data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 网格组件是开发者选择 Ext JS 的最大原因之一。它的性能、功能和灵活性使其成为一个强大的特性。在本节中，我们将通过创建一个网格来显示我们的产品数据的示例来操作。
- en: Product data
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品数据
- en: 'Before we dive into creating a grid component, we must create a data store
    that will hold the product data that our grid will display. In [Chapter 5](ch05.html
    "Chapter 5. Modeling Data Structures for Your UI"), *Modeling Data Structures
    for Your UI*, we defined the models that represent our product data, but we didn''t
    create a products store to hold a collection of product model instances. To do
    this, we create a new file called `Products.js` in the `store` folder of our project
    with the following class definition:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入创建网格组件之前，我们必须创建一个数据存储，它将保存我们的网格将显示的产品数据。在[第5章](ch05.html "第5章。为您的UI建模数据结构")，*为您的UI建模数据结构*中，我们定义了表示我们的产品数据的数据模型，但我们没有创建一个产品存储来保存产品模型实例的集合。为此，我们在项目的
    `store` 文件夹中创建了一个名为 `Products.js` 的新文件，其中包含以下类定义：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is a simple store definition with the only new configuration being the
    `autoLoad: true` setting, which will perform a load using the defined proxy as
    soon as the store is instantiated. In order to have this store automatically instantiated,
    we include it in the `stores` config of the `Application.js` file.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个简单的存储定义，唯一的新配置是 `autoLoad: true` 设置，它将在存储实例化后立即使用定义的代理执行加载。为了使此存储自动实例化，我们将它包含在
    `Application.js` 文件的 `stores` 配置中。'
- en: 'Our `products.json` file contains some simple product data, as seen here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `products.json` 文件包含一些简单的产品数据，如下所示：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Product grid
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品网格
- en: To create a grid, we use the `Ext.grid.Panel` component which extends from the
    `Ext.panel.Panel` class and so can be used in the same way as a simple panel (for
    example, it can have docked items, be given dimensions, and so on).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个网格，我们使用 `Ext.grid.Panel` 组件，它扩展自 `Ext.panel.Panel` 类，因此可以像简单面板一样使用（例如，它可以有停靠项，给定尺寸等）。
- en: 'We will define our product grid in a file called `ProductGrid.js` inside a
    new folder called `product` under the project''s view folder. We give it a basic
    configuration:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目视图文件夹下的一个名为 `product` 的新文件夹中的 `ProductGrid.js` 文件中定义我们的产品网格。我们给它一个基本的配置：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will recognize the `Ext.define` structure as the same as we have used throughout
    the book with the class name and parent class defined. The `xtype` config lets
    us define a string that can be used when lazily instantiating the product grid.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你会认出 `Ext.define` 结构与我们在整本书中使用的一样，其中定义了类名和父类。`xtype` 配置允许我们定义一个字符串，当懒加载产品网格时可以使用。
- en: 'The grid component has only two required configurations which we have included
    in the previous example: a store containing the data to be displayed and an array
    of columns which define what data is shown.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 网格组件只有两个必需的配置，我们在前面的示例中已经包含：包含要显示的数据的存储和一个定义显示什么数据的列数组。
- en: The store can be an actual store reference or a storeId that will be used to
    look up the store instance—in this case the products store we defined earlier.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 存储可以是实际的存储引用或用于查找存储实例的存储ID——在这种情况下，是我们之前定义的产品存储。
- en: Our columns definition contains an array of configuration objects that will
    be used to instantiate `Ext.grid.column.Column` classes (or subclasses thereof,
    for example, Date, Template, Number, and so on). The `text` property will define
    the column's header text and the `dataIndex` is the field to map to within the
    store's records. In our example, we have opted to display all the products' fields.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的列定义包含一个配置对象数组，这些对象将被用来实例化 `Ext.grid.column.Column` 类（或其子类，例如 Date、Template、Number
    等）。`text` 属性将定义列的标题文本，而 `dataIndex` 是映射到存储记录中的字段。在我们的例子中，我们选择显示所有产品的字段。
- en: 'Finally, we can include the new `ProductGrid` in our application and see it
    in action. We must first require the new component in the `views` array of `Application.js`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在我们的应用程序中包含新的 `ProductGrid` 并看到它的实际效果。我们必须首先在 `Application.js` 的 `views`
    数组中引入新的组件：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can then use the xtype in the Main view''s items collection, placing it
    in the center region:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在主视图的 `items` 集合中使用 xtype，将其放置在中心区域：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Reloading our application should show a grid with three rows of data:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载我们的应用程序应该显示一个包含三行数据的网格：
- en: '![Product grid](img/3717_07_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![产品网格](img/3717_07_05.jpg)'
- en: Customizing column displays
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义列显示
- en: So far, our grid simply displays the data values as they are held in the model,
    which is fine for simple values but some data would benefit from more advanced
    formatting.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的网格只是简单地显示模型中持有的数据值，这对于简单值来说是可以的，但某些数据将受益于更高级的格式化。
- en: 'There are multiple ways of achieving the same effect when it comes to formatting
    column values. We will cover the two main options: column renderers and template
    columns.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式化列值时，有多种实现相同效果的方法。我们将介绍两种主要选项：列渲染器和模板列。
- en: Column renderers
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列渲染器
- en: We will start by adding a bit of color to our grid by customizing the styling
    of the **Quantity** column when it starts to get low. We will make the figures
    red when they drop to 3 or below, and orange when between 7 and 3.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过自定义 **数量** 列的样式来给我们的网格添加一些颜色，当数量开始变低时。我们将当数量降至3或以下时使数字变红，当数量在7到3之间时变橙。
- en: 'A column `renderer` is a function that allows us to manipulate the data value
    (without affecting the underlying stored value) before it is displayed. We add
    the `renderer` property to the column definition and give it a function with the
    following parameters:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列 `renderer` 是一个函数，它允许我们在数据值显示之前对其进行操作（而不影响底层存储的值）。我们向列定义中添加 `renderer` 属性，并给它一个具有以下参数的函数：
- en: '**value**: The value of the bound model field'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**: 绑定模型字段的值'
- en: '**metaData**: Additional attributes of the cell being rendered, for example,
    `tdCls`, `tdAttr`, and `tdStyle`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**metaData**: 正在被渲染的单元格的额外属性，例如 `tdCls`、`tdAttr` 和 `tdStyle`'
- en: '**record**: The record for the current row'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**record**: 当前行的记录'
- en: '**rowIndex**: The index of the current row'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rowIndex**: 当前行的索引'
- en: '**colIndex**: The index of the current column'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**colIndex**: 当前列的索引'
- en: '**store**: The store that is bound to the grid'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**store**: 绑定到网格的存储'
- en: '**view**: The grid view'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**view**: 网格视图'
- en: 'The renderer function should return a string that will then be displayed in
    the cell. The following code shows our `renderer` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器函数应该返回一个字符串，然后将在单元格中显示。以下代码显示了我们的 `renderer` 函数：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Column renderers](img/3717_07_06.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![列渲染器](img/3717_07_06.jpg)'
- en: Template columns
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板列
- en: As we mentioned earlier, there are various other column types that offer additional
    features. The template column allows us to define an `Ext.XTemplate` that is merged
    with the row's record. This is particularly useful if we want to include more
    complex HTML in the cell.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，还有各种其他列类型提供了额外的功能。模板列允许我们定义一个与行记录合并的 `Ext.XTemplate`。如果我们想在单元格中包含更复杂的HTML，这尤其有用。
- en: 'The next example shows how we can include the `StockValue` field besides the
    `Price`. We start by adding an `xtype: ''templatecolumn''` property to the column
    definition and then by defining a `tpl` string which will be converted into an
    `Ext.XTemplate` instance:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '下一个示例展示了我们如何在 `Price` 之外包含 `StockValue` 字段。我们首先在列定义中添加一个 `xtype: ''templatecolumn''`
    属性，然后定义一个 `tpl` 字符串，该字符串将被转换为 `Ext.XTemplate` 实例：'
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Template columns](img/3717_07_07.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![模板列](img/3717_07_07.jpg)'
- en: Grid widgets
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格小部件
- en: Rendering complex components in grids has long been a desire of Ext JS developers
    and has now been made much easier with the introduction of grid widgets. These
    are components that are rendered inside grid cells and bound to a model field.
    Examples of grid widgets are buttons, mini graphs, form fields, and so on.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在网格中渲染复杂组件一直是Ext JS开发者的一个愿望，而现在随着网格小部件的引入，这已经变得容易得多。这些是在网格单元格内渲染并绑定到模型字段的组件。网格小部件的例子包括按钮、迷你图表、表单字段等等。
- en: 'We are going to add a simple button widget to our grid to allow each product''s
    details to be viewed. We start by adding a new `widgetcolumn` to our grid''s column
    array. The widget option defines the kind of widget displayed:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算在我们的网格中添加一个简单的按钮小部件，以便查看每个产品的详细信息。我们首先在我们的网格列数组中添加一个新的`widgetcolumn`。小部件选项定义了显示的小部件类型：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will render a button on each row that we can then hook up to a click event
    to open up a product details view (see the next section for further details on
    doing this).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每一行渲染一个按钮，然后我们可以将其连接到点击事件以打开产品详情视图（有关此操作的更多详细信息，请参阅下一节）。
- en: '![Grid widgets](img/3717_07_08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![网格小部件](img/3717_07_08.jpg)'
- en: 'We can hook into the widget''s events using the `listeners` config as we would
    if we were using the component anywhere else in our application. The following
    snippet shows how to attach a simple `click` handler to the button:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`listeners`配置来挂钩小部件的事件，就像我们会在应用程序的任何其他地方使用组件一样。以下代码片段显示了如何将一个简单的`click`处理程序附加到按钮上：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Inputting data with forms
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单输入数据
- en: A key aspect of web applications is forms. Being able to input data into our
    system is imperative, and as such, Ext JS has form components to suit all types
    of input that can be easily bound to our data models and related views.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用的一个关键方面是表单。能够将数据输入到我们的系统中是必不可少的，因此Ext JS提供了适用于所有类型输入的表单组件，这些组件可以轻松地绑定到我们的数据模型和相关视图。
- en: In this section, we will expand on our product grid and allow users to edit
    products through a simple form.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将扩展我们的产品网格，并允许用户通过一个简单的表单来编辑产品。
- en: Defining a form
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义表单
- en: 'We define our product form as we would any other view—by creating a file (in
    this case named view/product/ProductForm.js) and calling `Ext.define` within it.
    We extend the `Ext.form.Panel` class and give it an xtype of product—`ProductForm`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就像定义任何其他视图一样定义我们的产品表单——通过创建一个文件（在这种情况下命名为view/product/ProductForm.js）并在其中调用`Ext.define`。我们扩展了`Ext.form.Panel`类，并给它一个xtype为product—`ProductForm`：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Within our form, we want to have input fields for the product''s name, description,
    quantity, and price. There are numerous specific `form` field types we can use
    to suit most data types: `text`, `number`, `textarea`, `combobox`, `time`, `file`,
    `date`, `html`, and more. Check out the `Ext.form.field.*` namespace for all the
    possibilities.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表单中，我们希望有输入字段来输入产品的名称、描述、数量和价格。我们可以使用多种特定的`form`字段类型来适应大多数数据类型：`text`、`number`、`textarea`、`combobox`、`time`、`file`、`date`、`html`等等。查看`Ext.form.field.*`命名空间以获取所有可能性。
- en: 'We will make use of the `text`, `textarea`, and `number` fields for our form.
    We configure each using their xtypes and `fieldLabel`. Additionally, we will give
    our `textarea` an explicit height and tell our `Price` field that it can have
    a `decimalPrecision` of `2`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`text`、`textarea`和`number`字段来构建我们的表单。我们通过它们的xtypes和`fieldLabel`来配置每个字段。此外，我们将为我们的`textarea`指定一个显式的高度，并告诉我们的`Price`字段它可以有`2`位的`decimalPrecision`：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we have our input fields ready we will also add two buttons: `Save` and
    `Cancel`. We use the `bbar` config, which is a shortcut to adding a bottom docked
    toolbar, and define two buttons:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了输入字段，我们还将添加两个按钮：`保存`和`取消`。我们使用`bbar`配置，这是一个添加底部停靠工具栏的快捷方式，并定义了两个按钮：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Displaying our form
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示我们的表单
- en: We want to open our form when a user clicks the **Details** button beside a
    product in the grid and we want it to be pre-populated with that product's information.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在用户点击网格中产品旁边的**详情**按钮时打开我们的表单，并希望它预先填充该产品的信息。
- en: 'We start by creating a ViewController called `product.ProductGridController`,
    which will be attached to the `ProductGrid` view:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`product.ProductGridController`的ViewController，它将被附加到`ProductGrid`视图上：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This class extends the `Ext.app.ViewController` class and we give it an alias
    of `ProductGrid`. We use this alias to tie it back to our `ProductGrid` view by
    adding `controller: ''ProductGrid''` to the `ProductGrid` class.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '这个类扩展了`Ext.app.ViewController`类，并给它一个别名`ProductGrid`。我们使用这个别名通过在`ProductGrid`类中添加`controller:
    ''ProductGrid''`来将其与`ProductGrid`视图关联起来。'
- en: We will now use `ProductGridController` to listen for a click on the **Details**
    button and create and show our `ProductForm`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 `ProductGridController` 来监听点击 **详情** 按钮的事件，并创建并显示我们的 `ProductForm`。
- en: 'The click handler we added to the **Details** button in the previous section
    must be replaced with the name of the ViewController method that we want to execute
    when that event happens. We will call this `onDetailsClick`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中添加到 **详情** 按钮的点击处理程序必须替换为我们想要在事件发生时执行的 ViewController 方法的名称。我们将称之为 `onDetailsClick`：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `onDetailsClick` method of ViewController will instantiate a `ProductForm`
    instance, with some extra configuration to size and float it above the existing
    UI, and then show it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ViewController 的 `onDetailsClick` 方法将实例化一个 `ProductForm` 实例，并添加一些额外的配置来调整大小和浮动，使其位于现有的
    UI 之上，然后显示它：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we run our app, we will see the form display as a modal window above our
    grid.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的应用，我们将看到表单以模态窗口的形式显示在我们的网格上方。
- en: '![Displaying our form](img/3717_07_09.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![显示我们的表单](img/3717_07_09.jpg)'
- en: Populating our form
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充我们的表单
- en: At the moment, our product form is displayed but it isn't populated with the
    details of the product we clicked on. To do this, we must bind each of the form
    fields to the product model via a `ViewModel`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的产品表单已显示，但它没有填充我们点击的产品详情。为了做到这一点，我们必须通过 `ViewModel` 将每个表单字段绑定到产品模型。
- en: We start by creating a `ProductFormModel` class with a very simple configuration.
    The class extends the `Ext.app.ViewModel` class and is given an alias of `ProductForm`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个具有非常简单配置的 `ProductFormModel` 类。该类扩展了 `Ext.app.ViewModel` 类，并赋予了一个别名
    `ProductForm`。
- en: 'We also define the `data` property, which holds the data to be bound, with
    a `rec` property which will be a reference to the product model instance we want
    to display:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了 `data` 属性，它包含要绑定的数据，以及一个 `rec` 属性，它将是我们想要显示的产品模型实例的引用：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This class is then tied to our `ProductForm` class with its alias:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这个类与 `ProductForm` 类通过其别名关联起来：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that these two are tied together, we can make use of the `bind` option
    of each form field to tell the framework to populate the field with a value from
    this `ViewModel`. We can also do this with the form''s title property, so it displays
    the product name:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这两者已经绑定在一起，我们可以利用每个表单字段的 `bind` 选项来告诉框架使用 `ViewModel` 中的值填充字段。我们也可以这样做表单的标题属性，以便显示产品名称：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The final piece of the puzzle is to give the `ViewModel` a reference to the
    correct product model instance. We do this in the `onDetailsClick` method of `ProductGridController`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是给 `ViewModel` 提供正确的产品模型实例的引用。我们在 `ProductGridController` 的 `onDetailsClick`
    方法中这样做：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, when we open the form, the fields will be prepopulated. You will also notice
    that when you edit the product name, for example, the grid and form title will
    automatically update in real time. Pretty clever.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们打开表单时，字段将被预先填充。你还会注意到，当你编辑产品名称时，例如，网格和表单标题将自动实时更新。非常聪明。
- en: Persisting updates
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化更新
- en: At the moment, our `Save` and `Cancel` buttons don't do anything, so let's hook
    them up.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的 `保存` 和 `取消` 按钮没有任何作用，所以让我们将它们连接起来。
- en: 'We start by defining what happens when the buttons are clicked. We use the
    same pattern as we did with the product grid''s `Details` button and assign the
    click event a method name which correlates to a method in the ViewController:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义当按钮被点击时会发生什么。我们使用与产品网格的 `详情` 按钮相同的模式，并为点击事件分配一个与 ViewController 中的方法相对应的方法名：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we must create a ViewController called `ProductFormController`. Just like
    we did with `ProductGrid`, we have to tell the view that the ViewController exists
    by adding `controller: ''ProductFormController''`. The ViewModel and ViewControllers
    must also be *required* by the view, so they are available:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们必须创建一个名为 `ProductFormController` 的 ViewController。就像我们对 `ProductGrid`
    所做的那样，我们必须通过添加 `controller: ''ProductFormController''` 来告诉视图 ViewController 的存在。ViewModel
    和 ViewController 也必须由视图 *要求*，因此它们是可用的：'
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Inside the ViewController's handlers, we use the `getView` method to retrieve
    a reference to the form, so we can act on it. The `onSave` method will retrieve
    a reference to the product record (via the ViewModel) and commit it (alternatively,
    if you have a proper backend setup, you would call the `save` method). The `onCancel`
    method calls the `reject` method on the product model, so any changes that have
    been made are reverted. Both methods will then close the form and destroy it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ViewController 的处理程序中，我们使用 `getView` 方法来获取表单的引用，以便我们可以对其操作。`onSave` 方法将获取产品记录的引用（通过
    ViewModel）并提交它（或者，如果你有一个合适的后端设置，你会调用 `save` 方法）。`onCancel` 方法在产品模型上调用 `reject`
    方法，因此所做的任何更改都将被撤销。然后这两个方法都会关闭表单并销毁它。
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Data-bound views
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定视图
- en: So far, we have seen how to display data sets in trees and grids, but what if
    we want a bit more flexibility in how things are displayed?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在树和网格中显示数据集，但如果我们想要在显示方式上获得更多灵活性怎么办？
- en: Data views give us this freedom and allow us to define custom HTML to be displayed
    for each item in the dataset but while retaining the powerful automatic binding
    setup. We can then apply our own custom CSS to this HTML to style it as we want.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 数据视图给我们这种自由，并允许我们为数据集中的每个项目定义自定义 HTML 来显示，同时保留强大的自动绑定设置。然后我们可以将我们自己的自定义 CSS
    应用到这个 HTML 上，以按我们的意愿进行样式设计。
- en: We will work through an example where we create a data view for the users in
    our system.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个示例来演示，创建一个用于我们系统中用户的 数据视图。
- en: Defining our users' data view
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们的用户数据视图
- en: 'As always, we create a new view class—`BizDash.view.user.UsersView`—extending
    the base framework class `Ext.view.View`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们创建一个新的视图类—`BizDash.view.user.UsersView`—扩展基本框架类 `Ext.view.View`：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A data view requires three properties to function fully: a `store`, a `tpl`,
    and an `itemSelector`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 数据视图需要三个属性才能完全功能：一个 `store`、一个 `tpl` 和一个 `itemSelector`。
- en: Store
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储
- en: In exactly the same way as the grid and tree we've looked at previously, this
    is the data source that the component will be bound to. Any changes made to this
    store or its records will automatically be reflected in the view.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前查看的网格和树完全相同，这是组件将要绑定到的数据源。对这个存储或其记录所做的任何更改都将自动反映在视图中。
- en: 'In this instance, we will use the users store and will configure it using the
    `storeId`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用用户存储，并使用 `storeId` 进行配置：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Template
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板
- en: A data view is based on the concept of rendering a piece of HTML for each record
    in the bound data store. The `tpl` config defines `Ext.XTemplate` that will be
    merged with a record to produce that piece of HTML. Without this, nothing will
    be rendered to the screen.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 数据视图基于为绑定数据存储中的每个记录渲染 HTML 的概念。`tpl` 配置定义了将合并到记录中以生成该 HTML 片段的 `Ext.XTemplate`。没有这个，屏幕上不会渲染任何内容。
- en: 'We want to display each user''s name, role, and photo. We define the data view
    with the following template string:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想显示每个用户的姓名、角色和照片。我们使用以下模板字符串定义数据视图：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We start by using the `tpl` markup tag along with the `for` attribute. This
    tells the template to loop over the array it is given and merge the HTML within
    it with each record in turn. We mark data placeholders, whose names match the
    model's field names, using the `{{...}}` notation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `tpl` 标记标签和 `for` 属性。这告诉模板遍历它给出的数组，并将它内部的 HTML 与每个记录依次合并。我们使用 `{{...}}`
    符号标记数据占位符，其名称与模型的字段名称匹配。
- en: Item selector
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目选择器
- en: Finally, for our view component to know how to identify a single record's HTML,
    we must give it a CSS selector that can identify a single node. This is used to
    allow events to be raised on individual items (for example, click, double-click,
    and so on).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使我们的视图组件能够识别单个记录的 HTML，我们必须给它一个可以识别单个节点的 CSS 选择器。这用于允许在单个项目上引发事件（例如，点击、双击等）。
- en: 'We have given the wrapper div the `user-item` class, which we can use as the
    unique selector:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经给包装 div 分配了 `user-item` 类，我们可以将其用作唯一选择器：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Styling the view
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图样式
- en: If you show our data view, it will look a bit poor, so we need to include some
    styling to make it pretty.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你展示我们的数据视图，它看起来可能有点简陋，所以我们需要添加一些样式来使其看起来更美观。
- en: 'We do this by creating a `.scss` file called `UsersView.scss` within the `sass/src`
    folder and mirroring the view folders structure, so the SASS is automatically
    picked up. In this case, we create it in `sass/src/view/user/UsersView.scss`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `sass/src` 文件夹中创建一个名为 `UsersView.scss` 的 `.scss` 文件，并复制视图文件夹的结构来实现这一点，这样
    SASS 就会自动被选中。在这种情况下，我们在 `sass/src/view/user/UsersView.scss` 中创建它：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Following a `sencha app build` command and a refresh, you should see a nicer-styled
    data view, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`sencha app build`命令并刷新后，您应该会看到一个样式更佳的数据视图，如下所示：
- en: '![Styling the view](img/3717_07_10.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![设置视图样式](img/3717_07_10.jpg)'
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learnt how Ext JS' components fit together and the
    lifecycle that they follow when created and destroyed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Ext JS组件是如何相互配合的，以及它们在创建和销毁时遵循的生命周期。
- en: 'We then moved on to utilizing some of the most popular and useful components.
    We have explored the details of the following components within our BizDash application:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向使用一些最受欢迎和最有用的组件。在我们的BizDash应用程序中，我们探索了以下组件的详细信息：
- en: Trees
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树形结构
- en: Grids
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格
- en: Forms
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单
- en: Data views
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据视图
- en: In addition to explaining the main features and configuration options of these
    components, we linked them together within a simple MVVM architecture, taking
    advantage of two-way data binding and event listening.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解释这些组件的主要特性和配置选项外，我们还在一个简单的MVVM架构中将它们链接在一起，利用双向数据绑定和事件监听。
- en: In the next chapter, we will introduce Ext JS themes and how they can be customized
    to make your application unique.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Ext JS主题以及如何自定义它们以使您的应用程序独特。
