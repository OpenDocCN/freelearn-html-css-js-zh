- en: Node.js Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 模块
- en: Before writing Node.js applications, you must learn about Node.js modules and
    packages. Modules and packages are the building blocks for breaking down your
    application into smaller pieces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 Node.js 应用程序之前，你必须了解 Node.js 模块和包。模块和包是将你的应用程序分解成更小部分的基本构建块。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining a module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个模块
- en: The CommonJS and ES2015 module specifications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS 和 ES2015 模块规范
- en: Using ES2015/2016/2017 coding practices in Node.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Node.js 中使用 ES2015/2016/2017 编码实践
- en: Using the ES6 module format in Node.js code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Node.js 代码中使用 ES6 模块格式
- en: Understanding how Node.js finds modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Node.js 如何查找模块
- en: The npm package management system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm 包管理系统
- en: So, let's get on with it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Defining a module
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个模块
- en: Modules are the basic building blocks for constructing Node.js applications.
    A Node.js module encapsulates functions, hiding details inside a well-protected
    container, and exposing an explicitly-declared list of functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是构建 Node.js 应用程序的基本构建块。Node.js 模块封装了函数，将细节隐藏在一个保护良好的容器中，并公开一个显式声明的函数列表。
- en: 'There are two module formats that we must consider:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须考虑两种模块格式：
- en: The traditional Node.js format based on the CommonJS standard has been used
    since Node.js was created.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于CommonJS标准的传统 Node.js 格式自 Node.js 创建以来一直被使用。
- en: With ES2015/2016 a new format, ES6 Modules, has been defined with a new `import`
    keyword. ES6 modules will be (or is) supported in all JavaScript implementations.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着 ES2015/2016 的引入，一个新的格式，ES6 模块，通过新的 `import` 关键字被定义。ES6 模块将在所有 JavaScript
    实现中得到支持。
- en: Because ES6 modules are now the standard module format, the Node.js **Technical
    Steering Committee** (**TSC**) is committed to first-class support for ES6 modules.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ES6 模块现在是标准模块格式，Node.js 技术指导委员会（**TSC**）致力于为 ES6 模块提供一流的支持。
- en: We have already seen modules in action in the previous chapter. Every JavaScript
    file we use in Node.js is itself a module. It's time to see what they are and
    how they work. We'll start with CommonJS modules and then quickly bring in ES6
    modules.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中看到了模块的实际应用。在 Node.js 中使用的每个 JavaScript 文件本身就是一个模块。现在是时候看看它们是什么以及它们是如何工作的了。我们将从
    CommonJS 模块开始，然后快速引入 ES6 模块。
- en: 'In the `ls.js` example in Chapter 2, *Setting up Node.js*, we wrote the following
    code to pull in the `fs` module, giving us access to its functions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章的 `ls.js` 示例中，我们编写了以下代码来引入 `fs` 模块，从而获得对其函数的访问权限：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `require` function searches for the named module, loading the module definition
    into the Node.js runtime, and making its functions available. In this case, the
    `fs` object contains the code (and data) exported by the `fs` module. The `fs`
    module is part of the Node.js core and provides filesystem functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 函数用于搜索指定模块，将模块定义加载到 Node.js 运行时中，并使其函数可用。在这种情况下，`fs` 对象包含了由 `fs`
    模块导出的代码（和数据）。`fs` 模块是 Node.js 核心的一部分，提供了文件系统功能。'
- en: By declaring `fs` as `const`, we have a little bit of assurance against making
    coding mistakes that would modify the object holding the module reference.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `fs` 声明为 `const`，我们获得了一点点保证，防止在编码时犯修改包含模块引用的对象的错误。
- en: In every Node.js module, the `exports` object within the module is the interface
    exported to other code. Anything assigned to a field of the `exports` object is
    available to other pieces of code, and everything else is hidden. By the way,
    this object is actually `module.exports`. The `exports` object is an alias for
    `module.exports`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 Node.js 模块中，模块内部的 `exports` 对象是导出到其他代码的接口。任何分配给 `exports` 对象字段的值都可以供其他代码使用，而其他所有内容都是隐藏的。顺便说一句，这个对象实际上是
    `module.exports`。`exports` 对象是 `module.exports` 的别名。
- en: The `require` function and `module.exports` objects both come from the CommonJS
    specification. ES6 modules have similar concepts, but a different implementation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 函数和 `module.exports` 对象都来自 CommonJS 规范。ES6 模块有类似的概念，但实现方式不同。'
- en: 'Let''s look at a brief example of this before diving into the details. Ponder
    over the `simple.js` module:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们先简要地看看这个例子。思考一下 `simple.js` 模块：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have one variable, `count`, which is not attached to the `exports` object,
    and a function, `next`, which is attached. Now, let''s use it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个变量 `count`，它没有附加到 `exports` 对象上，还有一个函数 `next`，它被附加上了。现在，让我们使用它：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `exports` object in the module is the object that is returned by `require('./simple')`.
    Therefore, each call to `s.next` calls the `next` function in `simple.js`. Each
    returns (and increments) the value of the local variable, `count`. An attempt
    to access the private field, `count`, shows it's unavailable from outside the
    module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中的 `exports` 对象是 `require('./simple')` 返回的对象。因此，每次调用 `s.next` 都会调用 `simple.js`
    中的 `next` 函数。每次调用都会返回（并增加）局部变量 `count` 的值。尝试访问私有字段 `count` 会显示它无法从模块外部访问。
- en: 'To reiterate the rule:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调规则：
- en: Anything (functions or objects) assigned as a field of `exports` (as known as `module.exports`)
    is available to other code outside the module
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `exports` 字段分配（也称为 `module.exports`）的任何内容（函数或对象）都可以供模块外部的其他代码使用
- en: Objects not assigned to `exports` are not available to code outside the module,
    unless the module exports those objects via another mechanism
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有分配给 `exports` 的对象对模块外部的代码不可用，除非模块通过其他机制导出这些对象
- en: This is how Node.js solves the global object problem of browser-based JavaScript.
    The variables that look like they're global variables are only global to the module
    containing that variable. These variables are not visible to any other code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Node.js 解决基于浏览器的 JavaScript 的全局对象问题的方法。看起来像是全局变量的变量实际上只对该变量所在的模块是全局的。这些变量对任何其他代码不可见。
- en: Now that we've got a taste for modules, let's take a deeper look.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对模块有了初步的了解，让我们更深入地研究一下。
- en: CommonJS and ES2015 module formats
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS 和 ES2015 模块格式
- en: Node.js's module implementation is strongly inspired by, but not identical to,
    the CommonJS module specification. The differences between them might only be
    important if you need to share code between Node and other CommonJS systems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的模块实现强烈受到 CommonJS 模块规范的影响，但并不完全相同。它们之间的差异可能只有在您需要在 Node 和其他 CommonJS
    系统之间共享代码时才重要。
- en: Among the changes in ES2015 is a standard module format meant for use everywhere.
    It has some interesting features, and by existing everywhere it should advance
    the state of JavaScript. Since it is incompatible with the CommonJS/Node.js module
    system, adopting ES2015 modules in Node.js means reworking our practices and accepted
    norms.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES2015 的变化中，有一个标准模块格式，旨在任何地方使用。它有一些有趣的功能，由于它无处不在，它应该会推进 JavaScript 的发展状态。由于它与
    CommonJS/Node.js 模块系统不兼容，因此在 Node.js 中采用 ES2015 模块意味着我们需要重新工作我们的实践和接受的标准。
- en: As a practical matter, Node.js programmers will be dealing with both module
    formats for some time during a transition period. Our long-term goal should be
    to adopt ES2015 modules across the board. The Node.js platform is slated to bring
    in support for ES2015 modules in Node.js 10\. As of Node.js 8.5, the feature is
    available by setting a command-line flag.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在过渡期间，Node.js 程序员将同时处理这两种模块格式。我们的长期目标应该是全面采用 ES2015 模块。Node.js 平台计划在 Node.js
    10 中引入对 ES2015 模块的支持。截至 Node.js 8.5，可以通过设置命令行标志来启用此功能。
- en: CommonJS/Node.js module format
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS/Node.js 模块格式
- en: We've already seen a couple of examples of this module format, with the `simple.js`
    example, and the programs we examined in Chapter 2, *Setting up Node.js*. So let's
    take a closer look.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过 `simple.js` 示例和我们在第二章“设置 Node.js”中检查的程序看到了这种模块格式的几个例子。所以让我们更仔细地看看。
- en: CommonJS modules are stored in files with the extension `.js`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 模块存储在扩展名为 `.js` 的文件中。
- en: Loading a CommonJS module is a synchronous operation. That means that when the
    `require('modulename')` function call returns, the module has been located and
    completely read into memory and is ready to go. The module is cached in memory
    so that subsequent `require('modulename')` calls return immediately, and all return
    the exact same object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 CommonJS 模块是一个同步操作。这意味着当 `require('modulename')` 函数调用返回时，模块已经被定位并完全读入内存，并准备好使用。该模块被缓存在内存中，因此后续的
    `require('modulename')` 调用将立即返回，并且所有返回的都是同一个对象。
- en: 'Node.js modules provide a simple encapsulation mechanism to hide implementation
    details while exposing an API. Modules are treated as if they were written as
    follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 模块提供了一个简单的封装机制来隐藏实现细节，同时暴露一个 API。模块被处理得好像它们是这样编写的：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Thus, everything within the module is contained within an anonymous private
    namespace context. This is how the global object problem is resolved; everything in
    a module that looks global is actually contained within this private context.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模块内的所有内容都包含在一个匿名私有命名空间上下文中。这就是解决全局对象问题的方法；模块中看似全局的内容实际上都包含在这个私有上下文中。
- en: 'Objects and functions can be exposed from a CommonJS module by means of two
    free variables Node.js inserts into this private context: `module` and `exports`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 Node.js 插入到这个私有上下文中的两个自由变量来从 CommonJS 模块中公开对象和函数：`module` 和 `exports`：
- en: The `module` object contains several fields that you might find useful. Refer
    to the online Node.js documentation for details.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module` 对象包含一些你可能觉得有用的字段。有关详细信息，请参阅在线 Node.js 文档。'
- en: 'The `exports` object is an alias of the `module.exports` field. This means
    that the following two lines of code are equivalent:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports` 对象是 `module.exports` 字段的别名。这意味着以下两行代码是等效的：'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Your code can break the alias between the two if you do this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，你的代码可能会破坏这两个别名之间的关联：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Do not do that, because `exports` will no longer be equivalent to `module.exports`.
    If your intent is to assign a single object or function to be what''s returned
    by `require`, do this instead:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做，因为 `exports` 将不再等同于 `module.exports`。如果你的意图是将单个对象或函数分配为 `require` 返回的内容，请改为这样做：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Some modules do export a single function because that's how the module author
    envisioned delivering the desired functionality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块确实只导出一个函数，因为模块作者就是这样设想来交付所需功能的。
- en: The Node.js package format is derived from the CommonJS module system ([http://commonjs.org](http://commonjs.org)).
    When developed, the CommonJS team aimed to fill a gap in the JavaScript ecosystem.
    At that time, there was no standard module system, making it trickier to package
    JavaScript applications. The `require` function, the `exports` object, and other
    aspects of Node.js modules come directly from the CommonJS `Modules/1.0` spec.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 包格式源自 CommonJS 模块系统 ([http://commonjs.org](http://commonjs.org))。在开发过程中，CommonJS
    团队旨在填补 JavaScript 生态系统中的空白。当时，没有标准的模块系统，这使得打包 JavaScript 应用程序变得更加复杂。Node.js 模块的
    `require` 函数、`exports` 对象以及其他方面直接来自 CommonJS 的 `Modules/1.0` 规范。
- en: ES6 module format
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6 模块格式
- en: ES6 modules are a new module format designed for all JavaScript environments.
    While Node.js has had a good module system for its whole existence, browser-side
    JavaScript has not. That left the browser-side community with either relying on
    the `<script>` tag, or using non-standardized solutions. For that matter, traditional
    Node.js modules were never standardized, outside of the CommonJS effort. Therefore,
    ES6 modules stand to be a big improvement for the entire JavaScript world, by
    getting everyone on the same page with a common module format and mechanisms.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 模块是一种为所有 JavaScript 环境设计的全新模块格式。虽然 Node.js 整个生命周期中都有一个很好的模块系统，但浏览器端的 JavaScript
    并没有。这使浏览器端的社区要么依赖于 `<script>` 标签，要么使用非标准化的解决方案。就这一点而言，传统的 Node.js 模块从未标准化，除了 CommonJS
    努力之外。因此，ES6 模块有望为整个 JavaScript 世界带来重大改进，通过使每个人都使用相同的模块格式和机制达成共识。
- en: The side effect is that the Node.js community needs to start looking at, learning
    about, and adopting the ES2015 module format.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用是，Node.js 社区需要开始关注、学习并采用 ES2015 模块格式。
- en: ES6 modules are referred to by Node.js with the extension `.mjs`. When it came
    to implementing the new module format, the Node.js team determined that they could
    not support both CommonJS and ES6 modules with the `.js` extension. The `.mjs`
    extension was decided as the solution, and you may see tongue-in-cheek references
    to *Michael Jackson Script* for this file extension.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 使用 `.mjs` 扩展名来引用 ES6 模块。在实现新的模块格式时，Node.js 团队确定他们无法同时支持 CommonJS 和 ES6
    模块使用 `.js` 扩展名。`.mjs` 扩展名被选为解决方案，你可能会看到对这个文件扩展名的讽刺性引用，称为 *Michael Jackson Script*。
- en: One interesting detail is that ES6 modules load asynchronously. This may not
    have an impact on Node.js programmers, except that this is part of the rationale
    behind requiring the new `.mjs` extension.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的细节是，ES6 模块是异步加载的。这可能对 Node.js 程序员没有太大影响，但这是要求使用新的 `.mjs` 扩展名背后的部分原因。
- en: 'Create a file named `simple2.mjs` in the same directory as the `simple.js` example
    that we looked at earlier:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录下创建一个名为 `simple2.mjs` 的文件，该文件是我们之前查看的 `simple.js` 示例：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'ES6 items exported from a module are declared with the `export` keyword. This
    keyword can be put in front of any top-level declaration, such as variable, function,
    or class declarations:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从模块导出的 ES6 项目使用 `export` 关键字声明。这个关键字可以放在任何顶层声明之前，例如变量、函数或类声明：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The effect of this is similar to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果类似于以下：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The intent of both is essentially the same: to make a function, or other object,
    available to code outside the module. A statement such as `export function next()`
    is a named export, meaning the exported thing has a name, and that code outside
    the module uses that name to access the object. As we see here, named `exports`
    can be functions or objects, and they may also be class definitions.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的意图本质上相同：使一个函数或其他对象对模块外部的代码可用。例如，`export function next()` 是一个命名导出，意味着导出的东西有一个名字，外部代码使用这个名字来访问对象。正如我们所看到的，命名
    `exports` 可以是函数或对象，它们也可以是类定义。
- en: Using `export default` can be done once per module, and is the `default` export
    from the module. The `default` export is what code outside the module accesses
    when using the module object itself, rather than when using one of the exports
    from the module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `export default` 可以在每个模块中只做一次，并且是模块的 `default` 导出。`default` 导出是当使用模块对象本身而不是使用模块的导出之一时，外部代码访问的内容。
- en: You can also declare something, such as the `squared` function, and then export
    it later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明一些东西，比如 `squared` 函数，然后稍后导出它。
- en: 'Now let''s see how to use this ES2015 module. Create a `simpledemo.mjs` file
    with the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用这个 ES2015 模块。创建一个名为 `simpledemo.mjs` 的文件，内容如下：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `import` statement does what it means: it imports objects exported from
    a module. This version of the `import` statement is most similar to a traditional
    Node.js `require` statement, meaning that it creates an object through which you
    access the objects exported from the module.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句做了它意味着的事情：它导入了从模块导出的对象。这个版本的 `import` 语句与传统的 Node.js `require` 语句最相似，这意味着它通过创建一个对象来访问模块导出的对象。'
- en: 'This is how the code executes:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的执行方式：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As of Node.js 8.5, the new module format is available behind an option flag
    as shown here. You're also presented with this nice warning that it's an experimental
    feature. Accessing the `default` export is accomplished by accessing the field
    named `default`. Accessing an exported value, such as the `meaning` field, is
    done without parentheses because it is a value and not a function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Node.js 8.5，新的模块格式可以通过选项标志使用，如下所示。你还会看到一个警告，说明这是一个实验性功能。访问 `default` 导出是通过访问名为
    `default` 的字段来完成的。访问导出的值，如 `meaning` 字段，不需要括号，因为它是一个值而不是一个函数。
- en: 'Now to see a different way to import objects from a module, create another
    file, named `simpledemo2.mjs`, containing the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看从模块中导入对象的另一种方式，创建另一个文件，命名为 `simpledemo2.mjs`，内容如下：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, each imported object is its own thing rather than being attached
    to another object. Instead of writing `simple2.next()`, you simply write `next()`.
    The `as` clause is a way to declare an alias, if nothing else so you can use the
    default export. We already used an `as` clause earlier, and it can be used in
    other instances where you wish to provide an alias for the value being exported
    or imported.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个导入的对象都是独立的东西，而不是附加到另一个对象上。你不需要写 `simple2.next()`，只需写 `next()`。`as`
    子句是一种声明别名的方式，如果其他方式不可行，这样你就可以使用默认导出。我们之前已经使用了一个 `as` 子句，并且可以在其他需要为导出或导入的值提供别名的实例中使用它。
- en: 'Node.js modules can be used from ES2015 `.mjs` code. Create a file named `ls.mjs`,
    containing the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 模块可以从 ES2015 `.mjs` 代码中使用。创建一个名为 `ls.mjs` 的文件，内容如下：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You cannot, however, `require` an ES2015 module into regular Node.js code. The
    lookup algorithm for ES2015 modules is different, and as we mentioned earlier,
    ES2015 modules are loaded asynchronously.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能将 ES2015 模块 `require` 到常规 Node.js 代码中。ES2015 模块的查找算法不同，正如我们之前提到的，ES2015
    模块是异步加载的。
- en: 'Another wrinkle is handling the `fs.promises` submodule.  We are using that
    submodule in the example, but how?    This `import` statement does not work:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个复杂的问题是处理 `fs.promises` 子模块。我们在示例中使用了这个子模块，但它是如何使用的？  这个 `import` 语句不起作用：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This fails as so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这失败了，原因如下：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That leaves us with this construct:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了这个结构：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Executing the script gives the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本会得到以下结果：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last thing to note about ES2015 module code is that `import` and `export`
    statements must be top-level code. Even putting an `export` inside a simple block
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 ES2015 模块代码的最后一点是，`import` 和 `export` 语句必须是顶层代码。即使在像这样简单的块中放置一个 `export`：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Results in an error:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结果导致错误：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While there are a few more details about ES2015 modules, these are their most
    important attributes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管还有关于 ES2015 模块的更多细节，但这些是最重要的属性。
- en: JSON modules
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON 模块
- en: 'Node.js supports using `require(''/path/to/file-name.json'')` to import a JSON
    file. It is equivalent to this code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 支持使用 `require('/path/to/file-name.json')` 来导入 JSON 文件。它与以下代码等价：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That is, the JSON file is read synchronously, and the text is parsed as JSON.
    The resultant object is available as the object exported from the module. Create
    a file named `data.json`, containing the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 即，JSON 文件是同步读取的，文本被解析为 JSON。结果对象作为模块导出的对象可用。创建一个名为 `data.json` 的文件，包含以下内容：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now create a file named `showdata.js`, containing the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为 `showdata.js` 的文件，包含以下内容：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It will execute as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它将按以下方式执行：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `util.inspect` function is a useful way to present an object in an easy-to-read
    fashion.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`util.inspect` 函数是一种以易于阅读的方式展示对象的有用方法。'
- en: Supporting ES6 modules on older Node.js versions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在较老的 Node.js 版本上支持 ES6 模块
- en: While support for ES6 modules arrived as an experimental feature in Node.js
    8.5, there are two ways to use these modules on earlier Node.js implementations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ES6 模块的支持作为 Node.js 8.5 的实验性功能出现，但在较早的 Node.js 实现中，有两种方式可以使用这些模块。
- en: One method is to use the Babel transpiler to rewrite ES6 code so it can execute
    on older Node.js versions. For an example, see [https://blog.revillweb.com/using-es2015-es6-modules-with-babel-6-3ffc0870095b](https://blog.revillweb.com/using-es2015-es6-modules-with-babel-6-3ffc0870095b).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用 Babel 编译器重写 ES6 代码，使其能够在较老的 Node.js 版本上执行。例如，请参阅 [https://blog.revillweb.com/using-es2015-es6-modules-with-babel-6-3ffc0870095b](https://blog.revillweb.com/using-es2015-es6-modules-with-babel-6-3ffc0870095b)。
- en: 'The better method is the `esm` package in the Node.js registry. Simply do the
    following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是 Node.js 注册表中的 `esm` 包。只需按照以下步骤操作：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To use this module, one simply invokes `require('esm')` once, and ES6 modules
    are retrofitted into Node.js.  The `--require` flag automatically loads the named
    module.  Without rewriting the code, we can selectively use the esm module with
    this the command-line option.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此模块，只需调用一次 `require('esm')`，ES6 模块就会被集成到 Node.js 中。`--require` 标志会自动加载指定的模块。无需重写代码，我们可以通过命令行选项选择性地使用
    esm 模块。
- en: 'This example demonstrates retrofitting ES6 modules into older Node.js releases. 
    To successfully execute the `ls.mjs` example   we must have support for `async`/`await`
    functions, and arrow functions.  Since Node.js 6.x does not support either, the
    `ls.mjs` example will fail, and will necessitate rewriting such code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了将 ES6 模块集成到较老的 Node.js 版本中。要成功执行 `ls.mjs` 示例，我们必须有对 `async`/`await` 函数和箭头函数的支持。由于
    Node.js 6.x 不支持这些，`ls.mjs` 示例将失败，并需要重写此类代码：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For more information, see:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅：
- en: '[https://medium.com/web-on-the-edge/es-modules-in-node-today-32cff914e4b](https://medium.com/web-on-the-edge/es-modules-in-node-today-32cff914e4b). 
    That article describes an older release of the `esm` module, at the time named
    `@std/esm`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://medium.com/web-on-the-edge/es-modules-in-node-today-32cff914e4b](https://medium.com/web-on-the-edge/es-modules-in-node-today-32cff914e4b)。这篇文章描述了
    `esm` 模块的早期版本，当时命名为 `@std/esm`。'
- en: Demonstrating module-level encapsulation
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示模块级别的封装
- en: 'A key attribute of modules is encapsulation. The objects that are not exported
    from the module are private to the module, and cannot be accessed from code outside
    the module. To reiterate, modules are treated as if they were written as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的一个关键属性是封装。未从模块导出的对象是模块私有的，并且不能从模块外部的代码中访问。重申一点，模块被当作如下编写来处理：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This JavaScript idiom defines an anonymous private scope. Anything declared
    within that scope cannot be accessed by code outside the scope. That is, unless
    some code makes object references available to other code outside this private
    scope. That''s what the `module.exports` object does: it is a mechanism for the
    module author to expose object references from the module. Other code can then
    access resources inside the module in a controlled fashion.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JavaScript 习惯用法定义了一个匿名私有作用域。在该作用域内声明的任何内容都无法被作用域外的代码访问。也就是说，除非某些代码使对象引用对作用域外的其他代码可用。这正是
    `module.exports` 对象的作用：它是模块作者从模块中暴露对象引用的一种机制。然后其他代码可以以受控的方式访问模块内的资源。
- en: The top-level variables inside a module look like they exist in the global scope.
    Instead of being truly Global, they're safely private to the module and are completely
    inaccessible to other code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 模块内部顶级变量的外观就像它们存在于全局作用域中。实际上，它们并不是真正的全局变量，而是安全地私有于模块，并且完全不可被其他代码访问。
- en: 'Let''s take a look at a practical demonstration of that encapsulation. Create
    a file named `module1.js`, containing the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际演示该封装的例子。创建一个名为 `module1.js` 的文件，包含以下内容：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, create a file named `module2.js`, containing the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为 `module2.js` 的文件，包含以下内容：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, run it as follows (you must have Node.js already installed):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式运行（你必须已经安装了 Node.js）：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This artificial example demonstrates encapsulation of the values in `module1.js` from
    those in `module2.js`. The `A` and `B` values in `module1.js` don't overwrite
    `A` and `B` in `module2.js` because they're encapsulated within `module1.js`.
    The `values` function in `module1.js` does allow code in `module2.js` access to
    the values; however, `module2.js` cannot directly access those values. We can
    modify the object `module2.js` received from `module1.js`. But doing so does not
    change the values within `module1.js`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个人为的例子演示了 `module1.js` 中的值与 `module2.js` 中的值的封装。`module1.js` 中的 `A` 和 `B` 值不会覆盖
    `module2.js` 中的 `A` 和 `B`，因为它们被封装在 `module1.js` 中。`module1.js` 中的 `values` 函数允许
    `module2.js` 中的代码访问这些值；然而，`module2.js` 不能直接访问这些值。我们可以修改从 `module1.js` 接收到的 `module2.js`
    对象。但这样做不会改变 `module1.js` 中的值。
- en: Finding and loading CommonJS and JSON modules using require
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 require 查找和加载 CommonJS 和 JSON 模块
- en: 'We have talked about several types of modules: CommonJS, JSON, ES2015, and
    native code modules. All but the ES2015 modules are loaded using the `require`
    function. That function has a very powerful and flexible algorithm for locating
    modules within a directory hierarchy. This algorithm, coupled with the npm package
    management system, gives the Node.js platform a lot of power and flexibility.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了几种模块类型：CommonJS、JSON、ES2015 和原生代码模块。除了 ES2015 模块之外，所有模块都是使用 `require`
    函数加载的。该函数有一个非常强大且灵活的算法，用于在目录层次结构中定位模块。这个算法与 npm 包管理系统的结合，为 Node.js 平台提供了大量的功能和灵活性。
- en: File modules
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件模块
- en: The CommonJS and ES2015 modules we've just looked at are what the Node.js documentation
    describes as a **file module**. Such modules are contained within a single file,
    whose filename ends with `.js`, `.mjs`, `.json`, or `.node`. The latter are compiled
    from C or C++ source code, or even other languages such as Rust, while the former
    are of course written in JavaScript or JSON.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚查看的 CommonJS 和 ES2015 模块是 Node.js 文档中所描述的 **文件模块**。这样的模块包含在一个单独的文件中，其文件名以
    `.js`、`.mjs`、`.json` 或 `.node` 结尾。后缀为 `.node` 的模块是从 C 或 C++ 源代码编译的，或者甚至是其他语言，如
    Rust，而前者当然是用 JavaScript 或 JSON 编写的。
- en: We've already looked at several examples of using these modules, as well as
    the difference between the CommonJS format traditionally used in Node.js, and
    the new ES2015 modules that are now supported.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了一些使用这些模块的示例，以及 Node.js 中传统使用的 CommonJS 格式和现在支持的新 ES2015 模块之间的区别。
- en: Modules baked into Node.js binary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成到 Node.js 二进制中的模块
- en: Some modules are pre-compiled into the Node.js binary. These are the core Node.js
    modules documented on the Node.js website at [https://nodejs.org/api/index.html](https://nodejs.org/api/index.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块被预编译到 Node.js 二进制文件中。这些是 Node.js 网站上文档化的核心 Node.js 模块，网址为 [https://nodejs.org/api/index.html](https://nodejs.org/api/index.html)。
- en: They start out as source code within the Node.js build tree. The build process
    compiles them into the binary so that the modules are always available.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它们最初是 Node.js 构建树中的源代码。构建过程将它们编译成二进制文件，以便模块始终可用。
- en: Directories as modules
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录作为模块
- en: A module can contain a whole directory structure full of stuff. Stuff here is
    a technical term referring to internal file modules, data files, template files,
    documentation, tests, assets, and more. Once stored within a properly constructed
    directory structure, Node.js will treat these as a module that satisfies a `require('moduleName')`
    call.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块可以包含一个完整的目录结构，其中充满了各种东西。这里的“东西”是一个术语，指的是内部文件模块、数据文件、模板文件、文档、测试、资产等等。一旦存储在正确构建的目录结构中，Node.js
    将将其视为一个满足 `require('moduleName')` 调用的模块。
- en: This may be a little confusing because the word *module* is being overloaded
    with two meanings. In some cases, a module is a file, and in other cases, a module is
    a directory containing one or more file modules.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点令人困惑，因为单词 *module* 被赋予了两个含义。在某些情况下，一个 *module* 是一个文件，而在其他情况下，一个 *module*
    是一个包含一个或多个文件模块的目录。
- en: 'In most cases, a directory-as-module contains a `package.json` file. This file
    contains data about the module (known as package) that Node.js uses while loading
    the module. The Node.js runtime recognizes these two fields:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，一个作为模块的目录包含一个`package.json`文件。这个文件包含有关模块（称为包）的数据，Node.js在加载模块时使用这些数据。Node.js运行时识别这两个字段：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If this `package.json` file is in a directory named `awesomelib`, then `require('./awesomelib')`
    will load the file module in `./awesomelib/lib/awesome.js`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个`package.json`文件位于名为`awesomelib`的目录中，那么`require('./awesomelib')`将加载`./awesomelib/lib/awesome.js`中的文件模块。
- en: If there is no `package.json`, then Node.js will look for either `index.js`
    or `index.node`. In such a case, `require('./awesomelib')` will load the file
    module in `./awesomelib/index.js`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`package.json`，那么Node.js将寻找`index.js`或`index.node`。在这种情况下，`require('./awesomelib')`将加载`./awesomelib/index.js`中的文件模块。
- en: In either case, the directory module can easily contain other file modules.
    The module that's initially loaded would simply use `require('./anotherModule')` one
    or more times to load other, private modules.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，目录模块可以轻松地包含其他文件模块。最初加载的模块将简单地使用`require('./anotherModule')`一次或多次来加载其他私有模块。
- en: The npm package management system can recognize a lot more data in the `package.json` file.
    That includes the package name, its author, the home page URL, the issue-queue
    URL, package dependencies, and more. We'll go over this later.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: npm包管理系统能够在`package.json`文件中识别更多的数据。这包括包名、作者、主页URL、问题队列URL、包依赖项等等。我们稍后会介绍这一点。
- en: Module identifiers and pathnames
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块标识符和路径名
- en: Generally speaking, the module name is a pathname, but with the file extension
    removed. Earlier, when we wrote `require('./simple')`, Node.js knew to add `.js`
    to the filename and load in `simple.js`. Similarly, Node.js would recognize `simple.json`
    or `simple.node` as the filename legitimately satisfying `require('./simple')`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，模块名称是一个路径名，但去除了文件扩展名。早些时候，当我们写下`require('./simple')`时，Node.js知道要添加`.js`到文件名并加载`simple.js`。同样，Node.js会识别`simple.json`或`simple.node`作为合法满足`require('./simple')`的文件名。
- en: 'There are three types of module identifiers: relative, absolute, and top-level:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模块标识符有三种类型：相对、绝对和顶级：
- en: '**Relative module identifiers**: These begin with `./` or `../` and absolute
    identifiers begin with `/`. The module name is identical with POSIX filesystem
    semantics. The resultant pathname is interpreted relative to the location of the
    file being executed. That is, a module identifier beginning with `./` is looked
    for in the current directory, whereas one starting with `../` is looked for in
    the parent directory.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对模块标识符**：这些以`./`或`../`开头，绝对标识符以`/`开头。模块名称与POSIX文件系统语义相同。结果路径名相对于正在执行文件的当前位置进行解释。也就是说，以`./`开头的模块标识符将在当前目录中查找，而以`../`开头的则是在父目录中查找。'
- en: '**Absolute module identifiers**: These begin with`/`and are, of course, looked
    for in the root of the filesystem, but this is not a recommended practice.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绝对模块标识符**：这些以`/`开头，当然，它们在文件系统的根目录中查找，但这不是推荐的做法。'
- en: '**Top-level module identifiers**: These begin with none of those strings and
    are just the module name, or else `module-name/path/to/module`. These must be
    stored in a `node_modules` directory, and the Node.js runtime has a nicely flexible
    algorithm for locating the correct `node_modules` directory:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶级模块标识符**：这些不以任何这些字符串开头，只是模块名称，或者`module-name/path/to/module`。这些必须存储在`node_modules`目录中，Node.js运行时有一个灵活的算法来定位正确的`node_modules`目录：'
- en: In the case of `module-name/path/to/module` specifiers, what will be loaded
    is a module `path/to/module` within the top-level module named `module-name`
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`module-name/path/to/module`指定的情况下，将加载的是名为`module-name`的顶级模块中的`path/to/module`模块。
- en: The baked-in modules are specified using top-level module names
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置模块使用顶级模块名称指定
- en: The search begins in the directory containing the file calling `require()`.
    If that directory contains a `node_modules` directory, which then contains either
    a matching directory module or a matching file module, then the search is satisfied.
    If the local `node_modules` directory does not contain a suitable module, it tries
    again in the parent directory, and it will continue upward in the filesystem until
    it either finds a suitable module or it reaches the root directory.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索从调用 `require()` 的文件所在的目录开始。如果该目录包含一个 `node_modules` 目录，该目录包含匹配的目录模块或文件模块，则搜索满足。如果本地
    `node_modules` 目录不包含合适的模块，它将在父目录中再次尝试，并在文件系统中向上继续，直到找到合适的模块或达到根目录。
- en: 'That is, with a `require` call in `/home/david/projects/notes/foo.js`, the
    following directories will be consulted:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在 `/home/david/projects/notes/foo.js` 文件中进行 `require` 调用时，将会查询以下目录：
- en: '`/home/david/projects/notes/node_modules`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/david/projects/notes/node_modules`'
- en: '`/home/david/projects/node_modules`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/david/projects/node_modules`'
- en: '`/home/david/node_modules`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/david/node_modules`'
- en: '`/home/node_modules`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/node_modules`'
- en: '`/node_modules`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/node_modules`'
- en: If the module is not found through this search, there are global folders in
    which modules can be located. The first is specified in the `NODE_PATH` environment
    variable. This is interpreted as a colon-delimited list of absolute paths similar
    to the `PATH` environment variable. On Windows, the elements of `NODE_PATH` are
    of course separated by semicolons. Node.js will search those directories for a
    matching module.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过此搜索未找到模块，存在一些全局文件夹，其中可以找到模块。第一个是在 `NODE_PATH` 环境变量中指定的。这被解释为类似于 `PATH` 环境变量的冒号分隔的绝对路径列表。在
    Windows 上，`NODE_PATH` 的元素当然由分号分隔。Node.js 将在这些目录中搜索匹配的模块。
- en: The `NODE_PATH` approach is not recommended, because of surprising behavior
    which can happen if people are unaware that this variable must be set. If a specific
    module located in a specific directory referenced in `NODE_PATH` is required for
    proper function, and the variable is not set, the application will likely fail.
    As the Twelve-Factor Application model suggests, it is best for all dependencies
    to be explicitly declared, and with Node.js that means listing all dependencies
    in the `package.json` so that `npm` or `yarn` can manage the dependencies.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不推荐使用 `NODE_PATH` 方法，因为如果人们不知道这个变量必须设置，可能会出现令人惊讶的行为。如果需要特定目录中位于 `NODE_PATH`
    中引用的特定模块来正确运行，而变量未设置，应用程序可能会失败。正如十二要素应用程序模型所建议的，最好将所有依赖项明确声明，在 Node.js 中这意味着在
    `package.json` 中列出所有依赖项，以便 `npm` 或 `yarn` 可以管理依赖项。
- en: This variable was implemented before the module resolution algorithm just described
    was finalized. Because of that algorithm, `NODE_PATH` is largely unnecessary.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量是在上述模块解析算法最终确定之前实现的。由于该算法，`NODE_PATH` 大部分是不必要的。
- en: 'There are three additional locations that can hold modules:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个其他位置可以存放模块：
- en: '`$HOME/.node_modules`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$HOME/.node_modules`'
- en: '`$HOME/.node_libraries`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$HOME/.node_libraries`'
- en: '`$PREFIX/lib/node`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$PREFIX/lib/node`'
- en: In this case, `$HOME` is what you expect, the user's home directory, and `$PREFIX`
    is the directory where Node.js is installed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`$HOME` 是你所期望的，即用户的主目录，而 `$PREFIX` 是 Node.js 安装的目录。
- en: Some are beginning to recommend against using global modules. The rationale
    is the desire for repeatability and deployability. If you've tested an app, and
    all its code is conveniently located within a directory tree, you can copy that
    tree for deployment to other machines. But, what if the app depended on some other
    file that was magically installed elsewhere on the system? Will you remember to
    deploy such files?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开始建议不要使用全局模块。其理由是重复性和可部署性的需求。如果你已经测试了一个应用程序，并且所有代码都方便地位于一个目录树中，你可以复制这个树以部署到其他机器上。但是，如果应用程序依赖于系统其他地方神奇地安装的某些文件呢？你会记得部署这些文件吗？
- en: An example of application directory structure
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序目录结构的示例
- en: 'Let''s take a look at the filesystem structure of a typical Node.js Express
    application:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看典型 Node.js Express 应用程序的文件系统结构：
- en: '![](img/d5c0a49b-762d-4675-9c45-5bcd4afb99e0.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5c0a49b-762d-4675-9c45-5bcd4afb99e0.png)'
- en: This is an Express application (we'll start using Express in [Chapter 5](e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml),
    *Your First Express Application*) containing a few modules installed in the `node_modules`
    directory. One of those, Express, has its own `node_modules` directory containing
    a couple of modules.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Express 应用程序（我们将在第 5 章[Your First Express Application](e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml)中使用
    Express，其中包含了一些安装在 `node_modules` 目录中的模块。其中之一是 Express，它有自己的 `node_modules` 目录，包含了一些模块。
- en: 'For `app.js` to load `models-sequelize/notes.js`, it uses the following `require`
    call:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `app.js` 加载 `models-sequelize/notes.js`，它使用了以下 `require` 调用：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is a relative module identifier, where the pathname is resolved relative
    to the directory containing the file making the reference.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对模块标识符，其中路径名是相对于创建引用的文件所在的目录解析的。
- en: 'Use the following code to do the reverse in `models-sequelize/notes.js`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码在 `models-sequelize/notes.js` 中进行反向操作：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Again, this is a relative module identifier, this time resolved relative to
    the subdirectory containing `models-sequelize/notes.js`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一个相对模块标识符，这次是相对于包含 `models-sequelize/notes.js` 的子目录解析的。
- en: 'Any reference to a top-level module identifier will first look in the `node_modules`
    directory shown here. This directory is populated from the dependencies listed
    in the `package.json`, as we''ll see in a few pages:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对顶级模块标识符的任何引用将首先查找这里显示的 `node_modules` 目录。这个目录是从 `package.json` 中列出的依赖中填充的，正如我们将在几页后看到的：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: All of these are typical modules included in an Express application. Most of
    them are readily visible in the screenshot shown earlier. What's loaded is the
    main file in the corresponding subdirectory of `node_modules`, for example, `node_modules/express/index.js`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是 Express 应用程序中包含的典型模块。其中大部分在前面显示的截图中都可以清楚地看到。加载的是相应子目录中 `node_modules`
    的主文件，例如，`node_modules/express/index.js`。
- en: But the application cannot directly reference the dependencies of the Express
    module that are in its internal `node_modules` directory. The module search algorithm
    only moves upward in the filesystem; it does not descend into subsidiary directory
    trees.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但是应用不能直接引用其内部 `node_modules` 目录中 Express 模块的依赖。模块搜索算法只在文件系统中向上移动；它不会进入子目录树。
- en: One side effect of the upward search direction is the handling of conflicting
    dependencies.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 向上搜索方向的一个副作用是处理冲突的依赖。
- en: Suppose two modules (modules A and B) listed a dependency on the same module
    (C)?  In the normal case, the two dependencies on module C could be handled by
    the same instance of that module. As we'll see in a few pages, npm's dependency
    list in `package.json` can use loose or precise version number references. Depending
    on the current version number for module C, modules A and B may, or may not, be
    in agreement as to which version to use. If they do not agree, npm can arrange
    the module installation such that both module A and B get the version of module
    C they depend on, without either stepping on the other. If both are agreeable
    with the same module C instance, only one copy will be installed, but if they
    disagree then npm will install two copies. The two copies will be located such
    that the module search algorithm will cause each module to find the correct version
    of module C.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个模块（模块 A 和 B）列出了对同一模块（C）的依赖？在正常情况下，对模块 C 的两个依赖可以由该模块的同一实例处理。正如我们将在几页后看到的，npm
    在 `package.json` 中的依赖列表可以使用宽松或精确的版本号引用。根据模块 C 的当前版本号，模块 A 和 B 可能或可能不会就使用哪个版本达成一致。如果它们不一致，npm
    可以安排模块安装，使得模块 A 和 B 都得到它们所依赖的模块 C 的版本，而不会相互冲突。如果它们都同意使用同一模块 C 实例，则只会安装一个副本，但如果它们不一致，则
    npm 将安装两个副本。这两个副本将被放置在模块搜索算法会导致每个模块找到模块 C 正确版本的位置。
- en: 'Let''s try a concrete example to clarify what was just said. In the screenshot
    earlier, you see two instances of the `cookie` module. We can use npm to query
    for all references to this module:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来澄清刚才所说的内容。在前面显示的截图中，你可以看到 `cookie` 模块的两个实例。我们可以使用 npm 查询对这个模块的所有引用：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This says the `cookie-parser` module depends on version 0.1.3 of `cookie`, while
    Express depends on version 0.1.5\. How does npm avoid problems with these two
    conflicting versions?  By putting one inside the `node_modules` directory inside
    the `express` module. This way, when *Express* refers to this module, it will
    use the `0.1.5` instance in its own `node_modules` directory, while the `cookie-parser`
    module will use the `0.1.3` instance in the top-level `node_modules` directory.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示`cookie-parser`模块依赖于`cookie`的0.1.3版本，而Express依赖于0.1.5版本。npm如何避免这两个冲突版本的问题？通过将一个版本放在`express`模块内部的`node_modules`目录中。这样，当*Express*引用此模块时，它将使用其自己的`node_modules`目录中的`0.1.5`实例，而`cookie-parser`模块将使用顶级`node_modules`目录中的`0.1.3`实例。
- en: Finding and loading ES6 modules using import
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`import`查找和加载ES6模块
- en: The `import` statement is used to load ES6 modules, and it only works inside
    an ES6 module. Because ES6 modules are loaded asynchronously, the `require()`
    statement cannot load ES6 modules. As we said earlier, ES6 modules are recognized
    by Node.js by the `.mjs` extension.  The ECMAScript TC-39 committee has (or plans
    to) officially register that file extension with the recognized authorities so
    that regular tools will recognize both file extensions as JavaScript.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句用于加载ES6模块，并且它只能在ES6模块内部使用。因为ES6模块是异步加载的，所以`require()`语句不能加载ES6模块。正如我们之前所说的，ES6模块通过`.mjs`扩展名被Node.js识别。ECMAScript
    TC-39委员会（或计划）将此文件扩展名正式注册为已识别的权威机构，以便常规工具可以识别这两种文件扩展名作为JavaScript。'
- en: 'The module specifier one hands to the `import` statement is interpreted as
    a URL. For the time being, Node.js will only accept `file:` URL because of the
    security implications of loading modules over the Internet. Because it''s a URL,
    some characters such as `:`, `?`, `#`, or `%` must receive special treatment.
    For example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块指定符传递给`import`语句时，它被解释为一个URL。目前，由于在互联网上加载模块的安全影响，Node.js将仅接受`file:` URL。因为它是一个URL，所以一些字符如 `:`,
    `?`, `#`, 或 `%` 必须进行特殊处理。例如：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These are valid module specifiers where `?search` and `#hash` have the sort
    of meaning you'd expect in a URL. So long as Node.js only supports `file:` URL
    for `import` statements, we cannot make use of that feature, but we have to keep
    it in mind and avoid using these strings in module URL.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是有效的模块指定符，其中`?search`和`#hash`具有在URL中预期的含义。只要Node.js只为`import`语句支持`file:` URL，我们就无法使用该功能，但我们必须记住这一点，并避免在模块URL中使用这些字符串。
- en: One can install custom module loader hooks that could conceivably use those
    URL parts for some purpose.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以安装自定义模块加载钩子，这些钩子可能需要使用这些URL部分来完成某些任务。
- en: The module search algorithm is similar to what we described for `require`. If
    the specifier begins with `./`, `../`, or `/`, the specifier is interpreted as
    a pathname. Otherwise, it is interpreted as a top-level module similar to the
    `require` statement, with one big difference. The `import` statement will not
    search for a global module. This is frowned on, but if one must use a global module,
    that can be accomplished with a symbolic link.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 模块搜索算法与我们之前描述的`require`类似。如果指定符以`./`, `../`, 或 `/`开头，则指定符被解释为路径名。否则，它被解释为类似于`require`语句的顶级模块，有一个很大的区别。`import`语句将不会搜索全局模块。这是不被推荐的，但如果必须使用全局模块，可以通过符号链接来实现。
- en: For documentation, see [https://nodejs.org/api/esm.html](https://nodejs.org/api/esm.html).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有关文档，请参阅 [https://nodejs.org/api/esm.html](https://nodejs.org/api/esm.html)。
- en: Hybrid CommonJS/Node.js/ES6 module scenarios
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合CommonJS/Node.js/ES6模块场景
- en: We've gone over the format for CommonJS/Node.js modules, the format for ES6
    modules, and the algorithm for locating and importing both. The last thing to
    cover is those hybrid situations where our code will use both module formats at
    the same time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了CommonJS/Node.js模块的格式、ES6模块的格式以及定位和导入这两种模块的算法。最后要讨论的是那些混合情况，即我们的代码将同时使用这两种模块格式。
- en: 'As a practical matter, ES6 modules are very new to the Node.js platform, and
    therefore we have a large body of existing code written as CommonJS/Node.js modules.
    Many tools in the Node.js market have implementation dependencies on the CommonJS
    format. This means we''ll be facing situations where ES6 modules will need to
    use CommonJS modules, and vice versa:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，ES6模块在Node.js平台上非常新，因此我们有一大批现有的代码是以CommonJS/Node.js模块的形式编写的。Node.js市场上的许多工具都依赖于CommonJS格式。这意味着我们将面临ES6模块需要使用CommonJS模块，反之亦然的情况：
- en: CommonJS module loads other CommonJS modules with `require()`
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS模块使用`require()`来加载其他CommonJS模块。
- en: 'CommonJS module cannot load ES6 modules—except for two methods:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS模块不能加载ES6模块——除了两种方法：
- en: Dynamic import, also known as `import()`, can load an ES6 module as an asynchronous
    operation
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态导入，也称为`import()`，可以异步操作加载ES6模块。
- en: The `@std/esm` package supplies a `require()` function with one that can load
    ES6 modules as an asynchronous operation
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@std/esm`包提供了一个`require()`函数，它可以异步操作加载ES6模块。'
- en: ES6 modules load other ES6 modules with `import`, with the full semantics of
    the `import` statement
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6模块使用`import`加载其他ES6模块，具有`import`语句的完整语义。
- en: ES6 modules load CommonJS modules using `import`
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6模块使用`import`加载CommonJS模块。
- en: Therefore, out of the box, three of the scenarios are directly supported. The
    fourth is supported with a workaround module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，直接支持三种场景。第四种场景可以通过一个工作区模块得到支持。
- en: 'When an ES6 module loads a CommonJS module, its `module.exports` object is
    exposed as the `default` export of the module. This means your code uses this
    pattern:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个ES6模块加载CommonJS模块时，其`module.exports`对象作为模块的`default`导出暴露出来。这意味着你的代码使用以下模式：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is extremely similar to using a CommonJS module in another CommonJS module.
    You are simply transliterating the `require()` call into an `import` statement.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在另一个CommonJS模块中使用CommonJS模块极为相似。你只是简单地将`require()`调用转换为`import`语句。
- en: Dynamic imports with import()
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`import()`进行动态导入。
- en: ES6 modules do not cover all the requirements to fully replace Node.js/CommonJS
    modules. One of the missing capabilities is being addressed with the Dynamic Import
    feature currently on its way through the TC-39 committee.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块并没有涵盖完全替代Node.js/CommonJS模块的所有要求。其中缺失的功能之一正在通过TC-39委员会的动态导入特性得到解决。
- en: 'Support for dynamic imports landed in Node.js 9.7\. See the documentation at:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 动态导入的支持在Node.js 9.7中实现。请参阅以下文档：
- en: '[https://github.com/tc39/proposal-dynamic-import](https://github.com/tc39/proposal-dynamic-import).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/tc39/proposal-dynamic-import](https://github.com/tc39/proposal-dynamic-import)。'
- en: 'We''ll use dynamic imports to solve an issue in Chapter 7, *Data Storage and
    Retrieval*, about dynamically choosing the module to load.  In normal usage of
    the `require()` statement, can use a simple string literal to specify the module
    name.  But it is also possible to use a string literal to compute the module name,
    like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第7章“数据存储和检索”中，使用动态导入来解决动态选择要加载的模块的问题。在`require()`语句的正常使用中，可以使用一个简单的字符串字面量来指定模块名称。但也可以使用字符串字面量来计算模块名称，如下所示：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We used this technique in earlier editions of this book to dynamically choose
    between several implementations of the same model API. The ES6 `import` statement
    does not support anything but a simple string literal, and therefore cannot compute
    the module specifier like this example.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的早期版本中使用了这种技术，以动态选择同一模型API的几个实现。ES6的`import`语句不支持任何东西，而只是一个简单的字符串字面量，因此不能像这个例子那样计算模块指定器。
- en: With dynamic imports, we have an `import()` function where the module specifier
    is a regular string, letting us make a similar dynamic choice of module. Unlike
    the `require()` function, which is synchronous, `import()` is asynchronous, and
    returns a Promise. Hence, it's not a direct replacement for `require()` in that
    it's not terribly useful as a top-level function. You'll see how to use it in Chapter
    7, *Data Storage and Retrieval*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态导入，我们有一个`import()`函数，其中模块指定器是一个普通字符串，允许我们做出类似的动态模块选择。与同步的`require()`函数不同，`import()`是异步的，并返回一个Promise。因此，它不是`require()`的直接替代品，因为它作为一个顶级函数并不特别有用。你将在第7章“数据存储和检索”中看到如何使用它。
- en: Perhaps the most important feature it brings is that CommonJS modules can use
    `import()` to load an ES6 module.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它带来的最重要的特性可能是，CommonJS模块可以使用`import()`来加载ES6模块。
- en: The import.meta feature
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`import.meta`特性。'
- en: Another new feature, `import.meta`, is making its way through the TC-39 committee,
    and is being implemented for Node.js 10.x. It is an object existing within the
    scope of an ES6 module providing some metadata about the module. See [https://github.com/tc39/proposal-import-meta](https://github.com/tc39/proposal-import-meta).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新特性`import.meta`正在通过TC-39委员会，并为Node.js 10.x实现。它是一个存在于ES6模块作用域内的对象，提供了关于模块的一些元数据。见[https://github.com/tc39/proposal-import-meta](https://github.com/tc39/proposal-import-meta)。
- en: A partial implementation, supporting just `import.meta.url`, has landed in the
    Node.js source. Its use requires the `--harmony-import-meta` command-line flag.
    The content of `import.meta.url` is a fully qualified `file:` URL for the current
    module, such as `file:///Users/david/chap10/notes/app.mjs`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一个部分实现，仅支持 `import.meta.url`，已集成到 Node.js 源代码中。其使用需要 `--harmony-import-meta`
    命令行标志。`import.meta.url` 的内容是当前模块的完全限定 `file:` URL，例如 `file:///Users/david/chap10/notes/app.mjs`。
- en: Where this becomes important is that ES6 modules do not support the `__dirname`,
    `__filename`, and other global variables used historically in Node.js modules.
    The `__dirname` variable is routinely used to read in resource data from files
    sitting in the package directory. It is intended that for such cases, one parses
    the directory name out of `import.meta.url`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这变得重要的地方在于，ES6 模块不支持 Node.js 模块中历史上使用的 `__dirname`、`__filename` 和其他全局变量。`__dirname`
    变量通常用于从软件包目录中的文件读取资源数据。对于此类情况，应从 `import.meta.url` 中解析目录名称。
- en: npm - the Node.js package management system
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm - Node.js 的包管理系统
- en: As described in Chapter2, *Setting **up **Node.js*, npm is a package management
    and distribution system for Node.js. It has become the de facto standard for distributing
    modules (packages) for use with Node.js. Conceptually, it's similar to tools such
    as `apt-get` (Debian), `rpm`/`yum` (Red Hat/Fedora), `MacPorts` (macOS), `CPAN`
    (Perl), or `PEAR` (PHP). Its purpose is publishing and distributing Node.js packages
    over the Internet using a simple command-line interface. With npm, you can quickly
    find packages to serve specific purposes, download them, install them, and manage
    packages you've already installed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如第2章所述，**设置 Node.js**，npm 是 Node.js 的包管理和分发系统。它已成为使用 Node.js 分发模块（软件包）的事实标准。从概念上讲，它与
    `apt-get`（Debian）、`rpm`/`yum`（Red Hat/Fedora）、`MacPorts`（macOS）、`CPAN`（Perl）或
    `PEAR`（PHP）等工具类似。它的目的是通过简单的命令行界面在互联网上发布和分发 Node.js 软件包。使用 npm，你可以快速找到满足特定目的的软件包，下载、安装它们，并管理已安装的软件包。
- en: The `npm` application extends on the package format for Node.js, which in turn
    is largely based on the CommonJS package specification. It uses the same `package.json`
    file that's supported natively by Node.js, but with additional fields to build
    in additional functionality.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm` 应用程序扩展了 Node.js 的软件包格式，而 Node.js 的软件包格式又主要基于 CommonJS 软件包规范。它使用与 Node.js
    本地支持的相同的 `package.json` 文件，但增加了额外的字段以构建额外的功能。'
- en: The npm package format
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm 软件包格式
- en: 'An npm package is a directory structure with a `package.json` file describing
    the package. This is exactly what was referred to earlier as a directory module,
    except that npm recognizes many more `package.json` tags than Node.js does. The
    starting point for npm''s `package.json` are the CommonJS Packages/1.0 specification.
    The documentation for npm''s `package.json` implementation is accessed using the
    following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 npm 软件包是一个目录结构，包含一个描述软件包的 `package.json` 文件。这正是之前提到的目录模块，只不过 npm 识别的 `package.json`
    标签比 Node.js 多得多。npm 的 `package.json` 的起点是 CommonJS Packages/1.0 规范。可以通过以下命令访问
    npm 的 `package.json` 实现文档：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A basic `package.json` file is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的 `package.json` 文件如下：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The file is in JSON format, which, as a JavaScript programmer, you should be
    familiar with.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是 JSON 格式，作为 JavaScript 程序员，你应该熟悉这种格式。
- en: 'The most important tags are `name` and `version`. The name will appear in URLs
    and command names, so choose one that''s safe for both. If you desire to publish
    a package in the public `npm` repository, it''s helpful to check whether a particular
    name is already being used at [http://npmjs.com](http://npmjs.com) or with the
    following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的标签是 `name` 和 `version`。名称将出现在 URL 和命令中，因此请选择一个既安全又合适的名称。如果您希望将软件包发布到公共 `npm`
    仓库，检查特定名称是否已在 [http://npmjs.com](http://npmjs.com) 或以下命令中使用是有帮助的：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `main` tag is treated the same as we discussed in the previous section on
    directory modules. It defines which file module will be returned when invoking
    `require('packageName')`. Packages can contain many modules within themselves
    and they can be listed in the `modules` list.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 标签的处理方式与我们之前在目录模块部分讨论的方式相同。它定义了在调用 `require(''packageName'')` 时将返回哪个文件模块。软件包可以在自身内部包含许多模块，并且它们可以在
    `modules` 列表中列出。'
- en: Packages can be bundled as tar-gzip archives (tarballs), especially to send
    them over the internet.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包可以被打包成 tar-gzip 归档（tarball），尤其是在通过网络发送时。
- en: 'A package can declare dependencies on other packages. That way, npm can automatically
    install other modules required by the module being installed. Dependencies are
    declared as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 包可以声明对其他包的依赖。这样，npm 可以自动安装安装的模块所需的模块。依赖项如下声明：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `description` and `keyword` fields help people find the package when searching
    in an npm repository ([https://www.npmjs.com/](https://www.npmjs.com/)). Ownership
    of a package can be documented in the `homepage`, `author`, or `contributors`
    fields:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`description` 和 `keyword` 字段有助于人们在 npm 仓库 ([https://www.npmjs.com/](https://www.npmjs.com/))
    中搜索时找到包。包的所有权可以在 `homepage`、`author` 或 `contributors` 字段中记录：'
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Some `npm` packages provide executable programs meant to be in the user''s
    `PATH`. These are declared using the `bin` tag. It''s a map of command names to
    the script that implements that command. The command scripts are installed into
    the directory containing the node executable using the name given:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `npm` 包提供可执行程序，这些程序意味着它们应该位于用户的 `PATH` 中。这些程序使用 `bin` 标签声明。这是一个命令名称到实现该命令的脚本的映射。命令脚本使用给定的名称安装到包含
    node 可执行文件的目录中：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `directories` tag describes the package directory structure. The `lib`
    directory is automatically scanned for modules to load. There are other directory
    tags for binaries, manuals, and documentation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`directories` 标签描述了包的目录结构。`lib` 目录会自动扫描以加载模块。还有其他目录标签用于二进制文件、手册和文档：'
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The script tags are script commands run at various events in the life cycle
    of the package. These events include `install`, `activate`, `uninstall`, `update`,
    and more. For more information about script commands, use the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本标签是在包生命周期的各种事件中运行的脚本命令。这些事件包括 `install`、`activate`、`uninstall`、`update` 等。有关脚本命令的更多信息，请使用以下命令：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We've already used the scripts feature when showing how to set up Babel. We'll
    use these later for automating the build, test, and execution processes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在展示如何设置 Babel 时使用了脚本功能。我们将在自动化构建、测试和执行过程时使用这些脚本。
- en: This was only a taste of the npm package format; see the documentation (`npm
    help json`) for more.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 npm 包格式的尝鲜；有关更多信息，请参阅文档 (`npm help json`)。
- en: Finding npm packages
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找 npm 包
- en: 'By default, `npm` modules are retrieved over the internet from the public package
    registry maintained on [http://npmjs.com](http://npmjs.com). If you know the module
    name, it can be installed simply by typing the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`npm` 模块通过网络从 [http://npmjs.com](http://npmjs.com) 上维护的公共包注册表中检索。如果您知道模块名称，可以通过输入以下内容简单地安装它：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: But what if you don't know the module name? How do you discover the interesting
    modules? The website [http://npmjs.com](http://npmjs.com) publishes a searchable
    index of the modules in that registry.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您不知道模块名称怎么办？您如何发现有趣的模块？网站 [http://npmjs.com](http://npmjs.com) 发布了该注册表中模块的可搜索索引。
- en: 'The npm package also has a command-line search function to consult the same
    index:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: npm 包还提供了一个命令行搜索功能，用于查询相同的索引：
- en: '![](img/da103ddf-0088-4106-b1d3-7c9e1a79bc9e.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da103ddf-0088-4106-b1d3-7c9e1a79bc9e.png)'
- en: 'Of course, upon finding a module, it''s installed as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在找到模块后，它会按照以下方式安装：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After installing a module, you may want to see the documentation, which would
    be on the module''s website. The `homepage` tag in `package.json` lists that URL.
    The easiest way to look at the `package.json` file is with the `npm view` command,
    as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 安装模块后，您可能想查看文档，这些文档通常位于模块的网站上。`package.json` 中的 `homepage` 标签列出了该 URL。查看 `package.json`
    文件的最简单方法是使用 `npm view` 命令，如下所示：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can use `npm view` to extract any tag from `package.json`, like the following,
    which lets you view just the `homepage` tag:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `npm view` 从 `package.json` 中提取任何标签，如下所示，这可以让您仅查看 `homepage` 标签：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Other fields in the `package.json` can be viewed by simply giving the desired
    tag name.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 中的其他字段可以通过简单地给出所需的标签名称来查看。'
- en: Other npm commands
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他 npm 命令
- en: The main `npm` command has a long list of subcommands for specific package management
    operations. These cover every aspect of the life cycle of publishing packages
    (as a package author), and downloading, using, or removing packages (as an npm
    consumer).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 `npm` 命令有一系列子命令，用于特定的包管理操作。这些涵盖了发布包（作为包作者）的生命周期中的各个方面，以及下载、使用或删除包（作为 npm
    消费者）。
- en: 'You can view the list of these commands just by typing `npm` (with no arguments).
    If you see one you want to learn more about, view the help information:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需输入 `npm`（不带参数）即可查看这些命令的列表。如果您想了解更多关于某个命令的信息，请查看帮助信息：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Installing an npm package
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 npm 包
- en: 'The `npm install` command makes it easy to install packages upon finding the
    one of your dreams, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当您找到心仪的包时，`npm install`命令可以轻松地安装包，如下所示：
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The named module is installed in `node_modules` in the current directory. The
    specific version installed depends on any version number listed on the command
    line, as we see in the next section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 命名模块安装在本目录的`node_modules`中。安装的具体版本取决于命令行上列出的任何版本号，正如我们在下一节中看到的。
- en: Installing a package by version number
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按版本号安装包
- en: 'Version number matching in npm is powerful and flexible. The same sort of version
    specifiers used in `package.json` dependencies can also be used with the `npm
    install` command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: npm中的版本号匹配功能强大且灵活。在`package.json`依赖中使用的相同类型的版本指定符也可以与`npm install`命令一起使用：
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The last two are what they sound like. You can specify `express@4.16.2` to target
    a precise version, or `express@">4.1.0 < 5.0"` to  target a range of Express V4
    versions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个选项正如其名。您可以指定`express@4.16.2`以定位精确版本，或`express@">4.1.0 < 5.0"`以定位Express
    V4版本的范围内。
- en: 'The version match specifiers include these choices:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 版本匹配指定符包括以下选项：
- en: '**Exact version match**: 1.2.3'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确版本匹配**：1.2.3'
- en: '**At least version N**: >1.2.3'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**至少版本N**：>1.2.3'
- en: '**Up to version N**: <1.2.3'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**至版本N**：<1.2.3'
- en: '**Between two releases**: >=1.2.3 <1.3.0'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两个版本之间**：>=1.2.3 <1.3.0'
- en: The `@tag` attribute is a symbolic name such as `@latest`, `@stable`, or `@canary`.
    The package owner assigns these symbolic names to specific version numbers, and
    can reassign them as desired. The exception is `@latest`, which is updated whenever
    a new release of the package is published.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`@tag`属性是一个符号名称，例如`@latest`、`@stable`或`@canary`。包所有者将这些符号名称分配给特定的版本号，并且可以根据需要重新分配它们。例外是`@latest`，每当发布包的新版本时，它都会被更新。'
- en: For more documentation, run these commands: `npm help json` and `npm help npm-dist-tag`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多文档，请运行以下命令：`npm help json`和`npm help npm-dist-tag`。
- en: Global package installs
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局包安装
- en: 'In some instances you want to install a module globally, so that it can be
    used from any directory. For example, the Grunt or Gulp build tools are widely
    useful, and conceivably you will find it useful if these tools are installed globally.
    Simply add the `-g` option:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望全局安装一个模块，以便可以从任何目录中使用它。例如，Grunt或Gulp构建工具非常实用，如果这些工具全局安装，您可能会发现它们很有用。只需添加`-g`选项：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you get an error, and you''re on a Unix-like system (Linux/Mac), you may
    need to run this with `sudo`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到错误，并且您在类Unix系统（Linux/Mac）上，您可能需要使用`sudo`运行此命令：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: A global install is most important for those packages which install executable
    commands. We'll get into this shortly.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些安装可执行命令的包来说，全局安装尤为重要。我们很快就会讨论这个问题。
- en: 'If a local package install lands in `node_modules`, where does a global package
    install land?  On a Unix-like system it lands in `PREFIX/lib/node_modules`, and
    on Windows it lands in `PREFIX/node_modules`. In this case PREFIX means the directory
    where Node.js is installed. You can inspect the location of this directory like
    so:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本地包安装到`node_modules`中，那么全局包安装会到哪里？在类Unix系统中，它位于`PREFIX/lib/node_modules`，在Windows系统中，它位于`PREFIX/node_modules`。在这种情况下，PREFIX是指Node.js安装的目录。您可以像这样检查此目录的位置：
- en: '[PRE55]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The algorithm used by Node.js for the `require` function automatically searches
    this directory for packages if the package is not found elsewhere.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中`require`函数使用的算法会自动搜索此目录以查找包，如果在其他地方找不到该包。
- en: Remember that ES6 modules do not support global packages.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，ES6模块不支持全局包。
- en: Avoiding global module installation
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免全局模块安装
- en: Some in the Node.js community now frown on installing a package globally. One
    rationale exists in the Twelve Factor model. Namely, a software project is more
    reliable if all its dependencies are explicitly declared. If a build tool such
    as Grunt is required, but is not explicitly declared in `package.json`, the users
    of the application would have to receive instructions to install Grunt, and they
    would have to follow those instructions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Node.js社区中的一些人开始对全局安装包表示不满。十二要素模型中存在一个合理的理由。也就是说，如果一个软件项目的所有依赖都明确声明，那么这个项目将更加可靠。如果需要像Grunt这样的构建工具，但它在`package.json`中没有明确声明，那么应用程序的用户将需要收到安装Grunt的指示，并且他们必须遵循这些指示。
- en: Users being users, they might skip over the instructions, fail to install the
    dependency, and then complain the application doesn't work. Surely most of us
    have done that once or twice.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 用户作为用户，他们可能会跳过指示，未能安装依赖项，然后抱怨应用程序无法工作。当然，我们大多数人可能都这样做过一两次。
- en: It's recommended to avoid this potential problem by installing everything locally
    via one mechanism—the `npm install` command.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 建议通过一种机制（即 `npm install` 命令）在本地安装所有内容，以避免这种潜在的问题。
- en: Maintaining package dependencies with npm
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 npm 维护包依赖项
- en: As we mentioned earlier, the `npm install` command by itself installs the packages
    listed in the `dependencies` section of `package.json`. This is easy and convenient.
    Simply by listing all the dependencies, it's quick and easy to install the dependencies
    required for using the package. What happens is npm looks in `package.json` for
    the `dependencies` or `devDependencies` field, and it will automatically install
    the mentioned packages.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`npm install` 命令本身会安装 `package.json` 中 `dependencies` 部分列出的包。这很简单且方便。只需列出所有依赖项，就可以快速轻松地安装使用该包所需的依赖项。实际上，npm
    会查找 `package.json` 中的 `dependencies` 或 `devDependencies` 字段，并会自动安装提到的包。
- en: 'You can manage the dependencies manually by editing `package.json`. Or you
    can use npm to assist you with editing the dependencies. You can add a new dependency
    like so:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过编辑 `package.json` 来手动管理依赖项。或者，您可以使用 npm 帮助您编辑依赖项。您可以添加新的依赖项，如下所示：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In response, npm will add a `dependencies` tag to `package.json`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，npm 将在 `package.json` 中添加一个 `dependencies` 标签：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, when your application is installed, `npm` will automatically also install
    that package along with any `dependencies` listed by that package.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你的应用程序被安装时，`npm` 会自动安装该包以及该包列出的任何 `dependencies`。
- en: The `devDependencies` are modules used during development. That field is initialized
    the same as above, but with the `--save-dev` flag.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`devDependencies` 是在开发过程中使用的模块。该字段与上面初始化的方式相同，但使用 `--save-dev` 标志。'
- en: 'By default, when an `npm` install is run, modules listed in both `dependencies` and `devDependencies` are
    installed. Of course, the purpose for having two lists is to not install the `devDependencies` in
    some cases:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当运行 `npm install` 命令时，会安装同时列在 `dependencies` 和 `devDependencies` 中的模块。当然，设置两个列表的目的是在某些情况下不安装
    `devDependencies`：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This installs only the modules listed in `dependencies` and none of the `devDependencies` modules.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会安装列在 `dependencies` 中的模块，而不会安装任何 `devDependencies` 模块。
- en: In the Twelve-Factor application model, it's suggested that we explicitly identify
    the dependencies required by the application. This way we can reliably build our
    application, knowing that we've tested against a specific set of dependencies
    that we've carefully identified. By installing exactly the dependencies against
    which the application has been tested, we have more confidence in the application.
    On the Node.js platform, npm gives us this dependencies section, including a flexible
    mechanism to declare compatible package versions by their version number.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在十二要素应用程序模型中，建议我们明确标识应用程序所需的依赖项。这样我们就可以可靠地构建我们的应用程序，因为我们已经针对我们仔细识别的特定依赖项进行了测试。通过安装针对应用程序已测试的精确依赖项，我们对应用程序的信心更大。在
    Node.js 平台上，npm 给我们提供了这个依赖项部分，包括通过版本号声明兼容包版本的灵活机制。
- en: Automatically updating package.json dependencies
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动更新 package.json 依赖项
- en: 'With npm@5 (also known as npm version 5), one change was that it''s no longer
    required to add `--save` to the `npm install` command. Instead, `npm` by default
    acts as if you ran the command with `--save`, and will automatically add the dependency
    to your `package.json`. This is meant to simplify using `npm`, and it is arguably
    more convenient that `npm` now does this. At the same time it can be very surprising
    and inconvenient for `npm` to go ahead and modify `package.json` for you. The
    behavior can be disabled by using the `--no-save` flag. This behavior can be permanently
    disabled using the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 npm@5（也称为 npm 版本 5）中，一个变化是不再需要在 `npm install` 命令中添加 `--save`。相反，`npm` 默认会像你运行了带有
    `--save` 的命令一样操作，并自动将依赖项添加到你的 `package.json` 中。这是为了简化使用 `npm`，并且可以说现在这样做更加方便。同时，`npm`
    自动修改 `package.json` 可能会非常令人惊讶且不便。可以通过使用 `--no-save` 标志来禁用此行为。此行为可以通过以下方式永久禁用：
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `npm config` command supports a long list of settable options for tuning
    behavior of npm. See `npm help config` for the documentation, and `npm help 7
    config` for the list of options.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm config` 命令支持一系列可设置的选项，用于调整 npm 的行为。请参阅 `npm help config` 获取文档，以及 `npm
    help 7 config` 获取选项列表。'
- en: Fixing bugs by updating package dependencies
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过更新包依赖项修复错误
- en: Bugs exist in every piece of software. An update to the Node.js platform may
    break an existing package, as might an upgrade to packages used by the application.
    Your application may trigger a bug in a package it uses. In these and other cases,
    fixing the problem might be as simple as updating a package dependency to a later
    (or earlier) version.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件包都存在错误。Node.js平台的更新可能会破坏现有的软件包，同样，应用程序使用的软件包的升级也可能导致问题。您的应用程序可能会触发它使用的软件包中的错误。在这些和其他情况下，解决问题可能只需将软件包依赖项更新到较新（或较旧）的版本。
- en: First identify whether the problem exists in the package or in your code. After
    determining it's a problem in another package, investigate whether the package
    maintainers have already fixed the bug. Is the package hosted on GitHub or another
    service with a public issue queue? Look for an open issue on this problem. That
    investigation will tell you whether to update the package dependency to a later
    version. Sometimes, it will tell you to revert to an earlier version; for example,
    if the package maintainer introduced a bug that doesn't exist in an earlier version.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确定问题存在于软件包还是您的代码中。在确定问题是另一个软件包的问题后，调查软件包维护者是否已经修复了该错误。该软件包托管在GitHub或其他带有公共问题队列的服务上吗？寻找有关此问题的开放问题。这项调查将告诉您是否需要将软件包依赖项更新到较新版本。有时，它将告诉您回滚到较旧版本；例如，如果软件包维护者在较旧版本中引入了不存在的问题。
- en: Sometimes, you will find that the package maintainers are unprepared to issue
    a new release. In such a case, you can fork their repository and create a patched
    version of their package.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会发现软件包维护者没有准备好发布新版本。在这种情况下，您可以分叉他们的存储库并创建他们软件包的修补版本。
- en: 'One approach to fixing this problem is **pinning** the package version number
    to one that''s known to work. You might know that version 6.1.2 was the last release
    against which your application functioned, and that starting with version 6.2.0
    your application breaks. Hence, in `package.json`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是将软件包版本号**锁定**到一个已知可以工作的版本。您可能知道版本6.1.2是您的应用程序最后一次使用的版本，而从版本6.2.0开始，您的应用程序会崩溃。因此，在`package.json`中：
- en: '[PRE60]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This freezes your dependency to the specific version number. You're free, then,
    to take your time updating your code to work against later releases of that module.  Once
    your code is updated, or the upstream project is updated, change the dependency
    appropriately.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就冻结了您对该特定版本号的依赖。然后，您可以自由地花时间更新您的代码，以便与该模块的后续版本兼容。一旦您的代码更新，或者上游项目更新，就相应地更改依赖项。
- en: Another approach is to host a version of the package somewhere outside of the
    npm repository. This is covered in a later section.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将软件包的版本托管在npm存储库之外的地方。这将在后面的章节中介绍。
- en: Packages that install commands
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装命令的软件包
- en: Some packages install command-line programs. A side effect of installing such
    packages is a new command that you can type at the shell prompt or use in shell
    scripts. An example is the hexy program that we briefly used in Chapter 2, *Setting
    up Node.js*. Another example is the widely used Grunt or Gulp build tools.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件包会安装命令行程序。安装此类软件包的一个副作用是在shell提示符下可以输入的新命令或可以在shell脚本中使用的新命令。例如，我们在第2章“设置Node.js”中简要使用过的hexy程序。另一个例子是广泛使用的Grunt或Gulp构建工具。
- en: 'The `package.json` file in such packages specifies the command-line tools that
    are installed. The command can be installed to one of two places:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类软件包中，`package.json`文件指定了已安装的命令行工具。命令可以安装到以下两个位置之一：
- en: '**Global Install**: It is installed either to a directory such as `/usr/local`,
    or to the `bin` directory where Node.js was installed. The `npm bin -g` command
    tells you the absolute pathname for this directory.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局安装**：它安装到诸如`/usr/local`之类的目录，或者安装到Node.js安装的`bin`目录。`npm bin -g`命令会告诉您此目录的绝对路径名。'
- en: '**Local Install**: To `node_modules/.bin` in the package where the module is
    being installed. The `npm bin` command tells you the absolute pathname for this
    directory.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地安装**：将命令安装到正在安装模块的软件包中的`node_modules/.bin`目录。`npm bin`命令会告诉您此目录的绝对路径名。'
- en: To run the command, simply type the command name at a shell prompt. Except there's
    a little bit of configuration required to make that simple.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行命令，只需在shell提示符下输入命令名称即可。不过，为了使这个过程变得简单，需要进行一些配置。
- en: Configuring the PATH variable to handle commands installed by modules
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置PATH变量以处理由模块安装的命令
- en: Typing the full pathname is not a user-friendly requirement to execute the command.
    We want to use the commands installed by modules, and we want a simple process
    for doing so. Meaning, we must add an appropriate value in the `PATH` variable,
    but what is it?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 输入完整的路径名并不是执行命令的用户友好要求。我们希望使用模块安装的命令，并希望有一个简单的过程来做到这一点。也就是说，我们必须在`PATH`变量中添加适当的值，但那是什么？
- en: For global package installations, the executable lands in a directory that is
    probably already in your `PATH` variable, like `/usr/bin` or `/usr/local/bin`.
    Local package installations are what require special handling. The full path for
    the `node_modules/.bin` directory varies for each project, and obviously it won't
    work to add the full path for every `node_modules/.bin` directory to your `PATH`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于全局包安装，可执行文件会落在可能已经在您的`PATH`变量中的目录中，如`/usr/bin`或`/usr/local/bin`。本地包安装需要特殊处理。`node_modules/.bin`目录的完整路径对于每个项目都是不同的，显然，将每个`node_modules/.bin`目录的完整路径添加到您的`PATH`中是不可行的。
- en: Adding `./node_modules/.bin` to the `PATH` variable (or, on Windows, `.\node_modules\.bin`)
    works great. Any time your shell is in the root of a Node.js project, it will
    automatically find locally-installed commands from Node.js packages.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 将`./node_modules/.bin`添加到`PATH`变量中（或者在Windows上为`.\node_modules\.bin`）效果很好。每次当您的shell位于Node.js项目的根目录时，它将自动找到本地安装的Node.js包中的命令。
- en: How we do this depends on the command shell you use, and your operating system.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何做这取决于您使用的命令shell和操作系统。
- en: 'On a Unix-like system the command shells are `bash` and `csh`. Your `PATH`
    variable would be set up in one of these ways:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在类Unix系统中，命令shell是`bash`和`csh`。您的`PATH`变量将按照以下方式之一设置：
- en: '[PRE61]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The next step is adding the command to your login scripts so the variable is
    always set. On `bash`, add the corresponding line to your `~/.bashrc`, and on
    `csh` add it to your `~/.cshrc`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将命令添加到您的登录脚本中，以便变量始终设置。在`bash`中，将相应的行添加到您的`~/.bashrc`中，在`csh`中添加到您的`~/.cshrc`中。
- en: Configuring the PATH variable on Windows
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上配置`PATH`变量
- en: 'On Windows, this task is handled through a system-wide settings panel:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，这项任务通过系统设置面板来处理：
- en: '![](img/a75f2b97-76d6-4507-82e1-45df40c66272.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a75f2b97-76d6-4507-82e1-45df40c66272.png)'
- en: This pane of the System Properties panel is found by searching for `PATH` in
    the Windows Settings screen. Click on the Environment Variables button, then select
    the Path variable, and finally click on the Edit button. In the screen here click
    the New button to add an entry to this variable, and enter `.\node_modules\.bin` as
    shown. You'll have to restart any open command shell windows. Once you do, the
    effect will be as shown previously.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Windows设置屏幕中搜索`PATH`来找到系统属性面板的这个面板。点击环境变量按钮，然后选择`Path`变量，最后点击编辑按钮。在此屏幕中，点击新建按钮向此变量添加条目，并输入如所示`.\node_modules\.bin`。您将不得不重新启动任何打开的命令shell窗口。一旦这样做，效果将如之前所示。
- en: Avoiding modifications to the PATH variable
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免修改`PATH`变量
- en: What if you don't want to add these variables to your `PATH` at all times? 
    The `npm-path` module may be of interest. This is a small program that computes
    the correct `PATH` variable for your shell and operating system. See the package
    at  [https://www.npmjs.com/package/npm-path](https://www.npmjs.com/package/npm-path).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想始终将这些变量添加到您的`PATH`中，那么`npm-path`模块可能对您有所帮助。这是一个小型程序，它会为您计算正确的`PATH`变量，适用于您的shell和操作系统。请参阅该软件包[https://www.npmjs.com/package/npm-path](https://www.npmjs.com/package/npm-path)。
- en: Updating outdated packages you've installed
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新您已安装的过时包
- en: The coder codes, updating their package, leaving you in their dust unless you
    keep up.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员编写代码，更新他们的包，除非您跟上，否则您会被甩在后面。
- en: 'To find out if your installed packages are out of date, use the following command:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出您的已安装包是否过时，请使用以下命令：
- en: '[PRE62]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The report shows the current npm packages, the currently-installed version,
    as well as the current version in the `npm` repository. Updating the outdated
    packages is very simple:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 报告显示了当前npm包、当前安装的版本以及`npm`仓库中的当前版本。更新过时的包非常简单：
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Installing packages from outside the npm repository
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从npm仓库外部安装包
- en: 'As awesome as the npm repository is, we don''t want to push everything we do
    through their service. This is especially true for internal development teams
    who cannot publish their code for all the world to see. While you can rent or
    install a private npm repository, there''s another way. Packages can be installed
    from other locations. Details about this are in `npm help package.json` in the `dependencies`
    section. Some examples are:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管npm仓库很棒，但我们不希望将我们做的所有事情都通过他们的服务推送。这对于无法让全世界看到其代码的内部开发团队来说尤其如此。虽然您可以租赁或安装私有npm仓库，但还有另一种方法。可以从其他位置安装包。有关详细信息，请参阅`npm
    help package.json`中的`dependencies`部分。一些示例包括：
- en: '**URL**: You can specify any URL that downloads a tarball, that is, a `.tar.gz` file.
    For example, GitHub or GitLab repositories can easily export tarball URL. Simply
    go to the Releases tab to find them.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**: 您可以指定任何下载tar包的URL，即`.tar.gz`文件。例如，GitHub或GitLab仓库可以轻松导出tar包URL。只需转到“发布”标签即可找到它们。'
- en: '**Git URL**: Similarly, any Git repository can be accessed with the right URL.
    For example:'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git URL**: 类似地，任何Git仓库都可以使用正确的URL访问。例如：'
- en: '[PRE64]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**GitHub Shortcut**: For GitHub repositories you can list just the repository
    specifier, such as `expressjs/express`.  A tag or a commit can be referenced using
    `expressjs/express#tag-name`.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub快捷方式**: 对于GitHub仓库，您可以仅列出仓库指定符，例如`expressjs/express`。可以使用`expressjs/express#tag-name`引用标签或提交。'
- en: '**Local filesystem**: You can install from a local directory using a URL like
    this:  `file:../../path/to/dir`.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地文件系统**: 您可以使用类似这样的URL从本地目录安装：`file:../../path/to/dir`。'
- en: Initializing a new npm package
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化新的npm包
- en: If you want to create a new package, you can create the `package.json` file
    by hand or you can get npm's help. The `npm init` command leads you through a
    little dialog to get starting values for the `package.json` file.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建一个新的包，您可以手动创建`package.json`文件，或者您可以使用npm的帮助。`npm init`命令会引导您通过一个小对话框，以获取`package.json`文件的起始值。
- en: Once you get through the questions, the `package.json` file is written to disk.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成这些问题，`package.json`文件就会被写入磁盘。
- en: 'Expect to have to edit that file considerably before publishing to the npm
    repository. A few fields help give a good impression to folks looking at the package
    listing on `npmjs.com`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 预计在发布到npm仓库之前，您需要相当程度地编辑该文件。一些字段有助于给查看`npmjs.com`上包列表的人留下好印象：
- en: Link to the home page, and issue queue URL
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接到主页和问题队列URL
- en: Keywords, so it can be linked with other similar packages
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字，以便它可以与其他类似包链接
- en: A good description that helps folks understand the purpose
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的描述，有助于人们了解其目的
- en: A good `README.md` file so folks can read some documentation right away
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的`README.md`文件，以便人们可以立即阅读一些文档
- en: Declaring Node.js version compatibility
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明Node.js版本兼容性
- en: It's important that your Node.js software runs on the correct version of Node.js. 
    The primary reason being when new features are added to the platform.  You'll
    want to use those new features, whether it is the async functions added in 8.x
    or the ES Modules supported added in 10.x.  We need a way to declare the Node.js
    version required to run our software.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Node.js软件运行在正确的Node.js版本上非常重要。主要原因是当平台添加新功能时。您将想要使用这些新功能，无论是8.x中添加的异步函数还是10.x中支持的ES模块。我们需要一种方法来声明运行我们的软件所需的Node.js版本。
- en: 'This dependency is declared in `package.json` using the `engines` tag:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此依赖项使用`package.json`中的`engines`标签声明：
- en: '[PRE65]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This, of course, uses the same version number matching scheme discussed earlier.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这使用的是之前讨论过的相同版本号匹配方案。
- en: Publishing an npm package
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布npm包
- en: All those packages in the npm repository came from people like you with an idea
    of a better way of doing something. It is very easy to get started with publishing
    packages. Online docs can be found at [https://docs.npmjs.com/getting-started/publishing-npm-packages](https://docs.npmjs.com/getting-started/publishing-npm-packages).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: npm仓库中的所有这些包都来自像您这样的人，他们有更好的做事方式的想法。开始发布包非常容易。在线文档可以在[https://docs.npmjs.com/getting-started/publishing-npm-packages](https://docs.npmjs.com/getting-started/publishing-npm-packages)找到。
- en: You first use the `npm adduser` command to register yourself with the npm repository.
    You can also sign up with the website. Next, you log in using the `npm login`
    command.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先使用`npm adduser`命令在npm仓库中注册自己。您也可以通过网站注册。接下来，使用`npm login`命令登录。
- en: Finally, while sitting in the package root directory, use the `npm publish`
    command. Then, stand back so that you don't get stampeded by the crush of thronging
    fans. Or, maybe not. There are almost 600,000 packages in the repository, with
    almost 400 packages added every day. To get yours to stand out, you will require
    some marketing skill, which is another topic beyond the scope of this book.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你坐在包根目录中时，使用`npm publish`命令。然后，退后一步，以免被涌动的粉丝冲撞。或者，也许不是。仓库中几乎有600,000个包，每天几乎有400个包被添加。要让你的包脱颖而出，你需要一些营销技巧，这是本书范围之外的另一个话题。
- en: Explicitly specifying package dependency version numbers
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明确指定包依赖版本号
- en: One feature of the Twelve-Factor methodology is step two, explicitly declaring
    your dependencies. We've already touched on this, but it's worth reiterating and
    to seeing npm makes this easy to accomplish.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素方法的一个特点是第二步，明确声明你的依赖。我们已经提到了这一点，但值得重申，并看到npm使这一任务变得容易完成。
- en: Step one of the Twelve-Factor methodology is ensuring that your application
    code is checked into a source code repository. You probably already know this,
    and even have the best of intentions to ensure that everything is checked in.
    With Node.js, each module should have its own repository rather than putting every
    single last piece of code in one repository.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素方法的第一步是确保你的应用程序代码被提交到一个源代码仓库中。你可能已经知道了这一点，甚至有最好的意图来确保所有内容都被提交。在使用Node.js时，每个模块应该有自己的仓库，而不是把所有代码都放在一个仓库中。
- en: Each module can then progress on its own timeline. A breakage in one module
    is easy to back out by changing the version dependency in `package.json`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个模块可以按照自己的时间表独立进展。一个模块的故障可以通过在`package.json`中更改版本依赖来轻松回滚。
- en: This gets us to Twelve-Factor step two. There are two aspects of this step,
    one of which is the package versioning that we discussed previously. The next
    is explicitly declaring version numbers, which can be declared in `dependencies`
    and `devDependencies` sections of `package.json`. This ensures that everyone on
    the team is on the same page, developing against the same versions of the same
    modules. When it's time to deploy to testing, staging, or production servers,
    and the deployment script runs `npm install` or `npm update`, the code will use
    a known version of the module that everyone tested against.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了十二要素的第二步。这一步有两个方面，其中一个是之前讨论过的包版本控制。接下来是明确声明版本号，这可以在`package.json`文件的`dependencies`和`devDependencies`部分声明。这确保了团队中的每个人都处于同一页面，针对相同模块的相同版本进行开发。当需要部署到测试、预发布或生产服务器时，部署脚本运行`npm
    install`或`npm update`，代码将使用已知版本的模块，这是每个人都测试过的。
- en: The lazy way of declaring dependencies is putting `*` in the version field.
    That uses the latest version in the npm repository. Maybe this will work, until
    one day the maintainers of that package introduce a bug. You'll type `npm update`,
    and all of a sudden your code doesn't work. You'll head over to the GitHub site
    for the package, look in the issue queue, and possibly see that others have already
    reported the problem you're seeing. Some of them will say that they've pinned
    on the previous release until this bug is fixed. What that means is their `package.json`
    file does not depend on `*` for the latest version, but on a specific version
    number before the bug was created.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 声明依赖的懒惰方式是在版本字段中放置`*`。这使用npm仓库中的最新版本。也许这会工作，直到有一天该包的维护者引入了一个错误。你将输入`npm update`，突然你的代码就不再工作了。你将前往该包的GitHub网站，查看问题队列，可能会看到其他人已经报告了你遇到的问题。其中一些人会表示，他们已经锁定在之前的版本上，直到这个错误被修复。这意味着他们的`package.json`文件不是依赖于`*`的最新版本，而是依赖于错误创建之前的特定版本号。
- en: Don't do the lazy thing, do the smart thing.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 不要做懒惰的事情，要做聪明的事情。
- en: The other aspect of explicitly declaring dependencies is to not implicitly depend
    on global packages. Earlier, we said that some in the Node.js community caution
    against installing modules in the global directories. This might seem like an
    easy shortcut to sharing code between applications. Just install it globally,
    and you don't have to install the code in each application.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 明确声明依赖的另一个方面是不要隐式地依赖于全局包。之前我们提到，Node.js社区中的一些人警告不要在全局目录中安装模块。这看起来像是一个在应用程序之间共享代码的简单捷径。只需全局安装，你就不必在每个应用程序中安装代码。
- en: But, doesn't that make deployment harder? Will the new team member be instructed
    on all the special files to install here and there to make the application run?
    Will you remember to install that global module on all destination machines?
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这不会使部署更困难吗？新团队成员会被指导安装所有特殊的文件来使应用程序运行吗？你会记得在所有目标机器上安装那个全局模块吗？
- en: For Node.js, that means listing all the module dependencies in `package.json`,
    and then the installation instructions are simply `npm install`, followed perhaps
    by editing a configuration file.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Node.js来说，这意味着在`package.json`中列出所有模块依赖项，然后安装说明就是简单地`npm install`，可能还会编辑配置文件。
- en: The Yarn package management system
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Yarn包管理系统
- en: As powerful as npm is, it is not the only package management system for Node.js.
    Because the Node.js core team does not dictate a package management system, the
    Node.js community is free to roll up their sleeves and develop any system they
    feel best. That the vast majority of us use npm is a testament to its value and
    usefulness. But there is a competitor.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管npm功能强大，但它并不是Node.js的唯一包管理系统。因为Node.js核心团队没有指定包管理系统，Node.js社区可以自由地卷起袖子，开发他们认为最好的任何系统。我们中的绝大多数人使用npm是对其价值和有用性的证明。但有一个竞争对手。
- en: Yarn (see [https://yarnpkg.com/en/](https://yarnpkg.com/en/)) is a collaboration
    between engineers at Facebook, Google, and several other companies. They proclaim
    that Yarn is ultra fast, ultra-secure (by using checksums of everything), and
    ultra reliable (by using a `yarn-lock.json` file to record precise dependencies).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Yarn（见[https://yarnpkg.com/en/](https://yarnpkg.com/en/））是Facebook、Google和其他几家公司的工程师之间的合作。他们宣称Yarn非常快，非常安全（通过使用所有内容的校验和），非常可靠（通过使用`yarn-lock.json`文件来记录精确的依赖关系）。
- en: Instead of running their own package repository, Yarn runs on top of npm's package
    repository at `npmjs.com`. This means that the Node.js community is not forked
    by Yarn, but enhanced by having an improved package management tool.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Yarn不是运行自己的包仓库，而是在`npmjs.com`上的npm包仓库之上运行。这意味着Node.js社区没有被Yarn分叉，而是通过拥有一个改进的包管理工具而得到增强。
- en: The npm team responded to Yarn in npm@5 (also known as npm version 5) by improving
    performance, and by introducing a `package-lock.json` file to improve reliability. 
    The npm team have announced additional improvements in npm@6.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: npm团队在npm@5（也称为npm版本5）中回应了Yarn，通过提高性能，并引入`package-lock.json`文件来提高可靠性。npm团队在npm@6中宣布了额外的改进。
- en: Yarn has become very popular and is widely recommended over npm. They perform
    extremely similar functions, and the performance is not that different to npm@5\.
    The command-line options are worded differently. An important benefit Yarn brings
    to the Node.js community is that competition between Yarn and npm seems to be
    breeding faster advances in Node.js package management.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Yarn已经变得非常流行，并且比npm更受欢迎。它们执行的功能极其相似，性能与npm@5没有太大差异。命令行选项的措辞不同。Yarn带给Node.js社区的一个重要好处是，Yarn和npm之间的竞争似乎正在催生Node.js包管理的更快进步。
- en: 'To get you started, these are the most important commands:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你开始，以下是最重要的命令：
- en: '`yarn add`: Adds a package to use in your current package'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn add`：将包添加到当前包中使用'
- en: '`yarn init`: Initializes the development of a package'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn init`：初始化包的开发'
- en: '`yarn install`: Installs all the dependencies defined in a `package.json` file'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn install`：安装`package.json`文件中定义的所有依赖项'
- en: '`yarn publish`: Publishes a package to a package manager'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn publish`：将包发布到包管理器'
- en: '`yarn remove`: Removes an unused package from your current package'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn remove`：从当前包中移除一个未使用的包'
- en: Running `yarn` by itself does the `yarn install` behavior. There are several
    other commands in Yarn, and `yarn help` will list them all.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 单独运行`yarn`会执行`yarn install`行为。Yarn中还有其他几个命令，`yarn help`会列出它们。
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about modules and packages for Node.js.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中学到了很多关于Node.js模块和包的知识。
- en: Specifically, we covered implementing modules and packages for Node.js, managing
    installed modules and packages, and saw how Node.js locates modules.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了Node.js模块和包的实现、管理已安装的模块和包，以及看到了Node.js如何定位模块。
- en: Now that you've learned about modules and packages, we're ready to use them
    to build applications, which is the topic of the next chapter.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了模块和包，我们准备使用它们来构建应用程序，这是下一章的主题。
