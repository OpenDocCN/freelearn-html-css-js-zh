- en: WebGL 2 Highlights
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL 2 突出特点
- en: In this book, we have covered the foundations of computer graphics with WebGL
    2, the web-based 3D Graphics API that ships with all modern browsers. We learned
    that WebGL 1 is based on OpenGL ES 2.0, while WebGL 2 is based on OpenGL ES 3.0,
    which guarantees many features that are offered in WebGL 1 as *optional* extensions,
    along with many other powerful methods. Although we’ve used WebGL 2 to learn a
    wide range of computer graphics topics, almost all that knowledge and all of those
    skills translate to other graphics APIs. That being said, let’s take a moment
    to cover the key features that WebGL 2 provides over WebGL 1, along with a strategy
    for migration from WebGL 1 to WebGL 2.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用 WebGL 2 覆盖了计算机图形学的基础，这是所有现代浏览器都内置的基于网络的 3D 图形 API。我们了解到 WebGL 1 基于
    OpenGL ES 2.0，而 WebGL 2 基于 OpenGL ES 3.0，这保证了 WebGL 1 中作为 *可选* 扩展提供的许多特性，以及许多其他强大的方法。尽管我们使用
    WebGL 2 学习了广泛的计算机图形学主题，但几乎所有这些知识和技能都可以转移到其他图形 API 上。因此，让我们花一点时间来介绍 WebGL 2 相比
    WebGL 1 提供的关键特性，以及从 WebGL 1 迁移到 WebGL 2 的策略。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: A more extensive look at the WebGL 2 API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 WebGL 2 API 的更深入探讨
- en: New additions to the WebGL 2 core specification
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL 2 核心规范的新增内容
- en: A strategy for migrating 3D applications from WebGL 1 to WebGL 2
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 WebGL 1 迁移 3D 应用到 WebGL 2 的策略
- en: What's New in WebGL 2?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL 2 的新特性是什么？
- en: 'As of January 27, 2016, WebGL 2 is available by default in Firefox and Chrome.
    This means that you will automatically have access to WebGL 2 without any additional
    dependencies, as long as you use one of the following browsers:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2016 年 1 月 27 日，WebGL 2 在 Firefox 和 Chrome 中默认可用。这意味着只要您使用以下浏览器之一，您将自动获得对
    WebGL 2 的访问权限，而无需任何额外的依赖项：
- en: Firefox 51 or above
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox 51 或更高版本
- en: Google Chrome 56 or above
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Chrome 56 或更高版本
- en: Chrome for Android 64 or above
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome for Android 64 或更高版本
- en: WebGL 2 Support
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 2 支持
- en: For an updated list of the browsers that support WebGL 2, please visit the Khronos
    Group web page by following this link: [http://www.khronos.org/WebGL/wiki/Getting_a_WebGL_Implementation](http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation). Or,
    you can visit the well-known **CanIUse.com** resource at: [https://caniuse.com/#search=WebGL
    2](https://caniuse.com/#search=webgl2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取支持 WebGL 2 的浏览器列表的最新版本，请通过以下链接访问 Khronos Group 网站：[http://www.khronos.org/WebGL/wiki/Getting_a_WebGL_Implementation](http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation)。或者，您也可以访问知名的
    **CanIUse.com** 资源：[https://caniuse.com/#search=WebGL 2](https://caniuse.com/#search=webgl2)。
- en: As described in [Chapter 1](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml), *Getting
    Started*, WebGL 1 is based on OpenGL ES 2.0; therefore, it doesn’t expose features
    like query timers, compute shaders, uniform buffers, and so on. That being said,
    with WebGL 2 (based on OpenGL ES 3.0), we are getting access to more GPU features
    like instancing and multiple render targets. Since WebGL 2 is a considerable upgrade
    from WebGL 1, let’s highlight some of its important features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml) 所述，*入门指南*，WebGL 1 基于 OpenGL
    ES 2.0；因此，它不暴露查询计时器、计算着色器、统一缓冲区等特性。话虽如此，随着 WebGL 2（基于 OpenGL ES 3.0），我们能够访问更多
    GPU 特性，如实例化和多个渲染目标。鉴于 WebGL 2 相比 WebGL 1 是一个相当大的升级，让我们突出其一些重要特性。
- en: Vertex Array Objects
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点数组对象
- en: As described in [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml), *Rendering*,
    we can implement **vertex array objects** in WebGL 1 by using the `OES_vertex_array_object` extension.
    That being said, they are available by default in WebGL 2. This is an important
    feature that should alwaysbe used, since it significantly reduces rendering times.
    When not using vertex array objects, all attributes data is in a global WebGL
    state, which means that calling functions such as `gl.vertexAttribPointer`, `gl.enableVertexAttribArray`,
    and `gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer)` manipulates the global state.
    This leads to performance loss, because before any draw call, we would need to
    set up all vertex attributes and set the `ELEMENT_ARRAY_BUFFER` where indexed
    data is being used. On the other hand, with vertex array objects, we would set
    up all attributes during our application's initialization and simply bind the
    data during rendering, yielding much better performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 2 章](d2019a49-9e84-448c-8799-e296187476d1.xhtml) 中所述，*渲染*，我们可以通过使用 `OES_vertex_array_object`
    扩展在 WebGL 1 中实现 **顶点数组对象**。话虽如此，它们在 WebGL 2 中默认可用。这是一个重要的特性，应该始终使用，因为它可以显著减少渲染时间。当不使用顶点数组对象时，所有属性数据都在全局
    WebGL 状态中，这意味着调用如 `gl.vertexAttribPointer`、`gl.enableVertexAttribArray` 和 `gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,
    buffer)` 等函数会操作全局状态。这会导致性能损失，因为在任何绘制调用之前，我们需要设置所有顶点属性并设置用于索引数据的 `ELEMENT_ARRAY_BUFFER`。另一方面，使用顶点数组对象时，我们会在应用程序初始化期间设置所有属性，并在渲染期间简单地绑定数据，从而获得更好的性能。
- en: This is very similar to the `IDirect3DVertexDeclaration9`/`ID3D11InputLayout` interfaces
    in DirectX land.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 DirectX 中的 `IDirect3DVertexDeclaration9`/`ID3D11InputLayout` 接口非常相似。
- en: '| WebGL 1 with Extension | WebGL 2 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| WebGL 1 带扩展 | WebGL 2 |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `createVertexArrayOES` | `createVertexArray` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `createVertexArrayOES` | `createVertexArray` |'
- en: '| `deleteVertexArrayOES` | `deleteVertexArray` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `deleteVertexArrayOES` | `deleteVertexArray` |'
- en: '| `isVertexArrayOES` | `isVertexArray` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `isVertexArrayOES` | `isVertexArray` |'
- en: '| `bindVertexArrayOES` | `bindVertexArray` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `bindVertexArrayOES` | `bindVertexArray` |'
- en: 'An example of this is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Wider Range of Texture Formats
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更广泛的纹理格式范围
- en: 'While WebGL 1 had a limited set of texture formats, WebGL 2 provides a much
    larger set, some of which are listed here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 WebGL 1 有一组有限的纹理格式，但 WebGL 2 提供了更大的一组，其中一些列在这里：
- en: '| `RGBA32I` | `RG8` | `RGB16UI` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `RGBA32I` | `RG8` | `RGB16UI` |'
- en: '| `RGBA32UI` | `RG8I` | `RGB8_SNORM` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `RGBA32UI` | `RG8I` | `RGB8_SNORM` |'
- en: '| `RGBA16I` | `RG8UI` | `RGB8I` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `RGBA16I` | `RG8UI` | `RGB8I` |'
- en: '| `RGBA16UI` | `R32I` | `RGB8UI` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `RGBA16UI` | `R32I` | `RGB8UI` |'
- en: '| `RGBA8` | `R32UI` | `SRGB8` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `RGBA8` | `R32UI` | `SRGB8` |'
- en: '| `RGBA8I` | `R16I` | `R11F_G11F_B10F` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `RGBA8I` | `R16I` | `R11F_G11F_B10F` |'
- en: '| `RGBA8UI` | `R16UI` | `RGB9_E5` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `RGBA8UI` | `R16UI` | `RGB9_E5` |'
- en: '| `SRGB8_ALPHA8` | `R8` | `RG32F` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `SRGB8_ALPHA8` | `R8` | `RG32F` |'
- en: '| `RGB10_A2` | `R8I` | `RG16F` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `RGB10_A2` | `R8I` | `RG16F` |'
- en: '| `RGB10_A2UI` | `R8UI` | `RG8_SNORM` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `RGB10_A2UI` | `R8UI` | `RG8_SNORM` |'
- en: '| `RGBA4` | `RGBA32F` | `R32F` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `RGBA4` | `RGBA32F` | `R32F` |'
- en: '| `RGB5_A1` | `RGBA16F` | `R16F` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `RGB5_A1` | `RGBA16F` | `R16F` |'
- en: '| `RGB8` | `RGBA8_SNORM` | `R8_SNORM` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `RGB8` | `RGBA8_SNORM` | `R8_SNORM` |'
- en: '| `RGB565` | `RGB32F` | `DEPTH_COMPONENT32F` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `RGB565` | `RGB32F` | `DEPTH_COMPONENT32F` |'
- en: '| `RG32I` | `RGB32I` | `DEPTH_COMPONENT24` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `RG32I` | `RGB32I` | `DEPTH_COMPONENT24` |'
- en: '| `RG32UI` | `RGB32UI` | `DEPTH_COMPONENT16` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `RG32UI` | `RGB32UI` | `DEPTH_COMPONENT16` |'
- en: '| `RG16I` | `RGB16F` |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `RG16I` | `RGB16F` |  |'
- en: '| `RG16UI` | `RGB16I` |  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `RG16UI` | `RGB16I` |  |'
- en: 3D Textures
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D 文本纹理
- en: A **3D texture **is a texture in which each mipmap level contains a single three-dimensional
    image. A 3D texture is essentially just a stack of 2D textures that can be sampled
    with `x`, `y`, and `z` coordinates in the shader. This functionality allows us
    to have multiple 2D textures in a single object so that shaders can seamlessly
    select which image to use for each object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**3D 纹理** 是一种纹理，其中每个米普级别包含单个三维图像。3D 纹理本质上只是一个堆叠的 2D 纹理，可以在着色器中使用 `x`、`y` 和
    `z` 坐标进行采样。这种功能使我们能够在单个对象中拥有多个 2D 纹理，以便着色器可以无缝选择每个对象使用的图像。'
- en: This is useful for visualizing volumetric data (like medical scans), 3D effects
    like smoke, storing lookup tables, and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于可视化体数据（如医学扫描）、3D 效果（如烟雾）、存储查找表等非常有用。
- en: Texture Arrays
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理数组
- en: '**Texture arrays**, similar to 3D textures, are a great feature for reducing
    complexity, improving code maintainability, and increasing the number of textures
    that can be used. By ensuring that all texture slices in a texture array are the
    same size, shaders can have access to many textures with a smaller footprint.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**纹理数组**，类似于3D纹理，是一个减少复杂性、提高代码可维护性以及增加可使用纹理数量的优秀特性。通过确保纹理数组中所有纹理切片的大小相同，着色器可以访问许多纹理，同时占用更小的空间。'
- en: Instanced Rendering
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例渲染
- en: In WebGL 2, **instancing** or **instanced rendering** is available by default*. *Instance
    rendering is a way to execute the same drawing commands many times in a row, with
    each producing a slightly different result. This can be a very efficient method
    for rendering a large amount of geometry with very few API calls.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL 2中，**实例化**或**实例渲染**默认可用**。实例渲染是一种连续多次执行相同的绘制命令的方法，每次产生略微不同的结果。这对于使用非常少的API调用渲染大量几何体来说是一个非常有效的方法。
- en: Instancing is a great performance booster for certain types of geometry, especially
    objects with many instances but without many vertices. Good examples are grass
    and fur. Instancing avoids the overhead of an individual API call per object,
    while minimizing memory costs by avoiding storing geometric data for each separate
    instance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化是某些类型几何体性能的极大提升，特别是那些实例数量多但顶点数量不多的对象。好的例子是草地和毛发。实例化避免了每个对象单独API调用的开销，同时通过避免为每个单独的实例存储几何数据来最小化内存成本。
- en: 'Here''s a quick example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速示例：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Non-Power of 2 Texture Support
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非2的幂次纹理支持
- en: As we saw in [Chapter 7](1455f0ba-ecbd-463d-bd1b-6c91fa910b26.xhtml), *Textures**,*mipmaps are
    a powerful feature in which pre-calculated, optimized sequences of images, each
    of which is a progressively lower-resolution representation of the same image,
    allow for more optimized rendering. While in WebGL 1 the height and width of each
    image, or level, in the mipmap is a power of two smaller than the previous level,
    in WebGL 2, that limit is removed. That is, **non-power of 2 textures** work the
    same as power of 2 textures.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第7章中看到的，**纹理**和*mipmaps*是一种强大的特性，其中预计算的、优化的图像序列，每个图像都是同一图像的逐级降低分辨率的表示，允许进行更优化的渲染。虽然在WebGL
    1中，mipmap中每个图像或级别的宽度和高度都是前一级别的一半的2的幂，但在WebGL 2中，这个限制被移除了。也就是说，**非2的幂次纹理**与2的幂次纹理的工作方式相同。
- en: Fragment Depth
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段深度
- en: In WebGL 2, we can manually set our own custom values to the depth buffer (z-buffer).
    This feature allows you to manipulate the depth of a fragment from the fragment
    shader. This can be expensive, because it forces the GPU to bypass a lot of it's
    normal fragment discard behavior, but can also allow for some interesting effects
    that would be difficult to accomplish without having incredibly high poly geometry.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL 2中，我们可以手动设置自己的自定义值到深度缓冲区（z缓冲区）。这个特性允许你在片段着色器中操作片段的深度。这可能会很昂贵，因为它迫使GPU绕过大量的正常片段丢弃行为，但也可以实现一些在没有极其高多边形几何体的情况下难以实现的效果。
- en: Texture Size in Shaders
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器中的纹理大小
- en: In WebGL 2, you can look up the size of any texture within ESSL shaders using `textureSize`.
    With WebGL 1, you'd need to create a uniform and pass the data into the shader
    manually.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL 2中，你可以使用`textureSize`在ESSL着色器中查找任何纹理的大小。在WebGL 1中，你需要创建一个uniform并将数据手动传递到着色器中。
- en: 'For example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Sync Objects
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步对象
- en: With WebGL 1, the path from Javascript to GPU to screen is fairly opaque to
    developers. That is, you dispatch draw commands and at some undefined point in
    the future, the results show up on the screen. In WebGL 2, **sync objects** allow
    the developer to gain a little more insight into when the GPU has completed it's
    work. Using `gl.fenceSync`, you can place a marker at some point in the GPU command
    stream and then later call `gl.clientWaitSync` to pause Javascript execution until
    the GPU has completed all commands up to the fence. Obviously blocking execution
    isn't desirable for applications that want to render fast, but this can be very
    beneficial for getting accurate benchmarks. It may also possibly be used in the
    future for synchronizing between workers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL 1中，从JavaScript到GPU再到屏幕的路径对开发者来说相当不透明。也就是说，你发送绘制命令，在未来的某个未定义的时刻，结果会显示在屏幕上。在WebGL
    2中，**同步对象**允许开发者获得更多关于GPU何时完成工作的洞察。使用`gl.fenceSync`，你可以在GPU命令流中的某个位置放置一个标记，然后稍后调用`gl.clientWaitSync`来暂停JavaScript执行，直到GPU完成所有命令直到栅栏。显然，对于想要快速渲染的应用程序来说，阻塞执行是不理想的，但这对获取准确的基准测试非常有帮助。这也可能在未来用于在工作者之间同步。
- en: Direct Texel Lookup
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接纹理查找
- en: It's often convenient to store large arrays of data in a texture. This is possible
    in WebGL 1, but you can only address textures with texture coordinates inside
    a range spanning from `0.0` to `1.0`. In WebGL 2, accessing this sort of data
    is considerably easier, as you can easily look up values from a texture with pixel/texel
    coordinates.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常方便将大量数据存储在纹理中。这在 WebGL 1 中是可能的，但你只能使用纹理坐标在 `0.0` 到 `1.0` 的范围内访问纹理。在 WebGL
    2 中，访问这类数据要容易得多，因为你可以轻松地使用像素/纹理坐标从纹理中查找值。
- en: 'For example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Flexible Shader Loops
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活的着色器循环
- en: In WebGL 1, loops in the shader had to use a constant integer expression. However,
    since WebGL 2 is based on OpenGL ES 3.0, this limit no longer exists.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 1 中，着色器中的循环必须使用一个常量整数表达式。然而，由于 WebGL 2 基于 OpenGL ES 3.0，这个限制不再存在。
- en: Shader Matrix Functions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器矩阵函数
- en: Given that WebGL 2's shading language is much more feature-rich than WebGL 1's,
    we now have many more matrix math operations at our fingertips. For example, if
    an `inverse` or `transpose` of a matrix is needed, we would need to pass it in
    as a uniform. However, in WebGL 2, functions such as `inverse`and `transpose` are
    functions directly built into shaders.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 WebGL 2 的着色语言比 WebGL 1 的功能更丰富，我们现在有更多矩阵数学运算可供使用。例如，如果需要矩阵的 `inverse` 或 `transpose`，我们需要将其作为统一变量传递。然而，在
    WebGL 2 中，`inverse` 和 `transpose` 等函数是直接内置于着色器中的。
- en: Common Compressed Textures
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见压缩纹理
- en: 'In WebGL 1, there are various compressed texture formats that are hardware-dependent.
    For example, formats such as `S3TC` and `PVTC` are desktop and iOS only, respectively.
    However, in WebGL 2, the following formats are much more flexible by being hardware
    independent:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 1 中，存在各种硬件依赖的压缩纹理格式。例如，`S3TC` 和 `PVTC` 格式分别仅适用于桌面和 iOS。然而，在 WebGL 2
    中，以下格式由于硬件无关性而更加灵活：
- en: '`COMPRESSED_R11_EAC RED`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSED_R11_EAC RED`'
- en: '`COMPRESSED_SIGNED_R11_EAC RED`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSED_SIGNED_R11_EAC RED`'
- en: '`COMPRESSED_RG11_EAC RG`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSED_RG11_EAC RG`'
- en: '`COMPRESSED_SIGNED_RG11_EAC RG`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSED_SIGNED_RG11_EAC RG`'
- en: '`COMPRESSED_RGB8_ETC2 RGB`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSED_RGB8_ETC2 RGB`'
- en: '`COMPRESSED_SRGB8_ETC2 RGB`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSED_SRGB8_ETC2 RGB`'
- en: '`COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA`'
- en: '`COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA`'
- en: '`COMPRESSED_RGBA8_ETC2_EAC RGBA`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSED_RGBA8_ETC2_EAC RGBA`'
- en: '`COMPRESSED_SRGB8_ALPHA8_ETC2_EAC`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPRESSED_SRGB8_ALPHA8_ETC2_EAC`'
- en: Uniform Buffer Objects
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一缓冲对象
- en: Setting shader program uniforms is a huge part of almost any WebGL/OpenGL draw
    loop. This can make your draw calls fairly chatty as they make hundreds or thousands
    of `gl.uniform` calls.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设置着色程序统一变量是几乎任何 WebGL/OpenGL 绘制循环的重要组成部分。这可能会使你的绘制调用相当频繁，因为它们会进行数百或数千次的 `gl.uniform`
    调用。
- en: In WebGL 1, if we have `n` number of uniforms that need to be updated, then
    it would require `n` number of calls with the appropriate uniform method—this
    can be quite slow. However, with WebGL 2, we can use **uniform buffer objects****, **which
    allow us to specify a large number of uniforms from a single buffer. This is a
    major boost in performance, since we can manipulate uniforms in the buffer outside
    of WebGL by using JavaScript-typed arrays and updating a set of uniforms with
    a single call. Additionally, uniform buffers can be bound to multiple programs
    at the same time, so it's possible to update global data (like projection or view
    matrices) once and all programs that use them will automatically see the changed
    values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 1 中，如果我们有需要更新的 `n` 个统一变量，那么就需要使用 `n` 次适当的统一变量方法调用——这可能会相当慢。然而，在 WebGL
    2 中，我们可以使用 **统一缓冲对象**，这允许我们从单个缓冲区中指定大量统一变量。这大大提高了性能，因为我们可以在 WebGL 之外使用 JavaScript
    类型的数组来操作缓冲区中的统一变量，并通过单次调用更新一组统一变量。此外，统一缓冲区可以同时绑定到多个程序，因此可以一次性更新全局数据（如投影或视图矩阵），所有使用它们的程序将自动看到更改后的值。
- en: '**Heterogeneous Uniform Buffer Objects** It''s important to note that, in a
    given application, you can leverage a diverse set of uniform buffer objects to
    fit your application''s needs.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**异构统一缓冲对象** 需要注意的是，在给定的应用程序中，你可以利用一系列不同的统一缓冲对象来满足你的应用需求。'
- en: Integer Textures and Attributes
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数纹理和属性
- en: While in WebGL 1 textures and attributes are represented as floating-point values,
    regardless of their original type, in WebGL 2, textures and attributes are provided
    integer representation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 WebGL 1 中，纹理和属性无论其原始类型如何，都表示为浮点值，而在 WebGL 2 中，纹理和属性提供整数表示。
- en: Transform Feedback
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换反馈
- en: A powerful technique offered in WebGL 2 is that vertex shaders can write their
    results back into a buffer. This can be very useful in situations where we want
    to leverage the GPU's computational power to perform complex computations so that
    we are able to read them within our application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 2 提供的一个强大技术是顶点着色器可以将它们的输出写回缓冲区。这在需要利用 GPU 的计算能力执行复杂计算并能在我们的应用程序中读取它们的情况下非常有用。
- en: Sampler Objects
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样本对象
- en: While in WebGL 1 all texture parameters are *per texture*, in WebGL 2, we can
    optionally use **sampler objects**. By using samplers, we can move all texture
    parameters to a sampler, allowing a single texture to be sampled in different
    ways.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 WebGL 1 中所有纹理参数都是 *每个纹理*，但在 WebGL 2 中，我们可以选择使用 **样本对象**。通过使用样本，我们可以将所有纹理参数移动到样本中，允许单个纹理以不同的方式采样。
- en: In WebGL 1, texture image data and sampling information (which tells GPU how
    to read the image data) are both stored in texture objects. It can be painful
    when we want to read from the same texture twice but with a different method (say,
    linear filtering vs nearest filtering) because we need to have two texture objects.
    With sampler objects, we can separate these two concepts. We can have one texture
    object and two different sampler objects. This will result in a change in how
    our engine organize textures.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 1 中，纹理图像数据和采样信息（告诉 GPU 如何读取图像数据）都存储在纹理对象中。当我们想要从同一个纹理中两次以不同的方法（比如，线性过滤与最近邻过滤）读取时，可能会很痛苦，因为我们需要有两个纹理对象。通过使用样本对象，我们可以将这些两个概念分开。我们可以有一个纹理对象和两个不同的样本对象。这将导致我们的引擎组织纹理的方式发生变化。
- en: 'Here’s an example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Depth Textures
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度纹理
- en: A major drawback to WebGL 1 is the lack of support for **depth textures**. In
    WebGL 2, they are available by default.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 1 的一个主要缺点是缺乏对 **深度纹理** 的支持。在 WebGL 2 中，它们默认可用。
- en: Standard Derivatives
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准导数
- en: While in WebGL 1 you'd need to compute normal and pass them to shaders, in WebGL
    2, you can compute them within shaders by using a larger set of mathematical operations
    that are available by default.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 WebGL 1 中你需要计算法线并将其传递给着色器，但在 WebGL 2 中，你可以通过使用默认可用的更大数学运算集在着色器内计算它们。
- en: UNSIGNED_INT Indices
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UNSIGNED_INT 索引
- en: In WebGL 2, there isn't a practical size limit for indexed geometries since
    we can use 32-bit `int` for indices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 2 中，索引几何体没有实际的大小限制，因为我们可以使用 32 位 `int` 作为索引。
- en: Blend Equation MIN / MAX
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合方程 MIN / MAX
- en: In WebGL, you can easily take the `MIN` or `MAX` of two colors when blending
    using these added functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 中，你可以通过这些附加函数轻松地获取两个颜色在混合时的 `MIN` 或 `MAX`。
- en: Multiple Render Targets (MRT)
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重渲染目标（MRT）
- en: In WebGL 2, you can draw to multiple buffers at once from a shader. This can
    be quite powerful for various deferred rendering techniques. This is "the big
    one" for many developers, because it makes many of the modern deferred rendering
    techniques that have become such a core part of modern realtime 3D practical for
    WebGL.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 2 中，你可以从着色器一次绘制到多个缓冲区。这对于各种延迟渲染技术来说非常强大。这对许多开发者来说是一个“大事件”，因为它使得许多已经成为现代实时
    3D 核心部分的现代延迟渲染技术对 WebGL 变得实用。
- en: Texture Access in Vertex Shaders
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点着色器中的纹理访问
- en: While accessing textures within vertex shaders is possible in WebGL 1, you would
    need to count how many textures you could access, and that could equal zero. In
    WebGL 2, texture access is much more streamlined, and the texture access count
    is required to be at least `16`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 WebGL 1 中在顶点着色器内访问纹理是可能的，但你可能需要计算你可以访问多少个纹理，这可能是零。在 WebGL 2 中，纹理访问更加流畅，并且纹理访问计数至少需要是
    `16`。
- en: Multi-Sampled Renderbuffers
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多样本渲染缓冲区
- en: While in WebGL 1 we could only use the GPU's built in multi-sample system to
    anti-alias our `canvas`, in WebGL 2, there is support to perform our own custom
    multi-sampling.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 WebGL 1 中我们只能使用 GPU 内置的多样本系统来抗锯齿我们的 `canvas`，但在 WebGL 2 中，支持我们自己的自定义多样本处理。
- en: Query Objects
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询对象
- en: '**Query objects** give developers another, more explicit way to peek at the
    inner workings of the GPU. A query wraps a set of GL commands for the GPU to asynchronously
    report some sort of statistic about. For example, occlusion queries are done in
    the following way: performing a `gl.ANY_SAMPLES_PASSED` query around a set of
    draw calls will let you detect if any of the geometry passed the depth test. If
    not, you know that the object wasn''t visible and may choose not to draw that
    geometry in future frames until something happens (object moved, camera moved,
    and so on) that indicates that the geometry might have become visible again.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询对象**为开发者提供了另一种更明确的方式来窥视GPU的内部工作原理。查询封装了一组GL命令，以便GPU异步报告某些统计信息。例如，遮挡查询是这样进行的：在一系列绘制调用周围执行`gl.ANY_SAMPLES_PASSED`查询将允许你检测是否有任何几何体通过了深度测试。如果没有，你知道该对象是不可见的，并且可以选择不在未来的帧中绘制该几何体，直到发生某些事件（对象移动、相机移动等）表明该几何体可能再次变得可见。'
- en: It should be noted that these queries are asynchronous, which means that a queries'
    results may not be ready for many frames after the query was originally issued!
    This makes them tricky to use, but it can be worth it in the right circumstances.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，这些查询是异步的，这意味着查询的结果可能在查询最初发出后的许多帧之后才准备好！这使得它们使用起来很棘手，但在适当的情况下可能值得。
- en: 'Here''s an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Texture LOD
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理LOD
- en: The **texture LOD** parameter is used to determine which mipmap to fetch from.
    This allows for mipmap streaming, that is, loading only the mipmap levels currently
    needed. This is very useful for a WebGL environment, where textures are downloaded
    via a network.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**纹理LOD**参数用于确定从哪个mipmap中获取。这允许进行mipmap流式传输，即只加载当前所需的mipmap级别。这对于WebGL环境非常有用，因为纹理是通过网络下载的。'
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Shader Texture LOD
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器纹理LOD
- en: The **Shader Texture LOD** bias control makes mipmap level control simpler for
    glossy environment effects in physically-based rendering. Now as part of the WebGL
    2 core, the `lodBias` can be passed as an optional parameter to texture.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**着色器纹理LOD**偏差控制使得基于物理渲染的哑光环境效果中的mipmap级别控制更加简单。现在作为WebGL 2核心的一部分，`lodBias`可以作为可选参数传递给纹理。'
- en: Floating Point Textures Always Available
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用的浮点纹理
- en: While in WebGL 1, floating point textures are optional*,* but in WebGL 2, they
    are available by default.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL 1中，浮点纹理是可选的*，*但在WebGL 2中，它们默认可用。
- en: Migrating to WebGL 2
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移到WebGL 2
- en: As we described previously, WebGL 2 is nearly 100 percent backward compatible
    with WebGL 1.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所描述的，WebGL 2 几乎与 WebGL 1 完全向后兼容。
- en: Backward Compatibility
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 向后兼容性
- en: All exceptions to backward compatibility are recorded at the following link: [https://www.khronos.org/registry/WebGL/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY](https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有向后兼容性的例外情况都记录在以下链接中：[https://www.khronos.org/registry/WebGL/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY](https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY)。
- en: That being said, let's cover some key components of migrating a WebGL 1 application
    to WebGL 2.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们来了解一下将WebGL 1应用程序迁移到WebGL 2的一些关键组件。
- en: Attaining context
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取上下文
- en: 'In WebGL 1, you''d attain a WebGL context with something that looks like the
    following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL 1中，你会用类似以下的方式获取WebGL上下文：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In WebGL 2, you''d simply attain the context with a single line, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL 2中，你只需用一行代码获取上下文，如下所示：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Extensions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'While in WebGL many optionalextensions were *required* for more advanced functionality,
    in WebGL 2 you can remove most of those extensions, because they are available
    by *default*. Some of these include the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL中，许多可选扩展对于更高级的功能是*必需的*，但在WebGL 2中，你可以移除其中大部分扩展，因为它们默认可用。以下是一些包括在内：
- en: Depth textures: [https://www.khronos.org/registry/WebGL/extensions/WebGL_depth_texture](https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度纹理：[https://www.khronos.org/registry/WebGL/extensions/WebGL_depth_texture](https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
- en: 'Floating point textures:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点纹理：
- en: '[https://www.khronos.org/registry/WebGL/extensions/OES_texture_float](https://www.khronos.org/registry/webgl/extensions/OES_texture_float)'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.khronos.org/registry/WebGL/extensions/OES_texture_float](https://www.khronos.org/registry/webgl/extensions/OES_texture_float)'
- en: '[https://www.khronos.org/registry/WebGL/extensions/OES_texture_float_linear](https://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear)'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.khronos.org/registry/WebGL/extensions/OES_texture_float_linear](https://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear)'
- en: Vertex array objects: [https://www.khronos.org/registry/WebGL/extensions/OES_vertex_array_object](https://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点数组对象：[https://www.khronos.org/registry/WebGL/extensions/OES_vertex_array_object](https://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object)
- en: Standard derivatives: [https://www.khronos.org/registry/WebGL/extensions/OES_standard_derivatives](https://www.khronos.org/registry/webgl/extensions/OES_standard_derivatives)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准导数：[https://www.khronos.org/registry/WebGL/extensions/OES_standard_derivatives](https://www.khronos.org/registry/webgl/extensions/OES_standard_derivatives)
- en: Instanced drawing: [https://www.khronos.org/registry/WebGL/extensions/ANGLE_instanced_arrays](https://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例绘制：[https://www.khronos.org/registry/WebGL/extensions/ANGLE_instanced_arrays](https://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays)
- en: '`UNSIGNED_INT` indices: [https://www.khronos.org/registry/WebGL/extensions/OES_element_index_uint](https://www.khronos.org/registry/webgl/extensions/OES_element_index_uint)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNSIGNED_INT`索引：[https://www.khronos.org/registry/WebGL/extensions/OES_element_index_uint](https://www.khronos.org/registry/webgl/extensions/OES_element_index_uint)'
- en: Setting gl_FragDepth: [https://www.khronos.org/registry/WebGL/extensions/EXT_frag_depth](https://www.khronos.org/registry/webgl/extensions/EXT_frag_depth)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`gl_FragDepth`：[https://www.khronos.org/registry/WebGL/extensions/EXT_frag_depth](https://www.khronos.org/registry/webgl/extensions/EXT_frag_depth)
- en: Blend equation `MIN`/`MAX`: [https://www.khronos.org/registry/WebGL/extensions/EXT_blend_minmax](https://www.khronos.org/registry/webgl/extensions/EXT_blend_minmax)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合方程`MIN`/`MAX`：[https://www.khronos.org/registry/WebGL/extensions/EXT_blend_minmax](https://www.khronos.org/registry/webgl/extensions/EXT_blend_minmax)
- en: Direct texture LOD access: [https://www.khronos.org/registry/WebGL/extensions/EXT_shader_texture_lod](https://www.khronos.org/registry/webgl/extensions/EXT_shader_texture_lod)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接纹理LOD访问：[https://www.khronos.org/registry/WebGL/extensions/EXT_shader_texture_lod](https://www.khronos.org/registry/webgl/extensions/EXT_shader_texture_lod)
- en: Multiple draw buffers: [https://www.khronos.org/registry/WebGL/extensions/WebGL_draw_buffers](https://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个绘制缓冲区：[https://www.khronos.org/registry/WebGL/extensions/WebGL_draw_buffers](https://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers)
- en: Texture access in vertex shaders
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点着色器中的纹理访问
- en: Shader Updates
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器更新
- en: While WebGL 2's shader language, based on GLSL 300, is backward compatible with
    WebGL 1's shader language, we need to make a few changes to ensure that our shaders
    compile. Let's cover them now.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WebGL 2的着色语言，基于GLSL 300，与WebGL 1的着色语言向后兼容，但我们需要进行一些更改以确保我们的着色器能够编译。现在让我们来探讨这些更改。
- en: Shader Definitions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器定义
- en: With WebGL 2's shaders, we have to prepend all shaders with the following line
    of code: `#version 300 es`. It’s important to note that this *must *be the very
    first line in the shader, otherwise the shader will not compile.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL 2的着色器中，我们必须在所有着色器前添加以下代码行：`#version 300 es`。需要注意的是，这必须是着色器的第一行，否则着色器将无法编译。
- en: Attribute Definitions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性定义
- en: 'Given that attributes are *provided as inputs *to shaders, in GLSL 300 ES,
    the `attribute` qualifier is removed. For example, with WebGL''s GLSL 100, you
    might have the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于属性作为输入提供给着色器，在GLSL 300 ES中，`attribute`修饰符被移除。例如，使用WebGL的GLSL 100，你可能会有以下代码：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In GLSL 300 ES, this would be as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLSL 300 ES中，这将如下所示：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Varying Definitions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量定义
- en: 'While in GLSL 100, varyings are often defined in both the vertex and fragment
    shaders, the `varying` qualifier has been removed in GLSL 300 ES. That is, varying
    qualifiers are updated with their appropriate `in` and `out` qualifiers, depending
    on whether the values are provided as *inputs* or returned as *outputs*. For example,
    consider the following from GLSL 100:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLSL 100中，变量通常在顶点着色器和片段着色器中定义，但在GLSL 300 ES中，`varying`修饰符已被移除。也就是说，根据值是作为*输入*提供还是作为*输出*返回，变量修饰符会更新为相应的`in`和`out`修饰符。例如，考虑以下GLSL
    100中的代码：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This would be changed to the following in GLSL 300 ES:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变为以下GLSL 300 ES中的代码：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: No More gl_FragColor
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不再使用`gl_FragColor`
- en: 'While in GLSL 100 you''d ultimately render the color of the pixel by setting
    the `gl_FragColor` inside of the fragment shader, in GLSL 300 ES, you simply expose
    a value from your fragment shader. Consider, for example, the following in GLSL
    100:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLSL 100中，你最终会通过在片段着色器中设置`gl_FragColor`来渲染像素的颜色，但在GLSL 300 ES中，你只需从你的片段着色器中暴露一个值。例如，考虑以下GLSL
    100中的代码：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This would be updated by setting a defined custom output variable, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过设置一个定义的输出变量来更新，如下所示：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It's important to note that even though we declared a variable called `fragColor`,
    you can choose any name not starting with the prefix `gl_`, due to ambiguity.
    Throughout this book, we have defined this custom variable as `fragColor`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，尽管我们声明了一个名为 `fragColor` 的变量，但由于歧义，你可以选择任何不以 `gl_` 前缀开始的名称。在这本书中，我们定义了这个自定义变量为
    `fragColor`。
- en: Automatic Texture Type Detection
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动纹理类型检测
- en: 'While in GLSL 100 you''d get a color from a texture by using the appropriate
    methods, such as `texture2D`, in GLSL 300 ES, shaders automatically detect the
    type based on the sampler type in use. For example, consider the following in
    GLSL 100:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GLSL 100 中，你会通过使用适当的方法，如 `texture2D`，从纹理中获取颜色，但在 GLSL 300 ES 中，着色器会根据使用的采样器类型自动检测类型。例如，考虑以下
    GLSL 100 中的内容：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This would be updated to the following in GLSL 300 ES:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 GLSL 300 ES 中更新为以下内容：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Non-Power of 2 Texture Support
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非2的幂纹理支持
- en: As demonstrated in [Chapter 7](1455f0ba-ecbd-463d-bd1b-6c91fa910b26.xhtml), *Textures*, in
    WebGL 1, mipmaps don't exist for textures that don't conform to the *power of
    2* restriction. In WebGL 2, however, non-power of 2 textures work exactly the
    same as power of 2 textures.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第7章](1455f0ba-ecbd-463d-bd1b-6c91fa910b26.xhtml)中所示，在 WebGL 1 中，对于不符合 *2的幂*
    限制的纹理，不存在米柏（mipmap）。然而，在 WebGL 2 中，非2的幂纹理与2的幂纹理工作方式完全相同。
- en: Floating Point Framebuffer Attachments
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点帧缓冲区附加
- en: While in WebGL 1 a strange hack is required to check whether there is support
    for rendering to a floating point texture, in WebGL 2, this involves a simple
    check via standard methods.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 1 中，需要一种奇怪的技巧来检查是否支持渲染到浮点纹理，而在 WebGL 2 中，这涉及到通过标准方法进行简单的检查。
- en: Vertex Array Objects
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点数组对象
- en: While using vertex array objects is not a *necessary *requirement, it's a highly *recommended *feature
    to use in your migration. By using vertex array objects, you can improve both
    the overall structure of your code and the performance of your application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用顶点数组对象不是 *必需的* 要求，但在迁移过程中使用它是一个高度 *推荐* 的特性。通过使用顶点数组对象，你可以改善你代码的整体结构以及你应用程序的性能。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let’s summarize what we’ve learned in this chapter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所学的内容：
- en: We covered many of the core methods available only in the WebGL 2 specification.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们涵盖了 WebGL 2 规范中仅有的许多核心方法。
- en: We learned some of the key differences between WebGL 1 and WebGL 2.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了一些 WebGL 1 和 WebGL 2 之间的关键区别。
- en: We discussed migration strategies for converting a WebGL 1 application to WebGL
    2.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了将 WebGL 1 应用程序转换为 WebGL 2 的迁移策略。
- en: We're nearly done! Can you believe it? Up next, in the final chapter, *Journey
    Ahead*, we will conclude this book by laying out a roadmap of concepts, resources,
    and other useful pieces of information that are both inspiring and empowering,
    to help you continue down the path of mastering real-time computer graphics.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！你能相信吗？接下来，在最后一章，*前方之旅*，我们将通过列出概念、资源和其他有用的信息来结束这本书，这些信息既鼓舞人心又赋权，帮助你继续沿着掌握实时计算机图形学的道路前进。
