- en: Chapter 13. Highcharts and Ext JS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章. Highcharts 和 Ext JS
- en: 'This chapter starts with an introduction of Sencha''s Ext JS. Since the Ext
    JS framework covers a broad range of features, it comprises a large collection
    of classes. Therefore, a quick guide on a small set will be given, especially
    for the user interface components likely to be used with Highcharts. Then, we
    will learn which Highcharts extension we have for Ext JS and how to create a Highcharts
    graph within Ext JS. We will also learn about a small set of APIs provided by
    the extension. After that, we will use network data to build a simple application
    to demonstrate how the Ext JS components can interact with Highcharts. Finally,
    we will have a brief look at a commercial Ext JS application working together
    with Highcharts. In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从 Sencha 的 Ext JS 介绍开始。由于 Ext JS 框架涵盖了广泛的功能，它包含了一个庞大的类集合。因此，我们将给出一个小集合的快速指南，特别是对于可能用于
    Highcharts 的用户界面组件。然后，我们将学习我们为 Ext JS 提供的 Highcharts 扩展以及如何在 Ext JS 中创建 Highcharts
    图表。我们还将了解扩展提供的一小部分 API。之后，我们将使用网络数据构建一个简单的应用程序来演示 Ext JS 组件如何与 Highcharts 交互。最后，我们将简要查看一个与
    Highcharts 一起工作的商业 Ext JS 应用程序。在本章中，我们将涵盖以下主题：
- en: Introducing and giving a quick tutorial on Sencha Ext JS classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍并快速讲解 Sencha Ext JS 类
- en: Introducing the Highcharts extension for Ext JS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Ext JS 的 Highcharts 扩展
- en: Demonstrating how to convert a working Highcharts configuration for the extension
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何将扩展的现有 Highcharts 配置进行转换
- en: Preparing the Ext JS JsonStore object for the extension
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为扩展准备 Ext JS JsonStore 对象
- en: Describing APIs provided by the extension module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述扩展模块提供的 API
- en: Illustrating how to create an Ext JS application with the Highcharts extension
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说明如何使用 Highcharts 扩展创建 Ext JS 应用程序
- en: A short introduction to Sencha Ext JS
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sencha Ext JS 的简要介绍
- en: Sencha's Ext JS is one of the most comprehensive **Rich Internet Application**
    (**RIA**) frameworks on the market. An RIA framework can produce a web frontend
    that behaves like a desktop application. Ext JS supports many features such as
    proxy storage, charting, managing SVG, tabs, toolbars, a myriad of different form
    inputs, and many, many others. There are other popular RIA frameworks, such as
    the Java-based **Google Web Toolkit** (**GWT**) and Python-based Dojo. Both frameworks
    can be integrated with Highcharts via third-party contributed software.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha 的 Ext JS 是市场上最全面的 **富互联网应用**（RIA）框架之一。RIA 框架可以生成一个像桌面应用程序一样表现的前端网页。Ext
    JS 支持许多功能，如代理存储、图表、管理 SVG、标签页、工具栏、多种不同的表单输入等。还有其他流行的 RIA 框架，例如基于 Java 的 **Google
    Web Toolkit**（GWT）和基于 Python 的 Dojo。这两个框架都可以通过第三方贡献的软件与 Highcharts 集成。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See [http://www.highcharts.com/download](http://www.highcharts.com/download)
    under the section *Third Party Implementation* for the full list of software contributed
    by other developers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 *第三方实现* 部分的 [http://www.highcharts.com/download](http://www.highcharts.com/download)，以获取其他开发者贡献的软件完整列表。
- en: The Highcharts extension was originally written by Daniel Kloosterman for Ext
    JS 2+ as an adapter, as it didn't support any charts. In Ext JS 3, it started
    adopting the YUI charting library as the charting solution. However, the charts
    lacked features and style, and the main drawback was that they required Flash
    to run. Since Ext JS 3.1, I have been maintaining the Highcharts extension and
    added features, such as support for donut charts and enhancements for some of
    the APIs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Highcharts 扩展最初由 Daniel Kloosterman 为 Ext JS 2+ 编写，作为一个适配器，因为当时它不支持任何图表。在 Ext
    JS 3 中，它开始采用 YUI 图表库作为图表解决方案。然而，这些图表缺乏功能和样式，主要缺点是它们需要 Flash 才能运行。自从 Ext JS 3.1
    以来，我一直维护 Highcharts 扩展，并添加了诸如支持饼图和增强一些 API 等功能。
- en: Although Ext JS 4 comes with its own chart library, some users still prefer
    Highcharts over Ext JS 4 charts for style and flexibility. Moreover, Ext JS 4
    can run alongside version 3 codes, so it is desirable to enhance the extension
    to natively support Ext JS 4, which I have done. The extension implementation
    has always been to follow the original approach, which is to preserve the use
    of Highcharts configurations as much as possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Ext JS 4 自带图表库，但一些用户仍然更喜欢 Highcharts 而不是 Ext JS 4 图表，因为 Highcharts 在样式和灵活性方面更胜一筹。此外，Ext
    JS 4 可以与版本 3 代码并行运行，因此增强扩展以原生支持 Ext JS 4 是很有必要的，我已经实现了这一点。扩展实现始终遵循原始方法，即尽可能保留
    Highcharts 配置的使用。
- en: At the time of writing, Ext JS 5 has just been released and the changes from
    Ext JS 4 to Ext JS 5 are not as drastic as from Ext JS 3 to Ext JS 4\. The Highcharts
    extension has been updated to be fully compatible with both Ext JS 4 and 5\. In
    this chapter, we will focus on working with Ext JS 5\. All the examples are simply
    from the previous edition, which is based on Ext JS 4, and they are updated to
    work with Ext JS 5.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Ext JS 5 刚刚发布，从 Ext JS 4 到 Ext JS 5 的变化并不像从 Ext JS 3 到 Ext JS 4 那样剧烈。Highcharts
    扩展已被更新，以完全兼容 Ext JS 4 和 5。在本章中，我们将专注于使用 Ext JS 5。所有示例都简单地来自上一版，该版基于 Ext JS 4，并且已更新以与
    Ext JS 5 一起工作。
- en: There are demos online at [http://joekuan.org/demos/Highcharts_Sencha/desktop.extjs5/](http://joekuan.org/demos/Highcharts_Sencha/desktop.extjs5/)
    and the extension can be downloaded from [http://github.com/JoeKuan/Highcharts_Sencha/](http://github.com/JoeKuan/Highcharts_Sencha/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有演示 [http://joekuan.org/demos/Highcharts_Sencha/desktop.extjs5/](http://joekuan.org/demos/Highcharts_Sencha/desktop.extjs5/)，并且可以从
    [http://github.com/JoeKuan/Highcharts_Sencha/](http://github.com/JoeKuan/Highcharts_Sencha/)
    下载扩展。
- en: Unlike jQuery UI, an Ext JS application is programmed in pure JavaScript, without
    the need to collaborate with HTML markup or fiddle with particular CSS classes
    (strictly speaking, there are times when it is necessary to interface with HTML
    and CSS, but it is not common and is only in small doses). This empowers programmers
    to focus on developing the entire web application in a single language and to
    concentrate on application logic. That also pushes the server-side development
    to reside in data operations only, unlike some approaches that use server-side
    language with HTML and CSS to serve client pages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与 jQuery UI 不同，Ext JS 应用程序是用纯 JavaScript 编程的，无需与 HTML 标记协作或调整特定的 CSS 类（严格来说，有时需要与
    HTML 和 CSS 进行接口，但这并不常见，而且只是小量）。这使得程序员能够专注于用单一语言开发整个 Web 应用程序，并专注于应用程序逻辑。这也推动服务器端开发仅限于数据操作，与一些使用服务器端语言与
    HTML 和 CSS 一起提供客户端页面的方法不同。
- en: 'Technically, JavaScript does not have classes: function itself is an object.
    The Ext JS framework provides access to its components through the class approach,
    organized in a hierarchical manner. In this chapter, we will use the word "class"
    to refer to Ext JS classes.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，JavaScript 没有类：函数本身就是一个对象。Ext JS 框架通过类方法提供对其组件的访问，这些组件以分层的方式组织。在本章中，我们将使用“类”一词来指代
    Ext JS 类。
- en: A quick tour of Ext JS components
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ext JS 组件快速浏览
- en: 'There are a myriad of classes in Ext JS, and it is beyond the scope of this
    book to introduce them. Sencha provides three types of online documentation in
    terms of both quality and quantity: a reference manual, tutorials (written and
    video), and working demos. You are strongly advised to spend ample time reviewing
    these materials. In this section, a very brief introduction is given about some
    components, especially those that are likely to interface with Highcharts. This
    chapter is by no means enough to get you started with programming in Ext JS, but
    should be enough to give you an idea.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 中有大量的类，本书的范围超出了介绍它们的范围。Sencha 提供了三种类型的在线文档，在质量和数量方面：参考手册、教程（书面和视频）以及工作演示。强烈建议您花充足的时间审查这些材料。在本节中，对一些组件进行了非常简要的介绍，特别是那些可能需要与
    Highcharts 接口的部分。但这章绝对不足以让您开始使用 Ext JS 进行编程，但应该足以让您有一个大致的概念。
- en: Implementing and loading Ext JS code
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现和加载 Ext JS 代码
- en: 'An Ext JS application can always be divided into multiple JavaScript files,
    but they should always start from one HTML file. The following code snippet demonstrates
    how to start up Ext JS from an HTML file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Ext JS 应用程序始终可以分成多个 JavaScript 文件，但它们应该始终从一个 HTML 文件开始。以下代码片段演示了如何从一个 HTML
    文件启动 Ext JS：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ext JS 5 is packaged with various themes. The preceding example demonstrates
    how to load one of the available themes. We will apply different themes in the
    examples to show the look and feel of Ext JS 5\. The script file, `ext-all.js`,
    contains all the Ext JS classes in a compressed format.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5 包含了各种主题。前面的示例演示了如何加载可用的主题之一。在示例中，我们将应用不同的主题来展示 Ext JS 5 的外观和感觉。脚本文件
    `ext-all.js` 以压缩格式包含了所有 Ext JS 类。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Ext JS has the facility to build a custom class file to cut down loading for
    production deployments. We are leaving that for you to explore.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 有构建自定义类文件的设施，以减少生产部署的加载。我们将这个留给你们去探索。
- en: '`Ext.require` is to load specific classes used in the application. `Ext.onReady`
    is the DOM-ready method, the same as the `$.ready` jQuery method that the application
    startup code starts running inside this function.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.require`用于加载应用程序中使用的特定类。`Ext.onReady`是DOM就绪方法，与应用程序启动代码在函数内部开始运行的`$.ready`
    jQuery方法相同。'
- en: Creating and accessing Ext JS components
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和访问 Ext JS 组件
- en: 'Out of all the classes in Ext JS, we should start by discussing `Ext.Component`,
    which is the base class for Ext JS user interface components. Depending on the
    characteristics of the component, some of them such as `Panel`, `Window`, `FieldSet`,
    and `RadioGroup` can contain multiple components, because they are inherited through
    another class: `Container`. We will look at `Container` in more detail later.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS 的所有类中，我们应该首先讨论`Ext.Component`，它是 Ext JS 用户界面组件的基类。根据组件的特性，其中一些组件，如`Panel`、`Window`、`FieldSet`和`RadioGroup`可以包含多个组件，因为它们是通过另一个类`Container`继承的。我们将在稍后更详细地查看`Container`。
- en: 'To create an Ext JS object, we use the `Ext.create` method, which takes two
    parameters. The first parameter is the string presentation of a class path, for
    example `''Ext.window.Window''`, or an alias name such as `''widget.window''`.
    The second parameter is the object specifier, containing the initial values to
    instantiate a class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Ext JS 对象，我们使用`Ext.create`方法，它接受两个参数。第一个参数是类路径的字符串表示，例如`'Ext.window.Window'`，或者一个别名，例如`'widget.window'`。第二个参数是对象指定符，包含实例化类的初始值：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code snippet is used to create a window widget and its content
    is defined through the `items` option. `Window` is a class derived from the `Container`
    class, which inherits the `items` option for containing other components. When
    the window is finally created and ready to render, it goes through each object
    specifier in the items array and creates each component.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段用于创建一个窗口小部件，其内容是通过`items`选项定义的。`Window`类是从`Container`类派生出来的，它继承了`items`选项以包含其他组件。当窗口最终创建并准备好渲染时，它会遍历`items`数组中的每个对象指定符，并创建每个组件。
- en: The `xtype` option is the Ext-specific type, which has a short unique name to
    symbolize the component's class path. In Ext JS, all interface components have
    their own `xtype` names (this refers to the `Ext.Component` manual). The `xtype`
    option is commonly used for convenience to create components within the container,
    as opposed to `Ext.create` with a full pathname.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`xtype`选项是 Ext 特定的类型，它有一个简短的唯一名称来表示组件的类路径。在 Ext JS 中，所有界面组件都有自己的`xtype`名称（这指的是`Ext.Component`手册）。`xtype`选项通常用于方便在容器内创建组件，而不是使用带有完整路径名的`Ext.create`。'
- en: 'The `id` field is to give a unique ID name to a component. The purpose is to
    gain direct access to a component at any point inside a program. To retrieve the
    component with an ID value, we can execute the following line of code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`字段是为了给一个组件赋予一个唯一的ID名称。其目的是在任何程序内部直接访问一个组件。要检索具有ID值的组件，我们可以执行以下代码行：'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, we can use the `itemId` option to assign a unique name. The
    difference is that the ID has to be globally unique to the application, whereas
    `itemId` only has to be unique within the parent container, to avoid name conflict
    elsewhere in the application. To access a component with the `itemId` value, we
    need to call `getComponent` from the immediate parent container, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`itemId`选项来分配一个唯一的名称。区别在于ID必须对整个应用程序全局唯一，而`itemId`只需要在父容器内部唯一，以避免在应用程序的其他地方发生名称冲突。要访问具有`itemId`值的组件，我们需要从直接父容器调用`getComponent`，如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Moreover, we can chain the call all the way from the top level to the desired
    component, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以从顶级一直链式调用到所需的组件，如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `'textbox'` (with `itemId` defined) component is constructed inside the
    parent container, `'panel'`, which resides inside the window object. Although
    the `getCmp` method provides direct, easy access to a component, it should generally
    be avoided as part of best practices, due to slower performance and undesired
    effects if a duplicate ID is accidentally used.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`itemId`定义的`'textbox'`组件是在父容器`'panel'`内部构建的，该容器位于窗口对象内部。尽管`getCmp`方法提供了直接、简单的访问组件的方式，但它通常应该避免作为最佳实践的一部分，因为它的性能较慢，如果意外使用了重复的ID，可能会产生不期望的效果。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of avoiding long sample code, we use the `getCmp` call in some
    of the demos.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免长样本代码，我们在一些演示中使用了`getCmp`调用。
- en: 'Note that Sencha also provides convenient component navigation, `up` and `down`
    methods which search for target component with CSS style selector. Here is an
    example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Sencha还提供了方便的组件导航，`up`和`down`方法通过CSS样式选择器搜索目标组件。以下是一个示例：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see the preceding expression is much more simplified and direct. The
    `down` method basically traverses down to its children components and so on until
    come across the first component with the matching criteria. In this case, the
    matching expression `'#textbox'` means a component with `itemId` specified as
    a textbox. Many different search expression can be used, another example is `down('textarea')`
    which means searching for the first child component with `xtype` value of textarea.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的表达式更加简化且直接。`down`方法基本上是向下遍历到其子组件，等等，直到遇到第一个符合条件组件。在这种情况下，匹配表达式`'#textbox'`表示一个`itemId`被指定为文本框的组件。可以使用许多不同的搜索表达式，另一个例子是`down('textarea')`，表示搜索第一个具有`xtype`值为textarea的子组件。
- en: Using layout and viewport
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用布局和视口
- en: 'As we mentioned earlier, some types of components have the ability to contain
    other components, because they are extended from the `Container` class. Another
    feature of the `Container` class is to arrange the layout between the contained
    components; the layout policy is specified via the `layout` option. There are
    about a dozen layout policies: among them `''anchor''`, `''border''`, and `''fit''`
    are most commonly used (the `card` layout is also used often, but through the
    tab panel). The `border` layout is widely used in GUI programming. The layout
    is finely divided into the `''north''`, `''east''`, `''south''`, `''west''`, and
    `''center''` regions.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，某些类型的组件具有包含其他组件的能力，因为它们是从`Container`类扩展而来的。`Container`类的另一个特性是在包含组件之间安排布局；布局策略通过`layout`选项指定。大约有十几种布局策略：其中`'anchor'`、`'border'`和`'fit'`是最常用的（`card`布局也经常使用，但通过标签面板）。`border`布局在GUI编程中被广泛使用。布局被精细地划分为`'north'`、`'east'`、`'south'`、`'west'`和`'center'`区域。
- en: 'When developing an application that requires utilizing the whole browser space,
    we generally use a `Viewport` class coupled with a `border` layout. `Viewport`
    is a special type of container whose size automatically binds to the browser.
    The following is a simple example of using a viewport:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发需要利用整个浏览器空间的应用程序时，我们通常使用与`border`布局结合的`Viewport`类。`Viewport`是一种特殊的容器，其大小会自动绑定到浏览器。以下是一个使用视口的简单示例：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the `border` layout in a gray theme:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了灰色主题中的`border`布局：
- en: '![Using layout and viewport](img/7451OS_13_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![使用布局和视口](img/7451OS_13_01.jpg)'
- en: Panel
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面板
- en: '`Panel` is a basic container component, and is generally used as a building
    block with the layout format and then combined with more panels or components.
    Another general use is to extend the `Panel` class to a special purpose type of
    panel, for example `PortalPanel` in the online portal demo. The most widely used
    panel types are `GridPanel`, `FormPanel`, and `TabPanel`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Panel`是一个基本的容器组件，通常用作布局格式的构建块，然后与更多的面板或组件结合使用。另一种一般用途是将`Panel`类扩展为特殊用途的面板类型，例如在线门户演示中的`PortalPanel`。最广泛使用的面板类型是`GridPanel`、`FormPanel`和`TabPanel`。'
- en: GridPanel
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格面板
- en: '`GridPanel` is used for displaying data in table format and it comes with lots
    of useful features, such as drag-and-drop column ordering, column sorting, flexible
    data rendering, enable or disable column display functions, and many others. `GridPanel`
    can also be used with different plugins such as row editor, allowing a user to
    edit field values on the fly. The class comes with a large set of events settings
    that can establish smooth coordination with other components. Nonetheless, the
    most tightly coupled component is the store object, which we will demonstrate
    in a later section.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridPanel`用于以表格格式显示数据，并附带许多有用的功能，例如拖放列排序、列排序、灵活的数据渲染、启用或禁用列显示功能等。`GridPanel`还可以与不同的插件一起使用，例如行编辑器，允许用户即时编辑字段值。该类提供了一套大量的事件设置，可以与其他组件建立顺畅的协调。尽管如此，最紧密耦合的组件是存储对象，我们将在后面的部分进行演示。'
- en: FormPanel
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单面板
- en: '`FormPanel` is a panel for accommodating field input components in form style,
    that is, labels on the left-hand side, inputs on the right-hand side, and the
    buttons array. Ext JS provides a great selection of form inputs, such as date
    time fields, comboboxes, number fields, sliders, and many others. Underneath the
    `FormPanel` layer, there is a `BasicForm` component, which contributes to field
    validations, form submission, and loading services with the store''s `Record`
    class for adding and editing entries.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormPanel` 是一个用于容纳表单样式字段输入组件的面板，即左侧是标签，右侧是输入，以及按钮数组。Ext JS 提供了大量的表单输入，例如日期时间字段、组合框、数字字段、滑块等。在
    `FormPanel` 层下面，有一个 `BasicForm` 组件，它通过存储的 `Record` 类为字段验证、表单提交和加载服务做出贡献，用于添加和编辑条目。'
- en: 'The following is a screenshot of `FormPanel` with various inputs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 `FormPanel` 的截图，展示了各种输入：
- en: '![FormPanel](img/7451OS_13_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![FormPanel](img/7451OS_13_02.jpg)'
- en: TabPanel
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TabPanel
- en: '`TabPanel`, as its name implies, is a panel associated with tabs. It supports
    creating and removing tabs on the fly and scrolling between tabs. The following
    code snippet shows how to create a tab panel:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabPanel`，正如其名称所暗示的，是一个与标签关联的面板。它支持动态创建和删除标签以及在不同标签之间滚动。以下代码片段展示了如何创建一个标签面板：'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is a screenshot of tabs within the tab panel, with a scrolling
    feature:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有滚动功能的标签面板内标签的截图：
- en: '![TabPanel](img/7451OS_13_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![TabPanel](img/7451OS_13_03.jpg)'
- en: Window
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Window
- en: '`Window` is a special type of panel that is not bound to any parent container
    and is free-floating within the application. It offers many features found in
    normal desktop windows, such as resize and maximize/minimize, and also comes with
    options for adding a toolbar, footer bar, and buttons. Later, we will see the
    `Window` panel in action in an example.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window` 是一种特殊的面板类型，它不绑定到任何父容器，并在应用程序中自由浮动。它提供了许多在普通桌面窗口中找到的功能，例如调整大小和最大化/最小化，还提供了添加工具栏、页脚栏和按钮的选项。稍后，我们将通过一个示例来查看
    `Window` 面板的实际应用。'
- en: Ajax
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ajax
- en: The Ext JS framework provides its own method, `Ajax.request`, for issuing Ajax
    queries. This is used when the returned JSON data is not required to be converted
    into table rows and field columns. The method is generally coupled with `Ext.decode`
    to convert the returned JSON format string into a JavaScript object and directly
    access individual fields inside the object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 框架提供自己的方法，`Ajax.request`，用于发起 Ajax 查询。当返回的 JSON 数据不需要转换为表格行和字段列时，使用此方法。该方法通常与
    `Ext.decode` 配合使用，将返回的 JSON 格式字符串转换为 JavaScript 对象，并直接访问对象内部的各个字段。
- en: 'The following code snippet shows a sample of issuing an Ajax query:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了发起一个 Ajax 查询的示例：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Store and JsonStore
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Store 和 JsonStore
- en: '`Store` is a general purpose storage class for modeled data. There are several
    classes derived from `Store,` but the most important one for Highcharts is `JsonStore`.
    It is a proxy-cached storage class responsible for issuing an Ajax query and unpacks
    the returned JSON data into modeled data. The `JsonStore` class is often used
    for accessing database data that resides on the server side. A store object can
    bind with more than one component, for example a `JsonStore` object can bind to
    a grid panel and a column chart. Clicking on a column order direction in the grid
    panel can change the row sequence in `JsonStore`, affecting the order of the columns
    displayed in the chart. In other words, the `Store` class acts as a skeleton to
    hold several components working together effortlessly and systematically.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Store` 是一种用于模型数据的通用存储类。有几个类是从 `Store` 派生出来的，但 Highcharts 最重要的是 `JsonStore`。它是一个代理缓存的存储类，负责发起
    Ajax 查询并将返回的 JSON 数据解包成模型数据。`JsonStore` 类通常用于访问位于服务器端的数据库数据。存储对象可以与多个组件绑定，例如，一个
    `JsonStore` 对象可以绑定到一个网格面板和一个柱状图。在网格面板中点击列排序方向可以改变 `JsonStore` 中的行顺序，从而影响图表中显示的列顺序。换句话说，`Store`
    类充当一个骨架，以使多个组件能够轻松且系统地协同工作。'
- en: It is important to note that the load method in the `Store` class is asynchronous.
    An event handler should be assigned to the load event if we want to tie an action
    after the data is loaded. The action can be specified through `listeners.click`
    via either the object specifier or `store.on` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`Store` 类中的加载方法是异步的。如果我们想在数据加载后执行某个操作，应将事件处理程序分配给加载事件。可以通过 `listeners.click`
    通过对象指定器或 `store.on` 方法指定操作。
- en: Example of using JsonStore and GridPanel
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JsonStore 和 GridPanel 的示例
- en: 'So far, a number of Ext JS components have been introduced; we should see how
    they work together. Let''s build a simple window application that contains a table
    (`GridPanel`) showing a list of hosts with their download usage that are returned
    from the server. Let''s assume that we have rows of data returned in JSON format
    from the server:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，已经介绍了一些 Ext JS 组件；我们应该看看它们是如何协同工作的。让我们构建一个简单的窗口应用程序，其中包含一个表格（`GridPanel`），显示从服务器返回的主机列表及其下载使用情况。假设我们从服务器返回的数据行是以
    JSON 格式：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First we define the data model to correspond with the JSON data. For the sake
    of simplicity, we can put all our demo code inside `Ext.onReady` rather than in
    a separate JavaScript file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义数据模型以与 JSON 数据相对应。为了简化，我们可以将所有演示代码放在 `Ext.onReady` 中，而不是单独的 JavaScript
    文件中：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is not mandatory to accept field names returned by the server. `Ext.data.Model`
    offers the `mapping` option to map an alternative field name to use on the client
    side.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接受服务器返回的字段名不是强制的。`Ext.data.Model` 提供了 `mapping` 选项，可以将备用字段名映射到客户端使用。
- en: 'The next step is to define a `JsonStore` object with the URL, connection type,
    and the data format type. We will bind the `JsonStore` object with the `NetworkData`
    data model defined in the preceding code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义一个 `JsonStore` 对象，包含 URL、连接类型和数据格式类型。我们将 `JsonStore` 对象绑定到前面代码片段中定义的 `NetworkData`
    数据模型：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`idProperty` is used to define which field is regarded as an ID if the default
    `''id''` fieldname is not provided, so that methods such as `Store.getById` can
    function properly. The `root` option tells the reader (`JsonReader`) which property
    name holds the array of row data in the JSON response from the server. The next
    task is to build a `Window` panel with a `GridPanel` class, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`idProperty` 用于定义如果未提供默认的 `''id''` 字段名，哪个字段被视为 ID，以便 `Store.getById` 等方法可以正常工作。`root`
    选项告诉读取器（`JsonReader`），哪个属性名包含来自服务器的 JSON 响应中的行数据数组。接下来的任务是构建一个 `Window` 面板，使用
    `GridPanel` 类，如下所示：'
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We instruct the grid panel to bind with the `netStore` object and define a
    list of columns to display. We then match each column to the store''s data field
    through the `dataIndex` option. The following is a screenshot showing part of
    a window (crisp theme) with a grid panel inside it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指示网格面板绑定到 `netStore` 对象，并定义要显示的列列表。然后，我们通过 `dataIndex` 选项将每个列与存储的数据字段匹配。以下是一个窗口（清晰主题）截图，其中包含网格面板的一部分：
- en: '![Example of using JsonStore and GridPanel](img/7451OS_13_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JsonStore 和 GridPanel 的示例](img/7451OS_13_04.jpg)'
- en: The Highcharts extension
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Highcharts 扩展
- en: In this section, we will examine how simple it is to create a Highcharts component
    in Ext JS. We do this by importing from an existing Highcharts configuration.
    Let's continue from the previous JsonStore example and incorporate it within the
    extension.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在 Ext JS 中创建 Highcharts 组件是多么简单。我们通过从现有的 Highcharts 配置中导入来实现这一点。让我们从上一个
    JsonStore 示例继续，并将其纳入扩展中。
- en: Step 1 – removing some of the Highcharts options
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 步 - 移除一些 Highcharts 选项
- en: 'Let''s assume that we already have a working independent Highcharts configuration,
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有了一个工作独立的 Highcharts 配置，如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first step is to remove all the fields that the extension will handle internally
    and pass them to Highcharts. For this reason, we need to remove `chart.renderTo`
    and the dimension options. We also need to remove the `chart.series` array, because
    eventually `JsonStore` will be the source of graph data. We also want to remove
    `chart.xAxis.categories` as it contains graph data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是移除扩展将内部处理的全部字段并将它们传递给 Highcharts。因此，我们需要移除 `chart.renderTo` 和维度选项。我们还需要移除
    `chart.series` 数组，因为最终 `JsonStore` 将是图形数据的来源。我们还想移除 `chart.xAxis.categories`，因为它包含图形数据。
- en: Step 2 – converting to a Highcharts extension configuration
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 步 - 转换为 Highcharts 扩展配置
- en: 'The next step is to construct a new configuration for the extension derived
    from the old Highcharts configuration. Let''s start a new configuration object,
    `myNewConfig`, with the size properties:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是构建一个新的配置，用于扩展旧的 Highcharts 配置。让我们从一个新的配置对象 `myNewConfig` 开始，包含大小属性：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to create a new option, `chartConfig`, which is required by
    the extension. We put the rest of the properties left in the `myConfig` object
    towards `chartConfig`. The following code snippet shows what the new config should
    look like:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个新的选项 `chartConfig`，这是扩展所必需的。我们将 `myConfig` 对象中剩余的属性移向 `chartConfig`。以下代码片段显示了新的配置应该是什么样子：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Step 3 – constructing a series option by mapping the JsonStore data model
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 3 – 通过映射 JsonStore 数据模型构建系列选项
- en: 'Recalling the data model of the store object, we have the following code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾存储对象的 data 模型，我们有以下代码片段：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next task is to build a series array with options matching the data model
    of `JsonStore`. The new series array has a similar structure to the one in Highcharts
    options. We also need to link the store object inside the object configuration.
    Eventually, the options object should become like the following code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是构建一个与 `JsonStore` 数据模型匹配的系列数组。新的系列数组结构与 Highcharts 选项中的结构类似。我们还需要在对象配置中链接存储对象。最终，选项对象应类似于以下代码片段：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `dataIndex` option is used for mapping the *y* value from `JsonStore` into
    the series data array. As the `'host'` field is string-type data, it is used as
    categories. Therefore, we specify the `xField` option outside the series array
    shared by the series.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataIndex` 选项用于将 `JsonStore` 中的 *y* 值映射到系列数据数组中。由于 `''host''` 字段是字符串类型的数据，它被用作类别。因此，我们指定
    `xField` 选项在系列数组外部，与系列共享。'
- en: Step 4 – creating the Highcharts extension
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 4 – 创建 Highcharts 扩展
- en: 'The final step is to put everything together to display a chart in Ext JS.
    We can create a Highcharts component first and put it inside an Ext JS container
    object, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将所有内容组合起来，在 Ext JS 中显示图表。我们首先创建一个 Highcharts 组件，并将其放入 Ext JS 容器对象中，如下所示：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or alternatively, we can create the whole thing through one configuration using
    `xtype`, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以通过使用 `xtype` 在一个配置中创建整个结构，如下所示：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following screenshot shows a Highcharts graph inside an Ext JS window (classic
    theme):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Ext JS 窗口（经典主题）内的 Highcharts 图表：
- en: '![Step 4 – creating the Highcharts extension](img/7451OS_13_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 4 – 创建 Highcharts 扩展](img/7451OS_13_05.jpg)'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to display data at startup, the JsonStore must be instantiated by setting
    the `autoLoad` option to `true` or calling the `Store.load` method manually at
    the start of the program.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在启动时显示数据，必须通过将 `autoLoad` 选项设置为 `true` 或在程序开始时手动调用 `Store.load` 方法来实例化 JsonStore。
- en: Passing series-specific options in the Highcharts extension
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Highcharts 扩展中传递特定系列的选项
- en: 'If we need to pass series-specific options, for example color, data point decorations,
    and so on, then we simply put them into the series configuration in the same way
    we normally do in Highcharts:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要传递特定系列的选项，例如颜色、数据点装饰等，那么我们只需以通常在 Highcharts 中做的方式，将它们放入系列配置中：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The extension will copy these options across at the same time as creating the
    series.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建系列的同时，扩展将复制这些选项。
- en: Converting a data model into a Highcharts series
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据模型转换为 Highcharts 系列
- en: In the previous example, we learned how to map a simple data model from the
    Ext JS store into Highcharts. However, there are several ways to declare the data
    mapping, and each way has different implications depending on the scenarios, especially
    in multiple series.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了如何将简单的数据模型从 Ext JS 存储映射到 Highcharts。然而，有几种声明数据映射的方法，每种方法根据场景的不同有不同的影响，尤其是在多个系列的情况下。
- en: X-axis category data and y-axis numerical values
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: X 轴类别数据和 y 轴数值
- en: 'This is the simplest and probably the most common scenario. Each series has
    numerical values along the *y* axis and shares data between the categories. For
    historical reasons, the `dataIndex` option can also be replaced with another option
    name, `yField`, which has a higher priority, and both behave in exactly the same
    way:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单且可能是最常见的情况。每个系列在 *y* 轴上有数值，并在类别间共享数据。由于历史原因，`dataIndex` 选项也可以替换为另一个选项名称
    `yField`，它具有更高的优先级，并且两者行为完全相同：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Numerical values for both x and y axes
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x 轴和 y 轴的数值
- en: 'Another scenario is where both the *x* and *y* axes are made up of numerical
    values. There are two different ways to specify the data mapping. First, each
    series holds the *y* axis values and shares common *x* axis values. In this case,
    the series are specified in the same way as the previous example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是，*x* 轴和 *y* 轴都由数值组成。有两种不同的方式来指定数据映射。首先，每个系列持有 *y* 轴值并共享共同的 *x* 轴值。在这种情况下，系列指定方式与上一个示例相同：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another situation is that each series holds its own pairs of *x* and *y* values,
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是，每个系列都持有自己的 *x* 和 *y* 值对，如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The difference between the two settings is that the first configuration ends
    up with two line series in the graph with data points aligning along the *x* axis,
    whereas the latter one doesn't, and the store data model is different as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种设置的差异在于，第一种配置最终在图表中产生两个线系列，数据点沿 *x* 轴对齐，而后者则没有，存储数据模型也有所不同。
- en: Performing preprocessing from store data
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从存储数据执行预处理
- en: Suppose that we need to perform a preprocessing task on the server data before
    we can plot the chart. We can do this by overriding a template method in the series
    configuration.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要在绘制图表之前对服务器数据进行预处理。我们可以通过覆盖系列配置中的模板方法来实现这一点。
- en: 'Inside the extension code, each series is actually instantiated from a `Serie`
    class. This class has a standard method defined, `getData`, which is for retrieving
    data from the store. Let''s visit the original implementation of `getData`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展代码中，每个系列实际上是从一个 `Serie` 类实例化的。这个类定义了一个标准方法，名为 `getData`，用于从存储中检索数据。让我们看看
    `getData` 的原始实现：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The classes and methods in this extension are named that way with the word "`Serie`"
    by the original author.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展中的类和方法被原始作者命名为包含单词 "`Serie`"。
- en: Basically, `getData` is called for every row returned from `JsonStore`. The
    method is passed with two parameters. The first one is an Ext JS `Record` object,
    which is an object representation of a row of data. The second parameter is the
    index value of the record inside the store. Inside the `Record` object, the `data`
    option holds the values according to the model definition when the store object
    is created.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，每次从 `JsonStore` 返回的每一行都会调用 `getData` 方法。该方法传递两个参数。第一个参数是一个 Ext JS `Record`
    对象，它是一个数据行的对象表示。第二个参数是记录在存储中的索引值。在 `Record` 对象内部，`data` 选项在创建存储对象时根据模型定义持有值。
- en: 'As we can see, the simple implementation of `getData` is to access `record.data`
    based on the values of `xField`, `yField`, and `dataIndex` and format it into
    a Highcharts `Point` configuration. We can override this method as we declare
    a series to suit our need for data conversion. Let''s continue the example: suppose
    the server is returning the data in a JSON string:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`getData` 的简单实现是根据 `xField`、`yField` 和 `dataIndex` 的值访问 `record.data`，并将其格式化为
    Highcharts `Point` 配置。我们可以根据我们声明系列时的数据转换需求来覆盖此方法。让我们继续例子：假设服务器以 JSON 字符串的形式返回数据：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`JsonStore` interprets the preceding data as rows with the following model
    definition:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonStore` 将前面的数据解释为具有以下模型定义的行：'
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We need to plot a column chart with each bar as the total of the upload and
    download fields, so we define the `getData` method for the series as shown next.
    Note that we don''t need to declare `yField` or `dataIndex` anymore, because the
    `getData` method for this particular series has already taken care of the field
    mappings:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要绘制一个柱状图，其中每个条形是上传和下载字段的总量，因此我们为系列定义了如下的 `getData` 方法。请注意，我们不再需要声明 `yField`
    或 `dataIndex`，因为此特定系列的 `getData` 方法已经处理了字段映射：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Plotting pie charts
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制饼图
- en: 'Plotting pie charts is slightly different to line, column, and scatter charts.
    A pie series is composed of data values where each value is from a category. Therefore,
    the module has two specific option names, `categorieField` and `dataField`, for
    category and data, respectively. To plot a pie chart, the series is needed to
    specify the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制饼图与线图、柱状图和散点图略有不同。饼图系列由数据值组成，其中每个值来自一个类别。因此，该模块有两个特定的选项名称，分别为 `categorieField`
    和 `dataField`，分别用于类别和数据。要绘制饼图，系列需要指定以下内容：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `getData` method of the `PieSeries` class subsequently converts the mapped
    data from the store into the `Point` object, with values assigned to the `name`
    and `y` fields.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`PieSeries` 类的 `getData` 方法随后将存储中的映射数据转换为 `Point` 对象，并将值分配给 `name` 和 `y` 字段。'
- en: Plotting donut charts
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制环形图
- en: 'Let''s remind ourselves that a donut chart is actually a two-series pie chart
    in which the data in the inner pie is a subcategory of the outer pie. In other
    words, each slice in the inner series is always the total of its outer portions.
    Therefore, the data returned from `JsonStore` has to be designed in such a way
    that these can be grouped into subcategories by field name. In this case, the
    JSON data should be returned, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提醒自己，环形图实际上是一个包含两个系列的饼图，其中内饼图的数据是外饼图的子类别。换句话说，内系列中的每个切片总是其外部分的总和。因此，从 `JsonStore`
    返回的数据必须设计成可以通过字段名将这些数据分组到子类别中。在这种情况下，JSON 数据应该返回如下所示：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we use an extra Boolean option, `totalDataField`, for the inner pie series
    to indicate that we want to use `dataField` to scan for the total value for each
    `"host"` category. As for the outer series, we just define it as a normal pie
    series, but with `"direction"` and `"bytes"` as `categorieField` and `dataField`,
    respectively. The following is the series definition for the donut chart:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个额外的布尔选项 `totalDataField`，对于内饼图系列，表示我们想要使用 `dataField` 来扫描每个 `"host"`
    类别的总值。对于外系列，我们只需将其定义为正常的饼图系列，但将 `"direction"` 和 `"bytes"` 分别定义为 `categorieField`
    和 `dataField`。以下是为环形图定义的系列：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following screenshot shows what a donut chart looks like in Ext JS (aria
    theme):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Ext JS（aria 主题）中的环形图的外观：
- en: '![Plotting donut charts](img/7451OS_13_06.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![绘制环形图](img/7451OS_13_06.jpg)'
- en: Inside the extension, the implementation of the `getData` method for the `PieSeries`
    class is significantly different from other series types, in order to handle both
    pie and donut series data. Therefore, it is not advisable to overwrite this method.
    Later on, we will see how pie and donut charts are plotted with this module.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展内部，`PieSeries` 类的 `getData` 方法的实现与其他系列类型显著不同，以便处理饼图和环形图的数据。因此，不建议覆盖此方法。稍后，我们将看到如何使用此模块绘制饼图和环形图。
- en: Module APIs
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块 API
- en: 'The Highcharts extension comes with a small set of APIs. Most of them are helper
    functions to modify series in the Ext JS layer. As for the Highcharts native APIs,
    they can be invoked through the `chart` property inside the extension component,
    for example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Highcharts 扩展包含一组小的 API。其中大部分是辅助函数，用于修改 Ext JS 层中的系列。至于 Highcharts 原生 API，可以通过扩展组件内部的
    `chart` 属性来调用，例如：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding line of code, `'highchart'` is the `itemId` value when the
    chart component is created. The `down` method is Ext JS's convenient way of using
    the CSS selection style to navigate through the hierarchical components.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，`'highchart'` 是创建图表组件时的 `itemId` 值。`down` 方法是 Ext JS 使用 CSS 选择样式遍历层次组件的便捷方式。
- en: As mentioned earlier, the `chartConfig` option contains all the Highcharts configurations.
    Once the chart component is created, it saves `chartConfig` inside the component.
    Hence, the `chartConfig` property possesses all the initial configurations that
    have created the chart. Later, we will see how this `chartConfig` property plays
    a role with regards to API calls.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`chartConfig` 选项包含所有 Highcharts 配置。一旦创建图表组件，它就会在组件内部保存 `chartConfig`。因此，`chartConfig`
    属性包含创建图表的所有初始配置。稍后，我们将看到这个 `chartConfig` 属性如何在 API 调用中发挥作用。
- en: addSeries
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: addSeries
- en: 'The `addSeries` method adds one or more series into the chart. The added series
    is/are also stored inside the `chartConfig.series` array, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`addSeries` 方法将一个或多个系列添加到图表中。添加的系列也存储在 `chartConfig.series` 数组中，如下所示：'
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The series parameter is an array of series configuration objects. `addSeries`
    not only allows series configuration with the `xField`, `yField`, and `dataIndex`
    options, but also supports series configuration with the data array, so it won''t
    go via the store object to extract the data. The following are examples of using
    `addSeries` in different ways:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 系列参数是一个系列配置对象的数组。`addSeries` 不仅允许使用 `xField`、`yField` 和 `dataIndex` 选项进行系列配置，还支持使用数据数组进行系列配置，因此它不会通过存储对象提取数据。以下是如何以不同方式使用
    `addSeries` 的示例：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The optional `append` parameter sets the series parameter to either replace
    the currently displayed series or append the series to the chart. The default
    is `false`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 `append` 参数将系列参数设置为替换当前显示的系列或将系列添加到图表中。默认值为 `false`。
- en: removeSerie and removeAllSeries
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: removeSerie 和 removeAllSeries
- en: 'The `removeSerie` method removes a single series in the chart and the `removeAllSeries`
    method removes all the series defined for the chart. Both methods also remove
    the series configuration in `chartConfig.series`, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeSerie` 方法从图表中移除单个系列，而 `removeAllSeries` 方法移除为图表定义的所有系列。这两种方法也会移除 `chartConfig.series`
    中的系列配置，如下所示：'
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `idx` parameter is the index value in the series array. The optional `redraw`
    parameter sets whether to redraw the chart after the series is removed. The default
    is `true`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`idx` 参数是系列数组中的索引值。可选的 `redraw` 参数设置在移除系列后是否重新绘制图表。默认值为 `true`。'
- en: setTitle and setSubTitle
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setTitle 和 setSubTitle
- en: 'Both `setTitle` and `setSubTitle` change the current chart title as well as
    the title settings in `chartConfig`, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTitle` 和 `setSubTitle` 都会更改当前图表标题以及 `chartConfig` 中的标题设置，如下所示：'
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: draw
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: draw
- en: 'So far, we have mentioned `chartConfig` but haven''t really explained what
    it does in the module. The `draw` method actually destroys the internal Highcharts
    object and recreates the chart based on the settings inside the current `chartConfig`.
    Suppose we have already created a chart component but we want to change some of
    the display properties. We modify properties inside `chartConfig` (Highcharts
    configurations) and call this method to recreate the internal Highcharts object:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们提到了 `chartConfig`，但还没有真正解释它在模块中的功能。`draw` 方法实际上销毁了内部 Highcharts 对象，并根据当前
    `chartConfig` 内的设置重新创建图表。假设我们已创建了一个图表组件，但想更改一些显示属性。我们修改 `chartConfig`（Highcharts
    配置）内的属性，并调用此方法来重新创建内部 Highcharts 对象：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Although we can call Highcharts' native APIs via the internal `chart` option
    without destroying and recreating the chart, not all Highcharts elements can be
    changed with API calls, for example series color, legend layout, the column stacking
    option, invert chart axes, and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过内部 `chart` 选项调用 Highcharts 的原生 API 而不销毁和重新创建图表，但并非所有 Highcharts 元素都可以通过
    API 调用来更改，例如系列颜色、图例布局、列堆叠选项、反转图表轴等等。
- en: As a result, this method enables the extension component to refresh the internal
    chart with any configuration change, without the need to recreate the component
    itself. Hence, this empowers the Ext JS application by not removing it from the
    parent container and reinserting a new one. Also, the layout in the parent container
    is not disrupted.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此方法使扩展组件能够在不重新创建组件本身的情况下，通过任何配置更改刷新内部图表。因此，它通过不在父容器中移除并重新插入一个新组件来增强 Ext JS
    应用程序。此外，父容器中的布局也不会被打乱。
- en: Event handling and export modules
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理和导出模块
- en: Specifying chart event handlers for the extension is exactly the same as how
    we normally declare event handlers in Highcharts. Since this is now under both
    the Ext JS and jQuery environments, the implementation can use both Ext JS and
    jQuery methods.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为扩展指定图表事件处理器与我们在 Highcharts 中通常声明事件处理器的方式完全相同。由于现在它处于 Ext JS 和 jQuery 环境下，实现可以使用
    Ext JS 和 jQuery 方法。
- en: The Highcharts exporting chart module is unaffected by the extension. The export
    settings simply bypass this extension and work straightaway.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Highcharts 导出图表模块不受扩展的影响。导出设置只是绕过此扩展并直接工作。
- en: Extending the example with Highcharts
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Highcharts 扩展示例
- en: In this section, we will build a larger example that includes other types of
    panels and charts. The application is built with a viewport showing two regions—the
    `'center'` region is a tab panel containing three tabs for each different type
    of network data graph, and the `'west'` region shows the table data of the current
    graph on display. The graph in the first tab is **Bandwidth Utilisation**, which
    indicates the data rate passing through the network.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个更大的示例，其中包含其他类型的面板和图表。应用程序使用视口显示两个区域——`'center'` 区域是一个包含三个标签的标签面板，每个标签对应不同类型的网络数据图表，而
    `'west'` 区域显示当前显示图表的表格数据。第一个标签中的图表是 **带宽利用率**，表示通过网络的数据速率。
- en: 'The following screenshot shows the front screen of the application (neptune
    theme):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了应用程序的前端屏幕（neptune 主题）：
- en: '![Extending the example with Highcharts](img/7451OS_13_07.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Highcharts 扩展示例](img/7451OS_13_07.jpg)'
- en: '**Plot Yesterday** in the toolbar is a toggle button that triggers an additional
    series, **Yesterday**, to be plotted on the same chart. An extra column of data
    called **Yesterday** is also displayed in the left-hand side table, as shown in
    the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏中的**昨天**按钮是一个切换按钮，它会在同一图表上触发一个额外的系列**昨天**。在左侧表格中还会显示一个名为**昨天**的额外数据列，如下面的截图所示：
- en: '![Extending the example with Highcharts](img/7451OS_13_08.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![使用Highcharts扩展示例](img/7451OS_13_08.jpg)'
- en: 'The **Plot Yesterday** button handler uses the `addSeries` and `removeSeries`
    methods internally to toggle the **Yesterday** series. The following is the implementation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**昨天**按钮处理程序内部使用`addSeries`和`removeSeries`方法来切换**昨天**系列。以下是其实现：'
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s move on to the second tab, which is a column chart showing a list of
    hosts with their network usage in uplink and downlink directions, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到第二个标签页，它是一个柱状图，显示了主机列表及其上行和下行方向的网络使用情况，如下所示：
- en: '![Extending the example with Highcharts](img/7451OS_13_09.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![使用Highcharts扩展示例](img/7451OS_13_09.jpg)'
- en: 'When we click on the **Stacked Columns** button, the bars of both series are
    stacked together instead of aligned adjacent to each other, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**堆叠柱状图**按钮时，两个系列的条形会堆叠在一起，而不是相邻对齐，如下所示：
- en: '![Extending the example with Highcharts](img/7451OS_13_10.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![使用Highcharts扩展示例](img/7451OS_13_10.jpg)'
- en: 'This is achieved by modifying the column `stacking` option inside the extension
    `chartConfig` property and recreating the whole chart with the module''s `draw`
    method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过修改扩展的`chartConfig`属性中的列`stacking`选项，并使用模块的`draw`方法重新创建整个图表来实现的：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Note that we declare the default `stacking` option inside `chartConfig` when
    we create the chart, so that we can directly modify the property in the handler
    code later:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在创建图表时在`chartConfig`内部声明了默认的`stacking`选项，这样我们就可以在稍后的处理代码中直接修改该属性：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The final tab is **Last 7 Days Network Usage**, which has a pie chart showing
    the network usage for each of the last seven days, as shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个标签页是**最近7天网络使用情况**，它有一个饼图显示了最近七天的网络使用情况，如下面的截图所示：
- en: '![Extending the example with Highcharts](img/7451OS_13_11.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![使用Highcharts扩展示例](img/7451OS_13_11.jpg)'
- en: 'Let''s see how this pie chart is implemented in detail. `JsonStore` is adjusted
    to return data in the following format:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这个饼图是如何实现的。`JsonStore`被调整为以下格式返回数据：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we define the tab panel content, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义标签页内容，如下所示：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The series is set up as an inner series, hence the use of the `totalDataField`
    and `dataField` options to get the total bytes of `"lan"` and `"wan"` as the slice
    value for each `''host''`. If we click on the **Show Traffic Type** button, then
    the pie chart is changed to a donut chart, as shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 系列被设置为内部系列，因此使用了`totalDataField`和`dataField`选项来获取`"lan"`和`"wan"`的总字节数，作为每个`'host'`的切片值。如果我们点击**显示流量类型**按钮，那么饼图就会变成一个环形图，如下面的截图所示：
- en: '![Extending the example with Highcharts](img/7451OS_13_12.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![使用Highcharts扩展示例](img/7451OS_13_12.jpg)'
- en: 'The original data labels in the first pie chart are replaced with items inside
    the legend box. An outer series is displayed with a fixed color scheme to show
    the **LAN** and **WAN** portions of traffic. The following is the **Show Traffic
    Type** button''s button handler code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张饼图中的原始数据标签被替换为图例框内的项目。一个外部系列以固定的颜色方案显示，以展示**局域网**和**广域网**的流量部分。以下是为**显示流量类型**按钮的按钮处理代码：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the toggle button is enabled, then we add an outer pie series (with the `innerSize`
    option) via the `addSeries` method. Moreover, we align the outer series accordingly
    with the traffic `'type'`, and so `categorieField` and `dataField` are assigned
    to `'type'` and `'bytes'`. Since more information is needed to display the second
    series, we set the inner series to a smaller size for more space. In order to
    only show the first two data labels in the outer series, we implement `dataLabels.formatter`
    to print the label when `this.point.x` is 0 and 1\. After that, we disable the
    data labels by returning null in the `formatter` function. Finally, the `draw`
    method is used to reflect all the changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果切换按钮被启用，那么我们通过 `addSeries` 方法添加一个外部的饼图系列（带有 `innerSize` 选项）。此外，我们根据流量 `'type'`
    对外系列进行相应对齐，因此 `categorieField` 和 `dataField` 被分配给 `'type'` 和 `'bytes'`。由于需要更多信息来显示第二个系列，我们将内部系列的大小设置为更小，以获得更多空间。为了只显示外部系列中的前两个数据标签，我们实现了
    `dataLabels.formatter` 来在 `this.point.x` 为 0 和 1 时打印标签。之后，我们在 `formatter` 函数中返回
    null 来禁用数据标签。最后，使用 `draw` 方法来反映所有更改。
- en: Displaying a context menu by clicking on a data point
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过点击数据点显示上下文菜单
- en: 'For interactive applications, it would be handy to allow users to launch specific
    actions by clicking on a data point. To do that, we need to handle Highcharts''
    click events. Here, we create a simple menu for showing the difference between
    the selected point and the average value of the series. The following is the sample
    code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交互式应用，允许用户通过点击数据点来启动特定操作将非常有用。为了做到这一点，我们需要处理 Highcharts 的点击事件。在这里，我们创建了一个简单的菜单，用于显示选定点与系列平均值之间的差异。以下是示例代码：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: First we create a simple Ext JS `Menu` object with the menu item **Compare to
    Average Usage**. The `click` handler is called with the mouse event parameter,
    `evt`, and then we obtain the mouse pointer location, `pageX` and `pageY`, and
    pass it to the menu object. As a result, the Ext JS menu appears next to the pointer
    after clicking on a data point.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个简单的 Ext JS `Menu` 对象，带有菜单项 **与平均使用情况比较**。`click` 处理器使用鼠标事件参数 `evt`
    被调用，然后我们获取鼠标指针位置，`pageX` 和 `pageY`，并将其传递给菜单对象。结果，在点击数据点后，Ext JS 菜单出现在指针旁边。
- en: 'The `''this''` keyword in the `click` event handler refers to the selected
    point object. We then use the `scope` option to pass the Highcharts point object
    to the menu handler layer. Inside the handler, the `''this''` keyword becomes
    the data point object instead of the Ext JS menu item. We extract the series data
    to calculate the average and compute the difference with the selected point value.
    Then, we display the message with the value. The following is the screenshot of
    the menu:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `click` 事件处理器中的 `'this'` 关键字指的是选定的点对象。然后我们使用 `scope` 选项将 Highcharts 点对象传递给菜单处理器层。在处理器内部，`'this'`
    关键字变成了数据点对象，而不是 Ext JS 菜单项。我们提取系列数据来计算平均值，并计算与选定点值的差异。然后，我们显示带有该值的消息。以下是该菜单的截图：
- en: '![Displaying a context menu by clicking on a data point](img/7451OS_13_13.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![通过点击数据点显示上下文菜单](img/7451OS_13_13.jpg)'
- en: A commercial RIA with Highcharts – Profiler
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有 Highcharts 的商业 RIA – Profiler
- en: So far, we have demonstrated how Highcharts can be applied within the Ext JS
    framework. However, the demo itself seems rather shrink-wrapped for an RIA product.
    In this section, we will have a quick glance at a commercial application, **Profiler,**
    a tool for profiling companies network scenario developed by iTrinegy. Due to
    the nature of its business, a stack of diagnostic graphs is required for this
    type of application. The whole application is designed as a collection of portals
    for monitoring network traffic from multiple sites. Users can drill down from
    utilization graph to top downlink usage by IP address graph, modify filter properties
    to display relative data in multiple series, and so on.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了如何在 Ext JS 框架中应用 Highcharts。然而，这个演示本身对于一个 RIA 产品来说似乎有点过于封闭。在本节中，我们将快速浏览一个商业应用，**Profiler**，这是由
    iTrinegy 开发的一个用于分析公司网络场景的工具。由于其业务性质，此类应用需要一系列诊断图表。整个应用被设计成多个门户，用于监控来自多个地点的网络流量。用户可以从利用率图表向下钻取到按
    IP 地址排序的上行链路使用情况图表，修改过滤器属性以显示多个系列中的相关数据，等等。
- en: 'In order to fine-tune the profiling parameters and provide a portal interface,
    a framework offering dynamic and calibrated user interfaces is needed. For this
    reason, Ext JS is a suitable candidate, as it offers a rich set of professional
    looking widget components, and its cross-browser support makes building complicated
    RIA software manageable. The following is the interface for launching a bandwidth
    utilization report graph with specific parameters:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了微调分析参数并提供门户界面，需要一个提供动态和校准用户界面的框架。因此，Ext JS 是一个合适的候选者，因为它提供了一套丰富的专业外观的小部件组件，并且它的跨浏览器支持使得构建复杂的
    RIA 软件变得可管理。以下是通过特定参数启动带宽利用率报告图的界面：
- en: '![A commercial RIA with Highcharts – Profiler](img/7451OS_13_14.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![带有 Highcharts 的商业 RIA – 分析器](img/7451OS_13_14.jpg)'
- en: 'The Highcharts events are easily bound with Ext JS components so that a fully
    interactive navigation style becomes possible. For instance, if a peak appears
    on the **Utilisation** graph, the users can either click on the peak data point
    or highlight a region for a specific time range, then a context menu with a selection
    of network graphs pops up. This action means that we can append the selected time
    region to be part of the accumulated filters and navigate towards a specific graph.
    The following is a screenshot of the context menu, which shows up in one of the
    graphs:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Highcharts 事件可以轻松地与 Ext JS 组件绑定，从而实现全交互式导航风格。例如，如果**利用率**图上出现一个峰值，用户可以点击峰值数据点或突出显示特定时间范围内的区域，然后会出现一个包含网络图选择的上下文菜单。这一操作意味着我们可以将选定的时区添加到累积的过滤器中，并导航到特定的图表。以下是一个上下文菜单的截图，它出现在图表之一中：
- en: '![A commercial RIA with Highcharts – Profiler](img/7451OS_13_15.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![带有 Highcharts 的商业 RIA – 分析器](img/7451OS_13_15.jpg)'
- en: If we proceed by selecting the same graph again, **Utilisation**, it means we
    want to zoom into greater detail within the selected time region. This doesn't
    use the Highcharts default zoom action, which just stretches the graph series
    and redraws the axes. In fact, it launches another Ajax query with the selected
    time and returns graph data in finer granularity, so the peak in the graph can
    be diagnosed further. In other words, the application enables the user to visually
    filter through a sequence of different graphs. At the same time, the user gradually
    refines the filters in different dimensions. This process dissects the problem
    into the root cause in a prompt, intuitive, and effective fashion.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过再次选择相同的图表，即**利用率**，这意味着我们想在选定的时区内更详细地放大。这并不使用 Highcharts 的默认缩放操作，它只是拉伸图表系列并重新绘制坐标轴。实际上，它启动了另一个带有选定时间的
    Ajax 查询，并返回更细粒度的图表数据，因此可以进一步诊断图中的峰值。换句话说，该应用程序使用户能够通过一系列不同的图表进行视觉筛选。同时，用户逐渐在不同维度上细化过滤器。这个过程以迅速、直观和有效的方式将问题剖析到根本原因。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the very basics of Ext JS, which is a framework
    for building **Rich Internet Applications** (**RIAs**). We looked at a quick introduction
    of a dozen Ext JS components that are likely to be used with the Highcharts extension
    for Ext JS. Then, we explored how to create a Highcharts component from an existing
    Highcharts configuration in a step-by-step approach. We looked into the small
    set of APIs that are provided by the extension module and built a simple application
    with network usage data. Finally, we took a brief look at Highcharts and Ext JS
    applied to a commercial network profiling application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Ext JS 的基础知识，它是一个用于构建**富互联网应用**（**RIAs**）的框架。我们快速介绍了可能用于与 Highcharts
    扩展结合使用的十几个 Ext JS 组件。然后，我们以逐步的方式探讨了如何从现有的 Highcharts 配置中创建 Highcharts 组件。我们研究了扩展模块提供的少量
    API，并使用网络使用数据构建了一个简单的应用程序。最后，我们简要地看了看 Highcharts 和 Ext JS 在商业网络分析应用中的应用。
- en: In the next chapter, we will explore how to run Highcharts on the server side.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在服务器端运行 Highcharts。
