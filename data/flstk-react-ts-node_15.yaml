- en: '*Chapter 12*: Building the React Client for Our Online Forum Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：为我们的在线论坛应用构建React客户端'
- en: We've come a long way. In this chapter, we'll start coding our application,
    starting with the React client. We will take everything we learned about in the
    previous chapters and build our React app using the new Hooks API. We will also
    use Responsive techniques to build a mobile client that will adapt its views to
    handle both mobile and desktop devices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走了很长的路。在本章中，我们将开始编写我们的应用程序，从React客户端开始。我们将利用前几章学到的一切，使用新的Hooks API构建我们的React应用。我们还将使用响应式技术构建一个移动客户端，该客户端将适应其视图以处理移动设备和桌面设备。
- en: Technical requirements
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You should now have a good understanding of web development using React, Node,
    Express, and GraphQL. You should also be familiar with CSS. We will once again
    be using Node and Visual Studio Code to write our code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对使用React、Node、Express和GraphQL进行Web开发有很好的理解。你也应该熟悉CSS。我们将再次使用Node和Visual
    Studio Code来编写我们的代码。
- en: The GitHub repository for this book can be found at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap12` folder.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的GitHub存储库可以在[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node)找到。使用`Chap12`文件夹中的代码。
- en: To set up the [*Chapter 12*](B15508_12_Final_JC_ePub.xhtml#_idTextAnchor179)
    code folder, go to your `HandsOnTypescript` folder and create a new folder called
    `Chap12`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置[*第12章*](B15508_12_Final_JC_ePub.xhtml#_idTextAnchor179)代码文件夹，转到你的`HandsOnTypescript`文件夹并创建一个名为`Chap12`的新文件夹。
- en: Creating the initial version of our React application
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的React应用的初始版本
- en: In this section, we will be building out our React client. We won't be able
    to complete the client entirely since it will need our backend features, such
    as our GraphQL API, the ability to authenticate, post threads, and so on. However,
    we'll begin creating our main screens and set up Redux and React Router.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建我们的React客户端。我们将无法完全完成客户端，因为它将需要我们的后端功能，比如我们的GraphQL API、认证能力、发布主题等等。但是，我们将开始创建我们的主要屏幕并设置Redux和React
    Router。
- en: There will be a very large amount of code in this section. Please take frequent
    breaks and pace yourself. The code will evolve and get iterated and refactored
    numerous times during our build. Sometimes, it will be for better code reuse.
    Sometimes, it will be to improve our design and its readability. So, if you get
    stuck, please refer to the source code. This will be the most challenging section
    of this book so far.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将包含大量的代码。请经常休息并控制自己的节奏。代码将在我们的构建过程中不断演变、迭代和重构多次。有时，这将是为了更好的代码重用。有时，这将是为了改进我们的设计和可读性。因此，如果你遇到困难，请参考源代码。这将是本书迄今为止最具挑战性的部分。
- en: Note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will not be showing every line of code as that would be redundant. Please
    download and open the source code in your editor to follow along.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会展示每一行代码，因为那将是多余的。请下载并在你的编辑器中打开源代码以便跟随。
- en: 'In this section, we will be covering the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下主题：
- en: React project setup and dependency configuration
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React项目设置和依赖配置
- en: Styling and layout
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式和布局
- en: Core component and feature creation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心组件和功能创建
- en: Tip
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Having everything compile and work from the beginning is actually not of any
    benefit to your learning. Do not focus on getting stuff to simply compile and
    run the first time you do this. Instead, try experimenting and making changes.
    In other words, break the code so that it does not compile and then fix it. This
    is the only way to ensure you understand what you're doing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始就让一切编译和工作实际上对你的学习没有任何好处。不要专注于让东西简单地编译和运行。相反，尝试实验和进行更改。换句话说，打破代码，使其无法编译，然后修复它。这是确保你理解自己在做什么的唯一方法。
- en: 'Let''s start by creating our base project by using `create-react-app`. Then,
    we will add Redux and React Router:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`create-react-app`创建我们的基本项目开始。然后，我们将添加Redux和React Router：
- en: 'Go to the `Chap12` folder from your Terminal and run the following command:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到终端中的`Chap12`文件夹并运行以下命令：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, cd into the new `super-forum-client` folder and run the `start` command
    to make sure it''s working:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入新的`super-forum-client`文件夹并运行`start`命令以确保它正常工作：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s install Redux and React Router:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们安装Redux和React Router：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, now, we have our core packages installed. Before we start coding, we need
    to discuss how we will lay out our application. In our case, we want our application
    to work on both mobile devices and desktops. This way, we can have a single application
    that runs on phones, desktops, and laptops.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在，我们已经安装了我们的核心包。在我们开始编码之前，我们需要讨论如何布置我们的应用程序。在我们的情况下，我们希望我们的应用程序能在移动设备和桌面上运行。这样，我们就可以拥有一个单一的应用程序，可以在手机、桌面和笔记本电脑上运行。
- en: There are multiple ways of approaching this goal. We can use a library such
    as **Bootstrap** or a UI framework such as **Ionic** to help us build out a UI
    and layout. These frameworks are great and work well, but they also hide some
    of the details about how layout and styling work on the web. You can also lose
    some control when using frameworks and end up with a site that looks similar to
    other sites that use the same framework.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以实现这个目标。我们可以使用诸如**Bootstrap**这样的库或**Ionic**这样的UI框架来帮助我们构建UI和布局。这些框架非常好用，但它们也隐藏了一些关于Web上布局和样式工作的细节。使用框架时，你也可能失去一些控制，最终得到的网站看起来与使用相同框架的其他网站类似。
- en: CSS Grid
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS Grid
- en: For our application, we will use Responsive Web Design. Responsive Web Design
    is simply the intent that our web application adapts to different devices and
    screen dimensions. There are many ways, when using web technologies, that we can
    do this. One of them is CSS Grid. With this system, we can structure our application
    screen to make optimal use of desktop space, while at the same time automatically
    reconfigure it for mobile devices. Due to this, we will be using CSS Grid, as
    well as other web technologies, to create our layout.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用响应式网页设计。响应式网页设计只是我们的网页应用程序适应不同的设备和屏幕尺寸的意图。在使用Web技术时，有许多方法可以做到这一点。其中之一就是CSS
    Grid。通过这个系统，我们可以构建我们的应用程序屏幕，充分利用桌面空间，同时自动重新配置为移动设备。因此，我们将使用CSS Grid以及其他Web技术来创建我们的布局。
- en: CSS Grid gives us most of the capabilities that programs such as Bootstrap could
    accomplish. However, CSS Grid is part of the CSS web standard, instead of being
    part of a third-party library. So, we know that our layout will always work with
    the web and will never suddenly become unsupported.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CSS Grid给我们提供了大部分像Bootstrap这样的程序所能实现的功能。但是，CSS Grid是CSS网络标准的一部分，而不是第三方库的一部分。因此，我们知道我们的布局将始终与网络一起工作，永远不会突然不受支持。
- en: 'So, what is CSS Grid? CSS Grid is a layout method built into standard CSS that
    allows us to create flexible layouts using rows and columns. It was created to
    replace the use of tables for layouts. CSS Grid is very capable and there are
    numerous ways of doing the same thing. To keep things simple, I will show you
    one specific way to do this, though you can explore more options later if you
    think you''ll find that useful. Let''s get started using CSS Grid:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是CSS Grid？CSS Grid是内置标准CSS的布局方法，允许我们使用行和列创建灵活的布局。它被创建来取代表格布局的使用。CSS Grid非常强大，有许多做同样事情的方法。为了保持简单，我将向您展示一种特定的方法来做到这一点，尽管如果您认为这将有用，您可以稍后探索更多选项。让我们开始使用CSS
    Grid：
- en: 'First, go back to our project, open `App.tsx`, and remove the contents of the
    `App` object. Do the following:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，回到我们的项目，打开`App.tsx`，并删除`App`对象的内容。做以下事情：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we've gotten rid of most of the contents and replaced it with
    layout placeholders. Of course, we will make components out of these elements
    eventually, but for now, we'll focus on getting our `Grid` layout working.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经摆脱了大部分内容，并用布局占位符替换了它。当然，我们最终会将这些元素制作成组件，但现在，我们将专注于使我们的`Grid`布局工作。
- en: 'Now, let''s replace the contents of the `App.css` file, like this:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们替换`App.css`文件的内容，就像这样：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, there''s a `:root` pseudoclass, which we will use as a container for
    the CSS Variables for our app theme. To make styling and theming more consistent
    and easier, we will use variables instead of hardcoding values. As we build out
    our app, you will see more and more variables being added here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个`:root`伪类，我们将使用它作为我们应用程序主题的CSS变量的容器。为了使样式和主题更一致和更容易，我们将使用变量而不是硬编码的值。随着我们构建应用程序，您将看到这里添加了越来越多的变量：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following margin settings centers our layout:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的边距设置使我们的布局居中：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s a rundown of the Grid-related attributes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与Grid相关的属性的概述：
- en: '`display`: Here, we declare that our element will be of the `grid` type.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display`：在这里，我们声明我们的元素将是`grid`类型。'
- en: '`grid-template-columns`: This attribute tells our app the width of our columns
    in a relative way. In our setup, it indicates we have four columns. The `fr` value
    indicates that some portion of the available width should be given to the column.
    So, for example, in our case, we have four columns, so if each column had exactly
    equal amounts of the available width, each column''s value would be `1fr`. But
    in our case, each column will be using a different amount of width smaller or
    greater than the equal distribution, which is why we have the varying values.
    Possible values can be specific, such as `100px` or `2rem`, percentages, such
    as example `20%`, or implicit, such as .`25fr`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid-template-columns`：这个属性告诉我们的应用程序列的宽度是相对的。在我们的设置中，它表示我们有四列。`fr`值表示应该给列的可用宽度的一部分。因此，例如，在我们的情况下，我们有四列，所以如果每列的可用宽度完全相等，每列的值将是`1fr`。但在我们的情况下，每列将使用不同数量的宽度，比均匀分配的宽度小或大，这就是为什么我们有不同的值。可能的值可以是具体的，比如`100px`或`2rem`，百分比，比如例子`20%`，或者是隐式的，比如`.25fr`。'
- en: '`grid-template-rows`: Indicates the number and size of rows. Possible values
    are the same as columns.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid-template-rows`：指示行的数量和大小。可能的值与列相同。'
- en: '`grid-template-areas`: Every Grid can have labeled sections called areas. As
    this example shows, you simply add the labels for each area in Grid form to the
    columns and rows that you want them to be in. So, in our case, `"nav nav nav nav"`
    represents the first of our two rows with four columns, while `"sidebar leftmenu
    content rightmenu"` represents our second row and each of its columns.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid-template-areas`：每个Grid都可以有称为区域的标记部分。正如这个例子所示，您只需在网格形式的列和行中为每个区域添加标签。因此，在我们的情况下，`"nav
    nav nav nav"`代表我们的两行中的第一行，有四列，而`"sidebar leftmenu content rightmenu"`代表我们的第二行及其每一列。'
- en: '`gap`: This is a way of adding padding in-between columns and rows. The first
    entry indicates the row, while the second indicates the column.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gap`：这是在列和行之间添加填充的一种方法。第一个条目表示行，第二个表示列。'
- en: 'Now that we''ve explained the basic features of CSS Grid, let''s look at the
    styling for the related sections of the Grid. The remaining styles are for the
    Grid content areas:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经解释了CSS Grid的基本特性，让我们来看看与Grid相关部分的样式。剩下的样式是用于Grid内容区域的：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, they have a `grid-area` attribute, which indicates which area
    of the Grid the element belongs to. The `nav` area will be for navigation. `sidebar`
    will show a menu of user-specific settings and will only appear for desktops and
    laptops; it will be hidden for mobile devices. `leftmenu` will be used to store
    our Thread categories list. `content` will house our main list of Threads, filtered
    by category. Finally, `rightmenu` will show a list of popular or otherwise relevant
    Threads.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它们有一个`grid-area`属性，指示元素属于网格的哪个区域。`nav`区域将用于导航。`sidebar`将显示用户特定设置的菜单，并且仅在桌面和笔记本电脑上显示；它将在移动设备上隐藏。`leftmenu`将用于存储我们的主题类别列表。`content`将容纳我们按类别筛选的主题列表。最后，`rightmenu`将显示一些热门或相关的主题列表。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I am using these awkward `background-color` settings temporarily, only to distinguish
    between each area clearly. Eventually, we will remove them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我暂时使用这些尴尬的`background-color`设置，只是为了清楚地区分每个区域。最终，我们会将它们删除。
- en: Now, we have a basic layout for our app that works for desktop and laptop devices.
    But how can we make this auto reconfigure itself for smaller screens, such as
    phones and tablets? There is a CSS technology called **Media Queries** that could
    be of help in situations like this. However, for our needs, it alone is insufficient.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序在桌面和笔记本设备上都有一个基本布局。但是，我们如何使其自动重新配置以适应较小的屏幕，比如手机和平板电脑？有一种名为**媒体查询**的CSS技术可以在这种情况下提供帮助。然而，对于我们的需求来说，它单独是不够的。
- en: We are building our app dynamically, using React driven by state changes. This
    means that certain screen components should not be drawn if they are not needed
    or cannot be displayed on smaller devices. So, although we could use Media Queries
    to hide elements when smaller screens are detected, it would be an inefficient
    use of resources to have React render something that is never going to be seen
    or directly used by the user.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在动态构建我们的应用程序，使用由状态更改驱动的React。这意味着在较小的设备上，某些屏幕组件不应该被绘制，如果它们不需要或者不能在较小的设备上显示。因此，尽管我们可以使用媒体查询在检测到较小的屏幕时隐藏元素，但让React渲染永远不会被用户看到或直接使用的东西将是资源的低效使用。
- en: 'Instead, let''s see what we can do in code using event handling and React Hooks
    to take care of this issue:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们看看我们可以在代码中如何使用事件处理和React Hooks来解决这个问题：
- en: The first thing we want to do is convert our elements into React components.
    Let's create a new folder inside the `src` folder called `components`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们要做的是将我们的元素转换为React组件。让我们在`src`文件夹内创建一个名为`components`的新文件夹。
- en: 'Then, inside that folder, create a container component for each of the elements
    that were inside the root `div` of our `App` component. Your `src` folder and
    the `App.tsx` file should now look like this:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在该文件夹内，为我们`App`组件的根`div`中的每个元素创建一个容器组件。现在，您的`src`文件夹和`App.tsx`文件应该是这样的：
- en: '![Figure 12.1 – Refactored App.tsx file'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 重构后的App.tsx文件'
- en: '](img/Figure_12.01_B15508.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.01_B15508.jpg)'
- en: Figure 12.1 – Refactored App.tsx file
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 重构后的App.tsx文件
- en: 'Due to brevity, I won''t review every single file we need to create here since
    it is highly repetitive code, but here''s a sample of the updated `Main` component
    (the source code will, of course, contain the complete application code for all
    components):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于篇幅限制，我不会审查我们需要在这里创建的每个文件，因为这是高度重复的代码，但这是更新后的`Main`组件的一个示例（当然，源代码将包含所有组件的完整应用程序代码）：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, we just moved our code from `App.tsx` into the component''s
    `Main.tsx` file. This means you''ll need to create the remaining components; that
    is, `Nav`, `SideBar`, `LeftMenu`, and `RightMenu`. Here''s a screenshot of the
    React Developer Tools screen showing our component hierarchy so far. React Developer
    Tools was discussed in *Chapter 6, Setting Up Our Project Using create-react-app
    and Testing with Jest*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是将我们的代码从`App.tsx`移动到组件的`Main.tsx`文件中。这意味着您需要创建剩下的组件；也就是说，`Nav`、`SideBar`、`LeftMenu`和`RightMenu`。这是React
    Developer Tools屏幕的截图，显示了我们目前的组件层次结构。React Developer Tools在*第6章，使用create-react-app设置我们的项目并使用Jest进行测试*中进行了讨论：
- en: '![Figure 12.2 – Component hierarchy view'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – 组件层次结构视图'
- en: '](img/Figure_12.02_B15508.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.02_B15508.jpg)'
- en: Figure 12.2 – Component hierarchy view
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 组件层次结构视图
- en: Notice that we have the **Nav**, **SideBar**, **LeftMenu**, **Main**, and **RightMenu**
    components here. Each component represents the areas of our app on the root of
    our website. Note that we will have more screens than this as we build out our
    app.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里有**Nav**、**SideBar**、**LeftMenu**、**Main**和**RightMenu**组件。每个组件代表我们网站根目录上的应用程序区域。请注意，随着我们构建应用程序，我们将有更多的屏幕。
- en: We had to do this componentization anyway because we are building a React application.
    But how does this help us with our desire to make our web app responsive so that
    it auto-configures to different device screens? By separating out each area of
    the Grid into its own component, we can allow each component to use a React Hook
    that looks for screen size information. Due to this, if the component is not appropriate
    for a certain screen size, it will not render or render differently.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们必须进行这种组件化，因为我们正在构建一个React应用程序。但是这如何帮助我们实现我们的愿望，使我们的Web应用程序响应，以便自动配置到不同的设备屏幕？通过将网格的每个区域分离为自己的组件，我们可以允许每个组件使用一个React
    Hook来查找屏幕尺寸信息。因此，如果组件不适合某个屏幕尺寸，它将不会渲染或以不同的方式渲染。
- en: In order to make this responsive system work, we'll need two main features.
    First, we'll need some additional CSS styles that use Media Queries to lay out
    our Grid differently when smaller devices are detected. Additionally, we'll need
    to have our components become aware when certain screen sizes are being used and
    either not render the component or render it differently. Let's see what that
    code looks like.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个响应式系统工作，我们需要两个主要功能。首先，我们需要一些额外的CSS样式，使用媒体查询在检测到较小设备时以不同的方式布局我们的网格。此外，我们需要让我们的组件在使用特定屏幕尺寸时变得意识到，并且要么不渲染组件，要么以不同的方式渲染它。让我们看看代码是什么样子的。
- en: 'First, let''s create our media queries for mobile devices. Open your `App.css`
    file and add the following Media Query to the bottom of our file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为移动设备创建媒体查询。打开您的`App.css`文件，并在文件底部添加以下媒体查询：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we are overriding the original `App` class definition whenever the device''s
    `orientation` is in `portrait` mode and the resolution is `768px` or less. If
    you run the app using Chrome Developer Tools in mobile mode as an iPhone X, you
    should see this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当设备的`orientation`处于`portrait`模式且分辨率为`768px`或更低时，我们覆盖了原始的`App`类定义。如果您在iPhone
    X上使用Chrome开发者工具以移动模式运行应用程序，您应该会看到这个：
- en: '![Figure 12.3 – Chrome Developer Tools view of our app in mobile mode'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 - Chrome开发者工具中我们应用程序的移动模式视图'
- en: '](img/Figure_12.03_B15508.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.03_B15508.jpg)'
- en: Figure 12.3 – Chrome Developer Tools view of our app in mobile mode
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 - Chrome开发者工具中我们应用程序的移动模式视图
- en: 'The app has a white right-hand side because we are still rendering the elements
    that existed in the original desktop mode. We''ll fix this soon. Now, let''s create
    our **Hook**, which helps handle device size-based rendering:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序右侧是白色的，因为我们仍在渲染原始桌面模式中存在的元素。我们很快会解决这个问题。现在，让我们创建我们的**Hook**，它有助于处理基于设备尺寸的渲染：
- en: Create a folder inside the `src` folder called `hooks`. Then, add a file called
    `useWindowDimensions.ts`. Notice that it is not a component since it has a `ts`
    extension. Copy the source code from this book's GitHub repository and let's go
    through it.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹内创建一个名为`hooks`的文件夹。然后，添加一个名为`useWindowDimensions.ts`的文件。请注意，它不是一个组件，因为它有一个`ts`扩展名。从本书的GitHub存储库中复制源代码，然后我们来看一下。
- en: First, we create an interface called `WindowDimension` so that we can type in
    what is returned by our Hook, which in this case is the browser's `window` object
    dimensions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`WindowDimension`的接口，以便我们可以为我们的Hook返回的内容进行类型化，这种情况下是浏览器的`window`对象尺寸。
- en: Then, on *line 8*, we name our `useWindowDimensions` Hook. Then, on the next
    line, we create a state object called `dimension` and give it a value of `0` for
    `height` and `0` for `width`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*第8行*，我们命名我们的`useWindowDimensions` Hook。然后，在下一行，我们创建一个名为`dimension`的状态对象，并为`height`和`width`赋值为`0`。
- en: Next, we create our handler function, `handleResize`, which will use the state
    update method, `setDimension`, to set our dimension values. The `window` object
    of our browser provides the dimension values.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的处理函数`handleResize`，它将使用状态更新方法`setDimension`来设置我们的尺寸值。我们浏览器的`window`对象提供了尺寸值。
- en: Finally, starting no *line 21*, we use the `useEffect` Hook to handle the window's
    `resize` event. Note that an empty array, `[]`, means that this will run only
    once on first load. Also, note that when we add an event handler, we must also
    return an event remover (this prevents memory leaks and redundant event handlers
    from being added).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从*第21行*开始，我们使用`useEffect` Hook来处理窗口的`resize`事件。请注意，空数组`[]`表示这将仅在首次加载时运行。还要注意，当我们添加事件处理程序时，我们还必须返回一个事件移除器（这可以防止内存泄漏和冗余事件处理程序被添加）。
- en: 'Now, we need to update our `SideBar`, `LeftMenu`, and `RightMenu` components
    so that they will use our `useWindowDimensions` Hook and know not to render when
    a device has a width of less than or equal to `768` (the same as our media query).
    The code to use with the Hook is identical across each of these components, so
    I will only show the `SideBar` component here. Please update the other components
    yourself in a similar manner:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新我们的`SideBar`、`LeftMenu`和`RightMenu`组件，以便它们将使用我们的`useWindowDimensions`
    Hook，并且知道在设备宽度小于或等于`768`时不进行渲染（与我们的媒体查询相同）。使用Hook的代码在这些组件中是相同的，所以我只会在这里展示`SideBar`组件。请以类似的方式自行更新其他组件：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we use the `useWindowDimensions` Hook to get the `width` dimension.
    We then check if it is `768` or lower and if it is, we return `null`; otherwise,
    we return the normal JSX. The other components will have the same code for the
    `useWindowDimensions` Hook.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用`useWindowDimensions` Hook来获取`width`维度。然后我们检查它是否为`768`或更低，如果是，我们返回`null`；否则，我们返回正常的JSX。其他组件将使用相同的代码来使用`useWindowDimensions`
    Hook。
- en: 'If you run the app, you will see that the white gap is now gone and that these
    components are not rendered in the HTML. Note that to save time, we will only
    support desktop and mobile portrait mode for iPhone X. Supporting every possible
    device configuration is beyond the scope of this book. Here is a good link on
    the topic of supporting multiple device screens from Google: [https://developers.google.com/web/fundamentals/codelabs/your-first-multi-screen-site](https://developers.google.com/web/fundamentals/codelabs/your-first-multi-screen-site).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，您会看到白色间隙现在已经消失，并且这些组件不会在HTML中进行渲染。请注意，为了节省时间，我们只会支持iPhone X的桌面和移动纵向模式。支持每种可能的设备配置超出了本书的范围。这是一个关于支持多个设备屏幕的主题的好链接：[https://developers.google.com/web/fundamentals/codelabs/your-first-multi-screen-site](https://developers.google.com/web/fundamentals/codelabs/your-first-multi-screen-site)。
- en: Before we continue, let's flesh out our client base configurations, such as
    Redux and React Router.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们完善我们的客户端基本配置，如Redux和React Router。
- en: Update your `index.tsx` file so that it includes Redux and React Router. We
    covered Redux and React Router in [*Chapter 7*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*,
    Learning Redux and React Router*. As always, the source code is available if you
    get stuck.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的`index.tsx`文件，以便包含Redux和React Router。我们在[*第7章*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*，学习Redux和React
    Router*中涵盖了Redux和React Router。如果遇到困难，源代码始终可用。
- en: Now, let's create a folder inside the `src` folder called `store` and add our
    Redux files there. Create the `AppState.ts` and `configureStore.ts` files and
    enter the code as shown in the source files. We are not ready for `UserProfileReducer`
    yet, so you can leave it out for now. We won't be using Redux middleware since
    I showed this in [*Chapter 7*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*,
    Learning Redux and React Router*.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`src`文件夹内创建一个名为`store`的文件夹，并在其中添加我们的Redux文件。创建`AppState.ts`和`configureStore.ts`文件，并输入源文件中显示的代码。我们现在还没有准备好`UserProfileReducer`，所以您可以暂时将其排除在外。我们不会使用Redux中间件，因为我在[*第7章*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*，学习Redux和React
    Router*中展示了这一点。
- en: Now, before we continue and start creating components, let's add a newer React
    feature to our app that will help us add more polish.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们继续并开始创建组件之前，让我们向我们的应用程序添加一个新的React功能，这将帮助我们增加更多的亮点。
- en: Error Boundaries
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误边界
- en: 'Error Boundaries is a lot like exception handling for React Components. In
    a large app, it is not always possible to prevent all errors that may occur. So,
    by using Error Boundaries with our components, we can "catch" unanticipated errors
    and provide a better user experience to our users. When errors occur, we''ll display
    an error screen that we pre-create rather than some ominous looking technical
    error message. Let''s get started:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界很像是React组件的异常处理。在大型应用程序中，通常无法防止所有可能发生的错误。因此，通过在我们的组件中使用错误边界，我们可以“捕获”意外错误，并为用户提供更好的用户体验。发生错误时，我们将显示一个预先创建的错误屏幕，而不是一些看起来可怕的技术错误消息。让我们开始吧：
- en: First, let's create our Error Boundary file. Inside of the `components` folder,
    create a file called `ErrorBoundary.tsx` and add the source code from this book's
    GitHub repository to it. Note that Error Boundaries still uses the older class
    style because we need the `getDerivedStateFromError` and `componentDidCatch` life
    cycle event handlers to catch errors. The React team does plan to add a Hooks
    equivalent eventually.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的错误边界文件。在`components`文件夹内，创建一个名为`ErrorBoundary.tsx`的文件，并将此书的GitHub存储库中的源代码添加到其中。请注意，错误边界仍然使用旧的类样式，因为我们需要`getDerivedStateFromError`和`componentDidCatch`生命周期事件处理程序来捕获错误。React团队确实计划最终添加Hooks等效功能。
- en: At the top of the file, notice that we also have a matching CSS style file.
    It's trivial, so I won't show it here, but you can find it in the source code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，请注意我们还有一个匹配的CSS样式文件。这很琐碎，所以我不会在这里展示，但您可以在源代码中找到它。
- en: First, we will create a type for our Error Boundary's props called `ErrorBoundaryProps`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为我们的错误边界的props创建一个类型，称为`ErrorBoundaryProps`。
- en: Next, we must create another type for our Error Boundary's local state called
    `ErrorBoundaryState`. At the beginning of the `ErrorBoundary` class definition,
    we will see some boilerplate with the constructor for setting up the state. Immediately
    following this, we will use the `getDerivedStateFromError` function to tell React
    to show the error UI if `hasError` is true.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须为我们的错误边界的本地状态创建另一种类型，称为`ErrorBoundaryState`。在`ErrorBoundary`类定义的开头，我们将看到一些用于设置状态的构造函数的样板。紧接着，我们将使用`getDerivedStateFromError`函数告诉React如果`hasError`为true，则显示错误UI。
- en: On *line 31*, it is in our `componentDidCatch` function that our component realizes
    an error of some kind occurred and sets our `hasError` state variable to true.
    We can also run our own code here to log errors and notify support if needed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第31行*，在我们的`componentDidCatch`函数中，我们的组件意识到发生了某种错误，并将我们的`hasError`状态变量设置为true。我们还可以在这里运行我们自己的代码来记录错误并在需要时通知支持。
- en: Finally, if `hasError` is true, we render our message so that users do not have
    to see strange technical messages that can be confusing. You can, of course, write
    your own custom message.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果`hasError`为true，我们会呈现我们的消息，以便用户不必看到可能令人困惑的奇怪技术消息。当然，您可以编写自己的自定义消息。
- en: Warning
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Error Boundaries do not catch errors that are occurring inside event handlers,
    asynchronous code, or server-side rendered React, as well as errors thrown by
    Error Boundaries themselves. You must deal with those yourself generally using
    `try catch`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界不会捕获发生在事件处理程序、异步代码或服务器端渲染的React中的错误，以及错误边界本身抛出的错误。通常情况下，您必须自己处理这些错误，使用`try
    catch`。
- en: 'Now, let''s test our Error Boundary by throwing an error inside one of our
    components. Update the `Main.tsx` file''s `Main` function, like this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过在其中一个组件中抛出错误来测试我们的错误边界。更新`Main.tsx`文件的`Main`函数，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we deliberately throw an `Error`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们故意抛出了一个`Error`。
- en: Try running the app now. You should see the type of screen we were trying to
    avoid. Why is this happening? This is happening because we are currently in development
    mode and React deliberately shows all errors in this mode. If we were in production
    mode, by running `npm run build`, we would see the Error Boundary message.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试运行应用程序。您应该会看到我们试图避免的屏幕类型。为什么会发生这种情况？这是因为我们目前处于开发模式，React故意在此模式下显示所有错误。如果我们处于生产模式，通过运行`npm
    run build`，我们将看到错误边界消息。
- en: 'However, we can still view our Error Boundary screen while in development mode
    if we click on the **x** button on the Chrome browser''s upper right-hand corner.
    If you do this, you should see the following message:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在开发模式下，我们仍然可以在Chrome浏览器右上角点击**x**按钮来查看我们的错误边界屏幕。如果您这样做，您应该会看到以下消息：
- en: '![Figure 12.4 – Error Boundary message'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 – 错误边界消息'
- en: '](img/Figure_12.04_B15508.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.04_B15508.jpg)'
- en: Figure 12.4 – Error Boundary message
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 错误边界消息
- en: As you can see, our normal error message now appears. And again, feel free to
    style this message as you see fit. To save time, we will leave it as-is.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在显示了正常的错误消息。再次，随意根据您的喜好设置此消息的样式。为了节省时间，我们将保持原样。
- en: Data Service layer
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据服务层
- en: 'In our application, we will be making calls to either a GraphQL API or a Web
    API, or fetching network calls. However, none of these backend services are ready
    yet. For now, we''ll create a file that will contain fake network calls to simulate
    a real backend. Once our real backend arrives, we will remove this feature:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将调用GraphQL API或Web API，或者获取网络调用。但是，这些后端服务都还没有准备好。现在，我们将创建一个文件，其中包含模拟真实后端的假网络调用。一旦我们的真实后端到位，我们将删除此功能：
- en: First, create a folder called `services` inside `src` and then create the `DataService.ts`
    file inside it. Since this is code we will soon discard, I won't show it here,
    but you can grab the code from the source files. Note that some references to
    Model types will be in this service, so you'll need to add those and we'll cover
    them as this chapter progresses.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`src`内创建一个名为`services`的文件夹，然后在其中创建`DataService.ts`文件。由于这是我们很快会丢弃的代码，我不会在这里展示，但你可以从源文件中获取代码。请注意，此服务中将包含对模型类型的一些引用，因此您需要添加这些引用，并且在本章的进展中我们将对其进行讨论。
- en: Now that we have a way of getting data, let's update our `LeftMenu` component
    so that it uses it. But first, we need to create our `Category` type since we
    are using TypeScript. Create a new folder called `model` inside `src`. Then, create
    the `Category.ts` file and add the source code to it.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了获取数据的方法，让我们更新我们的`LeftMenu`组件，以便使用它。但首先，我们需要创建我们的`Category`类型，因为我们使用的是TypeScript。在`src`内创建一个名为`model`的新文件夹。然后，创建`Category.ts`文件并添加源代码。
- en: Now, update the `LeftMenu.tsx` file. First, we will update the imports by adding
    the model type called `Category` and then the `LeftMenu.css` file. We'll be using
    these later in our code.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`LeftMenu.tsx`文件。首先，我们将通过添加名为`Category`的模型类型和`LeftMenu.css`文件来更新导入。我们稍后会在我们的代码中使用它们。
- en: Then, on *line 9*, create our state object called `categories` that contains
    our list of categories. Before we can load `Category` data, we need some default
    text, `Left Menu`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在*line 9*上，创建我们的状态对象`categories`，其中包含我们的类别列表。在我们加载`Category`数据之前，我们需要一些默认文本，`Left
    Menu`。
- en: Then, on *line 13*, we have `useEffect`, where we make a call to our `getCategories`
    function and get our `Categories`. Then, we use the ES6 `map` function to convert
    our objects into JSX.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在*line 13*上，我们有`useEffect`，在其中我们调用我们的`getCategories`函数并获取我们的`Categories`。然后，我们使用ES6的`map`函数将我们的对象转换为JSX。
- en: Finally, in the returned JSX, we use the `Categories` state object in our UI.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在返回的JSX中，我们在UI中使用`Categories`状态对象。
- en: 'If you reload your browser, you will see a 2-second delay due to the timers
    in our fake `DataService`, and then the list of categories, like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新加载浏览器，您将看到由于我们假的`DataService`中的定时器而出现2秒的延迟，然后显示类别列表，就像这样：
- en: '![Figure 12.5 – Loaded categories'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 - 加载的类别'
- en: '](img/Figure_12.05_B15508.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.05_B15508.jpg)'
- en: Figure 12.5 – Loaded categories
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 - 加载的类别
- en: Again, we'll remove `DataService` once our real server calls are ready.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的真实服务器调用准备就绪，我们将删除`DataService`。
- en: Navigation menu
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航菜单
- en: Now that we have a base configuration and layout, we can start creating our
    SideBar menu. The interesting thing about our SideBar menu items is that they
    will be used on both the SideBar and as a drop-down modal for mobile devices.
    This way, we can write less code by having only a single component for both display
    types.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本配置和布局，我们可以开始创建我们的侧边栏菜单。我们的侧边栏菜单项的有趣之处在于它们将同时用于侧边栏和作为移动设备的下拉模态框。这样，我们可以通过只有一个组件来减少代码量。
- en: 'Now, in order to create the SideBar with a correct set of links, we need to
    know if the user is logged in. If they are not logged in, we will show them login
    and register menus. If they are logged in, we will show them logout and UserProfile
    menus. The UserProfile menu screen will show the user''s settings, as well as
    a list of posts that they have made. Since the login state of our user will be
    shared across the application, let''s put this data into our Redux store:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建具有正确链接集的侧边栏，我们需要知道用户是否已登录。如果他们没有登录，我们将显示登录和注册菜单。如果他们已登录，我们将显示注销和用户配置文件菜单。用户配置文件菜单屏幕将显示用户的设置，以及他们发布的帖子列表。由于我们的用户的登录状态将在整个应用程序中共享，让我们将这些数据放入我们的Redux存储中：
- en: We will use the existence of a `UserProfile` object instance, or lack thereof,
    as an indication that a user is logged in. First, let's add a new reducer to our
    currently empty reducers set. Create a new folder inside `store` called `user`.
    Now, create a file called `Reducer.ts` and add the required source code.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`UserProfile`对象实例的存在或不存在作为用户已登录的指示。首先，让我们向当前空的reducers集合中添加一个新的reducer。在`store`内创建一个名为`user`的新文件夹。现在，创建一个名为`Reducer.ts`的文件并添加所需的源代码。
- en: Then, create an action type called `UserProfileSetType` so that our `UserProfileReducer`
    can be distinguished from other reducers.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`UserProfileSetType`的操作类型，以便我们的`UserProfileReducer`可以与其他reducer区分开。
- en: Next, we must create a payload type called `UserProfilePayload`. This is the
    data that will be in our actions when they are dispatched later.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个名为`UserProfilePayload`的有效负载类型。这是我们的操作在稍后分派时将包含的数据。
- en: Then, we must create the `UserProfileAction` interface, which is of the `action`
    type. This is used to distinguish an action for UserProfiles from some other action
    type.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须创建`UserProfileAction`接口，它是`action`类型的。这用于区分用户配置文件的操作与其他操作类型。
- en: Finally, we have our actual reducer, `UserProfileReducer`, which performs filtering
    based on our desired `UserProfileSetType`. Again, Redux was covered in [*Chapter
    7*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*, Learning Redux and React
    Router.*
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有我们的实际reducer，`UserProfileReducer`，它根据我们期望的`UserProfileSetType`执行过滤。再次强调，Redux在[*第7章*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*中已经涵盖了，学习Redux和React
    Router。*
- en: 'In order to help us style our components, we''ll need to use icons to provide
    a better visual presentation. Let''s install Font Awesome as it is a free and
    provides an attractive kit of styles and icons that are very popular for web development.
    Run the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助我们样式化我们的组件，我们需要使用图标来提供更好的视觉呈现。让我们安装Font Awesome，因为它是免费的，并提供了一个吸引人的样式和图标套件，非常受欢迎的网页开发。运行以下命令：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we''ve added our icons, let''s create a new folder inside `src/components`
    called `sidebar` and move our existing `SideBar.tsx` file into it. Now, create
    a new file called `SideBarMenus.tsx` and add the following code to it. Make sure
    you''ve added the necessary imports:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经添加了我们的图标，让我们在`src/components`文件夹内创建一个名为`sidebar`的新文件夹，并将现有的`SideBar.tsx`文件移动到其中。现在，创建一个名为`SideBarMenus.tsx`的新文件，并将以下代码添加到其中。确保你已经添加了必要的导入：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We use the `useSelector` and `useDispatch` Hooks to access Redux''s capabilities:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`useSelector`和`useDispatch` Hook来访问Redux的功能：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we use a `useEffect` Hook to call, dispatch, and update our `UserProfile`
    object. Notice that it is now hardcoded, but we will use a GraphQL call later
    when our backend is ready:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`useEffect` Hook来调用、分发和更新我们的`UserProfile`对象。注意它现在是硬编码的，但是当我们的后端准备好时，我们将使用GraphQL调用：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we must add a `FontAwesome` font for the UserProfile and then show the
    current `username`. This menu item will eventually be clickable so that our user''s
    profile screen appears:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须为UserProfile添加一个`FontAwesome`字体，然后显示当前的`用户名`。这个菜单项最终将是可点击的，这样我们用户的个人资料屏幕就会出现：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we build out our screens to log in, log out, register, and so on, we will
    add these menu items to this JSX.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的登录、登出、注册等屏幕时，我们将把这些菜单项添加到这个JSX中。
- en: 'I personally find bullet points distracting, so let''s remove all the bullets
    from all the app''s unordered lists by adding the following style to the `index.css`
    file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人觉得项目符号很分散注意力，所以让我们通过在`index.css`文件中添加以下样式来移除应用程序所有无序列表的项目符号：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we need to update `SideBar.tsx` so that it uses `SideBarMenus.tsx`. Update
    `SideBar` like this. First, add the appropriate imports, such as `SideBarMenus`,
    first:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新`SideBar.tsx`，使其使用`SideBarMenus.tsx`。像这样更新`SideBar`。首先，添加适当的导入，比如`SideBarMenus`，首先：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we can update the JSX to include it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新JSX来包含它。
- en: Note that we will eventually write some code so that the `UserProfile` icon
    and `userName` will only appear when our user is actually logged in. We will also
    click enable it so that clicking on it opens our user's UserProfile screen. However,
    we cannot do this without our backend. For now, we will have it as a placeholder.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们最终会编写一些代码，以便`UserProfile`图标和`userName`只在用户实际登录时出现。我们还将使其可点击，以便点击它会打开用户的UserProfile屏幕。然而，没有我们的后端，我们无法做到这一点。现在，我们将其作为一个占位符。
- en: 'Let''s continue and reuse our `SideBarMenus` component for mobile display.
    Update the `Nav.tsx` file inside the `components` folder. Add the appropriate
    imports:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续并重用我们的`SideBarMenus`组件来进行移动显示。在`components`文件夹内更新`Nav.tsx`文件。添加适当的导入：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Again, we have used our `useWindowDimensions` Hook to determine if we are on
    a mobile device. However, this time, we have created a function called `getMobileMenu`
    to handle the logic of deciding what JSX to return. If we are not running a mobile
    device, it returns nothing; otherwise, it returns the `FontAwesome` icon for the
    hamburger menu:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用我们的`useWindowDimensions` Hook来确定我们是否在移动设备上。然而，这一次，我们创建了一个名为`getMobileMenu`的函数来处理决定返回什么JSX的逻辑。如果我们不是在移动设备上运行，它不返回任何东西；否则，它返回汉堡菜单的`FontAwesome`图标：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The screen, when viewed on a mobile device, should look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当在移动设备上查看屏幕时，应该是这样的：
- en: '![Figure 12.6 – Nav menu in mobile mode'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 - 移动模式下的导航菜单'
- en: '](img/Figure_12.06_B15508.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.06_B15508.jpg)'
- en: Figure 12.6 – Nav menu in mobile mode
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 - 移动模式下的导航菜单
- en: 'As we build out our app, we need to be able to display modals. So, before we
    continue, we need to install `react-modal`. This package will allow us to make
    some components modal popups. This makes them more flexible in terms of when we
    can display them. Install `react-modal` like this:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建我们的应用程序时，我们需要能够显示模态框。因此，在继续之前，我们需要安装`react-modal`。这个包将允许我们创建一些组件模态弹出框。这使得它们在何时显示上更加灵活。像这样安装`react-modal`：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In order to use this modal and have it be responsive and adapt to different
    device screens, we need to update our styles. In our `App.css` file, you will
    see a class called `modal-menu` that has been applied to all our modals.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用这个模态框并使其响应并适应不同的设备屏幕，我们需要更新我们的样式。在我们的`App.css`文件中，你会看到一个名为`modal-menu`的类被应用到了所有的模态框上。
- en: This is the default style for modals that our non-mobile devices will get. The
    main thing to note here is that the modal starts its `left` position at 50% of
    the screen. Then, we use `transform` to pull it back halfway (50% of itself).
    This should center our modal so that it's in the middle of the screen. Notice
    that `z-index` is set high to ensure this modal always appears on top.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的非移动设备将获得的模态框的默认样式。这里需要注意的主要是模态框从屏幕的50%位置开始。然后，我们使用`transform`将其拉回一半（自身的50%）。这样可以使我们的模态框居中，使其位于屏幕的中间。请注意，`z-index`设置得很高，以确保这个模态框始终显示在顶部。
- en: For mobile devices, we use our `App.css` file's existing Media Query to hold
    an updated `modal-menu`. Basically, we are overriding the same attributes that
    were in the desktop styles with styles for the mobile Media Query. In this case,
    we are using `left`, `right`, and `top` to stretch out the modal to the ends of
    the available screen. This is why our transform is now 0, since it's not needed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动设备，我们使用`App.css`文件中现有的媒体查询来保存一个更新后的`modal-menu`。基本上，我们正在覆盖桌面样式中的相同属性，使用移动媒体查询的样式。在这种情况下，我们使用`left`、`right`和`top`来将模态框拉伸到可用屏幕的两端。这就是为什么我们的transform现在是0，因为它不再需要。
- en: Moving on, we will add our click handler to the hamburger icon and then show
    our `SideBarMenus` component when the icon is clicked. So, we'll need to update
    our `Nav.tsx` file again so that it includes our modal, which displays `SideBarMenus`.
    Let's update `Nav.tsx`. Add the appropriate imports first. Then, add the code
    from the source.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为汉堡图标添加点击处理程序，然后在图标被点击时显示我们的`SideBarMenus`组件。因此，我们需要再次更新我们的`Nav.tsx`文件，以便包含我们的模态框，其中显示`SideBarMenus`。让我们更新`Nav.tsx`。首先添加适当的导入。然后，添加源代码中的代码。
- en: If we start by looking on *line 10*, we will see we have a new local state called
    `showMenu`. We'll use this to control whether we show or hide our modal menu.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们从*第10行*开始查看，我们会看到一个名为`showMenu`的新本地状态。我们将使用它来控制我们是显示还是隐藏我们的模态菜单。
- en: The `onClickToggle` handler is used in `FontAwesomeIcon`, inside the `getMobileMenu`
    function, to toggle the `showMenu` local state, which shows or hides the modal.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onClickToggle`处理程序在`FontAwesomeIcon`中使用，在`getMobileMenu`函数内，用于切换`showMenu`本地状态，从而显示或隐藏模态框。'
- en: In a `ReactModal`, when any request to close comes into the component, we need
    to set the state controlling display so that it can be explicitly set to false;
    otherwise, the modal will not go away. This is what `onRequestClose` does. The
    `shouldCloseOnOverlayClick` property allows us to close the modal, even when we
    click anywhere outside it. This is a commonly expected behavior by users, so it's
    good to have.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ReactModal`中，当任何关闭请求进入组件时，我们需要设置控制显示的状态，以便可以明确地将其设置为false；否则，模态框将不会消失。这就是`onRequestClose`的作用。`shouldCloseOnOverlayClick`属性允许我们关闭模态框，即使我们在外部任何地方点击也可以。这是用户通常期望的行为，所以最好有。
- en: Finally, the JSX has been updated so that we can add our `ReactModal`, which
    includes our `SideBarMenus` component.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，JSX已经更新，以便我们可以添加我们的`ReactModal`，其中包括我们的`SideBarMenus`组件。
- en: As you can see, the modal is called `ReactModal` and that among its properties,
    there's the prop called `isOpen`. This determines whether the modal is shown or
    not.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，模态框被称为`ReactModal`，在其属性中，有一个名为`isOpen`的属性。这决定了模态框是否显示。
- en: 'If you run the code and then click on the hamburger icon, you will see this:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行代码，然后点击汉堡图标，您将看到这个：
- en: '![Figure 12.7 – ReactModel with SideBarMenus'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – 带有SideBarMenus的ReactModel'
- en: '](img/Figure_12.07_B15508.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.07_B15508.jpg)'
- en: Figure 12.7 – ReactModel with SideBarMenus
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 带有SideBarMenus的ReactModel
- en: Again, we will be building out this menu as we add more features.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，随着我们添加更多功能，我们将扩展此菜单。
- en: Authentication components
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证组件
- en: 'Now that we have our SideBar set up, let''s start building our authentication
    components. We''ll start by building our register, login, and logout screens:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了我们的SideBar，让我们开始构建我们的身份验证组件。我们将首先构建我们的注册、登录和注销屏幕：
- en: 'Let''s create the registration modal first. In order to do this, we''ll need
    to add a link for registration inside our `SideBarMenus` component. Open the `SideBarMenus.tsx`
    file and update it like this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建注册模态框。为了做到这一点，我们需要在`SideBarMenus`组件内部添加一个注册链接。打开`SideBarMenus.tsx`文件并像这样更新它：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, before we create our Registration component, let''s create a helper service
    that validates our passwords for us. We want to make sure users enter sufficiently
    long and complex passwords, so we need a `src` called `common` and then another
    folder called `validators`. In the `validators` folder, create a file called `PasswordValidator.ts`
    and add the following code to it. The code is pretty simple, so I won''t show
    all of it here, but do notice the password strength and the Regular Expression.
    A Regular Expression is just a programmatic way of searching for patterns in a
    string:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在创建注册组件之前，让我们创建一个辅助服务，用于验证我们的密码。我们希望确保用户输入足够长且复杂的密码，因此我们需要一个名为`common`的`src`，然后另一个名为`validators`的文件夹。在`validators`文件夹中，创建一个名为`PasswordValidator.ts`的文件，并将以下代码添加到其中。代码非常简单，所以我不会在这里展示全部，但请注意密码强度和正则表达式。正则表达式只是在字符串中搜索模式的编程方式：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we''ve used a Regular Expression to check for proper complexity by ensuring
    that we have both letters, numbers, and symbols in our password. Parantheses represent
    a set of related expressions. So, first, we have lowercase letters, then uppercase
    letters, then numbers, then symbols, and finally an expected length:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了正则表达式来检查适当的复杂性，确保我们的密码中既有字母、数字又有符号。括号表示一组相关表达式。因此，首先是小写字母，然后是大写字母，然后是数字，然后是符号，最后是预期长度：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code isn't particularly complicated, but since we are going to need this
    across several components, such as registration and on the server, having it in
    a separate file is better for code reuse.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不特别复杂，但由于我们将需要在多个组件中使用，比如注册和服务器端，将其放在一个单独的文件中更有利于代码重用。
- en: Note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In SPA web development, validations are generally done twice – once on the client
    and again on the server. Doing this twice may seem redundant, but it's necessary
    for added security. Once we start building out our server code, we'll learn how
    to share dependencies like this across projects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在SPA网页开发中，通常会对验证进行两次 – 一次在客户端，一次在服务器端。这样做可能看起来多余，但对于增加的安全性是必要的。一旦我们开始构建服务器端代码，我们将学习如何在项目之间共享这样的依赖。
- en: 'Since we''re creating multiple authentication-related components, let''s create
    a folder inside `components` called `auth` and then place our authentication-related
    files there. Once you''ve created the `auth` folder, add a file called `Registration.tsx`
    in there. Add the following code to the file. If you look at the source code,
    you will be able to see the necessary imports. Make sure your `App.css` file is
    updated as well. Note that eventually, we''ll move some of this code into a shared
    location, but for now, we''ll use it directly in our `Registration` component:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在创建多个与身份验证相关的组件，让我们在`components`内部创建一个名为`auth`的文件夹，然后将我们的身份验证相关文件放在其中。一旦创建了`auth`文件夹，就在其中添加一个名为`Registration.tsx`的文件。将以下代码添加到文件中。如果您查看源代码，您将能够看到必要的导入。确保您的`App.css`文件也已更新。请注意，最终，我们将把其中一些代码移到共享位置，但现在，我们将直接在我们的`Registration`组件中使用它：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we are creating our reducer, which has many related fields:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建我们的reducer，其中有许多相关字段：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since this is a modal component, we are allowing our parent components to control
    how this component is viewed by passing props. The `isOpen` prop controls how
    the modal is displayed, while the `onClickToggle` function controls hiding and
    showing the modal:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个模态组件，我们允许父组件通过传递props来控制此组件的显示方式。`isOpen`prop控制模态的显示方式，而`onClickToggle`函数控制模态的隐藏和显示：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we have the `isRegisterDisabled` local state value, which disables the
    register button if the given values are not correct, and, of course, our local
    reducer, `userReducer`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`isRegisterDisabled`本地状态值，如果给定值不正确，则禁用注册按钮，当然还有我们的本地reducer，`userReducer`：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`allowRegister` is just a helper function for setting the register button to
    disabled and showing a message if needed.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowRegister`只是一个用于设置注册按钮为禁用并在需要时显示消息的辅助函数。'
- en: 'Next, we have a series of `onChange` event handlers for each field, such as
    the `userName` field. They each do validation as needed, as well as update the
    typed-in text:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有一系列`onChange`事件处理程序，用于每个字段，比如`userName`字段。它们根据需要进行验证，并更新输入的文本：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `onChangeUserName` function is used to set a `userName` and validate whether
    registration is allowed to continue:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChangeUserName`函数用于设置`userName`并验证是否允许继续注册：'
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `onChangeEmail` function is used to set the email and validate whether
    registration is allowed to continue:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChangeEmail`函数用于设置电子邮件并验证是否允许继续注册：'
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `onChangePassword` function is used to set the password and validate whether
    registration is allowed to continue:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChangePassword`函数用于设置密码并验证是否允许继续注册：'
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `onChangedPasswordConfirm` function is used to set `passwordConfirm` and
    validate whether registration is allowed to continue:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChangedPasswordConfirm`函数用于设置`passwordConfirm`并验证是否允许继续注册：'
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, since this is a registration component, we use `passwordsSame` to check
    whether the password and the confirmation password are equal.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于这是一个注册组件，我们使用`passwordsSame`来检查密码和确认密码是否相等。
- en: 'Next, we have `onClickRegister` and `onClickCancel`. The `onClickRegister`
    button click handler will submit the attempted registration. Currently, since
    we have no backend, it does no actual submission, but we''ll fill it in once we
    have the server up. On the other hand, the `onClickCancel` handler exits the `Registration`
    component:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有`onClickRegister`和`onClickCancel`。`onClickRegister`按钮点击处理程序将提交尝试的注册。目前，由于我们没有后端，它不会进行实际提交，但一旦服务器启动，我们将填写它。另一方面，`onClickCancel`处理程序退出`Registration`组件：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the `e.preventDefault` function simply prevents the standard behavior,
    which is different depending on the context. In the case of forms, our `onClickRegister`
    handler is associated with a button inside a form tag, so the default behavior
    is to submit and cause a page refresh. A page refresh is `preventDefault`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`e.preventDefault`函数只是阻止了标准行为，这取决于上下文而有所不同。在表单的情况下，我们的`onClickRegister`处理程序与表单标签内的按钮相关联，因此默认行为是提交并导致页面刷新。页面刷新是`preventDefault`。
- en: 'Now that the event handlers have been set up we return the JSX that is tied
    to those handlers. First, we start with the `ReactModal` wrapper component:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在事件处理程序已经设置好，我们返回与这些处理程序相关联的JSX。首先，我们从`ReactModal`包装组件开始：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, our modal is controlled externally by a parent component via the `isOpen`
    and `onClickToggle` props.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们的模态是由父组件通过`isOpen`和`onClickToggle`props来外部控制的。
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we have our email field.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们的电子邮件字段。
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is our password field.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的密码字段。
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is our password confirmation field.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的密码确认字段。
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we have our button to register.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的注册按钮。
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here is our button to cancel.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的取消按钮。
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, note that we have a message section that's using the `resultMsg` reducer
    field. This will show errors if something has gone wrong.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们有一个消息部分，它使用`resultMsg` reducer字段。如果出现问题，它将显示错误。
- en: Now, if you run the app in desktop mode, you should see something this:![Figure
    12.8 – Desktop registration modal view
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您在桌面模式下运行应用程序，您应该会看到类似这样的东西：![图12.8-桌面注册模态视图
- en: '](img/Figure_12.08_B15508.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.08_B15508.jpg)'
- en: Figure 12.8 – Desktop registration modal view
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8-桌面注册模态视图
- en: 'If you run your Chrome debugger and switch to mobile mode, you will see the
    following screen after clicking on your hamburger icon and then the register label:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行Chrome调试器并切换到移动模式，然后单击汉堡图标，然后单击注册标签，您将看到以下屏幕：
- en: '![Figure 12.9 – Mobile registration modal view'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9-移动注册模态视图'
- en: '](img/Figure_12.09_B15508.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.09_B15508.jpg)'
- en: Figure 12.9 – Mobile registration modal view
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9-移动注册模态视图
- en: As you can see, we were able to effectively get two screens with only a single
    component by using CSS responsive capabilities.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们能够通过使用CSS响应能力有效地获得两个屏幕，而只使用一个组件。
- en: Now, let's move on to the login modal. If we take a look at the existing `Registration`
    component, we will see that it contains some code that we could also use in our
    `Login` component. We really should refactor the code so that it can be reused.
    For example, `Registration`, `Login`, and `Logout` will all use `ReactModal` and
    therefore receive props to control the modal's display. So, let's see what we
    can do to reuse our existing code. First, let's extract the `RegistrationProps`
    interface from the `Registration.tsx` file and place it in its own file. Create
    a folder called `types` inside `components`. Then, create a file called `ModalProps.ts`
    and add the `RegistrationProps` interface. Rename it `ModalProps`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续登录模态。如果我们看一下现有的`Registration`组件，我们会发现它包含一些代码，我们也可以在`Login`组件中使用。我们真的应该重构代码，以便可以重用它。例如，`Registration`，`Login`和`Logout`都将使用`ReactModal`，因此接收控制模态显示的props。因此，让我们看看我们可以做些什么来重用我们现有的代码。首先，让我们从`Registration.tsx`文件中提取`RegistrationProps`接口，并将其放在自己的文件中。在`components`内创建一个名为`types`的文件夹。然后，创建一个名为`ModalProps.ts`的文件，并添加`RegistrationProps`接口。将其重命名为`ModalProps`。
- en: As you can see, it's the same as `RegistrationProps` except for the name change.
    Now, open the `Registration.tsx` file, remove `RegistrationProps`, and import
    `ModalProps`. Then, replace `RegistrationProps` with `ModalProps`. Check that
    everything still runs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它与`RegistrationProps`相同，只是名称更改。现在，打开`Registration.tsx`文件，删除`RegistrationProps`，并导入`ModalProps`。然后，用`ModalProps`替换`RegistrationProps`。检查一下是否一切正常运行。
- en: 'We refactored `ModalProps` so that it can be reused across components. Now,
    let''s pull out `UserReducer` since `Login` uses some of its fields. Create a
    new folder called `common` inside the existing `auth` folder and create the `UserReducer.ts`
    file. Place the following code inside it:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重构了`ModalProps`，以便它可以在组件之间重复使用。现在，让我们拿出`UserReducer`，因为`Login`使用了它的一些字段。在现有的`auth`文件夹内创建一个名为`common`的新文件夹，并创建`UserReducer.ts`文件。将以下代码放入其中：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s do one more refactor. The `allowRegister` function in `Registration`
    disables a button and updates the status message. This can also clearly be reused.
    Let''s create a new file called `Helpers.ts` inside the common folder and add
    the following code inside it:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们进行另一个重构。`Registration`中的`allowRegister`函数禁用了一个按钮并更新了状态消息。这也可以清楚地被重用。让我们在common文件夹内创建一个名为`Helpers.ts`的新文件，并将以下代码放入其中：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, we changed the function name to `allowSubmit` and we are now
    taking `dispatch` as a parameter. Now, remove `allowRegister` from `Registration`
    and import the new `allowSubmit` function and update the `allowRegister` calls
    to `allowSubmit` calls. Check the code of your `Registration.tsx` file against
    the source code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将函数名称更改为`allowSubmit`，现在将`dispatch`作为参数。现在，从`Registration`中删除`allowRegister`，并导入新的`allowSubmit`函数，并将`allowRegister`调用更新为`allowSubmit`调用。检查一下您的`Registration.tsx`文件的代码是否与源代码一致。
- en: We'll leave the two `onClick` calls as-is, even though `Login` will also have
    similar calls, as we'll probably have to do some component-specific things for
    these calls later once our backend is ready.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持两个`onClick`调用不变，即使`Login`也将有类似的调用，因为一旦我们的后端准备好，我们可能还需要为这些调用做一些特定于组件的事情。
- en: You should now be able to run this code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够运行此代码。
- en: 'Now, we can use the newly extracted code in our new `Login` component. In the
    `auth` folder, create a new file called `Login.tsx` and add the relevant code
    from the source code. I''ll highlight a few items here:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在新的`Login`组件中使用新提取的代码。在`auth`文件夹中，创建一个名为`Login.tsx`的新文件，并从源代码中添加相关代码。我将在这里突出显示一些项目：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since our `Login` component has different needs than our `Registration` component,
    we are only using a subset of the fields from our `userReducer` by using object
    destructuring.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`Login`组件与我们的`Registration`组件有不同的需求，我们只使用了`userReducer`中的一部分字段，通过对象解构来实现。
- en: In the JSX, notice that we've updated some of the CSS classes in order to align
    the buttons better. These new classes are in the `App.css` file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX中，注意我们已经更新了一些CSS类，以便更好地对齐按钮。这些新类在`App.css`文件中。
- en: Finally, we need to add a link for logging in. Update the `SideBarMenu.tsx`
    file, as shown in the source code.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个登录链接。更新`SideBarMenu.tsx`文件，如源代码所示。
- en: Since `Logout` is very similar, I've added the component but will not cover
    it here. We'll add code to control which menu links are shown depending on user
    login status later as the backend gets more fleshed out. We'll also add additional
    validation. However, we have a lot more work to do before that, so let's continue.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Logout`非常相似，我已经添加了该组件，但不会在这里进行介绍。随着后端的进一步完善，我们将添加代码来控制显示哪些菜单链接取决于用户的登录状态。我们还将添加额外的验证。但在此之前，我们还有很多工作要做，所以让我们继续。
- en: Routing and screens
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由和屏幕
- en: 'Now, let''s continue by creating the routes that our application will need.
    Up to this point, we have had only a single URL for our app. The root URL is `http://localhost:3000`.
    We now want to divide our application so that it has distinct routes for specific
    sections of our application. We''ll start by taking our existing code, modifying
    it, and making that into our first root React Route. Let''s get started:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建应用程序需要的路由。到目前为止，我们的应用程序只有一个URL。根URL是`http://localhost:3000`。现在，我们希望将我们的应用程序划分为具有特定部分的不同路由。我们将从获取现有代码开始，修改它，并将其作为我们的第一个根React路由。让我们开始吧：
- en: First, let's move our Grid area-related components into distinct folders. First,
    create a folder called `areas` inside the `components` folder. Then, move the
    `Nav.tsx`, `Nav.css`, `RightMenu.tsx`, `Main.tsx`, `LeftMenu.tsx`, and `LeftMenu.css`
    files, as well as the entire `sidebar` folder, into the new `areas` folder. Your
    file path imports will need to be updated, including the `App.tsx` file. Take
    a look at the source code to learn how to do that.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将我们的网格区域相关组件移入不同的文件夹。首先，在`components`文件夹内创建一个名为`areas`的文件夹。然后，将`Nav.tsx`、`Nav.css`、`RightMenu.tsx`、`Main.tsx`、`LeftMenu.tsx`和`LeftMenu.css`文件，以及整个`sidebar`文件夹，移入新的`areas`文件夹。您的文件路径导入将需要更新，包括`App.tsx`文件。查看源代码，了解如何操作。
- en: Once you've done that, create a new folder inside `areas` called `main` and
    move the `Main.tsx` file inside it. Make sure to update your paths. We'll be adding
    all our main area-related components into this folder.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，在`areas`内创建一个名为`main`的新文件夹，并将`Main.tsx`文件移入其中。确保更新您的路径。我们将把所有与主要区域相关的组件添加到此文件夹中。
- en: The first new component we'll create in this folder is a `MainHeader` component.
    As the name implies, it will be used as a header for the main section. It will
    show what category of thread items we are currently looking at. Create the `MainHeader.tsx`
    file inside the `main` folder and add the code from the source into it.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在此文件夹中创建的第一个新组件是`MainHeader`组件。顾名思义，它将用作主区域的标题。它将显示我们当前正在查看的主题项目的类别。在`main`文件夹内创建`MainHeader.tsx`文件，并将源代码中的代码添加到其中。
- en: This control's only purpose is to display the current `Category` name.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此控件的唯一目的是显示当前的`Category`名称。
- en: Again, note that we have some new CSS classes in the `MainHeader.css` and `App.css`
    files.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们在`MainHeader.css`和`App.css`文件中有一些新的CSS类。
- en: Home screen
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主屏幕
- en: 'Before we continue, let''s perform some basic setup for our new route. Here,
    we''ll create our new screen component, `Home`, and update any related files,
    such as `App.tsx`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们为我们的新路由执行一些基本设置。在这里，我们将创建我们的新屏幕组件`Home`，并更新任何相关文件，例如`App.tsx`：
- en: When we first created our `App.tsx` file, we did so as if our application will
    have only one screen. Obviously, this is not true. Now that we have fleshed out
    our layout, let's begin adding our distinct screens and routes. Open the `App.tsx`
    file and update it like this.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们第一次创建`App.tsx`文件时，我们假设我们的应用程序只有一个屏幕。显然，这是不正确的。现在我们已经完善了我们的布局，让我们开始添加我们不同的屏幕和路由。打开`App.tsx`文件并像这样更新它。
- en: 'Here, we have added a new import called `Home` that represents the main page
    route. We will build this later:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个名为`Home`的新导入，代表了主页路由。我们稍后会构建这个：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We are defining a function here to send to our route''s `render` property.
    This function allows all the route''s props, as well as any custom props we would
    like to send, to be included in the initialization of our `Home` component:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义一个函数，以发送到我们路由的`render`属性。这个函数允许所有路由的props，以及我们想要发送的任何自定义props，在初始化我们的`Home`组件时包含在内：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So, the previous code that showed our Grid areas will now be in the `Home` component,
    which again, we will build shortly.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以前显示我们的网格区域的代码现在将在`Home`组件中，而这个组件我们稍后会构建。
- en: As shown in [*Chapter 7*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*,
    Learning Redux and React Router*, our `Switch` component allows React Router to
    change the rendering of route screens based on the URL provided. For now, we will
    have two routes pointing to the same `Home` screen, but we will add more later.
    The root path will show Threads for a default category, while the `categorythreads`
    route will show Threads for a specific category.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第7章*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*所示，学习Redux和React Router*，我们的`Switch`组件允许React
    Router根据提供的URL更改路由屏幕的渲染。目前，我们将有两个指向相同`Home`屏幕的路由，但稍后我们将添加更多。根路径将显示默认类别的线程，而`categorythreads`路由将显示特定类别的线程。
- en: 'Before we create our new `Home` component, let''s refactor our CSS a bit and
    make it more reusable. First, update the `App.css` file by adding the following
    class above the `App` class:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新的`Home`组件之前，让我们稍微重构一下我们的CSS，并使其更具可重用性。首先，通过在`App`类之前添加以下类来更新`App.css`文件：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will now become the root class for any components that represent route
    screens in our app.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将成为我们应用程序中代表路由屏幕的任何组件的根类。
- en: 'Next, create a new file called `Home.css` inside the `components/routes` folder.
    Now, cut this entire set of CSS styles from `App.css`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`components/routes`文件夹内创建一个名为`Home.css`的新文件。现在，从`App.css`中剪切整个CSS样式集：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Create a folder inside the `components` folder called `routes` and add a new
    file called `Home.tsx` inside it. The code is short and simple, so you can just
    copy it from the source. It's mostly the old code from the previous version of
    `App.tsx`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹内创建一个名为`routes`的文件夹，并在其中添加一个名为`Home.tsx`的新文件。代码很简短简单，所以您可以直接从源代码中复制。这主要是来自以前版本的`App.tsx`的旧代码。
- en: We've updated our root CSS `App` class so that it's now `screen-root-container
    home-container`. Using two classes in one class attribute simply means to first
    apply the first class style and then apply the next, which will override any settings
    from the prior. Also, we will now be able to use `screen-root-container` in the
    other screens.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了我们的根CSS`App`类，现在它是`screen-root-container home-container`。在一个类属性中使用两个类，意味着首先应用第一个类的样式，然后应用下一个类的样式，这将覆盖之前的任何设置。此外，我们现在将能够在其他屏幕中使用`screen-root-container`。
- en: We've successfully moved our original `App.tsx` code into the `Home.tsx` file.
    Notice that we also placed our `Nav` component inside a `div` tag. We're doing
    this so that we can reuse the `Nav` component later in other screens. You should
    now remove the `className="navigation"` attribute from your `Nav.tsx` component
    file.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将原始的`App.tsx`代码移到了`Home.tsx`文件中。请注意，我们还将我们的`Nav`组件放在了一个`div`标签内。我们这样做是为了以后可以在其他屏幕中重用`Nav`组件。您现在应该从`Nav.tsx`组件文件中删除`className="navigation"`属性。
- en: Now that we have updated our `Home` screen, we need to update our `Main` component
    so that it lists the threads within the given category. In order to do this, we
    actually need to do quite a few updates. First, we need to create two new models
    called `Thread` and `ThreadItem`. `Thread` is the initial post, while `ThreadItem`
    is a response. Let's start with our models.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经更新了我们的`Home`屏幕，我们需要更新我们的`Main`组件，以便列出给定类别内的线程。为了做到这一点，我们实际上需要做一些更新。首先，我们需要创建两个新模型，名为`Thread`和`ThreadItem`。`Thread`是初始帖子，而`ThreadItem`是一个回复。让我们从我们的模型开始。
- en: First, create `Thread.ts` in the `models` folder, as shown in the source code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`models`文件夹中创建`Thread.ts`，如源代码所示。
- en: There's not much to explain here as it's fairly obvious. However, note that
    `points` indicates the total number of likes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多需要解释的，因为这是相当明显的。但是，请注意，`points`表示点赞的总数。
- en: Next, let's do `ThreadItem.ts`. Create the required file and add the source
    code to it. It's pretty similar to `Thread`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们做`ThreadItem.ts`。创建所需的文件并将源代码添加到其中。这与`Thread`非常相似。
- en: 'Now, we will create the thread card file component. This component will represent
    a single Thread record and will show things such as its title, body, and points.
    Create a file called `ThreadCard.tsx` inside the `components/areas/main` folder.
    Then, add the code to it:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建线程卡文件组件。这个组件将代表一个单独的线程记录，并显示诸如标题、正文和点数等内容。在`components/areas/main`文件夹内创建一个名为`ThreadCard.tsx`的文件。然后，添加代码：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'First, we have various imports, including the `Link` object and the `useHistory`
    Hook from React Router:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有各种导入，包括`Link`对象和来自React Router的`useHistory` Hook：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'const ThreadCard: FC<ThreadCardProps> = ({ thread }) => {'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'const ThreadCard: FC<ThreadCardProps> = ({ thread }) => {'
- en: const history = useHistory();
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: const history = useHistory();
- en: const { width } = useWindowDimensions();
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: const { width } = useWindowDimensions();
- en: 'const onClickShowThread = (e: React.  MouseEvent<HTMLDivElement>) => {'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 'const onClickShowThread = (e: React.  MouseEvent<HTMLDivElement>) => {'
- en: history.push("/thread/" + thread.id);
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: history.push("/thread/" + thread.id);
- en: '};'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'const getPoints = (thread: Thread) => {'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 'const getPoints = (thread: Thread) => {'
- en: if (width <= 768) {
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（宽度 <= 768）{
- en: return (
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <label
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <label
- en: style={{
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: style={{
- en: 'marginRight: ".75em",'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'marginRight: ".75em",'
- en: 'marginTop: ".25em",'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'marginTop: ".25em",'
- en: '}}'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '}}'
- en: '>'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '{thread.points || 0}'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '{线程.点数 || 0}'
- en: <FontAwesomeIcon
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: <FontAwesomeIcon
- en: icon={faHeart}
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: icon={faHeart}
- en: className="points-icon"
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: className="points-icon"
- en: style={{
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: style={{
- en: 'marginLeft: ".2em",'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'marginLeft: ".2em",'
- en: '}}'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '}}'
- en: />
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: </label>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: </label>
- en: );
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return null;
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: return null;
- en: '};'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'const getResponses = (thread: Thread) => {'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 'const getResponses = (thread: Thread) => {'
- en: if (width <= 768) {
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（宽度 <= 768）{
- en: return (
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <label
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: <label
- en: style={{
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: style={{
- en: 'marginRight: ".5em",'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'marginRight: ".5em",'
- en: '}}'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '}}'
- en: '>'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '{thread && thread.threadItems && thread.           threadItems.length}'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '{线程 && 线程.线程项目 && 线程.线程项目.length}'
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: <FontAwesomeIcon
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: <FontAwesomeIcon
- en: icon={faReplyAll}
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: icon={faReplyAll}
- en: className="points-icon"
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: className="points-icon"
- en: style={{
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: style={{
- en: 'marginLeft: ".25em",'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'marginLeft: ".25em",'
- en: 'marginTop: "-.25em",'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'marginTop: "-.25em",'
- en: '}}'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '}}'
- en: />
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: </label>
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: </label>
- en: );
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return null;
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: return null;
- en: '};'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: const getPointsNonMobile = () => {
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: const getPointsNonMobile = () => {
- en: if (width > 768) {
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（宽度 > 768）{
- en: return (
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <div className="threadcard-points">
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="threadcard-points">
- en: <div className="threadcard-points-item">
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="threadcard-points-item">
- en: '{thread.points || 0}'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '{线程.点数 || 0}'
- en: <br />
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: <br />
- en: <FontAwesomeIcon icon={faHeart}              className="points-icon" />
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: <FontAwesomeIcon icon={faHeart}              className="points-icon" />
- en: </div>
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: <div
- en: className="threadcard-points-item"
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: className="threadcard-points-item"
- en: 'style={{ marginBottom: ".75em" }}'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 'style={{ marginBottom: ".75em" }}'
- en: '>'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '{thread && thread.threadItems && thread.             threadItems.length}'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '{线程 && 线程.线程项目 && 线程.线程项目.length}'
- en: '[PRE55]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: <br />
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <br />
- en: <FontAwesomeIcon icon={faReplyAll}              className="points-icon" />
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: <FontAwesomeIcon icon={faReplyAll}              className="points-icon" />
- en: </div>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: );
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return null;
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: return null;
- en: '};'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE56]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: return (
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <section className="panel threadcard-container">
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: <section className="panel threadcard-container">
- en: <div className="threadcard-txt-container">
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="threadcard-txt-container">
- en: <div className="content-header">
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="content-header">
- en: <Link
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: <Link
- en: to={`/categorythreads/${thread.category.id}`}
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: to={`/categorythreads/${thread.category.id}`}
- en: className="link-txt"
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: className="link-txt"
- en: '>'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <strong>{thread.category.name}</strong>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <strong>{thread.category.name}</strong>
- en: </Link>
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: </Link>
- en: '[PRE57]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '<span className="username-header" style={{            marginLeft: ".5em" }}>'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '<span className="username-header" style={{            marginLeft: ".5em" }}>'
- en: '{thread.userName}'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '{thread.userName}'
- en: </span>
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: </span>
- en: </div>
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div className="question">
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="question">
- en: <div
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: <div
- en: onClick={onClickShowThread}
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: onClick={onClickShowThread}
- en: data-thread-id={thread.id}
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: data-thread-id={thread.id}
- en: 'style={{ marginBottom: ".4em" }}'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'style={{ marginBottom: ".4em" }}'
- en: '>'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <strong>{thread.title}</strong>
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: <strong>{thread.title}</strong>
- en: </div>
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: <div
- en: className="threadcard-body"
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: className="threadcard-body"
- en: onClick={onClickShowThread}
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: onClick={onClickShowThread}
- en: data-thread-id={thread.id}
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: data-thread-id={thread.id}
- en: '>'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <div>{thread.body}</div>
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: <div>{thread.body}</div>
- en: </div>
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE58]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <div className="threadcard-footer">
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="threadcard-footer">
- en: <span
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: <span
- en: style={{
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 样式={{
- en: 'marginRight: ".5em",'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'marginRight: ".5em",'
- en: '}}'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '}}'
- en: '>'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <label>
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: <label>
- en: '{thread.views}'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '{thread.views}'
- en: <FontAwesomeIcon icon={faEye}                  className="icon-lg" />
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: <FontAwesomeIcon icon={faEye}                  className="icon-lg" />
- en: </label>
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: </label>
- en: </span>
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: </span>
- en: <span>
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: <span>
- en: '{getPoints(thread)}'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '{getPoints(thread)}'
- en: '{getResponses(thread)}'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '{getResponses(thread)}'
- en: </span>          </div>
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: </span>          </div>
- en: </div>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE59]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '{getPointsNonMobile()}    </section>'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '{getPointsNonMobile()}    </section>'
- en: );
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '};'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: export default ThreadCard;
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: export default ThreadCard;
- en: '[PRE60]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: .threadcard-txt-container {
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: .threadcard-txt-container {
- en: 'display: flex;'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 'display: flex;'
- en: 'flex-direction: column;'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'flex-direction: column;'
- en: 'width: 92%;'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 'width: 92%;'
- en: 'margin: 0.75em 1em 0.75em 1.2em;'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 'margin: 0.75em 1em 0.75em 1.2em;'
- en: 'border-right: solid 1px var(--border-color);'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 'border-right: solid 1px var(--border-color);'
- en: '}'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE61]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now that we've created our Thread container, `ThreadCard`, let's update our
    `Main.tsx` file so that we can use it. Add the code from the source.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的Thread容器，`ThreadCard`，让我们更新我们的`Main.tsx`文件，以便我们可以使用它。添加源代码中的代码。
- en: if you look on *line 8*, you will see the `useParams` function being used. Previously,
    we created two routes for React Router in the `App.tsx` file. One of the routes,
    `categorythreads`, accepted a URL parameter. By using the `useParams` Hook, we
    can get route parameters – in this case, `categoryId` – so that we can use them.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看*第8行*，您将看到`useParams`函数被使用。之前，我们在`App.tsx`文件中为React Router创建了两个路由。其中一个路由`categorythreads`接受了一个URL参数。通过使用`useParams`
    Hook，我们可以获取路由参数 - 在这种情况下是`categoryId` - 以便我们可以使用它们。
- en: Then, on *line 9*, we have the `category` state. Once we've retrieved our category
    from the list of threads, we will update this state.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*第9行*，我们有`category`状态。一旦我们从线程列表中检索到我们的类别，我们将更新此状态。
- en: On *line 10*, we have a state object, which is a list of our `ThreadCards`,
    called `threadCards`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第10行*，我们有一个状态对象，它是我们的`ThreadCards`列表，称为`threadCards`。
- en: Then, in `useEffect`, we are updating our list of `ThreadCards` if we get a
    new `categoryId`. When we get a valid `categoryId`, we use our `DataService` to
    query for a list of threads that are specific to that category and then build
    out a list of `ThreadCards`. We also take the first thread to get the name of
    the category, since they all have the same category.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`useEffect`中，如果我们获得新的`categoryId`，我们将更新我们的`ThreadCards`列表。当我们获得有效的`categoryId`时，我们使用我们的`DataService`来查询特定类别的线程列表，然后构建出`ThreadCards`列表。我们还取第一个线程来获取类别的名称，因为它们都属于同一类别。
- en: Finally, we return our UI.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回我们的UI。
- en: Note
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, you will see warnings about missing dependencies on the array of
    the `useEffect` Hook. These are what I consider opinionated warnings and with
    experience, you will be able to judge which of them can be safely ignored. For
    example, in `useEffect` for `Main.tsx`, I am deliberately ignoring this warning
    about the `category` state object, because including the object in the array would
    trigger an unnecessary double run of `useEffect` (because `useEffect` runs whenever
    something in its array list has changed) and possibly a double render.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会看到有关`useEffect` Hook数组中缺少依赖项的警告。这些是我认为是有意见的警告，通过经验，您将能够判断哪些可以安全地忽略。例如，在`Main.tsx`的`useEffect`中，我故意忽略了关于`category`状态对象的警告，因为将对象包含在数组中会触发`useEffect`的不必要的双重运行（因为`useEffect`在其数组列表中的某些内容发生变化时运行），可能会导致双重渲染。
- en: 'Now, let''s try running in desktop mode. Go to `http://localhost:3000/categorythreads/1`.
    You should see the following:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在桌面模式下运行。转到`http://localhost:3000/categorythreads/1`。你应该看到以下内容：
- en: '![Figure 12.10 – Desktop view of the categorythreads URL'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10 - 类别帖子URL的桌面视图'
- en: '](img/Figure_12.10_B15508.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.10_B15508.jpg)'
- en: Figure 12.10 – Desktop view of the categorythreads URL
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 - 类别帖子URL的桌面视图
- en: 'Here''s what it looks like on mobile:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上它是这个样子的：
- en: '![Figure 12.11 – Mobile view of the categorythreads URL'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11 - 类别帖子URL的移动视图'
- en: '](img/Figure_12.11_B15508.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.11_B15508.jpg)'
- en: Figure 12.11 – Mobile view of the categorythreads URL
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 - 类别帖子URL的移动视图
- en: As you can see, in mobile mode, we don't have the right column of points. Instead,
    those points are in the bottom of the main text section. The icons show that,
    for the first post, two people have seen it. 55 people liked it, and one person
    responded.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在移动模式下，我们没有右侧的积分栏。相反，这些积分在主文本部分的底部。图标显示，对于第一篇帖子，有两个人看过它。有55个人喜欢它，还有一个人回复了。
- en: Wow – that was a lot of code we just went through! However, we're not done yet!
    Let's continue by building our `RightMenu` component.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 哇 - 我们刚刚经历了很多代码！但是，我们还没有完成！让我们继续构建我们的`RightMenu`组件。
- en: 'On our `RightMenu`, we want to show a list of the top three categories with
    the most thread postings. In each category, we''ll show the topmost viewed threads.
    Let''s get started:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`RightMenu`上，我们想要显示一个帖子数量最多的三个类别的列表。在每个类别中，我们将显示最多人浏览的帖子。让我们开始吧：
- en: First, create a folder for `RightMenu` inside the `areas` folder called `rightMenu`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`areas`文件夹内创建一个名为`rightMenu`的`RightMenu`文件夹。
- en: Now, create a new file inside that folder called `TopCategory.tsx`. This component
    will represent a single top category and its threads.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在那个文件夹里创建一个名为`TopCategory.tsx`的新文件。这个组件将代表一个单独的顶级类别及其帖子。
- en: Create a new model that will represent the data coming from the server. Let's
    call it `CategoryThread`. Create a file called `CategoryThread.ts` inside the
    `models` folder and enter the source code.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模型，代表从服务器传来的数据。让我们称之为`CategoryThread`。在`models`文件夹内创建一个名为`CategoryThread.ts`的文件，并输入源代码。
- en: Now, we need to update our existing `RightMenu` component and create a new component
    that will display our `CategoryThread` items. To group and organize our `CategoryThread`
    items, we need to use a tool called Lodash to help us.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新我们现有的`RightMenu`组件，并创建一个新的组件来显示我们的`CategoryThread`项目。为了对我们的`CategoryThread`项目进行分组和组织，我们需要使用一个叫做Lodash的工具来帮助我们。
- en: 'Lodash is a dependency that provides an enormous library of JavaScript helper
    functions. It would be impossible to go through all its capabilities here. However,
    Lodash is particularly useful for managing arrays and collections. You will see
    it''s pretty straightforward to use, but if you would like more details, here''s
    a link to their documentation: `https://lodash.com/docs/`. Install Lodash like
    this:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Lodash是一个提供了大量JavaScript辅助函数库的依赖项。在这里不可能涵盖它的所有功能。然而，Lodash特别适用于管理数组和集合。你会发现它非常容易使用，但如果你想要更多细节，这里是他们的文档链接：`https://lodash.com/docs/`。像这样安装Lodash：
- en: '[PRE62]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, we need to build our `TopCategory` component. Create the file called `TopCategory.tsx`
    in the same folder as `RightMenu` and add the relevant source code to it.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要构建我们的`TopCategory`组件。在与`RightMenu`相同的文件夹中创建一个名为`TopCategory.tsx`的文件，并添加相关的源代码。
- en: At the top, notice that we have a complementary CSS file called `TopCategory.css`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，请注意我们有一个补充的CSS文件叫做`TopCategory.css`。
- en: Next, we have a new interface called `TopCategoryProps` for receiving props.
    On *line 10*, the threads state object will store our JSX element when it's ready.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个名为`TopCategoryProps`的新接口用于接收props。在*line 10*上，当准备好时，帖子状态对象将存储我们的JSX元素。
- en: Then, on *line 12*, we have `useEffect`, which we will use to build our UI elements
    based on the passed in prop; that is, `topCategories`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*line 12*上，我们有`useEffect`，我们将使用它基于传入的prop来构建我们的UI元素；也就是说，`topCategories`。
- en: The returned JSX has a `strong` header, which is the name of the first category
    element that was found, since the array of top categories is always from one category.
    Then, we included our list of threads.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的JSX有一个`strong`标题，这是找到的第一个类别元素的名称，因为顶级类别的数组总是来自一个类别。然后，我们包括了我们的帖子列表。
- en: 'Since this `RightMenu` does not render for mobile devices, let''s see what
    it looks like on desktop:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个`RightMenu`在移动设备上不渲染，让我们看看在桌面上它是什么样子的：
- en: '![Figure 12.12 – RightMenu with top categories'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12 - 带有顶级类别的RightMenu'
- en: '](img/Figure_12.12_B15508.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.12_B15508.jpg)'
- en: Figure 12.12 – RightMenu with top categories
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 - 带有顶级类别的RightMenu
- en: OK – we're getting there! We've completed most of what we need for our main
    screen, but now, we need our application to show an individual **Thread posting**.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 好的 - 我们快要完成了！我们已经完成了大部分我们主屏幕所需的内容，但现在，我们需要我们的应用程序显示单独的**帖子**。
- en: Thread posts screen
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帖子屏幕
- en: 'This screen will be multi-use. Using this screen, we will be able to create
    a new posting or display an existing one. We will also show Thread responses on
    the same screen. Let''s get started:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕将是多用途的。使用这个屏幕，我们将能够创建一个新的帖子或显示一个现有的帖子。我们还将在同一个屏幕上显示帖子的回复。让我们开始吧：
- en: First, we need to create our new route component. We'll call it `Thread.tsx`
    and place it inside a new folder called `thread`, which should be placed inside
    the `routes` folder. However, our `Thread` component will be complex, so we should
    split it into modular pieces known as child components. In this case, doing this
    will not give us code reuse benefits. However, it will make the code easier to
    read and refactor since it will be distributed in chunks instead of a single very
    large monolith. Let's create a new component file called `ThreadHeader.tsx` and
    add the source code to it.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的新路由组件。我们将称之为`Thread.tsx`，并将其放在一个名为`thread`的新文件夹中，该文件夹应放在`routes`文件夹内。然而，我们的`Thread`组件将会很复杂，所以我们应该将其拆分为称为子组件的模块化部分。在这种情况下，这样做不会给我们带来代码重用的好处。然而，这将使代码更容易阅读和重构，因为它将被分发成块，而不是一个非常庞大的单体。让我们创建一个名为`ThreadHeader.tsx`的新组件文件，并将源代码添加到其中。
- en: First, notice the new function we are importing, `getTimePastIfLessThanDay`.
    This function will look at a passed-in date and format it appropriately for ease
    of readability.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意我们正在导入的新函数`getTimePastIfLessThanDay`。这个函数将查看传入的日期并适当地格式化它，以便易于阅读。
- en: This component will take the fields in as parameters and not have a state of
    its own. `ThreadHeader` is acting as a display-only component. It shows the thread's
    `title`, `userName`, and `lastModifiedOn` time.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件将接受字段作为参数，而不具有自己的状态。`ThreadHeader`充当一个仅用于显示的组件。它显示了主题的`title`、`userName`和`lastModifiedOn`时间。
- en: Now, create the `Thread.tsx` file and add the source code to it.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`Thread.tsx`文件并将源代码添加到其中。
- en: Notice that we are importing a new `Thread.css` file and our new `ThreadHeader`
    component. Also, notice that since our component is also called `Thread`, as is
    our model, I am importing our model as `ThreadModel`. This type of issue can occur
    somewhat frequently in large projects, so you should be aware that you can import
    in this manner.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在导入一个新的`Thread.css`文件和我们的新的`ThreadHeader`组件。还要注意，由于我们的组件也被称为`Thread`，就像我们的模型一样，我将我们的模型导入为`ThreadModel`。这种问题在大型项目中可能会经常发生，所以你应该知道你可以以这种方式导入。
- en: Next, we must create our local `thread` state object, which is of the `ThreadModel`
    type. Then, we must use the `useParams` Hook once again to get the route parameter's
    `id`, which is the ID of the thread for this route.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建我们的本地`thread`状态对象，它是`ThreadModel`类型。然后，我们必须再次使用`useParams` Hook来获取路由参数的`id`，这是这条线程的ID。
- en: In `useEffect`, if the `id` route parameter exists and it is greater than `0`,
    we attempt to get our `thread`. Later, once our backend is ready, we'll write
    some code so that new threads can be inserted.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在`useEffect`中，如果`id`路由参数存在且大于`0`，我们尝试获取我们的`thread`。稍后，一旦我们的后端准备好了，我们将编写一些代码，以便可以插入新的线程。
- en: Finally, we return our UI, which includes `ThreadHeader`. Notice that the `lastModifiedOn`
    field is non-nullable, so we are using a ternary check for a null `thread` and
    returning the current date if it is null.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回我们的UI，其中包括`ThreadHeader`。请注意，`lastModifiedOn`字段是非空的，所以我们使用三元检查来检查`thread`是否为空，如果为空则返回当前日期。
- en: 'Now, we need to create a new route for our `Thread` screen component. Open
    `App.tsx` again and update the code, like this:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的`Thread`屏幕组件创建一个新的路由。再次打开`App.tsx`并更新代码，就像这样：
- en: '[PRE63]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we''ve added the `renderThread` function for our `Thread` component:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为我们的`Thread`组件添加了`renderThread`函数：
- en: '[PRE64]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Notice that our route for `Thread` is `"/thread/:id"`, which means that after
    the thread path, it expects a parameter. Internally, React Router will label it
    `id`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的`Thread`的路由是`"/thread/:id"`，这意味着在线程路径之后，它期望一个参数。在内部，React Router将其标记为`id`。
- en: Now, we'll add the next section of our Thread screen. On this screen, we will
    be displaying the Thread's category via a drop-down menu. However, since the standard
    dropdown in HTML, called a `select` element, is ugly and does not integrate well
    with React, we'll use an NPM package called `react-dropdown` to help us get a
    more attractive and React integrated control.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加我们线程屏幕的下一部分。在这个屏幕上，我们将通过下拉菜单显示线程的类别。然而，由于HTML中标准的下拉菜单，称为`select`元素，外观丑陋且与React集成不佳，我们将使用一个名为`react-dropdown`的NPM包来帮助我们获得一个更具吸引力和React集成的控件。
- en: 'Install `react-dropdown` like this:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样安装`react-dropdown`：
- en: '[PRE65]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, let's create our `Title` component. We'll call it `ThreadTitle`. Create
    a file called `ThreadTitle.tsx` inside the `thread` folder and add the source
    code to it.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的`Title`组件。我们将它称为`ThreadTitle`。在`thread`文件夹中创建一个名为`ThreadTitle.tsx`的文件，并将源代码添加到其中。
- en: This is just a simple renderer, so I won't explain it here. However, notice
    that, at the moment, our `onChangeTitle` handler is blank. Again, once our backend
    is ready, we will distinguish between read and write states and implement the
    `onChangeTitle` function.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的渲染器，所以我不会在这里解释它。然而，请注意，目前我们的`onChangeTitle`处理程序是空的。同样，一旦我们的后端准备好了，我们将区分读取和写入状态，并实现`onChangeTitle`函数。
- en: Now, let's update our `Thread.tsx` file and take a look at what we have so far.
    Update `Thread.tsx` like this. Note that as we've been adding these Thread-related
    components, we've been updating the `Thread.css` file, so keep your CSS file updated
    as well.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更新我们的`Thread.tsx`文件，看看我们到目前为止做了什么。像这样更新`Thread.tsx`。请注意，随着我们添加这些与Thread相关的组件，我们一直在更新`Thread.css`文件，所以也要保持你的CSS文件更新。
- en: 'The state and `useEffect` code is basically the same, so I won''t show it here:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 状态和`useEffect`代码基本上是一样的，所以我不会在这里展示它：
- en: '[PRE66]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, we have added our new components to our returned JSX. As you can see,
    our code is a lot shorter and easier to read than if we had the individual elements
    and event handlers all in the `Thread.tsx` file.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将新的组件添加到了返回的JSX中。正如你所看到的，我们的代码比在`Thread.tsx`文件中拥有单独的元素和事件处理程序时要简短和易读得多。
- en: 'If you run the app via `http://localhost:` `3000/thread/1`, you should see
    this:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过`http://localhost:3000/thread/1`运行应用程序，你应该会看到这个：
- en: '![Figure 12.13 – Thread screen'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.13 - 线程屏幕'
- en: '](img/Figure_12.13_B15508.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.13_B15508.jpg)'
- en: Figure 12.13 – Thread screen
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 - 线程屏幕
- en: Note that the gap on the right is where we will add likes and response count
    information for the Thread.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意右侧的空白处是我们将为线程添加喜欢和回复计数信息的地方。
- en: Now, we're not reviewing every single CSS file here because we want to focus
    on the code, but since this is a major screen and route destination, let's review
    the CSS to see how we laid this out. This is what we have thus far. Update your
    `Thread.css` file so that we can take a look together.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不会在这里审查每个CSS文件，因为我们想专注于代码，但由于这是一个重要的屏幕和路由目的地，让我们审查一下CSS，看看我们是如何布局的。到目前为止，我们就是这样。更新你的`Thread.css`文件，这样我们就可以一起看一下。
- en: As we did previously with the Home screen, we placed our nav control inside
    its own div container called `thread-nav-container`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前在主屏幕上做的那样，我们将我们的导航控件放在自己的名为`thread-nav-container`的div容器中。
- en: This `thread-content-container` class is where the actual Thread content is
    being laid out. As you can see, the layout is a Grid with two columns and an undefined
    indeterminate number of rows.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread-content-container`类是实际的Thread内容布局。正如您所见，布局是一个具有两列和不确定数量行的网格。'
- en: The rest of the content is being added to the first column using the `grid-column`
    attribute. We will add the second column to hold our Thread's points (likes) later.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 其余内容使用`grid-column`属性添加到第一列。稍后我们将添加第二列来保存我们的Thread的点（赞）。
- en: Now, we need to add a section for the body of our Thread posting. The body entry
    is a bit more complicated because we will need to add a Rich Text entry formatter.
    This control will allow users to format their text and do more sophisticated editing.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的Thread帖子的正文添加一个部分。正文条目更复杂，因为我们需要添加一个富文本条目格式化程序。这个控件将允许用户格式化他们的文本并进行更复杂的编辑。
- en: 'To create our body, let''s install an NPM package called Slate.js. This will
    be our Rich Text editor and formatter. We''ll also need to install several dependencies,
    including something called Emotion. Emotion is a library that allows us to use
    CSS directly inside JavaScript:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的正文，让我们安装一个名为Slate.js的NPM包。这将是我们的富文本编辑器和格式化程序。我们还需要安装几个依赖项，包括一个叫做Emotion的东西。Emotion是一个允许我们直接在JavaScript中使用CSS的库：
- en: '[PRE67]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Next, we need to create the `RichEditor.tsx` file in the same `editor` folder
    and add this code to it.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在相同的`editor`文件夹中创建`RichEditor.tsx`文件，并将此代码添加到其中。
- en: At the top of our imports section, we can see the usual React-related imports,
    but also two Slate.js imports. These are there to help us create our editor UI.
    I'll explain these in more detail later.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的导入部分的顶部，我们可以看到通常的与React相关的导入，但也有两个Slate.js的导入。这些是帮助我们创建编辑器UI的。我稍后会更详细地解释这些。
- en: The `isHotKey` import is a tool that helps us build keyboard shortcuts for our
    editor.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`isHotKey`导入是一个帮助我们为编辑器构建键盘快捷键的工具。'
- en: The `withHistory` import allows the editor to save the edits that have occurred,
    in their correct order, so that they can be undone if needed.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`withHistory`导入允许编辑器保存已发生的编辑，以正确的顺序，以便在需要时可以撤消。'
- en: '`Button` and `Toolbar` are controls that can be used to build our editor UI.
    We''ll create the `RichTextControls` file in a moment.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`和`Toolbar`是可以用来构建我们的编辑器UI的控件。我们稍后将创建`RichTextControls`文件。'
- en: Now, we can import our icons and CSS stylesheet.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以导入我们的图标和CSS样式表。
- en: 'The `HOTKEYS` variable is a dictionary that contains the various shortcut keys
    to formatting pairings. `[keyName: string]` on the left represents the dictionary
    key; the right-hand side shows the value.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`HOTKEYS`变量是一个包含各种快捷键到格式配对的字典。左边的`[keyName: string]`表示字典键；右边显示值。'
- en: On *line 26*, we have the `initialValue` variable. Our editor uses objects for
    its value, not strings. So, the `initialValue` variable represents the starting
    value object of the editor. The type is a `Node` array that comes from the Slate.js
    editor. In Slate.js, text is represented as hierarchical trees of nodes. This
    is to make sure that the structure of the text is kept intact, but also to allow
    formatting information to live alongside the text. You can think of it as text
    and metadata together.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第26行*，我们有`initialValue`变量。我们的编辑器使用对象作为其值，而不是字符串。因此，`initialValue`变量表示编辑器的起始值对象。类型是来自Slate.js编辑器的`Node`数组。在Slate.js中，文本被表示为节点的分层树。这是为了确保文本的结构保持完整，同时也允许格式信息与文本一起存在。您可以将其视为文本和元数据一起。
- en: The `LIST_TYPES` array is used to distinguish between whether an entry is a
    paragraph or a list of text.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIST_TYPES`数组用于区分条目是段落还是文本列表。'
- en: On *line 38*, we start creating our `RichEditor` component. As we mentioned
    previously, in Slate.js, the value or content of the text inside the editor is
    not plain text. It is a JSON object and its root type is `Node`. So, our main
    text value, called `value`, is a state object of the Node array type.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第38行*，我们开始创建我们的`RichEditor`组件。正如我们之前提到的，在Slate.js中，编辑器内文本的值或内容不是普通文本。它是一个JSON对象，其根类型是`Node`。因此，我们的主文本值，称为`value`，是`Node`数组类型的状态对象。
- en: Next, we have the `renderElement` function, which is used internally to render
    larger text pieces. An `Element` is a multi-line set of text. We'll build the
    `Element` component in a bit.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`renderElement`函数，它在内部用于呈现较大的文本片段。`Element`是一组多行文本。我们稍后将构建`Element`组件。
- en: Then, we have the `renderLeaf` function, which is used to render smaller bits
    of text. A `Leaf` is a small snippet of text. We will create this component a
    bit later.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`renderLeaf`函数，用于呈现较小的文本片段。`Leaf`是一小段文本。我们稍后将创建这个组件。
- en: Note that we covered Hooks, such as `useCallback` and `useMemo`, in [*Chapter
    5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081)*, React Development with Hooks*.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在[*第5章*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081)*，使用Hooks进行React开发*中介绍了`useCallback`和`useMemo`等Hooks。
- en: We then have the editor variable. The editor is the React component that accepts
    and displays text, as opposed to the `Slate`, `Toolbar`, and `Editable` components,
    which act as wrappers around the editor and inject or modify text formatting for
    it.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有编辑器变量。编辑器是接受和显示文本的React组件，而不是`Slate`、`Toolbar`和`Editable`组件，它们作为编辑器周围的包装器，并为其注入或修改文本格式。
- en: The `useEffect` function is used to grab the `existingBody` prop and make it
    the local state value, assuming `existingBody` was passed in. Again, an `existingBody`
    is passed in only during view mode, not create mode.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`函数用于获取`existingBody`属性并将其作为本地状态值，假设传入了`existingBody`。再次强调，`existingBody`仅在查看模式下传入，而不是创建模式。'
- en: The `onChangeEditorValue` event handler sets the local `value` state when it
    is changed in the UI. Again, notice how the value type is not text, but a `Node`
    array.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChangeEditorValue`事件处理程序在UI中更改时设置本地`value`状态。再次注意，值类型不是文本，而是`Node`数组。'
- en: Starting on *line 59*, we start our JSX definition. We initialize our Slate
    wrapper component with our `editor` instance, local `value` state, and the `onChange`
    event.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 从*第59行*开始，我们开始定义我们的JSX。我们使用我们的`editor`实例、本地`value`状态和`onChange`事件初始化我们的Slate包装组件。
- en: 'Next, `Toolbar`, which is from the `RichTextControls.tsx` file, represents
    a layout container and contains our buttons for formatting. They look like this.
    I will explain `MarkButton` and `BlockButton` later:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Toolbar`来自`RichTextControls.tsx`文件，表示一个布局容器，并包含我们的格式化按钮。它们看起来像这样。我稍后会解释`MarkButton`和`BlockButton`：
- en: '![Figure 12.14 – Slate.js Toolbar buttons'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14 – Slate.js工具栏按钮'
- en: '](img/Figure_12.14_B15508.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.14_B15508.jpg)'
- en: Figure 12.14 – Slate.js Toolbar buttons
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 – Slate.js工具栏按钮
- en: The Editable control contains the main formatters, shortcut keys, and base settings
    for our editor.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 可编辑控件包含了我们编辑器的主要格式化程序、快捷键和基本设置。
- en: Notice that I've moved out most of the functions outside the main component
    for readability.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了可读性，我已经将大部分函数移到主组件之外。
- en: On *line 92*, we have our `MarkButton` control. `MarkButton` is a function that
    generates the button UI and also associates the actual formatter that triggers
    when that specific button is clicked. Generally, marks are used for words or characters,
    as opposed to blocks, which are usually multi-line statements. `Button` is from
    our `RichTextControls.tsx` file. It represents a styled button on our Toolbar.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第92行*，我们有我们的`MarkButton`控件。`MarkButton`是一个生成按钮UI并关联实际格式化程序的函数，当特定按钮被点击时触发。通常，标记用于单词或字符，而不是通常是多行语句的块。`Button`来自我们的`RichTextControls.tsx`文件。它表示我们工具栏上的样式化按钮。
- en: Next, we have the `isMarkActive` function. The `isMarkActive` function determines
    if a formatter has been applied already.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`isMarkActive`函数。`isMarkActive`函数确定格式化程序是否已经应用。
- en: Next, the `toggleMark` function will toggle the formatting based on whether
    it has been applied or not. It associates the editor with the format.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`toggleMark`函数将根据是否已应用格式来切换格式。它将编辑器与格式关联起来。
- en: '`BlockButton` sets the formatting for a block of text and creates its button.
    Usually, a block contains multiple `Nodes`.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockButton`设置文本块的格式并创建其按钮。通常，一个块包含多个`Nodes`。'
- en: The `isBlockActive` function determines if formatting was applied.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`isBlockActive`函数确定是否应用了格式。'
- en: '`ToggleBlock` toggles the applied formatting.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToggleBlock`切换应用的格式。'
- en: Next, the `Element` component determines which type of HTML to use. `Elements`
    are used quite frequently in Slate.js.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Element`组件确定要使用哪种类型的HTML。`Elements`在Slate.js中经常使用。
- en: We use `Leafs` to determine smaller HTML to return. `Leafs` are frequently used
    in Slate.js.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Leafs`来确定要返回的较小的HTML。`Leafs`在Slate.js中经常使用。
- en: We now have a reusable Rich Text editor. We will certainly use this component
    in our Thread display. Now, since it is its own component, we can reuse this code
    wherever we like.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可重用的富文本编辑器。我们肯定会在我们的线程显示中使用这个组件。现在，因为它是自己的组件，我们可以在任何地方重用这段代码。
- en: Now, we need to add our new `RichEditor` to our `ThreadBody.tsx` file. It is
    a small component, so just add the code from the source.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的新`RichEditor`添加到我们的`ThreadBody.tsx`文件中。它是一个小组件，所以只需从源代码中添加代码。
- en: 'Finally, we need to reference our `ThreadBody` from our `Thread` component,
    like this. Make sure you have all the necessary imports. Then, in the JSX, just
    below `ThreadTitle`, add the following code:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要从我们的`Thread`组件中引用我们的`ThreadBody`，就像这样。确保您有所有必要的导入。然后，在JSX中，在`ThreadTitle`的下面，添加以下代码：
- en: '[PRE68]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Again, notice how easy it is to read and understand this JSX now that we have
    put it into components.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，现在将它放入组件中，阅读和理解这个JSX是多么容易。
- en: 'Now, let''s take a look at what this looks like:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这是什么样子的：
- en: '![Figure 12.15 – Thread entry screen and its editor'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15 – 线程输入屏幕及其编辑器'
- en: '](img/Figure_12.15_B15508.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.15_B15508.jpg)'
- en: Figure 12.15 – Thread entry screen and its editor
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – 线程输入屏幕及其编辑器
- en: 'Our Rich Text editor provides the following options: bold, italic, underline,
    show as code, make header, wrap in quotes, number list, and bullet list. As you
    can see, all our formatters work.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的富文本编辑器提供以下选项：加粗、斜体、下划线、显示为代码、制作标题、引用、编号列表和项目符号列表。正如您所看到的，我们所有的格式化工作都很好。
- en: 'When using Slate.js, you might be wondering why the bullets appear, even though
    we added the CSS to remove `ul` styling to our `index.css` file earlier. In order
    to get proper styling in our editor, I updated that style like this:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Slate.js时，您可能会想知道为什么会出现项目符号，即使我们之前已经在我们的`index.css`文件中添加了删除`ul`样式的CSS。为了在我们的编辑器中获得适当的样式，我更新了那个样式，就像这样：
- en: '[PRE69]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This is a CSS selector that says "do not apply this style if the element has
    a custom attribute on it called `data-slate-node`". This is what Slate.js uses
    to distinguish its own elements from other standard HTML.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个CSS选择器，表示“如果元素上有一个名为`data-slate-node`的自定义属性，则不应用此样式”。这是Slate.js用来区分自己的元素和其他标准HTML的方法。
- en: 'Wow, that was a lot of code! However, we''re not done yet. We still have to
    create our points column on the right, add our response capability, and allow
    `ThreadItems` to be added. Let''s leave the points column for a little later and
    work on our response system next:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，那是很多代码！但是，我们还没有完成。我们仍然需要在右侧创建我们的积分列，添加我们的响应功能，并允许添加`ThreadItems`。让我们稍后再处理积分列，先处理我们的响应系统：
- en: The first thing we want to do is some refactoring. In our `ThreadHeader` component,
    we displayed `userName` and `lastModifiedOn` to let users know who created the
    post and when. We can use this display for our responses as well. So, let's pull
    out this bit of code and put into a separate component so that we can reuse it.
    Create a file called `UserNameAndTime.tsx` in the `routes/thread` folder and add
    the source code to it. Since we're basically copying over the `ThreadHeader` code,
    I won't review it here.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是一些重构。在我们的`ThreadHeader`组件中，我们显示了`userName`和`lastModifiedOn`来让用户知道谁创建了帖子以及何时创建的。我们也可以将这个显示用于我们的回复。所以，让我们将这一部分代码提取出来，放到一个单独的组件中，这样我们就可以重用它。在`routes/thread`文件夹中创建一个名为`UserNameAndTime.tsx`的文件，并添加源代码。由于我们基本上是复制了`ThreadHeader`的代码，我就不在这里进行审查了。
- en: 'Now, we can use this by updating our `ThreadHeader` component code. Update
    it by replacing the JSX under the `h3` tags for `title` with the following code.
    Don''t forget to add the import statement:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过更新我们的`ThreadHeader`组件代码来使用它。通过用以下代码替换`title`下的`h3`标签下的JSX来更新它。不要忘记添加导入语句：
- en: '[PRE70]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Great! Now, we can start building our `ThreadItems` component. But this time,
    we'll do things a little differently. In the case of Thread responses, it is possible
    that we might have more than one response. So, this scenario is somewhat analogous
    to a machine in a widget factory. There is only one machine but potentially many
    widgets that need to be created. This sort of situation in programming design
    would usually entail using something called a factory pattern.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们可以开始构建我们的`ThreadItems`组件。但这一次，我们会有点不同。在主题回复的情况下，可能会有多个回复。因此，这种情况在编程设计中通常需要使用一种称为工厂模式的东西。
- en: 'So, what we''re going to make is actually two components. One component will
    act as the factory "building" Thread responses. The other component will define
    what a response actually looks like. So, together these two components can churn
    out any number of responses. Note that we''re not using the formal design pattern
    for the factory, just a rough conceptual model. Let''s get started:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们要做的实际上是两个组件。一个组件将充当工厂“构建”主题回复。另一个组件将定义回复实际上是什么样子的。因此，这两个组件一起可以产生任意数量的回复。请注意，我们没有使用工厂的正式设计模式，只是一个粗略的概念模型。让我们开始吧：
- en: First, we need to create our `ThreadResponse` component, which will define what
    our `ThreadItem` UI and behavior look like. Create a `ThreadResponse.tsx` file
    inside `routes`/`thread` and add the relevant source code.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的`ThreadResponse`组件，它将定义我们的`ThreadItem` UI和行为是什么样子的。在`routes`/`thread`文件夹中创建一个`ThreadResponse.tsx`文件，并添加相关的源代码。
- en: First, notice we are importing and reusing the `RichEditor` and `UserNameAndTime`
    components we created earlier. Can you imagine how much work it would take to
    have to recreate them again if we had not componentized them? Thank goodness we
    put them into their own components!
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意我们正在导入和重用我们之前创建的`RichEditor`和`UserNameAndTime`组件。你能想象如果我们没有将它们组件化，要重新创建它们需要多少工作吗？谢天谢地，我们把它们放到了它们自己的组件中！
- en: Next, we have our `ThreadResponseProps` interface. Notice that all our props
    are optional. This is in preparation for when we refactor this component and make
    it capable of creating new response entries.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的`ThreadResponseProps`接口。请注意，我们所有的props都是可选的。这是为了准备当我们重构这个组件并使其能够创建新的回复条目时。
- en: Finally, we have the returned JSX. This is a pretty simple UI – we just display
    our `UserNameAndTime` and `RichEditor`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了返回的JSX。这是一个非常简单的UI - 我们只显示我们的`UserNameAndTime`和`RichEditor`。
- en: Now, let's create our `ThreadResponse` factory. Create a file called `ThreadResponseBuilder.tsx`
    in the same folder and add the relevant source code to it.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的`ThreadResponse`工厂。在同一个文件夹中创建一个名为`ThreadResponseBuilder.tsx`的文件，并添加相关的源代码。
- en: First, we have the `ThreadResponsesBuilderProps` interface. This component will
    receive a `props` that contains a list of `ThreadItems`. We'll have to update
    our `Thread` parent component so that it passes the list down.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`ThreadResponsesBuilderProps`接口。这个组件将接收一个包含`ThreadItems`列表的`props`。我们将不得不更新我们的`Thread`父组件，以便它将列表传递下去。
- en: Starting on *line 12*, since our builder is churning out multiple responses,
    our only state, `responseElements`, is a JSX element that's used to contain them.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 从*第12行*开始，因为我们的构建器正在生产多个回复，我们唯一的状态`responseElements`是一个用于包含它们的JSX元素。
- en: Next, we use `useEffect` to create our list of response elements. Each `ThreadResponse`
    instance has a unique key, which prevents rendering issues. Whenever our `threadItems`
    props change, we will create a `ul` of `ThreadResponses`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`useEffect`来创建我们的回复元素列表。每个`ThreadResponse`实例都有一个唯一的键，这可以防止渲染问题。每当我们的`threadItems`
    props改变时，我们将创建一个`ThreadResponses`的`ul`。
- en: Finally, we return our JSX, which is a list of `TheadResponse` elements.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回我们的JSX，这是一个`TheadResponse`元素的列表。
- en: We're almost done. Let's update our `Thread.tsx` file so that it now uses our
    `ThreadResponsesBuilder` component. Note that the styling has been updated in
    the `App.css` and `Thread.css` files.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们快要完成了。让我们更新我们的`Thread.tsx`文件，使其现在使用我们的`ThreadResponsesBuilder`组件。请注意，样式已经在`App.css`和`Thread.css`文件中更新。
- en: 'In the JSX just below `ThreadBody`, add the highlighted tags shown in the following
    code:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ThreadBody`下面的JSX中，添加以下代码中显示的突出显示的标签：
- en: '[PRE71]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![Figure 12.16 – A Thread and its responses'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16 - 一个主题及其回复'
- en: '](img/Figure_12.16_B15508.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.16_B15508.jpg)'
- en: Figure 12.16 – A Thread and its responses
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 - 一个主题及其回复
- en: We now have an almost complete `Thread` posting and viewing UI. But again, we're
    not done yet. We still have to build our points viewer and enable `Thread` and
    `ThreadItem` posting. We'll build the points viewing component here, but let's
    leave the posting capability for later chapters, when we have our backend ready
    to tie it together. Also, when our backend is ready, it will become clearer as
    to why we did certain things the way we did them here.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎有了一个完整的`Thread`发布和查看UI。但是，我们还没有完成。我们仍然需要构建我们的点查看器，并启用`Thread`和`ThreadItem`的发布。我们将在这里构建点查看组件，但是让我们把发布能力留到以后的章节，当我们的后端准备好时再将其联系在一起。此外，当我们的后端准备好时，为什么我们在这里做某些事情将变得更加清晰。
- en: 'For our `categorythreads` route, you saw that we had a vertical bar showing
    our likes and response count. If you take a look at how we created that section,
    you''ll see we put that code into a function called `getPointsNonMobile`. We could
    extract this feature into its own React component. Obviously, this will allow
    us to use it in both our `ThreadCard` component and our `Thread` component, as
    well as anywhere else we may need it later. Let''s get started:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`categorythreads`路由，你会发现我们有一个垂直条显示我们的点赞和回复计数。如果你看一下我们是如何创建这个部分的，你会发现我们将那段代码放入了一个名为`getPointsNonMobile`的函数中。我们可以将这个功能提取到自己的React组件中。显然，这将允许我们在`ThreadCard`组件和`Thread`组件以及以后可能需要的任何其他地方使用它。让我们开始吧：
- en: Create a new file called `ThreadPointsBar.tsx` and place it inside the root
    of the `components` folder. We'll take the `getPointsNonMobile` function from
    the `ThreadCard` component and add it inside this new component.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ThreadPointsBar.tsx`的新文件，并将其放在`components`文件夹的根目录中。我们将从`ThreadCard`组件中获取`getPointsNonMobile`函数，并将其添加到这个新组件中。
- en: On *line 6*, we use `ThreadPointsBarProps` as our props type. You may be wondering
    why I didn't just pass the entire Thread object in. Adding only the member data
    that's needed allows us to keep better separation of concerns. If we passed the
    entire Thread, not only would we be telling our `ThreadPointsBar` about what model
    types we are dealing with, but we would be giving it information it does not actually
    use or need.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行，我们使用`ThreadPointsBarProps`作为我们的props类型。你可能会想为什么我不直接传入整个Thread对象。只添加需要的成员数据可以更好地保持关注点的分离。如果我们传递整个Thread，不仅会告诉`ThreadPointsBar`我们正在处理哪种模型类型，还会给它一些实际上并没有使用或需要的信息。
- en: Next, the returned JSX is basically the same as the original function as it
    does the same thing. Now, try updating the `ThreadCard` component so that the
    `getPointsNonMobile` function gets removed. In its place, we will add our new
    `ThreadPointsBar` component. Note that our `ThreadCard.css` file was updated slightly,
    so you should refresh it. The screen should look identical to our original screen
    since we only moved things around.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，返回的JSX基本上与原始函数相同，因为它执行相同的操作。现在，尝试更新`ThreadCard`组件，以便删除`getPointsNonMobile`函数。我们将在其位置添加我们的新`ThreadPointsBar`组件。请注意，我们稍微更新了`ThreadCard.css`文件，因此您应该刷新它。屏幕应该与我们的原始屏幕相同，因为我们只是移动了一些东西。
- en: 'Now, let''s add our new `ThreadPointsBar` component to our `Thread` route component.
    The JSX changes are small but significant, so let''s go over them here and then
    look at our updated `Thread.css` file:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将新的`ThreadPointsBar`组件添加到我们的`Thread`路由组件中。JSX的变化很小但很重要，所以让我们在这里进行解释，然后再看看我们更新后的`Thread.css`文件：
- en: '[PRE72]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here, we''ve moved the order of some of our elements around. Now, the main
    Thread post-related elements are under this `div` in the `thread-content-post-container`
    class:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们改变了一些元素的顺序。现在，主要的Thread帖子相关元素位于`thread-content-post-container`类的`div`下面：
- en: '[PRE73]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here, we have a brand new `div` with a `thread-content-points-container` class
    that contains our new `ThreadPointsBar` component:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个全新的带有`thread-content-points-container`类的`div`，其中包含我们的新`ThreadPointsBar`组件：
- en: '[PRE74]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: </div>
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: );
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '};'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE75]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now, we want to give our points totals for our responses. However, because we
    could end up having many responses, it might not look that great to have 20 or
    30 little vertical points bars for each response. So, to make things look cleaner,
    let's just put these points on the same line as our `userName` and `createdOn`
    dates. Luckily for us, we've already created most of the code to show these points
    in our `ThreadCard` component with the `getPoints` function. So, let's convert
    that into a component too.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想为我们的回复给出点数总计。但是，因为我们可能会有很多回复，为每个回复显示20或30个小的垂直点条可能看起来不太好。为了使事情看起来更整洁，让我们把这些点放在与我们的`userName`和`createdOn`日期相同的行上。幸运的是，我们已经在`ThreadCard`组件中使用`getPoints`函数创建了大部分显示这些点的代码。所以，让我们也将其转换为一个组件。
- en: Create a new file called `ThreadPointsInline.tsx` and add the relevant source
    code to it. We've basically just copied and pasted our `getPoints` code into here,
    so there's not much to explain. However, notice that we reused the `ThreadPointsBarProps`
    interface from the `ThreadPointsBar` component. So, we need to make this type
    exportable.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`ThreadPointsInline.tsx`的新文件，并将相关源代码添加到其中。我们基本上只是将我们的`getPoints`代码复制粘贴到这里，所以没有太多解释。但是，请注意我们从`ThreadPointsBar`组件中重用了`ThreadPointsBarProps`接口。因此，我们需要将这种类型导出。
- en: 'I''ll assume you know how to update the `ThreadCard.tsx` file since we did
    this earlier with `ThreadPointsBar`. Now, let''s update the `ThreadResponse.tsx`
    file so that it uses our new `ThreadPointsInline` component. Try and do this on
    your own; only look at the code if you get stuck. So, here''s what we have now:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你知道如何更新`ThreadCard.tsx`文件，因为我们之前使用`ThreadPointsBar`做过这个。现在，让我们更新`ThreadResponse.tsx`文件，以便使用我们的新`ThreadPointsInline`组件。尝试自己做这个；只有在卡住时才查看代码。现在我们有：
- en: '![Figure 12.17 – Displaying thread points'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17 - 显示主题点数'
- en: '](img/Figure_12.17_B15508.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.17_B15508.jpg)'
- en: Figure 12.17 – Displaying thread points
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17 - 显示主题点数
- en: As you can see, both our points systems can be seen. Now, there's one final
    small trick we need to implement to get this screen showing up properly on mobile
    devices.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的两个点系统都可以看到。现在，我们需要实现一个最后的小技巧，以便在移动设备上正确显示这个屏幕。
- en: Open the `Thread.css` file and make sure it contains the same Media Query as
    the source code.
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Thread.css`文件，确保它包含与源代码相同的媒体查询。
- en: Now, open the `Thread` component's code so that we can go through it.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`Thread`组件的代码，这样我们就可以浏览它。
- en: On *line 32*, you will see that our Thread post-related items all live inside
    `thread-content-container`. The CSS class, via the Media Query, has been set so
    that it only has a `ThreadPointsBar` component from that area, we don't end up
    with an empty space, because we had two columns previously.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第32行*，你会看到我们的线程帖子相关的项目都位于`thread-content-container`内。通过媒体查询设置了CSS类，以便它只有一个`ThreadPointsBar`组件，从该区域，我们不会得到一个空白空间，因为之前有两列。
- en: Next, we can see that our `ThreadPointsBar` actually lives inside `thread-content-points-container`.
    In the Media Query, we are making that element invisible. This is still efficient
    because, as you may recall, internally, `ThreadPointsBar` is using our `useWindowDimensions`
    Hook to determine if it should render itself or not. It will not do this for mobile
    devices.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到我们的`ThreadPointsBar`实际上位于`thread-content-points-container`内。在媒体查询中，我们使该元素不可见。这仍然是有效的，因为你可能还记得，内部，`ThreadPointsBar`正在使用我们的`useWindowDimensions`
    Hook来确定它是否应该渲染自身。它不会为移动设备执行此操作。
- en: 'Awesome! Let''s take a look our screen now on mobile:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在让我们在移动设备上查看我们的屏幕：
- en: '![Figure 12.18 – Mobile view of the Thread screen'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.18 – 线程屏幕的移动视图'
- en: '](img/Figure_12.18_B15508.jpg)'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.18_B15508.jpg)'
- en: Figure 12.18 – Mobile view of the Thread screen
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18 – 线程屏幕的移动视图
- en: Terrific! Now, we have one code base and two screens.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们有一个代码库和两个屏幕。
- en: 'For the final item in this chapter, we will build out our `UserProfile` screen.
    We want to do a few things with this screen:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个项目中，我们将构建`UserProfile`屏幕。我们想在这个屏幕上做一些事情：
- en: Allow users to reset their passwords.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户重置他们的密码。
- en: Show all user-generated Thread posts.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有用户生成的线程帖子。
- en: Show all user-generated responses (`ThreadItems`).
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有用户生成的回复（`ThreadItems`）。
- en: 'Let''s get started:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: The very first thing we have to do is actually make a change to the `SideBarMenus`
    component. We need to move out the `useEffect` call in order to send our user
    to Redux, and then to the `Login` component. We're doing this so that when the
    user successfully logs in, the new user object will be sent to Redux. By now,
    you should be comfortable with making this kind of change. So, go ahead and remove
    this code from `SideBarMenu` and add it to `Login`.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实际上要做的第一件事是对`SideBarMenus`组件进行更改。我们需要移出`useEffect`调用，以便将我们的用户发送到Redux，然后发送到`Login`组件。我们这样做是为了当用户成功登录时，新的用户对象将被发送到Redux。到目前为止，你应该已经习惯了进行这种改变。所以，继续将这段代码从`SideBarMenu`中移除，并添加到`Login`中。
- en: Tip
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure that when you put the code into `Login`, you change the name of `dispatch`
    to something else, as there is already a `dispatch` in the `Login` component.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将代码放入`Login`时，将`dispatch`的名称更改为其他名称，因为`Login`组件中已经有一个`dispatch`。
- en: This new screen will include a password reset feature, but you may recall we
    already have a lot of code for doing password confirmations in our `Register`
    component. Let's try to extract that code into its own component so that we can
    reuse it in both the `Register` component and our new `UserProfile` component.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个新屏幕将包括密码重置功能，但你可能还记得我们已经有很多代码来进行密码确认在我们的`Register`组件中。让我们尝试将该代码提取到自己的组件中，以便我们可以在`Register`组件和我们的新`UserProfile`组件中重用它。
- en: Create a file called `PasswordComparison.tsx` inside the `components/auth/common`
    folder. Add the relevant source code to it.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components/auth/common`文件夹内创建一个名为`PasswordComparison.tsx`的文件。将相关的源代码添加到其中。
- en: This is a fairly straightforward copy and paste, but there's a couple of things
    to note. Notice that this component does not use `userReducer`, instead taking
    props for its values. In particular, notice that one of them is the `dispatch`
    function. `dispatch` call belongs to the parent. Everything else is basically
    a copy and paste.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的复制粘贴，但有一些要注意的地方。请注意，此组件不使用`userReducer`，而是使用其值的props。特别要注意的是其中一个是`dispatch`函数。`dispatch`调用属于父级。其他一切基本上都是复制和粘贴。
- en: Try removing this code yourself from the original `Register` component. Ensure
    that you remove all the unnecessary imports.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己从原始的`Register`组件中删除这段代码。确保删除所有不必要的导入。
- en: Now, let's create a new `userProfile` folder inside the `routes` folder so that
    we can create our new `UserProfile.tsx` file and add the relevant source code
    to it.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`routes`文件夹内创建一个新的`userProfile`文件夹，这样我们就可以创建我们的新的`UserProfile.tsx`文件，并将相关的源代码添加到其中。
- en: Starting on *line 14*, we use our `userReducer` since we need some of its properties,
    such as `userName`. We also get the Redux user reducer and set some local state
    for the user's Threads and `ThreadItems`.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 从*第14行*开始，我们使用我们的`userReducer`，因为我们需要一些它的属性，比如`userName`。我们还获取Redux用户reducer并为用户的Threads和`ThreadItems`设置一些本地状态。
- en: On *line 28*, the `useEffect` function is using the`getUserThreads` function
    of `DataService`, which gets the user's Threads. We don't need another call to
    get `ThreadItems` because Threads contains related `ThreadItems`. However, I did
    update the `ThreadItem` class so that it includes its parent `ThreadId`. Take
    a look at those files for that code.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第28行*，`useEffect`函数使用`DataService`的`getUserThreads`函数，获取用户的Threads。我们不需要另一个调用来获取`ThreadItems`，因为Threads包含相关的`ThreadItems`。但是，我更新了`ThreadItem`类，以便它包括其父`ThreadId`。查看这些文件以获取该代码。
- en: Next, starting on *line 38*, we map each Thread in the query results to an `li`.
    We also add all `ThreadItems` to a single array so that we can use them later.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从*第38行*开始，我们将查询结果中的每个线程映射到一个`li`。我们还将所有`ThreadItems`添加到一个数组中，以便以后使用。
- en: Then, starting on *line 53*, we've taken our `ThreadItems` and mapped them to
    a set of `li` as well.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从*第53行*开始，我们将我们的`ThreadItems`映射到一组`li`。
- en: On *line 77*, we use the `PasswordComparison` component that we created earlier.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第77行*，我们使用了之前创建的`PasswordComparison`组件。
- en: On *line 82*, notice we have our button using `isSubmitDisabled`. Can you guess
    how this disabling is working, even though `UserProfile` does not contain any
    code to change it? That's right – `PasswordComparison` is doing it internally
    using our UserProfile's `dispatch` function.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第82行*，请注意我们的按钮使用了`isSubmitDisabled`。你能猜到这种禁用是如何工作的吗，即使`UserProfile`并不包含任何改变它的代码？没错——`PasswordComparison`在内部使用我们UserProfile的`dispatch`函数来做到这一点。
- en: Finally, we have our Threads and `ThreadItems` rendered off our local state
    objects.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的Threads和`ThreadItems`是从我们的本地状态对象渲染出来的。
- en: For the final change, let's update our `App.tsx` file so that it includes our
    new route for `UserProfile`. Note that we also need to temporarily add the `userName`
    Redux call until the same call, inside `Login.tsx`, is completely working (we'll
    finish the call in `Login.tsx` once our backend is ready). This is because when
    we load our `UserProfile`, there is no guarantee that the user has already loaded
    their `Login` screen. However, we know that if they've loaded any screen in the
    app, they must have loaded the `App.tsx` component. Update `App.tsx` from the
    source code.
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后的更改，让我们更新我们的`App.tsx`文件，以便包括我们的新路由`UserProfile`。请注意，我们还需要临时添加`userName`
    Redux调用，直到`Login.tsx`中的相同调用完全工作（一旦我们的后端准备好，我们将在`Login.tsx`中完成调用）。这是因为当我们加载我们的`UserProfile`时，不能保证用户已经加载了他们的`Login`屏幕。但是，我们知道如果他们已经加载了应用程序中的任何屏幕，他们必须已经加载了`App.tsx`组件。从源代码中更新`App.tsx`。
- en: So, first, we have a `useEffect` with a hardcoded `userName` being sent to the
    Redux store. Again, this is only temporary until our backend is ready.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个`useEffect`，其中有一个硬编码的`userName`被发送到Redux存储。同样，这只是临时的，直到我们的后端准备好为止。
- en: On *line 26*, `renderUserProfile` is the function that returns our `UserProfile`
    component. That function is then used on *line 33* as the destination for the
    new route; that is, `"/userprofile/:id"`.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第26行*，`renderUserProfile`是返回我们的`UserProfile`组件的函数。然后在*第33行*将该函数用作新路由的目的地；即`"/userprofile/:id"`。
- en: 'There''s one more tiny change we need to make. In our `SideBarMenus` component,
    let''s update our `userName` label so that it''s a link to our new `UserProfile`
    screen. You can find this JSX in the `SideBarMenus.tsx` file:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做一个微小的改变。在我们的`SideBarMenus`组件中，让我们更新我们的`userName`标签，使其成为指向我们新的`UserProfile`屏幕的链接。您可以在`SideBarMenus.tsx`文件中找到这个JSX：
- en: '[PRE76]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, replace it with this:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用这个替换它：
- en: '[PRE77]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, if you run the app, you will see the following:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行应用程序，您将看到以下内容：
- en: '![Figure 12.19 – UserProfile screen'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.19 – 用户资料屏幕'
- en: '](img/Figure_12.19_B15508.jpg)'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.19_B15508.jpg)'
- en: Figure 12.19 – UserProfile screen
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19 – 用户资料屏幕
- en: If you click on any of the Thread links, you'll see that they take us to the
    thread route.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击任何一个Thread链接，您会发现它们会带我们到thread路由。
- en: That was amazing! We've gone through so much React code in this chapter. We
    learned about the layout, folder structure, component creation, code reuse, code
    refactoring, styling, and more. Code refactoring in particular can be very time-consuming
    and even stressful. However, the reality is that most of the time, we will not
    be writing new code but refactoring existing code. So, this was a good way to
    build our skills.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在这一章中，我们经历了大量的React代码。我们学习了布局、文件夹结构、组件创建、代码重用、代码重构、样式等。特别是代码重构可能非常耗时甚至令人紧张。然而，现实是，大多数时候，我们不会写新代码，而是重构现有代码。因此，这是建立我们技能的一个很好的方式。
- en: In the next few chapters, we will be building out our backend and tying it together
    with our client side. You should now feel very confident – you've made a huge
    effort in getting through this complex chapter.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将构建我们的后端，并将其与我们的客户端连接起来。现在你应该感到非常自信——你已经在这一复杂章节中付出了巨大的努力。
- en: Summary
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we began our journey of building our full stack application
    by creating our React client. We used Hooks to create our components, implemented
    component hierarchies, and designed layouts using CSS Grid. We then refactored
    a ton of code, and we tried to reuse as much code as possible. Even though we're
    not done yet, we've built out a large important piece of our final application.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们开始了构建全栈应用程序的旅程，首先创建了React客户端。我们使用Hooks创建了组件，实现了组件层次结构，并使用CSS Grid设计了布局。然后我们重构了大量的代码，并尽量重用了尽可能多的代码。尽管我们还没有完成，但我们已经构建了最终应用程序的一个重要部分。
- en: 'In the next chapter, we will learn about the session state on our backend server,
    what the session state is, how to use it, and the most popular tool for creating
    and managing session data: Redis.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于后端服务器上的会话状态，会话状态是什么，如何使用它，以及创建和管理会话数据的最流行工具：Redis。
