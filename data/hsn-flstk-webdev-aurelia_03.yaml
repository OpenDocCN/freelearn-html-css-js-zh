- en: Testing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和调试
- en: Testing is one of the most important phases of the development process. Whatever
    type of project you are working on, testing is key if you want to deliver applications
    with high quality and make your users happy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是开发过程中最重要的阶段之一。无论您正在处理哪种类型的项目，如果您想交付高质量的应用程序并让用户满意，测试是关键。
- en: Just imagine what would happen if your favorite taxi application makes your
    driver take you to the wrong place or the price of your trip is higher than it's
    supposed to be? This embarrassing bug will undoubtedly produce a series of catastrophic
    events that will damage the reputation of the application and, worse still, the
    company reputation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果您的最喜欢的出租车应用程序让您的司机带您去错误的地方，或者您的行程价格比预期的高？这个尴尬的错误无疑会引发一系列灾难性事件，损害应用程序的声誉，更糟糕的是，公司的声誉。
- en: 'Learning how to test our Aurelia applications and how to correctly apply the
    **Test**-**Driven Development** (**TDD**) approach will improve the quality of
    your applications, avoid embarrassing bugs, make your users happier, and make
    you a better developer. So, in this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何测试我们的 Aurelia 应用程序以及如何正确应用**测试驱动开发**（**TDD**）方法将提高您应用程序的质量，避免尴尬的错误，让您的用户更满意，并使您成为一名更好的开发者。因此，在本章中，我们将涵盖以下主题：
- en: Benefits of testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的好处
- en: TDD
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD
- en: Aurelia testing framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aurelia 测试框架
- en: Practicing testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习测试
- en: Debugging our code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试我们的代码
- en: Benefits of testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的好处
- en: 'Making *testing* part of our development process comes with a lot of benefits
    in every layer of our project. Before we start writing code to test our application,
    let''s review the benefits that good testing brings to:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将*测试*纳入我们的开发流程，在项目的每一层都带来了许多好处。在我们开始编写测试应用程序的代码之前，让我们回顾一下良好的测试为以下方面带来的好处：
- en: The development team
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队
- en: The project
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目
- en: The organization
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织
- en: The users
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: For the development team
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于开发团队
- en: If you work in a team with multiple members, you might have experienced that
    bad moment when a member pushes some changes and the application does not work
    as expected. Not only that, if the team does not have a mechanism to avoid changes
    that can break, someone else's code might cause conflict and decrease the quality
    of our applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个有多名成员的团队中工作，您可能经历过这样的时刻：一名成员推送了一些更改，而应用程序没有按预期工作。不仅如此，如果团队没有避免破坏性更改的机制，其他人可能导致的代码冲突可能会降低我们应用程序的质量。
- en: Applying testing enables a mechanism that helps us avoid potential bugs in the
    code. It is recommended that you write test scripts for all the components into
    the application. The code coverage percentage is an indicator of how much testing
    the development team has written for the application. It is recommended to have
    a 100 percent coverage; with this, you ensure that every time someone else changes
    the code, you are not breaking someone else's code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用测试机制可以帮助我们避免代码中的潜在错误。建议您为应用程序的所有组件编写测试脚本。代码覆盖率百分比是开发团队为应用程序编写测试程度的指标。建议达到100%的覆盖率；这样，您可以确保每次有人更改代码时，您不会破坏他人的代码。
- en: For the project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于项目
- en: If you are working in an *agile* team, you might be familiar with sprints of
    two weeks or maybe one month. When you work in agile teams, it is important to
    automate as much as you can, and automating the testing phase will help your team
    deliver deliverables quickly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个*敏捷*团队中工作，您可能熟悉两周或一个月的冲刺。当您在敏捷团队中工作时，尽可能自动化是非常重要的，自动化测试阶段将帮助您的团队快速交付成果。
- en: 'Automating testing without the need for human intervention requires your team
    to write tests in all the phases of the application, such as these:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无需人工干预的自动化测试要求您的团队在应用程序的所有阶段编写测试，例如以下这些：
- en: Unit test
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration test
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: UI test
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 测试
- en: End-to-end test
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: For Aurelia applications, you will learn how to write unit-test scripts and
    end-to-end tests. Writing tests and automating them will increase the development
    speed of our team.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Aurelia 应用程序，您将学习如何编写单元测试脚本和端到端测试。编写测试并自动化它们将提高我们团队的开发速度。
- en: For the organization
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于组织
- en: It is important to protect the reputation of the organization in which you are
    working. Testing projects in our organization as much as possible will improve
    its reputation and make it more reliable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 保护您所在组织的声誉非常重要。尽可能多地测试我们组织的项目将提高其声誉并使其更加可靠。
- en: There are many cases where big companies have lost a large amount of money because
    of failures in software. All these mistakes could have been avoided if the applications
    had been tested before they were published to the users. For that reason, understanding
    the importance of good testing is key in every aspect of the organization.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况，大公司因为软件故障而损失了大量资金。如果这些应用程序在发布给用户之前进行了测试，所有这些错误本可以避免。因此，理解良好测试的重要性对于组织的各个方面至关重要。
- en: For the users
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于用户来说
- en: Nothing is worse than delivering an application to your users that does not
    satisfy their needs, and even worse is an application infested with bugs and is
    of a generally poor quality. Think carefully about what you deliver to your users.
    The more you code, the more satisfied your users will be.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比向用户交付不能满足他们需求的应用程序更糟糕的了，更糟糕的是，应用程序充满了错误，质量普遍较差。仔细思考你向用户交付的内容。你编写的代码越多，你的用户就越满意。
- en: Test-Driven Development
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: This is a development approach that changes the way developers test the code
    of their applications. Previously, developers implemented all the business logic
    of their applications and once everything was coded, they wrote the tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种改变开发者测试其应用程序代码方式的发展方法。以前，开发者实现了他们应用程序的所有业务逻辑，一旦一切都编码完成，他们就会编写测试。
- en: 'Writing test scripts is not an easy task; just imagine the time it takes to
    code all the business logic of your application, and the fact that you have to
    write tests for all the possible scenarios requires a lot of knowledge about the
    system itself and the level of complexity only increases if you are the sole developer
    who maintains the code. However, thankfully, there is a better way to test things
    out. TDD is composed of three simple phases:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试脚本不是一件容易的任务；想象一下编写你应用程序所有业务逻辑所需的时间，以及你必须为所有可能的场景编写测试的事实，这需要你对系统本身的很多知识，而且如果你是唯一维护代码的开发者，复杂性只会增加。然而，幸运的是，有一个更好的方法来测试事物。TDD由三个简单阶段组成：
- en: '![](img/8288c148-ff21-4e0c-8387-d6c9ddaca46f.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8288c148-ff21-4e0c-8387-d6c9ddaca46f.png)'
- en: 'Always remember these three colors: red, green, and blue; they represent the
    TDD cycle. Being in the red phase means that you have written what your piece
    of code is supposed to do, but the functionality is not implemented yet and the
    test will fail. Being in the blue phase, it means that you have implemented the
    code and the test now passes without any problem, but the code might be refactored.
    Lastly, being in the green phase means that both the code and tests were implemented
    and passed successfully, and the code is well formatted and easy for any developer
    to read.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住这三个颜色：红色、绿色和蓝色；它们代表TDD周期。处于红色阶段意味着你已经写下了你的代码应该做什么，但功能尚未实现，测试将失败。处于蓝色阶段，意味着你已经实现了代码，测试现在通过没有任何问题，但代码可能需要重构。最后，处于绿色阶段意味着代码和测试都已实现并通过，代码格式良好，任何开发者都容易阅读。
- en: Let's cover each step in further detail to get a close look at TDD phases by
    coding a simple example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个简单的示例来详细说明每个步骤，以便更接近地观察TDD阶段。
- en: Making our code fail
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们的代码失败
- en: It is important to know that we won't use any testing framework at this point.
    The main goal in this section is to understand how TDD works; we have a complete
    tour of testing technology in the following sections in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，我们在这个阶段不会使用任何测试框架。本节的主要目标是了解TDD是如何工作的；在本章的后续部分，我们将对测试技术进行全面的介绍。
- en: 'We will use TDD to create an additional function called `sum`, which will return
    the sum of two numbers that are passed as parameters. First, using an editor of
    your choice, create a new file called `testing.js` and add the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用TDD创建一个名为`sum`的附加函数，该函数将返回作为参数传递的两个数字的总和。首先，使用你选择的编辑器，创建一个名为`testing.js`的新文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, we import the `assert` module to use its `equal` function. The `equal`
    function expects three parameters:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`assert`模块以使用其`equal`函数。`equal`函数期望三个参数：
- en: The current value or expression to be analyzed
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前要分析的价值或表达式
- en: The expected value
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期值
- en: The message that should be thrown in case the current and expected value are
    not equal
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当当前值和预期值不相等时应该抛出的消息
- en: If the assertion *fails*, the program will be *finished* and you will see the
    reason why the assertion fails in your Terminal.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言*失败*，程序将被*终止*，你将在你的终端中看到断言失败的原因。
- en: 'Once we import our `assert` module, we proceed to create our `add` function.
    However, this function does not perform any operation; this is because our intention
    is to first write the test and make it fail, and after that we will implement
    the logic itself in the next point. In the same `testing.js` file, append to the
    following code with the testing case right below the `add` function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了我们的`assert`模块，我们就继续创建我们的`add`函数。然而，这个函数不执行任何操作；这是因为我们的意图是首先编写测试并使其失败，然后我们将在下一个点中实现逻辑本身。在同一个`testing.js`文件中，在`add`函数下方添加以下代码，并添加测试用例：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have our test case, which will compare the current value—`add(5, 5)`—housed
    into the result variable against the expected value—`10`, and if they are not
    equal, the `Should be 10` error message will be displayed and as the program is
    complete, the next expression—`console.log`—won't be executed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了测试用例，它将比较当前值——`add(5, 5)`存放在结果变量中——与预期值——`10`，如果它们不相等，将显示`Should be 10`错误消息，并且由于程序已经完成，下一个表达式——`console.log`——将不会执行。
- en: 'It''s time to execute our test. Using your Terminal, get into your folder where
    you have created the `testing.js` file and execute the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候执行我们的测试了。使用你的终端，进入你创建`testing.js`文件的文件夹，并执行以下命令：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If everything went wrong, you should see the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切出错，你应该看到以下输出：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Cool! Now it's time to implement the code and pass our test.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！现在是我们实现代码并通过测试的时候了。
- en: Implementing the code
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现代码
- en: 'Now, let''s implement the code in the `add` function. We will declare a `result`
    variable into the function to house the addition between the two parameters passed
    to it. Open the `testing.js` file and apply the following changes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`add`函数中实现代码。我们将声明一个`result`变量到函数中，用于存放传递给它的两个参数之间的加法运算。打开`testing.js`文件并应用以下更改：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have implemented the logic for our `add` function, the next time
    we run the test, we expect that the `assertion.equal` function won''t fail and
    the `Test passed!!` message will be displayed. Let''s try it out. Execute the
    following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`add`函数的逻辑，下次我们运行测试时，我们期望`assertion.equal`函数不会失败，并且会显示`Test passed!!`消息。让我们试试看。执行以下命令：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the test passed and now the `Test passed!!` message is displayed.
    By using this strategy to write the test first and then implement it, we can be
    100 percent sure that our application is doing what it's supposed to do.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，测试通过了，现在显示`Test passed!!`消息。通过使用这种先编写测试然后实现的策略，我们可以100%确信我们的应用程序正在做它应该做的事情。
- en: Let's follow the last step to finish our TDD flow.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循最后一步来完成我们的TDD流程。
- en: Refactoring our code
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构我们的代码
- en: At this point, everything is okay; we have our test and implementation written,
    the code is doing what we expect, and it seems that there's nothing left to do.
    But, as a good developer, we should look for ways to make our code more readable
    and reduce the lines of code. Also, the refactoring phase is used to change some
    weird variable names and, if possible, add comments to our code if needed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切正常；我们已经编写了测试和实现，代码正在做我们期望的事情，看起来似乎没有剩下什么要做的。但是，作为一个好的开发者，我们应该寻找使我们的代码更易于阅读并减少代码行数的方法。此外，重构阶段用于更改一些奇怪的变量名，如果需要，还可以添加注释到我们的代码中。
- en: 'Open your `testing.js` file and apply the following changes to make it more
    readable:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`testing.js`文件，应用以下更改以使其更易于阅读：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first change is in the `add` function. As this is a simple addition operation,
    declaring a `result` variable is not necessary, so we return the addition result
    in the `return` function to make it more readable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改是在`add`函数中。由于这是一个简单的加法操作，声明一个`result`变量是不必要的，因此我们返回加法结果在`return`函数中，使其更易于阅读。
- en: Finally, we are passing the results of the call to `add(5, 5)` into the `assert.equal`
    function, so it is easier to know what you are trying to test.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`add(5, 5)`调用的结果传递给`assert.equal`函数，这样更容易知道你正在尝试测试什么。
- en: As you might see, TDD is easy to implement but a little bit hard to adopt; we
    (the authors :D) encourage you to adopt and use it at work. This will make your
    life easier and will help you become a better programmer who knows how to deliver
    quality software.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，TDD易于实现但稍微有点难于采用；我们（作者们 :D）鼓励你在工作中采用并使用它。这将使你的生活更轻松，并帮助你成为一个更好的程序员，知道如何交付高质量的软件。
- en: Now it's time to see what Aurelia has to offer. Keep reading!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看Aurelia能提供什么了。继续阅读！
- en: Aurelia testing frameworks
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Aurelia测试框架
- en: Aurelia is powered by other open source testing technologies which together
    help us set up a very productive development environment. Understanding the fundamentals
    of these technologies will give us a clear idea of how things work and will give
    you the knowledge to tackle any problem that may appear in the future.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia由其他开源测试技术支持，这些技术共同帮助我们设置一个非常高效的开发环境。了解这些技术的根本原理将给我们一个清晰的思路，了解事情是如何运作的，并将为你提供解决未来可能出现的任何问题的知识。
- en: Before we write our first Aurelia tests, let's learn about JasmineJS and KarmaJS,
    the most awesome frameworks that the JavaScript ecosystem could provide us for
    testing, and let's use the example implemented in the TDD section to understand
    how to write testing scripts using the Jasmine syntax and assertions helper functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写第一个Aurelia测试之前，让我们了解一下JasmineJS和KarmaJS，这些是JavaScript生态系统为我们提供的最棒的测试框架，并且让我们使用TDD部分中实现的示例来了解如何使用Jasmine语法和断言辅助函数编写测试脚本。
- en: Learning JasmineJS
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习JasmineJS
- en: 'As is detailed in its website, Jasmine is a behavior-driven development framework
    for testing JavaScript code: it does not depend on any other JavaScript frameworks,
    it does not require a DOM, and it has a clean, obvious syntax so that you can
    easily write tests. Jasmine is an easy-to-learn framework, and it comes with its
    own assertion functions, so we don''t need to install any additional assertion
    library, such as Chai. Let''s start installing it and exploring the building blocks—suites
    and test cases.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如其网站详细说明，Jasmine是一个用于测试JavaScript代码的行为驱动开发框架：它不依赖于任何其他JavaScript框架，它不需要DOM，并且它有一个干净、明显的语法，这样你可以轻松编写测试。Jasmine是一个易于学习的框架，它自带断言函数，因此我们不需要安装任何额外的断言库，例如Chai。让我们开始安装它并探索构建块——套件和测试用例。
- en: Installation and configuration
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置
- en: 'We will use the NPM tool to install Jasmine. Open your favorite Terminal and
    execute the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用NPM工具安装Jasmine。打开你喜欢的终端并执行以下命令：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding instruction will install Jasmine as an executable program that
    you can invoke in any folder in your Terminal. We achieve this using the `--global`
    flag in the `npm install` command.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令将Jasmine作为可执行程序安装，你可以在终端的任何文件夹中调用它。我们通过在`npm install`命令中使用`--global`标志来实现这一点。
- en: 'Once Jasmine is installed, we need to create our project example skeleton to
    practice with Jasmine. For this, we need to do the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Jasmine安装完成，我们需要创建我们的项目示例骨架来练习使用Jasmine。为此，我们需要做以下几步：
- en: Create a new folder called `practice-jasmine`
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`practice-jasmine`的新文件夹
- en: Initialize a new Jasmine project by executing the `jasmine init` command
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`jasmine init`命令初始化一个新的Jasmine项目
- en: Write our test script
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写我们的测试脚本
- en: 'So, having the steps clear, open your Terminal and execute the following commands:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，步骤清晰后，打开你的终端并执行以下命令：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the `jasmine init` command is executed, it will create the following folder
    structure for our project:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了`jasmine init`命令，它将为我们的项目创建以下文件夹结构：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can get the preceding tree list by installing the `tree` program and executing
    it into your `practice-jasmine` folder with the `tree` command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过安装`tree`程序并在`practice-jasmine`文件夹中执行`tree`命令来获取上述树状列表。
- en: 'As you can see in the root of the project''s folder, there is a `spec` folder,
    where we will save all our test scripts. Right in the `spec` folder, there is
    a `support` folder where a `jasmine.json` file has been created for us. This file
    contains all the configuration that Jasmine will use to find our test scripts
    and then execute them. Using the editor of your choice, open the `jasmine.json`
    file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在项目文件夹的根目录中看到的，有一个`spec`文件夹，我们将在这里保存所有的测试脚本。在`spec`文件夹中，有一个`support`文件夹，其中为我们创建了一个`jasmine.json`文件。此文件包含Jasmine将用于查找我们的测试脚本并执行它们的全部配置。使用你选择的编辑器打开`jasmine.json`文件：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The important properties to consider in this file are `spec_dir`, which points
    to the folder that hosts our test scripts, and `spec_files`, which declares a
    regular expression that tells Jasmine that the files containing `spec.js` or `Spec.js`
    at the end of their names have to be considered as test scripts and have to be
    processed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中需要考虑的重要属性是`spec_dir`，它指向包含我们的测试脚本的文件夹，以及`spec_files`，它声明一个正则表达式，告诉Jasmine，以`spec.js`或`Spec.js`结尾的文件必须被视为测试脚本，并且必须被处理。
- en: 'To validate that everything is configured correctly, execute the following
    command in the root `practice-jasmine` directory:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切配置正确，在`practice-jasmine`根目录中执行以下命令：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should see the message `No specs found` displayed which means that as we
    didn't write any test yet, Jasmine was not able to process any test case. Also,
    you can see how much time Jasmine takes to execute your tests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到显示消息`No specs found`，这意味着因为我们还没有编写任何测试，Jasmine无法处理任何测试用例。此外，你还可以看到Jasmine执行你的测试所需的时间。
- en: Test suites
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试套件
- en: Following the best practices, you have to separate your tests that are similar
    to be grouped in suites. For example, in our application, we will write code to
    manage football matches and information about teams. Both matches and teams are
    different domains and for that reason, we should group the tests related to the
    matches in a suite and repeat the same for teams.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循最佳实践，你必须将相似的可分组测试分开。例如，在我们的应用程序中，我们将编写代码来管理足球比赛和球队信息。比赛和球队是不同的领域，因此，我们应该将相关的比赛测试分组在一个套件中，并为球队重复同样的操作。
- en: 'Following the example where we created an `add` function, we might be implementing
    this function for a Calculator application, so let''s use this as an example to
    understand Jasmine. In the `specs` folder, create the `calculator.spec.js` file
    and write the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了`add`函数的示例之后，我们可能正在为计算器应用程序实现这个函数，所以让我们以此为例来理解Jasmine。在`specs`文件夹中创建`calculator.spec.js`文件，并编写以下代码：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have created our test suite; for that, we are using the `describe` function
    and we pass the name of our suite as the first parameter, in this case `Calculator`,
    and as the second parameter, we pass a function that will contain the code for
    our test cases.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了测试套件；为此，我们使用了`describe`函数，并将套件名称作为第一个参数传递，在这个例子中是`Calculator`，作为第二个参数，我们传递一个函数，该函数将包含我们的测试用例代码。
- en: Test cases
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例
- en: 'To write the test for our applications, we need test cases that should basically
    consider all the possible scenarios that your app can afford. For our Calculator
    example, we will create test cases for the four main arithmetic operations—addition,
    multiplication, subtraction, and division. Test cases are created using the `it`
    function, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写我们应用程序的测试，我们需要考虑所有可能场景的测试用例。对于我们的计算器示例，我们将为四个主要算术运算——加法、乘法、减法和除法创建测试用例。测试用例是通过`it`函数创建的，如下所示：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before we continue on our trip, we should have something to test. So let''s
    create a `Calculator` object to test out. In the same `calculator.spec.js` file,
    add the following code at the very beginning, before the suite declaration, as
    follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续我们的旅程之前，我们应该有一些可以测试的内容。所以让我们创建一个`Calculator`对象来测试。在同一个`calculator.spec.js`文件中，在套件声明之前，添加以下代码，如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have something to test, let's learn about how we can write assertions
    in our test file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以测试的内容，让我们了解一下如何在测试文件中编写断言。
- en: Expects
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期望
- en: 'We test the functionality of our code by writing expects that are no more than
    simple assumptions that we have for our code if everything was implemented correctly.
    In the file we are working on, apply the following changes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过编写期望来测试我们代码的功能，这些期望不会超过我们对代码的正确实现所持有的简单假设。在我们正在工作的文件中，应用以下更改：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have created the expectations that we have for our code. For example, for
    the additional test case, we expect that the result of `add(1, 2)` returns `3`.
    We specify the match operation using helper functions, such as the `toEqual` function,
    that as its name says, won't raise any exception in case the result of calling
    the add function is the same as the expected value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们对代码的期望。例如，对于加法测试用例，我们期望`add(1, 2)`的结果返回`3`。我们使用辅助函数指定匹配操作，例如`toEqual`函数，正如其名称所示，如果调用加法函数的结果与期望值相同，则不会抛出任何异常。
- en: 'Now that we have our test script fully implemented, let''s execute it and see
    what we get in the console. Run the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全实现了测试脚本，让我们执行它并看看控制台会显示什么。运行以下命令：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now the output displayed is that `4 specs` were found and executed without
    failures. It is time to see what will happen if we force a test case to fail.
    Replace the expect statement in the addition test case for the following expects:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显示的输出是找到了`4 specs`并成功执行，没有失败。现在是时候看看如果我们强制测试用例失败会发生什么了。替换加法测试用例中的以下期望语句：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the changes are applied, run the following command to make our test fail:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用了更改，运行以下命令使我们的测试失败：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's analyze the output. The first thing to note is the following `F...` string,
    this means that the first test has failed and the other 3 (dots) are correct.
    You can also read the `Expected 3 to equal 30` message giving the reason why our
    test fails, and finally the test resume that shows that `4 specs` where found
    but just `1 failure` occurred.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析输出。首先要注意的是以下 `F...` 字符串，这意味着第一个测试失败了，其他 3 个（点）是正确的。你也可以阅读 `Expected 3 to
    equal 30` 的消息，了解我们的测试失败的原因，最后是测试摘要，显示找到了 `4 个规范` 但只发生了 `1 个失败`。
- en: The output for this test displays the failing test at the beginning of the `F...`
    string. This might be at the beginning or in another order. That is because the
    random property in the `jasmine.json` file is configured to be true, which means
    random executions. If you want to execute your tests sequentially, change the
    random property to false.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的输出显示在 `F...` 字符串的开头失败的测试。这可能是开始或另一个顺序。这是因为 `jasmine.json` 文件中的随机属性被配置为
    true，这意味着随机执行。如果你想要顺序执行你的测试，将随机属性更改为 false。
- en: You have seen how easy it is to use the Jasmine framework to test our code.
    Of course, you have to learn more about it; we would really like to teach you
    everything about Jasmine, but that is beyond the scope of this book. We recommend
    you visit the official site at [https://jasmine.github.io/](https://jasmine.github.io/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了使用 Jasmine 框架测试我们的代码是多么容易。当然，你必须更多地了解它；我们真的想教你关于 Jasmine 的所有内容，但这超出了本书的范围。我们建议你访问官方网站
    [https://jasmine.github.io/](https://jasmine.github.io/)。
- en: Learning KarmaJS
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 KarmaJS
- en: We have explored Jasmine, which basically is a testing framework powered with
    a cool syntax and functions that help us write the test scripts for our application;
    in order to execute our test, we had to execute them manually and wait until this
    finished to see how many tests passed and how many failed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了 Jasmine，它基本上是一个由酷炫的语法和函数支持的测试框架，帮助我们编写应用程序的测试脚本；为了执行我们的测试，我们必须手动执行它们并等待直到完成，才能看到有多少测试通过，有多少测试失败。
- en: Karma is a test runner. A test runner is a tool that is configured to look for
    the test scripts of our application, execute the tests automatically, and export
    the result of our testing. As we are creating web components with Aurelia, we
    will need to test our application in different browsers with different characteristics,
    and as web browsers are different in many ways, we need a way to test our web
    application in all possible browsers to ensure that our users won't face any problem
    with our app.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 是一个测试运行器。测试运行器是一个配置为查找我们的应用程序测试脚本、自动执行测试并导出测试结果的工具。因为我们正在使用 Aurelia 创建
    Web 组件，我们需要在不同的浏览器中测试我们的应用程序，不同的浏览器有不同的特性，而由于 Web 浏览器在许多方面都不同，我们需要一种方法来测试我们的 Web
    应用程序在所有可能的浏览器中，以确保我们的用户不会遇到任何与我们的应用程序相关的问题。
- en: 'Karma is able to use any testing framework to implement tests. As we have learned
    Jasmine, we will be using it to write our test scripts, and we will be using Karma
    to pick up the test files, execute them, and export the results. The following
    illustrates the flow:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 能够使用任何测试框架来实施测试。因为我们已经学习了 Jasmine，我们将使用它来编写我们的测试脚本，并且我们将使用 Karma 来拾取测试文件，执行它们，并导出结果。以下展示了流程：
- en: '![](img/3bcb21ff-e054-48b5-baa5-d1ff436bb484.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bcb21ff-e054-48b5-baa5-d1ff436bb484.png)'
- en: We will see the power of KarmaJS later in this chapter; just keep in mind that
    Aurelia uses Karma as its test runner for all the projects that you create using
    the Aurelia CLI, as discussed in Chapter 1, *Introducing Aurelia.*
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到 KarmaJS 的强大功能；只需记住，Aurelia 使用 Karma 作为其测试运行器，用于所有使用 Aurelia CLI 创建的项目，正如第
    1 章 *介绍 Aurelia* 中讨论的那样。
- en: Installing karma
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 karma
- en: 'We will use the NPM to install Karma and other dependencies. Let''s start creating
    a practice folder called `practice-karma` and initializing our project. Run the
    following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 NPM 安装 Karma 和其他依赖项。让我们开始创建一个名为 `practice-karma` 的练习文件夹并初始化我们的项目。运行以下命令：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We use `npm init` to create a new module; this will prompt you a bunch of questions
    and will create a `package.json` file similar to this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `npm init` 来创建一个新的模块；这将提示你一系列问题，并创建一个类似于以下的 `package.json` 文件：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Up to now, you should have the following folder structure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该有以下的文件夹结构：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now it''s time to install Karma and the dependencies that we require to use
    Karma and Jasmine. In the `practice-karma` folder, run the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候安装 Karma 和我们使用 Karma 和 Jasmine 所需的依赖项了。在 `practice-karma` 文件夹中，运行以下命令：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding command will install the dependencies required to use Karma and
    Jasmine, and also will add the dependencies to our `package.json` file into the
    `devDependencies` attribute. Open your `package.json` file, and you should see
    something similar to this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将安装使用 Karma 和 Jasmine 所需的依赖项，并将依赖项添加到我们的 `package.json` 文件中的 `devDependencies`
    属性。打开您的 `package.json` 文件，您应该看到类似以下的内容：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we have to use the `--save-dev` flag, the dependencies are listed in the
    `devDependencies` attribute; if you use `--save` instead, it will list the dependencies
    in the `dependencies` attribute.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须使用 `--save-dev` 标志，所以依赖项列在 `devDependencies` 属性中；如果您使用 `--save` 代替，它将在
    `dependencies` 属性中列出依赖项。
- en: Configuring Karma
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Karma 配置
- en: 'Now that Karma is installed, we need to configure the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Karma已经安装，我们需要配置以下内容：
- en: Jasmine as testing tool
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine 作为测试工具
- en: Folders with the app code
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含应用代码的文件夹
- en: Web browser launcher
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络浏览器启动器
- en: Reporters
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告器
- en: 'Setting up all the preceding parameters might result in a very time-consuming
    task, so we will use the Karma executable to configure everything automatically.
    In the `practice-karma` folder, run the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 设置所有前面的参数可能是一个非常耗时的工作，因此我们将使用 Karma 可执行文件来自动配置一切。在 `practice-karma` 文件夹中，运行以下命令：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will prompt you a bunch of questions; just press enter to accept all the
    default configuration, and once everything is done, a `karma.conf.js` file will
    be created:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示您一系列问题；只需按回车键接受所有默认配置，一旦完成所有操作，就会创建一个 `karma.conf.js` 文件：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need to specify a pattern for the files to be utilized in the testing process.
    To do this, apply the following changes to the `files: []` property:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要指定用于测试过程中要使用的文件的模式。为此，将以下更改应用到 `files: []` 属性：'
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we have specified that every file that ends with `.spec.js` in its name
    will be processed by karma. Let''s create the `specs` folder and inside, create
    the `calculator.spec.js` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了所有以 `.spec.js` 结尾的文件都将由 karma 处理。让我们创建一个 `specs` 文件夹，并在其中创建一个 `calculator.spec.js`
    文件：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should have a project structure similar to the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目结构应该类似于以下内容：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now it's time to test things out by creating a testing example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过创建一个测试示例来测试一下了。
- en: Testing example
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试示例
- en: 'For the Calculator app example, let''s create the *src* folder in the root
    project''s folder and create the `calculator.js` file inside:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Calculator 应用程序示例，让我们在根项目文件夹中创建一个 `src` 文件夹，并在其中创建 `calculator.js` 文件：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, we are not saving our `calculator.js` file inside the `specs/`
    folder, so we need to configure karma to load the files present in the `src/`
    folder. Apply the following changes in the `karma.conf.js` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们没有在 `specs/` 文件夹中保存 `calculator.js` 文件，因此我们需要配置 karma 来加载 `src/` 文件夹中的文件。在
    `karma.conf.js` 文件中应用以下更改：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, Karma will load all the files from the `specs` and `src` folder when testing
    is running.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Karma 将在测试运行时加载 `specs` 和 `src` 文件夹中的所有文件。
- en: 'Let''s implement the code of our `calculator.js` file. Using your editor of
    choice, open the `src/calculator.js` file and apply the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现 `calculator.js` 文件的代码。使用您选择的编辑器打开 `src/calculator.js` 文件，并应用以下代码：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you want to make a variable accessible globally, simply create it as a property
    of the window object. In this case, we made the `Calculator` object **global**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使一个变量在全局范围内可访问，只需将其创建为 window 对象的一个属性。在这种情况下，我们使 `Calculator` 对象 **全局化**。
- en: 'Now, let''s write our test case. Open the `specs/calculator.spec.js` file and
    apply the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写我们的测试用例。打开 `specs/calculator.spec.js` 文件，并应用以下代码：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code should be familiar to you if you note that we are using the
    Jasmine testing framework to write our tests. Now that we have everything set
    up and our code implemented, let's continue by launching the tests.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到我们正在使用 Jasmine 测试框架来编写测试，那么前面的代码应该对您来说很熟悉。现在我们已经设置好一切并实现了代码，让我们继续通过启动测试来继续操作。
- en: Launching the test runner
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动测试运行器
- en: 'Now that we have our test code and a Calculator object, it''s time to launch
    Karma to execute our test. Open the command line and in the `practice-karma` root
    folder, execute the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了测试代码和 Calculator 对象，是时候启动 Karma 来执行我们的测试了。打开命令行，在 `practice-karma` 根目录下，执行以下命令：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding command will output a bunch of logs, while it opens a new window
    in your Chrome web browser and executes your test into the web page recently started.
    This page is opened in Chrome because it is configured in the `karma.conf.js`.
    Consider this example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将输出大量日志，同时在你的 Chrome 浏览器中打开一个新窗口并执行最近启动的网页中的测试。这个页面是在 Chrome 中打开的，因为它在
    `karma.conf.js` 中进行了配置。考虑以下示例：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note in the last lines that our test was executed with a successful result.
    The web page launched looks similar to this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到最后几行，我们的测试以成功的结果执行。启动的网页看起来类似于以下：
- en: '![](img/5f11a98a-d0c2-4882-b77e-181eae459390.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f11a98a-d0c2-4882-b77e-181eae459390.png)'
- en: 'As you might have noted, running the previous command might be too long to
    remember; to make our life easy, let''s configure our `package.json` file to configure
    the `test` script to execute this command for us. Open the `package.json` files
    and apply the following changes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，运行前面的命令可能太长而难以记住；为了使我们的生活更简单，让我们配置 `package.json` 文件以配置 `test` 脚本来为我们执行此命令。打开
    `package.json` 文件并应用以下更改：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once configured, execute the following command to run the tests:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，执行以下命令以运行测试：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That's it. Using Karma and Jasmine will give us all the enablers we need to
    write robust tests for our applications. Both technologies are not limited to
    web development. You can use them in any Javascript project such as a backend
    written in Node.js. So now, it's time to see an example with a real Aurelia component.
    Keep reading!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。使用 Karma 和 Jasmine 将为我们提供编写稳健测试所需的所有工具，这两种技术不仅限于 Web 开发。你可以在任何 JavaScript
    项目中使用它们，例如用 Node.js 编写的后端。因此，现在是时候看看一个真实的 Aurelia 组件的例子了。继续阅读！
- en: Testing an Aurelia component
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Aurelia 组件
- en: 'In order to see a real testing example, we will create a simple application.
    This app will merely greet a user and display the topic currently learning. These
    two pieces of data, the username and topic, will be persisted as bindable entities
    and we will call this component `info-box`. We will develop an application similar
    to the following mock-up:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到真实的测试示例，我们将创建一个简单的应用程序。这个应用程序将仅仅问候用户并显示当前正在学习的话题。这两项数据，用户名和话题，将被持久化为可绑定实体，我们将称这个组件为
    `info-box`。我们将开发一个类似于以下模拟的应用程序：
- en: '![](img/9d76e6c9-ce5f-4a8e-9f7e-d51e7e75141f.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d76e6c9-ce5f-4a8e-9f7e-d51e7e75141f.png)'
- en: Coding the application
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码应用程序
- en: We will use the Aurelia CLI to generate our Aurelia application. Aurelia configures
    the project to work with the Karma test runner and the Jasmine testing framework
    and uses Chrome as the default web browser.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Aurelia CLI 生成我们的 Aurelia 应用程序。Aurelia 配置项目以与 Karma 测试运行器和 Jasmine 测试框架一起工作，并使用
    Chrome 作为默认的 Web 浏览器。
- en: Creating the application
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: 'To create our application, open your Terminal and in the working directory
    you prefer, run the following command and accept the defaults:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的应用程序，打开你的终端，在首选的工作目录中运行以下命令并接受默认设置：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding command will create a new directory called `aurelia-testapp`;
    let''s get into this folder and launch the application by running the following
    command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将创建一个名为 `aurelia-testapp` 的新目录；让我们进入这个文件夹，通过运行以下命令启动应用程序：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding command will output a bunch of logs while the development server
    is starting and Aurelia is getting started. Head over to `http://localhost:9000`;
    and you should see something similar to the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将在开发服务器启动和 Aurelia 启动时输出大量日志。转到 `http://localhost:9000`；你应该会看到以下类似的内容：
- en: '![](img/1c624d46-6a5f-40c0-a41c-6547476a532a.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c624d46-6a5f-40c0-a41c-6547476a532a.png)'
- en: Creating our component
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的组件
- en: 'To create our `info-box` component, we will use the Aurelia CLI. Stop the running
    application and execute the following command. This will ask you for the destination
    folder; press *Enter* to use `src` as default:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的 `info-box` 组件，我们将使用 Aurelia CLI。停止运行中的应用程序并执行以下命令。这将要求你输入目标文件夹；按 *Enter*
    使用 `src` 作为默认值：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This command will create two files that together define the `info-box` component;
    these files are as listed:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建两个文件，这两个文件共同定义了 `info-box` 组件；这些文件如下所示：
- en: '`info-box.js`: Contains the component''s view model'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info-box.js`：包含组件的视图模型'
- en: '`info-box.html`: Contains the HTML view template'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info-box.html`：包含 HTML 视图模板'
- en: Let's implement our `info-box` component.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现我们的 `info-box` 组件。
- en: Implementing the info-box view model
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 info-box 视图模型
- en: 'Open the `info-box.js` file and apply the following changes to declare the
    `username` and `topic` attributes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `info-box.js` 文件并应用以下更改以声明 `username` 和 `topic` 属性：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Implementing the info-box view HTML template
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现信息框视图HTML模板
- en: 'Open the `info-box.js` file and apply the following changes to bind our attributes
    to the HTML template:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`info-box.js`文件，并应用以下更改以将属性绑定到HTML模板：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Rendering the info-box component
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染信息框组件
- en: 'To load and render our component, we need to import the component into the
    app component. Open the `app.html` file and apply the following changes:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载和渲染我们的组件，我们需要将其导入到应用程序组件中。打开`app.html`文件，并应用以下更改：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'First, we import the `info-box` component and then use it using the `<info-box>` tag
    syntax. With changes done, launch the application again by running the `au run
    --watch` command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`info-box`组件，然后使用`<info-box>`标签语法使用它。完成更改后，通过运行`au run --watch`命令再次启动应用程序：
- en: '![](img/8a10e764-5b92-4b56-a943-30f0ab9dc317.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a10e764-5b92-4b56-a943-30f0ab9dc317.png)'
- en: Writing the test
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: 'Before we start writing our test, let''s clean up the `test` folder by removing
    the `app.spec.js` file in the `unit` folder. Once completed, you should have something
    similar to folder tree:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写测试之前，让我们清理`test`文件夹，通过从`unit`文件夹中删除`app.spec.js`文件。完成后，你应该有一个类似的文件夹结构：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `unit` folder, create the `info-box.spec.js` file and add the following
    code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`unit`文件夹中创建`info-box.spec.js`文件，并添加以下代码：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, we import two objects from the Aurelia framework that we will use to
    initialize our `info-box` component. Then, we declare our `Info-Box` test suite
    and we declare one test case.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从Aurelia框架导入两个我们将用于初始化`info-box`组件的对象。然后，我们声明我们的`Info-Box`测试套件，并声明一个测试用例。
- en: 'Note that we are using a special syntax; instead of using `function() {}`,
    we are using `() => {}` ECMAScript syntax. To unit test our component, we will
    need to perform the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的是特殊语法；我们使用`() => {}` ECMAScript语法，而不是`function() {}`。为了对组件进行单元测试，我们需要执行以下步骤：
- en: Bootstrap the component
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入组件
- en: Test the component
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试组件
- en: Bootstrapping the component
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入组件
- en: 'We will need to create the component so that Jasmine will use it to apply the
    test. Apply the following changes in the `info-box.spec.js` file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建组件，以便Jasmine可以使用它来应用测试。在`info-box.spec.js`文件中应用以下更改：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Before we bootstrap the component, it has to be created. We use the `StageComponent`
    object to instantiate an Aurelia component; we specify the component by passing
    its name as a param of the `withResources` function. Lastly, we specify a view
    using the `<info-box>` element in the `inView` function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们引入组件之前，必须先创建它。我们使用`StageComponent`对象来实例化一个Aurelia组件；通过将组件名称作为`withResources`函数的参数来指定组件。最后，在`inView`函数中使用`<info-box>`元素来指定一个视图。
- en: Once we have the component skeleton defined, we call its `create` function and
    pass the `bootstrap` object. The `bootstrap` object contains the default configuration
    specified in the `main.js` file, as discussed in Chapter 1*, Introducing Aurelia.*
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了组件的骨架，我们就调用它的`create`函数并传递`bootstrap`对象。`bootstrap`对象包含在第一章“介绍Aurelia”中讨论的`main.js`文件中指定的默认配置。
- en: Testing the component
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件
- en: 'Now that we have our component created, we need to test it. To do this, we
    rely on the done callback passed to the test function to notify Jasmine that the
    test is done. If we don''t specify the done parameter, our test won''t be executed
    because we execute our assertions in a promise and if we don''t call it, we will
    get a timeout error since Jasmine won''t be able to know when our test completed.
    Let''s apply the following changes to the `info-box.spec.js` file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了组件，我们需要对其进行测试。为此，我们依赖于传递给测试函数的`done`回调，以通知Jasmine测试已完成。如果我们不指定`done`参数，我们的测试将不会执行，因为我们在一个承诺中执行断言，如果我们不调用它，我们将得到超时错误，因为Jasmine将无法知道我们的测试何时完成。让我们对`info-box.spec.js`文件应用以下更改：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You should be aware that if you are using Webpack, you might need to import
    `PLATFORM` from the `aurelia-pal` module in order to load the `info-box` resource
    as follows—`.withResourceS(PLATFORM.moduleName('info-box'))`. For additional Webpack
    considerations, visit the official site at [https://aurelia.io/docs/build-systems/webpack](https://aurelia.io/docs/build-systems/webpack).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，如果你使用Webpack，你可能需要从`aurelia-pal`模块中导入`PLATFORM`，以便按如下方式加载`info-box`资源——`.withResourceS(PLATFORM.moduleName('info-box'))`。有关Webpack的更多考虑，请访问官方网站[https://aurelia.io/docs/build-systems/webpack](https://aurelia.io/docs/build-systems/webpack)。
- en: In the `then` function, we pass our callback that will use the `component.element.querySelector`
    function to access the HTML elements into the `info-box` component, and we use
    the `innerHTML` property of the elements to access the element's values.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `then` 函数中，我们将使用 `component.element.querySelector` 函数访问 HTML 元素的回调传递给 `info-box`
    组件，并使用元素的 `innerHTML` 属性来访问元素的值。
- en: Next, we compare the values of the elements by the expected values and when
    all the `expect` statements are executed, we call the `done()` function to tell
    Jasmine we have finished this test case.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过预期值比较元素的值，当所有 `expect` 语句执行完毕后，我们调用 `done()` 函数来告诉 Jasmine 我们已经完成了这个测试用例。
- en: 'Lastly, a `catch` callback is passed to print any error detected in the test
    process. Once everything is complete, run the following command in your Terminal:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个 `catch` 回调被传递以打印测试过程中检测到的任何错误。一旦一切完成，请在您的终端中运行以下命令：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If everything went right, the Chrome web browser should be opened and you should
    see the following output in your Terminal window:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，Chrome 网络浏览器应该已经打开，您应该在终端窗口中看到以下输出：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That's it! Now you know how to test Aurelia components. A little challenge for
    you is to apply everything learned in a TDD cycle. Have fun!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！现在您已经知道如何测试 Aurelia 组件了。一个小挑战是，在 TDD 循环中应用所学的所有内容。祝您玩得开心！
- en: Debugging our code
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试我们的代码
- en: Debugging tools are extremely important for a developer. It does not matter
    which programming language or framework you are using, or if you are working on
    either frontend or backend project. Debugging will always be present in your development
    process.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 调试工具对于开发者来说至关重要。无论您使用的是哪种编程语言或框架，或者您是在前端还是后端项目中工作，调试都将始终存在于您的开发过程中。
- en: Nowadays, the web browser does more than just server pages, caching content,
    saving favorites, and so on. They are complete web development tools that provide
    awesome tools to debug our code and application performance.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，网络浏览器不仅仅只是服务器页面、缓存内容、保存收藏夹等等。它们是完整的网络开发工具，提供了调试我们的代码和应用程序性能的强大工具。
- en: Let's see how we can debug our code using our favorite web browser. We will
    use Chrome Developer Tools as an example.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用我们最喜欢的网络浏览器来调试我们的代码。我们将以 Chrome 开发者工具为例。
- en: Refactoring our application
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构我们的应用程序
- en: First, we need to start our application and open it in a web browser. Let's
    use our `aurelia-testapp`*:*
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要启动我们的应用程序并在网络浏览器中打开它。让我们使用我们的 `aurelia-testapp`*：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With the application up and running, head over to `http://localhost:9000` to
    see the application. We will add a button and when the button is pressed, we will
    debug some dummy code. Open the `info-box.html` file and apply the following change:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行起来后，转到 `http://localhost:9000` 来查看应用程序。我们将添加一个按钮，当按钮被按下时，我们将调试一些示例代码。打开
    `info-box.html` 文件并应用以下更改：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Open the `info-box.js` file and apply the following changes:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `info-box.js` 文件并应用以下更改：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Go back to your browser application, click on the Debug Me! button, and you
    should see the following on the screen:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 返回您的浏览器应用程序，点击 Debug Me! 按钮，您应该在屏幕上看到以下内容：
- en: '![](img/d5b52c1a-fb65-40fc-bc2b-35efb26d58cc.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5b52c1a-fb65-40fc-bc2b-35efb26d58cc.png)'
- en: Debugging with Chrome Developer Tools
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Chrome 开发者工具进行调试
- en: 'We need to open the Chrome Developer Tools. To do this, go to the View | Developer
    | Developer tools option in the menu or press *F12*. You should see something
    like the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要打开 Chrome 开发者工具。为此，请转到菜单中的视图 | 开发者 | 开发者工具选项，或者按 *F12*。您应该看到如下内容：
- en: '![](img/67c2e18e-3cbd-47ca-b209-95e9c395d23e.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67c2e18e-3cbd-47ca-b209-95e9c395d23e.png)'
- en: 'With this window open, let''s apply a little change to our `info-box` file
    to tell the browser that we want to stop and debug our code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在此窗口打开的情况下，让我们对我们的 `info-box` 文件进行一些更改，以告诉浏览器我们想要停止并调试我们的代码：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Go back to your application and click on the Debug Me! button. The `debugger;`
    instruction will stop the browser execution and enter into the browser debugging
    mode:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 返回您的应用程序并点击 Debug Me! 按钮。`debugger;` 指令将停止浏览器执行并进入浏览器调试模式：
- en: '![](img/59055109-a3b2-41c2-8af5-51fe53f119e6.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59055109-a3b2-41c2-8af5-51fe53f119e6.png)'
- en: You can use the Developer Tools options to navigate your code, analyze variables
    values, add breakpoints, and so on. I personally prefer to debug my code in this
    way. You can try debugging code using the Node.js command line or another type
    of debugging. Debugging tools will vary depending on the web browser you are working
    on.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用开发者工具选项来导航您的代码，分析变量值，添加断点等。我个人更喜欢以这种方式调试我的代码。您可以使用Node.js命令行或其他类型的调试来尝试调试代码。调试工具将根据您正在工作的浏览器而有所不同。
- en: Now that we are in good shape and we know how to style and test Aurelia applications,
    it's time to learn how to create awesome Aurelia components. Keep reading!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了准备，并且知道如何样式化和测试Aurelia应用程序，是时候学习如何创建出色的Aurelia组件了。继续阅读！
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the benefits that good testing brings to our company,
    team, products, and users. Good testing will always make our products better and
    our users happy.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了良好的测试给我们的公司、团队、产品和用户带来的好处。良好的测试将始终使我们的产品更好，让我们的用户更满意。
- en: 'We learned how to apply TDD to our software development process and the importance
    and impact it has on the quality of our apps. You should always remember that
    TDD is composed of three colored phases: the red phase, which makes your test
    fail; the blue phase, which makes your test pass; and lastly, the green phase,
    which refactors and cleans your code.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何将TDD应用到我们的软件开发过程中，以及它对我们应用程序质量的重要性和影响。您应该始终记住，TDD由三个彩色阶段组成：红色阶段，使您的测试失败；蓝色阶段，使您的测试通过；最后是绿色阶段，重构和清理您的代码。
- en: We also learned about the testing technologies that Aurelia uses for development
    and learned how to use them independently. Jasmine is the testing framework and
    Karma is used as the test runner.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了Aurelia用于开发的测试技术，并学习了如何独立使用它们。Jasmine是测试框架，Karma用作测试运行器。
- en: We practiced with a real testing example of an Aurelia component and we explored
    some debugging options.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Aurelia组件的真实测试示例进行了练习，并探索了一些调试选项。
- en: Now that we are in good shape and know how to style and test Aurelia applications,
    it's time to become real experts in creating Aurelia components. So, keep reading!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了准备，并且知道如何样式化和测试Aurelia应用程序，是时候成为创建Aurelia组件的真正专家了。所以，继续阅读！
