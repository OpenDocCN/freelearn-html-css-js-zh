- en: Chapter 6. Hacker News API on Koa.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：Koa.js上的Hacker News API
- en: In this chapter, we will build an API to power our own Hacker News! While technically
    this wouldn't be very different from the previous chapters, we will use a different
    framework altogether, Koa.js ([http://koajs.com/](http://koajs.com/)).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个API来为我们的Hacker News提供动力！虽然从技术上讲，这与前几章不会有很大不同，但我们将使用完全不同的框架，即Koa.js
    ([http://koajs.com/](http://koajs.com/))。
- en: Koa.js is a new web framework designed by the team behind Express. Why did they
    create a new framework? Because it is designed from the bottom up, with a minimalistic
    core for more modularity, and to make use of the new generator syntax, proposed
    in ECMAScript 6, but already implemented in node 0.11.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Koa.js是由Express背后的团队设计的新型Web框架。他们为什么创建一个新的框架？因为它是从底层设计的，具有最小化的核心以实现更多模块化，并利用ECMAScript
    6中提出的新的生成器语法，尽管它已经在node 0.11中实现。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The odd version releases of node are considered unstable. At the time of writing,
    the latest stable release was version 0.10\. However, when this book went to print,
    node 0.12 was finally released and is the latest stable version.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的不规则版本被认为是不可稳定的。在撰写本文时，最新的稳定版本是0.10版本。然而，当这本书付印时，node 0.12终于发布，是当时的最新稳定版本。
- en: An alternative to node 0.11 would be io.js, which at the time of writing reached
    version 1.0, and also implements ES6 goodies (forked from Node.js and maintained
    by a handful of node core contributors). In this chapter, we will stick to node
    0.11\. (When this book went to print, node 0.12 was finally released and is the
    latest stable version of node.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: node 0.11的一个替代方案是io.js，在撰写本文时达到了1.0版本，并实现了ES6的特性（从Node.js分叉并由少数几个node核心贡献者维护）。在本章中，我们将坚持使用node
    0.11。（当这本书付印时，node 0.12最终发布，是当时的最新稳定版本。）
- en: One of the main benefits of the generator syntax is that you can very elegantly
    avoid callback hell, without the use of complicated promise patterns. You can
    write your APIs even more cleanly than ever before. We'll go over the subtleties
    as well as some caveats that come with the bleeding edge.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器语法的主要好处之一是您可以非常优雅地避免回调地狱，而无需使用复杂的promise模式。您甚至可以比以前更干净地编写您的API。我们将讨论一些细微差别以及一些与尖端技术相关的注意事项。
- en: 'Some things we will cover in this chapter are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Generator syntax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器语法
- en: Middleware philosophy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件哲学
- en: Context, versus req,res
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文，与req,res对比
- en: Centralized error handling
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中错误处理
- en: Mongoose models in Koa.js
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Koa.js中的Mongoose模型
- en: Thunkify to use Express modules
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Thunkify来使用Express模块
- en: Testing generator functions with Mocha
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mocha测试生成器函数
- en: Parallel HTTP requests using co-mocha
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用co-mocha进行并行HTTP请求
- en: Rendering views with koa-render
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用koa-render渲染视图
- en: Serve static assets with koa-mount and koa-static
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用koa-mount和koa-static提供静态资源
- en: Generator syntax
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器语法
- en: Generator functions are at the core of Koa.js, so let's dive right into dissecting
    this beast. Generators allow adept JavaScript users to implement functions in
    completely new ways. Koa.js makes use of the new syntax to write code in a synchronous-looking
    fashion while maintaining the performance benefits of an asynchronous flow.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数是Koa.js的核心，所以让我们直接深入剖析这个怪物。生成器允许熟练的JavaScript用户以全新的方式实现函数。Koa.js利用新的语法以同步的方式编写代码，同时保持异步流程的性能优势。
- en: 'The following defines a simple generator function in `src/helloGenerator.js`
    (note the asterisk syntax):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义了一个简单的生成器函数`src/helloGenerator.js`（注意星号语法）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To use Mocha with Koa.js:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Koa.js中使用Mocha：
- en: 'You will need to include `co-mocha` to add generator support, requiring once
    at the first line of each test file is the safe way to do it. Now you can pass
    generator functions to Mocha''s `it` function as follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要包含`co-mocha`以添加生成器支持，在测试文件的第一个行引入它是安全的方式。现在您可以将生成器函数传递给Mocha的`it`函数，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to run this code, you will need to have node 0.11 installed, and use
    the `--harmony-generators` flag as you run Mocha:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行此代码，您需要安装node 0.11版本，并在运行Mocha时使用`--harmony-generators`标志：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If all is well, congratulations, you have just written your first generator
    function! Now let's explore the execution flow of generator functions a little
    more.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，恭喜您，您刚刚编写了您的第一个生成器函数！现在让我们更深入地探索生成器函数的执行流程。
- en: Note
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the magic use of the `yield` keyword. The `yield` keyword can only be used
    within a `Generator` function, and works somewhat similar to `return`, expecting
    a single value to be passed, that can also be a generator function (also accepts
    other yieldables—more on that later), and yields the process to that function.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`yield`关键字的神奇用法。`yield`关键字只能在`Generator`函数中使用，其工作方式与`return`类似，期望传递一个值，这个值也可以是一个生成器函数（也接受其他可`yield`的对象——稍后详细介绍），并将流程传递给该函数。
- en: 'When a `function*` is passed, the execution flow will wait until that function
    returns before it continues further down. In essence, it would be equivalent to
    the following callback pattern:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当传递一个`function*`时，执行流程将等待该函数返回后才继续向下执行。本质上，它等同于以下回调模式：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Much cleaner, right? Compare the following code:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更干净，对吧？比较以下代码：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the nasty callback hello if we didn''t have generator functions:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有生成器函数，会有一个讨厌的回调hello：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Another neat advantage is super clean error handling, which we will get into
    later.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个很酷的优势是超级干净的错误处理，我们稍后会详细介绍。
- en: The preceding example is not too interesting because the `helloGenerator()`
    function is a synchronous function anyway, so it would've worked the same, even
    if we didn't use generator functions!
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的例子不太有趣，因为`helloGenerator()`函数本质上是一个同步函数，所以即使我们没有使用生成器函数，它也会以相同的方式工作！
- en: 'So let''s make it more interesting and change `helloGenerator.js` to the following:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们让它更有趣一些，将`helloGenerator.js`改为以下内容：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Wait! Your test is failing?! What is going on here? Well, `yield` should have
    given the flow to the `helloGenerator()` function, let it run asynchronously,
    and wait until it is done before continuing. Yet, `ans` is undefined. And nobody
    is lying.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等等！你的测试失败了？！这里发生了什么？嗯，`yield`应该将流程交给`helloGenerator()`函数，让它异步运行，并在完成后再继续。然而，`ans`是未定义的。没有人撒谎。
- en: The reason why it is undefined is because the `generator()` function returns
    immediately after calling the `setTimeout` function, which is set to `ans`. The
    message that should have returned from within the `setTimeout` function is broadcast
    into the infinite void, nowhere to be seen, ever again.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它之所以是未定义的，是因为`generator()`函数在调用`setTimeout`函数后立即返回，该函数被设置为`ans`。本应从`setTimeout`函数内部返回的消息被广播到无尽的虚空，从此再也无处可见。
- en: Note
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One thing to keep in mind with generator functions is that once you use a generator
    function, you better commit, and not resort to callbacks down the stack! Recall
    that we mentioned that `yield` expects a generator function. The `setTimeout`
    function is not a generator function, so what do we do? The `yield` method can
    also accept a Promise or a Thunk (more on this later).
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在生成器函数方面，有一点需要注意，一旦你使用了生成器函数，你最好坚持使用，不要在调用栈中回退到回调！回想一下，我们提到`yield`期望一个生成器函数。`setTimeout`函数不是一个生成器函数，所以我们怎么办？`yield`方法也可以接受一个Promise或Thunk（稍后详细介绍）。
- en: 'The `setTimeout()` function isn''t a Promise, so we have two options left;
    we can thunkify the function, which basically takes a normal node function with
    a callback pattern and returns a Thunk, so we can yield to it; alternatively,
    we use co-sleep, which is basically a minuscule node package that has done it
    for you as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setTimeout()`函数不是一个Promise，所以我们还有两个选择；我们可以将函数thunkify，这基本上是将具有回调模式的普通node函数转换为一个Thunk，这样我们就可以向它yield；或者，我们可以使用co-sleep，这是一个基本的小型node包，它已经为你做了以下事情：'
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will talk about how to thunkify later, so let's use `co-sleep`. Generally
    a good idea to reuse what's available is to just do a quick search in the npm
    registry. There are numerous `co` packages out there!
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论如何实现thunkify，所以让我们先使用`co-sleep`。通常，重用现有资源的一个好方法就是快速在npm注册表中搜索。那里有大量的`co`包！
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now all should be good; your tests should pass after sleeping for 1 second.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该一切正常；在休眠1秒后，你的测试应该通过。
- en: 'Note that the `co` library is what''s under the hood of Koa.js, giving it the
    generator-based control flow goodies. If you want to use this sort of flow outside
    Koa.js, you can use something like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`co`库是Koa.js底层的实现，为其提供了基于生成器的控制流特性。如果你想在Koa.js之外使用这种流程，可以使用类似以下的方法：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Middleware philosophy
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件哲学
- en: You should be familiar by now with the middlewares in Express. We used them
    a lot to dry out code, especially for validation and authentication. In Express,
    middleware is placed between the server that receives the request and the handler
    that responds to a request. The request flows one way, until it terminates at
    `res.send` or something equivalent.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉 Express 中的中间件了。我们大量使用它们来简化代码，尤其是在验证和认证方面。在 Express 中，中间件被放置在接收请求的服务器和响应请求的处理程序之间。请求单向流动，直到在
    `res.send` 或等效操作处终止。
- en: 'In Koa.js, everything is a middleware, including the handler itself. As a matter
    of fact, a Koa.js application is just an object, which contains an array of middleware
    generator functions! The request flows all the way down the stack of middlewares,
    and back up again. This is best explained with a simple example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Koa.js 中，一切都是中间件，包括处理程序本身。实际上，一个 Koa.js 应用程序只是一个对象，它包含一个中间件生成函数的数组！请求在整个中间件堆栈中流动，然后再返回。这最好用一个简单的例子来解释：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here we have a Koa.js application with two middlewares. The first middleware
    adds an `X-Response-Time` header to the response, whereas the second middleware
    simply sets the response body to `Hello` `World` for each request. The flow is
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个包含两个中间件的 Koa.js 应用程序。第一个中间件为响应添加一个 `X-Response-Time` 头部，而第二个中间件简单地为每个请求设置响应体为
    `Hello World`。流程如下：
- en: The request comes in on port `3000`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求在端口 `3000` 上到来。
- en: The first middleware receives the execution flow.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个中间件接收执行流程。
- en: A new `Date` object is created and assigned to `start`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Date` 对象并将其分配给 `start`。
- en: The flow yields to the next middleware on the stack.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量将控制权交给堆栈中的下一个中间件。
- en: The second middleware sets `body` on the Context to `Hello` `World`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个中间件将 `body` 设置为 Context 中的 `Hello World`。
- en: Since there is no more middleware down the stack to be yielding to, the flow
    returns back upstream.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有更多的中间件在堆栈中要 `yield`，流程返回上游。
- en: The first middleware receives the execution flow again and continues down.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个中间件再次接收执行流程并继续向下。
- en: The response time is calculated and the response header is set.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算响应时间并设置响应头。
- en: The request has reached the top and the Context is returned.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求已到达顶部，Context 被返回。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Koa.js does not use `req,` `res` anymore; they are encapsulated into a single
    Context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Koa.js 不再使用 `req` 和 `res`；它们被封装到一个单一的 Context 中。
- en: 'To run this app, we can use the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此应用程序，我们可以使用以下命令：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Context versus req,res
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Context 与 req,res 的比较
- en: A Koa.js Context is created for each incoming request. Within each middleware,
    you can access the Context using the `this` object. It includes the Request and
    Response object in `this.request` and `this.response`, respectively, although
    most methods and accessors are directly available from the Context.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个传入的请求创建一个 Koa.js Context。在每个中间件中，你可以使用 `this` 对象访问 Context。它包括 `this.request`
    和 `this.response` 中的请求和响应对象，尽管大多数方法和访问器都直接从 Context 中可用。
- en: The most important property is `this.body`, which sets the response body. The
    response status is automatically set to `200` when the response body is set. You
    may override this by setting `this.status` manually.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的属性是 `this.body`，它设置响应体。当设置响应体时，响应状态自动设置为 `200`。你可以通过手动设置 `this.status` 来覆盖它。
- en: Another very useful syntactic sugar is `this.throw`, which allows you to return
    an error response by simply calling `this.throw(400)`, or if you want to override
    the standard HTTP error message, you may pass a second argument with the error
    message. We will get to Koa.js slick error handling later in this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的语法糖是 `this.throw`，它允许你通过简单地调用 `this.throw(400)` 来返回错误响应，或者如果你想覆盖标准的
    HTTP 错误消息，你可以传递一个带有错误消息的第二个参数。我们将在本章后面讨论 Koa.js 的流畅错误处理。
- en: Now that we've got the basics down, let's start building a Hacker News API!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经掌握了基础知识，让我们开始构建一个 Hacker News API 吧！
- en: The link model
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接模型
- en: 'The following code describes the straightforward link document model in `src/models/links.js`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码描述了 `src/models/links.js` 中的直接链接文档模型：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that this is pretty much identical to how you would define a model in
    Express, with one exception: the `upvotes` static method. Since `findByIdAndUpdate`
    is an asynchronous I/O operation, we need to make sure that we `yield` to it,
    so as to make sure we wait for this operation to complete, before we continue
    the execution.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这基本上与你在 Express 中定义模型的方式相同，只有一个例外：`upvotes` 静态方法。由于 `findByIdAndUpdate` 是一个异步
    I/O 操作，我们需要确保我们 `yield` 到它，以确保在继续执行之前等待此操作完成。
- en: Earlier we noted that not only generator functions can be yielded to; it also
    accepts Promises, which is awesome, because they are quite ubiquitous. Using Mongoose,
    for example, we can turn Mongoose query instances into Promises by calling the
    `exec()` method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，不仅生成器函数可以被传递，它还接受 Promises，这很棒，因为它们非常普遍。例如，使用 Mongoose，我们可以通过调用 `exec()`
    方法将 Mongoose 查询实例转换为 Promises。
- en: The link routes
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接路由
- en: 'With the link model in place, let''s set up some routes in `src/routes/links.js`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好链接模型后，让我们在 `src/routes/links.js` 中设置一些路由：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This should start to look familiar. Instead of function handlers with the signature
    (`req, res`) that we are used to in Express, we simply use middleware generator
    functions and set the response body in `this.body`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该开始看起来熟悉了。我们不再使用在 Express 中我们习惯的带有 (`req, res`) 签名的函数处理器，而是简单地使用中间件生成函数，并在
    `this.body` 中设置响应体。
- en: Tying it together
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整合在一起
- en: 'Now that we have our model and routes defined perform the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的模型和路由，请执行以下步骤：
- en: 'Let''s tie it together in a Koa.js application in `src/app.js`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 Koa.js 应用程序中 `src/app.js` 中将其整合起来：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we use `koa-body-parser` to parse the request body in `this.request.body`
    and `koa-router`, which allows you to define Express style routes, the kind you
    saw earlier.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用 `koa-body-parser` 来解析请求体 `this.request.body` 和 `koa-router`，它允许您定义类似
    Express 风格的路由，就像您之前看到的那些。
- en: Next, we connect to the database, which isn't different from the previous chapters,
    so we will omit the code here.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们连接到数据库，这与前面的章节没有不同，所以我们将在这里省略代码。
- en: 'Finally, we define the Koa app, mount the middleware, and load the routes.
    Then, in the root folder, we have `/app.js` as given in the following:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义 Koa 应用程序，挂载中间件，并加载路由。然后，在根目录中，我们有 `/app.js`，如下所示：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This just loads the app and starts an HTTP server, which listens on port `3000`.
    Now to start the server, make sure you use the `--harmony-generators` flag. You
    should now have a working Koa API to power a Hacker News-like website!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是加载应用程序并启动一个监听端口 `3000` 的 HTTP 服务器。现在要启动服务器，请确保您使用 `--harmony-generators`
    标志。您现在应该有一个可以驱动类似 Hacker News 网站的 Koa API 了！
- en: Validation and error handling
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证和错误处理
- en: Error-handling is one of the fortes of Koa.js. Using generator functions we
    don't need to deal with error handling in every level of the callbacks, avoiding
    the use of (`err,` `res`) signature callbacks popularized by Node.js. We don't
    even need to use the `.error` or `.catch` methods known to Promises. We can use
    plain old `try/catch` that ships with JavaScript out of the box.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是 Koa.js 的一个强项。使用生成器函数，我们不需要在回调的每一层处理错误处理，避免了 Node.js 流行起来的 (`err, res`)
    签名回调的使用。我们甚至不需要使用 Promises 的 `.error` 或 `.catch` 方法。我们可以使用 JavaScript 自带的 `try/catch`。
- en: 'The implication of this is that we can now have the following centralized error
    handling middleware:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在可以有以下集中的错误处理中间件：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we include this as one of the first middlewares on the Koa stack, it will
    basically wrap the entire stack, which is yielded to downstream, in a giant `try/catch`
    clause. Now we don't need to worry about exceptions being thrown into the ether.
    In fact, you are now encouraged to `throw` common JavaScript errors, knowing that
    this middleware will gracefully unpack it for you, and present it to the client.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这个中间件作为 Koa 栈中的第一个中间件之一包含时，它将基本上将整个栈（向下传递）包裹在一个巨大的 `try/catch` 子句中。现在我们不需要担心异常被抛入空中。事实上，现在您被鼓励抛出常见的
    JavaScript 错误，因为您知道这个中间件会优雅地为您解包它，并将其呈现给客户端。
- en: 'Now this may not always be exactly what you want though. For instance, if you
    try to upvote an ID that is not a valid BSON format, Mongoose will throw `CastError`
    with the message `Cast` `to` `ObjectId` `failed` `for` `value` `xxx` `at` `path`
    `_id''`. While informative for you, it is pretty dirty for the client. So here''s
    how you can override the error by returning a `400` error with a nice, clean message:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不总是您想要的。例如，如果您尝试对一个不是有效 BSON 格式的 ID 进行点赞，Mongoose 将会抛出带有消息 `Cast to ObjectId
    failed for value xxx at path _id` 的 `CastError`。虽然对您来说很有信息量，但对客户端来说却相当糟糕。所以，您可以这样通过返回一个带有良好、清晰信息的
    `400` 错误来覆盖这个错误：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We basically catch the error where it happens, as opposed to let it bubble up
    all the way to the error handler. While we could throw a JavaScript error object
    with the `status` and `message` fields set to pass it along to the errorHandler
    middleware, we can also handle it here directly with the `this.throw` helper of
    the Context object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上在错误发生的地方捕获它，而不是让它一直冒泡到错误处理器。虽然我们可以抛出一个带有 `status` 和 `message` 字段设置的JavaScript错误对象，将其传递给错误处理器中间件，但我们也可以直接使用上下文对象的
    `this.throw` 辅助函数来处理它。
- en: 'Now if you pass a valid BSON ID, but the link does not exist, Mongoose will
    not throw an error. Therefore, you still have to check whether the value of `link`
    is not `undefined`. Here is yet another gorgeous helper of the Context object:
    `this.assert`. It basically asserts whether a condition is met, and if not, it
    will return a `400` error with the message `link` `not` `found`, as passed in
    the second and third argument.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你传递了一个有效的BSON ID，但链接不存在，Mongoose 不会抛出错误。因此，你仍然需要检查 `link` 的值是否不是 `undefined`。这里又是上下文对象的一个漂亮的辅助函数：`this.assert`。它基本上断言一个条件是否满足，如果不满足，它将返回一个带有消息
    `link` `not` `found` 的 `400` 错误，该消息作为第二个和第三个参数传递。
- en: 'Here are a few more validations to the submission of links:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些对链接提交的验证：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We ensure that a title is being passed, as well as a valid URL, for which we
    use the following RegEx util:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保传递了一个标题以及一个有效的URL，为此我们使用了以下正则表达式工具：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now there are still ways to refactor the validation checks into modular middleware;
    similar to what we did in [Chapter 3](ch03.html "Chapter 3. Multiplayer Game API
    – Connect 4"), *Multiplayer Game API – Connect* this is left as an exercise to
    the reader.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在仍然有方法可以将验证检查重构为模块化中间件；类似于我们在 [第3章](ch03.html "第3章。多人游戏API - Connect 4") 中所做的那样，*多人游戏API
    - Connect* 这留作读者的练习。
- en: Update route
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新路由
- en: A CRUD API is not complete with the update route! If you are a Hacker News frequenter,
    you'll know that titles of the submissions can change (but not the URL). This
    route should be straightforward, but there is one caveat! Yes, you could use `findByIdAndUpdate`,
    which is used by `upvote`, but what if you wanted to use Mongoose's instance method
    `.save()`?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CRUD API如果没有更新路由是不完整的！如果你是Hacker News的常客，你会知道提交的标题可能会改变（但URL不会变）。这个路由应该是直接的，但有一个注意事项！是的，你可以使用
    `findByIdAndUpdate`，这是 `upvote` 使用的，但如果你想使用Mongoose的实例方法 `.save()` 呢？
- en: Well, it does not return a Promise, so therefore we cannot `yield` to it. In
    fact, at the time of writing, there is still an open issue about this. Using `save()`,
    we can only use the traditional callback pattern. However, remember the rule—do
    not mix generator functions with callbacks!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它不返回Promise，所以我们不能 `yield` 到它。实际上，在撰写本文时，关于这一点仍然有一个开放的问题。使用 `save()`，我们只能使用传统的回调模式。然而，记住规则——不要将生成器函数与回调混合！
- en: So now what? Well, it will be quite common for certain node modules to be only
    available in the callback format. While most common modules are ported to a Koa
    version, you can still use Express packages; you just have to `thunkify` them.
    In fact, you could turn any callback style function into a thunk.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来该做什么呢？嗯，对于某些节点模块只以回调格式提供的情况将相当普遍。虽然大多数常见模块都已转换为Koa版本，但你仍然可以使用Express包；你只需要将它们
    `thunkify`。实际上，你可以将任何回调风格的函数转换为thunk。
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now here''s how to turn a function that accepts a callback into a yieldable
    thunk:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看如何将接受回调的函数转换为可 `yield` 的thunk：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Adding the preceding code to `model/links.js`, we can now do the following
    in the update route:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码添加到 `model/links.js` 中后，我们可以在更新路由中执行以下操作：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice the use of `saveThunk()` near the bottom. It is basically a `thunkified`
    version of the original `save()` method. This means that an error that would originally
    be passed as the first argument in the callback is now thrown as an Error. We
    can afford not to wrap it in a `try/catch` block because the errorHandler middleware
    will catch it and throw a `500` error, which would be appropriate in this case.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意底部附近对 `saveThunk()` 的使用。它基本上是原始 `save()` 方法的 `thunkified` 版本。这意味着原本作为回调的第一个参数传递的错误现在被抛出为一个Error。我们可以承担不将其包裹在
    `try/catch` 块中的风险，因为错误处理中间件会捕获它并抛出一个 `500` 错误，这在这种情况下是合适的。
- en: Also, note how the thunk returns an array. This is because the original callback
    has an arity of `3`. The first argument is the error, the second argument is the
    new document, while the third argument is the number of affected documents. The
    array returned by the thunk contains the latter two values. If the arity of the
    callback was `2`, it would've just returned the value; something to keep in mind.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意thunk返回一个数组。这是因为原始回调的参数数量为`3`。第一个参数是错误，第二个参数是新的文档，第三个参数是受影响的文档数量。thunk返回的数组包含后两个值。如果回调的参数数量是`2`，它将只返回值；这是一个需要注意的点。
- en: Let's perform some tests
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们进行一些测试
- en: In this chapter we omitted the disciplined TDD approach, since it has been covered
    multiple times in previous chapters. However, testing is slightly different in
    Koa.js, so let's highlight some of those differences.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们省略了纪律性的TDD方法，因为在前面的章节中已经多次介绍过。然而，在Koa.js中，测试略有不同，所以让我们突出一些这些差异。
- en: 'We can still use supertest in the neat way that we did before, with one slight
    adjustment as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用supertest以我们之前干净的方式使用，但需要稍作调整，如下所示：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We need to call the `.callback()` method to return an object that we can pass
    to supertest. In fact, the returned object can even be mounted on top of an Express
    app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调用`.callback()`方法来返回一个对象，我们可以将其传递给supertest。实际上，返回的对象甚至可以挂载在Express应用之上。
- en: 'Testing the routes to submit links is pretty straightforward:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 测试提交链接的路由相当直接：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At the start of this test suite, we clear the collection in the DB and submit
    a link using a post request. Nothing special here; note that we use Mocha's default
    callbacks for the asynchronous requests, and not `co-mocha`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试套件的开始，我们在数据库中清空集合，并通过POST请求提交一个链接。这里没有什么特别的；请注意，我们使用Mocha的默认回调函数处理异步请求，而不是`co-mocha`。
- en: 'Let''s submit a few more links, and check that they are indeed stored in the
    DB:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提交更多链接，并检查它们是否确实存储在数据库中：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that we store link IDs in an array for the next test case to demonstrate
    the final, most awesome bonus feature of Koa.js, parallel asynchronous requests,
    out of the box!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将链接ID存储在一个数组中，以便在下一个测试用例中演示Koa.js的最终、最酷的附加功能——开箱即用的并行异步请求！
- en: Parallel requests
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行请求
- en: The backend of Hacker News should be able to deal with the race condition, that
    is, it should handle hundreds of concurrent `upvote` requests without losing data
    (recall [Chapter 4](ch04.html "Chapter 4. MMO Word Game"), *MMO Word Game* on
    race conditions). So let's write a test case that simulates parallel requests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Hacker News的后端应该能够处理竞争条件，也就是说，它应该能够处理数百个并发的`upvote`请求而不会丢失数据（回忆[第4章](ch04.html
    "第4章. MMO Word Game")，关于竞争条件的*MMO Word Game*）。因此，让我们编写一个模拟并行请求的测试用例。
- en: Traditionally, you would immediately think of using the extremely powerful and
    popular `async` library, which has a lot of very useful tools to deal with complex
    asynchronous execution flows. One of the most useful tools that `async` offers
    is `async.parallel`, with which you can make asynchronous requests in parallel.
    It is used to be the go-to solution for parallel requests, but now Koa offers
    something out of the box and with a much cleaner syntax!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，你可能会立即想到使用功能强大且流行的`async`库，它提供了许多非常有用的工具来处理复杂的异步执行流程。`async`提供的一个最有用的工具是`async.parallel`，你可以用它来并行执行异步请求。它曾经是并行请求的首选解决方案，但现在Koa提供了开箱即用的功能，并且语法更加简洁！
- en: Recall that `co` is actually what gives Koa the power of generator functions,
    so refer to the readme page of the `co` project to read more about all the patterns
    that it has to offer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`co`实际上是赋予Koa生成器功能力量的东西，因此请参考`co`项目的readme页面，了解更多它提供的所有模式。
- en: 'So far we yielded to generator functions, Promises, and thunks. However, that
    is not all. You can also `yield` to an array of the preceding which would execute
    them in parallel! Here''s how:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经产出到了生成器函数、Promises和thunks。然而，这还不是全部。你还可以`产出`一个前一个数组的数组，这将并行执行它们！下面是如何做的：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Firstly, notice how we use a generator function, so be sure that you have `require(co-mocha)`
    on top of your test file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意我们使用了一个生成器函数，所以请确保你在测试文件顶部有`require(co-mocha)`。
- en: 'Secondly, `supertest` does not return a thunk or a promise, which we can yield
    to, so we require `co-supertest` for this test case:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`supertest`不返回一个thunk或promise，我们可以从中产出，因此我们需要为这个测试用例使用`co-supertest`：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Thirdly, we build an array of requests to be executed later. We are basically
    pushing thunks into an array; they could be promises too. Now when we yield the
    array, it will execute all requests in parallel, and return an array of all the
    response objects!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们构建一个稍后要执行的请求数组。我们基本上是将 thunks 推入一个数组；它们也可以是承诺。现在当我们产生这个数组时，它将并行执行所有请求，并返回所有响应对象的数组！
- en: Quite mind blowing if you're used to `async.parallel` for these things, right?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了使用 `async.parallel` 来做这些事情，这会让你感到非常震撼，对吧？
- en: Rendering HTML pages
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染 HTML 页面
- en: At this point, we have a simple Koa API that has all the basic functionalities
    quite well tested. Let's add a simple view layer on top to show how you can serve
    static files from a Koa app as well. So if the app receives a request from a browser
    for HTML content, we'll serve a functional web page, where we can see the links
    submitted, submit a link, as well as upvote a link.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个简单的 Koa API，它已经对所有基本功能进行了相当充分的测试。现在让我们在上面添加一个简单的视图层，以展示如何从 Koa 应用程序中提供静态文件。所以如果应用程序收到浏览器对
    HTML 内容的请求，我们将提供一个功能性的网页，我们可以看到提交的链接，提交一个链接，以及点赞一个链接。
- en: Let's pause here for a quick real-developer-life anecdote to implement the preceding.
    The tendency for modularity is an empowering force of the open source community.
    A modern day developer has access to a plethora of well-tested modules. Oftentimes,
    the majority of the developer's work is simply to compose an app of several such
    modules. We learn of these modules from prior experience, books, news websites,
    social media, and so on. So how do we go about choosing the right tools instead
    of reinventing the wheel?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里暂停一下，快速分享一个真实开发者的生活趣事来实现前面的功能。模块化的趋势是开源社区的一个强大动力。现代开发者可以访问大量经过良好测试的模块。通常，开发者的主要工作只是将几个这样的模块组合成一个应用程序。我们从以往的经验、书籍、新闻网站、社交媒体等地方了解到这些模块。那么我们如何选择合适的工具而不是重新发明轮子呢？
- en: 'It is always recommended to do a simple search to see whether a module is already
    available. In this case, we are interested in rendering views with Koa.js, so
    let''s try the search term `koa-render` on [www.npmjs.com](http://www.npmjs.com).
    Two popular packages come up that seem to quite fit our needs, as shown in the
    following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 总是建议先进行简单的搜索，看看是否已经有现成的模块可用。在这种情况下，我们感兴趣的是使用 Koa.js 渲染视图，所以让我们在 [www.npmjs.com](http://www.npmjs.com)
    上尝试搜索词 `koa-render`。出现了两个流行的包，看起来非常适合我们的需求，如下面的截图所示：
- en: '![Rendering HTML pages](img/B00818_06_01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![渲染 HTML 页面](img/B00818_06_01.jpg)'
- en: 'The `koa-views` is a template rendering middleware for Koa, supporting many
    template engines. Sounds promising! `koa-render` adds a `render()` method to Koa
    that allows you to render almost any templating engine. Not bad either. As shown
    in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`koa-views` 是 Koa 的模板渲染中间件，支持许多模板引擎。听起来很有希望！`koa-render` 为 Koa 添加了一个 `render()`
    方法，允许你渲染几乎任何模板引擎。也不算差。如下面的截图所示：'
- en: '![Rendering HTML pages](img/B00818_06_02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![渲染 HTML 页面](img/B00818_06_02.jpg)'
- en: One of the things we can look at to guide our choice is the number of downloads;
    both packages have a decent amount of downloads, which shows some credibility.
    The `koa-views` has about 5 times more downloads than `koa-render` per month.
    While these badges are a minor touch, it does show that the author cared enough
    and is likely to support it. The number of recent commits is also a of good indicator
    that can be found on the GitHub page for the project, the number issues that have
    been resolved, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看的一些指导我们选择的事项之一是下载量；这两个包都有相当多的下载量，这表明它们有一定的可信度。`koa-views` 每个月的下载量是 `koa-render`
    的约 5 倍。虽然这些徽章只是小细节，但它确实表明作者非常关心，并且很可能支持它。项目 GitHub 页面上的最近提交次数也是一个很好的指标，包括已解决的
    issue 数量等。
- en: At the time of writing, both projects' GitHub links redirect to `koa-views`,
    which is unexpected, but good for us! Looking at the GitHub account of the author
    of koa-render, we cannot find the project anymore, so it's safe to assume it was
    discontinued; avoid it! When you can, try to avoid using non-maintainable packages
    as it might pose a threat given the fact that Node.js (and io.js) are rapidly
    evolving ecosystems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，这两个项目的 GitHub 链接都重定向到 `koa-views`，这出人意料，但对我们来说是个好消息！查看 `koa-render` 的作者
    GitHub 账户，我们找不到这个项目了，所以可以安全地假设它已经被废弃；避免使用它！当你有机会时，尽量避免使用不可维护的包，因为考虑到 Node.js（和
    io.js）是快速发展的生态系统，这可能会构成威胁。
- en: 'Back to rendering HTML pages, Koa, unlike Express, has no pre-baked opinion
    about the rendering of views. However, it does provide us with some mechanisms
    for content negotiation, some of which we can use to enhance and reuse the routes
    we already have for our API. Let''s see what our `/links` handler will look like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 回到渲染 HTML 页面，与 Express 不同，Koa 对视图的渲染没有预设的意见。然而，它确实为我们提供了一些内容协商的机制，其中一些我们可以用来增强和重用我们为
    API 已经拥有的路由。让我们看看我们的 `/links` 处理器将是什么样子：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our use case is rather simple; we either serve JSON or HTML. When the request
    header `accepts` is set to `text/html`, something browsers set automatically,
    we''ll render the HTML. For the rendering of dynamic jade views to work as expected,
    we must not forget to include the `koa-views` middleware in `app.js` somewhere
    before the router middleware:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的使用案例相当简单；我们要么提供 JSON 或 HTML。当请求头 `accepts` 设置为 `text/html`，这是浏览器自动设置的，我们将渲染
    HTML。为了使动态 jade 视图渲染正常工作，我们必须在 `app.js` 中在路由中间件之前某处包含 `koa-views` 中间件：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The middleware points to a folder with a relative path that will contain the
    templates. Right now, we just need a single template `views/index.jade`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件指向一个包含模板的文件夹，其相对路径如下。目前，我们只需要一个单独的模板 `views/index.jade`：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It's a jade file similar to the ones presented before in this book. It loops
    over every link loaded at the controller, which has a single action to upvote.
    Links are displayed in the descending order of votes, which only happens when
    the page is reloaded. There is also a simple form that allows the user to submit
    new links.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个与本书中之前展示的类似的 jade 文件。它遍历控制器中加载的每个链接，控制器有一个单动作用于点赞。链接按投票数降序显示，这仅在页面重新加载时发生。还有一个简单的表单，允许用户提交新的链接。
- en: We chose to load jQuery from a CDN simply in order to make the `PUT` request
    for upvotes. Notice that our use of inline JavaScript as well as adding a click
    event using the onclick element is highly discouraged, other than to make this
    example simple to digest.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择从 CDN 加载 jQuery，只是为了简化 `PUT` 请求点赞的过程。请注意，除了使这个例子易于理解之外，我们强烈不建议使用内联 JavaScript
    以及使用 onclick 元素添加点击事件。
- en: 'Now if you have your app running and you go to `localhost:3000/links`, here''s
    the result:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您已经运行了您的应用程序，并且您访问 `localhost:3000/links`，这里的结果如下：
- en: '![Rendering HTML pages](img/B00818_06_03.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![渲染 HTML 页面](img/B00818_06_03.jpg)'
- en: So that's a start from a functional standpoint! Clearly not good enough if we
    want to add more frontend JavaScript and CSS styling to it; we still need to be
    able to serve static files.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，从功能角度来看，这是一个起点！如果我们想添加更多的前端 JavaScript 和 CSS 样式，这显然还不够好；我们仍然需要能够提供静态文件。
- en: Serving static assets
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器静态资源
- en: 'Although usually you''d be incentivized to create a separate server for your
    assets, let''s keep things simple and dive straight to the goal. We want to serve
    any files from a certain folder to a certain base path. For that purpose, we''ll
    need two small middlewares, respectively, `koa-static` and `koa-mount`. In `src/app.js`,
    we add the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常您会被鼓励为您的资源创建一个单独的服务器，但让我们保持简单，直接进入目标。我们想要从某个文件夹向某个基本路径提供任何文件。为此，我们需要两个小的中间件，分别是
    `koa-static` 和 `koa-mount`。在 `src/app.js` 中，我们添加以下内容：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The function `mount()` will namespace the request for each middleware that follows,
    in this particular case being combined with serve, which will serve any file inside
    the `public/` directory. If we decide not to mount to any particular URL, serving
    files would still work; it just won't have a nice namespace.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `mount()` 将为每个后续的中间件命名空间请求，在这个特定的情况下，它是与 `serve` 结合使用的，这将服务于 `public/` 目录内的任何文件。如果我们决定不对任何特定的
    URL 进行挂载，文件服务仍然可以工作；只是它不会有漂亮的命名空间。
- en: Now all you need to do is create a `public/` directory in the root folder with
    `filepublic/main.css` and it will able to serve a stylesheet.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您只需要在根目录中创建一个 `public/` 目录，并包含 `filepublic/main.css` 文件，它将能够提供样式表。
- en: This method allows to serve all static files you'd expect; CSS, JavaScript,
    images, and even videos.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许提供您期望的所有静态文件；CSS、JavaScript、图像，甚至是视频。
- en: To take it even further, there are many build tools and best practices for front-end
    assets, including ways to set up asset pipelines with Grunt, Gulp, Browserify,
    SASS, CoffeeScript, and many others tools. Not to mention front-end frameworks
    such as Angular, Ember, React, and so on. This is only the beginning.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更进一步，有许多前端资源构建工具和最佳实践，包括使用 Grunt、Gulp、Browserify、SASS、CoffeeScript 以及许多其他工具来设置资源管道。更不用说前端框架，如
    Angular、Ember、React 等。这只是开始。
- en: Hope you enjoyed the introduction to Koa.js!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢 Koa.js 的介绍！
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We built an API with which you can now host your own Hacker News of X! Obviously,
    we're still missing the sort and decay algorithm, as well as comments, but since
    you reached this far, it should be an easy exercise for you.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个 API，您现在可以使用它来托管自己的 Hacker News of X！显然，我们仍然缺少排序和衰减算法，以及评论功能，但既然您已经走到这一步，这应该对您来说是一个简单的练习。
- en: The purpose of this chapter was really to give you a taste of the neat features
    of Koa.js, and demonstrate the use of the generator function pattern, which will
    be available in ECMAScript 6\. If you like being on the bleeding edge, and enjoy
    the generator syntax, it is definitely a good alternative to Express.js.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这章的目的实际上是为了让您领略 Koa.js 的便捷特性，并展示生成器函数模式的使用，该模式将在 ECMAScript 6 中提供。如果您喜欢走在技术前沿，并且喜欢生成器语法，那么这绝对是一个比
    Express.js 更好的替代方案。
