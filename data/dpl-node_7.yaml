- en: Chapter 7. Deploying and Maintaining
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：部署和维护
- en: In this book, we have seen the advantages of composing applications out of well
    defined components. This assembly process involves the installation of many support
    systems, from the operating system your application will run on, to the version
    of Node you will support, to the various npm modules, testing frameworks, profiling
    tools, and other subsystems that power an application. It is likely that you have
    been doing all this on a single machine—manually starting and stopping servers,
    updating configurations, and altering application code. Are you adding a new module?
    Stop the server, add the module, and restart the server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经看到了将应用程序构建成定义良好的组件的优点。这个过程涉及安装许多支持系统，从应用程序将运行的操作系统，到您将支持的Node版本，再到各种npm模块、测试框架、分析工具以及其他支撑应用程序的子系统。您可能一直在单台机器上做所有这些——手动启动和停止服务器、更新配置和修改应用程序代码。您是否正在添加新模块？停止服务器，添加模块，然后重新启动服务器。
- en: In a production environment, this sort of ad hoc development is almost impossible,
    and it remains tedious regardless. How can this process be automated and streamlined
    so that altering the number of servers being balanced or incrementally pushing
    out new deployments can be done with minimum work, thus making life simpler for
    the folks responsible for operations?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，这种临时性的开发几乎是不可能的，而且无论如何都相当繁琐。如何自动化并简化这个过程，以便在服务器负载平衡数量发生变化或增量推送新部署时，可以以最少的劳动完成，从而让负责运营的人员的生活变得更加简单？
- en: 'In this chapter, we will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Automating the deployment of applications, including a look at the differences
    between continuous integration, delivery, and deployment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化应用程序的部署，包括对持续集成、交付和部署之间差异的探讨
- en: Using Git to track local changes and triggering deployment actions via webhooks
    when appropriate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Git跟踪本地更改，并在适当的时候通过webhooks触发部署操作
- en: Using Vagrant to synchronize your local development environment with a deployed
    production server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vagrant将本地开发环境与已部署的生产服务器同步
- en: Provisioning a server with Ansible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible配置服务器
- en: Implementing continuous integration and deployment using Jenkins and working
    through a complete example of how to automate builds and deploys when the source
    code changes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jenkins实现持续集成和部署，并通过一个完整的示例了解如何在源代码更改时自动化构建和部署
- en: Maintaining npm packages and dependency trees, outlining how to track version
    changes, and keeping your deployed applications up to date
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护npm包和依赖树，概述如何跟踪版本变化，并确保部署的应用程序保持最新
- en: Note that application deployment is a complex topic with many dimensions that
    are often considered within unique sets of needs. This chapter is intended as
    an introduction to some of the technologies and themes you will encounter. Also,
    note that the scaling issues discussed in [Chapter 3](ch03.html "Chapter 3. Scaling
    Node"), *Scaling Node*, are part and parcel of deployment. Also, our discussion
    in [Chapter 2](ch02.html "Chapter 2. Installing and Virtualizing Node Servers"),
    *Installing and Virtualizing Node Servers*, is relevant here. You may want to
    revisit those topics while working through the following deployment scenarios.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，应用程序部署是一个复杂的话题，涉及许多维度，这些维度通常在独特的需求集中被考虑。本章旨在介绍您将遇到的一些技术和主题。此外，请注意，[第3章](ch03.html
    "第3章。扩展节点")中讨论的扩展问题，*扩展节点*，是部署的一部分。同样，[第2章](ch02.html "第2章。安装和虚拟化节点服务器")中关于*安装和虚拟化节点服务器*的讨论也与此相关。您可能希望在处理以下部署场景时回顾这些主题。
- en: Using GitHub webhooks
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitHub webhooks
- en: At the most basic level, deployment involves automatically validating, preparing,
    and releasing new code into production environments. One of the simplest ways
    to set up a deployment strategy is to trigger releases whenever changes are committed
    to a Git repository through the use of **webhooks**. Paraphrasing the GitHub documentation,
    webhooks *provide a way for notifications to be delivered to an external web server
    whenever certain actions occur on a repository*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本层面上，部署涉及自动验证、准备和将新代码发布到生产环境。设置部署策略的最简单方法之一是在Git仓库中提交更改时通过使用**webhooks**触发发布。引用GitHub文档，webhooks
    *提供了一种在仓库上发生某些操作时将通知发送到外部Web服务器的方式*。
- en: In [Chapter 2](ch02.html "Chapter 2. Installing and Virtualizing Node Servers"),
    *Installing and Virtualizing Node Servers*, we saw a simplified example of this
    process, where pushing changes to a Heroku instance caused your production build
    to automatically update. One problem with this simple solution is that no validation
    was performed—if you pushed bad code, your production server would blindly run
    bad code. In this section, we'll use GitHub webhooks to create a simple continuous
    deployment workflow, adding more realistic checks and balances.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。安装和虚拟化Node服务器")*安装和虚拟化Node服务器*中，我们看到了这个过程的简化示例，其中将更改推送到Heroku实例会导致您的生产构建自动更新。这个简单解决方案的一个问题是没有任何验证——如果您推送了坏代码，您的生产服务器会盲目地运行坏代码。在本节中，我们将使用GitHub钩子创建一个简单的持续部署工作流程，增加更现实的检查和平衡。
- en: We'll build a local development environment that lets developers work with a
    clone of the production server code, make changes, and see the results of those
    changes immediately. As this local **development** build uses the same repository
    as the **production** build, the build process for a chosen environment is simple
    to configure, and multiple production and/or development *boxes* can be created
    with no special effort.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个本地开发环境，让开发者可以使用生产服务器代码的副本进行工作，进行更改，并立即看到这些更改的结果。由于这个本地**开发**构建与**生产**构建使用相同的仓库，因此配置所选环境的构建过程很简单，无需特殊努力即可创建多个生产和/或开发**盒子**。
- en: The first step is to create a GitHub ([www.github.com](http://www.github.com))
    account if you don't already have one. Basic accounts are free and easy to set
    up.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是如果您还没有的话创建一个GitHub ([www.github.com](http://www.github.com)) 账户。基本账户是免费的，并且易于设置。
- en: Now, let's look at how GitHub webhooks work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看GitHub钩子是如何工作的。
- en: Enabling webhooks
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用钩子
- en: 'Create a new folder and insert the following `package.json` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件夹，并插入以下`package.json`文件：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This ensures that Express 4.x is installed and includes the `body-parser` package,
    which is used to handle POST data. Next, create a basic server called `server.js`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了Express 4.x已安装，并包含`body-parser`包，该包用于处理POST数据。接下来，创建一个名为`server.js`的基本服务器：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Enter the folder you've created, and build and run the server with `npm install;
    npm start`. Visit `localhost:8082/` and you should see **"Hello World!"** in your
    browser.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您创建的文件夹，使用`npm install; npm start`构建和运行服务器。访问`localhost:8082/`，您应该在浏览器中看到**"Hello
    World!"**。
- en: 'Whenever any file changes in a given repository, we want GitHub to push information
    about the change to `/webhook`. So, the first step is to create a GitHub repository
    for the Express server mentioned in the code. Go to your GitHub account and create
    a new repository with the name `''express-webhook''`. The following screenshot
    shows this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定仓库中的任何文件更改时，我们希望GitHub将有关更改的信息推送到`/webhook`。因此，第一步是为代码中提到的Express服务器创建一个GitHub仓库。转到您的GitHub账户，并创建一个名为`'express-webhook'`的新仓库。以下截图显示了这一过程：
- en: '![Enabling webhooks](img/1403OS_07_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![启用钩子](img/1403OS_07_03.jpg)'
- en: 'Once the repository is created, enter your local repository folder and run
    the following commands:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库创建后，进入您的本地仓库文件夹，并运行以下命令：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should now have a new GitHub repository and a local linked version. The
    next step is to configure this repository to broadcast the push event on the repository.
    Navigate to the following URL:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该有一个新的GitHub仓库和一个本地链接版本。下一步是配置这个仓库以广播仓库上的推送事件。导航到以下URL：
- en: '`https://github.com/<your_username>/express-webhook/settings`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://github.com/<你的用户名>/express-webhook/settings`'
- en: 'From here, navigate to **Webhooks & Services** | **Add webhook** (you may need
    to enter your password again). You should now see the following screen:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，导航到**Webhooks & Services** | **添加钩子**（您可能需要再次输入密码）。现在您应该看到以下屏幕：
- en: '![Enabling webhooks](img/1403OS_07_04.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![启用钩子](img/1403OS_07_04.jpg)'
- en: This is where you set up webhooks. Note that the `push` event is already set
    as default, and, if asked, you'll want to disable SSL verification for now. GitHub
    needs a target URL to use POST on change events. If you have your local repository
    in a location that is already web accessible, enter that now, remembering to append
    the `/webhook` route, as in [http://www.example.com/webhook](http://www.example.com/webhook).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您设置钩子的地方。请注意，`push`事件已设置为默认，如果您被要求，您现在想禁用SSL验证。GitHub需要一个目标URL来在更改事件上使用POST。如果您将本地仓库放置在一个已经可以公开访问的Web位置，现在输入该位置，记得要附加`/webhook`路由，例如[http://www.example.com/webhook](http://www.example.com/webhook)。
- en: If you are building on a local machine or on another limited network, you'll
    need to create a secure tunnel that GitHub can use. A free service to do this
    can be found at [http://localtunnel.me/](http://localtunnel.me/). Follow the instructions
    on that page, and use the custom URL provided to configure your webhook.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在本地机器或另一个受限网络上构建，你需要创建一个GitHub可以使用的安全隧道。你可以在这个免费服务[http://localtunnel.me/](http://localtunnel.me/)找到这个服务。按照页面上的说明操作，并使用提供的自定义URL来配置你的webhook。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Other good forwarding services can be found at [https://forwardhq.com/](https://forwardhq.com/)
    and [https://meetfinch.com/](https://meetfinch.com/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他好的转发服务可以在[https://forwardhq.com/](https://forwardhq.com/)和[https://meetfinch.com/](https://meetfinch.com/)找到。
- en: 'Now that webhooks are enabled, the next step is to test the system by triggering
    a push event. Create a new file called `readme.md` (add whatever you''d like to
    it), save it, and then run the following commands:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在webhook已经启用，下一步是通过触发一个推送事件来测试系统。创建一个名为`readme.md`的新文件（添加你想要的任何内容），保存它，然后运行以下命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will push changes to your GitHub repository. Return to the **Webhooks
    & Services** section for the `express-webhook` repository on GitHub. You should
    see something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把更改推送到你的GitHub仓库。返回GitHub上的`express-webhook`仓库的**Webhooks & Services**部分。你应该会看到类似以下的内容：
- en: '![Enabling webhooks](img/1403OS_07_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![启用webhooks](img/1403OS_07_05.jpg)'
- en: 'This is a good thing! GitHub noticed your push and attempted to deliver information
    about the changes to the webhook endpoint you set, but the delivery failed as
    we haven''t configured the `/webhook` route yet—that''s to be expected. Inspect
    the failed delivery payload by clicking on the last attempt—you should see a large
    JSON file. In that payload, you''ll find something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好事！GitHub注意到了你的推送并尝试将更改信息传递到设置的webhook端点，但由于我们还没有配置`/webhook`路由，传递失败是预料之中的。通过点击最后的尝试来检查失败的传递负载——你应该会看到一个大的JSON文件。在这个负载中，你会找到类似以下的内容：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It should now be clear what sort of information GitHub will pass along whenever
    a push event happens. You can now configure the `/webhook` route in the demonstration
    Express server to parse this data and do something with that information, such
    as sending an e-mail to an administrator. For example, use the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很清楚GitHub在推送事件发生时将传递什么样的信息。你现在可以配置演示Express服务器中的`/webhook`路由来解析这些数据并使用这些信息，例如向管理员发送电子邮件。例如，使用以下代码：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next time your webhook fires, the entire JSON payload will be displayed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你的webhook触发时，整个JSON负载将显示出来。
- en: Let's take this to another level, breaking down the autopilot application to
    see how webhooks can be used to create a build/deploy system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，分解autopilot应用程序，看看如何使用webhook来创建一个构建/部署系统。
- en: Implementing a build/deploy system using webhooks
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用webhook实现构建/部署系统
- en: To demonstrate how to build a webhook-powered deployment system, we're going
    to use a starter kit for application development. Go ahead and use fork on the
    repository at [https://github.com/sandro-pasquali/autopilot.git](https://github.com/sandro-pasquali/autopilot.git).
    You now have a copy of the **autopilot** repository, which includes scaffolding
    for common Gulp tasks, tests, an Express server, and a deploy system that we're
    now going to explore.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何构建一个由webhook驱动的部署系统，我们将使用一个应用程序开发入门套件。前往[https://github.com/sandro-pasquali/autopilot.git](https://github.com/sandro-pasquali/autopilot.git)的仓库并使用Fork。你现在有了**autopilot**仓库的副本，它包括常见Gulp任务的脚手架、测试、Express服务器和一个我们现在将要探索的部署系统。
- en: 'The autopilot application implements special features depending on whether
    you are running it in production or in development. While autopilot is a little
    too large and complex to fully document here, we''re going to take a look at how
    major components of the system are designed and implemented so that you can build
    your own or augment existing systems. Here''s what we will examine:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你是在生产环境中运行还是在开发环境中运行，autopilot应用程序会实现特殊功能。虽然autopilot太大太复杂，无法在这里完全记录，但我们将查看系统的主要组件是如何设计和实现的，这样你就可以构建自己的或增强现有系统。以下是我们要检查的内容：
- en: How to create webhooks on GitHub programmatically
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在GitHub上以编程方式创建webhook
- en: How to catch and read webhook payloads
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何捕获和读取webhook负载
- en: How to use payload data to clone, test, and integrate changes
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用负载数据来克隆、测试和集成更改
- en: How to use PM2 to safely manage and restart servers when code changes
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用PM2在代码更改时安全地管理和重启服务器
- en: If you haven't already used fork on the autopilot repository, do that now. Clone
    the autopilot repository onto a server or someplace else where it is web-accessible.
    Follow the instructions on how to connect and push to the fork you've created
    on GitHub, and get familiar with how to pull and push changes, commit changes,
    and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在 autopilot 仓库上使用 fork，现在就做。将 autopilot 仓库克隆到服务器或其他可以网络访问的地方。遵循如何在 GitHub
    上连接和推送你创建的 fork 的说明，并熟悉如何拉取和推送更改、提交更改等操作。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PM2 delivers a basic deploy system that you might consider for your project
    ([https://github.com/Unitech/PM2/blob/master/ADVANCED_README.md#deployment](https://github.com/Unitech/PM2/blob/master/ADVANCED_README.md#deployment)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: PM2 提供了一个基本的部署系统，你可能考虑将其用于你的项目（[https://github.com/Unitech/PM2/blob/master/ADVANCED_README.md#deployment](https://github.com/Unitech/PM2/blob/master/ADVANCED_README.md#deployment)）。
- en: 'Install the cloned autopilot repository with `npm install; npm start`. Once
    npm has installed dependencies, an interactive CLI application will lead you through
    the configuration process. Just hit the *Enter* key for all the questions, which
    will set defaults for a local development build (we''ll build in production later).
    Once the configuration is complete, a new development server process controlled
    by PM2 will have been spawned. You''ll see it listed in the PM2 manifest under
    `autopilot-dev` in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `npm install; npm start` 安装克隆的 autopilot 仓库。一旦 npm 安装了依赖项，一个交互式 CLI 应用程序将引导你完成配置过程。只需按
    *Enter* 键回答所有问题，这将设置本地开发构建的默认值（我们将在稍后构建生产环境）。配置完成后，PM2 将启动一个新的开发服务器进程。你将在以下截图的
    PM2 清单中看到它列在 `autopilot-dev` 下：
- en: '![Implementing a build/deploy system using webhooks](img/1403OS_07_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用 webhook 实现构建/部署系统](img/1403OS_07_02.jpg)'
- en: You will make changes in the `/source` directory of this development build.
    When you eventually have a production server in place, you will use `git push`
    on the local changes to push them to the autopilot repository on GitHub, triggering
    a webhook. GitHub will use `POST` on the information about the change to an Express
    route that we will define on our server, which will trigger the build process.
    The build runner will `pull` your changes from GitHub into a temporary directory,
    install, build, and test the changes, and if all is well, it will replace the
    relevant files in your deployed repository. At this point, PM2 will restart, and
    your changes will be immediately available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本开发构建的 `/source` 目录中进行更改。当你最终部署好生产服务器时，你将使用 `git push` 将本地更改推送到 GitHub 上的
    autopilot 仓库，从而触发 webhook。GitHub 将使用 `POST` 方法对更改信息发送到我们在服务器上定义的 Express 路由，这将触发构建过程。构建运行器将从
    GitHub `pull` 你的更改到临时目录，安装、构建和测试更改，如果一切顺利，它将替换你已部署仓库中的相关文件。此时，PM2 将重新启动，你的更改将立即可用。
- en: 'Schematically, the flow looks like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从示意图上看，流程如下：
- en: '![Implementing a build/deploy system using webhooks](img/1403OS_07_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![使用 webhook 实现构建/部署系统](img/1403OS_07_01.jpg)'
- en: 'To create webhooks on GitHub programmatically, you will need to create an access
    token. The following diagram explains the steps from A to B to C:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式在 GitHub 上创建 webhook，你需要创建一个访问令牌。以下图表解释了从 A 到 B 到 C 的步骤：
- en: '![Implementing a build/deploy system using webhooks](img/1403OS_07_09.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用 webhook 实现构建/部署系统](img/1403OS_07_09.jpg)'
- en: We're going to use the Node library at [https://github.com/mikedeboer/node-github](https://github.com/mikedeboer/node-github)
    to access GitHub. We'll use this package to create hooks on GitHub using the access
    token you've just created.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用位于 [https://github.com/mikedeboer/node-github](https://github.com/mikedeboer/node-github)
    的 Node 库来访问 GitHub。我们将使用此包使用你刚刚创建的访问令牌在 GitHub 上创建钩子。
- en: 'Once you have an access token, creating a webhook is easy:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了访问令牌，创建 webhook 就很容易了：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Autopilot performs this on startup, removing the need for you to manually create
    a hook.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Autopilot 在启动时执行此操作，无需你手动创建钩子。
- en: Now, we are listening for changes. As we saw previously, GitHub will deliver
    a payload indicating what has been added, what has been deleted, and what has
    changed. The next step for the autopilot system is to integrate these changes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在监听更改。正如我们之前看到的，GitHub 将发送一个有效载荷，指示已添加的内容、已删除的内容以及已更改的内容。autopilot 系统的下一步是整合这些更改。
- en: It is important to remember that, when you use webhooks, you do not have control
    over how often GitHub will send changesets—if more than one person on your team
    can push, there is no predicting when those pushes will happen. The autopilot
    system uses Redis to manage a queue of requests, executing them in order. You
    will need to manage multiple changes in a way. For now, let's look at a straightforward
    way to build, test, and integrate changes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，当您使用 webhooks 时，您无法控制 GitHub 发送变更集的频率——如果您的团队中有多个人可以推送，那么这些推送发生的时间是无法预测的。自动飞行系统使用
    Redis 来管理请求队列，按顺序执行它们。您需要以这种方式管理多个更改。现在，让我们看看一种简单的方法来构建、测试和集成更改。
- en: 'In your code bundle, visit `autopilot/swanson/push.js`. This is a process runner
    on which fork has been used by `buildQueue.js` in that same folder. The following
    information is passed to it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码包中，访问 `autopilot/swanson/push.js`。这是在同一文件夹中 `buildQueue.js` 使用了分叉的过程运行器。以下信息传递给它：
- en: The URL of the GitHub repository that we will clone
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将要克隆的 GitHub 仓库的 URL
- en: The directory to clone that repository into (`<temp directory>`/`<commit hash>`)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将该仓库克隆到的目录（`<临时目录>`/`<提交哈希>`）
- en: The changeset
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更集
- en: The location of the production repository that will be changed
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要更改的生产仓库的位置
- en: Go ahead and read through the code. Using a few shell scripts, we will clone
    the changed repository and build it using the same commands you're used to—`npm
    install`, `npm test`, and so on. If the application builds without errors, we
    need only run through the changeset and replace the old files with the changed
    files.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，先阅读一下代码。使用几个 shell 脚本，我们将克隆更改后的仓库，并使用您熟悉的相同命令构建它——`npm install`、`npm test`
    等等。如果应用程序构建无误，我们只需运行变更集，并用更改后的文件替换旧文件。
- en: The final step is to restart our production server so that the changes reach
    our users. Here is where the real power of PM2 comes into play.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是重启我们的生产服务器，以便更改能够到达我们的用户。这正是 PM2 真正发挥其强大功能的地方。
- en: When the autopilot system is run in production, PM2 creates a cluster of servers
    (similar to the Node `cluster` module). This is important as it allows us to restart
    the production server incrementally. As we restart one server node in the cluster
    with the newly pushed content, the other clusters continue to serve old content.
    This is essential to keeping a zero-downtime production running.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动飞行系统在生产环境中运行时，PM2 会创建一个服务器集群（类似于 Node 的 `cluster` 模块）。这很重要，因为它允许我们逐步重启生产服务器。当我们使用新推送的内容重启集群中的一个服务器节点时，其他节点继续服务旧内容。这对于保持零停机时间生产至关重要。
- en: Hopefully, the autopilot implementation will give you a few ideas on how to
    improve this process and customize it to your own needs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 希望自动飞行实现能给你一些如何改进此过程并定制到您自己需求的灵感。
- en: Synchronizing local and deployed builds
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步本地和部署的构建
- en: One of the most important (and often difficult) parts of the deployment process
    is ensuring that the environment an application is being developed, built, and
    tested within perfectly simulates the environment that application will be deployed
    into. In this section, you'll learn how to emulate, or virtualize, the environment
    your deployed application will run within using Vagrant. After demonstrating how
    this setup can simplify your *local* development process, we'll use Ansible to
    provision a remote instance on DigitalOcean.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 部署过程中最重要（并且常常是困难）的部分之一是确保应用程序开发、构建和测试的环境完美地模拟了应用程序将要部署到的环境。在本节中，您将学习如何使用 Vagrant
    模拟或虚拟化您的部署应用程序将运行的环境。在演示了这种设置如何简化您的 *本地* 开发过程之后，我们将使用 Ansible 在 DigitalOcean 上配置一个远程实例。
- en: Developing locally with Vagrant
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Vagrant 在本地开发
- en: For a long while, developers would work directly on running servers or cobble
    together their own version of the production environment locally, often writing
    ad hoc scripts and tools to smoothen their development process. This is no longer
    necessary in a world of virtual machines. In this section, we will learn how to
    use Vagrant to emulate a production environment within your development environment,
    advantageously giving you a realistic *box* to work on testing code for production
    and isolating your development process from your local machine processes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，开发者会直接在运行的服务器上工作，或者在自己的本地环境中拼凑生产环境的版本，通常编写临时的脚本和工具来简化他们的开发过程。在虚拟机时代，这不再是必要的。在本节中，我们将学习如何使用
    Vagrant 在开发环境中模拟生产环境，这为你提供了一个现实中的 *虚拟机* 来测试生产代码，并使你的开发过程与本地机器过程隔离开。
- en: By definition, Vagrant is used to create a virtual box emulating a production
    environment. So, we need to install Vagrant, a virtual machine, and a machine
    image. Finally, we'll need to write the configuration and provisioning scripts
    for our environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，Vagrant 用于创建一个模拟生产环境的虚拟机。因此，我们需要安装 Vagrant、虚拟机和机器镜像。最后，我们还需要为我们的环境编写配置和预配置脚本。
- en: Go to [http://www.vagrantup.com/downloads](http://www.vagrantup.com/downloads)
    and install the right Vagrant version for your box. Do the same with VirtualBox
    here at [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [http://www.vagrantup.com/downloads](http://www.vagrantup.com/downloads)
    安装适合你的虚拟机的正确 Vagrant 版本。同样，在 [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)
    这里安装 VirtualBox。
- en: 'You now need to add a box to run. For this example, we''re going to use Centos
    7.0, but you can choose whichever you''d prefer. Create a new folder for this
    project, enter it, and run the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要添加一个虚拟机来运行。在这个例子中，我们将使用 Centos 7.0，但你可以选择你喜欢的任何版本。为这个项目创建一个新的文件夹，进入它，并运行以下命令：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Usefully, the creators of Vagrant, HashiCorp, provide a search service for Vagrant
    boxes at [https://atlas.hashicorp.com/boxes/search](https://atlas.hashicorp.com/boxes/search).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的是，Vagrant 的创建者 HashiCorp 提供了一个 Vagrant 虚拟机搜索服务，请访问 [https://atlas.hashicorp.com/boxes/search](https://atlas.hashicorp.com/boxes/search)。
- en: You will be prompted to choose your virtual environment provider—select `virtualbox`.
    All relevant files and machines will now be downloaded. Note that these boxes
    are very large and may take time to download.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示选择你的虚拟环境提供商——选择 `virtualbox`。所有相关文件和机器现在将被下载。请注意，这些虚拟机非常大，可能需要一些时间来下载。
- en: 'You''ll now create a configuration file for Vagrant called `Vagrantfile`. As
    with npm, the `init` command quickly sets up a base file. Additionally, we''ll
    need to inform Vagrant of the box we''ll be using:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将创建一个名为 `Vagrantfile` 的 Vagrant 配置文件。与 npm 类似，`init` 命令会快速设置一个基础文件。此外，我们还需要通知
    Vagrant 我们将使用的虚拟机：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Vagrantfile is written in Ruby and defines the Vagrant environment. Open it
    up now and scan it. There is a lot of commentary, and it makes a useful read.
    Note the `config.vm.box = "chef/centos-7.0"` line, which was inserted during the
    initialization process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrantfile 使用 Ruby 编写，并定义了 Vagrant 环境。现在打开它并扫描它。里面有很多注释，读起来很有用。注意初始化过程中插入的
    `config.vm.box = "chef/centos-7.0"` 这一行。
- en: 'Now you can start Vagrant:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始使用 Vagrant：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If everything went as expected, your box has been booted within Virtualbox.
    To confirm that your box is running, use the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切如预期进行，你的虚拟机已经在 Virtualbox 中启动。为了确认你的虚拟机正在运行，请使用以下代码：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you see a prompt, you've just set up a virtual machine. You'll see that you
    are in the typical home directory of a CentOS environment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个提示，那么你刚刚设置了一个虚拟机。你会看到你处于 CentOS 环境的典型家目录中。
- en: To destroy your box, run `vagrant destroy`. This deletes the virtual machine
    by cleaning up captured resources. However, the next `vagrant up` command will
    need to do a lot of work to rebuild. If you simply want to shut down your machine,
    use `vagrant halt`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要销毁你的虚拟机，运行 `vagrant destroy`。这将通过清理捕获的资源来删除虚拟机。然而，下一个 `vagrant up` 命令将需要做很多工作来重建。如果你只是想关闭你的机器，请使用
    `vagrant halt`。
- en: Vagrant is useful as a virtualized, production-like environment for developers
    to work within. To that end, it must be configured to emulate a production environment.
    In other words, your box must be provisioned by telling Vagrant how it should
    be configured and what software should be installed whenever `vagrant up` is run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant作为一个虚拟化、类似生产环境的开发环境非常有用。为此，它必须配置为模拟生产环境。换句话说，你的box必须通过告诉Vagrant如何配置以及每次运行`vagrant
    up`时应安装什么软件来进行配置。
- en: 'One strategy for provisioning is to create a shell script that configures our
    server directly and point the Vagrant provisioning process to that script. Add
    the following line to Vagrantfile:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器的一种策略是创建一个shell脚本，直接配置我们的服务器，并将Vagrant配置过程指向该脚本。在Vagrantfile中添加以下行：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, create that file with the following contents in the folder hosting Vagrantfile:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在托管Vagrantfile的文件夹中创建一个包含以下内容的文件：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Destroy any running Vagrant boxes. Run Vagrant again, and you will notice in
    the output the execution of the commands in our provisioning shell script.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁任何正在运行的Vagrant boxes。再次运行Vagrant，你会在输出中注意到我们的配置shell脚本中的命令执行。
- en: 'When this has been completed, enter your Vagrant box as the root (Vagrant boxes
    are automatically assigned the root password "vagrant"):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，以root身份进入你的Vagrant box（Vagrant boxes会自动分配root密码"vagrant"）：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will see that Node v0.12.x is installed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到已经安装了Node v0.12.x：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It''s standard to allow password-less sudo for the *Vagrant* user. Run `visudo`
    and add the following line to the `sudoers` configuration file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 允许*Vagrant*用户无密码sudo是标准做法。运行`visudo`并在`sudoers`配置文件中添加以下行：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Typically, when you are developing applications, you'll be modifying files in
    a project directory. You might bind a directory in your Vagrant box to a local
    code editor and develop in that way. Vagrant offers a simpler solution. Within
    your VM, there is a `/vagrant` folder that maps to the folder that Vagrantfile
    exists within, and these two folders are automatically synced. So, if you add
    the `server.js` file to the right folder on your local machine, that file will
    also show up in your VM's `/vagrant` folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你开发应用程序时，你会在项目目录中修改文件。你可能会将Vagrant box中的某个目录绑定到本地代码编辑器，并以此方式开发。Vagrant提供了一个更简单的解决方案。在你的VM中，有一个`/vagrant`文件夹，它映射到Vagrantfile存在的文件夹，这两个文件夹会自动同步。因此，如果你在你的本地机器上的正确文件夹中添加了`server.js`文件，该文件也会出现在VM的`/vagrant`文件夹中。
- en: Go ahead and create a new `test` file either in your local folder or in your
    VM's `/vagrant` folder. You'll see that file synchronized to both locations regardless
    of where it was originally created.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的本地文件夹或VM的/vagrant文件夹中创建一个新的`test`文件。你会发现无论它最初是在哪里创建的，该文件都会同步到这两个位置。
- en: 'Let''s clone our `express-webhook` repository from earlier in this chapter
    into our Vagrant box. Add the following lines to provision.sh:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将本章早些时候的`express-webhook`仓库克隆到我们的Vagrant box中。在provision.sh中添加以下行：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following to Vagrantfile, which will map port `8082` on the Vagrant
    box (a guest port representing the port our hosted application listens on) to
    port `8000` on our host machine:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vagrantfile中添加以下内容，这将把Vagrant box上的端口`8082`（表示托管应用程序监听的端口）映射到主机上的端口`8000`：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we need to restart the Vagrant box (loading this new configuration) and
    re-provision it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要重新启动Vagrant box（加载此新配置）并重新配置：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will take a while as `yum` installs various dependencies. When provisioning
    is complete, you should see this as the last line:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`yum`正在安装各种依赖项，这个过程可能需要一些时间。配置完成后，你应该看到以下内容作为最后一行：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remembering that we bound the guest port `8082` to the host port `8000`, go
    to your browser and navigate to `localhost:8000`. You should see **"Hello World!"**
    displayed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们已将客户端端口`8082`绑定到主机端口`8000`，打开浏览器并导航到`localhost:8000`。你应该会看到**"Hello World!"**显示。
- en: Also note that in our provisioning script, we cloned to the (shared) `/vagrant`
    folder. This means the clone of `express-webhook` should be visible in the current
    folder, which will allow you to work on the more easily accessible codebase, knowing
    it will be automatically synchronized with the version on your Vagrant box.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在我们的配置脚本中，我们克隆到了（共享的）`/vagrant`文件夹。这意味着`express-webhook`的克隆应该可以在当前文件夹中看到，这将允许你更容易地访问代码库，并知道它将与Vagrant
    box上的版本自动同步。
- en: Provisioning with Ansible
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible进行配置
- en: Configuring your machines *by hand*, as we've done previously, doesn't scale
    well. For one, it can be overly difficult to set and manage environment variables.
    Also, writing your own provisioning scripts is error-prone and no longer necessary
    given the existence of provisioning tools, such as Ansible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，手动配置机器并不容易扩展。首先，设置和管理环境变量可能过于困难。此外，编写自己的配置脚本容易出错，并且由于存在配置工具，如Ansible，因此不再必要。
- en: 'With Ansible, we can define server environments using an organized syntax rather
    than ad hoc scripts, making it easier to distribute and modify configurations.
    Let''s recreate the `provision.sh` script developed earlier using Ansible **playbooks**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible，我们可以使用有组织的语法来定义服务器环境，而不是使用临时脚本，这使得配置的分布和修改更加容易。让我们使用Ansible **playbooks**
    重新创建之前开发的 `provision.sh` 脚本：
- en: '*Playbooks are Ansible''s configuration, deployment, and orchestration language.
    They can describe a policy you want your remote systems to enforce or a set of
    steps in a general IT process.*'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Playbooks是Ansible的配置、部署和编排语言。它们可以描述你希望远程系统执行的政策或一般IT流程中的一系列步骤。*'
- en: 'Playbooks are expressed in the **YAML** format (a human-readable data serialization
    language). To start with, we''re going to change Vagrantfile''s provisioner to
    Ansible. First, create the following subdirectories in your Vagrant folder:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks以**YAML**格式（一种人类可读的数据序列化语言）表示。首先，我们将更改Vagrantfile的provisioner为Ansible。首先，在你的Vagrant文件夹中创建以下子目录：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These will be explained as we proceed through the Ansible setup.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将在我们通过Ansible设置的过程中解释。
- en: 'Next, create the following configuration file and name it `ansible.cfg`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建以下配置文件，并将其命名为 `ansible.cfg`：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This indicates that Ansible **roles** can be found in the `/provisioning` folder,
    and that we want to keep a provisioning log in `ansible.log`. Roles are used to
    organize tasks and other functions into reusable files. These will be explained
    shortly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示Ansible **roles** 可以在 `/provisioning` 文件夹中找到，并且我们希望在 `ansible.log` 中保留配置日志。Roles用于将任务和其他功能组织到可重用的文件中。这些将在稍后解释。
- en: 'Modify the `config.vm.provision` definition to the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `config.vm.provision` 定义修改为以下内容：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This tells Vagrant to defer to Ansible for provisioning instructions, and that
    we want the provisioning process to be verbose—we want to get feedback when the
    provisioning step is running. Also, we can see that the playbook definition, `provisioning/server.yml`,
    is expected to exist. Create that file now:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Vagrant在配置指令上依赖于Ansible，并且我们希望配置过程是详细的——我们希望在配置步骤运行时获得反馈。此外，我们可以看到预期的playbook定义，`provisioning/server.yml`，是存在的。现在创建该文件：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Playbooks can contain very complex rules. This simple file indicates that we
    are going to provision all available hosts using a single role called `common`.
    In more complex deployments, an inventory of IP addresses could be set under `hosts`,
    but, here, we just want to use a general setting for our one server. Additionally,
    the provisioning step will be provided with certain environment variables following
    the forms `env.user`, `nvm.node_version`, and so on. These variables will come
    into play when we define the `common` role, which will be to provision our Vagrant
    server with the programs necessary to build, clone, and deploy `express-webhook`.
    Finally, we assert that Ansible should run as an administrator (`sudo`) by default—this
    is necessary for the `yum` package manager on CentOS.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks可以包含非常复杂的规则。此简单文件表示我们将使用名为 `common` 的单个角色来配置所有可用的主机。在更复杂的部署中，可以在 `hosts`
    下设置IP地址列表，但在这里，我们只想为我们的单个服务器使用通用设置。此外，配置步骤将提供某些环境变量，形式为 `env.user`、`nvm.node_version`
    等。这些变量将在我们定义 `common` 角色时发挥作用，该角色将为我们的Vagrant服务器提供构建、克隆和部署 `express-webhook` 所需的程序。最后，我们断言Ansible默认应以管理员（`sudo`）身份运行——这是在CentOS上运行`yum`包管理器所必需的。
- en: We're now ready to define the `common` role. With Ansible, folder structures
    are important and are implied by the playbook. In our case, Ansible expects the
    role location (`./provisioning`, as defined in `ansible.cfg`) to contain the `common`
    folder (reflecting the `common` role given in the playbook), which itself must
    contain a `tasks` folder containing a `main.yml` file. These last two naming conventions
    are specific and required.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义 `common` 角色。在Ansible中，文件夹结构很重要，并且由playbook隐含。在我们的例子中，Ansible期望角色位置（`./provisioning`，如`ansible.cfg`中定义）包含
    `common` 文件夹（反映playbook中给出的`common`角色），该文件夹本身必须包含一个包含`main.yml`文件的`tasks`文件夹。这两个命名约定是特定的，并且是必需的。
- en: 'The final step is creating the `main.yml` file in `provisioning/common/tasks`.
    First, we replicate the `yum` package loaders (see the file in your code bundle
    for the full list):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在 `provisioning/common/tasks` 中创建 `main.yml` 文件。首先，我们复制 `yum` 软件包加载器（请参考代码包中的文件以获取完整列表）：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we see a few benefits of Ansible. A human-readable description of `yum`
    tasks is provided to a looping structure that will install every item in the list.
    Next, we run the nvm installer, which simply executes the auto-installer for nvm:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 Ansible 的几个好处。为 `yum` 任务提供了一个人类可读的描述，并将其提供给循环结构，该结构将安装列表中的每一项。接下来，我们运行
    nvm 安装程序，它只是简单地执行 nvm 的自动安装器：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that, here, we''re overriding the playbook''s `sudo` setting. This can
    be done on a per-task basis, which gives us the freedom to move between different
    permission levels while provisioning. We are also able to execute shell commands
    while at the same time interpolating variables:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们正在覆盖 playbook 的 `sudo` 设置。这可以在每个任务的基础上完成，这给了我们在配置过程中在不同权限级别之间移动的自由。我们还能在执行
    shell 命令的同时插入变量：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Ansible provides extremely useful tools for file manipulation, and we will see
    here a very common one—updating the `.bashrc` file for a user. The `lineinfile`
    directive makes the addition of aliases, among other things, straightforward.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 提供了极其有用的文件操作工具，在这里我们将看到一个非常常见的例子——更新用户的 `.bashrc` 文件。`lineinfile` 指令使得添加别名等操作变得简单直接。
- en: The remainder of the commands follow a similar pattern to implement, in a structured
    way, the provisioning directives we need for our server. All the files you will
    need are in your code bundle in the `vagrant/with_ansible` folder. Once you have
    them installed, run `vagrant up` to see Ansible in action.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的命令遵循类似的模式，以结构化的方式实现我们服务器所需的配置指令。所有你需要用到的文件都在你的代码包中的 `vagrant/with_ansible`
    文件夹里。一旦安装完毕，运行 `vagrant up` 就可以看到 Ansible 的实际应用。
- en: 'One of the strengths of Ansible is the way it handles contexts. When you start
    your Vagrant build, you will notice that Ansible gathers facts, as shown in the
    following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的一个优势在于它处理上下文的方式。当你开始你的 Vagrant 构建，你会注意到 Ansible 会收集事实，如下面的截图所示：
- en: '![Provisioning with Ansible](img/1403OS_07_06.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Ansible 进行配置](img/1403OS_07_06.jpg)'
- en: Simply put, Ansible analyzes the context it is working in and only executes
    what is necessary to execute. If one of your tasks has already been run, the next
    time you try `vagrant provision`, that task will not run again. This is *not*
    true for shell scripts! In this way, editing playbooks and reprovisioning does
    not consume time redundantly changing what has already been changed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Ansible 分析其工作上下文，并且只执行必要的操作。如果你的某个任务已经运行过，那么下次你尝试 `vagrant provision` 时，该任务将不会再次运行。这对于
    shell 脚本来说可不是这样！通过这种方式，编辑 playbooks 和重新配置不会重复改变已经改变的内容，从而节省时间。
- en: Ansible is a powerful tool that can be used for provisioning and much more complex
    deployment tasks. One of its great strengths is that it can run remotely—unlike
    most other tools, Ansible uses SSH to connect to remote servers and run operations.
    There is no need to install it on your production boxes. You are encouraged to
    browse the Ansible documentation at [http://docs.ansible.com/index.html](http://docs.ansible.com/index.html)
    to learn more.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个强大的工具，可用于配置和更多复杂的部署任务。它的一大优势是可以在远程运行——与大多数其他工具不同，Ansible 使用 SSH 连接到远程服务器并执行操作。你不需要在生产服务器上安装它。我们鼓励你浏览
    Ansible 文档 [http://docs.ansible.com/index.html](http://docs.ansible.com/index.html)
    以获取更多信息。
- en: Integrating, delivering, and deploying
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成、交付和部署
- en: In this chapter, we've been looking at using deployment systems that encourage
    agile development, generally facilitating safe delivery into production environments
    of code updates in near real time. Variations in how deployments can be structured
    and/or understood, which usually depend on factors such as team size and management
    structure, are common. A brief summary of each of the three typical categories,
    **continuous integration**, **continuous delivery**, and **continuous deployment**,
    will be provided in the following sections. Finally, we'll set up a build/deploy
    system for a Node application using Jenkins, a CI server, configured to automatically
    deploy changes to a Heroku server.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在探讨使用鼓励敏捷开发的部署系统，通常可以促进代码更新在近乎实时的情况下安全地交付到生产环境。部署的结构和/或理解方式的差异很常见，这通常取决于团队规模和管理结构等因素。以下几节将简要介绍三个典型类别，**持续集成**、**持续交付**和**持续部署**。最后，我们将使用Jenkins，一个CI服务器，为Node应用程序设置一个构建/部署系统，配置为自动将更改部署到Heroku服务器。
- en: Continuous integration
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous integration is the process of merging changes into a master branch
    continuously (typically, several times a day). The goal of CI is to make errors
    impatient and noisy, arriving early and failing loudly, rather than emerging later
    from much larger and more complex **bulk** merges comprising several days or weeks
    of work. Unit tests are typically run here. Note that an updated integration branch
    is not necessarily continuously deployed, though it may be. The goal is to keep
    a master branch fresh, current, and ready to be deployed when necessary.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是将更改持续合并到主分支的过程（通常每天几次）。CI的目标是让错误变得不耐烦和嘈杂，尽早出现并大声失败，而不是从几天或几周的工作中出现的更大、更复杂的**批量**合并中后期出现。通常在这里运行单元测试。请注意，更新的集成分支不一定持续部署，尽管它可能如此。目标是保持主分支新鲜、当前，并在必要时准备好部署。
- en: Continuous delivery
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续交付
- en: '"Delivery" is the key word here. In environments where all changes must be
    tested/vetted by a quality assurance team or some other group of stakeholders
    prior to being released, changes are delivered and reviewed as they are proposed.
    While continuous delivery does not preclude delivery into production, the general
    goal is to deliver new code where it can be subjected to further functional tests,
    tests of business logic, and so on, prior to it reaching real customers.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: “交付”是这里的关键词。在所有更改都必须在发布之前由质量保证团队或其他利益相关者测试/审查的环境中，“交付”和“审查”是在提出更改时进行的。虽然持续交付不排除将代码交付到生产环境，但一般目标是在代码到达真实客户之前，将其交付到可以进行进一步功能测试、业务逻辑测试等的地方。
- en: This test environment should be equivalent to the production environment and,
    when tests pass, there should be confidence that the changes will also be deployable
    to production. Because this stage is typically understood as preceding deployment,
    it is often described as the *staging environment*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试环境应与生产环境相当，并且当测试通过时，应有一定的信心认为这些更改也可以部署到生产环境中。因为这个阶段通常被视为部署之前，所以它通常被称为*预部署环境*。
- en: Staged changes are normally deployable in one step, a single system command,
    or the click of a button in a GUI.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段性更改通常可以一步部署，一个系统命令，或GUI中的一个按钮点击。
- en: Continuous deployment
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续部署
- en: Continuous deployment is the aggressive, optimistic strategy of building your
    application in a way such that it can be released into production at any time,
    typically as soon as it passes certain automated tests. This strategy generally
    leads to many releases per day and requires that the validation pipeline, which
    changes move through, is as close to production-like as possible.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署是一种积极、乐观的策略，以构建应用程序的方式使其可以随时发布到生产环境，通常是在通过某些自动化测试后立即发布。这种策略通常导致每天发布许多版本，并且需要验证管道尽可能接近生产环境。
- en: 'Because there is limited (or nonexistent) oversight of the code being released,
    continuous post-release inspection of application performance is normal. That
    is, trust but verify: push changes into production after automated testing, but
    regularly check whether your visitor counts are dropping, response times are rising,
    or other metrics are behaving abnormally.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对发布代码的监督有限（或不存在），对应用程序性能的持续发布后检查是正常的。也就是说，信任但核实：在自动化测试后推送到生产环境，但定期检查您的访问量是否下降、响应时间是否上升，或其他指标是否异常。
- en: While similar to continuous delivery, the two should not be confused.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与持续交付类似，但这两者不应混淆。
- en: Building and deploying with Jenkins
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Jenkins 构建和部署
- en: You've learned how to use GitHub webhooks to trigger a build process whenever
    new code is pushed to a repository. From pulling and testing a changed repository
    to notifying a chat server that a new build has occurred, Jenkins helps you to
    trigger deployment workflows. As your deployment needs become more complex than
    simply testing a single branch, the benefits of a more powerful CI tool become
    apparent. Jenkins provides tools to manage build permissions, task scheduling,
    triggering deploys, displaying build logs, and more. Let's deploy an application
    using Jenkins.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何使用 GitHub webhooks 在代码推送到存储库时触发构建过程。从拉取和测试更改后的存储库到通知聊天服务器新的构建已发生，Jenkins
    帮助您触发部署工作流程。当您的部署需求比简单地测试单个分支更复杂时，更强大的 CI 工具的好处就显现出来了。Jenkins 提供了管理构建权限、任务调度、触发部署、显示构建日志等工具。让我们使用
    Jenkins 部署一个应用程序。
- en: 'To install Jenkins, run the installer for your environment that can be found
    at [http://jenkins-ci.org/](http://jenkins-ci.org/). There are also services that
    allow you to install Jenkins in the "cloud", but we''re going to build a local
    service. Upon successful installation, a browser will open up with the Jenkins
    "home page" UI, as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Jenkins，运行您环境中的安装程序，该程序可在 [http://jenkins-ci.org/](http://jenkins-ci.org/)
    找到。还有允许您在“云”中安装 Jenkins 的服务，但我们将构建一个本地服务。安装成功后，浏览器将打开并显示 Jenkins 的“主页”UI，如下所示：
- en: '![Building and deploying with Jenkins](img/1403OS_07_07.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Jenkins 构建和部署](img/1403OS_07_07.jpg)'
- en: You will use this Jenkins **dashboard** often as you manage builds.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理构建时，您将经常使用这个 Jenkins **仪表板**。
- en: 'Note that Jenkins will, by default, run on port `8080`. You will, as with webhooks,
    need to map this location to a web-accessible URL directly, via proxy, via forwarding,
    or in some other way. Move to **Manage Jenkins** | **Configure System** and find
    the **Jenkins Location** section. Add the Jenkins URL, as shown in the following
    screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Jenkins 默认将在端口 `8080` 上运行。您需要像处理 webhooks 一样，直接通过代理、转发或其他方式将此位置映射到一个可访问的
    Web URL。转到 **管理 Jenkins** | **配置系统** 并找到 **Jenkins 位置** 部分。添加 Jenkins URL，如下面的截图所示：
- en: '![Building and deploying with Jenkins](img/1403OS_07_08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Jenkins 构建和部署](img/1403OS_07_08.jpg)'
- en: If you are running Jenkins on `localhost`, jump back to earlier in this chapter
    when we discussed using forwarding services, such as [http://localtunnel.me/](http://localtunnel.me/).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 `localhost` 上运行 Jenkins，请回到本章前面我们讨论使用转发服务（如 [http://localtunnel.me/](http://localtunnel.me/)）的部分。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may be warned about an unsecured Jenkins instance. This is a valid complaint!
    While we will not set up authentication, you should do so in any real production
    environment. It isn't hard. Visit **Manage Jenkins** | **Configure Global Security**
    to do so and/or visit [https://wiki.jenkins-ci.org/display/JENKINS/Securing+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Securing+Jenkins).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会收到关于不安全 Jenkins 实例的警告。这是一个有效的投诉！虽然我们不会设置身份验证，但在任何实际的生产环境中，您都应该这样做。这并不难。访问
    **管理 Jenkins** | **配置全局安全** 来进行设置，或访问 [https://wiki.jenkins-ci.org/display/JENKINS/Securing+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Securing+Jenkins)。
- en: The next thing to do is configure Jenkins to work with Node.js and GitHub. From
    the dashboard, navigate to **Manage Jenkins** | **Manage Plugins** | **Available**.
    You should see a list of available plugins, from which you will search for and
    install *NodeJS Plugin* and *GitHub Plugin*. This may take a while as these plugins,
    and their dependencies, are installed. If any of the installs prompt you to restart
    Jenkins, you will find instructions on how to do that in the installs list provided
    further on in this section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置 Jenkins 以与 Node.js 和 GitHub 一起工作。从仪表板导航到 **管理 Jenkins** | **管理插件** |
    **可用**。您应该会看到一个可用插件的列表，您将从中搜索并安装 *NodeJS 插件* 和 *GitHub 插件*。由于这些插件及其依赖项需要安装，这可能需要一些时间。如果任何安装提示您重新启动
    Jenkins，您将在本节稍后提供的安装列表中找到如何操作的说明。
- en: The key integration that we'll have to do is with GitHub. In a new browser window,
    visit your GitHub account and generate a new access token.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须完成的关键集成是与 GitHub 的集成。在一个新的浏览器窗口中，访问您的 GitHub 账户并生成一个新的访问令牌。
- en: 'Copy the generated key. You will now give Jenkins this access token so that
    it can perform operations on GitHub on your behalf, in particular around webhooks.
    Return to **Manage Jenkins** | **Configure**, and add this OAuth token and your
    user information to the **GitHub Web Hook** section, as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 复制生成的密钥。现在，您将向Jenkins提供这个访问令牌，以便它可以代表您在GitHub上执行操作，特别是在webhooks方面。返回到**管理Jenkins**
    | **配置**，并将此OAuth令牌和您的用户信息添加到**GitHub Web Hook**部分，如下所示：
- en: '![Building and deploying with Jenkins](img/1403OS_07_10.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jenkins构建和部署](img/1403OS_07_10.jpg)'
- en: Run **Test Credential** to ensure that Jenkins can connect to GitHub using the
    token you've provided.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**测试凭据**以确保Jenkins可以使用您提供的令牌连接到GitHub。
- en: Finally, we need to provide our GitHub credentials to Jenkins so that it can
    pull our repository when changes happen. Navigate to **Credentials** and click
    on **Global credentials**. Select **Username with Password** and add your credentials,
    which will ensure that you give these credentials a useful name (you'll need to
    refer to these credentials later).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要向Jenkins提供我们的GitHub凭据，以便在发生更改时它可以拉取我们的仓库。导航到**凭据**并点击**全局凭据**。选择**用户名和密码**并添加您的凭据，这将确保您为这些凭据提供了一个有用的名称（您稍后需要引用这些凭据）。
- en: Because you have already built your own webhook-powered CI system, it may already
    be apparent to you why Jenkins is being configured in this way. In the end, we
    are configuring Jenkins to respond to push events on a GitHub repository, pull
    the changed repository, and automatically build it. To that end, we will need
    to provision Jenkins so that it is configured with Node and can, therefore, build
    Node repositories.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您已经构建了自己的由webhook驱动的CI系统，所以您可能已经很明显为什么Jenkins要以这种方式配置。最终，我们正在配置Jenkins以响应GitHub仓库的推送事件，拉取更改后的仓库，并自动构建它。为此，我们需要配置Jenkins，使其配置了Node节点，因此可以构建Node仓库。
- en: 'Navigate to **Configure System** and add a NodeJS installation, as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到**配置系统**并添加一个NodeJS安装，如下所示：
- en: '![Building and deploying with Jenkins](img/1403OS_07_11.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jenkins构建和部署](img/1403OS_07_11.jpg)'
- en: You will now configure the Node environment that Jenkins will use. You should
    match that environment with the environment your production servers will run in.
    Click on **Add NodeJS** and follow the instructions. You can select **Install
    automatically** and, when presented with installer options, select **Install from
    nodejs.org**. Make sure that you add any global npm packages you need—tools such
    as gulp, pm2, mocha, and others that are necessary to your build environment.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将配置Jenkins将使用的Node环境。您应该将此环境与您的生产服务器运行的环境相匹配。点击**添加NodeJS**并按照说明操作。您可以选择**自动安装**，并在提供安装选项时选择**从nodejs.org安装**。确保添加您需要的任何全局npm包——例如gulp、pm2、mocha和其他对您的构建环境必要的工具。
- en: 'If you would rather manage the install yourself, just use the "Run Shell command"
    option and something like the following command, adding any global installs you''d
    like:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意自己管理安装，只需使用“运行Shell命令”选项，并使用以下类似命令，添加你想要的全局安装：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember to save your changes!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 记得保存您的更改！
- en: 'We''re almost done configuring Jenkins for CI. The last step is to create a
    build project. Navigate to **New Item**, add a useful item name in the **Item
    name** field, select **Freestyle project**, and click on **OK**. Now, navigate
    to **Source Code Management**, select **Git**, add a GitHub repository name, select
    the credentials to access that repository, click on **Save**, and you''ll be ready
    to build, as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了Jenkins CI的配置。最后一步是创建一个构建项目。导航到**新建项目**，在**项目名称**字段中添加一个有用的项目名称，选择**Freestyle项目**，然后点击**确定**。现在，导航到**源代码管理**，选择**Git**，添加GitHub仓库名称，选择访问该仓库的凭据，点击**保存**，然后您就可以开始构建，如下面的截图所示：
- en: '![Building and deploying with Jenkins](img/1403OS_07_12.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jenkins构建和部署](img/1403OS_07_12.jpg)'
- en: 'Return to the Jenkins dashboard, and you''ll see your build project listed.
    Click on the name, and select **Build Now** from the menu on the left-hand side.
    If all goes well, you''ll see a build history table quickly populate, as shown
    here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Jenkins仪表板，你会看到你的构建项目列出来。点击项目名称，从左侧菜单中选择**立即构建**。如果一切顺利，你会看到构建历史表快速填充，如下所示：
- en: '![Building and deploying with Jenkins](img/1403OS_07_13.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jenkins构建和部署](img/1403OS_07_13.jpg)'
- en: Click on the number and, if all is well, you'll see information on your build,
    indicating *no changes* (you have just pulled off a masterstroke), some information
    about the Git revision number, and so on. Now, the real test—make a change to
    your GitHub repository, either by pushing a change or simply editing a file using
    GitHub's editing tools. If you return to the dashboard, you will see that Jenkins
    has added a new build to **Build Queue**; shortly the build will complete, and
    you'll see the changes you've just made listed in your project's build history.
    You've just created a CI environment for your project!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 点击数字，如果一切顺利，您将看到有关构建的信息，表明 *没有更改*（您刚刚完成了一项妙手回春），一些关于 Git 修订版本的详细信息，等等。现在，真正的测试——对您的
    GitHub 仓库进行更改，无论是通过推送更改还是简单地使用 GitHub 的编辑工具编辑文件。如果您返回到仪表板，您将看到 Jenkins 已将一个新的构建添加到
    **构建队列**；不久构建将完成，您将在项目的构建历史中看到您刚刚所做的更改。您已经为您的项目创建了一个 CI 环境！
- en: Now, we need to deploy. We'll use Heroku to deploy, but feel free to try your
    provider of choice—as long as it *speaks* Git, Jenkins will be able to push your
    repository.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要进行部署。我们将使用 Heroku 进行部署，但请随意尝试您选择的任何提供商——只要它 *支持* Git，Jenkins 就能够推送您的仓库。
- en: Deploying to Heroku
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到 Heroku
- en: 'It might be useful to return to [Chapter 2](ch02.html "Chapter 2. Installing
    and Virtualizing Node Servers"), *Installing and Virtualizing Node Servers*, and
    refresh your memory about how to build on Heroku. At the very least, you will
    need to install Heroku Toolbelt and authenticate. Once you are connected to Heroku
    via the toolbelt, clone the `express-webhook` repository we created earlier and
    enter that folder. Now, run `heroku create` to build a machine on Heroku. You
    should receive both a URL and a Git endpoint resembling the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 [第 2 章](ch02.html "第 2 章。安装和虚拟化 Node 服务器")，*安装和虚拟化 Node 服务器*，并刷新您对如何在 Heroku
    上构建的记忆。至少，您需要安装 Heroku Toolbelt 并进行身份验证。通过工具带连接到 Heroku 后，克隆我们之前创建的 `express-webhook`
    仓库，并进入该文件夹。现在，运行 `heroku create` 在 Heroku 上构建一个机器。您应该会收到一个 URL 和一个类似于以下内容的 Git
    端点：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, it is time to push something for that server to run. Execute the following
    command to push the `express-webhook` application to Heroku:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候向服务器推送一些内容以便其运行了。执行以下命令将 `express-webhook` 应用程序推送到 Heroku：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The express-webhook application is now deployed to Heroku. Heroku will have
    automatically built and started the application. Go ahead and visit the URL we
    received before in a browser. The next step is to use Jenkins to automatically
    deploy to Heroku whenever you make changes to the application repository.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`express-webhook` 应用程序现在已部署到 Heroku。Heroku 将自动构建并启动应用程序。请访问我们之前收到的 URL，在浏览器中查看。下一步是使用
    Jenkins 在您对应用程序仓库进行更改时自动将其部署到 Heroku。'
- en: 'You are now connected to two Git repositories, which you can see by running
    `git remote -v`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在连接了两个 Git 仓库，您可以通过运行 `git remote -v` 来查看：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `origin` URL is our GitHub repository, and `heroku` represents the Git repository
    maintained by Heroku. We'll synchronize these two via Jenkins.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`origin` URL 是我们的 GitHub 仓库，而 `heroku` 代表 Heroku 维护的 Git 仓库。我们将通过 Jenkins 同步这两个仓库。'
- en: 'As Jenkins will eventually be doing the pushing for us, we need to give it
    permission to access your Heroku box. What we''re going to do is generate a key
    pair for the `jenkins` user and associate these local SSH keys with Heroku, allowing
    Jenkins to perform pushes and so on. Log in as the `jenkins` user, and run the
    following two commands:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Jenkins 最终将为我们进行推送，我们需要授予它访问您的 Heroku 机器的权限。我们将为 `jenkins` 用户生成一个密钥对，并将这些本地
    SSH 密钥与 Heroku 关联起来，允许 Jenkins 执行推送等操作。以 `jenkins` 用户身份登录，并运行以下两个命令：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Jenkins can now authenticate with Heroku. All that is left to do is inform Jenkins
    about the Heroku repository and to instruct Jenkins to deploy to Heroku whenever
    it is informed, via the webhook we configured earlier, that changes have been
    made.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 现在可以与 Heroku 进行身份验证。剩下的工作就是通知 Jenkins 关于 Heroku 仓库的信息，并指导 Jenkins 在通过之前配置的
    webhook 通知有更改时部署到 Heroku。
- en: 'Return to your Jenkins project, click on **Configure**, and add the Heroku
    Git endpoint as another repository to the **Source Code Management** section by
    clicking on **Add Repository**. Fill in the **Repository URL** field to match
    the one you received earlier:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 返回您的 Jenkins 项目，点击 **配置**，然后通过点击 **添加仓库** 将 Heroku Git 端点作为另一个仓库添加到 **源代码管理**
    部分。填写 **仓库 URL** 字段以匹配您之前收到的：
- en: '![Deploying to Heroku](img/1403OS_07_14.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![部署到 Heroku](img/1403OS_07_14.jpg)'
- en: Note that you will *not* fill in **Credentials** as we've earlier linked Jenkins
    to Heroku using SSH keys.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你将 *不* 填写 **凭据**，因为我们之前已经使用 SSH 密钥将 Jenkins 连接到 Heroku。
- en: 'Now, click on the "Advanced" button underneath the new repository, and give
    it a name—you''ll need this for the next step. Here we use **heroku**, but it
    can be anything:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击新仓库下方的“高级”按钮，给它一个名字——你将在下一步需要它。这里我们使用 **heroku**，但它可以是任何名字：
- en: '![Deploying to Heroku](img/1403OS_07_15.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![部署到 Heroku](img/1403OS_07_15.jpg)'
- en: Now, Jenkins has been made aware of our GitHub repo and our Heroku repo. The
    final step is to configure Jenkins to push GitHub changes to Heroku.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Jenkins 已经知道我们的 GitHub 仓库和 Heroku 仓库。最后一步是配置 Jenkins 将 GitHub 的更改推送到 Heroku。
- en: 'Scroll down to **Post-build Actions** in your Jenkins project. Click on **Add
    post-build action** and select **Git publisher**. Fill out the form provided exactly
    as shown here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到 Jenkins 项目的“构建后操作”。点击“添加构建后操作”，选择“Git 发布者”。按照此处所示填写提供的表格：
- en: '![Deploying to Heroku](img/1403OS_07_16.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![部署到 Heroku](img/1403OS_07_16.jpg)'
- en: We are telling Jenkins to push to the `master` branch of the `express-webhook`
    GitHub repository to `heroku` after each successful build. This is the deploy
    step. Save your changes—you're done!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在告诉 Jenkins 在每次成功构建后将 `express-webhook` GitHub 仓库的 `master` 分支推送到 `heroku`。这是部署步骤。保存你的更改——你已经完成了！
- en: 'To test that everything is working, modify the default route of `server.js`
    in your local clone of `express-webhook` such that it produces a different message,
    and push that change to GitHub. If you return to the Jenkins dashboard, you will
    soon see something like the following progress indicator on the build status of
    your project:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一切是否正常工作，修改你本地克隆的 `express-webhook` 中的 `server.js` 默认路由，使其产生不同的消息，并将此更改推送到
    GitHub。如果你返回到 Jenkins 控制台，你将很快在项目的构建状态上看到以下进度指示器：
- en: '![Deploying to Heroku](img/1403OS_07_17.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![部署到 Heroku](img/1403OS_07_17.jpg)'
- en: If all goes well, your project will be listed on the dashboard as having been
    successfully built. If you refresh your Heroku URL, you will also see the changes
    you've made. Congratulations on successfully setting up continuous deployment
    for your project!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你的项目将在仪表板上列出，表明它已成功构建。如果你刷新你的 Heroku URL，你也将看到你所做的更改。恭喜你成功为你的项目设置了持续部署！
- en: Now that you have the structure set up for CI and deployment, start adding tests
    and other build steps and run them either in your Node environment or using the
    many Jenkins tools available to you. Happy building!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为 CI 和部署设置了结构，开始添加测试和其他构建步骤，并在你的 Node 环境中或使用你可用的许多 Jenkins 工具中运行它们。祝构建愉快！
- en: Package maintenance
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包维护
- en: JavaScript itself does not provide a native package management system; npm does
    this job for Node applications. A good package management strategy is, therefore,
    a key part of a good deployment strategy.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 本身不提供原生的包管理系统；npm 为 Node 应用程序完成这项工作。因此，良好的包管理策略是良好部署策略的关键部分。
- en: Packages offer the benefit of encapsulation. Running packages are accessible
    only through the API they've exported. This isolation reduces the number of potential
    bugs in a system, thus guarding the core functionality from accidental alteration.
    However, given that (opaque) packages can themselves require other packages as
    dependencies, the full dependency graph of an application can be difficult for
    a developer to easily see. For example, if the functionality of a package you
    have implemented suddenly changes, how do you debug it? Is the error in the package?
    Is it in one of its dependent packages?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 包提供封装的好处。运行中的包只能通过它们导出的 API 访问。这种隔离减少了系统中潜在错误的数量，从而保护核心功能免受意外更改。然而，由于（不透明的）包本身可能需要其他包作为依赖项，一个应用程序的完整依赖图可能对开发者来说难以轻易看到。例如，如果你实现的包的功能突然发生变化，你如何调试它？错误是在包中吗？还是在它的依赖包之一中？
- en: Understanding *what is going on* in your npm dependency graph is essential when
    you are deploying Node applications. In this section, we will look at ways to
    stay up to date on package updates, use Git to manage private packages, track
    the health of an *entire* dependency graph, and look at best practices to set
    version rules in your application's `package.json` file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你部署 Node 应用程序时，理解 *npm 依赖图中的情况* 是至关重要的。在本节中，我们将探讨如何保持包更新的同步，使用 Git 管理私有包，跟踪整个依赖图的健康状况，以及查看在应用程序的
    `package.json` 文件中设置版本规则的最佳实践。
- en: Understanding Semver
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Semver
- en: '**Semantic Versioning** (**Semver**) is simply a set of rules that have been
    proposed to govern how dependencies in a system are declared. Npm enforces these
    rules in its package manager, so understanding how they govern dependency management
    is what will be discussed here.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义版本控制** (**Semver**) 简单来说是一组规则，这些规则被提出以规范系统中依赖项的声明。Npm 在其包管理器中强制执行这些规则，因此理解它们如何管理依赖项将是这里讨论的重点。'
- en: 'Take for example the following npm package file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下 npm 包文件为例：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each dependency is given a version number corresponding to a version in the
    npm repository. Some of these numbers are further modified by tokens, for example,
    a caret (`^`) or a tilde (`~`), as well as version ranges. Let's look at what
    each segment of semantically versioned numbers signify and how various tokens
    are used to modulate those segments.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每个依赖项都有一个与 npm 仓库中的版本相对应的版本号。其中一些数字通过标记进一步修改，例如，一个 caret (`^`) 或一个 tilde (`~`)，以及版本范围。让我们看看语义版本号中的每个部分代表什么，以及如何使用各种标记来调节这些部分。
- en: 'A version number is broken into three segments, which are shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号被分解为三个部分，如下所示：
- en: '![Understanding Semver](img/1403OS_07_18.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![理解 Semver](img/1403OS_07_18.jpg)'
- en: 'Semver concretely describes allowable package version ranges as well as implying
    the current stability or state of a package—whether the package is stable, whether
    it is mature, and so on. The numbering proceeds in order: 1.0.1 precedes 1.0.2,
    which precedes 2.0.0.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Semver 具体描述了允许的包版本范围，并暗示了包的当前稳定性或状态——包是否稳定，是否成熟等。编号按顺序进行：1.0.1 在 1.0.2 之前，1.0.2
    在 2.0.0 之前。
- en: 'The significance of the changes that Semver describes proceeds from left to
    right, where a change in the major version of a package typically describes changes
    that break compatibility with lower versions—2.0 is not compatible with 1.0\.
    According to [semver.org](http://semver.org), you should use version numbers in
    this way:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Semver 描述的变更的重要性从左到右递增，其中包的主版本变更通常描述了与较低版本不兼容的变更——2.0 与 1.0 不兼容。根据 [semver.org](http://semver.org)，你应该这样使用版本号：
- en: '*"Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when
    you make incompatible API changes, MINOR version when you add functionality in
    a backwards-compatible manner, and PATCH version when you make backwards-compatible
    bug fixes."*'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"给定版本号 MAJOR.MINOR.PATCH，当进行不兼容的 API 变更时增加 MAJOR 版本，当以向后兼容的方式添加功能时增加 MINOR
    版本，当进行向后兼容的错误修复时增加 PATCH 版本。"*'
- en: 'Then, Semver allows you to set acceptable range limits on the versions of dependencies
    in your application with an eye toward providing useful indications of the level
    of impact implied by version changes. Some common usage examples are given here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Semver 允许你根据提供有用的影响程度指示，为应用程序中依赖项的版本设置可接受的范围限制。以下是一些常见的使用示例：
- en: '"3" indicates that only the major version (3) must be satisfied, ignoring minor
    or patch values—3.0.0, 3.6.3, and 3.99.99 are all acceptable.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"3" 表示只有主版本（3）必须满足，忽略次要或补丁值——3.0.0、3.6.3 和 3.99.99 都是可接受的。'
- en: '"3.4.5" indicates that *only* that version is acceptable, with no variation.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"3.4.5" 表示只有那个版本是可接受的，没有变化。'
- en: '"<, <=, > and >=" range comparators work as expected in many programming languages
    and can be used to set controlled ranges. >= 3.0.1 <= 3.2.1 accepts 3.0.2 and
    3.1.9 but not 3.0.0 or 3.2.2.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"<, <=, > 和 >=" 范围比较符在许多编程语言中按预期工作，可以用来设置受控范围。>= 3.0.1 <= 3.2.1 接受 3.0.2 和
    3.1.9，但不接受 3.0.0 或 3.2.2。'
- en: 1.3.4 >= 3.0.1 <= 3.2.1 accepts the version range as described in the preceding
    point *or* the 1.3.4 version.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.3.4 >= 3.0.1 <= 3.2.1 接受前面所述的版本范围或 1.3.4 版本。
- en: Being equivalent to >= 0.0.0, "*" indicates that *any* version is acceptable.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相当于 >= 0.0.0 的 "*" 表示任何版本都是可接受的。
- en: Hyphen ranges (-) describe inclusive sets. The hyphen range 1.0.0 - 2.0.0 matches
    any package with a major version of 1.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hyphen 范围 (-) 描述了包含的集合。Hyphen 范围 1.0.0 - 2.0.0 匹配任何主版本为 1 的包。
- en: x-ranges provide a shorthand for minor and patch ranges; 1.2.x is equivalent
    to >= 1.2.0 <= 1.3.0 and 1.x is equivalent to >= 1.0.0 <= 2.0.0.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x-ranges 为小版本和补丁版本提供了一种简写方式；1.2.x 等同于 >= 1.2.0 <= 1.3.0，而 1.x 等同于 >= 1.0.0 <=
    2.0.0。
- en: Tilde(~) ranges allow patch-level changes if a minor version is specified and
    minor-level changes if it is not. ~1.3.2 is equivalent to >= 1.3.2 < 1.4.0, ~1.3
    is equivalent to >= 1.3.0 < 1.4.0, and ~1 is equivalent to >= 1.0.0 < 2.0.0.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tilde (~) 范围允许在指定小版本时进行补丁级别变更，未指定时进行小版本变更。~1.3.2 等同于 >= 1.3.2 < 1.4.0，~1.3 等同于
    >= 1.3.0 < 1.4.0，而 ~1 等同于 >= 1.0.0 < 2.0.0。
- en: Caret(^) ranges allow changes that do not modify the leftmost nonzero digit.
    ^1.2.0 is equivalent to >= 1.2.0 <= 2.0.0, ^0.2.1 is equivalent to >= 0.2.1 <=
    0.3.0, and ^0.0.2 is equivalent to >= 0.0.2 < 0.0.3.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员符号（^）范围允许更改不修改最左边的非零数字。^1.2.0 等同于 >= 1.2.0 <= 2.0.0，^0.2.1 等同于 >= 0.2.1 <=
    0.3.0，而 ^0.0.2 等同于 >= 0.0.2 < 0.0.3。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details, visit [https://github.com/npm/node-semver](https://github.com/npm/node-semver)
    and [https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver).
    A useful tool to check versions for specific packages against Semver tuples can
    be found at [http://semver.npmjs.com/](http://semver.npmjs.com/).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请访问 [https://github.com/npm/node-semver](https://github.com/npm/node-semver)
    和 [https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver)。一个有用的工具，可以用来检查特定包与
    Semver 元组的版本，可以在 [http://semver.npmjs.com/](http://semver.npmjs.com/) 找到。
- en: As we saw when we were using the `npm install <packagename> --save` construct,
    npm defaults to caret prefixing—npm will assign the newly installed dependency
    a version of `^<latest version>` in `package.json`. If you'd like to have a default
    tilde prefix, use `npm config set save-prefix="~"`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在使用 `npm install <packagename> --save` 构造时看到的，npm 默认使用管理员符号前缀——npm 将为新安装的依赖项分配
    `^<最新版本>` 的版本号到 `package.json` 中。如果你想使用默认的波浪线前缀，请使用 `npm config set save-prefix="~"`。
- en: Another important feature of Semver for maintainability is prerelease tags.
    These tags allow you to release a package version that is not ready for production
    (prerelease), which you might do in order to get it in the hands of other people
    on your team, beta testers, and so on, while ensuring that the default version
    will be installed on a "normal" install.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Semver 的另一个重要特性是预发布标签。这些标签允许你发布一个尚未准备好生产的包版本（预发布），你可能这样做是为了将其交给团队中的其他人、测试人员等，同时确保默认版本将在“正常”安装时安装。
- en: When you publish an npm package, you can use the `--tag` argument to tag that
    release. The published package is now no longer tagged as "latest" but as whichever
    tag you've assigned it. Let's say we tagged the **alpha.7** package (and changed
    the version field of the package with `npm version <version>-alpha.7`).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发布一个 npm 包时，你可以使用 `--tag` 参数来标记那个版本。现在发布的包不再标记为 "latest"，而是你分配给它的任何标签。比如说，我们标记了
    **alpha.7** 包（并且使用 `npm version <version>-alpha.7` 更改了包的版本字段）。
- en: 'Now, consider the case where that package is being listed as a dependency somewhere
    in *userland*:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑这种情况，该包被列在 *userland* 的某个地方作为依赖项：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When this package is installed, npm will install the alpha.7 package—Semver
    ranges would apply as alpha.7 is greater than alpha.1.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个包被安装时，npm 将安装 alpha.7 包——Semver 范围将适用，因为 alpha.7 大于 alpha.1。
- en: 'Let''s define our package in this way:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样定义我们的包：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding case, the alpha.7 package will *not* be installed. In this
    way, we can see that by the Semver rule, prerelease tags only apply if the comparator
    (what you've set as the version of the package) also contains a prerelease tag.
    In this way, you can safely release experimental breaking changes in tagged packages
    as only someone who is fully aware of the tag name (and its alpha nature) would
    do the work required to be done to use it, while others continue to use production
    versions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，alpha.7 包将 **不会** 被安装。这样，我们可以看到，根据 Semver 规则，预发布标签仅在比较器（你设置的包版本）也包含预发布标签时才适用。这样，你可以在标记的包中安全地发布实验性的破坏性更改，因为只有完全了解标签名称（及其
    alpha 特性）的人才会进行使用它所需的工作，而其他人将继续使用生产版本。
- en: Managing packages with npm
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 npm 管理包
- en: One of the most important (and tricky) application management strategies you
    will deploy is choosing packages and updating package versions. In this section,
    good strategies to maintain your npm packages will be discussed—how to keep your
    packages up to date, how to lock dependencies, how to load packages from Git repositories
    rather than npm, and so on.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你将部署的最重要（且棘手）的应用程序管理策略之一是选择包和更新包版本。在本节中，我们将讨论维护你的 npm 包的好策略——如何保持你的包更新，如何锁定依赖项，如何从
    Git 仓库加载包而不是 npm，等等。
- en: Generally, you'll want to balance the relative safety of the rigid Semver constraints
    with the need to stay as up to date as possible with the latest version of an
    important package and to keep your dependency tree predictable and clean. Developing
    a good strategy here will help with application maintenance.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望平衡严格的 Semver 约束的相对安全性，以及尽可能保持与重要包的最新版本同步的需求，同时保持你的依赖树可预测且干净。制定一个好的策略将有助于应用程序维护。
- en: 'Take a look at the following six aspects of package maintenance:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下六个方面是包维护的要点：
- en: Maintaining awareness of the full npm dependency tree
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护对完整的npm依赖树的意识
- en: Tracking divergence between the latest version and the installed version of
    a package
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪包的最新版本和安装版本之间的差异
- en: Removing unused packages defined in your package file
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除在包文件中定义的未使用包
- en: Ensuring that all needed dependencies are installed
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有必需的依赖项都已安装
- en: Ensuring that the dependencies you need are the ones you have
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所需的依赖项是你拥有的那些
- en: Using private or other modules not held in the npm repository
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用私有或其他不在npm仓库中的模块
- en: Other package management systems enforce the rule that a single version of a
    package exists across all dependencies; npm does not. Packages typically require
    other packages, so multiple versions of the same package can enter into an npm
    build. An application may have A and B dependencies, with the A package requiring
    version 1.0.1 of the C package, and with the B package requiring version 2.0.1
    of the C package.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 其他包管理系统强制执行规则，即包的单一版本存在于所有依赖项中；npm则不是这样。包通常需要其他包，因此同一包的多个版本可以进入npm构建。一个应用程序可能有A和B依赖项，其中A包需要C包的1.0.1版本，而B包需要C包的2.0.1版本。
- en: Think about what it means to say that, on every npm install, there is limited
    (often barely thought out) control over the package versions inserted into a dependency
    tree—there is no guarantee that your application will run the same code at any
    given time. What's been installed at one moment may fundamentally change if you
    reinstall one hour later or even one second later. That's an extraordinary level
    of risk to introduce into production systems—similar to a software manager being
    indifferent to who makes changes, where, or when.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在每次npm安装时，对依赖树中插入的包版本的控制是有限的（通常思考得很少）——无法保证你的应用程序在任何给定时间运行相同的代码。某一时刻安装的内容，如果在一个小时后或甚至一秒后重新安装，可能会发生根本性的变化。这是将风险引入生产系统的一个异常高的水平——类似于软件经理对谁、在哪里、何时进行更改漠不关心。
- en: 'The first step is getting a full breakdown of what has been installed. Use
    `npm ls` for this, which returns something like the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是获取完整的安装分解。使用`npm ls`来完成此操作，它返回如下内容：
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you want this tree to be represented as JSON, use the `--json` flag: `npm
    ls --json`. To include the contents of each package''s `description` field in
    the output, use `npm ls --long`. You can use `npm ls -g` to get this tree for
    *globally* installed packages. If you''d just like to know which packages are
    installed globally, try `` ls `npm root -g` ``.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将此树表示为JSON，请使用`--json`标志：`npm ls --json`。要包括每个包的`description`字段的输出，请使用`npm
    ls --long`。你可以使用`npm ls -g`来获取全局安装包的此树。如果你只想知道哪些包已全局安装，请尝试`ls `npm root -g``。
- en: 'Keeping up to date on the current versions of the installed packages is something
    you should be doing regularly. It doesn''t take long for the version of a package
    to become outdated. Npm provides the `npm outdated` tool for this purpose (here,
    it is used with the `--long` "extended information" argument). The following screenshot
    shows this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 定期保持已安装包的当前版本更新是你应该做的事情。包的版本很快就会过时。npm提供了`npm outdated`工具来完成此目的（在这里，它使用了`--long`“扩展信息”参数）。下面的截图显示了这一点：
- en: '![Managing packages with npm](img/1403OS_07_19.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![使用npm管理包](img/1403OS_07_19.jpg)'
- en: 'Here, we see that the `package.json` file within the `node_modules/redis` folder
    of our application is at version 0.8.2 (**current**), that the **latest** version
    is 0.12.1, and that the **wanted** Semver for *redis* in the root `package.json`
    file will match up to version 0.12.1\. This indicates that it has been quite a
    while since `npm install` was run within this application. A very useful global
    tool to perform these sorts of checks is `npm-check` ([https://github.com/dylang/npm-check](https://github.com/dylang/npm-check)),
    which delivers more detailed information, as shown in the following screenshot:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们的应用程序的`node_modules/redis`文件夹中的`package.json`文件版本为0.8.2（**当前**），最新版本为0.12.1，并且根`package.json`文件中*redis*的期望Semver将与版本0.12.1相匹配。这表明自从在这个应用程序中运行`npm
    install`以来已经有一段时间了。一个非常有用的全局工具来执行这些检查是`npm-check`([https://github.com/dylang/npm-check](https://github.com/dylang/npm-check))，它提供了更详细的信息，如下面的截图所示：
- en: '![Managing packages with npm](img/1403OS_07_20.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![使用npm管理包](img/1403OS_07_20.jpg)'
- en: Additionally, this tool offers an interactive UI that will automatically update
    the packages you choose.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此工具还提供了一个交互式用户界面，它将自动更新你选择的包。
- en: Another type of residue that accumulates over time is unused packages. These
    can be installed in `node_modules` but no longer linked, or these can be defined
    for a package but not required anywhere in the application's code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，另一种会积累的残留物是未使用的包。这些包可能已安装在 `node_modules` 中但不再链接，或者这些包可能已为某个包定义但未在应用程序代码的任何地方使用。
- en: To remove packages that are *installed* but no longer listed in `package.json`,
    you can use `npm prune`. Note that this is simply a technique for cleaning up
    the `node_modules` folder within an individual package's folder; it is not a smart,
    global tool to remove unused packages across the entire tree.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除在 `package.json` 中不再列出的已安装包，你可以使用 `npm prune`。请注意，这仅仅是一种清理单个包文件夹内的 `node_modules`
    文件夹的技术；它不是一个智能的全局工具，不能在整个树中删除未使用的包。
- en: 'The `dependency-check` module ([https://github.com/maxogden/dependency-check](https://github.com/maxogden/dependency-check))
    is another tool to find unnecessary packages. Assuming that such an unused dependency
    exists, dependency-check will find it:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependency-check` 模块（[https://github.com/maxogden/dependency-check](https://github.com/maxogden/dependency-check)）是另一个用于查找不必要的包的工具。假设存在这样的未使用依赖项，`dependency-check`
    将会找到它：'
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Conversely, packages may be required in the application code but not listed
    in a package file. This happens occasionally, when a necessary package is installed
    during development but not saved to `package.json`, possibly because the user
    forgets to use the `--save` option or for some other reason. The `dependency-check`
    command will walk all files in your codebase and find such cases, as shown here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，包可能需要在应用程序代码中使用，但未在包文件中列出。这种情况偶尔发生，当在开发过程中安装了必要的包但未保存到 `package.json` 中时，可能是由于用户忘记使用
    `--save` 选项或其他原因。`dependency-check` 命令将遍历你的代码库中的所有文件，并找到此类情况，如下所示：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that it is expected that the entry point to your application is listed
    in `package.json` as `dependency-check` needs to know where your application tree
    is rooted. You should, therefore, ensure that your packages all have a `main`
    attribute pointing to an existing file. If you need to add further files to check,
    use the `--entry` argument as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，预期你的应用程序的入口点在 `package.json` 中列出，因为 `dependency-check` 需要知道你的应用程序树根在哪里。因此，你应该确保你的所有包都有一个指向现有文件的
    `main` 属性。如果你需要添加更多要检查的文件，请使用以下 `--entry` 参数：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To have a `main` entry point to your application is an important general practice
    that you should follow.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个指向你应用程序的 `main` 入口点是你应该遵循的重要通用实践。
- en: 'One final tool that can help speed up your npm builds is `npm dedupe`. When
    triggered, npm attempts to reduce the number of redundant package installs, "flattening"
    the tree somewhat, and, therefore, reducing install time. Consider this dependency
    tree:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个可以帮助加快你的 npm 构建的工具有 `npm dedupe`。当触发时，npm 尝试减少冗余包安装的数量，"扁平化" 树结构，因此减少安装时间。考虑以下依赖树：
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, the A package depends on the B and D packages, which each depend on the
    C package. Normally, C would be installed twice, once for each parent. However,
    if the Semver that B and D use to target C matches a single version of C, npm
    will reduce the tree in a way that both B and D pull from pull from the same,
    single, installed version of C. Note that Semver rules still apply—npm will not
    break version requirements solely to reduce the number of installs required.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，A 包依赖于 B 和 D 包，而这两个包又各自依赖于 C 包。通常，C 会安装两次，一次为每个父包。然而，如果 B 和 D 用来针对 C 的 Semver
    匹配 C 的单个版本，npm 将以这种方式减少树的大小，即 B 和 D 都从相同的单个已安装版本 C 中提取。请注意，Semver 规则仍然适用——npm
    不会仅仅为了减少所需的安装次数而破坏版本要求。
- en: It should be clear that many of the tools we've been looking at would fit nicely
    into a build/deploy process, issuing a warning if, for example, a given package
    is not used or is out of date. npm is itself an npm package ([https://github.com/npm/npm](https://github.com/npm/npm))—try
    using npm programmatically within your build process to perform some of these
    checks.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，我们一直在查看的许多工具都可以很好地集成到构建/部署过程中，例如，如果某个包未使用或已过时，则会发出警告。npm 本身也是一个 npm 包（[https://github.com/npm/npm](https://github.com/npm/npm)）——尝试在你的构建过程中使用
    npm 进行编程，以执行这些检查之一。
- en: Designing a dependency tree
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计依赖树
- en: All dependencies are not created equal. Some are necessary when in development
    mode but are not meaningful in production. The location and versions of dependencies
    can also vary as you may not always use packages in the npm repository, or you
    may want to use specialized versions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有依赖项都同等重要。有些在开发模式下是必要的，但在生产中却没有意义。依赖项的位置和版本也可能变化，因为你可能并不总是使用npm仓库中的包，或者你可能想使用特定的版本。
- en: 'There are three types of dependencies used in npm package files: **dependencies**,
    **devDependencies**, and **peerDependencies**. Let''s look at the differences.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: npm包文件中使用了三种类型的依赖项：**dependencies**、**devDependencies**和**peerDependencies**。让我们看看它们之间的区别。
- en: Simple dependencies are likely what you're most familiar with. These dependencies
    are *always* installed, regardless of context. You should place dependencies that
    *must* exist in this collection, typically the packages your production build
    will need.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 简单依赖可能是你最熟悉的。这些依赖项**总是**被安装，无论在什么环境下。你应该将**必须**存在于这个集合中的依赖项放置在这里，通常是生产构建所需的包。
- en: 'When you are developing and building, you will often use tools, such as Mocha
    or gulp. Once a validated build is ready to be placed in production, however,
    there is no need for those packages to accompany it. The packages you do not need
    in production should be placed in the devDependencies collection. While npm will
    always install both dependencies and devDependencies, you can (and should) exclude
    devDependencies from the deploy install using the `--production` flag, which is
    as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发和构建时，你经常会使用工具，如Mocha或gulp。然而，一旦经过验证的构建准备好投入生产，就没有必要将这些包与其一起放置。在生产中不需要的包应该放在devDependencies集合中。虽然npm总是会安装依赖项和devDependencies，但你（并且应该）可以通过使用`--production`标志从部署安装中排除devDependencies，如下所示：
- en: '[PRE40]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Usefully, if you run the `npm config set production` command, the `~/.npmrc`
    file will be updated such that all future installs will automatically set the
    `--production` flag. For example, your provisioner can do this configuration.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的是，如果你运行`npm config set production`命令，`~/.npmrc`文件将被更新，使得所有未来的安装都将自动设置`--production`标志。例如，你的配置器可以执行此配置。
- en: 'Finally, peerDependencies deals with the case of plugins. You''re familiar
    with various Grunt plugins. While these are loaded via the npm ecosystem, they
    need their host program (Grunt) in order to function. You might think that each
    of these plugins should just `require(''grunt'')`—but which version of Grunt?
    Any one of these plugins may depend on a specific version of its host program,
    but those host programs are also direct dependencies of the package. So, consider
    this declaration:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，peerDependencies处理的是插件的案例。你熟悉各种Grunt插件。虽然这些插件是通过npm生态系统加载的，但它们需要其宿主程序（Grunt）才能运行。你可能认为每个插件都应该直接`require('grunt')`——但是哪个版本的Grunt呢？任何一个插件都可能依赖于其宿主程序的具体版本，但这些宿主程序也是包的直接依赖。因此，考虑以下声明：
- en: '[PRE41]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding declaration leads to a dangerous conflict:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明可能导致危险的冲突：
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, peerDependencies should be used in plugin-type packages that have specific
    host-program needs, allowing the plugin to "carry along" their needed host. If
    npm attempts to install a different version of that host program, an error is
    thrown. This, of course, leads to another problem—any given plugin can cause an
    install to fail if its required host program is not version-compatible with the
    one the main application is demanding. The complexities of peerDependencies remain
    an ongoing discussion in the Node community ([https://github.com/npm/npm/issues/5080](https://github.com/npm/npm/issues/5080)).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，peerDependencies应该在具有特定宿主程序需求的插件类型包中使用，允许插件“携带”它们所需的宿主。如果npm尝试安装该宿主程序的不同版本，则会抛出错误。这当然会导致另一个问题——如果插件所需的主程序版本与主应用程序要求的版本不兼容，任何给定的插件都可能导致安装失败。peerDependencies的复杂性在Node社区中仍然是一个持续讨论的话题([https://github.com/npm/npm/issues/5080](https://github.com/npm/npm/issues/5080))。
- en: As mentioned, npm does not put many limits on package versions, allowing multiple
    versions of the same package to exist simultaneously and, indeed, for versions
    (and, therefore, package functionality) to change unexpectedly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，npm对包版本的限制不多，允许同一包存在多个版本，并且确实，版本（以及因此包的功能）可能会意外地发生变化。
- en: 'One way to secure your application''s state is to lock a dependency tree using
    `npm shrinkwrap`. This command will trigger npm to generate the `npm-shrinkwrap.json`
    file containing explicit references to specific versions. The file generated contains
    definitions such as the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的应用程序状态的一种方法是通过使用 `npm shrinkwrap` 锁定依赖树。这个命令会触发 npm 生成包含对特定版本明确引用的 `npm-shrinkwrap.json`
    文件。生成的文件包含如下定义：
- en: '[PRE43]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It should be clear how this syntax ensures that future installs will be identical.
    Note that this is a heavy-handed approach that you probably don't need very often.
    However, in production situations where you are deploying identical code across
    multiple machines, shrinkwrapped "bundles" may be exactly what you need.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 应该清楚这种语法如何确保未来的安装将与之前相同。请注意，这是一个较为直接的方法，你可能并不经常需要它。然而，在生产环境中，当你需要在多台机器上部署相同代码时，shrinkwrap
    的“捆绑包”可能正是你所需要的。
- en: 'Another option to ensure visibility in the behavior of your packages is to
    control them in their entirety. You are able to link dependencies to Git repositories,
    either public or private. For example, you can load Express directly from its
    GitHub repository:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种确保你的包行为可见性的方法是完全控制它们。你可以将依赖项链接到 Git 仓库，无论是公开的还是私有的。例如，你可以直接从 Express 的 GitHub
    仓库加载 Express：
- en: '[PRE44]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: npm assumes GitHub, so you are able to use the compressed syntax, as shown in
    the preceding code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: npm 假设 GitHub，因此你可以使用压缩语法，如前述代码所示。
- en: 'You can also link to a private Git repository using `https/oauth`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `https/oauth` 链接到私有 Git 仓库：
- en: '[PRE45]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also use SSH as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以按照以下方式使用 SSH：
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The npm package manager is an essential part of the Node ecosystem, and Node
    applications are typically composed of dozens, even hundreds, of packages. Developing
    a strategy around package management is an important consideration if you plan
    to release and maintain a large-scale Node application.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: npm 包管理器是 Node 生态系统的一个基本组成部分，Node 应用程序通常由数十个，甚至数百个包组成。如果你计划发布和维护一个大规模的 Node
    应用程序，围绕包管理制定策略是一个重要的考虑因素。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to deploy a local build into a production-ready
    environment. The powerful Git webhook tool was demonstrated as a way of creating
    a continuous integration environment, and this knowledge was carried forward into
    the creation of a full build/deploy pipeline that connected a GitHub repository
    to a Heroku deployment via a CI environment configured using Jenkins. We also
    covered the semantic versioning system that npm uses and even how to use Semver,
    npm methods, and some helper libraries to keep our package trees clean and predictable.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将本地构建部署到生产就绪环境中。强大的 Git webhook 工具被演示为创建持续集成环境的一种方式，并将这一知识应用于创建一个完整的构建/部署管道，该管道通过使用
    Jenkins 配置的 CI 环境将 GitHub 仓库连接到 Heroku 部署。我们还介绍了 npm 使用的语义版本控制系统，甚至如何使用 Semver、npm
    方法以及一些辅助库来保持我们的包树整洁和可预测。
- en: From basic JavaScript programs to the deployment of full applications, in this
    book, we took a tour of Node's design and goals. We've worked through ways in
    which Node's event-driven architecture influences how we design networked software
    by building on the foundational concept of streams. With an eye toward the creation
    of fast, deployable systems, we worked through virtualization strategies, compiler
    optimizations, load balancing, and vertical and horizontal scaling strategies.
    Additionally, the power of composing software out of small, focused programs was
    considered by introducing the power of micro services, interprocess messaging,
    and queues as one way to build distributed systems.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从基本的 JavaScript 程序到完整应用程序的部署，在这本书中，我们游览了 Node 的设计和目标。我们探讨了 Node 事件驱动架构如何通过构建流的基础概念来影响我们设计网络软件的方式。为了创建快速、可部署的系统，我们探讨了虚拟化策略、编译器优化、负载均衡以及垂直和水平扩展策略。此外，通过引入微服务、进程间消息传递和队列作为构建分布式系统的一种方式，我们还考虑了由小型、专注的程序组成的软件的力量。
- en: Keeping in mind that software is written by fallible humans, we also covered
    strategies for testing and maintaining running applications, learning to expect
    failure, and planning for it, with the help of both native and third-party logging
    and monitoring tools. We learned debugging techniques and optimization strategies
    aimed at reducing bottlenecks at the local and network levels and also how to
    find their source when they inevitably appear. With the goal of making development
    simpler, we looked at how to make effective use of integration tools and versioning
    systems, provision virtual machines and test with headless browsers, enable developers
    to work freely and take risks, and push changes with the confidence that smart
    deployment strategies confer. Constructing a smart build pipeline, you learned
    about the power of full-stack JavaScript, transpilation, live updates, and continuous
    testing and integration.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到软件是由有缺陷的人类编写的，我们还涵盖了测试和维持运行中的应用程序的战略，学习预期失败并为此做好准备，借助原生和第三方日志和监控工具。我们学习了调试技术和优化策略，旨在减少本地和网络级别的瓶颈，以及如何在它们不可避免地出现时找到它们的来源。为了使开发更简单，我们研究了如何有效地使用集成工具和版本控制系统，配置虚拟机并使用无头浏览器进行测试，使开发者能够自由工作并承担风险，并带着智能部署策略带来的信心推送更改。构建智能构建管道，您了解了全栈
    JavaScript、转译、实时更新和持续测试与集成的力量。
- en: You are encouraged to modify and extend the example code to improve it or, otherwise,
    change it to your needs. The hope is that, as you come to appreciate the power
    of Node.js, the npm ecosystem, and open source software, you will begin to naturally
    design your applications so that they will require few changes when pushed into
    production, and that you will share your discoveries so that others can do the
    same thing.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您修改和扩展示例代码以改进它或根据您的需求进行更改。希望随着您开始欣赏 Node.js 的力量、npm 生态系统和开源软件，您将开始自然地设计您的应用程序，以便在推向生产时需要很少的更改，并且您将分享您的发现，以便其他人也能做到同样的事情。
