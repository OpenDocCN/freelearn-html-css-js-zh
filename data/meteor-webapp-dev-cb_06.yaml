- en: Chapter 6. Mastering Reactivity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 掌握响应式编程
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Creating and consuming a reactive value
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和消费响应式值
- en: Using Ajax query results in ReactiveVar
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ajax查询结果修改UI元素响应式
- en: Making a custom library reactive
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使自定义库响应式
- en: Updating Blaze templates without Mongo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用Mongo更新Blaze模板
- en: Using inline data to modify UI elements reactively
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内联数据响应式地修改UI元素
- en: Integrating the jQuery UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成jQuery UI
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Reactive programming** is an emerging development methodology, where changes
    to data automatically trigger changes to the rest of the system. This allows you,
    the developer, to write code declaratively and let the reactive elements manage
    any changes. Meteor is, perhaps, the best and most fully developed implementation
    of reactive programming available today. By understanding the core concepts of
    reactive programming, you can use the `Tracker` (formerly `Deps`) library to create
    simple, declarative code while avoiding the usual pitfalls associated with reactive
    and asynchronous JavaScript programming. The recipes in this chapter will give
    you simple, clear examples of how the major components of Meteor''s reactive model
    work.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式编程**是一种新兴的开发方法，其中数据的变化会自动触发整个系统的变化。这允许您，作为开发者，以声明式的方式编写代码，并让响应式元素管理任何变化。Meteor可能是今天最好的、最全面实现的响应式编程。通过理解响应式编程的核心概念，您可以使用`Tracker`（以前称为`Deps`）库创建简单、声明式的代码，同时避免与响应式和异步JavaScript编程相关的常见陷阱。本章中的食谱将为您提供简单、清晰的示例，说明Meteor响应模型的主要组件是如何工作的。'
- en: Creating and consuming a reactive value
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和消费响应式值
- en: '`Tracker`, simply put, is Meteor''s variable tracking system. It is used to
    manage reactive values, data structures, and computations (functions that consume
    reactive values). This recipe will show you how to create reactive values, and
    perform computations on those values, using `Tracker.autorun()`. In other words,
    it will teach you how reactive programming works inside Meteor. This recipe will
    come in handy as a foundation for more complex functionalities.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tracker`，简单来说，是Meteor的变量跟踪系统。它用于管理响应式值、数据结构和计算（消耗响应式值的函数）。本食谱将向您展示如何创建响应式值，并使用`Tracker.autorun()`对这些值进行计算。换句话说，它将教会您在Meteor内部如何进行响应式编程。这个食谱将作为更复杂功能的基础非常有用。'
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the sake of simplicity, we will be using a default Meteor project, with
    the `reactive-var` package added to it. Open a terminal window, navigate to where
    you would like to create your root project, and execute the following commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将使用默认的Meteor项目，并添加`reactive-var`包。打开一个终端窗口，导航到您想要创建根项目的地方，并执行以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You are now ready to start using reactive variables.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以开始使用响应式变量了。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We are going to modify the text of a button, based on a reactive variable; so
    we will need to create the button and hook up the reactive context.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据响应式变量修改按钮的文本；因此，我们需要创建按钮并连接响应式上下文。
- en: 'Open your project in your favorite text editor and edit the `reactiverecipes.html`
    file, adding an ID to the `<button>` element, as shown in the following example:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您最喜欢的文本编辑器中打开您的项目，并编辑`reactiverecipes.html`文件，为`<button>`元素添加一个ID，如下例所示：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, open `reactiverecipes.js` and add the following lines of code just below
    the `if (Meteor.isClient)` condition:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`reactiverecipes.js`，并在`if (Meteor.isClient)`条件下方添加以下代码行：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, add the following line inside the `Template.hello.events` declaration,
    just below the `Session.set()` function in the `''click button''` function:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Template.hello.events`声明中添加以下行，位于`'click button'`函数中的`Session.set()`函数下方：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save your changes and navigate to `http://localhost:3000` in a browser. Once
    there, click on the button labeled **Click Me** and watch the text change to **Again!**:![How
    to do it...](img/image00374.jpeg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改，并在浏览器中导航到`http://localhost:3000`。一旦到达那里，点击标有**点击我**的按钮，并观察文本变为**再次！**：![如何操作...](img/image00374.jpeg)
- en: 'You can manually change the value of the button text by opening a console window
    in your browser and using the `btnText.set()` command, as shown in the following
    example:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过在浏览器中打开控制台窗口并使用`btnText.set()`命令来手动更改按钮文本，如下例所示：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The button text will change to whatever value you set it to, instantly.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按钮文本将立即变为您设置的任何值。
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding example seems oversimplified, but we have two things to say about
    that.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子似乎过于简化，但关于这一点我们有两点要说。
- en: First, it's simple because Meteor was built to make your code very simple and
    easy to follow. This makes your development and debug efforts significantly less
    time consuming.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它之所以简单，是因为 Meteor 是为了使您的代码非常简单和易于理解而构建的。这使得您的开发和调试工作大大减少了时间消耗。
- en: Notice how the process of declaring a reactive variable is made up of one line
    of code. When we added the `btnText = new ReactiveVar('Click Me')` statement,
    we were simply declaring a variable (and initializing its value to `'Click Me'`),
    but we know by the declaration that it is a reactive variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意声明响应式变量的过程是如何由一行代码组成的。当我们添加 `btnText = new ReactiveVar('Click Me')` 语句时，我们只是声明了一个变量（并将其初始化为
    `'Click Me'`），但我们通过声明知道它是一个响应式变量。
- en: Next, we encapsulated an extremely straightforward jQuery statement inside a
    `Tracker.autorun()` block. This block is called a **reactive computation**. Reactive
    computations run once initially and then rerun (are recomputed) whenever a change
    is made to any reactive variables contained inside. So, in this example, we told
    `Tracker` to monitor the value of `btnText`(a reactive variable) and automatically
    run (hence the term `autorun`) the code block again when it would change.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `Tracker.autorun()` 块内部封装了一个极其简单的 jQuery 语句。这个块被称为**响应式计算**。响应式计算最初运行一次，然后每当任何包含在其中的响应式变量发生变化时，它都会重新运行（重新计算）。因此，在这个例子中，我们告诉
    `Tracker` 监控 `btnText`（一个响应式变量）的值，并在它发生变化时自动再次运行（因此得名 `autorun`）代码块。
- en: Notice that we don't have to worry about any time conditions, such as "is this
    the first run?" or "okay, when there's a change…." We just simply declare the
    jQuery statement and let `Tracker` figure out the timing for us.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不必担心任何时间条件，例如“这是第一次运行吗？”或者“好吧，当有变化时……”。我们只需简单地声明 jQuery 语句，让 `Tracker` 为我们确定时间。
- en: This is what the term **transparent reactive programming** means. There is one
    set of code for the initialization and another set of code for changes. Besides
    the variable declarations, your entire code base can be written as normal, plain
    old JavaScript.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**透明响应式编程**这个术语的含义。有一套代码用于初始化，另一套代码用于处理变化。除了变量声明外，您的整个代码库都可以用普通的、老式的 JavaScript
    编写。
- en: Second, what it's doing under the hood is anything but simple! To create this
    frontend simplicity for you, the programmer, Meteor implements reactive providers
    and reactive computations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它在底层所做的事情绝对不简单！为了给您，程序员，提供这样的前端简单性，Meteor 实现了响应式提供者和响应式计算。
- en: 'We''ll sacrifice a bit of fidelity to make the concept simpler to understand.
    When `Tracker.autorun` is called, it does four things:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将牺牲一点精确度来使概念更容易理解。当调用 `Tracker.autorun` 时，它会做四件事：
- en: It creates a computation
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建一个计算
- en: It sets `Tracker.currentComputation` to that computation
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 `Tracker.currentComputation` 设置为那个计算
- en: It calls the function that was passed to it
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用传递给它的函数
- en: It sets `Tracker.currentComputation` to `null`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 `Tracker.currentComputation` 设置为 `null`
- en: A computation is essentially an event handler function and contains a reference
    to the function that was passed to `Tracker.autorun`. The event that the computation
    is waiting for is a call to the `computation.invalidate` method. When the `invalidate`
    method is called, the computation reruns the function it contains.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 计算本质上是一个事件处理函数，并包含传递给 `Tracker.autorun` 的函数的引用。计算所等待的事件是调用 `computation.invalidate`
    方法。当调用 `invalidate` 方法时，计算会重新运行它包含的函数。
- en: 'Now we come to the function. The function passed to `Tracker.autorun` is considered
    a reactive function if it contains **reactive providers**. A reactive provider
    is an object that has functions to get and set some value, and keeps track of
    dependencies. When the `get` function is called, it does three things:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看函数。传递给 `Tracker.autorun` 的函数如果包含**响应式提供者**，则被视为响应式函数。响应式提供者是一个具有获取和设置某些值的功能的对象，并跟踪依赖关系。当调用
    `get` 函数时，它会做三件事：
- en: It checks to see whether `Tracker.currentComputation` has a value.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查 `Tracker.currentComputation` 是否有值。
- en: If it does, the computation is added to an internal list.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它有，计算就会被添加到内部列表中。
- en: It returns the value of the variable that the getter requested.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它返回 getter 请求的变量的值。
- en: Both steps 1 and 2 are performed by making a call to `depend()`, which is a
    method found on a dependency object. The `reactive-var` library automates this
    part, so you don't have to call the `depend()` method directly. All you have to
    do is use the reactive variable!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤都是通过调用`depend()`方法来执行的，这是一个在依赖对象上找到的方法。`reactive-var`库自动处理这部分，所以你不需要直接调用`depend()`方法。你所要做的就是使用反应性变量！
- en: 'Likewise, when the `set` function is called, it does two things:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当调用`set`函数时，它会做两件事：
- en: It changes the value of the internal variable
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它改变了内部变量的值
- en: For every computation in the internal list, the `invalidate()` method is called
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于内部列表中的每个计算，都会调用`invalidate()`方法
- en: The `invalidate()` methods are called in a loop by making a call to `changed()`,
    which is a `helper` method found on a dependency object. Again, `reactive-var`
    takes care of this for you. You're welcome!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`changed()`方法，循环调用`invalidate()`方法，这是一个在依赖对象上找到的`helper`方法。再次强调，`reactive-var`为你处理了这部分。欢迎你！
- en: When each computation is invalidated, it reruns the function that it contains.
    And the entire loop starts over with the newly rerun function calling the getters,
    which return their values (like the `text` value of our `btnReact` button) and
    add the computations to the provider's internal list, waiting once again for the
    setter to be called.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个计算被无效化时，它会重新运行包含它的函数。整个循环从新重新运行的函数调用getter开始，getter返回它们的值（比如我们的`btnReact`按钮的`text`值）并将计算添加到提供者的内部列表中，再次等待setter被调用。
- en: 'Even though they are extremely oversimplified (any core MDG members reading
    this are probably spitting coffee right now…), here is what the `ReactiveVar`
    and `autorun` objects do:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们被极度简化（任何阅读此内容的MDG核心成员可能正在喷咖啡……），以下是`ReactiveVar`和`autorun`对象所做的工作：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are two things that we left out, for clarity, but are important in order
    to have a complete understanding. First, the `depend()` helper method also sets
    up an `onInvalidate()` listener, which removes the computation from the reactive
    provider's internal list. Second, computations are checked to see whether they
    already exist in an internal list before they are added.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们省略了两件事，但为了有一个完整的理解，这两件事很重要。首先，`depend()`辅助方法还设置了一个`onInvalidate()`监听器，它会从反应性提供者的内部列表中移除计算。其次，在将计算添加到内部列表之前，会检查计算是否已经存在于内部列表中。
- en: Why are the computations removed when the computation is invalidated, you may
    ask? The answer, in short, is that it makes the entire computation `add-execute-remove`
    loop very elegant. It keeps all the computations up to date and the dependent
    functions only run once each, no matter how many times a getter is called inside
    the same function. If they weren't removed, the functions would be run multiple
    times, which is *no bueno*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你问为什么在计算被无效化时移除计算，简短的答案是，这使得整个计算`add-execute-remove`循环非常优雅。它保持所有计算都是最新的，并且依赖函数只运行一次，无论在同一个函数内部调用getter的次数有多少。如果它们没有被移除，函数会被多次运行，这可不是什么好事。
- en: 'So let''s review what we did in this recipe:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回顾一下在这个配方中我们做了什么：
- en: The `autorun` method creates a computation and passes your function to this
    computation
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autorun`方法创建一个计算并将你的函数传递给这个计算'
- en: The computation has an `onInvalidate` method that, among other things, runs
    your function
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算有一个`onInvalidate`方法，它除了其他事情外，还会运行你的函数
- en: After `autorun` has created a computation, it runs your function once, using
    the `onInvalidate` method
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`autorun`创建了一个计算之后，它会使用`onInvalidate`方法运行你的函数一次
- en: Your function has reactive variables in it, which have to-do lists
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的函数中包含反应性变量，它们有自己的待办列表
- en: As your function runs, getters are called, which add the computations to the
    to-do lists
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的函数运行时，会调用getter，它们会将计算添加到待办列表中
- en: Setters are also called, which execute the to-do lists and clear them
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也会调用setter，执行待办列表并清除它们
- en: Because your functions in the to-do lists have reactive variables, the process
    is repeated (the functions are rerun)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为待办事项列表中的函数有反应性变量，所以这个过程会重复（函数会被重新运行）
- en: Lather, rinse, and repeat
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复上述步骤
- en: Again, this explanation is drastically simplified, and therefore, pretty inaccurate;
    however, conceptually, it will hopefully give you a good understanding of what's
    happening under the hood.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个解释被极大地简化了，因此，相当不准确；然而，从概念上讲，它可能会帮助你更好地理解底层发生了什么。
- en: There's more…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Meteor also provides the `ReactiveDict` object, which runs exactly like `ReactiveVar`,
    but can store collections of reactive variables in key-value pairs. The syntax
    is exactly the same as for `ReactiveVar`, but you will need to add a key to the
    `set` and `get` methods, as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 还提供了 `ReactiveDict` 对象，它运行方式与 `ReactiveVar` 完全相同，但可以以键值对的形式存储一系列的响应式变量。语法与
    `ReactiveVar` 完全相同，但您需要在 `set` 和 `get` 方法中添加一个键，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To use `ReactiveDict`, simply add the `reactive-dict` package using the following
    terminal command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `ReactiveDict`，只需使用以下终端命令添加 `reactive-dict` 包：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Lastly, you don't have to use `ReactiveVar`, or `ReactiveDict`, and can instead
    *roll your own* reactive providers. Please see the *Making a custom library reactive*
    recipe found in this chapter as an example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您不必使用 `ReactiveVar` 或 `ReactiveDict`，而是可以自己*实现*响应式提供者。请参阅本章中找到的 *制作自定义库响应式*
    菜谱作为示例。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating dynamic lists* recipe in [Chapter 3](part0036.xhtml#aid-12AK81
    "Chapter 3. Building Great User Interfaces"), *Building Great User Interfaces*
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 3 章 *创建动态列表* 菜谱，*构建出色的用户界面*
- en: The *Making a custom library reactive* recipe in this chapter
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *制作自定义库响应式* 菜谱
- en: Using Ajax query results in ReactiveVar
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ajax 查询结果填充 ReactiveVar
- en: Whenever we use Ajax, requesting (and even receiving) data is pretty easy. The
    complications come in when we have to update the UI with new or updated data.
    With Meteor's reactive programming capabilities, this is no longer an issue. In
    this recipe, you will see how to update your UI with Ajax results, using Meteor's
    `ReactiveVar` library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们使用 Ajax，请求（甚至接收）数据都相当简单。当我们需要用新的或更新的数据更新 UI 时，问题就出现了。借助 Meteor 的响应式编程能力，这个问题就不再是问题。在这个菜谱中，您将看到如何使用
    Meteor 的 `ReactiveVar` 库来更新您的 UI。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get up and run quickly, we will use a default Meteor project with a few
    packages added. Open a terminal window, navigate to where you would like to create
    your root project, and execute the following commands:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速启动，我们将使用默认的 Meteor 项目，并添加了一些包。打开一个终端窗口，导航到您想要创建根项目的地方，并执行以下命令：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are now ready to build a reactive Ajax query!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好构建一个响应式的 Ajax 查询了！
- en: How to do it…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We will be pulling the weather data from `openweathermap.org`, using their free
    (but for testing only) API. We will take the results from our `openweathermap.org`
    queries and put them into a `ReactiveVar` library so that they can then be consumed
    reactively by our Blaze templates.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `openweathermap.org` 拉取天气数据，使用他们免费的（但仅用于测试）API。我们将从我们的 `openweathermap.org`
    查询结果中提取数据，并将它们放入 `ReactiveVar` 库中，以便它们可以被我们的 Blaze 模板响应式地消费。
- en: 'Let''s start by modifying the UI:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从修改 UI 开始：
- en: 'Open `ajaxreactive.html` and add a call to our soon-to-be-created `weather`
    template, just under the call to the existing `hello` template, as shown in the
    following code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ajaxreactive.html` 并在我们的即将创建的 `weather` 模板调用下添加对现有 `hello` 模板的调用，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will also want to repurpose the counter in our `hello` template to tell
    us what the starting longitude will be. Change the description in the `<p>` element
    inside the `hello` template, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望在我们的 `hello` 模板中重新使用计数器，以告诉我们起始经度将是什么。按照以下方式更改 `hello` 模板中的 `<p>` 元素的描述：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, add our `weather` template, which is just a simple table with a bit of
    prettiness added, thanks to bootstrap! At the bottom of `ajaxreactive.html`, add
    the following template:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加我们的 `weather` 模板，它只是一个简单的表格，添加了一些美观性，多亏了 bootstrap！在 `ajaxreactive.html`
    的底部添加以下模板：
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save your changes and navigate to `http://localhost:3000`. While nothing (except
    the description of the counter) will change, we will very soon want to view our
    weather data.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改并导航到 `http://localhost:3000`。虽然除了计数器的描述外，没有什么会改变，但我们很快就会想查看我们的天气数据。
- en: 'Let''s open `ajaxreactive.js` and declare our `ReactiveVar` libraries. Just
    below `Session.setDefault()`, add the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开 `ajaxreactive.js` 并声明我们的 `ReactiveVar` 库。在 `Session.setDefault()` 下方添加以下代码：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will now modify the `''click button''` function to increment the counter
    and make our Ajax call. Locate the function inside the `Template.hello.events`
    section and modify the code as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将修改 `'click button'` 函数以增加计数器并执行我们的 Ajax 调用。在 `Template.hello.events` 部分找到该函数，并按以下方式修改代码：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to update the counter increment to `4`; otherwise, your `weather`
    data won't change much as you click.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记将计数器增加的值改为 `4`；否则，您点击时 `weather` 数据不会改变太多。
- en: 'Next, we need to add `Template.weather.helpers` so that our UI will populate
    properly. Just after the `Template.hello.events` section, add the following:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加`Template.weather.helpers`，以便我们的UI能够正确填充。在`Template.hello.events`部分之后，添加以下内容：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we need to add our Ajax call and the asynchronous callback function
    once the result comes in. Just after the `Template.weather.helpers` section, add
    the following two functions:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要添加我们的Ajax调用和异步回调函数，一旦结果返回。在`Template.weather.helpers`部分之后，添加以下两个函数：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save all your changes and click on the button on the project page in your browser.
    You should see something similar to the following screenshot:![How to do it…](img/image00375.jpeg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有更改，并在浏览器中的项目页面上点击按钮。你应该会看到以下截图类似的内容：![如何做…](img/image00375.jpeg)
- en: As you click, the weather results for a given area, moving towards north, will
    be displayed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的点击，给定区域的天气结果将显示出来，向北移动。
- en: How it works…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this instance, we didn't use a Mongo collection, which is automatically reactive.
    Instead, we made calls to `openweather.org api` and updated a `ReactiveVar` library
    (in this case, the `weatherList` variable) using the `set` method. Because the
    template helpers rely on a call to the `get` method of that same `ReactiveVar`,
    they are automatically rerun when the `ReactiveVar` is updated. Let's break it
    down.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有使用自动反应的Mongo集合。相反，我们调用了`openweather.org api`，并使用`set`方法更新了`ReactiveVar`库（在这种情况下，`weatherList`变量）。因为模板辅助函数依赖于对该相同`ReactiveVar`的`get`方法的调用，所以当`ReactiveVar`更新时，它们会自动重新运行。让我们来分解一下。
- en: 'We first created the `weather` template in our HTML:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在HTML中创建了`weather`模板：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The template iterates over the `reports` helper object using an `{{#each...}}`
    block, populating an HTML table with the results.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 模板使用`{{#each...}}`块遍历`reports`辅助对象，用结果填充HTML表格。
- en: 'Next, inside our client-side JavaScript, we declared our reactive variable,
    `weatherlist`, using a new `ReactiveVar` library:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的客户端JavaScript中，我们使用新的`ReactiveVar`库声明了我们的反应式变量`weatherlist`：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then used `weatherlist.get()` in our `reports` helper object, which is in
    `Template.weather.helpers`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`reports`辅助对象中使用了`weatherlist.get()`，该对象位于`Template.weather.helpers`：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By using it here, we set up a dependency so that anytime `weatherlist.set()`
    is called, the data for the template is refreshed and the template is updated/rerun.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在这里使用它，我们设置了一个依赖关系，以便每次调用`weatherlist.set()`时，模板的数据都会刷新，并且模板会更新/重新运行。
- en: 'Finally, we hooked up our button to an Ajax call using `HTTP.get()`, and we
    passed the `harvestWeather` function as a callback (`HTTP.get(url,arg,callback)`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`HTTP.get()`将我们的按钮连接到Ajax调用，并将`harvestWeather`函数作为回调（`HTTP.get(url,arg,callback)`）：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the callback is triggered, it massages the data from the Ajax call and
    repopulates our reactive variable using `weatherlist.set()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回调被触发，它会整理Ajax调用中的数据，并使用`weatherlist.set()`重新填充我们的反应式变量：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As mentioned in the preceding section, when this `set` function is called, it
    invalidates the template functions and reactively updates our UI.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当这个`set`函数被调用时，它会使模板函数无效，并反应式地更新我们的UI。
- en: You can see very clearly in the callback function (`harvestWeather`), and in
    the weather template helper function (`reports`), that the calls are regular,
    plain JavaScript. We're literally just calling a `get` or `set` function. Because
    the object we're calling those functions on is a `ReactiveVar`, all the reactive
    dependencies and UI updates are handled for us.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在回调函数（`harvestWeather`）和天气模板辅助函数（`reports`）中非常清楚地看到，这些调用是常规的、纯JavaScript。我们实际上只是在调用一个`get`或`set`函数。因为我们调用这些函数的对象是一个`ReactiveVar`，所以所有反应式依赖和UI更新都由我们处理。
- en: You can begin to quickly see how powerful Meteor's reactive programming model
    is. Instead of messing around with events and handlers or worrying about callback
    hell, we used a simple, clean `set` command and let Meteor handle all the details
    for us.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以快速看到Meteor的反应式编程模型是多么强大。我们不是在处理事件和处理器，也不是担心回调地狱，我们使用了简单的、干净的`set`命令，让Meteor为我们处理所有细节。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating dynamic lists* recipe in [Chapter 3](part0036.xhtml#aid-12AK81
    "Chapter 3. Building Great User Interfaces"), *Building Great User Interfaces*
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](part0036.xhtml#aid-12AK81 "第3章。构建出色的用户界面")的*创建动态列表*食谱中，*构建出色的用户界面*
- en: The *Creating and consuming a reactive value* recipe in this chapter
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*创建和消费反应值*食谱
- en: Making a custom library reactive
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义库的反应性
- en: Because we so often deal with variables and data, it can go unnoticed that Meteor's
    reactivity doesn't only work with reactive values. Any function from any JavaScript
    library can be turned into a reactive provider. This recipe will show you how
    to create your own reactive providers using the `Tracker.depend()` and `Tracker.changed()`
    commands.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们经常处理变量和数据，所以有时会忽略 Meteor 的响应性不仅适用于响应式值。任何 JavaScript 库中的任何函数都可以被转换成响应式提供者。这个配方将向你展示如何使用
    `Tracker.depend()` 和 `Tracker.changed()` 命令创建自己的响应式提供者。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To keep the example simple, we will use a default Meteor project, with a `bootstrap`
    package, and a random color generator. Open a terminal window, navigate to where
    you would like to create your root project, and execute the following commands:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例简单，我们将使用默认的 Meteor 项目，包含一个 `bootstrap` 包和一个随机颜色生成器。打开一个终端窗口，导航到您想要创建根项目的地方，并执行以下命令：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's pretend you have a (pretty awesome) library called `colorsaurus`. Your
    `colorsaurus` object likes to roar. A lot. Mostly because "rawr" means "I love
    you" in dinosaur, but also because the colorsaurus wants to share as many random
    colors as possible with all his friends. Whenever you ask this motley beast for
    a color, he instantly gives you a random color. This is obviously the most useful
    library ever written, so let's get to work building it!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你有一个（相当酷）的库叫做 `colorsaurus`。你的 `colorsaurus` 对象喜欢咆哮。很多。主要是因为在恐龙语中，“rawr”意味着“我爱你”，而且
    `colorsaurus` 希望尽可能多地与所有朋友分享随机颜色。每次你从这个杂色生物那里请求一个颜色时，它会立即给你一个随机颜色。这显然是有史以来最有用的库，所以让我们开始构建它！
- en: 'Open `customreactive.js` and add the following `colorsaurus` object just below
    the `Template` declarations, inside the `Meteor.isClient` conditional:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `customreactive.js` 并在 `Template` 声明下方添加以下 `colorsaurus` 对象，位于 `Meteor.isClient`
    条件语句内：
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'While we''re in `customreactive.js`, let''s add the `numcolor` helper function.
    Locate the `Template.hello.helpers` method and add the following to the top of
    the method:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在 `customreactive.js` 中时，让我们添加 `numcolor` 辅助函数。定位到 `Template.hello.helpers`
    方法，并在方法顶部添加以下内容：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save your changes, navigate to `http://localhost:3000`, and in the console
    window, type the following commands:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改，导航到 `http://localhost:3000`，并在控制台窗口中输入以下命令：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should get a random color and a nice, short *I love you* from our friend,
    the `colorsaurus` function:![How to do it…](img/image00376.jpeg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会得到一个随机颜色和来自我们的朋友 `colorsaurus` 函数的一个简洁的 *我爱你*：![如何操作…](img/image00376.jpeg)
- en: 'It''s not reactive yet, but we need to prepare our UI first, for all the awesomeness
    that a reactive `colorsaurus` function can unleash. Open `customreactive.html`
    and make the following modifications to the `hello` template:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还不是响应式的，但我们需要先准备我们的用户界面，以便释放响应式 `colorsaurus` 函数的所有强大功能。打开 `customreactive.html`
    并对 `hello` 模板进行以下修改：
- en: '[PRE25]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We now need to change our `click` event to make `colorsaurus` roar. In `customreactive.js`,
    modify the `Template.hello.events` section as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更改 `click` 事件以使 `colorsaurus` 发出咆哮声。在 `customreactive.js` 中修改 `Template.hello.events`
    部分，如下所示：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All that''s left to do is make `colorsaurus` reactive and set up an `autorun`
    function. Open `customreactive.js` again and add the following reactive statements,
    including adding the `Tracker.Depenency` object:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的工作就是让 `colorsaurus` 具有响应性并设置一个 `autorun` 函数。再次打开 `customreactive.js` 并添加以下响应式语句，包括添加
    `Tracker.Depenency` 对象：
- en: '[PRE27]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, add a `Tracker.autorun` function, immediately after the `colorsaurus`
    code block, as shown in the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `colorsaurus` 代码块之后立即添加一个 `Tracker.autorun` 函数，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Save your changes, go to your browser, and click on the button as many times
    as your little 'colorsaurus-lovin' heart wishes. You'll get some really great
    color combinations, as shown in the following screenshot:![How to do it…](img/image00377.jpeg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改，转到您的浏览器，并点击按钮，直到您的小小心灵渴望为止。您将获得一些非常棒的颜色组合，如下面的截图所示：![如何操作…](img/image00377.jpeg)
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Notice how the button, text, and the page background change, and they all change
    to random, separate colors. That's because we used a reactive library function
    that returns a random color each time it is called instead of returning a set
    variable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意按钮、文本和页面背景是如何变化的，并且它们都变成了随机、不同的颜色。这是因为我们使用了一个响应式库函数，每次调用时都会返回一个随机颜色，而不是返回一个固定的变量。
- en: By having our `color()` function return the result of `randomColor()`, we are
    ensuring that every time `colorsaurus.color()` is called, we get a different result.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让我们的 `color()` 函数返回 `randomColor()` 的结果，我们确保每次调用 `colorsaurus.color()` 时，都会得到不同的结果。
- en: We added `colorDep.depend()` to the returning function, which logs the computations
    that are created by either `Tracker.autorun` or by a reactive template (see the
    *Creating and consuming a reactive value* recipe found in this chapter for a full
    explanation).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在返回函数中添加了 `colorDep.depend()`，这会记录由 `Tracker.autorun` 或响应式模板（见本章中 *创建和消费响应式值*
    的配方，以获取完整解释）创建的计算。
- en: Finally, we called `colorDep.changed()`, which runs the logged computations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用了 `colorDep.changed()`，这会运行记录的计算。
- en: 'Every part of the code is separate from—and therefore not dependent on—the
    other code parts or libraries. Through the `Tracker.Dependency` object, Meteor
    keeps track of everything for us so we can add or remove reactive dependencies
    at will. Try, for example, running the following line in your browser console:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的每一部分都是独立的，因此不依赖于其他代码部分或库。通过 `Tracker.Dependency` 对象，Meteor 会为我们跟踪一切，这样我们就可以随意添加或删除响应式依赖项。例如，尝试在您的浏览器控制台中运行以下行：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, every time you click the button on the page, you get yet another random
    color from the `colorsaurus`, printed to your console:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次您点击页面上的按钮时，您都会从 `colorsaurus` 获得另一个随机颜色，并将其打印到您的控制台：
- en: '![How it works…](img/image00378.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/image00378.jpeg)'
- en: This is reactive programming at its very best. Rawr!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最好的响应式编程。Rawr！
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using reactivity with HTML attributes* recipe in [Chapter 3](part0036.xhtml#aid-12AK81
    "Chapter 3. Building Great User Interfaces"), *Building Great User Interfaces*
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](part0036.xhtml#aid-12AK81 "第3章。构建出色的用户界面") 中 *使用响应性与HTML属性* 的配方，*构建出色的用户界面*'
- en: The *Creating and consuming a reactive value* recipe in this chapter
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *创建和消费响应式值* 的配方
- en: Updating Blaze templates without Mongo
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无Mongo更新Blaze模板
- en: Not everything in our UI has to be dependent on Mongo collections. We can, in
    fact, use pretty much any reactive object inside our templates, and changes will
    appear instantly. This recipe will quickly show you how to use custom collections
    to populate and update UI templates.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户界面中的并非所有内容都必须依赖于Mongo集合。实际上，我们可以在模板中使用几乎任何响应式对象，并且更改将立即显示。这个配方将快速向您展示如何使用自定义集合来填充和更新UI模板。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start with a base Meteor project and add the `bootstrap` and `reactive-var`
    packages. In a terminal window, navigate to where you would like your project
    to reside and enter the following commands:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础 Meteor 项目开始，并添加 `bootstrap` 和 `reactive-var` 包。在终端窗口中，导航到您希望项目驻留的位置，并输入以下命令：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, open a browser and navigate to `http://localhost:3000` so that you
    can see updates in real time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开浏览器并导航到 `http://localhost:3000`，以便您可以看到实时更新。
- en: How to do it…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will create a simple array of button press snapshots, with a new element
    being added to the array every time the button on the page is clicked. Subsequently,
    these buttons will be added to the UI using a `{{#each}}` template block.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的按钮点击快照数组，每次页面上的按钮被点击时，都会向数组中添加一个新元素。随后，这些按钮将使用 `{{#each}}` 模板块添加到
    UI 中。
- en: 'First, open `mongoless.html` and add the following block to the `hello` template,
    just after the `<p>` element and just before the closing `</template>` tag, as
    shown in the following example:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 `mongoless.html` 并将以下块添加到 `hello` 模板中，紧随 `<p>` 元素之后，并在关闭 `</template>`
    标签之前，如下例所示：
- en: '[PRE31]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now need to add a reactive variable and append some helpers to the `Template.hello.helpers`
    object. Open `mongoless.js` and add the following highlighted code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个响应式变量并将一些辅助函数附加到 `Template.hello.helpers` 对象上。打开 `mongoless.js` 并添加以下高亮代码：
- en: '[PRE32]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'All that''s left to do is to update the `presses` variable each time the button
    is pressed. Inside `Template.hello.events`, in the `''click button''` event handler,
    add the following lines of code immediately after the `Session.set()` call:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的只是每次按钮被按下时更新 `presses` 变量。在 `Template.hello.events` 中，在 `'click button'`
    事件处理程序中，在 `Session.set()` 调用之后立即添加以下代码行：
- en: '[PRE33]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Save all of your changes, go to your browser, and start clicking on the button
    labeled **Click Me**. You should see a new button created each time you click
    on the button, similar to the following:![How to do it…](img/image00379.jpeg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有更改，打开你的浏览器，并开始点击标记为 **点击我** 的按钮。你应该会在每次点击按钮时看到一个新按钮被创建，类似于以下内容：![如何操作…](img/image00379.jpeg)
- en: How it works…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'When we added the `buttonPresses` helper function to the `Template.hello.helpers`
    object, we simply replaced what we would usually use a Mongo collection for with
    a simple array stored inside a `ReactiveVar` element:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `buttonPresses` 辅助函数添加到 `Template.hello.helpers` 对象时，我们只是用存储在 `ReactiveVar`
    元素内的简单数组替换了我们通常会用 MongoDB 集合来做的操作：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Collections are reactive providers, which means they track and rerun computations
    as appropriate. The `presses` object is also a reactive provider, and therefore,
    does the exact same thing. It reruns any stored computations / reactive functions
    whenever the value is updated. In this case, it reruns computations when the array
    is modified, and `presses.set()` is called as a result.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是响应式提供者，这意味着它们会根据需要跟踪和重新运行计算。`presses` 对象也是一个响应式提供者，因此它执行完全相同的事情。当值更新时，它会重新运行任何存储的计算/响应式函数。在这种情况下，当数组被修改并且调用
    `presses.set()` 时，它会重新运行计算。
- en: See also
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating dynamic lists* recipe in [Chapter 3](part0036.xhtml#aid-12AK81
    "Chapter 3. Building Great User Interfaces"), *Building Great User Interfaces*
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 章](part0036.xhtml#aid-12AK81 "第 3 章。构建出色的用户界面")中的 *Creating dynamic lists*
    菜谱，*Building Great User Interfaces*'
- en: The *Creating and consuming a reactive value* recipe in this chapter
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *Creating and consuming a reactive value* 菜谱
- en: Using inline data to modify UI elements reactively
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内联数据动态修改 UI 元素
- en: Typically, when elements in an HTML page are rendered, then that rendering isn't
    directly linked to any of the data used to create them, for example, if we have
    an array of objects, we may generate some HTML by iterating over the array and
    adding `<div>` elements for each object in the array. Unless we do something to
    manually link them to the array of objects, these newly created elements aren't
    associated with the data that created them in any way. This leads to all kinds
    of development shenanigans, as developers try to shoehorn in associative data,
    which is used in events and other downstream functions. Long story short, using
    only existing web technologies, it's difficult to keep all of the data exactly
    in sync with your HTML DOM elements. Meteor has been designed to help solve this
    problem gracefully, keeping track of the context of each DOM element and therefore
    allowing instant access to the data used to create the element in the first place.
    This recipe will walk you through how to retrieve and use the data associated
    with individual DOM elements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当 HTML 页面中的元素被渲染时，这种渲染并不直接与创建它们的任何数据相关联，例如，如果我们有一个对象数组，我们可能会通过遍历数组并为数组中的每个对象添加
    `<div>` 元素来生成一些 HTML。除非我们手动将它们与对象数组相关联，否则这些新创建的元素在没有任何方式与创建它们的数据相关联。这导致开发者尝试强行加入关联数据，这些数据用于事件和其他下游函数。简而言之，仅使用现有的网络技术，很难确保所有数据与
    HTML DOM 元素完全同步。Meteor 被设计用来优雅地解决这个问题，跟踪每个 DOM 元素的上下文，因此允许即时访问最初创建元素时使用的数据。这个菜谱将指导你如何检索和使用与单个
    DOM 元素关联的数据。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the code base from the *Updating Blaze templates without Mongo*
    recipe, found in this chapter. Please complete that recipe and then add the `randomcolor`
    package by running the following terminal command in the root folder of your project:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章中找到的 *Updating Blaze templates without Mongo* 菜谱中的代码库。请完成该菜谱，然后在项目根目录中运行以下终端命令来添加
    `randomcolor` 包：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Have your browser open to `http://localhost:3000` as well so we can see the
    changes in real time.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保你的浏览器也打开到 `http://localhost:3000`，这样我们就可以实时看到更改。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We are going to add some functionality to the existing button creation. First,
    we'll add a random color to each new button; second, we'll remove this color when
    the buttons are clicked; and third, we'll restore the color based on the associative
    inline data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向现有的按钮创建功能添加一些功能。首先，我们将为每个新按钮添加一个随机颜色；其次，当按钮被点击时，我们将移除该颜色；第三，我们将根据关联的内联数据恢复颜色。
- en: So let's get started. We need to update the `hello` template, setting the initial
    background colors for new buttons. We also need a way to remove those colors at
    random. We'll do this by adding a new control button.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。我们需要更新`hello`模板，为新按钮设置初始背景颜色。我们还需要一种随机移除这些颜色的方法。我们将通过添加一个新的控制按钮来实现这一点。
- en: 'Open your `.html` file (probably `mongoless.html`) and modify the `hello` template
    to look like the following:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`.html`文件（可能是`mongoless.html`），修改`hello`模板以使其看起来如下：
- en: '[PRE36]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We now need to add the `btnColor` helper to `Template.hello.helpers` and modify
    the data object being stored to make room for the new color. We also need to refine
    the `click` events on the buttons to differentiate between adding a new button
    and removing a button''s color. Open your `.js` file (probably called `mongoless.js`)
    and make the following changes to the variable declarations and the helpers:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将`btnColor`辅助函数添加到`Template.hello.helpers`中，并修改存储的数据对象以为新颜色腾出空间。我们还需要细化按钮上的`click`事件，以区分添加新按钮和移除按钮颜色。打开你的`.js`文件（可能是`mongoless.js`），对变量声明和辅助函数进行以下更改：
- en: '[PRE37]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we need to modify the existing `click` event, add a new event to remove
    color, and add one final handler to set up all the new buttons to regain their
    color when clicked. Make the following changes to the `Template.hello.events`
    section:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要修改现有的`click`事件，添加一个新的事件来移除颜色，并添加一个最终的处理程序来设置所有新按钮在点击时恢复颜色。对`Template.hello.events`部分进行以下更改：
- en: '[PRE38]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Save all your changes and click on the **Click Me** Button on your screen 5-10
    times. You'll notice that all the new buttons being added have a random color
    assigned to them, as shown in the following screenshot:![How to do it...](img/image00380.jpeg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有更改并点击屏幕上的**点击我**按钮5-10次。你会注意到所有新添加的按钮都被分配了随机颜色，如下面的截图所示：![如何操作...](img/image00380.jpeg)
- en: Now, click on the **Or Me!** button multiple times. At random, the buttons will
    lose their random color and change to the default `btn-info` blue color provided
    by `bootstrap`, as shown in the following screenshot:![How to do it...](img/image00381.jpeg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，多次点击**或我**按钮。随机地，按钮会失去随机颜色并变为由`bootstrap`提供的默认`btn-info`蓝色，如下面的截图所示：![如何操作...](img/image00381.jpeg)
- en: Any of the buttons that have lost their color can regain the color by clicking
    directly on the button.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 任何失去颜色的按钮都可以通过直接点击按钮来恢复颜色。
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The crux of this recipe is found inside the `''click .pressed''` event handler.
    There, we assign the `backgroundColor` attribute of the clicked button to `this.color`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的核心在于`'click .pressed'`事件处理程序内部。在那里，我们将点击按钮的`backgroundColor`属性分配给`this.color`：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this case, there is a reference to the associated data object for that DOM
    element. Meteor keeps track of how each element is created. So when an event is
    fired inside the template, Meteor provides the data object as the *context* (the
    `this`) in the event handler. In this way, Meteor can provide instant access to
    the inline data for each rendered element.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，有一个对该DOM元素相关联的数据对象的引用。Meteor跟踪每个元素是如何创建的。因此，当模板内部发生事件时，Meteor将数据对象作为*上下文*（即`this`）在事件处理程序中提供。这样，Meteor可以提供对每个渲染元素的内置数据的即时访问。
- en: 'Notice that even after we manually changed the `backgroundColor` using the
    `''click #chgColor''` event, Meteor still has a reference to the data object used
    to render the element. This becomes important because we now no longer need to
    store data as an attribute of the DOM element—no more `data-color` or `data-whatever`
    attributes that clutter up the UI and potentially expose data. The data objects,
    though hidden from the UI, are available instantly and inline. So no fancy calculations
    or DOM manipulation needs to be done in order to access the necessary contextual
    data.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，即使我们手动使用`''click #chgColor''`事件更改了`backgroundColor`，Meteor仍然保留用于渲染元素的data对象的引用。这变得很重要，因为我们现在不再需要将数据作为DOM元素的属性存储——不再需要`data-color`或`data-whatever`属性来杂乱无章地填充UI并可能暴露数据。虽然数据对象对UI是隐藏的，但它们可以立即和直接地访问。因此，为了访问必要的相关数据，不需要进行任何复杂的计算或DOM操作。'
- en: There's more…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The preceding example uses the default Meteor `Template` event handlers, so
    of course, the data is available. But, even if you bypass Meteor's `Template`
    event handlers and use, say, jQuery events instead, the associated data will be
    available by calling the `Blaze.getData()` function of the element.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用默认的 Meteor `Template` 事件处理器，因此当然数据是可用的。但是，即使您绕过 Meteor 的 `Template` 事件处理器并使用，例如，jQuery
    事件，通过调用元素的 `Blaze.getData()` 函数，相关数据也将可用。
- en: 'Setting up the event handler is a little bit tricky in this case. We have to
    first move the population of each button to a new template because the jQuery
    `click` event handler must be run inside of a `rendered()` function callback.
    To accomplish this, make the following changes to your `.html` file (probably
    `mongoless.html`):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下设置事件处理器有点棘手。我们必须首先将每个按钮的填充移动到新的模板中，因为 jQuery `click` 事件处理器必须在 `rendered()`
    函数回调内部运行。为此，请对您的 `.html` 文件（可能是 `mongoless.html`）进行以下更改：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You will also need to remove the `''click .pressed''` event handler from `Template.hello.events`.
    Once you''ve removed the event handler, add the `jQuery.click()` event handler
    inside a `Template.btnRank.rendered` code block, to be run immediately upon the
    rendering of a new button, as shown in the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要从 `Template.hello.events` 中移除 `'click .pressed'` 事件处理器。一旦移除事件处理器，请在 `Template.btnRank.rendered`
    代码块内添加 `jQuery.click()` 事件处理器，以便在新按钮渲染时立即运行，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Lastly, because we moved the `div` rendering to the new `helloBtn` template,
    we need to move the `btnRank` and `btnColor` helpers from `Template.hello.helpers`
    to a newly created `Template.helloBtn.helpers` block, as shown in the following
    code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们将 `div` 渲染移动到了新的 `helloBtn` 模板，我们需要将 `btnRank` 和 `btnColor` 辅助函数从 `Template.hello.helpers`
    移动到新创建的 `Template.helloBtn.helpers` 块，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That's a lot of work for the same result, but it helps to illustrate the flexibility
    of the Blaze/Meteor associative data capabilities. We only had to slightly modify
    the event helper to point to `Blaze.getData(this).color` rather than `this.color`.
    Although the same keyword exists in each event handler, the `this` inside the
    jQuery event handler refers to the DOM element, rather than the associated data
    object inside the original Meteor event handler. `Blaze.getData(element)` takes
    a DOM element as an argument and retrieves the associated inline data for that
    element.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项大量工作以获得相同的结果，但它有助于说明 Blaze/Meteor 关联数据功能的灵活性。我们只需稍微修改事件辅助函数，将其指向 `Blaze.getData(this).color`
    而不是 `this.color`。尽管每个事件处理器中都有相同的关键字，但 jQuery 事件处理器内的 `this` 指的是 DOM 元素，而不是原始 Meteor
    事件处理器内的关联数据对象。`Blaze.getData(element)` 以 DOM 元素作为参数，并检索该元素的关联内联数据。
- en: In either case, getting to the associated data is very straightforward and allows
    you to do anything to your UI programmatically, without having to worry about
    destroying/altering the data associated with each rendered element.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，获取相关数据都非常简单，这允许您以编程方式对 UI 进行任何操作，而无需担心破坏/更改与每个渲染元素关联的数据。
- en: See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Inserting templates with Spacebars* and *Creating dynamic lists* recipes
    in [Chapter 3](part0036.xhtml#aid-12AK81 "Chapter 3. Building Great User Interfaces"),
    *Building Great User Interfaces*
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](part0036.xhtml#aid-12AK81 "第 3 章。构建出色的用户界面") 的 *使用 Spacebars 插入模板*
    和 *创建动态列表* 菜谱中，请参阅 [第 3 章](part0036.xhtml#aid-12AK81 "第 3 章。构建出色的用户界面")。
- en: Integrating a jQuery UI
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 jQuery UI
- en: The jQuery library is crazily popular, and for good reason. When used properly,
    it can speed up the development process and give us reliable ways of doing things
    that would otherwise take a lot of coding effort.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 库非常受欢迎，这是有充分理由的。当正确使用时，它可以加快开发过程，并为我们提供可靠的方式来执行那些否则需要大量编码的工作。
- en: A complement to jQuery is jQuery UI, which is a set of widgets, themes, and
    animation effects. With jQuery UI, you can quickly create drag and drop components,
    sortable lists, and lots of other useful UI niceties.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的补充是 jQuery UI，它是一组小部件、主题和动画效果。使用 jQuery UI，您可以快速创建拖放组件、可排序列表以及许多其他有用的
    UI 美化功能。
- en: This recipe will walk you through creating a jQuery UI-sortable widget inside
    a Meteor template.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将指导您在 Meteor 模板中创建一个 jQuery UI-sortable 小部件。
- en: Getting ready
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will definitely want client and server folders to keep the
    code clean and readable. To accomplish this, we will rely on our default template
    scaffolding. Please create a new project called `swatches` using the *Setting
    up your project file structure* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Optimizing Your Workflow"), *Optimizing Your Workflow*, as your starting
    file structure.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们肯定希望客户端和服务器文件夹保持代码的整洁和可读性。为了实现这一点，我们将依赖我们的默认模板脚手架。请使用 [第 1 章](part0015.xhtml#aid-E9OE1
    "第 1 章。优化你的工作流程") 中 *设置你的项目文件结构* 配方创建一个名为 `swatches` 的新项目，作为你的起始文件结构。
- en: 'Once you''ve completed the scaffolding, we will need to add the `randomcolor`
    package to our project. In a terminal window, navigate to the root folder of your
    project and run the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成脚手架搭建，我们需要将 `randomcolor` 包添加到我们的项目中。在终端窗口中，导航到你的项目根目录，并运行以下命令：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will also want a nice theme, so let''s use the adapted version of Google''s
    Material Design theme, for funzies. Enter the following command in the same terminal
    window:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望有一个漂亮的主题，所以让我们使用 Google 的 Material Design 主题的修改版，以增添乐趣。在相同的终端窗口中输入以下命令：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we want to get a customized version of jQuery UI directly from `jqueryui.com`.
    Navigate to [http://jqueryui.com/](http://jqueryui.com/) in a browser and click
    on **Custom Download**, placed toward the right:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要直接从 `jqueryui.com` 获取 jQuery UI 的定制版本。在浏览器中导航到 [http://jqueryui.com/](http://jqueryui.com/)，并点击右侧的
    **Custom Download**：
- en: '![Getting ready](img/image00382.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/image00382.jpeg)'
- en: 'In the download builder, make the following selections:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载构建器中，进行以下选择：
- en: Select the latest stable version
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择最新稳定版本
- en: Uncheck the **Toggle** **All** checkbox under **Components**
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **Components** 下取消选择 **Toggle All** 复选框
- en: Check the **Toggle** **All** checkbox under **UI** **Core**
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **UI Core** 下选择 **Toggle All** 复选框
- en: Check the **Sortable** checkbox under **Interactions**
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **Interactions** 下选择 **Sortable** 复选框
- en: At the bottom, select **No** **Theme** from the **Theme** dropdown
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底部，从 **Theme** 下拉菜单中选择 **No Theme**
- en: 'Your selections will look similar to the following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你的选择将类似于以下截图：
- en: '![Getting ready](img/image00383.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/image00383.jpeg)'
- en: All we need is the sortable interaction and the UI core. Everything else just
    adds to our file size, so we'll leave it out. Click on **Download**, unzip the
    downloaded file once complete, locate the `jquery-ui.min.js` file, and copy it
    to your `[project root]/client/lib/scripts` folder.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要可排序交互和 UI 核心。其他所有内容都会增加我们的文件大小，所以我们将省略它们。点击 **Download**，下载完成后解压文件，找到 `jquery-ui.min.js`
    文件，并将其复制到 `[project root]/client/lib/scripts` 文件夹中。
- en: We could simply pull in jQuery UI using a community package, but it's a bit
    bulkier and it doesn't help us see how non-packaged third-party libraries can
    be used inside Meteor. So, we'll go with this manual installation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用社区包引入 jQuery UI，但它体积较大，并且不能帮助我们了解如何在 Meteor 中使用未打包的第三方库。因此，我们将采用这种手动安装方式。
- en: Open a browser to `http://localhost:3000` so we can see the changes in real
    time. We are now ready to add the jQuery UI-sortable widget to our project.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器到 `http://localhost:3000`，以便我们可以实时查看更改。我们现在已准备好将 jQuery UI-sortable 小部件添加到我们的项目中。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will create color swatches, which will display the hexadecimal code they
    represent, and they will be sortable, which means we can move them around via
    drag and drop.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建色卡，它们将显示它们所代表的十六进制代码，并且它们将是可排序的，这意味着我们可以通过拖放来移动它们。
- en: 'To accomplish this, we first need to create a `Swatches` collection, accessible
    on both the client and the server. In your `[project root]/both/` folder, create/edit
    a file named `model.js` and add the following collection declaration:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现这一点，我们首先需要创建一个 `Swatches` 集合，该集合在客户端和服务器上均可访问。在你的 `[project root]/both/`
    文件夹中，创建或编辑一个名为 `model.js` 的文件，并添加以下集合声明：
- en: '[PRE45]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, let''s create our UI using a template named `swatches`. Open/create the
    `[project root]/client/main.html` file, remove all the contents, and add the following
    code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用名为 `swatches` 的模板创建我们的用户界面。打开或创建 `[project root]/client/main.html`
    文件，删除所有内容，并添加以下代码：
- en: '[PRE46]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will want to style it just a little bit to make the swatches consistently
    sized. Open/create a file named `[project root]/client/lib/styles/style.css` and
    add the following CSS declarations:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望对其进行一点格式化，以便使色卡尺寸保持一致。打开或创建一个名为 `[project root]/client/lib/styles/style.css`
    的文件，并添加以下 CSS 声明：
- en: '[PRE47]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we will create the logic needed to add swatches and be able to drag
    them around the screen. Open/create the `[project root]/client/scripts/main.js`
    file, delete anything inside the file, and add the following `Template.helpers`
    and `Rankings` declarations:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建添加色卡并能够将它们拖动到屏幕上的逻辑。打开/创建 `[项目根]/client/scripts/main.js` 文件，删除文件内的所有内容，并添加以下
    `Template.helpers` 和 `Rankings` 声明：
- en: '[PRE48]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, the fun part! We will create the `jQuery.sortable` object with its `stop()`
    function and hook up our `button.click` event handler using regular jQuery. In
    order for the `sortable` and `click` event handlers to be added properly, we need
    to declare them inside a `Template.rendered()` function. In the same `main.js`
    file, just below the `Rankings` declaration, enter the following code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，有趣的部分来了！我们将创建 `jQuery.sortable` 对象及其 `stop()` 函数，并使用常规 jQuery 将我们的 `button.click`
    事件处理器连接起来。为了正确添加 `sortable` 和 `click` 事件处理器，我们需要在 `Template.rendered()` 函数内部声明它们。在
    `main.js` 文件中，在 `Rankings` 声明下方，输入以下代码：
- en: '[PRE49]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Save all of your changes and hop over to your browser. The page should have
    a nice, stylish blue button labeled **NEW** **COLOR**. Every time you click on
    this button, a new swatch will be added with a random color. If you drag and drop
    any of the swatches from one position to another, the swatches will be reordered
    appropriately. This reordering is not temporary. If you refresh the page or open
    another browser window, the reordering you did via drag and drop will remain.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有更改，然后转到你的浏览器。页面应该有一个标有 **NEW** **COLOR** 的漂亮、时尚的蓝色按钮。每次你点击这个按钮，都会添加一个新的色卡，颜色是随机的。如果你将任何色卡从一个位置拖放到另一个位置，色卡将会适当地重新排序。这种重新排序不是临时的。如果你刷新页面或打开另一个浏览器窗口，你通过拖放所做的重新排序将会保持。
- en: So, for example, let's say you move a swatch from the last element to the first.
    The change will stick and any other clients/browsers that open to the same page
    will instantly reflect the change.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你将色卡从最后一个元素移动到第一个。这个变化将会保持，并且任何打开到同一页面的其他客户端/浏览器将立即反映这个变化。
- en: 'When the following purple swatch is dragged and dropped, the changes will be
    as shown, as displayed on the right-hand side of the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下紫色色卡被拖动并放置时，变化将如以下截图右侧所示：
- en: '![How to do it...](img/image00384.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image00384.jpeg)'
- en: 'It is instantly updated in every UI, as shown in the following screenshot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，它会在每个 UI 中立即更新：
- en: '![How to do it...](img/image00385.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image00385.jpeg)'
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Thanks to our `click` event handler, whenever a swatch is added using `Swatches.insert()`,
    a rank is assigned to that swatch:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们的 `click` 事件处理器，每当使用 `Swatches.insert()` 添加色卡时，都会为该色卡分配一个排名：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we look at the `swatches` helper inside `Template.colors.helpers`, we can
    see that the Mongo `Collection.find()` query is sorted by `rank`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `Template.colors.helpers` 中的 `swatches` 辅助函数，我们可以看到 MongoDB 的 `Collection.find()`
    查询是按 `rank` 排序的：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This preserves the order of the swatches in the UI and allows us to manipulate
    their order as a result of drag and drop.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这保留了 UI 中色卡的顺序，并允许我们通过拖放来操作它们的顺序。
- en: Inside of our `sortable.stop()` function, we were identifying where in the list
    the swatch had been dragged and dropped to. Once we determine where the swatch
    is located, we calculate a new rank for that swatch using the `Rankings` helper
    functions. We then immediately update the `swatches` collection with the new rank,
    which propagates and makes the position of the UI change permanent.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `sortable.stop()` 函数内部，我们正在确定色卡被拖动并放置到列表中的位置。一旦我们确定了色卡的位置，我们就使用 `Rankings`
    辅助函数计算该色卡的新排名。然后我们立即使用新排名更新 `swatches` 集合，这将传播并使 UI 的位置变化永久化。
- en: There's more…
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The key takeaway here is that while jQuery (or any other third-party library)
    may be used to make direct DOM manipulations, these manipulations won't persist
    beyond a single user's session, or even beyond the next DDP change from the server.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点在于，虽然可以使用 jQuery（或任何其他第三方库）来执行直接的 DOM 操作，但这些操作不会超出单个用户的会话，甚至不会超出服务器下一次 DDP
    变更。
- en: To make the manipulations permanent and to fully utilize the Blaze rendering
    engine's fantastic reactive programming model, we need to modify the datasource
    (in this case, the `swatches` collection). The modification is handled immediately,
    and with no effort on our part, through reactivity.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使操作永久化并充分利用 Blaze 渲染引擎的出色响应式编程模型，我们需要修改数据源（在这种情况下，是 `swatches` 集合）。修改将立即处理，而且不需要我们做任何努力，通过响应式来实现。
- en: So, to review, third-party libraries can go right ahead and manipulate DOM elements
    in a Meteor application, with the third-party code being executed inside a `Template.rendered()`
    function block.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了回顾，第三方库可以直接在Meteor应用程序中操作DOM元素，第三方代码将在`Template.rendered()`函数块内部执行。
- en: To make the changes "stick", we simply update the corresponding Mongo collection
    as well. Using this technique, we can integrate nearly every JavaScript library
    out there (if someone hasn't already done it for us on [https://atmospherejs.com/](https://atmospherejs.com/)).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要使更改“生效”，我们只需更新相应的Mongo集合即可。使用这种技术，我们可以几乎集成所有现有的JavaScript库（如果还没有人为我们完成[https://atmospherejs.com/](https://atmospherejs.com/)上的工作）。
- en: See also
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Setting up your project file structure* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Optimizing Your Workflow"), *Optimizing Your Workflow*
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](part0015.xhtml#aid-E9OE1 "第1章。优化你的工作流程")中的*设置你的项目文件结构*配方，*优化你的工作流程*'
- en: The *Using inline data to modify UI elements reactively* recipe in this chapter
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用内联数据动态修改UI元素*配方
