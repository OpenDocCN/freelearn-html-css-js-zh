- en: Chapter 4. Structural Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章 结构型设计模式
- en: While creational patterns play the part of flexibly creating objects, structural
    patterns, on the other hand, are patterns about composing objects. In this chapter,
    we are going to talk about structural patterns that fit different scenarios.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建型模式在灵活创建对象方面发挥作用时，结构型模式另一方面则是关于对象组合的模式。在本章中，我们将讨论适合不同场景的结构型模式。
- en: If we take a closer look at structural patterns, they can be divided into *structural
    class patterns* and *structural object patterns*. Structural class patterns are
    patterns that play with "interested parties" themselves, while structural object
    patterns are patterns that weave pieces together (like Composite Pattern). These
    two kinds of structural patterns complement each other to some degree.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察结构型模式，它们可以分为 *结构型类模式* 和 *结构型对象模式*。结构型类模式是与“相关方”本身玩弄的模式，而结构型对象模式则是将碎片编织在一起的模式（如组合模式）。这两种结构型模式在一定程度上相互补充。
- en: 'Here are the patterns we''ll walk through in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨以下模式：
- en: '**Composite**: Builds tree-like structures using primitive and composite objects.
    A good example would be the DOM tree that forms a complete page.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：使用原始和组合对象构建树状结构。一个很好的例子就是构成完整页面的 DOM 树。'
- en: '**Decorator**: Adds functionality to classes or objects dynamically.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**：动态地为类或对象添加功能。'
- en: '**Adapter**: Provides a general interface and work with different adaptees
    by implementing different concrete adapters. Consider providing different database
    choices for a single content management system.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**：提供了一个通用接口，并通过实现不同的具体适配器与不同的适配器协同工作。例如，可以考虑为单一的内容管理系统提供不同的数据库选择。'
- en: '**Bridge**: Decouples the abstraction from its implementation, and make both
    of them interchangeable.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接**：将抽象与其实现解耦，并使两者可互换。'
- en: '**Façade**: Provides a simplified interface for the combination of complex
    subsystems.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观**：为复杂子系统的组合提供了一个简化的接口。'
- en: '**Flyweight**: Shares stateless objects that are being used many times to improve
    memory efficiency and performance.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**享元**：共享被多次使用的无状态对象，以提高内存效率和性能。'
- en: '**Proxy**: Acts as the surrogate that takes extra responsibilities when accessing
    objects it manages.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：作为代理，在访问它管理的对象时承担额外的责任。'
- en: Composite Pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式
- en: 'Objects under the same class could vary from their properties or even specific
    subclasses, but a complex object can have more than just normal properties. Taking
    DOM elements, for example, all the elements are instances of class `Node`. These
    nodes form tree structures to represent different pages, but every node in these
    trees is complete and uniform compared to the node at the root:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 同一类的对象可能因其属性或甚至特定的子类而有所不同，但一个复杂对象可能不仅仅有普通属性。以 DOM 元素为例，所有元素都是 `Node` 类的实例。这些节点形成树结构来表示不同的页面，但与根节点相比，这些树中的每个节点都是完整且统一的：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding HTML represents a DOM structure like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 HTML 表示一个 DOM 结构，如下所示：
- en: '![Composite Pattern](img/image_04_001.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![组合模式](img/image_04_001.jpg)'
- en: All of the preceding objects are instances of `Node`, they implement the interface
    of a *component* in Composite Pattern. Some of these nodes like HTML elements
    (except for `HTMLImageElement`) in this example have child nodes (components)
    while others don't.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前面对象都是 `Node` 的实例，它们实现了组合模式中 *组件* 的接口。其中一些节点（如本例中的 HTML 元素，除了 `HTMLImageElement`）有子节点（组件），而其他则没有。
- en: Participants
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of Composite Pattern implementation include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式实现的参与者包括：
- en: '**Component**: `Node`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：`节点`'
- en: Defines the interface and implement the default behavior for objects of the
    composite. It should also include an interface to access and manage the child
    components of an instance, and optionally a reference to its parent.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义接口并为组合对象实现默认行为。它还应包括访问和管理实例子组件的接口，以及可选的对其父组件的引用。
- en: '**Composite**: Includes some HTML elements, like `HTMLHeadElement` and `HTMLBodyElement`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：包括一些 HTML 元素，如 `HTMLHeadElement` 和 `HTMLBodyElement`'
- en: Stores child components and implements related operations, and of course its
    own behaviors.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储子组件并实现相关操作，当然也包括其自身的行为。
- en: '**Leaf**: `TextNode`, `HTMLImageElement`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶节点**：`TextNode`，`HTMLImageElement`'
- en: Defines behaviors of a primitive component.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义原始组件的行为。
- en: '**Client**:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：'
- en: Manipulates the composite and its components.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 操作组合及其组件。
- en: Pattern scope
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Composite Pattern applies when objects can and should be abstracted recursively
    as components that form tree structures. Usually, it would be a natural choice
    when a certain structure needs to be formed as a tree, such as trees of view components,
    abstract syntax trees, or trees that represent file structures.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象可以并且应该递归地作为形成树结构的组件进行抽象时，适用组合模式。通常，当需要形成某种结构作为树时，这会是一个自然的选择，例如视图组件的树、抽象语法树或表示文件结构的树。
- en: Implementation
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: We are going to create a composite that represents simple file structures and
    has limited kinds of components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个表示简单文件结构并具有有限组件类型的组合体。
- en: 'First of all, let''s import related node modules:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入相关的节点模块：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Module `path` and `fs` are built-in modules of Node.js, please refer to Node.js
    documentation for more information: [https://nodejs.org/api/](https://nodejs.org/api/).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 `path` 和 `fs` 是 Node.js 的内置模块，请参阅 Node.js 文档以获取更多信息：[https://nodejs.org/api/](https://nodejs.org/api/).
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is my personal preference to have the first letter of a namespace (if it's
    not a function at the same time) in uppercase, which reduces the chance of conflicts
    with local variables. But a more popular naming style for namespace in JavaScript
    does not.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的偏好是，如果命名空间（同时不是函数）的首字母大写，这可以减少与局部变量的冲突机会。但 JavaScript 中命名空间的一种更流行的命名风格并不这样做。
- en: 'Now we need to make abstraction of the components, say `FileSystemObject`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对组件进行抽象，比如 `FileSystemObject`：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are using `abstract class` because we are not expecting to use `FileSystemObject`
    directly. An optional `parent` property is defined to allow us to visit the upper
    component of a specific object. And the `basename` property is added as a helper
    for getting the basename of the path.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `抽象类`，因为我们不期望直接使用 `FileSystemObject`。定义了一个可选的 `parent` 属性，以便我们可以访问特定对象的上级组件。还添加了
    `basename` 属性，作为获取路径基本名的辅助工具。
- en: 'The `FileSystemObject` is expected to have subclasses, `FolderObject` and `FileObject`.
    For `FolderObject`, which is a composite that may contain other folders and files,
    we are going to add an `items` property (getter) that returns other `FileSystemObject`
    it contains:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystemObject` 预期应该有子类，即 `FolderObject` 和 `FileObject`。对于 `FolderObject`，它是一个可能包含其他文件夹和文件的组合体，我们将添加一个
    `items` 属性（获取器），它返回它包含的其他 `FileSystemObject`：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can initialize the `items` property in the `constructor` with actual files
    and folders existing at given `path`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `constructor` 中初始化 `items` 属性，以实际存在于给定 `path` 的文件和文件夹：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may have noticed we are forming `items` with different kinds of objects,
    and we are also passing `this` as the `parent` of newly created child components.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们正在使用不同类型的对象来形成 `items`，同时我们也在将 `this` 作为新创建的子组件的 `parent` 传递。
- en: 'And for `FileObject`, we''ll add a simple `readAll` method that reads all bytes
    of the file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `FileObject`，我们将添加一个简单的 `readAll` 方法，该方法读取文件的所有字节：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Currently, we are reading the child items inside a folder from the actual filesystem
    when a folder object gets initiated. This might not be necessary if we want to
    access this structure on demand. We may actually create a getter that calls `readdir`
    only when it's accessed, thus the object would act like a proxy to the real filesystem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当文件夹对象被初始化时，我们从实际的文件系统中读取文件夹内的子项。如果我们希望按需访问此结构，这可能不是必要的。我们实际上可以创建一个获取器，仅在访问时调用
    `readdir`，这样对象就会像真实文件系统的代理一样操作。
- en: Consequences
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Both the primitive object and composite object in Composite Pattern share the
    component interface, which makes it easy for developers to build a composite structure
    with fewer things to remember.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式中的原始对象和组合对象都共享组件接口，这使得开发者可以更容易地使用较少要记住的事物构建组合结构。
- en: It also enables the possibility of using markup languages like XML and HTML
    to represent a really complex object with extreme flexibility. Composite Pattern
    can also make the rendering easier by having components rendered recursively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使得使用像 XML 和 HTML 这样的标记语言来表示极其复杂的对象成为可能，具有极大的灵活性。组合模式还可以通过递归渲染组件来简化渲染。
- en: As most components are compatible with having child components or being child
    components of their parents themselves, we can easily create new components that
    work great with existing ones.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数组件都兼容拥有子组件或成为其父组件的子组件，我们可以轻松地创建与现有组件配合得很好的新组件。
- en: Decorator Pattern
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: Decorator Pattern adds new functionality to an object dynamically, usually without
    compromising the original features. The word decorator in Decorator Pattern does
    share something with the word decorator in the ES-next decorator syntax, but they
    are not exactly the same. Classical Decorator Pattern as a phrase would differ
    even more.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式可以动态地向对象添加新功能，通常不会损害原始功能。装饰器模式中的“装饰器”一词与 ES-next 装饰器语法中的“装饰器”一词确实有一些相似之处，但它们并不完全相同。作为短语，经典的装饰器模式差异更大。
- en: The classical Decorator Pattern works with a composite, and the brief idea is
    to create decorators as components that do the decorating work. As composite objects
    are usually processed recursively, the decorator components would get processed
    automatically. So it becomes your choice to decide what it does.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的装饰器模式与组合一起工作，简而言之，就是创建作为装饰工作的组件的装饰器。由于组合对象通常递归处理，装饰器组件会自动处理。因此，您可以选择它要做什么。
- en: 'The inheritance hierarchy could be like the following structure shown:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 继承层次结构可能如下所示的结构：
- en: '![Decorator Pattern](img/image_04_002.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![装饰器模式](img/image_04_002.jpg)'
- en: 'The decorators are applied recursively like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是递归应用的，如下所示：
- en: '![Decorator Pattern](img/image_04_003.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![装饰器模式](img/image_04_003.jpg)'
- en: 'There are two prerequisites for the decorators to work correctly: the awareness
    of context or object that a decorator is decorating, and the ability of the decorators
    being applied. The Composite Pattern can easily create structures that satisfy
    those two prerequisites:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器正确工作有两个先决条件：装饰器所装饰的上下文或对象的认识，以及应用装饰器的能力。组合模式可以轻松创建满足这两个先决条件的结构：
- en: The decorator knows what it decorates as the `component` property
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器知道它装饰的内容，作为 `component` 属性
- en: The decorator gets applied when it is rendered recursively
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器在递归渲染时应用
- en: However, it doesn't really need to take a structure like a composite to gain
    the benefits from Decorator Pattern in JavaScript. As JavaScript is a dynamic
    language, if you can get your decorators called, you may add whatever you want
    to an object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上并不需要采用组合结构来在 JavaScript 中获得装饰器模式的好处。由于 JavaScript 是一种动态语言，如果您能调用装饰器，您就可以向对象添加任何您想要的内容。
- en: 'Taking method `log` under `console` object as an example, if we want a timestamp
    before every log, we can simply replace the `log` function with a wrapper that
    has the timestamp prefixed:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `console` 对象下的 `log` 方法为例，如果我们想在每次日志前添加时间戳，我们可以简单地用带有时间戳前缀的包装器替换 `log` 函数：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Certainly, this example has little to do with the classical Decorator Pattern,
    but it enables a different way for this pattern to be done in JavaScript. Especially
    with the help of new decorator syntax:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子与经典的装饰器模式关系不大，但它为在 JavaScript 中实现这种模式提供了一种不同的方法。特别是借助新的装饰器语法：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'TypeScript provides the decorator syntax transformation as an experimental
    feature. To learn more about decorator syntax, please check out the following
    link: [http://www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 提供了装饰器语法转换作为一项实验性功能。要了解更多关于装饰器语法的知识，请查看以下链接：[http://www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html)。
- en: Participants
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of classical Decorator Pattern implementation include:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 经典装饰器模式实现的参与者包括：
- en: '**Component**: `UIComponent`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：`UIComponent`'
- en: Defines the interface of the objects that can be decorated.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义可以装饰的对象的接口。
- en: '**ConcreteComponent**: `TextComponent`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体组件**：`TextComponent`'
- en: Defines additional functionalities of the concrete component.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义具体组件的附加功能。
- en: '**Decorator**: `Decorator`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**：`Decorator`'
- en: Defines a reference to the component to be decorated, and manages the context.
    Conforms the interface of a component with proper behaviors.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义对要装饰的组件的引用，并管理上下文。使组件符合适当的接口和行为。
- en: '**ConcreteDecorator**: `ColorDecorator`, `FontDecorator`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体装饰器**：`ColorDecorator`, `FontDecorator`'
- en: Defines additional features and exposes API if necessary.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义额外的功能，并在必要时暴露 API。
- en: Pattern scope
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Decorator Pattern usually cares about objects, but as JavaScript is prototype-based,
    decorators would work well with the classes of objects through their prototypes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式通常关注对象，但由于 JavaScript 是基于原型的，装饰器可以通过它们的原型很好地与对象的类一起工作。
- en: The classical implementation of Decorator Pattern could have much in common
    with other patterns we are going to talk about later, while the function one seems
    to share less.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式的经典实现可能与其他我们稍后将要讨论的模式有很多共同之处，而函数式装饰器似乎共享较少。
- en: Implementation
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: In this part, we'll talk about two implementations of Decorator Pattern. The
    first one would be classical Decorator Pattern that decorates the target by wrapping
    with new classes that conform to the interface of `UIComponent`. The second one
    would be decorators written in new decorator syntax that processes target objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将讨论装饰器模式的两种实现。第一个将是经典的装饰器模式，通过包装符合 `UIComponent` 接口的新类来装饰目标。第二个将是使用新装饰器语法编写的装饰器，它处理目标对象。
- en: Classical decorators
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典装饰器
- en: 'Let''s get started by defining the outline of objects to be decorated. First,
    we''ll have the `UIComponent` as an abstract class, defining its abstract function
    `draw`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义要装饰的对象的轮廓开始。首先，我们将 `UIComponent` 定义为一个抽象类，定义其抽象函数 `draw`：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then a `TextComponent` that extends the  `UIComponent`, as well as its text
    contents of class `Text`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一个扩展了 `UIComponent` 的 `TextComponent`，以及其文本内容为 `Text` 类：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What''s next is to define the interface of decorators to decorate objects that
    are instances of class `TextComponent`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要定义装饰器的接口，以便装饰 `TextComponent` 类的实例对象：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we have everything for concrete decorators. In this example, `ColorDecorator`
    and `FontDecorator` look similar:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了具体的装饰器。在这个例子中，`ColorDecorator` 和 `FontDecorator` 看起来很相似：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the implementation just described, `this.texts` in `draw` method calls the
    getter defined on class `Decorator`. As this in that context would ideally be
    an instance of class `ColorDecorator` or `FontDecorator`; the `texts` it accesses
    would finally be the array in its `component` property.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述实现中，`draw` 方法中的 `this.texts` 调用了在 `Decorator` 类上定义的 getter。在这个上下文中，`this`
    理想情况下应该是 `ColorDecorator` 或 `FontDecorator` 的实例；它访问的 `texts` 最终将是其 `component`
    属性中的数组。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This could be even more interesting or confusing if we have nested decorators
    like we will soon. Try to draw a schematic diagram if it confuses you later.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有嵌套装饰器，这可能会更有趣或更令人困惑。如果你后来感到困惑，试着画一个示意图。
- en: 'Now it''s time to actually assemble them:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是真正组装它们的时候了：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The order of nesting decorators does not matter in this example. As either `ColorDecorator`
    or `FontDecorator` is a valid `UIComponent`, they can be easily dropped in and
    replace previous `TextComponent`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，装饰器的嵌套顺序并不重要。因为无论是 `ColorDecorator` 还是 `FontDecorator` 都是一个有效的 `UIComponent`，它们可以很容易地插入并替换之前的
    `TextComponent`。
- en: Decorators with ES-next syntax
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ES-next 语法装饰器
- en: 'There is a limitation with classical Decorator Pattern that can be pointed
    out directly via its nesting form of decorating. That applies to ES-next decorators
    as well. Take a look at the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 经典装饰器模式有一个限制，可以通过装饰的嵌套形式直接指出。这也适用于 ES-next 装饰器。看看下面的例子：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: What follows the `@` character is an expression that evaluates to a decorator.
    While a decorator is a function that processes target objects, we usually use
    higher-order functions to parameterize a decorator.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`@` 字符后面的表达式评估为装饰器。虽然装饰器是一个处理目标对象的函数，但我们通常使用高阶函数来参数化装饰器。'
- en: We now have two decorators `prefix` and `suffix` decorating the `getContent`
    method. It seems that they are just parallel at first glance, but if we are going
    to add a prefix and suffix onto the content returned, like what the name suggests,
    the procedure would actually be recursive rather than parallel just like the classical
    implementation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个装饰器 `prefix` 和 `suffix` 装饰了 `getContent` 方法。乍一看，它们似乎是平行的，但如果我们打算在返回的内容上添加前缀和后缀，就像名字所暗示的那样，这个过程实际上将是递归的，而不是像经典实现那样平行。
- en: 'To make decorators cooperate with others as we''d expect, we need to handle
    things carefully:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让装饰器像我们预期的那样与其他元素协作，我们需要小心处理：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In current ECMAScript decorator proposal, when decorating a method or property
    (usually with getter or setter), you will have the third argument passed in as
    the property descriptor.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的 ECMAScript 装饰器提案中，当装饰一个方法或属性（通常使用 getter 或 setter）时，你会接收到一个作为属性描述符的第三个参数。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Check out the following link for more information about property descriptors:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于属性描述符的信息，请查看以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。
- en: The `suffix` decorator would be just like the `prefix` decorator. So I'll save
    the code lines here.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`suffix` 装饰器将与 `prefix` 装饰器类似。所以我会在这里保存代码行。'
- en: Consequences
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: The key to the Decorator Pattern is being able to add functionalities dynamically,
    and decorators are usually expected to play nice with each other. Those expectations
    of Decorator Pattern make it really flexible to form a customized object. However,
    it would be hard for certain types of decorators to actually work well together.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式的关键是能够动态地添加功能，并且通常期望装饰器之间能够友好地协同工作。装饰器模式的这些期望使其能够非常灵活地形成定制对象。然而，对于某些类型的装饰器来说，实际上要很好地协同工作可能会有困难。
- en: Consider decorating an object with multiple decorators just like the second
    example of implementation, would the decorating order matter? Or should the decorating
    order matter?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑用多个装饰器装饰一个对象，就像实现示例的第二部分，装饰顺序是否重要？或者装饰顺序应该重要吗？
- en: A properly written decorator should always work no matter where it is in the
    decorators list. And it's usually *preferred* that the decorated target behaves
    almost the same with decorators decorated in different orders.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确编写的装饰器应该始终能够工作，无论它在装饰器列表中的位置如何。通常，*更受欢迎*的是，装饰的目标在装饰器以不同顺序装饰时几乎表现出相同的行为。
- en: Adapter Pattern
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Adapter Pattern connects existing classes or objects with another existing client.
    It makes classes that are not designed to work together possible to cooperate
    with each other.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式将现有的类或对象与另一个现有的客户端连接。它使得原本设计不兼容的类能够相互协作。
- en: An adapter could be either a *class* adapter or an *object* adapter. A class
    adapter extends the adaptee class and exposes extra APIs that would work with
    the client. An object adapter, on the other hand, does not extend the adaptee
    class. Instead, it stores the adaptee as a dependency.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器可以是 *类* 适配器或 *对象* 适配器。类适配器扩展了适配者类，并公开了与客户端一起工作的额外 API。另一方面，对象适配器不扩展适配者类。相反，它将适配者存储为依赖项。
- en: 'The class adapter is useful when you need to access protected methods or properties
    of the adaptee class. However, it also has some restrictions when it comes to
    the JavaScript world:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 类适配器在需要访问适配者类的受保护方法或属性时很有用。然而，在 JavaScript 世界中，它也有一些限制：
- en: The adaptee class needs to be extendable
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配者类需要可扩展性
- en: If the client target is an abstract class other than pure interface, you can't
    extend the adaptee class and the client target with the same adapter class without
    a *mixin*
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端目标是除了纯接口之外的抽象类，没有使用 *mixin*，你不能使用相同的适配器类扩展适配者和客户端目标。
- en: A single class with two sets of methods and properties could be confusing
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有两组方法和属性的单一类可能会让人感到困惑
- en: 'Due to those limitations, we are going to talk more about object adapters.
    Taking browser-side storage for example, we''ll assume we have a client working
    with storage objects that have both methods `get` and `set` with correct signatures
    (for example, a storage that stores data online through AJAX). Now we want the
    client to work with IndexedDB for faster response and offline usage; we''ll need
    to create an adapter for IndexedDB that gets and sets data:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制，我们将更多地讨论对象适配器。以浏览器端存储为例，我们假设我们有一个与具有正确签名（例如，通过 AJAX 在线存储数据的存储）的存储对象一起工作的客户端。现在我们希望客户端能够与
    IndexedDB 协作以实现更快的响应和离线使用；我们需要为 IndexedDB 创建一个适配器来获取和设置数据：
- en: '![Adapter Pattern](img/image_04_004.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![适配器模式](img/image_04_004.jpg)'
- en: We are going to use Promise for receiving results or errors of asynchronous
    operations. See the following link for more information if you are not yet familiar
    with Promise: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Promise 来接收异步操作的结果或错误。如果您还不熟悉 Promise，请查看以下链接以获取更多信息：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)。
- en: Participants
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of Adapter Pattern include:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者包括：
- en: '**Target: **`Storage`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：`Storage`'
- en: Defines the interface of existing targets that works with client
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义与客户端一起工作的现有目标接口
- en: '**Adaptee**: `IndexedDB`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**：`IndexedDB`'
- en: The implementation that is not designed to work with the client
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 未设计成与客户端一起工作的实现
- en: '**Adapter**: `IndexedDBStorage`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**：`IndexedDBStorage`'
- en: Conforms the interface of target and interacts with adaptee
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 符合目标接口并与适配器交互
- en: '**Client**.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**'
- en: Manipulates the target
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 操作目标
- en: Pattern scope
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Adapter Pattern can be applied when the existing client class is not designed
    to work with the existing adaptees. It focuses on the unique *adapter* part when
    applying to different combinations of clients and adaptees.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当现有的客户端类没有设计成与现有的适配器一起工作时，可以应用适配器模式。它专注于应用不同客户端和适配器组合时的独特 *适配器* 部分。
- en: Implementation
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Start with the `Storage` interface:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Storage` 接口开始：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We defined the `get` method with generic, so that if we neither specify the
    generic type, nor cast the value type of a returned Promise, the type of the value
    would be `{}`. This would probably fail following type checking.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用泛型定义了 `get` 方法，这样如果我们既没有指定泛型，也没有将返回的 Promise 的值类型进行类型转换，那么值的类型将是 `{}`。这可能会在类型检查后失败。
- en: 'With the help of examples found on MDN, we can now set up the IndexedDB adapter.
    Visit  `IndexedDBStorage`: [https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MDN 上找到的示例的帮助下，我们现在可以设置 IndexedDB 适配器。访问 `IndexedDBStorage`：[https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB)。
- en: The creation of IndexedDB instances is asynchronous. We could put the opening
    operation inside a `get` or `set` method so the database can be opened on demand.
    But for now, let's make it easier by creating an instance of `IndexedDBStorage`
    that has a database instance which is already opened.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB 实例的创建是异步的。我们可以将打开操作放在 `get` 或 `set` 方法中，这样数据库就可以按需打开。但为了简化，让我们创建一个
    `IndexedDBStorage` 实例，它已经有一个打开的数据库实例。
- en: 'However, constructors usually don''t have asynchronous code. Even if they do,
    it cannot apply changes to the instance before completing the construction. Fortunately,
    Factory Method Pattern works well with asynchronous initiation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，构造函数通常没有异步代码。即使它们有，也不能在完成构造之前对实例应用更改。幸运的是，工厂方法模式与异步初始化配合得很好：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside the Promise resolver of method `open`, we''ll get the asynchronous work
    done:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `open` 方法的 Promise 解析器内部，我们将完成异步工作：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now when we are accessing an instance of `IndexedDBStorage`, we can assume
    it has an opened database and is ready to make queries. To make changes or to
    get values from the database, we need to create a transaction. Here''s how:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们访问 `IndexedDBStorage` 的实例时，可以假设它有一个已打开的数据库并且准备好进行查询。要更改或从数据库获取值，我们需要创建一个事务。以下是方法：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Method `set` is similar. But while the transaction is by default read-only,
    we need to explicitly specify `'readwrite'` mode.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `set` 类似。但默认情况下，事务是只读的，我们需要明确指定 `'readwrite'` 模式。
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And now we can have a drop-in replacement for the previous storage used by the
    client.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以有一个可以替换之前客户端使用的存储。
- en: Consequences
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: By applying Adapter Pattern, we can fill the gap between classes that originally
    would not work together. In this situation, Adapter Pattern is quite a straightforward
    solution that might come to mind.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用适配器模式，我们可以填补原本无法协同工作的类之间的差距。在这种情况下，适配器模式是一个相当直接且容易想到的解决方案。
- en: But in other scenarios like a debugger *adapter* for debugging extensions of
    an IDE, the implementation of Adapter Pattern could be more challenging.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但在其他场景中，如 IDE 扩展的调试 *适配器*，适配器模式的具体实现可能更具挑战性。
- en: Bridge Pattern
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接模式
- en: Bridge Pattern decouples the abstraction manipulated by clients from functional
    implementations and makes it possible to add or replace these abstractions and
    implementations easily.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式将客户端操作的抽象与功能实现解耦，并使得添加或替换这些抽象和实现变得容易。
- en: 'Take a set of *cross-API* UI elements as an example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以一组 *跨 API* UI 元素为例：
- en: '![Bridge Pattern](img/image_04_005.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![桥接模式](img/image_04_005.jpg)'
- en: We have the abstraction `UIElement` that can access different implementations
    of `UIToolkit` for creating different UI based on either SVG or canvas. In the
    preceding structure, the *bridge* is the connection between `UIElement` and `UIToolkit`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`UIElement`的抽象，它可以访问`UIToolkit`的不同实现，以便基于SVG或画布创建不同的UI。在前面的结构中，*桥接*是`UIElement`和`UIToolkit`之间的连接。
- en: Participants
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of Bridge Pattern include:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式的参与者包括：
- en: '**Abstraction: **`UIElement`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**：`UIElement`'
- en: Defines the interface of objects to be manipulated by the client and stores
    the reference to its implementer.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义客户端将要操作的对象的接口，并存储对其实现者的引用。
- en: '**Refined abstraction**: `TextElement`, `ImageElement`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精细抽象**：`TextElement`，`ImageElement`'
- en: Extends abstraction with specialized behaviors.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展抽象以包含特定的行为。
- en: '**Implementer**: `UIToolkit`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现者**：`UIToolkit`'
- en: Defines the interface of a general implementer that will eventually carry out
    the operations defined in abstractions. The implementer usually cares only about
    basic operations while the abstraction will handle high-level operations.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了一个通用实现者的接口，该接口最终将执行在抽象中定义的操作。实现者通常只关心基本操作，而抽象将处理高级操作。
- en: '**Concrete implementer**: `SVGToolkit`, `CanvasToolkit`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体实现者**：`SVGToolkit`，`CanvasToolkit`'
- en: Implements the implementer interface and manipulates low-level APIs.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现实现者接口并操作低级API。
- en: Pattern scope
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Although having abstraction and implementer decoupled provides Bridge Pattern
    with the ability to work with several abstractions and implementers, most of the
    time, bridge patterns work only with a single implementer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管抽象和实现者解耦使桥接模式能够与多个抽象和实现者一起工作，但大多数情况下，桥接模式只与单个实现者一起工作。
- en: If you take a closer look, you will find Bridge Pattern is extremely similar
    to Adapter Pattern. However, while Adapter Pattern tries to make existing classes
    cooperate and focuses on the adapters part, Bridge Pattern foresees the divergences
    and provides a well-thought-out and universal interface for its abstractions that
    play the part of adapters.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现桥接模式与适配器模式极为相似。然而，适配器模式试图使现有类协作并专注于适配器部分，而桥接模式则预见到了差异，并为扮演适配器角色的抽象提供了一个深思熟虑且通用的接口。
- en: Implementation
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: A working implementation could be non-trivial in the example we are talking
    about. But we can still sketch out the skeleton easily.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的示例中，一个有效实现可能并不简单。但我们仍然可以轻松地勾勒出其骨架。
- en: 'Start with implementer `UIToolkit` and abstraction `UIElement` that are directly
    related to the bridge concept:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从与桥接概念直接相关的实现者`UIToolkit`和抽象`UIElement`开始：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And now we can extend `UIElement` for refined abstractions with different behaviors.
    First the `TextElement`  class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以扩展`UIElement`以获得具有不同行为的精细抽象。首先是`TextElement`类：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the `ImageElement`  class with similar code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以及具有类似代码的`ImageElement`类：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By creating concrete `UIToolkit` subclasses, we can manage to make everything
    together with the client. But as it could lead to hard work we would not want
    to touch now, we''ll skip it by using a variable pointing to `undefined` in this
    example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建具体的`UIToolkit`子类，我们可以设法与客户端一起管理所有内容。但是，由于这可能导致我们现在不想接触的繁重工作，我们将通过在这个示例中使用指向`undefined`的变量来跳过它：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the real world, the render part could also be a heavy lift. But as it's coded
    at a relatively higher-level, it tortures you in a different way.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，渲染部分也可能是一项繁重的工作。但由于它是在相对较高层次上编写的，它以不同的方式折磨你。
- en: Consequences
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Despite having completely different names for the abstraction (`UIElement`)
    in the example above and the adapter interface (`Storage`), they play similar
    roles in a static combination.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在上面的示例中抽象（`UIElement`）和适配器接口（`Storage`）的名称完全不同，但在静态组合中它们扮演着相似的角色。
- en: However, as we mentioned in the pattern scope section, the intentions of Bridge
    Pattern and Adapter Pattern differ.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在模式范围部分提到的，桥接模式和适配器模式的目的不同。
- en: By decoupling the abstraction and implementer, Bridge Pattern brings great extensibility
    to the system. The client does not need to know about the implementation details,
    and this helps to build more stable systems as it forms a healthier dependency
    structure.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解耦抽象和实现者，桥接模式为系统带来了极大的可扩展性。客户端不需要了解实现细节，这有助于构建更稳定的系统，因为它形成了一个更健康的依赖结构。
- en: Another bonus that might be brought by Bridge Pattern is that, with a properly
    configured build process, it can reduce compilation time as the compiler does
    not need to know information on the other end of the bridge when changes are made
    to a refined abstraction or concrete implementer.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个桥接模式可能带来的好处是，通过正确配置的构建过程，它可以在对精炼抽象或具体实现者进行更改时减少编译时间，因为编译器不需要知道桥的另一端的信息。
- en: Façade Pattern
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式
- en: The Façade Pattern organizes subsystems and provides a unified higher-level
    interface. An example that might be familiar to you is a modular system. In JavaScript
    (and of course TypeScript), people use modules to organize code. A modular system
    makes projects easier to maintain, as a clean project structure can help reveal
    the interconnections among different parts of the project.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式组织子系统并提供统一的更高层接口。一个可能您熟悉的例子是模块化系统。在JavaScript（当然也包括TypeScript）中，人们使用模块来组织代码。模块化系统使得项目更容易维护，因为一个干净的项目结构可以帮助揭示项目不同部分之间的相互联系。
- en: It is common that one project gets referenced by others, but obviously the project
    that references other projects doesn't and shouldn't care much about the inner
    structures of its dependencies. Thus a façade can be introduced for a dependency
    project to provide a higher-level API and expose what really matters to its dependents.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目被其他项目引用是很常见的，但显然引用其他项目的项目并不关心也不应该关心其依赖项的内部结构。因此，可以引入一个外观为依赖项目提供一个更高层的API并暴露对其依赖项真正重要的内容。
- en: Take a robot as an example. People who build a robot and its components will
    need to control every part separately and let them cooperate at the same time.
    However, people who want to use this robot would only need to send simple commands
    like "walk" and "jump".
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以机器人为例。构建机器人和其组件的人需要分别控制每个部分并让它们同时协作。然而，想要使用这个机器人的人只需要发送简单的命令，比如“行走”和“跳跃”。
- en: 'For the most flexible usage, the robot "SDK" can provide classes like `MotionController`,
    `FeedbackController`, `Thigh`, `Shank`, `Foot` and so on. Possibly like the following
    image shows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最灵活的使用，机器人“SDK”可以提供诸如`MotionController`、`FeedbackController`、`Thigh`、`Shank`、`Foot`等类。可能如下图所示：
- en: '![Façade Pattern](img/image_04_006.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![外观模式](img/image_04_006.jpg)'
- en: 'But certainly, most of the people who want to control or program this robot
    do not want to know as many details as this. What they really want is not a fancy
    tool box with *everything* inbox, but just an integral robot that follows their
    commands. Thus the robot "SDK" can actually provide a façade that controls the
    inner pieces and exposes much simpler APIs:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，大多数想要控制或编程这个机器人的人并不想了解这么多细节。他们真正想要的不是一个包含所有功能的复杂工具箱，而是一个能够遵循他们命令的完整机器人。因此，机器人“SDK”实际上可以提供一个控制内部组件并暴露更简单API的外观：
- en: '![Façade Pattern](img/image_04_007.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![外观模式](img/image_04_007.jpg)'
- en: Unfortunately, Façade Pattern leaves us an open question of how to design the
    façade API and subsystems. Answering this question properly is not easy work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，外观模式给我们留下了一个如何设计外观API和子系统的开放问题。正确回答这个问题并不容易。
- en: Participants
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of a Façade Pattern are relatively simple when it comes to
    their categories:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到它们的类别时，外观模式的参与者相对简单：
- en: '**Façade**: `Robot`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观**：`Robot`'
- en: Defines a set of higher-level interfaces, and makes subsystems cooperate.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一组更高层的接口，并使子系统协作。
- en: '**Subsystems**: `MotionController`, `FeedbackController`, `Thigh`, `Shank`
    and `Foot`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子系统**：`MotionController`、`FeedbackController`、`Thigh`、`Shank`和`Foot`'
- en: Implements their own functionalities and communicates internally with other
    subsystems if necessary. Subsystems are dependencies of a façade, and they do
    not depend on the façade.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现它们自己的功能，并在必要时与其他子系统进行内部通信。子系统是外观的依赖项，它们不依赖于外观。
- en: Pattern scope
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Façades usually act as junctions that connect a higher-level system and its
    subsystems. The key to the Façade Pattern is to draw a line between what a dependent
    should or shouldn't care about of its dependencies.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 外观通常充当连接更高层系统和其子系统的枢纽。外观模式的关键在于在依赖项应该或不应该关心的依赖项之间划一条线。
- en: Implementation
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Consider putting up a robot with its left and right legs, we can actually add
    another abstraction layer called `Leg` that manages `Thigh`, `Shank` , and `Foot`.
    If we are going to separate motion and feedback controllers to different legs
    respectively, we may also add those two as part of the `Leg`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑放置一个具有左右腿的机器人，我们实际上可以添加一个名为 `Leg` 的另一个抽象层来管理 `Thigh`、`Shank` 和 `Foot`。如果我们打算将运动和反馈控制器分别分配给不同的腿，我们也可以将这两个添加到
    `Leg` 中：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Before we add more details to `Leg`, let's first define `MotionController` and
    `FeedbackController` .
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向 `Leg` 添加更多细节之前，让我们首先定义 `MotionController` 和 `FeedbackController`。
- en: 'The `MotionController` is supposed to control a whole leg based on a value
    or a set of values. Here we are simplifying that as a single angle for not being
    distracted by this impossible robot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`MotionController` 应该根据一个值或一组值来控制整个腿。在这里，我们将其简化为一个角度，以免被这个不可能的机器人分散注意力：'
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And the `FeedbackController` is supposed to be an instance of `EventEmitter`
    that reports the state changes or useful events:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeedbackController` 应该是一个 `EventEmitter` 的实例，用于报告状态变化或有用的事件：'
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can make class `Leg` relatively complete:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使 `Leg` 类相对完整：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s put two legs together to sketch the skeleton of a robot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把两条腿放在一起来勾勒出机器人的骨骼：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I'm omitting the definition of classes `Thigh`, `Shank` , and `Foot` as we are
    not actually going to walk the robot. Now for a user that only wants to walk or
    jump a robot via simple API, they can make it via the `Robot` object that has
    everything connected.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了 `Thigh`、`Shank` 和 `Foot` 类的定义，因为我们实际上不会让机器人行走。现在，对于只想通过简单的 API 让机器人行走或跳跃的用户，他们可以通过具有所有连接的
    `Robot` 对象来实现。
- en: Consequences
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Façade Pattern loosens the coupling between client and subsystems. Though it
    does not decouple them completely as you will probably still need to work with
    objects defined in subsystems.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Façade 模式松散了客户端和子系统之间的耦合。尽管它并没有完全解耦它们，因为你可能仍然需要与子系统定义的对象一起工作。
- en: Façades usually forward operations from client to proper subsystems or even
    do heavy work to make them work together.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Façade 模式通常将客户端的操作转发到适当的子系统，甚至进行大量工作以使它们协同工作。
- en: With the help of Façade Pattern, the system and the relationship and structure
    within the system can stay clean and intuitive.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Façade 模式的帮助下，系统和系统内部的关系和结构可以保持清晰和直观。
- en: Flyweight Pattern
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flyweight 模式
- en: A flyweight in Flyweight Pattern is a stateless object that can be shared across
    objects or maybe classes many times. Obviously, that suggests Flyweight Pattern
    is a pattern about memory efficiency and maybe performance if the construction
    of objects is expensive.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight 模式中的轻量级对象是一个无状态对象，它可以被多次共享于对象或类之间。显然，这表明 Flyweight 模式是一种关于内存效率的模式，也许如果对象的构建成本高昂，它还可能影响性能。
- en: Taking drawing snowflakes as an example. Despite real snowflakes being different
    to each other, when we are trying to draw them onto canvas, we usually have a
    limited number of styles. However, by adding *properties* like sizes and transformations,
    we can create a beautiful snow scene with limited snowflake styles.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以绘制雪花为例。尽管真实的雪花各不相同，但当我们试图将它们绘制到画布上时，我们通常只有有限数量的样式。然而，通过添加诸如大小和变换等属性，我们可以使用有限的雪花样式创建一个美丽的雪景。
- en: As a flyweight is stateless, ideally it allows multiple operations simultaneously.
    You might need to be cautious when working with multi-thread stuff. Fortunately,
    JavaScript is usually single-threaded and avoids this issue if all related code
    is synchronous. You will still need to take care in detailed scenarios if your
    code is working asynchronously.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于轻量级对象是无状态的，理想情况下它允许同时进行多个操作。当处理多线程内容时，你可能需要小心。幸运的是，JavaScript 通常单线程，并且如果所有相关代码都是同步的，它将避免这个问题。如果你的代码是异步的，你仍然需要在详细场景中小心处理。
- en: 'Assume we have some flyweights of class `Snowflake`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些 `Snowflake` 类的轻量级对象：
- en: '![Flyweight Pattern](img/image_04_008.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![Flyweight Pattern](img/image_04_008.jpg)'
- en: 'When it snows, it would look like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当下雪时，它看起来会是这样：
- en: '![Flyweight Pattern](img/image_04_009.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![Flyweight Pattern](img/image_04_009.jpg)'
- en: In the image above, snowflakes in different styles are the result of rendering
    with different properties.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图片中，不同风格的雪花是使用不同属性渲染的结果。
- en: It's common that we would have styles and image resources being loaded dynamically,
    thus we could use a `FlyweightFactory` for creating and managing flyweight objects.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会有样式和图像资源被动态加载，因此我们可以使用 `FlyweightFactory` 来创建和管理轻量级对象。
- en: Participants
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The simplest implementation of Flyweight Pattern has the following participants:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight模式最简单的实现有以下参与者：
- en: '**F****lyweight**: `Snowflake`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F****lyweight**：`Snowflake`'
- en: Defines the class of flyweight objects.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义flyweight对象的类。
- en: '**Flyweight factory**: `FlyweightFactory`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flyweight factory**：`FlyweightFactory`'
- en: Creates and manages flyweight objects.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建和管理flyweight对象。
- en: '**Client**.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**。'
- en: Stores states of targets and uses flyweight objects to manipulate these targets.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储目标的状态并使用flyweight对象来操作这些目标。
- en: With these participants, we assume that the manipulation could be accomplished
    through flyweights with different states. It would also be helpful sometimes to
    have `concrete flyweight` class allowing customized behaviors.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些参与者中，我们假设可以通过具有不同状态的flyweight来完成操作。有时，拥有允许自定义行为的`具体flyweight`类也会很有帮助。
- en: Pattern scope
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Flyweight Pattern is a result of efforts to improving memory efficiency and
    performance. The implementation cares about having the instances being stateless,
    and it is usually the client that manages detailed states for different targets.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight模式是提高内存效率和性能努力的成果。实现关注实例的无状态性，通常客户端负责管理不同目标的具体状态。
- en: Implementation
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: What makes Flyweight Pattern useful in the snowflake example is that a snowflake
    with the same style usually shares the same image. The image is what consumes
    time to load and occupies notable memory.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在雪花示例中，使Flyweight模式有用的原因是具有相同风格的雪花通常共享相同的图像。图像是消耗加载时间和占用显著内存的部分。
- en: 'We are starting with a fake `Image` class that pretends to load images:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个假的`Image`类开始，它假装加载图像：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Snowflake` class in our example has only a single `image` property, and
    that is a property that will be shared by many snowflakes to be drawn. As the
    instance is now stateless, parameters from context are required for rendering:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`Snowflake`类只有一个`image`属性，这是一个将被许多要绘制的雪花共享的属性。由于实例现在是无状态的，需要从上下文中获取参数进行渲染：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The flyweights are managed by a factory for easier accessing. We''ll have a
    `SnowflakeFactory` that caches created snowflake objects with certain styles:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于访问，flyweights由一个工厂管理。我们将有一个`SnowflakeFactory`，它缓存了具有特定风格的创建的雪花对象：
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With building blocks ready, we''ll implement the client (`Sky`) that snows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好构建块后，我们将实现客户端（`Sky`），它将下雪：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are going to fill the sky with random snowflakes at random positions. Before
    that let''s create a helper function that generates a number between 0 and a max
    value given:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用随机位置的随机雪花填充天空。在此之前，让我们创建一个辅助函数，该函数生成一个介于0和最大值之间的数字：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And then complete method `snow` of `Sky`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后完成`Sky`的`snow`方法：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now we may have thousands of snowflakes in the sky but with only three instances
    of `Snowflake` created. You can continue this example by storing the state of
    snowflakes and animating the snowing.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可能在天空中有成千上万的雪花，但只创建了三个`Snowflake`实例。你可以通过存储雪花的状态并动画化下雪来继续这个例子。
- en: Consequences
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Flyweight Pattern reduces the total number of objects involved in a system.
    As a direct result, it may save quite a lot memory. This saving becomes more significant
    when the flyweights get used by the client that processes a large number of targets.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight模式减少了系统中涉及的对象总数。作为直接结果，它可能节省相当多的内存。当flyweights被处理大量目标的客户端使用时，这种节省变得更加显著。
- en: Flyweight Pattern also brings extra logic into the system. When to use or not
    to use this pattern is again a balancing game between development efficiency and
    runtime efficiency from this point of view. Though most of the time, if there's
    not a good reason, we go with development efficiency.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight模式也将额外的逻辑引入到系统中。何时使用或何时不使用此模式，从这个角度来看，又是开发效率与运行时效率之间的一种平衡游戏。尽管大多数时候，如果没有充分的理由，我们会选择开发效率。
- en: Proxy Pattern
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式
- en: 'Proxy Pattern applies when the program needs to know about or to intervene
    the behavior of accessing objects. There are several detailed scenarios in Proxy
    Pattern, and we can distinguish those scenarios by their different purposes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式适用于程序需要了解或干预访问对象的行为时。代理模式有几个详细场景，我们可以通过它们的不同目的来区分这些场景：
- en: '**Remote proxy**: A proxy with interface to manipulate remote objects, such
    as data items on a remote server'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程代理**：具有操作远程对象接口的代理，例如远程服务器上的数据项'
- en: '**Virtual proxy**: A proxy that manages expensive objects which need to be
    loaded on demand'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟代理**：一种管理需要按需加载的昂贵对象的代理'
- en: '**Protection proxy**: A proxy that controls access to target objects, typically
    it verifies permissions and validates values'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护代理**: 控制对目标对象访问的代理，通常它验证权限并验证值'
- en: '**Smart proxy**: A proxy that does additional operations when accessing target
    objects'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能代理**: 在访问目标对象时执行额外操作的代理'
- en: In the section of Adapter Pattern, we used factory method `open` that creates
    an object asynchronously. As a trade-off, we had to let the client wait before
    the object gets created.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在适配器模式的部分，我们使用了工厂方法 `open`，该方法异步创建对象。作为权衡，我们必须让客户端在对象创建之前等待。
- en: With Proxy Pattern, we could now `open` database on demand and create storage
    instances synchronously.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理模式，我们现在可以按需打开数据库并同步创建存储实例。
- en: '![Proxy Pattern](img/image_04_010.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![代理模式](img/image_04_010.jpg)'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A proxy is usually dedicated to object or objects with known methods and properties.
    But with the new `Proxy` API provided in ES6, we can get more interesting things
    done by getting to know what methods or properties are being accessed. Please
    refer to the following link for more information: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 代理通常用于具有已知方法和属性的单一对象或对象。但是，通过ES6提供的新的 `Proxy` API，我们可以通过了解正在访问哪些方法或属性来执行更有趣的操作。请参阅以下链接获取更多信息：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)。
- en: Participants
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of Proxy Pattern include:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式的参与者包括：
- en: '**Proxy**: `IndexedDB``Storage`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**: `IndexedDB` Storage'
- en: Defines interface and implements operations to manage access to the subject.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义接口并实现操作以管理对主题的访问。
- en: '**Subject**: `IndexedDB`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**: `IndexedDB`'
- en: The subject to be accessed by proxy.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要由代理访问的主题。
- en: '**Client**: Accesses subject via proxy.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**: 通过代理访问主题。'
- en: Pattern scope
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Despite having a similar structure to Adapter Pattern, the key of Proxy Pattern
    is to intervene the access to target objects rather than to adapt an incompatible
    interface. Sometimes it might change the result of a specific method or the value
    of a certain property, but that is probably for falling back or exception  handling
    purposes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与适配器模式具有相似的结构，但代理模式的关键在于干预对目标对象的访问，而不是适配不兼容的接口。有时它可能会改变特定方法的结果或某些属性的值，但这可能是为了回退或异常处理目的。
- en: Implementation
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: There are two differences we'll have in this implementation compared to the
    example for pure Adapter Pattern. First, we'll create the `IndexedDBStorage` instance
    with a constructor, and have the database opened on demand. Second, we are going
    to add a useless permission checking for methods `get` and `set`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与纯适配器模式的示例相比，在这个实现中我们将有两个不同之处。首先，我们将使用构造函数创建 `IndexedDBStorage` 实例，并在需要时打开数据库。其次，我们将为
    `get` 和 `set` 方法添加一个无用的权限检查。
- en: 'Now when we call the method `get` or `set`, the database could either have
    been opened or not. Promise is a great choice for representing a value that might
    either be pending or settled. Consider this example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们调用 `get` 或 `set` 方法时，数据库可能已经打开，也可能没有。Promise 是表示可能悬而未决或已解决的值的绝佳选择。考虑以下示例：
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It''s hard to tell whether Promise `ready` is fulfilled when the second timeout
    fires. But the overall behavior is easy to predict: it will log the `''biu~''` text
    in around 1 second. By replacing the Promise variable `ready` with a method or
    getter, it would be able to start the asynchronous operation only when needed.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二次超时触发时，很难判断Promise `ready` 是否已解决。但整体行为很容易预测：它将在大约1秒后记录 `'biu~'` 文本。通过将Promise变量
    `ready` 替换为方法或getter，它将能够在需要时才开始异步操作。
- en: 'So let''s start the refactoring of class `IndexedDBStorage` with the getter
    that creates the Promise of the database to be opened:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从创建数据库打开Promise的getter开始重构 `IndexedDBStorage` 类：
- en: '[PRE36]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now the first time we access property `dbReady`, it will open the database and
    create a Promise that will be fulfilled with the database being opened. To make
    this work with methods `get` and `set`, we just need to wrap what we've implemented
    into a `then` method following the `dbReady` Promise.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第一次我们访问属性 `dbReady`，它将打开数据库并创建一个Promise，该Promise将在数据库打开时得到解决。为了使 `get` 和 `set`
    方法能够正常工作，我们只需要将我们已实现的内容包装在一个 `then` 方法中，该方法跟随 `dbReady` Promise。
- en: 'First for method `get`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先针对 `get` 方法：
- en: '[PRE37]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And followed by updated method `set`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着是更新后的 `set` 方法：
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we finally have the `IndexedDBStorage` property that can do a real drop-in
    replacement for the client that supports the interface. We are also going to add
    simple permission checking with a plain object that describes the permission of
    read and write:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于有了`IndexedDBStorage`属性，它可以真正地替换支持该接口的客户端。我们还将添加一个简单的权限检查，使用一个描述读和写权限的普通对象：
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then we will add permission checking for method `get` and `set` separately:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将分别对`get`和`set`方法添加权限检查：
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You may recall Decorator Pattern when you are thinking about the permission
    checking part, and decorators could be used to simplify the lines written. Try
    to use decorator syntax to implement this permission checking yourself.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当你思考权限检查部分时，可能会回想起装饰者模式，装饰者可以用来简化所写的代码。尝试使用装饰器语法自己实现这个权限检查。
- en: Consequences
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: The implementation of Proxy Pattern can usually be treated as the encapsulation
    of the operations to specific objects or targets. It is easy to have the encapsulation
    augmented without extra burden on the client.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式的实现通常可以被视为对特定对象或目标的操作封装。这种封装很容易增加，而不会给客户端带来额外的负担。
- en: For example, a working online database proxy could do much more than just acting
    like a plain surrogate. It may cache data and changes locally, or synchronize
    on schedule without the client being aware.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个工作的在线数据库代理可以做的不仅仅是充当一个普通的代理。它可能本地缓存数据和更改，或者在客户端不知情的情况下按计划同步。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about structural design patterns including Composite,
    Decorator, Adapter, Bridge, Façade, Flyweight, and Proxy. Again we found some
    of these patterns are highly inter related and even similar to each other to some
    degree.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了结构型设计模式，包括组合、装饰者、适配器、桥接、外观、享元和代理。再次我们发现这些模式之间高度相关，甚至在某种程度上相似。
- en: For example, we mixed Composite Pattern with Decorator Pattern, Adapter Pattern
    with Proxy Pattern, compared Adapter Pattern and Bridge Pattern. During the journey
    of exploring, we sometimes found it was just a natural result to have our code
    end in a pattern that's similar to what we've listed if we took writing *better
    code* into consideration.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将组合模式与装饰者模式混合，适配器模式与代理模式结合，比较了适配器模式和桥接模式。在探索的过程中，我们有时会发现，如果我们考虑到编写**更好的代码**，我们的代码最终以我们所列出的类似模式结束，这仅仅是一个自然的结果。
- en: Taking Adapter Pattern and Bridge Pattern as an example, when we are trying
    to make two classes cooperate, it comes out with Adapter Pattern and when we are
    planning on connecting with different classes in advance, it goes with Bridge
    Pattern. There are no actual lines between each pattern and the applications of
    those patterns, though the techniques behind patterns could usually be useful.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以适配器模式和桥接模式为例，当我们试图使两个类合作时，会出现适配器模式；当我们计划提前连接不同的类时，就会使用桥接模式。尽管这些模式之间没有实际的线条，但模式背后的技术通常是有用的。
- en: In the next chapter, we are going to talk about behavioral patterns that help
    to form algorithms and assign the responsibilities.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论行为模式，这些模式有助于形成算法和分配责任。
