- en: Real-Time Web Apps with Socket.io
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Socket.io实时Web应用程序
- en: In this chapter, you're going to learn about Socket.io and WebSockets, which
    enable two-way communication between the server and the client. This means that
    we're not only going to be setting up a Node server, but also a client. This client
    could be a web app, an iPhone app, or an Android app. For this book, the client
    will be a web app. This means that we're going to be connecting the two, allowing
    data to flow seamlessly from the browser to the server and from the server to
    the browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习有关Socket.io和WebSockets的知识，它们可以在服务器和客户端之间进行双向通信。这意味着我们不仅要设置一个Node服务器，还要设置一个客户端。这个客户端可以是一个web应用程序，iPhone应用程序或Android应用程序。对于本书来说，客户端将是一个web应用程序。这意味着我们将连接这两个，允许数据在浏览器和服务器之间无缝流动。
- en: Now, our todo app data can only flow in one direction, and the client has to
    initialize the request. With Socket.io, we're going to be able to send data back
    and forth instantly. This means that for real-time apps, such as an email app,
    a food ordering app, or a chat app, the server doesn't need to wait for the client
    to request information; the server can say, "*Hey, I just got something you probably
    want to show the user, so here it is!"* This is going to open up a world of possibilities,
    and we're going to get started by figuring out how to integrate Socket.io into
    a Node app. Let's dive in!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的todo应用程序数据只能单向流动，客户端必须初始化请求。使用Socket.io，我们将能够立即来回发送数据。这意味着对于实时应用程序，比如电子邮件应用程序，食品订购应用程序或聊天应用程序，服务器不需要等待客户端请求信息；服务器可以说，“嘿，我刚刚收到了一些你可能想要向用户显示的东西，所以在这里！”这将开启一系列可能性，我们将从如何将Socket.io集成到Node应用程序中开始。让我们开始吧！
- en: Creating a new web app project
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的web应用项目
- en: Before you can add sockets to your web application, you need a web application
    to add them to, which is exactly what we'll create in this section. We'll make
    a basic Express app, which we'll get up on GitHub. Then, we'll deploy it to Heroku
    so we can view it live in the browser.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以将套接字添加到您的Web应用程序之前，您需要一个Web应用程序来添加它们，这正是我们将在本节中创建的。我们将创建一个基本的Express应用程序，并将其上传到GitHub。然后，我们将部署到Heroku，这样我们就可以在浏览器中实时查看它。
- en: Now, the first step to that process is going to be to making a directory. We'll
    do a few things together to get us all going in the right direction. The first
    step in the process from the desktop is to run `mkdir` to make a new directory
    for this project; I'm going to call it `node-chat-app`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个过程的第一步是创建一个目录。我们将一起做一些事情，让我们都朝着正确的方向前进。从桌面开始的过程的第一步是运行`mkdir`来为这个项目创建一个新目录；我将把它叫做`node-chat-app`。
- en: 'Then, we can use `cd` to navigate into that directory and we can run a few
    commands:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`cd`命令导航到该目录，然后运行一些命令：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First up, `npm init`. As with all of our projects in this book, we''ll be taking
    advantage of npm, so we''ll run the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是`npm init`。和本书中的所有项目一样，我们将利用npm，所以我们将运行以下命令：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](img/3dcad9af-d069-4002-b47d-e98cd23bfa61.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3dcad9af-d069-4002-b47d-e98cd23bfa61.png)'
- en: 'Then, we''ll use the *e**nter* key to use the default value for every option:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用*enter*键来使用每个选项的默认值：
- en: '![](img/dabdb017-99da-4bf2-800a-b2519d8a7417.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dabdb017-99da-4bf2-800a-b2519d8a7417.png)'
- en: 'When we''re done, we can type `yes`, and now we have a `package.json` file.
    Before we move into Atom, we''ll run the following command to initialize a new
    Git repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成后，我们可以输入`yes`，现在我们有了一个`package.json`文件。在我们进入Atom之前，我们将运行以下命令来初始化一个新的Git仓库：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll be putting this project under version control using Git, and we'll also
    use Git to push to GitHub and Heroku. With this in place, I can use the `clear`
    command to clear the Terminal output, and we can move into Atom. We'll start by
    opening up the folder and setting up our basic app structure.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Git对这个项目进行版本控制，并且我们还将使用Git推送到GitHub和Heroku。有了这个设置，我可以使用`clear`命令来清除终端输出，然后我们可以进入Atom。我们将从打开文件夹并设置我们的基本应用程序结构开始。
- en: Setting up our basic app structure
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的基本应用程序结构
- en: 'To set up the basic app structure, I''m going to open up the folder that we
    just created on the desktop, called `node-chat-app`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置基本的应用程序结构，我将打开桌面上刚创建的文件夹，名为`node-chat-app`：
- en: '![](img/4bc28905-c257-4137-82d4-d9090f43789b.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bc28905-c257-4137-82d4-d9090f43789b.png)'
- en: In this folder, we'll get started by making a couple of directories. Now, unlike
    the other apps in the previous chapters, the chat app is going to have a frontend,
    which means we'll be writing some HTML.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，我们将开始创建一些目录。现在，不像前几章的其他应用程序，聊天应用程序将有一个前端，这意味着我们将编写一些HTML。
- en: 'We''ll also add some styles and writing some JavaScript code that runs in the
    browser, as opposed to running on the server. For this to work, we''ll have two
    folders:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一些样式和编写一些在浏览器中运行的JavaScript代码，而不是在服务器上运行。为了使这个工作，我们将有两个文件夹：
- en: One will be called `server`, which will store our Node.js code
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将被称为`server`，它将存储我们的Node.js代码
- en: The other one will be called `public`, which will store our styles, our HTML
    files, and our client-side JavaScript
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个将被称为`public`，它将存储我们的样式，我们的HTML文件和我们的客户端JavaScript
- en: 'Now, inside `server`, just like we did for the todo API, we''ll have a `server.js`
    file, which is going to be the root of our Node application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`server`文件夹中，就像我们为todo API所做的那样，我们将有一个`server.js`文件，它将是我们的Node应用程序的根：
- en: '![](img/bbbb2aaf-1b53-4a38-8063-01926870b587.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbbb2aaf-1b53-4a38-8063-01926870b587.png)'
- en: This file will do stuff like create a new Express app, configure the public
    directory to be the static folder Express serves up, and call `app.listen` to
    start up the server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件将做一些事情，比如创建一个新的Express应用程序，配置公共目录为Express提供的静态文件夹，并调用`app.listen`来启动服务器。
- en: 'Inside `public`, what we''ll do for this section is create just one file, called
    `index.html`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`文件夹中，我们将在本节中创建一个文件，名为`index.html`：
- en: '![](img/f5682799-13ac-4176-8ec6-50e206eaf810.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5682799-13ac-4176-8ec6-50e206eaf810.png)'
- en: The `index.html` file will be the markup page we serve when someone visits the
    app. For now, we'll make a really simple one that just prints a message to the
    screen so we can confirm it's getting served up properly. In the next section,
    we'll worry about integrating Socket.io on the client.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`文件将是我们在应用程序中访问时提供的标记页面。现在，我们将制作一个非常简单的页面，只是在屏幕上打印一条消息，以便我们可以确认它被正确地提供出来。在下一节中，我们将担心在客户端集成Socket.io。'
- en: Setting up the index.html file for DOCTYPE
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为DOCTYPE设置index.html文件
- en: 'For now though, in our `index.html` file, we''ll provide `DOCTYPE` so the browser
    knows which version of HTML we want to use. We tell it to use HTML which refers
    to HTML5\. Next up, we''ll open and close our `html` tag:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，现在，在我们的`index.html`文件中，我们将提供`DOCTYPE`，这样浏览器就知道我们要使用哪个版本的HTML。我们告诉它使用HTML，这是指HTML5。接下来，我们将打开并关闭我们的`html`标签：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This tag is going to let us provide the `head` and `body` tags, which are exactly
    what we''ll need to get things working:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标记将让我们提供`head`和`body`标签，这正是我们需要让事情运转起来的。
- en: 'First up is `head`. Inside `head`, we can provide various configuration tags.
    We''ll use just one for now, `meta`, so we can tell the browser which `charset`
    we want to use. In the `meta` tag, we''ll provide the `charset` attribute, setting
    it equal to `utf-8` inside quotes:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是`head`。在`head`内，我们可以提供各种配置标签。现在我们只使用一个，`meta`，这样我们就可以告诉浏览器我们想要使用哪个`charset`。在`meta`标签中，我们将提供`charset`属性，将其设置为`utf-8`，放在引号内：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next up, we''ll provide the `body` tag inside `html`. This contains the HTML
    we want to actually render to the screen, and what we''ll do for this one is render
    a `p` tag, which is for a paragraph, and we''ll have some simple text like `Welcome
    to the chat app`:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`html`标签内提供`body`标签。这包含了我们实际要呈现到屏幕上的HTML，对于这个，我们将呈现一个`p`标签，用于段落，然后我们会有一些简单的文本，比如`Welcome
    to the chat app`：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is all that's going to show up for the moment. Now, we can move outside
    the `html` file, going back into the `server` file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是目前要显示的全部内容。现在，我们可以离开`html`文件，回到`server`文件。
- en: Setting up the server.js file for the public directory
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为公共目录设置server.js文件
- en: In our `server` file, we want to set up this server to serve up the `public`
    folder. Now, in this case, the `server.js` file is not in the root of the project,
    which means we have to go up a directory from `server` to `node-chat-app`. Then,
    we have to go into the `public` folder. This will make it a little hard to set
    up the Express middleware. What we'll do is take a look at a built-in Node module
    that makes it really easy to convert paths.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`server`文件中，我们想要设置这个服务器来提供`public`文件夹。现在，在这种情况下，`server.js`文件不在项目的根目录中，这意味着我们必须从`server`进入`node-chat-app`的上一级目录。然后，我们必须进入`public`文件夹。这将使设置Express中间件有点困难。我们将看一下一个内置的Node模块，它可以很容易地转换路径。
- en: 'Now, in order to show you what I''m talking about, let''s go ahead and use
    two `console.log` calls:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了向你展示我在说什么，让我们继续使用两个`console.log`调用：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first `console.log` call will show us how we used to do it, and the second
    one will show us the better way to do it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`console.log`调用将向我们展示我们以前是如何做的，第二个将向我们展示更好的做法。
- en: 'Inside the first `console.log` call, we''ll provide the same path we provided
    for our very first Express app. We use `__dirname` to reference the current directory,
    which in this case is the `server` directory because the file is inside the `server`
    folder. Then, we concatenate it, `/public`. Now, in this case, we do not have
    a `public` folder in the `server` folder; the `public` folder and the `server`
    folder are at the exact same level, which means we need to use `..` to go up a
    directory and then we need to go into `public`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`console.log`调用中，我们将提供我们为我们的第一个Express应用程序提供的相同路径。我们使用`__dirname`来引用当前目录，这种情况下是`server`目录，因为文件在`server`文件夹内。然后，我们连接它，`/public`。现在，在这种情况下，我们在`server`文件夹中没有一个`public`文件夹；`public`文件夹和`server`文件夹在完全相同的级别，这意味着我们需要使用`..`来进入上一级目录，然后我们需要进入`public`：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the old way of doing things, and if we run this from the Terminal,
    we can see why it looks a little weird. I''m going to run `server/server.js`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是旧的做事情的方式，如果我们从终端运行这个，我们可以看到为什么它看起来有点奇怪。我将运行`server/server.js`：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What we get is this path, as shown in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是这个路径，如下面的截图所示：
- en: '![](img/27dff985-7df2-4295-a4ec-776fadd70a3b.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27dff985-7df2-4295-a4ec-776fadd70a3b.png)'
- en: We go into the `Users/Andrew/Desktop/` project folder, which is expected, then
    we go into `server`, out of `server`, and into `public`—this is absolutely unnecessary.
    What we'd like to do is just go from the `project` folder right into `public`,
    keeping a clean, cross-OS compatible path. In order to do that, we'll use a module
    that comes with Node called `path`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入了`Users/Andrew/Desktop/`项目文件夹，这是预期的，然后我们进入`server`，离开`server`，然后进入`public`——这是完全不必要的。我们想要做的是直接从`project`文件夹进入`public`，保持一个干净、跨操作系统兼容的路径。为了做到这一点，我们将使用一个随Node一起提供的名为`path`的模块。
- en: The join method
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: join方法
- en: 'Now, let''s see the documentation of `path`, because `path` has plenty of methods
    that we won''t be using in this section. We''ll go to [nodejs.org](https://nodejs.org/en/),
    where we can find the Docs tab. We''ll go to the Docs page and then the API reference page:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`path`的文档，因为`path`有很多方法在这一节中我们不会使用。我们将前往[nodejs.org](https://nodejs.org/en/)，在那里我们可以找到Docs选项卡。我们将进入Docs页面，然后进入API参考页面：
- en: '![](img/f2a281b3-95b3-48da-9a15-8d521be5707e.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2a281b3-95b3-48da-9a15-8d521be5707e.png)'
- en: 'Here''s a list of all the modules we have available to us. We''re using the
    Path module:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以使用的所有模块的列表。我们正在使用Path模块：
- en: '![](img/f0dbc7a1-cd59-472b-b676-d0b85daa536b.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0dbc7a1-cd59-472b-b676-d0b85daa536b.png)'
- en: 'Inside Path, the method we''ll use is `join`, which you can see in the preceding
    screenshot. If you click on this method, you can go to a little example of how
    `join` works:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Path中，我们将使用的方法是`join`，你可以在前面的截图中看到。如果你点击这个方法，你可以看到`join`如何工作的一个小例子：
- en: '![](img/5bd530c8-7f9f-497f-adc5-10780bf142e4.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bd530c8-7f9f-497f-adc5-10780bf142e4.png)'
- en: 'The `join` method takes your partial paths and joins them together, which means
    the example shown in the preceding screenshot results in the simpler path. In
    this example, we can see that we start with `foo`. We then go into `bar`, which
    also shows up; we then go into `baz/asdf`, which does indeed show up. The next
    part is the interesting part: we go into the `quux` directory, then we go out
    using `..`, and you can see the result path doesn''t show us going into and out
    of, like our path does inside the Terminal; instead, it resolves that into the
    final path, where the `quux` directory is nowhere in sight.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`方法接受您的部分路径并将它们连接在一起，这意味着在前面截图中显示的示例会得到更简单的路径。在这个例子中，我们可以看到我们从`foo`开始。然后我们进入`bar`，这也显示出来；然后我们进入`baz/asdf`，这确实显示出来。接下来是有趣的部分：我们进入`quux`目录，然后我们使用`..`退出，您可以看到结果路径并没有显示我们进入和退出，就像我们在终端内的路径一样；相反，它将其解析为最终路径，`quux`目录不见了。'
- en: 'We''ll use this exact same method to clean up our path. Inside Atom, we can
    load in the `path` module by creating a constant called `path` and requiring it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用完全相同的方法来清理我们的路径。在Atom中，我们可以通过创建一个名为`path`的常量并要求它来加载`path`模块：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Remember, this one does not need to be installed: it is a built-in module,
    and you have access to it without using `npm`. Next up, we''ll make a variable
    called `publicPath`. I''ll make that a constant variable, since we''ll be making
    any changes to it, and we''ll call `path.join`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个不需要安装：它是一个内置模块，您可以在不使用`npm`的情况下访问它。接下来，我们将创建一个名为`publicPath`的变量。我将使其成为一个常量变量，因为我们将对其进行任何更改，并将调用`path.join`：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''ll pass some arguments into `path.join` in a moment. Before we do, though,
    I''m going to call `console.log(publicPath)`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一会儿将一些参数传递给`path.join`。在我们这样做之前，我将调用`console.log(publicPath)`：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, inside `path.join`, what we want to do is take the two paths, `__dirname`
    and `''/../public''`, and pass them in as separate arguments. We do still want
    to start in the `server` folder of the `dirname` directory. Then, as the second
    argument, we''ll specify the relative path inside quotes. We''ll go out of the
    directory using `..` then use a forward slash to go into the `public` folder:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`path.join`内，我们要做的是取两个路径`__dirname`和`'/../public'`，并将它们作为单独的参数传递。我们仍然希望从`dirname`目录的`server`文件夹开始。然后，作为第二个参数，我们将在引号内指定相对路径。我们将使用`..`退出目录，然后使用斜杠进入`public`文件夹：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I''ll save the `server` file, and we should now be able to go back to the Terminal
    and see our new path—and here it is:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我将保存`server`文件，现在我们应该能够返回终端并看到我们的新路径-在这里：
- en: '![](img/99ebfc25-831e-4d61-9f80-4368ac0118f1.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99ebfc25-831e-4d61-9f80-4368ac0118f1.png)'
- en: Instead of going into `server` and then going out, we go right into the `public`
    directory, which is ideal. This is the path we want to provide to the Express
    static middleware.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是进入`server`然后退出，而是直接进入`public`目录，这是理想的。这是我们要提供给Express静态中间件的路径。
- en: 'Now that we have this `public` path variable in place, let''s set up Express
    locally. Before we get into that, we will install it using `npm i`. The module
    name is `express`, and we''ll use the most recent version, `@4.16.3`, with the
    `--save` flag:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了这个`public`路径变量，让我们在本地设置Express。在我们开始之前，我们将使用`npm i`进行安装。模块名称是`express`，我们将使用最新版本`@4.16.3`，带有`--save`标志。
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll run the installer, and then we can go ahead and actually use it inside
    `server.js`. In `package.json`, we now have it sitting in the dependencies object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行安装程序，然后我们可以继续在`server.js`中实际使用它。在`package.json`中，我们现在将其放在依赖对象中。
- en: Configuring basic server setup
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基本服务器设置
- en: With the Express installer in place, you'll create a brand new Express application
    and configure the Express static middleware, as we've done previously to serve
    up the `public` folder. Finally, you'll call `app.listen` on port `3000`. You'll
    provide one of those little callback functions to print a message to the Terminal,
    such as `server is up on port 3000`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Express安装程序后，您将创建一个全新的Express应用程序，并配置Express静态中间件，就像我们之前做的那样，以提供`public`文件夹。最后，您将在端口`3000`上调用`app.listen`。您将提供其中一个小回调函数，以在终端上打印消息，例如`服务器在端口3000上运行`。
- en: Once you have the server created, you'll start it up inside the Terminal and
    head to `localhost:3000` inside the browser. If we go there right now we'll get
    an error, because there is no server running on that port. You should be able
    to refresh this page and see the little message we typed in the paragraph tag
    over inside `index.html`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了服务器，您将在终端内启动它，并在浏览器中转到`localhost:3000`。如果我们现在去那里，我们会得到一个错误，因为该端口上没有运行服务器。您应该能够刷新此页面并看到我们在`index.html`内的段落标签中键入的小消息。
- en: 'The first thing I''ll do is inside `server.js`, load in Express by creating
    a constant called `express` and requiring the library we just installed:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我要做的第一件事是在`server.js`内加载Express，创建一个名为`express`的常量并要求我们刚刚安装的库：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next up, you need to make an `app` variable where we can configure our Express
    application. I''ll make a variable called `app` and set it equal to a call to
    `express`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要创建一个`app`变量，我们可以在其中配置我们的Express应用程序。我将创建一个名为`app`的变量，并将其设置为调用`express`：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember, we don't configure Express by passing in arguments; instead, we configure
    Express by calling methods on `app` to create routes, add middleware, or start
    up the server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们不是通过传递参数来配置Express；相反，我们通过在`app`上调用方法来配置Express，以创建路由、添加中间件或启动服务器。
- en: 'First up, we''ll call `app.use` to configure our Express static middleware.
    This will serve up that `public` folder:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将调用`app.use`来配置我们的Express静态中间件。这将提供`public`文件夹：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'What you need to do is call `express.static` and pass in the path. We create
    a `publicPath` variable, which stores exactly the path we need:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的是调用`express.static`并传入路径。我们创建一个`publicPath`变量，它存储了我们需要的路径：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The last thing to do is call `app.listen`. This will start up the server on
    port `3000`, and we'll provide a callback function as the second argument to print
    a little message to the Terminal once the server is up.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的一件事是调用`app.listen`。这将在端口`3000`上启动服务器，并且我们将提供一个回调函数作为第二个参数，以在服务器启动后在终端上打印一条小消息。
- en: 'I''ll use `console.log` to print `Server is up on port 3000`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`console.log`来打印`Server is up on port 3000`：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this in place, we can now start up the server inside the Terminal and
    make sure our `index.html` file shows up in the browser. I''ll go ahead and use
    the `clear` command to clear the Terminal output, then I''ll use `nodemon` to
    run the server, using the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以在终端内启动服务器，并确保我们的`index.html`文件出现在浏览器中。我将使用`clear`命令清除终端输出，然后我将使用`nodemon`运行服务器，使用以下命令：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](img/9bb3fd9a-ba44-4ffe-b697-a53787f26ac9.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bb3fd9a-ba44-4ffe-b697-a53787f26ac9.png)'
- en: 'Here, we get our little message, `Server is up on port 3000`. In the browser,
    if I give things a refresh, we get our markup, `Welcome to the chat app`, as shown
    in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了我们的小消息，`Server is up on port 3000`。在浏览器中，如果我刷新一下，我们就会得到我们的标记，`Welcome
    to the chat app`，如下面的截图所示：
- en: '![](img/702468dc-5328-47a3-a420-2ea2ee480034.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/702468dc-5328-47a3-a420-2ea2ee480034.png)'
- en: We now have a basic server set up, which means in the next section, we can actually
    add Socket.io on both the client and the backend.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个基本的服务器，这意味着在下一节中，我们实际上可以在客户端和后端都添加Socket.io。
- en: Setting up a gitignore file
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置gitignore文件
- en: Now, before we start getting things on GitHub and Heroku, we'll first set up
    a few things inside Atom. We need to set up a `.gitignore` file, which we'll provide
    in the root of the project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们开始在GitHub和Heroku上进行操作之前，我们将首先在Atom中设置一些东西。我们需要设置一个`.gitignore`文件，我们将在项目的根目录中提供它。
- en: Inside `.gitignore`, the only thing we'll be ignoring is the `node_modules`
    folder. We do not want to commit any of this code to our repo, because it can
    be generated using `npm install` and it's subject to change. It's a real pain
    to manage that sort of thing, and it is not recommended that you commit it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.gitignore`中，我们唯一要忽略的是`node_modules`文件夹。我们不想将任何这些代码提交到我们的仓库，因为它可以使用`npm install`生成，并且可能会发生变化。管理这种东西真的很痛苦，不建议你提交它。
- en: 'The next thing we''ll do is configure a few things for Heroku. First up, we
    have to use the `process.env.PORT` environment variable. I''ll create a constant
    called `port` next to the `publicPath` variable, setting it equal to `process.env.PORT`
    or `3000`. We''ll use it locally:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是为Heroku配置一些东西。首先，我们必须使用`process.env.PORT`环境变量。我将在`publicPath`变量旁边创建一个名为`port`的常量，将其设置为`process.env.PORT`或`3000`。我们将在本地使用它：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we can provide `port` in `app.listen`, and we can provide it in the following
    message by changing our regular string to a template string to get `Server is
    up on`. I''ll inject the `port` variable value:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`app.listen`中提供`port`，并且可以通过将常规字符串更改为模板字符串来在以下消息中提供它，以获得`Server is up
    on`。我将注入`port`变量值：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have that in place, the next thing we need to change in order to
    get our app set up for Heroku is update the `package.json` file, adding a `start`
    script and specifying the version of Node we want to use. Under `scripts`, I''ll
    add a `start` script telling Heroku how to start the application. In order to
    start the app, you have to run the `node` command. You''ll have to go into the
    `server` directory, and the file to start it up is `server.js`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了，接下来我们需要改变的是为了让我们的应用为Heroku设置好，更新`package.json`文件，添加一个`start`脚本并指定我们想要使用的Node版本。在`scripts`下，我将添加一个`start`脚本，告诉Heroku如何启动应用程序。为了启动应用程序，你必须运行`node`命令。你必须进入`server`目录，启动它的文件是`server.js`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''re also going to specify `engines`, which we''ve done before. `engines`,
    as you know, lets you tell Heroku which version of Node to use:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将指定`engines`，这是我们以前做过的。正如你所知，`engines`可以让你告诉Heroku要使用哪个版本的Node：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will be important as we are taking advantage of some features only available
    in the latest versions of Node. Inside `engines`, I''ll provide the exact same
    key-value pair I used previously, setting `node` equal to `9.3.0`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是重要的，因为我们正在利用一些仅在最新版本的Node中才能使用的功能。在`engines`中，我将提供与之前使用的完全相同的键值对，将`node`设置为`9.3.0`：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you're using a different version of Node, you can provide that instead of
    the version I have added here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是不同版本的Node，你可以提供这里添加的版本的替代版本。
- en: Making a commit with the current uncommitted files
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用当前未提交的文件进行提交
- en: Now that we have this in place, you are ready to make a commit with all of the
    current uncommitted files. You'll then go into GitHub and create a GitHub repository,
    where you'll push your local code up. Make sure the code actually gets on GitHub;
    you can do that by refreshing the GitHub repo page. You should see your directory
    structure right there on the repo.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好用所有当前未提交的文件进行提交了。然后你将进入GitHub并创建一个GitHub仓库，将你的本地代码推送上去。确保代码实际上被推送到GitHub；你可以通过刷新GitHub仓库页面来做到这一点。你应该在仓库中看到你的目录结构。
- en: The next thing you need to do is create a Heroku application and deploy to it.
    Once your application is deployed, you should be able to visit the app URL on
    the browser. You should see the exact same message as the one we have in our `localhost:3000`.
    The `Welcome to the chat app` message should print, but instead of being on `localhost:3000`,
    you should be on the actual Heroku app.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你需要做的是创建一个Heroku应用并部署到它。一旦你的应用部署完成，你应该能够在浏览器上访问应用的URL。你应该看到与我们在`localhost:3000`上看到的完全相同的消息。`Welcome
    to the chat app`消息应该会打印出来，但不是在`localhost:3000`上，而是在实际的Heroku应用上。
- en: Now we have made all the changes necessary inside the project. We have configured
    the `port` variable and we have set up our `scripts` and `engines`, so you don't
    have to make any more code changes; you just need to work your wizardry in the
    browser and the Terminal to get this done.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在项目内进行了所有必要的更改。我们已经配置了`port`变量，并设置了我们的`scripts`和`engines`，所以你不需要再进行任何代码更改；你只需要在浏览器和终端中施展你的魔法来完成这个。
- en: 'The first step is to make a new GitHub repository. We need a place to push
    up our code. We can head over to [github.com](https://github.com/), click on that
    big green New repository button, and make a new one. I''ll call my repository
    `node-course-2-chat-app`. I will leave this public and create it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新的GitHub存储库。我们需要一个地方来推送我们的代码。我们可以前往[github.com](https://github.com/)，点击那个大大的新存储库按钮，然后创建一个新的。我会把我的存储库命名为`node-course-2-chat-app`。我会将其设置为公共并创建：
- en: '![](img/87bf2c14-1f24-4ab5-a821-3303b4b45b5f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87bf2c14-1f24-4ab5-a821-3303b4b45b5f.png)'
- en: 'Now that we''ve created the repository, we have a list of commands we can use.
    We have an existing repository we want to push, so we can copy these lines:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了存储库，我们有一系列可以使用的命令。我们有一个现有的存储库要推送，所以我们可以复制这些行：
- en: '![](img/dcd2bf63-eb91-40ab-9345-388086661b42.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcd2bf63-eb91-40ab-9345-388086661b42.png)'
- en: 'In the Terminal, before we can actually push anything, we need to make a commit.
    I''ll shut down `nodemon` and run the `git status` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，在我们实际推送任何东西之前，我们需要进行提交。我会关闭`nodemon`并运行`git status`命令：
- en: '![](img/14707ad1-5052-4aa0-a9c6-a1748b736135.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14707ad1-5052-4aa0-a9c6-a1748b736135.png)'
- en: Here, you see we have our expected files, we have the `public` and `server`
    folders, we have `.gitignore`, and we have `package.json`. However, `node_modules`
    is nowhere in sight. Then, you need to use `git add .` to add these untracked
    files to the next commit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们有我们预期的文件，我们有`public`和`server`文件夹，我们有`.gitignore`，我们有`package.json`。然而，`node_modules`不见了。然后，你需要使用`git
    add .`将这些未跟踪的文件添加到下一个提交中。
- en: 'If you run the `git status` command again, you can see everything does look
    good:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行`git status`命令，你会看到一切看起来都很好：
- en: '![](img/3283a9cf-163b-497c-94ee-29e67d7b5699.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3283a9cf-163b-497c-94ee-29e67d7b5699.png)'
- en: 'We have four changes to be committed: four new files. I''ll run `git commit`
    with the `-m` flag to specify a message. The `-a` flag is not required, since
    all of the files are already added. In the quotes, `Init commit` will get the
    job done:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四个要提交的更改：四个新文件。我会运行`git commit`并使用`-m`标志来指定消息。由于所有文件都已经添加，所以不需要`-a`标志。在引号中，`Init
    commit`就可以完成任务：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once you have that commit in place, you can actually push it up to GitHub by
    running the two lines they gave you. I''ll run both of those:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了提交，你可以通过运行他们给你的两行将其推送到GitHub。我会运行这两行：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As shown here, it''s now up on GitHub. We can confirm that by refreshing the
    page, and instead of seeing the instructions, we see the files we created:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，它现在已经在GitHub上了。我们可以通过刷新页面来确认，而不是看到说明，我们看到了我们创建的文件：
- en: '![](img/bcdd497d-6a76-4a67-ac36-6221823c42f9.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcdd497d-6a76-4a67-ac36-6221823c42f9.png)'
- en: 'The next and last thing to do is get the app on Heroku. You don''t actually
    have to go to the Heroku web app to get that done; we can run `heroku create`
    inside the Terminal:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的最后一件事是将应用程序放在Heroku上。实际上，你不需要去Heroku网站应用程序去完成这个；我们可以在终端内运行`heroku create`：
- en: '![](img/0fd758d2-3258-4a0d-a20b-9ca567cb4ef6.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fd758d2-3258-4a0d-a20b-9ca567cb4ef6.png)'
- en: 'Let''s go ahead and create the application. We can use the following command
    to deploy the app. I''m going to go ahead and run that:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建应用程序。我们可以使用以下命令来部署应用程序。我将继续运行它：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will take my local code and push it up to Heroku. Heroku will see that
    new code was pushed, so it will then go ahead and deploy it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我的本地代码推送到Heroku。Heroku将看到新代码被推送，然后会部署它：
- en: '![](img/568ef626-d985-4ab6-8f63-36485be6b3e7.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/568ef626-d985-4ab6-8f63-36485be6b3e7.png)'
- en: 'Once it''s up, we can use the `heroku open` command to open up the app URL
    on the browser. Alternatively, you can always grab the URL from the Terminal.
    I''ll copy the URL, shown in the preceding screenshot, head into the browser,
    and paste it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它上线了，我们可以使用`heroku open`命令在浏览器上打开应用程序的URL。或者，你也可以随时从终端获取URL。我会复制在前面截图中显示的URL，进入浏览器，然后粘贴它：
- en: '![](img/2f19e93c-32d4-47f5-bc74-ca3e10e809e6.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f19e93c-32d4-47f5-bc74-ca3e10e809e6.png)'
- en: As shown in the preceding screenshot, we should see our app. Welcome to the
    chat app shows up on the screen, and with this in place, we are done! We have
    a basic Express server, we have a backend and a frontend, it's up on GitHub, and
    it's up on Heroku!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们应该看到我们的应用程序。欢迎使用聊天应用程序显示在屏幕上，有了这个，我们就完成了！我们有一个基本的Express服务器，我们有一个后端和一个前端，它已经在GitHub上，也已经在Heroku上了！
- en: We are ready to move on to the next section, where we are actually going to
    start integrating Socket.io.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好进入下一节，我们将真正开始集成Socket.io。
- en: Adding Socket.io to an app
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向应用程序添加Socket.io
- en: Now that you have a basic Express application up and running, in this section,
    you'll configure your server to allow for incoming WebSocket connections. This
    means the server will be able to accept connections and we'll be setting up the
    client to make the connections. Then, we'll have a persistent connection and we
    can send data back and forth, whether it's data from the server to the client,
    or data from the client to the server. That is the beauty of WebSockets—you can
    send data in either direction.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个基本的Express应用程序在运行，在本节中，你将配置服务器以允许传入的WebSocket连接。这意味着服务器将能够接受连接，我们将设置客户端进行连接。然后，我们将有一个持久连接，我们可以来回发送数据，无论是从服务器到客户端的数据，还是从客户端到服务器的数据。这就是WebSocket的美妙之处——你可以在任何方向发送数据。
- en: Now, in order to set up WebSockets, we'll be using a library called Socket.io.
    Just like Express makes it really easy to set up an HTTP server, Socket.io makes
    it dead simple to set up a server that supports WebSockets and to create a frontend
    that communicates with the server. Socket.io has a backend and frontend library;
    we'll be using both to set up WebSockets.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了设置WebSockets，我们将使用一个名为Socket.io的库。就像Express使设置HTTP服务器变得非常容易一样，Socket.io使设置支持WebSockets的服务器和创建与服务器通信的前端变得非常简单。Socket.io有一个后端和前端库；我们将使用两者来设置WebSockets。
- en: Setting up Socket.io
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Socket.io
- en: 'To get started, inside the Terminal, let''s go ahead and install the most recent
    version of Socket.io using `npm i`. The module name is `socket.io`, and the most
    recent version at time of writing is `@2.0.4`. We''ll use the `--save` dev flag
    to update the `package.json` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在终端中，让我们继续安装最新版本的Socket.io，使用`npm i`。模块名是`socket.io`，撰写时的最新版本是`@2.0.4`。我们将使用`--save`
    dev标志来更新`package.json`文件：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once this is in place, we can go ahead and make a few changes to our `server`
    file. First up, we''ll load in the library. I''ll make a constant called `socketIO` and
    set it equal to the `require` statement for the `socket.io` library:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个设置好了，我们可以继续对我们的`server`文件进行一些更改。首先，我们将加载库。我将创建一个叫做`socketIO`的常量，并将其设置为`socket.io`库的`require`语句：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this in place, we now need to integrate Socket.io into our existing web
    server. Currently, we use Express to make our web server. We create a new Express
    app, we configure our middleware, and we call `app.listen`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在需要将Socket.io集成到我们现有的Web服务器中。目前，我们使用Express来创建我们的Web服务器。我们创建一个新的Express应用程序，配置我们的中间件，并调用`app.listen`：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, behind the scenes, Express is actually using a built-in Node module called
    `http` to create this server. We'll need to use `http` ourselves. We need to configure
    Express to work with `http`. Then, and only then, will we also be able to add
    Socket.io support.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在幕后，Express实际上是在使用一个内置的Node模块叫做`http`来创建这个服务器。我们需要自己使用`http`。我们需要配置Express来与`http`一起工作。然后，只有这样，我们才能添加Socket.io支持。
- en: Creating a server using the http library
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用http库创建服务器
- en: 'First up, we''ll load in the `http` module. So, let''s make a constant called
    `http`, which is a built-in Node module so there''s no need to install it. We
    can simply enter `require(''http'')`, just like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将加载`http`模块。所以，让我们创建一个叫做`http`的常量，这是一个内置的Node模块，所以不需要安装它。我们可以简单地输入`require('http')`，就像这样：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'From here, we''ll create a server using this `http` library. Just below our
    `app` variable, let''s make a variable called `server`. We''ll call `http.createServer`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将使用这个`http`库创建一个服务器。在我们的`app`变量下面，让我们创建一个叫做`server`的变量。我们将调用`http.createServer`：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, you might not know it but you''re actually already using the `createServer`
    method behind the scenes. When you call `app.listen` on your Express app, it literally
    calls this exact same method, passing in the app as the argument for `createServer`.
    The `createServer` method takes a function. This function looks really similar
    to one of our Express callbacks, and it gets called with a request and a response:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能不知道，但实际上你已经在幕后使用`createServer`方法。当你在Express应用程序上调用`app.listen`时，它实际上调用了这个完全相同的方法，将应用程序作为`createServer`的参数传递。`createServer`方法接受一个函数。这个函数看起来非常类似于我们的Express回调之一，并且会被调用以请求和响应：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, as I mentioned, `http` is actually used behind the scenes for Express.
    It''s integrated so much so that you can actually just provide `app` as the argument,
    and we are done:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我所提到的，Express实际上在幕后使用了`http`。它被集成得如此之深，以至于你实际上可以将`app`作为参数提供，然后我们就完成了：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Before we integrate Socket.io, let''s go ahead and wrap up this change. We''ll
    use the HTTP server as opposed to the Express server, so instead of calling `app.listen`,
    we''ll call `server.listen`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成Socket.io之前，让我们继续完成这个更改。我们将使用HTTP服务器而不是Express服务器，所以我们将调用`server.listen`而不是`app.listen`：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once again, there's no need to change the arguments passed in the `server.listen`
    method—they're exactly the same and built really closely to each other, so the
    `server.listen` arguments are the same as the Express `app.listen` arguments.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，不需要更改传递给`server.listen`方法的参数——它们完全相同，并且非常接近彼此，因此`server.listen`的参数与Express的`app.listen`的参数相同。
- en: 'Now that we have this in place, we haven''t actually changed any app functionality.
    Our server is still going to work on port `3000`, but we''re still not going to
    have access to Socket.io. In the Terminal, I can prove this by clearing the Terminal
    output and starting up our server using `nodemon` command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这一步，我们实际上并没有改变任何应用程序功能。我们的服务器仍然会在端口`3000`上工作，但我们仍然无法访问Socket.io。在终端中，我可以通过清除终端输出并使用`nodemon`命令启动我们的服务器来证明这一点：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, I''ll load `localhost:3000` in the browser URL and see what I get back:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将在浏览器URL中加载`localhost:3000`，看看我得到了什么：
- en: '![](img/d0d7f5b6-0533-4639-a599-8444ed9366bc.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0d7f5b6-0533-4639-a599-8444ed9366bc.png)'
- en: As shown in the preceding screenshot, we get our HTML, and Welcome to the chat
    app shows up. This means that our app is still working even though we're now using
    the HTTP server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们得到了我们的HTML，欢迎来到聊天应用程序。这意味着我们的应用程序仍然在工作，即使我们现在使用的是HTTP服务器。
- en: Configuring the server to use Socket.io
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器使用Socket.io
- en: The next thing that we'll do is configure the server to use Socket.io—that's
    the entire reason we made this change. Next to the `server` variable, we'll make
    a variable called `io`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的事情是配置服务器使用Socket.io——这就是我们进行这个更改的整个原因。在`server`变量旁边，我们将创建一个名为`io`的变量。
- en: 'We''ll set it equal to a call to `socket.io` and pass in `server`, which we
    want to use with our WebSockets:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它设置为调用`socket.io`并传入`server`，这是我们想要与我们的WebSockets一起使用的：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we have access to that server via the `server` variable, so we'll pass it
    in as the first and only argument. Now, what we get back is our WebSockets server.
    On here, we can do anything we want in terms of emitting or listening to events.
    This is how we're going to communicate between the server and the client, and
    we'll talk more about that later in this section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过 `server` 变量可以访问服务器，所以我们将它作为第一个且唯一的参数传递进去。现在，我们得到的是我们的 WebSockets 服务器。在这里，我们可以做任何我们想做的事情，无论是发出还是监听事件。这就是我们将在服务器和客户端之间进行通信的方式，我们稍后会在本节中详细讨论。
- en: With this in place, our server is ready to go; we are ready to accept new connections.
    The problem is that we don't have any connections to accept. When we load our
    web page, we're not doing anything. We're not actually connecting to the server.
    We are going to need to manually run some JavaScript code to initiate that connection
    process.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，我们的服务器已经准备就绪；我们已经准备好接受新的连接。问题是我们没有任何连接可以接受。当我们加载我们的网页时，我们什么也没做。我们实际上没有连接到服务器。我们需要手动运行一些
    JavaScript 代码来启动连接过程。
- en: 'Now, when we integrated Socket.io with our server, we actually got access to
    a few cool things. First up, we got access to a route that accepts incoming connections,
    which means that we can now accept WebSocket connections. Plus, we got access
    to a JavaScript library, which makes it really easy to work with Socket.io on
    the client. This library is available at the following path: `localhost:3000/socket.io/socket.io.js`.
    If you load this JavaScript file in the browser, you can see it''s just a really
    long JavaScript library:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们将 Socket.io 与我们的服务器集成时，我们实际上获得了一些很酷的东西。首先，我们获得了一个接受传入连接的路由，这意味着我们现在可以接受
    WebSocket 连接。此外，我们获得了一个 JavaScript 库，这使得在客户端上使用 Socket.io 变得非常容易。这个库可以在以下路径找到：`localhost:3000/socket.io/socket.io.js`。如果你在浏览器中加载这个
    JavaScript 文件，你会发现它只是一个非常长的 JavaScript 库。
- en: '![](img/99e7d630-174a-4fa3-a6ab-376abd26388d.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99e7d630-174a-4fa3-a6ab-376abd26388d.png)'
- en: This contains all of the code we'll need on the client to make the connection
    and to transfer data, whether it's from server to client or client to server.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了我们在客户端需要的所有代码，以建立连接和传输数据，无论是从服务器到客户端，还是从客户端到服务器。
- en: What we'll do in order to make the connection from our HTML file is load this
    in. I'll go back to `localhost:3000`. Now, we can go ahead and move into Atom,
    opening up `index.html`, and near the bottom of the `body` tag, we'll add a `script`
    tag to load in the file we just pulled up in the browser.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的 HTML 文件建立连接，我们将加载它。我将返回到 `localhost:3000`。现在，我们可以继续进入 Atom，打开 `index.html`，并在
    `body` 标签的底部附近，添加一个 `script` 标签来加载我们刚刚在浏览器中打开的文件。
- en: 'First up, we''ll make the `script` tag itself, opening and closing it, and
    in order to load in an external file, we''ll use the `src` attribute to provide
    the path:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建 `script` 标签本身，打开和关闭它，为了加载外部文件，我们将使用 `src` 属性来提供路径：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, this path is relative to our server. It''s going to be `/socket.io/socket.io.js`,
    which is exactly as we typed it in the browser earlier:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个路径是相对于我们的服务器的。它将是 `/socket.io/socket.io.js`，这正是我们之前在浏览器中输入的。
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'By adding the `script` tag, we''re now loading in the library. On the browser,
    we have access to all sorts of methods available, thanks to the `socket` library.
    One of those methods is going to let us initiate a connection request, and that''s
    exactly what we''re going to do in the next line. Let''s add a second `script`
    tag. This time, instead of loading an external script, we''ll write some JavaScript
    right in the line:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `script` 标签，我们现在加载了这个库。在浏览器中，由于 `socket` 库的存在，我们可以访问各种可用的方法。其中一个方法将让我们发起连接请求，这正是我们将在下一行中做的。让我们添加第二个
    `script` 标签。这一次，我们不是加载外部脚本，而是直接在这一行中编写一些 JavaScript：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can add any JavaScript we like, and this JavaScript is going to run right
    after the Socket.io library loads. A little bit later on, we''ll be breaking this
    out into its own file—but for the moment, we can simply have our JavaScript code
    right inside our HTML file. We''re going to call `io`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加任何我们喜欢的 JavaScript，这个 JavaScript 将在 Socket.io 库加载后立即运行。稍后，我们将把它拆分成自己的文件，但目前，我们可以简单地将我们的
    JavaScript 代码放在 HTML 文件中。我们将调用 `io`：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`io` is a method available to us because we loaded in this library. It''s not
    native to the browser, and when we call it, we''re actually initiating the request.
    We''re making a request from the client to the server to open up a WebSocket and
    keep that connection open. Now, what we get back from `io` is really important;
    we''ll save that in a variable called `socket`, just like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`io` 是一个可用的方法，因为我们加载了这个库。它不是浏览器的原生方法，当我们调用它时，实际上是在发起请求。我们从客户端向服务器发出请求，打开一个
    WebSocket 并保持连接。现在，我们从 `io` 得到的东西非常重要；我们将把它保存在一个叫做 `socket` 的变量中，就像这样：'
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This creates our connection and stores the socket in a variable. This variable
    is critical to communicating; it's exactly what we need in order to listen for
    data from the server and send data to the server. Now that we have this in place,
    let's go ahead and save our HTML file. We'll move into the browser and open up
    Chrome Developer Tools.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了我们的连接并将 socket 存储在一个变量中。这个变量对于通信至关重要；这正是我们需要的，以便监听来自服务器的数据并向服务器发送数据。现在我们已经做好了这一切，让我们继续保存我们的
    HTML 文件。我们将进入浏览器并打开 Chrome 开发者工具。
- en: Now regardless of what browser you use, whether it's IE, Safari, Firefox, or
    Chrome, you'll have access to a set of developer tools, which makes it really
    easy to debug and see what's going on behind the scenes in your web page. We'll
    be using the Chrome Developer Tools here to do a little debugging, I'd highly
    recommend using Chrome for the course just so you can follow along exactly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么浏览器，无论是 IE、Safari、Firefox 还是 Chrome，你都可以访问一组开发者工具，这使得在你的网页背后轻松调试和查看发生的事情。我们将在这里使用
    Chrome 开发者工具进行一些调试，我强烈建议在课程中使用 Chrome，这样你可以完全跟上。
- en: 'To open up Developer tools, we go to Settings | More tools | Developer tools.
    You can also use the keyboard shortcut particular to your operating system. When
    you open Developer tools, you''re going to be greeted with an overwhelming set
    of options, as shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开开发者工具，我们转到设置|更多工具|开发者工具。您也可以使用特定于您的操作系统的键盘快捷键。打开开发者工具后，您将看到一个令人震惊的选项集，如下所示：
- en: '![](img/72f77d05-d85e-479b-beb7-f6b57fa68309.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72f77d05-d85e-479b-beb7-f6b57fa68309.png)'
- en: You're most likely brought to the Elements panel if you've never used Chrome
    Developer Tools before. The panel we're going to be using right now is the Network
    panel.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未使用过Chrome开发者工具，您很可能会被带到元素面板。我们现在要使用的面板是网络面板。
- en: The Network panel keeps track of all of the requests made by your web page.
    So, if I make a request for a JavaScript file, I'm going to see that in a nice
    list, as shown in the preceding screenshot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 网络面板跟踪您的网页发出的所有请求。因此，如果我请求JavaScript文件，我将在一个漂亮的列表中看到它，就像前面的屏幕截图所示的那样。
- en: 'We''re going to have to refresh the page in order to see the list of network
    requests; right here, we have five:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不刷新页面才能看到网络请求列表；在这里，我们有五个：
- en: '![](img/ab69f98e-f2d1-4a7a-80a2-93731e25162a.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab69f98e-f2d1-4a7a-80a2-93731e25162a.png)'
- en: The network request at the very top is the first one that was made, and the
    one at the very bottom is the last one that was made. The first one was for the
    `localhost:3000` page, which was for the HTML file that loads `Welcome to the
    chat app`. The second one is for that JavaScript file that we saw on the browser,
    which gives us the library and gives us access to calling that `io` method that
    starts the connection process. The next four are all related to starting up and
    maintaining that connection. With this in place, we now have that live connection
    between the client and the server, and we can start communicating whatever we
    want to communicate.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的网络请求是第一个发出的请求，底部的是最后一个发出的请求。第一个是`localhost:3000`页面的请求，用于加载`欢迎来到聊天应用`的HTML文件。第二个是我们在浏览器上看到的JavaScript文件的请求，它为我们提供了库，并让我们调用启动连接过程的`io`方法。接下来的四个都与启动和维护该连接有关。有了这个，我们现在在客户端和服务器之间有了实时连接，我们可以开始传达任何我们想要传达的内容。
- en: Communication between the client and server
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的通信
- en: Now, the communication could be anything at all. In this case, it comes in the
    form of an event. Events can be emitted from both the client and the server, and
    both the client and the server can listen for events. Let's talk about an event
    that might happen in an email app.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通信可以是任何东西。在这种情况下，它以事件的形式出现。事件可以从客户端和服务器发出，并且客户端和服务器都可以监听事件。让我们来谈谈在电子邮件应用中可能发生的事件。
- en: 'In an email app, the server might emit an event called `newEmail` when a new
    email comes in. The client is then going to listen for that event. When it fires,
    it will get the `newEmail` data and render the email to the screen below the other
    ones. The same thing could happen the other way: maybe the client wants to create
    a new email and send it to someone else. It will ask for the email address of
    the person and the contents of the message, and it''s then going to emit an event
    on the client that the server is going to listen for. So, this whole server/client
    relationship is entirely run via these events.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子邮件应用中，当新邮件到达时，服务器可能会发出一个名为`newEmail`的事件。然后客户端将监听该事件。当它触发时，它将获取`newEmail`数据并将邮件呈现在其他邮件下方的屏幕上。同样的事情也可能发生在另一个方向上：也许客户端想要创建一封新的电子邮件并将其发送给其他人。它将要求输入收件人的电子邮件地址和消息的内容，然后将在客户端上发出一个事件，服务器将监听该事件。因此，整个服务器/客户端关系完全通过这些事件来运行。
- en: Now, we'll create custom events for our specific application throughout this
    chapter; but for now, we're going to look at a couple of default built-in ones
    that let you keep track of new users and disconnecting users. This means we'll
    be able to do something like greet a user when they join our application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在本章中为我们的特定应用程序创建自定义事件；但现在，我们将看一下一些默认内置事件，让您可以跟踪新用户和断开连接的用户。这意味着我们将能够做一些像在用户加入我们的应用程序时问候用户的事情。
- en: The io.on method
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: io.on方法
- en: 'In order to play around with this inside Atom, in `server.js`, we are going
    to call a method on `io` called `io.on`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Atom中玩耍，我们将在`server.js`中调用`io`上的一个方法，称为`io.on`：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `io.on` method lets you register an event listener. We can listen for a
    specific event and do something when that event happens. One built-in event that
    we''re going to use—the most popular one—is called `connection`. This lets you
    listen for a new connection of a client to the server, and lets you do something
    when that connection comes in. In order to do something, you provide a callback
    function as the second argument, and this callback function is going to get called
    with a `socket`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.on`方法允许您注册事件侦听器。我们可以监听特定事件，并在该事件发生时执行某些操作。我们将要使用的一个内置事件是最受欢迎的，称为`connection`。这使您可以监听客户端与服务器的新连接，并在该连接到来时执行某些操作。为了执行某些操作，您需要提供一个回调函数作为第二个参数，这个回调函数将使用`socket`被调用：'
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This `socket` argument is really similar to the `socket` argument we have access
    to inside the `index.html` file. This represents the individual socket, as opposed
    to all of the users connected to the server. Now, with this in place, we can do
    whatever we like. For example, I could use `console.log` to print a little message,
    such as `New user connected`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`socket`参数与我们在`index.html`文件中访问的`socket`参数非常相似。这代表了单个socket，而不是连接到服务器的所有用户。现在，有了这个，我们可以做任何我们想做的事情。例如，我可以使用`console.log`打印一条消息，比如`新用户已连接`：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Every time a user connects to our app, we''ll print a message to the console.
    I''ll go ahead and save the `server.js` file, move into the Terminal, and you''ll
    see that the message actually already exists:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户连接到我们的应用时，我们将在控制台上打印一条消息。我将保存`server.js`文件，进入终端，您将看到消息实际上已经存在：
- en: '![](img/d65ffe25-41a2-4158-b4ac-3590bf86d903.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d65ffe25-41a2-4158-b4ac-3590bf86d903.png)'
- en: To explain why, we need to understand one thing about WebSockets. WebSockets,
    as I mentioned, are a persistent technology, meaning that the client and server
    both keep the communication channel open for as long as either of them want to.
    If the server shuts down, the client doesn't really have a choice, and vice versa.
    If I close a browser tab, the server cannot force me to keep the connection open.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释原因，我们需要了解有关WebSockets的一件事。正如我提到的，WebSockets是一种持久技术，这意味着客户端和服务器都会保持通信渠道打开，只要它们中的任何一个希望保持打开。如果服务器关闭，客户端实际上没有选择，反之亦然。如果我关闭浏览器选项卡，服务器无法强迫我保持连接打开。
- en: Now, when a connection drops the client, it's still going to try to reconnect.
    When we restart the server using `nodemon`, there's about a quarter of a second
    where the server is down, and the client notices that. It says, "woah, woah, woah!
    Server went down! Let's try to reconnect!" Eventually it reconnects, and that's
    why we're seeing the message, `New user connected`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当连接断开客户端时，它仍会尝试重新连接。当我们使用`nodemon`重新启动服务器时，大约有四分之一秒的时间服务器是关闭的，客户端会注意到这一点。它会说，“哇，哇，哇！服务器宕机了！让我们尝试重新连接！”最终它会重新连接，这就是为什么我们会看到消息`New
    user connected`。
- en: 'Go ahead and shut down the server, and over inside the client, you''ll see
    that network requests are being made in Chrome Developer Tools:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 继续关闭服务器，在客户端内部，您将看到网络请求正在Chrome开发者工具中进行：
- en: '![](img/4a98cb77-75d4-493b-9afb-d48ac57f2cbd.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a98cb77-75d4-493b-9afb-d48ac57f2cbd.png)'
- en: 'They''re trying to reconnect to the server, and you can see they''re failing
    because the server is not up. Now, go back into the Terminal and restart the server
    like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 他们正在尝试重新连接到服务器，您可以看到他们失败了，因为服务器没有启动。现在，回到终端，像这样重新启动服务器：
- en: '![](img/05a56f3d-7382-46f4-86c3-3ebe0df21368.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05a56f3d-7382-46f4-86c3-3ebe0df21368.png)'
- en: 'Inside the client, we''ll try to reconnect again. We''ll get a success result
    from the server—and boom—we are back! Just like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端内部，我们将尝试再次重新连接。我们将从服务器获得成功的结果，然后我们就回来了！就像这样：
- en: '![](img/73e49a7b-0326-40b2-86c4-130b7f59353e.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73e49a7b-0326-40b2-86c4-130b7f59353e.png)'
- en: Now, when we reconnect, you can see that we get the message again, and that's
    why we saw it when we first added it to the `server.js` file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们重新连接时，您可以看到我们再次收到了消息，这就是我们第一次将其添加到`server.js`文件时看到它的原因。
- en: Adding a connection event in the client
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端添加连接事件
- en: 'Now, the connection event also exists in the client. This means that in the
    client, we can do something when we successfully connect to the server. It may
    not happen right away; it may take a little time. Over inside Atom, we can add
    this event inside `index.html`, right below our call to `io`. As shown, we''ll
    call `socket.on`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，连接事件也存在于客户端。这意味着在客户端，当我们成功连接到服务器时，我们可以执行一些操作。它可能不会立即发生；可能需要一点时间。在Atom内部，我们可以在`index.html`中添加此事件，就在我们对`io`的调用下面。如图所示，我们将调用`socket.on`：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We want to listen for an event, and this event is a little different to the
    one we have in our `server.js` file. It''s not `on(''connection'')`, but `on(''connect'')`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要监听一个事件，这个事件与我们在`server.js`文件中的事件有些不同。它不是`on('connection')`，而是`on('connect')`：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `on` method here is exactly the same as the one we used in `server.js`.
    The first argument is the event name and the second argument is the callback function.
    In this case, we don't get access to a `socket` argument, since we already have
    it as a `socket` variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`on`方法与我们在`server.js`中使用的方法完全相同。第一个参数是事件名称，第二个参数是回调函数。在这种情况下，我们不会获得`socket`参数的访问权限，因为我们已经将其作为`socket`变量。
- en: 'In this case, all I''ll do is use `console.log` to print a little message to
    the console, `Connected to server`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我要做的就是使用`console.log`在控制台中打印一条小消息，`Connected to server`：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now that we have this in place, we can go into the browser and go to a new
    tab in Developer tools. We''ll load the Console tab. The Console tab is kind of
    like the Terminal inside Node. If we use `console.log` in our client-side JavaScript
    code, those messages are going to show up there. As you can see in the preceding
    screenshot, we also have some errors. These errors occurred when our server was
    down as I was showing you how it reconnects; but if we refresh the page, as you''re
    going to see, `Connected to server` shows up, as shown here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经做到了这一点，我们可以进入浏览器并转到开发者工具中的新选项卡。我们将加载控制台选项卡。控制台选项卡有点像Node内部的终端。如果我们在客户端JavaScript代码中使用`console.log`，这些消息将显示在那里。正如您在前面的屏幕截图中所看到的，我们还有一些错误。这些错误发生在我们的服务器关闭时，我正在向您展示它是如何重新连接的；但是如果我们刷新页面，正如您将看到的，`Connected
    to server`会显示出来，如下所示：
- en: '![](img/b2c5a05b-8a60-4dbf-92b8-8a736595cd37.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2c5a05b-8a60-4dbf-92b8-8a736595cd37.png)'
- en: As soon as the connection happens, the client and the server both have that
    event fired. The client prints `Connected to server` and the server prints `New
    user connected`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接发生，客户端和服务器都会触发该事件。客户端打印`Connected to server`，服务器打印`New user connected`。
- en: With this in place, we've now used the event system in Socket.io. We haven't
    set our own custom events, but we have taken advantage of some built-in ones.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在已经在Socket.io中使用了事件系统。我们还没有设置自己的自定义事件，但我们已经利用了一些内置事件。
- en: The disconnect event
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断开连接事件
- en: The last thing we're going to talk about in this section is the `disconnect`
    event, which lets you do something on both the server and the client when the
    connection drops. We'll add an event listener on the client, and do the same thing
    on the server.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们要讨论的最后一件事是`disconnect`事件，它允许您在连接断开时在服务器和客户端上执行某些操作。我们将在客户端上添加一个事件侦听器，并在服务器上执行相同的操作。
- en: 'On the client, next to our `connect` event, we can call `socket.on` again to
    listen to a new event. Once again, the name of the event here is the name of a
    built-in event, so it''s only going to work if you type it correctly. This one
    is called `disconnect`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，紧挨着我们的`connect`事件，我们可以再次调用`socket.on`来监听一个新事件。再次强调，这里的事件名称是一个内置事件的名称，所以只有在您正确输入时才会起作用。这个事件叫做`disconnect`：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `disconnect` event is going to fire whenever the connection drops. If the
    server goes down, the client is going to be able to do something. For now, that
    something is just going to be log a message, `console.log(''Disconnected from
    server'')`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`disconnect`事件将在连接断开时触发。如果服务器宕机，客户端将能够执行某些操作。目前，这个操作只是记录一条消息，`console.log(''与服务器断开连接'')`：'
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now that we have this message in place, we can actually save our `index.html`
    file. Go over to the browser and give it a refresh to load in our new JavaScript
    file. Go ahead and make your browser screen just a little bit smaller so we can
    see it in the background of the Terminal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这条消息，我们可以保存我们的`index.html`文件。转到浏览器并刷新以加载我们的新JavaScript文件。继续让你的浏览器屏幕小一点，这样我们可以在终端的背景中看到它。
- en: 'I''ll go to the Terminal, shut down the connection by shutting down the server,
    and over inside the browser, we get `Disconnected from server` printing to the
    screen:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我将转到终端，通过关闭服务器关闭连接，在浏览器内，我们得到`与服务器断开连接`打印到屏幕上：
- en: '![](img/7b2c98db-b167-450b-9edd-2866e78baf95.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b2c98db-b167-450b-9edd-2866e78baf95.png)'
- en: 'If I restart my server inside the Terminal, you can see we''ve automatically
    connected, as `Connected to server` prints to the screen:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在终端内重新启动服务器，你可以看到我们已经自动连接，因为`连接到服务器`打印到屏幕上：
- en: '![](img/8f0feac0-1f57-46ae-8260-c0053d06bb4c.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f0feac0-1f57-46ae-8260-c0053d06bb4c.png)'
- en: Now, the exact same event exists on the server. We can listen for a disconnecting
    client and we can do something when they leave. In order to register this event,
    you are going to go into `server.js`, and inside our callback, you're going to
    call `socket.on` in `server.js`, just like we did in the `index.html` file. It's
    the exact same signature. The first argument is the event name, `disconnect`.
    The callback function should do something simple, like print `client disconnected`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务器上也存在完全相同的事件。我们可以监听断开连接的客户端，并在他们离开时执行某些操作。为了注册这个事件，你需要进入`server.js`，在我们的回调内，你需要像在`index.html`文件中一样调用`socket.on`在`server.js`内。它的签名完全相同。第一个参数是事件名称，`disconnect`。回调函数应该做一些简单的事情，比如打印`客户端断开连接`。
- en: Once you have that in place, what I want you to do is open up the browser and
    open up the Terminal, then close the browser tab. You should see the message print
    in the server—whatever message you happened to type here. Open up another browser
    tab, close it, and make sure you get the same message. This message should print
    every time one of your browser tabs closes, assuming that browser tab had an open
    connection.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做到了这一点，我希望你打开浏览器并打开终端，然后关闭浏览器标签。你应该看到消息在服务器上打印出来——无论你在这里输入了什么消息。打开另一个浏览器标签，关闭它，并确保你得到相同的消息。假设浏览器标签有一个打开的连接，每次关闭一个浏览器标签时，这条消息都应该打印出来。
- en: 'Now, to do this, all you need to do is copy the exact same signature as we
    used in the `io.on` method. `socket.on` takes two arguments: the first one is
    the name of the event we''re trying to listen to, `disconnect`; and the second
    argument is the function to run when the event fires:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要做到这一点，你只需要复制`io.on`方法中使用的完全相同的签名。`socket.on`接受两个参数：第一个是我们要监听的事件名称，`disconnect`；第二个参数是事件触发时要运行的函数：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In this case, all we''re going to do is use `console.log` to print `User was
    disconnected`, just like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们要做的只是使用`console.log`打印`用户已断开连接`，就像这样：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we''ll save the file, which is automatically going to restart our application.
    Switch to the Terminal and then to the browser, so you can see the Terminal in
    the background. I''m going to open up a new tab, so when I close this currently
    open tab, the Chrome browser doesn''t close completely. Close the tab with the
    open connection and, as shown in the following screenshot, inside the Terminal,
    we get `User was disconnected`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将保存文件，这将自动重新启动我们的应用程序。切换到终端，然后切换到浏览器，这样你就可以看到后台的终端。我将打开一个新标签，这样当我关闭当前打开的标签时，Chrome浏览器不会完全关闭。关闭具有打开连接的标签，并且如下截图所示，在终端内，我们得到`用户已断开连接`：
- en: '![](img/fafaca7c-7953-45ac-abff-01d99d39c79f.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fafaca7c-7953-45ac-abff-01d99d39c79f.png)'
- en: If I open up a new tab and go to `localhost:3000`, then `New user connected`
    prints. As soon as I close it,  `User was disconnected` prints to the screen on
    the server. Hopefully, you're starting to see why WebSockets are so awesome—that
    instant two-way communication makes any sort of real-time application effortless
    to build.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我打开一个新标签并转到`localhost:3000`，那么将打印`新用户已连接`。一旦我关闭它，服务器屏幕上将打印`用户已断开连接`。希望你开始看到为什么WebSockets如此强大——即时的双向通信使任何实时应用程序都变得轻而易举。
- en: 'Now, let''s wrap this one up with a commit. I''ll shut down our server and
    run `git status`. We can see that we only have modified files:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用一个提交来结束这一切。我将关闭我们的服务器并运行`git status`。我们可以看到我们只有修改过的文件：
- en: '![](img/1b7ad71a-38da-450f-a53b-87b0991bae91.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b7ad71a-38da-450f-a53b-87b0991bae91.png)'
- en: 'So, `git commit` with the `-am` flag is going to get the job done. We can add
    our message, `Add connect and disconnect event handlers`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，使用`git commit`和`-am`标志将完成工作。我们可以添加我们的消息，`添加连接和断开事件处理程序`：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: I'll make the commit and push it up to GitHub by using the `git push` command.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提交并使用`git push`命令将其推送到GitHub。
- en: With that in place, we are done. In the next section, we're going to get into
    the very interesting stuff—you're going to learn how to emit and listen to custom
    events. This means you can send any data you like from the server to the client,
    and vice versa.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了。在下一节中，我们将进入非常有趣的内容——你将学会如何发出和监听自定义事件。这意味着你可以从服务器向客户端发送任何你喜欢的数据，反之亦然。
- en: Emitting and listening to custom events
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出和监听自定义事件
- en: In the previous section, you learned how to listen to those built-in events—things
    such as connection events and disconnection events. Those are fine, and they're
    a great starting place, but in this section, what we want to talk about is emitting
    and listening to custom events, and this is where Socket.io gets really interesting.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你学会了如何监听那些内置事件——诸如连接事件和断开连接事件。这些都很好，是一个很好的起点，但在这一节中，我们想要讨论的是发出和监听自定义事件，这就是Socket.io变得非常有趣的地方。
- en: 'When you''re able to emit and listen to custom events, you can send anything
    you want from the server to the client or from the client to the server. Now,
    to go through a quick example of how that''ll look, we''re going to use an example
    app, which will be an email application:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你能够发出和监听自定义事件时，你可以从服务器向客户端发送任何你想要的东西，或者从客户端向服务器发送任何你想要的东西。现在，让我们快速看一下这将是什么样子的一个例子，我们将使用一个示例应用程序，这将是一个电子邮件应用程序：
- en: '![](img/2900ca06-4ada-4f9d-b008-d808ba8d2aaf.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2900ca06-4ada-4f9d-b008-d808ba8d2aaf.png)'
- en: 'On the left, we have our server, which is starting up a Socket.io web server.
    On the right, we have our email app, which is showing a list of all our current
    emails. Now, one custom event that our app might require is a `newEmail` event:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边，我们有我们的服务器，它正在启动一个Socket.io web服务器。在右边，我们有我们的电子邮件应用程序，它显示了我们所有当前电子邮件的列表。现在，我们的应用可能需要的一个自定义事件是`newEmail`事件：
- en: '![](img/e853b6ec-58a3-476c-b1ab-1dc5919a2e78.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e853b6ec-58a3-476c-b1ab-1dc5919a2e78.png)'
- en: The `newEmail` event is going to be emitted by the server when an email comes
    in. For example, if I sign up to a new service, that service sends me an email
    to confirm my email. Then, the server eventually gets that email and it emits
    an event that the client listens to. The client is going to listen for the `newEmail`
    event and will be able to re-render the list of emails in the browser using jQuery,
    React, Ember, or whatever library it happens to be using, showing the new email
    to me, the user.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当有电子邮件到达时，服务器将发出`newEmail`事件。例如，如果我注册了一个新服务，该服务会发送一封电子邮件给我确认我的电子邮件。然后，服务器最终收到了那封电子邮件，并发出了一个客户端监听的事件。客户端将监听`newEmail`事件，并能够使用jQuery、React、Ember或者任何它正在使用的库重新渲染浏览器中的电子邮件列表，向我展示新的电子邮件。
- en: Now, aside from just sending a message that an event happened, the most important
    piece to the puzzle is sending data, and we can actually do that. When you create
    and emit a custom event, you can send whatever information you like from the server
    to the client or from the client to the server. Usually, this takes the form of
    an object with various properties. In the case of getting a new email, I might
    want to know who the email is from. I definitely need to know the text of the
    email, and I also want to know when the email arrived at my server so I can render
    what I need to inside the browser for whoever happens to be using the email app.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 除了只发送事件发生的消息之外，最重要的是发送数据，我们实际上可以做到这一点。当你创建并发出自定义事件时，你可以从服务器向客户端发送任何你喜欢的信息，或者从客户端向服务器发送任何你喜欢的信息。通常，这采用一个具有各种属性的对象的形式。在获取新电子邮件的情况下，我可能想知道电子邮件是谁发来的。我肯定需要知道电子邮件的文本，我还想知道电子邮件何时到达我的服务器，这样我就可以在浏览器中为使用电子邮件应用程序的人渲染所需的内容。
- en: 'Now, this is data flowing from the server to the client, which is something
    we were not able to accomplish with HTTP requests, but it is something we can
    accomplish using Socket.io. Now, another event, the  `createEmail` event, is going
    to flow from the client to the server:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是从服务器流向客户端的数据，这是我们无法通过HTTP请求实现的，但使用Socket.io是可以实现的。现在，另一个事件，`createEmail`事件，将从客户端流向服务器：
- en: '![](img/a4683655-d8fe-48a7-9f09-3c6d2500b135.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4683655-d8fe-48a7-9f09-3c6d2500b135.png)'
- en: When I create a new email inside my web browser, I'll need to emit that event
    from the client, and the server is going to listen for that event. Once again,
    we will be sending some data across. Although the data will be a little different,
    we want to know who the email needs to be sent to, we need the text of the email,
    and maybe we want to schedule it for down the line, so a `scheduleTimestamp` field
    could be used.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在网页浏览器中创建一个新的电子邮件时，我需要从客户端发出该事件，服务器将监听该事件。再次，我们将发送一些数据。虽然数据会有所不同，但我们想知道电子邮件需要发送给谁，我们需要电子邮件的文本，也许我们想要安排它在未来的某个时间发送，所以可以使用`scheduleTimestamp`字段。
- en: Obviously, these are all just example fields; your fields for a real email app
    would probably be a little different. With this in place, though, we are ready
    to go ahead and actually create these two events inside our application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些只是示例字段；你真正的电子邮件应用程序的字段可能会有所不同。不过，有了这个，我们已经准备好在我们的应用程序中实际创建这两个事件了。
- en: Creating custom events inside an application
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中创建自定义事件
- en: Let's dive in to creating custom events inside our application, starting with
    creating `newEmail` and `createEmail` events. Before we start emitting or listening
    to custom events, let's go ahead and make a few tweaks to our client-side JavaScript.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在我们的应用程序中创建自定义事件，首先创建`newEmail`和`createEmail`事件。在我们开始发出或监听自定义事件之前，让我们对我们的客户端JavaScript进行一些调整。
- en: Moving the JavaScript into a separate file
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JavaScript移到一个单独的文件中
- en: 'As you might have noticed in the last section, I accidentally used ES6 arrow
    functions inside our client-side JavaScript code. As I mentioned, we want to avoid
    this; the project is going to work correctly in Chrome, but if you tried to load
    it up on your mobile phone, Internet Explorer, Safari, or some versions of Firefox,
    the program would crash. So, instead of using arrow functions, we''ll use regular
    functions by removing the arrow and adding the `function` keyword before our arguments.
    I''ll do this for the `on(''connect''` listener and for the `on(''disconnect''`
    listener, adding the `function` keyword and removing the arrow:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节中可能已经注意到的，我在我们的客户端JavaScript代码中意外地使用了ES6箭头函数。正如我提到的，我们要避免这样做；项目将在Chrome中正确工作，但如果你尝试在手机、Internet
    Explorer、Safari或某些版本的Firefox上加载它，程序将崩溃。因此，我们将使用常规函数来代替箭头函数，即删除箭头并在参数之前添加`function`关键字。我将对`on('connect'`监听器和`on('disconnect'`监听器进行此操作，添加`function`关键字并删除箭头：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: I'll also take our JavaScript and move it into a separate file. Instead of editing
    the client-side JavaScript right inside our HTML file, we'll have a separate file
    where that code lives. This is a better method to get things done.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将把我们的JavaScript移动到一个单独的文件中。不再直接在我们的HTML文件中编辑客户端JavaScript，而是有一个单独的文件来存放那些代码。这是一个更好的方法来完成事情。
- en: 'In the `public` folder, we can make a new folder for this JavaScript file.
    I''ll make one called `js` (we''ll have multiple JavaScript files by the time
    this app is over, so it''s a good idea to create a folder to house all of those).
    For now, though, we just need one, `index.js`. The `index.js` file will load when
    we load `index.html`, and it will contain all the JavaScript required to get this
    page to work, starting with the JavaScript we wrote in the last section. Cut out
    all of the code in the `script` tag and paste it into `index.js`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`文件夹中，我们可以为这个JavaScript文件创建一个新文件夹。我会创建一个叫做`js`的文件夹（当这个应用程序结束时，我们将有多个JavaScript文件，所以创建一个文件夹来存放所有这些文件是一个好主意）。不过，现在我们只需要一个`index.js`。`index.js`文件将在加载`index.html`时加载，并且它将包含所有所需的JavaScript代码，从我们在上一节中编写的JavaScript开始。剪切`script`标签中的所有代码，并将其粘贴到`index.js`中：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can save the file and update our `script` tag. Instead of having the code
    in line, we''ll load it in by providing the `src` attribute, with the path to
    the file as `/js/index.js`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保存文件并更新我们的`script`标签。不再将代码放在一行中，而是通过提供`src`属性加载它，路径为`/js/index.js`：
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that we have this in place, we have the exact same functionality that we
    had before—only this time around, the JavaScript has been broken out into its
    own file. Start up the server using `nodemon server/server.js`. Once it''s up,
    we can go ahead and load the app by going to the browser and opening up `localhost:3000`.
    I''ll open up Developer tools as well, so we can make sure everything is working
    as expected. Inside the console, we see `Connected to server` is still printing:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这个，我们有了与之前完全相同的功能——只是这一次，JavaScript已经被拆分成了自己的文件。使用`nodemon server/server.js`启动服务器。一旦启动，我们可以通过浏览器打开`localhost:3000`来加载应用程序。我也会打开开发者工具，这样我们就可以确保一切都按预期工作。在控制台中，我们看到`Connected
    to server`仍在打印：
- en: '![](img/8982ec98-bf7d-4919-af54-d88434f1a7ef.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8982ec98-bf7d-4919-af54-d88434f1a7ef.png)'
- en: This is code that exists in `index.js`, and the very fact that it's showing
    up here proves that the file was loaded. With this in place, we can now move on
    to our custom events.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是存在于`index.js`中的代码，它出现在这里的事实证明文件已经被加载。有了这个，我们现在可以继续进行自定义事件。
- en: 'Now, we have two events that we talked about for our example email application:
    we have `newEmail`, which is from the server to the client; and we have `createEmail`,
    which is an event emitted by the client and listened to by the server. We''re
    going to get started with `newEmail`, and to kick things off, we''re going to
    head into our client-side JavaScript and listen for that event.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为我们的示例电子邮件应用程序讨论了两个事件：我们有`newEmail`，它是从服务器到客户端的；我们还有`createEmail`，它是客户端发出并由服务器监听的事件。我们将从`newEmail`开始，为了启动这些事情，我们将进入我们的客户端JavaScript并监听该事件。
- en: 'When that event fires, we want to do something: we want to take the data and
    use jQuery, React, or some other frontend framework to render it to the browser
    so the user can see the email as soon as it comes in.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当该事件触发时，我们想要做一些事情：我们想要获取数据并使用jQuery、React或其他一些前端框架将其呈现到浏览器中，以便用户可以在收到电子邮件时立即看到它。
- en: Adding a newEmail custom event
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个newEmail自定义事件
- en: 'Now, in order to listen to a custom event, we are still going to use `socket.on`;
    although, instead of specifying the name of one of the built-in events, we''ll
    provide the first argument inside quotes as the name of our custom event. In this
    case, that name is going to be `newEmail`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了监听自定义事件，我们仍然将使用`socket.on`；不过，我们不再指定内置事件的名称，而是提供引号内的第一个参数作为我们自定义事件的名称。在这种情况下，该名称将是`newEmail`：
- en: '[PRE57]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, the second argument for `socket.on` is the same as the second argument
    for the built-in event listeners. We''ll provide a function, and this function
    is going to get called when the event fires:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`socket.on`的第二个参数与内置事件监听器的第二个参数相同。我们将提供一个函数，当事件触发时，这个函数将被调用：
- en: '[PRE58]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For now, all we''re going to do inside the function is use `console.log` to
    print a little message, `New email`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在函数内部要做的就是使用`console.log`打印一条消息，`New email`：
- en: '[PRE59]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will print inside of the web developer console every time the client hears
    this event coming across the pipeline. Now that we have the listener in place
    for `newEmail`, let's go ahead and emit this event inside `server.js`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 每当客户端听到这个事件传过来时，这将在Web开发者控制台中打印出来。现在我们已经为`newEmail`设置了监听器，让我们继续在`server.js`中发出这个事件。
- en: The emit method
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: emit方法
- en: 'Inside `server.js`, what we want to do is call a method on `socket`. The `socket`
    method has a method called `emit`, which we''ll use on both the client and the
    server to emit events:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中，我们要做的是在`socket`上调用一个方法。`socket`方法有一个叫做`emit`的方法，我们将在客户端和服务器上都使用它来发出事件：
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `emit` method is really similar to the listeners; although, instead of
    listening to an event, we are creating the event. The first argument is the same.
    It''s going to be the name of the event you want to emit. In this case, we have
    to match it exactly as we specified in `index.js`, `newEmail`. Now, as shown in
    the following code, we''ll provide `newEmail`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`emit`方法与监听器非常相似；不过，与监听事件不同，我们是创建事件。第一个参数是相同的。它将是您要发出的事件的名称。在这种情况下，我们必须与我们在`index.js`中指定的完全匹配，即`newEmail`。现在，如下面的代码所示，我们将提供`newEmail`：'
- en: '[PRE61]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, this is not a listener, so we''ll not provide a callback function. What
    we want to do is specify the data. Now, by default, we don''t have to specify
    any data; maybe we just want to emit `newEmail` without anything, letting the
    browser know that something happened. If we do this, over inside the browser we
    can refresh the app, and we get `New email`, as shown in the following screenshot:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这不是一个监听器，所以我们不会提供回调函数。我们要做的是指定数据。现在，默认情况下，我们不必指定任何数据；也许我们只是想发出`newEmail`而没有任何内容，让浏览器知道发生了某事。如果我们这样做，在浏览器中刷新应用程序，我们会得到`New
    email`，如下面的屏幕截图所示：
- en: '![](img/3015d73d-3ead-4b41-a4d1-574b92392d0e.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3015d73d-3ead-4b41-a4d1-574b92392d0e.png)'
- en: 'The event is still happening even though we''re not sending across any custom
    data. If you do want to send custom data, which is most likely the case, that''s
    super easy. All you have to do is provide a second argument for `newEmail`. Now,
    you could provide an argument of three, or true, or anything else, but you usually
    want to send multiple pieces of data across, so an object is going to be your
    second argument:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有发送任何自定义数据，事件仍在发生。如果您确实想发送自定义数据，这很可能是情况，那很容易。您只需为`newEmail`提供第二个参数。现在，您可以提供三个、true或其他任何参数，但通常您希望发送多个数据，因此对象将成为您的第二个参数：
- en: '[PRE62]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This is going to let you specify anything you like. In our case, we might specify
    who the email is from by specifying a `from` attribute; for instance, it''s from
    `mike@example.com`. Maybe we also have the `text` attribute for the email, `Hey.
    What is going on`, and we might have other attributes as well. For example, `createdAt`
    could be a timestamp of when the server got the email, as shown here:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让您指定任何您喜欢的内容。在我们的情况下，我们可能通过指定`from`属性来指定电子邮件的发件人；例如，它来自`mike@example.com`。也许我们还有电子邮件的`text`属性，`嘿。发生了什么`，我们可能还有其他属性。例如，`createdAt`可以是服务器收到电子邮件的时间戳，如下所示：
- en: '[PRE63]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The data shown in the preceding code block will get sent along with the `newEmail`
    event from the server to the client. Now, go ahead and save `server.js`, and inside
    our client-side JavaScript `index.js` file, we can go ahead and do something with
    that data. The data that''s emitted with your event is provided as the first argument
    to your callback function. As shown in the following code, we have our callback
    function for `newEmail`, which means we can name the first argument `email` and
    do whatever we want with it:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器和客户端之间，前面代码块中显示的数据将随着`newEmail`事件一起从服务器发送到客户端。现在，保存`server.js`，在我们的客户端JavaScript
    `index.js`文件中，我们可以对该数据进行操作。与您的事件一起发出的数据将作为回调函数的第一个参数提供。如下面的代码所示，我们有`newEmail`的回调函数，这意味着我们可以将第一个参数命名为`email`并对其进行任何操作：
- en: '[PRE64]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We might be appending it to a list of emails in a real web app, but for our
    purposes, all we''ll do right now is provide it as the second argument to `console.log`,
    rendering it to the screen:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会将其附加到真实网络应用程序中的电子邮件列表中，但就我们的目的而言，我们现在要做的就是将其作为`console.log`的第二个参数提供，将其呈现到屏幕上：
- en: '[PRE65]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: With this in place, we can now test that everything is working as expected.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以测试一切是否按预期工作。
- en: Testing the newEmail event
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试newEmail事件
- en: 'If I go to the browser and give things a refresh using *command* +* R*, we
    see over inside the console that we have `New email`, and below this we have `Object`. We
    can click on `Object` to expand it and we see all of the properties we specified:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我去浏览器，使用*command* +* R*进行刷新，我们在控制台中看到`New email`，在这之下我们有`Object`。我们可以点击`Object`来展开它，然后我们可以看到我们指定的所有属性：
- en: '![](img/bd867838-4c51-46f5-b1b7-f8e364658f62.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd867838-4c51-46f5-b1b7-f8e364658f62.png)'
- en: We have our `from` property, the `text` property, and our `createdAt` property.
    All of it is showing up as expected, which is fantastic! In real time, we were
    able to pass not only an event, but event data from the server to the client,
    which is something we could never do with an HTTP API.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的`from`属性，`text`属性和我们的`createdAt`属性。所有这些都如预期般显示，这太棒了！实时地，我们能够将事件和事件数据从服务器传递到客户端，这是我们无法通过HTTP
    API实现的。
- en: Adding a createEmail custom event
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个createEmail自定义事件
- en: Now, on the other side of things, we have a situation where we want to emit
    an event from the client trying to send some data to the server. This is for our
    `createEmail` event. Now, in this case, we will add our event listener inside  `server.js`
    using `socket.on`, just as we do for any other event listener, such as we have
    in `server.js`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有一个情况，我们希望从客户端发出事件，尝试向服务器发送一些数据。这是我们的`createEmail`事件。在这种情况下，我们将在`server.js`中使用`socket.on`添加我们的事件监听器，就像我们为任何其他事件监听器所做的那样，就像我们在`server.js`中所做的那样。
- en: 'The `io.on` method we used for the connection event is a very special event;
    you will usually not be attaching anything to `io`, or be making calls to `io.on`
    or `io.emit`, other than the one we have mentioned in this function. Our custom
    event listeners are going to happen in the following statement by calling `socket.on`
    as we do for `disconnect`, passing in the name of the event you want to listen
    to—in this case, it is the `createEmail` event:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于连接事件的`io.on`方法是一个非常特殊的事件；通常您不会将任何内容附加到`io`，也不会调用`io.on`或`io.emit`，除了我们在此函数中提到的内容。我们的自定义事件监听器将在以下语句中发生，通过调用`socket.on`来实现，就像我们为`disconnect`所做的那样，传递您要监听的事件的名称——在本例中是`createEmail`事件：
- en: '[PRE66]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, for `createEmail`, we do want to add a listener. We are in our Node code,
    so we can use an arrow function:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于`createEmail`，我们确实想要添加一个监听器。我们在我们的Node代码中，所以我们可以使用箭头函数：
- en: '[PRE67]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We''re probably going to expect some data, such as the email to create, so
    we can name that first argument. We name it after the data sent along with the
    event, so I''m going to call this `newEmail`. For this example, all we''re going
    to do is print it to the console so we can make sure the event is properly going
    from client to server. I''ll add `console.log` and log out the event name, `createEmail`.
    As the second argument, I''ll log out the data so I can view it in the Terminal
    and make sure everything works as expected:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能期望一些数据，比如要创建的电子邮件，所以我们可以命名第一个参数。我们根据事件发送的数据命名它，所以我将称其为`newEmail`。对于这个示例，我们将只是将其打印到控制台，以便我们可以确保事件从客户端正确地传递到服务器。我将添加`console.log`并记录事件名称`createEmail`。作为第二个参数，我将记录数据，以便我可以在终端中查看它，并确保一切按预期工作：
- en: '[PRE68]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now we have our listener in place and our server did restart; however, we're
    never actually emitting the event on the client. We can go ahead and fix this
    by calling `socket.emit` in `index.js`. Now, call it inside our `connect` callback
    function. We don't want to emit the event until we are connected, and `socket.emit`
    is going to let us do just that. We can call `socket.emit` to emit the event.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了我们的监听器，并且我们的服务器已经重新启动；但是，我们实际上从未在客户端发出事件。我们可以通过在`index.js`中调用`socket.emit`来解决这个问题。现在，在我们的`connect`回调函数中调用它。我们不希望在连接之前发出事件，`socket.emit`将让我们做到这一点。我们可以调用`socket.emit`来发出事件。
- en: 'The event name is `createEmail`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 事件名称是`createEmail`：
- en: '[PRE69]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, we can pass any data we like in as the second argument. In the case of
    an email app, we''re probably going to need to send it to someone, so we''ll have
    an address for that—something like `jen@example.com`. We''re obviously going to
    need some text—something like `Hey. This is Andrew`. Also, we might have other
    properties, such as subject, but for now we''re going to stick with just these
    two:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将任何我们喜欢的数据作为第二个参数传递。在电子邮件应用程序的情况下，我们可能需要将其发送给某人，因此我们将为此提供一个地址——类似于`jen@example.com`。显然，我们需要一些文本——类似于`嘿。我是安德鲁`。此外，我们可能还有其他属性，比如主题，但现在我们将只使用这两个：
- en: '[PRE70]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: So, what we've done here is we've created a client-side script that connects
    it to the server, and as soon as it connects, it emits this `createEmail` event.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在这里所做的是创建一个客户端脚本，将其连接到服务器，一旦连接，就会触发这个`createEmail`事件。
- en: Now, this is not a realistic example. In a real-world app, a user is most likely
    going to fill out a form. You'll grab the previously mentioned pieces of data
    from the form, and then you'll emit the event. We will be working with HTML forms
    a little later; for now, though, we're just calling `socket.emit` to play around
    with these custom events.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这不是一个现实的例子。在真实世界的应用程序中，用户很可能会填写表单。您将从表单中获取先前提到的数据片段，然后发出事件。稍后我们将稍微处理HTML表单；不过，现在我们只是调用`socket.emit`来玩这些自定义事件。
- en: 'Save `index.js`, and inside the browser, we can now give the page a refresh.
    As soon as it connects, it''s going to emit that event:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 保存`index.js`，在浏览器中，我们现在可以刷新页面。一旦连接，它将触发该事件：
- en: '![](img/9ea89ef8-d3e2-402f-ae94-0bf7b4b40141.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ea89ef8-d3e2-402f-ae94-0bf7b4b40141.png)'
- en: 'In the Terminal, you see `createEmail` printing:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，您会看到`createEmail`打印：
- en: '![](img/b7b51fa1-5a51-452d-8594-bfb9a2b1972d.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7b51fa1-5a51-452d-8594-bfb9a2b1972d.png)'
- en: The event was emitted from the client to the server. The server got the data
    and all is well.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是从客户端发出到服务器。服务器收到了数据，一切都很好。
- en: socket.emit in the developer console
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者控制台中的socket.emit
- en: Now, another cool thing about the console is that we have access to the variables
    created by our application; most notably the socket variable. This means that
    inside Google Chrome, in the developer console, we can call `socket.emit` and
    we emit whatever we like.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，控制台的另一个很酷的功能是，我们可以访问应用程序创建的变量；最重要的是socket变量。这意味着在Google Chrome中，在开发者控制台中，我们可以调用`socket.emit`，并发出我们喜欢的任何内容。
- en: 'I can emit an action, `createEmail`, and I can pass in some data as the second
    argument, an object where I have a to attribute equal to `julie@example.com`.
    I have my other attributes too—something like `text`, which I can set equal to
    `Hey`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以发出一个动作，`createEmail`，并且我可以将一些数据作为第二个参数传递，一个对象，其中我有一个等于`julie@example.com`的to属性。我还有其他属性——类似于`text`，我可以将其设置为`Hey`：
- en: '[PRE71]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This is an example of how we can use the developer console to make debugging
    our app even easier. We can type a statement, hit *enter*, and it''s going to
    go ahead and emit the event:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，说明我们如何使用开发者控制台使调试应用程序变得更加容易。我们可以输入一个语句，按*enter*，它将继续发出事件：
- en: '![](img/8811a670-5871-4777-b76f-fe0776ab552b.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8811a670-5871-4777-b76f-fe0776ab552b.png)'
- en: 'Inside the Terminal, we''ll get that event and do something with it—whether
    it''s creating the email or doing anything else we might require. Inside the Terminal,
    you can see `createEmail` showed up. We''ll send that one to Julie, and then there''s
    the text, `Hey`. It all got to the server from the client:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们将得到该事件并对其进行处理——无论是创建电子邮件还是执行其他任何我们可能需要的操作。在终端中，您可以看到`createEmail`出现了。我们将把它发送给朱莉，然后有文本`Hey`。所有这些都从客户端到服务器了：
- en: '![](img/5d17b9f5-2766-4b66-a660-5dcb8c2720c0.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d17b9f5-2766-4b66-a660-5dcb8c2720c0.png)'
- en: 'Now that we have this in place and we''ve played around with how we can use
    these custom events, it''s time to move from the email application to the actual
    app we''re going to be building: *the chat app*.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了这一切，并且已经玩过了如何使用这些自定义事件，是时候从电子邮件应用程序转移到我们将要构建的实际应用程序了：*聊天应用*。
- en: The custom events in the chat app
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天应用中的自定义事件
- en: 'Now that you know how to emit and listen to custom events, we''re going to
    move on to creating two events that we''ll actually use in the chat app. These
    are going to be `newMessage` and `createMessage`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何触发和监听自定义事件，我们将继续创建两个在聊天应用中实际使用的事件。这些将是`newMessage`和`createMessage`：
- en: '![](img/659b8cff-cdef-4a5a-8117-0694c4a5378e.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/659b8cff-cdef-4a5a-8117-0694c4a5378e.png)'
- en: Now, for the chat app, we once again have our server, which is going to be the
    server we build; and we have our client, which is going to be a user who is in
    the chat app. There are most likely going to be multiple users who all want to
    communicate with each other.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于聊天应用程序，我们再次有我们的服务器，这将是我们构建的服务器；还有我们的客户端，这将是在聊天应用程序中的用户。很可能会有多个用户都想互相交流。
- en: 'Now, the first event we''ll have is a `newMessage` event. This is going to
    be emitted by the server and listened to on the client:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将要处理的第一个事件是`newMessage`事件。这将由服务器发出，并在客户端上进行监听：
- en: '![](img/1be19315-6b2b-4499-ba4d-3e3c0d181df5.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1be19315-6b2b-4499-ba4d-3e3c0d181df5.png)'
- en: When a new message comes in, the server will send it to everyone connected to
    the chat room, so they can display it to the screen and a user can go ahead and
    respond to it. The `newMessage` event is going to require some data. We're going
    to need to know who the message was from; a string of someone's name, such as
    `Andrew`, the text of the message, something like, `hey, can you meet up at six`,
    and a `createdAt` timestamp.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当有新消息进来时，服务器会将其发送给连接到聊天室的所有人，这样他们就可以在屏幕上显示出来，用户可以继续回复。`newMessage`事件将需要一些数据。我们需要知道消息是谁发出的；一个人名的字符串，比如`Andrew`，消息的文本，比如`嘿，你能六点见面吗`，还有一个`createdAt`时间戳。
- en: All of this data is going to get rendered inside our chat application in the
    browser. We'll be doing that for real in a little bit, but for now we'll just
    print it to the console. So, this is the first event I want you to create. You'll
    make this `newMessage` event, emit it from the server—for now, you can simply
    emit it when a user connects—and you'll listen to it on the client. For now, on
    the client, you can just print with `console.log` a little message when you get
    the data. You can say something like `got new message`, printing the object that
    was passed with this data.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据都将在我们的聊天应用程序中在浏览器中呈现。我们马上就要真正做到这一点，但现在我们只是将其打印到控制台。所以，这是我要你创建的第一个事件。你将创建这个`newMessage`事件，从服务器发出它——现在，当用户连接时，你可以简单地发出它——并在客户端上进行监听。现在，在客户端上，当你收到数据时，你可以用`console.log`打印一条消息。你可以说一些像`收到新消息`的话，打印传递的对象。
- en: 'Next up, the second event we''ll work with is `createMessage`. This will come
    from the client to the server. So if I''m user 1, I''ll fire a `createMessage`
    event from my browser. This will go to the server, and the server will fire `newMessage`
    events to everyone else so they can see my message, which means the `createMessage`
    event is going to get emitted from the client and the server is going to be the
    one who''s listening for the event:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要处理的第二个事件是`createMessage`。这将从客户端发送到服务器。所以如果我是用户1，我将从浏览器中触发一个`createMessage`事件。这将发送到服务器，服务器将向其他人发出`newMessage`事件，这样他们就可以看到我的消息，这意味着`createMessage`事件将从客户端发出，服务器将监听该事件：
- en: '![](img/82e574bd-553e-43e4-bfa1-020918b7a805.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82e574bd-553e-43e4-bfa1-020918b7a805.png)'
- en: 'Now, this event will require some data. We''ll need to know who the message
    was from and also the text: what did they want to say? We need both of these pieces
    of information.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个事件将需要一些数据。我们需要知道消息是谁发出的，还有文本：他们想说什么？我们需要这两个信息。
- en: 'Now, notice a discrepancy here: we''re sending the `from`, `text`, and `createdAt`
    properties to the client, but we''re not asking for a `createdAt` property from
    the client when they create a message. This `createdAt` property is actually going
    to get created on the server. This is going to prevent the user from being able
    to spoof the time a message was created at. There are certain properties we''re
    going to trust the user to provide us with; there''s others that we will not trust
    them to provide us with, and one of those is going to be `createdAt`.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意这里的一个不一致之处：我们将`from`、`text`和`createdAt`属性发送到客户端，但当他们创建消息时，我们并没有要求客户端提供`createdAt`属性。这个`createdAt`属性实际上将在服务器上创建。这将防止用户能够伪造消息创建的时间。有一些属性我们将信任用户提供给我们；还有一些我们将不信任他们提供给我们，其中之一将是`createdAt`。
- en: Now, for `createMessage`, all you have to do is set up an event listener on
    the server that waits for this to fire, and once again, you can simply print a
    message, for example, `create message`, and then you can provide the data that
    was passed along to `console.log`, printing it to the Terminal. Now, once you
    have that listener in place, you'll want to emit it. You can emit it when you
    user first connects, and you can also fire a couple of `socket.emit` calls from
    Chrome Developer Tools, making sure that all of the messages show up in the Terminal,
    listening for the `createMessage` event.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于`createMessage`，你所要做的就是在服务器上设置一个事件监听器，等待它触发，然后，你可以再次简单地打印一条消息，例如`创建消息`，然后你可以提供传递给`console.log`的数据，将其打印到终端上。现在，一旦你放置了监听器，你将想要发出它。你可以在用户首次连接时发出它，你还可以从Chrome开发者工具中发出一些`socket.emit`调用，确保所有的消息都显示在终端上，监听`createMessage`事件。
- en: 'We''re going to get started inside `server.js` by listening for that `createMessage`
    event, and this is going to happen down below the `socket.emit` function in `server.js`.
    Now, we have an old event listener from `createEmail`; we can remove that, and
    we can call `socket.on` to listen to our brand new event, `createMessage`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`server.js`开始，通过监听`createMessage`事件来进行处理，这将发生在`server.js`中`socket.emit`函数的下面。现在，我们有一个来自`createEmail`的旧事件监听器；我们可以删除它，并调用`socket.on`来监听我们全新的事件`createMessage`：
- en: '[PRE72]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `createMessage` event is going to require a function to call when the event
    actually happens. We''ll want to do something with the message data:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`createMessage`事件将需要一个在事件实际发生时调用的函数。我们将想要对消息数据进行一些处理：'
- en: '[PRE73]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'For the moment, all you need to do is use `console.log` to print it to the
    Terminal so we can verify that everything works as expected. We''ll get our message
    data, which will include a `from` property and a `text` property, and we''ll print
    it to the screen. You don''t have to specify the exact message I used; I''ll just
    say `createMessage`, and the second argument will be the data that was passed
    from the client to the server:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你只需要使用`console.log`将其打印到终端，以便我们可以验证一切是否按预期工作。我们将得到我们的消息数据，其中包括`from`属性和`text`属性，并将其打印到屏幕上。你不必指定我使用的确切消息；我只会说`createMessage`，第二个参数将是从客户端传递到服务器的数据：
- en: '[PRE74]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now that we have our listener in place, we can go ahead and emit this inside
    the client in `index.js`. Now, we currently have an emit call for the `createEmail`
    event. I''ll remove this `emit` call. We''ll call `socket.emit` first and then
    `emit(''createMessage'')`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了监听器，我们可以在`index.js`中的客户端发出这个事件。现在，我们目前有一个发出`createEmail`事件的调用。我将删除这个`emit`调用。我们将首先调用`socket.emit`，然后调用`emit('createMessage')`：
- en: '[PRE75]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Next, we'll emit `createMessage` with the necessary data.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用必要的数据发出`createMessage`。
- en: Remember when you're emitting a custom event that the first argument is the
    event name and the second is the data.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你发出自定义事件时，第一个参数是事件名称，第二个是数据。
- en: 'For the data, we''ll provide an object with two properties: `from`, this one''s
    from `Andrew`; and `text`, which is the actual text of the message, which could
    be something like `Yup, that works for me`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据，我们将提供一个带有两个属性的对象：`from`，这个是`Andrew`；和`text`，这是消息的实际文本，可能是`是的，对我来说没问题`：
- en: '[PRE76]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This is going to be the event we emit. I''m going to save `index.js`, head
    over to the browser, and we should be able to refresh the app and see the data
    in the Terminal:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们发出的事件。我将保存`index.js`，转到浏览器，我们应该能够刷新应用程序并在终端中看到数据：
- en: '![](img/98277517-b201-4820-bd7c-8b525aeb1b1b.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98277517-b201-4820-bd7c-8b525aeb1b1b.png)'
- en: As shown in the preceding screenshot, inside the Terminal we have `createMessage`
    with the `from` property that we specified, and the text, `Yup, that works for
    me`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，在终端中，我们有`createMessage`和我们指定的`from`属性，以及文本`是的，对我来说没问题`。
- en: 'Now, we can also emit events from Chrome Developer Tools to play around with
    Socket.io. We can add `socket.emit`, and we can emit any event we like, passing
    in some data:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还可以从Chrome开发者工具中发出事件，以便使用Socket.io进行调试。我们可以添加`socket.emit`，并且可以发出任何我们喜欢的事件，传入一些数据：
- en: '[PRE77]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The event we''ll emit is `createMessage`, and the data is a `from` attribute;
    this one''s from `Jen` and a text attribute, `Nope`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发出的事件是`createMessage`，数据是一个`from`属性；这个是`Jen`，和一个文本属性，`Nope`：
- en: '![](img/6c85e450-ed3d-42b2-bc66-a6e92e08d942.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c85e450-ed3d-42b2-bc66-a6e92e08d942.png)'
- en: 'When I send this off, the message shows up on the server in real time, and
    as shown in the following screenshot, you can see it''s from `Jen`, the text is
    `Nope`, and everything is working as expected:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当我发送这条消息时，消息会实时显示在服务器上，如下截图所示，你可以看到它来自`Jen`，文本是`Nope`，一切都按预期工作：
- en: '![](img/d2d5b142-317f-4c4b-9048-e17438974b18.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2d5b142-317f-4c4b-9048-e17438974b18.png)'
- en: Now, that's the first event; the other one is the `newMessage` event, which
    is going to be emitted by the server and listened to by the client.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是第一个事件；另一个是`newMessage`事件，将由服务器发出并由客户端监听。
- en: The newMessage event
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新消息事件
- en: 'To get started with this one, we''ll add our event listener inside `index.js`.
    We have the old event listener for `newEmail`. I''m going to go ahead and remove
    that, and we''ll call `socket.on` to listen to the new event, `newMessage`. The
    `newMessage` event is going to require a callback:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个，我们将在`index.js`中添加我们的事件监听器。我们有旧的`newEmail`事件监听器。我将继续删除它，然后我们将调用`socket.on`来监听新事件`newMessage`。`newMessage`事件将需要一个回调函数：
- en: '[PRE78]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For the moment, we''ll use `console.log` to print the message to the console,
    but later, we''ll be taking this message and adding it to the browser so a user
    can actually see it on the screen. Now, we are going to get the message data.
    I''ll create an argument called `message` for the moment, and we can go ahead
    and simply log it to the screen using `console.log`, printing the name of the
    event so it''s easy to track in the Terminal, and the actual data that was passed
    from server to client:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将使用`console.log`将消息打印到控制台，但稍后，我们将获取这条消息并将其添加到浏览器中，以便用户实际上可以在屏幕上看到它。现在，我们将获取消息数据。我将暂时创建一个名为`message`的参数，然后我们可以简单地使用`console.log`将其打印到屏幕上，打印事件的名称，以便在终端中易于跟踪，以及从服务器传递到客户端的实际数据：
- en: '[PRE79]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, the last thing we need to do is simply emit `newMessage` from the server,
    making sure it shows up in the client. Inside `server.js`, instead of emitting
    `newEmail`, we will call `socket.emit`, emitting our custom event, `newMessage`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们唯一需要做的是简单地从服务器发出`newMessage`，确保它显示在客户端。在`server.js`中，我们将调用`socket.emit`，发出我们的自定义事件`newMessage`，而不是发出`newEmail`：
- en: '[PRE80]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we will need some data—that message data. We''ll also provide that as
    the second argument. It''ll be an object with a `from` property. It could be from
    whoever you like; I''ll go with `John`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一些数据——那条消息的数据。我们也将作为第二个参数提供。它将是一个带有`from`属性的对象。它可以来自任何人；我会选择`John`：
- en: '[PRE81]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next up, we''ll provide the `text` property. This can be anything as well,
    such as `See you then`, and finally we''ll provide the `createdAt` property. This
    will be generated by the server later so a user can''t spoof the time a message
    was created at, but for now, we''ll just use some sort of random number, such
    as `123123`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提供`text`属性。这也可以是任何东西，比如`再见`，最后我们将提供`createdAt`属性。这将稍后由服务器生成，以便用户无法伪造消息创建的时间，但现在，我们将只使用某种随机数，比如`123123`：
- en: '[PRE82]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, as soon as a user connects to the server, we''ll be emitting that event.
    Inside the browser, I can go ahead and refresh things. We have our `newMessage`
    event showing up and the data is exactly as we specified it in our `server.js`
    file:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦用户连接到服务器，我们将发出该事件。在浏览器中，我可以继续刷新。我们的`newMessage`事件显示出来，数据与我们在`server.js`文件中指定的完全一样：
- en: '![](img/53484234-07b0-4d98-9fa2-f2bf1522d640.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53484234-07b0-4d98-9fa2-f2bf1522d640.png)'
- en: We have our `createdAt` timestamp, our `from` property, and our `text` property.
    In future, we'll be literally taking this data and rendering it into the browser
    so it shows up and someone can read it and respond to it, but for now we are done.
    We have our event listener on the server for `createMessage`, and our event listener
    on the client for `newMessage`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的`createdAt`时间戳，我们的`from`属性和我们的`text`属性。将来，我们将直接将这些数据渲染到浏览器中，以便显示出来，某人可以阅读并回复，但现在我们已经完成了。我们在服务器上为`createMessage`有了事件监听器，并在客户端为`newMessage`有了事件监听器。
- en: 'That is it for this section! Since we are done, we will be making a quick commit.
    I''ll shut down the server and run the `git status` command:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本节的全部内容！既然我们已经完成，我们将进行快速提交。我将关闭服务器并运行`git status`命令：
- en: '![](img/96400b89-9804-4600-935d-ff23fe25d419.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96400b89-9804-4600-935d-ff23fe25d419.png)'
- en: 'As shown in the preceding screenshot, we have quite a few changes here. We
    have our new `js` file in the `public.js` folder, and we''ve also changed `server.js`
    and `index.html`. I''ll run the `git add .` command to add all of that to the
    next commit, and then I''ll create a commit using `git commit` with the `-m` flag.
    A good message for this one is `Add newMessage and createMessage events`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们这里有很多变化。我们在`public.js`文件夹中有我们的新的`js`文件，我们还改变了`server.js`和`index.html`。我将运行`git
    add .`命令将所有内容添加到下一个提交中，然后我将使用`git commit`和`-m`标志创建一个提交。这个提交的一个好消息是`Add newMessage
    and createMessage events`：
- en: '[PRE83]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: With this in place, we can now push our code up to GitHub. There's no need to
    do anything with Heroku since we don't have anything visual just yet; we'll hold
    off on that until later.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以将我们的代码推送到GitHub上。目前不需要在Heroku上做任何事情，因为我们还没有任何可视化的东西；我们将推迟到以后再处理。
- en: In the next section, we're going to wire up messages, so when tab 1 emits a
    message, it's visible by tab 2\. This is going to bring us one step closer to
    actually communicating in real time between different browser tabs.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将连接消息，所以当标签页1发出消息时，标签页2可以看到。这将使我们更接近在不同的浏览器标签页之间实际实时通信。
- en: Broadcasting events
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播事件
- en: Now that we have our custom event listeners and emitters in place, it's time
    to actually wire up the message system so when one user sends a message to the
    server, it actually gets sent to every connected user. If I have two tabs open
    and I emit a `createMessage` event from one tab, I should see the message arrive
    in the second one.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了自定义事件监听器和发射器，是时候实际连接消息系统了，所以当一个用户向服务器发送消息时，它实际上会发送给每个连接的用户。如果我打开两个标签页并从一个标签页发出`createMessage`事件，我应该在第二个标签页中看到消息到达。
- en: To test things locally, we'll be using separate tabs, but the same would work
    on Heroku with separate browsers on separate networks; as long as everyone has
    the same URL on their browser, they will be connected, regardless of which machine
    they're on. Now, for localhost, we obviously don't have the right privilege, but
    as we deploy to Heroku, which we will be doing in this section, we'll be able
    to test this out between, say, your phone and the browser running on your machine.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 本地测试时，我们将使用单独的标签页，但在Heroku上使用单独的浏览器和单独的网络也可以实现相同的效果；只要每个人在浏览器上有相同的URL，他们就会连接在一起，无论他们在哪台机器上。现在，对于本地主机，我们显然没有正确的权限，但是当我们部署到Heroku时，我们将在本节中进行，我们将能够在您的手机和在您的机器上运行的浏览器之间进行测试。
- en: Wiring up the createMessage listener for all users
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为所有用户连接创建`createMessage`监听器
- en: 'To get started, we''ll update the `createMessage` listener. Currently, all
    we do is log the data to the screen. But here, instead of just logging it, we
    actually want to emit a new event, a `newMessage` event, to everybody, so each
    connected user gets the message that was sent from a specific user. In order to
    get that done, we''ll call a method on `io`, which will be `io.emit`:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更新`createMessage`监听器。目前，我们只是将数据记录到屏幕上。但是在这里，我们不仅要记录它，我们实际上要发出一个新事件，一个`newMessage`事件，给每个人，这样每个连接的用户都会收到从特定用户发送的消息。为了完成这个目标，我们将在`io`上调用一个方法，即`io.emit`：
- en: '[PRE84]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`Socket.emit` emits an event to a single connection, whereas `io.emit` emits
    an event to every single connection. Here, we are going to emit the `newMessage`
    event, specifying it as our first argument. The second argument, as with `socket.emit`,
    is the data you want to send:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`Socket.emit`向单个连接发出事件，而`io.emit`向每个连接发出事件。在这里，我们将发出`newMessage`事件，将其指定为我们的第一个参数。与`socket.emit`一样，第二个参数是要发送的数据：'
- en: '[PRE85]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, we know we''ll get a `from` property and a `text` property from the client—those
    appear in `socket.emit` for the `createMessage` event in `index.js`—which means
    what we need to do is pass those along, setting `from` equal to `message.from`,
    and setting `text` equal to `message.text`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道我们将从客户端得到`from`属性和`text`属性——这些出现在`index.js`中`createMessage`事件的`socket.emit`中——这意味着我们需要做的是传递这些属性，将`from`设置为`message.from`，将`text`设置为`message.text`：
- en: '[PRE86]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, along with `from` and `text`, we''ll also specify a `createdAt` property,
    which will be generated by the server to prevent a specific client from spoofing
    the time a message was created. The `createdAt` property is set equal to `new
    Date`, and we''ll call the `getTime` method to get that timestamp back, which
    we''ve done before:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除了`from`和`text`，我们还将指定一个`createdAt`属性，这将由服务器生成，以防止特定客户端伪造消息创建的时间。`createdAt`属性设置为`new
    Date`，我们将调用`getTime`方法来获取时间戳，这是我们以前做过的：
- en: '[PRE87]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Now that we have this in place, we actually have messaging wired up. We can
    go ahead and remove our emit calls—the `newMessage` emit call and the `createMessage`
    emit call—from `server.js` and `index.js`, respectively, making sure to save both
    files. With this in place, we can go ahead and test this by opening up two connections
    to the server and emitting some events.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这一步，我们实际上已经连接了消息。我们可以继续删除`server.js`和`index.js`中的发出调用——`server.js`和`index.js`中的`newMessage`发出调用和`createMessage`发出调用，确保保存两个文件。有了这个，我们可以继续测试，打开两个连接到服务器并发出一些事件。
- en: Testing the messaging events
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试消息事件
- en: 'I''m going to start up the server inside the Terminal using the `nodemon server/server.js`
    command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`nodemon server/server.js`命令在终端中启动服务器：
- en: '![](img/2f0192c1-36b7-4667-b655-74be87037ef3.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f0192c1-36b7-4667-b655-74be87037ef3.png)'
- en: 'Inside the browser, we can now open up two tabs, both at `localhost:3000`.
    For both tabs, I am going to open up Developer tools, since that''s currently
    the graphic user interface for our application. We don''t have any forms just
    yet, which means we need to use the Console tab to run some statements. We''ll
    do the same thing for a second tab:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们现在可以打开两个标签页，都在`localhost:3000`。对于两个标签页，我将打开开发者工具，因为那是我们应用程序的图形用户界面。我们目前还没有任何表单，这意味着我们需要使用Console标签来运行一些语句。我们将对第二个标签页做同样的事情：
- en: '![](img/2b76c60f-3aaa-465c-8791-6ed308ea1629.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b76c60f-3aaa-465c-8791-6ed308ea1629.png)'
- en: 'Notice that as soon as we open the tabs, we''ll get `New user connected` messages
    in the Terminal:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦我们打开标签页，我们将在终端中收到`New user connected`的消息：
- en: '![](img/d3134c5a-c8dd-4d7f-8a1f-24f27e9561da.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3134c5a-c8dd-4d7f-8a1f-24f27e9561da.png)'
- en: 'Now that we have our two tabs open, we can go ahead and emit a `createMessage`
    event from either one. I''ll emit it from the second tab by calling `socket.emit`,
    emitting a custom event. The event name is `createMessage`, and it takes those
    two properties we just discussed—the `from` property and the `text` property—both
    of which I''ll specify in the `socket.emit` object. The `from` property will be
    set equal to the first name, `Andrew`, and the `text` property will get set equal
    to `''This should work''`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个标签页打开了，我们可以继续从任何一个标签页发出`createMessage`事件。我将从第二个标签页发出，通过调用`socket.emit`来发出一个自定义事件。事件名称是`createMessage`，它接受我们刚刚讨论过的这两个属性——`from`属性和`text`属性——我都会在`socket.emit`对象中指定。`from`属性将设置为第一个名字`Andrew`，`text`属性将设置为`'This
    should work'`：
- en: '[PRE88]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'With this in place, we can now emit my event from the browser. It will go to
    the server, which will send the message to every connected user, including the
    currently connected user who sent the message. We''re going to hit *enter*, it
    fires it off, and we see that we get `newMessage`. We have the message we just
    created, but the cool thing is that over in the other tab, we also have the message:
    a message from one user has reached another user in a separate tab:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以从浏览器中发出我的事件。它将发送到服务器，服务器将把消息发送给每个连接的用户，包括当前连接的用户发送的消息。我们将按下*enter*，它就会触发，我们会看到我们收到了`newMessage`。我们有刚刚创建的消息，但很酷的是，在另一个标签页中，我们也有这条消息：一个用户的消息已经传达到另一个标签页的用户那里：
- en: '![](img/3c1a7d6e-35a8-4369-8009-094e6d4a6f74.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c1a7d6e-35a8-4369-8009-094e6d4a6f74.png)'
- en: 'With this in place, we now have a very basic messaging system set up: a user
    emits an event, it goes to the server, and the server sends it to everyone else
    who is connected. With this in place, I''d like to make a commit and deploy to
    Heroku so we can test it out.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有了一个非常基本的消息系统：用户发出一个事件，它传递到服务器，服务器将其发送给所有其他连接的用户。有了这个，我想进行提交并部署到Heroku，这样我们就可以测试一下。
- en: Committing and deploying messaging to Heroku
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交并将消息部署到Heroku
- en: 'If I run the `git status` command in the Terminal, I see I have my two changed
    files as expected:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在终端中运行`git status`命令，我会看到我有两个预期的更改文件：
- en: '![](img/b4f5767e-22b4-4d24-8774-ffb6a27bb40c.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4f5767e-22b4-4d24-8774-ffb6a27bb40c.png)'
- en: 'I can then run the `git commit` command with the `-am` flag to specify a message
    for this commit—something like `Emit newMessage on createMessage` will get the
    job done:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以使用`git commit`命令和`-am`标志来指定此提交的消息，比如`Emit newMessage on createMessage`就可以完成任务：
- en: '[PRE89]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: I can then go ahead and actually make the commit, pushing it up to both GitHub
    and Heroku. The `git push` command is going to get it on GitHub.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以继续实际进行提交，将其推送到GitHub和Heroku。`git push`命令将把它推送到GitHub上。
- en: The `git push heroku master` command is going to deploy it live to the web.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`git push heroku master`命令将把它部署到网络上。 '
- en: 'We''ll be able to open up our chat application and make sure it works regardless
    of the browser, computer, or any other variable:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够打开我们的聊天应用程序，并确保它在任何浏览器、计算机或其他变量下都能正常工作：
- en: '![](img/46fcc142-6d27-444c-b117-fc868a0a2157.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46fcc142-6d27-444c-b117-fc868a0a2157.png)'
- en: 'As shown in the preceding screenshot, we are compressing and launching the
    app. It looks like everything is done. I''ll use the `heroku open` command to
    open it up. This will open it up in my default browser, and as shown in the following
    screenshot, you''ll see that we have `Welcome to the chat app`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们正在压缩并启动应用程序。看起来一切都完成了。我将使用`heroku open`命令打开它。这将在我的默认浏览器中打开它，如下面的截图所示，您将看到我们有`Welcome
    to the chat app`：
- en: '![](img/59853981-8d91-4aef-a24a-713307e74816.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59853981-8d91-4aef-a24a-713307e74816.png)'
- en: Testing messaging in a Firefox browser using Heroku
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Firefox浏览器中使用Heroku测试消息传递
- en: 'Now, to demonstrate this, what I''ll open up a separate browser. I''ll open
    up Firefox and type in the exact same URL. Then, I''ll copy this URL and grab
    the Firefox browser, making it smaller so we can quickly switch between the two,
    opening up the Heroku app here:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了演示这一点，我将打开一个单独的浏览器。我将打开Firefox并输入完全相同的URL。然后，我将复制这个URL并打开Firefox浏览器，使其变小，这样我们可以快速在两者之间切换，打开Heroku应用程序：
- en: '![](img/5473cdad-dee3-4f40-aaed-23b924882cff.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5473cdad-dee3-4f40-aaed-23b924882cff.png)'
- en: 'Now, Firefox also has Developer Tools available via the menu in the top-right
    corner. There, we have a Web Developer section; we''re looking for Web Console:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Firefox也可以通过右上角的菜单访问开发者工具。在那里，我们有一个Web Developer部分；我们要找的是Web Console：
- en: '![](img/cec09cd5-77a7-400b-b0af-405d042bb09f.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cec09cd5-77a7-400b-b0af-405d042bb09f.png)'
- en: 'Now that we have this open, we can go into Developer tools for our Chrome tab
    connected to the Heroku application, and what we''ll do is emit an event using
    `socket.emit`. We''ll emit a `createMessage` event. We''ll specify our custom
    properties inside of the object, then we can go ahead and have `from` set to `Mike`,
    and we can set the `text` property equal to `Heroku`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打开了这个，我们可以进入我们连接到Heroku应用程序的Chrome标签的开发者工具，我们将使用`socket.emit`发出一个事件。我们将发出一个`createMessage`事件。我们将在对象内指定我们的自定义属性，然后我们可以继续设置`from`为`Mike`，并且我们可以将`text`属性设置为`Heroku`：
- en: '[PRE90]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, when I go ahead and emit this event, everything should work as expected.
    We''re calling `socket.emit` and emitting `createMessage`. We have our data, which
    means it will go to the Heroku server, which will send it over to Firefox. We''ll
    send this off, which should mean we get `newMessage` in Chrome Developer tools.
    Then, inside Firefox, we also have the message. It''s from `Mike`, the text is
    `Heroku`, and we have the `createdAt` timestamp added by our server:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我继续发出这个事件时，一切应该如预期般工作。我们调用`socket.emit`并发出`createMessage`。我们有我们的数据，这意味着它将发送到Heroku服务器，然后发送到Firefox。我们将发送这个，这应该意味着我们在Chrome开发者工具中得到`newMessage`。然后，在Firefox中，我们也有这条消息。它是来自`Mike`，文本是`Heroku`，并且我们的服务器添加了`createdAt`时间戳：
- en: '![](img/e0df6017-f242-4a88-96c9-8e31161dd1be.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0df6017-f242-4a88-96c9-8e31161dd1be.png)'
- en: With this in place, we have a messaging system—not only working locally, but
    also on Heroku—which means anybody in the world can visit this URL; they can emit
    the event, and everyone else connected is going to see that event in the console.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们有了一个消息系统——不仅在本地工作，而且在Heroku上也可以工作，这意味着世界上的任何人都可以访问这个URL；他们可以发出事件，而所有其他连接的人都将在控制台中看到该事件。
- en: Now that we've tested it out across browsers, I will close Firefox, and we'll
    move on to the second part of this section.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在各个浏览器中测试过了，我将关闭Firefox，然后我们将继续进行本节的第二部分。
- en: Broadcasting events to other users
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向其他用户广播事件
- en: 'In this part of the section, we''ll talk about a different way to emit events.
    Some events you want to send to everybody: a new message should go to every single
    user, including the one who sent it so it can show up inside the list of messages.
    Other events, on the other hand, should only go to other people, so if user one
    emits an event, it shouldn''t go back to user one, but instead go only to users
    two and three.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的这一部分，我们将讨论一种不同的发出事件的方法。有些事件你希望发送给每个人：新消息应该发送给每个用户，包括发送者，这样它才能显示在消息列表中。另一方面，其他事件应该只发送给其他人，所以如果用户一发出一个事件，它不应该返回给用户一，而应该只发送给用户二和用户三。
- en: A good example of this is when a user joins a chatroom. I want to print a little
    message, like `Andrew joined`, when someone joins, and I want to print a message,
    like `welcome Andrew`, for the actual user who joined. So, in the first tab I
    would see `welcome Andrew`, and in the second tab I would see `Andrew joined`.
    In order to get that done, we'll look at a different way to emit events in the
    server. This will be done via broadcasting. Broadcasting is the term for emitting
    an event to all but one specific user.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是当用户加入聊天室时。当有人加入时，我想打印一条小消息，比如`Andrew joined`，当实际加入的用户加入时，我想打印一条消息，比如`welcome
    Andrew`。所以，在第一个标签中，我会看到`welcome Andrew`，在第二个标签中，我会看到`Andrew joined`。为了完成这个目标，我们将看一种在服务器上发出事件的不同方法。这将通过广播来完成。广播是向除了一个特定用户之外的所有人发出事件的术语。
- en: 'I''ll start up the server once again using the `nodemon server/server.js` command,
    and inside Atom, we can now tweak how we emit the event in the `io.emit` method
    in `server.js`. Now, this is going to be the final way we do things, but we''ll
    play around with broadcasting as well, which means I''ll comment this out as opposed
    to removing it:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我将再次使用`nodemon server/server.js`命令启动服务器，并且在Atom中，我们现在可以调整我们在`server.js`中的`io.emit`方法中发出事件的方式。现在，这将是我们做事情的最终方式，但我们也会玩一下广播，这意味着我会将其注释掉，而不是删除它：
- en: '[PRE91]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To broadcast, we have to specify the individual socket. This lets the Socket.io
    library know which users shouldn''t get the event. In this case, the user that
    we call here is not going to get the event, but everyone else will. Now, we need
    to call `socket.broadcast`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行广播，我们必须指定单个套接字。这让Socket.io库知道哪些用户不应该收到事件。在这种情况下，我们在这里调用的用户将不会收到事件，但其他人会。现在，我们需要调用`socket.broadcast`：
- en: '[PRE92]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Broadcast is an object that has its own emit function, and it's the exact same
    syntax as `io.emit` or `socket.emit`. The big difference is who it gets sent to.
    This will send the event to everybody but the mentioned socket, which means if
    I fire a `createMessage` event, the `newMessage` event will fire to everybody
    but myself, and that's exactly what we can do here.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 广播是一个具有自己发射功能的对象，它的语法与`io.emit`或`socket.emit`完全相同。最大的区别在于它发送给谁。这将把事件发送给除了提到的套接字之外的所有人，这意味着如果我触发一个`createMessage`事件，`newMessage`事件将发送给除了我自己之外的所有人，这正是我们在这里可以做的。
- en: 'It''s going to be identical, which means we can go ahead and pass in the message
    event name. The arguments will be identical: the first one will be `newMessage`,
    and the other one will be the object with our properties, `from: message.from` and `text:
    message.text`. Last up,we have `createdAt` equal to a new timestamp, `new Date().getTime`:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '它将是相同的，这意味着我们可以继续传递消息事件名称。参数将是相同的：第一个将是`newMessage`，另一个将是具有我们属性的对象，`from: message.from`和`text:
    message.text`。最后，我们有`createdAt`等于一个新的时间戳，`new Date().getTime`：'
- en: '[PRE93]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'With this in place, we will not see the messages we send, but everybody else
    will. We can prove this by heading over to Google Chrome. I''ll give both tabs
    a refresh, and from the second tab, once again, we will emit an event. We can
    actually use the up arrow key inside the web developer console to rerun one of
    our previous commands, and that''s exactly what we''ll do:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们将看不到我们发送的消息，但其他人会看到。我们可以通过转到Google Chrome来证明这一点。我会给两个标签都刷新一下，然后从第二个标签再次发出一个事件。我们实际上可以在Web开发者控制台中使用上箭头键重新运行我们之前的命令，这正是我们要做的：
- en: '[PRE94]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Here, we''re emitting a `createMessage` event with a `from` property set to
    `Andrew` and a `text` property equal to `This should work`. If I hit *enter* to
    send this off, you''ll notice that this tab no longer receives the message:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在发出一个`createMessage`事件，其中`from`属性设置为`Andrew`，`text`属性等于`This should work`。如果我按*enter*发送这条消息，你会注意到这个标签不再接收消息：
- en: '![](img/a2355f90-e4e6-4efa-b16b-9d7b1c43e29a.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2355f90-e4e6-4efa-b16b-9d7b1c43e29a.png)'
- en: 'However, if I go to `localhost:3000`, we will get `newMessage` showing up with
    the message data:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我去`localhost:3000`，我们将看到`newMessage`显示出消息数据：
- en: '![](img/1ed3ea24-b881-4894-8ca8-9642376e2aff.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ed3ea24-b881-4894-8ca8-9642376e2aff.png)'
- en: This is because tab two broadcasts the event, which means it was only received
    by other connections, such as tab one or any other connected user.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为标签二广播了事件，这意味着它只被其他连接接收，比如标签一或任何其他连接的用户。
- en: Emitting two events when a user connects
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当用户连接时发出两个事件
- en: 'With broadcasting in place, let''s get into the final way we emit messages.
    We''ll emit two events in `socket.io`, right when a user connects. Now, we''ll
    not actually use broadcasting in this context, so we''ll comment the broadcast
    object out and uncomment our old code. It should look like this:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 有了广播，让我们进入最后一种发出消息的方式。我们将在`socket.io`中发出两个事件，就在用户连接时。现在，在这种情况下，我们实际上不会使用广播，所以我们将注释掉广播对象，并取消注释我们的旧代码。它应该看起来像这样：
- en: '[PRE95]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: You'll first call `socket.emit` to emit a message to the user who joins. Your
    message should come from the admin, `from Admin`, and the text should say something
    like `Welcome to the chat app`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先调用`socket.emit`来向加入的用户发出消息。你的消息应该来自管理员，`from Admin`，文本应该说一些像`Welcome to
    the chat app`的东西。
- en: 'Now, along with `socket.emit`, you''ll also call `socket.broadcast.emit`, which
    will get sent to everybody but the user who joined, which means you can go ahead
    and set `from` equal to `Admin` once again, and you can set `text` equal to `New
    user joined`:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除了`socket.emit`，你还将调用`socket.broadcast.emit`，这将被发送给除了加入的用户之外的所有人，这意味着你可以继续将`from`设置为`Admin`，并将`text`设置为`New
    user joined`：
- en: '[PRE96]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This means that when we join a chatroom, we'll see a message greeting us, and
    everyone else is going to see a message letting them know that someone else has
    joined. Both of these events are going to be `newMessage` events. We'll have to
    specify `from` (which is `Admin`), the `text` (which is whatever we said it should
    be), and `createdAt`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们加入聊天室时，我们会看到一条问候我们的消息，其他人会看到一条消息，告诉他们有人加入了。这两个事件都将是`newMessage`事件。我们将不得不指定`from`（即`Admin`），`text`（即我们说的任何内容）和`createdAt`。
- en: Greeting an individual user
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向个人用户问候
- en: 'To kick things off, we''ll fill out the first call. This is a call to `socket.emit`,
    and this call will be responsible for greeting the individual users:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将填写第一个调用。这是对`socket.emit`的调用，这个调用将负责问候个别用户：
- en: '[PRE97]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We will still send an event of `newMessage` type and the exact same data from
    `text` and `createdAt`. The only difference here is that we''ll be generating
    all the properties as opposed to getting some of them from the user as we did
    earlier. Let''s get started with `from`. This one will be from `Admin`. Any time
    we send a message via the server, we''ll call `Admin` and the text will be our
    little message, `Welcome to the chat app`. Next, we''ll add `createdAt`, which
    will be set equal to `new Date` by calling the `Date().getTime` method:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然会发送一个`newMessage`类型的事件，以及来自`text`和`createdAt`的完全相同的数据。这里唯一的区别是，我们将生成所有属性，而不是像之前那样从用户那里获取其中一些。让我们从`from`开始。这个将来自`Admin`。每当我们通过服务器发送消息时，我们将调用`Admin`，文本将是我们的小消息，`Welcome
    to the chat app`。接下来，我们将添加`createdAt`，它将被设置为通过调用`Date().getTime`方法的`new Date`：
- en: '[PRE98]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Later on, we'll greet them by name. We don't have that information for the moment,
    so we'll stick with a generic greeting. With this call in place, we can remove
    the comment and we can move on to the second one. This is the broadcast call that's
    going to alert every other user, except for the one who joined, that someone new
    is here.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将以姓名问候他们。目前我们没有这些信息，所以我们将坚持使用通用的问候语。有了这个调用，我们可以删除注释，然后继续进行第二个调用。这是广播调用，将提醒除了加入的用户之外的所有其他用户，有新人来了。
- en: Broadcasting a new user in the chat
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在聊天中广播新用户
- en: 'To broadcast a new user in the chat, we''ll use `socket.broadcast.emit` and
    we''ll emit a `newMessage` event, providing our props. The `from` property, once
    again, will be set equal to the `Admin` string; `text` is going to be set equal
    to our little message, `New user joined`; and last up is `createdAt`, which is
    going to be set equal to `new Date` by calling the `Date().getTime` method:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在聊天中广播新用户，我们将使用`socket.broadcast.emit`，并发出一个`newMessage`事件，提供我们的属性。`from`属性再次将被设置为`Admin`字符串；`text`将被设置为我们的小消息，`New
    user joined`；最后是`createdAt`，它将通过调用`Date().getTime`方法设置为`new Date`：
- en: '[PRE99]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Now we can remove our comment for the second call and everything should work
    as expected. The next thing you need to do is test out that all of this is working
    as expected by heading into the browser. There's a couple ways you could have
    done it; as long as you got it done, it doesn't really matter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以删除第二个调用的注释，一切应该如预期的那样工作。你需要做的下一件事是测试所有这些是否按预期工作，进入浏览器。你可以有几种方法来做到这一点；只要你做到了，实际上并不重要。
- en: Testing the user connection
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用户连接
- en: 'I''ll close both of my old tabs and open up Developer tools before ever visiting
    the page. Then, we can go to `localhost:3000` and we should see a little message
    in Developer tools:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我将关闭我的两个旧标签，并在访问页面之前打开开发者工具。然后，我们可以去`localhost:3000`，我们应该在开发者工具中看到一条小消息：
- en: '![](img/edd24c86-928c-46a7-bbef-28fb3bca952d.png)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edd24c86-928c-46a7-bbef-28fb3bca952d.png)'
- en: Here we see a new message, `Welcome to the chat app`, printing, which is fantastic!
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了一条新消息，`Welcome to the chat app`，打印出来，这太棒了！
- en: 'Next up, we want to test that the broadcast is working as expected. For the
    second tab, I''ll also open up Developer tools and go to `localhost:3000` once
    again. Once again, we get our little message, `Welcome to the chat app`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要测试广播是否按预期工作。对于第二个标签，我还会打开开发者工具并再次转到`localhost:3000`。再次，我们收到了我们的小消息，“欢迎来到聊天应用”：
- en: '![](img/981514a6-2843-4033-bd4d-5af4c8a316b8.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![](img/981514a6-2843-4033-bd4d-5af4c8a316b8.png)'
- en: If we go to the first tab, we also see that a new user joined, and this is fantastic
    too!
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转到第一个标签，我们还会看到有新用户加入，这也太棒了！
- en: 'Now, I will make a commit to save these changes. Let''s go ahead and shut down
    the server and use `git status` command:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将提交以保存这些更改。让我们关闭服务器并使用`git status`命令：
- en: '![](img/351f2f54-3ca8-43fb-8482-c79c6892da6a.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](img/351f2f54-3ca8-43fb-8482-c79c6892da6a.png)'
- en: 'Then, we can go ahead and run the `git commit` command with the `-am` flag
    and specify a message, `Greet new user and alert others`:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以继续运行带有`-am`标志的`git commit`命令，并指定消息，“向新用户打招呼并提醒其他人”：
- en: '[PRE100]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Once the commit is in place, we can use the `git push` command to push it up
    to GitHub.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提交就位，我们可以使用`git push`命令将其推送到GitHub。
- en: There's no need to deploy to Heroku right now, although you could easily deploy
    and test if you feel so inclined. With this in place, we are now done!
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 现在没有必要立即部署到Heroku，尽管如果你感兴趣，你可以轻松部署和测试。有了这个，我们现在完成了！
- en: Summary
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked into Socket.io and WebSockets to enable two-way communication
    between the server and client. We worked on setting up a basic Express server,
    a backend and a frontend, and we committed it up on GitHub and on Heroku. Next,
    we looked into adding `socket.io` to the app to set up communication between the
    server and client.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了Socket.io和WebSockets，以实现服务器和客户端之间的双向通信。我们致力于设置一个基本的Express服务器、后端和前端，并将其提交到GitHub和Heroku。接下来，我们研究了如何向应用程序添加`socket.io`以建立服务器和客户端之间的通信。
- en: Then, we looked into emitting and listening to custom events inside our application.
    Lastly, we wired up the message system by broadcasting the events such that when
    one user sends a message to the server, it actually gets sent to every connected
    user excluding the user who sends the message.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了在应用程序内发出和监听自定义事件。最后，我们通过广播事件来连接消息系统，这样当一个用户向服务器发送消息时，实际上会发送给每个连接的用户，但不包括发送消息的用户。
- en: With all this in place, we now have a rudimentary—but working—messaging system,
    which is a great place to start! We're going to continue on in the next chapter
    by adding more features and building out the UI.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，我们现在有了一个基本但有效的消息系统，这是一个很好的开始！在下一章中，我们将继续添加更多功能并构建用户界面。
