- en: '*Chapter 5*: React Development with Hooks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：使用Hooks进行React开发'
- en: In this chapter, we'll learn about development with React Hooks. We'll compare
    and contrast Hook development with the older class-based style and see why development
    with Hooks is a better way of developing in React. We'll also learn about best
    practices when coding with Hooks so that we can have the best quality code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习使用React Hooks进行开发。我们将比较和对比使用旧的基于类的样式和使用Hooks进行开发的方式，看看为什么使用Hooks进行开发是React中更好的开发方式。我们还将学习在使用Hooks编码时的最佳实践，以便我们可以拥有最高质量的代码。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the limitations of class-style components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解类式组件的限制
- en: Learning about React Hooks and understanding the benefits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习React Hooks并了解其好处
- en: Comparing and contrasting the class-style and the Hooks style
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较和对比类式和Hooks式样
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You should have a basic understanding of web development and the SPA style of
    coding. We will once again be using Node and Visual Studio Code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对Web开发和SPA编码风格有基本的了解。我们将再次使用Node和Visual Studio Code。
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap5` folder.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库位于[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node)。使用`Chap5`文件夹中的代码。
- en: To set up the [*Chapter 5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081)
    code folder, go to your `HandsOnTypescript` folder and create a new folder called
    `Chap5`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 设置[*第5章*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081)的代码文件夹，转到您的`HandsOnTypescript`文件夹并创建一个名为`Chap5`的新文件夹。
- en: Understanding the limitations and issues with the old class-style components
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解旧类式组件的限制和问题
- en: In this section, we'll review what class-style components are. We'll see why
    inheritance-style code reuse and lifecycle methods, although well intentioned,
    ultimately did not provide good code reuse and component structure capabilities.
    Although we will not write our code with class components, it is very important
    to understand class-based components because most existing React code uses classes,
    since Hooks are still somewhat new. So, as a professional developer, you will
    have to read and maintain this code base until it uses Hooks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾什么是类式组件。我们将看到为什么继承式代码重用和生命周期方法，尽管初衷良好，最终并没有提供良好的代码重用和组件结构能力。尽管我们不会用类组件编写代码，但了解基于类的组件非常重要，因为大多数现有的React代码使用类，因为Hooks仍然有些新。因此，作为专业开发人员，您将不得不阅读和维护这些代码库，直到它使用Hooks为止。
- en: In order to understand the limitations of class-style components, we first need
    to review what they are. A React application is made up of many individual structures
    called components. When using a class-based style, these components are JavaScript
    ES6 classes that inherit from `React.Component`. A component is basically a machine
    that may contain data, called state, and the component will emit HTML via a language
    called JSX based upon changes to this data. Although components can become quite
    complex, at a basic level this is what they are.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解类式组件的限制，我们首先需要回顾一下它们是什么。一个React应用程序由许多称为组件的个体结构组成。在使用基于类的样式时，这些组件是继承自`React.Component`的JavaScript
    ES6类。组件基本上是一个可能包含数据（称为状态）的机器，并且根据这些数据的更改通过一种称为JSX的语言发出HTML。尽管组件可能变得非常复杂，但在基本层面上，这就是它们。
- en: A class component usually has state of its own, although this is not a requirement.
    In addition, a class-based component can have child components. Child components
    are simply other React components that have been embedded into the render function
    of a parent component and therefore will be rendered out when the parent is rendered.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件通常有自己的状态，尽管这不是必需的。此外，基于类的组件可以有子组件。子组件只是其他React组件，已嵌入到父组件的渲染函数中，因此在渲染父组件时也会被渲染出来。
- en: A class component must inherit from the `React.Component` object. By doing this,
    it receives all the capabilities of a React component, including the lifecycle
    functions. These functions are event handlers that React provides that allow developers
    to hook into events that occur at specific times during the lifetime of a React
    component. In other words, these functions allow us as developers to inject our
    own code and logic into a React component at the desired time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件必须继承自`React.Component`对象。通过这样做，它将获得作为React组件的所有功能，包括生命周期函数。这些函数是React提供的事件处理程序，允许开发人员在React组件的生命周期中特定时间发生的事件中进行挂钩。换句话说，这些函数允许我们作为开发人员在所需的时间注入我们自己的代码和逻辑到React组件中。
- en: State
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: We touched upon state in [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072)*,
    Learning Single-Page Application Concepts and How React Enables Them*. Let's dive
    a little deeper before we learn more about React components. React uses JSX to
    render HTML to the browser. However, the thing that triggers these renders is
    component state or, more accurately, any change to component state. So, what is
    component state? In a React class component, there is a single field called `state`.
    This field is an object that can contain any number of properties that describe
    the associated component. Functions should not be applied to state, but you can
    have as many functions as you require as members of your class component.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072)*中提到了状态，学习单页应用程序概念以及React如何实现它们*。在我们学习更多关于React组件之前，让我们深入了解一下。React使用JSX将HTML呈现到浏览器。然而，触发这些呈现的是组件状态，或者更准确地说，是对组件状态的任何更改。那么，什么是组件状态？在React类组件中，有一个名为`state`的字段。这个字段是一个对象，可以包含描述相关组件的任意数量的属性。函数不应用于状态，但您可以将任意数量的函数作为类组件的成员。
- en: As mentioned, changing state causes the React system to re-render your component.
    State changes are what drive renders in React and components contain only the
    UI elements for themselves, which is a good way of maintaining a separation of
    concerns and clean coding practices. State changes in class-based components are
    triggered by the `setState` function. This function takes a parameter that is
    your new state and React will later asynchronously update your state. This means
    the actual state change does not happen immediately but is controlled by the React
    system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，改变状态会导致React系统重新渲染您的组件。状态变化驱动了React中的渲染，组件只包含自己的UI元素，这是保持关注点分离和清晰编码实践的好方法。基于类的组件中的状态变化是由`setState`函数触发的。这个函数接受一个参数，即您的新状态，React稍后会异步更新您的状态。这意味着实际的状态更改不会立即发生，而是由React系统控制。
- en: In addition to state there is the ability to share the state of a component
    using props. Props are state properties that have been passed down to child components
    of a component. Just like when state changes, if props change, a re-render on
    the child is also triggered. A re-render of a parent will also trigger a re-render
    to a child. Note that a re-render does not mean the entire UI is updated. The
    reconciliation process will still run and will only change what is needed based
    upon what state has changed and what is already on the screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了状态之外，还可以使用props共享组件的状态。Props是已传递给组件的子组件的状态属性。就像当状态改变时，如果props改变，子组件也会触发重新渲染。父组件的重新渲染也会触发子组件的重新渲染。请注意，重新渲染并不意味着整个UI都会更新。协调过程仍将运行，并且将根据状态的变化和屏幕上已有的内容来确定需要更改什么。
- en: Lifecycle methods
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期方法
- en: 'The following image is a good overview of the lifecycle calls in a class-based
    React component. As you can see, it''s quite complicated. In addition, there are
    also several deprecated functions that are not mentioned in the diagram, such
    as `componentWillReceiveProps`, which have been completely eliminated as they
    were causing issues such as unwanted renders and infinite loops:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图片很好地概述了基于类的React组件中的生命周期调用。正如您所看到的，它非常复杂。此外，图表中还没有提到几个已弃用的函数，比如`componentWillReceiveProps`，它们已经完全被淘汰，因为它们会导致不必要的渲染和无限循环：
- en: '![Figure 5.1 – React class component lifecycle'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – React类组件生命周期'
- en: '](img/Figure_5.1_B15508.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B15508.jpg)'
- en: Figure 5.1 – React class component lifecycle
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – React类组件生命周期
- en: 'Image source: [http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)
- en: Let's review this diagram starting at a high level. First off, you can see we
    have **Mounting**, **Updating**, and **Unmounting**. Mounting is simply the instantiation
    and initialization of a component, and then the addition of the initialized component
    into the virtual React DOM. We discussed the virtual DOM that React uses to reconcile
    components between itself and the real browser DOM in [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072)*,
    Learning Single-Page Application Concepts and How React Enables Them*. Updating
    refers to re-renders. That is when state changes and the UI must be updated. Unmounting
    is when a component is no longer used and is to be removed from the DOM.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从高层次开始审查这个图表。首先，您可以看到我们有**装载**、**更新**和**卸载**。装载只是组件的实例化和初始化，然后将初始化的组件添加到虚拟React
    DOM中。我们在[*第4章*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072)*，学习单页应用程序概念以及React如何实现它们*中讨论了React使用的虚拟DOM来在自身和真实浏览器DOM之间协调组件。更新指的是重新渲染。当状态改变时，UI必须更新。卸载是指组件不再使用并且将从DOM中移除。
- en: Now we'll go over the lifecycle methods. Since there are many, let's list them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍生命周期方法。由于有很多方法，让我们列出它们。
- en: Mounting
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装载
- en: 'Under mounting, we have the following methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在装载下，我们有以下方法：
- en: '`Constructor`: This is not a lifecycle method but the built-in class constructor.
    It is traditionally used to initialize state and bind any custom event functions.
    You may recall from [*Chapter 3*](B15508_03_Final_JC_ePub.xhtml#_idTextAnchor052)*,
    Building Better Apps with ES6+ Features*, `bind` is used to switch the `this`
    object of a function. This is done in the constructor.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数：这不是一个生命周期方法，而是内置的类构造函数。传统上用于初始化状态和绑定任何自定义事件函数。您可能还记得[*第3章*](B15508_03_Final_JC_ePub.xhtml#_idTextAnchor052)*，使用ES6+功能构建更好的应用程序*中提到，`bind`用于切换函数的`this`对象。这是在构造函数中完成的。
- en: '`getDerivedStateFromProps(props, state)`: If you are basing your local state
    on props from a parent you would use this function. This is a static function.
    It should be used sparingly as it triggers additional renders. It can also be
    used in updates.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDerivedStateFromProps(props, state)`: 如果您的本地状态基于父级的props，您将使用此函数。这是一个静态函数。应该谨慎使用，因为它会触发额外的渲染。它也可以在更新中使用。'
- en: '`render`: This can also run during updating for re-renders. This function is
    what triggers the reconciliation process for React. It should only render out
    JSX, which could also be inside arrays or plain text. If due to state or props
    you decide there is nothing to render you should return `null`. It is possible
    to return a boolean, but outside of testing I see little value in doing this.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render`：这也可以在更新时运行进行重新渲染。这个函数触发了React的协调过程。它应该只渲染出JSX，也可以在数组或纯文本中。如果由于状态或props决定没有东西需要渲染，应该返回`null`。可能返回布尔值，但除了测试之外，我认为这样做没有太大的价值。'
- en: '`componentDidMount`: This function is triggered after a component is finished
    mounting (being initialized). You can place network API calls here. You can also
    add event handler subscriptions here, but you must remember to unsubscribe them
    in the `componentWillUnmount` function or it can cause a memory leak. You can
    call `setState` to change local state data here, but you are then triggering a
    second call to render so it should be used sparingly. `SetState` is used to update
    local state.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidMount`：这个函数在组件完成挂载（初始化）后触发。你可以在这里放置网络API调用。你也可以在这里添加事件处理程序订阅，但你必须记得在`componentWillUnmount`函数中取消订阅，否则会导致内存泄漏。你可以在这里调用`setState`来改变本地状态数据，但这样会触发第二次渲染，所以应该谨慎使用。`SetState`用于更新本地状态。'
- en: '`UNSAFE` deprecated methods (do not use) are `UNSAFE_componentWillMount`, `UNSAFE_componentWillReceiveProps`,
    and `UNSAFE_componentWillUpdate`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNSAFE`已弃用的方法（不要使用）是`UNSAFE_componentWillMount`，`UNSAFE_componentWillReceiveProps`和`UNSAFE_componentWillUpdate`。'
- en: Updating
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新
- en: 'Let''s look at the methods under updating:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看更新下的方法：
- en: '`shouldComponentUpdate(nextProps, nextState)`: This is used to decide whether
    a re-render should be done or not. It usually compares the previous props to the
    current props.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate(nextProps, nextState)`：用于决定是否应该进行重新渲染。它通常会比较先前的props和当前的props。'
- en: '`getSnapshotBeforeUpdate(prevProps, prevState)`: This runs immediately before
    the render to DOM occurs so you can capture the DOM state just before React changes
    it. If you return something from this function, it is given as a parameter to
    the `componentDidUpdate` function.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSnapshotBeforeUpdate(prevProps, prevState)`：这个函数在DOM渲染之前立即运行，这样你就可以在React改变它之前捕获DOM状态。如果你从这个函数返回了一些东西，它会作为参数传递给`componentDidUpdate`函数。'
- en: '`componentDidUpdate(prevProps, prevState, snapshot)`: This function runs immediately
    after a re-render is complete. You can make changes to the finished DOM here,
    or you can call to `setState`, but you must have a condition so that you do not
    cause an infinite loop error. The snapshot state comes from the `getSnapshotBeforeUpdate`
    function.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate(prevProps, prevState, snapshot)`：这个函数在重新渲染完成后立即运行。你可以在这里对完成的DOM进行更改，或者你可以调用`setState`，但你必须有一个条件，以免引起无限循环错误。快照状态来自`getSnapshotBeforeUpdate`函数。'
- en: Unmounting
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卸载
- en: 'The following method is used at this level:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法在这个级别上使用：
- en: '`componentWillUnmount`: This is similar to `dispose` functions in languages
    such as C# and can be used to do cleanup work, for example, removing event listeners
    or other subscriptions.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUnmount`：这类似于C#等语言中的`dispose`函数，可以用于清理工作，例如，移除事件监听器或其他订阅。'
- en: The main concern in dealing with any of these lifecycle methods is to prevent
    unnecessary or unwanted re-renders. We must select the one that is less likely
    to trigger unnecessary re-renders, or if we need to use a specific method so our
    code runs at a specific time, we should add prop and state checks in order to
    reduce unneeded re-renders. It is paramount that you get renders until control
    or your user experience will suffer because of a slow and buggy application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 处理任何生命周期方法时的主要关注点是防止不必要或不想要的重新渲染。我们必须选择那种不太可能触发不必要重新渲染的方法，或者如果我们需要在特定时间运行代码，我们应该添加prop和state检查以减少不必要的重新渲染。重要的是要控制渲染，否则用户体验会因为慢和有bug的应用而受到影响。
- en: Let's go over some of the main calls. Let's start with `getDerivedStateFromProps`.
    In general, it is a good idea to avoid using this function, or just use it sparingly.
    From experience, it makes it very difficult to figure out when a component will
    re-render. In general, it tends to trigger unwanted re-renders, which can cause
    unintended behavior that's again difficult to track down.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些主要的调用。让我们从`getDerivedStateFromProps`开始。一般来说，最好避免使用这个函数，或者只是少量使用。根据经验，这使得很难弄清楚组件何时会重新渲染。一般来说，它往往会触发不必要的重新渲染，这可能会导致意外行为，而这又很难追踪。
- en: 'The React team recommends some alternatives, and we should always prefer these
    as they are almost always easier to reason about and more consistent in behavior:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: React团队推荐了一些替代方法，我们应该始终优先考虑这些方法，因为它们几乎总是更容易理解和行为更一致：
- en: When you need to trigger behavior based upon a prop value that changed. For
    example, getting network data or triggering some other action. Use `componentDidUpdate`
    instead. It is less likely to trigger an infinite loop as long as you do a check
    before causing anything that changes state. For example, you can use the `prevProps`
    parameter and compare it to your local state values before calling `setState`
    to change your state data.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要根据改变的prop值触发行为时。例如，获取网络数据或触发其他操作。使用`componentDidUpdate`。只要在引起任何改变状态之前进行检查，就不太可能触发无限循环。例如，你可以使用`prevProps`参数并将其与你的本地状态值进行比较，然后调用`setState`来改变你的状态数据。
- en: Use the `memoization` technique (note this idea is not a part of React necessarily;
    it's just a programming technique). `Memoization` is basically like caching, except
    instead of having a cache expiration you would use a variable change to update
    the cache. So, in React, this simply means use a property or function that first
    checks whether a props value is different from last time, and only if it is different
    does it trigger a state update.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`memoization`技术（请注意，这个想法不一定是React的一部分；它只是一种编程技术）。`Memoization`基本上就像缓存，只是不是通过缓存过期来更新缓存，而是通过变量改变来更新缓存。因此，在React中，这只是意味着使用一个属性或函数，首先检查props值是否与上次不同，只有在不同的情况下才触发状态更新。
- en: There is a built-in component wrapper in React called `React.memo`. It will
    trigger a re-render only when a child's props change, not when the parent component
    re-renders.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: React中有一个内置的组件包装器叫做`React.memo`。它只会在子组件的props改变时触发重新渲染，而不会在父组件重新渲染时触发重新渲染。
- en: Make your component fully controlled, which simply means that it will have no
    state of its own and will render under the direction of its parent whenever props
    change or the parent renders. Facebook also recommends using uncontrolled components
    as well by changing their key (a key is a unique identifier for the component),
    which then triggers a re-render. However, I disagree with this suggestion. As
    you recall, we discussed encapsulation and abstraction in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017)*,
    Understanding TypeScript*, and this means that the uncontrolled component's behavior
    should be unknown to the parent. This also means that it is not entirely controllable
    by the parent, and it shouldn't be. Therefore to get an uncontrolled component
    to do what the parent wants may make it tempting to add implementation changes
    inside that component, which will then tie it more closely to the parent. At times
    this may be unavoidable, but if it can be avoided it should be.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的组件完全受控，这意味着它不会有自己的状态，并且在父组件的指导下渲染，每当props改变或父组件渲染时。Facebook还建议使用未受控组件，方法是通过更改它们的key（key是组件的唯一标识符），然后触发重新渲染。然而，我不同意这个建议。正如您所记得的，我们在[*第1章*]（B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017）*，理解TypeScript*中讨论了封装和抽象，这意味着未受控组件的行为对父组件来说应该是未知的。这也意味着它不完全受父组件控制，也不应该受到控制。因此，让未受控组件执行父组件想要的操作可能会诱使在组件内部添加实现更改，这将使其与父组件更紧密地联系在一起。有时这是不可避免的，但如果可以避免，就应该避免。
- en: If your component's rendered state depends on network data you can use `componentDidMount`
    to make your network call there, and then update state (assuming you need this
    data only once on load). Note `componentDidMount` only runs once on the component's
    first load. Also, if you use this function you will be doing one additional render,
    but that's still better than the potential for causing additional unwanted renders.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的组件的渲染状态取决于网络数据，您可以使用`componentDidMount`在那里进行网络调用，然后更新状态（假设您只需要在加载时获取此数据）。请注意，`componentDidMount`仅在组件首次加载时运行一次。此外，如果您使用此函数，将会进行一次额外的渲染，但这仍然比可能导致额外不必要的渲染要好。
- en: '`ComponentDidUpdate` can be used to handle scenarios where state needs to change
    due to prop changes. Since this method is called after the render, it is less
    likely to cause infinite render loops as long as you compare your props to state
    before triggering any state changes. Having said that, it is better to avoid derived
    state entirely if at all possible and keep your state in a single parent root
    component and share that state via props. To be honest, this is tedious work as
    you will need to pass down your state via props to children that may be several
    layers deep. It also means you need to structure your state schema well so that
    you can cleanly separate state bound for a specific child. When we use Hooks later,
    you''ll see that this is much easier to do with Hooks than with a single state
    object. Nevertheless, having as little local component state as possible is a
    best practice for React development.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComponentDidUpdate`可用于处理由于prop更改而需要更改状态的情况。由于此方法在渲染后调用，因此触发任何状态更改之前将props与状态进行比较，不太可能导致无限渲染循环。话虽如此，最好尽量避免派生状态，并将状态保留在单个父根组件中，并通过props共享该状态。老实说，这是繁琐的工作，因为您需要通过props将状态传递给可能有几层深的子组件。这也意味着您需要很好地构建状态模式，以便可以清晰地分离为特定子组件绑定的状态。稍后当我们使用Hooks时，您将看到使用Hooks比使用单个状态对象更容易。然而，尽可能减少本地组件状态是React开发的最佳实践。'
- en: 'Let''s create a small project where we can try out a class component and discuss
    its features:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小项目，尝试使用类组件并讨论其特性：
- en: Switch your command line or terminal to the `Chap5` folder.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的命令行或终端切换到`Chap5`文件夹。
- en: 'Run the following command within that folder:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中运行以下命令：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now open Visual Studio in the folder you just created, `class-components`,
    and also open a terminal or command line in that same folder. Let''s create a
    new file called `Greeting.tsx` in the `src` folder. It should look like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在您刚创建的`class-components`文件夹中打开Visual Studio，并在同一文件夹中打开终端或命令行。让我们在`src`文件夹中创建一个名为`Greeting.tsx`的新文件。它应该是这样的：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we create our class we also need to remember to export it so that it can
    be accessed by whatever component will be using it. This is done with the `React.Component<GreetingProps>`.
    This type declaration is indicating not only that this class is a React component
    but also that it takes a prop of the `GreetingProps` type. Once the declaration
    is set we define the constructor, which takes a prop of the same type, `GreetingProps`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建类时，还需要记得导出它，以便任何将使用它的组件都可以访问它。这是通过`React.Component<GreetingProps>`完成的。这种类型声明不仅表示这个类是一个React组件，还表示它接受`GreetingProps`类型的prop。声明设置后，我们定义构造函数，它接受相同类型的prop，`GreetingProps`。
- en: Important Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If your component takes props, it is important that the first call you make
    inside the constructor is the call to the base class constructor, `super(props)`.
    This ensures that React is aware of your incoming props and so can react when
    props change (no pun intended). Inside the constructor, we don't need to use `this.props`
    to reference the `props` object since it is being passed in as a constructor parameter.
    Anywhere else, `this.props` is required.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组件接受props，重要的是在构造函数内部进行的第一个调用是对基类构造函数`super(props)`的调用。这确保了React知道您传入的props，因此可以在props改变时做出反应（无意冒犯）。在构造函数内部，我们不需要使用`this.props`来引用`props`对象，因为它作为构造函数参数传入。在其他任何地方，都需要使用`this.props`。
- en: Next, we see that `state` is instantiated in `constructor`, and the variable
    and its type are declared in the line below as being the `GreetingState` type.
    Then, finally, we have our `render` function, which declares JSX that will eventually
    be converted into HTML. Notice that the `render` function has a logical `if`/`else`
    statement to show a different UI depending on the value of `this.props.name`.
    `render` functions should try and control the proper UI and not render anything
    when there is no reason to. This can improve performance and memory when done
    consistently. Just return `null` if there is nothing to `render`, as React understands
    this value is indicating not to render anything.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们看到`state`在`constructor`中被实例化，变量及其类型在下一行被声明为`GreetingState`类型。最后，我们有我们的`render`函数，它声明了最终将被转换为HTML的JSX。请注意，`render`函数具有逻辑`if`/`else`语句，根据`this.props.name`的值显示不同的UI。`render`函数应该尽量控制正确的UI，在没有理由渲染任何内容时不要渲染任何内容。这样做可以在一致性的情况下提高性能和内存。如果没有要`render`的内容，只需返回`null`，因为React理解这个值表示不要渲染任何内容。
- en: 'Now all we need to do is update the `App.tsx` file so that it includes our
    `Greeting.tsx` component. Open the `App.tsx` file and update it like this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要更新`App.tsx`文件，以便包含我们的`Greeting.tsx`组件。打开`App.tsx`文件并像这样更新它：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, we used the `Greeting` component to replace some of the JSX
    that was already there. Notice that we did not pass the `name` property to `Greeting`.
    Let''s see what happens when we run the app. Execute this command in your terminal,
    making sure you are in the `class-components` folder:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们使用`Greeting`组件替换了部分已经存在的JSX。请注意，我们没有将`name`属性传递给`Greeting`。让我们看看当我们运行应用程序时会发生什么。在终端中执行此命令，确保您在`class-components`文件夹中：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let''s go to our `App.tsx` file and update `Greeting` to add a `name` value.
    Replace the `Greeting` component inside `App.tsx` with this:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们去我们的`App.tsx`文件，并更新`Greeting`以添加一个`name`值。用以下内容替换`App.tsx`中的`Greeting`组件：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Figure 5.3 – Updated screen'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 - 更新屏幕'
- en: '](img/Figure_5.3_B15508.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B15508.jpg)'
- en: Figure 5.3 – Updated screen
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 更新屏幕
- en: 'OK, so we''ve created a simple class-based component. Let''s now start making
    use of some of the lifecycle methods and see how they work:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经创建了一个简单的基于类的组件。现在让我们开始使用一些生命周期方法，并看看它们是如何工作的：
- en: 'Update `Greeting.tsx` to include the `getDerivedStateFromProps` function:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Greeting.tsx`以包括`getDerivedStateFromProps`函数：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code is virtually identical except we will now add the `getDerivedStateFromProps`
    function just above the `render` function:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码几乎相同，除了我们现在将`getDerivedStateFromProps`函数添加到`render`函数的上面：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s leave this code as is for now and update our `App.tsx` file so that
    it can accept an input, which takes the name of the current user:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们暂时保留这段代码，并更新我们的`App.tsx`文件，以便它可以接受一个输入，该输入获取当前用户的名字：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `onChangeName`, we are then setting the `state` property `enteredName` to
    the value of the user input by using the `setState` function. You must never modify
    state in your class components without using this function or else your state
    will lose synchronization with the React runtime:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onChangeName`中，我们将`state`属性`enteredName`设置为用户输入的值，使用`setState`函数。在类组件中，您绝对不能在不使用这个函数的情况下修改状态，否则您的状态将与React运行时失去同步：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we have added a `console.log` statement to see when the `App.tsx` `render`
    function is called. Also, we have defined a new `input` control whose value is
    `this.state.enteredName` and its `onChange` event is tied to our `onChangeName`
    function. If you save this code and open the Chrome dev tools, you will see this:![Figure
    5.4 – Rendering Greeting
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加了一个`console.log`语句，以查看`App.tsx`的`render`函数何时被调用。此外，我们定义了一个新的`input`控件，其值为`this.state.enteredName`，其`onChange`事件与我们的`onChangeName`函数相关联。如果您保存此代码并打开Chrome开发工具，您将会看到这个：![图5.4
    - 渲染问候
- en: '](img/Figure_5.4_B15508.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.4_B15508.jpg)'
- en: Figure 5.4 – Rendering Greeting
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - 渲染问候
- en: You can see our render logging messages and also the `Greeting` `name` prop
    and `message` state values. Additionally, since we did not enter a value in the
    `input`, the `name` prop is blank and therefore the `name` property of our `Greeting`
    component and the end of the `message` string are also blank. You're probably
    wondering why the logs for `Greeting` run twice. It's because we are running in
    StrictMode for development purposes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们的`render`日志消息，以及`Greeting`的`name`属性和`message`状态值。另外，由于我们没有在`input`中输入值，`name`属性为空，因此我们的`Greeting`组件的`name`属性和`message`字符串的末尾也为空。您可能想知道为什么`Greeting`的日志运行两次。这是因为我们正在开发目的下运行在StrictMode中。
- en: 'Let''s quickly remove that so we don''t get confused. Go to your `index.tsx`
    file and replace the code with this:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速删除它，以免混淆。转到您的`index.tsx`文件，并用以下代码替换：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you save and look at your browser debug console, you will see this:![Figure
    5.5 – Browser debug console
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您保存并查看浏览器调试控制台，您将会看到这个：![图5.5 - 浏览器调试控制台
- en: '](img/Figure_5.5_B15508.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.5_B15508.jpg)'
- en: Figure 5.5 – Browser debug console
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 - 浏览器调试控制台
- en: The rationale for all this work is to show what specifically can trigger calls
    to render and how we can be more careful about this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工作的原因是为了显示特定可以触发渲染调用的内容，以及我们如何更加小心谨慎地处理这些内容。
- en: Now let's type our name into the input, and you'll see this:![Figure 5.6 – App.tsx
    input
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在输入框中输入我们的名字，您会看到这个：![图5.6 - App.tsx输入
- en: '](img/Figure_5.6_B15508.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.6_B15508.jpg)'
- en: Figure 5.6 – App.tsx input
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 - App.tsx输入
- en: 'The question is, why does my message end with "Hello from, "? If you look at
    the code in `Greeting`, you can see that we only set the `message` state property
    once during the constructor run (which is effectively like using `componentDidMount`).
    So, since this event runs only once when the screen first loads, at that time
    `this.props.name` is blank as we''ve not entered a value yet. So, what can we
    do? Well, let''s try using the `getDerivedStateFromProps` function and see what
    happens:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题是，为什么我的消息以"Hello from, "结尾？如果您查看`Greeting`中的代码，您会发现我们只在构造函数运行期间设置了`message`状态属性一次（这实际上就像使用`componentDidMount`）。因此，由于此事件仅在屏幕首次加载时运行一次，那时`this.props.name`为空，因为我们还没有输入值。那么，我们能做些什么呢？好吧，让我们尝试使用`getDerivedStateFromProps`函数，看看会发生什么：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I''m only showing the `Greeting` class as that''s the only thing I want to
    change for this example. So, in the following code, take a look at the updated
    `getDerivedStateFromProps`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我只展示`Greeting`类，因为这是我想要为这个示例做出改变的唯一内容。因此，在下面的代码中，看一下更新的`getDerivedStateFromProps`：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, that function has now become more complex and I am doing a comparison
    against the new prop and our existing state. Then we clone our `state` object.
    It is very important to make sure you do this so that you do not accidentally
    edit your state directly. Then we update the `state.message` value using a new
    static function, `getNewMessage` (since I'm setting the message in multiple places).
    Now let's try adding our name. If you do this, you'll see that our name gets added
    to the message, but also we get a `Greeting` and `App` render for each letter
    we type. Right now this isn't too bad as we don't have much code, but you can
    imagine if we keep adding new properties to our local state on our `Greeting`
    component and we have a much more complex application, things can get very difficult.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个函数现在变得更加复杂，我正在对新的属性和我们现有的状态进行比较。然后我们克隆我们的`state`对象。非常重要的是要确保您这样做，以免意外直接编辑您的状态。然后我们使用一个新的静态函数`getNewMessage`来更新`state.message`的值（因为我在多个地方设置了消息）。现在让我们尝试添加我们的名字。如果您这样做，您会发现我们的名字被添加到消息中，但是每输入一个字母，我们都会得到一个`Greeting`和`App`的渲染。现在这还不算太糟糕，因为我们的代码还不多，但是您可以想象，如果我们在`Greeting`组件的本地状态上不断添加新属性，并且我们有一个更复杂的应用程序，事情可能会变得非常困难。
- en: 'Let''s refactor this code and see if we can improve things a bit:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构一下这段代码，看看我们是否能稍微改进一下：
- en: 'Update `App.tsx`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`App.tsx`：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: render() {
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: render() {
- en: console.log("rendering App");
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: console.log("rendering App");
- en: return (
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <div className="App">
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="App">
- en: <header className="App-header">
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <header className="App-header">
- en: <img src={logo} className="App-logo" alt="logo"          />
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <img src={logo} className="App-logo" alt="logo"          />
- en: <input value={this.state.enteredName}
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <input value={this.state.enteredName}
- en: onChange={this.onChangeName} />
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: onChange={this.onChangeName} />
- en: <Greeting message state property to our Greeting component as a prop.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <Greeting message state property to our Greeting component as a prop.
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we''ll look at our `Greeting` component, but to keep things clean, let''s
    create a new file called `GreetingFunctional.tsx` and put the following code inside
    it:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将看一下我们的`Greeting`组件，但为了保持清晰，让我们创建一个名为`GreetingFunctional.tsx`的新文件，并将以下代码放入其中：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you have added this file, you''ll also need to update your `App.tsx` file
    import of `Greeting` to refer to this file like this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您添加了这个文件，您还需要更新您的`App.tsx`文件中对`Greeting`的导入，以便像这样引用这个文件：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, `Greeting` has been drastically shortened and made simpler.
    It is now a functional component because it is a best practice to make components
    that have no local state to be functions instead of classes. We weren't able to
    reduce the re-renders, since changing the message necessarily triggers a re-render,
    but even this shortening and reducing of code is worth this change. Also, even
    though we moved some code into `App.tsx`, you'll notice that this code is also
    less involved than the code that was in our original `Greeting` component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`Greeting`已经大大缩短并变得更简单。它现在是一个功能组件，因为最佳实践是将没有本地状态的组件制作成函数而不是类。我们无法减少重新渲染，因为更改消息必然会触发重新渲染，但即使这种缩短和减少代码也值得这种改变。此外，即使我们将一些代码移到`App.tsx`中，您会注意到这段代码也比我们原来的`Greeting`组件中的代码少得多。
- en: There is one issue with this style of component building, where most of the
    state is inside a single parent component and child components get props passed
    down to them, which is that for complex multi-level component hierarchies there
    can be a lot of boilerplate code to pass the props through multiple levels of
    components. It is for these scenarios that we could use React Context to bypass
    the hierarchy and send parent state directly to a child. However, I don't like
    using Context because bypassing the natural component hierarchy to arbitrarily
    inject state to some component feels like an anti-pattern (a design method you
    should not be using). It's bound to cause confusion and make it more difficult
    to refactor code later. I'll get into Context more later in [*Chapter 7*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*,
    Learning Redux and React Router*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组件构建风格存在一个问题，即大部分状态都在一个单独的父组件中，子组件通过传递props来获取状态，对于复杂的多级组件层次结构，可能需要大量的样板代码来将props传递给多个级别的组件。对于这些情况，我们可以使用React
    Context来绕过层次结构，直接将父状态发送给子组件。但是，我不喜欢使用Context，因为绕过自然的组件层次结构，任意向某个组件注入状态，感觉像是一种反模式（一种不应该使用的设计方法）。这很可能会引起混乱，并使以后重构代码变得更加困难。我稍后会更详细地介绍Context，见[*第7章*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*，学习Redux和React
    Router*。
- en: In this section, we learned about class-based React components. Since Hooks
    are still relatively new, most existing React apps are still using class-based
    components, therefore having an understanding of this style of coding is still
    important. In the next section, we will explore Hook-based components and then
    later compare the two styles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了基于类的React组件。由于Hooks仍然相对较新，大多数现有的React应用程序仍在使用基于类的组件，因此了解这种编码风格仍然很重要。在下一节中，我们将探索基于Hook的组件，然后稍后比较这两种风格。
- en: Learning React Hooks and understanding how it is an improvement over class-style
    components
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习React Hooks并了解它是如何改进类式组件的。
- en: In this section, we will learn about React Hooks. We'll take a look at an example
    project and see how it works. Since this book is primarily about Hooks, at least
    with regard to React, it will help us write our code later.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习React Hooks。我们将看一个示例项目并了解它是如何工作的。由于本书主要是关于Hooks，至少就React而言，它将帮助我们以后编写我们的代码。
- en: Let's discuss some of the reasons for Hooks. We saw in the class components
    section that classes have lifecycle methods that allow you to handle certain events
    that occur while a component is alive. With React Hooks, we don't have those lifecycle
    methods, because with Hooks all components are functional components. We created
    a functional component in the class-components sample app called `GreetingFunctional`
    in the previous section. A functional component is a component that is a JavaScript
    function and returns JSX. The reason for this change is that the entire design
    is attempting to move away from **Object Oriented Programming** (**OOP**) inheritance
    models and instead use composition as its primary code reuse model. We covered
    OOP inheritance models in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025)*,
    Exploring TypeScript*, but composition means that instead of receiving functionality
    as an inheritance from some parent class we are simply combining functional components,
    sort of like Lego pieces, to design our screens.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些使用Hooks的原因。我们在类组件部分看到，类有生命周期方法，允许您处理组件存活时发生的某些事件。使用React Hooks，我们没有这些生命周期方法，因为使用Hooks时所有组件都是功能组件。在上一节的类组件示例应用程序中创建了一个功能组件`GreetingFunctional`。功能组件是一个JavaScript函数并返回JSX的组件。这种变化的原因是整个设计试图摆脱**面向对象编程**（**OOP**）继承模型，而是使用组合作为其主要代码重用模型。我们在[*第2章*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025)*，探索TypeScript*中介绍了OOP继承模型，但组合意味着我们不是从某个父类继承功能，而是简单地组合功能组件，有点像乐高积木，来设计我们的屏幕。
- en: Along with these functional components we have Hooks. Hooks are just JavaScript
    functions that provide certain capabilities to the component. These include the
    creation of state, access to network data, and just about anything else a component
    needs. Additionally, Hooks are not component specific, and therefore any Hook
    can be used in any component—assuming it's useful and makes sense. If you look
    back at our class-component project, you will see that there's really no way of
    sharing the logic in our lifecycle event methods. We cannot easily extract it
    out and then reuse it in some other class component. This is one of the primary
    reasons for the creation of the Hooks model in React. Therefore, these two pieces,
    functional components and reusable functions (Hooks), are the key to understanding
    React Hooks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些功能组件，我们还有Hooks。Hooks只是提供某些功能给组件的JavaScript函数。这些功能包括状态的创建、访问网络数据，以及组件需要的任何其他功能。此外，Hooks不是特定于组件的，因此任何Hook都可以在任何组件中使用——假设它是有用的并且是合理的。如果您回顾一下我们的类组件项目，您会发现没有办法共享生命周期事件方法中的逻辑。我们不能轻松地将其提取出来，然后在其他类组件中重用。这是React中创建Hooks模型的主要原因之一。因此，这两个部分，功能组件和可重用函数（Hooks），是理解React
    Hooks的关键。
- en: 'To start, let''s list some of the more important Hooks that we will be using
    in our code. We will give examples of their use in code soon, but for now, we''ll
    discuss them at a high level:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们列出我们在代码中将要使用的一些更重要的Hooks。我们很快会在代码中给出它们的使用示例，但现在，我们将在高层次上讨论它们：
- en: '`useState`: This function is the bread and butter of development with Hooks.
    It replaces the `state` and `setState` calls within class components. `useState`
    takes a value as a parameter that represents the initial state of the state property
    it is trying to represent. It also returns an array. The first item is the actual
    state property and the second is a function that can update that property. In
    general, it is used to update a single value, as opposed to a more complex object
    that has multiple properties. A better Hook for that type of state may be `useReducer`,
    which is explained later.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState`：这个函数是使用Hooks进行开发的基础。它替换了类组件中的`state`和`setState`调用。`useState`以一个值作为参数，表示它正在尝试表示的状态属性的初始状态。它还返回一个数组。第一项是实际的状态属性，第二项是一个可以更新该属性的函数。一般来说，它用于更新单个值，而不是具有多个属性的更复杂的对象。这种类型状态的更好的Hook可能是`useReducer`，稍后会解释。'
- en: '`useEffect`: This function triggers after components have finished being drawn
    on the screen. It is similar to `componentDidMount` and `componentDidUpdate`.
    However, they run before drawing onto the screen happens. It is intended to be
    used to update state objects. So if, for example, you need to get network data
    and then update state, you can do it here. You can also subscribe to events here,
    but you should also unsubscribe by returning a function that does the unsubscribing.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect`：这个函数在组件完成绘制到屏幕后触发。它类似于`componentDidMount`和`componentDidUpdate`。但是，它们在绘制到屏幕之前运行。它旨在用于更新状态对象。因此，例如，如果您需要获取网络数据然后更新状态，可以在这里做。您也可以在这里订阅事件，但是您还应该通过返回一个执行取消订阅的函数来取消订阅。'
- en: You can have multiple separate implementations of `useEffect`, each responsible
    for doing something unique. This function usually runs after every completed screen
    draw. So, if any component state or props change, this will run. You can force
    it to run only once, like `componentDidMount`, by passing an empty array as a
    parameter. You can also force it to run only when specific props or state changes
    by passing those as arrays into the `useEffect` array parameter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以有多个独立的`useEffect`实现，每个负责执行某些独特的操作。这个函数通常在每次完成屏幕绘制后运行。因此，如果任何组件状态或props发生变化，它将运行。您可以通过将空数组作为参数传递来强制它只运行一次，就像`componentDidMount`一样。您还可以通过将它们作为数组传递到`useEffect`数组参数中，来强制它仅在特定的props或状态更改时运行。
- en: This function runs asynchronously, but if you need to know some element values
    on the screen, such as scroll position, you may need to use `useLayoutEffect`.
    This function runs synchronously, allowing you to get certain element values as
    they currently are on the screen and then do something with them in a synchronous
    manner. But, of course, this blocks your UI, so you need to only do things that
    are very fast or the user experience will suffer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是异步运行的，但是如果你需要知道屏幕上一些元素的值，比如滚动位置，你可能需要使用`useLayoutEffect`。这个函数是同步运行的，允许你以同步的方式获取屏幕上某些元素的值，然后以同步的方式对它们进行操作。但是，当然，这会阻塞你的UI，所以你只能做一些非常快速的事情，否则用户体验会受到影响。
- en: '`useCallback`: This function will create an instance of a function once a set
    of parameters has been changed. This function exists to try and save memory, because
    otherwise an instance of the function would be recreated on each render. It takes
    a handler function as its first parameter and then an array of items that may
    change as its second. If the items don''t change, the callback doesn''t get a
    new instance. Therefore any properties used inside this function will be the prior
    values. When I first learned about this function, I found it difficult to understand,
    so I''ll give an example of it later.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useCallback`：这个函数将在一组参数发生变化时创建一个函数实例。这个函数存在是为了节省内存，否则函数的实例将在每次渲染时重新创建。它以处理函数作为第一个参数，然后以一个可能会改变的项目数组作为第二个参数。如果项目没有改变，回调函数就不会得到一个新的实例。因此，这个函数内部使用的任何属性都将是之前的值。当我第一次了解这个函数时，我觉得很难理解，所以我稍后会举个例子。'
- en: '`useMemo`: This function is intended to save the result of a long-running task.
    It''s a bit like caching, but it only runs if the array of parameters has changed,
    so in this sense it''s similar to `useCallback`. However, `useMemo` returns a
    value that is the result of some heavy computation.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useMemo`：这个函数旨在保存长时间运行任务的结果。它有点像缓存，但只有在参数数组发生变化时才会运行，所以在这个意义上它类似于`useCallback`。然而，`useMemo`返回的是一些重型计算的结果。'
- en: '`useReducer`: This function works similarly to `React Redux`. It takes two
    parameters, `reducer` and `initial state`, and returns two objects: a `state`
    object that will be updated by the `reducer` and a dispatcher that receives updated
    state data, called an `action`, and passes it to the `reducer`. The `reducer`
    acts as a filtering mechanism and determines how action data will be used to update
    the state. We will show an example later in code. This method works well when
    you want to have a single complex state object with multiple properties that may
    need to be updated.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useReducer`：这个函数与`React Redux`类似。它接受两个参数，`reducer`和`initial state`，并返回两个对象：一个由`reducer`更新的`state`对象和一个接收更新后的状态数据（称为`action`）并将其传递给`reducer`的分发器。`reducer`充当过滤机制，并确定如何使用动作数据来更新状态。我们稍后会在代码中展示一个例子。当你想要有一个具有多个可能需要更新的属性的单一复杂状态对象时，这种方法效果很好。'
- en: '`useContext`: This function is a way of having global state data that can be
    shared across components. It is better to use it sparingly as it gives the ability
    to arbitrarily inject state into any child without regard to hierarchy. We will
    use `React Redux` rather than `Context`, but it is good to know it exists.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useContext`：这个函数是一种具有全局状态数据的方式，可以在组件之间共享。最好谨慎使用它，因为它可以任意地将状态注入到任何子组件中，而不考虑层次结构。我们将使用`React
    Redux`而不是`Context`，但知道它的存在是很好的。'
- en: '`useRef`: This can be used to hold any value in its current property. This
    value does not trigger a re-render if it changes, and the value lives as long
    as the component it was created in lives. It''s a way of holding state that has
    no effect on renders. One of its use cases is to hold a DOM element. You may want
    to do this because under certain circumstances it is necessary to opt out of the
    standard state-driven React model and access HTML elements directly. For this
    purpose, `useRef` is used to access an instance of an element.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useRef`：这可以用来保存当前属性中的任何值。如果它发生变化，这个值不会触发重新渲染，而且这个值的生存期与它所创建的组件的生存期一样长。这是一种保持状态的方式，对渲染没有影响。它的一个用例是保存DOM元素。你可能想这样做，因为在某些情况下，有必要退出标准的基于状态的React模型，直接访问HTML元素。为此，`useRef`用于访问元素的实例。'
- en: There are, of course, many other Hooks out there, both from the React team and
    third parties. But once you are comfortable, you'll be able to see what else you
    may need or, even better, be able to create your own Hooks. We will also be creating
    our own Hooks for our project as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他的Hooks，既有来自React团队的，也有第三方的。但是一旦你熟悉了，你就能看到你可能需要什么，甚至更好的是，能够创建你自己的Hooks。我们也将为我们的项目创建自己的Hooks。
- en: 'Let''s take a look at some examples of using Hooks. We''ll create a new project
    in `Chap5` to get started:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些使用Hooks的例子。我们将在`Chap5`中创建一个新项目来开始：
- en: 'Switch your command line or terminal to the `Chap5` folder and run the following
    command within that folder:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的命令行或终端切换到`Chap5`文件夹，并在该文件夹中运行以下命令：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the last example for the class-components project, we created a class component
    called `Greeting.tsx` that had its own state. For demonstration purposes, let''s
    create the same component as a React Hooks functional component. In the `src`
    folder of your `hooks-components` project, create a new file called `Greeting.tsx`
    and add this code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类组件项目的最后一个例子中，我们创建了一个名为`Greeting.tsx`的类组件，它有自己的状态。为了演示目的，让我们将相同的组件创建为React
    Hooks函数组件。在`hooks-components`项目的`src`文件夹中，创建一个名为`Greeting.tsx`的新文件，并添加以下代码：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is the version of the code where we get a name as a prop and have our own
    local state. We should try and avoid local state, but I'm doing this for demonstration
    purposes. As you can see, it's way shorter than the class version. In addition,
    we have no lifecycle functions to override. We are using an arrow function because
    it's shorter than using a regular function and we don't need a function's features.
    As you can see, we do have a declaration for the `Greeting` component. It uses
    `FC`, `GreetingProps` interface. The state is stored in the `message` property
    by using the `useState` function, which is a small one-line statement with no
    constructor since this is a function and not a class. Note `GreetingProps` next
    to the parameter is not necessary; I only included it for completeness. Notice
    also that we are using parameter deconstruction by passing `{ name }` instead
    of `props`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的一个版本，我们将一个名字作为prop并拥有我们自己的本地状态。我们应该尽量避免使用本地状态，但我正在做这个来进行演示。正如你所看到的，这比类版本要短得多。此外，我们没有生命周期函数需要重写。我们使用箭头函数是因为它比使用常规函数要短，而且我们不需要函数的特性。正如你所看到的，我们对`Greeting`组件进行了声明。它使用了`FC`，`GreetingProps`接口。状态存储在`message`属性中，使用了`useState`函数，这是一个小的一行语句，没有构造函数，因为这是一个函数而不是一个类。注意`GreetingProps`在参数旁边并不是必要的；我只是为了完整性才包含它。还要注意，我们使用了参数解构，通过传递`{
    name }`而不是`props`。
- en: Next, we have our `useEffect` function. As stated, this is sort of similar to
    `componentDidMount` or `componentDidUpdate`, but runs after drawing to the screen
    finishes. It will update the `message` state property whenever our `name` prop
    updates because we pass it as a `parameter` to the `useEffect` function. Since
    this is not a class, we have no render function. The return value of the function
    is the call to render.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的`useEffect`函数。正如所述，这有点类似于`componentDidMount`或`componentDidUpdate`，但是在绘制到屏幕完成后运行。每当我们的`name`prop更新时，它将更新`message`状态属性，因为我们将它作为参数传递给`useEffect`函数。由于这不是一个类，我们没有渲染函数。函数的返回值是调用渲染。
- en: 'Now we''ll refactor a bit by placing our state into the `App.tsx` component.
    Let''s make `GreetingFunctional.tsx` like we did in the class version of our component:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将通过将我们的状态放入`App.tsx`组件中来进行一些重构。让我们像我们在组件的类版本中做的那样，将`GreetingFunctional.tsx`组件做成这样：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let''s refactor `App.tsx` as a functional component and use the `useReducer`
    Hook we learned about in this section. We''ll leave out the imports since they''re
    the same:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将`App.tsx`重构为一个函数组件，并使用我们在本节学到的`useReducer` Hook。我们将省略导入，因为它们是一样的：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We define our reducer and an initial state object called `initialState`. The
    default signature for reducers is parameters of the `any` type because both the
    state and action objects can technically be of any type. If you look at the `reducer`
    function, you''ll notice it tries to handle different types of actions by returning
    a new state object and an appropriate updated member (again, it is very important
    you do not modify the original state object directly. Copy it and then do your
    update on the new object and return that). So, this is the intended usage of `useReducer`.
    If your state objects are complex and the logic to change the properties is complex,
    you would use a `useReducer` function. You can think of it as a form of containment
    for related logic on your state object. Next, you can see the actual call to `useReducer`
    in the `App` component:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们的reducer和一个名为`initialState`的初始状态对象。reducer的默认签名是`any`类型的参数，因为状态和动作对象都可以是任何类型。如果你看一下`reducer`函数，你会注意到它试图通过返回一个新的状态对象和一个适当更新的成员来处理不同类型的动作（再次强调，你绝对不能直接修改原始状态对象。复制它，然后在新对象上进行更新并返回它）。所以，这就是`useReducer`的预期用法。如果你的状态对象很复杂，改变属性的逻辑也很复杂，你会使用`useReducer`函数。你可以把它看作是对状态对象上相关逻辑的一种封装。接下来，你可以在`App`组件中看到对`useReducer`的实际调用：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, this function returns an object and a `dispatch` function. The
    object is the entire state object after the reducer runs, but in our case we do
    deconstruction so we can directly call the `message` and `enteredName` properties.
    So after this setup, the `onChangeName` event is defined, which, when triggered,
    runs the `useReducer` dispatcher, `dispatch`, to trigger the actual change by
    sending over the appropriate action. If you run this code, you'll see it runs
    as before.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个函数返回一个对象和一个`dispatch`函数。对象是reducer运行后的整个状态对象，但在我们的情况下，我们进行了解构，所以我们可以直接调用`message`和`enteredName`属性。在这个设置之后，定义了`onChangeName`事件，当触发时，运行`useReducer`的分发器`dispatch`，通过发送适当的动作来触发实际的更改。如果你运行这段代码，你会发现它和以前一样运行。
- en: 'Now the nice thing about all this is that, as you can see, we can take our
    `reducer` function and reuse it in other functional components. We can also take
    our dispatcher and pass it down to child components so that the child can trigger
    updates to our state as well. Let''s try that out:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有这些的好处是，正如你所看到的，我们可以把我们的`reducer`函数拿来在其他函数组件中重用。我们也可以把我们的分发器传递给子组件，这样子组件也可以触发对我们状态的更新。让我们试一试：
- en: 'Let''s update our `GreetingFunctional.tsx` component with this code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用这段代码更新我们的`GreetingFunctional.tsx`组件：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we have passed down `enteredName` and `greetingDispatcher` to
    our `Greeting` component as props. Then we also brought over the `input` and `onChangeName`
    events in order to use them in our component.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经将`enteredName`和`greetingDispatcher`作为props传递给了我们的`Greeting`组件。然后我们还带入了`input`和`onChangeName`事件，以便在我们的组件中使用它们。
- en: 'Now, let''s update our `App.tsx` file like this:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们像这样更新我们的`App.tsx`文件：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, we have removed `onChangeName` and the input so that we can
    use it in our `GreetingFunctional.tsx` component. We are also passing `enteredName`,
    `message`, and `dispatch` as parameters to the `Greeting` component. If you run
    this you should see that it is our child `GreetingFunctional.tsx` that is triggering
    the `reducer` updates.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经移除了`onChangeName`和输入，以便我们可以在我们的`GreetingFunctional.tsx`组件中使用它。我们还将`enteredName`、`message`和`dispatch`作为参数传递给`Greeting`组件。如果你运行这个，你会看到触发`reducer`更新的是我们的子`GreetingFunctional.tsx`组件。
- en: 'Next, let''s look at the `useCallback` function. Update `App.tsx` like this:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`useCallback`函数。像这样更新`App.tsx`：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What we''re doing is having an input that will take the user''s initial number
    value, using `startCount`. Then we will increment that number by clicking `setCountCallback`.
    But make note of how `useCallback` is having the `count` state as a parameter.
    This means that when `count` changes, `setCountCallback` will be reinitialized
    with current values. The remaining code is returning the desired JSX that will
    generate the final HTML:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个输入，该输入将使用`startCount`获取用户的初始数字值。然后，我们将通过单击`setCountCallback`递增该数字。但请注意，`useCallback`是如何将`count`状态作为参数的。这意味着当`count`更改时，`setCountCallback`将重新初始化为当前值。其余的代码返回了所需的JSX，将生成最终的HTML：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The return is providing the UI for this incrementation ability.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 返回提供了这种递增能力的UI。
- en: 'If you run this code and click the **Increment count** button, you will see
    that it increments, as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码并单击**增加计数**按钮，您将看到它会增加，如下所示：
- en: '![Figure 5.7 – Increment count clicked 8 times'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 – 单击增加计数8次'
- en: '](img/Figure_5.7_B15508.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.7_B15508.jpg)'
- en: Figure 5.7 – Increment count clicked 8 times
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 单击增加计数8次
- en: 'However, try changing the passed-in array, `[count, startCount]`, and remove
    the `count` variable so it just says `[startCount]`. Now, it does not keep incrementing
    because there is no dependency on `count`. It only counts once, on the first run,
    no matter how many times we click:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，尝试更改传入的数组`[count, startCount]`，并删除`count`变量，使其只说`[startCount]`。现在，它不会继续递增，因为没有依赖于`count`。无论我们点击多少次，它只会计数一次，第一次运行时，无论我们点击多少次：
- en: '![Figure 5.8 – After removing count'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 – 删除count后'
- en: '](img/Figure_5.8_B15508.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.8_B15508.jpg)'
- en: Figure 5.8 – After removing count
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 删除count后
- en: Therefore, even if you click many times, it will always be incremented by one,
    since the function is cached in memory and it always runs with the same initial
    value of `count`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使您点击多次，它也将始终递增一次，因为该函数被缓存在内存中，并且始终以`count`的相同初始值运行。
- en: 'Let''s look at one more example for performance. We''ll use the memo wrapper
    on this example to reduce re-renders. It''s not a Hook, but it is a new capability
    added recently to React. Let''s look at the steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个性能示例。我们将在此示例中使用memo包装器以减少重新渲染。这不是一个Hook，但它是最近添加到React中的一个新功能。让我们看看步骤：
- en: 'Create a new file called `ListCreator.tsx` and add this code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ListCreator.tsx`的新文件，并添加以下代码：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This component will take a list of items and render them as a list.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将接受一个项目列表并将其呈现为列表。
- en: 'Now, let''s update our `App.tsx` file to send new list items based on the increment
    count. Again, I''ve only included the `App` function. Please note there is a new
    import called `ListCreator` that is needed as well:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更新我们的`App.tsx`文件，以根据递增计数发送新的列表项。再次，我只包含了`App`函数。请注意，还需要一个名为`ListCreator`的新导入：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: const onWelcomeBtnClick = () => {
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: const onWelcomeBtnClick = () => {
- en: setCountCallback();
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: setCountCallback();
- en: '}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'const onChangeStartCount = (e:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'const onChangeStartCount = (e:'
- en: React.ChangeEvent<HTMLInputElement>) => {
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: React.ChangeEvent<HTMLInputElement>) => {
- en: setStartCount(Number(e.target.value));
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: setStartCount(Number(e.target.value));
- en: '}'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: console.log("App.tsx render");
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: console.log("App.tsx render");
- en: return (
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <div className="App">
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="App">
- en: <header className="App-header">
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <header className="App-header">
- en: <img src={logo} className="App-logo" alt="logo" />
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <img src={logo} className="App-logo" alt="logo" />
- en: <Greeting
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 问候
- en: message={message}
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: message={message}
- en: enteredName={enteredName}
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: enteredName={enteredName}
- en: greetingDispatcher={ dispatch } />
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: greetingDispatcher={ dispatch } />
- en: '<div style={{marginTop: ''10px''}}>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '<div style={{marginTop: ''10px''}}>'
- en: <label>Enter a number and we'll increment           it</label>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <label>输入一个数字，我们将递增           它</label>
- en: <br/>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <br/>
- en: <input value={startCount}           onChange={onChangeStartCount}
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <input value={startCount}           onChange={onChangeStartCount}
- en: 'style={{width: ''.75rem''}} />&nbsp;'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'style={{width: ''.75rem''}} />&nbsp;'
- en: <label>{count}</label>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <label>{count}</label>
- en: <br/>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <br/>
- en: <button onClick={onWelcomeBtnClick}>Increment
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <button onClick={onWelcomeBtnClick}>增加
- en: count</button>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: count</button>
- en: </div>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <div>
- en: <ListCreator listItems={listItems} />
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <ListCreator listItems={listItems} />
- en: </div>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </header>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: </header>
- en: </div>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: )
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '}'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s do a small update to `ListCreator` to reduce our renders:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对`ListCreator`进行一些小的更新，以减少我们的渲染：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I only showed the `ListCreator` component, but as you can see we added a wrapper
    called `React.memo`. This wrapper only allows component updates if the props passed
    in have changed. Therefore we get a small performance benefit. If this was a complex
    object with lots of elements it could make a big difference.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我只展示了`ListCreator`组件，但是您可以看到我们添加了一个名为`React.memo`的包装器。此包装器仅在传入的props发生更改时才允许组件更新。因此，我们获得了一些小的性能优势。如果这是一个具有大量元素的复杂对象，它可能会产生很大的差异。
- en: As you can see throughout these examples, for any given Hook, we can reuse that
    same Hook in different components and with different parameters. This is the key
    takeaway of Hooks. Code reuse is now much easier.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这些示例中所看到的，对于任何给定的Hook，我们可以在不同的组件中重用相同的Hook，并使用不同的参数。这是Hooks的关键要点。代码重用现在变得更加容易。
- en: Please note `useState` and `useReducer` are just reusable functions that allow
    you to use functions across multiple components. So using `useState` in component
    A and then `useState` in component B will not allow you to share the state across
    both components, even if the state names are the same. You're just reusing capability,
    that's all.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`useState`和`useReducer`只是可重用的函数，允许您在多个组件中使用函数。因此，在组件A中使用`useState`，然后在组件B中使用`useState`将不允许您在两个组件之间共享状态，即使状态名称相同也是如此。你只是重用功能，仅此而已。
- en: In this section, we learned about React Hooks. We reviewed some of the main
    Hooks available in the library as well as how to use some of them. We will cover
    more Hooks later and also begin building our app in future chapters. This coverage
    of Hooks is going to help us to start building our components later.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了React Hooks。我们回顾了库中一些主要的Hooks以及如何使用其中一些。我们将在以后的章节中涵盖更多的Hooks，并开始构建我们的应用程序。这些Hooks的覆盖将帮助我们以后开始构建我们的组件。
- en: Comparing and contrasting the class way versus the Hooks way
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较和对比类方式与Hooks方式
- en: In this section, we will discuss some of the differences between the class way
    and the Hooks way of writing code in React. We will see why the React team decided
    Hooks was the way forward. Learning these details will give us confidence in using
    Hooks in our own code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论在React中以类方式和Hooks方式编写代码之间的一些差异。我们将看到为什么React团队决定使用Hooks是前进的方式。了解这些细节将使我们对在自己的代码中使用Hooks更有信心。
- en: Code reuse
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重用
- en: If you look at the class-based lifecycle methods, not only are there many to
    remember and understand, you can also see that for each class component you would
    have a pretty much unique implementation of lifecycle functions. This makes code
    reuse difficult to do with classes. With Hooks, we also have many different built-in
    Hooks we can use and need to know. However, they are not component specific and
    can be reused for different components at will. This is the key motivator for
    using Hooks. Code reuse is much easier because the Hooks are not tied to any specific
    class. Each Hook is focused on providing a specific capability or functionality,
    regardless of where it's used. Additionally, if we do the work of building our
    own Hooks, we can reuse them when appropriate as well.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下基于类的生命周期方法，不仅有许多需要记住和理解的方法，而且你还可以看到对于每个类组件，你将有一个几乎独特的生命周期函数实现。这使得使用类进行代码重用变得困难。使用Hooks，我们还有许多不同的内置Hooks可以使用和需要了解。然而，它们不是组件特定的，可以随意重用于不同的组件。这是使用Hooks的关键动机。代码重用变得更容易，因为Hooks不与任何特定的类绑定。每个Hook都专注于提供特定的功能或功能，无论它在哪里使用。此外，如果我们努力构建自己的Hooks，我们也可以在适当的时候重用它们。
- en: Take a look at `Greeting` in the class-component project. How could we reuse
    the code in this component? Even if we could do this, it adds no real value or
    benefit. In addition to this, `getDerivedStateFromProps` adds complexity that
    may trigger a re-render. And we haven't even used any of the other lifecycle methods
    at all.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在类组件项目中查看`Greeting`。我们如何在这个组件中重用代码？即使我们可以做到这一点，它也没有真正的价值或好处。除此之外，`getDerivedStateFromProps`增加了可能触发重新渲染的复杂性。而且我们根本没有使用任何其他生命周期方法。
- en: Hook components and React in general prioritize componentization over inheritance.
    In fact, the React team states that it is a best practice to use components within
    other components as a means of sharing code instead of inheritance.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Hook组件和React总体上优先考虑组件化而不是继承。事实上，React团队表示，最佳实践是使用组件在其他组件中共享代码，而不是继承。
- en: So, to reiterate, lifecycle components are generally tied to a specific component,
    but Hooks can be used across components with a little work to properly generalize
    them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要重申一下，生命周期组件通常与特定组件绑定，但是通过一些工作，Hooks可以跨组件使用并适当地泛化它们。
- en: Simplicity
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单性
- en: Do you recall how large `Greeting` became once we added the `getDerivedStateFromProps`
    call into it? In addition, we always need a constructor to instantiate our state
    and use `bind` for all of our components. Since our components are simple, it
    didn't matter. But for production code, you'll see components with many functions
    that will all need `bind` calls put on them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得一旦我们在其中添加了`getDerivedStateFromProps`调用，`Greeting`变得多么庞大吗？此外，我们总是需要一个构造函数来实例化我们的状态，并为所有组件使用`bind`。由于我们的组件很简单，这并不重要。但是对于生产代码，你会看到许多函数的组件都需要进行`bind`调用。
- en: '`Greeting` in the hooks-component project was much simpler. Even when that
    component grows, the Hooks being called will mostly repeat, additionally making
    code easier to read.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在hooks-component项目中，`Greeting`要简单得多。即使该组件增长，调用的Hooks大部分都会重复，这还会使代码更易于阅读。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered a very large amount of information. We learned about class-based
    components and what makes them difficult to work with. We also learned about Hook-based
    components, which are simpler and easier to reuse.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的信息。我们了解了基于类的组件以及使它们难以使用的原因。我们还了解了基于Hook的组件，它们更简单，更容易重用。
- en: We now know the fundamentals of React programming. We can now create our own
    React components and begin building our application!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在了解了React编程的基础知识。我们现在可以创建自己的React组件并开始构建我们的应用程序！
- en: In the next chapter, we'll learn about the tooling around React. We'll combine
    the knowledge we gained here with the tooling information, and it will help us
    write clean, responsive code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于React周围的工具。我们将结合我们在这里获得的知识和工具信息，这将帮助我们编写干净、响应迅速的代码。
