- en: Service Registry and Discovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表和发现
- en: After handling core concerns in our distributed system through a gateway, we
    will now talk about service registry and discovery in this chapter. The more services
    we have, the more complicated it becomes to handle them using only predefined
    ports. In the previous chapter, we saw the gateway interacting with the service
    registry, which maintains the service location in a database. The client request
    is dispatched to service based on the information contained in a database. In
    this chapter, we will see how the service registry is populated, and in what ways
    services, clients, and gateways interact with it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网关处理我们分布式系统的核心问题后，我们现在将在本章中讨论服务注册表和发现。我们拥有的服务越多，仅使用预定义端口来处理它们就变得越复杂。在上一章中，我们看到网关与服务注册表进行交互，后者在数据库中维护服务位置。客户端请求根据数据库中的信息分派到服务。在本章中，我们将看到服务注册表是如何填充的，以及服务、客户端和网关如何与之交互。
- en: 'This chapter will commence by understanding service discovery, how the service
    registry is maintained dynamically, different ways of registering services in
    the registry, and pros and cons of each way. We will understand the end to end
    process of maintaining a service registry and how a service is discovered based
    on a registry. We will see the available options for designing a service registry,
    get acquainted with each of the steps, and then we will design our dynamic service
    registry using the best practices available. In this chapter, we will look at
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从理解服务发现开始，了解动态维护服务注册表的方式，注册服务到注册表的不同方式以及每种方式的利弊。我们将了解维护服务注册表的端到端流程，以及根据注册表发现服务的方式。我们将看到设计服务注册表的可用选项，熟悉每个步骤，然后使用可用的最佳实践设计我们的动态服务注册表。在本章中，我们将研究以下主题：
- en: Introduction to the service registry
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册表的介绍
- en: The what, why, and how of service registry and discovery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册表和发现的什么、为什么和如何
- en: Service discovery patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现模式
- en: Service registry patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册表模式
- en: Service registry and discovery options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册表和发现选项
- en: How to choose the service registry and discovery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择服务注册表和发现
- en: Introduction to the service registry
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表的介绍
- en: In this section, we will see the need for service discovery and the need for
    the service registry and try to understand the difference between service registry
    and discovery. We already have some of our shopping cart microservices set ups,
    but with core dependency on a network location that was static. Our code reads
    a value from a configuration file and on any change in the location of a service,
    we update it in our configurations. In the practical world, it is very difficult
    to maintain this as service instances are dynamically assigned locations. Moreover,
    service instances change dynamically based on the needs for autoscaling, failure
    handling, and updating process that is abstracted from a consumer client in the
    microservice world. Hence, clients need to use a more enhanced service discovery
    mechanism.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到服务发现的需求以及服务注册表的需求，并尝试理解服务注册表和发现之间的区别。我们已经设置了一些购物车微服务，但是核心依赖于静态的网络位置。我们的代码从配置文件中读取一个值，并在服务位置发生任何变化时，在我们的配置中进行更新。在实际世界中，很难维护这一点，因为服务实例是动态分配位置的。此外，服务实例根据自动扩展、故障处理和更新过程的需要动态变化，这些过程是在微服务世界中从消费者客户端中抽象出来的。因此，客户端需要使用更加强大的服务发现机制。
- en: 'Service discovery can be defined as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现可以定义为：
- en: A complete end to end process of registering services in a central place (API
    Gateway or database) and reaching out to targeted service of consuming via looking
    up in the service registry.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个中心位置（API网关或数据库）注册服务的完整端到端流程，并通过在服务注册表中查找来到达目标服务的消费。
- en: In the microservices world, different microservices are typically distributed
    in a **platform as a service** (**PaaS**) environment. The infrastructure is typically
    immutable as we usually have containers or immutable VM images. Services can usually
    scale up or down based on traffic and pre-fixed metrics. As everything is constantly
    dynamic, the exact address of the service may not be known until the service is
    ready to be used and deployed. This dynamic nature is one of the most important
    aspects to be handled in the microservice world. A logical and obvious solution
    is persisting these endpoints somewhere and that itself is the basis of a service
    registry. In this approach, each microservice registers with a central broker
    (the component that we saw in [Chapter 5](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml),
    *Understanding API Gateway*) and it provides all details about that microservice,
    such as the endpoint address, the contract details, the communication protocol,
    and so on. Consuming services usually query the broker to find the available location
    of a service at that point and then invoke it based on the location retrieved.
    Some of the commonly available options for this are Zookeeper, Consul, Netflix
    Eureka, and Kubernetes, which we will look at in much more detail soon.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，不同的微服务通常分布在平台即服务（PaaS）环境中。基础设施通常是不可变的，因为我们通常有容器或不可变的虚拟机镜像。服务通常可以根据流量和预设的指标进行扩展或缩减。由于一切都是不断变化的，直到服务准备好被使用和部署之前，服务的确切地址可能是未知的。这种动态性是微服务世界中需要处理的最重要的方面之一。一个逻辑和显而易见的解决方案是将这些端点持久化在某个地方，这本身就是服务注册表的基础。在这种方法中，每个微服务都向一个中央代理（我们在第5章中看到的组件，*理解API网关*）注册，并提供有关该微服务的所有详细信息，如端点地址、合同细节、通信协议等。消费服务通常会查询代理以查找该服务的可用位置，然后根据检索到的位置调用它。这方面一些常见的选项包括Zookeeper、Consul、Netflix
    Eureka和Kubernetes，我们很快将更详细地了解它们。
- en: What, why, and how of service registry and discovery
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表和发现的什么、为什么和如何
- en: After looking briefly at service registry, we will understand the what, why,
    and how of service registry and discovery in this section. From understanding
    the need for service discovery, we will then understand the process and components
    involved in that process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要了解了服务注册表之后，我们将在本节中了解服务注册和发现的原因、目的和方法。从理解服务发现的需求开始，然后了解涉及该过程的过程和组件。
- en: The why of service registry and discovery
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册和发现的原因
- en: Whatever container technology we go for, in production environments we will
    always have three four hosts and a number of containers inside each. In general,
    the way we distribute our services across all available hosts is totally dynamic
    and dependent on business capabilities, and can change at any point in time as
    hosts are just servers and they are not going to last forever. This is where service
    discovery and registry comes in. We need an external system that solves the limitations
    of a common web server, keeps an eye on all the services at all times, and maintains
    a combination of IP and port so that clients can seamlessly route to those service
    providers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择哪种容器技术，在生产环境中，我们总是会有三四个主机和每个主机内的多个容器。一般来说，我们在所有可用主机上分发我们的服务的方式是完全动态的，取决于业务能力，并且可以随时更改，因为主机只是服务器，它们不会永远持续下去。这就是服务发现和注册的作用。我们需要一个外部系统来解决常见Web服务器的限制，始终关注所有服务，并维护IP和端口的组合，以便客户端可以无缝地路由到这些服务提供者。
- en: 'To understand the need for service registry and discovery, we will take a classic
    example. Let''s say we have 10 instances of our product catalog microservice running
    on an arbitrary number of nodes. Now in order to have a resilient system, someone
    needs to keep track of those 10 nodes because whenever there would be a need to
    consume a product catalog service, at least one proper IP address or hostname
    should be available or else the consumer must query a central place where it can
    find the location of the product-catalog service. This approach very much resembles
    a DNS, the difference being that this is just for internal services to service
    communication. Most microservice-based architecture is dynamically moving. Services
    scale up and down based on development, depreciation, and traffic. Whenever a
    service endpoint changes, the registry needs to know about the change. The service
    registry is all about this: maintaining all information about how to reach every
    service.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解服务注册和发现的需求，我们将举一个经典的例子。假设我们有10个产品目录微服务的实例在任意数量的节点上运行。现在，为了拥有一个弹性系统，有人需要跟踪这10个节点，因为每当需要消费产品目录服务时，至少应该有一个正确的IP地址或主机名可用，否则消费者必须查询一个中央位置，找到产品目录服务的位置。这种方法非常类似于DNS，不同之处在于这只是用于内部服务之间的通信。大多数基于微服务的架构都是动态变化的。服务根据开发、折旧和流量进行扩展和缩减。每当服务端点发生变化时，注册表都需要知道这个变化。服务注册表就是为了维护关于如何到达每个服务的所有信息。
- en: There are lots of available tools in the market to solve this problem and as
    an architect, we need to decide the right tool based on our need. We need to consider
    factors such as how much automation can be done and how much control we have over
    the tool. There exist right from low-level tools such as Consul, to high-level
    tools such as Kubernetes or Docker swarm,which take care of advanced requirements
    such as load balancing containers and container scheduling capabilities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有很多可用的工具来解决这个问题，作为架构师，我们需要根据我们的需求来决定合适的工具。我们需要考虑诸如可以做多少自动化以及我们对工具有多少控制等因素。从低级工具如Consul到高级工具如Kubernetes或Docker
    swarm，都可以满足高级需求，比如负载均衡容器和容器调度能力。
- en: How service registry and discovery?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册和发现是如何工作的？
- en: 'Today, three basic approaches are prevalent for service registry and discovery:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，服务注册和发现有三种基本方法：
- en: 'The first rudimentary and preliminary approach is using existing DNS infrastructure.
    A well deployed DNS would be highly available and distributed. Examples of this
    approach include `httpd`, `confd`, `systemd`, and so on. In this approach, standard
    DNS libraries are used as registrar clients. Each microservice entry receives
    an entry in a DNS zone file and does a DNS lookup to connect to or locate a microservice.
    Another approach is using proxies such as NGINX, which periodically poll DNS for
    service discovery. The advantage of this approach includes being language agnostic:
    it works with any language with minimal or zero changes. However, it has several
    flaws, such as DNS does not provide a real-time view, managing new zone files
    on service registrations and deregistrations, and maintaining the high availability
    of this component for resiliency.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，最基本和初步的方法是使用现有的DNS基础设施。一个良好部署的DNS将是高度可用和分布式的。这种方法的例子包括`httpd`，`confd`，`systemd`等。在这种方法中，标准的DNS库被用作注册客户端。每个微服务条目在DNS区域文件中接收一个条目，并进行DNS查找以连接或定位微服务。另一种方法是使用诸如NGINX之类的代理，它们定期轮询DNS以进行服务发现。这种方法的优点包括语言不可知性：它可以与任何语言一起工作，几乎不需要或零改变。然而，它也有一些缺点，比如DNS不能提供实时视图，管理服务注册和注销时的新区域文件，以及维护此组件的高可用性以实现弹性。
- en: The second approach is more dynamic and more suitable to microservices using
    consistent key-value data stores such as Hashicorp's Consul, Apache Zookeeper,
    etcd, and so on. These tools are highly distributed systems. With the key-value
    store and sidecar pattern, it solves all the issues that we had while using DNS.
    This approach is meant to be completely transparent to any developer writing the
    code. A developer can write code in any programming language and not think of
    how microservices interact with other services. It has several limitations, such
    as sidecar being limited to service discovery of hosts and not more granular routes.
    It also adds extra latency by introducing an extra hop for every microservice.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法更加动态，更适合使用一致性键值数据存储的微服务，比如Hashicorp的Consul、Apache Zookeeper、etcd等。这些工具是高度分布式系统。通过键值存储和边车模式，解决了在使用DNS时遇到的所有问题。这种方法旨在对任何编写代码的开发人员完全透明。开发人员可以使用任何编程语言编写代码，而不必考虑微服务如何与其他服务交互。它也有一些限制，比如边车仅限于主机的服务发现，而不是更精细的路由。它还通过引入额外的跳跃为每个微服务增加了额外的延迟。
- en: The final approach for service discovery is adopting ready-made frameworks such
    as Netflix Eureka, specially designed and optimized for service discovery. This
    model exposes functionality directly to end developers.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现的最终方法是采用诸如Netflix Eureka之类的现成框架，专门为服务发现而设计和优化。这种模型直接向最终开发人员公开功能。
- en: Whichever tool we select, each of the microservices needs a central client to
    communicate for service discovery, whose main function is to allow service registration
    and resolution. Whenever a service starts, the service discovery uses the registration
    process to signal its availability to other services. Once available, other services
    use service resolution to locate the service on the network. The two processes
    involved around are as follows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无论选择哪种工具，每个微服务都需要一个中央客户端进行服务发现通信，其主要功能是允许服务注册和解析。每当一个服务启动时，服务发现就会使用注册过程向其他服务表明其可用性。一旦可用，其他服务就会使用服务解析来定位网络上的服务。涉及的两个过程如下。
- en: Service registration
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册
- en: On startup and shutdown, the service registers itself, or through third-party
    registration, a service registration client also sends constant heartbeats so
    that the client knows that the service is alive. A heartbeat is a message that
    is sent periodically to other services to say that the service is running and
    alive. They should be sent asynchronously or implemented as event-based, in order
    to avoid performance issues. Other approaches include polling the service constantly.
    The service registration stage is also responsible for setting the contract of
    the service, that is, service name, protocol, version, and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动和关闭时，服务会自行注册，或者通过第三方注册，服务注册客户端还会发送持续的心跳，以便客户端知道服务是活动的。心跳是定期发送给其他服务的消息，表明服务正在运行并且活动。它们应该是异步发送或者作为基于事件的实现，以避免性能问题。其他方法包括不断轮询服务。服务注册阶段还负责设置服务的契约，即服务名称、协议、版本等。
- en: Service resolution
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务解析
- en: This is the process of returning the network address of microservices. An ideal
    service discovery client has several critical features such as caching, failover,
    and load balancing. In order to avoid network latency when caching services, addresses
    are critical. The cache layer subscribes to updates from service discovery to
    ensure that it is always up to date. A typical microservice implementation layer
    is deployed in various locations for high availability; the service resolution
    client must know how to return the address of service instances based on load
    availability and other factors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是返回微服务的网络地址的过程。理想的服务发现客户端具有缓存、故障转移和负载均衡等关键功能。为了避免网络延迟，缓存服务地址至关重要。缓存层订阅来自服务发现的更新，以确保它始终是最新的。典型的微服务实现层部署在各个位置以实现高可用性；服务解析客户端必须知道如何根据负载可用性和其他因素返回服务实例的地址。
- en: The what of service registry and discovery
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册和发现的内容
- en: In this section, we will look at the what of service registry and discovery.
    We will see all aspects involved in a service registry and have a look at all
    the possible options involved regarding maintaining it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下服务注册和发现的内容。我们将看到服务注册的所有方面，并查看关于维护它的所有可能选项。
- en: Maintaining service registry
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护服务注册表
- en: 'In this section, we will see how a consumer ultimately finds a service provider.
    We will see all available approaches and look at the pros and cons of each option:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到消费者最终如何找到服务提供者。我们将看到所有可用的方法，并查看每个选项的利弊：
- en: '**Updation through sockets**: Regular polling soon becomes a problem as consumers
    are least concerned with registering themselves with the discovery service, and
    it also becomes painful for the discovery service to maintain a list of the consumers.
    A better solution would be for the client to open up a socket connection with
    the discovery service and continuously get an up-to-date list of all the service
    changes.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过套接字进行更新**：定期轮询很快就会成为一个问题，因为消费者最不关心向发现服务注册自己，对于发现服务来说，维护消费者列表也变得困难。更好的解决方案是客户端与发现服务建立套接字连接，并持续获取所有服务更改的最新列表。'
- en: '**Service discovery as a proxy**: This is more of a server-side implementation
    where logic for routing is present in the discovery service, making it not necessary
    for the clients to maintain any lists. They simply make outbound requests to the
    discovery service, which forwards the request to an appropriate service provider
    and returns the results to the providers.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现作为代理**：这更多是一个服务器端的实现，路由逻辑存在于发现服务中，使得客户端不需要维护任何列表。他们只需向发现服务发出出站请求，发现服务将请求转发给适当的服务提供者，并将结果返回给提供者。'
- en: Timely health checks
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 及时的健康检查
- en: 'There are two approaches for performing timely health checks for discovery.
    One method states that services should send a message to a centralized discovery
    service, whereas another method has the discovery service sending requests to
    the service providers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以进行及时的发现健康检查。一种方法是服务应该向集中式发现服务发送消息，而另一种方法是发现服务向服务提供者发送请求：
- en: '**Service polls registrar: **In this approach, a service provider actively
    sends messages at a predefined regular interval to the registrar discovery service.
    The discovery service keeps track of all the last time requests were received
    and considers a service provider dead if a certain time threshold has not been
    made.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务轮询注册器：**在这种方法中，服务提供者会定期向注册发现服务发送消息。发现服务会跟踪上次接收请求的时间，并且如果超过一定时间阈值，就会认为服务提供者已经失效。'
- en: '**Registrar polls service: **This is the approach where a central discovery
    service sends requests to the service providers. However, a shortcoming to this
    approach is that a centralized discovery service may get exhausted with the task
    of making so many outbound requests. Furthermore, if service providers disappear,
    then the registrar has to make a lot of failed health lookups, which would be
    network waste.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册器轮询服务：**这是一种中央发现服务向服务提供者发送请求的方法。然而，这种方法的一个缺点是，集中式发现服务可能会因为执行太多的出站请求而耗尽资源。此外，如果服务提供者消失，那么注册器就必须进行大量的失败健康查找，这将是网络资源的浪费。'
- en: Service discovery patterns
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现模式
- en: 'Discovery is the counterpart of service registry from the view of clients.
    Whenever a client wants to access a service, it must find details about the service,
    where it is located, and other contract information. This is typically done using
    two approaches, client-side discovery and server-side discovery. Service discovery
    can be briefly summarized as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 发现是客户端视角下的服务注册的对应物。每当客户端想要访问一个服务时，它必须找到关于服务的详细信息，它的位置以及其他合同信息。这通常使用两种方法来完成，即客户端发现和服务器端发现。服务发现可以简要总结如下：
- en: Microservices or consumers don't have any prior knowledge about the physical
    location of other services. They don't know when a service goes down or another
    node of the service is going up.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务或消费者对其他服务的物理位置没有任何先验知识。他们不知道服务何时下线或另一个服务节点何时上线。
- en: Services broadcast their existence and disappearance.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务广播它们的存在和消失。
- en: Services are able to other service instances based on other broadcasted metadata.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务能够基于其他广播的元数据找到其他服务实例。
- en: Instance failures are detected and any request to that failed node is prevented
    and is made invalid.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例故障会被检测到，并且任何对于失败节点的请求都会被阻止并作废。
- en: Service discovery is not a single point of failure.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现不是单点故障。
- en: In this section, we will both look at the patterns of service discovery and
    understand the pros and cons of each pattern.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究服务发现的模式，并了解每种模式的优缺点。
- en: Client-side discovery pattern
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端发现模式
- en: While using a client-side pattern, it is the client's or the gateway's duty
    to determine the location of a network of available service instances and also
    to load balance the requests among them. The client queries a service registry,
    which is nothing but a set of available service instances, stores its response,
    and then routes the request according to the location address in that response.
    The client uses some famous load balancing algorithms to choose one of the service
    instances and make a request to that instance. The physical network location of
    that service instance is registered with the registry whenever the service starts
    and deregistered when the service goes down. The service instance registration
    is refreshed using a heartbeat mechanism or polling or through sockets for real-time
    updates.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用客户端模式时，客户端或网关的职责是确定可用服务实例的位置，并在它们之间进行负载均衡。客户端查询服务注册表，这只是一组可用的服务实例，存储其响应，然后根据响应中的位置地址路由请求。客户端使用一些著名的负载平衡算法来选择一个服务实例，并向该实例发出请求。每当服务启动时，该服务实例的物理网络位置会在注册表中注册，并在服务关闭时注销。服务实例的注册会使用心跳机制、轮询或通过实时更新的套接字来刷新。
- en: '**Advantages:**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**优势：**'
- en: The pattern is pretty static except for the service registry, so it is a lot
    easier to maintain
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模式除了服务注册表之外相当静态，因此更容易维护
- en: As the client is aware of the service instance, the client can make intelligent,
    application-specific, situation-dependent load balancing decisions such as constantly
    using a hash
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于客户端知道服务实例，客户端可以做出智能的、特定于应用程序的、情境依赖的负载均衡决策，比如不断使用哈希
- en: '**Pain areas:**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**痛点：**'
- en: The client is tightly coupled to the service registry
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端与服务注册表紧密耦合
- en: There would be a need to implement client-side service discovery in every programming
    language and framework that is used by a service client
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在每种服务客户端使用的编程语言和框架中实现客户端服务发现
- en: A famous tool for client-side registration process is Netflix Eureka. It provides
    a REST API for managing service instance registrations and for querying available
    instances. A full list of APIs and available options can be found at [https://github.com/Netflix/eureka/wiki/Eureka-REST-operations](https://github.com/Netflix/eureka/wiki/Eureka-REST-operations),
    which has all available operations that can be done.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个著名的客户端注册工具是Netflix Eureka。它提供了一个用于管理服务实例注册和查询可用实例的REST API。可以在[https://github.com/Netflix/eureka/wiki/Eureka-REST-operations](https://github.com/Netflix/eureka/wiki/Eureka-REST-operations)找到完整的API列表和可用选项，其中包含所有可用的操作。
- en: Server-side discovery pattern
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端发现模式
- en: The counter approach to this is having a separate component for a registry,
    which is the server-side discovery pattern. In this approach, a client makes a
    request to the service through a load balancer in between. The load balancer then
    queries the service registry and routes each request to an available service instance
    to provide a service response to the consumer. A classic example of such an approach
    is an inbuilt AWS load balancer. An Amazon **Elastic Load Balancer** (**ELB**)
    is commonly used to handle the huge external traffic from the internet and load
    balance among the incoming traffic, but the use of an ELB goes way beyond this.
    An ELB can also be used to load balance traffic internal traffic to the VM. When
    a client makes a request to an ELB through its DNS, the ELB load balances the
    traffic among a set of registered EC2 instances or containers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的反对意见是为注册表单独设置一个组件，这就是服务器端发现模式。在这种方法中，客户端通过负载均衡器向服务发出请求。负载均衡器然后查询服务注册表，并将每个请求路由到可用的服务实例，以向消费者提供服务响应。这种方法的一个典型例子是内置的AWS负载均衡器。Amazon
    **弹性负载均衡器**（**ELB**）通常用于处理来自互联网的大量外部流量，并在传入流量中进行负载均衡，但ELB的用途远不止于此。ELB也可以用于将流量负载均衡到虚拟机的内部流量。当客户端通过其DNS向ELB发出请求时，ELB会将流量在一组注册的EC2实例或容器之间进行负载均衡。
- en: One of the approaches in maintaining server-side discovery is using a proxy
    on each host. This proxy plays the role of server-side discovery load balancer.
    A proxy transparently forwards the request to available service instances running
    anywhere on that server. Kubernetes runs on a similar approach. Some of the available
    tools are NGINX and Consul templates. These tools configure reverse proxying and
    reload NGINX or HAProxy servers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 维护服务器端发现的方法之一是在每个主机上使用代理。这个代理扮演着服务器端发现负载均衡器的角色。代理透明地将请求转发到服务器上任何地方运行的可用服务实例。Kubernetes采用了类似的方法。一些可用的工具是NGINX和Consul模板。这些工具配置了反向代理并重新加载NGINX或HAProxy服务器。
- en: 'Advantages of the server-side discovery pattern:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端发现模式的优势：
- en: Simpler code for client-side discovery on the server side as we don't have to
    write code for discovery in each service and it is totally abstracted from the
    client
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端的客户端发现中，代码更简单，因为我们不必为每个服务编写发现代码，而且它完全与客户端抽象无关
- en: Functionalities such as load balancing are taken care of through this approach
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过这种方法来处理负载均衡等功能
- en: 'Disadvantages of the server-side discovery pattern:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端发现模式的缺点：
- en: The router is yet another component that needs to be maintained on the server.
    If the environment is clustered, then it needs to be replicated everywhere.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器是另一个需要在服务器上维护的组件。如果环境是集群的，那么它需要在每个地方进行复制。
- en: Unless the router is a TCP router, the router should have support for protocols
    such as HTTP, RPC, and so on.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非路由器是TCP路由器，否则路由器应该支持诸如HTTP、RPC等协议。
- en: It needs more network hops compared to client-side discovery.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与客户端发现相比，它需要更多的网络跳数。
- en: 'Let''s look at both approaches in this diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这个图表中看看这两种方法：
- en: '![](img/a55feab0-118a-4e26-af33-9a55c0dccbd8.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a55feab0-118a-4e26-af33-9a55c0dccbd8.png)'
- en: Client-side vs server-side service discovery
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端与服务器端服务发现
- en: Service registry patterns
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表模式
- en: One of the key aspects of discovering services in a distributed system is service
    registry. The service registry is just a database that has all the network locations
    of service instances. As it contains crucial information, it must be highly available
    and stay up to date on an efficient system. Based on the system clients (in our
    case, API Gateway), we can even cache network locations obtained from the service
    registry. However, it must be updated on a daily basis, otherwise clients won't
    be able to discover service instances and communicate per service. A service registry,
    in order to be highly available, consists of clusters where a replication protocol
    is used to maintain consistency. The service registry saves the metadata of microservice
    instances, which includes things such as actual locations, host ports, communication
    protocol, and so on. Startup and shutdown processes of microservices are constantly
    monitored. In this section, we will look at service registry and common service
    registration options. We will look at the pros and cons of each approach.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中发现服务的一个关键方面是服务注册表。服务注册表只是一个包含所有服务实例的网络位置的数据库。由于它包含关键信息，因此必须在高效的系统上保持高可用性并保持最新。根据系统客户端（在我们的情况下是API网关），我们甚至可以缓存从服务注册表获取的网络位置。然而，它必须每天更新，否则客户端将无法发现服务实例并按服务进行通信。为了保持高可用性，服务注册表由集群组成，其中使用复制协议来保持一致性。服务注册表保存微服务实例的元数据，其中包括实际位置、主机端口、通信协议等。微服务的启动和关闭过程会不断受到监控。在本节中，我们将看看服务注册表和常见的服务注册选项。我们将分析每种方法的优缺点。
- en: All service instances must register and deregister from the central registry
    in order to have a fault tolerant system. There are various ways to handle this
    registration and deregistration process. One option is the service registry providing
    endpoints and the service instance registers itself, that is, self-registration.
    Another option is using some other system components to manage the registration
    of service instances. Let's dive deep into both of these patterns to understand
    them in detail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务实例必须在中央注册表中注册和注销，以建立一个容错系统。有各种方法来处理这个注册和注销的过程。一种选择是服务注册表提供端点，服务实例自行注册，即自注册。另一种选择是使用其他系统组件来管理服务实例的注册。让我们深入了解这两种模式的细节。
- en: Self-registration pattern
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自注册模式
- en: While using the self-registration process, a service instance itself is responsible
    for registering and deregistering within the service registry. Also, the service
    instance must constantly send heartbeat requests in order to let the registry
    know the status of the service. If the registry doesn't receive heartbeats, the
    registry can assume that the service no longer exists and can deregister or stop
    listening for that service. The self-registration pattern forces microservices
    to communicate with the service registry by themselves. Whenever a service goes
    up or down, it has to communicate with the registry to inform it of its status.
    Microservices deal with single concerns, so introducing yet another concern everywhere
    might be an extra burden and may seem an anti-pattern; however, it has the added
    advantage that a service maintains its own state model, knowing the current state,
    that is, **STARTING**, **AVAILABLE**, **SHUTDOWN**, without being dependent on
    any other third-party services.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用自注册过程时，服务实例本身负责在服务注册表中注册和注销。此外，服务实例必须不断发送心跳请求，以便让注册表知道服务的状态。如果注册表没有收到心跳，它可以假定服务不再存在，并注销或停止监听该服务。自注册模式迫使微服务自己与服务注册表通信。每当服务启动或关闭时，它都必须与注册表通信，告知其状态。微服务处理单一关注点，因此在任何地方引入另一个关注点可能是额外的负担，可能看起来是一种反模式；但是，它的优势在于服务维护自己的状态模型，知道当前状态，即**STARTING**，**AVAILABLE**，**SHUTDOWN**，而不依赖于任何其他第三方服务。
- en: A well-known example of a self-registration process is the Netflix OSS Eureka
    client. The Eureka client handles all aspects of client registration and deregistration.
    We will see a detailed implementation of Eureka in a later section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自注册过程的一个著名例子是Netflix OSS Eureka客户端。Eureka客户端处理客户端注册和注销的所有方面。我们将在后面的章节中看到Eureka的详细实现。
- en: 'Disadvantages of the self-registration pattern:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 自注册模式的缺点：
- en: The service is coupled to the service registry. It must constantly communicate
    with the server to tell it about the service's state.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该服务与服务注册表耦合。它必须不断与服务器通信，告诉它有关服务状态的信息。
- en: Service registry logic is not centralized and must be implemented in every language
    we have in the ecosystem.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册逻辑不是集中的，必须在我们生态系统中的每种语言中实现。
- en: Third-party registration pattern
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方注册模式
- en: When using a third-party registration process and service instances, microservices
    stick to the principle of single responsibility and are no longer responsible
    for registering themselves with the service registry. Instead, we introduce a
    new component in the system, *service registrar*, which handles the responsibility
    of maintaining service registry. The service registrar, in order to maintain the
    registry, keeps track of instances either by polling the environment or by subscribing
    to startup and shutdown events. Whenever it notices a newly available service,
    it registers the instance with the registry. Likewise, if it fails to receive
    health checks, then it deregisters that service from the registry. Unlike the
    self-registration pattern, the microservice code is far less complex as it is
    not responsible for registering itself, but it has drawbacks too. If the registrar
    is not selected carefully, it becomes yet another component that has to be installed,
    configured, maintained, and highly available since it is a critical component
    of the system. Third-party registration is normally the preferred choice in industry
    as it automatically manages the registry. Additional data required for the registry
    can be provided in the form of policies or contracts, which can be updated in
    the database. Tools such as Apache Zookeeper or Netflix Eureka, in combination
    with others, are widely used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用第三方注册过程和服务实例时，微服务遵循单一责任原则，不再负责向服务注册表注册自己。相反，我们在系统中引入一个新组件，*服务注册器*，它负责维护服务注册表。为了维护注册表，服务注册器通过轮询环境或订阅启动和关闭事件来跟踪实例。每当它注意到一个新的可用服务时，它就会将该实例注册到注册表中。同样，如果它无法收到健康检查，那么它就会从注册表中注销该服务。与自注册模式不同，微服务代码要简单得多，因为它不负责注册自己，但它也有缺点。如果注册器没有经过精心选择，它就会成为必须安装、配置、维护和高可用的另一个组件，因为它是系统的关键组件。在工业界，第三方注册通常是首选，因为它可以自动管理注册表。注册表所需的额外数据可以以策略或合同的形式提供，并可以在数据库中更新。Apache
    Zookeeper或Netflix Eureka等工具通常与其他工具结合使用。
- en: Third-party registration has various advantages. Say a service goes down, a
    third-party registrar can take appropriate action such as providing safe fallbacks,
    triggering a self-repair mechanism, and so on. If there is heavy traffic on a
    service, the registry process can automatically add a new endpoint by requesting
    a new instantiation of that microservice. These health checks performed on services
    can help in auto-deregistering to stop the failure cascading to the entire system.
    A well-known example is Registrator, which we are going to see later in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方注册有各种优势。比如，如果一个服务宕机，第三方注册器可以采取适当的措施，如提供安全回退，触发自我修复机制等。如果某个服务的流量很大，注册过程可以通过请求新的微服务实例自动添加新的端点。对服务执行的这些健康检查可以帮助自动注销，以阻止故障级联到整个系统。一个著名的例子是Registrator，我们将在本章后面看到。
- en: 'Some of the famous available examples of third-party registration patterns
    include:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些著名的第三方注册模式的例子包括：
- en: '**Netflix Prana: **Outsourced by Netflix, Netflix OSS Prana is especially for
    non-JVM languages. It is an implementation of the sidecar pattern, which runs
    side by side with service instances and exposes them over HTTP. Prana registers
    and deregisters service instances over HTTP with Netflix Eureka.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix Prana：由Netflix外包，Netflix OSS Prana专门针对非JVM语言。它是边车模式的实现，与服务实例并行运行，并通过HTTP公开它们。Prana使用HTTP与Netflix
    Eureka注册和注销服务实例。
- en: '**Built-in components such as the ELB:** Most deployment environments have
    inbuilt components. EC2 instances created automatically through scaling are automatically
    registered to the ELB. Similarly, Kubernetes services are automatically registered
    and made available for discovery (we will look at this in more detail in the scaling
    section of [Chapter 10](ccd4f3a3-dcbc-4cf9-ae9b-3e1b55206644.xhtml), *Hardening
    Your Application*).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置组件，如ELB：**大多数部署环境都有内置组件。通过自动扩展创建的EC2实例会自动注册到ELB。同样，Kubernetes服务会自动注册并可供发现（我们将在[第10章](ccd4f3a3-dcbc-4cf9-ae9b-3e1b55206644.xhtml)的扩展部分中更详细地了解这一点，*加固您的应用*）。'
- en: 'Advantages of the third-party registration pattern are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方注册模式的优势如下：
- en: The code is less complex as each service doesn't have to write code for registering
    and deregistering itself
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码较少复杂，因为每个服务不必为自己的注册和注销编写代码
- en: The central registrar also contains code for performing health checks and this
    doesn't need to be replicated everywhere
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央注册器还包含执行健康检查的代码，这不需要在所有地方复制。
- en: 'Disadvantages of third-party registration pattern are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方注册模式的缺点如下：
- en: Unless it is provided by a service discovery tool, it is yet another component
    that needs to be maintained and made highly available
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非由服务发现工具提供，否则它是另一个需要维护并保持高可用性的组件
- en: Service registry and discovery options
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册和发现选项
- en: In this section, we will look at some of the commonly available options in the
    market for service discovery and registry. Options range right from low-level
    solutions providing a high degree of control to the architect (etcd from CoreOS
    and Consul from HashiCorp) to high-end solutions providing container scheduling
    solutions (Kubernetes from Google, Docker swarm, and so on). In this section,
    we will understand various options and look at the pros and cons of each.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究市场上一些常见的服务发现和注册选项。选项范围从提供高度控制的低级解决方案（如CoreOS的etcd和HashiCorp的Consul）到提供容器调度解决方案的高端解决方案（如Google的Kubernetes、Docker
    swarm等）。在本节中，我们将了解各种选项，并查看每种选项的优缺点。
- en: Eureka
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eureka
- en: Eureka is a service registry and discovery framework outsourced by Netflix with
    a need for primary usage of locating services for the purpose of load balancing
    and failover for any middle-tier servers. In this section, we will look at service
    discovery and registry using Eureka.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka是由Netflix外包的服务注册和发现框架，需要主要用于定位服务以进行负载平衡和故障转移。在本节中，我们将使用Eureka进行服务发现和注册。
- en: 'The overall Eureka architecture consists of two components: the Eureka server
    and client. The Eureka server is a standalone server application that is responsible
    for:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 整体Eureka架构由两个组件组成：Eureka服务器和客户端。Eureka服务器是一个独立的服务器应用程序，负责：
- en: Managing a registry of service instances
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理服务实例的注册表
- en: Providing the means to register any service, deregister any microservice, and
    query instances as part of service discovery
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供注册任何服务、注销任何微服务和查询实例作为服务发现的一部分的手段
- en: Registry propagation of instances to other Eureka servers and clients provides
    a mechanism similar to heartbeats to constantly monitor services
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实例的注册传播到其他Eureka服务器和客户端，提供类似心跳的机制来不断监视服务
- en: 'The Eureka client is a part of an ecosystem and has the following responsibilities:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka客户端是生态系统的一部分，具有以下责任：
- en: Register and unregister bound microservices with the Eureka server on processes
    such as startup, shutdown, and so on
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动、关闭等过程中向Eureka服务器注册和注销绑定的微服务
- en: Keep the connection alive with the Eureka server by constantly sending heartbeats
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过不断发送心跳来保持与Eureka服务器的连接
- en: Retrieve other service instance information, cache it, and update it on a daily
    basis
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索其他服务实例信息，缓存并每天更新
- en: 'We will be using the following terminology in Eureka frequently:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将经常在Eureka中使用以下术语：
- en: '| **Eureka server** | It is the discovery server. It has a registry of all
    services with their current state by means of registering and deregistering any
    service, and APIs for discovering any service. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **Eureka服务器** | 它是发现服务器。它通过注册和注销任何服务以及发现任何服务的API来拥有所有服务的注册表及其当前状态。|'
- en: '| **Eureka service** | Anything that is found in Eureka service registry and
    anything that is registered for others and is meant to be discovered. Each service
    has a logical identifier that can refer to the instance ID of that application
    and it is called the VIP or service ID. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **Eureka服务** | Eureka服务注册表中发现的任何内容，以及为其他服务注册并且意图被发现的任何内容。每个服务都有一个逻辑标识符，可以引用该应用程序的实例ID，称为VIP或服务ID。|'
- en: '| **Eureka instance** | Any application that registers with the Eureka server
    so that it can be discovered by other services. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **Eureka实例** | 注册到Eureka服务器的任何应用程序，以便其他服务可以发现它。|'
- en: '| **Eureka client** | Any microservice application that can register and discover
    any microservice. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **Eureka客户端** | 可以注册和发现任何微服务的任何微服务应用程序。|'
- en: In this section, we will set up the Eureka server register a sample microservice
    with the Eureka server, and find the location of that microservice in our other
    microservice. So, let's get started.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置Eureka服务器注册一个示例微服务，并在其他微服务中找到该微服务的位置。所以，让我们开始吧。
- en: Setting up the Eureka server
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Eureka服务器
- en: The Eureka server is a Netflix OSS product and a service discovery pattern implementation
    where every microservice is registered and a client looks up on the server to
    get dependent microservices. A Eureka server runs on the JVM platform, so we will
    directly use an available template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka服务器是Netflix OSS产品，是一种服务发现模式的实现，其中每个微服务都注册，客户端在服务器上查找依赖的微服务。Eureka服务器在JVM平台上运行，因此我们将直接使用可用模板。
- en: To run a Eureka server, you will need Java 8 and Maven set up.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Eureka服务器，您需要安装Java 8和Maven。
- en: 'Let''s take a look at the steps to set up Eureka server:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看设置Eureka服务器的步骤：
- en: Go to the `eureka` folder inside the extracted source code for this chapter.
    You will find a ready-to-use Java project for Eureka server named `euraka-server`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到本章节的提取源代码中的`eureka`文件夹。您将找到一个名为`euraka-server`的Eureka服务器的现成Java项目。
- en: 'Inside the root directory, open up the Terminal and run the following command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录中，打开终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should see dependencies getting installed and at the end, you will get a
    message confirming a successful build and that your `target` folder is generated.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到依赖项正在安装，最后，您将收到一条确认成功构建的消息，并生成`target`文件夹。
- en: Open the `target` folder, inside which you will be able to see Eureka server
    `.jar` file (`demo-service-discovery-0.0.1-SNAPSHOT.jar`).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`target`文件夹，您将能够看到Eureka服务器的`.jar`文件(`demo-service-discovery-0.0.1-SNAPSHOT.jar`)。
- en: 'Open up a Terminal and hit the following command. You should see your server
    startup:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并输入以下命令。您应该会看到服务器启动：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output for the preceding command is shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述命令的输出截图：
- en: '![](img/752cdf41-7b07-4a3f-952b-110ad52026d5.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/752cdf41-7b07-4a3f-952b-110ad52026d5.png)'
- en: Starting up Spring Eureka server
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Spring Eureka服务器
- en: 'Hit `http://localhost:9091/` and you should be able to see Eureka server started.
    You should see something like this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`http://localhost:9091/`，您应该能够看到Eureka服务器已启动。您应该会看到类似于这样的内容：
- en: '![](img/27767950-8a0c-4e57-94c0-57b1596cbd3b.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27767950-8a0c-4e57-94c0-57b1596cbd3b.png)'
- en: Spring Eureka server
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Eureka服务器
- en: Now that we have started Eureka server, we will register our services with it.
    We will be able to see our service under Instances currently registered with Eureka
    after registering with Eureka server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了Eureka服务器，我们将向其注册我们的服务。在注册到Eureka服务器后，我们将能够在Eureka当前注册的实例下看到我们的服务。
- en: Registering with Eureka server
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Eureka服务器注册
- en: 'Now that our Eureka server is up and running and ready to accept the registration
    of microservices, we will register a demo microservice and see it on the Eureka
    dashboard. You can follow along with the source code attached to the source files
    (`first-microservice-register`). Let''s get started:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Eureka服务器已经启动并准备好接受微服务的注册，我们将注册一个演示微服务并在Eureka仪表板上看到它。您可以跟随源文件中附带的源代码(`first-microservice-register`)。让我们开始吧：
- en: Pull up our first microservice code from [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing
    up for the Journey*. We will be using the `eureka-js-client` ([https://www.npmjs.com/package/eureka-js-client](https://www.npmjs.com/package/eureka-js-client))
    module in the project, which is a JavaScript implementation of Netflix OSS Eureka.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)中提取我们的第一个微服务代码，*为旅程做准备*。我们将在项目中使用`eureka-js-client`([https://www.npmjs.com/package/eureka-js-client](https://www.npmjs.com/package/eureka-js-client))模块，这是Netflix
    OSS Eureka的JavaScript实现。
- en: 'Open up a Terminal and install `eureka-js-client`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并安装`eureka-js-client`：
- en: '[PRE2]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we will install the types of `eureka-js-client` to be used in our TypeScript
    project. At the time of writing, the types available in the `DefinitelyTyped`
    repository were not up to date. So, we will now write our custom types.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将安装`eureka-js-client`的类型，以在我们的TypeScript项目中使用。在撰写本文时，`DefinitelyTyped`存储库中的类型尚未更新。因此，我们现在将编写我们自定义的类型。
- en: Create a folder, `custom_types`, and inside it add `eureka-js-client.d.ts`.
    Copy the contents either from attached source code or from my gist at [https://gist.github.com/insanityrules/7461385aa561db5835c5c35279eb12bf](https://gist.github.com/insanityrules/7461385aa561db5835c5c35279eb12bf)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`custom_types`的文件夹，并在其中添加`eureka-js-client.d.ts`。可以从附加的源代码或我的gist（[https://gist.github.com/insanityrules/7461385aa561db5835c5c35279eb12bf](https://gist.github.com/insanityrules/7461385aa561db5835c5c35279eb12bf)）中复制内容
- en: 'Next, we will register our Express app with Eureka. Open `Application.ts` and
    inside it write the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用Eureka注册我们的Express应用程序。打开`Application.ts`并在其中编写以下代码：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What did we just do? Have a look at the following points for a better understanding:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做了什么？请查看以下要点，以便更好地理解：
- en: We registered our app instance named `hello-world-chapter-6` with a key, `myvip`,
    and data center, `myOwn`, with Eureka
  id: totrans-136
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用名称为`hello-world-chapter-6`的应用实例注册了一个名为`myvip`的键和数据中心`myOwn`到Eureka
- en: We provided `statusPageURL` and `IpAddress`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提供了`statusPageURL`和`IpAddress`
- en: We added Eureka information with host, port, and service paths
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了Eureka信息，包括主机、端口和服务路径
- en: The full list of configurations can be found here ([https://www.npmjs.com/package/eureka-js-client](https://www.npmjs.com/package/eureka-js-client))
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在此处找到完整的配置列表([https://www.npmjs.com/package/eureka-js-client](https://www.npmjs.com/package/eureka-js-client))
- en: 'Next, we will start with the client; just add the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从客户端开始；只需添加以下内容：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our register is all ready; we can now start our service with `npm start`. Now,
    navigate to `localhost:9091` to check the server instances:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的注册已经准备就绪；现在我们可以使用`npm start`启动我们的服务。现在，转到`localhost:9091`检查服务器实例：
- en: '![](img/6c317192-06e7-4606-b2f3-5b3c95d2ba77.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c317192-06e7-4606-b2f3-5b3c95d2ba77.jpg)'
- en: Service registered in Eureka server
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eureka服务器中注册的服务
- en: 'Our service will constantly fetch service registries and send heartbeats to
    tell that service is running. Let''s stop and deregister the service when our
    microservice is killed. Just add the following code to `Application.ts`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的服务将不断获取服务注册表并发送心跳以告知服务正在运行。当我们的微服务被终止时，让我们停止并注销服务。只需将以下代码添加到`Application.ts`中：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that our service is synced with Eureka, in the next section we will see
    how to discover a service.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务已与Eureka同步，在下一节中我们将看到如何发现服务。
- en: Discovering with Eureka server
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eureka服务器进行发现
- en: In this section, we will discover our register service in another microservice.
    We will be getting a response from that service without knowing the service address
    or hardcoding the location anywhere. Copy the structure of `first-microservice`
    from [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing up for
    the Journey*. As we will need Eureka client everywhere, we will create `EurekaService.ts`.
    You can find the full source code in the `eureka/eureka-service-discovery/src`
    folder of the project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在另一个微服务中发现我们注册的服务。我们将从该服务获取响应，而不知道服务地址或在任何地方硬编码位置。从[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)中复制`first-microservice`的结构，*为旅程做准备*。由于我们将在各处需要Eureka客户端，我们将创建`EurekaService.ts`。您可以在项目的`eureka/eureka-service-discovery/src`文件夹中找到完整的源代码。
- en: 'Let''s take a look at the steps to discover our registered service:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看发现我们注册服务的步骤：
- en: 'Create a file called `EurekaService.ts`, and create static methods for initializing
    clients:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EurekaService.ts`的文件，并创建用于初始化客户端的静态方法：
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In `Application.ts`, start your client and add stop processes as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Application.ts`中，启动您的客户端并添加停止进程如下：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In our `HelloWorld.ts` we will call the service from `first-microservice-register`
    and fetch its response. We won''t hardcode locations. Add the following LOCs in
    `HelloWorld.ts`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`HelloWorld.ts`中，我们将调用`first-microservice-register`中的服务并获取其响应。我们不会硬编码位置。在`HelloWorld.ts`中添加以下LOCs：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we selected the protocol, port, and IP address from our service
    registry.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们从我们的服务注册表中选择了协议、端口和IP地址。
- en: Run your application and you will be able to see the response from `first-microservice-register`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序，您将能够看到来自`first-microservice-register`的响应。
- en: Key points for Eureka
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eureka的关键点
- en: 'After this exercise on Eureka service registry and discovery, let''s take a
    look at some salient points on Eureka:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行Eureka服务注册和发现的练习之后，让我们来看看Eureka的一些要点：
- en: Eureka consists of a server component and a client-side component. The server
    component is the one that all microservices communicate with. They register their
    availability by constantly sending out heartbeats. The consuming services also
    use server components for discovering services.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eureka包括服务器组件和客户端组件。服务器组件是所有微服务通信的组件。它们通过不断发送心跳来注册其可用性。消费服务还使用服务器组件来发现服务。
- en: When a microservice is bootstrapped using our Eureka service, it reaches out
    to the Eureka server and broadcasts its existence with contract details. After
    registration, the service endpoint sends heartbeat requests every 30 seconds to
    renew its lease period. If a service endpoint fails to do so a certain number
    of times, it gets taken out of service registry.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用我们的Eureka服务引导微服务时，它会联系Eureka服务器并广播其存在以及合同细节。注册后，服务端点每30秒发送心跳请求以更新其租约期。如果服务端点未能这样做一定次数，它将从服务注册表中移除。
- en: 'You can enable debug logs by setting either of the following options:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过设置以下选项之一来启用调试日志：
- en: '`NODE_DEBUG=request`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NODE_DEBUG=request`'
- en: '``client.logger.level(''debug'');``'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``client.logger.level(''debug'');``'
- en: The client constantly fetches the registry at every predefined point and caches
    it. Hence, when it wants to discover another service, the extra network hop is
    prevented.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端不断地在每个预定义的点获取注册表并对其进行缓存。因此，当它想要发现另一个服务时，就可以防止额外的网络跳跃。
- en: Eureka client provides a list of available services with options to provide
    them by hostname or instance name.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eureka客户端提供了可用服务的列表，并提供了按主机名或实例名提供它们的选项。
- en: Eureka server is zone aware. Zone information can be supplied when registering
    a service in the same zone. To further introduce a load balancer, we can use a
    resilient client ([https://www.npmjs.com/package/resilient](https://www.npmjs.com/package/resilient))
    which is equivalent to Netflix Ribbon.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eureka服务器具有区域感知功能。在相同区域注册服务时可以提供区域信息。为了进一步引入负载均衡器，我们可以使用一个等同于Netflix Ribbon的弹性客户端([https://www.npmjs.com/package/resilient](https://www.npmjs.com/package/resilient))。
- en: It has options for a health check, status page, registering, deregistering,
    maximum number of retries, and so on.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有健康检查、状态页面、注册、注销、最大重试次数等选项。
- en: Eureka is a classic example of a server-side client registry and self-registration
    option.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eureka是服务器端客户端注册和自注册选项的典型示例。
- en: Consul
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Consul
- en: Another option we have for service registry and discovery is HashiCorp Consul
    ([https://www.consul.io/](https://www.consul.io/)). Consul is an open source implementation
    of a distributed key-value store and other service discovery and registry features.
    It can run either as the master or as an agent. The master orchestrates the whole
    network and maintains the registry. A Consul agent acts as a proxy to the master
    and forwards all requests to the master. In this section, we will understand service
    discovery and registry using Consul.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于服务注册和发现的另一个选项是HashiCorp Consul ([https://www.consul.io/](https://www.consul.io/))。Consul是分布式键值存储和其他服务发现和注册功能的开源实现。它可以作为主节点或代理运行。主节点编排整个网络并维护注册表。Consul代理充当主节点的代理，并将所有请求转发到主节点。在本节中，我们将了解使用Consul进行服务发现和注册。
- en: In this exercise, we will do service registry and discovery using Consul. We
    will look at ways of self-registering/deregistering using Consul. Let's get started;
    we'll be using Linux OS in this exercise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Consul进行服务注册和发现。我们将看看使用Consul进行自注册/注销的方法。让我们开始吧；在这个练习中，我们将使用Linux操作系统。
- en: Setting up the Consul server
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Consul服务器
- en: 'Let''s take a look at the steps to set up Consul sever:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看设置Consul服务器的步骤：
- en: 'Setting up Consul server is pretty straightforward. Just download the executable
    from [https://www.consul.io/downloads.html](https://www.consul.io/downloads.html) and
    unzip it to the location of your choice. After unzipping, hit the following command
    to make it available to the binary executions:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Consul服务器非常简单。只需从[https://www.consul.io/downloads.html](https://www.consul.io/downloads.html)下载可执行文件，并将其解压缩到您选择的位置。解压缩后，输入以下命令使其可用于二进制执行：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Test your Consul installation by opening up a Terminal and typing `consul -v`;
    you should be able to see version 1.0.7.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开终端并输入`consul -v`来测试您的Consul安装；您应该能够看到版本1.0.7。
- en: 'Now, we will open Consul UI terminal. Consul comes by default with a UI dashboard;
    to start the Consul terminal with a UI dashboard, hit the following command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将打开Consul UI终端。Consul默认带有一个UI仪表板；要启动带有UI仪表板的Consul终端，请输入以下命令：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open up `localhost:8500`; you should be able to see something like this:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`localhost:8500`；您应该能够看到类似于这样的东西：
- en: '![](img/f80d0fe1-1a21-440a-931b-9d1e4cb7e0af.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f80d0fe1-1a21-440a-931b-9d1e4cb7e0af.png)
- en: Consul server
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Consul服务器
- en: We have successfully started Consul server; next we will register some services
    inside Consul.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功启动了Consul服务器；接下来我们将在Consul中注册一些服务。
- en: Talking with Consul server
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Consul服务器交谈
- en: 'Like Eureka, Consul has also exposed some REST endpoints that can be used to
    interact with the Consul server. In this section, we will see how to:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与Eureka一样，Consul也暴露了一些REST端点，可以用来与Consul服务器交互。在本节中，我们将看到如何：
- en: Register a service instance
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册服务实例
- en: Send heartbeats and do a health check
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送心跳并进行健康检查
- en: Deregister a service instance
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注销服务实例
- en: Subscribe to updates
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅更新
- en: Registering a service instance
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册服务实例
- en: 'Let''s start by taking clones of the first microservice from [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml),
    *Gearing up for the Journey*. You can find the entire source code in the `chapter-6/consul/consul-producer`
    folder:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)的第一个微服务开始克隆，*为旅程做准备*。您可以在`chapter-6/consul/consul-producer`文件夹中找到整个源代码：
- en: 'Open up the Terminal and hit the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并输入以下命令：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now in `Application.ts`, we will initialize our Consul client. Write this code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`Application.ts`中，我们将初始化我们的Consul客户端。写下这段代码：
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we will register our service with Consul:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在Consul中注册我们的服务：
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the program and you should be able to see successful logs. You will be
    able to see output similar to the following:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，您应该能够看到成功的日志。您将能够看到类似以下的输出：
- en: '![](img/f200cf26-9b2b-44ce-9acf-950dc9d45f23.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f200cf26-9b2b-44ce-9acf-950dc9d45f23.png)
- en: Service registry with Consul and Consul dashboard
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与Consul和Consul仪表板的服务注册
- en: Sending heartbeats and doing a health check
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送心跳并进行健康检查
- en: 'Now, we will add one scheduler that constantly sends heartbeats to tell our
    Consul server that it is active. In the same code as the previous exercise, just
    add the following lines of code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个调度程序，不断发送心跳以告诉我们的Consul服务器它是活动的。在与上一个练习相同的代码中，只需添加以下代码行：
- en: '[PRE14]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What did we do?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: Every five seconds, we send out heartbeats to Consul, to ensure that our service
    with the `CONSUL_ID` that we generated is active.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每五秒钟，我们向Consul发送心跳，以确保我们生成的`CONSUL_ID`的服务是活动的。
- en: Periodic heartbeats are sent out to make sure that Consul knows that our service
    is active and it doesn't disconnect our service. Earlier, we kept TTL values in
    our settings as 10 seconds, which means that if Consul server doesn't receive
    heartbeats after 10 seconds, it will assume that the service is down.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期心跳被发送出去，以确保Consul知道我们的服务是活动的，并且不会断开我们的服务。早些时候，我们在设置中保留了TTL值为10秒，这意味着如果Consul服务器在10秒后没有收到心跳，它将假定服务已经停止。
- en: A higher TTL value means that Consul will know very late when the application
    is dead or unable to serve requests. A short TTL value, on the other hand, means
    that we are sending too much data over the network, which can flood Consul, so
    this value should be selected carefully.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较高的TTL值意味着Consul将在应用程序死亡或无法提供请求时知道得很晚。另一方面，较短的TTL值意味着我们在网络上传输了太多数据，这可能会淹没Consul，因此这个值应该谨慎选择。
- en: You always need to pass a unique ID, so in this exercise, we generated UUID
    and mixed host and port with it.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您总是需要传递一个唯一的ID，所以在这个练习中，我们生成了UUID，并将主机和端口混合在一起。
- en: 'The health check API is available over HTTP. All we have to do is hit the following:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查API可通过HTTP获得。我们所要做的就是输入以下内容：
- en: '[PRE15]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Deregistering an application
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注销应用程序
- en: 'In this section, we will deregister our application whenever the server terminates
    or someone kills the server. This ensures that Consul doesn''t have to wait until
    the TTL period to actually know that the service is down. Simply add the following
    lines of code in `Application.ts`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在服务器终止或有人杀死服务器时注销我们的应用程序。这确保Consul不必等到TTL期限才真正知道服务已经停止。只需在`Application.ts`中添加以下代码行：
- en: '[PRE16]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, when you check Consul server when you gracefully kill the application,
    you won't be able to see our Consul producer registered.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您在优雅地终止应用程序时检查Consul服务器时，您将无法看到我们的Consul生产者已注册。
- en: Subscribing to updates
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅更新
- en: 'Just like Eureka, we will constantly get the Consul registry, so whenever we
    need to communicate to another registry we won''t need to make another registry
    call, as the registry is already cached at our end. Consul takes care of this
    by providing a feature called `watch`. Responses to a service will have an index
    number, which can be used for future requests to compare. They are nothing but
    a cursor to keep track of where we have left off. Let''s add watchers to our application:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Eureka一样，我们将不断获取Consul注册表，所以每当我们需要与另一个注册表通信时，我们就不需要进行另一个注册表调用，因为注册表已经在我们这边缓存了。Consul通过提供一个名为`watch`的功能来处理这个问题。对服务的响应将有一个索引号，可以用于将来的请求进行比较。它们只是一个用来跟踪我们离开的位置的光标。让我们向我们的应用程序添加观察者：
- en: 'Create a new watcher by adding the following code. Here, we have created a
    watcher on the service named `data` in Consul:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码来创建一个新的观察者。在这里，我们在Consul中的名为`data`的服务上创建了一个观察者：
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we will add a change event on our watcher, so whenever it receives new
    updates we will just cache the registry for our service data. Create one array
    and persist the entries that it receives while watching:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的观察者上添加一个更改事件，所以每当它接收到新的更新时，我们将只是缓存我们的服务数据的注册表。创建一个数组，并在观察时持久化它接收到的条目：
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add an error handler:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个错误处理程序：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That''s it. Now, run the program using `npm start` and register another service
    with the name `data` (the steps are the same as registering a new service). Then,
    you should be able to see output like the following:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。现在，使用`npm start`运行程序，并使用名称`data`注册另一个服务（注册新服务的步骤与注册新服务相同）。然后，您应该能够看到以下输出：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That's it. We just did service registry and interacted with Eureka server. Whenever
    the data service goes down, this value will also be dynamically updated. Now that
    we have the dynamic address and port, we can use it anytime to discover the location
    of services.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们刚刚进行了服务注册，并与Eureka服务器进行了交互。每当数据服务关闭时，此值也将动态更新。现在我们有了动态地址和端口，我们随时可以使用它来发现服务的位置。
- en: Key points for Consul
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Consul的关键点
- en: 'After completing the exercise on Consul, let''s now summarize the key points
    for Consul:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了对Consul的练习后，现在让我们总结一下Consul的关键点：
- en: Consul works on the gossip protocol (tell everyone who is alive and has been
    in constant touch with others) to form dynamic clusters.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Consul使用gossip协议（告诉每个活着并与其他人保持不断联系的人）来形成动态集群。
- en: It has an inbuilt key-value store that not only stores data, but is also used
    to register watches, which can be used for a number of tasks, such as notifying
    others about data changes, running different health checks, and some custom commands
    depending on use cases.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它具有内置的键值存储，不仅存储数据，还用于注册观察，可用于许多任务，如通知其他人有关数据更改、运行不同的健康检查以及根据用例运行一些自定义命令。
- en: Service discovery is embedded, so we do not need any third-party tools. It has
    inbuilt features such as health checks, watches, and so on.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务发现是内置的，因此我们不需要任何第三方工具。它具有内置功能，如健康检查、观察等。
- en: It has out-of-the-box support for multiple data centers, and the gossip protocol
    works across all data centers as well. It can also be used to discover information
    about other deployed services and nodes on which they reside. It has inbuilt health
    checks, TTLs, and custom command support where we can add our own middleware functions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有对多个数据中心的开箱即用支持，gossip协议也适用于所有数据中心。它还可以用于发现有关其他部署服务和它们所在节点的信息。它具有内置的健康检查、TTL和自定义命令支持，我们可以在其中添加自己的中间件函数。
- en: Registrator
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Registrator
- en: While Consul seems a great alternative for service discovery and registration,
    there is quite a big drawback where each service needs to maintain their startup
    and shutdown codes, which seems like quite a lot of duplicated code everywhere.
    We need a tool that auto-registers a service to the Consul server based on listening
    to their startup and shutdown events. Registrator is just the right tool for that.
    It is a service registry bridge for Docker with options to plug adapters as per
    the need. Registrator automatically registers and deregisters services when they
    come online or go dead. It has pluggable options for service registries, meaning
    it can be used with various other service registry clients such as Consul, etcd,
    and more.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Consul似乎是服务发现和注册的一个很好的选择，但存在一个相当大的缺点，即每个服务都需要维护它们的启动和关闭代码，这似乎在各处都有相当多的重复代码。我们需要一个工具，根据监听它们的启动和关闭事件，自动将服务注册到Consul服务器。Registrator正是这样的工具。它是一个用于Docker的服务注册桥接器，具有根据需要插入适配器的选项。当服务上线或下线时，Registrator会自动注册和注销服务。它具有可插拔的服务注册选项，这意味着它可以与各种其他服务注册客户端一起使用，如Consul、etcd等。
- en: 'Let''s get started with using Registrator. In this exercise, we will use service
    registry for Consul, plug it into Registrator, and then start a service and let
    Registrator autoregister it in Consul server:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用Registrator。在这个练习中，我们将使用Consul的服务注册表，将其插入Registrator，然后启动一个服务，让Registrator在Consul服务器中自动注册它：
- en: 'First of all, start the Consul server using the following command:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令启动Consul服务器：
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we will pull the Docker image of Registrator and specify to plug it into
    Consul registry, so that when Registrator finds any services they will be automatically
    added to Consul server. Open up the Terminal and hit the following command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将拉取Registrator的Docker镜像，并指定将其插入到Consul注册表中，这样当Registrator发现任何服务时，它们将自动添加到Consul服务器。打开终端并输入以下命令：
- en: '[PRE22]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We run the container in detached mode and name it. We run in host network mode
    to make sure that Registrator has the hostname and IP address of the actual host.
    The last line is our registry URI. Registrator needs to be run on every host;
    for our exercise, we went ahead with a single host. To start Registrator, the
    essential configuration that we need to provide is how to connect to a registry,
    in this case Consul.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以分离模式运行容器并对其命名。我们以主机网络模式运行，以确保Registrator具有实际主机的主机名和IP地址。最后一行是我们的注册URI。Registrator需要在每个主机上运行；对于我们的练习，我们选择了单个主机。要启动Registrator，我们需要提供的基本配置是如何连接到注册表，在这种情况下是Consul。
- en: 'To ensure that Registrator has successfully started, hit the following command
    and you should be able to see logs streaming and the message `Listening for Docker
    events ...`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保Registrator已成功启动，请输入以下命令，您应该能够看到日志流和消息`Listening for Docker events ...`：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we will just start any service using Docker and our service will be automatically
    registered with Consul. Open up Terminal and just start our service from [Chapter
    2](https://cdp.packtpub.com/typescript_microservices/wp-admin/post.php?post=121&action=edit#post_48), *Gearing
    up for the Journey* in Docker using the following:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需使用Docker启动任何服务，我们的服务将自动注册到Consul。打开终端，只需使用以下命令在Docker中启动我们的服务：
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or you can just start any service, let''s say `redis`, by simply typing the
    following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以只是启动任何服务，比如`redis`，只需输入以下命令：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Open up Consul user interface and you will be able to see our service registered
    there.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Consul用户界面，您将能够在那里看到我们的服务已注册。
- en: Here, we efficiently implemented auto discovery using Registrator and Consul.
    It works as auto discovery.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Registrator和Consul有效地实现了自动发现。它可以作为自动发现。
- en: Key points for Registrator
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Registrator的关键点
- en: 'Let''s discuss the key points for Registrator:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论Registrator的关键要点：
- en: Registrator acts as an auto-discovery agent, where it listens for Docker startup
    and shutdown events.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Registrator充当自动发现代理，它监听Docker的启动和关闭事件。
- en: 'Registrator has the following inbuilt options taken from their GitHub `Readme`
    file:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Registrator具有以下内置选项，取自他们的GitHub“Readme”文件：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using Registrator with Consul gives a very viable solution for our service discovery
    and registry without duplicating code everywhere.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Consul与Registrator可以为我们的服务发现和注册提供非常可行的解决方案，而无需在各处重复编写代码。
- en: These are some of the widely used solutions available right now. Besides these,
    there are other solutions too such as ELB, Kubernetes, and so on.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是目前广泛使用的一些解决方案。除此之外，还有其他解决方案，比如ELB、Kubernetes等。
- en: In this section, we saw service registry and discovery using Eureka, Consul,
    and Registrator and saw some other options based on our service discovery and
    registry patterns. In the next section, we will understand how to choose the correct
    service registry and discovery solution.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了使用Eureka、Consul和Registrator进行服务注册表和发现，并根据我们的服务发现和注册表模式看到了一些其他选项。在下一节中，我们将了解如何选择正确的服务注册表和发现解决方案。
- en: How to choose service registry and discovery
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何选择服务注册表和发现
- en: 'Previously, we saw various service registry and discovery options based on
    service registry and discovery patterns. So, the next question that arises is
    pretty obvious, which solution to go for? That question is pretty wide and it
    actually depends on the requirements. Your requirements are most likely to be
    different than most other companies, so rather than going with the most common
    solutions, a better approach would be to evaluate your requirements and devise
    your own strategy based on that. To devise a strategy, the following questions
    should be properly evaluated:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们根据服务注册表和发现模式看到了各种服务注册表和发现选项。因此，接下来显而易见的问题是，选择哪种解决方案？这个问题非常广泛，实际上取决于需求。您的需求很可能与大多数其他公司的需求不同，因此与其选择最常见的解决方案，不如根据您的需求进行评估，并基于此制定自己的策略。为了制定策略，应该适当评估以下问题：
- en: Is the system going to be coded in only one language or is there a polyglot
    environment? Writing the same code in different languages is pretty cumbersome.
    In this case, Registrator is pretty helpful.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统是否只使用一种语言编码，还是使用多语言环境？在不同语言中编写相同的代码非常麻烦。在这种情况下，Registrator非常有帮助。
- en: Is there a legacy system involved? Are both the systems going to run for some
    time? In this case, self registering solutions can be pretty helpful.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否涉及旧系统？这两个系统是否会运行一段时间？在这种情况下，自注册解决方案可能非常有帮助。
- en: How simplified is service discovery process? Is there going to be a gateway?
    Is there going to be a load balancer in between?
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现过程有多简化？是否会有网关？是否会有负载均衡器在中间？
- en: Is there a requirement for an API for the service discovery? Do individual microservices
    need to communicate with other microservices? In this case, HTTP or DNS-based
    solutions are pretty helpful.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否需要为服务发现提供API？个别微服务是否需要与其他微服务通信？在这种情况下，基于HTTP或DNS的解决方案非常有帮助。
- en: Are service discovery solutions embedded in each microservice or is there a
    need to embed the logic centrally?
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现解决方案是否嵌入到每个微服务中，还是需要将逻辑集中嵌入？
- en: Do we need separate application configurations or can we store these in key-value
    stores such as Redis or MongoDB?
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否需要单独的应用程序配置，还是可以将其存储在诸如Redis或MongoDB之类的键值存储中？
- en: What is the deployment strategy? Is there a need for deployment strategies such
    as the blue-green strategy? Based on appropriate service discovery, solutions
    should be selected.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署策略是什么？是否需要像蓝绿策略这样的部署策略？应根据适当的服务发现选择解决方案。
- en: Blue-green is a deployment strategy where the downtime is reduced by running
    two identical production environments named blue and green.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿是一种部署策略，通过运行两个名为蓝色和绿色的相同生产环境来减少停机时间。
- en: How is the system going to run? Are there going to be multiple data centers?
    If that's the case, then running Eureka is most appropriate.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统将如何运行？是否会有多个数据中心？如果是这样，那么运行Eureka是最合适的。
- en: How do you maintain your acknowledgments? How is the access control list maintained?
    If that's the case, then Consul has inbuilt solutions.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何维护您的确认？访问控制列表如何维护？如果是这样，那么Consul有内置解决方案。
- en: How much support is there? Is it open sourced and does it have widespread support?
    Are there too many issues?
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少支持？它是否开源并且有广泛的支持？有太多问题吗？
- en: How are auto-scaling solutions decided?
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何决定自动扩展解决方案？
- en: Based on these questions, and after properly evaluating them, we can decide
    on appropriate solutions. After carefully evaluating these, we can select any
    solution. Given here is a list of careful points that need to be taken care of
    while selecting any solution.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些问题，并经过适当评估后，我们可以决定适当的解决方案。在仔细评估这些之后，我们可以选择任何解决方案。以下是在选择任何解决方案时需要注意的一些要点。
- en: Take care of these points while selecting either Consul or Eureka.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择Consul或Eureka时，请注意这些要点。
- en: If you select Consul
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果选择Consul
- en: 'While Consul has lots of benefits, the following points need to be taken care
    of while selecting Consul:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Consul有很多好处，但在选择Consul时需要注意以下几点：
- en: Clients need to write their own load-balancing, timeout, and retry logic. To
    avoid writing complete logic, we can utilize the following `node` module at [https://www.npmjs.com/package/resilient](https://www.npmjs.com/package/resilient).
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端需要编写自己的负载均衡、超时和重试逻辑。为了避免编写完整的逻辑，我们可以利用以下`node`模块：[https://www.npmjs.com/package/resilient](https://www.npmjs.com/package/resilient)。
- en: The client needs to implement fetch logic, and cache, and Consul failure handling
    individually unless we utilized Registrator. These needs to be written separately
    for each language in the ecosystem.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端需要单独实现获取逻辑、缓存和Consul故障处理，除非我们使用了Registrator。这些需要分别为生态系统中的每种语言编写。
- en: Priorities cannot be set for servers; custom logic needs to be written.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法为服务器设置优先级；需要编写自定义逻辑。
- en: If you select Eureka
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果选择Eureka
- en: 'While Eureka has many added advantages, the following points need to be taken
    care of while selecting Eureka:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Eureka有许多附加优势，但在选择Eureka时需要注意以下几点：
- en: Clients have to add their own load-balancing, timeout, and retry logic, so we
    need to integrate it with external tools such as Netflix Ribbon.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须添加自己的负载均衡、超时和重试逻辑，因此我们需要将其与Netflix Ribbon等外部工具集成。
- en: Documentation is very poor. If you have a non-JVM environment, you won't be
    able to use Eureka. Eureka server needs to be run on JVM platforms. Documentation
    is very vague for non-JVM clients.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档非常贫乏。如果您使用非JVM环境，将无法使用Eureka。Eureka服务器需要在JVM平台上运行。对于非JVM客户端，文档非常模糊。
- en: Web UI is extremely dull and noninformative.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web UI非常单调且缺乏信息。
- en: In this section, we learned about major takeaways while selecting Eureka or
    Consul. We summarized major points to actually help us decide a service registry
    and discovery solution.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了在选择Eureka或Consul时的主要要点。我们总结了一些重要观点，以帮助我们实际决定服务注册和发现解决方案。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about service registry and discovery. We went through
    the when, what, and why of service discovery and understood the service registry
    and discovery patterns. We saw the pros and cons of each pattern and the available
    options for each of them. Then, we implemented service discovery and registry
    using Eureka, Consul, and service registrator. In the end, we saw how to choose
    a service discovery and registry solution and the key takeaways while selecting
    Eureka or Consul.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了服务注册和发现。我们深入了解了服务发现的时间、内容和原因，并了解了服务注册和发现模式。我们看到了每种模式的优缺点以及它们的可用选项。然后，我们使用Eureka、Consul和服务注册器实现了服务发现和注册。最后，我们看到了如何选择服务发现和注册解决方案，以及在选择Eureka或Consul时的关键要点。
- en: In the next chapter, we will see service state and how microservices communicate
    with each other. We will learn more design patterns such as event-based communication
    and the publisher-subscriber pattern, see a service bus in action, share database
    dependencies, and so on. We will learn about stateful and stateless services with
    some live examples.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到服务状态以及微服务之间的通信。我们将学习更多的设计模式，如基于事件的通信和发布-订阅模式，看到服务总线的运作，共享数据库依赖等等。我们将通过一些实际示例了解有状态和无状态的服务。
