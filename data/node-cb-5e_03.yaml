- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Working with Streams
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理流
- en: Streams are one of the key features of Node.js. Most Node.js applications rely
    on the underlying Node.js streams implementation, be it for reading/writing files,
    handling HTTP requests, or other network communications. Streams provide a mechanism
    to read input and write output sequentially.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 流是Node.js的关键特性之一。大多数Node.js应用程序都依赖于Node.js的底层流实现，无论是用于读取/写入文件、处理HTTP请求还是其他网络通信。流提供了一种机制，可以顺序地读取输入和写入输出。
- en: By reading chunks of data sequentially, we can work with very large files (or
    other data input) that would generally be too large to read into memory and process
    as a whole. Streams are fundamental to big data applications or media streaming
    services, where the data is too large to consume at once.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过顺序读取数据块，我们可以处理非常大的文件（或其他数据输入），这些文件通常太大，无法一次性读入内存并整体处理。流对于大数据应用或媒体流服务是基本的，在这些服务中，数据太大，无法一次性消费。
- en: 'There are four main types of streams in Node.js:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中有四种主要的流类型：
- en: '**Readable streams** : Used for reading data, such as reading a file, or reading
    data from a request.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读流**：用于读取数据，例如读取文件或从请求中读取数据。'
- en: '**Writable streams** : Used for writing data, such as writing a file, or sending
    data to a response.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可写流**：用于写入数据，例如写入文件或将数据发送到响应。'
- en: '**Duplex streams** : Used for both reading and writing data, such as a TCP
    socket.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双工流**：用于读取和写入数据，例如TCP套接字。'
- en: '**Transform streams** : A type of duplex stream that transforms the data input,
    and then outputs the transformed data. A common example would be a compression
    stream.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换流**：一种双工流，它转换数据输入，然后输出转换后的数据。一个常见的例子是压缩流。'
- en: This chapter will demonstrate how we can create these various types of streams,
    as well as how we can chain these types of streams together to form stream pipelines.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将演示我们如何创建这些不同类型的流，以及如何将这些类型的流连接起来形成流管道。
- en: 'This chapter will cover the following recipes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Creating readable and writable streams
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可读和可写流
- en: Interacting with paused streams
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与暂停的流交互
- en: Piping streams
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道流
- en: Creating transform streams
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建转换流
- en: Building stream pipelines
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建流管道
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The recipes in this chapter will focus on the streams implementations provided
    by the Node.js core **stream** module in Node.js 22. Because of this, we will
    not use the **readable-stream** module ( [https://github.com/nodejs/readable-stream](https://github.com/nodejs/readable-stream)
    ). The **readable-stream** module aims to mitigate any inconsistencies in the
    streams implementations across Node.js versions by providing an external mirror
    of the streams implementations as an independently installable module. At the
    time of writing, the latest major version of **readable-stream** is version 4,
    which aligns with the Node.js 18 streams implementations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的食谱将专注于Node.js 22中Node.js核心**stream**模块提供的流实现。因此，我们将不使用**readable-stream**模块（[https://github.com/nodejs/readable-stream](https://github.com/nodejs/readable-stream)）。**readable-stream**模块旨在通过提供一个可独立安装的模块作为流实现的镜像来减轻Node.js版本之间流实现的不一致性。在撰写本文时，**readable-stream**的最新主要版本是版本4，它与Node.js
    18的流实现相一致。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you should have Node.js 22 installed, preferably the latest
    version of Node.js 22. You’ll also need access to a terminal, editor, and the
    internet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您应该已经安装了Node.js 22，最好是Node.js 22的最新版本。您还需要访问终端、编辑器和互联网。
- en: The code samples for this chapter are available in this book’s GitHub repository
    ( [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    ) in the **Chapter03** directory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可在本书的GitHub仓库（[https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)）的**Chapter03**目录中找到。
- en: Creating readable and writable streams
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可读和可写流
- en: The Node.js **stream** core module provides the Node.js stream API. This recipe
    will introduce using streams in Node.js. It will cover how to create both a readable
    stream and a writable stream to interact with files using the Node.js core **fs**
    module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的**stream**核心模块提供了Node.js流API。本食谱将介绍如何在Node.js中使用流。它将涵盖如何创建可读流和可写流，以使用Node.js核心**fs**模块与文件交互。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before diving into this recipe, we must set up our workspace by creating a
    directory and files:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入这个食谱之前，我们必须通过创建目录和文件来设置我们的工作区：
- en: 'First, let’s create a directory to work in:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个工作目录：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the following two files:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下两个文件：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we’re ready to start this recipe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好开始这个菜谱了。
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we’ll learn how to create both a readable stream and a writeable
    stream. First, we’ll create a writable stream so that we can write a large file.
    After, we’ll read that large file using a readable stream:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建可读流和可写流。首先，我们将创建一个可写流，以便我们可以写入大文件。然后，我们将使用可读流读取这个大文件：
- en: 'Start by importing the Node.js core **File system** module into **write-stream.js**
    :'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将Node.js核心**文件系统**模块导入到**write-stream.js**中：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will create the writable stream using the **createWriteStream()**
    method that’s available on the **fs** module:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用**fs**模块上的**createWriteStream()**方法创建可写流：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, we can start writing content into our file. Let’s write a random
    string to the file multiple times:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以开始向文件写入内容。让我们多次将随机字符串写入文件：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can run the script with the following command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令运行脚本：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will create a file named **file.txt** in your current directory. The file
    will be approximately **7.5M** in size. To check that the file exists, enter the
    following command in your terminal:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在你的当前目录中创建一个名为**file.txt**的文件。文件大小约为**7.5M**。要检查文件是否存在，请在你的终端中输入以下命令：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we’ll create a script that will create a readable stream to read the
    contents of the file. Start the **read-stream.js** file by importing the **fs**
    core module:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个脚本，该脚本将创建一个可读流来读取文件内容。从导入**fs**核心模块开始**read-stream.js**文件：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can create our readable stream using the **createReadStream()** method:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用**createReadStream()**方法创建我们的可读流：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we can register a **data** event handler, which will execute each time
    a chunk of data has been read:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以注册一个**data**事件处理程序，每次读取到数据块时都会执行：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will also add an **end** event handler, which will be fired when there is
    no more data left to be consumed from the stream:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将添加一个**end**事件处理程序，当没有更多数据可以从流中消费时，它将被触发：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the program with the following command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Expect to see the data chunks as **Buffer** data that’s logged as they’re read:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期将看到以**Buffer**数据形式记录的数据块：
- en: '![Figure 3.1 – A snippet of data chunks read by the stream](img/B19212_03_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 流读取的数据块片段](img/B19212_03_01.jpg)'
- en: Figure 3.1 – A snippet of data chunks read by the stream
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 流读取的数据块片段
- en: 'If we call **toString()** on the individual chunks of data within the **data**
    event handler function, we’ll see the **String** content output as it is processed.
    Change the **data** event handler function to the following:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在**data**事件处理函数中的数据块上调用**toString()**，我们将看到处理过程中输出的**String**内容。将**data**事件处理函数更改为以下内容：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Rerun the script using the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令重新运行脚本：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Expect to see the following output:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期将看到以下输出：
- en: '![Figure 3.2 – A snippet of the data chunks read by the stream, in string form](img/B19212_03_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 流读取的数据块片段，以字符串形式](img/B19212_03_02.jpg)'
- en: Figure 3.2 – A snippet of the data chunks read by the stream, in string form
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 流读取的数据块片段，以字符串形式
- en: With that, we’ve created a file using **createWriteStream()** , and then read
    that file using **createReadStream()** .
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们使用**createWriteStream()**创建了一个文件，然后使用**createReadStream()**读取了该文件。
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we wrote and read a file sequentially using the **createReadStream()**
    and **createWriteStream()** core **fs** methods. The Node.js core **fs** module
    relies on the underlying Node.js **stream** core module. Generally, the Node.js
    **stream** core module is not interacted with directly. You’d typically only interact
    with the Node.js **stream** implementation via higher-level APIs, such as those
    exposed by the **fs** module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用**createReadStream()**和**createWriteStream()**核心**fs**方法顺序地写入和读取文件。Node.js核心**fs**模块依赖于底层的Node.js
    **stream**核心模块。通常，Node.js **stream**核心模块不会直接交互。你通常会通过高级API与Node.js **stream**实现交互，例如**fs**模块公开的API。
- en: Important note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For more information about the underlying Node.js streams implementations and
    API, please refer to the Node.js **stream** module documentation at [https://nodejs.org/docs/latest-v22.x/api/stream.html](https://nodejs.org/docs/latest-v22.x/api/stream.html)
    .
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Node.js底层流实现和API的更多信息，请参阅Node.js **stream**模块文档，链接为[https://nodejs.org/docs/latest-v22.x/api/stream.html](https://nodejs.org/docs/latest-v22.x/api/stream.html)。
- en: We created a writable stream, via the **fs.createWriteStream()** method, to
    write our file contents sequentially. The **fs.createWriteStream()** method accepts
    two parameters. The first is the path of the file to write to, while the second
    is an **options** object that can be used to supply configuration to the stream.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过**fs.createWriteStream()**方法创建了一个可写流，以顺序写入我们的文件内容。**fs.createWriteStream()**方法接受两个参数。第一个是要写入文件的路径，而第二个是一个**options**对象，可以用来向流提供配置。
- en: 'The following table details the configuration that we can supply to the **fs.createWriteStream()**
    method via an **options** object:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格详细说明了我们可以通过一个**options**对象传递给**fs.createWriteStream()**方法的配置：
- en: '| **Option** | **Description** | **Default Value** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **Option** | **描述** | **默认值** |'
- en: '| **flags** | Defines **File** **System** flags. | **w** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **flags** | 定义**文件系统**标志。 | **w** |'
- en: '| **encoding** | The encoding of the file. | **utf8** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **encoding** | 文件的编码。 | **utf8** |'
- en: '| **fd** | The **fd** value is expected to be a file descriptor. When this
    value is supplied, the **path** argument will be ignored. | **null** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **fd** | **fd**值预期为一个文件描述符。当提供此值时，将忽略**path**参数。 | **null** |'
- en: '| **mode** | Sets the file permissions. | **0o666** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **mode** | 设置文件权限。 | **0o666** |'
- en: '| **autoClose** | When **autoClose** is set to **true** , the file descriptor
    will be closed automatically. When **false** , the file descriptor will need to
    be closed manually. | **true** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **autoClose** | 当**autoClose**设置为**true**时，文件描述符将自动关闭。当**false**时，需要手动关闭文件描述符。
    | **true** |'
- en: '| **emitClose** | Controls whether the stream emits a **close** event after
    it has been destroyed. | **false** |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **emitClose** | 控制流在销毁后是否发出**close**事件。 | **false** |'
- en: '| **start** | Can be used to specify, as an integer, the position to start
    writing data. | **0** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **start** | 可以用作整数，指定开始写入数据的位置。 | **0** |'
- en: '| **fs** | Used to override **fs** implementations. | **null** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **fs** | 用于覆盖**fs**实现。 | **null** |'
- en: '| **signal** | Used to specify an **AbortSignal** object to programmatically
    cancel the writing of the stream. | **null** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **signal** | 用于指定一个**AbortSignal**对象以编程方式取消流的写入。 | **null** |'
- en: '| **highWaterMark** | Used to specify the maximum number of bytes that can
    be buffered before backpressure is applied. | **16384** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **highWaterMark** | 用于指定在应用背压之前可以缓冲的最大字节数。 | **16384** |'
- en: Table 3.1 – The configurations that can be passed to the createWriteStream()
    method
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 – 可以传递给createWriteStream()方法的配置
- en: Important note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: For more information on **File System** flags, please refer to [https://nodejs.org/api/fs.html#fs_file_system_flags](https://nodejs.org/api/fs.html#fs_file_system_flags)
    .
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**文件系统**标志的更多信息，请参阅[https://nodejs.org/api/fs.html#fs_file_system_flags](https://nodejs.org/api/fs.html#fs_file_system_flags)。
- en: 'Then, we created a readable stream to read the contents of our file sequentially.
    The **createReadStream()** method is an abstraction of a readable stream. Again,
    this method expects two parameters – the first being the path to the contents
    to read, and the second being an **options** object. The following table details
    the options we can pass to the **createReadStream()** method via an **options**
    object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个可读流来顺序读取我们文件的 内容。**createReadStream()**方法是一个可读流的抽象。同样，此方法期望两个参数 -
    第一个是读取内容的路径，第二个是一个**options**对象。以下表格详细说明了我们可以通过一个**options**对象传递给**createReadStream()**方法的选项：
- en: '| **Option** | **Description** | **Default Value** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **Option** | **描述** | **默认值** |'
- en: '| **flags** | Defines **File** **System** flags. | **r** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **flags** | 定义**文件系统**标志。 | **r** |'
- en: '| **encoding** | The encoding of the file. | **null** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **encoding** | 文件的编码。 | **null** |'
- en: '| **fd** | The **fd** value is expected to be a file descriptor. When this
    value is supplied, the **path** argument will be ignored. | **null** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **fd** | **fd**值预期为一个文件描述符。当提供此值时，将忽略**path**参数。 | **null** |'
- en: '| **mode** | Sets the file permissions, but only when the file is created.
    | **0o666** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **mode** | 设置文件权限，但仅在文件创建时。 | **0o666** |'
- en: '| **autoClose** | When **autoClose** is set to **true** , the file descriptor
    will be closed automatically. When **false** , the file descriptor will need to
    be closed manually. | **true** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **autoClose** | 当**autoClose**设置为**true**时，文件描述符将自动关闭。当**false**时，需要手动关闭文件描述符。
    | **true** |'
- en: '| **emitClose** | Controls whether the stream emits a **close** event after
    it has been destroyed. | **false** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **emitClose** | 控制流在销毁后是否发出**close**事件。 | **false** |'
- en: '| **start** | Can be used to specify, as an integer, which position to start
    reading data. | **0** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **start** | 可以用作整数，指定开始读取数据的位置。 | **0** |'
- en: '| **end** | Can be used to specify, as an integer, the position to stop reading
    data. | **Infinity** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **end** | 可以用作整数，指定停止读取数据的位置。 | **Infinity** |'
- en: '| **highWaterMark** | Dictates the maximum number of bytes that are stored
    in the internal buffer before the stream stops reading the input. | 64 KiB |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **highWaterMark** | 指定在流停止读取输入之前存储在内部缓冲区中的最大字节数。 | 64 KiB |'
- en: '| **fs** | Used to override **fs** implementations. | **null** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **fs** | 用于覆盖**fs**实现。 | **null** |'
- en: '| **signal** | Used to specify an **AbortSignal** object to programmatically
    cancel the reading of the stream. | **null** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **signal** | 用于指定一个**AbortSignal**对象以程序化取消流的读取。 | **null** |'
- en: Table 3.2 – The configurations that can be passed to the createReadStream()
    method
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 – 可以传递给createReadStream()方法的配置
- en: 'In **read-stream.js** , we registered a **data** event handler that executed
    each time our readable stream read a chunk of data. We could see the individual
    chunks’ outputs on the screen as they were read:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在**read-stream.js**中，我们注册了一个**data**事件处理程序，每次我们的可读流读取一块数据时都会执行。我们可以看到随着读取，屏幕上会显示各个数据块的输出：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once all the file data was read, our **end** event handler triggered – resulting
    in the **No more** **data** message.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取了所有文件数据，我们的**end**事件处理程序就会被触发——导致出现**没有更多****数据**的消息。
- en: All Node.js streams are instances of the **EventEmitter** class ( [https://nodejs.org/api/events.html#events_class_eventemitter](https://nodejs.org/api/events.html#events_class_eventemitter)
    ). Streams emit a series of different events.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Node.js流都是**EventEmitter**类的实例（[https://nodejs.org/api/events.html#events_class_eventemitter](https://nodejs.org/api/events.html#events_class_eventemitter)）。流会发出一系列不同的事件。
- en: 'The following events are emitted on readable streams:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下事件在可读流上发出：
- en: '**close** : Emitted when the stream and any of the stream’s resources have
    been closed. No further events will be emitted.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**close**：当流及其任何资源被关闭时发出。不会发出更多事件。'
- en: '**data** : Emitted when new data is read from the stream.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**data**：当从流中读取新数据时发出。'
- en: '**end** : Emitted when all available data has been read.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**end**：当所有可用数据都被读取时发出。'
- en: '**error** : Emitted when the readable stream experiences an error.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**error**：当可读流遇到错误时发出。'
- en: '**pause** : Emitted when the readable stream is paused.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pause**：当可读流被暂停时发出。'
- en: '**readable** : Emitted when there is data available to be read.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**readable**：当有可读数据时发出。'
- en: '**resume** : Emitted when a readable stream resumes after being in a paused
    state.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**resume**：当可读流在暂停状态下恢复时发出。'
- en: 'The following events are emitted on writable streams:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下事件在可写流上发出：
- en: '**close** : Emitted when the stream and any of its resources have been closed.
    No further events will be emitted.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**close**：当流及其任何资源被关闭时发出。不会发出更多事件。'
- en: '**drain** : Emitted when the writable stream can resume writing data.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**drain**：当可写流可以恢复写入数据时发出。'
- en: '**error** : Emitted when the writeable stream experiences an error.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**error**：当可写流遇到错误时发出。'
- en: '**finish** : Emitted when the writeable stream has ended, and all writes have
    been completed.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**finish**：当可写流结束，所有写入都已完成后发出。'
- en: '**pipe** : Emitted when the **stream.pipe()** method is called on a readable
    stream.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pipe**：当在可读流上调用**stream.pipe()**方法时发出。'
- en: '**unpipe** : Emitted when the **stream.unpipe()** method is called on a readable
    stream.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unpipe**：当在可读流上调用**stream.unpipe()**方法时发出。'
- en: There’s more…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Let’s dive deeper into readable streams, including how to read from infinite
    data sources. We’ll also learn how to use the more modern asynchronous iterator
    syntax with readable streams.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解可读流，包括如何从无限数据源读取。我们还将学习如何使用更现代的异步迭代语法与可读流一起使用。
- en: Interacting with infinite data
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与无限数据交互
- en: 'Streams make it possible to interact with infinite amounts of data. Let’s write
    a script that will process data sequentially, indefinitely:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 流使得与无限量的数据交互成为可能。让我们编写一个脚本，该脚本将按顺序、无限地处理数据：
- en: 'In the **learning-streams** directory, create a file named **infinite-read.js**
    :'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**learning-streams**目录下，创建一个名为**infinite-read.js**的文件：
- en: '[PRE15]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need an infinite data source. We will use the **/dev/urandom** file, which
    is available on Unix-like operating systems. This file is a pseudo-random number
    generator. Add the following to **infinite-read.js** to calculate the ongoing
    size of **/dev/urandom** :'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个无限的数据源。我们将使用**/dev/urandom**文件，该文件可在类Unix操作系统上使用。这是一个伪随机数生成器。将以下内容添加到**infinite-read.js**以计算**/dev/urandom**的持续大小：
- en: '[PRE16]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the script with the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE17]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Expect to see an output similar to the following, showing the ever-growing
    size of the **/** **dev/urandom** file:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期将看到类似以下输出，显示**/dev/urandom**文件不断增长的大小：
- en: '![Figure 3.3 – Output showing the ever-growing size of /dev/urandom](img/B19212_03_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 显示/dev/urandom文件不断增长大小的输出](img/B19212_03_03.jpg)'
- en: Figure 3.3 – Output showing the ever-growing size of /dev/urandom
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 显示/dev/urandom文件不断增长大小的输出
- en: This example demonstrates how we can use streams to process infinite amounts
    of data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了我们可以如何使用流来处理无限量的数据。
- en: Readable streams with async iterators
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有异步迭代器的可读流
- en: 'Readable streams are **asynchronous iterables** . This means we can use the
    **for await...of** syntax to loop over the stream data. In the following steps,
    we will implement the same functionality as in the main recipe but using the **for**
    **await...of** syntax:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可读流是**异步可迭代对象**。这意味着我们可以使用**for await...of**语法来遍历流数据。在以下步骤中，我们将使用**for** **await...of**语法实现与主要食谱相同的功能：
- en: 'Create a file named **for-await-read-stream.js** :'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**for-await-read-stream.js**的文件：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To implement the **read-stream.js** logic from this recipe using asynchronous
    iterables, use the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用异步迭代器实现此食谱中的**read-stream.js**逻辑，请使用以下代码：
- en: '[PRE19]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the file with the following command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行文件：
- en: '[PRE20]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For more information on the **for await...of** syntax, please refer to the MDN
    web docs ( [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of)
    ).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有关**for await...of**语法的更多信息，请参阅MDN网络文档（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of)）。
- en: Important note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Generally, developers should opt to use one of the Node.js streams API styles
    as using a combination of **on('data')** , **on('readable')** , **pipe()** , and/or
    async iterators could lead to unclear behavior.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发者应选择使用Node.js流API样式之一，因为使用**on('data')**、**on('readable')**、**pipe()**和/或异步迭代器的组合可能会导致行为不明确。
- en: Generating readable streams with Readable.from()
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Readable.from()生成可读流
- en: 'The **Readable.from()** method is exposed by the Node.js core **stream** module.
    This method is used to construct readable streams with iterators. Let’s take a
    closer look:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**Readable.from()**方法由Node.js核心**stream**模块公开。此方法用于使用迭代器构建可读流。让我们更详细地看看：'
- en: 'Create a file named **async-generator.js** :'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**async-generator.js**的文件：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Import the **Readable** class from the **stream** module:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**stream**模块导入**Readable**类：
- en: '[PRE22]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define the asynchronous generator function. This will form the content of our
    readable stream:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义异步生成器函数。这将形成我们的可读流内容：
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note the use of the **function*** syntax. This syntax defines a generator function.
    For more details on generator syntax, please refer to the MDN web docs ( [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)
    ).
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意使用**函数**语法。这种语法定义了一个生成器函数。有关生成器语法的更多详细信息，请参阅MDN网络文档（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)）。
- en: 'Create the readable stream using the **Readable.from()** method, passing the
    **generate()** function as the argument:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Readable.from()**方法创建可读流，将**generate()**函数作为参数传递：
- en: '[PRE24]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To output the content of our readable stream, register a **data** event handler
    that prints the chunks:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要输出我们的可读流内容，注册一个**data**事件处理程序，打印块：
- en: '[PRE25]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the program by entering the following command in your terminal:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中输入以下命令来运行程序：
- en: '[PRE26]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Expect to see the following generated values as output:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期将看到以下生成的值作为输出：
- en: '[PRE27]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See also
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[*Chapter 2*](B19212_02.xhtml#_idTextAnchor041)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第2章*](B19212_02.xhtml#_idTextAnchor041)'
- en: The *Interacting with paused streams* recipe of this chapter
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的**与暂停流交互**食谱
- en: The *Piping streams* recipe of this chapter
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的**管道流**食谱
- en: The *Creating transform streams* recipe of this chapter
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的**创建转换流**食谱
- en: The *Building stream pipelines* recipe of this chapter
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *构建流管道* 菜单
- en: Interacting with paused streams
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与暂停流交互
- en: A Node.js stream can be in either flowing or paused mode. In flowing mode, data
    chunks are read automatically, whereas in paused mode, the **stream.read()** method
    must be called to read the chunks of data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 流可以是流动模式或暂停模式。在流动模式下，数据块会自动读取，而在暂停模式下，必须调用 **stream.read()** 方法来读取数据块。
- en: In this recipe, we’ll learn how to interact with a readable stream that is in
    paused mode, which is its default upon creation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何与处于暂停模式的可读流交互，这是它在创建时的默认模式。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the **learning-streams** directory that we created in the previous recipe,
    create the following file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中创建的 **learning-streams** 目录中，创建以下文件：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We’re now ready to start this recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始这个菜谱了。
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we’ll learn how to interact with a readable stream that is
    in paused mode:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何与处于暂停模式的可读流交互：
- en: 'First, import the **fs** module into **paused-stream.js** :'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将 **fs** 模块导入到 **paused-stream.js** 中：
- en: '[PRE29]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, create a readable stream to read the **file.txt** file using the **createReadStream()**
    method:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 **createReadStream()** 方法创建一个可读流来读取 **file.txt** 文件：
- en: '[PRE30]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we need to register a **readable** event handler on the readable stream:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在可读流上注册一个 **readable** 事件处理程序：
- en: '[PRE31]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we can add the manual logic to read the data chunks within our **readable**
    handler. Add the following logic to read the data, until there is no data left
    to consume:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 **readable** 事件处理程序中添加手动逻辑来读取数据块，直到没有更多数据可以消费：
- en: '[PRE32]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can register an **end** event handler for our readable stream that
    will print a message stating **No more data.** once all the data has been read:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的可读流注册一个 **end** 事件处理程序，当所有数据都被读取后，它会打印一条消息，指出 **没有更多数据**。
- en: '[PRE33]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the script with the following command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE34]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Expect to see the following output, indicating that the chunks of the readable
    stream are being read:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期看到以下输出，表明可读流的块正在被读取：
- en: '![Figure 3.4 – Overview of the readable stream chunks as they are being read](img/B19212_03_04.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 读取过程中的可读流块概述](img/B19212_03_04.jpg)'
- en: Figure 3.4 – Overview of the readable stream chunks as they are being read
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 读取过程中的可读流块概述
- en: With that, we’ve learned how to interact with a readable stream in paused mode.
    We did this by listening for the readable event and manually calling the **read()**
    method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经学会了如何在暂停模式下与可读流交互。我们通过监听可读事件并手动调用 **read()** 方法来做到这一点。
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we learned how to interact with a readable stream that was in
    paused mode.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何与处于暂停模式的可读流交互。
- en: 'By default, a readable stream is in paused mode. However, a readable stream
    will switch to flowing mode in the following instances:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可读流处于暂停模式。然而，在以下情况下，可读流会切换到流动模式：
- en: When a **data** event handler is registered
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当注册 **data** 事件处理程序时
- en: When the **pipe()** method is called
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 **pipe()** 方法时
- en: When the **resume()** method is called
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 **resume()** 方法时
- en: Since our program in this recipe did none of these, our stream remained in paused
    mode.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个菜谱中的程序没有做任何这些操作，所以我们的流保持在暂停模式。
- en: 'If a readable stream was in flowing mode, it would switch back to paused mode
    in the following instances:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个可读流处于流动模式，在以下情况下它会切换回暂停模式：
- en: When the **pause()** method is called and there are no pipe destinations
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 **pause()** 方法且没有管道目标时
- en: When the **unpipe()** method is called on all pipe destinations
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在所有管道目标上调用 **unpipe()** 方法时
- en: We added a **readable** event handler to our readable stream. If the readable
    stream was already in flowing mode, a readable event handler being registered
    would stop the stream from flowing (it’s switched to paused mode).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向我们的可读流添加了一个 **readable** 事件处理程序。如果可读流已经处于流动模式，注册一个可读事件处理程序将停止流（它切换到暂停模式）。
- en: When the readable stream is in paused mode, it is necessary to manually call
    the **readableStream.read()** method to consume the stream data. In this recipe,
    we added logic within our **readable** event handler that continued to read the
    stream data until the data value was **null** . The data value being **null**
    indicates that the stream has ended (all currently available data has been read).
    The **readable** event can be emitted multiple times, indicating that more data
    has become available.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当可读流处于暂停模式时，必须手动调用**readableStream.read()**方法来消费流数据。在这个配方中，我们在**readable**事件处理器中添加了逻辑，继续读取流数据，直到数据值为**null**。数据值为**null**表示流已结束（所有当前可用的数据都已读取）。**readable**事件可以多次触发，表示有更多数据可用。
- en: When a stream is in paused mode, we can have more control over when the data
    is being read. Essentially, we’re pulling the data from the stream, rather than
    it being pushed automatically.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当流处于暂停模式时，我们可以更好地控制数据读取的时间。本质上，我们是从流中提取数据，而不是自动推送。
- en: Important note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Generally, if possible, it’s worthwhile using the **pipe()** method to handle
    the consumption data of a readable stream as memory management is handled automatically.
    The following recipe, *Piping streams* , will go into more detail about the **pipe()**
    method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果可能的话，使用**pipe()**方法来处理可读流的消费数据是有价值的，因为内存管理是自动处理的。以下配方，*管道流*，将更详细地介绍**pipe()**方法。
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[*Chapter 2*](B19212_02.xhtml#_idTextAnchor041)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第二章*](B19212_02.xhtml#_idTextAnchor041)'
- en: The *Creating readable and writable streams* recipe of this chapter
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*创建可读和可写流*配方
- en: The *Piping streams* recipe of this chapter
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*管道流*配方
- en: The *Creating transform streams* recipe of this chapter
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*创建转换流*配方
- en: The *Building stream pipelines* recipe of this chapter
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*构建流管道*配方
- en: Piping streams
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道流
- en: A pipe is a form of one-way redirection. In our terminal (DOS or Unix-like),
    we often utilize the pipe operator ( **|** ) to pipe the output of one program
    as the input to another program. For example, we can enter **$ ls | head -3**
    to pipe the output of the **ls** command to the **head -3** command, resulting
    in the first three files in our directory being returned.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一种单向重定向形式。在我们的终端（DOS或类Unix），我们经常使用管道操作符（**|**）将一个程序的输出作为另一个程序的输入。例如，我们可以输入**$
    ls | head -3**将**ls**命令的输出通过管道传递给**head -3**命令，结果返回目录中的前三个文件。
- en: Like how we can use the pipe operator in our shells to pipe output between programs,
    we can use the Node.js **pipe()** method to pipe data between streams.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以在我们的shell中使用管道操作符在程序之间传递输出一样，我们也可以使用Node.js的**pipe()**方法在流之间传递数据。
- en: In this recipe, we’ll learn how to use the **pipe()** method.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用**pipe()**方法。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow these steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Create a directory to work in:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个工作目录：
- en: '[PRE35]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Start by creating a file named **file.txt** :'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个名为**file.txt**的文件：
- en: '[PRE36]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add some dummy data to **file.txt** , such as the following:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向**file.txt**添加一些示例数据，如下所示：
- en: '[PRE37]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we’re ready to start this recipe.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始这个配方。
- en: How to do it…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we’ll learn how to pipe a readable stream to a writable stream:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何将可读流通过管道连接到可写流：
- en: 'Create a file named **pipe-stream.js** :'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**pipe-stream.js**的文件：
- en: '[PRE38]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, start the **pipe-stream.js** file by importing the **fs** module:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过导入**fs**模块来启动**pipe-stream.js**文件：
- en: '[PRE39]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a readable stream to read **file.txt** using the **createReadStream()**
    method:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**createReadStream()**方法创建一个可读流来读取**file.txt**：
- en: '[PRE40]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we need to pipe our readable stream to **process.stdout** , which returns
    a writable stream connected to **STDOUT** :'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的可读流通过管道连接到**process.stdout**，它返回一个连接到**STDOUT**的可写流：
- en: '[PRE41]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the program with the following command:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE42]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Expect to see the following output:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期看到以下输出：
- en: '[PRE43]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With that, we’ve piped a readable stream to a writeable stream using the **pipe()**
    method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经使用**pipe()**方法将可读流连接到了可写流。
- en: How it works…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, we created a readable stream to read our **file.txt** file using
    the **createReadStream()** method. Then, we piped the output of this readable
    stream to **process.stdout** (a writable stream) using the **pipe()** method.
    The **pipe()** method attaches a data event handler to the source stream, which
    writes the incoming data to the destination stream.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用**createReadStream()**方法创建了一个可读流来读取我们的**file.txt**文件。然后，我们使用**pipe()**方法将这个可读流的输出导向**process.stdout**（一个可写流）。**pipe()**方法将数据事件处理程序附加到源流上，该处理程序将传入的数据写入目标流。
- en: The **pipe()** method is used to direct data through a flow of streams. Under
    the hood, the **pipe()** method manages the flow of data to ensure that the destination
    writable stream is not overwhelmed by a faster readable stream.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**pipe()**方法用于将数据通过流流导向。在底层，**pipe()**方法管理数据流，以确保目标可写流不会被更快的可读流淹没。'
- en: The in-built management provided by the **pipe()** method helps resolve the
    issue of backpressure. Backpressure occurs when an input overwhelms a system’s
    capacity. For streams, this could occur when we’re consuming a stream that is
    rapidly reading data, and the writable stream can’t keep up. This can result in
    a large amount of memory being kept in a process before being written by the writable
    stream. The mass amount of data being stored in memory can degrade our Node.js
    process performance, or in the worst cases, cause the process to crash.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**pipe()**方法内置的管理有助于解决背压问题。当输入超过系统容量时，就会发生背压。对于流来说，这可能会发生在我们消费一个快速读取数据的流时，而可写流无法跟上。这可能导致在可写流写入之前，在进程中保留大量内存。在内存中存储的大量数据可能会降低Node.js进程的性能，或者在最坏的情况下导致进程崩溃。'
- en: By default, when using the **pipe()** method, **stream.end()** is called on
    the destination writable stream when the source readable stream emits an **end**
    event. This means that the destination is no longer writable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当使用**pipe()**方法时，当源可读流发出**end**事件时，会在目标可写流上调用**stream.end()**。这意味着目标不再可写。
- en: 'To disable this default behavior, we can supply **{ end: false }** to the **pipe()**
    method via an **options** argument:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '要禁用此默认行为，我们可以通过**options**参数向**pipe()**方法提供**{ end: false }**：'
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This configuration instructs the destination stream to remain open even after
    the **end** event has been emitted by the source stream.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置指示目标流在源流发出**end**事件后仍然保持打开状态。
- en: There’s more…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Stream chaining in Node.js allows for efficient data processing by linking
    together multiple streams. This method enables data transformations with minimal
    memory overhead, which is ideal for operations such as compression. In the following
    example, we’ll demonstrate the process of reading a file, compressing its contents,
    and writing the compressed data to a new file to highlight the use of **pipe()**
    for chaining streams:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的流链式操作允许通过连接多个流来实现高效的数据处理。这种方法通过最小化内存开销来实现数据转换，这对于压缩等操作来说是非常理想的。在下面的示例中，我们将演示读取文件、压缩其内容并将压缩数据写入新文件的过程，以突出**pipe()**在流链式操作中的使用：
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, **readStream.pipe(zlib.createGzip()).pipe(writeStream);** reads
    data from **input.txt** , compresses it on-the-fly, and writes the compressed
    data to **output.txt.gz** . This chain of operations is executed with efficiency,
    showcasing the elegance and power of stream chaining in Node.js for data processing
    tasks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，**readStream.pipe(zlib.createGzip()).pipe(writeStream);**从**input.txt**读取数据，即时压缩，并将压缩数据写入**output.txt.gz**。这一系列操作以高效的方式执行，展示了Node.js中流链式操作在数据处理任务中的优雅和强大。
- en: In the example provided, error handling is not explicitly shown, but it’s crucial
    in a real-world application. In Node.js, when chaining streams, errors can be
    propagated through the chain. When using **pipe()** , errors should be listened
    for on each stream by attaching an **error** event listener to each stream involved.
    This ensures that errors are caught and managed where they occur.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的示例中，没有明确显示错误处理，但在实际应用中这是至关重要的。在Node.js中，当链式操作流时，错误可以通过链传播。当使用**pipe()**时，应在每个涉及的流上监听错误，通过为每个流附加一个**error**事件监听器来实现。这确保了错误在发生时被捕获和管理。
- en: See also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating readable and writable streams* recipe of this chapter
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的**创建可读和可写流**食谱
- en: The *Creating transform streams* recipe of this chapter
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的**创建转换流**食谱
- en: The *Building stream pipelines* recipe of this chapter
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的**构建流管道**食谱
- en: Creating transform streams
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建转换流
- en: Transform streams allow us to consume input data, process that data, and then
    output the data in its processed form. We can use transform streams to handle
    data manipulation functionally and asynchronously. It’s possible to pipe many
    transform streams together, allowing us to break complex processing down into
    sequential tasks.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 转换流允许我们消费输入数据，处理这些数据，然后以处理后的形式输出数据。我们可以使用转换流以功能性和异步方式处理数据操作。可以将多个转换流串联起来，这样我们就可以将复杂处理分解为一系列任务。
- en: In this recipe, we’re going to create a transform stream using the Node.js core
    **stream** module.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 Node.js 核心模块 **stream** 创建一个转换流。
- en: Important note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **through2** module ( [https://www.npmjs.com/package/through2](https://www.npmjs.com/package/through2)
    ) is very popular and provides a wrapper for creating Node.js transform streams.
    However, over the past few years, there have been many simplifications and improvements
    to the Node.js core stream implementation. Today, the Node.js stream API provides
    simplified construction, as demonstrated in this recipe, which means we can achieve
    equivalent syntax using Node.js core directly, without the need for **through2**
    .
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**through2** 模块（[https://www.npmjs.com/package/through2](https://www.npmjs.com/package/through2)）非常受欢迎，并为创建
    Node.js 转换流提供了一个包装器。然而，在过去的几年中，Node.js 核心流实现已经进行了许多简化和改进。今天，Node.js 流 API 提供了简化的构建方式，如本菜谱所示，这意味着我们可以直接使用
    Node.js 核心来达到等效的语法，而不需要 **through2**。'
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow these steps:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Create a directory to work in:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个工作目录：
- en: '[PRE46]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a file named **transform-stream.js** :'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **transform-stream.js** 的文件：
- en: '[PRE47]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We’ll also need some sample data to transform. So, create a file named **file.txt**
    :'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一些用于转换的样本数据。因此，创建一个名为 **file.txt** 的文件：
- en: '[PRE48]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add some dummy text data to the **file.txt** file, such as the following:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 **file.txt** 文件中添加一些示例文本数据，例如以下内容：
- en: '[PRE49]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, we’re ready to start this recipe.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始这个菜谱。
- en: How to do it…
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we’ll learn how to create a transform stream using the Node.js
    core **stream** module. The transform stream we will create will convert all the
    text from our file into uppercase:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 Node.js 核心模块 **stream** 创建一个转换流。我们将创建的转换流将把文件中的所有文本转换为大写：
- en: 'Start by importing the Node.js core **File system** module into **transform-stream.js**
    :'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将 Node.js 核心模块 **文件系统** 导入到 **transform-stream.js** 中：
- en: '[PRE50]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we need to import the **Transform** class from the Node.js core **stream**
    module:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要从 Node.js 核心模块 **stream** 中导入 **Transform** 类：
- en: '[PRE51]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a readable stream to read the **file.txt** file:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可读流以读取 **file.txt** 文件：
- en: '[PRE52]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once our file content has been processed by our transform stream, we will write
    it to a new file named **newFile.txt** . Create a writable stream to write this
    file using the **createWriteStream()** method:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们的文件内容通过我们的转换流处理，我们将将其写入一个名为 **newFile.txt** 的新文件。使用 **createWriteStream()**
    方法创建一个可写流来写入此文件：
- en: '[PRE53]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we need to define our transform stream. We’ll name our transform stream
    **uppercase()** :'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们的转换流。我们将命名我们的转换流为 **uppercase()**：
- en: '[PRE54]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, within our transform stream, we will add the logic to transform the chunk
    into an uppercase string. Below the **// Data processing** comment, add the following
    line:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的转换流中，我们将添加逻辑以将块转换为一个大写字符串。在 **// 数据处理** 注释下方，添加以下行：
- en: '[PRE55]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This calls the transform stream callback function with the transformed chunk.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将调用转换流的回调函数，并传递转换后的块。
- en: 'At this point, we need to chain all our streams together. We will do this using
    the **pipe()** method. Add the following line to the bottom of the file:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要将所有流串联起来。我们将使用 **pipe()** 方法来完成。将以下行添加到文件底部：
- en: '[PRE56]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Enter the following command in your terminal to run the program:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中输入以下命令来运行程序：
- en: '[PRE57]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Expect **newFile.txt** to have been created by our program. You can confirm
    this by running the **cat** command, followed by the new file’s name, in the terminal:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期 **newFile.txt** 已由我们的程序创建。您可以通过在终端中运行 **cat** 命令，然后跟上新文件的名称来确认这一点：
- en: '[PRE58]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that the contents are now in uppercase, indicating that the data has passed
    through the transform stream.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，内容现在已为大写，这表明数据已通过转换流。
- en: With that, we’ve learned how to create a transform stream to manipulate data.
    Our transform stream converted the input data into uppercase strings. After, we
    piped our readable stream to the transform stream and piped the transform stream
    to our writable stream.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经学会了如何创建转换流来处理数据。我们的转换流将输入数据转换为大写字符串。之后，我们将可读流管道连接到转换流，并将转换流连接到可写流。
- en: How it works…
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Transform streams are duplex streams, which means they implement both readable
    and writable stream interfaces. Transform streams are used to process (or transform)
    the input and then pass it as output.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 转换流是双工流，这意味着它们实现了可读和可写流接口。转换流用于处理（或转换）输入，然后将其作为输出传递。
- en: 'To create a transform stream, we must import the **Transform** class from the
    Node.js core **stream** module. The transform stream constructor accepts the following
    two arguments:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建转换流，我们必须从 Node.js 核心模块 **stream** 中导入 **Transform** 类。转换流构造函数接受以下两个参数：
- en: '**transform** : The function that implements the data processing/transformation
    logic.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**transform**：实现数据处理/转换逻辑的函数。'
- en: '**flush** : If the transform process emits additional data, the **flush** method
    is used to flush the data. This argument is optional.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**flush**：如果转换过程产生额外的数据，将使用 **flush** 方法来刷新数据。此参数是可选的。'
- en: It is the **transform()** function that processes the stream input and produces
    the output. Note that it is not necessary for the number of chunks that are supplied
    via the input stream to be equal to the number output by the transform stream
    – some chunks could be omitted during the transformation/processing.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 是 **transform()** 函数处理流输入并产生输出。请注意，通过输入流提供的块的数量不必要等于转换流输出的数量——在转换/处理过程中可能会省略一些块。
- en: Under the hood, the **transform()** function gets attached to the **_transform()**
    method of the transform stream. The **_transform()** method is an internal method
    on the **Transform** class that is not intended to be called directly (hence the
    underscore prefix).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，**transform()** 函数被附加到转换流的 **_transform()** 方法上。**_transform()** 方法是 **Transform**
    类的一个内部方法，不打算直接调用（因此有下划线前缀）。
- en: 'The **_transform()** method accepts the following three arguments:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**_transform()** 方法接受以下三个参数：'
- en: '**chunk** : The data to be transformed.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**chunk**：要转换的数据。'
- en: '**encoding** : If the input is of the **String** type, the encoding will be
    of the **String** type. If it is of the **Buffer** type, this value is set to
    **buffer** .'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码**：如果输入是 **String** 类型，编码将是 **String** 类型。如果是 **Buffer** 类型，此值设置为 **buffer**。'
- en: '**callback(err, transformedChunk)** : The callback function to be called once
    the chunk has been processed. The callback function is expected to have two arguments
    – the first an error and the second the transformed chunk.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**callback(err, transformedChunk)**：一旦块被处理，就要调用的回调函数。期望回调函数有两个参数——第一个是错误，第二个是转换后的块。'
- en: In this recipe, our **transform()** function called the **callback()** function
    with our processed data (where our processed data was **chunk.toString().toUpperCase()**
    to convert the input into an uppercase string).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们的 **transform()** 函数使用处理后的数据调用了 **callback()** 函数（我们的处理数据是 **chunk.toString().toUpperCase()**，将输入转换为一个大写字符串）。
- en: Important note
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Node.js comes with some built-in transform streams. Both the Node.js core **crypto**
    and **zlib** modules expose transform streams. As an example, the **zlib.createGzip()**
    method is a transform stream that’s exposed by the **zlib** module that compresses
    the file that’s been piped to it.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 内置了一些转换流。Node.js 核心模块 **crypto** 和 **zlib** 都公开了转换流。例如，**zlib.createGzip()**
    方法是 **zlib** 模块公开的转换流，它压缩了被管道传输到它的文件。
- en: There’s more…
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In this section, we’ll learn how to create transform streams in **ECMAScript
    6** ( **ES6** ) syntax and how we can create an object mode transform stream.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 ECMAScript 6（**ES6**）语法创建转换流，以及我们如何创建一个对象模式的转换流。
- en: Adopting ES6 syntax
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 采用 ES6 语法
- en: 'In this recipe, we implemented a transform stream using the simplified constructor
    approach. It is also possible to implement these using the ES6 class syntax. The
    following steps will demonstrate this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用简化的构造函数方法实现了转换流。也可以使用 ES6 类语法来实现这些。以下步骤将演示这一点：
- en: 'Create a file named **transform-stream-es6.js** :'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **transform-stream-es6.js** 的文件：
- en: '[PRE59]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The transform stream from this recipe can be implemented as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个菜谱中转换流可以如下实现：
- en: '[PRE60]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With this code, it is clearer that we’re overriding the **_transform()** method
    with our transformation logic.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这段代码，我们可以更清晰地看到我们正在用我们的转换逻辑覆盖 **_transform()** 方法。
- en: This example uses ES6 syntax to create a custom transform stream that reads
    from **file.txt** , converts the content into uppercase, and writes it to **newFile.txt**
    . The **Uppercase** class, extending the **Transform** class, overrides the **_transform**
    method to process data chunks, converting them into uppercase with **chunk.toString().toUpperCase()**
    before pushing them to the write stream. The callback function, **callback()**
    , is invoked to indicate the completion of the current chunk’s processing, allowing
    the stream to handle the next chunk and maintain a regulated flow of data.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用 ES6 语法创建了一个自定义的转换流，该流从 **file.txt** 读取内容，将其转换为大写，并写入到 **newFile.txt**
    中。**Uppercase** 类扩展了 **Transform** 类，并覆盖了 **_transform** 方法来处理数据块，在将它们推送到写入流之前，使用
    **chunk.toString().toUpperCase()** 将它们转换为大写。回调函数 **callback()** 被调用以指示当前数据块的处理的完成，允许流处理下一个数据块并保持数据流的规律性。
- en: Creating object mode transform streams
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建对象模式转换流
- en: By default, Node.js streams operate on **String** , **Buffer** , or **Uint8Array**
    objects. However, it is also possible to work with Node.js streams in **object
    mode** . This allows us to work with other JavaScript values (except the **null**
    value). In object mode, the values that are returned from the stream are generic
    JavaScript objects. An example use case for object mode streaming could be implementing
    an application that queries a database for a large set of user records and then
    processes each user record individually.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Node.js 流操作 **String**、**Buffer** 或 **Uint8Array** 对象。然而，也可以使用 Node.js
    流在 **对象模式** 下工作。这允许我们使用其他 JavaScript 值（除了 **null** 值）。在对象模式下，从流中返回的值是通用的 JavaScript
    对象。对象模式流的一个用例是实现一个查询数据库以获取大量用户记录的应用程序，然后逐个处理每个用户记录。
- en: The main difference with object mode is that the **highWaterMark** value refers
    to the number of objects, rather than bytes. In previous recipes, we learned that
    the **highWaterMark** value dictates the maximum number of bytes that are stored
    in the internal buffer before the stream stops reading the input. For object mode
    streams, this value is set to **16** – meaning 16 objects are buffered at a time.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象模式的主要区别在于，**highWaterMark** 的值指的是对象的数目，而不是字节数。在之前的菜谱中，我们了解到 **highWaterMark**
    的值决定了在流停止读取输入之前内部缓冲区中存储的最大字节数。对于对象模式流，此值设置为 **16** – 意味着一次缓冲 16 个对象。
- en: 'To set a stream in object mode, we must pass **{ objectMode: true }** via the
    **options** object.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '要设置对象模式的流，我们必须通过 **options** 对象传递 **{ objectMode: true }**。'
- en: 'Let’s demonstrate how to create a transform stream in object mode:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示如何创建一个对象模式的转换流：
- en: 'Let’s create a folder called **object-streams** containing a file named **object-stream.js**
    and initialize the project with **npm** :'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 **object-streams** 的文件夹，包含一个名为 **object-stream.js** 的文件，并使用 **npm**
    初始化项目：
- en: '[PRE61]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Install the **ndjson** module:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 **ndjson** 模块：
- en: '[PRE62]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In **object-stream.js** , import the **Transform** class from the Node.js core
    **stream** module:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **object-stream.js** 中，从 Node.js 核心模块 **stream** 中导入 **Transform** 类：
- en: '[PRE63]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, import the **stringify()** method from the **ndjson** module:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从 **ndjson** 模块导入 **stringify()** 方法：
- en: '[PRE64]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create the transform stream, specifying **{ objectMode:** **true }** :'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建转换流，指定 **{ objectMode: true }** :'
- en: '[PRE65]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we can create our chain of streams. We will pipe the **Name** transform
    stream to the **stringify()** method (from **ndjson** ), and then pipe the result
    to **process.stdout** :'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，我们可以创建我们的流链。我们将把 **Name** 转换流连接到 **stringify()** 方法（来自 **ndjson**），然后将结果连接到
    **process.stdout** :'
- en: '[PRE66]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, still in **object-stream.js** , we’ll write some data to the **Name**
    transform stream using the **write()** method:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，仍然在 **object-stream.js** 中，我们将使用 **write()** 方法向 **Name** 转换流写入一些数据：
- en: '[PRE67]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the program with the following command:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE68]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This will output the following:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE69]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this example, we created a transform stream called **Name** that aggregates
    the value of two JSON properties ( **forename** and **surname** ) and returns
    a new property ( **name** ) with the aggregated value. The **Name** transform
    stream is in object mode and both reads and writes objects.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 **Name** 的转换流，它聚合了两个 JSON 属性（**forename** 和 **surname**）的值，并返回一个新的属性（**name**）带有聚合值。**Name**
    转换流处于对象模式，并且既读取又写入对象。
- en: We pipe our **Name** transform stream to the **stringify()** function provided
    by the **ndjson** module. The **stringify()** function converts the streamed JSON
    objects into newline-delimited JSON. The **stringify()** stream is a transform
    stream where the writable side is in object mode, but the readable side isn’t.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 **Name** 转换流连接到由 **ndjson** 模块提供的 **stringify()** 函数。**stringify()** 函数将流式
    JSON 对象转换为换行符分隔的 JSON。**stringify()** 流是一个转换流，其中可写部分处于对象模式，但可读部分不是。
- en: 'With transform streams (and duplex streams), you can independently specify
    whether the readable or writable side of the stream is in object mode by supplying
    the following configuration options:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转换流（和双工流），你可以通过提供以下配置选项来独立指定流的可读或可写部分是否处于对象模式：
- en: '**readableObjectMode** : When **true** , the readable side of the duplex stream
    is in object mode'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**readableObjectMode** : 当 **true** 时，双工流的可读部分处于对象模式'
- en: '**writableObjectMode** : When **true** , the writable side of the duplex stream
    is in object mode'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**writableObjectMode** : 当 **true** 时，双工流的可写部分处于对象模式'
- en: 'Note that it is also possible to set different **highWaterMark** values for
    the readable or writable side of a duplex stream using the following configuration
    options:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，也可以使用以下配置选项为双工流的可读或可写部分设置不同的 **highWaterMark** 值：
- en: '**readableHighWaterMark** : Configures the **highWaterMark** value for the
    readable side of the stream'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**readableHighWaterMark** : 为流的可读部分配置 **highWaterMark** 值'
- en: '**writableHighWaterMark** : Configures the **highWaterMark** value for the
    writable side of the stream'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**writableHighWaterMark** : 为流的可写部分配置 **highWaterMark** 值'
- en: The **readableHighWaterMark** and **writableHighWaterMark** configuration values
    have no effect if a **highWaterMark** value is supplied because the **highWaterMark**
    value takes precedence.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了 **highWaterMark** 值，则 **readableHighWaterMark** 和 **writableHighWaterMark**
    配置值将没有效果，因为 **highWaterMark** 值具有优先级。
- en: Using map and filter functions
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 map 和 filter 函数
- en: More recent versions of Node.js, later than version 16.4.0, provide **Experimental**
    array-like methods fo r readable streams. These methods can be used similarly
    to the array methods – for example, the **Readable.map()** and **Readable.filter()**
    methods provide similar functionality to **Array.prototype.map()** and **Array.prototype.filter()**
    .
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的较新版本（晚于 16.4.0 版本）为可读流提供了 **实验性** 的类似数组方法。这些方法可以像数组方法一样使用 - 例如，**Readable.map()**
    和 **Readable.filter()** 方法提供了类似于 **Array.prototype.map()** 和 **Array.prototype.filter()**
    的功能。
- en: 'The **map()** method can be used to map over the stream. For every chunk in
    the stream, the specified function will be called. The **transform stream** we
    created in this recipe could be rewritten using the **map()** method as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 **map()** 方法对流进行映射。对于流中的每个块，都会调用指定的函数。在本菜谱中创建的 **transform stream** 可以使用
    **map()** 方法重写如下：
- en: '[PRE70]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The **Readable.filter()** method can be used to filter a readable stream:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 **Readable.filter()** 方法来过滤可读流：
- en: '[PRE71]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'These are two recent function additions that provide array-like methods on
    readable streams. Many more array-like methods are now available on streams:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最近添加的两个函数，它们在可读流上提供了类似数组的方法。现在流上可用的类似数组方法还有很多：
- en: '**.** **drop()**'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **drop()**'
- en: '**.** **every()**'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **every()**'
- en: '**.** **filter()**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **filter()**'
- en: '**.** **find()**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **find()**'
- en: '**.** **flatMap()**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **flatMap()**'
- en: '**.** **forEach()**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **forEach()**'
- en: '**.** **map()**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **map()**'
- en: '**.** **reduce()**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **reduce()**'
- en: '**.** **some()**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **some()**'
- en: '**.** **take()**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **take()**'
- en: '**.** **toArray()**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** **toArray()**'
- en: 'More information, including the usage and parameters of these methods, can
    be found in the Node.js Stream API documentation: [https://nodejs.org/docs/latest-v22.x/api/stream.html](https://nodejs.org/docs/latest-v22.x/api/stream.html)
    .'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，包括这些方法的用法和参数，可以在 Node.js 流 API 文档中找到：[https://nodejs.org/docs/latest-v22.x/api/stream.html](https://nodejs.org/docs/latest-v22.x/api/stream.html)
    .
- en: Important note
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At the time of writing, the array-like stream methods are designated with an
    **Experimental** status.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，类似数组的流方法被指定为 **实验性** 状态。
- en: See also
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Creating readable and writable streams* recipe of this chapter
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *创建可读和可写流* 菜单
- en: The *Piping streams* recipe of this chapter
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *管道流* 菜单
- en: The *Building stream pipelines* recipe of this chapter
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *构建流管道* 菜单
- en: Building stream pipelines
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建流管道
- en: The Node.js core **stream** module provides a **pipeline()** method. Similar
    to how we can use the Node.js core stream **pipe()** method to pipe one stream
    to another, we can also use the **pipeline()** method to chain multiple streams
    together.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js核心**stream**模块提供了一个**pipeline()**方法。类似于我们可以使用Node.js核心流**pipe()**方法将一个流连接到另一个流，我们也可以使用**pipeline()**方法将多个流连接在一起。
- en: Unlike the **pipe()** method, the **pipeline()** method also forwards errors,
    making it easier to handle errors in the stream’s flow.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 与**pipe()**方法不同，**pipeline()**方法还转发错误，这使得处理流中的错误变得更加容易。
- en: This recipe builds upon many of the stream concepts that were covered in the
    other recipes in this chapter. Here, we’ll create a stream pipeline using the
    **pipeline()** method.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方基于本章其他配方中涵盖的许多流概念。在这里，我们将使用**pipeline()**方法创建一个流管道。
- en: Getting ready
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before diving into this recipe, let’s set up our workspace by creating a directory
    and files:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入这个配方之前，让我们通过创建目录和文件来设置我们的工作区：
- en: 'First, create a directory to work in named **stream-pipelines** :'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为**stream-pipelines**的工作目录：
- en: '[PRE72]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a file named **pipeline.js** :'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**pipeline.js**的文件：
- en: '[PRE73]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We’ll also need some sample data to transform. Create a file named **file.txt**
    :'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一些样本数据来转换。创建一个名为**file.txt**的文件：
- en: '[PRE74]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add some dummy text data to the **file.txt** file:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一些虚拟文本数据添加到**file.txt**文件中：
- en: '[PRE75]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now, we’re ready to start this recipe.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始这个配方。
- en: How to do it…
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we’ll create a stream pipeline using the **pipeline()** method.
    Our pipeline will read the **file.txt** file, convert the file’s contents into
    uppercase using a transform stream, and then write the new contents to a new file:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用**pipeline()**方法创建一个流管道。我们的管道将读取**file.txt**文件，使用转换流将文件内容转换为大写，然后将新内容写入新文件：
- en: 'Start by importing the Node.js core **fs** module into **pipeline.js** :'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将Node.js核心**fs**模块导入到**pipeline.js**中：
- en: '[PRE76]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, we need to import the **pipeline()** method and the **Transform** class
    from the Node.js core **stream** module:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要从Node.js核心**stream**模块导入**pipeline()**方法和**Transform**类：
- en: '[PRE77]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, we’ll create our transform stream (refer to the *Creating transform streams*
    recipe in this chapter for more information on transform streams). This will convert
    the input into uppercase strings:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的转换流（有关转换流的更多信息，请参阅本章中的*创建转换流*配方）。这将把输入转换为大写字符串：
- en: '[PRE78]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, we can start to create the stream pipeline. First, let’s call the **pipeline()**
    method:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建流管道。首先，让我们调用**pipeline()**方法：
- en: '[PRE79]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The **pipeline()** method expects the first argument to be a readable stream.
    Our first argument will be a readable stream that will read the **file.txt** file,
    using the **createReadStream()** method:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**pipeline()**方法期望第一个参数是一个可读流。我们的第一个参数将是一个可读流，它将使用**createReadStream()**方法读取**file.txt**文件：'
- en: '[PRE80]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, we need to add our transform stream as the second argument to the **pipeline()**
    method:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的转换流作为**pipeline()**方法的第二个参数添加：
- en: '[PRE81]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, we can add our writable stream to write the **newFile.txt** file to the
    pipeline:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的可写流添加到管道中，以将**newFile.txt**文件写入管道：
- en: '[PRE82]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, the last argument to our pipeline is a callback function that will
    execute once the pipeline has finished running. This callback function will handle
    any errors in our pipeline:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，管道的最后一个参数是一个回调函数，该函数将在管道运行完成后执行。此回调函数将处理管道中的任何错误：
- en: '[PRE83]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In your terminal, run the program with the following command. You should expect
    to see a message stating **Pipeline succeeded.** :'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，使用以下命令运行程序。您应该会看到一个消息表明**管道成功**：
- en: '[PRE84]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To confirm that the stream pipeline was successful, verify that the **newFile.txt**
    file contains the contents of **file.txt** , but in uppercase:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认流管道成功，请验证**newFile.txt**文件是否包含**file.txt**的内容，但为 uppercase：
- en: '[PRE85]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With that, we’ve created a stream pipeline using the **pipeline()** method that’s
    exposed by the Node.js core **stream** module.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经使用Node.js核心**stream**模块公开的**pipeline()**方法创建了一个流管道。
- en: How it works…
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The **pipeline()** method allows us to pipe streams to one another – forming
    a flow of streams.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**pipeline()**方法允许我们将流连接到一起——形成一个流流。'
- en: 'We can pass the following arguments to the stream’s **pipeline()** method:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向流的**pipeline()**方法传递以下参数：
- en: '**source** : A source stream from which to read data'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**source**：一个数据源流，从中读取数据'
- en: '**...transforms** : Any number of transform streams to process data ( including
    **0** )'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**...转换**：可以处理数据（包括**0**）的任意数量的转换流'
- en: '**destination** : A destination stream to write the processed data to'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地**：一个目标流，用于写入处理后的数据'
- en: '**callback** : The function to be called when the pipeline is complete'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调**：当管道完成时调用的函数'
- en: We pass the **pipeline()** method to our series of streams, in the order they
    need to run, followed by using a callback function that executes once the pipeline
    is complete.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 **pipeline()** 方法传递给一系列流，按照它们需要运行的顺序，然后使用一个回调函数，该函数在管道完成时执行。
- en: The **pipeline()** method elegantly forwards errors that occur in the streams
    onto the callback. This is one of the benefits of using the **pipeline()** method
    over the **pipe()** method.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**pipeline()** 方法优雅地将流中发生的错误转发到回调。这是使用 **pipeline()** 方法而不是 **pipe()** 方法的优点之一。'
- en: The **pipeline()** method also cleans up any unterminated streams by calling
    **stream.destroy()** .
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**pipeline()** 方法还会通过调用 **stream.destroy()** 清理任何未终止的流。'
- en: There’s more…
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In Node.js version 15 and later, there is a suite of asynchronous utility functions
    for streams that utilize **Promise** objects instead of callbacks. These functions
    can be found in the **stream/promises** core module. This module includes versions
    of **stream.pipeline()** and **stream.finished()** that are compatible with promises,
    providing a more modern and promise-friendly approach to stream handling.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 15 及更高版本中，有一套用于流的异步实用函数，这些函数使用 **Promise** 对象而不是回调。这些函数可以在 **stream/promises**
    核心模块中找到。此模块包括与 Promises 兼容的 **stream.pipeline()** 和 **stream.finished()** 版本，提供了一种更现代、更符合
    Promise 的流处理方法。
- en: 'Let’s convert the stream pipeline from the main recipe so that it uses the
    **Promise** version of **stream.pipeline()** :'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将主菜谱中的流管道转换为使用 **Promise** 版本的 **stream.pipeline()**：
- en: 'Create a file named **promise-pipeline.js** :'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **promise-pipeline.js** 的文件：
- en: '[PRE86]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Add the following to import the Node.js core **fs** and **stream/promises**
    modules:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到导入 Node.js 核心模块 **fs** 和 **stream/promises**：
- en: '[PRE87]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Add the transform stream:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加转换流：
- en: '[PRE88]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Since we’ll be awaiting **pipeline()** , we’ll need to wrap the **pipeline()**
    logic in an asynchronous function:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将等待 **pipeline()**，我们需要将 **pipeline()** 逻辑包裹在一个异步函数中：
- en: '[PRE89]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Finally, we can call our **run()** function, catching any errors:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以调用我们的 **run()** 函数，捕获任何错误：
- en: '[PRE90]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Run the program by using the following command:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE91]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: With that, we’ve demonstrated how to use the stream **pipeline()** method with
    Promises by using the Streams Promises API.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们展示了如何使用 Streams Promises API 通过 **pipeline()** 方法与 Promises 一起使用流。
- en: Important note
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Previously, the **pipeline()** method may have been converted into **Promise**
    form using the **util.promisify()** utility method. The **util.promisify()** method
    is used to convert a callback-style method into **Promise** form. The Streams
    Promises API replaces the need to use this.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，**pipeline()** 方法可能通过使用 **util.promisify()** 实用方法转换为 **Promise** 形式。**util.promisify()**
    方法用于将回调风格的函数转换为 **Promise** 形式。Streams Promises API 取代了使用此方法的需求。
- en: See also
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating readable and writable streams* recipe of this chapter
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *创建可读和可写流* 菜谱
- en: The *Piping streams* recipe of this chapter
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *管道流* 菜谱
- en: The *Creating transform streams* recipe of this chapter
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *创建转换流* 菜谱
