- en: Chapter 9\. Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 微服务
- en: 'Using Nest.js microservices, we are able to extract out part of our application’s
    business logic and execute it within a separate Nest.js context. By default, this
    new Nest.js context does not execute in a new thread or even a new process. For
    this reason, the name “microservices” is a bit misleading. In fact, if you stick
    with the default TCP transport, users may find that requests take longer to complete.
    However, there are benefits to offloading some pieces of your application to this
    new microservice context. To cover the basics, we will stick with the TCP transport,
    but look for some real-world strategies where Nest.js microservices can improve
    application performance in the Advanced Architecture section of this chapter.
    To see a working example, remember you can clone the accompanying Git repository
    for this book:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nest.js微服务，我们能够提取出应用程序业务逻辑的一部分，并在单独的Nest.js上下文中执行它。默认情况下，这个新的Nest.js上下文并不在新线程甚至新进程中执行。因此，“微服务”这个名称有点误导。实际上，如果您坚持使用默认的TCP传输，用户可能会发现请求完成的时间更长。然而，将应用程序的一些部分卸载到这个新的微服务上下文中也有好处。为了介绍基础知识，我们将坚持使用TCP传输，但在本章的高级架构部分中，我们将寻找一些现实世界的策略，Nest.js微服务可以提高应用程序性能。要查看一个工作示例，请记住您可以克隆本书的附带Git存储库：
- en: '`git clone https://github.com/backstopmedia/nest-book-example.git`'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/backstopmedia/nest-book-example.git`'
- en: Server bootstrap
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器引导
- en: To get started, make sure `@nestjs/microservices` is installed within your project.
    This module provides the client, server, and accompanying utilities needed to
    convert a Nest.js API application into a microservices application. Finally, we
    will modify our blog application’s bootstrap to enable microservices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请确保`@nestjs/microservices`已安装在您的项目中。该模块提供了客户端、服务器和所需的实用程序，以将Nest.js API应用程序转换为微服务应用程序。最后，我们将修改我们的博客应用程序的引导程序以启用微服务。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `connectMicroservice` method instructs the NestApplication to setup a new
    NestMicroservice context. The object provides the options for setting up the NestMicroservice
    context. Here, we are keeping things simple and using the standard TCP transport
    provided with Nest.js. A call to `startAllMicroservicesAsync` starts up the NestMicroservice
    context. Be sure to do this before calling `listen` on the NestApplication.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectMicroservice`方法指示NestApplication设置一个新的NestMicroservice上下文。该对象提供了设置NestMicroservice上下文的选项。在这里，我们保持简单，并使用Nest.js提供的标准TCP传输。调用`startAllMicroservicesAsync`启动NestMicroservice上下文。在调用NestApplication的`listen`之前，请务必这样做。'
- en: Configuration
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: 'The configuration parameters passed to `connectMicroservice` depends on the
    transport we use. A transport is a combination of a client and server that work
    in unison to transmit microservice requests and responses between the NestApplication
    and NestMicroservice contexts. Nest.js comes with a number of built-in transports
    and provides the ability to create custom transports. The available parameters
    depend on the transport we use. For now, we will use the TCP transport, but will
    cover other transports later. The possible options for the TCP transport are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`connectMicroservice`的配置参数取决于我们使用的传输方式。传输是客户端和服务器的组合，它们协同工作以在NestApplication和NestMicroservice上下文之间传输微服务请求和响应。Nest.js附带了许多内置传输，并提供了创建自定义传输的能力。可用的参数取决于我们使用的传输方式。现在，我们将使用TCP传输，但稍后会介绍其他传输方式。TCP传输的可能选项包括：
- en: '**host**: The host that is running the NestMicroservice context. The default
    is to assume `localhost` but this can be used if the NestMicroservice is running
    as a separate project on a different host such as a different Kubernetes pod.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**host**：运行NestMicroservice上下文的主机。默认值是假定为`localhost`，但如果NestMicroservice作为不同主机上的单独项目运行，例如不同的Kubernetes
    pod，可以使用这个选项。'
- en: '**port**: The port that the NestMicroservice context is listening on. The default
    is to assume `3000`, but we will use a different port to run our NestMicroservice
    context.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**port**：NestMicroservice上下文正在侦听的端口。默认值是假定为`3000`，但我们将使用不同的端口来运行我们的NestMicroservice上下文。'
- en: '**retryAttempts**: In the context of the TCP transport, this is the number
    of times the server will attempt to re-establish itself after it has received
    a `CLOSE` event.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**retryAttempts**：在TCP传输的上下文中，这是服务器在收到`CLOSE`事件后尝试重新建立自身的次数。'
- en: '**retryDelay**: Works in conjunction with `retryAttempts` and delays the transports
    retry process by a set amount of time in milliseconds.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**retryDelay**：与`retryAttempts`一起工作，并延迟传输重试过程一定的毫秒数。'
- en: First microservice handler
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个微服务处理程序
- en: For our first microservice handler, let’s convert the UserController index method
    into a microservice handler. To do this, we copy the method and make a few simple
    modifications. Instead of annotating the method with `Get`, we will use `MessagePattern`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个微服务处理程序，让我们将UserController索引方法转换为微服务处理程序。为此，我们复制该方法并进行一些简单的修改。我们将不再使用`Get`来注释该方法，而是使用`MessagePattern`。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A message pattern provides Nest.js the means for determining which microservice
    handler to execute. The pattern can be a simple string or a complex object. When
    a new microservice message is sent, Nest.js will search through all registered
    microservice handlers to find the handler that matches the message pattern exactly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 消息模式为Nest.js提供了确定要执行哪个微服务处理程序的手段。该模式可以是一个简单的字符串或一个复杂的对象。当发送新的微服务消息时，Nest.js将搜索所有已注册的微服务处理程序，以找到与消息模式完全匹配的处理程序。
- en: The microservice method itself can perform the same business logic that a normal
    controller handler can to respond in almost the same manor. Unlike a normal controller
    handler, a microservice handler has no HTTP context. In fact, decorators like
    `@Get`, `@Body`, and `@Req` make no sense and should not be used in a microservice
    controller. To complete the processing of a message, a simple value, promise,
    or RxJS Observable can be returned from the handler.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务方法本身可以执行与正常控制器处理程序几乎相同的业务逻辑来响应。与正常的控制器处理程序不同，微服务处理程序没有HTTP上下文。事实上，像`@Get`、`@Body`和`@Req`这样的装饰器在微服务控制器中没有意义，也不应该使用。为了完成消息的处理，处理程序可以返回一个简单的值、promise或RxJS
    Observable。
- en: Sending data
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送数据
- en: The previous microservice handler was very contrived. It is more likely that
    microservice handlers will be implemented to perform some processing on data and
    return some value. In a normal HTTP handler, we would use `@Req` or `@Body` to
    extract the data from the HTTP request’s body. Since microservice handlers have
    no HTTP context, they take input data as a method parameter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的微服务处理程序非常牵强。更有可能的是，微服务处理程序将被实现为对数据进行一些处理并返回一些值。在正常的HTTP处理程序中，我们会使用`@Req`或`@Body`来从HTTP请求的主体中提取数据。由于微服务处理程序没有HTTP上下文，它们将输入数据作为方法参数。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we used the `@Client` decorator to provide Nest.js Dependency
    Injection a place to inject an instance of the microservice client. The client
    decorator takes the same configuration object passed to `connectMicroservice`
    when bootstrapping the application. The client is how the NestApplication context
    communicates with the NestMicroservice context. Using the client, we modified
    the original `@Post('users')` API to offload processing of creating a new user
    to NestMicroservice context.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`@Client`装饰器为Nest.js依赖注入提供了一个注入微服务客户端实例的地方。客户端装饰器接受与在引导应用程序时传递给`connectMicroservice`相同的配置对象。客户端是NestApplication上下文与NestMicroservice上下文进行通信的方式。使用客户端，我们修改了原始的`@Post('users')`
    API，将创建新用户的处理过程转移到了NestMicroservice上下文中。
- en: '![Microservice TCP Flow](img/MicroserviceFlow001.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![微服务TCP流](img/MicroserviceFlow001.png)'
- en: This diagram shows a simplified view of the data flow when a new user is created.
    The client makes a TCP connection with the microservice context and offloads the
    processing of the database operations. The `rpcCreate` method will return a successful
    response with some data or an exception. While the microservice message is being
    processed, the normal controller handler will wait for the response.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表展示了创建新用户时数据流的简化视图。客户端与微服务上下文建立TCP连接，并将数据库操作的处理过程转移到微服务上下文中。`rpcCreate`方法将返回一个成功的响应和一些数据，或者一个异常。在处理微服务消息的同时，正常的控制器处理程序将等待响应。
- en: Take note that the microservice client `send` method returns an Observable.
    If you want to wait for the response from the microservice, simply subscribe to
    the Observable and use the response object to send the results. Alternatively,
    Nest.js treats Observables as first class citizens and can they can be returned
    from the handler. Nest.js will take care of subscribing to the Observable. Keep
    in mind, you lose a little control over the response status code and body. However,
    you can regain some of that control with exceptions and exception filters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，微服务客户端的`send`方法返回一个Observable。如果你想等待来自微服务的响应，只需订阅Observable并使用响应对象发送结果。另外，Nest.js将Observables视为一等公民，并且它们可以从处理程序中返回。Nest.js会负责订阅Observable。请记住，你会失去一些对响应状态码和主体的控制。但是，你可以通过异常和异常过滤器重新获得一些控制。
- en: Exception filters
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常过滤器
- en: Exception filters provide a means to transform exceptions thrown from microservice
    handlers into meaningful objects. For example, our `rpcCreate` method currently
    throws an error with a string but what happens when the UserService throws an
    error or possibly the ORM. This method could throw a number of different errors
    and the only means that calling method knows what happened is to parse the error
    string. That’s simply unacceptable, so let’s fix it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 异常过滤器提供了一种将从微服务处理程序抛出的异常转换为有意义对象的方法。例如，我们的`rpcCreate`方法目前抛出一个带有字符串的错误，但是当UserService抛出错误或者可能是ORM时会发生什么。这个方法可能会抛出许多不同的错误，而调用方法唯一知道发生了什么的方法是解析错误字符串。这是完全不可接受的，所以让我们来修复它。
- en: Start with creating a new exception class. Notice that our microservice exception
    extends RpcException and does not pass a HTTP status code in the constructor.
    These are the only differences between microservice exceptions and normal Nest.js
    API exceptions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的异常类。注意我们的微服务异常扩展了RpcException，并且在构造函数中没有传递HTTP状态码。这些是微服务异常和正常的Nest.js
    API异常之间唯一的区别。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can now change the `rpcCreate` method to throw this exception when the data
    is not valid.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以改变`rpcCreate`方法，当数据无效时抛出这个异常。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, create an exception filter. Microservice exception filters differ from
    their normal API counterparts by extending RpcExceptionFilter and returning an
    ErrorObservable. This filter will catch the RpcValidationException we created
    and throw an object containing a specific error code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个异常过滤器。微服务异常过滤器与它们的正常API对应物不同，它们扩展了RpcExceptionFilter并返回一个ErrorObservable。这个过滤器将捕获我们创建的RpcValidationException，并抛出一个包含特定错误代码的对象。
- en: '**Note** the `throwError` method is from the RxJS version 6 package. If you
    are still using RxJS version 5, use `Observable.throw`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**`throwError`方法来自RxJS版本6包。如果你仍在使用RxJS版本5，使用`Observable.throw`。'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All we have left is to act on our new exception when it occurs. Modify the `create`
    method to catch any exceptions thrown from the microservice client. In the catch,
    check if the `error_code` field has a value of `VALIDATION_FAILED`. When it does,
    we can return a `400` HTTP status code back to the user. This will allow the user’s
    client, the browser, to treat the error differently, possibly showing the user
    some messaging and allowing them to fix the data entered. This provides a much
    better user experience compared to throwing all errors back to the client as `500`
    HTTP status code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的异常发生时，我们所要做的就是采取行动。修改`create`方法以捕获从微服务客户端抛出的任何异常。在捕获中，检查`error_code`字段是否具有`VALIDATION_FAILED`的值。当它是这样时，我们可以向用户返回`400`的HTTP状态码。这将允许用户的客户端，即浏览器，以不同的方式处理错误，可能向用户显示一些消息并允许他们修复输入的数据。与将所有错误作为`500`的HTTP状态码返回给客户端相比，这提供了更好的用户体验。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Pipes
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: The most common pipe used with and provided by Nest.js is the ValidationPipe.
    This pipe, however, cannot be used with microservice handlers because it throws
    exceptions extending HttpException. All exceptions thrown in a microservice must
    extend RpcException. To fix this, we can extend the ValidationPipe, catch the
    HttpException, and throw an RpcException.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Nest.js中最常用的管道是ValidationPipe。然而，这个管道不能与微服务处理程序一起使用，因为它会抛出扩展HttpException的异常。在微服务中抛出的所有异常都必须扩展RpcException。为了解决这个问题，我们可以扩展ValidationPipe，捕获HttpException，并抛出RpcException。
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before we can use the ValidationPipe, we have to create a class that describes
    the format of the data our microservice method expects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ValidationPipe之前，我们必须创建一个描述我们微服务方法期望的数据格式的类。
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The new request class uses the `class-validator` NPM package to validate the
    object being passed to our microservice method from the Nest.js microservice module.
    The class contains all the properties with specific decorators to describe what
    those properties should contain. For example, the `email` property should be an
    email address, cannot be empty, must be defined, and must be a string. Now we
    just need to hook it up to our `rpcCreate` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 新的请求类使用`class-validator` NPM包来验证从Nest.js微服务模块传递给我们微服务方法的对象。该类包含所有属性，并使用特定的装饰器描述这些属性应包含的内容。例如，`email`属性应该是一个电子邮件地址，不能是空的，必须被定义，并且必须是一个字符串。现在我们只需要将其连接到我们的`rpcCreate`方法。
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since microservice handlers do not make use of the `@Body` decorator, we will
    need to use `@UsePipes` to make use of our new RpcValidationPipe. This will instruct
    Nest.js to validation the input data against it’s class type. Just like you would
    for APIs, use validation classes and the RpcValidationPipe to offload input validation
    out of your controller or microservice method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务处理程序不使用`@Body`装饰器，我们需要使用`@UsePipes`来使用我们的新的RpcValidationPipe。这将指示Nest.js根据其类类型验证输入数据。就像对API一样，使用验证类和RpcValidationPipe来将输入验证从控制器或微服务方法中卸载出来。
- en: Guards
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 守卫
- en: Guards in microservices serve the same purpose as they do in normal APIs. They
    determine if a specific microservice handler should handle a request. Up to now,
    we have used guards to protect API handlers from unauthorized access. We should
    do the same thing to our microservice handlers. Although in our application, our
    microservice handler is only called from our already protected API handler, we
    should never assume that will always be the case.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，守卫的作用与普通API中的作用相同。它们确定特定的微服务处理程序是否应该处理请求。到目前为止，我们已经使用守卫来保护API处理程序免受未经授权的访问。我们应该对我们的微服务处理程序做同样的事情。尽管在我们的应用程序中，我们的微服务处理程序只从我们已经受保护的API处理程序中调用，但我们永远不应该假设这将始终是这种情况。
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The new guard looks exactly like the API `CheckLoggedInUserGuard` guard. The
    difference is in the parameters that are passed to the `canActivate` method. Since
    this guard is being executed in the context of a microservice, it will be given
    a microservice `data` object instead of the API request object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 新的守卫看起来与API的`CheckLoggedInUserGuard`守卫完全相同。不同之处在于传递给`canActivate`方法的参数。由于这个守卫是在微服务的上下文中执行的，它将获得一个微服务`data`对象，而不是API请求对象。
- en: We use the new microservice guard the same way we did our API guard. Simply
    decorate out microservice handler with `@UseGuards` and our guard will now protect
    our microservice from misuse. Let’s make a new microservice for retrieving the
    current user’s information.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用新的微服务守卫与我们之前使用API守卫的方式相同。只需在微服务处理程序上添加`@UseGuards`装饰器，我们的守卫现在将保护我们的微服务免受滥用。让我们为检索当前用户信息创建一个新的微服务。
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `show` API handler now offloads the heavy lifting of accessing the database
    to the NestMicroservice context. The guard on the microservice handler ensures,
    if the handler is somehow invoked outside of the `show` API handler, it will still
    protect the user data from being exposed to unauthorized requests. But there is
    still a problem. This example returns the entire user object from the database,
    including the hashed password. This is a security vulnerability best solved by
    interceptors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`show` API处理程序现在将访问数据库的繁重工作交给了NestMicroservice上下文。微服务处理程序上的守卫确保，如果处理程序以某种方式在`show`API处理程序之外被调用，它仍将保护用户数据免受未经授权的请求。但仍然存在一个问题。这个示例从数据库返回整个用户对象，包括散列密码。这是一个安全漏洞，最好通过拦截器来解决。'
- en: Interceptors
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截器
- en: Microservice interceptors function no differently from normal API interceptors.
    The only difference is that the interceptor is passed the data object sent to
    the microservice handler instead of an API request object. This means you can
    actually write interceptors once and use them in both contexts. Just like API
    interceptors, microservice interceptors are executed before the microservice handler
    and must return an Observable. To secure our `rpcShow` microservice endpoint,
    we will create a new interceptor that will expect a `User` database object and
    remove the `password` field.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务拦截器的功能与普通API拦截器没有任何不同。唯一的区别是拦截器接收到的是发送到微服务处理程序的数据对象，而不是API请求对象。这意味着您实际上可以编写一次拦截器，并在两种情境下使用它们。与API拦截器一样，微服务拦截器在微服务处理程序之前执行，并且必须返回一个Observable。为了保护我们的`rpcShow`微服务端点，我们将创建一个新的拦截器，该拦截器将期望一个`User`数据库对象并移除`password`字段。
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The response from the `rpcShow` microservice handler will now have the `password`
    field removed. Notice in the interceptor we had to convert the `User` database
    object to and from JSON. This may differ depending on the ORM you make use of.
    With Sequelize, we need to get the raw data from the database response. This is
    because the response from the ORM is actually a class containing many different
    ORM methods and properties. By converting it to JSON and back, we can use the
    spread operator with `password: undefined` to delete the `password` field.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpcShow`微服务处理程序的响应现在将删除`password`字段。请注意，在拦截器中，我们必须将`User`数据库对象转换为JSON格式。这可能会因您使用的ORM而有所不同。使用Sequelize，我们需要从数据库响应中获取原始数据。这是因为ORM的响应实际上是一个包含许多不同ORM方法和属性的类。通过将其转换为JSON格式，然后使用`password:
    undefined`的扩展运算符来删除`password`字段。'
- en: Built-in transports
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置传输
- en: The TCP transport is only one of several transports Nest.js has built-in. Using
    the TCP transport, we had to bind our NestMicroservice context to an additional
    port, taking up yet another port on the server, and ensuring our NestMicroservice
    context was running before starting the NestApplication context. Other built-in
    transports can overcome these limitations and add additional benefits.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: TCP传输只是Nest.js内置的几种传输方式之一。使用TCP传输，我们必须将NestMicroservice上下文绑定到另一个端口，占用服务器上的另一个端口，并确保NestMicroservice上下文在启动NestApplication上下文之前运行。其他内置传输可以克服这些限制并增加额外的好处。
- en: Redis
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis
- en: '[Redis](https://redis.io/) is a simple in-memory data store that can be used
    as a pub-sub message broker. The Redis transport makes use of the [redis](https://github.com/NodeRedis/node_redis)
    NPM package and a Redis server to pass messages between the NestApplication and
    NestMicroservice contexts. To use the Redis transport, we need to update our `bootstrap`
    method to use the correct NestMicroservice configuration.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[Redis](https://redis.io/)是一个简单的内存数据存储，可以用作发布-订阅消息代理。Redis传输利用了[redis](https://github.com/NodeRedis/node_redis)
    NPM包和Redis服务器之间传递消息的NestApplication和NestMicroservice上下文。要使用Redis传输，我们需要更新我们的`bootstrap`方法以使用正确的NestMicroservice配置。'
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You would also have to update all locations where you have use the `@Client`
    decorator to the same settings. Instead, let’s centralize this configuration so
    we are not duplicating code and we can switch out the transport easier.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须更新所有使用`@Client`装饰器的位置，以使用相同的设置。相反，让我们将此配置集中化，这样我们就不会重复代码，并且可以更轻松地切换传输方式。
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Redis transport can take the following options:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Redis传输可以采用以下选项：
- en: '**url**: The url of the Redis server. The default is `redis://localhost:6379`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**url**：Redis服务器的URL。默认值为`redis://localhost:6379`。'
- en: '**retryAttempts**: The number of times the microservice server and client will
    attempt to reconnect to the Redis server when the connection is lost. This is
    used to create a `retry_strategy` for the `redis` NPM package.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**retryAttempts**：当连接丢失时，微服务服务器和客户端将尝试重新连接到Redis服务器的次数。这用于为`redis` NPM包创建`retry_strategy`。'
- en: '**retryDelay**: Works in conjunction with `retryAttempts` and delays the transports
    retry process by a set amount of time in milliseconds.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**retryDelay**：与`retryAttempts`配合使用，以毫秒为单位延迟传输的重试过程。'
- en: Now we can update the applications `bootstrap` to use the `microserviceConfig`
    object we have created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新应用程序的`bootstrap`以使用我们创建的`microserviceConfig`对象。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, update the `@Client` decorator in the UserController.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在UserController中更新`@Client`装饰器。
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Start up a Redis server, such as the [redis docker image](https://hub.docker.com/_/redis/)
    and the application and all our microservice transaction will now be processing
    through the Redis server. The below diagram shows a simplified view of the data
    flow when a new user is created and we are using the Redis transport.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Redis服务器，例如[redis docker image](https://hub.docker.com/_/redis/)和应用程序，所有我们的微服务事务现在将通过Redis服务器进行处理。下面的图表显示了在创建新用户并使用Redis传输时的数据流的简化视图。
- en: '![Microservice Redis Flow](img/MicroserviceFlow002.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![微服务Redis流程](img/MicroserviceFlow002.png)'
- en: Both the client and the server make a connection with the Redis server. When
    `client.send` is called, the client alters the message pattern on the fly to create
    pub and sub channels. The server consumes the message and removes the message
    pattern modification to find the correct microservice handler. Once processing
    is complete in the microservice handler, the pattern is modified again to match
    the sub channel. The client consumes this new message, unsubscribes from the sub
    channel, and passes the response back to the caller.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器都与Redis服务器建立连接。当调用`client.send`时，客户端会即时修改消息模式以创建发布和订阅通道。服务器消费消息并移除消息模式修改以找到正确的微服务处理程序。一旦微服务处理程序完成处理，模式再次被修改以匹配订阅通道。客户端消费这条新消息，取消订阅订阅通道，并将响应传递回调用者。
- en: MQTT
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MQTT
- en: '[MQTT](http://mqtt.org/) is a simple message protocol designed to be used when
    network bandwidth is a premium. The MQTT transport make use of the [mqtt](https://github.com/mqttjs/MQTT.js)
    NPM package and a remote MQTT server to pass messages between the NestApplication
    and NestMicroservice contexts. The data flow and how the microservice client and
    server operate are almost identical to the Redis transport. To make use of the
    MQTT transport, let’s update the microserviceConfig configuration object.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[MQTT](http://mqtt.org/)是一种简单的消息协议，旨在在网络带宽有限时使用。MQTT传输利用[mqtt](https://github.com/mqttjs/MQTT.js)
    NPM软件包和远程MQTT服务器在NestApplication和NestMicroservice上下文之间传递消息。数据流和微服务客户端和服务器的操作方式几乎与Redis传输相同。要使用MQTT传输，让我们更新microserviceConfig配置对象。'
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The MQTT transport can take several options, all of which are detailed in the
    Github repository for the `mqtt` NPM package. Most notably, the transport defaults
    the `url` option to `mqtt://localhost:1883` and there is no connection retrying.
    If the connection to the MQTT server is lost, microservice messages will no longer
    be passed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT传输可以采用几种选项，所有这些选项都在`mqtt` NPM软件包的Github存储库中详细说明。最值得注意的是，传输将`url`选项默认设置为`mqtt://localhost:1883`，并且没有连接重试。如果与MQTT服务器的连接丢失，微服务消息将不再传递。
- en: Start up a MQTT server, such as the [eclipse-mosquitto docker image](https://hub.docker.com/_/eclipse-mosquitto/),
    and the application and all our microservice transaction will now be processing
    through the MQTT server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 启动MQTT服务器，例如[eclipse-mosquitto docker image](https://hub.docker.com/_/eclipse-mosquitto/)，现在应用程序和所有微服务事务将通过MQTT服务器进行处理。
- en: NATS
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NATS
- en: '[NATS](https://nats.io/) is an open source message broker server that touts
    extremely high throughput. The NATS transport make use of the [nats](https://github.com/nats-io/node-nats)
    NPM package and a remote NATS server to pass messages between the NestApplication
    and NestMicroservice contexts.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[NATS](https://nats.io/)是一个自称具有极高吞吐量的开源消息代理服务器。NATS传输利用[nats](https://github.com/nats-io/node-nats)
    NPM软件包和远程NATS服务器在NestApplication和NestMicroservice上下文之间传递消息。'
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The NATS transport can take the following options:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: NATS传输可以采用以下选项：
- en: '**url**: The url of the NATS server. The default is `nats://localhost:4222`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**url**：NATS服务器的URL。默认值为`nats://localhost:4222`。'
- en: '**name**/**pass**: The username and password used to authenticate the Nest.js
    application with the NATS server.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**/**pass**：用于将Nest.js应用程序与NATS服务器进行身份验证的用户名和密码。'
- en: '**maxReconnectAttempts**: The number of times the server and client will attempt
    to reconnect to the NATS server when the connection is lost. The default is to
    attempt to reconnect 10 times.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maxReconnectAttempts**：当连接丢失时，服务器和客户端尝试重新连接到NATS服务器的次数。默认值是尝试重新连接10次。'
- en: '**reconnectTimeWait**: Works in conjunction with `maxReconnectAttempts` and
    delays the transports retry process by a set amount of time in milliseconds.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reconnectTimeWait**：与`maxReconnectAttempts`配合使用，以毫秒为单位延迟传输的重试过程。'
- en: '**servers**: An array of `url` strings all of which are NATS servers. This
    allows the transport to take advantage of a cluster of NATS servers.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**servers**：一组`url`字符串，所有这些字符串都是NATS服务器。这允许传输利用NATS服务器集群。'
- en: '**tls**: A boolean indicating if TLS should be used when connecting to the
    NATS server. **Note** this defaults to false meaning all messages are passed in
    clear text. An object can also be provided instead of a boolean, and can contain
    the standard Node TLS settings like the client certificate.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tls**：一个布尔值，指示连接到NATS服务器时是否应使用TLS。**注意**，默认值为false，这意味着所有消息都以明文传递。也可以提供对象而不是布尔值，并且可以包含标准的Node
    TLS设置，如客户端证书。'
- en: Start up a NATS server, such as the [nats docker image](https://hub.docker.com/_/nats/),
    and the application and all our microservice transaction will now be processing
    through the NATS server. The below diagram shows a simplified view of the data
    flow when a new user is created and we are using the NATS transport.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 启动NATS服务器，例如[nats docker image](https://hub.docker.com/_/nats/)，现在应用程序和所有微服务事务将通过NATS服务器进行处理。下面的图表显示了在创建新用户并使用NATS传输时数据流的简化视图。
- en: '![Microservice NATS Flow](img/MicroserviceFlow003.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![微服务NATS流程](img/MicroserviceFlow003.png)'
- en: Both the client and the server make a connection with the NATS server. When
    `client.send` is called, the client alters the message pattern on the fly to create
    pub and sub queues. One of the most notable differences between the Redis transport
    and the NATS transport is that the NATS transport makes use of queue groups. This
    means we can now have multiple NestMicroservice contexts and the NATS server will
    load balance messages between them. The server consumes the message and removes
    the message pattern modification to find the correct microservice handler. Once
    processing is complete in the microservice handler, the pattern is modified again
    to match the sub channel. The client consumes this new message, unsubscribes from
    the sub channel, and passes the response back to the caller.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器都与NATS服务器建立连接。当调用`client.send`时，客户端会即时修改消息模式以创建发布和订阅队列。Redis传输和NATS传输之间最显着的区别之一是NATS传输使用队列组。这意味着现在我们可以有多个NestMicroservice上下文，并且NATS服务器将在它们之间负载平衡消息。服务器消耗消息并移除消息模式修改以找到正确的微服务处理程序。一旦微服务处理程序完成处理，模式将再次修改以匹配订阅通道。客户端消耗这条新消息，取消订阅订阅通道，并将响应传递给调用者。
- en: gRPC
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC
- en: '[gRPC](https://grpc.io) is a remote procedural call client and server designed
    to be used with Googles [Protocol Buffers](https://developers.google.com/protocol-buffers/).
    gRPC and protocol buffers are extensive subjects worthy of their own books. For
    that reason, we will stick to discussing the setup and use of gRPC within a Nest.js
    application. To get started, we will need the [grpc](https://github.com/grpc/grpc-node)
    NPM package. Before we can write any code for our Nest.js application, we must
    write a Protocol Buffer file.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[gRPC](https://grpc.io)是一个远程过程调用客户端和服务器，旨在与Google的[Protocol Buffers](https://developers.google.com/protocol-buffers/)一起使用。gRPC和协议缓冲区是值得拥有自己的书籍的广泛主题。因此，我们将继续讨论在Nest.js应用程序中设置和使用gRPC。要开始，我们需要[grpc](https://github.com/grpc/grpc-node)
    NPM包。在我们可以为Nest.js应用程序编写任何代码之前，我们必须编写一个协议缓冲区文件。'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The above code snippet describes a single gRPC service called `UserService`.
    This will typically map to a service or controller within your own project. The
    service contains a single method, `show`, that takes in an object with a `userId`
    and returns an object with a `user` property. The `syntax` value indicates to
    the gRPC package which format of the protocol buffers language we are using. The
    `package` declaration acts as a namespace for everything we define in our proto
    file. This is most useful when importing and extending other proto files.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段描述了一个名为`UserService`的单个gRPC服务。这通常将映射到您自己项目中的一个服务或控制器。该服务包含一个名为`show`的方法，该方法接受一个带有`userId`的对象，并返回一个带有`user`属性的对象。`syntax`值指示gRPC包我们使用的协议缓冲区语言的格式。`package`声明充当我们在proto文件中定义的所有内容的命名空间。在导入和扩展其他proto文件时，这是最有用的。
- en: '**Note:** We kept the proto file pretty simple so we can focus on configuring
    Nest.js to use gRPC microservices.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**我们保持了proto文件的简单，以便我们可以专注于配置Nest.js以使用gRPC微服务。'
- en: Like all other transports, we now need to configure the NestMicroservice context
    and the microservice client in our controller.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他传输方式一样，我们现在需要在我们的控制器中配置NestMicroservice上下文和微服务客户端。
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The gRPC transport can take the following options:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC传输可以采用以下选项：
- en: '**url**: The url of the gRPC server. The default is `localhost:5000`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**url**：gRPC服务器的URL。默认值为`localhost:5000`。'
- en: '**credentials**: A `ServerCedentials` object from the `grpc` NPM package. The
    default is to use the `grpc.getInsecure` method to retrieve a default credential
    object. This will disable TLS encryption. In order to setup a secure communication
    channel, use `grpc.createSsl` and provide the root CA, private, and public certificates.
    More information about credentials can be found [here](https://grpc.io/grpc/node/grpc.credentials.html).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凭证：来自`grpc` NPM包的`ServerCedentials`对象。默认情况下，使用`grpc.getInsecure`方法来检索默认凭证对象。这将禁用TLS加密。为了建立安全的通信通道，请使用`grpc.createSsl`并提供根CA、私钥和公钥证书。有关凭证的更多信息可以在[这里](https://grpc.io/grpc/node/grpc.credentials.html)找到。
- en: '**protoPath**: The absolute path to the proto file.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**protoPath**：proto文件的绝对路径。'
- en: '**root**: An absolute path to the root of where all your proto files are found.
    This is an optional option and is most likely not necessary if you are not importing
    other proto files within your own. If this option is defined, it will be prepended
    to the `protoPath` option.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**root**：所有proto文件所在位置的绝对路径。这是一个可选选项，如果您不在自己的项目中导入其他proto文件，则很可能不需要。如果定义了此选项，它将被预置到`protoPath`选项之前。'
- en: '**package**: The name of the package to be used with the client and server.
    This should match the package name givin in the proto file.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package**：用于客户端和服务器的包的名称。这应该与proto文件中给出的包名称匹配。'
- en: We will need to make some changes to our controller before we can really use
    the gRPC transport.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正使用gRPC传输之前，我们需要对我们的控制器进行一些更改。
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that we still have the `client` property decorated with `@Client`, but
    we have a new type `ClientGrpc` and a new property `protoUserService`. The client
    injected when using the gRPC transport no longer contains a `send` method. Instead,
    it has a `getService` method that we must use to retrieve the service we defined
    in our proto file. We use the `onModuleInit` lifecycle hook so the gRPC service
    is retrieved immediately after Nest.js has instantiated our modules and before
    any clients try to use the controller APIs. The `getService` method is a generic
    and doesn’t actually contain any method definitions. Instead, we need to provide
    our own.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们仍然使用`@Client`装饰的`client`属性，但我们有一个新类型`ClientGrpc`和一个新属性`protoUserService`。使用gRPC传输时注入的客户端不再包含`send`方法。相反，它具有一个`getService`方法，我们必须使用它来检索我们在proto文件中定义的服务。我们使用`onModuleInit`生命周期钩子，以便在Nest.js实例化我们的模块之后立即检索gRPC服务，而在任何客户端尝试使用控制器API之前。`getService`方法是一个通用方法，实际上并不包含任何方法定义。相反，我们需要提供我们自己的方法。
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We could be a little more explicit with our interface but this gets the point
    across. Now the `protoUserService` property in our controller will have a `show`
    method allowing us to call the `show` gRPC service method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对我们的接口更加明确，但这可以传达要点。现在我们控制器中的`protoUserService`属性将具有一个`show`方法，允许我们调用`show`
    gRPC服务方法。
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The controller’s `show` API method gets updated to use the `protoUserService.show`.
    This will call the `rpcShow` method, but through the gRPC microservice transport.
    The `rpcShow` method contains a different decorator, `@GrpcMethod`, instead of
    `@MessagePattern`. This is required for all gRPC microservice handlers since the
    microservice is no longer matching a pattern, but instead is calling a defined
    gRPC service method. In fact, that is the mapping for the two optional parameters
    to the `@GrpcMethod` decorator: service name and service method.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的`show` API方法已更新为使用`protoUserService.show`。这将调用`rpcShow`方法，但通过gRPC微服务传输。`rpcShow`方法包含不同的装饰器`@GrpcMethod`，而不是`@MessagePattern`。这对于所有gRPC微服务处理程序是必需的，因为微服务不再匹配模式，而是调用定义的gRPC服务方法。实际上，这是`@GrpcMethod`装饰器的两个可选参数的映射：服务名称和服务方法。
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the above example, we did not defined the service name and service method
    when calling the `@GrpcMethod` decorator. Nest.js will automatically map these
    values to the method and class name. In this example, this is equivalent to `@GrpcMethod('UserController',
    'rpcShow')`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们在调用`@GrpcMethod`装饰器时没有定义服务名称和服务方法。Nest.js将自动将这些值映射到方法和类名。在这个例子中，这相当于`@GrpcMethod('UserController',
    'rpcShow')`。
- en: You may have noticed that we are using `0.0.0.0:5667` as the URL of our gRPC
    server. When we start up the Nest.js application, it will create a gRPC server
    on the localhost and listen on port `5667`. On the surface, this may look like
    a more complex version of the TCP transport. However, the power of the gRPC transport
    is directly derived from the language and platform agnostic nature of protocol
    buffers. This means we can create a Nest.js application that exposes microservices
    using gRPC that may be used by any other language or platform as long is it also
    uses protocol buffers to connect to our microservices. We can also create Nest.js
    applications that connect to microservices that may be exposed in another language
    like Go.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们将`0.0.0.0:5667`作为我们gRPC服务器的URL。当我们启动Nest.js应用程序时，它将在本地主机上创建一个gRPC服务器，并在端口`5667`上进行监听。从表面上看，这可能看起来像TCP传输的更复杂版本。但是，gRPC传输的强大之处直接源自协议缓冲区的语言和平台不可知性。这意味着我们可以创建一个使用gRPC公开微服务的Nest.js应用程序，该微服务可以被任何其他语言或平台使用，只要它也使用协议缓冲区连接到我们的微服务。我们还可以创建Nest.js应用程序，连接到可能在其他语言（如Go）中公开的微服务。
- en: '![Microservice gRPC Flow](img/MicroserviceFlow004.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![微服务gRPC流程](img/MicroserviceFlow004.png)'
- en: When using the gRPC transport to connect to services at two or more different
    URLs, we need to create an equal number of gRPC client connections, one for each
    server. The above diagram shows how processing would look if we offloaded the
    crud operations for comments in our example blog application to a Go server. We
    use a gRPC client to connect to the user microservices hosted in our Nest.js application
    and a separate one to connect to the comment microservices hosted in the Go application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用gRPC传输连接到两个或更多不同URL的服务时，我们需要创建相等数量的gRPC客户端连接，每个服务器一个。上面的图表显示了如果我们将示例博客应用程序中的评论的crud操作转移到Go服务器中，处理将会是什么样子。我们使用gRPC客户端连接到Nest.js应用程序中托管的用户微服务，另外一个连接到Go应用程序中托管的评论微服务。
- en: The same setup can be obtained by using any of the other transports. However,
    you would have to write the extra code to serialize and deserialize the messages
    between the Nest.js application and the Go application hosting the microservice.
    By using the gRPC transport, protocol buffers take care of that for you.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何其他传输都可以获得相同的设置。但是，您需要编写额外的代码来序列化和反序列化Nest.js应用程序和托管微服务的Go应用程序之间的消息。通过使用gRPC传输，协议缓冲区会为您处理这些问题。
- en: Custom transport
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义传输
- en: 'A custom transport allows you to define a new microservice client and server
    for communicating between the NestApplication and NestMicroservice contexts. You
    may want to create a custom transport strategy for a number of reasons: you or
    your company already have a message broker service that is does not have a built-in
    Nest.js transport, or you need to customize how one of the built-in transports
    works. For the purpose of our example, we will work through implementing a new
    RabbitMQ transport.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义传输允许您为NestApplication和NestMicroservice上下文之间的通信定义新的微服务客户端和服务器。您可能出于多种原因想要创建自定义传输策略：您或您的公司已经有一个没有内置Nest.js传输的消息代理服务，或者您需要自定义内置传输的工作方式。在我们的例子中，我们将通过实现一个新的RabbitMQ传输来工作。
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Nest.js requires all custom transports to implement the `CustomTransportStrategy`
    interface. This forces us to define our own `listen` and `close` methods. In our
    example, we connect to the RabbitMQ server and listen on a specific channel. Closing
    the server is as simple as disconnecting from the RabbitMQ server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Nest.js要求所有自定义传输都实现`CustomTransportStrategy`接口。这迫使我们定义自己的`listen`和`close`方法。在我们的例子中，我们连接到RabbitMQ服务器并监听特定的频道。关闭服务器就像从RabbitMQ服务器断开连接一样简单。
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By extending the Nest.js `Server` class, our custom transport comes pre-equipped
    with the RxJS handling of messages that makes Nest.js so great. However, our custom
    transport isn’t really handling messages at this point. We need to add the logic
    for how messages will be sent and received through RabbitMQ to our custom transport.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展Nest.js的`Server`类，我们的自定义传输预先配备了RxJS处理消息的功能，这使得Nest.js非常出色。然而，我们的自定义传输目前并没有真正处理消息。我们需要添加逻辑，以确定消息将如何通过RabbitMQ发送和接收到我们的自定义传输。
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The custom transport will now listen for incoming messages on the `sub` channel
    and send responses on the `pub` channel. The `handleMessage` method decodes the
    message’s content byte array and uses the embedded pattern object to find the
    correct microservice handler to service the message. For example, the `{cmd: ''users.create''}`
    will be handled by the `rpcCreate` handler. Finally, we call the handler, transform
    the response into an Observable, and pass that back into the Nest.js `Server`
    class. Once a response is provided, it will be passed on to our `sendMessage`
    method and out through the `pub` channel.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '自定义传输现在将在`sub`频道上监听传入的消息，并在`pub`频道上发送响应。`handleMessage`方法解码消息的内容字节数组，并使用嵌入的模式对象找到正确的微服务处理程序来处理消息。例如，`{cmd:
    ''users.create''}`将由`rpcCreate`处理程序处理。最后，我们调用处理程序，将响应转换为Observable，并将其传递回Nest.js的`Server`类。一旦提供了响应，它将通过我们的`sendMessage`方法传递，并通过`pub`频道传出。'
- en: Since a server is useless without a client, we will need to create one of those
    too. The RabbitMQ client must extend the Nest.js `ClientProxy` class and provide
    an override for the `close`, `connect`, and `publish` methods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器没有客户端是无用的，我们也需要创建一个客户端。RabbitMQ客户端必须扩展Nest.js的`ClientProxy`类，并为`close`、`connect`和`publish`方法提供重写。
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In our example, we created a new connection to the RabbitMQ server and the specified
    `pub` and `sub` channels. The client uses the channels in an opposite configuration
    compared to the server. The client sends messages through the `sub` channel and
    listens for responses on the `pub` channel. We also make use of the power of RxJS
    by piping all responses into a Subject to make processing simpler in the `publish`
    method. Let’s implement the `publish` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了一个新的连接到RabbitMQ服务器，并指定了`pub`和`sub`通道。客户端与服务器相比，使用了相反的通道配置。客户端通过`sub`通道发送消息，并在`pub`通道上监听响应。我们还利用了RxJS的强大功能，通过将所有响应导入Subject来简化`publish`方法中的处理。让我们实现`publish`方法。
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `publish` method starts off with assigning a unique ID to the message and
    subscribes to the response subject for sending the response back to the microservice
    caller. Finally, `sendToQueue` is called to send the message as a byte array to
    the `sub` channel. Once a response is received, the subscription to the response
    subject is fired. The first thing the subscription stream does is extract the
    `content` of the response and verify that the message ID matches the one that
    was assigned when `publish` was initially called. This keeps the client from processing
    a message response that does not belong to the specific `publish` execution context.
    Put simply, the client will receive every microservice response, even those that
    might be for a different microservice or a different execution of the same microservice.
    If the IDs match, the client checks fir errors and uses the `callback` to send
    the response back to the microservice caller.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish`方法首先为消息分配一个唯一的ID，并订阅响应主题以将响应发送回微服务调用者。最后，调用`sendToQueue`将消息作为字节数组发送到`sub`通道。一旦收到响应，就会触发对响应主题的订阅。订阅流的第一件事是提取响应的`content`并验证消息ID是否与最初调用`publish`时分配的ID匹配。这可以防止客户端处理不属于特定`publish`执行上下文的消息响应。简而言之，客户端将接收每个微服务响应，甚至可能是针对不同微服务或相同微服务的不同执行的响应。如果ID匹配，客户端会检查错误并使用`callback`将响应发送回微服务调用者。'
- en: Before we can use our new transport, we will need to update the microservice
    configuration object we created earlier.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用新传输之前，我们需要更新之前创建的微服务配置对象。
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We now have a method that will instantiate our custom transport server. This
    is used in the `bootstrap` of our application to connect our NestMicroservice
    context to the RabbitMQ server.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个方法，可以实例化我们的自定义传输服务器。这在我们应用程序的`bootstrap`中用于将我们的NestMicroservice上下文连接到RabbitMQ服务器。
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last piece of our custom transport is in our controller. Since we are using
    a custom transport, we can no longer use the `@ClientProxy` decorator. Instead,
    we have to instantiate our custom transport our selves. You could do this in the
    constructor as so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义传输的最后一部分在我们的控制器中。由于我们使用自定义传输，我们不能再使用`@ClientProxy`装饰器。相反，我们必须自己实例化我们的自定义传输。你可以在构造函数中这样做：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Wait! You have now created a hard binding between the controller and the custom
    transport client. This makes it more difficult to migrate to a different strategy
    in the future and very difficult to test. Instead, let’s make use of Nest.js’s
    fabulous Dependency Injection to create our client. Start off with creating a
    new module to house and expose our custom transport client.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！你现在在控制器和自定义传输客户端之间创建了一个硬绑定。这会使将来迁移到不同策略变得更加困难，而且非常难以测试。相反，让我们利用Nest.js的依赖注入来创建我们的客户端。首先创建一个新模块来容纳和公开我们的自定义传输客户端。
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In our example, we gave our component the injection token `'ClientProxy'`. This
    was just to keep things simple, and you can call it whatever you like. The import
    part is to make sure the injection token used to register the component is also
    the one used in the `@Inject` decorator we place in our controller’s constructor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们给我们的组件注入了标记为`'ClientProxy'`的注入令牌。这只是为了保持简单，你可以随意更改它。重要的是确保用于注册组件的注入令牌也是我们在控制器构造函数中放置`@Inject`装饰器时使用的注入令牌。
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our controller will now have a microservice client injected in at run time allowing
    the API handlers to communicate with the microservice handlers. Even better, the
    client can now be overridden in tests with a mock. Startup a RabbitMQ server,
    such as the [rabbitmq docker image](https://hub.docker.com/_/rabbitmq/) , and
    setup the `AMQP_URL` environment variable, ie `amqp://guest:guest@localhost:5672`,
    and all microservice requests will be processed through the RabbitMQ server.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器现在将在运行时注入一个微服务客户端，允许API处理程序与微服务处理程序进行通信。更好的是，客户端现在可以在测试中被模拟重写。启动一个RabbitMQ服务器，比如[rabbitmq
    docker image](https://hub.docker.com/_/rabbitmq/)，并设置`AMQP_URL`环境变量，即`amqp://guest:guest@localhost:5672`，所有微服务请求将通过RabbitMQ服务器进行处理。
- en: The data flow and how the microservice client and server operate in our RabbitMQ
    example are almost identical to the NATS transport. Just like with NATS, RabbitMQ
    provides the ability to have multiple NestMicroservice contexts consuming messages.
    RabbitMQ will work to load balance between all the consumers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的RabbitMQ示例中，微服务客户端和服务器的数据流以及操作方式几乎与NATS传输相同。就像NATS一样，RabbitMQ提供了多个NestMicroservice上下文消费消息的能力。RabbitMQ将在所有消费者之间进行负载均衡。
- en: Hybrid application
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合应用程序
- en: When we first started our microservice implementation in this chapter, we modified
    the bootstrap method to call `connectMicroservice`. This is a special method that
    converts our Nest.js application into a hybrid application. This simply means
    our application now contains multiple context types. Simple enough but this has
    some implications that you should be aware of. Specifically, using the hybrid
    application approach, you will no longer be able to attach global filters, pipes,
    guards, and interceptors for the NestMicroservice context. This is because the
    NestMicroservice context is immediately bootstrapped, but not connected, in a
    hybrid application. To get around this limitation, we can create our two contexts
    independently.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章开始实现微服务时，我们修改了启动方法来调用`connectMicroservice`。这是一个特殊的方法，将我们的Nest.js应用程序转换为混合应用程序。这意味着我们的应用程序现在包含多种上下文类型。这很简单，但这有一些影响，你应该意识到。具体来说，使用混合应用程序方法，你将无法再为NestMicroservice上下文附加全局过滤器、管道、守卫和拦截器。这是因为NestMicroservice上下文会立即启动，但在混合应用程序中不会连接。为了解决这个限制，我们可以独立地创建我们的两个上下文。
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that we are creating the two application contexts independently, we can
    make use of globals for the NestMicroservice context. To test this, we can update
    the `rpcCreate` handler to remove the `RpcValidationFilter`. Executing the application
    at this point should still result in validation errors being returned when the
    request to the `create` API does not contain required fields.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在独立创建两个应用程序上下文，我们可以利用NestMicroservice上下文的全局变量。为了测试这一点，我们可以更新`rpcCreate`处理程序以删除`RpcValidationFilter`。在这一点上执行应用程序仍然应该导致在请求`create`API时不包含必需字段时返回验证错误。
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can extend this approach of bootstrapping our application to split even more
    of our application into separate contexts. This still does not make use of multiple
    processes or threads, but employing some more advanced architecture design, we
    can gain those benefits.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展这种启动应用程序的方法，将更多的应用程序拆分为独立的上下文。这仍然不使用多个进程或线程，但通过使用一些更高级的架构设计，我们可以获得这些好处。
- en: Advanced architecture design
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级架构设计
- en: So far we have covered everything needed to setup and start writing and using
    microservices in Nest.js. Along the way we describe some of the drawbacks Nest.js’
    implementation of microservices has. Most notably, since the microservices does
    not run in a separate thread or process, you may not be gaining much in the way
    of performance when using Nest.js microservices.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了在Nest.js中设置和开始编写和使用微服务所需的一切。在这一过程中，我们描述了Nest.js微服务的一些缺点。特别是，由于微服务不在单独的线程或进程中运行，使用Nest.js微服务时可能在性能方面并没有太多收益。
- en: However, that is not to say you can’t get these benefits. Nest.js just doesn’t
    provide the tools out of the box. In most material found on the subject of running
    a NodeJS application in production, the one thing that is typically always covered
    and recommended is the use of the NodeJS `cluster` module. We can do the same
    thing with our Nest.js application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不是说你不能获得这些好处。Nest.js只是没有提供开箱即用的工具。在大多数关于在生产环境中运行NodeJS应用程序的资料中，通常总是涵盖并推荐使用NodeJS的`cluster`模块。我们可以在我们的Nest.js应用程序中做同样的事情。
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, not only does our NestApplication and NestMicroservice contexts run on
    their own threads, they are also clustered according to the number of CPUs available
    on the server. For each CPU, a separate NestApplication and NestMicroservice context
    will be created. The NestApplication context threads will share the main application
    port. Finally, since we are using RabbitMQ, having multiple NestMicroservice contexts
    running, we have multiple subscribers waiting for microservice messages. RabbitMQ
    will take care of load balancing message distribution between all of our NestMicroservice
    instances. We have made our application more resilient and better equipped to
    handle a heavier load of users than what it was at the beginning of this chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的NestApplication和NestMicroservice上下文不仅在自己的线程上运行，而且根据服务器上可用的CPU数量进行集群化。对于每个CPU，将创建一个单独的NestApplication和NestMicroservice上下文。NestApplication上下文线程将共享主应用程序端口。最后，由于我们使用RabbitMQ，运行多个NestMicroservice上下文，我们有多个订阅者等待微服务消息。RabbitMQ将负责在所有NestMicroservice实例之间负载平衡消息分发。我们使我们的应用程序更具弹性，更能够处理比本章开始时更多的用户负载。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At the beginning of this chapter, we stated “microservice” was a misleading
    name for this part of Nest.js. In fact, that could still be the case, but it really
    depends on a number of factors. Our initial example using the TCP transport could
    hardly qualify as a microservice by all conventional definitions. Both the NestApplication
    and NestMicroservice context were executing from the same process, meaning a catastrophic
    failure in one could bring both down.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们说“微服务”是Nest.js的一个误导性名称。事实上，情况可能仍然如此，但这实际上取决于许多因素。我们最初使用TCP传输的示例几乎无法符合所有传统定义的微服务。NestApplication和NestMicroservice上下文都是从同一个进程中执行的，这意味着一个的灾难性故障可能会导致两者都崩溃。
- en: After highlighting all the transports, Nest.js comes with out-of-the-box, and
    we re-implemented our microservices in the example blog application using a custom
    RabbitMQ transport. We even went as far as running the NestApplication and NestMicroservice
    contexts in their own thread. This was a major step in the right direction for
    fulfilling the “microservice” name.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在突出Nest.js开箱即用的所有传输方式之后，我们在示例博客应用程序中使用自定义的RabbitMQ传输重新实现了我们的微服务。我们甚至将NestApplication和NestMicroservice上下文运行在自己的线程中。这是朝着实现“微服务”名称的正确方向迈出的重要一步。
- en: Although we didn’t cover specifics in this book, it should now be apparent that
    you’re not limited to using microservices defined in the same Nest.js project
    or repository. Using transports like Redis and RabbitMQ, we could create and use
    multiple Nest.js projects for the sole purpose of executing a NestMicroservice
    context. All of these projects can be running independently inside a Kubernetes
    cluster and accessed by passing messages via Redis or RabbitMQ. Even better, we
    can use the built-in gRPC transport to communicate with microservices wrote in
    other languages and deployed to other platforms.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本书中没有涵盖具体细节，但现在显而易见的是，您不仅限于在同一个Nest.js项目或存储库中使用微服务。使用诸如Redis和RabbitMQ之类的传输方式，我们可以创建并使用多个Nest.js项目，其唯一目的是执行NestMicroservice上下文。所有这些项目都可以独立在Kubernetes集群中运行，并通过Redis或RabbitMQ传递消息进行访问。更好的是，我们可以使用内置的gRPC传输与其他语言编写的微服务进行通信，并部署到其他平台上。
- en: In the next chapter we will learn about routing and request handling in Nest.js.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Nest.js中的路由和请求处理。
