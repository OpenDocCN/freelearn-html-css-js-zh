- en: Chapter 7. Static Data Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 静态数据管理
- en: So far, we have implemented capabilities related to basic features of the application.
    From now on, we will start implementing the application's core features, starting
    with static data management. What exactly is this? Every application has information
    that is not directly related to the core business, but this information is used
    by the core business logic somehow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了与应用程序基本功能相关的功能。从现在开始，我们将开始实现应用程序的核心功能，从静态数据管理开始。这究竟是什么？每个应用程序都有与核心业务不直接相关的信息，但以某种方式被核心业务逻辑使用。这就是我们称之为静态数据的原因，因为它不经常改变。还有动态数据，这是在应用程序中变化的信息，我们称之为核心业务数据。客户、订单和销售将是动态或核心业务数据的例子。
- en: 'There are two types of data in every application: static data and dynamic data.
    For example, the types of categories, languages, cities, and countries can exist
    independently of the core business and can be used by the core business information
    as well; this is what we call static data because it does not change very often.
    And there is the dynamic data, which is the information that changes in the application,
    what we call core business data. Clients, orders, and sales would be examples
    of dynamic or core business data.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序中都有两种类型的数据：静态数据和动态数据。例如，类别、语言、城市和国家类型可以独立于核心业务存在，也可以被核心业务信息使用；这就是我们称之为静态数据的原因，因为它不经常改变。还有动态数据，这是在应用程序中变化的信息，我们称之为核心业务数据。客户、订单和销售将是动态或核心业务数据的例子。
- en: 'We can treat this static information as though they are independent MySQL tables
    (since we are using MySQL as the database server), and we can perform all the
    actions we can do on a MySQL table. So in this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些静态信息视为独立的MySQL表格（因为我们使用MySQL作为数据库服务器），我们可以执行在MySQL表格上可以执行的所有操作。因此，在本章中，我们将涵盖：
- en: Creating a new system module called static data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为静态数据的新系统模块
- en: Listing all information as a MySQL table
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有信息作为MySQL表格列出
- en: Creating new records on the tables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表格上创建新记录
- en: Live search on the table
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格上的实时搜索
- en: Filtering information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤信息
- en: Editing and deleting a record
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑和删除记录
- en: Creating an abstract component for reuse in all tables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用于所有表格重用的抽象组件
- en: Presenting the tables
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示表格
- en: 'If we open and analyze the **Entity Relationship** (**ER**) diagram that comes
    with the Sakila installation, we will notice the following tables:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开并分析随Sakila安装提供的**实体关系**（**ER**）图，我们会注意到以下表格：
- en: '![Presenting the tables](img/0457OT_07_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![展示表格](img/0457OT_07_01.jpg)'
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a reminder, the Sakila database can be downloaded at [http://dev.mysql.com/doc/index-other.html](http://dev.mysql.com/doc/index-other.html),
    and its documentation with installation instructions can be found at [http://dev.mysql.com/doc/sakila/en/](http://dev.mysql.com/doc/sakila/en/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，Sakila数据库可以从[http://dev.mysql.com/doc/index-other.html](http://dev.mysql.com/doc/index-other.html)下载，其文档和安装说明可在[http://dev.mysql.com/doc/sakila/en/](http://dev.mysql.com/doc/sakila/en/)找到。
- en: These tables can exist independently of the other tables, and we are going to
    work with them in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表格可以独立于其他表格存在，我们将在本章中与它们一起工作。
- en: 'When we open SQL editor in MySQL Workbench (version 6 ) ([http://dev.mysql.com/downloads/workbench/](http://dev.mysql.com/downloads/workbench/)),
    we can select a table, right-click on it, and select **Select Rows – Limit 1000**.
    When we choose this option, a new tab will be opened, and it looks as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在MySQL Workbench（版本6）中打开SQL编辑器时（[http://dev.mysql.com/downloads/workbench/](http://dev.mysql.com/downloads/workbench/))，我们可以选择一个表格，右键单击它，并选择**选择行
    – 限制1000**。当我们选择此选项时，将打开一个新标签页，其外观如下：
- en: '![Presenting the tables](img/0457OT_07_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![展示表格](img/0457OT_07_02.jpg)'
- en: 'The table shown previously is the `actor` table. The idea is to implement screens
    that look similar to the preceding screenshot for each of the tables that we selected:
    **Actors**, **Categories**, **Languages**, **Cities**, and **Countries** as displayed
    in the following screenshot (which is the final result of the code that we will
    be implementing in this chapter):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的表格是`actor`表格。我们的想法是为我们选择的每个表格实现类似于前一个屏幕截图的屏幕：**演员**、**类别**、**语言**、**城市**和**国家**，如以下屏幕截图所示（这是我们将在本章中实现的代码的最终结果）：
- en: '![Presenting the tables](img/0457OT_07_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![展示表格](img/0457OT_07_03.jpg)'
- en: Our goal in this chapter is to minimize the amount of code to implement these
    five screens. This means we want to create the most generic code as possible and
    will facilitate future code fixes and enhancements and also make it easier to
    create new screens with these same features if needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的目标是尽量减少实现这五个屏幕所需的代码量。这意味着我们希望尽可能创建最通用的代码，这将有助于未来的代码修复和增强，并且如果需要，也更容易创建具有相同功能的新的屏幕。
- en: So let's go ahead and start the development.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始开发吧。
- en: Creating a Model
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'As usual, we are going to start by creating the models. First, let''s list
    the tables we will be working with and their columns:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将从创建模型开始。首先，让我们列出我们将要处理的表及其列：
- en: '`Actor`: `actor_id`, `first_name`, `last_name`, `last_update`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Actor`: `actor_id`, `first_name`, `last_name`, `last_update`'
- en: '`Category`: `category_id`, `name`, `last_update`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Category`: `category_id`, `name`, `last_update`'
- en: '`Language`: `language_id`, `name`, `last_update`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Language`: `language_id`, `name`, `last_update`'
- en: '`City`: `city_id`, `city`, `country_id`, `last_update`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`City`: `city_id`, `city`, `country_id`, `last_update`'
- en: '`Country`: `country_id`, `country`, `last_update`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Country`: `country_id`, `country`, `last_update`'
- en: We could create one Model for each of these entities with no problem at all;
    however, we want to reuse as much code as possible. Take another look at the list
    of tables and their columns. Notice that all tables have one column in common—the
    `last_update` column.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为这些实体中的每一个创建一个模型，完全没有问题；然而，我们希望尽可能多地重用代码。再次查看表和列的列表。注意，所有表都有一个共同的列——`last_update`列。
- en: All the previous tables have the `last_update` column in common. That being
    said, we can create a super model that contains this field. When we implement
    the `actor` and `category` models, we can extend the super Model, in which case
    we do not need to declare the column. Don't you think?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个表都有一个共同的`last_update`列。换句话说，我们可以创建一个包含此字段的超级模型。当我们实现`actor`和`category`模型时，我们可以扩展超级模型，在这种情况下，我们不需要声明列。你不这么认为吗？
- en: Abstract Model
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象模型
- en: In OOP, there is a concept called inheritance, which is a way to reuse the code
    of existing objects. Ext JS uses an OOP approach, so we can apply the same concept
    in Ext JS applications. If you take a look back at the code we already implemented,
    you will notice that we are already applying inheritance in most of our classes
    (with the exception of the `util` package), but we are creating classes that inherit
    from Ext JS classes. Now, we will start creating our own super classes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，有一个称为继承的概念，这是一种重用现有对象代码的方式。Ext JS使用面向对象的方法，因此我们可以在Ext JS应用程序中应用相同的概念。如果你回顾一下我们已实现的代码，你会注意到我们已经在大多数类中应用了继承（除了`util`包），但我们正在创建继承自Ext
    JS类的类。现在，我们将开始创建我们自己的超级类。
- en: 'As all the models that we will be working with have the `last_update` column
    in common (if you take a look, all the Sakila tables have this column), we can
    create a super Model with this field. So, we will create a new file under `app/model/staticData`
    named `Base.js`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要处理的模型都具有共同的`last_update`列（如果你看一下，所有的Sakila表都有这个列），我们可以创建一个包含此字段的超级模型。因此，我们将在`app/model/staticData`下创建一个新的文件，命名为`Base.js`：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This Model has only one column, that is, `last_update`. On the tables, the `last_update`
    column has the type `timestamp`, so the `type` of the field needs to be `date`,
    and we will also apply `date format:` '`Y-m-j H:i:s`', which is years, months,
    days, hours, minutes, and seconds, following the same format as we have in the
    database (`2006-02-15 04:34:33`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型只有一个列，即`last_update`。在表中，`last_update`列的类型是`timestamp`，因此字段的`type`需要是`date`，我们还将应用`date
    format:` `'Y-m-j H:i:s'`，这是年、月、日、时、分、秒，遵循与数据库中相同的格式（`2006-02-15 04:34:33`）。
- en: When we can create each Model representing the tables, we will not need to declare
    the `last_update` field again.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们可以为每个表示表的模型创建模型时，我们就不需要再次声明`last_update`字段。
- en: Look again at the code at line `#1`. We are not extending the default `Ext.data.Model`
    class, but another `Base` class. Remember the `security.Base` Model we created
    in the preceding chapter? We are going to move its code to the model package and
    make some changes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看第`#1`行的代码。我们没有扩展默认的`Ext.data.Model`类，而是另一个`Base`类。还记得我们在上一章中创建的`security.Base`模型吗？我们将将其代码移动到模型包中并进行一些修改。
- en: Adapting the Base Model schema
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配Base模型架构
- en: 'Create a file named `Base.js` inside the `app/model` folder with the following
    content in it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/model`文件夹内创建一个名为`Base.js`的文件，并在其中包含以下内容：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only difference between this code and the code we implemented in the preceding
    chapter is `namespace` (`#1`). Instead of using `Packt.model.security`, we are
    going to use only `Packt.model`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一章中实现的代码相比，唯一的区别是`namespace`（`#1`）。我们不再使用`Packt.model.security`，而是将仅使用`Packt.model`。
- en: 'The `Packt.model.security.Base` class we created in the preceding chapter will
    look simpler now as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中创建的`Packt.model.security.Base`类现在看起来会更简单，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is very similar to the `staticData.Base` Model we are creating for this chapter.
    The difference is in the field that is common for the `staticData` package (`last_update`)
    and `security` package (`id`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它与我们为本章创建的`staticData.Base`模型非常相似。区别在于`staticData`包（`last_update`）和`security`包（`id`）共有的字段。
- en: 'Having a single schema for the application now means `entityName` of the models
    will be created based on their name after `''Packt.model''`. This means that the
    `User` and `Group` models we created in the preceding chapter will have `entityName`
    `security.User`, and `security.Group` respectively. However, we do not want to
    break the code we have implemented already, and for this reason we want the `User`
    and `Group` Model classes to have the entity name as `User` and `Group`. We can
    do this by adding `entityName: ''User''` to the `User` Model and `entityName:
    ''Group''` to the `Group` Model. We will do the same for the specific models we
    will be creating next.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '现在应用程序只有一个模式，这意味着模型的`entityName`将基于`''Packt.model''`之后的名称创建。这意味着我们在上一章中创建的`User`和`Group`模型将分别具有`entityName`
    `security.User`和`security.Group`。然而，我们不希望破坏已经实现的代码，因此我们希望`User`和`Group`模型类具有`entityName`
    `User`和`Group`。我们可以通过向`User`模型添加`entityName: ''User''`和向`Group`模型添加`entityName:
    ''Group''`来实现这一点。我们也将对接下来要创建的特定模型做同样的事情。'
- en: Having a super `Base` Model for all models within the application means our
    models will follow a pattern. The proxy template is also common for all models,
    and this means our server-side code will also follow a pattern. This is good to
    organize the application and for future maintenance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序中的所有模型都有一个超级`Base`模型，这意味着我们的模型将遵循一个模式。代理模板对所有模型也是通用的，这意味着我们的服务器端代码也将遵循一个模式。这对于组织应用程序和未来的维护是有益的。
- en: Specific models
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定模型
- en: 'Now we can create all the models representing each table. Let''s start with
    the Actor Model. We will create a new class named `Packt.model.staticData.Actor`;
    therefore, we need to create a new file name `Actor.js` under `app/model/staticData`,
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建代表每个表的模型。让我们从Actor模型开始。我们将创建一个名为`Packt.model.staticData.Actor`的新类；因此，我们需要在`app/model/staticData`下创建一个名为`Actor.js`的新文件，如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are three important things we need to note in the preceding code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们需要注意三个重要的事项：
- en: This Model is extending (`#1`) from the `Packt.model.staticData.Base` class,
    which extends from the `Packt.model.Base` class, which in turn extends from the
    `Ext.data.Model` class. This means this Model inherits all the attributes and
    behavior from the classes `Packt.model.staticData.Base`, `Packt.model.Base`, and
    `Ext.data.Model`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此模型扩展自`Packt.model.staticData.Base`类，该类又扩展自`Packt.model.Base`类，而`Packt.model.Base`类又扩展自`Ext.data.Model`类。这意味着此模型继承了`Packt.model.staticData.Base`、`Packt.model.Base`和`Ext.data.Model`类的所有属性和行为。
- en: As we created a super Model with the schema `Packt.model`, the default `entityName`
    created for this Model would be `staticData.Actor`. We are using `entityName`
    to help the proxy compile the `url` template with `entityName`. To make our life
    easier we are going to overwrite `entityName` as well (`#2`).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用`Packt.model`模式创建了一个超级模型，因此为该模型创建的默认`entityName`将是`staticData.Actor`。我们使用`entityName`来帮助代理编译带有`entityName`的`url`模板。为了使我们的工作更简单，我们将重写`entityName`（`#2`）。
- en: The third point is `idProperty` (`#3`). By default, `idProperty` has the value
    "`id`". This means that when we declare a Model with a field named "`id`", Ext
    JS already knows that this is the unique field of this Model. When it is different
    from "`id`", we need to specify it using the `idProperty` configuration. As all
    Sakila tables do not have a unique field called "`id`"—it is always the *name
    of the entity* + "*_id*"—we will need to declare this configuration in all models.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三点是`idProperty`（`#3`）。默认情况下，`idProperty`的值是"`id`"。这意味着当我们声明一个名为"`id`"的字段时，Ext
    JS 已经知道这是该模型的唯一字段。当它不同于"`id`"时，我们需要使用`idProperty`配置来指定它。由于所有 Sakila 表都没有名为"`id`"的唯一字段——它总是`实体名称`
    + "*_id*"，因此我们需要在所有模型中声明此配置。
- en: 'Now we can do the same for the other models. We need to create four more classes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为其他模型做同样的事情。我们需要创建四个更多类：
- en: '`Packt.model.staticData.Category`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.model.staticData.Category`'
- en: '`Packt.model.staticData.Language`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.model.staticData.Language`'
- en: '`Packt.model.staticData.City`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.model.staticData.City`'
- en: '`Packt.model.staticData.Country`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.model.staticData.Country`'
- en: 'At the end, we will have six Model classes (one super Model and five specific
    models) created inside the `app/model/staticData` package. If we create a UML-class
    diagram for the Model classes, we will have the following diagram:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在 `app/model/staticData` 包内创建六个模型类（一个超级模型和五个特定模型）。如果我们为模型类创建一个 UML 类图，我们将得到以下图示：
- en: '![Specific models](img/0457OT_07_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![特定模型](img/0457OT_07_04.jpg)'
- en: The **Actor**, **Category**, **Language**, **City**, and **Country** models
    extend the `Packt.model.staticData` Base Model, which extends from `Packt.model.Base`,
    which in turn extends the `Ext.data.Model` class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Actor**、**Category**、**Language**、**City** 和 **Country** 模型扩展了 `Packt.model.staticData`
    基础模型，该模型从 `Packt.model.Base` 扩展而来，而 `Packt.model.Base` 又从 `Ext.data.Model` 类扩展而来。'
- en: Creating a Store
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Store
- en: The next step is to create the stores for each Model. As we did with the Model,
    we will try to create a generic Store as well (in this chapter, will create a
    generic code for all screens, so creating a super Model, Store, and View is part
    of the capability). Although the common configurations are not in the Store, but
    in the Proxy (which we declared inside the schema in the `Packt.model.Base` class),
    having a super Store class can help us to listen to events that are common for
    all the static data stores.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为每个模型创建 Store。就像我们对模型所做的那样，我们将尝试创建一个通用 Store（在本章中，我们将为所有屏幕创建通用代码，因此创建超级模型、Store
    和 View 是能力的一部分）。尽管通用配置不在 Store 中，但在 Proxy 中（我们在 `Packt.model.Base` 类的 schema 中声明了它），拥有一个超级
    Store 类可以帮助我们监听所有静态数据 Store 的通用事件。
- en: We will create a super Store named `Packt.store.staticData.Base`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `Packt.store.staticData.Base` 的超级 Store。
- en: 'As we need a Store for each Model, we will create the following stores:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要为每个模型创建一个 Store，我们将创建以下 Store：
- en: '`Packt.store.staticData.Actors`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.store.staticData.Actors`'
- en: '`Packt.store.staticData.Categories`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.store.staticData.Categories`'
- en: '`Packt.store.staticData.Languages`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.store.staticData.Languages`'
- en: '`Packt.store.staticData.Cities`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.store.staticData.Cities`'
- en: '`Packt.store.staticData.Countries`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.store.staticData.Countries`'
- en: 'At the end of this topic, we will have created all the previous classes. If
    we create a UML diagram for them, we will have something like the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题结束时，我们将创建所有之前的类。如果我们为它们创建一个 UML 图，我们将得到如下所示的图示：
- en: '![Creating a Store](img/0457OT_07_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Store](img/0457OT_07_05.jpg)'
- en: All the Store classes extend from the `Base` Store.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Store 类都扩展自 `Base` Store。
- en: Now that we know what we need to create, let's get our hands dirty!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们需要创建什么，让我们动手吧！
- en: Abstract Store
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象 Store
- en: 'The first class we need to create is the `Packt.store.staticData.Base` class.
    Inside this class, we will only declare `autoLoad` as `true` so that all the subclasses
    of this Store can be loaded when the application launches:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的第一个类是 `Packt.store.staticData.Base` 类。在这个类中，我们只声明 `autoLoad` 为 `true`，以便所有这个
    Store 的子类在应用程序启动时都可以被加载：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All the specific stores that we will create will extend this Store. Creating
    a super Store like this can feel pointless; however, we do not know that during
    future maintenance, we will need to add some common Store configuration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的所有特定 Store 都将扩展这个 Store。创建这样一个超级 Store 可能感觉没有意义；然而，我们不知道在未来的维护中，我们是否需要添加一些通用的
    Store 配置。
- en: As we will use MVC for this module, another reason is that inside the Controller,
    we can also listen to Store events (available since Ext JS 4.2). If we want to
    listen to the same event of a set of stores and we execute exactly the same method,
    having a super Store will save us some lines of code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在这个模块中使用 MVC，另一个原因是我们在 Controller 中也可以监听 Store 事件（自 Ext JS 4.2 版本起可用）。如果我们想监听一组
    Store 的相同事件，并且执行完全相同的方法，拥有一个超级 Store 可以节省我们一些代码行。
- en: Specific Store
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定 Store
- en: Our next step is to implement the `Actors`, `Categories`, `Languages`, `Cities`,
    and `Countries` stores.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是实现 `Actors`、`Categories`、`Languages`、`Cities` 和 `Countries` 存储。
- en: 'So let''s start with the `Actors` Store:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从 `Actors` Store 开始：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After the definition of the Store, we need to extend from the Ext JS `Store`
    class. As we are using a super Store, we can extend directly from the super Store
    (`#1`), which means extending from the `Packt.store.staticData.Base` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义Store之后，我们需要从Ext JS `Store`类扩展。由于我们使用的是超级Store，我们可以直接从超级Store扩展（`#1`），这意味着从`Packt.store.staticData.Base`类扩展。
- en: Next, we need to declare the `fields` or the `model` that this Store is going
    to represent. In our case, we always declare the Model (`#2`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要声明这个Store将要表示的`fields`或`model`。在我们的例子中，我们总是声明Model（`#2`）。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using a `model` inside the Store is good for reuse purposes. The `fields` configuration
    is recommended just in case we need to create a very specific Store with specific
    data that we are not planning to reuse throughout the application, as in a chart
    or a report.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Store中使用`model`对于重用是有好处的。`fields`配置建议仅在需要创建一个非常具体的Store，其中包含我们不打算在整个应用程序中重用的特定数据时使用，例如在图表或报告中。
- en: For the other stores, the only thing that is going to be different is the name
    of the Store and the Model.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他存储，唯一将要不同的事情是Store和Model的名称。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As models and stores are very similar, we are not going to list their code in
    this chapter. However, if you need the code to compare with yours or simply want
    to get the complete source code, you can download the code bundle from this book
    or get it at [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模型和存储非常相似，我们不会在本章中列出它们的代码。然而，如果您需要与您的代码进行比较或只是想获取完整的源代码，您可以从本书中下载代码包或从[https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs)获取。
- en: Creating an abstract GridPanel for reuse
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于重用的抽象GridPanel
- en: 'Now is the time to implement the views. We have to implement five views: one
    to perform the CRUD operations for Actor, one for Category, one for Language,
    one for City, and one for Country.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实施视图的时候了。我们必须实现五个视图：一个用于执行Actor的CRUD操作，一个用于Category，一个用于Language，一个用于City，还有一个用于Country。
- en: 'The following screenshot represents the final result we want to achieve after
    implementing the **Actors** screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图表示在实现**Actors**屏幕后我们想要达到的最终结果：
- en: '![Creating an abstract GridPanel for reuse](img/0457OT_07_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![创建用于重用的抽象GridPanel](img/0457OT_07_06.jpg)'
- en: 'And the following screenshot represents the final result we want to achieve
    after implementing the **Categories** screen:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图表示在实现**Categories**屏幕后我们想要达到的最终结果：
- en: '![Creating an abstract GridPanel for reuse](img/0457OT_07_07.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![创建用于重用的抽象GridPanel](img/0457OT_07_07.jpg)'
- en: 'Did you notice anything similar between these two screens? Let''s take a look
    again:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到这两个屏幕之间有什么相似之处吗？让我们再看一遍：
- en: '![Creating an abstract GridPanel for reuse](img/0457OT_07_08.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![创建用于重用的抽象GridPanel](img/0457OT_07_08.jpg)'
- en: The top toolbar is the same (**1**); there is a Live Search capability (**2**);
    there is a filter plugin (**4**), and the **Last Update** and widget columns are
    also common (**3**). Going a little bit further, both GridPanels can be edited
    using a cell editor (similar to MS Excel capabilities, where you can edit a single
    cell by clicking on it). The only things different between these two screens are
    the columns that are specific to each screen (**5**). Does this mean we can reuse
    a good part of the code if we use inheritance by creating a super GridPanel with
    all these common capabilities? Yes!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的工具栏是相同的（**1**）；有一个实时搜索功能（**2**）；有一个过滤器插件（**4**），以及**最后更新**和部件列也是通用的（**3**）。再进一步，两个GridPanels都可以使用单元格编辑器进行编辑（类似于MS
    Excel的功能，您可以点击单个单元格来编辑它）。这两个屏幕之间唯一的不同之处在于每个屏幕特有的列（**5**）。这意味着如果我们通过创建一个具有所有这些通用功能的超级GridPanel来使用继承，我们可以重用代码的一部分吗？是的！
- en: 'So this is what we are going to do. So let''s create a new class named `Packt.view.staticData.BaseGrid`,
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是我们要做的。让我们创建一个名为`Packt.view.staticData.BaseGrid`的新类，如下所示：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will extend the `Ext.ux.LiveSearchGridPanel` class instead of `Ext.grid.Panel`.
    The `Ext.ux.LiveSearchGridPanel` class already extends the `Ext.grid.Panel` class
    and also adds the Live Search toolbar (**2**). The `LiveSearchGridPanel` class
    is a plugin that is distributed with the Ext JS SDK. So, we do not need to worry
    about adding it manually to our project (you will learn how to add third-party
    plugins to the project later in this book).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展`Ext.ux.LiveSearchGridPanel`类而不是`Ext.grid.Panel`。`Ext.ux.LiveSearchGridPanel`类已经扩展了`Ext.grid.Panel`类，并添加了实时搜索工具栏（**2**）。`LiveSearchGridPanel`类是随Ext
    JS SDK一起分发的插件。因此，我们不需要担心将其手动添加到我们的项目中（你将在本书后面的章节中学习如何将第三方插件添加到项目中）。
- en: As we will also add a toolbar with the **Add**, **Save Changes**, **Cancel Changes**
    buttons, we need to require the `util.Glyphs` class we created (`#2`).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还将添加带有**添加**、**保存更改**、**取消更改**按钮的工具栏，我们需要引入我们创建的`util.Glyphs`类（`#2`）。
- en: The configurations `#3` and `#4` show the border of each cell of the grid and
    to alternate between a white background and a light gray background.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 配置`#3`和`#4`显示了网格中每个单元格的边框，并在白色背景和浅灰色背景之间交替。
- en: Likewise, any other component that is responsible for displaying information
    in Ext JS, such as the "Panel" piece is only the shell. The View is responsible
    for displaying the columns in a GridPanel. We can customize it using the `viewConfig`
    (`#4`).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，任何负责在Ext JS中显示信息的组件，例如“面板”部分，只是外壳。视图负责在GridPanel中显示列。我们可以使用`viewConfig`（`#4`）来自定义它。
- en: The next step is to create an `initComponent` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个`initComponent`方法。
- en: To initComponent or not?
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化组件或不初始化组件？
- en: While browsing other developers' code, we might see some using the `initComponent`
    when declaring an Ext JS class and some who do not (as we have done until now).
    So what is the difference between using it and not using it?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览其他开发者的代码时，我们可能会看到一些人在声明Ext JS类时使用`initComponent`，而另一些人则没有使用（就像我们之前所做的那样）。那么使用它和不使用它的区别是什么？
- en: When declaring an Ext JS class, we usually configure it according to the application
    needs. They might become either a parent class for other classes or not. If they
    become a parent class, some of the configurations will be overridden, while some
    will not. Usually, we declare the ones that we expect to override in the class
    as configurations. We declare inside the `initComponent` method the ones we do
    not want to be overridden.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明Ext JS类时，我们通常根据应用程序的需求进行配置。它们可能成为其他类的父类，也可能不是。如果它们成为父类，一些配置将被覆盖，而一些则不会。通常，我们将我们预期要覆盖的类中的配置声明为配置。我们在`initComponent`方法中声明我们不希望被覆盖的配置。
- en: 'As there are a few configurations we do not want to be overridden, we will
    declare them inside the `initComponent`, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有一些配置我们不希望被覆盖，我们将它们声明在`initComponent`中，如下所示：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can define how the user can select information from the GridPanel: the default
    configuration is the `Selection RowModel` class. As we want the user to be able
    to edit cell by cell, we will use the `Selection CellModel` class (`#5`) and also
    the `CellEditing` plugin (`#6`), which is part of the Ext JS SDK. For the `CellEditing`
    plugin, we configure the cell to be available to edit when the user clicks on
    the cell (if we need the user to double-click, we can change to `clicksToEdit:
    2`). To help us later in the Controller, we also assign an ID to this plugin.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义用户如何从GridPanel中选择信息：默认配置是`Selection RowModel`类。因为我们希望用户能够逐个编辑单元格，我们将使用`Selection
    CellModel`类（`#5`）以及`CellEditing`插件（`#6`），它是Ext JS SDK的一部分。对于`CellEditing`插件，我们配置单元格在用户点击单元格时可供编辑（如果我们需要用户双击，我们可以将`clicksToEdit`改为`2`）。为了帮助我们在Controller中后续操作，我们还为此插件分配了一个ID。
- en: To be able to filter the information (the Live Search will only highlight the
    matching records), we will use the **Filters** plugin (`#7`). The **Filters**
    plugin is also part of the Ext JS SDK.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够过滤信息（实时搜索将仅突出显示匹配的记录），我们将使用**过滤器**插件（`#7`）。**过滤器**插件也是Ext JS SDK的一部分。
- en: The `callParent` method (`#8`) will call `initConfig` from the superclass `Ext.ux.LiveSearchGridPanel`
    passing the arguments we defined.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`callParent`方法（`#8`）将调用超类`Ext.ux.LiveSearchGridPanel`中的`initConfig`，并传递我们定义的参数。'
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is a common mistake to forget to include the `callParent` call when overriding
    the `initComponent` method. If the component does not work, make sure you are
    calling the `callParent` method!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写`initComponent`方法时忘记包含`callParent`调用是一个常见的错误。如果组件无法正常工作，请确保你已经调用了`callParent`方法！
- en: 'Next, we are going to declare `dockedItems`. As all GridPanels will have the
    same toolbar, we can declare `dockedItems` in the super class we are creating,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将声明 `dockedItems`。由于所有 GridPanels 都将具有相同的工具栏，我们可以在我们创建的父类中声明 `dockedItems`，如下所示：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will have **Add**, **Save Changes**, **Cancel Changes**, and **Clear Filters**
    buttons. Note that the toolbar (`#9`) and each of the buttons (`#10`) has `itemId`
    declared. As we are going to use the MVC approach in this example, we will declare
    a Controller. The `itemId` configuration has a responsibility similar to the reference
    that we declare when working with a ViewController. We will discuss the importance
    of `itemId` more when we declare the Controller later in this chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会有 **添加**、**保存更改**、**取消更改** 和 **清除过滤器** 按钮。请注意，工具栏（`#9`）和每个按钮（`#10`）都声明了
    `itemId`。由于我们将在本例中使用 MVC 方法，我们将声明一个控制器。`itemId` 配置具有与我们在与 ViewController 一起工作时声明的引用类似的责任。我们将在本章稍后声明控制器时进一步讨论
    `itemId` 的重要性。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'When declaring buttons inside a toolbar, we can omit the `xtype: ''button''`
    configuration since the button is the default component for toolbars.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '在工具栏内部声明按钮时，我们可以省略 `xtype: ''button''` 配置，因为按钮是工具栏的默认组件。'
- en: 'Inside the `Glyphs` class, we need to add the following attributes inside its
    `config`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Glyphs` 类中，我们需要在其 `config` 中添加以下属性：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And finally, we will add the two columns that are common for all the screens
    (`Last Update` column and Widget Column `delete` (`#13`)) along with the columns
    already declared in each specific GridPanel:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加所有屏幕都通用的两列（`最后更新` 列和 Widget Column 的 `delete` (`#13`)）以及已在每个特定 GridPanel
    中声明的列：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code we merge (`#11`) `me.columns` (`#12`) with two other `columns`
    and assign this value to `me.columns` again. We want all child grids to have these
    two columns plus the specific columns for each child grid. If the columns configuration
    from the `BaseGrid` class were outside `initConfig`, then when a child class declared
    its own columns configuration the value would be overridden. If we declare the
    `columns` configuration inside `initComponent`, a child class would not be able
    to add its own `columns` configuration, so we need to merge these two configurations
    (the columns from the child class `#12` with the two columns we want each child
    class to have).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 (`#11`) `me.columns` (`#12`) 与另外两个 `columns` 合并，并将此值赋给 `me.columns`。我们希望所有子网格都拥有这两列加上每个子网格的特定列。如果
    `BaseGrid` 类中的列配置在 `initConfig` 之外，那么当子类声明其自己的列配置时，该值将被覆盖。如果我们将在 `initComponent`
    中声明 `columns` 配置，子类将无法添加自己的 `columns` 配置，因此我们需要合并这两个配置（子类 `#12` 的列与每个子类都希望拥有的两列）。
- en: For the delete button, we are going to use a Widget Column (`#13`) (introduced
    in Ext JS 5). Until Ext JS 4, the only way to have a button inside a Grid Column
    was using an Action Column. We are going to use a button (`#16`) to represent
    a Widget Column. Because it is a Widget Column, there is no reason to make this
    column `sortable` (`#14`), and we can also disable its menu (`#15`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于删除按钮，我们将使用一个 Widget Column (`#13`)（在 Ext JS 5 中引入）。在 Ext JS 4 之前，在网格列内放置按钮的唯一方法是使用操作列。我们将使用一个按钮
    (`#16`) 来表示 Widget Column。因为它是一个 Widget Column，所以没有必要使此列 `可排序` (`#14`)，我们还可以禁用其菜单
    (`#15`)。
- en: We are going to discuss lines `#17` and `#18` in the next section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中讨论 `#17` 和 `#18` 行。
- en: Handling the Widget Column in the MVC architecture
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 MVC 架构中处理 Widget Column
- en: 'Let''s take a look again at the Widget Column declared in the super GridPanel,
    especially in the `handler` configuration:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看在 super GridPanel 中声明的 Widget Column，特别是其在 `handler` 配置中的内容：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even though the Widget Column is a widget and contains `xtype`, it is not possible
    to listen to its events in the MVC Controller, so we need a workaround to make
    it work in the MVC architecture. The reason is that the items that can be declared
    inside a Widget Column are subclasses of the `Ext.Widget` class, which is a subclass
    of the `Ext.Evented` class. MVC Controllers can only listen to events fired by
    a component subclass (panel, button, grid, tree, chart, and so on).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Widget Column 是一个组件并且包含 `xtype`，但在 MVC 控制器中无法监听其事件，因此我们需要一个解决方案使其在 MVC 架构中工作。原因是
    Widget Column 内部可以声明的项是 `Ext.Widget` 类的子类，而 `Ext.Widget` 类是 `Ext.Evented` 类的子类。MVC
    控制器只能监听由组件子类（面板、按钮、网格、树、图表等）触发的事件。
- en: That is why we are firing a custom event (`#18`) passing the parameters we need,
    so we can catch this event in this Controller and handle the programming logic
    needed to delete a record.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们触发了一个自定义事件 (`#18`)，传递我们需要的参数，这样我们就可以在这个控制器中捕获此事件，并处理删除记录所需的编程逻辑。
- en: In this example, we are setting `scope` of the handler as `me` (`#17`), which
    refers to `this` of the GridPanel. This means it will be the GridPanel that will
    be firing the `widgetclick` event, passing the grid itself and the widget button.
    The `btn` parameter contains a method named `getWidgetRecord`, which is used to
    retrieve the Model represented by the GridPanel row where the user clicked on
    the **Delete** button.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将处理器的 `scope` 设置为 `me` (`#17`)，它指的是 GridPanel 的 `this`。这意味着将会是 GridPanel
    触发 `widgetclick` 事件，传递网格本身和 widget 按钮。`btn` 参数包含一个名为 `getWidgetRecord` 的方法，用于检索用户点击
    **删除** 按钮时 GridPanel 行所代表的模型。
- en: 'If we were using an Action Column (a very popular choice until Ext JS 4) we
    would handle it in the MVC architecture in the same way (firing a custom event).
    An example can be found at: [http://goo.gl/pxdU4i](http://goo.gl/pxdU4i).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用动作列（在 Ext JS 4 之前是一个非常受欢迎的选择）我们会在 MVC 架构中以相同的方式处理它（触发自定义事件）。一个例子可以在：[http://goo.gl/pxdU4i](http://goo.gl/pxdU4i)
    找到。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Handling Widget Column handlers in the MVVM approach is easier. Instead of
    firing a custom event, we can simply refer to the method used in the ViewController
    as follows: `handler: ''onWidgetClick''`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '在 MVVM 方法中处理 Widget 列处理器更为简单。我们不需要触发一个自定义事件，而可以直接引用 ViewController 中使用的方法，如下所示：`handler:
    ''onWidgetClick''`。'
- en: Live Search plugin versus Filter plugin
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Live Search 插件与 Filter 插件
- en: Both plugins have the objective of helping the user to search for information
    quickly. In our project, we are using both.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个插件的目标都是帮助用户快速搜索信息。在我们的项目中，我们正在使用这两个插件。
- en: 'The Live Search plugin will search for any matching result in all the columns
    of the GridPanel. The search is also performed locally, which means that if we
    use the paging toolbar, this plugin will not work as expected. When using the
    paging toolbar, the grid only displays one page at a time, which means it is a
    limited number of rows. The remaining information is not kept locally, the paging
    toolbar only fetches the requested information, and this is the reason the search
    will not work when using paging. In our case, we display all the records from
    the database at once, so the plugin works as expected. For example, if we search
    for "`ada`", we will get the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Live Search 插件将在 GridPanel 的所有列中搜索任何匹配的结果。搜索也是本地执行的，这意味着如果我们使用分页工具栏，此插件将无法按预期工作。当使用分页工具栏时，网格一次只显示一页，这意味着它只显示有限数量的行。剩余的信息不会保留在本地，分页工具栏只获取请求的信息，这就是为什么在分页时搜索不会工作。在我们的情况下，我们一次性显示数据库中的所有记录，因此插件按预期工作。例如，如果我们搜索
    "`ada`"，我们将得到以下输出：
- en: '![Live Search plugin versus Filter plugin](img/0457OT_07_09.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Live Search 插件与 Filter 插件对比](img/0457OT_07_09.jpg)'
- en: 'And the Filter plugin will apply the filters on the Store as well, so it will
    only display to the user the matching results, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 Filter 插件也会在 Store 上应用过滤器，因此它只会向用户显示匹配的结果，如下所示：
- en: '![Live Search plugin versus Filter plugin](img/0457OT_07_10.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Live Search 插件与 Filter 插件对比](img/0457OT_07_10.jpg)'
- en: Specific GridPanels for each table
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个表的特定 GridPanel
- en: Our last stop before we implement the Controller is the specific GridPanels.
    We have already created the super GridPanel that contains most of the capabilities
    that we need. Now we just need to declare the specific configurations for each
    GridPanel.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现控制器之前，我们的最后一站是特定的 GridPanel。我们已经创建了一个包含我们所需大多数功能的超级 GridPanel。现在我们只需要为每个
    GridPanel 声明特定的配置。
- en: 'We will create five GridPanels that will extend from the `Packt.view.staticData.BaseGrid`
    class, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建五个 GridPanel，它们将扩展自 `Packt.view.staticData.BaseGrid` 类，如下所示：
- en: '`Packt.view.staticData.Actors`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.view.staticData.Actors`'
- en: '`Packt.view.staticData.Categories`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.view.staticData.Categories`'
- en: '`Packt.view.staticData.Languages`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.view.staticData.Languages`'
- en: '`Packt.view.staticData.Cities`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.view.staticData.Cities`'
- en: '`Packt.view.staticData.Countries`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.view.staticData.Countries`'
- en: 'Let''s start with the `Actors` GridPanel, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `Actors` GridPanel 开始，如下所示：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each specific class has its own `xtype` (`#1`). We also need to execute an
    `UPDATE` query in the database to update the menu table with the new xtypes we
    are creating:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特定的类都有自己的 `xtype` (`#1`)。我们还需要在数据库中执行一个 `UPDATE` 查询来更新菜单表，以包含我们正在创建的新 xtypes：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first declaration that is specific to the `Actors` GridPanel is the Store
    (`#2`). We are going to use the `Actors` Store. Because the `Actors` Store is
    inside the `staticData` folder (`store/staticData`), we also need to pass the
    name of the subfolder; otherwise, Ext JS will think that this Store file is inside
    the `app/store` folder, which is not true.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 针对 `Actors` GridPanel 特定的第一个声明是 Store (`#2`)。我们将使用 `Actors` Store。因为 `Actors`
    Store 在 `staticData` 文件夹内（`store/staticData`），我们还需要传递子文件夹的名称；否则，Ext JS 会认为此 Store
    文件在 `app/store` 文件夹内，这并不正确。
- en: Then we need to declare the `columns` specific to the `Actors` GridPanel (we
    do not need to declare the `Last Update` and the `Delete` Action Column because
    they are already in the super GridPanel).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要声明 `Actors` GridPanel 特定的 `columns`（我们不需要声明 `Last Update` 和 `Delete` 操作列，因为它们已经在超级
    GridPanel 中了）。
- en: What you need to pay attention to now are the `editor` and `filter` configurations
    for each column. The `editor` is for editing (`cellediting` plugin). We will only
    apply this configuration to the columns we want the user to be able to edit, and
    the `filter` (`filters` plugin) is the configuration that we will apply to the
    `columns` we want the user to be able to `filter` information from.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要关注的是每列的 `editor` 和 `filter` 配置。`editor` 用于编辑（`cellediting` 插件）。我们只会将此配置应用到我们希望用户能够编辑的列上，而
    `filter` (`filters` 插件）则是我们将应用到用户希望从 `columns` 中过滤信息的配置。
- en: For example, for the `id` column, we do not want the user to be able to edit
    it as it is a sequence provided by the MySQL database auto increment, so we will
    not apply the `editor` configuration to it. However, the user can filter the information
    based on the ID, so we will apply the `filter` configuration (`#3`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 `id` 列，我们不想让用户能够编辑它，因为它是由 MySQL 数据库自动递增提供的序列，因此我们不会对此列应用 `editor` 配置。然而，用户可以根据
    ID 过滤信息，因此我们将应用 `filter` 配置（`#3`）。
- en: 'We want the user to be able to edit the other two columns: `first_name` and
    `last_name`, so we will add the `editor` configuration. We can perform client
    validations as we can do on a field of a form too. For example, we want both fields
    to be mandatory (`#4` and `#7`) and the maximum number of characters the user
    can enter is `45` (`#5` and `#8`).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户能够编辑其他两列：`first_name` 和 `last_name`，因此我们将添加 `editor` 配置。我们可以像在表单字段上执行客户端验证一样执行客户端验证。例如，我们希望这两个字段都是必填的（`#4`
    和 `#7`），用户可以输入的最大字符数是 `45`（`#5` 和 `#8`）。
- en: And at last, as both columns are rendering text values (`string`), we will also
    apply `filter` (`#6` and `#9`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于这两个列都是渲染文本值（`string`），我们也将应用 `filter`（`#6` 和 `#9`）。
- en: 'For other filter types, please refer to the Ext JS documentation as shown in
    the following screenshot. The documentation provides an example and more configuration
    options that we can use:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他过滤类型，请参考以下截图所示的 Ext JS 文档。文档提供了一个示例和更多可用的配置选项：
- en: '![Specific GridPanels for each table](img/0457OT_07_11.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![每个表格的特定 GridPanels](img/0457OT_07_11.jpg)'
- en: And that is it! The super GridPanel will provide all the other capabilities.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！超级 GridPanel 将提供所有其他功能。
- en: Adding the Live Search CSS
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Live Search CSS
- en: 'When we navigate to the Live Search Grid example ([http://dev.sencha.com/ext/5.0.1/examples/grid/live-search-grid.html](http://dev.sencha.com/ext/5.0.1/examples/grid/live-search-grid.html))
    and we go through its source code, we can see that the example imports two CSS
    files: the `LiveSearchGridPanel.css` and `statusbar.css` (because the Live Search
    plugin has a dependency on the `statusbar` plugin). We also need to add this CSS
    to our application.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导航到 Live Search Grid 示例（[http://dev.sencha.com/ext/5.0.1/examples/grid/live-search-grid.html](http://dev.sencha.com/ext/5.0.1/examples/grid/live-search-grid.html)）并查看其源代码时，我们可以看到示例导入了两个
    CSS 文件：`LiveSearchGridPanel.css` 和 `statusbar.css`（因为 Live Search 插件依赖于 `statusbar`
    插件）。我们还需要将此 CSS 添加到我们的应用程序中。
- en: 'We are going to copy these two CSS files and rename the extension to `scss`.
    The Live Search CSS can be copied from `ext/src/ux/css`, and the `statusbar` CSS
    can be copied from `ext/src/ux/statusbar`. We need to place these two files inside
    our application custom CSS, which is located in the `sass/etc` directory. Create
    a new folder named `ux` and paste these files. Inside `all.scss`, we are going
    to import these two Sass files:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制这两个 CSS 文件并将扩展名更改为 `scss`。Live Search CSS 可以从 `ext/src/ux/css` 复制，而 `statusbar`
    CSS 可以从 `ext/src/ux/statusbar` 复制。我们需要将这些文件放置在我们的应用程序自定义 CSS 中，该 CSS 位于 `sass/etc`
    目录。创建一个名为 `ux` 的新文件夹并将这些文件粘贴进去。在 `all.scss` 中，我们将导入这两个 Sass 文件：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `statusbar` plugin displays an icon, and we need to fix the path to the
    `statusbar` images as well. Inside the `statusbar.scss` file, replace all matches
    "`../images`" by "`images/statusbar`". Go to `ext/src/ux/statusbar`, copy the
    `images` folder, and paste it inside `resources/images`. Rename `resources/images/images`
    to `resources/images/statusbar`. If you have `Sencha app watch` being executed
    in the terminal, Sencha Cmd will rebuild the app CSS file and the plugin will
    work 100 percent.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`statusbar`插件显示一个图标，我们还需要修复`statusbar`图像的路径。在`statusbar.scss`文件中，将所有匹配的"`../images`"替换为"`images/statusbar`"。转到`ext/src/ux/statusbar`，复制`images`文件夹，并将其粘贴到`resources/images`中。将`resources/images/images`重命名为`resources/images/statusbar`。如果你在终端中执行`Sencha
    app watch`，Sencha Cmd将重新构建应用程序CSS文件，并且插件将100%正常工作。'
- en: Generic Controller for all tables
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用于所有表格的通用控制器
- en: Now it is time to implement the last piece of the static data module. The goal
    is to implement a Controller that has the most generic code that will provide
    the functionalities for all the screens, without us having to create any specific
    method for any screens.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现静态数据模块的最后一块了。目标是实现一个控制器，它拥有最通用的代码，将为所有屏幕提供功能，而无需我们为任何屏幕创建任何特定方法。
- en: 'So let''s start with the base of the Controller. We are going to create a new
    class named `Packt.controller.StaticData`, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从控制器的基类开始。我们将创建一个名为`Packt.controller.StaticData`的新类，如下所示：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For now, we are going to declare the `requires` ((`#1`)—we are going to use
    the `Util` class in some methods and also the `Glyphs` class), the `stores` ((`#2`)—where
    we can list all the stores of this module), and also the `views` ((`#3`)—where
    we can list all views of this module).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将声明`requires`（`#1`）——我们将在某些方法中使用`Util`类和`Glyphs`类），`stores`（`#2`）——我们可以在这里列出这个模块的所有存储），以及`views`（`#3`）——我们可以在这里列出这个模块的所有视图）。
- en: As we are instantiating the views by their `xtype`, we need to declare them
    somewhere (`#2`). This can be inside the `requires` configuration in the `Application.js`
    file or inside a Controller. This is needed because Ext JS does not know the xtypes
    we are creating, so the names of the classes need to be listed somewhere.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通过`xtype`实例化视图，我们需要在某个地方声明它们（`#2`）。这可以在`Application.js`文件中的`requires`配置内或在一个控制器内完成。这是必需的，因为Ext
    JS不知道我们创建的xtypes，所以类的名称需要列在某个地方。
- en: The `stores` declaration (`#2`) that we are listing in this Controller will
    be instantiated when the Controller is instantiated as well. As this is a Controller
    from the MVC architecture, its scope is global, and it will be created when the
    application launches. Using the MVC approach for this case is interesting; after
    all, we are constructing the static data module that refers to common data used
    by other entities of the application. In this case, this information will be live
    throughout the life cycle of the application. This is unlike the Views, ViewModels,
    ViewControllers, and stores declared inside ViewModels, which are alive as long
    as the View is alive (tab opened). As we set `autoLoad:true` in the `Base` Store,
    when the application launches, the stores listed in this Controller will be instantiated
    and loaded.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个控制器中列出的`stores`声明（`#2`）将在控制器实例化时一起实例化。由于这是一个MVC架构中的控制器，其作用域是全局的，它将在应用程序启动时创建。对于这种情况使用MVC方法是有趣的；毕竟，我们正在构建一个静态数据模块，该模块引用了应用程序其他实体使用的通用数据。在这种情况下，这些信息将在应用程序的生命周期中始终是活动的。这与在ViewModel内部声明的Views、ViewModels、ViewControllers和存储不同，它们仅在视图活动时（标签页打开）存在。由于我们在`Base`存储中设置了`autoLoad:true`，当应用程序启动时，在这个控制器中列出的存储将被实例化和加载。
- en: We also have the `init` function and `this.control` where we are going to listen
    to all the events that we are interested in.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`init`函数和`this.control`，我们将在这里监听所有我们感兴趣的事件。
- en: Finding the correct selector
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到正确的选择器
- en: On the toolbar from each static data grid panel, we have a button with the text
    **Add**. When we click on this button, we want to add a new Model entry to the
    Store (and consequently, add a new record on the GridPanel) and enable editing
    so that the user can fill in the values to save them later (when they click on
    the **Save Changes** button).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个静态数据网格面板的工具栏上，我们有一个上面写着**添加**的按钮。当我们点击这个按钮时，我们希望将一个新的模型条目添加到存储中（并且相应地，在网格面板上添加一条新记录），并启用编辑功能，以便用户可以填写值以便稍后保存（当他们点击**保存更改**按钮时）。
- en: When listening to an event in a Controller, first we need to pass the selector
    that is going to be used by the `Ext.ComponentQuery` class to find the component.
    Then we need to list the event that we want to listen to. And then, we need to
    declare the function that is going to be executed when the event we are listening
    to is fired, or declare the name of the Controller method that is going to be
    executed when the event is fired. In our case, we are going to declare the method
    only for code organization purposes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当在控制器中监听事件时，首先我们需要传递一个选择器，这个选择器将由`Ext.ComponentQuery`类使用来查找组件。然后我们需要列出我们想要监听的事件。接下来，我们需要声明当监听的事件被触发时要执行的功能，或者声明当事件被触发时要执行的控制器的名称。在我们的例子中，我们只是为了代码组织的目的声明方法。
- en: 'Now let''s focus on finding the correct selector for the **Add** button (the
    other buttons will be similar as well). According to the `Ext.ComponentQuery`
    API documentation, we can retrieve components by using their `xtype` (if you are
    already familiar with JQuery, you will notice that `Ext.ComponentQuery` selector
    behavior is very similar to JQuery selector behavior). Well, we are trying to
    retrieve two buttons, and their `xtype` is `button`. We can then try the selector
    `''button''`. But before we start coding, let''s make sure that this is the correct
    selector to avoid changing the code all the time trying to figure out the correct
    selector. There is one very useful tip we can try: open the browser console—Command
    Editor—and type the following command and click on Run:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于找到**添加**按钮的正确选择器（其他按钮也将类似）。根据`Ext.ComponentQuery` API文档，我们可以通过它们的`xtype`来检索组件（如果你已经熟悉JQuery，你会注意到`Ext.ComponentQuery`选择器的行为与JQuery选择器的行为非常相似）。嗯，我们正在尝试检索两个按钮，它们的`xtype`是`button`。然后我们可以尝试选择器`'button'`。但在我们开始编码之前，让我们确保这是一个正确的选择器，以避免不断更改代码来尝试找出正确的选择器。有一个非常有用的技巧我们可以尝试：打开浏览器控制台——命令编辑器——并输入以下命令并点击运行：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see in the following screenshot, it returned an array of the buttons
    that were found by the selector we used, and the array contains several buttons!
    Too many buttons is not what we want. We want to narrow down to the **Add** button
    from the **Actors** screen, as shown in the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，它返回了我们使用选择器找到的按钮数组，并且数组包含多个按钮！太多的按钮不是我们想要的。我们想要缩小到**演员**屏幕中的**添加**按钮，如下面的截图所示：
- en: '![Finding the correct selector](img/0457OT_07_12.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![寻找正确的选择器](img/0457OT_07_12.jpg)'
- en: 'Let''s try to draw a path of the **Actors** screen using the components `xtype`
    we used. We have the **Actors** screen (`xtype: actorsgrid`); inside the screen,
    we have a toolbar (`xtype: toolbar`); and inside the toolbar, we have some buttons
    (`xtype: button`). Therefore, we have `actorsgrid` | `toolbar` | `button`. So
    we can try the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们尝试使用我们使用的`xtype`组件绘制**演员**屏幕的路径。我们有**演员**屏幕（`xtype: actorsgrid`）；在屏幕内部，我们有一个工具栏（`xtype:
    toolbar`）；在工具栏内部，我们有一些按钮（`xtype: button`）。因此，我们有`actorsgrid` | `toolbar` | `button`。所以我们可以尝试以下命令：'
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So let''s try this last selector on the **Console**, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们在**控制台**上尝试这个最后的选择器，如下所示：
- en: '![Finding the correct selector](img/0457OT_07_13.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![寻找正确的选择器](img/0457OT_07_13.jpg)'
- en: 'Now the result is an array of six buttons, and these are the buttons that we
    are looking for! There is still one detail missing: if we use the `''actorsgrid
    toolbar button''` selector, it will listen to the click event (which is the event
    we want to listen to) of all the six buttons.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的结果是一个包含六个按钮的数组，这些就是我们正在寻找的按钮！还有一个细节缺失：如果我们使用`'actorsgrid toolbar button'`选择器，它将监听所有六个按钮的点击事件（这是我们想要监听的事件）。
- en: However, when we click on the **Cancel** button, an action should happen; when
    we click on the **Save** button, a different action should happen because it is
    a different button. So we still want to narrow down the selector even more until
    it returns the **Add** button that we are looking for.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们点击**取消**按钮时，应该发生一个动作；当我们点击**保存**按钮时，应该发生不同的动作，因为它是不同的按钮。所以我们仍然想要进一步缩小选择器，直到它返回我们正在寻找的**添加**按钮。
- en: 'Going back to the Base Grid panel code, notice that we declared a configuration
    named `itemId` for all buttons. We can use these `itemId` configurations to identify
    the buttons in a unique way. And according to the `Ext.ComponentQuery` API documentation,
    we can use `#` as a prefix of `itemId`. So let''s try the following command on
    the **Console** to get the **Add** button reference:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Base Grid面板代码，注意我们为所有按钮声明了一个名为`itemId`的配置。我们可以使用这些`itemId`配置以独特的方式识别按钮。根据`Ext.ComponentQuery`
    API文档，我们可以使用`#`作为`itemId`的前缀。所以让我们在**控制台**上尝试以下命令来获取**添加**按钮的引用：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And the output will be only one button as we expect:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 并且输出结果将只有一个按钮，正如我们所期望的：
- en: '![Finding the correct selector](img/0457OT_07_14.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![查找正确的选择器](img/0457OT_07_14.jpg)'
- en: So now we have the selectors that we were looking for! Using the **Console**
    is a great tool and can save us a lot of time when trying to find the exact selector
    that we want instead of coding, testing, not getting the selector we want, coding
    again, testing again, and so on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们得到了我们一直在寻找的选择器！使用**控制台**是一个非常好的工具，当尝试找到我们想要的精确选择器而不是编码、测试、没有得到我们想要的选择器、再次编码、再次测试等等时，它可以节省我们很多时间。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Could we use only `button#add` as selector? Yes, we could use a shorter selector.
    However, it would work perfectly for now. As the application grows and we declare
    more classes and more buttons, the event would be fired for all buttons that have
    the `itemId` with `add` value, and this could lead to an error of the application.
    We always need to remember that `itemId` is scoped locally to its container. Using
    the `actorsgrid toolbar button` or `actorsgrid button` as selector, we make sure
    that the event will come from the button from the **Actors** screen.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否只用`button#add`作为选择器？是的，我们可以使用一个更短的选择器。然而，现在它将完美地工作。随着应用的成长和更多类和按钮的声明，事件将会对所有具有`itemId`值为`add`的按钮触发，这可能会导致应用出错。我们始终需要记住`itemId`是局部作用域的，使用`actorsgrid
    toolbar button`或`actorsgrid button`作为选择器，我们确保事件将来自**演员**屏幕的按钮。
- en: Now's the time for one last detail. The selector we found is specific to the
    **Actors** screen. We want some generic code—code that can be used for all screens
    from the static data module. The good news is that we created a super class (`Packt.view.staticData.BaseGrid`)
    with `xtype staticdatagrid`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候关注最后一个细节了。我们找到的选择器仅适用于**演员**屏幕。我们希望有一些通用的代码——可以在静态数据模块的所有屏幕上使用的代码。好消息是，我们创建了一个超级类（`Packt.view.staticData.BaseGrid`），其`xtype`为`staticdatagrid`。
- en: Using itemId versus id – Ext.Cmp is bad!
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用itemId与id的比较 – Ext.Cmp很糟糕！
- en: 'Whenever we can, we will always try to use the `itemId` configuration instead
    of `id` to uniquely identify a component. And here comes the question: Why?'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们能这样做的时候，我们总是会尝试使用`itemId`配置而不是`id`来唯一标识一个组件。那么问题来了：为什么？
- en: When using `id`, we need to make sure that `id` is unique and none of all the
    other components of the application can have the same `id` property. Now, imagine
    the situation where you are working with other developers on the same team and
    it is a big application. How can you make sure that `id` is going to be unique?
    It will be pretty difficult. Don't you think? And this can be a hard task to achieve.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`id`时，我们需要确保`id`是唯一的，并且应用中的所有其他组件都不能有相同的`id`属性。现在，想象一下你和其他开发者在同一个团队中工作，并且这是一个大型应用的情况。你怎么能确保`id`将是唯一的呢？这将会非常困难。你不这么认为吗？这可能会是一个难以完成的任务。
- en: Components created with `id` can be accessed globally using `Ext.getCmp`, which
    is shorthand for `Ext.ComponentManager.get`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`id`创建的组件可以通过`Ext.getCmp`全局访问，这是`Ext.ComponentManager.get`的简写。
- en: 'Just to mention one example, when using `Ext.getCmp` to retrieve a component
    by its `id`, it is going to return the last component declared with the given
    `id`. And if `id` is not unique, it can return the component that you are not
    expecting, and this can lead to an error in the application, as shown in the following
    figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 只举一个例子，当使用`Ext.getCmp`通过`id`检索一个组件时，它将返回具有给定`id`的最后一个声明的组件。如果`id`不是唯一的，它可能会返回你意想不到的组件，这可能导致应用中出错，如下面的图所示：
- en: '![Using itemId versus id – Ext.Cmp is bad!](img/0457OT_07_20.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![使用itemId与id的比较 – Ext.Cmp很糟糕！](img/0457OT_07_20.jpg)'
- en: 'Do not panic! There is an elegant solution: using `itemId` instead of `id`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 不要慌张！有一个优雅的解决方案：使用`itemId`而不是`id`。
- en: The `itemId` can be used as an alternative way to get a reference of a component.
    The `itemId` is an index to the container's internal `MixedCollection`, and that
    is why `itemId` is scoped locally to the container. This is the biggest advantage
    of `itemId`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemId` 可以用作获取组件引用的另一种方式。`itemId` 是容器内部 `MixedCollection` 的索引，这就是为什么 `itemId`
    是在容器范围内局部化的。这是 `itemId` 的最大优势。'
- en: For example, we can have a class named `MyWindow1` extending from `Window`,
    and inside this class, we can have a button with `itemId` containing the `submit`
    value. Then, we can have another class named `MyWindow2`, also extending from
    `Window`, and inside the class, we can also have a button with the `itemId` as
    `submit`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以有一个名为 `MyWindow1` 的类，它继承自 `Window`，在这个类中，我们可以有一个 `itemId` 包含 `submit`
    值的按钮。然后，我们可以有一个名为 `MyWindow2` 的另一个类，它也继承自 `Window`，在这个类中，我们也可以有一个 `itemId` 为 `submit`
    的按钮。
- en: 'Having two `itemIds` with the same value is not an issue. We only need to be
    careful when we use `Ext.ComponentQuery` to retrieve the component we want. For
    example, if we have a **Login** window whose alias is `login` and another screen
    called **Registration** window whose alias is `registration` and both windows
    have a button **Save**, whose `itemId` is `save`, if we simply use `Ext.ComponentQuery.query(''button#save'')`,
    the result will be an array with two results. However, if we narrow down the selector
    even more—let''s say we want the **Login Save** button, and not the **Registration
    Save** button, we need to use `Ext.ComponentQuery.query(''login button#save'')`,
    and the result will be only one, which is exactly what we expect. The contents
    of this paragraph are aptly encapsulated in the following image:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个 `itemId` 具有相同值的情况并不成问题。我们只需要在使用 `Ext.ComponentQuery` 检索我们想要的组件时小心。例如，如果我们有一个别名是
    `login` 的 **登录** 窗口，另一个名为 **注册** 的屏幕，其窗口别名是 `registration`，并且两个窗口都有一个名为 **保存**
    的按钮，其 `itemId` 是 `save`，如果我们简单地使用 `Ext.ComponentQuery.query('button#save')`，结果将是一个包含两个结果的数组。然而，如果我们进一步缩小选择器——比如说我们想要的是
    **登录保存** 按钮，而不是 **注册保存** 按钮，我们需要使用 `Ext.ComponentQuery.query('login button#save')`，结果将只有一个，这正是我们期望的。本段内容的适当封装如下图所示：
- en: '![Using itemId versus id – Ext.Cmp is bad!](img/0457OT_07_21.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![使用 itemId 与 id 的比较 – Ext.Cmp 是不好的！](img/0457OT_07_21.jpg)'
- en: You will notice that we will not use `Ext.getCmp` in the code of our project
    as it is not a good practice because of the reasons listed previously. Until Ext
    JS 3, this was the way that we had to use to retrieve components. But from Ext
    JS 4 onwards, and with the introduction of the MVC architecture and MVVM, this
    is not needed anymore.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在我们的项目代码中不会使用 `Ext.getCmp`，因为这并不是一个好的实践，原因如前所述。在 Ext JS 3 之前，这是我们必须使用的方式来检索组件。但从
    Ext JS 4 开始，随着 MVC 架构和 MVVM 的引入，这已经不再需要了。
- en: Adding a new record on the GridPanel
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 GridPanel 上添加新记录
- en: 'Now that we know how to find the correct selector to use in the Controller,
    let''s go ahead and declare the selector for the **Add** button:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何在 Controller 中找到正确的选择器，让我们继续声明 **添加** 按钮的选择器：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we need to implement the method `onButtonClickAdd`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现 `onButtonClickAdd` 方法：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From the parameters, we only have the `button` reference. We need to get the
    GridPanel reference. So, we are going to use the `up` method to get it (`#1`).
    Again, we are going to use the super GridPanel `xtype` as selector (`staticdatagrid`),
    because this way we have the most generic code possible.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从参数中，我们只有 `button` 引用。我们需要获取 GridPanel 的引用。因此，我们将使用 `up` 方法来获取它（`#1`）。我们再次将超级
    GridPanel 的 `xtype` 作为选择器（`staticdatagrid`），因为这样我们就有最通用的代码。
- en: 'All components in Ext JS have methods to query other components. They are listed
    as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 中的所有组件都有查询其他组件的方法。它们如下列出：
- en: '`up`: This navigates up the ownership hierarchy searching for an ancestor container
    that matches any passed selector or component'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`up`：这个方法沿着所有者层次结构向上导航，寻找匹配任何传递的选择器或组件的祖先容器'
- en: '`down`: This retrieves the first descendant of this container that matches
    the passed selector'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down`：这个方法检索匹配传递的选择器的第一个后代组件'
- en: '`query`: This retrieves all descendant components that match the passed selector'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query`：这个方法检索所有匹配传递的选择器的后代组件'
- en: The method query also has some alternatives, such as `queryBy(function)` and
    `queryById`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `query` 也有一些替代方案，例如 `queryBy(function)` 和 `queryById`。
- en: Once we have the GridPanel reference, we can get the Store reference using the
    `getStore` method (`#2`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 GridPanel 的引用，我们可以使用 `getStore` 方法（`#2`）来获取 Store 的引用。
- en: We need to have the Model name to instantiate it (`#5`) so that we can insert
    on the first position of the Store (this way it will be the first line of the
    GridPanel). So, still targeting generic code, we can get the `modelName` from
    the `store` (`#3`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要模型名称来实例化它（`#5`），这样我们就可以在Store的第一个位置插入（这样它将是GridPanel的第一行）。所以，仍然针对通用代码，我们可以从`store`（`#3`）中获取`modelName`。
- en: We can pass some configurations to the Model when we instantiate it. We want
    the `Last Update` column to be updated as well; we will only pass it as configuration
    with the most current *Date* and *Time*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化模型时，我们可以传递一些配置。我们希望`最后更新`列也被更新；我们将只传递最新的*日期*和*时间*作为配置。
- en: And at last, we also want to focus on a cell of the row so that the user can
    be aware that the cell can be edited, so we will focus on the second column of
    the grid (the first one is the `id`, which is not editable) of the first row (`#7`).
    But to do so, we need a reference to the `celleditor` plugin; we can get it by
    using the `getPlugin` method, passing `pluginId` as the parameter (`#4`).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还想让用户注意到行的某个单元格可以编辑，所以我们将焦点放在网格的第二列（第一列是`id`，不可编辑）的第一行（`#7`）。但要做到这一点，我们需要`celleditor`插件的引用；我们可以通过使用`getPlugin`方法，传递`pluginId`作为参数（`#4`）来获取它。
- en: 'Just to remember, we declared the `pluginId` for the `cellediting` plugin of
    the `Packt.view.staticData.BaseGrid` class, as shown in the following code snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了提醒，我们在`Packt.view.staticData.BaseGrid`类的`cellediting`插件中声明了`pluginId`，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that with only one method, we can program the necessary logic. The code
    is generic and provides the same capability to all static data grid panels.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仅使用一个方法，我们就可以编程必要的逻辑。代码是通用的，并为所有静态数据网格面板提供相同的功能。
- en: Editing an existing record
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑现有记录
- en: The editing of a cell will be done automatically by the `cellediting` plugin.
    However, when the user clicks on a cell to edit and finishes the editing, we need
    to update the **Last Update** value to the current *Date* and *Time*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格的编辑将由`cellediting`插件自动完成。然而，当用户点击单元格进行编辑并完成编辑后，我们需要将**最后更新**值更新为当前的*日期*和*时间*。
- en: 'The `cellediting` plugin has an event named `edit` that allows us to listen
    to the event we want. Unfortunately, the Controller is not able to listen to plugin
    events. Lucky for us, the GridPanel class also fires this event (the `cellediting`
    plugin forwards the event to the `GridPanel` internally), so we can listen to
    it. So we are going to add the following code to the Controller `init` control:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`cellediting`插件有一个名为`edit`的事件，允许我们监听我们想要的事件。不幸的是，控制器无法监听插件事件。幸运的是，GridPanel类也会触发此事件（`cellediting`插件将事件内部转发到`GridPanel`），因此我们可以监听它。所以我们将添加以下代码到控制器的`init`控制中：'
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we need to implement the `onEdit` method, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现`onEdit`方法，如下所示：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The second parameter is the event (`context`). From this parameter, we can get
    the **Model** instance (`record`) that the user edited and then set the `last_update`
    field to the current *Date* and *Time*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是事件（上下文）。从这个参数中，我们可以获取用户编辑的**模型实例（record**）并将`last_update`字段设置为当前的*日期*和*时间*。
- en: Deleting the handling Widget Column in the Controller
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制器中删除处理Widget列
- en: Well, the read, create, and update actions have already been implemented. Now,
    we need to implement the delete action. We do not have a button for the delete
    action, but we do have an `item` of an Action Column.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，读取、创建和更新操作已经实现。现在，我们需要实现删除操作。我们没有删除操作的按钮，但我们确实有一个动作列的`item`。
- en: 'In the topic *Handling the Widget Column in the MVC architecture*, you learned
    how to fire the event from the item of the Action Column so that we could handle
    it on the Controller. We cannot listen to the event fired by the Action Column
    itself; however, we can listen to the event fired by the Action Column that we
    created:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在主题*处理MVC架构中的Widget列*中，你学习了如何从动作列项触发事件，以便我们可以在控制器中处理它。我们无法监听动作列本身触发的事件；然而，我们可以监听我们创建的动作列触发的事件：
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s see how you can implement the `handleActionColumn` method:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何实现`handleActionColumn`方法：
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As this is a custom event, we need to get the parameters that were passed by
    the item of the Action Column.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个自定义事件，我们需要获取动作列项传递的参数。
- en: So first, we need to get the Store and also the `record` that the user clicked
    to delete. Then, using the second parameter, which is the name of the `action`
    of the Action Column item, we have a way to know which item fired the event. So
    if the `action` value is `delete`, we are going to remove the `record` from the
    Store and ask the user to commit the changes by pressing the button **Save Changes**,
    which is going to synchronize the models from the Store with the information we
    have on the server.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们需要获取Store以及用户点击删除的`record`。然后，使用第二个参数，即Action列项的`action`名称，我们有一种方式知道哪个项触发了事件。所以如果`action`值是`delete`，我们将从Store中删除`record`并要求用户通过按下按钮**保存更改**来提交更改，这将同步Store中的模型与服务器上的信息。
- en: Saving the changes
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存更改
- en: 'After the user performs an update, delete, or create action, the cells that
    were updated will have a mark (the dirty mark so that the Store knows what models
    were modified) as shown in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 用户执行更新、删除或创建操作后，更新的单元格将有一个标记（脏标记，以便Store知道哪些模型已被修改），如下面的截图所示：
- en: '![Saving the changes](img/0457OT_07_15.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![保存更改](img/0457OT_07_15.jpg)'
- en: In the same way that we can perform changes on the MySQL table, we need to save
    the changes (commit). That is why we created the **Save Changes** button; this
    way, we will synchronize all the changes at once to the server.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们可以在MySQL表中执行更改的方式相同，我们需要保存更改（提交）。这就是为什么我们创建了**保存更改**按钮；这样，我们将一次性将所有更改同步到服务器。
- en: 'So first, we need to add a listener to `me.control`, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向`me.control`添加一个监听器，如下所示：
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we need to implement the `onButtonClickSave` method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现`onButtonClickSave`方法：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The implementation of the method is pretty straightforward: we simply need
    to get the Store (`#2`) from the GridPanel (`#1`) and call the method `sync` (`#5`).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的实现相当简单：我们只需要从GridPanel（`#1`）获取Store（`#2`）并调用`sync`方法（`#5`）。
- en: However, we are going to validate that the information entered in the cells
    of the Grid contain valid information. To do so, we are going to call the method
    `validate` from the grid (`#3`) and get the `errors`. If no errors were found
    (`#4`), then we `sync` the Store with the server (`#5`); otherwise, we display
    the `errors` (`#6`).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将验证在Grid的单元格中输入的信息是否包含有效信息。为此，我们将从网格（`#3`）调用`validate`方法并获取`errors`。如果没有发现错误（`#4`），则将Store与服务器同步（`#5`）；否则，显示`errors`（`#6`）。
- en: The Grid Panel does not have a validate method by default. We are going to add
    this method to the `Base` Grid Panel.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Grid Panel默认没有验证方法。我们将向`Base` Grid Panel添加此方法。
- en: Validating cellediting in GridPanel
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证GridPanel中的单元格编辑
- en: Going back to the class `Packt.view.staticData.BaseGrid`, we are going to add
    the logic to validate a row from the grid and also the entire grid before saving.
    In this example, you will learn that we can also add useful methods to the classes
    we create; we do not need to develop all the code inside the Controller.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 回到类`Packt.view.staticData.BaseGrid`，我们将添加验证行和整个网格在保存之前的逻辑。在这个例子中，你将了解到我们也可以向创建的类中添加有用的方法；我们不需要在Controller中开发所有代码。
- en: 'The first method we are going to implement is `validateRow`. Given a record,
    we are going to validate it using Model validators, and if there are any errors,
    we will add the same form icon that Ext JS displays in the forms in case of validation
    errors in the cell that contains the error, and we will also add a tooltip in
    this cell (similar behavior from the form validation). The code for the method
    is as follows (we need to add it inside the `initComponent` method):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一种方法是`validateRow`。给定一个记录，我们将使用模型验证器来验证它，如果有任何错误，我们将在包含错误的单元格中添加Ext
    JS在表单中显示的相同表单图标（在单元格验证错误的情况下），并且我们还将在此单元格中添加一个工具提示（与表单验证类似的行为）。该方法的代码如下（我们需要将其添加到`initComponent`方法中）：
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given a `record` Model (`#1`), we are going to use its method `validate`. This
    method verifies that the information contained in the Model is valid according
    to the Model validators (we need to go back to the models we defined for this
    chapter and add the validators). This method returns an object with all the errors
    found in the record.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`record`模型（`#1`），我们将使用其`validate`方法。此方法验证模型中包含的信息是否根据模型验证器有效（我们需要回到本章定义的模型并添加验证器）。此方法返回一个包含记录中所有错误的对象。
- en: Using the `isValid` method (`#2`), we can easily find out whether the Model
    is valid or not. If it is valid, we return `true` (we will use this information
    later).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`isValid`方法（`#2`），我们可以轻松地找出模型是否有效。如果它是有效的，我们返回`true`（我们将在以后使用这个信息）。
- en: The `columnIndexes` (`#3`) is in an array that contains `dataIndex` of each
    column of the grid. This method was present in the grid panel class back in Ext
    JS 4.1, but in Ext JS 4.2, it was removed, and it is not present in Ext JS 5\.
    We are going to implement this method as well, but with the difference being that
    in this case, we are only interested in the columns that have the editor enabled
    (since we want to validate it).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`columnIndexes`（`#3`）在一个数组中，包含网格每一列的`dataIndex`。这个方法在Ext JS 4.1的网格面板类中存在，但在Ext
    JS 4.2中被移除，并且在Ext JS 5中不存在。我们将实现这个方法，但区别在于在这种情况下，我们只对启用了编辑器的列感兴趣（因为我们想对其进行验证）。'
- en: Then, for each `column` of the grid that has the editor enabled (`#4`), we are
    going to retrieve the `errors` specific for that column from the Model (`#5`).
    We are going to add each error `message` (`#6`) to an array of messages. After
    that, we are going to add the same error icon from an invalid form field to the
    grid cell (`#7`). And, at last, we are also going to add a tooltip to the cell
    with error (`#8`).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于网格中启用了编辑器的每一列（`#4`），我们将从模型中检索该列特定的`errors`（`#5`）。我们将每个错误`message`（`#6`）添加到一个消息数组中。之后，我们将从无效表单字段中添加相同的错误图标到网格单元格（`#7`）。最后，我们还将向有错误的单元格添加一个工具提示（`#8`）。
- en: 'Next, we are going to implement the `getColumnIndexes` function, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`getColumnIndexes`函数，如下所示：
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For each column of the grid (`#9`), we are going to verify that the editor is
    enabled (`#10`), and if yes, we are going to add `dataIndex` to the `columnIndexes`
    array (`#11`). In the end, we return this array (`#12`).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网格的每一列（`#9`），我们将验证编辑器是否已启用（`#10`），如果是，我们将`dataIndex`添加到`columnIndexes`数组（`#11`）。最后，我们返回这个数组（`#12`）。
- en: 'The `validateRow` method will only work for a single row. When we click on
    the **Save Changes** button, we want to validate the entire grid. To do so, we
    are going to implement one more method inside the `initComponent`, which is called
    `validate` (the method we called in the Controller):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`validateRow`方法只适用于单行。当我们点击**保存更改**按钮时，我们希望验证整个网格。为此，我们将在`initComponent`内部实现一个额外的`validate`方法（我们在控制器中调用过该方法）：'
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For the `validate` method, we are going to retrieve all the rows from the grid,
    and for each one (`#13`), we are going to call the `validateRow` method (`#14`).
    In line `#14`, we are also keeping track of whether any previous row `is valid`
    or not.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`validate`方法，我们将从网格中检索所有行，并对每一行（`#13`）调用`validateRow`方法（`#14`）。在行`#14`中，我们还会跟踪是否有任何之前的行`是有效的`。
- en: In the end, we return (`#16`) `undefined` if no error was found or we return
    an object with a title and message (`#15`) that we can use in the Controller to
    display an alert.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果没有发现错误，我们返回`undefined`（`#16`），或者返回一个包含标题和消息的对象（`#15`），我们可以在控制器中使用它来显示警告。
- en: 'If we add an empty row or edit a cell with invalid information, the grid will
    display an error icon on the cell and also a tooltip when we mouse over it. The
    output will be similar to the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加一个空行或编辑包含无效信息的单元格，网格将在单元格上显示一个错误图标，并且当我们将鼠标悬停在其上时也会显示一个工具提示。输出将类似于以下截图：
- en: '![Validating cellediting in GridPanel](img/0457OT_07_16.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![在GridPanel中验证单元格编辑](img/0457OT_07_16.jpg)'
- en: Model validators
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模型验证器
- en: 'To make this code work, we need to add the Model validators to `staticData`
    model. For example, for the `Actors` model, we can add the following code based
    on the database validations for the `actor` table:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此代码工作，我们需要将模型验证器添加到`staticData`模型中。例如，对于`Actors`模型，我们可以根据`actor`表的数据库验证添加以下代码：
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And in the `Packt.model.staticData.Base` class, we can add the `last_update`
    validator that is going to be common to all `staticData` models:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Packt.model.staticData.Base`类中，我们可以添加一个`last_update`验证器，这个验证器将适用于所有`staticData`模型：
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The autoSync configuration
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动同步配置
- en: The Store has a configuration named `autoSync`. The default value is `false`,
    but if we set it to `true`, the Store will automatically synchronize with the
    server whenever a change is detected. This can be good, but it also can be bad—it
    depends on how we are going to use it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Store有一个名为`autoSync`的配置。默认值是`false`，但如果我们将其设置为`true`，Store将在检测到更改时自动与服务器同步。这可能很好，但也可能很糟糕——这取决于我们如何使用它。
- en: For example, if we did not have the validations, the user could create an empty
    row and try to send it to the server. The server code would fail (some columns
    cannot be `null`), and this would be bad for the application. With `autoSync`
    set to `false`, the user can also choose when to save the information and the
    information can be sent in bulk instead of sending one request per action (create,
    update, or destroy)—`allowSingle` has to be set to `false` in the proxy writer
    as well.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们没有验证，用户可以创建一个空行并尝试将其发送到服务器。服务器代码将失败（某些列不能为 `null`），这对应用程序来说很糟糕。将 `autoSync`
    设置为 `false`，用户还可以选择何时保存信息，信息可以批量发送而不是每次操作（创建、更新或销毁）——`allowSingle` 也必须在代理写入器中设置为
    `false`。
- en: Canceling the changes
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消更改
- en: As the user can save the changes (commit), the user can also cancel them (rollback).
    All you have to do is to reload the Store so that you get the most updated information
    from the server, and the changes made by the user will be lost.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户可以保存更改（提交），用户也可以取消它们（回滚）。你只需要重新加载 Store，以便从服务器获取最新信息，用户所做的更改将会丢失。
- en: 'So we need to listen to the event, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要监听以下事件：
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And we need to implement the method:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的方法：
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you want, you can add a message asking whether the user really wants to roll
    back the changes. Calling the `reload` method from the Store is what we need to
    do to make it work.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你可以添加一个消息询问用户是否真的想要回滚更改。从 Store 调用 `reload` 方法是我们需要做的来使其工作。
- en: Tip
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As an alternative to the `reload` method of the Store, we could also call the
    method `rejectChanges` instead; however, the `reload` method is more failsafe,
    since we are getting the information from the server again.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Store 的 `reload` 方法的替代，我们也可以调用 `rejectChanges` 方法；然而，`reload` 方法更安全，因为我们再次从服务器获取信息。
- en: Clearing the filter
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除过滤器
- en: 'When using the `filter` plugin on the GridPanel, it will do everything that
    we need (when used locally). But there is one thing that it doesn''t provide to
    the user: the option to clear all the filters at once. So that is why we implemented
    a **Clear Filters** button.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 GridPanel 上使用 `filter` 插件时，它将执行我们需要的所有操作（当本地使用时）。但是，它没有提供给用户的一项功能：一次性清除所有过滤器的选项。这就是为什么我们实现了**清除过滤器**按钮。
- en: 'So first, let''s listen to the event:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，让我们监听这个事件：
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And then we can implement the method:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以实现这个方法：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When using the `filter` plugin, we are able to get a property named `filters`
    from the GridPanel. Then, all we need to do it is to call the `clearFilters` method.
    This will clear the filter values from each column that was filtered and will
    also clear the filters from the Store.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `filter` 插件时，我们能够从 GridPanel 获取一个名为 `filters` 的属性。然后，我们只需要调用 `clearFilters`
    方法。这将清除每个被过滤的列的过滤器值，并也会从 Store 中清除过滤器。
- en: Listening to Store events in the Controller
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Controller 中监听 Store 事件
- en: And the last event we will be listening to is the `write` event from the Store.
    We already added an `exception` listener to the Proxy (in Ext JS 3, the Store
    had an exception listener, while in Ext JS 4 and 5 this listener was moved to
    the Proxy). Now we need to add a listener in case of success.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要监听的最后一个是 Store 的 `write` 事件。我们已经在 Proxy 中添加了一个 `exception` 监听器（在 Ext JS
    3 中，Store 有一个异常监听器，而在 Ext JS 4 和 5 中，这个监听器被移动到了 Proxy）。现在我们需要添加一个监听器以处理成功的情况。
- en: The first step is to listen to the event from the Store in the Controller. This
    feature was introduced in Ext JS 4.2.x.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在 Controller 中监听 Store 的事件。这个功能是在 Ext JS 4.2.x 中引入的。
- en: 'Inside the `init` function of the Controller, we will add the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Controller 的 `init` 函数中，我们将添加以下代码：
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can listen to Store events inside the store option. The previous code will
    work for the **Actors** screen. If we want to do the same for the other screen,
    we need to add the same code as the preceding one. For example, the following
    code needs to be added for the **Categories** screen:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在存储选项中监听 Store 事件。之前的代码将适用于**演员**屏幕。如果我们想对其他屏幕做同样的事情，我们需要添加与前面相同的代码。例如，以下代码需要添加到**分类**屏幕：
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We cannot use the Base Store `storeId` here because each child Store will have
    its own `storeId`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在这里使用 Base Store 的 `storeId`，因为每个子 Store 都将有自己的 `storeId`。
- en: 'The write event is fired whenever the Store receives the response from the
    server. So let''s implement the method:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Store 收到来自服务器的响应时，将触发写事件。所以让我们实现这个方法：
- en: '[PRE39]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will simply display a message saying the changes have been saved. Notice
    that the message is also generic; this way we can use it for all the static data
    modules. A screenshot of the output is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地显示一条消息，说明更改已保存。请注意，该消息也是通用的；这样我们就可以为所有静态数据模块使用它。输出截图如下：
- en: '![Listening to Store events in the Controller](img/0457OT_07_17.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![在控制器中监听 Store 事件](img/0457OT_07_17.jpg)'
- en: Debug tip – Sencha extension for Chrome
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试技巧 – Chrome 的 Sencha 扩展程序
- en: Sometimes we need to inspect a particular Ext JS component we have instantiated
    for debugging purposes. Finding which methods are available and the current attributes
    and configurations that are set in the object can be a little tricky. When working
    in MVC, we might need to find the Store ID created and the stores that are alive
    in the application. Using `console.log` to output a particular object to inspect
    it is a lot of work!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要检查我们实例化的特定 Ext JS 组件以进行调试。找到可用的方法和对象中设置的当前属性和配置可能有点棘手。在 MVC 工作时，我们可能需要找到创建的
    Store ID 和应用程序中活跃的存储。使用 `console.log` 输出特定对象以进行检查是一项大量工作！
- en: 'The Sencha Labs team released a free extension for Chrome called **Sencha App
    Inspector**. When working with Ext JS (or Sencha Touch), it is recommended that
    you use this extension to help debug the application. In the following screenshot,
    we can see the extension in action—stores that have been instantiated by the application
    and the data that has been loaded into it:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Labs 团队发布了一个名为 **Sencha App Inspector** 的免费 Chrome 扩展程序。当使用 Ext JS（或
    Sencha Touch）时，建议您使用此扩展程序来帮助调试应用程序。在下面的屏幕截图中，我们可以看到扩展程序在运行——应用程序实例化的存储以及加载到其中的数据：
- en: '![Debug tip – Sencha extension for Chrome](img/0457OT_07_18.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![调试技巧 – Chrome 的 Sencha 扩展程序](img/0457OT_07_18.jpg)'
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about Sencha App Inspector and the download link please
    visit [https://github.com/senchalabs/AppInspector/](https://github.com/senchalabs/AppInspector/).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Sencha App Inspector 的更多信息以及下载链接，请访问 [https://github.com/senchalabs/AppInspector/](https://github.com/senchalabs/AppInspector/)。
- en: Firefox extension – Illuminations for Developers
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Firefox 扩展程序 – 开发者照明
- en: If your favorite browser for development is not Chrome, there is also a Sencha
    extension for Firefox (which can be used within Firebug) called Illuminations
    for Developers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢的开发浏览器不是 Chrome，还有适用于 Firefox（可在 Firebug 中使用）的 Sencha 扩展程序，名为开发者照明。
- en: It is not a free extension (but it is possible to try it for free for a limited
    period of time), and its cost has a good cost-benefit.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个免费扩展程序（但可以在有限的时间内免费试用），其成本具有很好的性价比。
- en: 'In the following screenshot, we can see the extension in action (stores that
    have been instantiated by the application and its properties):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到扩展程序在运行（应用程序实例化的存储及其属性）：
- en: '![Firefox extension – Illuminations for Developers](img/0457OT_07_19.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![Firefox 扩展程序 – 开发者照明](img/0457OT_07_19.jpg)'
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about Illuminations for Developers and the download link,
    please visit [http://www.illuminations-for-developers.com/](http://www.illuminations-for-developers.com/).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有关开发者照明以及下载链接的更多信息，请访问 [http://www.illuminations-for-developers.com/](http://www.illuminations-for-developers.com/)。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to implement screens that look very similar
    to the MySQL Table Editor. The most important concept we covered in this chapter
    is implementing abstract classes, using the inheritance concept from OOP. We are
    used to using these concepts on server-side languages, such as PHP, Java, .NET,
    and so on. This chapter demonstrated that it is also important to use these concepts
    on the Ext JS side; this way, we can reuse a lot of code and also implement generic
    code that provides the same capability for more than one screen.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何实现与 MySQL 表编辑器非常相似的屏幕。本章中我们介绍的最重要概念是使用面向对象编程中的继承概念实现抽象类。我们习惯于在服务器端语言中使用这些概念，例如
    PHP、Java、.NET 等。本章演示了在 Ext JS 端使用这些概念也同样重要；这样，我们可以重用大量代码，并且实现通用的代码，为多个屏幕提供相同的功能。
- en: 'We created a Base Model, Store, View and a Controller. We used the following
    plugins: `celleditor` for the GridPanel and Live Search grid and `filter` plugin
    for the GridPanel as well. You learned how to perform CRUD operations using the
    Store capabilities. You also learned how to create custom events and handle Widget
    Column events on the Controller. We also explored many of the MVC Controller capabilities
    in this chapter.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个基础模型、存储、视图和控制器。我们使用了以下插件：`celleditor` 用于 GridPanel 和 Live Search 网格，以及
    `filter` 插件用于 GridPanel。你学习了如何使用 Store 的功能来执行 CRUD 操作。你还学习了如何在控制器上创建自定义事件和处理 Widget
    Column 事件。在本章中，我们还探索了许多 MVC 控制器的功能。
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Reminder: you can get the complete source code for this chapter (with extra
    capabilities and server-side code) by downloading the code bundle from this book
    or from the GitHub repository [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：你可以通过从本书或 GitHub 仓库 [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs)
    下载代码包来获取本章（包含额外功能和服务器端代码）的完整源代码。
- en: In the next chapter, you will learn how to implement the Content Management
    module, which goes further than just managing one single table as we did on this
    chapter. We will manage information from other tables (related to the business
    of the application) and all its relations within the database.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何实现内容管理模块，这比本章中仅管理单个表要深入得多。我们将管理来自其他表（与应用程序的业务相关）的信息及其在数据库中的所有关系。
