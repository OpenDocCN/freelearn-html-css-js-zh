- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Callbacks and Events
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调和事件
- en: In synchronous programming, we conceptualize code as a series of consecutive
    computing steps that solve a specific problem. Every operation is blocking, which
    means that only when an operation is completed, it is possible to execute the
    next one. This approach makes the code very easy to read, understand, and debug.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步编程中，我们将代码概念化为一系列连续的计算步骤，这些步骤解决特定问题。每个操作都是阻塞的，这意味着只有当操作完成时，才能执行下一个操作。这种方法使得代码非常易于阅读、理解和调试。
- en: On the other side, in asynchronous programming, some operations, such as reading
    from a file or performing a network request, are launched and then executed "in
    the background." When we invoke an asynchronous operation, the instruction that
    follows is executed immediately, even if the previous asynchronous operation has
    not finished yet. In this scenario, we need a way to get notified when an asynchronous
    operation completes, and then continue the execution flow using the results from
    the operation. The most basic mechanism to get notified about the completion of
    an asynchronous operation in Node.js is the **callback**, which is nothing more
    than a function invoked by the runtime with the result of an asynchronous operation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一方面，在异步编程中，一些操作，如读取文件或执行网络请求，被启动并在“后台”执行。当我们调用异步操作时，接下来的指令会立即执行，即使前面的异步操作尚未完成。在这种情况下，我们需要一种方式来通知异步操作完成，然后使用操作的结果继续执行流程。在Node.js中，通知异步操作完成的最基本机制是**回调**，它只是由运行时调用的一个函数，该函数带有异步操作的结果。
- en: The callback is the most basic building block on which all other asynchronous
    mechanisms are based. In fact, without callbacks, we wouldn't have promises, and therefore
    not even async/await; we also wouldn't have streams or events. This is why it's
    important to know how callbacks work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是所有其他异步机制的基础性构建块。实际上，没有回调，我们就不会有承诺，因此也不会有async/await；我们也不会有流或事件。这就是为什么了解回调的工作原理很重要的原因。
- en: In this chapter, you will learn more about the Node.js Callback pattern and
    understand what it means, in practice, to write asynchronous code. We will make
    our way through conventions, patterns, and pitfalls, and by the end of this chapter,
    you will have mastered the basics of the Callback pattern.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将更深入地了解Node.js回调模式，并理解在实践中编写异步代码意味着什么。我们将逐步了解约定、模式和陷阱，到本章结束时，你将掌握回调模式的基础。
- en: You will also learn about the Observer pattern, which can be considered a close
    relative of the Callback pattern. The Observer pattern—embodied by the `EventEmitter`—uses
    callbacks to deal with multiple heterogeneous events and is one of the most extensively
    used components in Node.js programming.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将了解观察者模式，它可以被认为是回调模式的一个近亲。观察者模式——由`EventEmitter`体现——使用回调来处理多个异构事件，并且在Node.js编程中是最广泛使用的组件之一。
- en: 'To summarize, this is what you will learn in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这是本章你将学习的内容：
- en: The Callback pattern, how it works, what conventions are used in Node.js, and
    how to deal with its most common pitfalls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调模式的工作原理、Node.js中使用的约定以及如何处理其最常见的陷阱
- en: The Observer pattern and how to implement it in Node.js using the `EventEmitter`
    class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式及其在Node.js中使用`EventEmitter`类实现的方法
- en: The Callback pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调模式
- en: Callbacks are the materialization of the handlers of the Reactor pattern (introduced
    in the previous chapter). They are one of those imprints that give Node.js its
    distinctive programming style.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是反应器模式（在前一章中介绍）的处理器的具体体现。它们是那些赋予Node.js独特编程风格印记之一。
- en: Callbacks are functions that are invoked to propagate the result of an operation,
    and this is exactly what we need when dealing with asynchronous operations. In
    the asynchronous world, they replace the use of the `return` instruction, which,
    in turn, always executes synchronously. JavaScript is the ideal language for callbacks
    because functions are first-class objects and can be easily assigned to variables,
    passed as arguments, returned from another function invocation, or stored in data
    structures. Another ideal construct for implementing callbacks is **closures**.
    With closures, we can reference the environment in which a function was created;
    this way, we can always maintain the context in which the asynchronous operation
    was requested, no matter when or where its callback is invoked.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是用于传播操作结果的函数，这正是我们在处理异步操作时所需要的。在异步世界中，它们取代了`return`指令的使用，而`return`指令始终是同步执行的。JavaScript是回调的理想语言，因为函数是一等对象，可以轻松地分配给变量、作为参数传递、从另一个函数调用返回，或存储在数据结构中。实现回调的另一个理想结构是**闭包**。使用闭包，我们可以引用函数创建时的环境；这样，我们就可以始终维护异步操作请求的上下文，无论其回调何时或在哪里被调用。
- en: If you need to refresh your knowledge about closures, you can refer to the article
    on MDN Web Docs at [nodejsdp.link/mdn-closures](http://nodejsdp.link/mdn-closures).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要刷新关于闭包的知识，你可以参考MDN Web Docs上的文章[http://nodejsdp.link/mdn-closures](http://nodejsdp.link/mdn-closures)。
- en: In this section, we will analyze this particular style of programming, which
    uses callbacks instead of `return` instructions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析这种特定的编程风格，它使用回调而不是`return`指令。
- en: The continuation-passing style
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延续传递风格
- en: In JavaScript, a callback is a function that is passed as an argument to another
    function and is invoked with the result when the operation completes. In functional
    programming, this way of propagating the result is called **continuation-passing
    style** (**CPS**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，回调是一个作为参数传递给另一个函数的函数，当操作完成时，它将使用结果被调用。在函数式编程中，这种传播结果的方式被称为**延续传递风格**（**CPS**）。
- en: It is a general concept, and it is not always associated with asynchronous operations.
    In fact, it simply indicates that a result is propagated by passing it to another
    function (the callback), instead of directly returning it to the caller.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用概念，它并不总是与异步操作相关联。事实上，它仅仅表明结果是通过传递给另一个函数（回调）来传播的，而不是直接返回给调用者。
- en: Synchronous CPS
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步CPS
- en: 'To clarify this concept, let''s take a look at a simple synchronous function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明这个概念，让我们看看一个简单的同步函数：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you are wondering, there is nothing special going on here. The result is
    passed back to the caller using the `return` instruction. This is also called **direct
    style**, and it represents the most common way of returning a result in synchronous programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这里感到困惑，这里并没有什么特殊的事情发生。结果是使用`return`指令返回给调用者的。这也被称为**直接风格**，它代表了同步编程中返回结果最常见的方式。
- en: 'The equivalent CPS of the preceding function would be as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数的等价CPS如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `addCps()` function is a synchronous CPS function. It''s synchronous because
    it will complete its execution only when the callback completes its execution
    too. The following code demonstrates this statement:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`addCps()`函数是一个同步的CPS函数。它是同步的，因为它只有在回调完成执行后才会完成其执行。以下代码演示了这一点：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since `addCps()` is synchronous, the previous code will trivially print the
    following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`addCps()`是同步的，之前的代码将简单地打印以下内容：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's see how asynchronous CPS works.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看异步CPS是如何工作的。
- en: Asynchronous CPS
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步CPS
- en: 'Let''s consider a case where the `addCps()` function is asynchronous:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个`addCps()`函数是异步的情况：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous code, we used `setTimeout()` to simulate an asynchronous invocation
    of the callback. `setTimeout()` adds a task to the event queue that is executed
    after the given number of milliseconds. This is clearly an asynchronous operation.
    Now, let''s try to use `additionAsync()` and see how the order of the operations
    changes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们使用`setTimeout()`来模拟回调的异步调用。`setTimeout()`将任务添加到事件队列中，在给定数量的毫秒数后执行。这显然是一个异步操作。现在，让我们尝试使用`additionAsync()`并看看操作顺序如何变化：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code will print the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将打印以下内容：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since `setTimeout()` triggers an asynchronous operation, it doesn't wait for
    the callback to be executed; instead, it returns immediately, giving the control
    back to `additionAsync()`, and then back again to its caller. This property in
    Node.js is crucial, as it gives control back to the event loop as soon as an asynchronous request
    is sent, thus allowing a new event from the queue to be processed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`setTimeout()`触发异步操作，它不会等待回调执行；相反，它立即返回，将控制权交还给`additionAsync()`，然后再交还给其调用者。在Node.js中，这个特性至关重要，因为它在发送异步请求后立即将控制权交还给事件循环，从而允许处理队列中的新事件。
- en: '*Figure 3.1* shows how this works:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.1* 展示了它是如何工作的：'
- en: '![](img/B15729_03_01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15729_03_01.png)'
- en: 'Figure 3.1: Control flow of an asynchronous function''s invocation'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：异步函数调用的控制流
- en: When the asynchronous operation completes, the execution is then resumed, starting
    from the callback provided to the asynchronous function that caused the unwinding.
    The execution starts from the event loop, so it has a fresh stack. This is where
    JavaScript comes in really handy. Thanks to closures, it is trivial to maintain
    the context of the caller of the asynchronous function, even if the callback is invoked
    at a different point in time and from a different location.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步操作完成时，执行将从导致展开的异步函数提供的回调处恢复，从事件循环开始，因此它有一个新的栈。这正是JavaScript真正派上用场的地方。多亏了闭包，即使回调在时间上和位置上不同，也能轻松地维护异步函数调用者的上下文。
- en: To sum this up, a synchronous function blocks until it completes its operations.
    An asynchronous function returns immediately, and its result is passed to a handler
    (in our case, a callback) at a later cycle of the event loop.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，同步函数会阻塞直到完成其操作。异步函数立即返回，并在事件循环的后续周期将结果传递给处理程序（在我们的例子中，是一个回调）。
- en: Non-CPS callbacks
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非CPS回调
- en: 'There are several circumstances in which the presence of a callback argument
    might make us think that a function is asynchronous or is using a CPS. That''s
    not always true. Let''s take, for example, the `map()` method of an `Array` object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，回调参数的存在可能会让我们认为一个函数是异步的或正在使用CPS（Continuation Passing Style）。这并不总是正确的。以`Array`对象的`map()`方法为例：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Clearly, the callback is used just to iterate over the elements of the array,
    and not to pass the result of the operation. In fact, the result is returned synchronously
    using a direct style. There's no syntactic difference between non-CPS callbacks
    and CPS ones. Therefore, the intent of a callback should be clearly stated in
    the documentation of the API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，回调仅用于遍历数组的元素，而不是传递操作的结果。实际上，结果是通过直接风格同步返回的。非CPS回调和CPS回调之间没有语法上的区别。因此，回调的意图应在API的文档中明确说明。
- en: In the next section, we are going to discuss one of the most important pitfalls
    of callbacks that every Node.js developer should be aware of.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论每个Node.js开发者都应该注意的回调的一个最重要的陷阱。
- en: Synchronous or asynchronous?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步或异步？
- en: You have seen how the execution order of the instructions changes radically
    depending on the nature of a function—synchronous or asynchronous. This has strong
    repercussions on the flow of the entire application, both in terms of correctness
    and efficiency. The following is an analysis of these two paradigms and their
    pitfalls. In general, what must be avoided is creating inconsistency and confusion
    around the nature of an API, as doing so can lead to a set of problems that might
    be very hard to detect and reproduce. To drive our analysis, we will take, as
    an example, the case of an inconsistently asynchronous function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到，根据函数的性质（同步或异步），指令的执行顺序发生了根本性的变化。这在正确性和效率方面对整个应用程序的流程都有强烈的影响。以下是对这两种范式及其缺陷的分析。一般来说，必须避免在API的性质上造成不一致和混淆，因为这样做可能会导致一系列可能很难检测和重现的问题。为了推动我们的分析，我们将以一个不一致的异步函数为例。
- en: An unpredictable function
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个不可预测的函数
- en: 'One of the most dangerous situations is to have an API that behaves synchronously
    under certain conditions and asynchronously under others. Let''s take the following
    code as an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最危险的情况之一是API在某些条件下表现为同步，而在其他条件下表现为异步。以下代码是一个例子：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding function uses the `cache` map to store the results of different
    file read operations. Bear in mind that this is just an example; it does not have
    error management, and the caching logic itself is suboptimal (in *Chapter 11*,
    *Advanced Recipes*, you'll learn how to handle asynchronous caching properly).
    But besides all this, the preceding function is dangerous because it behaves asynchronously
    until the file is read for the first time and the cache is set, but it is synchronous
    for all the subsequent requests once the file's content is already in the cache.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数使用`cache`映射来存储不同文件读取操作的结果。请记住，这只是一个例子；它没有错误管理，并且缓存逻辑本身也不是最优的（在*第11章*，*高级技巧*中，您将学习如何正确处理异步缓存）。但除此之外，前面的函数是危险的，因为它在第一次读取文件并设置缓存之前是异步的，但在文件内容已经在缓存中之后，对于所有后续请求都是同步的。
- en: Unleashing Zalgo
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解放Zalgo
- en: 'Now, let''s discuss how the use of an unpredictable function, such as the one
    that we just defined, can easily break an application. Consider the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下使用不可预测的函数，例如我们刚刚定义的函数，如何轻易地破坏一个应用程序。考虑以下代码：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the preceding function is invoked, it creates a new object that acts as
    a notifier, allowing us to set multiple listeners for a file read operation. All
    the listeners will be invoked at once when the read operation completes and the
    data is available. The preceding function uses our `inconsistentRead()` function
    to implement this functionality. Let''s see how to use the `createFileReader()` function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的函数被调用时，它创建了一个新的对象，充当通知器，允许我们为文件读取操作设置多个监听器。当读取操作完成且数据可用时，所有监听器将同时被调用。前面的函数使用我们的`inconsistentRead()`函数来实现这一功能。让我们看看如何使用`createFileReader()`函数：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will print the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将打印以下内容：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the callback of the second reader is never invoked. Let''s
    see why:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第二个读者的回调从未被调用。让我们看看原因：
- en: During the creation of `reader1`, our `inconsistentRead()` function behaves
    asynchronously because there is no cached result available. This means that any
    `onDataReady` listener will be invoked later in another cycle of the event loop,
    so we have all the time we need to register our listener.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建`reader1`期间，我们的`inconsistentRead()`函数是异步的，因为没有可用的缓存结果。这意味着任何`onDataReady`监听器将在事件循环的另一个周期中稍后调用，所以我们有足够的时间注册我们的监听器。
- en: Then, `reader2` is created in a cycle of the event loop in which the cache for
    the requested file already exists. In this case, the inner call to `inconsistentRead()` will
    be synchronous. So, its callback will be invoked immediately, which means that
    all the listeners of `reader2` will be invoked synchronously as well. However,
    we are registering the listener after the creation of `reader2`, so it will never
    be invoked.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`reader2`是在事件循环的某个周期中创建的，此时请求的文件的缓存已经存在。在这种情况下，对`inconsistentRead()`的内部调用将是同步的。因此，它的回调将立即被调用，这意味着`reader2`的所有监听器也将同步调用。然而，我们在`reader2`创建之后注册监听器，所以它永远不会被调用。
- en: The callback behavior of our `inconsistentRead()` function is really unpredictable
    as it depends on many factors, such as the frequency of its invocation, the filename
    passed as an argument, and the amount of time taken to load the file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`inconsistentRead()`函数的回调行为真的很不可预测，因为它取决于许多因素，例如其调用的频率、作为参数传递的文件名以及加载文件所需的时间。
- en: The bug that you've just seen can be extremely complicated to identify and reproduce
    in a real application. Imagine using a similar function in a web server, where
    there can be multiple concurrent requests. Imagine seeing some of those requests
    hanging, without any apparent reason and without any error being logged. This
    can definitely be considered a nasty defect.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚才看到的错误在真实应用程序中可能非常复杂，难以识别和重现。想象一下在一个网络服务器中使用类似的函数，那里可能有多个并发请求。想象一下看到一些请求挂起，没有任何明显的原因，也没有记录任何错误。这绝对可以被认为是一个讨厌的缺陷。
- en: Isaac Z. Schlueter, the creator of npm and former Node.js project lead, in one
    of his blog posts, compared the use of this type of unpredictable function to *unleashing
    Zalgo*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: npm的创建者、前Node.js项目负责人Isaac Z. Schlueter在他的博客文章中，将这种不可预测函数的使用比作*释放Zalgo*。
- en: Zalgo is an internet legend about an ominous entity believed to cause insanity,
    death, and the destruction of the world. If you're not familiar with Zalgo, you
    are invited to find out what it is.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Zalgo是一个关于一个被认为会导致疯狂、死亡和世界毁灭的邪恶实体的互联网传说。如果您不熟悉Zalgo，欢迎您去了解它是什么。
- en: You can find Isaac Z. Schlueter's original post at [nodejsdp.link/unleashing-zalgo](http://nodejsdp.link/unleashing-zalgo).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Isaac Z. Schlueter的原始帖子](http://nodejsdp.link/unleashing-zalgo)中找到。
- en: Using synchronous APIs
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用同步API
- en: 'The lesson to learn from the unleashing Zalgo example is that it is imperative
    for an API to clearly define its nature: either synchronous or asynchronous.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从释放Zalgo的例子中可以学到的是，对于API来说，明确定义其性质至关重要：要么是同步的，要么是异步的。
- en: 'One possible fix for our `inconsistentRead()` function is to make it completely
    synchronous. This is possible because Node.js provides a set of synchronous direct
    style APIs for most basic I/O operations. For example, we can use the `fs.readFileSync()` function
    in place of its asynchronous counterpart. The code would become as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的`inconsistentRead()`函数的一个可能的修复方案是使其完全同步。这是可能的，因为Node.js为大多数基本I/O操作提供了一套同步直接风格API。例如，我们可以使用`fs.readFileSync()`函数来代替其异步对应函数。代码将如下所示：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see that the entire function was also converted into direct style. There
    is no reason for a function to have a CPS if it is synchronous. In fact, it is
    always best practice to implement a synchronous API using a direct style. This
    will eliminate any confusion around its nature and will also be more efficient
    from a performance perspective.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，整个函数也被转换成了直接风格。如果一个函数是同步的，那么它没有必要使用CPS（Continuation Passing Style）。实际上，始终使用直接风格实现同步API是最佳实践。这将消除对其本质的任何混淆，并且从性能角度来看也会更高效。
- en: '**Pattern**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式**'
- en: Always choose a direct style for purely synchronous functions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总是为纯同步函数选择直接风格。
- en: Bear in mind that changing an API from CPS to a direct style, or from asynchronous
    to synchronous or vice versa, might also require a change to the style of all
    the code using it. For example, in our case, we will have to totally change the
    interface of our `createFileReader()` API and adapt it so that it always works
    synchronously.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，将API从CPS（Continuation Passing Style）转换为直接风格，或从异步转换为同步或反之亦然，可能还需要更改所有使用该API的代码的风格。例如，在我们的案例中，我们将不得不完全更改`createFileReader()`API的接口，并使其始终以同步方式工作。
- en: 'Also, using a synchronous API instead of an asynchronous one has some caveats:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用同步API而不是异步API也有一些注意事项：
- en: A synchronous API for a specific functionality might not always be available.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于特定的功能，同步API可能并不总是可用。
- en: A synchronous API will block the event loop and put any concurrent requests
    on hold. This will break the Node.js concurrency model, slowing down the whole
    application. You will see later in this book what this really means for our applications.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步API将阻塞事件循环，并暂停任何并发请求。这将破坏Node.js的并发模型，减慢整个应用程序的速度。您将在本书的后面部分看到这对我们的应用程序真正意味着什么。
- en: In our `consistentReadSync()` function, the risk of blocking the event loop
    is partially mitigated because the synchronous I/O API is invoked only once per
    filename, while the cached value will be used for all the subsequent invocations.
    If we have a limited number of static files, then using `consistentReadSync()` won't
    have a big effect on our event loop. Things can change quickly if we have to read
    many files and only once.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`consistentReadSync()`函数中，由于同步I/O API仅在每次调用时针对每个文件名调用一次，而缓存的值将被用于所有后续调用，因此部分缓解了阻塞事件循环的风险。如果我们有有限数量的静态文件，那么使用`consistentReadSync()`对我们的事件循环不会有太大影响。如果我们必须读取许多文件，并且只读取一次，那么情况可能会迅速变化。
- en: Using synchronous I/O in Node.js is strongly discouraged in many circumstances,
    but in some situations, this might be the easiest and most efficient solution.
    Always evaluate your specific use case in order to choose the right alternative.
    As an example, it makes perfect sense to use a synchronous blocking API to load
    a configuration file while bootstrapping an application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，在Node.js中使用同步I/O被强烈反对，但在某些情况下，这可能是最简单、最有效率的解决方案。始终评估您的特定用例，以便选择正确的替代方案。例如，在启动应用程序时使用同步阻塞API加载配置文件是完全合理的。
- en: '**Pattern**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式**'
- en: Use blocking APIs sparingly and only when they don't affect the ability of the
    application to handle concurrent asynchronous operations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 适度使用阻塞API，并且仅在它们不影响应用程序处理并发异步操作的能力时使用。
- en: Guaranteeing asynchronicity with deferred execution
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用延迟执行保证异步性
- en: 'Another alternative for fixing our `inconsistentRead()` function is to make
    it purely asynchronous. The trick here is to schedule the synchronous callback
    invocation to be executed "in the future" instead of it being run immediately
    in the same event loop cycle. In Node.js, this is possible with `process.nextTick()`,
    which defers the execution of a function after the currently running operation
    completes. Its functionality is very simple: it takes a callback as an argument
    and pushes it to the top of the event queue, in front of any pending I/O event,
    and returns immediately. The callback will then be invoked as soon as the currently
    running operation yields control back to the event loop.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个修复我们的 `inconsistentRead()` 函数的替代方案是使其完全异步。这里的技巧是将同步回调调用安排在“将来”执行，而不是在同一个事件循环周期内立即执行。在
    Node.js 中，这可以通过 `process.nextTick()` 实现，它会在当前运行的操作完成后延迟函数的执行。它的功能非常简单：它接受一个回调作为参数，并将其推送到事件队列的顶部，在所有挂起的
    I/O 事件之前，并立即返回。然后，回调将在当前运行的操作将控制权交回事件循环时立即被调用。
- en: 'Let''s apply this technique to fix our `inconsistentRead()` function, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这种技术应用到修复我们的 `inconsistentRead()` 函数，如下所示：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, thanks to `process.nextTick()`, our function is guaranteed to invoke its
    callback asynchronously, under any circumstances. Try to use it instead of the
    `inconsistentRead()` function and verify that, indeed, Zalgo has been eradicated.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，多亏了 `process.nextTick()`，我们的函数在任何情况下都能保证异步调用其回调。尝试用它来代替 `inconsistentRead()`
    函数，并验证确实已经消除了 Zalgo。
- en: '**Pattern**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式**'
- en: You can guarantee that a callback is invoked asynchronously by deferring its
    execution using `process.nextTick()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `process.nextTick()` 来延迟回调的执行，从而保证回调异步调用。
- en: Another API for deferring the execution of code is `setImmediate()`. While its
    purpose is very similar to that of `process.nextTick()`, its semantics are quite
    different. Callbacks deferred with `process.nextTick()` are called **microtasks**
    and they are executed just after the current operation completes, even before
    any other I/O event is fired. With `setImmediate()`, on the other hand, the execution
    is queued in an event loop phase that comes after all I/O events have been processed.
    Since `process.nextTick()` runs before any already scheduled I/O, it will be executed
    faster, but under certain circumstances, it might also delay the running of any
    I/O callback indefinitely (also known as **I/O starvation**), such as in the presence
    of a recursive invocation. This can never happen with `setImmediate()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于延迟代码执行的 API 是 `setImmediate()`。虽然它的目的与 `process.nextTick()` 非常相似，但其语义却大不相同。使用
    `process.nextTick()` 延迟的回调被称为 **微任务**，它们将在当前操作完成后立即执行，甚至在任何其他 I/O 事件触发之前。另一方面，使用
    `setImmediate()`，执行将在所有 I/O 事件处理完毕后的一个事件循环阶段中排队。由于 `process.nextTick()` 在任何已安排的
    I/O 之前运行，它将更快地执行，但在某些情况下，它也可能无限期地延迟任何 I/O 回调的运行（也称为 **I/O 饥饿**），例如在递归调用的情况下。而
    `setImmediate()` 永远不会发生这种情况。
- en: Using `setTimeout(callback, 0)` has a behavior comparable to that of `setImmediate()`,
    but in typical circumstances, callbacks scheduled with `setImmediate()` are executed
    faster than those scheduled with `setTimeout(callback, 0)`. To see why, we have
    to consider that the event loop executes all the callbacks in different phases;
    for the type of events we are considering, we have timers (`setTimeout()`) that
    are executed before I/O callbacks, which are, in turn, executed before `setImmediate()`
    callbacks. This means that if we queue a task with `setImmediate()` in a `setTimeout()`
    callback, in an I/O callback, or in a microtask queued after these two phases,
    then the callback will be executed in a phase that comes right after the phase
    we are currently in. `setTimeout()` callbacks have to wait for the next cycle
    of the event loop.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setTimeout(callback, 0)` 的行为与 `setImmediate()` 类似，但在典型情况下，使用 `setImmediate()`
    安排的回调比使用 `setTimeout(callback, 0)` 安排的回调执行得更快。要了解为什么，我们必须考虑事件循环在不同的阶段执行所有回调；对于我们所考虑的事件类型，我们有定时器（`setTimeout()`），它在
    I/O 回调之前执行，而 I/O 回调又会在 `setImmediate()` 回调之前执行。这意味着，如果我们在一个 `setTimeout()` 回调、一个
    I/O 回调，或者在这两个阶段之后的微任务队列中安排一个 `setImmediate()` 任务，那么回调将在紧接当前阶段的阶段中执行。`setTimeout()`
    回调必须等待事件循环的下一个周期。
- en: You will better appreciate the difference between these APIs when we analyze
    the use of deferred invocation for running synchronous CPU-bound tasks later in this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分析本书后面使用延迟调用运行同步 CPU 密集型任务时，你会更好地理解这些 API 之间的区别。
- en: Next, we are going to explore the conventions used to define callbacks in Node.js.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨在 Node.js 中定义回调所使用的约定。
- en: Node.js callback conventions
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 回调约定
- en: In Node.js, CPS APIs and callbacks follow a set of specific conventions. These
    conventions apply to the Node.js core API, but they are also followed by the vast
    majority of the userland modules and applications. So, it's very important that
    you understand them and make sure that you comply whenever you need to design
    an asynchronous API that makes use of callbacks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中，CPS API 和回调遵循一组特定的约定。这些约定适用于 Node.js 核心API，但也被绝大多数用户模块和应用所遵循。因此，了解这些约定并在需要设计使用回调的异步API时确保遵守它们非常重要。
- en: The callback comes last
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调放在最后
- en: In all core Node.js functions, the standard convention is that when a function
    accepts a callback as input, this has to be passed as the last argument.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有核心 Node.js 函数中，标准约定是当一个函数接受回调作为输入时，必须将其作为最后一个参数传递。
- en: 'Let''s take the following Node.js core API as an example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的 Node.js 核心API为例：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see from the signature of the preceding function, the callback is
    always put in the last position, even in the presence of optional arguments. The
    reason for this convention is that the function call is more readable in case
    the callback is defined in place.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面函数的签名中看到的，回调总是放在最后一个位置，即使在存在可选参数的情况下也是如此。这种约定的原因是，如果回调在原地定义，函数调用将更易于阅读。
- en: Any error always comes first
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任何错误总是首先出现
- en: 'In CPS, errors are propagated like any other type of result, which means using
    callbacks. In Node.js, any error produced by a CPS function is always passed as
    the first argument of the callback, and any actual result is passed starting from
    the second argument. If the operation succeeds without errors, the first argument
    will be `null` or `undefined`. The following code shows you how to define a callback
    that complies with this convention:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPS中，错误像任何其他类型的结果一样传播，这意味着使用回调。在 Node.js 中，由CPS函数产生的任何错误总是作为回调的第一个参数传递，任何实际的结果从第二个参数开始传递。如果操作成功且没有错误，第一个参数将是
    `null` 或 `undefined`。以下代码展示了如何定义符合此约定的回调：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is best practice to always check for the presence of an error, as not doing
    so will make it harder for you to debug your code and discover the possible points
    of failure. Another important convention to take into account is that the error
    must always be of type `Error`. This means that simple strings or numbers should
    never be passed as error objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 总是检查错误的存在是一种最佳实践，因为不这样做会使您更难调试代码并发现可能的失败点。另一个需要考虑的重要约定是，错误必须始终是 `Error` 类型。这意味着简单的字符串或数字永远不会作为错误对象传递。
- en: Propagating errors
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传播错误
- en: Propagating errors in synchronous, direct style functions is done with the well-known `throw` statement,
    which causes the error to jump up in the call stack until it is caught.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步、直接风格的函数中传播错误使用的是众所周知的 `throw` 语句，它会导致错误在调用栈中向上跳转，直到被捕获。
- en: 'In asynchronous CPS, however, proper error propagation is done by simply passing
    the error to the next callback in the chain. The typical pattern looks as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在异步CPS中，通过简单地将错误传递给链中的下一个回调来正确地传播错误。典型的模式如下：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how we propagate the error received by the `readFile()` operation. We
    do not throw it or return it; instead, we just use the callback as if it were
    any other result. Also, notice how we use the `try...catch` statement to catch
    any error thrown by `JSON.parse()`, which is a synchronous function and therefore
    uses the traditional `throw` instruction to propagate errors to the caller. Lastly,
    if everything went well, `callback` is invoked with `null` as the first argument
    to indicate that there are no errors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何传播 `readFile()` 操作接收到的错误的。我们既没有抛出它，也没有返回它；相反，我们只是像使用任何其他结果一样使用回调。此外，注意我们是如何使用
    `try...catch` 语句来捕获 `JSON.parse()` 抛出的任何错误，这是一个同步函数，因此使用传统的 `throw` 指令将错误传播给调用者的。最后，如果一切顺利，`callback`
    将以 `null` 作为第一个参数被调用，表示没有错误。
- en: It's also interesting to note how we refrained from invoking `callback` from
    within the `try` block. This is because doing so would catch any error thrown
    from the execution of the callback itself, which is usually not what we want.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 也很有趣地注意到我们如何在 `try` 块中避免调用 `callback`。这是因为这样做会捕获从回调执行中抛出的任何错误，而这通常不是我们想要的。
- en: Uncaught exceptions
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未捕获的异常
- en: Sometimes, it can happen that an error is thrown and not caught within the callback
    of an asynchronous function. This could happen if, for example, we had forgotten
    to surround `JSON.parse()` with a `try...catch` statement in the `readJSON()` function
    we defined previously. Throwing an error inside an asynchronous callback would
    cause the error to jump up to the event loop, so it would never be propagated
    to the next callback. In Node.js, this is an unrecoverable state and the application
    would simply exit with a non-zero exit code, printing the stack trace to the `stderr` interface.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能会发生错误被抛出但未在异步函数的回调中捕获的情况。例如，如果我们忘记在之前定义的`readJSON()`函数中将`JSON.parse()`用`try...catch`语句包裹起来。在异步回调内部抛出错误会导致错误跳转到事件循环，因此它永远不会传播到下一个回调。在Node.js中，这是一个无法恢复的状态，应用程序将以非零退出代码退出，并将堆栈跟踪打印到`stderr`接口。
- en: 'To demonstrate this, let''s try to remove the `try...catch` block surrounding
    `JSON.parse()` from the `readJSON()` function we defined previously:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们尝试从之前定义的`readJSON()`函数中移除围绕`JSON.parse()`的`try...catch`块：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, in the function we just defined, there is no way of catching an eventual
    exception coming from `JSON.parse()`. If we try to parse an invalid JSON file
    with the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们刚刚定义的函数中，没有方法可以捕获来自`JSON.parse()`的潜在异常。如果我们尝试用以下代码解析一个无效的JSON文件：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will result in the application being abruptly terminated, with a stack
    trace similar to the following being printed on the console:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致应用程序突然终止，控制台上将打印出类似于以下内容的堆栈跟踪：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, if you look at the preceding stack trace, you will see that it starts from
    within the built-in `fs` module, and exactly from the point in which the native
    API has completed reading and returned its result back to the `fs.readFile()` function,
    via the event loop. This clearly shows that the exception traveled from our callback,
    up the call stack, and then straight into the event loop, where it was finally
    caught and thrown to the console.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看前面的堆栈跟踪，你会看到它从内置的`fs`模块内部开始，并且正好是从原生API完成读取并将结果通过事件循环返回到`fs.readFile()`函数的那个点。这清楚地表明异常是从我们的回调，沿着调用栈向上，然后直接进入事件循环，最终在那里被捕获并抛出到控制台。
- en: 'This also means that wrapping the invocation of `readJSONThrows()` with a `try...catch` block
    will not work, because the stack in which the block operates is different from
    the one in which our callback is invoked. The following code shows the anti-pattern
    that was just described:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着将`readJSONThrows()`的调用用`try...catch`块包裹起来不会起作用，因为该块操作的栈与我们的回调被调用的栈不同。以下代码展示了刚刚描述的反模式：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding `catch` statement will never receive the JSON parsing error, as
    it will travel up the call stack in which the error was thrown, that is, in the
    event loop and not in the function that triggered the asynchronous operation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`catch`语句永远不会收到JSON解析错误，因为它将在抛出错误的调用栈中向上传播，即事件循环中，而不是触发异步操作的那个函数中。
- en: 'As mentioned previously, the application will abort the moment an exception
    reaches the event loop. However, we still have the chance to perform some cleanup
    or logging before the application terminates. In fact, when this happens, Node.js
    will emit a special event called `uncaughtException`, just before exiting the
    process. The following code shows a sample use case:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当异常到达事件循环时，应用程序将终止。然而，我们仍然有机会在应用程序终止之前执行一些清理或记录操作。事实上，当这种情况发生时，Node.js将在退出进程之前发出一个名为`uncaughtException`的特殊事件。以下代码展示了示例用法：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's important to understand that an uncaught exception leaves the application
    in a state that is not guaranteed to be consistent, which can lead to unforeseeable
    problems. For example, there might still be incomplete I/O requests running or
    closures might have become inconsistent. That's why it is always advised, especially
    in production, to never leave the application running after an uncaught exception
    is received. Instead, the process should exit immediately, optionally after having
    run some necessary cleanup tasks, and ideally, a supervising process should restart
    the application. This is also known as the **fail-fast** approach and it's the
    recommended practice in Node.js.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，未捕获的异常会使应用程序处于一种无法保证一致性的状态，这可能导致不可预见的问题。例如，可能仍然有未完成的 I/O 请求正在运行，或者闭包可能已经变得不一致。这就是为什么在收到未捕获的异常后，始终建议，尤其是在生产环境中，不要让应用程序在异常后继续运行。相反，进程应立即退出，可选地运行一些必要的清理任务，理想情况下，监督进程应重新启动应用程序。这也被称为
    **fail-fast** 方法，并且在 Node.js 中是推荐的做法。
- en: We'll discuss supervisors in more detail in *Chapter 12*, *Scalability and Architectural
    Patterns*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 12 章，*可扩展性和架构模式*中更详细地讨论监督者（supervisors）。
- en: This concludes our gentle introduction to the Callback pattern. Now, it's time
    to meet the Observer pattern, which is another critical component of an event-driven
    platform such as Node.js.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对回调模式的温和介绍。现在，是时候认识观察者模式了，它是 Node.js 这样的事件驱动平台中的另一个关键组件。
- en: The Observer pattern
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Another important and fundamental pattern used in Node.js is the **Observer**
    pattern. Together with the Reactor pattern and callbacks, the Observer pattern is
    an absolute requirement for mastering the asynchronous world of Node.js.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中使用的另一个重要且基本的设计模式是 **观察者模式**。与反应器模式（Reactor pattern）和回调函数（callbacks）一起，观察者模式是掌握
    Node.js 异步世界的绝对要求。
- en: 'The Observer pattern is the ideal solution for modeling the reactive nature
    of Node.js and a perfect complement for callbacks. Let''s give a formal definition,
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是模拟 Node.js 的反应性特性的理想解决方案，并且是回调函数的完美补充。让我们给出一个正式的定义，如下：
- en: The Observer pattern defines an object (called subject) that can notify a set
    of observers (or listeners) when a change in its state occurs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式定义了一个对象（称为主题），当其状态发生变化时，可以通知一组观察者（或监听器）。
- en: The main difference from the Callback pattern is that the subject can actually
    notify multiple observers, while a traditional CPS callback will usually propagate
    its result to only one listener, the callback.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与回调模式的主要区别在于，主题（subject）实际上可以通知多个观察者（observers），而传统的 CPS 回调通常只会将结果传播给一个监听器，即回调函数。
- en: The EventEmitter
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EventEmitter
- en: 'In traditional object-oriented programming, the Observer pattern requires interfaces,
    concrete classes, and a hierarchy. In Node.js, all this becomes much simpler.
    The Observer pattern is already built into the core and is available through the `EventEmitter` class.
    The `EventEmitter` class allows us to register one or more functions as listeners,
    which will be invoked when a particular event type is fired. *Figure 3.2* visually
    explains this concept:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的面向对象编程中，观察者模式需要接口、具体类和层次结构。在 Node.js 中，所有这些都变得简单得多。观察者模式已经内置到核心中，并通过 `EventEmitter`
    类提供。`EventEmitter` 类允许我们将一个或多个函数注册为监听器，当触发特定事件类型时，这些函数将被调用。*图 3.2* 从视觉上解释了这一概念：
- en: '![](img/B15729_03_02.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15729_03_02.png)'
- en: 'Figure 3.2: Listeners receiving events from an EventEmitter'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：监听器从 EventEmitter 接收事件
- en: 'The `EventEmitter` is exported from the `events` core module. The following
    code shows how we can obtain a reference to it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` 是从 `events` 核心模块导出的。以下代码展示了我们如何获取对其的引用：'
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The essential methods of the `EventEmitter` are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` 的基本方法如下：'
- en: '`on(event, listener)`: This method allows us to register a new listener (a
    function) for the given event type (a string).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on(event, listener)`: 此方法允许我们为给定的事件类型（字符串）注册一个新的监听器（函数）。'
- en: '`once(event, listener)`: This method registers a new listener, which is then
    removed after the event is emitted for the first time.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`once(event, listener)`: 此方法注册一个新的监听器，在事件首次发出后将被移除。'
- en: '`emit(event, [arg1], [...])`: This method produces a new event and provides
    additional arguments to be passed to the listeners.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emit(event, [arg1], [...])`: 此方法产生一个新的事件，并提供额外的参数传递给监听器。'
- en: '`removeListener(event, listener)`: This method removes a listener for the specified
    event type.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeListener(event, listener)`: 此方法移除指定事件类型的监听器。'
- en: All the preceding methods will return the `EventEmitter` instance to allow chaining.
    The `listener` function has the signature `function([arg1], [...])`, so it simply
    accepts the arguments provided at the moment the event is emitted.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前面方法都会返回 `EventEmitter` 实例以允许链式调用。`listener` 函数的签名是 `function([arg1], [...])`，所以它简单地接受在事件发出时提供的参数。
- en: You can already see that there is a big difference between a listener and a
    traditional Node.js callback. In fact, the first argument is not an error, but
    it can be any data passed to `emit()` at the moment of its invocation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到，监听器与传统 Node.js 回调之间有一个很大的区别。实际上，第一个参数不是一个错误，但它可以是调用 `emit()` 时传递的任何数据。
- en: Creating and using the EventEmitter
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用 EventEmitter
- en: 'Let''s now see how we can use an `EventEmitter` in practice. The simplest way
    is to create a new instance and use it immediately. The following code shows us
    a function that uses an `EventEmitter` to notify its subscribers in real time
    when a particular regular expression is matched in a list of files:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何在实际中使用一个 `EventEmitter`。最简单的方法是创建一个新的实例并立即使用它。以下代码展示了一个函数，它使用 `EventEmitter`
    在实时中通知其订阅者当在文件列表中匹配到特定的正则表达式时：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The function we just defined returns an `EventEmitter` instance that will produce
    three events:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才定义的函数返回一个 `EventEmitter` 实例，该实例将产生三个事件：
- en: '`fileread`, when a file is being read'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileread`，当正在读取文件时'
- en: '`found`, when a match has been found'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`found`，当找到匹配项时'
- en: '`error,` when an error occurs during reading the file'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`，当读取文件时发生错误'
- en: 'Let''s now see how our `findRegex()` function can be used:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的 `findRegex()` 函数如何使用：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the code we just defined, we register a listener for each of the three event
    types produced by the `EventEmitter` that was created by our `findRegex()` function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚才定义的代码中，我们为 `findRegex()` 函数创建的 `EventEmitter` 产生的三种事件类型中的每一种都注册了一个监听器。
- en: Propagating errors
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传播错误
- en: As with callbacks, the `EventEmitter` can't just `throw` an exception when an error condition
    occurs. Instead, the convention is to emit a special event, called `error`, and
    pass an `Error` object as an argument. That's exactly what we were doing in the `findRegex()` function
    that we defined earlier.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与回调一样，当发生错误条件时，`EventEmitter` 不能只是 `throw` 一个异常。相反，惯例是发出一个特殊的事件，称为 `error`，并将一个
    `Error` 对象作为参数传递。这正是我们在之前定义的 `findRegex()` 函数中所做的。
- en: The `EventEmitter` treats the `error` event in a special way. It will automatically
    throw an exception and exit from the application if such an event is emitted and
    no associated listener is found. For this reason, it is recommended to always
    register a listener for the `error` event.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` 会以特殊的方式处理 `error` 事件。如果发出此类事件且没有找到相关监听器，它将自动抛出异常并退出应用程序。因此，建议始终为
    `error` 事件注册监听器。'
- en: Making any object observable
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使任何对象可观察
- en: In the Node.js world, the `EventEmitter` is rarely used on its own, as you saw
    in the previous example. Instead, it is more common to see it extended by other
    classes. In practice, this enables any class to inherit the capabilities of the
    `EventEmitter`, hence becoming an observable object.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 的世界中，正如你在前面的例子中看到的，`EventEmitter` 很少单独使用。相反，它更常见的是被其他类扩展。在实践中，这使任何类都能继承
    `EventEmitter` 的功能，从而成为一个可观察的对象。
- en: 'To demonstrate this pattern, let''s try to implement the functionality of the `findRegex()` function
    in a class, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个模式，让我们尝试在一个类中实现 `findRegex()` 函数的功能，如下所示：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `FindRegex` class that we just defined extends `EventEmitter` to become
    a fully fledged observable class. Always remember to use `super()` in the constructor
    to initialize the `EventEmitter` internals.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才定义的 `FindRegex` 类通过扩展 `EventEmitter` 成为一个完整的可观察类。始终记得在构造函数中使用 `super()`
    来初始化 `EventEmitter` 的内部结构。
- en: 'The following is an example of how to use the `FindRegex` class we just defined:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们刚才定义的 `FindRegex` 类的用法示例：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You will now notice how the `FindRegex` object also provides the `on()` method,
    which is inherited from the `EventEmitter`. This is a pretty common pattern in
    the Node.js ecosystem. For example, the `Server` object of the core HTTP module
    inherits from the `EventEmitter` function, thus allowing it to produce events
    such as `request` (when a new request is received), `connection` (when a new connection
    is established), or `closed` (when the server socket is closed).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会注意到`FindRegex`对象也提供了`on()`方法，这是从`EventEmitter`继承而来的。这在Node.js生态系统中是一个相当常见的模式。例如，核心HTTP模块的`Server`对象继承自`EventEmitter`函数，因此它能够产生诸如`request`（当接收到新请求时）、`connection`（当建立新连接时）或`closed`（当服务器套接字关闭时）等事件。
- en: Other notable examples of objects extending the `EventEmitter` are Node.js streams.
    We will analyze streams in more detail in *Chapter 6*, *Coding with Streams*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`EventEmitter`的其他显著例子是Node.js流。我们将在*第6章*，*使用流进行编码*中更详细地分析流。
- en: EventEmitter and memory leaks
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EventEmitter和内存泄漏
- en: When subscribing to observables with a long life span, it is extremely important
    that we **unsubscribe** our listeners once they are no longer needed. This allows
    us to release the memory used by the objects in a listener's scope and prevent
    **memory leaks**. Unreleased `EventEmitter` listeners are the main source of memory
    leaks in Node.js (and JavaScript in general).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当订阅具有长期生命周期的可观察对象时，一旦不再需要，我们取消订阅监听器非常重要。这允许我们释放监听器作用域中对象使用的内存，并防止**内存泄漏**。未释放的`EventEmitter`监听器是Node.js（以及JavaScript总体上）中内存泄漏的主要来源。
- en: 'A memory leak is a software defect whereby memory that is no longer needed
    is not released, causing the memory usage of an application to grow indefinitely.
    For example, consider the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏是一种软件缺陷，其中不再需要的内存没有被释放，导致应用程序的内存使用无限增长。例如，考虑以下代码：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The variable `thisTakesMemory` is referenced in the listener and therefore its
    memory is retained until the listener is released from `emitter`, or until the
    `emitter` itself is garbage collected, which can only happen when there are no
    more active references to it, making it unreachable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`thisTakesMemory`在监听器中被引用，因此它的内存保留直到监听器从`emitter`中释放，或者直到`emitter`本身被垃圾回收，这只能发生在没有更多活动引用它时，使其变得不可达。
- en: You can find a good explanation about garbage collection in JavaScript and the
    concept of reachability at [nodejsdp.link/garbage-collection](http://nodejsdp.link/garbage-collection).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[nodejsdp.link/garbage-collection](http://nodejsdp.link/garbage-collection)找到关于JavaScript垃圾回收和可达性概念的详细解释。
- en: 'This means that if an `EventEmitter` remains reachable for the entire duration
    of the application, all its listeners do too, and with them all the memory they
    reference. If, for example, we register a listener to a "permanent" `EventEmitter`
    at every incoming HTTP request and never release it, then we are causing a memory
    leak. The memory used by the application will grow indefinitely, sometimes slowly,
    sometimes faster, but eventually it will crash the application. To prevent such
    a situation, we can release the listener with the `removeListener()` method of
    the `EventEmitter`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果一个`EventEmitter`在整个应用程序运行期间都保持可达状态，那么所有它的监听器也是如此，以及它们所引用的所有内存。例如，如果我们为每个进入的HTTP请求注册一个监听器到“永久”的`EventEmitter`，并且从不释放它，那么我们就会导致内存泄漏。应用程序使用的内存将无限增长，有时缓慢，有时快速，但最终会导致应用程序崩溃。为了防止这种情况，我们可以使用`EventEmitter`的`removeListener()`方法来释放监听器：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: An `EventEmitter` has a very simple built-in mechanism for warning the developer
    about possible memory leaks. When the count of listeners registered to an event
    exceeds a specific amount (by default, 10), the `EventEmitter` will produce a
    warning. Sometimes, registering more than 10 listeners is completely fine, so
    we can adjust this limit by using the `setMaxListeners()` method of the `EventEmitter`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`有一个非常简单的内置机制来警告开发者关于可能的内存泄漏。当一个事件注册的监听器数量超过特定数量（默认为10）时，`EventEmitter`将产生一个警告。有时，注册超过10个监听器是完全正常的，因此我们可以通过使用`EventEmitter`的`setMaxListeners()`方法来调整这个限制。'
- en: We can use the convenience method `once(event, listener)` in place of `on(event,
    listener)` to automatically unregister a listener after the event is received
    for the first time. However, be advised that if the event we specify is never
    emitted, then the listener is never released, causing a memory leak.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`once(event, listener)`便利方法代替`on(event, listener)`，在事件第一次接收后自动注销监听器。然而，请注意，如果我们指定的事件从未发出，那么监听器永远不会释放，这可能导致内存泄漏。
- en: Synchronous and asynchronous events
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步和异步事件
- en: As with callbacks, events can also be emitted synchronously or asynchronously
    with respect to the moment the tasks that produce them are triggered. It is crucial
    that we never mix the two approaches in the same `EventEmitter`, but even more
    importantly, we should never emit the same event type using a mix of synchronous
    and asynchronous code, to avoid producing the same problems described in the *Unleashing
    Zalgo* section. The main difference between emitting synchronous and asynchronous
    events lies in the way listeners can be registered.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与回调函数一样，事件也可以相对于触发产生它们的任务的时间同步或异步地发出。我们绝对不能在同一个`EventEmitter`中混合这两种方法，但更重要的是，我们绝对不应该使用同步和异步代码的混合来发出相同的事件类型，以避免在*Unleashing
    Zalgo*部分中描述的相同问题。同步和异步事件之间的主要区别在于监听器注册的方式。
- en: When events are emitted asynchronously, we can register new listeners, even
    after the task that produces the events is triggered, up until the current stack
    yields to the event loop. This is because the events are guaranteed not to be
    fired until the next cycle of the event loop, so we can be sure that we won't
    miss any events.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件异步发出时，我们可以在触发产生事件的任务之后注册新的监听器，直到当前调用栈将控制权交给事件循环。这是因为事件保证不会在事件循环的下一个周期之前被触发，因此我们可以确信我们不会错过任何事件。
- en: 'The `FindRegex()` class we defined previously emits its events asynchronously
    after the `find()` method is invoked. This is why we can register the listeners
    *after* the `find()` method is invoked, without losing any events, as shown in
    the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的`FindRegex()`类在调用`find()`方法后异步发出其事件。这就是为什么我们可以在调用`find()`方法之后注册监听器，而不会丢失任何事件，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On the other hand, if we emit our events synchronously after the task is launched,
    we have to register all the listeners *before* we launch the task, or we will
    miss all the events. To see how this works, let''s modify the `FindRegex` class
    we defined previously and make the `find()` method synchronous:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们启动任务后同步地发出事件，我们必须在启动任务之前注册所有监听器，否则我们会错过所有事件。为了了解这是如何工作的，让我们修改之前定义的`FindRegex`类，并将`find()`方法改为同步：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s try to register a listener before we launch the `find()` task,
    and then a second listener after that to see what happens:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们启动`find()`任务之前，让我们尝试注册一个监听器，然后在该任务启动后注册第二个监听器，看看会发生什么：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As expected, the listener that was registered after the invocation of the `find()`
    task is never called; in fact, the preceding code will print:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在`find()`任务调用之后注册的监听器永远不会被调用；实际上，前面的代码将打印：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are some (rare) situations in which emitting an event in a synchronous
    fashion makes sense, but the very nature of the `EventEmitter` lies in its ability
    to deal with asynchronous events. Most of the time, emitting events synchronously
    is a telltale sign that we either don't need the `EventEmitter` at all or that,
    somewhere else, the same observable is emitting another event asynchronously,
    potentially causing a Zalgo type of situation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些（很少见）情况下，以同步方式发出事件是有意义的，但`EventEmitter`的本质在于其处理异步事件的能力。大多数时候，同步发出事件是一个明显的迹象，表明我们根本不需要`EventEmitter`，或者在其他地方，同一个可观察对象正在异步地发出另一个事件，这可能导致Zalgo类型的情况。
- en: The emission of synchronous events can be deferred with `process.nextTick()`
    to guarantee that they are emitted asynchronously.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`process.nextTick()`将同步事件的发出延迟，以确保它们是异步发出的。
- en: EventEmitter versus callbacks
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`EventEmitter`与回调函数'
- en: 'A common dilemma when defining an asynchronous API is deciding whether to use
    an `EventEmitter` or simply accept a callback. The general differentiating rule
    is semantic: callbacks should be used when a result must be returned in an asynchronous
    way, while events should be used when there is a need to communicate that something
    has happened.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 定义异步API时常见的困境是决定是否使用`EventEmitter`或简单地接受回调。一般区分规则是语义的：当需要以异步方式返回结果时，应使用回调；而当需要传达某事已发生时，应使用事件。
- en: 'But besides this simple principle, a lot of confusion is generated from the
    fact that the two paradigms are, most of the time, equivalent and allow us to
    achieve the same results. Consider the following code as an example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但除了这个简单的原则之外，由于这两种范式在大多数情况下是等价的，并且允许我们达到相同的结果，因此会产生很多混淆。以下代码作为例子：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The two functions `helloEvents()` and `helloCallback()` can be considered equivalent
    in terms of functionality. The first communicates the completion of the timeout
    using an event, while the second uses a callback. But what really differentiates
    them is the readability, the semantics, and the amount of code that is required
    for them to be implemented or used.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能的角度来看，`helloEvents()`和`helloCallback()`两个函数可以被认为是等价的。第一个使用事件传达超时的完成，而第二个使用回调。但真正区分它们的是可读性、语义以及实现或使用它们所需的代码量。
- en: 'While a deterministic set of rules for you to choose between one style or the
    other can''t be given, here are some hints to help you make a decision on which
    method to use:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不能给出一个确定性的规则来指导你选择一种风格或另一种风格，但以下是一些提示，帮助你决定使用哪种方法：
- en: Callbacks have some limitations when it comes to supporting different types
    of events. In fact, we can still differentiate between multiple events by passing
    the type as an argument of the callback, or by accepting several callbacks, one
    for each supported event. However, this can't exactly be considered an elegant
    API. In this situation, the `EventEmitter` can give a better interface and leaner
    code.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调在支持不同类型的事件方面有一些局限性。实际上，我们仍然可以通过传递类型作为回调的参数或接受多个回调（每个回调对应一个支持的事件）来区分多个事件。然而，这不能被认为是一个优雅的API。在这种情况下，`EventEmitter`可以提供更好的接口和更简洁的代码。
- en: The `EventEmitter` should be used when the same event can occur multiple times,
    or may not occur at all. A callback, in fact, is expected to be invoked exactly
    once, whether the operation is successful or not. Having a possibly repeating
    circumstance should make us think again about the semantic nature of the occurrence,
    which is more similar to an event that has to be communicated, rather than a result
    to be returned.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当同一个事件可能发生多次，或者根本不会发生时，应使用`EventEmitter`。实际上，回调预期只被调用一次，无论操作是否成功。存在可能重复的情况应该让我们重新思考发生的语义性质，这更类似于必须传达的事件，而不是要返回的结果。
- en: An API that uses callbacks can notify only one particular callback, while using
    an `EventEmitter` allows us to register multiple listeners for the same event.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回调的API只能通知一个特定的回调，而使用`EventEmitter`允许我们为同一事件注册多个监听器。
- en: Combining callbacks and events
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合回调和事件
- en: There are some particular circumstances where the `EventEmitter` can be used
    in conjunction with a callback. This pattern is extremely powerful as it allows
    us to pass a result asynchronously using a traditional callback, and at the same
    time return an `EventEmitter`, which can be used to provide a more detailed account
    on the status of an asynchronous process.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特定情况下，`EventEmitter`可以与回调一起使用。这种模式非常强大，因为它允许我们使用传统的回调异步传递结果，同时返回一个`EventEmitter`，它可以用来提供关于异步过程状态的更详细说明。
- en: 'One example of this pattern is offered by the `glob` package ([nodejsdp.link/npm-glob](http://nodejsdp.link/npm-glob)),
    a library that performs glob-style file searches. The main entry point of the
    module is the function it exports, which has the following signature:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的一个例子是由`glob`包提供的（[nodejsdp.link/npm-glob](http://nodejsdp.link/npm-glob)），这是一个执行glob样式的文件搜索的库。模块的主要入口点是它导出的函数，该函数具有以下签名：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The function takes a `pattern` as the first argument, a set of `options`, and
    a `callback` that is invoked with the list of all the files matching the provided
    pattern. At the same time, the function returns an `EventEmitter`, which provides
    a more fine-grained report about the state of the search process. For example,
    it is possible to be notified in real time when a match occurs by listening to
    the `match` event, to obtain the list of all the matched files with the `end`
    event, or to know whether the process was manually aborted by listening to the
    `abort` event. The following code shows what this looks like in practice:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受一个 `pattern` 作为第一个参数，一组 `options`，以及一个 `callback`，该 `callback` 被调用时，会传入与提供的模式匹配的所有文件的列表。同时，该函数返回一个
    `EventEmitter`，它提供了关于搜索过程状态的更详细报告。例如，可以通过监听 `match` 事件来实时通知匹配发生，通过 `end` 事件获取所有匹配文件的列表，或者通过监听
    `abort` 事件来了解过程是否被手动终止。以下代码展示了实际应用中的样子：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Combining an `EventEmitter` with traditional callbacks is an elegant way to
    offer two different approaches to the same API. One approach is usually meant
    to be simpler and more immediate to use, while the other is targeted at more advanced
    scenarios.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `EventEmitter` 与传统回调函数结合使用是一种优雅的方式来提供对同一 API 的两种不同方法。一种方法通常意味着更简单、更直接的使用方式，而另一种则针对更复杂的场景。
- en: 'The `EventEmitter` can also be combined with other asynchronous mechanisms
    such as promises (which we will look at in *Chapter 5*, *Asynchronous Control
    Flow Patterns with Promises and Async/Await*). In this case, just return an object
    (or array) containing both the promise and the `EventEmitter`. This object can
    then be destructured by the caller, like this: `{promise, events} = foo()`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` 还可以与其他异步机制（如承诺，我们将在第 5 章 *使用承诺和 Async/Await 的异步控制流模式* 中探讨）结合使用。在这种情况下，只需返回一个包含承诺和
    `EventEmitter` 的对象（或数组）。然后，调用者可以像这样解构该对象：`{promise, events} = foo()`。'
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we made our first contact with the practical aspects of writing
    asynchronous code. You discovered the two pillars of the entire Node.js asynchronous
    infrastructure—the callback and the `EventEmitter`—and we explored in detail their
    use cases, conventions, and patterns. We also explored some of the pitfalls of
    dealing with asynchronous code and you learned about the ways to avoid them. Mastering
    the content of this chapter paves the way toward learning the more advanced asynchronous
    techniques that will be presented throughout the rest of this book.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首次接触到了编写异步代码的实际方面。你发现了整个 Node.js 异步基础设施的两个支柱——回调和 `EventEmitter`——并且我们详细探讨了它们的使用案例、约定和模式。我们还探讨了处理异步代码的一些陷阱，并学习了避免它们的方法。掌握本章内容为学习本书其余部分将展示的更高级异步技术铺平了道路。
- en: In the next chapter, you will learn how to deal with complex asynchronous control
    flows using callbacks.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用回调函数处理复杂的异步控制流。
- en: Exercises
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**3.1 A simple event**: Modify the asynchronous `FindRegex` class so that it
    emits an event when the find process starts, passing the input files list as an argument.
    Hint: beware of Zalgo!'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3.1 简单事件**：修改异步 `FindRegex` 类，使其在查找过程开始时发出一个事件，并将输入文件列表作为参数传递。提示：注意 Zalgo
    问题！'
- en: '**3.2 Ticker**: Write a function that accepts a `number` and a `callback` as
    the arguments. The function will return an `EventEmitter` that emits an event
    called `tick` every 50 milliseconds until the `number` of milliseconds is passed
    from the invocation of the function. The function will also call the `callback`
    when the `number` of milliseconds has passed, providing, as the result, the total
    count of `tick` events emitted. Hint: you can use `setTimeout()` to schedule another
    `setTimeout()` recursively.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3.2 计时器**：编写一个函数，该函数接受一个 `number` 和一个 `callback` 作为参数。该函数将返回一个 `EventEmitter`，该
    `EventEmitter` 每隔 50 毫秒发出一个名为 `tick` 的事件，直到从函数调用开始经过的毫秒数达到指定的数值。当经过的毫秒数达到时，该函数还将调用
    `callback`，并提供作为结果的 `tick` 事件的总计数。提示：可以使用 `setTimeout()` 递归地安排另一个 `setTimeout()`。'
- en: '**3.3 A simple modification**: Modify the function created in exercise 3.2
    so that it emits a `tick` event immediately after the function is invoked.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3.3 简单修改**：修改在练习 3.2 中创建的函数，使其在函数调用后立即发出一个 `tick` 事件。'
- en: '**3.4 Playing with errors**: Modify the function created in exercise 3.3 so
    that it produces an error if the timestamp at the moment of a `tick` (including
    the initial one that we added as part of exercise 3.3) is divisible by 5\. Propagate
    the error using both the callback and the event emitter. Hint: use `Date.now()`
    to get the timestamp and the remainder (`%`) operator to check whether the timestamp
    is divisible by 5\.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3.4 玩转错误处理**：修改在练习3.3中创建的函数，使其在`tick`时刻（包括我们在练习3.3中添加的初始时刻）的戳记可以被5整除时产生一个错误。使用回调和事件发射器来传播这个错误。提示：使用`Date.now()`获取戳记，并使用取余（`%`）运算符来检查戳记是否可以被5整除。'
