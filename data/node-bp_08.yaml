- en: Chapter 8. Developing Web App Workflow with Grunt and Gulp
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章：使用 Grunt 和 Gulp 开发 Web 应用工作流程
- en: In the last few chapters, we learned how to use Node.js together with the most
    popular client-side JavaScript frameworks such as AngularJS and Ember.js. We learned
    how to run a fully functional web server and build a command-line tool.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的几章中，我们学习了如何使用 Node.js 与最流行的客户端 JavaScript 框架，如 AngularJS 和 Ember.js 一起使用。我们学习了如何运行一个功能齐全的
    Web 服务器和构建命令行工具。
- en: In this chapter, we will explore the world of the task runners. Grunt and Gulp
    are two modules widely used and they have a solid collection of plugins.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索任务运行器的世界。Grunt 和 Gulp 是两个广泛使用的模块，它们拥有一个坚实的插件集合。
- en: Introducing the task runners
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍任务运行器
- en: Applications are agreeably complex in nature. More and more logic is put into
    the browser and it is written with many lines of JavaScript code. The new CSS3
    features and the improved performance of native browser animations lead to a lot
    of CSS code. Of course, at the end, we still want to keep the things separated.
    Make sure that everything is well-placed in different folders and files. Otherwise,
    our code will be difficult to maintain. We may need to generate `manifest.json`,
    use a preprocessor, or simply copy files from one location to another. Thankfully,
    there are instruments that make our life easier. The **task runner** accepts instructions
    and performs certain actions. It enables us to set a watcher and monitor files
    for changes. This is extremely helpful if we have a complex setup and a lot of
    aspects to handle.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在本质上通常是复杂的。越来越多的逻辑被放入浏览器中，并且用许多行 JavaScript 代码编写。新的 CSS3 特性和原生浏览器动画性能的改进导致大量的
    CSS 代码。当然，最后我们仍然希望将事物分开。确保所有内容都放置在不同的文件夹和文件中。否则，我们的代码将难以维护。我们可能需要生成 `manifest.json`，使用预处理器，或者简单地从一处复制文件到另一处。幸运的是，有一些工具可以使我们的生活变得更简单。**任务运行器**接受指令并执行某些操作。它使我们能够设置监视器并监视文件的变化。这对于我们有一个复杂的设置和许多方面要处理的情况非常有帮助。
- en: 'At the moment, there are two popular task runners for Node.js: Grunt and Gulp.
    They are widely used because of the plugins written specifically for them; the
    modules themselves don''t have many features; however, if we combine them with
    external plugins, they become our best friends. Even companies such as Twitter
    or Adobe elaborate on them.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有两个流行的 Node.js 任务运行器：Grunt 和 Gulp。它们之所以被广泛使用，是因为为它们编写的特定插件；模块本身没有很多功能；然而，如果我们将它们与外部插件结合使用，它们就变成了我们的好朋友。甚至像
    Twitter 或 Adobe 这样的公司也在详细阐述它们。
- en: Exploring Grunt
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Grunt
- en: '**Grunt** is a Node.js module, which means it is installed via the Node.js
    package manager. To get started, we need to install Grunt''s command-line tool.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grunt** 是一个 Node.js 模块，这意味着它是通过 Node.js 软件包管理器安装的。要开始使用，我们需要安装 Grunt 的命令行工具。'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After running `npm install`, we will be able to request the plugin by calling
    `grunt.loadNpmTasks` (`grunt-contrib-concat`). There is also a `grunt.loadTasks`
    method for custom-defined tasks. Now, let's continue and run our first Grunt script.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm install` 后，我们将能够通过调用 `grunt.loadNpmTasks` (`grunt-contrib-concat`) 来请求插件。还有一个
    `grunt.loadTasks` 方法用于自定义任务。现在，让我们继续并运行我们的第一个 Grunt 脚本。
- en: Concatenating files
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接文件
- en: Concatenation is one of the most common operations. It is the same with the
    CSS styles. Having many files means more server requests, which could decrease
    the performance of your application. The `grunt-contrib-concat` plugin is here
    to help. It accepts a `glob` pattern of source files and a destination path. It
    goes through all the folders, finds the files that match the pattern, and merges
    them. Let's prepare a folder for our small experiment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 连接操作是最常见的操作之一。它与 CSS 样式相同。拥有许多文件意味着更多的服务器请求，这可能会降低应用程序的性能。`grunt-contrib-concat`
    插件就是为了帮助解决这个问题。它接受源文件的 `glob` 模式和目标路径。它会遍历所有文件夹，找到匹配模式的文件，并将它们合并。让我们为我们的小型实验准备一个文件夹。
- en: '![Concatenating files](img/00030.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![连接文件](img/00030.jpeg)'
- en: 'The `build/scripts.js` file will be generated by Grunt. So, we don''t have
    to create it. Add some content to the files in the `src` folder. Our `Gruntfile.js`
    file should contain the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`build/scripts.js` 文件将由 Grunt 生成。因此，我们不需要创建它。向 `src` 文件夹中的文件添加一些内容。我们的 `Gruntfile.js`
    文件应该包含以下代码：'
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `concat` task contains a `javascript` object that holds the configuration
    for the concatenation. The source value is actually a `glob` pattern that matches
    all the JavaScript files inside the `src` folder and its subfolders. We have used
    the `glob` module in [Chapter 6](part0046_split_000.html#page "Chapter 6. Using
    Node.js as a Command-line Tool"), *Using Node.js as a Command-line Tool*. With
    the preceding code, we can run the `grunt` command in our terminal. We will get
    a result similar to what is shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat` 任务包含一个 `javascript` 对象，该对象包含合并的配置。源值实际上是一个 `glob` 模式，它匹配 `src` 文件夹及其子文件夹中的所有
    JavaScript 文件。我们在 [第 6 章](part0046_split_000.html#page "第 6 章。使用 Node.js 作为命令行工具")，*使用
    Node.js 作为命令行工具*中使用了 `glob` 模块。使用前面的代码，我们可以在我们的终端中运行 `grunt` 命令。我们将得到以下截图所示的结果：'
- en: '![Concatenating files](img/00031.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![合并文件](img/00031.jpeg)'
- en: The `scripts.js` file should be generated in the `build` directory and contain
    all the files from the `src` folder.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts.js` 文件应该生成在 `build` 目录中，并包含 `src` 文件夹中的所有文件。'
- en: 'Very often, we end up debugging the compiled file. This is mainly because it''s
    the file that we use in the browser and everything is saved together, so we can''t
    really see where the error is initiated. In such cases, it is good to add some
    text before the content in every file. This will allow us to see the original
    destination of the code. The new content of the `Gruntfile.js` file is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的情况是我们最终会调试编译后的文件。这主要是因为它是我们在浏览器中使用的文件，所有内容都保存在一起，所以我们实际上看不到错误是从哪里开始的。在这种情况下，在每份文件的内容之前添加一些文本是很好的。这将使我们能够看到代码的原始目的地。`Gruntfile.js`
    文件的新内容如下：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Thus, we pass a custom `process` function. It accepts the content of the file
    and its path. It should return the code we want to be concatenated. In our case,
    we just add a short comment at the top.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们传递一个自定义的 `process` 函数。它接受文件的文本内容和其路径。它应该返回我们想要合并的代码。在我们的例子中，我们只是在顶部添加了一个简短的注释。
- en: Minifying your code
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩你的代码
- en: '**Minification** is a process that makes our code smaller. It uses smart algorithms
    that replace the names of our variables and functions. It also removes the unnecessary
    spaces and tabs. That''s pretty important for optimization because it normally
    decreases the file size by half. Grunt''s plugin, `grunt-contrib-uglify`, provides
    this functionality. Let''s use the example code from the previous pages and modify
    our `Gruntfile.js` file as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩**是一个使我们的代码变得更小的过程。它使用智能算法来替换我们的变量和函数的名称。它还删除了不必要的空格和制表符。这对于优化来说非常重要，因为它通常可以将文件大小减少一半。Grunt
    的插件 `grunt-contrib-uglify` 提供了这项功能。让我们使用上一页的示例代码，并按如下方式修改我们的 `Gruntfile.js` 文件：'
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we do the following important tasks:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们执行以下重要任务：
- en: We add `grunt-contrib-uglify` to our `package.json` file
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `grunt-contrib-uglify` 添加到我们的 `package.json` 文件中
- en: We run `npm install` to get the module in the `node_modules` directory
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们运行 `npm install` 以获取 `node_modules` 目录中的模块
- en: At the end, we define the minification's options
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们定义了最小化的选项
- en: In the preceding code, we set up a new task called `uglify`. Its property, `files`,
    contains a hash of the conversions we want to perform. The key is the destination
    path and the value is the source file. In our case, the source file is the output
    of another task so that we can directly use the `<% %>` delimiters. We are able
    to set the exact path, but doing it using the delimiters is much more flexible.
    This is because we may end up with a very long Grunt file and it is always good
    to keep the code maintainable. If we have the destination in one place only, we
    are able to correct it without repeating the same change in other places.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们设置了一个名为 `uglify` 的新任务。它的属性 `files` 包含我们想要执行的转换的哈希。键是目标路径，值是源文件。在我们的例子中，源文件是另一个任务的输出，这样我们就可以直接使用
    `<% %>` 分隔符。我们能够设置确切的路径，但使用分隔符做这件事要灵活得多。这是因为我们可能会得到一个非常长的 Grunt 文件，而且总是保持代码可维护性是很好的。如果我们只有一个地方有目的地，我们就能够纠正它，而无需在其他地方重复相同的更改。
- en: Note that the tasks we defined depend on each other, that is, they should be
    run in a specific order. Otherwise, we will receive unexpected results. Like in
    our example, the `concat` task is performed before `uglify`. That's because the
    second one needs the result from the first.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们定义的任务相互依赖，即它们应该按特定顺序运行。否则，我们将收到意外的结果。就像我们的例子中，`concat` 任务在 `uglify` 之前执行。这是因为第二个任务需要第一个任务的结果。
- en: Watching files for changes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视文件变化
- en: 'Grunt is really great at doing some stuff for us. However, it is a bit annoying
    if we have to run it every time we change some of our files. Let''s take the situation
    in the previous section. We have a bunch of JavaScript scripts and want to merge
    them into one file. If we work with the compiled version, then we have to run
    the concatenation every time we make corrections to the source files. For such
    cases, the best thing to do is set up a watcher—a task that monitors our filesystems
    and triggers a specific task. A plugin called `grunt-contrib-watch` does exactly
    this for us. Add this to our `package.json` file and run `npm install` again to
    install it locally. Our file needs only one entry in the configuration. The following
    code shows the new watch property:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt在为我们做一些事情方面真的很出色。然而，如果我们每次更改一些文件时都必须运行它，那就有点烦人了。让我们看看上一节的情况。我们有一堆JavaScript脚本，想要将它们合并到一个文件中。如果我们使用编译版本，那么每次我们修改源文件时都必须运行连接操作。在这种情况下，最好的做法是设置一个监视器——一个监视我们的文件系统并触发特定任务的作业。一个名为`grunt-contrib-watch`的插件为我们做了这件事。将其添加到我们的`package.json`文件中，然后再次运行`npm
    install`以本地安装它。我们的文件只需要在配置中有一个条目。以下代码显示了新的监视属性：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is a `watch` task added after `concat` and `uglify`. Note that the plugin
    requires two options. The first one, `files`, contains the files we want to monitor
    and the second one, `tasks`, defines the processes that will be run. We are also
    executing a specific part of the `concat` task. At the moment, we have only one
    thing to concatenate, but if we work on a big project, we may have several types
    of files or even different JavaScript sources. So, it is always good to specify
    our definitions, especially for the watching `glob` patterns. We really don't
    want to run unnecessary tasks. For example, we normally don't concatenate JavaScript
    if some of the CSS files are changed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`concat`和`uglify`之后添加了一个`watch`任务。请注意，该插件需要两个选项。第一个选项是`files`，它包含我们想要监控的文件，第二个选项是`tasks`，它定义了将要运行的过程。我们还在执行`concat`任务的特定部分。目前，我们只有一个要连接的文件，但如果我们处理一个大型项目，我们可能有几种类型的文件，甚至可能有不同的JavaScript源。因此，始终指定我们的定义是很好的，特别是对于监控的`glob`模式。我们真的不希望运行不必要的任务。例如，如果某些CSS文件已更改，我们通常不会连接JavaScript。
- en: 'If we use the setup shown in the preceding code and run Grunt, we will see
    the output as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面代码中显示的设置并运行Grunt，我们将看到以下截图所示的输出：
- en: '![Watching files for changes](img/00032.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![监控文件变化](img/00032.jpeg)'
- en: There is pretty good logging that shows what exactly happened. All the tasks
    are run and the `src\A.js` file is changed. Immediately, the `concat` and `uglify`
    plugins are launched.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有很好的日志记录显示了确切发生了什么。所有任务都运行了，`src\A.js`文件已更改。立即，`concat`和`uglify`插件被启动。
- en: Ignoring files
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略文件
- en: 'Sometimes, we will have files that should not occupy a part in the whole process,
    for example, having a CSS file should not be concatenated with the others. Grunt
    offers a solution for such cases. Let''s say we want to skip the JavaScript in
    `src/lib/D.js`. We should update our `GruntFile.js` file and change the `src`
    property of the task:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们将有一些不应该在整个过程中占用一部分的文件，例如，拥有一个CSS文件不应该与其他文件连接。Grunt为这种情况提供了解决方案。比如说，我们想要跳过`src/lib/D.js`中的JavaScript。我们应该更新我们的`GruntFile.js`文件并更改任务的`src`属性：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All we have to do is to use an array instead of a single string. The exclamation
    mark in front of the value tells Grunt that we want this file to be ignored.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是使用一个数组而不是一个单独的字符串。值前面的感叹号告诉Grunt我们想要忽略这个文件。
- en: Creating our own task
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们自己的任务
- en: Grunt has an enormous collection of plugins and we will probably find what we
    want. However, there are situations where we need something custom for our projects.
    In such cases, we will need a custom task. Let's say we need to save the file
    size of the compiled JavaScript. We should access `build/scripts.js`, check its
    size, and write it to a file on the hard disk.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt拥有大量的插件，我们可能会找到我们想要的东西。然而，有些情况下我们需要为我们的项目定制一些东西。在这种情况下，我们需要一个自定义任务。比如说，我们需要保存编译后的JavaScript文件的大小。我们应该访问`build/scripts.js`，检查其大小，并将其写入硬盘上的一个文件。
- en: 'The first thing we need is a new directory that will host our tasks as shown
    in the following screenshots:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要一个新的目录来存放我们的任务，如下面的截图所示：
- en: '![Creating our own task](img/00033.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们自己的任务](img/00033.jpeg)'
- en: 'Note the `custom` folder and the `jssize.js` file. Its name may not match that
    of the new task, but it is a good practice to keep them in sync. Before writing
    the actual code that does the job, we will change our configuration to fire the
    task. So far, we used `grunt.loadNpmTasks` to indicate modules we will use during
    the processing. However, our script is not part of the Node.js'' package management
    and we have to use `grunt.loadTasks`. The method accepts a path to the folder
    containing our file as shown in the following lines of code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`custom`文件夹和`jssize.js`文件。它的名称可能不会与新任务的名称匹配，但将它们保持同步是一个好的实践。在编写实际执行工作的代码之前，我们将更改我们的配置以触发任务。到目前为止，我们使用了`grunt.loadNpmTasks`来指示在处理过程中将使用的模块。然而，我们的脚本不是Node.js的包管理的一部分，我们必须使用`grunt.loadTasks`。该方法接受包含我们的文件的文件夹的路径，如下面的代码行所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'All the files in the `custom` directory will be fetched and registered as valid,
    ready-to-use plugins. Now we can add our `jssize` task to the default tasks list
    so that it runs along with the others as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`custom`目录中的所有文件都将被检索并注册为有效的、可用的插件。现在我们可以将我们的`jssize`任务添加到默认任务列表中，以便它与其他任务一起运行，如下所示：'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the end, we will add a new entry in the object passed to the `grunt.initConfig`
    function as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在传递给`grunt.initConfig`函数的对象中添加一个新的条目，如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As this is our own task, we can pass whatever we think is necessary. In our
    case, this is the file we will get the size of and the path we will save the result
    in.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们自己的任务，我们可以传递我们认为必要的任何内容。在我们的情况下，这是我们想要获取大小的文件以及我们将保存结果的路径。
- en: 'A Grunt task is actually a Node.js module that exports a function by accepting
    the Grunt''s API object. The following is the content of the `custom/jssize.js`
    file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt任务实际上是一个通过接受Grunt的API对象导出函数的Node.js模块。以下是`custom/jssize.js`文件的内容：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The key moment is the `grunt.registerMultiTask` method. The first argument is
    the name of the task. This is quite important because the same string is used
    in the `Gruntfile.js` file. Immediately after, we pass a description and anonymous
    function. The body of that function contains the real logic to accomplish the
    task. The configurations we defined are available in the `this.data` object. The
    file-size check is done and the result is saved via the `grunt.file` API.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关键时刻是`grunt.registerMultiTask`方法。第一个参数是任务的名称。这非常重要，因为在`Gruntfile.js`文件中也使用了相同的字符串。紧接着，我们传递一个描述和匿名函数。该函数的主体包含完成任务的真正逻辑。我们定义的配置在`this.data`对象中可用。文件大小检查是通过`grunt.file`
    API完成的。
- en: Generating a cache manifest file
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成缓存清单文件
- en: We found out how to create our own Grunt task. Let's write something interesting.
    Let's generate a cache manifest file for the project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了如何创建我们自己的Grunt任务。让我们写一些有趣的东西。让我们为项目生成一个缓存清单文件。
- en: '**The Cache manifest** file is a declarative file we use to indicate the static
    resources of our web application. This could be our CSS files, images, HTML templates,
    video files, or something that remains consistent. This is a huge optimization
    trick because the browser will load these resources not from the web, but from
    the user''s device. If we need to update an already cached file, we should change
    the manifest.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存清单**文件是我们用来指示我们的Web应用程序静态资源的声明性文件。这可能是我们的CSS文件、图像、HTML模板、视频文件或保持一致的东西。这是一个巨大的优化技巧，因为浏览器将不会从网络而是从用户的设备加载这些资源。如果我们需要更新已缓存的文件，我们应该更改清单。'
- en: 'At the moment, we have only JavaScript files. Let''s add a few images and one
    CSS file. Make the necessary changes so that our project folder looks like the
    following figure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只有JavaScript文件。让我们添加一些图像和一个CSS文件。进行必要的更改，使我们的项目文件夹看起来如下所示：
- en: '![Generating a cache manifest file](img/00034.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![生成缓存清单文件](img/00034.jpeg)'
- en: 'The content of `styles.css` is not important. The images in the `img` folder
    are also not important. We just need different files to test with. The next thing
    we have to do is add our task to `Gruntfile.js`. We will use `generate-manifest`
    as a name as shown in the following code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`styles.css`的内容并不重要。`img`文件夹中的图像也不重要。我们只需要不同的文件来测试。接下来，我们必须将我们的任务添加到`Gruntfile.js`中。我们将使用`generate-manifest`作为名称，如下面的代码片段所示：'
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that we are passing several `glob` patterns; these are the files we want
    to add. Describing every single file in the configuration will take too much time
    and we could forget something. Grunt has a really effective API method, `grunt.file.expand`,
    that accepts `glob` patterns and returns the matched files. The rest of our task
    is to compose the content of the manifest file and save it to the disc. We will
    register the new task and fill the `content` variable, which is later written
    to the file, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在传递几个 `glob` 模式；这些是我们想要添加的文件。在配置中描述每一个单独的文件会花费太多时间，我们可能会忘记一些东西。Grunt 有一个非常有效的
    API 方法，`grunt.file.expand`，它接受 `glob` 模式并返回匹配的文件。我们剩余的任务是组合清单文件的内容并将其保存到磁盘上。我们将注册新的任务并填充
    `content` 变量，该变量稍后将被写入文件，如下所示：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's a good practice to rely on the Grunt API in our custom tasks. It keeps
    the consistency of our application because we depend only on one module—Grunt.
    In the preceding code, we used `grunt.file.expand`, which we already discussed
    before the code, and `grunt.file.write` that saves the manifest's content to the
    disk.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义任务中依赖 Grunt API 是一项良好的实践。因为它保持了应用程序的一致性，因为我们只依赖于一个模块——Grunt。在前面的代码中，我们使用了
    `grunt.file.expand`，这是我们之前在代码中讨论过的，以及 `grunt.file.write`，它将清单的内容保存到磁盘。
- en: To provide a workable manifest, the cache file should start with `CACHE MANIFEST`.
    That's why we add it at the beginning. It's also a good practice to include the
    date on which the generation happened. The randomly generated `id` simplifies
    the process of an application's development.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个可工作的清单，缓存文件应该以 `CACHE MANIFEST` 开头。这就是我们为什么在开头添加它的原因。同时，在生成日期上包含也是一项良好的实践。随机生成的
    `id` 简化了应用程序开发的过程。
- en: 'As mentioned, the browser will serve the cached version of the files until
    the cache manifest file is changed. Setting a different `id` each time forces
    the browser to fetch the latest version of the files. However, in the production
    environment, this should be removed. To use the cache manifest file, add a special
    attribute in our HTML page as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，浏览器将提供文件的缓存版本，直到缓存清单文件被更改。每次设置不同的 `id` 都会迫使浏览器获取文件的最新版本。然而，在生产环境中，这应该被移除。要使用缓存清单文件，请在我们的
    HTML 页面中添加一个特殊属性，如下所示：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If everything goes well, we should see a result similar to that shown in the
    following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该看到如下截图所示的结果：
- en: '![Generating a cache manifest file](img/00035.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![生成缓存清单文件](img/00035.jpeg)'
- en: 'Hence, the content of the cache manifest will be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，缓存清单的内容如下：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Documenting our code
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录我们的代码
- en: We know that the code should have documentation. But very often, this is too
    time consuming and mundane. There are some good practices out there that we could
    use. One of them is to write comments into the code and generate the documentation
    using these comments. Following this approach, we should make our code more understandable
    for our colleagues. The Grunt plugin, `grunt-contrib-yuidoc`, will help us create
    the `.doc` files. Add it to our `package.json` and run `npm install`. Again, all
    we have to do is to update our `Gruntfile.js` file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道代码应该有文档。但很多时候，这会花费太多时间且很枯燥。有一些好的实践我们可以使用。其中之一是将注释写入代码，并使用这些注释生成文档。遵循这种方法，我们应该使我们的代码更容易被同事理解。Grunt
    插件 `grunt-contrib-yuidoc` 将帮助我们创建 `.doc` 文件。将其添加到我们的 `package.json` 并运行 `npm install`。再次，我们只需要更新我们的
    `Gruntfile.js` 文件。
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is a `paths` property that shows the source code and the `outdir` property
    that shows where the documentation will be saved. If we run Grunt and navigate
    to the directory with our favorite browser, we will see that there is nothing
    listed. That''s because we didn''t add any comment to the code. Open `src/A.js`
    and place the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `paths` 属性显示源代码，以及一个 `outdir` 属性显示文档将被保存的位置。如果我们运行 Grunt 并导航到我们的目录，我们会看到没有任何列表。这是因为我们没有在代码中添加任何注释。打开
    `src/A.js` 并放置以下代码：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After relaunching the tasks, we will see the **A Class** in the documentation
    as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动任务后，我们将在文档中看到 **A 类**，如下面的截图所示：
- en: '![Documenting our code](img/00036.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![记录我们的代码](img/00036.jpeg)'
- en: Discovering Gulp
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现 Gulp
- en: '**Gulp** is a build system that has become quite popular. It''s almost the
    same concept as Grunt. We are able to create tasks that do something for us. Of
    course, there are a lot of plugins. In fact, most of the main Grunt plugins have
    equivalent plugins in Gulp. However, there are some differences, which are mentioned
    in the following points:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gulp** 是一个已经相当流行的构建系统。它与 Grunt 几乎是相同的概念。我们能够创建为我们做些事情的任务。当然，有很多插件。实际上，大多数主要的
    Grunt 插件在 Gulp 中都有等效的插件。然而，也有一些差异，以下将提到这些差异。'
- en: There is a configuration file, but it is called `gulpfile.js`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个配置文件，但它被称为 `gulpfile.js`
- en: Gulp uses streams to process the files, which means that it doesn't create any
    temporary file or folder. This may lead to the better performance of the task
    runner.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gulp 使用流来处理文件，这意味着它不会创建任何临时文件或文件夹。这可能会导致任务运行器的性能更好。
- en: Gulp follows the `code-over-configuration` principle, that is, while we set
    up the Gulp tasks, the process is like coding rather than writing the configurations.
    This makes Gulp friendly for the developers.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gulp 遵循 `code-over-configuration` 原则，也就是说，当我们设置 Gulp 任务时，过程更像是在编码而不是在编写配置。这使得
    Gulp 对开发者来说更加友好。
- en: Installing Gulp and fetching plugins
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Gulp 和获取插件
- en: Like Grunt, Gulp is available in the Node.js' package manager.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Grunt 一样，Gulp 可在 Node.js 的包管理器中找到。
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding command line will set up the task runner globally. Once the installation
    is complete, we will be able to run the `gulp` command. Of course, we should do
    that in the directory containing the `gulpfile.js` file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令行将全局设置任务运行器。一旦安装完成，我们就可以运行 `gulp` 命令。当然，我们应该在包含 `gulpfile.js` 文件的目录中执行此操作。
- en: The plugins for Gulp are also Node.js modules. For example, `gulp-concat` is
    the same as `grunt-contrib-concat` and `gulp-uglify` is the alternative for `grunt-contrib-uglify`.
    It is a good practice to describe them in a `package.json` file. There is no function
    such as `grunt.loadNpmTasks`. We could directly require the module.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 的插件也是 Node.js 模块。例如，`gulp-concat` 与 `grunt-contrib-concat` 相同，而 `gulp-uglify`
    是 `grunt-contrib-uglify` 的替代品。在 `package.json` 文件中描述它们是一个好习惯。没有像 `grunt.loadNpmTasks`
    这样的函数。我们可以直接引入模块。
- en: Concatenating and minifying with Gulp
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Gulp 进行连接和压缩
- en: 'Let''s use the code we already have. There are a bunch of JavaScript files
    in the `src` folder and we want them concatenated. The task runner should also
    generate a minified version and watch the files for changes. We will need several
    modules, and here is how our `package.json` file looks like:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们已有的代码。`src` 文件夹中有一系列 JavaScript 文件，我们希望将它们连接起来。任务运行器还应生成一个压缩版本并监视文件的变化。我们需要几个模块，以下是我们的
    `package.json` 文件看起来像：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `gulp` command is needed because we need access to Gulp's API. The `gulp-concat`
    plugin will concatenate the files and `gulp-uglify` will minify the result. The
    `gulp-rename` plugin is used because we have to deliver two files—one suitable
    for reading and one minified, that is, `build/scripts.js` and `build/scripts.min.js`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 需要 `gulp` 命令是因为我们需要访问 Gulp 的 API。`gulp-concat` 插件将连接文件，而 `gulp-uglify` 将压缩结果。使用
    `gulp-rename` 插件是因为我们必须提供两个文件——一个适合阅读的文件和一个压缩的文件，即 `build/scripts.js` 和 `build/scripts.min.js`。
- en: 'The following code is the content of the `gulpfile.js` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `gulpfile.js` 文件的内容：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With Grunt, we need a little more knowledge about the task runner and its configuration
    structure. With Gulp, it's slightly different. We have the usual Node.js modules
    and the usage of their public APIs. The script starts with the definition of the
    plugins and the `gulp` object. A task is defined by using the `gulp.task` method.
    The first parameter is the name of the task and the second is a function. Also,
    instead of the function, we may pass an array of strings representing other tasks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Grunt 时，我们需要对任务运行器和其配置结构有一些更深入的了解。而使用 Gulp，情况则略有不同。我们通常使用 Node.js 模块以及它们公共
    API 的使用。脚本从插件定义和 `gulp` 对象的定义开始。一个任务是通过使用 `gulp.task` 方法定义的。第一个参数是任务的名称，第二个参数是一个函数。此外，我们也可以传递一个表示其他任务的字符串数组来代替函数。
- en: 'Similarly, like in Grunt, we have a `default` entry. This time, we split the
    tasks into two parts: JavaScript operations and watchers. Almost every Gulp task
    starts with `gulp.src` and ends with `gulp.dest`. The first method accepts the
    `glob` pattern, showing the files that need to be transformed. The `gulp.dest`
    plugin saves the result to the desired location. All the actions between them
    are actually modules that receive and output the streams. In our case, the `js`
    task fetches all the files from the `src` directory and its subfolders, concatenates
    them, and saves the result to the `build` folder. We continue by renaming the
    file, minifying it, and saving it in the same place. The output of our terminal
    after running `gulp` in the project''s folder should be as shown in the following
    screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，就像在Grunt中一样，我们有一个`default`入口。这次，我们将任务分为两部分：JavaScript操作和监视器。几乎每个Gulp任务都以`gulp.src`开始，以`gulp.dest`结束。第一个方法接受`glob`模式，显示需要转换的文件。`gulp.dest`插件将结果保存到期望的位置。它们之间的所有动作实际上都是接收和输出流的模块。在我们的例子中，`js`任务从`src`目录及其子文件夹中获取所有文件，将它们连接起来，并将结果保存到`build`文件夹。我们继续通过重命名文件、压缩它，并将它保存在同一位置。在项目文件夹中运行`gulp`后，我们的终端输出应该如下所示：
- en: '![Concatenating and minifying with Gulp](img/00037.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![使用Gulp进行连接和压缩](img/00037.jpeg)'
- en: Of course, we should see the `scripts.js` and `scripts.min.js` files in the
    build directory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该在构建目录中查看`scripts.js`和`scripts.min.js`文件。
- en: Creating your own Gulp plugin
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自己的Gulp插件
- en: 'The development of the Gulp plugin looks almost the same as creating a Grunt
    one. We need a new Node.js module with a proper API. The difference is that we
    receive a stream and we should then output the stream. This can be a little difficult
    to code because we need to understand how the streams work. Thankfully, there
    is a helper package that simplifies the process. We are going to use `through2`—a
    tiny wrapper around the Node.js'' streams API. So, our `package.json` file grows
    a bit with the following content:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp插件的开发几乎与创建Grunt插件相同。我们需要一个新的Node.js模块，具有适当的API。区别在于我们接收一个流，然后应该输出这个流。这可能会有一点难以编码，因为我们需要理解流是如何工作的。幸运的是，有一个辅助包可以简化这个过程。我们将使用`through2`——Node.js流API的一个小型包装器。因此，我们的`package.json`文件随着以下内容略有增长：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s create the same `jssize` task. It needs to do only one job: measure
    the file size of the concatenated file. We could recreate the `custom` directory
    and place an empty `jssize.js` file there. Our Gulp file also needs a quick correction.
    At the top, we require the newly created module as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建相同的`jssize`任务。它只需要做一项工作：测量连接文件的文件大小。我们可以重新创建`custom`目录，并在其中放置一个空的`jssize.js`文件。我们的Gulp文件还需要进行快速修正。在顶部，我们按照以下方式引入新创建的模块：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have to pipe the output of the first `gulp.dest(''./build/'')` command to
    the `jssize` plugin. The following snippet shows the finished task:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将第一个`gulp.dest('./build/')`命令的输出通过管道传输到`jssize`插件。以下片段显示了完成的任务：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s see how our plugin looks using the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下代码中我们的插件看起来如何：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `through2.obj` object returns a stream used in the Gulp's pipeline. Working
    with streams is like working with chunks. In other words, we do not receive the
    entire file, but parts of it again and again till we get the whole data. The `through2`
    object simplifies the process and gives us direct access to the entire file. So,
    the `transform` method accepts the file, its encoding, and a function that we
    need to call once we finish our job. Otherwise, the chain will be stopped and
    the next plugins will not be able to finish their tasks. The actual code that
    generates the `size.log` file is the same as that used in the Grunt version.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`through2.obj`对象返回一个用于Gulp管道的流。处理流就像处理块一样。换句话说，我们不会一次性收到整个文件，而是反复收到文件的部分，直到我们得到全部数据。`through2`对象简化了过程，并直接给我们提供了对整个文件的访问。因此，`transform`方法接受文件、其编码以及一个我们需要在完成工作后调用的函数。否则，链将被停止，下一个插件将无法完成其任务。生成`size.log`文件的实际代码与Grunt版本中使用的相同。'
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use the task runners. These are tools that
    make our life easier by simplifying the common tasks. As web developers, we might
    want to concatenate and minify our production code, and such trivial operations
    are well-handled by modules such as Grunt and Gulp. The wide range of plugins
    and the great Node.js community encourage the usage of task runners and change
    our workflow completely.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用任务运行器。这些工具通过简化常见任务使我们的生活变得更轻松。作为网页开发者，我们可能希望将生产代码连接和压缩，而像Grunt和Gulp这样的模块可以很好地处理这些琐碎的操作。广泛的插件和强大的Node.js社区鼓励使用任务运行器，并彻底改变了我们的工作流程。
- en: In the next chapter, we will dive into test-driven development and see how Node.js
    handles such processes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨测试驱动开发，并了解Node.js如何处理这些过程。
