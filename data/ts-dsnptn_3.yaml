- en: Chapter 5. Behavioral Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。行为设计模式
- en: As the name suggests, behavioral design patterns are patterns about how objects
    or classes interact with each other. The implementation of behavioral design patterns
    usually requires certain data structures to support the interaction in a system.
    However, behavioral patterns and structural patterns focus on different aspects
    when applied. As a result, you might find patterns in the category of behavioral
    design patterns usually have simpler or more straightforward structures compared
    to structural design patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，行为设计模式是关于对象或类如何相互交互的模式。行为设计模式的实现通常需要某些数据结构来支持系统中的交互。然而，当应用时，行为模式和结构模式关注不同的方面。因此，你可能会发现行为设计模式类别中的模式通常比结构设计模式更简单或更直接。
- en: 'In this chapter, we are going to talk about some of the following common behavioral
    patterns:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下一些常见的模式：
- en: '**Chain of Responsibility**: Organizes behaviors with different scopes'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**责任链**：组织不同范围的行为'
- en: '**Command**: Exposes commands from the internal with encapsulated context'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：通过封装的上下文暴露内部命令'
- en: '**Memento**: Provides an approach for managing states outside of their owners
    without exposing detailed implementations'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录**：提供一种管理状态的方法，这些状态不在其所有者之外，而不暴露详细的实现'
- en: '**Iterator**: Provides a universal interface for traversing'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器**：提供遍历的通用接口'
- en: '**Mediator**: It groups coupling and logically related objects and makes interconnections
    cleaner in a system that manages many objects'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中介者**：它将耦合和逻辑上相关的对象分组，并在管理许多对象的系统中使互连更清晰'
- en: Chain of Responsibility Pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链模式
- en: There are many scenarios under which we might want to apply certain actions
    that can fall back from a detailed scope to a more general one.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景下，我们可能希望应用某些可以从详细范围回退到更一般范围的动作。
- en: 'A nice example would be the help information of a GUI application: when a user
    requests help information for a certain part of the user interface, it is expected
    to show information as specific as possible. This can be done with different implementations,
    and the most intuitive one for a web developer could be events bubbling.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是GUI应用程序的帮助信息：当用户请求用户界面某部分的帮助信息时，期望显示尽可能具体的信息。这可以通过不同的实现来完成，对于一个网络开发者来说，最直观的实现可能是事件冒泡。
- en: 'Consider a DOM structure like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个DOM结构如下：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If a user clicks on the `span.origin` element, a `click` event would start
    bubbling from the `span` element to the document root (if `useCapture` is `false`):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击`span.origin`元素，一个`click`事件将从`span`元素冒泡到文档根（如果`useCapture`为`false`）：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By default, it will trigger both event listeners added in the preceding code.
    To stop the propagation as soon as an event gets handled, we can call its `stopPropagation`
    method:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它将触发前面代码中添加的所有事件监听器。为了在事件被处理时立即停止传播，我们可以调用其`stopPropagation`方法：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Though a `click` event is not exactly the same as the help information request,
    with the support of custom events, it's quite easy to handle help information
    with necessary detailed or general information in the same chain.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然点击事件并不完全等同于帮助信息请求，但在自定义事件的支持下，处理带有必要详细或一般信息的帮助信息相当容易。
- en: 'Another important implementation of the Chain of Responsibility Pattern is
    related to error handling. A primitive example for this could be using `try...catch`.
    Consider code like this: we have three functions: `foo`, `bar`, and `biu`, `foo`
    is called by `bar` while `bar` is called by `biu`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式的一个重要实现与错误处理相关。一个原始的例子可能是使用`try...catch`。考虑以下代码：我们有三个函数：`foo`、`bar`和`biu`，`foo`被`bar`调用，而`bar`被`biu`调用：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside both functions `bar` and `biu`, we can do some error catching. Assuming
    function `foo` throws two kinds of errors:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数`bar`和`biu`内部，我们可以做一些错误捕获。假设函数`foo`抛出两种类型的错误：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In function `bar` we would like to handle the `TypeError` and leave other errors
    throwing on:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数`bar`中，我们希望处理`TypeError`，并让其他错误抛出：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And in function `biu`, we would like to add more general handling that catches
    all the errors so that the program will not crash:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数`biu`中，我们希望添加更通用的处理，捕获所有错误，以便程序不会崩溃：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So by using `try...catch` statements, you may have been using the Chain of Responsibility
    Pattern constantly without paying any attention to it. Just like you may have
    been using other well-known design patterns all the time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用`try...catch`语句，你可能一直在不断地使用责任链模式，而没有注意到它。就像你可能一直在使用其他众所周知的设计模式一样。
- en: 'If we abstract the structure of Chain of Responsibility Pattern into objects,
    we could have something as illustrated in the figure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将责任链模式的结构抽象为对象，我们可能会有如图所示的某种结构：
- en: '![Chain of Responsibility Pattern](img/image_05_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![责任链模式](img/image_05_001.jpg)'
- en: Participants
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of the Chain of Responsibility Pattern include:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式的参与者包括：
- en: '**Handler**: Defines the interface of the handler with successor and method
    to handle requests. This is done implicitly with classes like `EventEmitter` and
    `try...catch` syntax.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**：定义了处理器与后继者之间的接口以及处理请求的方法。这通过`EventEmitter`类和`try...catch`语法隐式完成。'
- en: '**Concrete handler**: `EventListener`, `catch` block and `HandlerA`/`HandlerB`
    in the class version. Defines handlers in the form of callbacks, code blocks and
    classes that handle requests.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体处理器**：`EventListener`、`catch`块和类版本中的`HandlerA`/`HandlerB`。以回调函数、代码块和类等形式定义处理器。'
- en: '**Client**: Initiates the requests that go through the chain.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：启动通过链传递的请求。'
- en: Pattern scope
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式作用域
- en: The Chain of Responsibility Pattern itself could be applied to many different
    scopes in a program. It requires a multi-level chain to work, but this chain could
    be in different forms. We've been playing with events as well as `try...catch`
    statements that have structural levels, this pattern could also be applied to
    scenarios that have logical levels.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式本身可以应用于程序中的许多不同作用域。它需要一个多级链来工作，但这个链可以有不同的形式。我们已经玩过事件以及具有结构级别的`try...catch`语句，这个模式也可以应用于具有逻辑级别的场景。
- en: 'Consider objects marked with different scopes using string:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串标记不同作用域的对象：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we have two objects with related scopes specified by string, and by adding
    filters to these scope strings, we can apply operations from specific ones to
    general ones.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个对象，它们的作用域由字符串指定，通过向这些作用域字符串添加过滤器，我们可以将特定操作应用于一般操作。
- en: Implementation
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现部分
- en: 'In this part, we are going to implement the class version we''ve mentioned
    at the end of the introduction to the Chain of Responsibility Pattern. Consider
    requests that could either ask for help information or feedback prompts:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将实现我们在责任链模式介绍中提到的类版本。考虑可能请求帮助信息或反馈提示的请求：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We are using string literal type here with union type. It is a pretty useful
    feature provided in TypeScript that plays well with existing JavaScript coding
    styles. See the following link for more information: [http://www.typescriptlang.org/docs/handbook/advanced-types.html](http://www.typescriptlang.org/docs/handbook/advanced-types.html).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用字符串字面量类型与联合类型。这是TypeScript提供的一个非常有用的特性，它与现有的JavaScript编码风格兼容。更多信息请见以下链接：[http://www.typescriptlang.org/docs/handbook/advanced-types.html](http://www.typescriptlang.org/docs/handbook/advanced-types.html)。
- en: 'One of the key processes for this pattern is going through the handlers'' chain
    and finding out the most specific handler that''s available for the request. There
    are several ways to achieve this: by recursively invoking the `handle` method
    of a successor, or having a separate logic walking through the handler successor
    chain until the request is confirmed as handled.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的关键过程之一是遍历处理器的链，并找出对请求可用的最具体的处理器。实现这一目标有几种方法：通过递归调用后继者的`handle`方法，或者通过单独的逻辑遍历处理器后继链，直到确认请求已被处理。
- en: The logic walking through the chain in the second way requires the acknowledgment
    of whether a request has been properly handled. This can be done either by a state
    indicator on the request object or by the return value of the `handle` method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种遍历链的逻辑需要确认请求是否被正确处理。这可以通过请求对象上的状态指示器或`handle`方法的返回值来完成。
- en: 'We''ll go with the recursive implementation in this part. Firstly, we want
    the default handling behavior of a handler to be forwarding requests to its successor
    if any:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将采用递归实现。首先，我们希望处理器默认的处理行为是将请求转发给其后继者（如果有的话）：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now for `HelpHandler`, it handles help requests but forwards others:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于`HelpHandler`，它处理帮助请求，但转发其他请求：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code for `FeedbackHandler` is similar:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeedbackHandler`的代码类似：'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Thus, a chain of handlers could be made up in some way. And if a request got
    in this chain, it would be passed on until a handler recognizes and handles it.
    However, it is not necessary to have all requests *handled* after processing them.
    The handlers can always pass a request on whether this request gets processed
    by this handler or not.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以通过某种方式构建一个处理程序链。如果请求进入这个链，它将被传递，直到处理程序识别并处理它。然而，在处理请求后，并不一定需要处理所有请求。处理程序可以始终将请求传递下去，无论这个请求是否被处理程序处理。
- en: Consequences
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: The Chain of Responsibility Pattern decouples the connection between objects
    that issue the requests and logic that handles those requests. The sender assumes
    that its requests could, but not necessarily, be properly handled without knowing
    the details. For some implementations, it is also very easy to add new responsibilities
    to a specific handler on the chain. This provides notable flexibility for handling
    requests.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式解耦了发出请求的对象与处理这些请求的逻辑之间的连接。发送者假设其请求可能，但不一定，能够得到适当的处理，而无需了解细节。对于某些实现，向链上的特定处理程序添加新的责任也非常容易。这为处理请求提供了显著的灵活性。
- en: 'Besides the examples we''ve been talking about, there is another important
    mutation of `try...catch` that can be treated in the Chain of Responsibility Pattern
    - Promise. Within a smaller scope, the chain could be represented as:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前提到的例子之外，还有一个重要的`try...catch`变异，它可以在责任链模式中处理 - Promise。在更小的范围内，链可以表示为：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The standard `catch` method on an ES Promise object does not provide the overload
    that accepts an error type as a parameter, but many implementations do.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ES Promise对象上的标准`catch`方法不提供接受错误类型作为参数的重载，但许多实现都做到了。
- en: In a larger scope, this chain would usually appear when the code is playing
    with third-party libraries. A common usage would be converting errors produced
    by other libraries to errors known to the current project. We'll talk more about
    error handling of asynchronous code later in this book.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的范围内，这个链通常出现在代码与第三方库交互时。一种常见的用法是将其他库产生的错误转换为当前项目已知的错误。我们将在本书的后面部分更多地讨论异步代码的错误处理。
- en: Command Pattern
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: Command Pattern involves encapsulating operations as executable commands and
    could either be in the form of objects or functions in JavaScript. It is common
    that we may want to make operations rely on certain context and states that are
    not accessible for the invokers. By storing those pieces of information with a
    command and passing it out, this situation could be properly handled.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式涉及将操作封装为可执行的命令，在JavaScript中可以是对象或函数的形式。通常情况下，我们可能希望使操作依赖于某些调用者无法访问的上下文和状态。通过将这部分信息与命令一起存储并传递出去，这种情况可以得到妥善处理。
- en: 'Consider an extremely simple example: we want to provide a function called
    `wait`, which returns a `cancel` handler:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个极其简单的例子：我们想要提供一个名为`wait`的函数，它返回一个`cancel`处理程序：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `cancel` handler in the preceding code is just a command we were talking
    about. It stores the context (`$layer`) using closure and is passed out as the
    return value of function `wait`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的`cancel`处理程序正是我们刚才提到的命令。它使用闭包存储上下文（`$layer`），并以函数`wait`的返回值的形式传递出去。
- en: Closure in JavaScript provides a really simple way to store command context
    and states, however, the direct disadvantage would be compromised flexibility
    between context/states and command functions because closure is lexically determined
    and cannot be changed at runtime. This would be okay if the command is only expected
    to be invoked with fixed context and states, but for more complex situations,
    we might need to construct them as objects with a proper data structure.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的闭包提供了一种非常简单的方式来存储命令上下文和状态，然而，直接的缺点是上下文/状态与命令函数之间的灵活性会受到影响，因为闭包是词法确定的，无法在运行时更改。如果命令只预期在固定的上下文和状态下调用，这将是可行的，但对于更复杂的情况，我们可能需要将它们构建为具有适当数据结构的对象。
- en: 'The following diagram shows the overall relations between participants of Command
    Pattern:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了命令模式中参与者之间的整体关系：
- en: '![Command Pattern](img/image_05_002.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![命令模式](img/image_05_002.jpg)'
- en: By properly splitting apart context and states with the command object, Command
    Pattern could also play well with Flyweight Pattern if you wanted to reuse command
    objects multiple times.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令对象正确地分离上下文和状态，命令模式也可以很好地与享元模式协同工作，如果你想要多次重用命令对象的话。
- en: Other common extensions based on Command Pattern include undo support and macros
    with multiple commands. We are going to play with those later in the implementation
    part.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 基于命令模式的其他常见扩展包括撤销支持和具有多个命令的宏。我们将在实现部分稍后玩转这些内容。
- en: Participants
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of Command Pattern include:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的参与者包括：
- en: '**Command**: Defines the general interface of commands passing around, it could
    be a function signature if the commands are in the form of functions.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：定义传递命令的一般接口，如果命令以函数的形式存在，则可以是函数签名。'
- en: '**Concrete command**: Defines the specific behaviors and related data structure.
    It could also be a function that matches the signature declared as `Command`.
    The `cancel` handler in the very first example is a concrete command.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体命令**：定义特定的行为和相关数据结构。它也可以是一个与声明为`Command`的签名匹配的函数。在第一个例子中，`cancel`处理程序就是一个具体命令。'
- en: '**Context**: The context or receiver that the command is associated with. In
    the first example, it is the `$layer`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：命令关联的上下文或接收者。在第一个例子中，它是`$layer`。'
- en: '**Client**: Creates concrete commands and their contexts.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：创建具体的命令及其上下文。'
- en: '**Invoker**: Executes concrete commands.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用者**：执行具体命令。'
- en: Pattern scope
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: 'Command Pattern suggests two separate parts in a single application or a larger
    system: *client* and *invoker*. In the simplified example `wait` and `cancel`,
    it could be hard to distinguish the difference between those parts. But the line
    is clear: *client* knows or controls the context of commands to be executed with,
    while *invoker* does not have access or does not need to care about that information.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式建议在单个应用程序或更大的系统中建议两个独立的部分：*客户端*和*调用者*。在简化的示例`wait`和`cancel`中，可能很难区分这些部分之间的差异。但界限是清晰的：*客户端*知道或控制要执行的命令的上下文，而*调用者*没有访问或不需要关心这些信息。
- en: The key to the Command Pattern is the separation and bridging between those
    two parts through commands that store context and states.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的关键是通过存储上下文和状态的命令在这两部分之间进行分离和桥接。
- en: Implementation
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'It''s common for an editor to expose commands for third-party extensions to
    modify the text content. Consider a `TextContext` that contains information about
    the text file being edited and an abstract `TextCommand` class associated with
    that context:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编辑器来说，向第三方扩展公开命令以修改文本内容是很常见的。考虑一个包含有关正在编辑的文本文件信息的`TextContext`和一个与该上下文关联的抽象`TextCommand`类：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Certainly, `TextContext` could contain much more information like language,
    encoding, and so on. You can add them in your own implementation for more functionality.
    Now we are going to create two commands: `ReplaceCommand` and `InsertCommand`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`TextContext`可以包含更多像语言、编码等信息。您可以在自己的实现中添加它们以获得更多功能。现在我们将创建两个命令：`ReplaceCommand`和`InsertCommand`。
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Those two commands share similar logic and actually `InsertCommand` can be treated
    as a subset of `ReplaceCommand`. Or if we have a new delete command, then replace
    command can be treated as the combination of delete and insert commands.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令具有相似的逻辑，实际上`InsertCommand`可以被视为`ReplaceCommand`的一个子集。或者如果我们有一个新的删除命令，那么替换命令可以被视为删除和插入命令的组合。
- en: 'Now let''s assemble those commands with the client and invoker:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用客户端和调用者组装这些命令：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we go further, we can actually have a command that executes other commands.
    Namely, we can have macro commands. Though the preceding example alone does not
    make it necessary to create a macro command, there would be scenarios where macro
    commands help. As those commands are already associated with their contexts, a
    macro command usually does not need to have an explicit context:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更进一步，实际上可以有一个执行其他命令的命令。也就是说，我们可以有宏命令。尽管前面的例子单独来看并不需要创建宏命令，但会有一些场景中宏命令会很有帮助。由于这些命令已经与它们的上下文相关联，宏命令通常不需要有显式的上下文：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Consequences
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Command Pattern decouples the client (who knows or controls context) and the
    invoker (who has no access to or does not care about detailed context).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式将客户端（知道或控制上下文的人）和调用者（没有访问或不需要关心详细上下文的人）解耦。
- en: 'It plays well with Composite Pattern. Consider the example of macro commands
    we mentioned above: a macro command can have other macro commands as its components,
    thus we make it a composite command.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它与组合模式配合得很好。考虑我们上面提到的宏命令示例：一个宏命令可以有其他宏命令作为其组件，因此我们将其视为一个组合命令。
- en: Another important case of Command Pattern is adding support for undo operations.
    A direct approach is to add the `undo` method to every command. When an undo operation
    is requested, invoke the `undo` method of commands in reverse order, and we can
    pray that every command would be undone correctly. However, this approach relies
    heavily on a flawless implementation of the `undo` method as every mistake will
    accumulate. To implement more stable undo support, redundant information or snapshots
    could be stored.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的另一个重要案例是添加对撤销操作的支持。一种直接的方法是将 `undo` 方法添加到每个命令中。当请求撤销操作时，以相反的顺序调用命令的 `undo`
    方法，我们只能希望每个命令都能正确撤销。然而，这种方法高度依赖于 `undo` 方法的完美实现，因为每个错误都会累积。为了实现更稳定的撤销支持，可以存储冗余信息或快照。
- en: Memento Pattern
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Memento 模式
- en: 'We''ve talked about an undo support implementation in the previous section
    on the Command Pattern, and found it was not easy to implement the mechanism purely
    based on reversing all the operations. However, if we take snapshots of objects
    as their history, we may manage to avoid accumulating mistakes and make the system
    more stable. But then we have a problem: we need to store the states of objects
    while the states are encapsulated with objects themselves.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节关于命令模式的讨论中，我们提到了一个撤销支持实现，并发现仅基于反转所有操作来实现机制并不容易。然而，如果我们把对象的快照作为它们的历史，我们可能能够避免累积错误并使系统更加稳定。但随后我们遇到了一个问题：我们需要在对象的状态被封装在对象本身时存储对象的状态。
- en: 'Memento Pattern helps in this situation. While a memento carries the state
    of an object at a certain time point, it also controls the process of setting
    the state back to an object. This makes the internal state implementation hidden
    from the undo mechanism in the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Memento 模式有助于这种情况。当一个备忘录携带了对象在某个时间点的状态时，它还控制了将状态设置回对象的过程。这使得以下示例中的内部状态实现隐藏在撤销机制之后：
- en: '![Memento Pattern](img/image_05_003.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Memento 模式](img/image_05_003.jpg)'
- en: We have the instances of the memento controlling the state restoration in the
    preceding structure. It can also be controlled by the caretaker, namely the undo
    mechanism, for simple state restoring cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结构中，我们有备忘录实例控制状态恢复。它也可以由保管人，即撤销机制，控制，用于简单的状态恢复情况。
- en: Participants
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of Memento Pattern include:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Memento 模式的参与者包括：
- en: '**Memento**: Stores the state of an object and defines method `restore` or
    other APIs for restoring the states to specific objects'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Memento**：存储对象的当前状态并定义 `restore` 或其他用于将状态恢复到特定对象的 API'
- en: '**Originator**: Deals with objects that need to have their internal states
    stored'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Originator**：处理需要存储其内部状态的对象'
- en: '**Caretaker**: Manages mementos without intervening with what''s inside'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保管人**：管理备忘录而不干预其内部内容'
- en: Pattern scope
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: 'Memento Pattern mainly does two things: it prevents the caretaker from knowing
    the internal state implementation and decouples the state retrieving and restoring
    process from states managed by the `Caretaker` or `Originator.`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Memento 模式主要做两件事：它防止保管人了解内部状态实现，并将状态检索和恢复过程从由 `Caretaker` 或 `Originator` 管理的状态中解耦。
- en: When the state retrieving and restoring processes are simple, having separated
    mementos does not help much if you are already keeping the decoupling idea in
    mind.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态检索和恢复过程很简单时，如果你已经考虑了解耦的想法，拥有分离的备忘录并不会带来太多帮助。
- en: Implementation
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Start with an empty `State` interface and `Memento` class. As we do not want
    `Caretaker` to know the details about state inside an `Originator` or `Memento`,
    we would like to make `state` property of `Memento` private. Having restoration
    logic inside `Memento` does also help with this, and thus we need method `restore`.
    So that we don't need to expose a public interface for reading state inside a
    memento.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个空的 `State` 接口和 `Memento` 类开始。由于我们不希望 `Caretaker` 了解 `Originator` 或 `Memento`
    内部状态的细节，我们希望将 `Memento` 的 `state` 属性设置为私有。在 `Memento` 中包含恢复逻辑也有助于这一点，因此我们需要 `restore`
    方法。这样我们就不需要公开接口来读取备忘录内部的状态。
- en: 'And as an object assignment in JavaScript assigns only its reference, we would
    like to do a quick copy for the states (assuming state objects are single-level):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 中的对象赋值仅分配其引用，我们希望对状态进行快速复制（假设状态对象是单层的）：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For `Originator` we use a getter and a setter for creating and restoring specific
    mementos:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Originator`，我们使用 getter 和 setter 来创建和恢复特定的备忘录：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now the `Caretaker` would manage the history accumulated with mementos:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Caretaker`将管理与备忘录一起积累的历史：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In some implementations of Memento Pattern, a `getState` method is provided
    for instances of `Originator` to read state from a memento. But to prevent classes
    other than `Originator` from accessing the `state` property, it may rely on language
    features like a *friend modifier* to restrict the access (which is not yet available
    in TypeScript).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Memento模式的实现中，为`Originator`的实例提供了一个`getState`方法，以便从备忘录中读取状态。但为了防止除`Originator`之外的类访问`state`属性，它可能依赖于诸如*友元修饰符*之类的语言特性来限制访问（TypeScript中尚未提供）。
- en: Consequences
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Memento Pattern makes it easier for a caretaker to manage the states of originators
    and it becomes possible to extend state retrieving and restoring. However, a perfect
    implementation that seals everything might rely on language features as we've
    mentioned before. Using mementos could also bring a performance cost as they usually
    contain redundant information in trade of stability.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Memento模式使看护者更容易管理发起者的状态，并使扩展状态检索和恢复成为可能。然而，一个完美的实现可能依赖于我们之前提到的语言特性。使用备忘录也可能带来性能成本，因为它们通常包含冗余信息以换取稳定性。
- en: Iterator Pattern
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代模式
- en: 'Iterator Pattern provides a universal interface for accessing internal elements
    of an aggregate without exposing the underlying data structure. A typical iterator
    contains the following methods or getters:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代模式提供了一个通用的接口，用于访问聚合体的内部元素，而不暴露底层的数据结构。典型的迭代器包含以下方法或获取器：
- en: '`first()`: moves the cursor to the *first* element in the aggregates'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first()`: 将光标移动到聚合体中的*第一个*元素'
- en: '`next()`: moves the cursor to the *next* element'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next()`: 将光标移动到*下一个*元素'
- en: '`end`: a getter that returns a Boolean indicates whether the cursor is at the
    end'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`: 一个获取器，返回一个布尔值，指示光标是否在末尾'
- en: '`item`: a getter that returns the element at the position of the current cursor'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item`: 一个获取器，返回当前光标位置的元素'
- en: '`index`: a getter that returns the index of the element at the current cursor'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`: 一个获取器，返回当前光标所在元素的位置索引'
- en: 'Iterators for aggregates with different interfaces or underlying structures
    usually end with different implementations as shown in the following figure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有不同接口或底层结构的聚合体，它们的迭代器通常会有不同的实现，如下面的图示所示：
- en: '![Iterator Pattern](img/image_05_004.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![迭代器模式](img/image_05_004.jpg)'
- en: Though the client does not have to worry about the structure of an aggregate,
    an iterator would certainly need to. Assuming we have everything we need to build
    an iterator, there could be a variety of ways for creating one. The factory method
    is widely used when creating iterators, or a *factory getter* if no parameter
    is required.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然客户端不需要担心聚合体的结构，但迭代器肯定需要。假设我们拥有构建迭代器所需的一切，可能会有多种创建迭代器的方法。在创建迭代器时，工厂方法被广泛使用，或者如果没有参数要求，则使用*工厂获取器*。
- en: Starting with ES6, syntax sugar `for...of` is added and works for all objects
    with property `Symbol.iterator`. This makes it even easier and more comfortable
    for developers to work with customized lists and other classes that can be iterated.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从ES6开始，添加了语法糖`for...of`，适用于所有具有`Symbol.iterator`属性的属性对象。这使得开发人员使用自定义列表和其他可迭代的类变得更加容易和舒适。
- en: Participants
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of Iterator Pattern include:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代模式的部分包括：
- en: '**Iterator**: `AbstractListIterator`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器**: `AbstractListIterator`'
- en: Defines the universal iterator interface that is going to transverse different
    aggregates.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了通用的迭代器接口，该接口将遍历不同的聚合体。
- en: '**Concrete iterator**: `ListIterator`, `SkipListIterator` and `ReversedListIterator`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体迭代器**: `ListIterator`、`SkipListIterator`和`ReversedListIterator`'
- en: Implements specific iterator that transverses and keeps track of a specific
    aggregate.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现特定的迭代器，用于遍历并跟踪特定的聚合体。
- en: '**Aggregate**: `AbstractList`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合体**: `AbstractList`'
- en: Defines a basic interface of aggregates that iterators are going to work with.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了聚合体的基本接口，迭代器将与之协同工作。
- en: '**Concreate aggregate**: `List` and `SkipList`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体聚合体**: `List`和`SkipList`'
- en: Defines the data structure and factory method/getter for creating associated
    iterators.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了数据结构和工厂方法/获取器，用于创建关联的迭代器。
- en: Pattern scope
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Iterator Pattern provides a unified interface for traversing aggregates. In
    a system that doesn't rely on iterators, the main functionality provided by iterators
    could be easily taken over by simple helpers. However, the reusability of those
    helpers could be reduced as the system grows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式为遍历聚合提供了统一的接口。在一个不依赖于迭代器的系统中，迭代器提供的主要功能可以很容易地被简单的辅助工具所取代。然而，随着系统的增长，这些辅助工具的可重用性可能会降低。
- en: Implementation
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: In this part, we are going to implement a straightforward array iterator, as
    well as an ES6 iterator.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将实现一个简单的数组迭代器，以及一个 ES6 迭代器。
- en: Simple array iterator
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单数组迭代器
- en: 'Let''s start by creating an iterator for a JavaScript array, which should be
    extremely easy. Firstly, the universal interface:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为 JavaScript 数组创建一个迭代器开始，这应该非常简单。首先，是通用接口：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please notice that the TypeScript declaration for ES6 has already declared an
    interface called `Iterator`. Consider putting the code in this part into a namespace
    or module to avoid conflicts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，TypeScript 对 ES6 已经声明了一个名为 `Iterator` 的接口。考虑将这段代码放入一个命名空间或模块中，以避免冲突。
- en: 'And the implementation of a simple array iterator could be:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 简单数组迭代器的实现可以是：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we need to extend the prototype of native `Array` to add an `iterator`
    getter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要扩展原生 `Array` 的原型以添加一个 `iterator` 属性：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To make `iterator` a valid property of the  `Array` instance, we also need
    to extend the interface of `Array`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `iterator` 成为 `Array` 实例的有效属性，我们还需要扩展 `Array` 的接口：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This should be written outside the namespace under the global scope. Or if you
    are in a module or ambient module, you might want to try `declare global { ...
    }` for adding new properties to existing global interfaces.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该写在全球作用域下的命名空间之外。或者如果你在一个模块或环境模块中，你可能想尝试使用 `declare global { ... }` 来向现有的全局接口添加新属性。
- en: ES6 iterator
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES6 迭代器
- en: 'ES6 provides syntax sugar `for...of` and other helpers for *iterable* objects,
    namely the objects that have implemented the `Iterable` interface of the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 提供了 `for...of` 语法糖和其他辅助工具来支持 *可迭代* 对象，即实现了以下 `Iterable` 接口的对象：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Assume we have a class with the following structure:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个具有以下结构的类：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And we would like to make it iterable. More specifically, we would like to
    make it iterates reversely. As the `Iterable` interface suggests, we just need
    to add a method with a special name `Symbol.iterator` for creating an `Iterator`.
    Let''s call the iterator `SomeIterator`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使其可迭代。更具体地说，我们希望它反向迭代。正如 `Iterable` 接口所建议的，我们只需要添加一个具有特殊名称 `Symbol.iterator`
    的方法来创建一个 `Iterator`。让我们称这个迭代器为 `SomeIterator`：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And then define the `iterator` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义 `iterator` 方法：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we would have `SomeData` that works with `for...of`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们会有 `SomeData` 与 `for...of` 一起工作。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Iterators also play well with generators; see the following link for more examples:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器也与生成器配合得很好；有关更多示例，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)。
- en: Consequences
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响
- en: Iterator Pattern decouples iteration usage from the data structure that is being
    iterated. The direct benefit of this is enabling an interchangeable data class
    that may have completely different internal structures, like an array and binary
    tree. Also, one data structure can be iterated via different iterators with different
    traversal mechanisms and results in different orders and efficiencies.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式将迭代的使用与被迭代的 数据结构解耦。这种做法的直接好处是允许使用可互换的数据类，这些数据类可能具有完全不同的内部结构，例如数组和二叉树。此外，一个数据结构可以通过不同的迭代器以不同的遍历机制进行迭代，从而产生不同的顺序和效率。
- en: A unified iterator interface in one system could also help the developer from
    being confused when facing different aggregates. As we mentioned previously, some
    language like your beloved JavaScript provides a language level abstraction for
    iterators and makes life even easier.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个系统中实现统一的迭代器接口也可以帮助开发者面对不同的聚合时不会感到困惑。正如我们之前提到的，一些语言（比如你钟爱的 JavaScript）为迭代器提供了语言级别的抽象，使得生活更加简单。
- en: Mediator Pattern
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介者模式
- en: The connections between UI components and related objects could be extremely
    complex. Object-oriented programming distributes functionalities among objects.
    This makes coding easier with cleaner and more intuitive logic; however, it does
    not ensure the reusability and sometimes makes it difficult to understand if you
    look at the code again after some days (you may still understand every single
    operation but would be confused about the interconnections if the network becomes
    really intricate).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: UI组件和相关对象之间的连接可能非常复杂。面向对象编程将功能分布在对象之间。这使得编码更加容易，逻辑更清晰、更直观；然而，这并不保证可重用性，有时在几天后再次查看代码时可能会感到困难（你可能仍然理解每个单独的操作，但如果网络变得非常复杂，你可能会对相互连接感到困惑）。
- en: Consider a page for editing user profile. There are standalone inputs like nickname
    and tagline, as well as inputs that are related to each other. Taking location
    selection for example, there could easily be a tree-level location and the options
    available in lower levels are determined by the selection of higher levels. However,
    if those objects are managed directly by a single huge controller, it will result
    in a page that has limited reusability. The code formed under this situation would
    also tend to have a hierarchy that's less clean for people to understand.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个用于编辑用户资料的页面。这里有独立的输入，如昵称和标语，以及相互关联的输入。以位置选择为例，可能会有一个树状级别的位置，较低级别的选项由较高级别的选择决定。然而，如果这些对象直接由一个巨大的控制器管理，将导致页面可重用性有限。在这种情况下形成的代码也倾向于具有人们难以理解的层次结构。
- en: 'Mediator Pattern tries to solve this problem by separating coupling elements
    and objects as groups, and adding a *director* between a group of elements and
    other objects as shown in the following figure:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式试图通过将耦合元素和对象作为组进行分离，并在一组元素和其他对象之间添加一个*导演*来解决这个问题，如下面的图所示：
- en: '![Mediator Pattern](img/image_05_005.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![中介者模式](img/image_05_005.jpg)'
- en: Those objects form a mediator with their colleagues that can interact with other
    objects as a single object. With proper encapsulation, the mediator will have
    better reusability as it has just the right size and properly divided functionality.
    In the world of web front end development, there are concepts or implementations
    that fit Mediator Pattern well, like *Web Component* and *React*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象与其同事形成一个中介者，可以作为一个单一对象与其他对象交互。通过适当的封装，中介者将具有更好的可重用性，因为它具有合适的大小和合理划分的功能。在Web前端开发的世界中，有一些概念或实现非常适合中介者模式，如*Web组件*和*React*。
- en: Participants
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of Mediator Pattern include:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式涉及到的参与者包括：
- en: '**Mediator**:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中介者**：'
- en: Usually, the abstraction or skeleton predefined by a framework. Defines the
    interface that colleagues in a mediator communicate through.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，框架预先定义的抽象或骨架。定义了中介者同事之间通过该接口进行通信的接口。
- en: '**Concrete mediator**: `LocationPicker`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体中介者**：`LocationPicker`'
- en: Manages the colleagues and makes them cooperate, providing a higher level interface
    for objects outside.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 管理同事并使他们合作，为外部对象提供更高层次的接口。
- en: '**Colleague classes**: `CountryInput`, `ProvinceInput`, `CityInput`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同事类**：`CountryInput`, `ProvinceInput`, `CityInput`'
- en: Defines references to their mediator and notifies its changes to the mediator
    and accepts modifications issued by the mediator.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义对其中介者的引用，并通知中介者其变化，并接受中介者发出的修改。
- en: Pattern scope
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Mediator Pattern could connect many parts of a project, but does not have direct
    or enormous impact on the outline. Most of the credit is given because of increased
    usability and cleaner interconnections introduced by mediators. However, along
    with a nice overall architecture, Mediator Pattern can help a lot with refined
    code quality, and make the project easier to maintain.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式可以连接项目的许多部分，但不会对轮廓产生直接或巨大的影响。大部分的赞誉归功于中介者带来的可用性提高和更清晰的连接。然而，随着良好的整体架构，中介者模式可以在代码质量优化和项目维护方面提供很大帮助。
- en: Implementation
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Using libraries like React would make it very easy to implement Mediator Pattern,
    but for now, we are going with a relatively primitive way and handle changes by
    hand. Let''s think about the result we want for a `LocationPicker` we''ve discussed,
    and hopefully, it includes `country`, `province` and `city` fields:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像React这样的库将使实现中介者模式变得非常容易，但到目前为止，我们正在采用一种相对原始的方法，并手动处理更改。让我们考虑我们之前讨论的`LocationPicker`想要的结果，并希望它包括`country`、`province`和`city`字段：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And now we can sketch the overall structure of class `LocationPicker`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以勾勒出类 `LocationPicker` 的整体结构：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before we can tell how the colleagues are going to cooperate, we would like
    to add a helper method `setOptions` for updating options in a `select` element:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够告诉同事们如何合作之前，我们希望添加一个辅助方法 `setOptions` 用于更新 `select` 元素中的选项：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'I personally tend to have methods that do not depend on a specific instance
    static methods and this applies to methods `getCountries`, `getProvincesByCountry`,
    and `getCitiesByCountryAndProvince` that simply return a list by the information
    given as function arguments (though we are not going to actually implement that
    part):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人倾向于编写不依赖于特定实例的方法，即静态方法，并且这适用于 `getCountries`、`getProvincesByCountry` 和 `getCitiesByCountryAndProvince`
    这些方法，它们简单地通过函数参数提供的信息返回一个列表（尽管我们实际上不会实现那部分）：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we may add methods for updating options in the `select` elements:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加更新 `select` 元素选项的方法：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, weave those colleagues together and add listeners to the `change`
    events:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将这些同事编织在一起，并为 `change` 事件添加监听器：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Consequences
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Mediator Pattern, like many other design patterns, downgrades a level-100 problem
    into two level-10 problems and solves them separately. A well-designed mediator
    usually has a proper size and usually tends to be reused in the future. For example,
    we might not want to put nickname input together with the country, province, and
    city inputs as this combination doesn't tend to occur in other situations (which
    means they are not strongly related).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 调解器模式，就像许多其他设计模式一样，将一个100级的问题降级为两个10级的问题，并分别解决。一个设计良好的调解者通常具有适当的大小，并且通常倾向于在未来被重用。例如，我们可能不想将昵称输入与国家、省份和城市输入放在一起，因为这个组合在其他情况下不太可能出现（这意味着它们不是强相关的）。
- en: As the project evolves, a mediator may grow to a size that's not efficient anymore.
    So a properly designed mediator should also take the dimension of time into consideration.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的演变，调解者可能增长到一个不再高效的大小。因此，一个设计良好的调解者也应该考虑时间的维度。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about some common behavioral patterns for different
    scopes and different scenarios. Chain of Responsibility Pattern and Command Pattern
    can apply to a relatively wide range of scopes, while other patterns mentioned
    in this chapter usually care more about the scope with objects and classes directly
    related.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了不同范围和不同场景的一些常见行为模式。责任链模式（Chain of Responsibility Pattern）和命令模式（Command
    Pattern）可以应用于相对广泛的范围，而本章中提到的其他模式通常更关注与对象和类直接相关的范围。
- en: Behavioral patterns we've talked about in this chapter are less like each other
    compared to creational patterns and structural patterns we previously walked through.
    Some of the behavioral patterns could compete with others, but many of them could
    cooperate. For example, we talked about Command Pattern with Memento Pattern to
    implement undo support. Many others may cooperate in parallel and do their own
    part.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论的行为模式与之前走过的创建型模式和结构型模式相比，彼此之间更不相似。一些行为模式可能相互竞争，但许多模式可以相互合作。例如，我们讨论了使用备忘录模式实现撤销支持的命令模式。许多其他模式可能并行合作，并完成自己的部分。
- en: In the next chapter, we'll continue talking about other behavioral design patterns
    that are useful and widely used.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论其他有用且广泛使用的其他行为设计模式。
