- en: Creating a RESTful API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个RESTful API
- en: Now that your application is complete and ready for the world to see, you can
    start thinking of ways to make it more popular. What if you want to allow external
    systems access rights to your data in a way such that they can mass produce inserts
    to your website without the need for users to visit the actual website?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的应用程序已经完成并准备好展示给世界，你可以开始考虑让它变得更受欢迎。如果你想允许外部系统以一种方式访问你的数据，使它们可以大规模地向你的网站插入数据，而不需要用户访问实际的网站呢？
- en: One example that comes to mind almost immediately is how users of another website,
    say [www.facebook.com](http://www.facebook.com), could upload an image to Facebook
    and have it automatically uploaded to your website as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个几乎立刻想到的例子是，另一个网站的用户，比如[www.facebook.com](http://www.facebook.com)，可以上传一张图片到Facebook，并且它会自动上传到你的网站上。
- en: The only way to make a scenario like this possible is **by** providing an API
    to your data and the code that gives external developers access to a suite of
    tools that will allow them to perform actions without the need to interact with
    the actual web pages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使这种情景成为可能的唯一方法是**通过**提供一个API给你的数据，并且给外部开发者访问一套工具的代码，使他们可以执行操作而不需要与实际的网页进行交互。
- en: 'In this chapter, we will review the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将回顾以下主题：
- en: Introducing RESTful APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍RESTful API
- en: Installing a few basic tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装一些基本工具
- en: Creating a basic API server and sample JSON data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基本的API服务器和示例JSON数据
- en: Responding to `GET` requests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应`GET`请求
- en: Updating data with `POST` and `PUT`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`POST`和`PUT`更新数据
- en: Removing data with `DELETE`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DELETE`删除数据
- en: Consuming external APIs from Node.js
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Node.js消费外部API
- en: What is an API?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是API？
- en: An **Application Programming Interface** (**API**) is a set of tools that a
    system makes available so that unrelated systems or software have the ability
    to interact with each other. Typically, a developer uses an API when writing software
    that will interact with a closed, external software system. The external software
    system provides an API as a standard set of tools that all developers can use.
    Many popular social networking sites provide developers access to APIs to build
    tools to support those sites. The most obvious examples are Facebook and Twitter.
    Both have a robust API that provides developers with the ability to build plugins
    and work with data directly, without them being granted full access, as a general
    security precaution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）是一个系统提供的一组工具，使不相关的系统或软件有能力相互交互。通常，当开发人员编写将与封闭的外部软件系统交互的软件时，他们会使用API。外部软件系统提供API作为所有开发人员可以使用的一套标准工具。许多流行的社交网络网站提供开发人员访问API的权限，以构建支持这些网站的工具。最明显的例子是Facebook和Twitter。它们都有一个强大的API，为开发人员提供了直接处理数据和构建插件的能力，而不需要被授予完全访问权限，作为一般的安全预防措施。'
- en: As you will see with this chapter, providing your own API is not only fairly
    simple, but it also empowers you to provide your users with access to your data.
    You also have the added peace of mind of knowing that you are in complete control
    over what level of access you can grant, what sets of data you can make read-only,
    and what data can be inserted and updated.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中所看到的，提供自己的API不仅相当简单，而且还赋予你提供用户访问你的数据的权力。你还可以放心地知道，你完全控制着你可以授予的访问级别，你可以使哪些数据集只读，以及可以插入和更新哪些数据。
- en: What is a RESTful API?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是RESTful API？
- en: '**Representational State Transfer** (**REST**) is a fancy way of saying CRUD
    over HTTP. What this means is, when you use a REST API, you have a uniform means
    to create, read, and update data using simple HTTP URLs with a standard set of
    HTTP verbs. The most basic form of a REST API will accept one of the HTTP verbs
    at a URL and return some kind of data as a response.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**表述性状态转移**（**REST**）是一种通过HTTP进行CRUD的花哨方式。这意味着，当你使用REST API时，你有一种统一的方式，使用简单的HTTP
    URL和一组标准的HTTP动词来创建、读取和更新数据。REST API的最基本形式将在URL上接受HTTP动词之一，并作为响应返回某种数据。'
- en: 'Typically, a REST API `GET` request will always return some kind of data, such
    as JSON, XML, HTML, or plain text. A `POST` or `PUT` request to a RESTful API
    URL will accept data to create or update. The URL for a RESTful API is known as
    an endpoint, and when working with these endpoints, it is typically said that
    you are consuming them. The standard HTTP verbs used while interfacing with REST
    APIs include:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，REST API的`GET`请求总是会返回某种数据，比如JSON、XML、HTML或纯文本。对RESTful API URL的`POST`或`PUT`请求将接受数据以创建或更新。RESTful
    API的URL被称为端点，当使用这些端点时，通常说你在消费它们。在与REST API交互时使用的标准HTTP动词包括：
- en: '`GET`: This retrieves data'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：这是检索数据'
- en: '`POST`: This submits data for a new record'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：这是提交新记录的数据'
- en: '`PUT`: This submits data to update an existing record'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：这是提交数据以更新现有记录'
- en: '`PATCH`: This submits a date to update only specific parts of an existing record'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：这是提交日期以更新现有记录的特定部分'
- en: '`DELETE`: This deletes a specific record'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：这会删除特定记录'
- en: Typically, RESTful API endpoints are defined in a way such that they mimic the
    data models and have semantic URLs that are somewhat representative of the data
    models. What this means is that to request a list of models, for example, you
    would access an API endpoint of `/models`. Likewise, to retrieve a specific model
    by its ID, you would include that in the endpoint URL via `/models/:Id`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RESTful API端点以一种模仿数据模型并具有语义URL的方式进行定义。这意味着，例如，要请求模型列表，你将访问`/models`的API端点。同样，要通过其ID检索特定模型，你将在端点URL中包含它，如`/models/:Id`。
- en: 'Some sample RESTful API endpoint URLs are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例RESTful API端点URL如下：
- en: '`GET http://myapi.com/v1/accounts`: This returns a list of accounts'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://myapi.com/v1/accounts`：这将返回一个账户列表'
- en: '`GET http://myapi.com/v1/accounts/1`: This returns a single account'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://myapi.com/v1/accounts/1`：这将返回一个单一账户'
- en: 'by `Id: 1`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '通过`Id: 1`'
- en: '`POST http://myapi.com/v1/accounts`: This creates a new account'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST http://myapi.com/v1/accounts`：这将创建一个新账户'
- en: (data submitted as a part of the request)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: （数据作为请求的一部分提交）
- en: '`PUT http://myapi.com/v1/accounts/1`: This updates an existing'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT http://myapi.com/v1/accounts/1`: 这将更新现有的帐户'
- en: 'account by `Id: 1` (data submitted as part of the request)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '通过`Id: 1`提交的帐户（作为请求的一部分提交的数据）'
- en: '`GET http://myapi.com/v1/accounts/1/orders`: This returns a list of orders
    for account `Id: 1`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://myapi.com/v1/accounts/1/orders`: 这将返回帐户`Id: 1`的订单列表'
- en: '`GET http://myapi.com/v1/accounts/1/orders/21345`: This returns the details
    for a single order by `Order Id: 21345` for account `Id: 1`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://myapi.com/v1/accounts/1/orders/21345`: 这将返回帐户`Id: 1`的单个订单的详细信息，订单`Id:
    21345`'
- en: It's not a requirement that the URL endpoints match this pattern; it's just
    common convention.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: URL端点匹配此模式并不是必需的；这只是常见的约定。
- en: Introducing Postman REST Client
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Postman REST Client
- en: Before we get started, there are a few tools that will make life much easier
    when you're working directly with APIs. The first of these tools is called Postman
    REST Client, and it's a Google Chrome application that can run right in your browser
    or as a standalone, packaged application. Using this tool, you can easily make
    any kind of request to any endpoint you want. The tool provides many useful and
    powerful features that are very easy to use, and best of all, free!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，有一些工具可以使您在直接使用API时更加轻松。其中一个工具就是称为Postman REST Client的工具，它是一个可以直接在浏览器中运行或作为独立的打包应用程序运行的Google
    Chrome应用程序。使用此工具，您可以轻松地向任何您想要的端点发出任何类型的请求。该工具提供了许多有用且强大的功能，非常易于使用，而且最重要的是，免费！
- en: Installation instructions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装说明
- en: Postman REST Client can be installed in two different ways, but both require
    Google Chrome to be installed and running on your system. The easiest way to install
    the application is by visiting the chrome web store at [https://chrome.google.com/webstore/category/apps](https://chrome.google.com/webstore/category/apps).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Postman REST Client可以以两种不同的方式安装，但都需要安装并在您的系统上运行Google Chrome。安装该应用程序的最简单方法是访问Chrome网络商店[https://chrome.google.com/webstore/category/apps](https://chrome.google.com/webstore/category/apps)。
- en: Perform a search for Postman REST Client, and multiple results will be returned.
    There is the regular Postman REST Client that runs as an application built into
    your browser, and then a separate Postman REST Client (packaged app) that runs
    as a standalone application on your system in its own dedicated window. Go ahead
    and install your preference. If you install the application as the standalone
    packaged app, an icon to launch it will be added to your dock or task bar. If
    you install it as a regular browser app, you can launch it by opening a new tab
    in Google Chrome, going to Apps, and finding the Postman REST Client icon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索Postman REST Client，将返回多个结果。有常规的Postman REST Client，它作为内置到浏览器中的应用程序运行，还有一个单独的Postman
    REST Client（打包应用程序），它作为独立应用程序在您的系统中运行，并在自己的专用窗口中运行。继续安装您的首选项。如果您将应用程序安装为独立的打包应用程序，将会在您的停靠栏或任务栏上添加一个启动图标。如果您将其安装为常规浏览器应用程序，可以通过在Google
    Chrome中打开一个新标签页，转到应用程序，并找到Postman REST Client图标来启动它。
- en: 'After you''ve installed and launched the app, you should be presented with
    an output similar to the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并启动应用程序后，您应该看到类似以下截图的输出：
- en: '![](img/e209a66f-205d-4b6f-9152-451bac3c6017.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e209a66f-205d-4b6f-9152-451bac3c6017.png)'
- en: A quick tour of Postman REST Client
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Postman REST Client的快速介绍
- en: Using Postman REST Client, we're able to submit REST API calls to any endpoint
    we want, as well as modify the type of request. Then, we can have complete access
    to the data that's returned from the API, as well as any errors that might have
    occurred. To test an API call, enter the URL to your favorite website in the Enter
    request URL here field and leave the dropdown next to it as `GET`. This will mimic
    a standard `GET` request that your browser performs anytime you visit a website.
    Click on the blue Send button. The request is made and the response is displayed
    at the bottom half of the screen.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Postman REST Client，我们能够向任何我们想要的端点提交REST API调用，以及修改请求的类型。然后，我们可以完全访问从API返回的数据，以及可能发生的任何错误。要测试API调用，请在“在此输入请求URL”字段中输入您最喜欢的网站的URL，并将其旁边的下拉菜单保留为`GET`。这将模仿您访问网站时浏览器执行的标准`GET`请求。单击蓝色的发送按钮。请求被发送，并且响应显示在屏幕的下半部分。
- en: 'In the following screenshot, I sent a simple `GET` request to [http://kroltech.com](http://kroltech.com)
    and the HTML was returned as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '在下面的截图中，我向[http://kroltech.com](http://kroltech.com)发送了一个简单的`GET`请求，并返回了HTML。 '
- en: '![](img/031838ab-08cc-417a-953b-2e7e02b08ead.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/031838ab-08cc-417a-953b-2e7e02b08ead.png)'
- en: 'If we change this URL to that of the RSS feed URL for my website, you can see
    the XML returned:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此URL更改为我的网站的RSS源URL，您可以看到返回的XML：
- en: '![](img/1a46abbf-4451-4c57-88c8-da53ae7b65ac.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a46abbf-4451-4c57-88c8-da53ae7b65ac.png)'
- en: The XML view has a few more features, as it exposes the sidebar to the right
    that gives you a glimpse at the tree structure of the XML data. Not only that,
    but you can now see a history of the requests we've made so far along the left
    sidebar. This is great when we're performing more advanced `POST` or `PUT` requests
    and don't want to repeat the data setup for each request while testing an endpoint.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: XML视图具有更多功能，因为它公开了右侧的侧边栏，让您一览XML数据的树结构。不仅如此，您现在还可以看到我们迄今为止所做的请求的历史记录，沿左侧边栏。当我们执行更高级的`POST`或`PUT`请求并且不想在测试端点时重复数据设置时，这将非常有用。
- en: 'Here is a sample API endpoint that I submitted a `GET` request to that returns
    the JSON data in its response:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例API端点，我向其提交了一个`GET`请求，返回其响应中的JSON数据：
- en: '![](img/73ef80fc-6eaa-45f2-a52d-d7113694ca57.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73ef80fc-6eaa-45f2-a52d-d7113694ca57.png)'
- en: A really nice thing about making API calls to endpoints that return JSON using
    Postman Client is that it parses and displays the JSON in a very nicely formatted
    way, and each node in the data is expandable and collapsible.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Postman Client向返回JSON的端点发出API调用的一个非常好的功能是，它以非常好的格式解析和显示JSON，并且数据中的每个节点都是可展开和可折叠的。
- en: The app is very intuitive, so make sure you spend some time playing around and
    experimenting with different types of calls to different URLs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序非常直观，所以确保你花一些时间玩耍和尝试不同类型的调用不同的 URL。
- en: Using the JSONView Chrome extension
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSONView 谷歌浏览器扩展程序
- en: 'There is one other tool I want to talk to you about that (while extremely minor),
    is actually a really big deal. The `JSONView` Chrome extension is a very small
    plugin that will instantly convert any `JSONView` directly into a more usable
    JSON tree via the browser (exactly like in Postman Client). Here is an example
    of pointing to a URL that returns JSON from Chrome before `JSONView` is installed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个工具我想和你谈谈（虽然非常小），但实际上是一个非常重要的事情。`JSONView` 谷歌浏览器扩展程序是一个非常小的插件，它将立即通过浏览器将任何
    `JSONView` 直接转换为更可用的 JSON 树（就像在 Postman 客户端中一样）。这是在安装 `JSONView` 之前指向返回 JSON 的
    URL 的示例：
- en: '![](img/25cb7b1f-43fd-4a44-9381-869432df87ec.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25cb7b1f-43fd-4a44-9381-869432df87ec.png)'
- en: 'Here is that same URL after `JSONView` has been installed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 `JSONView` 之后，这就是相同的 URL：
- en: '![](img/fb010a96-c449-4d0d-8ea3-fb00adeb656e.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb010a96-c449-4d0d-8ea3-fb00adeb656e.png)'
- en: 'You should install the `JSONView` Google Chrome extension the same way you
    installed Postman REST Client: access the Chrome Web Store and perform a search
    for `JSONView`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该像安装 Postman REST Client 一样安装 `JSONView` 谷歌浏览器扩展程序：访问 Chrome 网上应用店，搜索 `JSONView`。
- en: Now that you have the tools to be able to easily work with and test API endpoints,
    let's take a look at writing your own and handling the different request types.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了能够轻松处理和测试 API 端点的工具，让我们来看看如何编写自己的端点并处理不同的请求类型。
- en: Creating a basic API server
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的 API 服务器
- en: 'Let''s create a super basic Node.js server using Express that we''ll use to
    create our own API. Then, we can send tests to the API using Postman REST Client
    to see how it all works. In a new project workspace, first install the `npm` modules
    that we''re going to need in order to get our server up and running:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Express 创建一个超级基本的 Node.js 服务器，我们将使用它来创建我们自己的 API。然后，我们可以使用 Postman REST
    Client 发送测试到 API，看看它是如何工作的。在一个新的项目工作空间中，首先安装我们需要的 `npm` 模块，以便让我们的服务器运行起来：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that the `package.json` file for this project has been initialized and
    the modules installed, let''s create a basic server file to bootstrap an Express
    server. Create a file named `server.js` and insert the following block of code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个项目的 `package.json` 文件已经初始化并安装了模块，让我们创建一个基本的服务器文件来引导 Express 服务器。创建一个名为
    `server.js` 的文件，并插入以下代码块：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most of this should look familiar to you. In the `server.js` file, we are requiring
    the express, body-parser, and underscore modules. We're also requiring a file
    named `movies.json`, which we'll create next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你来说应该看起来很熟悉。在 `server.js` 文件中，我们引入了 express、body-parser 和 underscore 模块。我们还引入了一个名为
    `movies.json` 的文件，接下来我们将创建它。
- en: After our modules are required, we set up the standard configuration for an
    Express server with the minimum amount of configuration needed to support an API
    server. Notice that we didn't set up Handlebars as a view-rendering engine because
    we aren't going to be rendering any HTML with this server, just pure JSON responses.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们引入模块之后，我们使用最少量的配置来设置 Express 服务器的标准配置，以支持 API 服务器所需的最少配置。请注意，我们没有设置 Handlebars
    作为视图渲染引擎，因为我们不打算使用这个服务器来渲染任何 HTML，只是纯粹的 JSON 响应。
- en: Creating sample JSON data
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建示例 JSON 数据
- en: 'Let''s create the sample `movies.json` file that will act as our temporary
    data store (even though the API we build for the purpose of demonstration won''t
    actually persist data beyond the app''s life cycle):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个临时数据存储的示例 `movies.json` 文件（尽管我们为了演示目的构建的 API 实际上不会在应用程序的生命周期之外保留数据）：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is just a really simple JSON list of a few of my favorite movies. Feel
    free to populate it with whatever you like. Boot up the server to make sure you
    aren''t getting any errors (note that we haven''t set up any routes yet, so it
    won''t actually do anything if you try to load it via a browser):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个非常简单的 JSON 电影列表。随意用你喜欢的内容填充它。启动服务器以确保你没有收到任何错误（请注意，我们还没有设置任何路由，所以如果你尝试通过浏览器加载它，它实际上不会做任何事情）：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Responding to GET requests
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应 GET 请求
- en: 'Adding a simple `GET` request support is fairly simple, and you''ve already
    seen this before in the app we built. Here is some sample code that responds to
    a `GET` request and returns a simple JavaScript object as JSON. Insert the following
    code in the `routes` section where we have the `// TO DO: Setup endpoints ...`
    comment waiting:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '添加简单的 `GET` 请求支持非常简单，你已经在我们构建的应用程序中见过这个。这是一些响应 `GET` 请求并返回简单 JavaScript 对象作为
    JSON 的示例代码。在我们有 `// TO DO: Setup endpoints ...` 注释等待的 `routes` 部分插入以下代码：'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Just like how we set up `viewModel` in [Chapter 5](8bd15cd0-997d-46b5-89ce-aa2b001cd890.xhtml),
    *Templating with Handlebars*, we create a basic JavaScript object that we can
    then send directly as a JSON response using `res.json` instead of `res.render`.
    Let''s tweak the function a little bit and change it so that it responds to a
    `GET` request against the root URL (that is `/`) route and returns the JSON data
    from our `movies` file. Add this new route after the `/test` route added previously:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第 5 章](8bd15cd0-997d-46b5-89ce-aa2b001cd890.xhtml)中设置了 `viewModel` 一样，*使用
    Handlebars 进行模板化*，我们创建一个基本的 JavaScript 对象，然后可以直接使用 `res.json` 发送作为 JSON 响应，而不是
    `res.render`。让我们稍微调整一下这个函数，并将它更改为响应根 URL（即 `/`）路由的 `GET` 请求，并从我们的 `movies` 文件返回
    JSON 数据。在之前添加的 `/test` 路由之后添加这个新路由：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `res` (response) object in Express has a few different methods to send data
    back to the browser. Each of these ultimately falls back on the base `send` method,
    which includes `header` information, `statusCodes`, and so on. `res.json` and
    `res.jsonp` will automatically format JavaScript objects into JSON and then send
    them using `res.send`. `res.render` will render a template view as a string and
    then send it using `res.send` as well.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express中，`res`（响应）对象有一些不同的方法来将数据发送回浏览器。这些方法最终都会回退到基本的`send`方法，其中包括`header`信息，`statusCodes`等。`res.json`和`res.jsonp`将自动将JavaScript对象格式化为JSON，然后使用`res.send`发送它们。`res.render`将以字符串形式呈现模板视图，然后也使用`res.send`发送它。
- en: 'With that code in place, if we launch the `server.js` file, the server will
    be listening for a `GET` request to the `/` URL route and will respond with the
    JSON data of our movies collection. Let''s first test it out using the Postman
    REST Client tool:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，如果我们启动`server.js`文件，服务器将监听`/`URL路由的`GET`请求，并响应我们电影集合的JSON数据。让我们首先使用Postman
    REST客户端工具进行测试：
- en: '![](img/d4a24349-089d-4720-b0ab-4d714a59e095.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4a24349-089d-4720-b0ab-4d714a59e095.png)'
- en: '`GET` requests are nice, because we could have just as easily pulled that same
    URL via our browser and received the same result:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`请求很好，因为我们可以很容易地通过浏览器拉取相同的URL并获得相同的结果：'
- en: '![](img/d767d05b-f1aa-490f-a2ba-7e921f3e4c42.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d767d05b-f1aa-490f-a2ba-7e921f3e4c42.png)'
- en: However, we're going to use Postman for the remainder of our endpoint testing,
    as it's a little more difficult to send `POST` and `PUT` requests using a browser.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将使用Postman进行剩余的端点测试，因为使用浏览器发送`POST`和`PUT`请求有点困难。
- en: Receiving data - POST and PUT requests
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收数据 - POST和PUT请求
- en: When we want to allow those using our API to insert or update data, we need
    to accept a request from a different HTTP verb. When inserting new data, the `POST`
    verb is the preferred method to accept data and know it's for an insert. Let's
    take a look at some code that accepts a `POST` request and data along with the
    request, inserts a record into our collection, and returns the updated JSON.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望允许使用我们的API插入或更新数据时，我们需要接受来自不同HTTP动词的请求。在插入新数据时，`POST`动词是接受数据并知道它是用于插入的首选方法。让我们看一下接受`POST`请求和数据的代码，将记录插入到我们的集合中，并返回更新的JSON。
- en: 'Insert the following block of code after the route you added for `GET` previously
    :'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前为`GET`添加的路由之后插入以下代码块：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first thing we do in the `POST` function is check to make sure the required
    fields were submitted along with the actual request. Assuming our data checks
    out and all the required fields are accounted for (in our case, every field),
    we insert the entire `req.body` object into the array as is, using the array''s
    `push` function. If any of the required fields aren''t submitted with the request,
    we return a 500 error message instead. Let''s submit a `POST` request to the same
    endpoint this time using the Postman REST Client. (Don''t forget to make sure
    your API server is running with node `server.js`.):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`POST`函数中，我们首先要做的是检查确保所需字段与实际请求一起提交。假设我们的数据检查通过，并且所有必需字段都被考虑在内（在我们的情况下，每个字段），我们将整个`req.body`对象按原样插入数组中，使用数组的`push`函数。如果请求中没有提交任何必需字段，我们将返回一个500错误消息。让我们使用Postman
    REST客户端向相同的端点提交一个`POST`请求。（不要忘记确保你的API服务器正在使用node `server.js`运行。）：
- en: '![](img/edc4584d-4582-4d35-bd86-cae7b3268bb4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edc4584d-4582-4d35-bd86-cae7b3268bb4.png)'
- en: 'First, we submitted a `POST` request with no data, so you can clearly see the
    500 error response that was returned:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们提交了一个没有数据的`POST`请求，所以你可以清楚地看到返回的500错误响应：
- en: '![](img/daaa2ebd-7dfa-4776-abb6-b49a1d6e2571.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/daaa2ebd-7dfa-4776-abb6-b49a1d6e2571.png)'
- en: 'Next, we provided the actual data using the `x-www-form-urlencoded` option
    in Postman and provided each of the name/value pairs with some new custom data.
    You can see from the results that the STATUS was 200, which is a success, and
    the updated JSON data was returned as a result. Reloading the main `GET` endpoint
    in a browser yields our original movies collection with the new one added:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在Postman中使用`x-www-form-urlencoded`选项提供了实际数据，并提供了每个名称/值对的一些新的自定义数据。你可以从结果中看到状态是200，这是成功的，并且更新的JSON数据作为结果返回。在浏览器中重新加载主`GET`端点，可以看到我们原始的电影集合中添加了新的电影：
- en: '![](img/232bb26a-3061-4a1b-9d5c-806a814d39b9.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/232bb26a-3061-4a1b-9d5c-806a814d39b9.png)'
- en: '`PUT` requests will work in almost exactly the same way, except traditionally,
    the `Id` property of the data is handled a little differently. In our example,
    we are going to require the `Id` attribute as a part of the URL and not accept
    it as a parameter in the data that''s submitted (since it''s usually not common
    for an `update` function to change the actual `Id` of the object it''s updating).
    Insert the following code for the `PUT` route after the existing `POST` route
    you added earlier:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`请求几乎以完全相同的方式工作，除了传统上，数据的`Id`属性处理方式有点不同。在我们的例子中，我们将要求`Id`属性作为URL的一部分，并且不接受它作为提交的数据参数（因为通常`update`函数不会改变正在更新的对象的实际`Id`）。在之前添加的`POST`路由之后，插入以下代码用于`PUT`路由：'
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code again validates that the required fields are included with the data
    that was submitted along with the request. Then, it performs an `_.each` loop
    (using the `underscore` module) to look through the collection of movies and find
    the one whose `Id` parameter matches that of the `Id` included in the URL parameter.
    Assuming there''s a match, the individual fields for that corresponding object
    are updated with the new values that were sent with the request. Once the loop
    is complete, the updated JSON data is sent back as the response. Similarly, in
    the `POST` request, if any of the required fields are missing, a simple 500 error
    message is returned. The following screenshot demonstrates a successful `PUT`
    request updating an existing record:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码再次验证了提交的数据中是否包含所需的字段。然后，它执行一个`_.each`循环（使用`underscore`模块）来查看电影集合，并找到其`Id`参数与URL参数中的`Id`匹配的项目。假设有匹配项，那么相应对象的个别字段将使用请求中发送的新值进行更新。一旦循环完成，更新后的JSON数据将作为响应发送回来。同样，在`POST`请求中，如果缺少任何必需的字段，将返回一个简单的500错误消息。以下截图展示了成功的`PUT`请求更新现有记录：
- en: '![](img/0c7e516c-e684-49f3-b85b-6481333dca58.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c7e516c-e684-49f3-b85b-6481333dca58.png)'
- en: The response from Postman, after including the value `1` in the URL as the `Id`
    parameter, which provides the individual fields to update as `x-www-form-urlencoded`
    values, and finally sends as `PUT`, shows that the original item in our movies
    collection is now the original Alien (not Aliens, its sequel, as we originally
    had).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman的响应中，包括将值`1`作为`Id`参数放入URL中，作为`x-www-form-urlencoded`值提供要更新的个别字段，最后作为`PUT`发送，显示我们电影集合中的原始项目现在是原始的Alien（而不是Aliens，它的续集，正如我们最初的情况）。
- en: Removing data - DELETE
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除数据 - DELETE
- en: 'The final stop on our whirlwind tour of the different REST API HTTP verbs is
    `DELETE`. It should be no surprise that sending a `DELETE` request should do exactly
    what it sounds like. Let''s add another route that accepts `DELETE` requests and
    deletes an item from our movies collection. Here is the code that takes care of
    the `DELETE` requests, which should be placed after the existing block of code
    from the previous `PUT`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在不同的REST API HTTP动词的旋风之旅中的最后一站是`DELETE`。发送`DELETE`请求应该做的事情应该不会让人感到意外。让我们添加另一个接受`DELETE`请求并从我们的电影集合中删除项目的路由。以下是处理`DELETE`请求的代码，应该放在先前`PUT`的现有代码块之后：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code will loop through the collection of movies and find a matching item
    by comparing the values of `Id`. If a match is found, the array `index` for the
    matched item is held until the loop is finished. Using the `array.splice` function,
    we can remove an array item at a specific index. Once the data has been updated
    by removing the requested item, the JSON data is returned. Notice that in the
    following screenshot the updated JSON that''s returned is in fact no longer displaying
    the original second item we deleted:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将循环遍历电影集合，并通过比较`Id`的值找到匹配的项目。如果找到匹配项，匹配项目的数组`index`将保持，直到循环结束。使用`array.splice`函数，我们可以删除特定索引处的数组项。一旦通过删除请求的项目更新了数据，JSON数据将被返回。请注意，在以下截图中，返回的更新后的JSON实际上不再显示我们删除的原始第二项：
- en: '![](img/d16f1ce3-2968-47fe-9bf2-b64f1256f94c.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d16f1ce3-2968-47fe-9bf2-b64f1256f94c.png)'
- en: The `~` use in JavaScript! That's a little bit of JavaScript black magic! The
    tilde (`~`) in JavaScript will bit flip a value. In other words, it will take
    a value and return the negative of that value incremented by one, that is `~n
    === -(n+1)`. Typically, the tilde is used with functions that return `-1` as a
    false response. By using `~` on `-1`, you are converting it to `0`. If you were
    to perform a Boolean check on `-1` in JavaScript, it would return `true`. You
    will see that `~` is primarily used with the `indexOf` function and `jQuery's
    $.inArray()`; both return `-1` as a `false` response.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`~`使用！这是一点点JavaScript黑魔法！在JavaScript中，波浪号（`~`）将对一个值进行位翻转。换句话说，它将取一个值并返回该值的负值加一，即`~n
    === -(n+1)`。通常，波浪号与返回`-1`作为假响应的函数一起使用。通过在`-1`上使用`~`，您将其转换为`0`。如果您在JavaScript中对`-1`执行布尔检查，它将返回`true`。您会发现`~`主要与`indexOf`函数和`jQuery`的`$.inArray()`一起使用；两者都将`-1`作为`false`响应。
- en: All of the endpoints defined in this chapter are extremely rudimentary, and
    most of these should never see the light of day in a production environment! Whenever
    you have an API that accepts anything other than `GET` requests, you need to be
    sure to enforce extremely strict validation and authentication rules. After all,
    you are basically giving your users direct access to your data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中定义的所有端点都非常基础，其中大多数在生产环境中不应该出现！每当您有一个接受除`GET`请求以外的任何内容的API时，您都需要确保执行非常严格的验证和身份验证规则。毕竟，您基本上是直接向用户提供对您数据的访问权限。
- en: Consuming external APIs from Node.js
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Node.js中使用外部API
- en: There will undoubtedly be a time when you want to consume an API directly from
    within your Node.js code. Perhaps your own API endpoint needs to first fetch data
    from some other, unrelated third-party API before sending a response. Whatever
    the reason, the act of sending a request to an external API endpoint and receiving
    a response can be done fairly easily by using a popular and well-known `npm` module
    called `request`. The `request` module was written by Mikeal Rogers and is currently
    the third most popular (and most relied upon) `npm` module, after `async` and
    `underscore`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，总有一天您想要直接从Node.js代码中使用API。也许您自己的API端点需要首先从某个与之无关的第三方API中获取数据，然后再发送响应。无论原因是什么，通过使用一个名为`request`的流行和知名的`npm`模块，可以相对容易地发送请求到外部API端点并接收响应。`request`模块是由Mikeal
    Rogers编写的，目前是第三受欢迎（也是最可靠的）`npm`模块，仅次于`async`和`underscore`。
- en: Request is basically a super simple HTTP client, so everything you've been doing
    with Postman REST Client so far is basically what `Request` can do, only the resulting
    data is available to you in your Node code, as well as the response status codes
    and/or errors, if any.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请求基本上是一个超级简单的HTTP客户端，所以到目前为止你用Postman REST Client所做的一切基本上都是`Request`可以做的，只是结果数据在你的Node代码中可用，以及响应状态码和/或错误（如果有的话）。
- en: Consuming an API endpoint using request
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用请求来消耗API端点
- en: 'Let''s do a neat trick and actually consume our own endpoint as if it was some
    third-party external API. First, we need to ensure we have `request` installed
    and can include it in our app:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个巧妙的技巧，实际上消耗我们自己的端点，就好像它是某个第三方外部API一样。首先，我们需要确保我们已经安装了`request`并且可以在我们的应用程序中包含它：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, edit `server.js` and make sure you include `request` as a required module
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`server.js`，确保你包含`request`作为一个必需的模块
- en: 'at the start of the file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的开头：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's add a new endpoint after our existing routes, which will be an endpoint
    accessible in our server via a `GET` request to `/external-api`. This endpoint,
    however, will actually consume another endpoint on another server, but for the
    purposes of this example, the other server is actually the same server we're currently
    running!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在现有路由之后添加一个新的端点，这将是通过对`/external-api`发出`GET`请求在我们的服务器中可访问的一个端点。然而，这个端点实际上将消耗另一个服务器上的另一个端点，但是出于这个例子的目的，另一个服务器实际上是我们当前正在运行的相同服务器！
- en: The `request` module accepts an options object with a number of different parameters
    and settings, but for this particular example, we only care about a few. We're
    going to pass an object that has a setting for the URL of the endpoint we want
    to consume. After the request is made and a response is received, we want an inline
    `callback` function to execute.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`request`模块接受一个带有许多不同参数和设置的选项对象，但对于这个特定的例子，我们只关心其中的一些。我们将传递一个具有我们要消耗的端点的URL设置的对象。在发出请求并收到响应后，我们希望执行一个内联的`callback`函数。'
- en: 'Place the following block of code after your existing list of `routes` in `server.js`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中现有的`routes`列表之后放置以下代码块：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `callback` function accepts three parameters: `error`, `response`, and
    `body`. The `response` object is like any other response that Express handles
    and has all of the various parameters as such. The third parameter, `body`, is
    what we''re really interested in. That will contain the actual result of the request
    to the endpoint that we called. In this case, it is the JSON data from our main
    `GET` route we defined earlier that returns our own list of movies. It''s important
    to note that the data returned from the request is returned as a string. We need
    to use `JSON.parse` to convert that string to actual, usable JSON data.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback`函数接受三个参数：`error`，`response`和`body`。`response`对象就像Express处理的任何其他响应一样，具有各种参数。第三个参数`body`是我们真正感兴趣的。它将包含我们调用的端点请求的实际结果。在这种情况下，它是我们之前定义的主`GET`路由返回的JSON数据，其中包含我们自己的电影列表。重要的是要注意，从请求返回的数据是作为字符串返回的。我们需要使用`JSON.parse`将该字符串转换为实际可用的JSON数据。'
- en: We manipulate the data that came back from request to suit our needs. In this
    example, we took the master list of movies and just returned a new collection
    that consists of only the `Title` and `Rating` of each movie and sorts the results
    by the top scores.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们操纵了从请求返回的数据以满足我们的需求。在这个例子中，我们拿到了电影的主列表，只返回了一个由每部电影的`Title`和`Rating`组成的新集合，并按照最高分数对结果进行排序。
- en: Load this new endpoint by pointing your browser to `http://localhost:3500/external-api`,
    and you can see the newly transformed JSON output to the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将浏览器指向`http://localhost:3500/external-api`来加载这个新的端点，你可以看到新转换的JSON输出显示在屏幕上。
- en: 'Let''s take a look at another example that''s a little more real-world. Let''s
    say that we want to display a list of similar movies for each one in our collection,
    but we want to look up that data somewhere, such as on [www.imdb.com](http://www.imdb.com).
    Here is the sample code that will send a `GET` request to IMDB''s JSON API, specifically
    for the word `aliens`, and returns a list of related movies by the `Title` and
    `Year`. Go ahead and place this block of code after the previous route for `external-api`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更真实的例子。假设我们想为我们收藏中的每部电影显示一系列相似的电影，但我们想在[www.imdb.com](http://www.imdb.com)等地方查找这些数据。下面是一个示例代码，它将向IMDB的JSON
    API发送一个`GET`请求，特别是针对单词`aliens`，并返回按`Title`和`Year`列出的相关电影。继续在`external-api`的先前路由之后放置这个代码块：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we take a look at this new endpoint in a browser, we can see that the JSON
    data that''s returned from our `/imdb` endpoint is actually retrieving and returning
    data from some other API endpoint itself:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中查看这个新的端点，我们可以看到从我们的`/imdb`端点返回的JSON数据实际上是从一些其他API端点检索和返回数据：
- en: '![](img/fef410ca-67ab-4945-b33a-8473a3893aaa.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fef410ca-67ab-4945-b33a-8473a3893aaa.png)'
- en: The JSON endpoint I am using for IMDB isn't actually from their API, but rather
    what they use on their home page when you type in the main Search box. This would
    not really be the most appropriate way to use their data, but it's more of a hack
    to show this example. In reality, to use their API (like most other APIs), you
    would need to register and get an API key that you would use so that they could
    properly track how much data you were requesting on a daily or hourly basis. Most
    APIs will require you to use a private key with them for this reason.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用的IMDB的JSON端点实际上并不是来自他们的API，而是当你在主搜索框中输入时他们在主页上使用的。这实际上并不是使用他们的数据的最合适的方式，但更多的是一个示例。实际上，要使用他们的API（就像大多数其他API一样），你需要注册并获取一个API密钥，这样他们才能正确地跟踪你每天或每小时请求了多少数据。出于这个原因，大多数API都需要你使用私钥。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a brief look at how APIs work in general, the RESTful
    API approach to semantic URL paths and arguments, and how we create a bare bones
    API.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了API的一般工作原理，语义URL路径和参数的RESTful API方法，以及如何创建一个简单的API。
- en: We used Postman REST Client to interact with the API by consuming endpoints
    and testing the different types of request methods (`GET`, `POST`, `PUT`, and
    so on). You also learned how to consume an external API endpoint by using the
    third-party node module `request`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Postman REST Client与API交互，通过消耗端点和测试不同类型的请求方法（`GET`，`POST`，`PUT`等）来进行测试。您还学会了如何使用第三方节点模块`request`来消耗外部API端点。
- en: In the next chapter, we will revisit our original application as we implement
    best practices by introducing testing in Node.js. We'll take a look at popular
    testing frameworks and write tests for the application to prove that our code
    works as expected.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重新访问我们的原始应用程序，通过在Node.js中引入测试来实施最佳实践。我们将研究流行的测试框架，并为应用程序编写测试，以证明我们的代码按预期工作。
