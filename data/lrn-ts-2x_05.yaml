- en: Working with Dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理依赖
- en: In the previous chapter, we learned how to work with classes and interfaces.
    We also learned about the SOLID principles and other object-oriented programming
    best practices. In this chapter, we will learn how to work with dependencies.
    The first part of the chapter will focus on the usage of modules. The second part
    of the chapter will focus on the management of dependencies in object-oriented
    programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用类和接口，还了解了 SOLID 原则和其他面向对象编程的最佳实践。在本章中，我们将学习如何处理依赖关系。本章的第一部分将专注于模块的使用。第二部分将专注于面向对象编程中依赖关系的管理。
- en: 'We are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Third-party dependencies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方依赖
- en: Internal modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部模块
- en: External modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部模块
- en: Asynchronous module definition (AMD)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步模块定义 (AMD)
- en: CommonJS modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS 模块
- en: ES6 modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6 模块
- en: Browserify and universal module definition (UMD)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Browserify 和通用模块定义 (UMD)
- en: Circular dependencies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环依赖
- en: Dependency injection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Third-party dependencies
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方依赖
- en: Third-party dependencies are usually open source libraries created by third-party
    organizations or independent software engineers. Third-party dependencies are
    external modules and can be imported using their name instead of a relative or
    absolute path.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方依赖通常是第三方组织或独立软件工程师创建的开源库。第三方依赖是外部模块，可以使用其名称而不是相对或绝对路径来导入。
- en: Package management tools
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包管理工具
- en: Package management tools are used for dependency management so that we no longer
    have to download and manage our application's dependencies manually.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理工具用于依赖管理，这样我们就不必手动下载和管理我们的应用程序依赖项。
- en: The rise and fall of package management tools
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包管理工具的兴衰
- en: The TypeScript ecosystem has experienced the rise and fall of many package managers
    over the past few years. This generated some confusion in the early days of TypeScript
    but, fortunately, today we have a much more stable ecosystem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，TypeScript 生态系统经历了许多包管理器的兴衰。这在 TypeScript 的早期阶段造成了一些混乱，但幸运的是，今天我们有一个更加稳定的生态系统。
- en: Some notable package managers in the TypeScript history include tsd, typings,
    npm, bower, yarn, and turbo. Some package managers, such as tsd, typings, and
    bower, are not recommended anymore, and others, such as yarn or turbo, are relatively
    new and not as widely adopted as npm. The recommended package manager at the time
    of writing is npm.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 历史中一些值得注意的包管理器包括 tsd、typings、npm、bower、yarn 和 turbo。一些包管理器，如 tsd、typings
    和 bower，现在不再推荐使用，而其他如 yarn 或 turbo 则相对较新，并且不如 npm 广泛采用。撰写本文时推荐的包管理器是 npm。
- en: npm
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm
- en: The **Node Package Manager** (**npm**) was originally developed as the default
    Node.js package management tool, but today it is used by many other tools.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node 包管理器**（**npm**）最初是作为 Node.js 的默认包管理工具开发的，但如今它被许多其他工具使用。'
- en: 'npm uses a configuration file, named `package.json`, to store references to
    all the dependencies installed in our project. Originally, npm was usually only
    used to install backend dependencies, but today it is used to install any dependencies.
    This includes the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: npm 使用一个名为 `package.json` 的配置文件来存储我们项目中安装的所有依赖项的引用。最初，npm 通常仅用于安装后端依赖项，但如今它用于安装任何依赖项。这包括以下内容：
- en: Backend dependencies
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端依赖
- en: Frontend dependencies
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端依赖
- en: Development tools
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发工具
- en: TypeScript type definitions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 类型定义
- en: 'Before we install any packages, we should add a `package.json` file to our
    project. We can do this by executing the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装任何包之前，我们应该在我们的项目中添加一个 `package.json` 文件。我们可以通过执行以下命令来完成此操作：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please note that we must install Node.js to be able to use the `npm` command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须安装 Node.js 才能使用 `npm` 命令。
- en: The `npm init` command will ask for some basic information about our project,
    including its name, version, description, entry point, test command, Git repository,
    keywords, author, and license.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm init` 命令将要求我们提供有关项目的一些基本信息，包括其名称、版本、描述、入口点、测试命令、Git 仓库、关键词、作者和许可证。'
- en: Refer to the official npm documentation at [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)
    if you are unsure about the purpose of some of the `package.json` fields mentioned
    earlier.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对之前提到的某些 `package.json` 字段的目的不确定，请参阅官方 npm 文档：[https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)。
- en: The `npm` command will then show us a preview of the `package.json` file that
    is about to be generated, and ask for our final confirmation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`命令将显示即将生成的`package.json`文件的预览，并要求我们进行最终确认。'
- en: 'If you would like to skip the questions and generate the file using the default
    settings, you can use the `npm init` command together with the `--yes` flag:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望跳过问题并使用默认设置生成文件，你可以使用带有`--yes`标志的`npm init`命令：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After creating the project's `package.json` file, we will use the `npm install`
    command to install our first dependency.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建项目的`package.json`文件后，我们将使用`npm install`命令安装我们的第一个依赖项。
- en: The `npm install` command takes as arguments the name of one or multiple dependencies
    separated by a single space, and the scope of the installation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install`命令将一个或多个依赖项的名称作为参数，这些依赖项由单个空格分隔，并指定安装范围。'
- en: 'The scope can be the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 范围可以是以下几种：
- en: Global dependency
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局依赖项
- en: Dependency at development time (for example, testing frameworks, compilers,
    and so on)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发时依赖项（例如，测试框架、编译器等）
- en: Dependency at runtime (for example, a web framework, database ORMs, and so on)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时依赖项（例如，Web框架、数据库ORM等）
- en: 'We will use the `tslint` npm package to check the style of our TypeScript code,
    so let''s install it as a development dependency (using the `--save-dev` argument):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`tslint` npm包来检查我们的TypeScript代码的风格，所以让我们将其作为开发依赖项安装（使用`--save-dev`参数）：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To install a global dependency, we will use the `-g` argument:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装全局依赖项，我们将使用`-g`参数：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We might need administrative privileges to install packages with global scope
    in our development environment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要在我们的开发环境中具有管理员权限来安装全局范围的包。
- en: Also note that npm will not add any entries to our `package.json` when installing
    packages with a global scope, but is important that we manually add the right
    dependencies to the `devDependencies` section in `package.json` to guarantee that
    the continuous integration build server will resolve all our project's dependencies
    correctly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，当使用全局范围的包安装包时，npm不会向我们的`package.json`添加任何条目，但手动将正确的依赖项添加到`package.json`中的`devDependencies`部分是很重要的，以确保持续集成构建服务器能够正确解析我们项目的所有依赖项。
- en: 'To install a runtime dependency, use the `--save` argument:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装运行时依赖项，请使用`--save`参数：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Please note that `react` is a module that can be used to create user interfaces.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`react`是一个可以用来创建用户界面的模块。
- en: 'Once we have installed some dependencies in the `package.json` file, the contents
    should look like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`package.json`文件中安装了一些依赖项，内容应该看起来像以下这样：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some fields in the `package.json` file must be configured manually. To learn
    more about the available `package.json` configuration fields, visit [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件中的一些字段必须手动配置。要了解更多关于可用的`package.json`配置字段的信息，请访问[https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)。'
- en: The versions of the npm packages used throughout this book may have been updated
    since its publication. Refer to the package documentation at [https://npmjs.com](https://npmjs.com)
    to find out potential incompatibilities and learn about new features.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所使用的npm包版本可能自出版以来已经更新。请参阅[https://npmjs.com](https://npmjs.com)上的包文档，以了解潜在的不兼容性和了解新功能。
- en: If you are using one of the modern versions of npm, installing a module will
    also generate a file named `package-lock.json`. This file describes the exact
    dependency tree that was generated, such that subsequent installations can generate
    identical trees, regardless of intermediate dependency updates.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用npm的现代版本之一，安装模块还会生成一个名为`package-lock.json`的文件。此文件描述了生成的确切依赖项树，以便后续安装可以生成相同的树，无论中间的依赖项更新如何。
- en: All the npm packages will be saved in the `node_modules` directory. It is recommended
    to avoid saving the `node_modules` directory into source control (for example,
    a Git repository).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的npm包都将保存在`node_modules`目录中。建议不要将`node_modules`目录放入源代码控制（例如，Git仓库）中。
- en: 'The next time we set up our development environment, we will need to download
    all our dependencies again, but to do so, we will only need to execute the `npm
    install` command without any additional parameters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下次我们设置开发环境时，我们需要再次下载所有依赖项，但要做到这一点，我们只需要执行`npm install`命令，无需任何附加参数：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The package manager (npm) will then search for the `package.json` file and install
    all the dependencies listed in it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器（npm）将随后搜索 `package.json` 文件并安装其中列出的所有依赖项。
- en: We can use the npm search engine at [https://www.npmjs.com](https://www.npmjs.com)
    to find potential modules that could be useful for our application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [https://www.npmjs.com](https://www.npmjs.com) 上的 npm 搜索引擎来查找可能对我们应用程序有用的潜在模块。
- en: We can check whether the dependencies of our project are outdated using the
    `npm outdated` command.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `npm outdated` 命令检查我们项目的依赖项是否过时。
- en: We have learned how to use npm to manage the dependencies of a project. However,
    npm is more than a package manager, because it also allows us to create commands
    to perform some custom automation tasks, for example, to release a version of
    our application or run some automated tests. We will learn more about this feature
    later in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 npm 来管理项目的依赖项。然而，npm 不仅仅是一个包管理器，因为它还允许我们创建命令来执行一些自定义自动化任务，例如发布我们应用程序的版本或运行一些自动化测试。我们将在第
    9 章 [自动化您的开发工作流程](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)中了解更多关于此功能的内容。
- en: Type definitions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型定义
- en: The TypeScript support for existing JavaScript libraries is achieved thanks
    to the declaration of the public interface, or API, of the library. The declaration
    of the public interface of a third-party module is known as **type definition**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 对现有 JavaScript 库的支持是通过声明库的公共接口或 API 来实现的。第三方模块公共接口的声明被称为 **类型定义**。
- en: When we install an npm module, we can face a few different scenarios.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装一个 npm 模块时，我们可能会遇到几种不同的场景。
- en: Modules with native support for TypeScript
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有对 TypeScript 本地支持的模块
- en: 'Some third-party dependencies feature built-in support for TypeScript. For
    example, an example of a module with native support for TypeScript is the InversifyJS
    module. In this case, installing the npm module is enough, because the module
    includes the required type definitions:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一些第三方依赖项具有内置对 TypeScript 的支持。例如，具有 TypeScript 本地支持的模块示例是 InversifyJS 模块。在这种情况下，仅安装
    npm 模块就足够了，因为该模块包括所需的类型定义：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Modules with external support for TypeScript
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有对 TypeScript 外部支持的模块
- en: 'Some third-party dependencies do not feature built-in support for TypeScript,
    but type definitions are available in a separate npm module. An example of a module
    with external support for TypeScript is the `react` module. In this case, installing
    the npm module is not enough, because it doesn''t include the required type definitions.
    We can solve this by installing the npm module which contains the missing type
    definitions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些第三方依赖项没有内置对 TypeScript 的支持，但类型定义可以在单独的 npm 模块中找到。一个具有对 TypeScript 外部支持的模块示例是
    `react` 模块。在这种情况下，仅安装 npm 模块是不够的，因为它不包括所需的类型定义。我们可以通过安装包含缺失类型定义的 npm 模块来解决这个问题：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The TypeScript team has developed an automated process that publishes all the
    available open source type definitions under one unique organization on the npm
    public registry. The organization is named `@types`, and the type definitions
    use the name of the module that they are defining.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 团队开发了一个自动化流程，该流程在 npm 公共注册表下以一个独特的组织名称发布所有可用的开源类型定义。该组织名为 `@types`，类型定义使用它们所定义的模块名称。
- en: Modules with no support for TypeScript
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有对 TypeScript 提供支持的模块
- en: Some third-party dependencies don't feature built-in support for TypeScript,
    and type definitions are not available in a separate npm. In this case, installing
    the npm module is not enough, because it doesn't include the required type definitions.
    We can solve this by creating our type definitions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一些第三方依赖项没有内置对 TypeScript 的支持，并且类型定义不在单独的 npm 中提供。在这种情况下，仅安装 npm 模块是不够的，因为它不包括所需的类型定义。我们可以通过创建我们的类型定义来解决这个问题。
- en: Unfortunately, the process of creating our type definitions is not something
    that can be systematically described and requires a bit of experience, but we
    are going to try to explain the main complexities around it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，创建我们的类型定义的过程不是可以系统描述的，需要一些经验，但我们将尝试解释围绕它的主要复杂性。
- en: Let's pretend that we need to write custom type definition for the `react-side-effect`
    npm module, which is not the case because the type definitions are available already,
    but we will use it as an example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们需要为 `react-side-effect` npm 模块编写自定义类型定义，尽管实际上并不需要，因为类型定义已经可用，但我们将用它作为示例。
- en: 'The first thing that we need to do is to install the package that is missing
    the type definitions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装缺少类型定义的包：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we need to open the `package.json` contained inside the `react-side-effect`
    module. Each npm module contains a `package.json` file, so it should be located
    at the following path:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要打开 `react-side-effect` 模块内部的 `package.json` 文件。每个 npm 模块都包含一个 `package.json`
    文件，因此它应该位于以下路径：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we examine the `package.json` file, we should be able to find the `main`
    field. The `main `field describes the entry point of the npm module. The `main`
    field in the `package.json` of the `react-side-effect` npm module looks as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查 `package.json` 文件，我们应该能够找到 `main` 字段。`main` 字段描述了 npm 模块的入口点。`react-side-effect`
    npm 模块的 `package.json` 中的 `main` 字段如下所示：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need to open that file and find which elements are exported by the module
    and how they are exported. This is the complicated part: we need to navigate through
    the source code and identify the exported elements and the kind of exports. The
    `lib/index.js` file only exports a function named `withSideEffect`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要打开那个文件，找出模块导出了哪些元素以及它们是如何导出的。这是复杂的一部分：我们需要在源代码中导航并识别导出的元素和导出类型。`lib/index.js`
    文件只导出了一个名为 `withSideEffect` 的函数：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, we can create a file named `external.d.ts` and add the following
    type definitions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以创建一个名为 `external.d.ts` 的文件，并添加以下类型定义：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Please note that we have used the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了以下方式：
- en: '`export = withSideEffect;`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`export = withSideEffect;`'
- en: We have used this kind of module export because that is the kind of export that
    we can [see](https://github.com/gaearon/react-side-effect/blob/eb25efece753108b083f9c2c1be8e650712810d0/src/index.js#L5)
    in the library's source code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这种类型的模块导出，因为这是我们可以在库的源代码中看到的导出类型。[查看详情](https://github.com/gaearon/react-side-effect/blob/eb25efece753108b083f9c2c1be8e650712810d0/src/index.js#L5)
- en: 'Sometimes we will see a module export like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们会看到类似以下的模块导出：
- en: '`export default withSideEffect;`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`export default withSideEffect;`'
- en: 'Or one like the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像以下这样的：
- en: '`export { withSideEffect };`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`export { withSideEffect };`'
- en: We need to ensure that our type definition file uses the same kind of export
    that is used in the library. We will learn more about the different kinds of exports
    later in this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们的类型定义文件使用与库中相同的导出类型。我们将在本章的后面部分了解更多关于不同类型导出的内容。
- en: 'The preceding code snippet declares a module named react-side-effect. The module
    exports an entity named `withSideEffect` with type `any`. The preceding type definitions
    should be enough to be able to import the module:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段声明了一个名为 react-side-effect 的模块。该模块导出一个名为 `withSideEffect` 的实体，其类型为 `any`。前面的类型定义应该足够让我们能够导入该模块：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But if we do so, we will get an error:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们这样做，我们会得到一个错误：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unfortunately, the only way to fix this is by adding an extra namespace, as
    described at [https://github.com/Microsoft/TypeScript/issues/5073](https://github.com/Microsoft/TypeScript/issues/5073):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，修复这个问题的唯一方法是通过添加一个额外的命名空间，正如在[https://github.com/Microsoft/TypeScript/issues/5073](https://github.com/Microsoft/TypeScript/issues/5073)中描述的那样：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this point, we can import the module without errors, but the type of `withSideEffect`
    is `any`. We can solve this by examining the source code and spending some time
    trying to figure out the signature of the function. If we do so, we will end up
    with something like the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以导入模块而不会出错，但 `withSideEffect` 的类型是 `any`。我们可以通过检查源代码并花一些时间来尝试确定函数的签名来解决此问题。如果我们这样做，我们最终会得到以下类似的内容：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please note that it is highly recommended to share your type definitions with
    the TypeScript community at [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，强烈建议您在[https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)上与
    TypeScript 社区分享您的类型定义。
- en: The ECMAScript specification type definitions (lib.d.ts)
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript 规范类型定义（lib.d.ts）
- en: 'The TypeScript compiler automatically includes type definitions for the ECMAScript
    version that we are targeting. For example, if we target ES5, we will not be able
    to access the Promise API, because it is part of the ES6 specification:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器会自动包含我们针对的 ECMAScript 版本的类型定义。例如，如果我们针对 ES5，我们将无法访问 Promise API，因为它属于
    ES6 规范的一部分：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, TypeScript allows us to import the type definitions for a proposal
    instead of an entire ECMAScript specification. For example, we can target ES5
    and use the Promise API by adding the following to our `tsconfig.json` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TypeScript 允许我们导入一个提案的类型定义，而不是整个 ECMAScript 规范。例如，我们可以针对 ES5 并通过向我们的 `tsconfig.json`
    文件中添加以下内容来使用 Promise API：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding setting is indicating to the TypeScript compiler that we want
    it to import the type definitions for the entire ECMAScript 5 specification, the
    **document object model** (**DOM**) and the Promise API.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的设置是在指示 TypeScript 编译器，我们希望它导入整个 ECMAScript 5 规范、**文档对象模型**（**DOM**）和 Promise
    API 的类型定义。
- en: External TypeScript helpers (tslib)
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部 TypeScript 辅助函数（tslib）
- en: 'As we already know, TypeScript allows us to use features of the upcoming ECMAScript
    specifications. TypeScript uses a series of helper functions to implement some
    of these features at runtime. The following are some of the helper functions generated
    by TypeScript:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，TypeScript 允许我们使用即将到来的 ECMAScript 规范的一些特性。TypeScript 使用一系列辅助函数在运行时实现这些特性中的某些功能。以下是由
    TypeScript 生成的某些辅助函数：
- en: '`__extends` for inheritance'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__extends` 用于继承'
- en: '`__assign` for object spread properties'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__assign` 用于对象展开属性'
- en: '`__rest` for object rest properties'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__rest` 用于对象剩余属性'
- en: '`__decorate`, `__param`, and `__metadata` for decorators'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__decorate`、`__param` 和 `__metadata` 用于装饰器'
- en: '`__awaiter` and `__generator` for `async`/`await`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__awaiter` 和 `__generator` 用于 `async`/`await`'
- en: If one of these helpers is required, TypeScript will generate it at compilation
    time. However, this can be a problem, because the helper is generated in all of
    the files that require it, which can lead to a lot of duplicated code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要这些辅助函数之一，TypeScript 将在编译时生成它。然而，这可能会成为一个问题，因为辅助函数会在所有需要它的文件中生成，这可能导致大量代码重复。
- en: 'We can use the following compilation settings to solve this problem:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下编译设置来解决这个问题：
- en: The `noEmitHelpers` flag will prevent TypeScript from emitting the helper functions
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `noEmitHelpers` 标志可以防止 TypeScript 生成辅助函数
- en: The `importHelpers` flag will emit the code necessary to import the helpers
    from the `tslib` npm module instead of emitting the helper functions
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `importHelpers` 标志将生成从 `tslib` npm 模块导入辅助函数所需的代码，而不是生成辅助函数。
- en: 'The `tslib` module contains the declaration of all the required TypeScript
    helpers. We can install the `tslib` module using npm, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`tslib` 模块包含了所有必需的 TypeScript 辅助函数的声明。我们可以使用 npm 安装 `tslib` 模块，如下所示：'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This way, the helper functions are only declared once (by the `tslib` module).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，辅助函数只声明一次（由 `tslib` 模块声明）。
- en: Internal modules (module and namespace)
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部模块（模块和命名空间）
- en: We can use the `module` and `namespace` keywords to define internal modules.
    TypeScript originally allowed us to use the `module` keyword to declare internal
    modules, but it was later deprecated in favor of the `namespace` keyword.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `module` 和 `namespace` 关键字来定义内部模块。TypeScript 最初允许我们使用 `module` 关键字来声明内部模块，但后来为了
    `namespace` 关键字而弃用了它。
- en: Internal modules (`namespaces`) can be used to encapsulate certain elements
    of an application and to provide our code with a better organization. However,
    **we should try to avoid them and favor external modules over namespaces**. External
    modules should be our preferred option because they are required by some tools
    that allow us to optimize certain aspects of our application. External modules
    will be covered in detail later in this chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 内部模块（`namespaces`）可以用来封装应用程序的某些元素，并为我们的代码提供更好的组织。然而，**我们应该尽量避免使用它们，并优先考虑外部模块而不是命名空间**。外部模块应该是我们的首选选项，因为某些工具需要它们来优化我们应用程序的某些方面。外部模块将在本章的后面部分详细讨论。
- en: 'We can use namespaces to group interfaces, classes, and objects that are somehow
    related. For example, we could wrap all our application models inside an internal
    module named `Models`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命名空间来分组接口、类和对象，它们在某种程度上是相关的。例如，我们可以在名为 `Models` 的内部模块中包装我们所有的应用程序模型：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All entities contained by a `namespace` are private by default. We can use the
    `export` keyword to declare what parts of our `namespace` we wish to make public.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`namespace` 包含的所有实体都是私有的。我们可以使用 `export` 关键字来声明我们希望公开的 `namespace` 的哪些部分。
- en: Nested internal modules
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套内部模块
- en: 'We can nest one `namespace` inside another as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样嵌套一个 `namespace`：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding example, we have declared a namespace named `App`, and inside
    it, we have declared a public namespace named `Models`, which contains two public
    classes: `UserModel` and `TalkModel`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了一个名为`App`的命名空间，并在其中声明了一个名为`Models`的公共命名空间，它包含两个公共类：`UserModel`和`TalkModel`。
- en: 'We can then access the namespace entities by indicating the full namespace
    name:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过指定完整的命名空间名称来访问命名空间实体：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Cross-file internal modules
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨文件内部模块
- en: TypeScript allows us to declare internal modules across multiple files. If an
    internal module becomes too big, it can be divided into multiple files to increase
    its maintainability. If we take the preceding example, we could add more contents
    to the internal module named `App` by referencing it in a new file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript允许我们在多个文件中声明内部模块。如果一个内部模块变得太大，它可以被分成多个文件以提高其可维护性。如果我们以先前的例子为例，我们可以在一个新文件中通过引用它来向名为`App`的内部模块添加更多内容。
- en: 'Let''s create a new file, named `validation.ts`, and add the following code
    to it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件，命名为`validation.ts`，并将以下代码添加到其中：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can then access the namespace entities declared in both files by indicating
    the full namespace name:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过指定完整的命名空间名称来访问两个文件中声明的命名空间实体：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Even though the namespaces `Models` and `Validation` are declared in two different
    files, we can access them through the `App` namespace.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管命名空间`Models`和`Validation`在不同的文件中声明，我们仍然可以通过`App`命名空间来访问它们。
- en: 'Namespace names can contain periods. For example, instead of nesting the internal
    modules (validation and models) inside the `app` module, we could have used periods
    in the `validation` and `models` internal module names:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间名称可以包含点号。例如，我们可以在`validation`和`models`内部模块名称中使用点号，而不是在`app`模块内部嵌套内部模块（验证和模型）：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Internal module aliases
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部模块别名
- en: 'The `import` keyword can be used within an internal module to provide an alias
    for another module, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部模块中可以使用`import`关键字为另一个模块提供一个别名，如下所示：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Compiling internal modules
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译内部模块
- en: Once we have finished declaring our internal modules, we can decide whether
    we want to compile each one into JavaScript or whether we prefer to concatenate
    all the files into one single file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了内部模块的声明，我们就可以决定是否要将每个模块编译成JavaScript，或者我们是否更倾向于将所有文件连接成一个单一的文件。
- en: 'We can use the `--out` flag to compile all the input files into a single JavaScript
    output file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`--out`标志将所有输入文件编译成一个单一的JavaScript输出文件：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The compiler will automatically order the output file based on the reference
    tags present in the files. We can then import our files or file using an HTML
    `<script>` tag.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将自动根据文件中存在的引用标签对输出文件进行排序。然后，我们可以使用HTML `<script>`标签导入我们的文件或文件。
- en: External modules
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部模块
- en: TypeScript also has the concept of an external module. JavaScript versions before
    ECMAScript 6 (ES6) don't include native support for external modules. Developers
    were forced to develop custom module loaders, and the open source community tried
    to come up with improved solutions over the years. As a result, today, there are
    several types of module loaders, and each one of them supports at least one module
    definition syntax.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript也有外部模块的概念。在ECMAScript 6（ES6）之前的JavaScript版本中，没有对外部模块的原生支持。开发者被迫开发自定义模块加载器，开源社区在多年中尝试提出改进的解决方案。因此，今天有几种类型的模块加载器，每种至少支持一种模块定义语法。
- en: In general, we can assume that when someone talks about a module, without explicitly
    specifying whether they are talking about an internal or external module, they
    are referring to an external module.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们提到一个模块时，如果没有明确指出是内部模块还是外部模块，我们可以假设他们指的是外部模块。
- en: Module loaders and module definition syntaxes
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块加载器和模块定义语法
- en: The main difference between using modules (instead of namespaces or internal
    modules) is that after declaring all our modules, we will not import them using
    an HTML `<script>` tag. Using the `<script>` tag is not recommended, because web
    browsers "halt" (or "freeze") simultaneous downloads and rendering of the page
    when they encounter and load the contents of a `<script>` tag.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块（而不是命名空间或内部模块）与使用命名空间或内部模块的主要区别是，在声明了所有模块之后，我们不会使用HTML `<script>`标签来导入它们。使用`<script>`标签是不推荐的，因为当网络浏览器遇到并加载`<script>`标签的内容时，它们会“暂停”（或“冻结”）页面的同时下载和渲染。
- en: We will discover more about network performance in [Chapter 13](2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml),
    *Application Performance*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第13章[应用性能](2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml)中了解更多关于网络性能的内容。
- en: External modules avoid loading the modules of our application using the `<script>`
    and use a module loader instead. A **module loader** is a tool that allows us
    to have better control over the module loading process. This allows us to perform
    tasks such as loading files asynchronously or combining multiple modules into
    a single highly optimized file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 外部模块避免使用 `<script>` 加载我们的应用程序模块，而是使用模块加载器。**模块加载器**是一种工具，它允许我们更好地控制模块加载过程。这使我们能够执行异步加载文件或合并多个模块到一个高度优化的单个文件等任务。
- en: 'Several module definition syntaxes have been proposed over the years by different
    open source projects due to the lack of native support for external modules in
    JavaScript:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中外部模块缺乏原生支持，多年来不同的开源项目提出了多种模块定义语法：
- en: '| **Module definition syntax** | **Notes** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **模块定义语法** | **注意事项** |'
- en: '| AMD | Introduced by the RequireJS module loader |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| AMD | 由 RequireJS 模块加载器引入 |'
- en: '| CommonJS | Introduced by Node.js |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| CommonJS | 由 Node.js 引入 |'
- en: '| UMD | Supports both AMD and UMD |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| UMD | 支持AMD和UMD |'
- en: '| SystemJS | Introduced by Angular 2, supports multiple syntaxes |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| SystemJS | 由 Angular 2 引入，支持多种语法 |'
- en: '| ES6 modules | Introduced by the ECMAScript 6 specification |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| ES6模块 | 由 ECMAScript 6 规范引入 |'
- en: 'We can also encounter a wide variety of module loaders:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能遇到各种各样的模块加载器：
- en: '| **Module loader** | **Module definition syntax** | **Notes** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **模块加载器** | **模块定义语法** | **注意事项** |'
- en: '| RequireJS | AMD | RequireJS was the very first mainstream module loader for
    JavaScript applications |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| RequireJS | AMD | RequireJS 是 JavaScript 应用程序的第一个主流模块加载器 |'
- en: '| Browserify | CommonJS | CommonJS modules were introduced by the original
    Node.js module system, but today Node.js supports ES6 modules natively |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| Browserify | CommonJS | CommonJS 模块最初由 Node.js 的原始模块系统引入，但如今Node.js原生支持ES6模块
    |'
- en: '| SystemJS | Supports multiple module definition syntaxes | Supports multiple
    module definition syntaxes |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| SystemJS | 支持多种模块定义语法 | 支持多种模块定义语法 |'
- en: '| Native | ES6 | Modern JavaScript engines can support ES6 modules natively
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 本地 | ES6 | 现代JavaScript引擎可以原生支持ES6模块 |'
- en: External modules at design time and runtime
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计时和运行时的外部模块
- en: TypeScript adds a layer of choice, because it allows us to choose which module
    definition syntax we want to use at design time and which one we want to use at
    runtime. In a landscape with so many options, it is very easy to feel overwhelmed
    and confused.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 增加了一层选择，因为它允许我们在设计时选择我们想要使用的模块定义语法，以及我们想要在运行时使用的语法。在如此多的选项中，很容易感到不知所措和困惑。
- en: 'Fortunately, only two module definition syntaxes are available at design time
    in TypeScript, and one of them is considered deprecated:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 TypeScript 中，设计时只有两种模块定义语法可用，其中一种被认为是过时的：
- en: The legacy external module syntax (deprecated)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的外部模块语法（已过时）
- en: The ES6 module syntax (recommended)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6模块语法（推荐）
- en: It is also possible to use other module definition syntaxes at runtime, such
    as the AMD or the UMD syntaxes, but the TypeScript compiler will not try to compile
    them into the selected module definition output.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，也可以使用其他模块定义语法，例如AMD或UMD语法，但TypeScript编译器不会尝试将它们编译成选定的模块定义输出。
- en: 'TypeScript allows us to choose which kind of module definition syntax will
    be used at runtime:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许我们选择在运行时使用哪种类型的模块定义语法：
- en: ES6
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6
- en: CommonJS
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS
- en: AMD
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD
- en: SystemJS
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SystemJS
- en: UMD
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMD
- en: 'We can indicate our preference by using the `--module` flag when compiling,
    as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在编译时使用 `--module` 标志来表示我们的偏好，如下所示：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It is important to understand that the kind of module definition syntax used
    at design time and the one used at runtime can be different.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，设计时和运行时使用的模块定义语法可能不同。
- en: Since the release of TypeScript 1.5, it has been recommended to use the ECMAScript
    6 module definition syntax, because it is based on the ECMAScript specification,
    which is considered a standard. Additionally, if we are planning to run our TypeScript
    application in a modern JavaScript engine, we will be able to use the ECMAScript
    6 module definition syntax at both design time and runtime.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 自 TypeScript 1.5 版本发布以来，建议使用 ECMAScript 6 模块定义语法，因为它基于 ECMAScript 规范，这被认为是一个标准。此外，如果我们计划在现代JavaScript引擎中运行我们的TypeScript应用程序，我们将在设计时和运行时都能使用
    ECMAScript 6 模块定义语法。
- en: We will now look at each of the available module definition syntaxes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看每种可用的模块定义语法。
- en: ES6 modules (runtime and design time)
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6模块（运行时和设计时）
- en: 'TypeScript 1.5 introduced support for the ES6 module syntax. The following
    code snippet defines an external module using the ES6 module syntax:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 1.5 引入了对 ES6 模块语法的支持。以下代码片段使用 ES6 模块语法定义了一个外部模块：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We don''t need to use the `namespace` keyword to declare an ES6 module, but
    we must use the `export` keyword. We can use the `export` keyword at the bottom
    of the module or when an entity is declared:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要使用 `namespace` 关键字来声明 ES6 模块，但我们必须使用 `export` 关键字。我们可以在模块底部或实体声明时使用 `export`
    关键字：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also export an entity using an alias:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用别名导出实体：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An export declaration exports all meanings of a name:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 导出声明导出名称的所有含义：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To import a module from another module, we must use the `import` keyword as
    follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要从另一个模块导入模块，我们必须使用 `import` 关键字，如下所示：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `import` keyword creates a variable for each imported component. In the
    preceding code snippet, a new variable named `UserModel` is declared, and its
    value contains a reference to the `UserModel` class, which is declared and exported
    by the imported module (the `model.ts` file).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 关键字为每个导入的组件创建一个变量。在前面的代码片段中，声明了一个名为 `UserModel` 的新变量，其值包含对导入模块（`model.ts`
    文件）中声明的 `UserModel` 类的引用。'
- en: 'We can use the `export` keyword to export multiple entities, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `export` 关键字导出多个实体，如下所示：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Furthermore, we can use the `import` keyword to import multiple entities from
    a single module, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用 `import` 关键字从单个模块导入多个实体，如下所示：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we can also use the `default` keyword to declare the default entity
    to be imported when no explicit entities are imported:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以使用 `default` 关键字来声明在没有明确导入实体时将被导入的默认实体：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can then import the default export as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以如下导入默认导出：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ES6 modules work natively on modern JavaScript engines, but if you are targeting
    a JavaScript engine that doesn't support ES6 modules, you will need to use a tool
    such as webpack to enable backward compatibility with previous JavaScript engines.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 模块在现代 JavaScript 引擎上原生支持，但如果你的目标是那些不支持 ES6 模块的 JavaScript 引擎，你需要使用像 webpack
    这样的工具来启用与先前 JavaScript 引擎的向后兼容性。
- en: Legacy external modules (design time only)
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧版外部模块（仅设计时使用）
- en: Before TypeScript 1.5, external modules were declared using a specific design-time
    syntax. However, once compiled into JavaScript, modules were transformed into
    AMD, CommonJS, UMD, or SystemJS modules.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 1.5 之前，外部模块使用特定的设计时语法声明。然而，一旦编译成 JavaScript，模块会被转换成 AMD、CommonJS、UMD
    或 SystemJS 模块。
- en: We should **try to avoid using the legacy external module syntax and use the
    new ES6 syntax instead**. However, we will take a quick look at the external module
    syntax, because it is still possible to face it sometimes in old applications
    and documentation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该**尽量避免使用旧版外部模块语法，而使用新的 ES6 语法**。然而，我们将快速浏览外部模块语法，因为有时在旧应用程序和文档中仍然可能会遇到它。
- en: 'To export a module using the legacy external module syntax, we need to use
    the `export` keyword. We can apply the `export` keyword directly to a class or
    interface as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用旧版外部模块语法导出模块，我们需要使用 `export` 关键字。我们可以直接将 `export` 关键字应用于类或接口，如下所示：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can also use the `export` keyword on its own by assigning to it the value
    that we desire to export:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将其值赋给 `export` 来单独使用 `export` 关键字，我们希望导出该值：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: External modules can be compiled into any of the available module definition
    syntaxes (AMD, CommonJS, SystemJS, or UMD).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 外部模块可以被编译成任何可用的模块定义语法（AMD、CommonJS、SystemJS 或 UMD）。
- en: 'The legacy external module syntax `import` statements look as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版外部模块的 `import` 语句如下所示：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: AMD modules (runtime only)
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AMD 模块（仅运行时使用）
- en: 'If we compile the external module that we defined in the ES6 modules section
    into an AMD module (using the flag `--compile amd`), we will generate the following
    AMD module:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 ES6 模块部分中定义的外部模块编译成 AMD 模块（使用标志 `--compile amd`），我们将生成以下 AMD 模块：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `define` function takes an array as its first argument. This array contains
    a list of the names of the module dependencies. The second argument is a callback
    that will be invoked once all the module dependencies have been loaded. The callback
    takes each of the module dependencies as its parameters and contains all the logic
    from our TypeScript component. Notice how the return type of the callback matches
    the components that we declared as public by using the `export` keyword.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`define`函数将其第一个参数作为一个数组。这个数组包含模块依赖项的名称列表。第二个参数是一个回调函数，一旦所有模块依赖项都已加载，它就会被调用。回调函数将每个模块依赖项作为其参数，并包含我们TypeScript组件的所有逻辑。注意回调函数的返回类型与使用`export`关键字声明的公共组件相匹配。'
- en: 'TypeScript will throw a compilation error because the `define` function is
    not declared. We can solve this problem by installing the RequireJS type definitions:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript会因为`define`函数未声明而抛出编译错误。我们可以通过安装RequireJS类型定义来解决此问题：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The AMD module can then be loaded using the RequireJS module loader as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用RequireJS模块加载器按如下方式加载AMD模块：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As we can observe, AMD modules use two different functions to define modules
    (`define`) and consume modules (`require`). Usually, the application entry point
    uses the require function to load all the required dependencies.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所观察到的，AMD模块使用两个不同的函数来定义模块（`define`）和消费模块（`require`）。通常，应用程序的入口点使用`require`函数来加载所有必需的依赖项。
- en: We will not discuss AMD and RequireJS further in this book, but if you want
    to learn more about it, you can do so by visiting [http://requirejs.org/docs/start.html](http://requirejs.org/docs/start.html).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将不会进一步讨论AMD和RequireJS，但如果你想要了解更多，你可以通过访问[http://requirejs.org/docs/start.html](http://requirejs.org/docs/start.html)来学习。
- en: CommonJS modules (runtime only)
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS模块（仅运行时）
- en: 'If we compile the external module that we defined in the ES6 modules section
    into an CommonJS module (using the flag `--compile commonjs`), we will obtain
    the following CommonJS module:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将ES6模块部分中定义的外部模块编译成CommonJS模块（使用标志`--compile commonjs`），我们将获得以下CommonJS模块：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we can see in the preceding code snippet, the CommonJS module definition
    syntax is almost identical to that of the legacy external module syntax. The main
    difference is the usage of the `module` object and its `exports` property instead
    of the `exports` keyword.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以在前面的代码片段中看到的那样，CommonJS模块定义语法几乎与遗留的外部模块语法相同。主要区别在于使用`module`对象及其`exports`属性而不是`exports`关键字。
- en: 'The preceding CommonJS module can be loaded natively by a Node.js application
    using the `import` keyword and the `require` function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的CommonJS模块可以通过Node.js应用程序使用`import`关键字和`require`函数原生加载：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: However, if we attempt to use the `require` function in a web browser, an exception
    will be thrown because the `require` function is undefined. We can easily solve
    this problem by using Browserify. Browserify is a module loader that allows us
    to use CommonJS modules in a web browser.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试在浏览器中使用`require`函数，将会抛出异常，因为`require`函数未定义。我们可以通过使用Browserify轻松解决这个问题。Browserify是一个模块加载器，它允许我们在浏览器中使用CommonJS模块。
- en: If you need more information about Browserify, visit the official documentation
    at [https://github.com/substack/node-browserify#usage](https://github.com/substack/node-browserify#usage).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于Browserify的信息，请访问官方文档[https://github.com/substack/node-browserify#usage](https://github.com/substack/node-browserify#usage)。
- en: UMD modules (runtime only)
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMD模块（仅运行时）
- en: If we want to release a JavaScript library or framework, we will need to compile
    our TypeScript application into both CommonJS and AMD modules, as well as compile
    in a way that it can be used by developers who don't want to use a module loader.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要发布一个JavaScript库或框架，我们需要将我们的TypeScript应用程序编译成CommonJS和AMD模块，并且以开发者不使用模块加载器也能使用的方式编译。
- en: 'The web development community has developed the following code snippet to help
    us to achieve UMD support:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发社区已经开发了一个代码片段来帮助我们实现UMD支持：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding code snippet is great, but we want to avoid manually adding it
    to every single module in our application. Fortunately, there are a few options
    available to achieve UMD support with ease.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段很棒，但我们希望避免手动将其添加到应用程序的每个模块中。幸运的是，有一些选项可以轻松实现UMD支持。
- en: The first option is to use the flag `--compile umd` to generate one UMD module
    for each module in our application. The second option is to create one single
    UMD module that will contain all the modules in the application using a module
    loader such as Browserify.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择是使用标志 `--compile umd` 为我们应用程序中的每个模块生成一个 UMD 模块。第二种选择是创建一个包含应用程序中所有模块的单个
    UMD 模块，使用模块加载器（如 Browserify）。
- en: Refer to the official Browserify project website at [http://browserify.org/](http://browserify.org/)
    to learn more about Browserify. Refer to the `Browserify-standalone` option to
    learn more about the generation of one unique optimized file.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Browserify 的更多信息，请参阅官方项目网站 [http://browserify.org/](http://browserify.org/)。有关生成单个优化文件的
    `Browserify-standalone` 选项的更多信息，请参阅。
- en: SystemJS modules (runtime only)
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SystemJS 模块（仅运行时）
- en: While UMD gives you a way to output a single module that works in both AMD and
    CommonJS, SystemJS will allow you to use ES6 modules closer to their native semantics
    without requiring an ES6-compatible browser engine.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 UMD 提供了一种在 AMD 和 CommonJS 中都工作的单个模块的输出方式，但 SystemJS 将允许你更接近其原生语义地使用 ES6 模块，而无需使用兼容
    ES6 的浏览器引擎。
- en: SystemJS was introduced by Angular 2.0, which is a popular web application development
    framework.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: SystemJS 是由 Angular 2.0 引入的，它是一个流行的 Web 应用程序开发框架。
- en: Refer to the official SystemJS project website at [https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)
    to learn more about SystemJS.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 SystemJS 的更多信息，请参阅官方项目网站 [https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)。
- en: There is a free list of common module mistakes available online at [http://www.typescriptlang.org/Handbook#modules-pitfalls-of-modules](http://www.typescriptlang.org/Handbook#modules-pitfalls-of-modules).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有免费的常见模块错误列表，可在 [http://www.typescriptlang.org/Handbook#modules-pitfalls-of-modules](http://www.typescriptlang.org/Handbook#modules-pitfalls-of-modules)
    查找。
- en: Modules summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块总结
- en: 'We can summarize all the preceding details using the following comparison table:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下比较表总结所有前面的细节：
- en: '| **Module syntax** | **Design-time support** | **Module loader runtime support**
    | **Native runtime support** | **Optimization tool support** | **Recommended**
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **Module syntax** | **设计时支持** | **模块加载器运行时支持** | **原生运行时支持** | **优化工具支持**
    | **推荐** |'
- en: '| **Legacy internal modules** | Yes | No | Yes (via closures) | No | No |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **Legacy internal modules** | Yes | No | Yes (via closures) | No | No |'
- en: '| **Namespaces** | Yes | No | Yes (via closures) | No | No |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **Namespaces** | Yes | No | Yes (via closures) | No | No |'
- en: '| **ES6** | **Yes** | **Yes** | **Yes** | **Yes** | **Yes** |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **ES6** | **Yes** | **Yes** | **Yes** | **Yes** | **Yes** |'
- en: '| **Legacy external modules** | Yes | Yes | No | Yes | No |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **Legacy external modules** | Yes | Yes | No | Yes | No |'
- en: '| **AMD** | No | Yes | No | Yes | No |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **AMD** | No | Yes | No | Yes | No |'
- en: '| **CommonJS** | No | Yes | No | Yes | No |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **CommonJS** | No | Yes | No | Yes | No |'
- en: '| **UMD** | No | Yes | No | Yes | No |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **UMD** | No | Yes | No | Yes | No |'
- en: '| **SystemJS** | No | Yes | No | Yes | No |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **SystemJS** | No | Yes | No | Yes | No |'
- en: As we can see, **the recommended solution going forward is the usage of ES6
    modules**. If you are targeting a JavaScript engine that doesn't support ES6 modules,
    you will need to use a tool such as webpack to enable backward compatibility with
    previous JavaScript engines.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，**未来推荐的做法是使用 ES6 模块**。如果你针对的是不支持 ES6 模块的 JavaScript 引擎，你需要使用像 webpack
    这样的工具来实现与先前 JavaScript 引擎的向后兼容性。
- en: We will learn more about Webpack in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 9 章 *自动化您的开发工作流程* 中学习更多关于 Webpack 的知识。
- en: Managing dependencies in OOP
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在面向对象编程中管理依赖
- en: We have learned how to work with application dependencies and third-party dependencies.
    We will now learn about the dependency inversion and extend what we learned in
    the previous chapter about the dependency inversion principle.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何处理应用程序依赖和第三方依赖。现在，我们将学习依赖倒置，并扩展前一章中关于依赖倒置原则的知识。
- en: Dependency injection versus dependency inversion
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入与依赖倒置
- en: Many articles use the terms *dependency injection* and *dependency inversion* as
    if their meanings were identical, but they are two very different concepts.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 许多文章将 *依赖注入* 和 *依赖倒置* 两个术语混为一谈，好像它们的含义相同，但实际上它们是两个非常不同的概念。
- en: 'The following example declares a class named `Ninja` and a class named `Katana`.
    The `Ninja` class has a dependency on the class `Katana`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例声明了一个名为 `Ninja` 的类和一个名为 `Katana` 的类。`Ninja` 类依赖于 `Katana` 类：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After declaring the preceding classes, we can inject an instance of `Katana`
    into the `Ninja` class:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明上述类之后，我们可以将`刀剑`类的实例注入到`忍者`类中：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding code snippet implements the dependency injection design pattern
    because we are injecting a dependency (`Katana`) into the `Ninja` class. However,
    we are not implementing the dependency inversion principle because the `Ninja`
    class has a direct dependency on the `Katana` class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段实现了依赖注入设计模式，因为我们正在将依赖项（`刀剑`）注入到`忍者`类中。然而，我们没有实现依赖倒置原则，因为`忍者`类直接依赖于`刀剑`类。
- en: 'The relationship between the `Ninja` class and the `Katana` class can be represented
    using the following diagram:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`忍者`类和`刀剑`类之间的关系可以用以下图表表示：'
- en: '***Ninja → Katana***'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '***忍者 → 刀剑***'
- en: 'The following code snippet declares an interface named `Weapon`, which is then
    implemented by the `Katana` class. This time, the `Ninja` class has a dependency
    on the `Weapon` interface instead of the `Katana` class:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为 `Weapon` 的接口，然后由 `刀剑` 类实现。这次，`忍者` 类依赖于 `Weapon` 接口而不是 `刀剑` 类：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After declaring the preceding classes, we can inject an instance of `Katana`
    into the `Ninja` class:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明上述类之后，我们可以将`刀剑`类的实例注入到`忍者`类中：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The preceding code snippet implements the dependency injection design pattern
    because we are injecting a dependency (`Katana`) into the `Ninja` class. It also
    implements the dependency inversion principle because the `Ninja` class does not
    have a direct dependency on the `Katana` class.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段实现了依赖注入设计模式，因为我们正在将依赖项（`刀剑`）注入到`忍者`类中。它还实现了依赖倒置原则，因为`忍者`类不直接依赖于`刀剑`类。
- en: 'This time, the relationship between the classes can be represented using the
    following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，类之间的关系可以用以下方式表示：
- en: '***Ninja → Weapon ← Katana***'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '***忍者 → 武器 ← 刀剑***'
- en: As we can see, the arrow that represents the relationship between the `Ninja`
    and the `Katana` classes has been inverted. This explains the name of the dependency
    inversion principle.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，表示`忍者`和`刀剑`类之间关系的箭头已经被反转。这解释了依赖倒置原则名称的由来。
- en: The dependency inversion principle is important because it makes our code easier
    to maintain by reducing the level of coupling between the entities in our application.
    For example, if we rename the `Katana` class, we will not need to change the `Ninja`
    class. This means that the `Katana` and the `Ninja` classes are fully independent
    of each other.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则很重要，因为它通过减少我们应用程序中实体之间的耦合程度，使我们的代码更容易维护。例如，如果我们重命名`刀剑`类，我们就不需要更改`忍者`类。这意味着`刀剑`和`忍者`类之间是完全独立的。
- en: Inversion of control containers
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制反转容器
- en: An **inversion of control** (**IoC**) container is a kind of tool that acts
    as a *smart factory*. An IoC container can be used to create instances of a class.
    If the class has some dependencies, the IoC container will be able to use dependency
    injection to cover the need for them. We say that the factory is *smart* because
    it can create dependencies based on matching conditions in the execution context
    and it can also control the life cycle of the instances that it creates.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转（**inversion of control**，**IoC**）容器是一种充当**智能工厂**的工具。IoC容器可以用来创建类的实例。如果类有一些依赖项，IoC容器将能够使用依赖注入来满足这些需求。我们说工厂是**智能**的，因为它可以根据执行上下文中的匹配条件创建依赖项，并且还可以控制它所创建的实例的生命周期。
- en: When we use an IoC container, we are *losing control* of the creation of class
    instances, and the injection of dependencies and the IoC container will take control
    of these aspects of our application. This fact should explain the meaning of the
    term *inversion of control*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 IoC 容器时，我们正在**失去**对类实例创建的控制，依赖注入和 IoC 容器将接管这些方面的应用控制。这一事实应该解释了术语**控制反转**的含义。
- en: InversifyJS basics
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InversifyJS 基础
- en: InversifyJS is an IoC container for TypeScript applications. InversifyJS can
    be used to implement the dependency inversion principle.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: InversifyJS 是一个用于 TypeScript 应用程序的 IoC 容器。InversifyJS 可以用来实现依赖倒置原则。
- en: 'To use InversifyJS, we need to install it using npm as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 InversifyJS，我们需要使用 npm 安装它，如下所示：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can then import some of the entities declared by `inversify` and `reflect-metadata`
    as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以导入由 `inversify` 和 `reflect-metadata` 声明的一些实体，如下所示：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following code snippet adds an annotation to the `Ninja` class using the
    `inject` decorator:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用 `inject` 装饰器在 `忍者` 类上添加了一个注解：
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To create an instance of `Ninja` using InversifyJS, we need to create an instance
    of the `Container` class and declare what is known as **type binding**. A type
    binding is a link between a type and an implementation of that type. The following
    code snippet declares two type bindings. The first type binding links the type
    `Weapon` with the implementation `Katana`. The second type binding links the type
    `Ninja` to itself:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用InversifyJS创建`Ninja`类的实例，我们需要创建`Container`类的实例并声明所谓的**类型绑定**。类型绑定是类型与其实现之间的链接。以下代码片段声明了两个类型绑定。第一个类型绑定将类型`Weapon`与实现`Katana`关联起来。第二个类型绑定将类型`Ninja`与其自身关联：
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can then create instances of the `Ninja` class using the container. The
    container uses the annotation to identify that the `Ninja` class has a dependency
    on the `Weapon` type. The container then creates an instance of the `Katana` class
    and is injected into the `Ninja` class because it knows that the `Katana` class
    is a valid implementation of the `Weapon` interface:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用容器创建`Ninja`类的实例。容器使用注解来识别`Ninja`类依赖于`Weapon`类型。然后容器创建`Katana`类的实例，并将其注入到`Ninja`类中，因为它知道`Katana`类是`Weapon`接口的有效实现：
- en: '[PRE56]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'InversifyJS also allows us to control the life cycle of the dependencies. For
    example, we can configure the `Katana` type binding to make all instances a single
    shared instance (singleton):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: InversifyJS还允许我们控制依赖项的生命周期。例如，我们可以配置`Katana`类型绑定，使所有实例都成为单个共享实例（单例）：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can also configure complex runtime constraints, which will determine how
    dependencies are resolved. For example, we could have two implementations of `Weapon`
    that are injected in different circumstances:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以配置复杂的运行时约束，这将决定依赖项如何解析。例如，我们可能有两种不同的`Weapon`实现，它们在不同的环境下被注入：
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Circular dependencies
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环依赖
- en: 'A circular dependency is an issue that we can encounter when working with multiple
    components and dependencies. Sometimes it is possible to reach a point in which
    one component (A) has a dependency on a second component (B), which depends on
    the first component (A). In the following diagram, each node is a component, and
    we can observe that the nodes **circular1.ts** and **circular2.ts** (in red) have
    a circular dependency. The nodes without dependencies are displayed in green,
    and those with dependencies but no issues are displayed in blue:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与多个组件和依赖项一起工作时，可能会遇到循环依赖的问题。有时可能会达到一个点，其中一个组件（A）依赖于第二个组件（B），而这个第二个组件（B）又依赖于第一个组件（A）。在以下图中，每个节点是一个组件，我们可以观察到节点**circular1.ts**和**circular2.ts**（用红色表示）存在循环依赖。没有依赖的节点以绿色显示，有依赖但没有问题的节点以蓝色显示：
- en: '![](img/2abf1609-4a3d-41de-8296-5c408b103420.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2abf1609-4a3d-41de-8296-5c408b103420.png)'
- en: The circular dependencies don't necessarily need to involve just two components.
    We can encounter scenarios in which a component depends on another component,
    which depends on other components, and some of the components in the dependency
    tree end up pointing to one of their parent components in the tree. InversifyJS
    will throw a runtime exception if a circular dependency is detected.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖不一定只涉及两个组件。我们可能会遇到这样的情况：一个组件依赖于另一个组件，而这个被依赖的组件又依赖于其他组件，依赖树中的一些组件最终会指向树中的某个父组件。如果InversifyJS检测到循环依赖，它将抛出一个运行时异常。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the basics about managing third-party dependencies.
    We also learned the differences between internal and external modules, and each
    of the main kinds of modules in each of these categories.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了管理第三方依赖项的基础知识。我们还学习了内部模块和外部模块之间的区别，以及每个类别中的主要模块类型。
- en: We also learned how to work with dependencies in object-oriented programming.
    Finally, we learned how to implement dependency injection and how to work with
    IoC containers.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何在面向对象编程中处理依赖项。最后，我们学习了如何实现依赖注入以及如何与IoC容器一起工作。
- en: In the next chapter, we will learn about the TypeScript/JavaScript runtime.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习TypeScript/JavaScript的运行时。
