- en: Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: When you're developing an application, it will eventually form a structure and
    evolve into a stable product that you can use in production and sell to your customers.
    In the beginning, everything may seem simple and many tend to postpone the construction
    of a proper test suite.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发应用程序时，它最终会形成一个结构，并演变成为一个可以用于生产并出售给客户的稳定产品。一开始，一切可能看起来都很简单，许多人倾向于推迟构建合适的测试套件。
- en: '"Debugging is twice as hard as writing the code in the first place."'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “调试是编写代码的两倍困难。”
- en: '*—Brian W. Kernighan and P. J. Plauger in* The Elements of Programming Style'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*——布赖恩·W·克尼汉和P. J.普劳格在《程序设计风格要素》一书中*'
- en: Later on, the application may become just sufficiently complex for you to hesitate
    to begin testing. You may eventually give up and never test your application.
    It may be frustrating, especially if you have never seen or used any test suite
    before.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，应用程序可能会变得足够复杂，以至于你犹豫是否开始测试。你可能会最终放弃，不再测试你的应用程序。这可能令人沮丧，尤其是如果你以前从未见过或使用过任何测试套件。
- en: 'Proper testing gives you more than a little bit of quality assurance. Proper
    testing gives you:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的测试不仅能提供一定程度的质量保证，还能提供：
- en: '**Predictability**: This means that your code execution, no matter if it''s
    an application or just a module, will have an expected result. As you evolve the
    tests and introduce different test cases, you begin to fulfill all the uses for
    your code, and you ensure its results were as intended.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测性**：这意味着无论你的代码执行是应用程序还是只是一个模块，都将有一个预期的结果。随着你完善测试并引入不同的测试用例，你开始满足代码的所有用途，并确保其结果符合预期。'
- en: '**Feature coverage**: This means that you can measure what parts of your code
    are tested or not. There are plenty of tools to inspect your code and tell you
    what parts of it haven''t been used in your test suite, which helps you create
    specific tests for specific parts of the code that are not yet covered.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能覆盖率**：这意味着你可以衡量你的代码哪些部分被测试了，哪些没有。有许多工具可以检查你的代码并告诉你哪些部分在你的测试套件中没有使用，这有助于你为尚未覆盖的代码的特定部分创建特定的测试。'
- en: '**Safe evolution**: This is a side effect. When your code gets complex, if
    your test suite has good code coverage, you can make changes and add features
    without compromising stability, as you can continuously run the test suite and
    see if it breaks anything.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全演变**：这是一个副作用。当你的代码变得复杂时，如果你的测试套件有良好的代码覆盖率，你可以在不损害稳定性的情况下进行更改和添加功能，因为你可以持续运行测试套件并查看是否有任何东西被破坏。'
- en: There's a developing methodology that involves first creating a test for a new
    feature and then making sure the test passes. This way, you can focus on how you
    think your code should be used (in the new test) and then evolve it (actually
    develop it) so the test stops failing and gives proper results.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正在发展中的方法包括首先为新的功能创建一个测试，然后确保测试通过。这样，你可以专注于你认为你的代码应该如何被使用（在新的测试中），然后逐步完善它（实际上开发它），以便测试不再失败并给出正确的结果。
- en: Let's see how code coverage can help in the testing process. Finally, we'll
    look at how you can mock parts of your code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码覆盖率如何在测试过程中发挥作用。最后，我们将探讨如何模拟代码的一部分。
- en: Integrating tests
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'We will create our first integration tests. Each of our tests will run separately,
    meaning they should not depend on any other test and should follow a predictable
    workflow. First, we need to change our `run.js` file to run all test files. For
    that, we''ll use `mocha` and add all files found in the `integration` folder:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建我们的第一个集成测试。我们的每个测试都将单独运行，这意味着它们不应该依赖于任何其他测试，并且应该遵循可预测的工作流程。首先，我们需要更改`run.js`文件以运行所有测试文件。为此，我们将使用`mocha`并添加在`integration`文件夹中找到的所有文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, let''s create the `integration` folder inside our `test` folder, and
    let''s create our first test file, called `image-upload.js`. Add this content
    to the file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们在`test`文件夹内创建一个名为`integration`的文件夹，并创建我们的第一个测试文件，命名为`image-upload.js`。将以下内容添加到文件中：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we now run the tests again, we should see the default `mocha` response with
    no tests passing and no tests failing:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次运行测试，我们应该看到默认的`mocha`响应，没有测试通过，也没有测试失败：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To avoid repeating code, let''s create a `tools.js` file inside the `test`
    folder, so we can export common tasks that every test file can use. Out of the
    box, I''m thinking about our microservice location and a sample image:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免代码重复，让我们在`test`文件夹内创建一个`tools.js`文件，这样我们就可以导出每个测试文件都可以使用的常见任务。开箱即用，我想到的是我们的微服务位置和一个示例图像：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create a `sample.png` image in the `test` folder. When a test needs to upload
    an image, it will use that sample. In the future, we could have different kinds
    of samples, such as huge images, to test performance and limitations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test`文件夹中创建一个`sample.png`图片。当测试需要上传图片时，它将使用这个样本。将来，我们可能会有不同类型的样本，例如大图片，以测试性能和限制。
- en: Using chai
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用chai
- en: 'We also need to make a little change to our microservice. We need to export
    its app so that the HTTP plugin from `chai` can load it and were able to test
    it without the need to run in a separate console. Add this to the end of our microservice
    file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对我们的微服务做一些小的改动。我们需要导出它的应用，这样`chai`的HTTP插件就可以加载它，我们可以在不运行在单独的控制台的情况下对其进行测试。将以下内容添加到我们的微服务文件末尾：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should have a folder hierarchy similar to the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该有一个类似于以下截图的文件夹层次结构：
- en: '![](img/618c9422-7b6e-4442-80be-bcda48e204ec.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/618c9422-7b6e-4442-80be-bcda48e204ec.png)'
- en: 'We should now change our `image-upload.js` test file to create our first real
    test:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该将我们的`image-upload.js`测试文件更改为创建我们的第一个真实测试：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We start by first including the `chai` modules and our `tools` file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包括`chai`模块和我们的`tools`文件：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we describe our test file as `Uploading image`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将我们的测试文件描述为`上传图片`：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We'll add the different use cases we can think of, related to the uploading
    of images.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加我们可以想到的不同用例，与图片上传相关。
- en: 'Inside, we use `beforeEach`, which is a `mocha` method that will be called
    before every test in this file. Remember, we want our tests to be consistent,
    so we add this method to remove our image before running every test. We don''t
    care whether the image exists:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，我们使用`beforeEach`，这是一个`mocha`方法，将在文件中的每个测试之前被调用。记住，我们希望我们的测试是一致的，所以我们添加这个方法在运行每个测试之前删除我们的图片。我们不在乎图片是否存在：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Look how we use the `tools.service`, which points to our microservice. If, later
    on, we change the name or somehow make it more complex, we just need to change
    the `tools` file, and everything should work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何使用`tools.service`，它指向我们的微服务。如果我们以后更改名称或使其更复杂，我们只需更改`tools`文件，一切都应该正常工作。
- en: 'Then, we add our first `integration` file''s test – a simple image upload:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加我们的第一个`integration`文件测试——一个简单的图片上传：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It checks whether the HTTP response code is `200` and if the response body,
    which is a JSON structure, has the status property set to `ok`. And we're done!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查HTTP响应代码是否为`200`，以及响应体，这是一个JSON结构，其状态属性设置为`ok`。我们就完成了！
- en: Let's run our test suite again and see how it goes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行我们的测试套件，看看效果如何。
- en: '![](img/c66ba039-aeab-40c5-b50d-244fbe83dd63.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c66ba039-aeab-40c5-b50d-244fbe83dd63.png)'
- en: Covering all code
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖所有代码
- en: For now, let's focus on adding coverage to our code. It's important to have
    it covered as much as possible when it's still just a small service. If we start
    adding tests and coverage when it's already big, you'll be frustrated, and it
    will be hard to find the motivation to cover it all.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们专注于为我们的代码添加覆盖率。当它仍然只是一个小型服务时，尽可能多地覆盖它很重要。如果我们开始添加测试和覆盖率，而它已经很大了，你会感到沮丧，而且很难找到覆盖所有内容的动力。
- en: This way, you'll find it rewarding to cover it in the beginning and keep the
    coverage percentage as high as possible along with code evolution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你会发现一开始就覆盖它并尽可能保持覆盖率百分比很高是很有回报的，同时随着代码的演变。
- en: 'Let''s get back to our image upload test, and add another test:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的图片上传测试，并添加另一个测试：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will upload the same image twice in a row and we should receive an error
    from the database saying there''s a duplicate. Let''s run the tests again:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连续上传同一张图片两次，我们应该从数据库收到一个错误，表示有重复。让我们再次运行测试：
- en: '![](img/57c1f00d-fe1e-45eb-9108-2e0099655ebd.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57c1f00d-fe1e-45eb-9108-2e0099655ebd.png)'
- en: 'Now, let''s open the initial page  of the coverage report:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开覆盖率报告的初始页面：
- en: '![](img/0dea63b8-dc21-4397-8f1d-578c481602a3.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0dea63b8-dc21-4397-8f1d-578c481602a3.png)'
- en: 'Notice that our file is no longer in a red background. This means the statement
    coverage has reached *50%*. Let''s click on our file and see how our image upload
    method is covered:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的文件不再在红色背景中。这意味着语句覆盖率达到了*50%*。让我们点击我们的文件，看看我们的图片上传方法是如何被覆盖的：
- en: '![](img/cac710e1-c7a0-4606-baab-c61c84cce671.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cac710e1-c7a0-4606-baab-c61c84cce671.png)'
- en: 'It''s complete! We can now move on. Just a reminder before we move to another
    method: having full coverage does not mean there are no bugs. That''s something
    you need to understand. You might have a use case that you''re not expecting,
    and so, you have no code for it, so there''s no obvious coverage.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！我们现在可以继续了。在我们转向另一种方法之前，提醒一下：完全覆盖并不意味着没有错误。这是你需要理解的事情。你可能有一个你未预料到的用例，因此没有为它编写代码，所以没有明显的覆盖率。
- en: For example, the `bodyparser` module will not limit the type of content. If
    we upload a text file with an image name on it, our code will accept it and store
    it in the database without noticing. Think of this use case as your homework,
    and try to create a test to cover that use case and then fix the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`bodyparser`模块不会限制内容的类型。如果我们上传一个带有图像名称的文本文件，我们的代码将接受它并将其存储在数据库中而不会注意到。将这个用例视为你的作业，并尝试创建一个测试来覆盖这个用例，然后修复代码。
- en: 'Let''s move to the next method we see after our upload method: the image check
    on *line 67*. Let''s create a new integration test file called `image-check.js`,
    and add a simple test:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到我们在上传方法之后看到的下一个方法：第67行的图像检查。让我们创建一个新的集成测试文件，命名为`image-check.js`，并添加一个简单的测试：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s run the test suite:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试套件：
- en: '![](img/4309bf36-5162-41b3-befb-d5c6f82a7ab7.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4309bf36-5162-41b3-befb-d5c6f82a7ab7.png)'
- en: 'We can see our console report is getting bigger. As we''re creating new integration
    test files and having a description for each one, `mocha` writes a nice tree view
    showing how the tests run. On the bottom, we can see the coverage report:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的控制台报告正在变大。随着我们创建新的集成测试文件并为每个文件添加描述，`mocha`会写出一个漂亮的树视图，显示测试是如何运行的。在底部，我们可以看到覆盖率报告：
- en: '![](img/bd63eccf-479c-4101-b6ce-333f96949c63.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd63eccf-479c-4101-b6ce-333f96949c63.png)'
- en: Looking at the check method, we see it's now fully covered. This one was very
    simple.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 看着检查方法，我们看到它现在完全覆盖了。这个很简单。
- en: We're still in the middle of statement coverage as our top method; the image
    manipulation one is almost half of our code. This means that when we start covering
    it, the coverage will significantly rise.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在语句覆盖的中间；图像操作的方法几乎占我们代码的一半。这意味着当我们开始覆盖它时，覆盖率将显著提高。
- en: 'Let''s create an `integration` test for it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为它创建一个`integration`测试：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before each test, we're deleting the image (if it exists) and then uploading
    a fresh sample one. Then, for each test, we'll download it and test the output
    according to what we asked for.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试之前，我们都会删除图像（如果存在）然后上传一个新的样本。然后，对于每个测试，我们将下载它并根据我们要求测试输出。
- en: 'Let''s try and run it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行它：
- en: '![](img/280f19a6-d82f-4a90-80d9-90ee36f3d1ab.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/280f19a6-d82f-4a90-80d9-90ee36f3d1ab.png)'
- en: Well, that was unexpected. The test fails because our length check does not
    match. This is actually a good example of something we just notice when we start
    to execute testing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是出乎意料的。测试失败是因为我们的长度检查不匹配。这实际上是我们开始执行测试时刚刚注意到的一个很好的例子。
- en: What happens is that, when we request an image, we use the `sharp` module to
    make any manipulation on the image, according to query parameters. In this case,
    we're not asking for any manipulation, but when we output the image (through `sharp`),
    it actually returns the same image in size, but perhaps with a little bit less
    quality, or maybe it just knows how to better encode our image and remove data
    from the file that is not needed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，当我们请求一个图像时，我们使用`sharp`模块根据查询参数对图像进行任何操作。在这种情况下，我们没有要求任何操作，但当我们通过`sharp`输出图像时，它实际上返回了相同大小的图像，但可能质量略低，或者它可能只是知道如何更好地编码我们的图像并从文件中删除不需要的数据。
- en: 'We don''t know exactly, but let''s assume we want the original image, untouched.
    We need to change our download method. Let''s assume that if no query parameters
    are defined at all, we just return the original image. Let''s add a condition
    to the top of our method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道确切的原因，但假设我们想要原始图像，保持其未受修改的状态。我们需要更改我们的下载方法。假设如果没有定义任何查询参数，我们直接返回原始图像。让我们在我们的方法顶部添加一个条件：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we run  it now, we should have no failures:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行它，我们应该没有失败：
- en: '![](img/352b4409-20b4-4d2e-b195-03270611ab1e.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/352b4409-20b4-4d2e-b195-03270611ab1e.png)'
- en: 'Our statement coverage did not rise much because we actually created a condition
    on top of the method and returned immediately, so our previous method is still
    untested:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的语句覆盖率没有显著提高，因为我们实际上在方法顶部创建了一个条件并立即返回，所以我们的上一个方法仍然未经过测试：
- en: '![](img/31f51911-414b-4152-b68a-182436f3abf6.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31f51911-414b-4152-b68a-182436f3abf6.png)'
- en: Looking at *line 78,* you should see a new mark, an `E` that means that the
    condition in that line never executed the `else` statement, which is the rest
    of our code. Let's add a test to this integration and resize our image.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *第78行*，你应该看到一个新标记，一个`E`，表示该行中的条件从未执行过`else`语句，也就是我们代码的其余部分。让我们为这个集成添加一个测试并调整我们的图片大小。
- en: 'We will need `sharp` to help us check whether the results are correct. Let''s
    include it on the top of our file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要`sharp`来帮助我们检查结果是否正确。让我们将其包含在我们的文件顶部：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, add a resize test:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加一个调整大小的测试：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s run our test suite:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试套件：
- en: '![](img/d947fad9-1cc1-4db9-b3eb-482e75f78d37.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d947fad9-1cc1-4db9-b3eb-482e75f78d37.png)'
- en: 'It now looks very good. From the console report, we can see some green. Let''s
    look at the front page of the coverage report:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来非常好。从控制台报告中，我们可以看到一些绿色。让我们看看覆盖率报告的前页：
- en: '![](img/6581e47d-6b3c-47b5-b3c3-9f70f6f8e583.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6581e47d-6b3c-47b5-b3c3-9f70f6f8e583.png)'
- en: 'We see green here as well. Having more than *80%* coverage is good, but we
    can still go further. Let''s see the file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里也看到了绿色。超过 *80%* 的覆盖率是好的，但我们还可以更进一步。让我们看看文件：
- en: '![](img/e3ff1101-6b82-4765-86ab-f6f784086d7b.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3ff1101-6b82-4765-86ab-f6f784086d7b.png)'
- en: 'It''s more or less covered. We still need to cover all the effects. We can
    actually run them all at once. The first two conditions also have an `E` marker,
    but that should disappear after adding a test without resizing. Let''s add it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 大概已经覆盖了。我们仍然需要覆盖所有的影响。实际上，我们可以一次运行它们所有。前两个条件也有一个`E`标记，但在添加一个不调整大小的测试后应该会消失。让我们添加它：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Looking at our report now, we see the coverage is almost complete:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看我们的报告，我们看到覆盖率几乎已经完成：
- en: '![](img/58b6d4de-05c0-40e3-8df5-50e38d241898.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58b6d4de-05c0-40e3-8df5-50e38d241898.png)'
- en: 'To cover those yellow nulls there, we need to resize the image with only `width`
    or `height`. We can add two tests for those:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了覆盖那些黄色的空值，我们需要仅使用`width`或`height`来调整图片大小。我们可以为这些情况添加两个测试：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a similar one for the `height`, and run the test suite. You should not
    see the statement coverage go up, only the branch coverage:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为`height`添加一个类似的测试，并运行测试套件。你不应该看到语句覆盖率上升，只有分支覆盖率：
- en: '![](img/4f13bae9-3dae-49e6-8f9d-0f27711e67e3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f13bae9-3dae-49e6-8f9d-0f27711e67e3.png)'
- en: 'The only method missing is the statistics method. This one is simple. We could
    eventually run a more specific test, by asking statistics, making a change such
    as an upload, and asking for statistics again to compare. I''ll leave that to
    you. Let''s just add a simple request test:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一缺少的方法是统计方法。这个很简单。我们最终可以通过请求统计信息，进行如上传之类的更改，然后再次请求统计信息来比较来运行一个更具体的测试。我会把这个留给你。我们只需添加一个简单的请求测试：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, running our test suite should give all green:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行我们的测试套件应该会显示所有绿色：
- en: '![](img/d7410c16-009c-45b0-b94e-7630e2685d0d.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7410c16-009c-45b0-b94e-7630e2685d0d.png)'
- en: 'We see there are only two lines uncovered: `29.121`. The first one is our timer
    and the second one is on the statistics method. Let''s refresh our HTML report:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到只有两行未被覆盖：`29.121`。第一行是我们的计时器，第二行是在统计方法上。让我们刷新我们的HTML报告：
- en: '![](img/63b758d2-a4e9-422c-bb9e-815b5e3bb32e.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63b758d2-a4e9-422c-bb9e-815b5e3bb32e.png)'
- en: This is rewarding; we have almost *100%* coverage. There's only one function
    not covered, which is our timer. And, there are only tree statements, which also
    represent the three branches, that aren't covered, but those aren't actually that
    important.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有回报的；我们几乎有 *100%* 的覆盖率。只有一个函数没有被覆盖，那就是我们的计时器。而且，只有三个语句，它们也代表了三个分支，没有被覆盖，但这些实际上并不重要。
- en: What is important is to keep this high coverage mark during the course of our
    development.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是在整个开发过程中保持这个高覆盖率。
- en: Mocking our services
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟我们的服务
- en: It's not at all uncommon to have parts of your service that are harder to test.
    Some, or most, of those parts are error-related conditions, where it's hard to
    make an external service such as a database engine return an error that will rarely
    occur during normal execution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的服务中，有些部分可能更难测试。其中一些，或者大多数，与错误相关的条件有关，在这些条件下，很难让外部服务，如数据库引擎返回在正常执行期间很少发生的错误。
- en: 'To be able to test, or at least simulate these kinds of events, we need to
    mock our services. There are a couple of options around, and Sinon is the most
    commonly used one in the Node.js ecosystem. This framework provides more than
    mocking; it also provides the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够测试，或者至少模拟这些类型的事件，我们需要模拟我们的服务。在这方面有几个选项，而在Node.js生态系统中，Sinon是最常用的一个。这个框架提供了不仅仅是模拟的功能；它还提供了以下功能：
- en: '**Spies**: Which monitor function calls and record arguments passed, the returned value and
    other properties'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间谍（Spies）**：记录哪些监控函数被调用以及传递的参数、返回值和其他属性'
- en: '**Stubs**: Which are enhanced spies with a pre-programmed behavior, helping
    us drive the execution into a pre-determined path (allowing us to mock a behavior)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根（Stubs）**：是增强版的间谍，具有预编程的行为，帮助我们驱动执行进入预定的路径（允许我们模拟行为）'
- en: Sinon also allows us to bend time, by virtually changing the service perception of
    time, and to be able to test timed interval calls (remember our interval timer?).
    With this in mind, let's see if we can make our microservice reach *100%* test
    coverage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon 还允许我们通过虚拟改变服务对时间的感知来弯曲时间，并能够测试定时器间隔调用（记得我们的间隔计时器吗？）。考虑到这一点，让我们看看我们能否使我们的微服务达到
    *100%* 的测试覆盖率。
- en: 'Let''s start by installing the framework, as we did with `chai`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装框架，就像我们之前对 `chai` 做的那样：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s add a test for the image deletion. This method is tested through
    the other tests and that''s why we didn''t need to add it before, but now that
    we want to fully test it, let''s add a basic test file called `image-delete.js`,
    with the following content:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个针对图片删除的测试。这个方法通过其他测试进行了测试，这就是为什么我们之前不需要添加它，但现在我们想要完全测试它，让我们添加一个基本的测试文件
    `image-delete.js`，内容如下：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that I added the Sinon dependency on top, although I'm not using it just
    yet. You may run the tests again, but you shouldn't notice any difference.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我添加了 Sinon 依赖项在顶部，尽管我现在还没有使用它。你可以再次运行测试，但你不应该注意到任何区别。
- en: 'We''ll need to change the database behavior, so let''s export a reference to
    it, so as to be able to access it from the tests. Add the following line in our
    microservice file before connecting to the database:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改数据库的行为，所以让我们导出一个对其的引用，以便在测试中访问它。在我们连接数据库之前，在我们的微服务文件中添加以下行：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, add another test to that file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向该文件添加另一个测试：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What we're doing is uploading an image, but, before requesting to delete it,
    we create a `stub` on the `db.query` method. We then inform Sinon that when the
    `stub` is called with the first argument with `DELETE`, we want it to asynchronously
    call the third argument (counting starts at 0) with a fake error. For any other
    call, we want it to just pass through.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在上传图片，但在请求删除之前，我们在 `db.query` 方法上创建了一个 `stub`。然后我们通知 Sinon，当 `stub` 被带有 `DELETE`
    首个参数调用时，我们希望它异步调用第三个参数（计数从 0 开始）并返回一个假错误。对于任何其他调用，我们希望它直接通过。
- en: Then, after deleting the image, we check that we received an HTTP `500` error
    code and restore the `stub` to the original function, ensuring that the other
    tests pass.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在删除图片之后，我们检查是否收到了 HTTP `500` 错误代码，并将 `stub` 恢复到原始功能，以确保其他测试通过。
- en: We're able to test this because `mocha` runs tests in serial; otherwise, we
    would need to do some gymnastics to ensure that we wouldn't interfere with the
    other tests.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够测试这一点，因为 `mocha` 以串行方式运行测试；否则，我们需要做一些体操来确保我们不会干扰其他测试。
- en: 'Now, open the previously created test file, `image-stats.js`, include Sinon on
    the top, and add the following test:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开之前创建的测试文件 `image-stats.js`，在顶部包含 Sinon，并添加以下测试：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''re now over 97% coverage. Let''s bend time and test our timer. Create a
    new test file called `image-delete-old.js`, and add the following content:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在覆盖率已经超过 97%。让我们弯曲时间并测试我们的计时器。创建一个名为 `image-delete-old.js` 的新测试文件，并添加以下内容：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this test, we're replacing the global timer functions (`setTimeout`and `setInterval`)
    with fake timers. We then make a simple call to statistics, and then advance time
    by one hour (the tick call), and then finish.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们用假定时器替换了全局定时器函数（`setTimeout` 和 `setInterval`）。然后我们进行了一次简单的统计调用，然后通过一个小时的时钟调用（tick
    call）推进时间，然后完成。
- en: 'Now, run the tests and see the results:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试并查看结果：
- en: '![](img/b344f959-c4d5-4473-97e7-f295bc1f4cce.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b344f959-c4d5-4473-97e7-f295bc1f4cce.png)'
- en: 'We now reach *100% coverage* on functions and lines. There''s only one branch,
    with one statement missing. It''s the possibility of a connection error:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在函数和行上达到了 *100% 的覆盖率*。只有一个分支，缺少一个语句。这是连接错误的可能性：
- en: '![](img/87727f4f-fbfb-42a5-b895-b80a691133ac.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87727f4f-fbfb-42a5-b895-b80a691133ac.png)'
- en: I'll leave it to you to figure it out how to mock that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我会留给你去想如何模拟它。
- en: Remember that if you successfully mock the `connect` method, you'll also need
    to handle the throw.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你成功模拟了 `connect` 方法，你还需要处理抛出异常的情况。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Tests allow us to ensure a certain code quality level. It's very important to
    include tests from the very beginning, while the code is simple, to ensure that
    we keep tests updated and avoid regressions to the expected behavior.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使我们能够确保一定的代码质量水平。在代码简单时，从一开始就包含测试非常重要，以确保我们保持测试更新，避免回归到预期的行为。
- en: It's very rewarding when we see that our code has a very high test coverage.
    This feeling forces you to keep that high mark and indirectly maintains good code
    quality.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到我们的代码具有非常高的测试覆盖率时，这感觉是非常有成就感的。这种感觉迫使你保持这个高分，并间接地维护了良好的代码质量。
