- en: Node Fundamentals – Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node基础知识-第2部分
- en: In this chapter, we'll continue our discussion on some more node fundamentals.
    We'll explore yargs, and we'll see how to parse command-line arguments using `process.argv`
    and yargs. After that, we'll explore JSON. JSON is nothing more than a string
    that looks kind of like a JavaScript object, with the notable differences being
    that it uses double quotes instead of single quotes and all of your property names—like
    `name` and `age`, in this case—require quotes around them. We'll look into how
    to convert an object into a string, then define that string, use it, and convert
    it back to an object.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将继续讨论一些更多的node基础知识。我们将探讨yargs，并看看如何使用`process.argv`和yargs来解析命令行参数。之后，我们将探讨JSON。JSON实际上就是一个看起来有点像JavaScript对象的字符串，与之不同的是它使用双引号而不是单引号，并且所有的属性名称，比如`name`和`age`，在这种情况下都需要用引号括起来。我们将探讨如何将对象转换为字符串，然后定义该字符串，使用它，并将其转换回对象。
- en: After we've done that, we'll fill out the `addNote` function. Finally, we'll
    look into refactor, moving the functionality into individual functions and testing
    the functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成了这些之后，我们将填写`addNote`函数。最后，我们将进行重构，将功能移入单独的函数并测试功能。
- en: 'More specifically, we''ll go through following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地，我们将讨论以下主题：
- en: yargs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: yargs
- en: JSON
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: Adding note
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加注释
- en: Refactor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构
- en: yargs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: yargs
- en: In this section, we will use yargs, a third-party npm module, to make the process
    of parsing much easier. It will let us access things such as title and body information
    without needing to write a manual parser. This is a great example of when you
    should look for an npm module. If we don't use a module, it would be more productive
    for our Node application to use a third-party module that has been tested and
    thoroughly vetted.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用yargs，一个第三方的npm模块，来使解析过程更加容易。它将让我们访问诸如标题和正文信息之类的东西，而无需编写手动解析器。这是一个很好的例子，说明何时应该寻找一个npm模块。如果我们不使用模块，对于我们的Node应用程序来说，使用经过测试和彻底审查的第三方模块会更加高效。
- en: To get started, we'll install the module, then we'll add it into the project,
    parsing for things such as a title of the body, and we'll call all the functions
    that will get defined over in `notes.js`. If the command is `add`, we'll call
    `add note`, so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装该模块，然后将其添加到项目中，解析诸如标题和正文之类的内容，并调用在`notes.js`中定义的所有函数。如果命令是`add`，我们将调用`add
    note`。
- en: Installing yargs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装yargs
- en: 'Now, let''s view the documents page for yargs. It''s always a good idea to
    know what you''re getting yourself into. If you search for `yargs` on Google,
    you should find the GitHub page as your first search result. As shown in the following
    screenshot, we have the GitHub page for the yargs library:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看yargs的文档页面。了解自己将要涉足的领域总是一个好主意。如果你在Google上搜索`yargs`，你应该会发现GitHub页面是你的第一个搜索结果。如下截图所示，我们有yargs库的GitHub页面：
- en: '![](img/af292fc6-2252-400f-b807-37dc2f91b054.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af292fc6-2252-400f-b807-37dc2f91b054.png)'
- en: Now, yargs is a very complex library. It has a ton of features for validating
    all sorts of input, and it has different ways in which you can format that input.
    We will start with a very basic example, although we will be introducing more
    complex examples throughout this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，yargs是一个非常复杂的库。它有很多功能来验证各种输入，并且有不同的方式来格式化输入。我们将从一个非常基本的例子开始，尽管在本章中我们将介绍更复杂的例子。
- en: If you want to look at any other features that we don't discuss in the chapter,
    or you just want to see how something works that we have talked about, you can
    always find it in the [yarg documents](http://yargs.js.org/docs/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看我们在本章中没有讨论的任何其他功能，或者你只是想看看我们讨论过的某些功能是如何工作的，你可以在[yarg文档](http://yargs.js.org/docs/)中找到它。
- en: 'We''ll now move into Terminal to install this module inside of our application.
    To do this, we''ll use `npm install` followed by the module name, `yargs`, and
    in this case, I''ll use the `@` sign to specify the specific version of the module
    I want to use, 11.0.0, which is the most recent version at the time of writing.
    Next, I''ll add the `save` flag, which, as we know, updates the `package.json`
    file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入终端，在我们的应用程序中安装这个模块。为了做到这一点，我们将使用`npm install`，然后是模块名称`yargs`，在这种情况下，我将使用`@`符号来指定我想要使用的模块的特定版本，即11.0.0，这是我写作时最新的版本。接下来，我将添加`save`标志，正如我们所知，这会更新`package.json`文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If I leave off the `save` flag, yargs will get installed into the `node_modules`
    folder, but if we wipe that `node_modules` folder later and run `npm install`,
    yargs won't get reinstalled because it's not listed in the `package.json` file.
    This is why we use the `save` flag.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我不加`save`标志，yargs将被安装到`node_modules`文件夹中，但如果我们稍后清空该`node_modules`文件夹并运行`npm
    install`，yargs将不会被重新安装，因为它没有列在`package.json`文件中。这就是为什么我们要使用`save`标志的原因。
- en: Running yargs
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行yargs
- en: 'Now that we''ve installed yargs, we can move over into Atom, inside of `app.js`,
    and get started with using it. The basics of yargs, the very core of its feature
    set, is really simple to take advantage of. The first thing we''ll do is to `require`
    it up, as we did with `fs` and `lodash` in the previous chapter. Let''s make a
    constant and call it `yargs`, setting it equal to `require(''yargs'')`, as shown
    here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了yargs，我们可以进入Atom，在`app.js`中开始使用它。yargs的基础，它的功能集的核心，非常简单易用。我们要做的第一件事就是像我们在上一章中使用`fs`和`lodash`一样，将其`require`进来。让我们创建一个常量并将其命名为`yargs`，将其设置为`require('yargs')`，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From here, we can fetch the arguments as yargs parses them. It will take the
    same `process.argv` array that we discussed in the previous chapter, but it goes
    behind the scenes and parses it, giving us something that''s much more useful
    than what Node gives us. Just above the `command` variable, we can make a `const`
    variable called `argv`, setting it equal to `yargs.argv`, as shown here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以获取yargs解析的参数。它将获取我们在上一章中讨论过的`process.argv`数组，但它在后台解析它，给我们比Node给我们的更有用的东西。就在`command`变量的上面，我们可以创建一个名为`argv`的`const`变量，将其设置为`yargs.argv`，如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `yargs.argv` module is where the yargs library stores its version of the
    arguments that your app ran with. Now we can print it using `console.log`, and
    this will let us take a look at the `process.argv` and `yargs.argv` variables;
    we can also compare them and see how yargs differs. For the command where we use
    `console.log` to print `process.argv`, I''ll make the first argument a string
    called `Process` so that we can differentiate it in Terminal. We''ll call `console.log`
    again. The first argument will be the `Yargs` string, and the second one will
    be the actual `argv` variable, which comes from yargs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`yargs.argv`模块是yargs库存储应用程序运行的参数版本的地方。现在我们可以使用`console.log`打印它，这将让我们查看`process.argv`和`yargs.argv`变量；我们还可以比较它们，看看yargs的不同之处。对于使用`console.log`打印`process.argv`的命令，我将把第一个参数命名为`Process`，这样我们就可以在终端中区分它。我们将再次调用`console.log`。第一个参数将是`Yargs`字符串，第二个参数将是来自yargs的实际`argv`变量：'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we can run our app (refer to the preceding code block) a few different ways
    and see how these two `console.log` statements differ.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以以几种不同的方式运行我们的应用程序（参考前面的代码块），看看这两个`console.log`语句的区别。
- en: 'First up, we''ll run at `node app.js` with the `add` command, and we can run
    this very basic example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`add`命令运行`node app.js`，我们可以运行这个非常基本的例子：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We already know what the `process.argv` array looks like from the previous
    chapter. The useful information is the third string inside of the array, which
    is ''add''. In the fourth string, Yargs gives us an object that looks very different:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从上一章知道了`process.argv`数组的样子。有用的信息是数组中的第三个字符串，即'add'。在第四个字符串中，Yargs给了我们一个看起来非常不同的对象：
- en: '![](img/df9afaf0-8b6c-4e8c-9725-21912fffd11a.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df9afaf0-8b6c-4e8c-9725-21912fffd11a.png)'
- en: As shown in the preceding code output, first we have the underscore property,
    then commands such as add are stored.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码输出所示，首先是下划线属性，然后存储了add等命令。
- en: 'If I were to add another command, say `add`, and then I were to add a modifier,
    say `encrypted`, you would see that add would be the first argument and encrypted
    the second, as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要添加另一个命令，比如`add`，然后我要添加一个修饰符，比如`encrypted`，你会看到`add`是第一个参数，`encrypted`是第二个参数，如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/374665b4-ede6-49f6-951c-ba21dba9f234.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/374665b4-ede6-49f6-951c-ba21dba9f234.png)'
- en: 'So far, yargs really isn''t shining. This isn''t much more useful than what
    we have in the previous example. Where it really shines is when we start passing
    in key-value pairs, such as the title example we used in the *Getting input* section
    of *Node Fundamentals - Part 1* in [chapter 2](9e56dc82-3ad8-4376-81b7-27ba482bd4e2.xhtml).
    I can set my `title` flag equal to `secrets`, press *enter*, and this time around,
    we get something much more useful:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，yargs并没有表现出色。这并不比我们在上一个例子中拥有的更有用。它真正发挥作用的地方是当我们开始传递键值对时，比如我们在*Node基础知识-第1部分*的*获取输入*部分中使用的标题示例中。我可以将我的`title`标志设置为`secrets`，按*enter*，这一次，我们得到了更有用的东西：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the following code output, we have the third string that we would need to
    parse in order to fetch the value and the key, and in the fourth string, we actually
    have a title property with a value of secrets:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码输出中，我们有第三个字符串，我们需要解析以获取值和键，而在第四个字符串中，我们实际上有一个带有值为secrets的标题属性：
- en: '![](img/919e2194-261b-4da5-990e-302f7d5c7ae5.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/919e2194-261b-4da5-990e-302f7d5c7ae5.png)'
- en: Also, yargs has built-in parsing for all the different ways you could specify
    this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，yargs已经内置了对您可能指定的所有不同方式的解析。
- en: 'We can insert a space after `title`, and it will still work just as it did
    before; we can add quotes around `secrets`, or add other words, like `secrets
    from Andrew`, and it will still parses it correctly, setting the `title` property
    to the `secrets from Andrew` string, as shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`title`后面插入一个空格，它仍然会像以前一样工作；我们可以在`secrets`周围添加引号，或者添加其他单词，比如`Andrew的秘密`，它仍然会正确解析，将`title`属性设置为`Andrew的秘密`字符串，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/9fa340c3-87f8-47db-a5f7-208d1c145319.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fa340c3-87f8-47db-a5f7-208d1c145319.png)'
- en: This is where yargs really shines! It makes the process of parsing your arguments
    a lot easier. This means that inside our app, we can take advantage of that parsing
    and call the proper functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是yargs真正发挥作用的地方！它使解析参数的过程变得更加容易。这意味着在我们的应用程序中，我们可以利用这种解析并调用适当的函数。
- en: Working with the add command
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用add命令
- en: 'Let''s work with the `add` command, for example, for parsing your arguments
    and calling the functions. Once the `add` command gets called, we want to call
    a function defined in `notes`, which will be responsible for actually adding the
    note. The `notes.addNote` function will get the job done. Now, what do we want
    to pass to the `addNote` function? We want to pass in two things: the title, which
    is accessible on `argv.title`, as we saw in the preceding example; and the body,
    `argv.body`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`add`命令为例，解析您的参数并调用函数。一旦调用`add`命令，我们希望调用`notes`中定义的一个函数，这个函数将负责实际添加笔记。`notes.addNote`函数将完成这项工作。现在，我们想要传递给`addNote`函数什么？我们想要传递两件事：标题，可以在`argv.title`上访问，就像我们在前面的例子中看到的那样；和正文，`argv.body`：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Currently, these command-line arguments, `title` and `body`, aren't required.
    So technically, the user could run the application without one of them, which
    would cause it to crash, but in future, we'll be requiring both of these.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这些命令行参数`title`和`body`并不是必需的。因此从技术上讲，用户可以在没有其中一个的情况下运行应用程序，这将导致应用程序崩溃，但在未来，我们将要求这两者都是必需的。
- en: Now that we have `notes.addNote` in place, we can remove our `console.log` statement,
    which was just a placeholder, and we can move into the notes application `notes.js`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了`notes.addNote`，我们可以删除我们之前的`console.log`语句，这只是一个占位符，然后我们可以进入笔记应用程序`notes.js`。
- en: 'Inside `notes.js`, we''ll get started by making a variable with the same name
    as the method we used over `app.js` and `addNote`, and we will set it equal to
    an anonymous arrow function, as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`notes.js`中，我们将通过创建一个与我们在`app.js`中使用的方法同名的变量来开始，然后将其设置为一个匿名箭头函数，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, this alone isn''t too useful, because we''re not exporting the `addNote`
    function. Below the variable, we can define `module.exports` in a slightly different
    way. In previous sections, we added properties onto `exports` to export them.
    We can actually define an entire object that gets set to `exports`, and in this
    case, we can set `addNote` equal to the `addNote` function defined in preceding
    code block:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仅仅这样还不太有用，因为我们没有导出`addNote`函数。在变量下面，我们可以以稍微不同的方式定义`module.exports`。在之前的部分中，我们添加属性到`exports`来导出它们。我们实际上可以定义一个整个对象，将其设置为`exports`，在这种情况下，我们可以将`addNote`设置为前面代码块中定义的`addNote`函数：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In ES6, there's actually a shortcut for this. When you're setting an object
    attribute and a value that's a variable and they're both exactly the same, you
    can actually leave off the colon and the value. Either way, the result identical.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，实际上有一个快捷方式。当你设置一个对象属性和一个变量的值，它们都完全相同时，你可以省略冒号和值。无论哪种方式，结果都是相同的。
- en: In the preceding code, we're setting an object equal to `module.exports`, and
    that object has a property, `addNote`, which points to the `addNote` function
    we defined as a variable in the preceding code block.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将一个对象设置为`module.exports`，这个对象有一个属性`addNote`，指向我们在前面的代码块中定义的`addNote`函数的变量。
- en: Once again, `addNote:` and `addNote` are identical inside of ES6\. We will be
    using the ES6 syntax for everything throughout this book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在ES6中，`addNote:`和`addNote`在ES6内部是相同的。我们将在本书中始终使用ES6语法。
- en: 'Now I can take my two arguments, `title` and `body`, and actually do something
    with them. In this case, we''ll call `console.log` and `Adding note`, passing
    in the two arguments as the second and third argument to `console.log`, `title`
    and `body`, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以拿到我的两个参数，`title`和`body`，并且实际上对它们做一些事情。在这种情况下，我们将调用`console.log`和`Adding
    note`，将两个参数作为`console.log`的第二个和第三个参数传递进去，`title`和`body`，如下所示：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we're in a pretty good position to run the `add` command with `title` and
    `body` and see if we get exactly what we'd expect, which is the `console.log`
    statement shown in the preceding code to print.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处于一个非常好的位置，可以使用`title`和`body`运行`add`命令，并查看我们是否得到了我们期望的结果，也就是前面代码中显示的`console.log`语句。
- en: 'Over in Terminal, we can start by running the app with `node app.js`, and then
    specify the filename. We''ll use the `add` command; which will run the appropriate
    function. Then, we''ll pass in `title`, setting it equal to `secret`, and then
    we can pass in `body`, which will be our second command-line argument, setting
    that equal to the string, `This is my secret`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们可以通过`node app.js`运行应用程序，然后指定文件名。我们将使用`add`命令；这将运行适当的函数。然后，我们将传入`title`，将其设置为`secret`，然后我们可以传入`body`，这将是我们的第二个命令行参数，将其设置为字符串`This
    is my secret`：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this command, we specified three things: the `add` command the `title` argument,
    which gets set to `secret`; and the `body` argument, which gets set to `"This
    is my secret"`. If all goes well, we''ll get the appropriate log. Let''s run the
    command.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们指定了三件事：`add`命令，`title`参数，设置为`secret`；和`body`参数，设置为`"This is my secret"`。如果一切顺利，我们将得到适当的日志。让我们运行这个命令。
- en: 'In the following command output, you can see Adding note secret, which is the
    title; and This is my secret, which is the body:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的命令输出中，你可以看到`Adding note secret`，这是标题；和`This is my secret`，这是正文：
- en: '![](img/ada96524-27a8-475a-b80a-44a32452a2c9.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ada96524-27a8-475a-b80a-44a32452a2c9.png)'
- en: With this in place, we now have one of our methods set up and ready to go. The
    next thing that we'll do is convert the other commands we have—the `list`, `read`,
    and `remove` commands. Let's look into one more command, and then you'll do the
    other two by yourself as exercises.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有了一个设置好并准备好的方法。我们接下来要做的是转换我们拥有的其他命令——`list`，`read`和`remove`命令。让我们再看一个命令，然后你可以自己练习另外两个。
- en: Working with the list command
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`list`命令
- en: 'Now, with the `list` command, I''ll remove the `console.log` statement and
    call `notes.getAll`, as shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`list`命令，我将删除`console.log`语句并调用`notes.getAll`，如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At some point, `notes.getAll` will return all of the notes. Now, `getAll` doesn't
    take any arguments since it will return all of the notes regardless of the title.
    The `read` command will require a title, and `remove` will also require the title
    of the note you want to remove.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，`notes.getAll`将返回所有的笔记。现在，`getAll`不需要任何参数，因为它将返回所有的笔记，而不管标题是什么。`read`命令将需要一个标题，`remove`也将需要你想要删除的笔记的标题。
- en: 'For now, we can create the `getAll` function. Inside `notes.js`, we''ll go
    through that process again. We''ll start by making a variable, calling it `getAll`,
    and setting it equal to an arrow function, which we''ve used before. We start
    with our arguments `list`, then we set up the arrow (`=>`), which is the equal
    sign and the greater than sign. Next, we specify the statements we want to run.
    Inside our code block, we''ll run `console.log(Getting all notes)`, as shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建`getAll`函数。在`notes.js`中，我们将再次进行这个过程。我们将首先创建一个变量，称之为`getAll`，并将其设置为一个箭头函数，这是我们之前使用过的。我们从我们的参数`list`开始，然后设置箭头(`=>`)，这是等号和大于号。接下来，我们指定我们想要运行的语句。在我们的代码块中，我们将运行`console.log(Getting
    all notes)`，如下所示：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last step to the process after adding that semicolon will be to add `getAll`
    to the `exports`, as shown in the following code block:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加分号之后的最后一步是将`getAll`添加到`exports`中，如下面的代码块所示：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember that in ES6, if you have a property whose name is identical to the
    value, which is a variable, you can simply remove the value variable and the colon.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在ES6中，如果你有一个属性的名称与值相同，这个值是一个变量，你可以简单地删除值变量和冒号。
- en: 'Now that we have `getAll` in `notes.js` in place, and we''ve wired it up in
    `app.js`, we can run things over in Terminal. In this case, we''ll run the `list`
    command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`notes.js`中有了`getAll`，并且在`app.js`中已经连接好了，我们可以在终端中运行。在这种情况下，我们将运行`list`命令：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](img/33f36369-3d7e-43da-ab9e-aa99cb60f7c2.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33f36369-3d7e-43da-ab9e-aa99cb60f7c2.png)'
- en: 'In the preceding code output, you can see at the bottom that Getting all notes
    prints to the screen. Now that we have this in place, we can remove `console.log(''Process'',
    process.argv)` from the `command` variable in `app.js`. The resultant code will
    look like the following code block:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码输出中，你可以看到屏幕上打印出了`Getting all notes`。现在我们已经有了这个，我们可以从`app.js`的`command`变量中删除`console.log('Process',
    process.argv)`。结果代码将如下所示：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will keep the yargs log around since we'll be exploring the other ways and
    methods to use yargs throughout the chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留yargs日志，因为我们将在本章中探索其他使用yargs的方法和方式。
- en: Now that we have the `list` command in place, next, I'd like you to create a
    method for the `read` and `remove` commands.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`list`命令，接下来，我想让你为`read`和`remove`命令创建一个方法。
- en: The read command
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取命令
- en: 'When the `read` command is used, we want to call `notes.getNote`, passing in
    `title`. Now, `title` will get passed in and parsed using yargs, which means that
    we can use `argv.title` to fetch it. And that''s all we have to do when it comes
    to calling the function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`read`命令时，我们希望调用`notes.getNote`，传入`title`。现在，`title`将被传递并使用yargs进行解析，这意味着我们可以使用`argv.title`来获取它。这就是在调用函数时所需要做的一切：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next step is to define `getNote`, because currently it doesn''t exist.
    Over in `notes.js`, right below the `getAll` variable, we can make a variable
    called `getNote`, which will be a function. We''ll use the arrow function, and
    it will take an argument; it will take the `note` title. The `getNote` function
    takes the title, then it returns the body for that note:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义`getNote`，因为目前它并不存在。在`notes.js`中，在`getAll`变量的下面，我们可以创建一个名为`getNote`的变量，它将是一个函数。我们将使用箭头函数，并且它将接受一个参数；它将接受`note`的标题。`getNote`函数接受标题，然后返回该笔记的内容：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside `getNote`, we can use `console.log` to print something like `Getting
    note`, followed by the title of the note you will fetch, which will be the second
    argument to `console.log`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getNote`中，我们可以使用`console.log`打印一些类似于`Getting note`的内容，后面跟着你将要获取的笔记的标题，这将是`console.log`的第二个参数：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is the first command, and we can now test it before we go on to the second
    one, which is `remove`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个命令，我们现在可以在继续第二个命令`remove`之前进行测试。
- en: 'Over in Terminal, we can use `node app.js` to run the file. We''ll be using
    the new `read` command, passing in a `title` flag. I''ll use a different syntax,
    where `title` gets set equal to the value outside of quotes. I''ll use something
    like `accounts`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们可以使用`node app.js`来运行文件。我们将使用新的`read`命令，传入一个`title`标志。我将使用不同的语法，其中`title`被设置为引号外的值。我将使用类似`accounts`的东西：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This `accounts` value will read the accounts note in the future, and it will
    print it to the screen, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`accounts`值将在将来读取`accounts`笔记，并将其打印到屏幕上，如下所示：
- en: '![](img/ed29fd53-b7d8-4c61-b33b-2b6c4fc782b3.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed29fd53-b7d8-4c61-b33b-2b6c4fc782b3.png)'
- en: As you can see in the preceding code output, we get an error, which we'll debug
    now.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的代码输出中所看到的，我们得到了一个错误，现在我们将对其进行调试。
- en: Dealing with the errors in parsing commands
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理解析命令中的错误
- en: 'Getting an error is not the end of the world. Getting an error usually means
    that you have a small typo or you forgot one step in the process. So, we''ll first
    figure out how to parse through these error messages, because the error messages
    you get in the code output can be pretty daunting. Let''s refer to the code output
    error here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到错误并不是世界末日。通常出现错误意味着你可能有一个小的拼写错误或者在过程中忘记了一步。所以，我们首先要弄清楚如何解析这些错误消息，因为代码输出中得到的错误消息可能会让人望而生畏。让我们来看一下代码输出中的错误：
- en: '![](img/1d14b0b9-86ba-4da5-9bd7-b5ac3513bce2.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d14b0b9-86ba-4da5-9bd7-b5ac3513bce2.png)'
- en: 'As you can see, the first line shows you where the error occurred. It''s inside
    of our `app.js` file, and the number 19 after the colon is the line number. It
    shows you exactly where things went bad. The `TypeError: notes.getNote is not
    a function` line is telling you pretty clearly that the `getNote` function you
    tried to run doesn''t exist. Now we can take this information and debug our app.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你所看到的，第一行显示了错误发生的位置。它在我们的`app.js`文件中，冒号后面的数字19是行号。它准确地告诉你事情出了问题的地方。`TypeError:
    notes.getNote is not a function`行清楚地告诉你你尝试运行的`getNote`函数不存在。现在我们可以利用这些信息来调试我们的应用程序。'
- en: 'In `app.js`, we see that we call `notes.getNote`. Everything looks great, but
    when we move into `notes.js`, we realize that we never actually exported `getNote`.
    This is why when we try to call the function, we get `getNote is not a function`.
    All we have to do to fix that error message is export `getNote`, as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`中，我们看到我们调用了`notes.getNote`。一切看起来很好，但当我们进入`notes.js`时，我们意识到我们实际上从未导出`getNote`。这就是为什么当我们尝试调用该函数时，我们会得到`getNote
    is not a function`。我们只需要做的就是导出`getNote`，如下所示：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now when we save the file and rerun the app from Terminal, we''ll get what
    we expect—Getting note followed by the title, which is accounts, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们保存文件并从终端重新运行应用程序时，我们将得到我们期望的结果——`Getting note`后面跟着标题，这里是`accounts`：
- en: '![](img/0ee76344-03dc-4a00-abe1-db51f870bdf1.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ee76344-03dc-4a00-abe1-db51f870bdf1.png)'
- en: This is how we can debug our error messages. Error messages contain really useful
    information. For the most part, the first couple of lines are code that you've
    written, and the other ones are internal Node code or third-party modules. In
    our case, the first line of the stack trace is important, as it shows exactly
    where the error occurred.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何调试我们的错误消息。错误消息包含非常有用的信息。在大多数情况下，前几行是你编写的代码，其他行是内部Node代码或第三方模块。在我们的情况下，堆栈跟踪的第一行很重要，因为它准确地显示了错误发生的位置。
- en: The remove command
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除命令
- en: 'Now, since the `read` command is working, we can move on to the last one, which
    is the `remove` command. Here, I''ll call `notes.removeNote`, passing in the title,
    which as we know is available in `argv.title`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`read`命令正在工作，我们可以继续进行最后一个命令`remove`。在这里，我将调用`notes.removeNote`，传入标题，正如我们所知道的在`argv.title`中可用：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next up, we''ll define the `removeNote` function over inside of our notes API
    file, right below the `getNote` variable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的笔记 API 文件中定义 `removeNote` 函数，就在 `getNote` 变量的下面：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, `removeNote` will work much the same way as `getNote`. All it needs is
    the title; it can use this information to find the note and remove it from the
    database. This will be an arrow function that takes the `title` argument.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`removeNote` 将与 `getNote` 工作方式基本相同。它只需要标题；它可以使用这些信息来查找笔记并从数据库中删除它。这将是一个接受
    `title` 参数的箭头函数。
- en: 'In this case, we''ll print the `console.log` statement, `Removing note`; then,
    as the second argument, we''ll simply print `title` back to the screen to make
    sure that it''s going through the process successfully. This time around, we''ll
    export our `removeNote` function; we''ll define it using the ES6 syntax:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将打印 `console.log` 语句 `Removing note`；然后，作为第二个参数，我们将简单地打印 `title` 回到屏幕上，以确保它成功地通过了这个过程。这一次，我们将导出我们的
    `removeNote` 函数；我们将使用 ES6 语法来定义它：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last thing to do is test it and make sure it works. We can reload the last
    command using the up arrow key. We change `read` to `remove`, and that is all
    we need to do. We''re still passing in the `title` argument, which is great, because
    that is what `remove` needs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是测试它并确保它有效。我们可以使用上箭头键重新加载上一个命令。我们将 `read` 改为 `remove`，这就是我们需要做的全部。我们仍然传入
    `title` 参数，这很好，因为这是 `remove` 需要的：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When I run this command, we get exactly what we expected. Removing note prints
    to the screen, as shown in the following code output, and then we get the title
    of the note that we''re supposed to be removing, which is accounts:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这个命令时，我们得到了我们预期的结果。移除笔记打印到屏幕上，如下面的代码输出所示，然后我们得到了我们应该移除的笔记的标题，即 accounts：
- en: '![](img/794f3513-27f1-4303-b518-374f61bb6cbf.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/794f3513-27f1-4303-b518-374f61bb6cbf.png)'
- en: This looks great! That is all it takes to use yargs to parse your arguments.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒！这就是使用 yargs 解析你的参数所需的全部内容。
- en: With this, we now have a place to define all of that functionality, for saving,
    reading, listing, and removing notes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有了一个地方来定义所有这些功能，用于保存、读取、列出和删除笔记。
- en: Fetching command
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取命令
- en: The last thing I want to discuss before we wrap up this section is—how we fetch
    `command`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，我想讨论的最后一件事是——我们如何获取 `command`。
- en: 'As we know, `command` is available in the `_` property as the first and only
    item. This means that in the `app.js`, `var command` statement, we can set `command`
    equal to `argv`, then `._`, and then we''ll use `[]` to grab the first item in
    the array, as shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，`command` 在 `_` 属性中作为第一个且唯一的项可用。这意味着在 `app.js` 中，`var command` 语句中，我们可以将
    `command` 设置为 `argv`，然后 `._`，然后我们将使用 `[]` 来抓取数组中的第一个项目，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this in place, we now have the same functionality, but we''ll use yargs
    everywhere. If I rerun the last command, we can test that the functionality still
    works. And it does! As shown in the following command output, we can see that
    Command: remove shows up:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个功能，我们现在有了相同的功能，但我们将在所有地方使用 yargs。如果我重新运行上一个命令，我们可以测试功能是否仍然有效。它确实有效！如下面的命令输出所示，我们可以看到命令：remove
    显示出来：
- en: '![](img/4d31df46-2653-4c07-b9bf-0f5f84665e7f.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d31df46-2653-4c07-b9bf-0f5f84665e7f.png)'
- en: Next, we'll look into filling out the individual functions. We'll take a look
    first at how we can use JSON to store our notes inside our file system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究填写各个函数。我们首先来看一下如何使用 JSON 将我们的笔记存储在文件系统中。
- en: JSON
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: Now that you know how to parse command-line arguments using `process.argv` and
    yargs, you've solved the first piece to the puzzle for the `notes` application.
    Now, how do we get that unique input from the user? The second piece to the puzzle
    is to solve how we store this information.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用 `process.argv` 和 yargs 解析命令行参数，你已经解决了 `notes` 应用程序的第一部分难题。现在，我们如何从用户那里获取独特的输入呢？解决这个难题的第二部分是解决我们如何存储这些信息。
- en: When someone adds a new note, we want to save it somewhere, preferably on the
    filesystem. So the next time they try to fetch, remove, or read that note, they
    actually get the note back. To do this, we'll need to introduce something called
    JSON. If you're already familiar with JSON, you probably know it is super popular.
    It stands for **JavaScript Object Notation**, and it's a way to represent JavaScript
    arrays and objects using a string. Now, why would you ever want to do that?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人添加新的笔记时，我们希望将其保存在某个地方，最好是在文件系统上。所以下次他们尝试获取、移除或读取该笔记时，他们实际上会得到该笔记。为了做到这一点，我们需要引入一个叫做
    JSON 的东西。如果你已经熟悉 JSON，你可能知道它非常受欢迎。它代表 JavaScript 对象表示法，是一种用字符串表示 JavaScript 数组和对象的方法。那么，为什么你会想要这样做呢？
- en: Well, you might want to do that because strings are just text, and that's pretty
    much supported anywhere. I can save JSON to a text file, and then I can read it
    later, parse it back into a JavaScript array or object, and do something with
    it. This is exactly what we'll take a look at in this section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你可能想这样做是因为字符串只是文本，而且几乎在任何地方都得到支持。我可以将 JSON 保存到文本文件中，然后稍后读取它，将其解析回 JavaScript
    数组或对象，并对其进行操作。这正是我们将在本节中看到的。
- en: To explore JSON and how it works, let's go ahead and make a new folder inside
    our project called `playground`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索 JSON 以及它的工作原理，让我们继续在我们的项目中创建一个名为 `playground` 的新文件夹。
- en: Throughout the book, I'll create the `playground` folders and various projects,
    which store simple one-off files that aren't a part of the bigger application;
    they're just a way to explore a new feature or learn a new concept.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将创建 `playground` 文件夹和各种项目，这些项目存储简单的一次性文件，不是更大应用程序的一部分；它们只是探索新功能或学习新概念的一种方式。
- en: In the `playground` folder, we'll make a file called `json.js`, this is where
    we can explore how JSON works. To get started, let's make a very simple object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `playground` 文件夹中，我们将创建一个名为 `json.js` 的文件，这是我们可以探索 JSON 工作原理的地方。让我们开始，让我们创建一个非常简单的对象。
- en: Converting objects into strings
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象转换为字符串
- en: 'Let''s first make a variable called `obj`, setting it equal to an object. On
    this object, we''ll just define one property, `name`, and set it equal to your
    first name; I''ll set this one equal to `Andrew`, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`obj`的变量，将其设置为一个对象。在这个对象上，我们只定义一个属性`name`，并将其设置为你的名字；我将这个属性设置为`Andrew`，如下所示：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, let's assume that we want to take this object and work on it. Let's say
    we want to, for example, send it between servers as a string and save it to a
    text file. To do this, we'll need to call one JSON method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要获取这个对象并对其进行操作。例如，我们想要将其作为字符串在服务器之间发送并保存到文本文件中。为此，我们需要调用一个JSON方法。
- en: 'Let''s take a moment to define a variable to store the result, `stringObj`,
    and we''ll set it equal to `JSON.stringify`, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个变量来存储结果`stringObj`，并将其设置为`JSON.stringify`，如下所示：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `JSON.stringify` method takes your object, in this case, the `obj` variable,
    and returns the JSON-stringified version. This means that the result stored in
    `stringObj` is actually a string. It''s no longer an object, and we can take a
    look at that using `console.log`. I''ll use `console.log` twice. First up, we''ll
    use the `typeof` operator to print the type of the string object to make sure
    that it actually is a string. Since `typeof` is an operator, it gets typed in
    lowercase, there is no camel casing. Then, you pass in the variable whose type
    you want to check. Next up, we can use `console.log` to print the contents of
    the string itself, printing out the `stringObj` variable, as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.stringify`方法接受你的对象，这里是`obj`变量，并返回JSON字符串化的版本。这意味着存储在`stringObj`中的结果实际上是一个字符串。它不再是一个对象，我们可以使用`console.log`来查看。我将使用`console.log`两次。首先，我们将使用`typeof`运算符打印字符串对象的类型，以确保它实际上是一个字符串。由于`typeof`是一个运算符，它以小写形式输入，没有驼峰命名法。然后，传入要检查其类型的变量。接下来，我们可以使用`console.log`来打印字符串本身的内容，打印`stringObj`变量，如下所示：'
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What we''ve done here is we''ve taken an object, converted it into a JSON string,
    and printed it onto the screen. Over in Terminal, I''ll navigate into the `playground`
    folder using the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将一个对象转换为JSON字符串，并将其打印到屏幕上。在终端中，我将使用以下命令导航到`playground`文件夹中：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For now, it doesn't matter where you run the command, but in future it will
    matter when we are in the `playground` folder, so take a moment to navigate into
    it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论你在哪里运行命令都无所谓，但在将来当我们在`playground`文件夹中时，这将很重要，所以花点时间进入其中。
- en: 'We can now use `node` to run our `json.js` file. When we run the file, we see
    two things:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`node`来运行我们的`json.js`文件。运行文件时，我们会看到两件事：
- en: '![](img/fba1baff-bbdb-4edf-95ba-fb767eb815cd.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fba1baff-bbdb-4edf-95ba-fb767eb815cd.png)'
- en: 'As shown in the preceding code output, first, we will get our type, which is
    a string, and this is great, because remember, JSON is a string. Next, we will
    get our object, which looks pretty similar to a JavaScript object, but there are
    a few differences. These differences are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码输出所示，首先我们会得到我们的类型，它是一个字符串，这很好，因为记住，JSON是一个字符串。接下来，我们将得到我们的对象，它看起来与JavaScript对象非常相似，但有一些区别。这些区别如下：
- en: First up, your JSON will have its attribute names automatically wrapped in double
    quotes. This is a requirement of the JSON syntax.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你的JSON将自动用双引号包裹其属性名称。这是JSON语法的要求。
- en: Next up, you'll notice your strings are also wrapped in double quotes as opposed
    to single quotes.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，你会注意到你的字符串也被双引号包裹，而不是单引号。
- en: Now, JSON doesn't just support string values, you can use an array, a Boolean,
    a number, or anything else. All of those types are perfectly valid inside of your
    JSON. In this case, we have a very simple example where we have a `name` property
    and it's set to `"Andrew"`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JSON不仅支持字符串值，还可以使用数组、布尔值、数字或其他任何类型。所有这些类型在你的JSON中都是完全有效的。在这种情况下，我们有一个非常简单的示例，其中有一个`name`属性，它设置为`"Andrew"`。
- en: This is the process of taking an object and converting it into a string. Next
    up, we'll define a string and convert that into an object we can actually use
    in our app.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将对象转换为字符串的过程。接下来，我们将定义一个字符串，并将其转换为我们可以在应用程序中实际使用的对象。
- en: Defining a string and using in app as an object
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个字符串并在应用程序中使用
- en: 'Let''s get started by making a variable called `personString`, and we''ll to
    set it equal to a string using single quotes since JSON uses double quotes inside
    of itself, as shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个名为`personString`的变量，并将其设置为一个字符串，使用单引号，因为JSON在其内部使用双引号，如下所示：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we''ll define our JSON in the quotes. We''ll start by opening and closing
    some curly braces. We''ll use double quotes to create our first attribute, which
    we''ll call `name`, and we''ll set that attribute equal to `Andrew`. This means
    that after the closing quote, we''ll add `:`; then we''ll open and close double
    quotes again and type the value `Andrew`, as shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将在引号中定义我们的JSON。我们将首先打开和关闭一些花括号。我们将使用双引号创建我们的第一个属性，我们将其称为`name`，并将该属性设置为`Andrew`。这意味着在闭合引号之后，我们将添加`:`；然后我们将再次打开和关闭双引号，并输入值`Andrew`，如下所示：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next up, we can add another property. After the value, `Andrew`, I''ll create
    another property after the comma, called `age`, which will be set equal to a number.
    I can use my colon and then define the number without the quotes, in this case,
    `25`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加另一个属性。在值`Andrew`之后，我将在逗号后创建另一个属性，称为`age`，并将其设置为一个数字。我可以使用冒号，然后定义数字而不使用引号，例如`25`：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can go ahead and use your name and your age, obviously, but make sure the
    rest looks identical to what you see here.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续使用你的名字和年龄，但确保其余部分看起来与这里看到的完全相同。
- en: Now, let's say we get the earlier-defined JSON from a server or we grab it from
    a text file. Currently, it's useless; if we want to get the `name` value, there
    is no good way to do that because we're using a string, so `personString.name`
    doesn't exist. What we need to do is take the string and convert it back into
    an object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们从服务器获取了先前定义的JSON，或者我们从文本文件中获取了它。目前它是无用的；如果我们想获取`name`值，没有好的方法可以做到，因为我们使用的是一个字符串，所以`personString.name`不存在。我们需要将字符串转换回对象。
- en: Converting a string back to an object
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串转换回对象
- en: 'To convert the string back to object, we''ll use the opposite of `JSON.stringify`,
    which is `JSON.parse`. Let''s make a variable to store the result. I''ll create
    a `person` variable and it will be set equal to `JSON.parse`, passing in as the
    one and only argument the string you want to parse, in this case, the `person`
    string, which we defined earlier:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串转换回对象，我们将使用`JSON.stringify`的相反操作，即`JSON.parse`。让我们创建一个变量来存储结果。我将创建一个`person`变量，并将其设置为`JSON.parse`，传入作为唯一参数要解析的字符串，即`person`字符串，我们之前定义过的：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, this variable takes your JSON and converts it from a string back into its
    original form, which could be an array or an object. In our case, it converts
    it back into an object, and we have the `person` variable as an object, as shown
    in the preceding code. Also, we can prove that it's an object using the `typeof`
    operator. I'll use `console.log` twice, just like we did previously.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个变量将把你的JSON从字符串转换回其原始形式，可以是数组或对象。在我们的情况下，它将其转换回对象，并且我们有`person`变量作为对象，如前面的代码所示。此外，我们可以使用`typeof`运算符证明它是一个对象。我将使用`console.log`两次，就像我们之前做过的那样。
- en: 'First up, we''ll print `typeof person`, and then we''ll print the actual `person`
    variable, `console.log(person)`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将打印`person`的`typeof`，然后我们将打印实际的`person`变量，`console.log(person)`：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this in place, we can now rerun the command in Terminal; I''ll actually
    start `nodemon` and pass in `json.js`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以在终端中重新运行命令；我将实际启动`nodemon`并传入`json.js`：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As shown in the following code output, you can now see that we''re working
    with an object, which is great, and we have our regular object:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的代码输出，您现在可以看到我们正在使用一个对象，这很棒，我们有我们的常规对象：
- en: '![](img/b1ede340-6c8d-49fd-8dde-a7365f3ca724.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1ede340-6c8d-49fd-8dde-a7365f3ca724.png)'
- en: We know that `Andrew` is an object because it's not wrapped in double quotes;
    the values don't have any quotes, and we use single quotes for `Andrew`, which
    is valid in JavaScript, but it's not valid in JSON.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`Andrew`是一个对象，因为它没有用双引号包裹；值没有引号，我们使用单引号`Andrew`，这在JavaScript中是有效的，但在JSON中是无效的。
- en: 'This is the entire process of taking an object, converting it to a string,
    and then taking the string and converting it back into the object, and this is
    exactly what we''ll do in the `notes` app. The only difference is that we''ll
    be taking the following string and storing it in a file, then later on, we''ll
    be reading that string from the file using `JSON.parse` to convert it back to
    an object, as shown in the following code block:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将对象转换为字符串，然后将字符串转换回对象的整个过程，这正是我们将在`notes`应用程序中做的。唯一的区别是，我们将取以下字符串并将其存储在文件中，然后稍后，我们将使用`JSON.parse`从文件中读取该字符串，将其转换回对象，如下面的代码块所示：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Storing the string in a file
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串存储在文件中
- en: With the basics in place, let's take it just one step further, that is, by storing
    the string in a file. Then, we want to read the contents of that file back by
    using the `fs` module and printing some properties from it. This means that we'll
    need to convert the string that we get back from `fs.readfilesync` into an object
    using `JSON.parse`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 基本知识已经就位，让我们再进一步，也就是将字符串存储在文件中。然后，我们希望使用`fs`模块读取该文件的内容，并打印一些属性。这意味着我们需要将从`fs.readfilesync`获取的字符串转换为对象，使用`JSON.parse`。
- en: Writing the file in the playground folder
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在playground文件夹中写入文件
- en: 'Let''s go ahead and comment out all the code we have so far and start with
    a clean slate. First up, let''s go ahead and load in the `fs` module. The `const`
    variable `fs` will be set equal to `require`, and we''ll pass the `fs` module
    that we''ve used in the past, as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续注释掉到目前为止的所有代码，从干净的板上开始。首先，让我们加载`fs`模块。`const`变量`fs`将被设置为`require`，我们将传递过去使用过的`fs`模块，如下所示：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The next thing we'll do is define the object. This object will be stored inside
    of our file, and then will be read back and parsed. This object will be a variable
    called `originalNote`, and we'll call it `originalNote` because later on, we'll
    load it back in and call that variable `Note`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是定义对象。这个对象将被存储在我们的文件中，然后将被读取并解析。这个对象将是一个名为`originalNote`的变量，我们将称它为`originalNote`，因为后来，我们将重新加载它并将该变量称为`Note`。
- en: 'Now, `originalNote` will be a regular JavaScript object with two properties.
    We''ll have the `title` property, which we''ll set equal to `Some title`, and
    the `body` property, which we will set equal to `Some body`, as shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`originalNote`将是一个常规的JavaScript对象，有两个属性。我们将有`title`属性，将其设置为`Some title`，和`body`属性，将其设置为`Some
    body`，如下所示：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The next step that you will need to do is take the original note and create
    a variable called `originalNoteString`, and set that variable equal to the JSON
    value of the object we defined earlier. This means that you'll need to use one
    of the two JSON methods we used previously in this section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的下一步是获取原始注释并创建一个名为`originalNoteString`的变量，并将该变量设置为我们之前定义的对象的JSON值。这意味着您需要使用我们在本节先前使用过的两种JSON方法之一。
- en: 'Now, once you have that `originalNoteString` variable, we can write a file
    to the filesystem. I''ll write that line for you, `fs.writeFileSync`. The `writeFileSync`
    method, which we used before, takes two arguments. One will be the filename, and
    since we''re using JSON, it''s important to use the JSON file extension. I''ll
    call this file `notes.json`. The other arguments will be text content, `originalNoteString`,
    which is not yet defined, as shown in this code block:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦你有了`originalNoteString`变量，我们就可以将文件写入文件系统。我会为你写下这一行，`fs.writeFileSync`。我们之前使用的`writeFileSync`方法需要两个参数。一个是文件名，由于我们使用的是JSON，使用JSON文件扩展名很重要。我会把这个文件叫做`notes.json`。另一个参数将是文本内容，`originalNoteString`，它还没有被定义，如下面的代码块所示：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is the first step to the process; this is how we'll write that file into
    the `playground` folder. The next step to the process will be to read out the
    contents, parse it using the JSON method earlier, and print one of the properties
    to the screen to make sure that it's an object. In this case, we'll print the
    title.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个过程的第一步；这是我们将文件写入`playground`文件夹的方法。下一步是读取内容，使用之前的JSON方法进行解析，并打印其中一个属性到屏幕上，以确保它是一个对象。在这种情况下，我们将打印标题。
- en: Reading out the content in the file
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文件中的内容
- en: The first step to print the title is to use a method we haven't used yet. We'll
    use the `read` method available on the filesystem module to read the contents.
    Let's make a variable called `noteString`. The `noteString` variable will be set
    equal to `fs.readFileSync`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 打印标题的第一步是使用我们尚未使用过的方法。我们将使用文件系统模块上可用的`read`方法来读取内容。让我们创建一个名为`noteString`的变量。`noteString`变量将被设置为`fs.readFileSync`。
- en: 'Now, `readFileSync` is similar to `writeFileSync` except that it doesn''t take
    the text content, since it''s getting the text content back for you. In this case,
    we''ll just specify the first argument, which is the filename, `notes.JSON`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`readFileSync`与`writeFileSync`类似，只是它不需要文本内容，因为它会为你获取文本内容。在这种情况下，我们只需指定第一个参数，即文件名`notes.JSON`：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we have the string, it will be your job to take that string, use one
    of the preceding methods, and convert it back into an object. You can call that
    variable `note`. Next up, the only thing left to do is to test whether things
    are working as expected, by printing with the help of `console.log(typeof note)`.
    Then, below this, we''ll use `console.log` to print the title, `note.title`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了字符串，你的工作就是拿到那个字符串，使用前面的方法之一，将它转换回对象。你可以将那个变量叫做`note`。接下来，唯一剩下的事情就是测试一切是否按预期工作，通过使用`console.log(typeof
    note)`来打印。然后，在这之下，我们将使用`console.log`来打印标题，`note.title`：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, over in Terminal, you can see (refer to the following screenshot) that
    I have saved the file in a broken state and it crashed, and that''s expected when
    you''re using `nodemon`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在终端中，你可以看到（参考下面的截图），我保存了一个损坏的文件，并且它崩溃了，这是使用`nodemon`时预期的结果：
- en: '![](img/d09a35f5-c804-4889-9ba7-dbb6be822a14.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d09a35f5-c804-4889-9ba7-dbb6be822a14.png)'
- en: To resolve this, the first thing I'll do is fill out the `originalNoteString`
    variable, which we had commented out earlier. It will now be a variable called
    `originalNoteString`, and we'll set it equal to the return value from `JSON.stringify`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我要做的第一件事是填写`originalNoteString`变量，这是我们之前注释掉的。现在它将成为一个名为`originalNoteString`的变量，并且我们将把它设置为`JSON.stringify`的返回值。
- en: 'Now, we know `JSON.stringify` takes our regular object and it converts the
    object into a string. In this case, we''ll take the `originalNote` object and
    convert it into a string. The next line, which we already have filled out, will
    save that JSON value into the `notes.JSON` file. Then we will read that value
    out:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道`JSON.stringify`将我们的普通对象转换为字符串。在这种情况下，我们将把`originalNote`对象转换为字符串。下一行，我们已经填写好了，将保存该JSON值到`notes.JSON`文件中。然后我们将读取该值出来：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The next step will be to create the `note` variable. The `note` variable will
    be set equal to `JSON.parse`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是创建`note`变量。`note`变量将被设置为`JSON.parse`。
- en: 'The `JSON.parse` method takes the string JSON and converts it back into a regular
    JavaScript object or array, depending on whatever you save. Here we will pass
    in `noteString`, which we''ll get from the file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.parse`方法将字符串JSON转换回普通的JavaScript对象或数组，取决于你保存的内容。在这里，我们将传入`noteString`，这是我们从文件中获取的：'
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this in place, we are now done. When I save this file, `nodemon` will
    automatically restart and we would expect to not see an error. Instead, we expect
    that we''ll see the object type as well as the note title. Right inside Terminal,
    we have object and Some title printing to the screen:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在完成了。当我保存这个文件时，`nodemon`将自动重新启动，我们不会看到错误。相反，我们期望看到对象类型以及笔记标题。在终端中，我们有对象和一些标题打印到屏幕上：
- en: '![](img/cb8126dd-2d1b-4213-9419-38b86f7d9424.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb8126dd-2d1b-4213-9419-38b86f7d9424.png)'
- en: With this in place, we've successfully completed the challenge. This is exactly
    how we will save our notes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经成功完成了挑战。这正是我们将保存我们的笔记的方法。
- en: 'When someone adds a new note, we''ll use the following code to save it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人添加新的笔记时，我们将使用以下代码来保存它：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When someone wants to read their note, we''ll use the following code to read
    it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人想要阅读他们的笔记时，我们将使用以下代码来读取它：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, what if someone wants to add a note? This will require us to first read
    all of the notes, then modify the notes array, and then use the code (refer to
    the previous code block) to save the new array back into the filesystem.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有人想要添加一条笔记呢？这将要求我们首先读取所有的笔记，然后修改笔记数组，然后使用代码（参考前面的代码块）将新数组保存回文件系统中。
- en: 'If you open up that `notes.JSON` file, you can see right here that we have
    our JSON code inside the file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`notes.JSON`文件，你可以看到我们的JSON代码就在文件中：
- en: '![](img/ad6c82b5-3af0-4fb8-8677-b579be0e6f68.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad6c82b5-3af0-4fb8-8677-b579be0e6f68.png)'
- en: '`.json` is actually a file format that''s supported by most text editors, so
    I actually already have some nice syntax highlighting built in. Now, in the next
    section, we''ll be filling out the `addNote` function using the exact same logic
    that we just used inside of this section.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`.json`实际上是大多数文本编辑器支持的文件格式，因此我已经内置了一些不错的语法高亮。现在，在下一节中，我们将填写`addNote`函数，使用刚刚在本节中使用的完全相同的逻辑。'
- en: Adding and saving notes
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和保存笔记
- en: In the previous section, you learned how to work with JSON inside Node.js, and
    this is the exact format we'll be using for the `notes.js` application. When you
    first run a command, we'll load in all the notes that might already exist. Then
    we'll run the command, whether it's adding, removing, or reading notes. Finally,
    if we've updated the array, like we will when we add and remove notes, we'll save
    those new notes back into the JSON file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学习了如何在Node.js中处理JSON，这是我们将在`notes.js`应用程序中使用的确切格式。当您首次运行命令时，我们将加载可能已经存在的所有笔记。然后我们将运行命令，无论是添加、删除还是阅读笔记。最后，如果我们已经更新了数组，就像我们在添加和删除笔记时所做的那样，我们将这些新的笔记保存回JSON文件中。
- en: Now, this will all happen inside of the `addNote` function, which we defined
    in the `notes.js` application, and we already wired up this function. In earlier
    sections, we ran the app `add` command, and this function executed with the `title`
    and `body` arguments.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有这些将发生在我们在`notes.js`应用程序中定义的`addNote`函数内部，我们已经连接了这个函数。在之前的部分中，我们运行了`add`命令，这个函数执行了`title`和`body`参数。
- en: Adding notes
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加笔记
- en: 'To get started with adding notes, the first thing we''ll do is create a variable
    called `notes`, and for the moment, we''ll set it equal to an empty array, just
    as in the following, using our square brackets:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始添加笔记，我们要做的第一件事是创建一个名为`notes`的变量，暂时将其设置为空数组，就像下面这样使用我们的方括号：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now that we have the empty array, we can go ahead and make a variable called
    `note`, which is the individual note. This will represent the new note:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了空数组，我们可以继续创建一个名为`note`的变量，这是单个笔记。这将代表新的笔记：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'On that note, we''ll have the two properties: a `title` and a `body`. Now,
    `title` can be set equal to the `title` variable, but, as we know, inside ES6,
    we can simply remove it when both values are the same; so we''ll add `title` and
    `body` as shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将有两个属性：一个`title`和一个`body`。现在，`title`可以设置为`title`变量，但是，正如我们所知，在ES6中，当两个值相同时，我们可以简单地将其删除；因此，我们将添加`title`和`body`如下所示：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now we have the `note` and the `notes` array.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了“note”和“notes”数组。
- en: Adding notes to the notes array
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将笔记添加到笔记数组中
- en: 'The next step in the process of adding notes will be to add the `note` to the
    `notes` array. The `notes.push` method will let us do just that. The `push` method
    on an array lets you pass in an item, which gets added to the end of the array,
    and in this case, we''ll pass in the `note` object. So we have an empty array,
    and we add our one item, as shown in the following code; next, we push it in,
    which means that we have an array with one item:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 添加笔记过程中的下一步将是将“note”添加到“notes”数组中。`notes.push`方法将让我们做到这一点。数组上的`push`方法允许您传入一个项目，该项目将被添加到数组的末尾，在这种情况下，我们将传入`note`对象。因此，我们有一个空数组，并且我们添加了一个项目，如下面的代码所示；接下来，我们将其推入，这意味着我们有一个包含一个项目的数组：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The next step in the process will be to update the file. Now, we don't have
    a file in place, but we can load an `fs` function and start creating the file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是更新文件。现在，我们没有文件，但我们可以加载一个`fs`函数并开始创建文件。
- en: 'Up above the `addNote` function, let''s load in the `fs` module. I''ll create
    a `const` variable called `fs` and set it equal to the return result from `require`,
    and we''ll require the `fs` module, which is a core node module, so there''s no
    need to install it using NPM:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addNote`函数的上面，让我们加载`fs`模块。我将创建一个名为`fs`的`const`变量，并将其设置为`require`的返回结果，并且我们将要求`fs`模块，这是一个核心的node模块，因此不需要使用NPM安装它：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With this in place, we can take advantage of `fs` inside the `addNote` function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以在`addNote`函数内部利用`fs`。
- en: 'Right after we push our item on to the `notes` array, we''ll call `fs.writeFileSync`,
    which we''ve used before. We know we need to pass in two things: the file name
    and the content we want to save. For the file, I''ll call, `notes-data.JSON`,
    and then we''ll pass in the content to save, which in this case will be the `stringify`
    notes array, which means we can call `JSON.stringify` passing in `notes`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将项目推入`notes`数组之后，我们将调用`fs.writeFileSync`，这是我们以前使用过的。我们知道我们需要传入两件事：文件名和我们想要保存的内容。对于文件，我将调用`notes-data.JSON`，然后我们将传入要保存的内容，这种情况下将是`stringify`
    notes数组，这意味着我们可以调用`JSON.stringify`传入`notes`：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We could have broken `JSON.stringfy(notes)` out into its own variable and referenced
    the variable in the above statement, but since we'll only be using it in one place,
    I find this is the better solution.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将`JSON.stringfy(notes)`拆分为自己的变量，并在上面的语句中引用该变量，但由于我们只会在一个地方使用它，我认为这是更好的解决方案。
- en: At this point, when we add a new note, it will update the `notes-data.JSON`
    file, which will be created on the machine since it does not exist, and the note
    will sit inside it. Now, it's important to note that currently every time you
    add a new note, it will wipe all existing ones because we never load in the existing
    ones, but we can get started testing that this note works as expected.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，当我们添加一个新的笔记时，它将更新`notes-data.JSON`文件，该文件将在机器上创建，因为它不存在，并且笔记将位于其中。现在，重要的是要注意，当前每次添加新的笔记时，它将擦除所有现有的笔记，因为我们从未加载现有的笔记，但我们可以开始测试这个笔记是否按预期工作。
- en: 'I''ll save the file, and over inside of Terminal, we can run this file using
    `node app.js`. Since we want to add a `note`, we will be using that `add` command
    which we set up, then we''ll specify our title and our body. The `title` flag
    can get set equal to `secret`, and for the `body` flag, I''ll set it equal to
    the `Some body here` string, as shown here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我将保存文件，在终端内部，我们可以使用`node app.js`运行这个文件。因为我们想要添加一个`note`，我们将使用我们设置的`add`命令，然后我们将指定我们的标题和正文。`title`标志可以设置为`secret`，对于`body`标志，我将把它设置为`Some
    body here`字符串，如下所示：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, when we run this command from Terminal, we''ll see what we''d expect:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们从终端运行这个命令时，我们将看到我们所期望的结果：
- en: '![](img/c9217989-f386-40c8-93ca-2f52480535b7.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9217989-f386-40c8-93ca-2f52480535b7.png)'
- en: 'As shown in the preceding screenshot, we see a couple of the file commands
    we added: we see that the `add` command was executed, and we have our Yargs arguments.
    The title and body arguments also show up. Inside Atom, we also see that we have
    a new `notes-data.json` file, and in the following screenshot, we have our note,
    with the `secret` title and the `Some body here` body:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们看到了我们添加的一些文件命令：我们看到`add`命令被执行了，并且我们有我们的Yargs参数。标题和正文参数也显示出来了。在Atom中，我们还看到了一个新的`notes-data.json`文件，在下面的屏幕截图中，我们有我们的笔记，有`secret`标题和`Some
    body here`正文：
- en: '![](img/20bb3654-0b57-403a-9e51-106a98033c0d.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20bb3654-0b57-403a-9e51-106a98033c0d.png)'
- en: This is the first step in wiring up that `addNote` function. We have an existing
    `notes` file and we do want to take advantage of these notes. If notes already
    exist, we don't want to simply wipe them every time someone adds a new note. This
    means that in `notes.js`, earlier at the beginning of the `addNote` function,
    we'll fetch those notes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是连接`addNote`函数的第一步。我们有一个现有的`notes`文件，我们确实希望利用这些笔记。如果笔记已经存在，我们不希望每次有人添加新笔记时都将它们简单地清除。这意味着在`notes.js`中，在`addNote`函数的开头，我们将获取这些笔记。
- en: Fetching new notes
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取新笔记
- en: 'I''ll add code for fetching new notes where I define the `notes` and `note`
    variables. As shown in the following code, we''ll use `fs.readFileSync`, which
    we''ve already explored. This will take the filename, in our case, `notes-data.JSON`.
    Now, we will want to store the return value from `readFileSync` on a variable;
    I''ll call that variable, `notesString`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加获取新笔记的代码，在那里我定义了`notes`和`note`变量。如下面的代码所示，我们将使用`fs.readFileSync`，这是我们已经探索过的。这将获取文件名，在我们的情况下是`notes-data.JSON`。现在，我们将希望将`readFileSync`的返回值存储在一个变量上；我将称这个变量为`notesString`：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Since this is the string version, we haven''t passed it through the `JSON.parse`
    method. So, I can set `notes` (the variable we defined earlier in `addNote` function)
    equal to the return value from the `JSON.parse` method. Then `JSON.parse` will
    take the string from the file we read and it will parse it into an array; we could
    pass in `notesString` just like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是字符串版本，我们还没有通过`JSON.parse`方法传递它。因此，我可以将`notes`（我们在`addNote`函数中之前定义的变量）设置为`JSON.parse`方法的返回值。然后`JSON.parse`将获取我们从文件中读取的字符串，并将其解析为一个数组；我们可以像这样传递`notesString`：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With this in place, adding a new note is no longer going to remove all of the
    notes that were already there.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，添加新的笔记将不再删除已经存在的所有笔记。
- en: 'Over in Terminal, I''ll use the up arrow key to load in the last command, and
    I''ll navigate over to the `title` flag and change it to `secret2` and rerun the
    command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我将使用上箭头键加载上一个命令，并导航到`title`标志，将其更改为`secret2`，然后重新运行命令：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In Atom, this time you can see we now have two notes inside of our file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，这次你可以看到我们的文件中现在有两个笔记：
- en: '![](img/f5cb9595-6c07-44ad-8e25-2e20db88fab3.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5cb9595-6c07-44ad-8e25-2e20db88fab3.png)'
- en: We have an array with two objects; the first one has the title of `secret` and
    the second one has the title of `secret2`, which is brilliant!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含两个对象的数组；第一个对象的标题是`secret`，第二个对象的标题是`secret2`，这太棒了！
- en: Trying and catching code block
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试和捕获代码块
- en: 'Now, if the `notes-data.json` file does not exist, which it won''t when the
    user first runs the command, the program will crash, as shown in the following
    code output. We can prove this by simply rerunning the last command after deleting
    the `note-data.JSON` file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`notes-data.json`文件不存在，当用户第一次运行命令时，程序将崩溃，如下面的代码输出所示。我们可以通过简单地删除`note-data.JSON`文件后重新运行上一个命令来证明这一点：
- en: '![](img/0b2d6170-3913-45eb-850b-b86ce5c4720e.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b2d6170-3913-45eb-850b-b86ce5c4720e.png)'
- en: Right here, you can see we're actually getting a JavaScript error, no such file
    or directory; it's trying to open up the `notes-data.JSON` file, but without much
    success. To fix this, we'll use a `try`-`catch` statement from JavaScript, which
    hopefully you've seen in the past. To brush up this, let's go over it really quick.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们实际上遇到了一个JavaScript错误，没有这样的文件或目录；它试图打开`notes-data.JSON`文件，但并不成功。为了解决这个问题，我们将使用JavaScript中的`try`-`catch`语句，希望你之前已经见过。为了快速复习一下，让我们来看一下。
- en: 'To create a `try`-`catch` statement, all you do is you type `try`, which is
    a reserved keyword, and then you open and close a set of curly braces. Inside
    the curly braces is the code that will run. This is the code that may or may not
    throw an error. Next, you''ll specify the `catch` block. Now, the `catch` block
    will take an argument, an error argument, and it also has a code block that runs:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`try`-`catch`语句，你所要做的就是输入`try`，这是一个保留关键字，然后打开和关闭一对花括号。花括号内部是将要运行的代码。这是可能会或可能不会抛出错误的代码。接下来，你将指定`catch`块。现在，`catch`块将带有一个参数，一个错误参数，并且还有一个将运行的代码块：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This code will run if and only if one of your errors in `try` actually occurs.
    So, if we load the file using `readFileSync` and the file exists, that''s fine,
    `catch` block will never run. If it fails, `catch` block will run and we can do
    something to recover from that error. With this in place, all we''ll do is move
    the `noteString` variable and the `JSON.parse` statements into `try`, as shown
    here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在`try`中的一个错误实际发生时，此代码才会运行。因此，如果我们使用`readFileSync`加载文件并且文件存在，那就没问题，`catch`块将永远不会运行。如果失败，`catch`块将运行，我们可以做一些事情来从错误中恢复。有了这个，我们将把`noteString`变量和`JSON.parse`语句移到`try`中，如下所示：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That's it; nothing else needs to happen. We don't need to put any code in `catch`,
    although you do need to define the `catch` block. Now, let's take a look at what
    happens when we run the whole code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；不需要发生其他任何事情。我们不需要在`catch`中放任何代码，尽管您需要定义`catch`块。现在，让我们看看运行整个代码时会发生什么。
- en: The first thing that happens is that we create our static variables—nothing
    special there—then we try to load in the file. If the `notesString` function fails,
    that is fine because we already defined `notes` to be an empty array. If the file
    doesn't exist and it fails, then we probably want an empty array for `notes` anyways,
    because clearly there are no `notes`, and there's no file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先发生的事情是我们创建静态变量——没有什么特别的——然后我们尝试加载文件。如果`notesString`函数失败，那没关系，因为我们已经定义`notes`为空数组。如果文件不存在并且加载失败，那么我们可能希望`notes`为空数组，因为显然没有`notes`，也没有文件。
- en: Next up, we'll parse that data into notes. There is a chance that this will
    fail if there's invalid data in the `notes-data.JSON` file, so the two lines can
    have problems. By putting them in `try`-`catch`, we're basically guaranteeing
    that the program isn't going to work unexpectedly, whether the file does or doesn't
    exist, but it contains corrupted data.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把数据解析成notes。如果`notes-data.JSON`文件中有无效数据，这两行可能会失败。通过将它们放在`try`-`catch`中，我们基本上保证程序不会出现意外情况，无论文件是否存在，但包含损坏的数据。
- en: 'With this in place, we can now save `notes` and rerun that previous command.
    Note that I do not have the `notes-data` file in place. When I run the command,
    we don''t see any errors, everything seems to run as expected:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以保存`notes`并重新运行之前的命令。请注意，我没有放置`notes-data`文件。当我运行命令时，我们没有看到任何错误，一切似乎都按预期运行：
- en: '![](img/c22407eb-04c5-4087-977d-bf2ad0afa79e.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c22407eb-04c5-4087-977d-bf2ad0afa79e.png)'
- en: 'When you now visit Atom, you can see that the `notes-data` file does indeed
    exist, and the data inside it looks great:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现在访问Atom时，您会发现`notes-data`文件确实存在，并且其中的数据看起来很棒：
- en: '![](img/c6741579-1700-4aeb-a58d-9751e468208e.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6741579-1700-4aeb-a58d-9751e468208e.png)'
- en: This is all we need to do to fetch the notes, update the notes with the new
    note, and finally save the notes to the screen.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的一切，获取notes，使用新note更新notes，最后将notes保存到屏幕上。
- en: Now, there is still a slight problem with `addNote`. Currently, `addNote` allows
    for duplicate titles; I could already have a note in the JSON file with the title
    of `secret`. I can come along and try to add a new note with the title of `secret`
    and it will not throw an error. What I'd like to do is to make the title unique,
    so that if there's already a note with that title, it will throw an error, letting
    you know that you need to create a note with a different title.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`addNote`还存在一个小问题。目前，`addNote`允许重复的标题；我可以在JSON文件中已经有一个标题为`secret`的note。我可以尝试添加一个标题为`secret`的新note，它不会抛出错误。我想要做的是使标题唯一，这样如果已经有一个具有该标题的note，它将抛出错误，让您知道需要使用不同的标题创建note。
- en: Making the title unique
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使标题唯一
- en: 'The first step to make the title unique will be to loop through all of the
    notes after we load them in and check whether there are any duplicates. If there
    are duplicates, we''ll not call the following two lines:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使标题唯一的第一步是在加载note后循环遍历所有note，并检查是否有任何重复项。如果有重复项，我们将不调用以下两行：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If there are no duplicates then it's fine, we will call both of the lines shown
    in the preceding code block, updating the `notes-data` file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有重复项，那就没问题，我们将调用前面代码块中显示的两行，更新`notes-data`文件。
- en: Now, we'll be refactoring this function down the line. Things are getting a
    little wonky and a little out of control, but for the moment, we can add this
    functionality right into the function. Let's go ahead and make a variable called
    `duplicateNotes`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在以后重构这个函数。事情变得有点混乱，有点失控，但目前，我们可以将这个功能直接添加到函数中。让我们继续并创建一个名为`duplicateNotes`的变量。
- en: 'The `duplicateNotes` variable will eventually store an array with all of the
    notes that already exist inside the `notes` array that have the title of the note
    you''re trying to create. Now, this means that if the `duplicateNotes` array has
    any items, that''s bad. This means that the note already exists and we should
    not add the note. The `duplicateNotes` variable will get set equal to a call to
    `notes`, which is our array of `notes.filter`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`duplicateNotes`变量最终将存储一个数组，其中包含`notes`数组中已经存在的具有您尝试创建的note标题的note。现在，这意味着如果`duplicateNotes`数组有任何项目，那就不好。这意味着该note已经存在，我们不应该添加该note。`duplicateNotes`变量将被设置为对`notes`的调用，这是我们的`notes.filter`数组：'
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `filter` method is an array method that takes a callback. We''ll use an
    arrow function, and that callback will get called with the argument. In this case,
    it will be the singular version; if I have an array of notes, it will be called
    with an individual note:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`方法是一个接受回调的数组方法。我们将使用箭头函数，回调将使用参数调用。在这种情况下，它将是单数形式；如果我有一个notes数组，它将被调用为一个单独的note：'
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This function gets called once for every item in the array, and you have the
    opportunity to return either true or false. If you return true, it will keep that
    item in the array, which will eventually get saved into `duplicateNotes`. If you
    return false, the new array it generates will not have that item inside `duplicateNotes`
    variable. All we want to do is to return true if the titles match, which means
    that we can return `note.title === title`, as shown here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会为数组中的每个项目调用一次，并且你有机会返回true或false。如果你返回true，它会保留数组中的那个项目，最终会保存到`duplicateNotes`中。如果你返回false，它生成的新数组就不会包含`duplicateNotes`变量中的那个项目。我们只需要在标题匹配时返回true，这意味着我们可以返回`note.title
    === title`，如下所示：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If the titles are equal, then the preceding `return` statement will result as
    true and the item will be kept in the array, which means that there are duplicate
    notes. If the titles are not equal, which is most likely the case, the statement
    will result as false, which means that there are no duplicate notes. Now, we can
    simplify this a little more using arrow functions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标题相等，那么前面的`return`语句将返回true，并且该项目将保留在数组中，这意味着有重复的笔记。如果标题不相等，这很可能是情况，那么该语句将返回false，这意味着没有重复的笔记。现在，我们可以使用箭头函数来简化一下。
- en: Arrow functions actually allow you to remove the curly braces if you only have
    one statement.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数实际上允许你在只有一个语句的情况下删除花括号。
- en: 'I''ll use the arrow function, as shown here:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用箭头函数，如下所示：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, I have deleted everything except `note.title === title` and added this
    in front of the arrow function syntax.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我已经删除了除了`note.title === title`之外的所有内容，并在箭头函数语法的前面添加了这个。
- en: This is perfectly valid using ES6 arrow functions. You have your arguments on
    the left, the arrow, and on the right, you have one expression. The expression
    doesn't take a semicolon and it's automatically returned as the function result.
    This means that the code we have here is identical to the code we had earlier,
    only it's much simpler and it only takes up one line.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这在ES6箭头函数中是完全有效的。你的参数在左边，箭头在中间，右边是一个表达式。这个表达式不需要分号，它会自动返回作为函数结果。这意味着我们这里的代码与之前的代码是相同的，只是更简单，而且只占用一行。
- en: Now that we have this in place, we can go ahead and check the length of the
    `duplicateNotes` variable. If the length of `duplicateNotes` is greater than `0`,
    this means that we don't want to save the note because a note already exists with
    that title. If it is `0`, we'll save the note.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个设置，我们可以继续检查`duplicateNotes`变量的长度。如果`duplicateNotes`的长度大于`0`，这意味着我们不想保存这个笔记，因为已经存在一个具有相同标题的笔记。如果它是`0`，我们将保存这个笔记。
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here, inside the `if` condition, we''re comparing the notes length with the
    number zero. If they are equal, then we do want to push the note onto the `notes`
    array and save the file. I''ll cut the following two lines:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`if`条件内部，我们正在将笔记的长度与数字0进行比较。如果它们相等，那么我们确实想要将笔记推送到`notes`数组中并保存文件。我将删除以下两行：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s paste them right inside of the `if` statement, as shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把它们粘贴到`if`语句的内部，如下所示：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If they're not equal, that's okay too; in that case we'll do nothing.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们不相等，也没关系；在这种情况下，我们将什么也不做。
- en: 'With this in place, we can now save our file and test this functionality out.
    We have our `notes-data.json` file, and this file already has a note with a title
    of `secret2`. Let''s rerun the previous command to try to add a new note with
    that same title:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在可以保存我们的文件并测试这个功能。我们有我们的`notes-data.json`文件，这个文件已经有一个标题为`secret2`的笔记。让我们重新运行之前的命令，尝试添加一个具有相同标题的新笔记：
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![](img/36e0f2c8-3e88-4e3d-a16c-d64b2162035b.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36e0f2c8-3e88-4e3d-a16c-d64b2162035b.png)'
- en: 'You''re in Terminal, so we''ll head back into our JSON file. You can see right
    here that we still just have one note:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在在终端中，所以我们将回到我们的JSON文件。你可以看到，我们仍然只有一个笔记：
- en: '![](img/bca02d09-6b41-42b8-8744-c7a3c3e18ad9.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bca02d09-6b41-42b8-8744-c7a3c3e18ad9.png)'
- en: Now all the titles inside of our application will be unique, so we can use these
    titles to fetch and delete notes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用程序中的所有标题都将是唯一的，所以我们可以使用这些标题来获取和删除笔记。
- en: 'Let''s go ahead and test that other notes can still be added. I''ll change
    the `title` flag from `secret2` to `secret`, and run that command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续测试其他笔记是否仍然可以添加。我将把`title`标志从`secret2`改为`secret`，然后运行该命令：
- en: '[PRE69]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '![](img/2ae3b082-396c-487d-80cd-c823b4500d9e.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ae3b082-396c-487d-80cd-c823b4500d9e.png)'
- en: 'Inside our `notes-data` file, you can see both notes show up:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`notes-data`文件中，你可以看到两个笔记都显示出来：
- en: '![](img/e1998cee-6016-4e62-aacf-8dec5cd336ff.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1998cee-6016-4e62-aacf-8dec5cd336ff.png)'
- en: As I mentioned earlier, next we will be doing some refactoring, since the code
    that loads the file, and the code that saves the file, will both be used in most
    of the functions we have defined and/or will define (that is, the `getAll`, `getNote`
    and `removeNote` functions).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，接下来我们将进行一些重构，因为加载文件的代码和保存文件的代码将在我们已经定义和/或将要定义的大多数函数中使用（即`getAll`、`getNote`和`removeNote`函数）。
- en: Refactoring
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: In the previous section, you created the `addNote` function, which works well.
    It starts by creating some static variables, then we fetch any existing notes,
    we check for duplicates, and if there are none, we push it onto the list, and
    then we save the data back into the filesystem.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，你创建了`addNote`函数，它工作得很好。它首先创建一些静态变量，然后我们获取任何现有的笔记，检查重复项，如果没有，我们将其推送到列表上，然后将数据保存回文件系统。
- en: The only problem is that we'll be doing a lot of these steps over and over again
    for every method. For example, with `getAll`, the idea is to fetch all of the
    notes, and send them back to `app.js` so it can print them to the screen for the
    user. The first thing we'll to do inside of the `getAll` statement is have the
    same code; we'll have our `try`-`catch` block to fetch the existing notes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是，我们将不断重复执行这些步骤。例如，对于`getAll`，我们的想法是获取所有的笔记，并将它们发送回`app.js`，以便它可以将它们打印到用户的屏幕上。在`getAll`语句的内部，我们首先要做的是有相同的代码；我们将有我们的`try`-`catch`块来获取现有的笔记。
- en: Now, this is a problem because we'll be repeating code throughout the application.
    It will be best to break out the fetching of notes and the saving of notes into
    separate functions that we can call in multiple locations.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是一个问题，因为我们将在整个应用程序中重复使用代码。最好将获取笔记和保存笔记拆分为单独的函数，我们可以在多个位置调用这些函数。
- en: Moving functionality into individual functions
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将功能移入各个函数
- en: 'To resolve the problem, I''d like to get started by creating two new functions:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题，我想首先创建两个新函数：
- en: '`fetchNotes`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchNotes`'
- en: '`saveNotes`'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saveNotes`'
- en: 'The first function, `fetchNotes`, will be an arrow function, and it will not
    to take any arguments since it will be fetching notes from the filesystem, as
    shown here:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`fetchNotes`将是一个箭头函数，它不需要接受任何参数，因为它将从文件系统中获取笔记，如下所示：
- en: '[PRE70]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The second function, `saveNotes`, will need to take an argument. It will need
    to take the `notes` array you want to save to the filesystem. We''ll set it equal
    to an arrow function, and then we''ll provide our argument, which I will name
    `notes`, as shown here:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数`saveNotes`将需要接受一个参数。它将需要接受要保存到文件系统的`notes`数组。我们将设置它等于一个箭头函数，然后提供我们的参数，我将其命名为`notes`，如下所示：
- en: '[PRE71]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now that we have these two functions, we can go ahead and start moving some
    of the functionality from `addNote` up into the individual functions.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这两个函数，我们可以开始将一些功能从`addNote`中移动到各个函数中。
- en: Working with fetchNotes
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fetchNotes
- en: First up, let's do `fetchNotes`, which will need the following `try`-`catch`
    block.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们做`fetchNotes`，它将需要以下`try`-`catch`块。
- en: 'I''ll actually cut it out of `addNote` and paste it in the `fetchNotes` function,
    as shown here:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我将它从`addNote`中剪切出来，粘贴到`fetchNotes`函数中，如下所示：
- en: '[PRE72]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This alone is not enough, because currently we don''t return anything from
    the function. What we want to do is to return the notes. This means that instead
    of saving the result from `JSON.parse` onto the `notes` variable, which we haven''t
    defined, we''ll simply return it to the calling function, as shown here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此还不够，因为目前我们没有从函数中返回任何内容。我们想要做的是返回这些笔记。这意味着我们不会将`JSON.parse`的结果保存到我们尚未定义的`notes`变量上，而是简单地将其返回给调用函数，如下所示：
- en: '[PRE73]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: So, if I call `fetchNotes` in the `addNote` function, shown as follows, I will
    get the `notes` array because of the `return` statement in the preceding code.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我在`addNote`函数中调用`fetchNotes`，如下所示，我将得到`notes`数组，因为在前面的代码中有`return`语句。
- en: 'Now, if there are no notes, maybe there''s no file at all; or there is a file,
    but the data isn''t JSON, we can return an empty array. We''ll add a `return`
    statement inside of `catch`, as shown in the following code block, because remember,
    `catch` runs if anything inside `try` fails:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果没有笔记，可能根本没有文件；或者有一个文件，但数据不是JSON，我们可以返回一个空数组。我们将在`catch`中添加一个`return`语句，如下面的代码块所示，因为请记住，如果`try`中的任何内容失败，`catch`就会运行：
- en: '[PRE74]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, this lets us simplify `addNote` even further. We can remove the empty
    space and we can take the array that we set on the `notes` variable and remove
    it and instead call `fetchNotes`, as shown here:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这让我们进一步简化了`addNote`。我们可以删除空格，并且可以取出我们在`notes`变量上设置的数组，并将其删除，而是调用`fetchNotes`，如下所示：
- en: '[PRE75]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: With this in place, we now have the exact same functionality we had before,
    but we have a reusable function, `fetchNotes`, which we can use in the `addNote`
    function to handle the other commands that our app will support.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有了与之前完全相同的功能，但是我们有了一个可重用的函数`fetchNotes`，我们可以在`addNote`函数中使用它来处理应用程序将支持的其他命令。
- en: Instead of copying code and having it in multiple places in your file, we've
    broken it into one place. If we ever want to change how this functionality works,
    whether we want to change the filename or some of the logic such as the `try`-`catch`
    block, we can change it once instead of having to change it in every function
    we have.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将代码拆分到一个地方，而不是复制代码并将其放在文件的多个位置。如果我们想要更改此功能的工作方式，无论是更改文件名还是一些逻辑，比如`try`-`catch`块，我们只需更改一次，而不必更改每个函数中的代码。
- en: Working with saveNotes
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用saveNotes
- en: 'Now, the same thing will go for `saveNotes` just as in the case of the `fetchNotes`
    function. The `saveNotes` function will take the `notes` variable and it will
    say this using `fs.writeFileSync`. I will cut out the line in `addNote` that does
    this (that is, `fs.writeFileSync(''notes-data.json'', JSON.stringfy(notes));`)
    and paste it in the `saveNotes` function, as shown here:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`saveNotes`的情况与`fetchNotes`函数一样。`saveNotes`函数将获取`notes`变量，并使用`fs.writeFileSync`来保存。我将剪切`addNote`中执行此操作的行（即`fs.writeFileSync('notes-data.json',
    JSON.stringfy(notes));`），并将其粘贴到`saveNotes`函数中，如下所示：
- en: '[PRE76]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, `saveNotes` doesn''t need to return anything. In this case, we''ll copy
    the line in `saveNotes` and then call `saveNotes` in the `if` statement of the
    `addNote` function, as shown in the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`saveNotes`不需要返回任何内容。在这种情况下，我们将在`addNote`函数的`if`语句中复制`saveNotes`中的行，并调用`saveNotes`，如下所示：
- en: '[PRE77]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This might seem like overkill, we've essentially taken one line and replaced
    it with a different line, but it is a good idea to start getting in the habit
    of creating reusable functions.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点多余，我们实际上是用不同的行替换了一行，但开始养成创建可重用函数的习惯是一个好主意。
- en: 'Now, calling `saveNotes` with no data is not going to work, we want to pass
    in the `notes` variable, which is our `notes` array defined earlier in the `saveNotes`
    function:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果没有数据调用`saveNotes`是行不通的，我们想要传入`notes`变量，这是我们在`saveNotes`函数中之前定义的`notes`数组：
- en: '[PRE78]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: With this in place, the `addNote` function should now work as it did before
    we did any of our refactoring.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，`addNote`函数现在应该像我们进行重构之前一样工作。
- en: Testing the functionality
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试功能
- en: 'The next step in the process will be to test this out by creating a new note.
    We already have two notes, with a title of `secret` and a title of `secret2` in
    `notes-data.json`, let''s make a third one using the `node app.js` command in
    Terminal. We''ll use the `add` command and pass in a title of `to buy` and a body
    of `food`, as shown here:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中的下一步将是通过创建一个新的笔记来测试这个功能。我们已经有两个笔记，在`notes-data.json`中有一个标题是`secret`，一个标题是`secret2`，让我们使用终端中的`node
    app.js`命令来创建第三个笔记。我们将使用`add`命令并传入一个标题`to buy`和一个正文`food`，就像这里显示的那样：
- en: '[PRE79]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This should create a new note, and if I run the command, you can see we don''t
    have any obvious errors:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会创建一个新的笔记，如果我运行这个命令，你会看到我们没有任何明显的错误：
- en: '![](img/d5e2807f-894f-416c-9d86-6117f68a76f2.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5e2807f-894f-416c-9d86-6117f68a76f2.png)'
- en: 'Inside of our `notes-data.json` file, if I scroll to the right, we have our
    brand new note as a title of `to buy` and a body of `food`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`notes-data.json`文件中，如果我向右滚动，我们有一个全新的笔记，标题是`to buy`，正文是`food`：
- en: '![](img/c5c5b8e9-aac7-4a78-af70-483f995a4e0d.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5c5b8e9-aac7-4a78-af70-483f995a4e0d.png)'
- en: 'So, everything is working as expected even though we''ve refactored the code.
    Now, the next thing I want to do inside `addNote` is take a moment to return the
    note that''s being added, and that will happen right after `saveNotes` comes back.
    So we''ll return `note`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，即使我们重构了代码，一切都按预期工作。现在，我想在`addNote`中的下一步是花点时间返回正在添加的笔记，这将发生在`saveNotes`返回之后。所以我们将返回`note`：
- en: '[PRE80]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This `note` object will get returned to whoever called the function, and in
    this case, it will get returned to `app.js`, where we called it in the `if else`
    block of the `add` command in the `app.js` file. We can make a variable to store
    this result and we can call it `note`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`note`对象将被返回给调用该函数的人，而在这种情况下，它将被返回给`app.js`，我们在`app.js`文件的`add`命令的`if else`块中调用它。我们可以创建一个变量来存储这个结果，我们可以称之为`note`：
- en: '[PRE81]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If `note` exists, then we know that the note was created. This means that we
    can go ahead and print a message, like `Note created`, and we can print the `note`
    title and the `note` body. Now, if `note` does not exist, if it's undefined, this
    means that there was a duplicate and that title already exists. If that's the
    case, I want you to print an error message such as `Note title already in use`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`note`存在，那么我们知道笔记已经创建。这意味着我们可以继续打印一条消息，比如`Note created`，然后我们可以打印`note`的标题和`note`的正文。现在，如果`note`不存在，如果它是未定义的，这意味着有一个重复的标题已经存在。如果是这种情况，我希望你打印一个错误消息，比如`Note
    title already in use`。
- en: There's a ton of different ways you could do this. The goal, though, is to print
    two different messages depending on whether or not a note was returned.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用很多不同的方法来做这个。不过，目标是根据是否返回了笔记来打印两条不同的消息。
- en: Now, inside `addNote`, if the `duplicateNotes` `if` statement never runs, we
    don't have an explicit call to return. But as you know, in JavaScript, if you
    don't call `return`, then `undefined` automatically is returned. This means that
    if `duplicateNotes.length` is not equal to zero, undefined will be returned and
    we can use that as the condition for our statement.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`addNote`中，如果`duplicateNotes`的`if`语句从未运行，我们就没有显式调用`return`。但是你知道，在JavaScript中，如果你不调用`return`，那么`undefined`会自动返回。这意味着如果`duplicateNotes.length`不等于零，将返回undefined，我们可以将其用作我们语句的条件。
- en: 'The first thing I''ll do here is to create an `if` statement, right next to
    the `note` variable we defined in `app.js`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我要做的是在我们在`app.js`中定义的`note`变量旁边创建一个`if`语句：
- en: '[PRE82]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This will be an object if things went well, and it will be undefined if things
    went poorly. This code in here is only ever going to run if it's an object. The
    `Undefined` result will fail the condition inside of JavaScript.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事情进展顺利，这将是一个对象，如果事情进展不顺利，它将是未定义的。这里的代码只有在它是一个对象的时候才会运行。在JavaScript中，`Undefined`的结果会使JavaScript中的条件失败。
- en: 'Now, if the `note` was created successfully, what we''ll do is to print a little
    message to the screen, using the following `console.log` statement:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果笔记成功创建，我们将通过以下`console.log`语句向屏幕打印一条消息：
- en: '[PRE83]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If things went poorly, inside the `else` clause, we can call `console.log`,
    and we can print something like `Note title taken`, as shown here:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事情进展不顺利，在`else`子句中，我们可以调用`console.log`，并打印一些像`Note title taken`这样的东西，就像这里显示的那样：
- en: '[PRE84]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, the other thing that we want to do if things went well is print the `notes`
    content. I''ll do this by first using `console.log` to print a couple of hyphens.
    This will create a little space above my note. Then I can use `console.log` twice:
    the first time we''ll print the title, I''ll add `Title:` as a string to show
    you what exactly you''re seeing, then I can concatenate the title, which we have
    access to in `note.title`, as shown in this code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果事情进展顺利，我们想要做的另一件事是打印`notes`的内容。我会首先使用`console.log`打印几个连字符。这将在我的笔记上方创建一些空间。然后我可以使用`console.log`两次：第一次我们将打印标题，我会添加`Title:`作为一个字符串来显示你究竟看到了什么，然后我可以连接标题，我们可以在`note.title`中访问到，就像这段代码中显示的那样：
- en: '[PRE85]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, the preceding syntax uses an ES5 syntax; we can swap this out with an
    ES6 syntax using what we''ve already talked about: template strings. We''ll add
    `Title`, a colon, and then we can use our dollar sign with our curly braces to
    inject the `note.title` variable, as shown here:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，上面的语法使用了ES5的语法；我们可以用我们已经讨论过的内容，即模板字符串，来换成ES6的语法。我们会添加`Title`，一个冒号，然后我们可以使用我们的美元符号和花括号来注入`note.title`变量，就像这里显示的那样：
- en: '[PRE86]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Similarly, I''ll add `note.body` after this to print out the body of the note.
    With this in place, the code should look like:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我会在此之后添加`note.body`来打印笔记的正文。有了这个，代码应该看起来像这样：
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, we should be able to run our app and see both of the title and body notes
    printed. In Terminal, I''ll rerun the previous command. This will try to create
    a note with to buy, which already exists, so we should get an error message, and
    right here you can see Note title taken:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够运行我们的应用程序并看到标题和正文笔记都被打印出来。在终端中，我会重新运行之前的命令。这将尝试创建一个已经存在的购买笔记，所以我们应该会得到一个错误消息，你可以在这里看到`Note
    title taken`：
- en: '![](img/bc0ca745-0319-4bf4-b419-5c68751c4556.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc0ca745-0319-4bf4-b419-5c68751c4556.png)'
- en: 'Now, we can rerun the command, changing the title to something else, such as
    `to buy from store`. This is a unique `note` title so the note should get created
    without any problems:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新运行命令，将标题更改为其他内容，比如`从商店购买`。这是一个独特的`note`标题，因此笔记应该可以顺利创建：
- en: '[PRE88]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '![](img/5a370f6c-aeea-483e-bea1-63915466ed7b.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a370f6c-aeea-483e-bea1-63915466ed7b.png)'
- en: 'As shown in the preceding output, you can see that we get just that: we have
    our Note created message, our little spacer, and our title along with the body.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，您可以看到我们确实得到了这样的结果：我们有我们的笔记创建消息，我们的小间隔，以及我们的标题和正文。
- en: The `addNote` command is now complete. We have an output when the command actually
    finishes, and we have all the code that runs behind the scenes to add the note
    to the data that gets stored in our file.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`addNote`命令现在已经完成。当命令实际完成时，我们会得到一个输出，并且我们有所有在后台运行的代码，将笔记添加到存储在我们文件中的数据中。'
- en: Summary
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned that parsing in `process.argv` can be a real pain.
    We would have to write a lot of manual code to parse out those hyphens, the equal
    signs, and the optional quotes. However, yargs can do all of that for us and it
    puts it on a really simple object we can access. You also learned how to work
    with JSON inside Node.js.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解到在`process.argv`中解析可能会非常痛苦。我们将不得不编写大量手动代码来解析那些连字符、等号和可选引号。然而，yargs可以为我们完成所有这些工作，并将其放在一个非常简单的对象上，我们可以访问它。您还学会了如何在Node.js中使用JSON。
- en: Next, we filled out the `addNote` function. We're able to add notes using the
    command line, and we're able to save those notes into a JSON file. Finally, we
    pulled out a lot of the code from `addNote` into separate functions, `fetchNotes`
    and `saveNotes`, which are now separate, and they're able to be reused throughout
    the code. When we start filling out the other methods, we can simply call `fetchNotes`
    and `saveNotes` instead of having to copy the contents over and over again to
    every new method.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们填写了`addNote`函数。我们能够使用命令行添加笔记，并且能够将这些笔记保存到一个JSON文件中。最后，我们将`addNote`中的大部分代码提取到单独的函数`fetchNotes`和`saveNotes`中，这些函数现在是独立的，并且可以在整个代码中重复使用。当我们开始填写其他方法时，我们可以简单地调用`fetchNotes`和`saveNotes`，而不必一遍又一遍地将内容复制到每个新方法中。
- en: In the next chapter, we'll continue our journey on node fundamentals. We'll
    explore some more concepts related to node, such as debugging; we'll work on the
    `read` and `remove` notes commands. Apart from this, we'll also learn about the
    advanced features of yargs and the arrow function.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨有关node的基本知识。我们将探索与node相关的一些更多概念，比如调试；我们将处理`read`和`remove`笔记命令。除此之外，我们还将学习有关yargs和箭头函数的高级特性。
