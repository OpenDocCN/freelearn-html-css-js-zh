- en: Promises in Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程中的promises
- en: In the previous two chapters, we looked at many important concepts of asynchronous
    programming in Node. This chapter is about promises. Promises are available in
    JavaScript since ES6\. Although they have been around in third-party libraries
    for quite some time, they finally made their way into the core JavaScript language,
    which is great because they're a really fantastic feature.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们学习了Node中许多重要的异步编程概念。本章是关于promises的。自ES6以来，JavaScript中就有了promises。尽管它们在第三方库中已经存在了相当长的时间，但它们最终进入了核心JavaScript语言，这很棒，因为它们是一个真正棒的特性。
- en: In this chapter, we'll learn about how promises work, we'll start to understand
    exactly why they're useful, and why they've even come to exist inside JavaScript. We'll
    take a look at a library called axios that supports promises. This will let us
    simplify our code, creating our promise calls easily. We'll actually rebuild an
    entire weather app in the last section.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习promise的工作原理，开始了解它们为什么有用，以及它们为什么甚至存在于JavaScript中。我们将看一下一个叫做axios的库，它支持promises。这将让我们简化我们的代码，轻松地创建我们的promise调用。我们实际上将在最后一节重新构建整个天气应用程序。
- en: 'Specifically, we''ll look into following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将研究以下主题：
- en: Introduction to ES6 promises
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6 promises简介
- en: Advanced promises
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级promises
- en: Weather app with promises
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用promises的天气应用程序
- en: Introduction to ES6 promises
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6 promises简介
- en: Promises aim to solve a lot of the problems that come up when we have a lot
    of asynchronous code in our application. They make it a lot easier to manage our
    asynchronous computations—things such as requesting data from a database. Alternatively,
    in the case of a weather app, things such as fetching data from a URL.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Promises旨在解决我们的应用程序中存在大量异步代码时出现的许多问题。它们使我们更容易管理我们的异步计算，比如从数据库请求数据。或者在天气应用程序的情况下，比如从URL获取数据。
- en: 'In the `app.js` file we do a similar thing using callbacks:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`文件中，我们使用回调做了类似的事情：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code, we have two callbacks:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们有两个回调：
- en: One that gets passed into `geocodeAddress`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`geocodeAddress`的一个
- en: One that gets passed into `getWeather`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`getWeather`的一个
- en: We use this to manage our asynchronous actions. In our case, it's things such
    as fetching data from an API, using an HTTP request. We can use promises in this
    example to make the code a lot nicer. This is exactly the aim later in the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个来管理我们的异步操作。在我们的情况下，这些操作包括从API获取数据，使用HTTP请求。在这个例子中，我们可以使用promises来使代码更加简洁。这正是本章的目标。
- en: In this section, we'll explore the basics concept of promises. We'll compare
    and contrast callbacks with promises just yet, because there's a lot more subtleties
    than can be described without knowing exactly how promises work. So, before we
    talk about why they're better, we will simply create some.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨promise的基本概念。我们暂时不会比较和对比回调和promise，因为有很多微妙之处，不能在不知道promise如何工作的情况下描述。因此，在我们讨论它们为什么更好之前，我们将简单地创建一些。
- en: Creating an example promise
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个例子promise
- en: In the Atom, inside the `playground` folder, we'll create a new file and call
    it `promise.js`. Before we define promises and talk about exactly how they work,
    we will run through a simple example because that is the best way to learn just
    about anything—going through an example and seeing how it works.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，我们将在`playground`文件夹中创建一个新文件，并将其命名为`promise.js`。在我们定义promise并讨论它们的工作原理之前，我们将通过一个简单的例子来运行，因为这是学习任何东西的最佳方式——通过一个例子并看到它是如何工作的。
- en: To get started, we'll work through a very basic example. We'll stick to the
    core promise features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过一个非常基本的例子来开始。我们将坚持核心promise功能。
- en: 'To get started with this very simple example, we''ll make a variable called
    `somePromise`. This will eventually store the promise object. We''ll be calling
    various methods on this variable to do something with the promise. We''ll set
    the `somePromise` variable equal to the return result from the constructor function
    for promises. We''ll use the `new` keyword to create a new instance of a promise.
    Then, we''ll provide the thing we want to create a new instance of, `Promise`,
    as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个非常简单的例子，我们将创建一个名为`somePromise`的变量。这将最终存储promise对象。我们将在这个变量上调用各种方法来处理promise。我们将把`somePromise`变量设置为promise构造函数的返回结果。我们将使用`new`关键字创建promise的新实例。然后，我们将提供我们想要创建新实例的东西，`Promise`，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now this `Promise` function, which is indeed a function—we have to call it
    like one; that is, it takes one argument. This argument will be a function. We''ll
    use an anonymous arrow function (`=>`), and inside it, we''ll do all of the asynchronous
    stuff we want to do:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个`Promise`函数，实际上是一个函数——我们必须像调用函数一样调用它；也就是说，它需要一个参数。这个参数将是一个函数。我们将使用一个匿名箭头函数(`=>`)，在其中，我们将做所有我们想做的异步工作：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It will all be abstracted, kind of like we abstract the HTTP request inside
    the `geocodeAddress` function in the `geocode.js` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被抽象化，有点像我们在`geocode.js`文件的`geocodeAddress`函数中抽象化HTTP请求一样：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All of the complex logic in the `geocodeAddress` function does indeed need to
    happen, but the `app.js` file doesn't need to worry about it. The `geocode.geocodeAddress`
    function in the `app.js` file has a very simple `if` statement that checks whether
    there's an error. If there is an error, we will print a message, and if there's
    not, we move on. The same thing will be true with promises.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`geocodeAddress`函数中的所有复杂逻辑确实需要发生，但`app.js`文件不需要担心它。`app.js`文件中的`geocode.geocodeAddress`函数有一个非常简单的`if`语句，检查是否有错误。如果有错误，我们将打印一条消息，如果没有，我们将继续。同样的情况也适用于promises。'
- en: 'The `new Promise` callback function will get called with two arguments, `resolve`
    and `reject`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Promise`回调函数将使用两个参数`resolve`和`reject`调用：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is how we'll manage the state of our promise. When we make a promise, we're
    making a promise; we're saying, "Hey, I'll go off and I'll fetch that website
    data for you." Now this could go well, in which case, you will `resolve` the promise,
    setting its state to fulfilled. When a promise is fulfilled, it's gone out and
    it's done the thing you've expected it to do. This could be a database request,
    an HTTP request, or something else completely.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们管理承诺状态的方式。当我们做出承诺时，我们正在做出承诺；我们在说，“嘿，我会去并且为你获取那个网站的数据。”现在这可能会顺利进行，这种情况下，你会`resolve`承诺，将其状态设置为实现。当一个承诺实现时，它已经出去并且做了你期望它做的事情。这可能是一个数据库请求，一个HTTP请求，或者完全不同的东西。
- en: Now when you call `reject`, you're saying, "Hey, we tried to get that thing
    done man, but we just could not." So the promise has been considered rejected.
    These are the two states that you can set a promise to—fulfilled or rejected.
    Just like inside `geocode.js`, we either provide one argument for an error, or
    we provide the second argument if things went well. Instead of doing that though,
    promises give us two functions we can call.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你调用`reject`时，你是在说，“嘿，我们试图完成那件事，但我们就是无法。”所以承诺被认为是被拒绝的。这是你可以设置一个承诺的两种状态——实现或拒绝。就像在`geocode.js`中一样，如果事情顺利进行，我们要么为错误提供一个参数，要么为第二个参数提供一个参数。不过，承诺给了我们两个可以调用的函数。
- en: 'Now, in order to illustrate exactly how we can use these, we''ll call `resolve`.
    Once again, this is not asynchronous. We''re not doing anything quite yet. So
    all of this will happen essentially in real time, as far as you see in Terminal.
    We''ll call `resolve` with some data. In this case, I''ll pass in a string, `Hey.
    It worked!`, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了准确说明我们如何使用这些，我们将调用`resolve`。再次强调，这不是异步的。我们还没有做任何事情。所以所有这些都将在终端中实时发生。我们将使用一些数据调用`resolve`。在这种情况下，我将传入一个字符串`嘿。它起作用了！`如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now this string is the value the promise was fulfilled with. This is exactly
    what someone will get back. In case of the `geocode.geocodeAddress` function in
    app file, it could be the data, whether it's the results or the error message.
    In our case though, we're using `resolve`, so this will be the actual data the
    user wanted. When things go well, `Hey. It worked!` is what they expect.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个字符串就是承诺实现的价值。这正是某人会得到的。在应用文件中的`geocode.geocodeAddress`函数的情况下，它可能是数据，无论是结果还是错误消息。但在我们的情况下，我们使用`resolve`，所以这将是用户想要的实际数据。当事情顺利进行时，“嘿。它起作用了！”就是他们期望的。
- en: Now you can only pass one argument to both `resolve` and `reject`, which means
    that if you want to provide multiple pieces of information I recommend that you
    resolve or reject an object that you can set multiple properties on. In our case
    though, a simple message, `Hey. It worked!`, will do the job.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只能给`resolve`和`reject`传递一个参数，这意味着如果你想提供多个信息，我建议你解决或拒绝一个对象，你可以在上面设置多个属性。但在我们的情况下，一个简单的消息“嘿。它起作用了！”就可以了。
- en: Calling the promise method then
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 然后调用承诺方法
- en: Now in order to actually do something when the promise gets either resolved
    or rejected, we need to call a promise method called `then`; `somePromise.then`.
    The `then` method lets us provide `callback` functions for both success and error
    cases. This is one of the areas where callbacks differ from promises. In a callback,
    we had one function that fired no matter what, and the arguments let us know whether
    or not things went well. With promises we'll have two functions, and this will
    be what determines whether or not things went as planned.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在承诺被实现或拒绝时实际执行某些操作，我们需要调用一个名为`then`的承诺方法；`somePromise.then`。`then`方法让我们为成功和错误情况提供`回调`函数。这是回调和承诺之间的一个区别。在回调中，我们有一个无论如何都会触发的函数，参数让我们知道事情是否顺利进行。而在承诺中，我们将有两个函数，这将决定事情是否按计划进行。
- en: 'Now before we dive into adding two functions, let''s start with just one. Right
    here, I''ll call then, passing in one function. This function will only get called
    if the promise gets fulfilled. This means that it works as expected. When it does,
    it will get called with the value passed to `resolve`. In our case, it''s a simple
    `message`, but it can be something like a user object in the case of a database
    request. For now though, we''ll stick with `message`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们深入添加两个函数之前，让我们先从一个函数开始。在这里，我将调用`then`，传入一个函数。只有在承诺实现时，这个函数才会被调用。这意味着它按预期工作。当它这样做时，它将被调用并传递给`resolve`。在我们的情况下，它是一个简单的`message`，但在数据库请求的情况下，它可以是像用户对象这样的东西。不过，现在我们将坚持使用`message`：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will print `message` to the screen. Inside the callback, when the promise
    gets fulfilled we''ll call `console.log`, printing `Success`, and then as a second
    argument, we''ll print the actual `message` variable:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在屏幕上打印`message`。在回调中，当承诺得到实现时，我们将调用`console.log`，打印“成功”，然后作为第二个参数，我们将打印实际的`message`变量：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running the promise example in Terminal
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在终端中运行承诺示例
- en: 'Now that we have a very basic promise example in place, let''s run it from
    the Terminal using `nodemon`, which we installed in the previous chapter. We''ll
    add `nodemon`, and then we''ll go into the `playground` folder, `/promise.js`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个非常基本的承诺示例，让我们使用我们在上一章中安装的`nodemon`从终端运行它。我们将添加`nodemon`，然后进入`playground`文件夹，`/promise.js`。
- en: '![](img/1baa93e7-2dda-4403-af61-a5918704c603.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1baa93e7-2dda-4403-af61-a5918704c603.png)'
- en: When we do this right away, our app runs and we get success. `Hey. It worked!` This
    happens instantaneously. There was no delay because we haven't done anything asynchronously.
    Now when we first explored callbacks (refer to [Chapter 5](b34c7f1b-8ae4-4974-a24b-6051605af3c7.xhtml),
    *Basics of Asynchronous Programming in Node.js* ), we used `setTimeout` to simulate
    a delay, and this is exactly what we'll do in this case.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们立即这样做时，我们的应用程序运行并且我们获得成功。“嘿。它起作用了！”这是瞬间发生的。没有延迟，因为我们还没有异步地做任何事情。现在当我们首次探索回调时（参见[第5章](b34c7f1b-8ae4-4974-a24b-6051605af3c7.xhtml)，*Node.js中异步编程的基础*），我们使用`setTimeout`来模拟延迟，这正是我们在这种情况下要做的。
- en: 'Inside our `somePromise` function, we''ll call `setTimeout`, passing in the
    two arguments: the function to call after the delay and the delay in milliseconds.
    I''ll go with `2500`, which is 2.5 seconds:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`somePromise`函数中，我们将调用`setTimeout`，传入两个参数：延迟后要调用的函数和以毫秒为单位的延迟。我将选择`2500`，即2.5秒：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now after those 2.5 seconds are up, then, and only then, do we want to `resolve`
    the promise. This means that our function, the one we pass into then will not
    get called for 2.5 seconds. Because, as we know, this will not get called until
    the promise resolves. I''ll save the file, which will restart `nodemon`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这2.5秒之后，然后，只有在这时，我们才希望`resolve`承诺。这意味着我们的函数，我们传递给`then`的函数将在2.5秒后才会被调用。因为，正如我们所知，这将在承诺解决之前不会被调用。我将保存文件，这将重新启动`nodemon`：
- en: '![](img/3b7bd22e-6649-463f-b385-3764d2b41738.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b7bd22e-6649-463f-b385-3764d2b41738.png)'
- en: 'In Terminal, you can see we have our delay, and then `success: Hey it worked!`
    prints to the screen. This 2.5 second delay was caused by this `setTimeout`. After
    the delay was up (in this case it''s an artificial delay, but later it''ll be
    a real delay), we''re able to `resolve` with the data.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '在终端中，你可以看到我们有延迟，然后`success: Hey it worked!`打印到屏幕上。这2.5秒的延迟是由`setTimeout`引起的。延迟结束后（在这种情况下是人为延迟，但以后将是真正的延迟），我们能够用数据`resolve`。'
- en: Error handling in promises
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺中的错误处理
- en: 'Now there''s a chance that things didn''t go well. We have to handle errors
    inside our Node applications. In that case, we wouldn''t call `resolve`, we would
    call `reject`. Let''s comment out the `resolve` line, and create a second one,
    where we call `reject`. We''ll call `reject` much the same way we called `resolve`.
    We have to pass in one argument, and in this case, a simple error message like `Unable
    to fulfill promise` will do:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有可能事情并不顺利。我们必须在Node应用程序中处理错误。在这种情况下，我们不会调用`resolve`，而是会调用`reject`。让我们注释掉`resolve`行，并创建第二行，在这一行中我们调用`reject`。我们将以与调用`resolve`相同的方式调用`reject`。我们必须传入一个参数，在这种情况下，一个简单的错误消息如`无法实现承诺`就可以了。
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now when we call `reject`, we''re telling the promise that it has been rejected.
    This means that the thing we tried to do did not go well. Currently, we don''t
    have an argument that handles this. As we mentioned, this function only gets called
    when things go as expected, not when we have errors. If I save the file and rerun
    it in Terminal, what we''ll get is a promise that rejects:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们调用`reject`时，我们告诉承诺它已被拒绝。这意味着我们尝试的事情并不顺利。目前，我们没有处理这一点的参数。正如我们提到的，这个函数只有在事情按预期进行时才会被调用，而不是在出现错误时。如果我保存文件并在终端中重新运行它，我们将得到一个拒绝的承诺：
- en: '![](img/a5925ae3-0b3a-4186-8be9-73ed7d094396.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5925ae3-0b3a-4186-8be9-73ed7d094396.png)'
- en: However, we don't have a handler for it, so nothing will print to the screen.
    This will be a pretty big problem. We need to do something with that error message.
    Maybe we will alert the user, or we will try some other code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有一个处理程序，所以什么都不会打印到屏幕上。这将是一个相当大的问题。我们需要对错误消息做些什么。也许我们会警告用户，或者我们会尝试一些其他代码。
- en: 'As shown in the previous code output, we can see that nothing printed between
    the restarting and exiting. In order to do something with the error, we''ll add
    a second argument to the `then` method. This second argument is what lets us handle
    errors in our promises. This argument will get executed and called with that value.
    In this case, it''s our message. We''ll create an argument called `errorMessage`,
    as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码输出所示，我们可以看到在重新启动和退出之间没有打印任何内容。为了处理错误，我们将在`then`方法中添加第二个参数。这个第二个参数让我们能够处理承诺中的错误。这个参数将被执行，并用该值调用。在这种情况下，它是我们的消息。我们将创建一个名为`errorMessage`的参数，如下所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the argument, we can do something with that. In this case, we''ll print
    it to the screen using `console.log`, printing `Error` with a colon and a space
    to add some nice formatting, followed by the actual value that was rejected:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数中，我们可以对其进行一些操作。在这种情况下，我们将使用`console.log`将其打印到屏幕上，打印带有冒号和空格的`Error`，然后是被拒绝的实际值：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have this in place, we can refresh things by saving the file. We
    will now see our error message in Terminal, because we now have a place for it
    to do something:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这个，我们可以通过保存文件来刷新事情。现在我们将在终端中看到我们的错误消息，因为我们现在有一个可以做一些事情的地方：
- en: '![](img/6a3cb6c6-97d1-4630-8932-6e8a8bfaa198.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a3cb6c6-97d1-4630-8932-6e8a8bfaa198.png)'
- en: Here, we have a place for it to print the message to the screen; `Unable to
    fulfill promise` prints to the screen, which works exactly as expected.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个地方可以将消息打印到屏幕上；`无法实现承诺`打印到屏幕上，这正如预期的那样。
- en: Merits of promises
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺的优点
- en: We now have a promise that can either get resolved or rejected. If it gets resolved,
    meaning the promise was fulfilled, we have a function that handles that. If it
    gets rejected, we have a function that handles that as well. This is one of the
    reasons why promises are awesome. You get to provide different functions, depending
    on whether or not the promise got resolved or rejected. This lets you avoid a
    lot of complex `if` statements inside of our code, which we needed to do in `app.js`
    to manage whether or not the actual callback succeeded or failed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以被解决或拒绝的承诺。如果它被解决，意味着承诺已经实现，我们有一个处理它的函数。如果它被拒绝，我们也有一个处理它的函数。这是承诺很棒的原因之一。你可以根据承诺是否被解决或拒绝来提供不同的函数。这让你避免了在我们的代码中使用大量复杂的`if`语句，我们需要在`app.js`中管理实际回调是否成功或失败。
- en: 'Now inside a promise, it''s important to understand that you can only either
    `resolve` or `reject` a promise once. If you `resolve` a promise you can''t `reject`
    it later, and if you `resolve` it with one value you can''t change your mind at
    a later point in time. Consider this example, where I have a code like the following
    code; here I `resolve` first and then I `reject`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在承诺中，重要的是要理解你只能`resolve`或`reject`一次承诺。如果你`resolve`了一个承诺，你就不能在以后`reject`它，如果你用一个值`resolve`它，你就不能在以后改变主意。考虑这个例子，我有一个像下面这样的代码；在这里我首先`resolve`然后我`reject`：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, we'll get our success `message` printing to the screen. We'll
    never see `errorMessage`, because, as I just said, you can only do one of these
    actions once. You can either `resolve` once or you can `reject` once. You can't
    do both; you can't do either twice.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们将看到我们的成功`message`打印到屏幕上。我们永远不会看到`errorMessage`，因为，正如我刚才说的，你只能执行其中一个操作一次。你只能一次`resolve`或一次`reject`。你不能两次都做；你不能两次做任何一种。 '
- en: 'This is another great advantage over callbacks. There''s nothing preventing
    us from accidentally calling the `callback` function twice. Let''s consider the `geocode.js`
    file for example. Let''s add another line in the `if` block of geocode request
    call, as shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是回调的另一个巨大优势。没有什么能阻止我们意外地两次调用`callback`函数。例如，让我们考虑`geocode.js`文件。让我们在geocode请求调用的`if`块中添加另一行，如下所示：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a more obvious example, but it could easily be hidden inside of complex
    `if-else` statements. In this case, our `callback` function in `app.js` will indeed
    get called twice, which can cause really big problems for our program. Inside
    the promise example this callback will never get called twice, no matter how many
    times you try to call `resolve` or `reject`, this function will only get fired
    once.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更明显的例子，但它很容易隐藏在复杂的`if-else`语句中。在这种情况下，我们`app.js`中的`callback`函数确实会被调用两次，这可能会给我们的程序带来很大的问题。在promise示例中，无论你尝试多少次调用`resolve`或`reject`，这个函数只会被触发一次，这个回调永远不会被调用两次。
- en: 'We can prove that right now by calling `resolve` again. In the promise example
    case, let''s save the file with the following changes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过再次调用`resolve`来证明这一点。在promise示例中，让我们保存文件并进行以下更改：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let's refresh things; we'll `resolve` with our message, `Hey. It worked!` and
    we'll never ever have the function fired a second time with no message. Because,
    as we said, the promise is already resolved. Once you set a promise's state to
    either fulfilled or rejected, you can't set it again.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们刷新一下；我们将用我们的消息`Hey. It worked!`来`resolve`，我们永远不会再次触发函数，因为，正如我们所说的，promise已经解决。一旦将promise的状态设置为已满足或已拒绝，就不能再次设置它。
- en: Now before a promise's `resolve` or `reject` function gets called, a promise
    is in a state known as pending. This means that you're waiting for information
    to come back, or you're waiting for your async computation to finish. In our case,
    while we're waiting for the weather data to come back, the promise would be considered
    pending. A promise is considered settled when it has been either fulfilled or
    rejected.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在promise的`resolve`或`reject`函数被调用之前，promise处于一种称为待定的状态。这意味着你正在等待信息返回，或者你正在等待异步计算完成。在我们的例子中，当我们等待天气数据返回时，promise将被视为待定。当promise被满足或拒绝时，它被认为是已解决的。
- en: No matter which one you chose, you could say the promise has settled, meaning
    that it's no longer pending. In our case, this would be a settled promise that
    was indeed fulfilled because `resolve` is called right here. So these are just
    a couple of the benefits of promises. You don't have to worry about having callbacks
    called twice, you can provide multiple functions—one for success handling and
    one for error handling. It really is a fantastic utility!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪一个，你都可以说promise已经完成，这意味着它不再是待定的。在我们的例子中，这将是一个已完成的promise，因为`resolve`就是在这里调用的。这些只是promise的一些好处。你不必担心回调被调用两次，你可以提供多个函数——一个用于成功处理，一个用于错误处理。这真的是一个很棒的工具！
- en: Now that we've gone through a quick example of how promises work, going over
    just the very fundamentals, we'll to move on to something slightly more complex.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速介绍了promise的工作原理，只是基本原理，我们将转向稍微复杂一些的内容。
- en: Advanced promises
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级promise
- en: In this section, we'll explore two more ways to use promises. We'll create functions
    that take input and return a promise. Also, we'll explore promise chaining, which
    will let us combine multiple promises.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨使用promise的另外两种方法。我们将创建接受输入并返回promise的函数。此外，我们将探索promise链式调用，这将让我们组合多个promise。
- en: Providing input to promises
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供promise的输入
- en: Now the problem with the example we discussed in the previous section is that
    we have a promise function, but it doesn't take any input. This most likely is
    never going to be the case when we're using real-world promises. We'll want to
    provide some input, such as the ID of a user to fetch from the database, a URL
    to request, or a partial URL, for example, just the address component.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在上一节讨论的示例中的问题是，我们有一个promise函数，但它不接受任何输入。当我们使用真实世界的promise时，这很可能永远不会发生。我们将想要提供一些输入，比如从数据库中获取用户的ID，请求的URL，或者部分URL，例如只有地址组件。
- en: 'In order to do this, we''ll have to create a function. For this example, we''ll
    make a variable, which will be a function called `asyncAdd`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须创建一个函数。在这个例子中，我们将创建一个名为`asyncAdd`的函数。
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will be a function that simulates the async functionality using `setTimeout`.
    In reality, it's just going to add two numbers together. However, it will illustrate
    exactly what we need to do, later in this chapter, to get our weather app using
    promises.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个使用`setTimeout`模拟异步功能的函数。实际上，它只是将两个数字相加。但是，它将准确地说明我们需要在本章后面做的事情，以便使用promise来获取我们的天气应用程序。
- en: 'Now in the function, we will take two arguments, `a` and `b`, and we''ll return
    a promise:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在函数中，我们将使用`a`和`b`两个参数，并返回一个promise：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, whoever calls this `asyncAdd` method, they can pass in input, but they
    can also get the promise back so that they can use then to sync up and wait for
    it to complete. Inside the `asyncAdd` function, we''ll use `return` to do this.
    We''ll `return` the `new Promise` object using the exact same `new Promise` syntax
    we did when we created the `somePromise` variable. Now this is the same function,
    so we do need to provide the constructor function that gets called with both `resolve`
    and `reject`, just like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论谁调用这个`asyncAdd`方法，他们都可以传入输入，但他们也可以得到promise，以便他们可以使用then来同步并等待它完成。在`asyncAdd`函数内部，我们将使用`return`来做到这一点。我们将使用完全相同的`new
    Promise`语法来`return`一个`new Promise`对象，就像我们创建`somePromise`变量时所做的那样。现在这是相同的函数，所以我们确实需要提供构造函数，该构造函数使用`resolve`和`reject`两个参数进行调用，就像这样：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we have an `asyncAdd` function, which takes two numbers and returns a promise.
    The only thing left to do is to actually simulate the delay, and make the call
    to `resolve`. To do this, we''ll simulate the delay using `setTimeout`. Then we''ll
    pass in my `callback` function, setting the delay to 1.5 seconds, or `1500` milliseconds:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`asyncAdd`函数，它接受两个数字并返回一个promise。唯一剩下的事情就是实际模拟延迟，并调用`resolve`。为此，我们将使用`setTimeout`来模拟延迟。然后我们将传入我的`callback`函数，将延迟设置为1.5秒，或`1500`毫秒：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `callback` function, we''ll write a simple `if-else` statement that
    will check if the type of both `a` and `b` is a number. If it is, great! We''ll
    `resolve` the value of the two numbers added. If they''re not numbers (one or
    more), then we''ll `reject`. To do this, we''ll use the `if` statement with the
    `typeof` operator:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`callback`函数中，我们将编写一个简单的`if-else`语句，检查`a`和`b`的类型是否都是数字。如果是，太好了！我们将`resolve`这两个数字相加的值。如果它们不是数字（一个或多个），那么我们将`reject`。为此，我们将使用`if`语句和`typeof`运算符：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we''re using the `typeof` object to get the string type before the variable.
    Also, we''re checking whether it''s equal to a number, which is what will come
    back from `typeof` when we have a number. Now similar to `a`, we''ll add `typeof
    b`,  which is also a number:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`typeof`对象来获取变量之前的字符串类型。此外，我们检查它是否等于一个数字，这是当我们有一个数字时`typeof`将返回的内容。现在类似于`a`，我们将添加`typeof
    b`，它也是一个数字：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can add the two numbers up, resolving the value. Inside the code block of
    the `if` statement, we''ll call `resolve`, passing in `a + b`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个数字相加，解析出值。在`if`语句的代码块内，我们将调用`resolve`，传入`a + b`：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will add the two numbers up, passing in one argument to `resolve`. Now
    this is the happy path when both `a` and `b` are indeed numbers. If things don''t
    go well, we''ll want to add `reject`. We''ll use the `else` block to do this.
    If the previous condition fails, we''ll `reject` by calling `reject(''Arguments
    must be numbers'')`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把这两个数字相加，传入一个参数给`resolve`。现在这是一个快乐的路径，当`a`和`b`都是数字时。如果事情不顺利，我们会想要添加`reject`。我们将使用`else`块来做这个。如果前面的条件失败，我们将通过调用`reject('Arguments
    must be numbers')`来`reject`：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have an `asyncAdd` function that takes two variables, `a` and `b`, returns
    a promise, and anyone who happens to call `asyncAdd` can add a then call onto
    the return result to get that value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`asyncAdd`函数，它接受两个变量`a`和`b`，返回一个promise，任何调用`asyncAdd`的人都可以添加一个then调用到返回结果上，以获得该值。
- en: Returning the promises
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回promise
- en: 'Now what exactly will this look like? To show this, first we''ll comment out
    all of the code we have in the `newPromise` variable of `promise.js`. Following
    this, we''ll call the `asyncAdd` variable where we make `asyncAdd`. We''ll call
    it like we would any other function, by passing in two values. Remember, this
    could be a database ID or anything else for an async function. In our case, it''s
    just two numbers. Let''s say, `5` and `7`. Now the return value from this function
    is a promise. We can make a variable and call then on that variable, but we can
    also just tack the `then` method, as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这到底是什么样子？为了展示这一点，首先我们将注释掉`promise.js`中`newPromise`变量中的所有代码。接着，我们将调用`asyncAdd`变量，我们将调用`asyncAdd`。我们将像调用任何其他函数一样调用它，传入两个值。请记住，这可以是数据库ID或任何其他异步函数的内容。在我们的例子中，它只是两个数字。假设是`5`和`7`。现在这个函数的返回值是一个promise。我们可以创建一个变量并在该变量上调用then，但我们也可以直接使用`then`方法，如下所示：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is exactly what we''ll do when we use promises; we''ll tack on then, passing
    in our callbacks. The first callback being the success case, and the second one
    being the error case:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在使用promise时要做的事情；我们将添加then，传入我们的回调。第一个回调是成功的情况，第二个是错误的情况：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the second callback, we''ll get our `errorMessage`, which we can log to
    the screen using the `console.log(errorMessage);` statement, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个回调中，我们将得到我们的`errorMessage`，我们可以使用`console.log(errorMessage);`语句将其记录到屏幕上，如下所示：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If one or more of the numbers are not actually numbers, the `error` function
    will fire because we called `reject`. If both are numbers, all we''ll do will
    get the result and print it to the screen, using `console.log`. We''ll add `res`
    and inside the arrow function (`=>`), we''ll add the `console.log` statement and
    print the string `Result` with a colon. Then, as the second argument in `console.log`,
    we''ll pass in the actual number, which will print it to the screen as well:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个或多个数字实际上不是数字，`error`函数将会触发，因为我们调用了`reject`。如果两个都是数字，我们将得到结果并将其打印到屏幕上，使用`console.log`。我们将添加`res`并在箭头函数（`=>`）内部添加`console.log`语句，并打印带有冒号的字符串`Result`。然后，作为`console.log`的第二个参数，我们将传入实际的数字，这将打印到屏幕上： '
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have our promise `asyncAdd` function in place, let''s test this
    out inside Terminal. To do this, we''ll run `nodemon` to start up `nodemon playground/promise.js`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在适当的位置有了我们的promise `asyncAdd`函数，让我们在终端中测试一下。为此，我们将运行`nodemon`来启动`nodemon
    playground/promise.js`：
- en: '![](img/2c8c4cc6-4777-4da8-89e2-6f18d6255ec9.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c8c4cc6-4777-4da8-89e2-6f18d6255ec9.png)'
- en: Right away, we'll get the delay and the result, `12` prints to the screen. This
    is fantastic! We are able to create the function that takes the dynamic input,
    but still returns a promise.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将立即得到延迟和结果，`12`打印到屏幕上。这太棒了！我们能够创建一个接受动态输入的函数，但仍然返回一个promise。
- en: Now notice that we've taken an async function that usually requires callbacks
    and we've wrapped it to use promises. This is a good handy feature. As you start
    using promises in Node, you'll come to realize that some things do not support
    promises and you'd like them to. For example, the request library that we used
    to make our HTTP requests does not support promises natively. However, we can
    wrap our request call inside of a promise, which is what we'll to do later in
    the section. For now though, we have a basic example illustrating how this works.
    Next, we'd like to talk about promise chaining.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请注意，我们已经将通常需要回调的异步函数包装成使用promise的形式。这是一个很方便的功能。当你开始在Node中使用promise时，你会意识到有些东西不支持promise，而你希望它们支持。例如，我们用来进行HTTP请求的request库不支持原生的promise。然而，我们可以将我们的请求调用包装在一个promise中，这是我们稍后将要做的。不过，现在我们有一个基本的例子说明了这是如何工作的。接下来，我们想谈谈promise
    chaining。
- en: Promise chaining
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promise chaining
- en: Promise chaining is the idea of having multiple promises run in a sequence.
    For example, I want to take an address and convert that into coordinates, and
    take those coordinates and convert them into weather information; this is an example
    of needing to synchronize two things. Also, we can do that really easily using
    promise chaining.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Promise chaining是指多个promise按顺序运行的概念。例如，我想要将地址转换为坐标，然后将这些坐标转换为天气信息；这是需要同步两件事情的一个例子。而且，我们可以很容易地使用promise
    chaining来做到这一点。
- en: 'In order to chain our promises, inside our success call we''ll return a new
    promise. In our example, we can `return` a new promise by calling `asyncAdd` again.
    I''ll call `asyncAdd` next to the `res` and `console.log` statements, passing
    in two arguments: the result, whatever the previous promise has returned, and
    some sort of new number; let''s use `33`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了链接我们的promise，在我们的成功调用中，我们将返回一个新的promise。在我们的例子中，我们可以通过再次调用`asyncAdd`来`return`一个新的promise。我将在`res`和`console.log`语句旁边调用`asyncAdd`，传入两个参数：结果，前一个promise返回的任何东西，以及某种新的数字；让我们使用`33`：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we''re returning a promise so we can add my chaining onto it by calling
    the `then` method again. The `then` method will to get called after we close the
    closing parenthesis for our previous `then` method. This will also take one or
    more arguments. We can pass in a success handler, which will be a function and
    an error handler, which will also be a function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们返回了一个promise，所以我们可以通过再次调用`then`方法来添加我的链式操作。`then`方法将在我们关闭前一个`then`方法的括号后被调用。这也将接受一个或多个参数。我们可以传入一个成功处理程序，它将是一个函数，以及一个错误处理程序，它也将是一个函数：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have our `then` callbacks set up, we can actually fill them out.
    Once again we will get a result; this will be the result of `5` plus `7`, which
    is `12`, plus `33`, which will be `45`. Then, we can print `console.log (''Should
    be 45'')`. Next, we''ll print the actual value from results variable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了我们的`then`回调，我们可以填写它们。再一次，我们将得到一个结果；这将是`5`加`7`的结果，即`12`，再加`33`，将是`45`。然后，我们可以打印`console.log
    ('Should be 45')`。接下来，我们将打印结果变量的实际值：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now our error handler will also be the same. We''ll have `errorMessage` and
    we''ll print it to the screen using the `console.log`, printing `errorMessage`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的错误处理程序也将是一样的。我们将有`errorMessage`，并使用`console.log`将其打印到屏幕上，打印`errorMessage`：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now what we have is some chaining. Our first then `callback` functions will
    fire based on the result of our first `asyncAdd` call. If it goes well, the first
    one will fire. If it goes poorly, the second function will fire. Our second then
    call will be based on the `asyncAdd` call, where we add `33`. This will let us
    chain the two results together, and we should get `45` printing to the screen.
    We''ll save this file, which will restart things inside `nodemon`. Eventually,
    we''ll get our two results: `12` and our `Should be 45`. As shown in the following
    code image, we get just that, `Result: 12` and `Should be 45`, printing to the
    screen:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们有了一些链式操作。我们的第一个`then`回调函数将根据我们第一个`asyncAdd`调用的结果触发。如果顺利进行，第一个将触发。如果进行不顺利，第二个函数将触发。我们的第二个then调用将基于`asyncAdd`调用，我们在其中添加`33`。这将让我们将两个结果链接在一起，我们应该得到`45`打印在屏幕上。我们将保存这个文件，这将重新启动`nodemon`中的事情。最终，我们会得到我们的两个结果：`12`和我们的`Should
    be 45`。如下图所示，我们得到了`Result: 12`和`Should be 45`，打印在屏幕上：'
- en: '![](img/51085c19-914c-45d4-9900-831e8209b8ea.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51085c19-914c-45d4-9900-831e8209b8ea.png)'
- en: Error handling in promises chaining
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: promise链中的错误处理
- en: 'Now when it comes to error handling, there are a few quirks; so, we''ll simulate
    some errors. First up, let''s simulate an error in our second `asyncAdd` call.
    We know we can do that by passing in a value that''s not a number. In this case,
    let''s wrap `33` inside quotes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在谈到错误处理时，有一些怪癖；所以，我们将模拟一些错误。首先，让我们模拟第二个`asyncAdd`调用中的错误。我们知道可以通过传入一个非数字的值来实现这一点。在这种情况下，让我们用引号括起`33`：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will be a string and our call should `reject`. Now we can save the file
    and see what happens:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个字符串，我们的调用应该`reject`。现在我们可以保存文件并看看会发生什么：
- en: '![](img/07962445-c8f8-4784-8512-560de7bf4cec.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07962445-c8f8-4784-8512-560de7bf4cec.png)'
- en: 'We get `Result: 12`, then we get our error, `Arguments must be numbers`. Exactly
    as we expect, this is printing on the screen. Instead of getting `Should be 45`,
    we get our error message.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '我们得到`Result: 12`，然后我们得到我们的错误，`Arguments must be numbers`。正如我们所期望的那样，这会打印在屏幕上。我们没有得到`Should
    be 45`，而是得到了我们的错误消息。'
- en: 'But things get a little trickier when something earlier on in the promise chain
    gets rejected. Let''s swap `''33''` with the number `33`. Then let''s replace
    `7` with the string `''7''`, as shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当promise链中的早期某个东西被拒绝时，事情就会变得有点棘手。让我们用数字`33`替换`'33'`。然后让我们用字符串`'7'`替换`7`，如下所示：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will cause our first promise to fail, which means we''ll never see the
    result. We should see the error message printing to the screen, but that''s not
    what will happen:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致我们的第一个promise失败，这意味着我们将永远看不到结果。我们应该看到错误消息打印在屏幕上，但这不会发生：
- en: '![](img/9144348b-9213-4f2b-89ff-9d3a09e6dff6.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9144348b-9213-4f2b-89ff-9d3a09e6dff6.png)'
- en: When we restart, we do indeed get the error message printing to the screen,
    but then we also get `Should be 45 undefined`. The second then `console.log` is
    running because we provided an error handler in the second `asyncAdd` function.
    It's running the error handler. Then it says,* Okay, things must be good now we
    ran the error handler. Let's move on to the next then call calling the success
    case*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新启动时，确实会将错误消息打印到屏幕上，但然后我们还会得到`Should be 45 undefined`。第二个`console.log`正在运行，因为我们在第二个`asyncAdd`函数中提供了一个错误处理程序。它正在运行错误处理程序。然后它说，*好的，现在事情一定很好，我们运行了错误处理程序。让我们继续进行下一个then调用，调用成功案例*。
- en: The catch method
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: catch方法
- en: 'To fix the error, we can remove both of our error handlers from both the `then`
    calls, and replace them with a call at the very bottom, to a different method,
    which we''ll call `.catch`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复错误，我们可以从两个`then`调用中删除我们的错误处理程序，并用一个调用替换它们，即在最底部调用一个不同的方法，我们将称之为`.catch`：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The catch promise method is similar to then, but it just takes one function.
    This is the error handler. As shown in the following code, we can specify one
    error handler if any of our promise calls fail. We''ll take `errorMessage` and
    print it to the screen using `console.log(errorMessage)`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: catch promise方法类似于then，但它只接受一个函数。如下面的代码所示，如果我们的任何promise调用失败，我们可以指定一个错误处理程序。我们将获取`errorMessage`并使用`console.log(errorMessage)`将其打印到屏幕上：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For now though, if things are a little blurry that is okay, as long as you're
    starting to see exactly what we're doing. We're taking the result from one promise
    and passing it to a different one. In this case, the result works exactly as expected.
    The first promise fails, we get, `Arguments must be numbers` printing to the screen.
    Also, we don't get that broken statement where we try to print `45`, but we get
    undefined instead. Using catch, we can specify an error handler that will fire
    for all of our previous failures. This is exactly what we want.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，如果现在有些模糊，没关系，只要你开始看到我们到底在做什么。我们正在将一个promise的结果传递给另一个promise。在这种情况下，结果的工作方式与预期完全相同。第一个promise失败，我们得到了打印到屏幕上的`Arguments
    must be numbers`。此外，我们没有得到那个破碎的语句，我们尝试打印`45`，但我们得到了undefined。使用catch，我们可以指定一个错误处理程序，它将对我们之前的所有失败进行处理。这正是我们想要的。
- en: The request library in promises
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺中的请求库
- en: Now as I mentioned earlier, some libraries support promises while others don't.
    The request library does not support promises. We will make a function that wraps
    request, returning a promise. We'll use some functionalities from the `geocode.js`
    file from the previous chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正如我之前提到的，有些库支持promise，而另一些则不支持。请求库不支持promise。我们将创建一个包装请求并返回promise的函数。我们将使用前一章中的`geocode.js`文件中的一些功能。
- en: 'First, let''s discuss a quick setup, and then we''ll actually fill it out.
    In the `playground` folder, we can make a new file to store this, called `promise-2.js`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下快速设置，然后我们将实际填写它。在`playground`文件夹中，我们可以创建一个新文件来存储这个，名为`promise-2.js`：
- en: '![](img/e237b240-cc2b-44e0-887a-52ae3eba14e2.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e237b240-cc2b-44e0-887a-52ae3eba14e2.png)'
- en: 'We''ll make a function called `geocodeAddress`. The `geocodeAddress` function
    will take the plain text address, and it will return a promise:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`geocodeAddress`的函数。`geocodeAddress`函数将接受纯文本地址，并返回一个promise：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `geocodeAddress` function will return a promise. So if I pass in a ZIP
    code, such as `19146`, I would expect a promise to come back, which I can attach
    a `then` call to. This will let me wait for that request to finish. Right here,
    I''ll tack on a call to `then`, passing in my two functions: the success handler
    for when the promise is fulfilled and the error handler for when the promise is
    rejected:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`geocodeAddress`函数将返回一个promise。因此，如果我传入一个邮政编码，比如`19146`，我会期望返回一个promise，我可以附加一个`then`调用。这将让我等待该请求完成。在这里，我将添加一个调用`then`，传入我的两个函数：当promise被实现时的成功处理程序和当promise被拒绝时的错误处理程序：'
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now when things go well, I''ll expect the `location` object with the address,
    the `latitude`, and the `longitude`, and when things go poorly, I''ll expect the
    error message:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当事情顺利进行时，我期望得到带有地址、`纬度`和`经度`的`location`对象，当事情进行不顺利时，我期望得到错误消息：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When the error message happens, we''ll just print it to the screen using `console.log
    (errorMessage)`. For now, when things go well and the success case runs, we''ll
    just print that entire object using our pretty printing technique, `console.log`.
    Then, we''ll call `JSON.stringify`, like we''ve done many times before, passing
    in the three arguments—the object, undefined for the filter method—which we''ll
    never use in the book, and the number `2` for the number of spaces we''d like
    to use as our indentation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当错误消息发生时，我们将只是使用`console.log(errorMessage)`将其打印到屏幕上。目前，当事情顺利进行并且成功案例运行时，我们将使用我们的漂亮打印技术，`console.log`打印整个对象。然后，我们将调用`JSON.stringify`，就像我们以前做过很多次一样，传入三个参数——对象，未定义的过滤方法——我们在书中永远不会使用，以及数字`2`作为我们想要用作缩进的空格数：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is what we want to create, the function that lets this functionality work
    as expected. This `then` call should work as shown in the previous code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们想要创建的功能正常工作的函数。这个`then`调用应该像前面的代码中显示的那样工作。
- en: 'To get started I''ll return the promise by calling: `return new Promise`, passing
    in my constructor function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我将通过调用`return new Promise`返回promise，传入我的构造函数：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside the function, we''ll add that call to request. Let''s provide the `resolve`
    and `reject` arguments:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们将添加对请求的调用。让我们提供`resolve`和`reject`参数：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have our `Promise` set up, we can load in the request module on
    top of the code, creating a constant called `request` and setting that equal to
    the return result from `require(''request'')`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了我们的`Promise`，我们可以在代码顶部加载请求模块，创建一个名为`request`的常量，并将其设置为`require('request')`的返回结果：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we''ll move into the `geocode.js` file, grab code inside the `geocodeAddress`
    function, and move it over into `promise-2 file`, inside of the constructor function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进入`geocode.js`文件，获取`geocodeAddress`函数内的代码，并将其移动到`promise-2`文件中的构造函数内：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we are mostly good to go; we only need to change a few things. The first
    thing we need to do is to replace our error handlers. In the `if` block of the
    code, we have called our `callback` handler with one argument; instead, we''ll
    call `reject`, because if this code runs, we want to `reject` the promise. We
    have the same thing in the next `else` block. We''ll call `reject` if we get `ZERO_RESULTS`.
    This is indeed a failure, and we do not want to pretend we succeeded:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们基本上可以开始了；我们只需要改变一些东西。我们需要做的第一件事是替换我们的错误处理程序。在代码的`if`块中，我们用一个参数调用了我们的`callback`处理程序；相反，我们将调用`reject`，因为如果这段代码运行，我们希望`reject`这个promise。在下一个`else`块中也是一样的。如果我们得到了`ZERO_RESULTS`，我们将调用`reject`。这确实是一个失败，我们不想假装我们成功了：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now in the next `else` block, this is where things did go well; here we can
    call `resolve`. Also, we can remove the first argument, as we know `resolve` and
    `reject` only take one argument:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在下一个`else`块中，事情进展顺利；在这里我们可以调用`resolve`。此外，我们可以删除第一个参数，因为我们知道`resolve`和`reject`只接受一个参数：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We are able to specify multiple values though, because we `resolve` an object
    with properties on it. Now that we have this in place, we are done. We can actually
    save our file, rerun it inside Terminal, and test things out.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定多个值，因为我们在对象上`resolve`了属性。既然我们已经做到了这一点，我们就完成了。我们可以保存我们的文件，重新在终端中运行它，然后测试一下。
- en: Testing the request library
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试请求库
- en: 'To test, we''ll save the file, move into Terminal, and shut down `nodemon`
    for the `promise.js` file. We''ll run `node` for the `promise.js` file. It''s
    in the `playground` folder, and it''s called `promise-2.js`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们将保存文件，进入终端，关闭`promise.js`文件的`nodemon`。我们将运行`promise.js`文件的`node`。它在`playground`文件夹中，名为`promise-2.js`：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, when we run this program, we''re actually making that HTTP request. As
    shown in the following code output, we can see the data comes back exactly as
    we expected:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个程序时，我们实际上正在发出HTTP请求。如下面的代码输出所示，我们可以看到数据返回的确如我们所期望的那样：
- en: '![](img/1fa26c34-7594-4433-ac64-700af003a6eb.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fa26c34-7594-4433-ac64-700af003a6eb.png)'
- en: 'We get our `address`, `latitude`, and `longitude` variables. This is fantastic!
    Now let''s test to see what happens when we pass in an invalid address, something
    like 5 zeroes, which we''ve used before to simulate an error:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们的`address`、`latitude`和`longitude`变量。这太棒了！现在让我们测试一下，当我们传入一个无效的地址时会发生什么，比如5个零，这是我们以前用来模拟错误的：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''ll save the file, rerun the program, and `Unable to find that address.`
    prints to the screen:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保存文件，重新运行程序，屏幕上打印出`无法找到该地址。`：
- en: '![](img/dd136fb7-56f6-4180-8d82-fb50a1c5e611.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd136fb7-56f6-4180-8d82-fb50a1c5e611.png)'
- en: This happens only because we call `reject`. We will call `reject` inside of
    the `Promise` constructor function. We have our error handler, which prints the
    message to the screen. This is an example of how to take a library that does not
    support promises and wrap it in a promise, creating a promise ready function.
    In our case, that function is `geocodeAddress`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是因为我们调用了`reject`。我们将在`Promise`构造函数中调用`reject`。我们有我们的错误处理程序，它将消息打印到屏幕上。这是一个将不支持promise的库包装成promise的示例，创建一个准备好的promise函数。在我们的情况下，该函数是`geocodeAddress`。
- en: Weather app with promises
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有promise的天气应用程序
- en: 'In this section, we''ll learn how to use a library that has promises built
    in. We''ll explore the axios library, which is really similar to request. Although,
    instead of using callbacks as request does, it uses promises. So we don''t have
    to wrap our calls in promises to get that promise functionality. We''ll actually
    be recreating the entire weather app in this section. We''ll only have to write
    about 25 lines of code. We''ll go through the entire process: taking the address,
    getting the coordinates, and then fetching the weather.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用内置promise的库。我们将探索axios库，它与request非常相似。不过，它使用promise而不是像request那样使用回调。因此，我们不必将我们的调用包装在promise中以获得promise功能。我们实际上将在本节中重新创建整个天气应用程序。我们只需要编写大约25行代码。我们将完成整个过程：获取地址、获取坐标，然后获取天气。
- en: Fetching weather app code from the app.js file
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从app.js文件中获取天气应用程序代码
- en: To fetch weather app code from the app.js file, we'll duplicate `app.js`, because
    we configure `yargs` in the original `app.js` file and we'll want to carry the
    code over to the new project. There's no need to rewrite it. In the `weather`
    directory, we'll duplicate `app.js`, giving it a new name, `app-promise.js`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要从app.js文件中获取天气应用程序代码，我们将复制`app.js`，因为我们在原始的`app.js`文件中配置了`yargs`，我们希望将代码转移到新项目中。没有必要重写它。在`weather`目录中，我们将复制`app.js`，给它一个新的名字，`app-promise.js`。
- en: 'Inside `app-promise.js`, before we add anything, let''s rip some stuff out.
    We''ll be ripping out the `geocode` and `weather` variable declarations. We''ll
    not be requiring any files:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app-promise.js`中，在我们添加任何内容之前，让我们先删除一些东西。我们将删除`geocode`和`weather`变量声明。我们将不需要引入任何文件：
- en: '![](img/d3bb21f5-b5b1-4c6a-a140-4ff58de97564.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3bb21f5-b5b1-4c6a-a140-4ff58de97564.png)'
- en: 'Then I''ll remove everything after our `yargs` configuration, which in this
    case is just our call to `geocodeAddress`. The resultant code will look like the
    following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将删除我们`yargs`配置之后的所有内容，这种情况下只有我们对`geocodeAddress`的调用。结果代码将如下所示：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Axios documentations
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Axios文档
- en: 'Now that we have a clean slate, we can get started by installing the new library.
    Before we run the `npm install` command, we''ll see where we can find the documentation.
    We can get it by visiting: [https://www.npmjs.com/package/axios](https://www.npmjs.com/package/axios).
    As shown in the following screenshot, we have the axios npm library page, where
    we can view all sorts of information about it, including the documentation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个干净的板子，我们可以开始安装新的库。在运行`npm install`命令之前，我们将看看在哪里可以找到文档。我们可以通过访问以下网址获取：[https://www.npmjs.com/package/axios](https://www.npmjs.com/package/axios)。如下面的截图所示，我们有axios
    npm库页面，我们可以查看有关它的各种信息，包括文档：
- en: '![](img/a1b15161-a362-4fa5-a931-7c7d8f79ad9f.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1b15161-a362-4fa5-a931-7c7d8f79ad9f.png)'
- en: 'Here we can see some things that look familiar. We have calls to then and catch,
    just like we do when we use promises outside of axios:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到一些看起来很熟悉的东西。我们调用了`then`和`catch`，就像我们在axios之外使用promise时一样。
- en: '![](img/c120402b-5698-4ec0-8c0a-7b838ad882ac.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c120402b-5698-4ec0-8c0a-7b838ad882ac.png)'
- en: Inside the stats column of this page, you can see that this is a super popular
    library. The most recent version is 0.13.1\. This is the exact version we'll be
    using. Feel free to go to this page when you use axios in your projects. There
    are a lot of really good examples and documentation. For now though, we can install
    it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面的统计栏中，你可以看到这是一个非常受欢迎的库。最新版本是0.13.1。这正是我们将要使用的确切版本。当你在项目中使用axios时，可以随时访问这个页面。这里有很多非常好的例子和文档。不过，现在我们可以安装它。
- en: Installing axios
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装axios
- en: 'To install axios, inside Terminal, we''ll be running `npm install`; the library
    name is `axios`, and we''ll specify the version `0.17.1` with the `save` flag
    updating the `package.json` file. Now I can run the `install` command, to install
    axios:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装axios，在终端中，我们将运行`npm install`；库的名称是`axios`，我们将使用`save`标志指定版本`0.17.1`来更新`package.json`文件。现在我可以运行`install`命令，来安装axios：
- en: '![](img/7b94abf0-4c96-4509-b51d-4076e50445e2.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b94abf0-4c96-4509-b51d-4076e50445e2.png)'
- en: Making calls in the app-promise file
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`app-promise`文件中进行调用
- en: 'Inside our `app-promise` file, we can get started by loading in `axios` at
    the top. We''ll make a constant called `axios`, setting it equal to `require(''axios'')`,
    as shown here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`app-promise`文件中，我们可以通过在顶部加载`axios`来开始。我们将创建一个常量叫做`axios`，将其设置为`require('axios')`，如下所示：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we have this in place, we can actually start making the calls in the
    code. This will involve us pulling out some of the functionality from the geocode
    and weather files. So we'll open up the `geocode.js` and `weather.js` files. Because
    we will be pulling some of the code from these files, things such as the URL and
    some of the error handling techniques. Although we'll talk about the differences
    as they come up.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经准备就绪，我们实际上可以开始在代码中进行调用了。这将涉及我们从地理编码和天气文件中提取一些功能。因此，我们将打开`geocode.js`和`weather.js`文件。因为我们将从这些文件中提取一些代码，比如URL和一些错误处理技术。尽管我们会在遇到时讨论它们的不同之处。
- en: 'The first thing we need to do is to encode the address and get the geocode
    URL. Now this stuff happens inside `geocode.js`. So we''ll actually copy the `encodedAddress`
    variable line, where we create the encoded address, and paste it in the `app-promise`
    file, following the `argv` variable:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是对地址进行编码并获取地理编码URL。现在这些操作发生在`geocode.js`中。因此，我们实际上会复制`encodedAddress`变量行，即我们创建编码地址的行，并将其粘贴到`app-promise`文件中，跟在`argv`变量后面。
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now we do need to tweak this a little bit. The `address` variable doesn''t
    exist; but we have `argv.address`. So, we''ll switch `address` with `argv.address`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要稍微调整一下这个。`address`变量不存在；但是我们有`argv.address`。因此，我们将`address`替换为`argv.address`：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we have the encoded address; the next thing we need to get before we can
    start using axios is the URL that we want to make the request to. We''ll grab
    that from the `geocode.js` file as well. In `app-promise.js`, we will make a new
    variable called `geocodeURI`. Then, we''ll take the URL present in `geocode.js`,
    from the opening tick to the closing tick, copy it, and paste it in `app-promise.js`,
    equal to `geocodeURI`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了编码后的地址；在我们开始使用axios之前，我们需要获取的下一件事是我们想要发出请求的URL。我们将从`geocode.js`文件中获取。在`app-promise.js`中，我们将创建一个名为`geocodeURI`的新变量。然后，我们将从`geocode.js`中获取URL，从开头的反引号到结束的反引号，复制并粘贴到`app-promise.js`中，赋值给`geocodeURI`：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now we use the encoded `address` variable inside the URL; this is fine because
    it does exist in our code. So at this point, we have our `geocodeUrl` variable
    and we can get started in making our very first axios request.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在URL中使用了编码的`address`变量；这没问题，因为它确实存在于我们的代码中。因此，在这一点上，我们有了我们的`geocodeUrl`变量，我们可以开始制作我们的第一个axios请求了。
- en: Making axios request
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出axios请求
- en: 'In our case, we''ll be taking the address and getting the `latitude` and `longitude`.
    To make our request, we''ll call a method available on axios, `axios.get`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将获取地址并获取`纬度`和`经度`。为了发出请求，我们将调用axios上可用的一个方法，`axios.get`。
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `get` is the method that lets us make our HTTP get request, which is exactly
    what we want to do in this case. Also, it''s really simple to set up. When you''re
    expecting JSON data, all you have to do is to pass in the URL that we have in
    the `geocodeUrl` variable. There''s no need to provide any other options, such
    as an option letting it know it''s `JSON. axios` knows how to automatically parse
    our JSON data. What get returns is actually a promise, which means we can use
    `.then` in order to run some code when the promise gets fulfilled or rejected,
    whether things go well or poorly:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`是让我们发出HTTP get请求的方法，这正是我们在这种情况下想要做的。而且，设置起来非常简单。当你期望JSON数据时，你所要做的就是传入`geocodeUrl`变量中的URL。无需提供任何其他选项，比如让它知道它是`JSON`的选项。axios知道如何自动解析我们的JSON数据。`get`返回的实际上是一个promise，这意味着我们可以使用`.then`来在promise被实现或被拒绝时运行一些代码，无论事情进行得好还是糟：'
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Inside then, we''ll provide one function. This will be the success case. The
    success case will get called with one argument, which the `axios` library recommends
    that you call `response`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`then`中，我们将提供一个函数。这将是成功的情况。成功的情况将被调用一个参数，`axios`库建议你将其称为`response`：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Technically, we could call anything you like. Now inside the function, we''ll
    get access to all of the same information we got inside of the request library;
    things such as our headers, response, and request headers, as well as the body
    information; all sorts of useful info. What we really need though is the `response.data`
    property. We''ll print that using `console.log`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们可以随意调用任何你喜欢的东西。现在在函数内部，我们将获得与我们在请求库内部获得的所有相同的信息；诸如我们的头部、响应和请求头部，以及正文信息；各种有用的信息。不过，我们真正需要的是`response.data`属性。我们将使用`console.log`打印出来。
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now that we have this in place, we can run our `app-promise` file, passing in
    a valid address. Also, we can see what happens when we make that request.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了准备，我们可以运行我们的`app-promise`文件，传入一个有效的地址。此外，我们可以看看当我们发出请求时会发生什么。
- en: 'Inside command line (Terminal), we''ll use the `clear` command first to clear
    the Terminal output. Then we can run `node` `app-promise.js`, passing in an address.
    Let''s use a valid address, for example, `1301 lombard street, philadelphia`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行（终端）中，我们将首先使用“clear”命令清除终端输出。然后我们可以运行“node”“app-promise.js”，传入一个地址。让我们使用一个有效的地址，例如“1301
    lombard street, philadelphia”：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The request goes out. And what do we get back? We get back the results object
    exactly as we saw it when we used the other modules in the previous chapters:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请求发出。我们得到了什么？我们得到了与我们在前几章中使用其他模块时看到的结果对象完全相同的结果：
- en: '![](img/b9b590ca-3f30-4583-9aa6-d9bad585323b.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9b590ca-3f30-4583-9aa6-d9bad585323b.png)'
- en: The only difference in this case is that we're using promises built in, instead
    of having to wrap it in promises or using callbacks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况下唯一的区别是我们使用了内置的promises，而不是必须将其包装在promises中或使用回调。
- en: Error handling in axios request
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: axios请求中的错误处理
- en: 'Now aside from the success handler we used in the previous example, we can
    also add a call to catch, to let us catch all of the errors that might occur.
    We''ll to get the error object as the one-and-only argument; then we can do something
    with that error object:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在除了我们在上一个示例中使用的成功处理程序之外，我们还可以添加一个调用catch的调用，让我们捕获可能发生的所有错误。我们将获得错误对象作为唯一的参数；然后我们可以对该错误对象进行处理：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inside the function, we''ll kick things off, using `console.log` to print the
    error argument:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们将使用`console.log`来启动事情，打印错误参数：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now let''s simulate an error by removing the dot in the URL:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过删除URL中的点来模拟错误：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can see what happens when we rerun the program. Now I'm doing this to explore
    the `axios` library. I know exactly what will happen. This is not why I'm doing
    it. I'm doing it to show you how you should approach new libraries. When you get
    a new library, you want to play around with all the different ways it works. What
    exactly comes back in that error argument when we have a request that fails? This
    is important information to know; so when you write a real-world app, you can
    add the appropriate error handling code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以看看当我们重新运行程序时会发生什么。现在我这样做是为了探索`axios`库。我知道会发生什么。这不是我这样做的原因。我这样做是为了向你展示你应该如何处理新的库。当你得到一个新的库时，你想玩弄它的所有不同工作方式。当我们有一个请求失败时，错误参数中究竟会返回什么？这是重要的信息；所以当你编写一个真实的应用程序时，你可以添加适当的错误处理代码。 '
- en: 'In this case, if we rerun the exact same command, we''ll get an error:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们重新运行完全相同的命令，我们将收到一个错误：
- en: '![](img/8b892515-a390-41a9-84d2-56b558906ea9.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b892515-a390-41a9-84d2-56b558906ea9.png)'
- en: As you can see, there really is nothing to print on the screen. We have a lot
    of very cryptic error codes and even the `errorMessage` property, which usually
    contains something good or does not. Then we have an error code followed by the
    URL. What we want instead is print a plain text English message.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，屏幕上真的没有什么可打印的。我们有很多非常神秘的错误代码，甚至`errorMessage`属性，通常包含一些好的内容或者没有。然后我们有一个错误代码，后面跟着URL。相反，我们希望打印一个纯文本的英文消息。
- en: 'To do this, we''ll use an `if-else` statement, checking what the code property
    is. This is the error code and in this case `ENOTFOUND`; we know it means that
    it could not connect to the server. In `app-promise.js`, inside the error handler,
    we can add this by having `if` and checking the condition:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用一个`if-else`语句，检查代码属性是什么。这是错误代码，在这种情况下是`ENOTFOUND`；我们知道这意味着它无法连接到服务器。在`app-promise.js`中，在错误处理程序内部，我们可以通过使用`if`来添加这个条件：
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If that is the case, we''ll print some sort of custom message to the screen
    using `console.log`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，我们将使用“console.log”在屏幕上打印某种自定义消息：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we have an error handler that handles this specific case. So we can remove
    our call to `console.log`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个处理这种特定情况的错误处理程序。所以我们可以删除我们对`console.log`的调用：
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now if we save the file, and rerun things from Terminal, we should get a much
    nicer error message printing to the screen:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们保存文件，并从终端重新运行事情，我们应该会得到一个更好的错误消息打印到屏幕上：
- en: '![](img/53f9b560-267b-411e-a2d1-6615e4267ddf.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53f9b560-267b-411e-a2d1-6615e4267ddf.png)'
- en: 'This is exactly what we get: `Unable to connect to API servers`. Now I''ll
    add that dot back in, so things start working. We can worry about the response
    that comes back.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们得到的：“无法连接到API服务器”。现在我会把那个点加回去，这样事情就开始运作了。我们可以担心返回的响应。
- en: Error handling with ZERO_RESULT body status
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZERO_RESULT状态的错误处理
- en: As you remember, inside the geocode file, there were some things we needed to
    do. We've already handled the error related to server connection, but there is
    still another error pending, that is, if the `body.status` property equals `ZERO_RESULTS`.
    We want to print an error message in that case.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你记得，在geocode文件中，有一些事情我们需要做。我们已经处理了与服务器连接相关的错误，但还有另一个待处理的错误，即，如果`body.status`属性等于`ZERO_RESULTS`。在这种情况下，我们想打印一个错误消息。
- en: To do this, we'll inside `app-promise`, create our very own error. We'll throw
    an error inside the `axios.get` function. This error will cause all of the code
    after it, not to run. It will move right into the error handler.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将在`app-promise`中创建我们自己的错误。我们将在`axios.get`函数中抛出一个错误。这个错误将导致它之后的所有代码都不会运行。它将直接进入错误处理程序。
- en: 'Now we only want to throw an error if the status property is set to `ZERO_RESULTS`.
    We''ll add an `if` statement at the very top of the `get` function to check `if
    (response.data.status)` equals `ZERO_RESULTS`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只想在status属性设置为“ZERO_RESULTS”时抛出错误。我们将在“get”函数的顶部添加一个“if”语句来检查“if（response.data.status）”是否等于“ZERO_RESULTS”：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If that is the case, then things went bad and we do not want to move on to
    make the weather request. We want to run our catch code we have. To throw a new
    error that our promise can catch, we''ll use a syntax called `throw new Error`.
    This creates and throws an error letting Node know that something went wrong.
    We can provide our own error message, something that''s readable to a user: `Unable
    to find that address`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，那么事情就变糟了，我们不想继续进行天气请求。我们想运行我们的catch代码。为了抛出一个新的错误，让我们的promise可以捕获，我们将使用一个称为`throw
    new Error`的语法。这将创建并抛出一个错误，让Node知道出了问题。我们可以提供我们自己的错误消息，对用户来说是可读的：`无法找到该地址`：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is a message that''ll let that user know exactly what went wrong. Now
    when this error gets thrown, the same catch code will run. Currently, we only
    have one `if` condition that checks whether the code property is `ENOTFOUND`.
    So we''ll add an `else` clause:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个消息，将让用户准确地知道出了什么问题。现在当这个错误被抛出时，相同的catch代码将运行。目前，我们只有一个`if`条件，检查代码属性是否为`ENOTFOUND`。所以我们将添加一个`else`子句：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Inside the `else` block, we can print the error message, which is the string
    we typed in the throw `new Error` syntax using the `e.` message property, as shown
    here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else`块中，我们可以打印错误消息，这是我们使用`e.`消息属性在throw `new Error`语法中键入的字符串，如下所示：
- en: '[PRE66]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If the error code is not `ENOTFOUND`, we''ll simply print the message to the
    screen. This will happen if we get zero results. So let''s simulate that to make
    sure the code works. Inside Terminal, we''ll rerun the previous command passing
    in a zip code. At first, we''ll use a valid zip code, `08822` and we should get
    our data back. Then we''ll use an invalid one: `00000`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误代码不是`ENOTFOUND`，我们将简单地将消息打印到屏幕上。如果我们得到零结果，就会发生这种情况。所以让我们模拟一下，以确保代码能正常工作。在终端中，我们将重新运行之前的命令，传入一个邮政编码。起初，我们将使用一个有效的邮政编码`08822`，我们应该得到我们的数据。然后我们将使用一个无效的邮政编码：`00000`。
- en: 'When we run the request with a valid address, we get this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用有效地址运行请求时，我们得到这个：
- en: '![](img/c125c1ba-ce47-4adb-9d2f-6f996c2bf381.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/c125c1ba-ce47-4adb-9d2f-6f996c2bf381.png)
- en: 'When we run the request with the invalid address, we get the error:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用无效的地址运行请求时，我们得到了错误：
- en: '![](img/3acd268c-c83b-486e-98a9-87c2e2ad37eb.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/3acd268c-c83b-486e-98a9-87c2e2ad37eb.png)
- en: By calling `throw new Error`, we're immediately stopping the execution of this
    function. So `console.log` with `e.message` never prints, which is exactly what
    we want. Now that we have our error handler in place, we can start generating
    that weather URL.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`throw new Error`，我们立即停止了这个函数的执行。所以`console.log`与`e.message`永远不会打印，这正是我们想要的。现在我们的错误处理程序已经就位，我们可以开始生成天气URL了。
- en: Generating the weather URL
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成天气URL
- en: 'In order to generate the weather URL, we''ll copy the URL from the `weather`
    file, taking it with the ticks in place, and moving it into the `app-promise`
    file. We''ll make a new variable called `weatherUrl`, setting it equal to the
    copied URL:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成天气URL，我们将从`weather`文件中复制URL，将其带有引号的部分放入`app-promise`文件中。我们将创建一个名为`weatherUrl`的新变量，将其设置为复制的URL：
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now `weatherUrl` does need a few pieces of information. We need the `latitude`
    and `longitude`. We have two variables `lat` and `lng`, so let''s create them,
    getting the appropriate value from that response object, `var lat` and `var lng`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`weatherUrl`确实需要一些信息。我们需要`纬度`和`经度`。我们有两个变量`lat`和`lng`，所以让我们创建它们，从响应对象中获取适当的值，`var
    lat`和`var lng`：
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now in order to pull them off, we have to go through that process of digging
    into the object. We''ve done it before. We''ll be looking in the response object
    at the data property, which is similar to the body in the request library. Then
    we''ll go into `results`, grabbing the first item and accessing the `geometry`
    property, then we''ll access `location.lat`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了取出它们，我们必须经历挖掘对象的过程。我们以前做过。我们将在响应对象的数据属性中查找，这类似于请求库中的body。然后我们将进入`results`，获取第一个项目并访问`geometry`属性，然后我们将访问`location.lat`：
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now similarly, we can add things for the `longitude` variable:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在同样，我们可以为`longitude`变量添加内容：
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now before we make that weather request, we want to print the formatted address
    because that''s something the previous app did as well. In our `console.log(response.data)`
    statement, and instead of printing `response.data`, we''ll dive into the data
    object getting the formatted address. This is also on the results array''s first
    item. We''ll be accessing the `formatted_address` property:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们发出天气请求之前，我们要打印格式化的地址，因为之前的应用程序也这样做了。在我们的`console.log(response.data)`语句中，我们将进入数据对象获取格式化的地址。这也是在结果数组的第一项上。我们将访问`formatted_address`属性：
- en: '[PRE71]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now that we have our formatted address printing to the screen, we can make our
    second call by returning a new promise. This is going to let us chain these calls
    together.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的格式化地址已经打印到屏幕上，我们可以通过返回一个新的promise来进行第二次调用。这将让我们链接这些调用在一起。
- en: Chaining the promise calls
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接承诺调用
- en: 'To get started, we''ll return a call to `axios.get`, passing in the URL. We
    just defined that, it is `weatherUrl`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将返回一个调用`axios.get`，传入URL。我们刚刚定义了它，它是`weatherUrl`：
- en: '[PRE72]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now that we have this call returning, we can attach another `then` call right
    between our previous `then` call and catch call, by calling then, passing in one
    function, just like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个调用返回，我们可以在之前的`then`调用和catch调用之间再添加一个`then`调用，通过调用then，传递一个函数，就像这样：
- en: '[PRE73]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This function will get called when the weather data comes back. We''ll get
    that same response argument, because we''re using the same method, `axios.get`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当天气数据返回时，将调用此函数。我们将得到相同的响应参数，因为我们使用相同的方法`axios.get`：
- en: '[PRE74]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Inside the `then` call, we don''t have to worry about throwing any errors,
    since we never needed to access a body property in order to check if something
    went wrong. With the weather request if this callback runs, then things went right.
    We can print the weather information. In order to get that done, we''ll make two
    variables:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在`then`调用中，我们不必担心抛出任何错误，因为我们从未需要访问body属性来检查是否出了问题。对于天气请求，如果这个回调运行，那么事情就对了。我们可以打印天气信息。为了完成这个任务，我们将创建两个变量：
- en: '`temperature`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temperature`'
- en: '`apparentTemperature`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apparentTemperature`'
- en: 'The `temperature` variable will get set equal to `response.data`. Then we''ll
    access that `currently` property. Then we''ll access temperature. We''ll pull
    out the second variable, the actual temperature or `apparentTemperature`, which
    is the property name, `var apparentTemperature`. We''ll be setting this equal
    to `response.data.currently.apparentTemperature`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`temperature`变量将被设置为`response.data`。然后我们将访问`currently`属性。然后我们将访问温度。我们将提取出第二个变量，实际温度或`apparentTemperature`，这是属性名称，`var
    apparentTemperature`。我们将把这个设置为`response.data.currently.apparentTemperature`：'
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now that we have our two things pulled out into variables, we can add those
    things inside of a call, `console.log`. We chose to define two variables, so that
    we don''t have to add the two really long property statements to `console.log`.
    We can simply reference the variables. We''ll add `console.log` and we''ll use
    template strings in the `console.log` statement, so that we can inject the previous
    mentioned two values inside of quotes: `It''s currently`, followed by `temperature`.
    Then we can add a period, `It feels like`, followed by `apparentTemperature`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将两个东西提取到变量中，我们可以将这些东西添加到`console.log`中。我们选择定义两个变量，这样我们就不必将两个非常长的属性语句添加到`console.log`中。我们可以简单地引用这些变量。我们将添加`console.log`，并在`console.log`语句中使用模板字符串，这样我们可以在引号中插入前面提到的两个值：`当前温度`，然后是`温度`。然后我们可以添加一个句号，`感觉像`，然后是`apparentTemperature`：
- en: '[PRE76]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now that we have our string printing to the screen, we can test that our app
    works as expected. We''ll save the file and inside Terminal, we''ll rerun the
    command from two commands ago where we had a valid zip code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的字符串已经打印到屏幕上，我们可以测试我们的应用程序是否按预期工作。我们将保存文件，在终端中，我们将重新运行两个命令之前的命令，其中我们有一个有效的邮政编码：
- en: '![](img/45cf383a-3a5f-4c59-a096-2ba3d38088a0.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45cf383a-3a5f-4c59-a096-2ba3d38088a0.png)'
- en: 'When we run this, we get the weather info for `Flemington`, New Jersey. It''s
    currently `84` degrees, but it feels like `90`. If we run something that has a
    bad address, we do get the error message:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个代码时，我们得到了`新泽西州`的`Flemington`的天气信息。当前温度是`84`华氏度，但感觉像`90`华氏度。如果我们运行的是一个错误的地址，我们会得到错误消息：
- en: '![](img/3b8c8c29-25de-44af-8688-7ebd557f4cc8.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b8c8c29-25de-44af-8688-7ebd557f4cc8.png)'
- en: So everything looks great! Using the `axios` library, we're able to chain promises
    like the app-promise without needing to do anything too crazy. The `axios get`
    method returns a promise, so we can access it directly using then.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一切看起来都很棒！使用`axios`库，我们能够像`app-promise`一样链式调用promise，而不需要做任何太疯狂的事情。`axios get`方法返回一个promise，所以我们可以直接使用`then`访问它。
- en: In the code, we use then once to do something with that geolocation data. We
    print the address to the screen. Then we return another promise, where we make
    the request for the weather. Inside of our second `then` call, we print the weather
    to the screen. We also added a catch call, which will handle any errors. If anything
    goes wrong with either of our promises, or if we throw an error, catch will get
    fired printing the messages to the screen.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们使用`then`一次来处理地理位置数据。我们将地址打印到屏幕上。然后我们返回另一个promise，在其中我们请求天气。在我们的第二个`then`调用中，我们将天气打印到屏幕上。我们还添加了一个`catch`调用，用于处理任何错误。如果我们的任何一个promise出现问题，或者我们抛出错误，`catch`将被触发，将消息打印到屏幕上。
- en: This is all it takes to use axios and set up promises for your HTTP requests.
    Now one reason people love promises over traditional callbacks is that instead
    of nesting we can simply chain. So our code doesn't get indented to crazy levels.
    As we saw in `app.js` in the previous chapter, we went a few indentation levels
    deep just to add two calls together. If we needed to add a third it would have
    gotten even worse. With promises, we can keep everything at the same level, keeping
    our code a lot easier to maintain.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用axios设置HTTP请求的promise所需的全部内容。人们喜欢promise而不是传统回调的一个原因是，我们可以简单地链式调用而不是嵌套。所以我们的代码不会缩进到疯狂的水平。正如我们在上一章的`app.js`中看到的，我们深入了几个缩进级别，只是为了将两个调用组合在一起。如果我们需要添加第三个，情况会变得更糟。有了promise，我们可以保持一切在同一级别，使我们的代码更容易维护。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've gone through a quick example of how promises work, by
    going over just the very fundamentals. Async is a critical part to Node.js. We
    went through the very basics of callbacks and promises. We looked a few examples,
    creating a pretty cool weather app.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过一个快速的例子介绍了promise的工作原理，只是介绍了非常基础的内容。异步是Node.js的一个关键部分。我们介绍了回调和promise的基础知识。我们看了一些例子，创建了一个相当酷的天气应用程序。
- en: This brings us to the end of our asynchronous Node.js programming, but this
    does not mean that you have to stop building out the weather app. There are a
    couple ideas as to what you could do to continue on with this project. First up,
    you can load in more information. The response we get back from the weather API
    contains a ton of stuff besides just the current temperature, which is what we
    used. It'd great if you can incorporate some of that stuff in there, whether it's
    high/low temperatures, or chances of precipitation.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的异步Node.js编程的结束，但这并不意味着你必须停止构建天气应用程序。有一些想法可以让你继续这个项目。首先，你可以加载更多的信息。我们从天气API得到的响应除了当前温度之外还包含了大量的其他信息。如果你能在其中加入一些东西，比如高/低温度或降水几率，那就太棒了。
- en: Next up, it'd be really cool to have a default location ability. There would
    be a command that lets me set a default location, and then I could run the weather
    app with no location argument to use that default. We could always specify a location
    argument to search for weather somewhere else. This would be an awesome feature,
    and it would work kind of similar to the Notes app, where we save data to the
    filesystem.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，拥有默认位置的能力将是非常酷的。会有一个命令让我设置一个默认位置，然后我可以在没有位置参数的情况下运行天气应用程序来使用默认位置。我们也可以指定一个位置参数来搜索其他地方的天气。这将是一个很棒的功能，它的工作方式有点类似于Notes应用程序，我们可以将数据保存到文件系统中。
- en: In the next chapter, we'll start creating web servers, which will be async.
    We'll make APIs, which will be async. Also, we'll create real-time Socket.IO apps,
    which will be async. We'll move on to creating Node apps that we deploy to servers,
    making those servers accessible to anybody with a web connection.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始创建异步的网络服务器。我们将制作异步的API。此外，我们将创建实时的Socket.IO应用程序，这也将是异步的。我们将继续创建Node应用程序，将其部署到服务器上，使这些服务器对任何具有网络连接的人都可以访问。
