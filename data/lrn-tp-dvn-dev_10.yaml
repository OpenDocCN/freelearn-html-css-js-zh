- en: Bringing It All Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切整合在一起
- en: In the previous chapters, we explored the different tools and techniques available
    for doing type-driven development in ReasonML.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了在 ReasonML 中进行类型驱动开发的不同工具和技术。
- en: In this chapter, using a final example, we are going to develop a sense for
    when to use each type-driven technique to solve problems. Let's see how we could,
    at least partly, create code that handles input (within a small JavaScript app)
    for social, productivity, and business applications. To be precise, what we mean
    here are the kinds of successful applications, such as Gmail, Facebook, Twitter,
    Skype, Airbnb, or Uber, launched by Internet or platform companies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，通过一个最终示例，我们将培养一种对何时使用每种类型驱动技术来解决问题的感觉。让我们看看我们至少可以部分地创建处理输入（在一个小的 JavaScript
    应用中）的社交、生产力和商业应用代码。更精确地说，我们这里指的是由互联网或平台公司推出的成功应用，如 Gmail、Facebook、Twitter、Skype、Airbnb
    或 Uber。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Starting with a variant type (version 1)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从变体类型开始（版本 1）
- en: Using more pattern matching (version 2)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更多模式匹配（版本 2）
- en: Switching to polymorphic variant types (version 3)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向多态变体类型（版本 3）
- en: Using records (version 4)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录（版本 4）
- en: Using modules for code structure (version 5)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块进行代码结构（版本 5）
- en: An alternative code structure (version 6)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码结构的另一种结构（版本 6）
- en: 'An improvement: Using lists as output (version 7)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进：使用列表作为输出（版本 7）
- en: 'Another improvement: Using mutable records (version 8)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一项改进：使用可变记录（版本 8）
- en: Unit testing our code (final version)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试我们的代码（最终版本）
- en: Starting with a variant type (version 1)
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从变体类型开始（版本 1）
- en: First, we need a `type` to represent the companies, which are internet-powered
    apps. Based on that `type`, we can think of writing functions that will help us
    build our logic in a type-safe manner. Let's see how it goes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个 `type` 来表示公司，这些公司是互联网应用。基于这个 `type`，我们可以考虑编写函数，以帮助我们以类型安全的方式构建逻辑。让我们看看结果如何。
- en: As a first attempt, we start small, defining a variant type for the internet
    companies we are interested in. As we have seen in previous chapters, we will
    use pattern matching to show the list of apps each of these companies delivers
    to their users.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一次尝试，我们从小处着手，定义一个我们感兴趣的互联网公司的变体类型。正如我们在前面的章节中看到的，我们将使用模式匹配来展示这些公司向用户提供的应用列表。
- en: 'We define the internet company type as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下定义互联网公司类型：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we define the function that shows the applications, based on the company,
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一个显示应用的函数，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following code will show some apps from Google:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将展示一些来自 Google 的应用：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the output of the whole code (generated from `src/Ch10/Ch10_PlatformCompany_V1.re`):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是整个代码的输出（由 `src/Ch10/Ch10_PlatformCompany_V1.re` 生成）：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's a good start.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个良好的开端。
- en: Since there are different categories of applications involved (social, business,
    communication, entertainment, and so on), we could enrich our type-driven logic
    by using more pattern matching code to differentiate the list of applications.
    Let's do that now.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及不同的应用类别（社交、商业、通信、娱乐等），我们可以通过使用更多的模式匹配代码来区分应用列表，从而丰富我们的类型驱动逻辑。现在让我们这样做。
- en: Using more pattern matching (version 2)
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更多模式匹配（版本 2）
- en: 'If we change the variants'' constructors to pass a string to them to represent
    each possible category (for example `Facebook(string)`, which could give `Facebook("social")`
    or `Facebook("business")`), we can do the trick. The additional pattern matching
    could then be something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将变体的构造函数更改为传递一个字符串以表示每个可能的类别（例如 `Facebook(string)`，它可以给出 `Facebook("social")`
    或 `Facebook("business")`），我们就可以做到这一点。额外的模式匹配可能如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, let''s start the second version of our code by defining the internet company
    variant type, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从定义互联网公司变体类型开始，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And, as we planned, our function''s pattern matching code could evolve, as
    follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们计划的那样，我们的函数的模式匹配代码可以演变，如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, the following code will show some result data, so we can see whether things
    work as expected:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下代码将展示一些结果数据，这样我们就可以看到事情是否按预期进行：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the output we get when executing this version (`src/Ch10/Ch10_PlatformCompany_V2.bs.js`,
    generated from `src/Ch10/Ch10_PlatformCompany_V2.re`):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行此版本时我们得到的结果（`src/Ch10/Ch10_PlatformCompany_V2.bs.js`，由 `src/Ch10/Ch10_PlatformCompany_V2.re`
    生成）：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that our type only accounts for internet companies, but our logic should
    also apply to other modern companies that use technology (web mobile, databases,
    AI) to build and deliver services in a scalable way. We can call them **platform
    companies**. So, we could add a type for platform companies too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的类型只考虑了互联网公司，但我们的逻辑也应该适用于其他使用技术（Web移动、数据库、AI）以可扩展的方式构建和提供服务的现代公司。我们可以称它们为**平台公司**。因此，我们也可以为平台公司添加一个类型。
- en: We can even consider that some internet companies (the big ones at least) are
    also platform companies or have launched platform businesses. So, we could change
    from *normal variant types* to *polymorphic variant types* to use their capability
    for type reuse.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以认为一些互联网公司（至少是那些大公司）也是平台公司或者已经推出了平台业务。因此，我们可以从*普通变体类型*切换到*多态变体类型*，以利用它们的类型重用能力。
- en: Let's start the third version based on these new ideas.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这些新想法开始第三个版本。
- en: Switching to polymorphic variant types (version 3)
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换到多态变体类型（版本 3）
- en: 'In this new version, we define the two types we build our logic around, reusing
    the first one inside the second one, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本中，我们定义了我们构建逻辑的两个类型，在第二个类型中重用第一个类型，如下所示：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Based on that, we make our function evolve as follows (using `platformCompany`
    to allow all the variants to be accepted for the `company` parameter):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们使我们的函数如下进化（使用`platformCompany`允许所有变体都能接受`company`参数）：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And now, let''s add the usual quick data display code, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加通常的快速数据显示代码，如下所示：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That seems like a good improvement, but let''s see whether it works. Testing
    the generated JavaScript code (based on `src/Ch10/Ch10_PlatformCompany_V3.re`)
    gives the following output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是一个很好的改进，但让我们看看它是否有效。基于`src/Ch10/Ch10_PlatformCompany_V3.re`生成的JavaScript代码的测试给出了以下输出：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Nice! What could we add to that?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！我们还能添加什么？
- en: 'Although this implementation is nice, you can quickly see it lacks the ability
    to handle a richer data structure. Basically, we would like to represent an *app*
    with all the needed information, such as *the name*, and *the URL* (at least for
    web apps). For that, Reason has a convenient tool we can use: *records*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个实现很棒，但你很快就能看出它缺乏处理更复杂数据结构的能力。基本上，我们希望用一个包含所有必要信息的*app*来表示，例如*名称*和*URL*（至少对于Web应用）。为此，Reason有一个方便的工具我们可以使用：*记录*。
- en: Let's see how it goes with the next version, using records to handle apps.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用记录处理应用的下个版本会怎样。
- en: Using records (version 4)
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用记录（版本 4）
- en: 'Nothing changes from our first variant types, but we will add the `webapp`
    record type definition to them, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的第一个变体类型相比，没有变化，但我们将添加`webapp`记录类型定义，如下所示：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we can input some data for the rest of the program, using that record
    type, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用该记录类型输入一些数据给程序的其余部分，如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we just defined a few of those values for a minimal test. The real
    production-ready code should include all the record values needed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只为最小测试定义了这些值中的几个。真正的生产就绪代码应该包括所有需要的记录值。
- en: 'The minimal `apps` function would then look like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的`apps`函数将如下所示：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s add some output display code, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些输出显示代码，如下所示：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We get the following output for that minimal testing case (code from the `src/Ch10/Ch10_PlatformCompany_V4.re`
    file):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了这个最小测试用例的以下输出（来自`src/Ch10/Ch10_PlatformCompany_V4.re`文件的代码）：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the next version, we will also use the URL of each app and show it in the
    output.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个版本中，我们还将使用每个应用的URL并在输出中显示它。
- en: We can also improve the global code structure by packaging some types and functions
    in modules.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将一些类型和函数打包到模块中来改进全局代码结构。
- en: Using modules for code structure (version 5)
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块进行代码结构（版本 5）
- en: 'The first improvement we can make is to create a module to contain the record
    for the web apps and a function that would return their string representation.
    Let''s call that module `WebApp`. Its definition is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一个改进是创建一个模块来包含Web应用的记录以及一个返回它们字符串表示的函数。让我们称这个模块为`WebApp`。它的定义如下：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, as in the previous version, we have our example web app values. The only
    thing that changes is that the type annotation is done using `WebApp.t`. That
    part of the code is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像上一个版本一样，我们有我们的示例Web应用值。唯一改变的是，类型注解使用`WebApp.t`完成。这部分代码如下：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We then create a module, called `Platform`, for the rest of the logic. It could
    contain the definition of the types for companies and the `apps` function. To
    make things simple, let's choose to have a unique polymorphic variant type that
    contains all the companies. Within the module, we can call it `t`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为 `Platform` 的模块，用于其余的逻辑。它可能包含公司类型的定义和 `apps` 函数。为了简化，让我们选择一个包含所有公司的唯一多态变体类型。在模块内部，我们可以称它为
    `t`。
- en: 'We create the module as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建模块如下：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can add a similar code that shows some possible output, and the code execution
    (JS code generated from the `src/Ch10/Ch10_PlatformCompany_V5.re` file) gives
    us an output similar to this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加类似的代码来展示一些可能的输出，以及代码执行（由 `src/Ch10/Ch10_PlatformCompany_V5.re` 文件生成的 JS
    代码）给出的输出类似于以下内容：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our result is encouraging. There may be different possibilities, so let's continue
    experimenting by trying an alternative code structure and later adding improvements.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果令人鼓舞。可能会有不同的可能性，所以让我们继续通过尝试替代的代码结构并进行后续改进来实验。
- en: An alternative code structure (version 6)
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代代码结构（版本 6）
- en: At this point, it's actually possible to write comprehensive code while using
    fewer modules in our code file. Let's keep the platform module, but move out what
    we had in the `WebApp` module in *Using modules for code structure (version 5)*,
    thus eliminating that module. At the same time, we will adjust some names and
    definitions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，实际上可以在我们的代码文件中使用更少的模块来编写全面的代码。让我们保留平台模块，但将我们在 *使用模块进行代码结构（版本 5）* 中拥有的
    `WebApp` 模块的内容移出，从而消除该模块。同时，我们将调整一些名称和定义。
- en: 'While we have fewer modules, we can improve our type-based code by introducing
    an interface file (`src/Ch10/Ch10_PlatformCompany_V6.rei`) to hold type information
    for the `.re` file (`src/Ch10/Ch10_PlatformCompany_V6.re`), as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有更少的模块时，我们可以通过引入一个接口文件（`src/Ch10/Ch10_PlatformCompany_V6.rei`）来改进基于类型的代码，该文件用于存储
    `.re` 文件（`src/Ch10/Ch10_PlatformCompany_V6.re`）的类型信息，如下所示：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we define the `webapp` and `pfcompany` types and adjust the `appToString`
    function accordingly (in `src/Ch10/Ch10_PlatformCompany_V6.re`), as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `webapp` 和 `pfcompany` 类型，并相应地调整 `appToString` 函数（在 `src/Ch10/Ch10_PlatformCompany_V6.re`
    中），如下所示：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, there is no algorithmic change in the part where we do the *let bindings*
    to have input data for the web apps, so because of readability, we will not repeat
    that part of the code here. You can see the complete set of record values in the
    `src/Ch10/Ch10_PlatformCompany_V6.re` file, and you will notice that we added
    input for some Google apps, as shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在执行 *let 绑定* 以获取 web 应用输入数据的部分没有算法上的变化，因此为了可读性，我们不会在这里重复那段代码。您可以在 `src/Ch10/Ch10_PlatformCompany_V6.re`
    文件中看到完整的记录值集合，您会注意到我们添加了一些 Google 应用的输入，如下所示：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we improve the `Platform` module code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们改进 `Platform` 模块代码：
- en: We have the `Platform` module, which is preceded by its signature, `PlatformType`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有 `Platform` 模块，它前面是它的签名 `PlatformType`。
- en: We're using `pfcompany` now as the type for the `company` values.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在使用 `pfcompany` 作为 `company` 值的类型。
- en: We added the case of Google (and their apps) in the code for pattern matching
    in the `apps` function.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `apps` 函数的模式匹配代码中添加了 Google（及其应用）的情况。
- en: 'The improvised part of the platform module code is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 平台模块代码的改进部分如下：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make this version of the implementation easily testable, we add the usual
    input and output printing code, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个实现版本的测试变得容易，我们添加了常用的输入和输出打印代码，如下所示：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To recap, we improved the type declarations using a `.rei` file (which helps
    with code documentation), we added a module signature (`PlatformType`) for platform,
    and we improved the coverage of the input by adding the Google case.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们通过使用 `.rei` 文件（有助于代码文档）改进了类型声明，为平台添加了一个模块签名（`PlatformType`），并通过添加 Google
    情况来扩展了输入的覆盖范围。
- en: The reader is encouraged to add input data (for the other companies in the variant
    type, such as Twitter, Amazon, and Uber).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励读者添加输入数据（用于变体类型中的其他公司，如 Twitter、Amazon 和 Uber）。
- en: An improvement – using lists as output (version 7)
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种改进——使用列表作为输出（版本 7）
- en: You noticed that in our output, we are just using strings (via concatenation).
    From the beginning, we could have returned a real list of the apps from each company.
    No problem, let's change the code to do that now.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到，在我们的输出中，我们只是使用字符串（通过连接）。从一开始，我们就可以返回每个公司真实的应用列表。没问题，让我们现在更改代码来实现这一点。
- en: The change is limited to the `Platform` module. In the signature, for the `apps`
    function, we change the output type from `string` to `list(string)`. And, in the
    pattern matching part of the function, we change the implementation accordingly,
    for example, by returning the `[appToString(facebook), appToString(messenger),
    appToString(instagram)]` list for Facebook apps.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 改变仅限于`Platform`模块。在签名中，对于`apps`函数，我们将输出类型从`string`更改为`list(string)`。在函数的模式匹配部分，我们相应地更改实现，例如，通过返回`[appToString(facebook),
    appToString(messenger), appToString(instagram)]`列表来表示Facebook应用。
- en: 'The main part of the new version is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的主要部分如下：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since we now output lists, it is a good idea to use `Array.of_list` to print
    them, since it is a  nice and quick  solution. We change the last part of the
    code with the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在输出列表，所以使用`Array.of_list`来打印它们是个好主意，因为它是一个既好又快的解决方案。我们用以下代码更改代码的最后部分：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Executing the resulting code with my input data gives the following output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我的输入数据执行生成的代码，得到以下输出：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Nice! This was an interesting improvement. Let's continue adding to it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这是一个有趣的改进。让我们继续添加。
- en: Another improvement – using mutable records (version 8)
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一个改进——使用可变记录（版本8）
- en: Now, we could use a mutable record for the `webapp` type, so that we use it
    for interesting app data that keeps updating. One such data point is the number
    of accounts created. Another one could be the number of downloads of the corresponding
    mobile app.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为`webapp`类型使用可变记录，这样我们就可以用它来处理不断更新的有趣应用数据。这样一个数据点是创建的账户数量。另一个可能是对应移动应用的下载次数。
- en: 'In this example, let''s see how we can improve our implementation by adding
    the *number of accounts* parameter to the record. This is done by using `mutable
    numberOfAccounts: int` as the entry for that parameter in the record definition.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，让我们看看如何通过向记录中添加*账户数量*参数来改进我们的实现。这是通过使用`mutable numberOfAccounts: int`作为记录定义中该参数的条目来完成的。'
- en: 'So that''s the only change for now, but let''s recap the definitions for the
    `webapp` type, the `pfcompany` type, and the `appToString` function for better
    readability, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在只有这一个更改，但让我们回顾一下`webapp`类型、`pfcompany`类型和`appToString`函数的定义，以便更好地阅读，如下所示：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that, let''s add a function that increments the value of `numberofAccounts` in
    the record corresponding to a web app each time there is a new sign-up. This function
    could look as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们添加一个函数，每次有新的注册时，都会在记录中对应网页应用的`numberofAccounts`值上增加。这个函数可能看起来如下所示：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, as before, we have the input data part. But now we have the new parameter
    `newSignUp` which we have to keep updating. To make things simple, let''s pretend
    that all these apps currently have the same number of accounts, and we choose
    10,000 as an arbitrary number. So, now the record definitions are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像之前一样，我们有输入数据部分。但现在我们有了新的参数`newSignUp`，我们必须不断更新它。为了简化问题，让我们假设所有这些应用目前都有相同的账户数量，我们选择10,000作为一个任意数。因此，现在的记录定义如下：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There is no change in the `Platform` module part, so let''s move to the next
    and last part, the code that tests things:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Platform`模块部分没有变化，所以让我们转到下一部分，也就是测试代码的部分：'
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Executing the code compiled from the `src/Ch10/Ch10_PlatformCompany_V5.re` file
    gives the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从`src/Ch10/Ch10_PlatformCompany_V5.re`文件编译的代码执行给出以下输出：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, we just took an interesting use case where mutable records can be used,
    and saw how easy it is to add that functionality.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只选取了一个有趣的用例，其中可以使用可变记录，并看到了添加该功能是多么简单。
- en: Unit testing our code (final version)
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试我们的代码（最终版本）
- en: Now is the time to add tests to our code! For a complete demonstration, let's
    create a new package in which we will do the necessary setup for writing unit
    tests with the `Jest` framework.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候给我们的代码添加测试了！为了完整演示，让我们创建一个新的包，我们将在这个包中设置使用`Jest`框架编写单元测试所必需的设置。
- en: Another web technology used at Facebook, `Jest` is a framework for writing tests
    for JavaScript code, which also works with compile-to-JavaScript languages, such
    as TypeScript or ReasonML. For Reason, we also need to install the `bs-jest` package,
    which provides bindings for Jest in BuckleScript.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Facebook使用的另一种网络技术，`Jest`是一个用于编写JavaScript代码测试的框架，它还与编译到JavaScript的语言（如TypeScript或ReasonML）一起工作。对于Reason，我们还需要安装`bs-jest`包，它为BuckleScript提供了Jest的绑定。
- en: Creating our final package and setting up for tests
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的最终包并设置测试
- en: 'To quickly get things working, we create a folder, called `Ch10-final`, which
    contains the following file structure:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速启动工作，我们创建了一个名为 `Ch10-final` 的文件夹，其中包含以下文件结构：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We got the `package.json` file by copying the one we were using, generated
    by the ReasonML or BuckleScript code starter, and adapting it. The first version
    is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过复制 ReasonML 或 BuckleScript 代码生成器生成的我们正在使用的 `package.json` 文件，并对其进行调整来获取
    `package.json` 文件。第一个版本如下：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then, we can add `Jest` and `bs-jest` (the one referenced by `glennsl/bs-jest`,
    to be precise) as development dependencies to our package using `npm`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `npm` 将 `Jest` 和 `bs-jest`（确切地说是 `glennsl/bs-jest` 中引用的）添加到我们的包中作为开发依赖项。
- en: To install `bs-jest`, run the `npm install @glennsl/bs-jest --save-dev` command.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `bs-jest`，请运行 `npm install @glennsl/bs-jest --save-dev` 命令。
- en: To install `Jest`, run the `npm install jest --save-dev` command.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `Jest`，请运行 `npm install jest --save-dev` 命令。
- en: 'With these installations, the required files are installed in the usual `node_modules`
    subdirectory and our `package.json` file changes to reference both dependencies
    with the versions that were installed. The updated `devDependencies` in the `package.json`
    file shows the two additions, as seen in the following extract:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些安装，所需的文件被安装到常规的 `node_modules` 子目录中，并且我们的 `package.json` 文件更改以引用已安装的两个依赖项的版本。`package.json`
    文件中的更新 `devDependencies` 显示了两个新增项，如下所示：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `bsconfig.json` file is also copied (and adapted) from the one we were
    using for the previous code setup (which allows the `bsb -w` command to work,
    and our `.re` files to be compiled on the fly). We adjust the `sources` list to
    reference both the `src` directory for the usual code and the `__tests__` directory
    for the *test code* (notice the `"type": "dev"` part), as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`bsconfig.json` 文件也是从我们之前使用的代码设置中复制（并调整）的（这允许 `bsb -w` 命令工作，并且我们的 `.re` 文件可以即时编译）。我们将
    `sources` 列表调整为引用 `src` 目录的常规代码和 `__tests__` 目录的 *测试代码*（注意 `"type": "dev"` 部分），如下所示：'
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last thing we need to add is the `@glennsl/bs-jest` reference to the `bs-dev-dependencies`
    parameter. We will see why in a minute.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要添加的是将 `@glennsl/bs-jest` 添加到 `bs-dev-dependencies` 参数中。我们将在下一分钟看到原因。
- en: 'The `bsconfig.json` file for our `ch10final` package is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `ch10final` 包的 `bsconfig.json` 文件如下：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the `src` subdirectory, we can add our final Reason code file (`src/Ch10-final/src/Ch10_PlatformCompany.re`).
    Our ReasonML code is exactly the same as in the previous version (the `src/Ch10/Ch10_PlatformCompany_V8.re` file),
    except that we simplify it by removing the last bit (the snippet that prints some
    output).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 子目录中，我们可以添加我们的最终 Reason 代码文件（`src/Ch10-final/src/Ch10_PlatformCompany.re`）。我们的
    ReasonML 代码与上一个版本（`src/Ch10/Ch10_PlatformCompany_V8.re` 文件）完全相同，除了我们通过删除最后部分（打印一些输出的代码片段）来简化它。
- en: Now, let's write the tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写测试。
- en: Writing our first tests
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个测试
- en: 'To test code using `Jest`, we must start by opening the module:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Jest` 测试代码，我们必须首先打开模块：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we define a `describe` function to encapsulate the tests suite. We need
    to open the `Expect` module, part of `Jest`, which provides the `expect` function
    with other things where we need to check that some values meet certain conditions.
    We also open the module file, which contains our implementation code. So far,
    our test function contains the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个 `describe` 函数来封装测试套件。我们需要打开 `Expect` 模块，它是 `Jest` 的一部分，它提供了 `expect`
    函数以及其他一些我们需要检查某些值是否满足特定条件的地方。我们还打开模块文件，其中包含我们的实现代码。到目前为止，我们的测试函数包含以下内容：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we can add a first test to verify the data returned by the `apps` function
    in the `Platform` module. The test suite code is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加第一个测试来验证 `Platform` 模块中 `apps` 函数返回的数据。测试套件代码如下：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let's not stop here and add a second test that verifies that the number of accounts
    is the previous number incremented by `1` after the `newSignUp` function has been
    called.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要停下来，添加第二个测试来验证在调用 `newSignUp` 函数后，账户数量是否是上一个数量加 `1`。
- en: 'The complete tests suite code is as follows (in the `src\Ch10-final\__tests__\Platform_test.re` file):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的测试套件代码如下（在 `src\Ch10-final\__tests__\Platform_test.re` 文件中）：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Running the tests
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: Before we can execute the tests, we need to build the code using the `bsb -make-world`
    command. This finds the test code and compiles it. If everything goes well, that
    process copies the resulting files in the `lib` part (generated) of the package
    structure (under `src\Ch10-final\lib\bs\__tests__`). We are now ready to run the
    tests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行测试之前，我们需要使用`bsb -make-world`命令来构建代码。这个命令会找到测试代码并编译它。如果一切顺利，这个过程会将生成的文件复制到包结构的`lib`部分（位于`src\Ch10-final\lib\bs\__tests__`）。我们现在可以开始运行测试了。
- en: To run the tests, we use the `Jest` command. In my case, running this on Windows,
    the executable is actually located at `node_modules\.bin\jest`, but in your case,
    you could just type `jest`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，我们使用`Jest`命令。在我的情况下，在Windows上运行，可执行文件实际上位于`node_modules\.bin\jest`，但根据你的情况，你只需输入`jest`即可。
- en: 'When we execute the `Jest` test runner command, we get the following output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行`Jest`测试运行器命令时，我们会得到以下输出：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: At this point, we have a good structure, including a test suite, and we can
    build on it. We can extend the input part of the code to take all the *platform
    companies* into account and add more functionalities. And we can add more tests
    as we go. This is left as an exercise for the reader.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有一个良好的结构，包括一个测试套件，我们可以在此基础上进行扩展。我们可以扩展代码的输入部分，以考虑所有*平台公司*，并添加更多功能。我们还可以在过程中添加更多测试。这留作读者的练习。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built some type-safe code that is also relatively easy to
    maintain and extend, using Reason's core features. We could go further to have
    more generic code using advanced techniques, such as functors, but that is not
    necessary for this small example.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Reason的核心特性构建了一些类型安全的代码，这些代码也相对容易维护和扩展。我们可以进一步使用高级技术，如函子，来创建更通用的代码，但这对于这个小示例来说并不是必要的。
- en: This was the final chapter. We iterated through a type-driven process of solving
    coding problems. While doing so, we improved our understanding of ReasonML's features
    and techniques, in particular variant types, functions, modules, and records.
    We also looked at how to test ReasonML code directly using the `Jest` framework.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们最后一章。我们通过类型驱动的过程解决了编码问题。在这个过程中，我们提高了对ReasonML的特性和技术，特别是变体类型、函数、模块和记录的理解。我们还探讨了如何使用`Jest`框架直接测试ReasonML代码。
- en: I hope the book was useful as an introduction to the world of ML languages,
    and that it will help you go further with the ReasonML techniques and tools, and
    maybe even with React if you are a web developer with additional skills.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这本书作为ML语言世界的入门之书是有用的，并且它将帮助你进一步学习ReasonML的技术和工具，如果你是一个具有额外技能的Web开发者，甚至可能包括React。
