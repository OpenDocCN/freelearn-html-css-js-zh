- en: Chapter 2. Basic Syntax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 基本语法
- en: In this chapter, we will introduce the basic syntax of Opa. This chapter will
    not cover every little tiny thing about Opa, but it is something you should know.
    It's also assumed that you have some basic knowledge about computer programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Opa 的基本语法。本章不会涵盖 Opa 的每一个细节，但它是一些你应该了解的知识点。同时假设你具备一些计算机编程的基础知识。
- en: Basic datatypes
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数据类型
- en: 'Datatypes are the shapes of data manipulated by an application. Opa uses datatypes
    to perform sanity and security checks on your application. Opa also uses datatypes
    to perform a number of optimizations. There are three basic datatypes in Opa:
    integers, floats, and strings. Also, you can define your type with the keyword
    `type`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型是应用程序操作的数据的形状。Opa 使用数据类型对你的应用程序进行合理性和安全性检查。Opa 还使用数据类型执行多项优化。Opa 有三种基本数据类型：整数、浮点数和字符串。此外，你可以使用
    `type` 关键字定义自己的类型：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Actually, thanks to a mechanism of type inference, Opa can work in most cases
    even if you do not provide any type information. For example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，多亏了类型推断机制，Opa 在大多数情况下即使你没有提供任何类型信息也能工作。例如：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So in the rest of this chapter, we will not address type information before
    variable, but you should know what type it is in your mind. In actual coding,
    a best practice is to provide the datatypes of our main functions and to let the
    inference engine pick up the datatypes of all the local variables and minor functions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章的其余部分，我们不会在变量之前讨论类型信息，但你应该在心里知道它的类型。在实际编码中，一个最佳实践是提供我们主要函数的数据类型，并让推断引擎获取所有局部变量和次要函数的数据类型。
- en: Integers
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: 'It is quite simple to write integer literals; there are a number of ways to
    do so:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 编写整型字面量相当简单；有几种方式可以做到这一点：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The tailing semicolon is optional in Opa; you can add it if you want.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Opa 中，尾随的分号是可选的；如果你想的话可以添加它。
- en: 'Opa provides the module `Int` ([http://doc.opalang.org/module/stdlib.core/Int](http://doc.opalang.org/module/stdlib.core/Int))
    to operate on integers. The following are the most used functions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Opa 提供了 `Int` 模块（[http://doc.opalang.org/module/stdlib.core/Int](http://doc.opalang.org/module/stdlib.core/Int)）来操作整数。以下是最常用的函数：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is no automatic type conversion between `float`, `int`, and `String`.
    So, use the following functions to convert between `int`, `float`, and `String`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `float`、`int` 和 `String` 之间没有自动类型转换。因此，请使用以下函数在 `int`、`float` 和 `String` 之间进行转换。
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Floats
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: 'It is also easy to define floats. They can be written in the following ways:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 定义浮点数也很容易。它们可以写成以下方式：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Opa provides the module `Float` ([http://doc.opalang.org/module/stdlib.core/Float](http://doc.opalang.org/module/stdlib.core/Float))
    to operate on floats. The following are the most used functions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Opa 提供了 `Float` 模块（[http://doc.opalang.org/module/stdlib.core/Float](http://doc.opalang.org/module/stdlib.core/Float)）来操作浮点数。以下是最常用的函数：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Strings
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: In Opa, text is represented by immutable utf8-encoded character strings. String
    literals follow roughly the same syntax used in C language, Java, or JavaScript.
    Note that you will have to escape special characters with backslashes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Opa 中，文本由不可变的 utf8 编码字符字符串表示。字符串字面量遵循类似于 C 语言、Java 或 JavaScript 中使用的语法。请注意，你必须使用反斜杠转义特殊字符。
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Opa has a feature called string insertions, which can put arbitrary expressions
    into a string. You can do that by embedding an expression between curly braces
    into a string. For example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Opa 有一个称为字符串插入的功能，可以将任意表达式放入字符串中。你可以通过在字符串中嵌入花括号内的表达式来实现这一点。例如：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Opa provides the module `String` ([http://doc.opalang.org/module/stdlib.core/String](http://doc.opalang.org/module/stdlib.core/String))
    to operate on strings. The most commonly used are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Opa 提供了 `String` 模块（[http://doc.opalang.org/module/stdlib.core/String](http://doc.opalang.org/module/stdlib.core/String)）来操作字符串。以下是最常用的功能：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sum
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 和
- en: A value has a sum type `t` or `u`, meaning that the values of this type are
    either of the two variants, a value of type `t` or a value of type `u`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值有一个类型 `t` 或 `u` 的和类型，这意味着这个类型的值可以是两种变体之一，即类型 `t` 的值或类型 `u` 的值。
- en: 'A good example of sum type are Boolean values, which are defined as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 和类型的一个好例子是布尔值，其定义如下：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Thus, a variable of type `bool` can be either `{true}` or `{false}`. Another
    commonly used sum type is the `option` type, which is defined as:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类型为 `bool` 的变量可以是 `{true}` 或 `{false}`。另一个常用的和类型是 `option` 类型，其定义如下：
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The ``option(`a)`` value is either `none` or `some` (a value x of type `` `a
    ``). Type `` `a `` means any type. This is a type-safe way to deal with possibly
    non-existing values. The `option` type is widely used; let''s take `String.index`
    for example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`option(`a`)` 值要么是 `none`，要么是 `some`（类型为 `a` 的值 x）。类型 `a` 表示任何类型。这是一种类型安全地处理可能不存在值的方法。`option`
    类型被广泛使用；以 `String.index` 为例：'
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The return type of `String.index` is the option (`int`), which means it will
    return a `{some:int}` record if a substring appears or a `{none}` record if it
    doesn't.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.index` 的返回类型是选项（`int`），这意味着如果出现子串，它将返回一个 `{some:int}` 记录；如果没有出现，则返回一个
    `{none}` 记录。'
- en: Note that the sum datatypes are not limited to two cases; they can have tens
    of cases.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，求和数据类型不仅限于两种情况；它们可以有数十种情况。
- en: Functions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Opa is a functional language. One of its features is that functions are regular
    values, which means a function may be passed as a parameter or returned as a result.
    As such, they follow the same naming rules as any other value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Opa 是一种函数式语言。其特性之一是函数是常规值，这意味着函数可以作为参数传递或作为结果返回。因此，它们遵循与其他任何值相同的命名规则。
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Last expression return
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后的表达式返回
- en: 'You may notice that there is no return inside the body of a function. That''s
    because Opa uses last expression return, which means the last expression of a
    function is the return value. For example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到函数体中没有返回语句。这是因为 Opa 使用最后表达式返回，这意味着函数的最后表达式是返回值。例如：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If `x` is greater than or equal to `y`, then `x` is the last expression and
    `x` will be returned; if `y` is greater than `x`, then `y` is the last expression
    and `y` will be returned.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 大于或等于 `y`，则 `x` 是最后一个表达式，并将返回 `x`；如果 `y` 大于 `x`，则 `y` 是最后一个表达式，并将返回 `y`。
- en: Modules
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: 'Functionalities are usually regrouped into modules; for example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 功能通常被重新组合到模块中；例如：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can access the content of a module by using the dot operator (`.`); for instance,
    `M.x`, `M.y`, and `M.test`. Actually, the content of a module is not field definitions,
    but bindings. In this example, we bind integer `1` to variable `x`, and bind the
    value of variable `x` to variable `y`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用点操作符（`.`）来访问模块的内容；例如，`M.x`、`M.y` 和 `M.test`。实际上，模块的内容不是字段定义，而是绑定。在这个例子中，我们将整数
    `1` 绑定到变量 `x`，并将变量 `x` 的值绑定到变量 `y`。
- en: Data structures
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: The only way to build data structures in Opa is to use records, which we will
    talk about later on. All other data structures, such as tuples and lists, are
    based on records. Opa provides different modules to help the user to manipulate
    lists and maps. Let's first have a look at records.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Opa 中构建数据结构的唯一方法是使用记录，我们将在稍后讨论。所有其他数据结构，如元组和列表，都是基于记录的。Opa 提供了不同的模块来帮助用户操作列表和映射。让我们首先看看记录。
- en: Records
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录
- en: 'Simply speaking, a record is a collection of data. Here is how to build a record:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，记录是一组数据的集合。以下是构建记录的方法：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The empty record,`{}`, has a synonym, `void`, which means the same thing. There
    are a number of syntactic shortcuts available to write records concisely. First,
    if you give a field name without the field value, it means the value of this field
    is `void`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 空记录 `{}` 有一个同义词 `void`，意味着相同的意思。有几种语法简写可用于简洁地编写记录。首先，如果你给出字段名而没有字段值，这意味着该字段的值是
    `void`：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second shorthand we always use is the sign `~`. It means if the field value
    is left empty, assign it with a variable having the same name as the field name:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用的第二个简写是符号 `~`。它表示如果字段值留空，则将其分配给与字段名相同的变量：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also build a record deriving from an existing record using the keyword
    `with`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用关键字 `with` 从现有记录构建记录：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that you can redefine as many fields as you want. In the example we saw
    just now, the field `a` in `y` is a string, but the field `a` in `x` is an integer.
    Here are some more examples about deriving:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以重新定义任意多的字段。在我们刚才看到的例子中，`y` 中的字段 `a` 是一个字符串，但 `x` 中的字段 `a` 是一个整数。这里有一些关于派生的更多例子：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tuples
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'An N-tuple is a sequence of *n* elements, where N is a positive integer. In
    Opa, an N-tuple is just a record with fields `f1` to `fN`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: N-元组是一个由 *n* 个元素组成的序列，其中 N 是一个正整数。在 Opa 中，N-元组只是一个具有字段 `f1` 到 `fN` 的记录：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note the trailing comma in the first case; it differentiates a 1-tuple from
    a parenthesized expression. The trailing comma is allowed for any other tuple,
    although, it makes no difference whether you write it or not in these cases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一个情况中的尾随逗号；它区分了 1-元组和大括号表达式。尾随逗号适用于任何其他元组，尽管在这种情况下写或不写都没有区别。
- en: Lists
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'In Opa, a list (linked list) is an immutable data structure, meant to contain
    finite or infinite sets of elements of the same type. Actually, list is just a
    record with special structures, which is defined as:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Opa中，一个列表（链表）是一个不可变的数据结构，旨在包含有限或无限个相同类型的元素集合。实际上，列表只是一个具有特殊结构的记录，定义为：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is how to build lists:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建列表的方法：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lists in Opa are much like arrays in C language and Java. But there are differences.
    First, lists are immutable in Opa, which means elements of a list cannot be changed
    by assignment. Second, the way we manipulate lists are different. We use the module
    `List` ([http://doc.opalang.org/module/stdlib.core/List](http://doc.opalang.org/module/stdlib.core/List))
    to manage lists in Opa. The following are the most commonly used operations on
    lists (which will be explained in the subsequent sections):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Opa中的列表与C语言和Java中的数组非常相似。但也有一些区别。首先，Opa中的列表是不可变的，这意味着列表的元素不能通过赋值来改变。其次，我们操作列表的方式不同。我们使用`List`模块（[http://doc.opalang.org/module/stdlib.core/List](http://doc.opalang.org/module/stdlib.core/List)）在Opa中管理列表。以下是在列表上最常用的操作（将在后续章节中解释）：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Iterating through a list
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历列表
- en: 'In C language or Java, we use a `for` or a `while` loop to iterate through
    lists or arrays. They look something like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言或Java中，我们使用`for`或`while`循环来遍历列表或数组。它们看起来像这样：
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'But in Opa, it is totally different. To loop through a list, we use `List.fold`
    or `List.foldi`. `List.fold` is a powerful function that you can use to do almost
    anything you want on a list. Here is a simple example of getting the length of
    a list:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Opa中，情况完全不同。要遍历一个列表，我们使用`List.fold`或`List.foldi`。`List.fold`是一个强大的函数，你可以用它来对列表执行几乎任何操作。以下是一个获取列表长度的简单示例：
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`List.fold` takes three parameters. The first is a function, the second is
    the list, and the third is an initial value. It loops through the list and applies
    the function on each element. So, if we name the function `f`, it is executed
    something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`List.fold`接受三个参数。第一个是一个函数，第二个是列表，第三个是初始值。它遍历列表并对每个元素应用该函数。所以，如果我们命名这个函数为`f`，它的执行方式如下：'
- en: '[PRE27]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, `f("a",0)` will be executed and will return 1, here `0` is the initial
    value and `a` is the first element. Then `f("b",1)` will return 2 and at last
    `f("c",2)` will return 3\. Here is a little more complicated example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`f("a",0)`将被执行并返回1，这里的`0`是初始值，`a`是第一个元素。然后`f("b",1)`将返回2，最后`f("c",2)`将返回3。以下是一个更复杂的示例：
- en: '[PRE28]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finding elements
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找元素
- en: 'We have many ways to find an element in a list. `List.index` searches the first
    occurrence of an element and returns its index. `List.index_p` searches the first
    occurrence of any element matching a given function and returns its index. `List.find`
    is the same as `List.index_p`, but returns the element itself but not its index.
    For example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种方法在列表中查找元素。`List.index`搜索元素的第一次出现并返回其索引。`List.index_p`搜索匹配给定函数的任何元素的第一次出现并返回其索引。`List.find`与`List.index_p`相同，但返回元素本身而不是其索引。例如：
- en: '[PRE29]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Transforming lists
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表转换
- en: 'If you want to project elements to a new list, for example doubling the number
    in a list or selecting the odd numbers, you can do this with `List.map` and `List.filter`.
    Here are some examples:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将元素投影到一个新的列表中，例如将列表中的数字加倍或选择奇数，你可以使用`List.map`和`List.filter`来实现。以下是一些示例：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Sorting a list
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序列表
- en: 'Call the function `List.sort` to sort a list in the usual order. The usual
    order means the default order, that is, numbers from small to big and strings
    in alphabetical order. Consider the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`List.sort`函数以通常的顺序对列表进行排序。通常的顺序是指默认的顺序，即从小到大排序数字和按字母顺序排序的字符串。考虑以下代码：
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`List.sort_by` uses the usual order, but it projects elements, for example,
    converting strings to lower-case before comparing them. `List.sort_with` allows
    us to use our own comparing function.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`List.sort_by`使用通常的顺序，但它将元素投影出来，例如在比较之前将字符串转换为小写。`List.sort_with`允许我们使用自己的比较函数。'
- en: 'To make that clear, suppose there are three points, P1 (1, 3), P2 (3, 2), and
    P3 (2, 1), and we want to sort them in two different ways:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明，假设有三个点，P1 (1, 3)，P2 (3, 2)，和P3 (2, 1)，我们想要以两种不同的方式对它们进行排序：
- en: By their Y coordinates
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过它们的Y坐标
- en: By distance from the origin of the coordinates (0, 0)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过坐标原点（0, 0）的距离
- en: 'Let''s see how to do that in Opa:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在Opa中如何做到这一点：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Maps
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: Maps are an important data structure just like lists. The most common cases
    of maps in Opa are `stringmap` and `intmap`. `stringmap` is a map from string
    to value of some type, while `intmap` is a map from numbers to value of some type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是一个重要的数据结构，就像列表一样。在 Opa 中，映射最常见的用例是 `stringmap` 和 `intmap`。`stringmap` 是从字符串到某种类型值的映射，而
    `intmap` 是从数字到某种类型值的映射。
- en: 'The way we manipulate maps is almost the same as lists, it is unwise to repeat
    it again. Here are some of the most used operations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们操作映射的方式几乎与列表相同，再次重复是不明智的。以下是一些最常用的操作：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Pattern matching
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'Pattern matching is a generalization of C language or Java''s `switch` statement.
    In C language and Java, the `switch` statement only allows you to choose from
    many statements based on an integer (including `char`) or an `enum` value. While
    in Opa, pattern matching is more powerful than that. The more general syntax for
    pattern matching is:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是 C 语言或 Java 的 `switch` 语句的泛化。在 C 语言和 Java 中，`switch` 语句仅允许你根据整数（包括 `char`）或
    `enum` 值从许多语句中选择。而在 Opa 中，模式匹配比这更强大。模式匹配的更通用语法如下：
- en: '[PRE34]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When a pattern is executed, `<expr>` is evaluated to a value, which is then
    matched against each pattern in order until a case is found. You can think about
    it this way:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式执行时，`<expr>` 被评估为一个值，然后按顺序与每个模式匹配，直到找到匹配的案例。你可以这样想：
- en: '[PRE35]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The rules of pattern matching are simple and are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配的规则很简单，如下所示：
- en: '**Rule 1**: Any value matches the pattern `_`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 1**：任何值都匹配模式 `_`'
- en: '**Rule 2**: Any value matches the variable pattern `x`, and the value is bound
    to the identifier `x`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 2**：任何值都匹配变量模式 `x`，并且该值被绑定到标识符 `x`'
- en: '**Rule 3**: An integer/float/string matches an integer/float/string pattern
    when they are equal'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 3**：当整数/浮点数/字符串相等时，它们匹配整数/浮点数/字符串模式'
- en: '**Rule 4**: A record (including tuples and lists) matches a closed record pattern
    when both records have the same fields and the value of the fields matches the
    pattern component-wise'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 4**：当两个记录具有相同的字段且字段值按组件匹配模式时，记录（包括元组和列表）匹配封闭记录模式'
- en: '**Rule 5**: A record (including tuples and lists) matches an open record pattern
    when the value has all the fields of the pattern (but can have more) and the value
    of the common fields matches the pattern component-wise'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 5**：当值具有模式的所有字段（但可以更多）且公共字段的值按组件匹配模式时，记录（包括元组和列表）匹配开放记录模式'
- en: '**Rule 6**: A value matches a pattern as `x` pattern when the value matches
    the pattern, and additionally it binds `x` to the value'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 6**：当值匹配模式时，它匹配为 `x` 模式，并且此外它将 `x` 绑定到该值'
- en: '**Rule 7**: A value matches an `OR` pattern if one of the values matches one
    of the two subpatterns'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 7**：如果一个值匹配两个子模式中的一个，则该值匹配 `OR` 模式'
- en: '**Rule 8**: In all the other cases, the matching fails'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 8**：在所有其他情况下，匹配失败'
- en: 'The first three and the last three rules (rule 1, 2, 3, 6, 7, 8) are easy to
    understand. Let''s take a look at them:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前三条规则和最后三条规则（规则 1、2、3、6、7、8）很容易理解。让我们来看看它们：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This code will not compile, we just used it to illustrate the rules.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码无法编译，我们只是用它来展示规则。
- en: 'Rule 4 and rule 5 are a little more complicated. A close record pattern is
    a record with fixed fields. An open record pattern is a record that ends with
    `…` to indicate that it may have other fields we do not care about. The following
    examples may make that clearer:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 4 和规则 5 稍微复杂一些。一个紧密记录模式是一个具有固定字段的记录。一个开放记录模式是一个以 `…` 结尾的记录，表示它可能包含我们不关心的其他字段。以下示例可能使这一点更清晰：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also match tuples and lists (since tuples and lists are special records,
    they are not hard to understand). For example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以匹配元组和列表（因为元组和列表是特殊的记录，它们并不难理解）。例如：
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Text parsers
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本解析器
- en: 'Parsing is something that web apps need to do quite often. Opa features a built-in
    syntax for building text parsers, which are first class values just as functions.
    The parser is based on parsing expression grammar ([http://en.wikipedia.org/wiki/Parsing_expression_grammar](http://en.wikipedia.org/wiki/Parsing_expression_grammar)),
    which may look like regular expressions at first, but do not behave anything like
    them. One big advantage of text parsers over regular expressions is that you can
    easily combine parsers. A good example is parsing URLs. Let''s start right away
    with our first Opa parser:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 解析是网络应用程序需要经常执行的操作。Opa提供了一种内置的语法来构建文本解析器，这些解析器就像函数一样是一等值。解析器基于解析表达式语法([http://en.wikipedia.org/wiki/Parsing_expression_grammar](http://en.wikipedia.org/wiki/Parsing_expression_grammar))，一开始可能看起来像正则表达式，但它们的行为与正则表达式截然不同。文本解析器相对于正则表达式的一个主要优点是你可以轻松地组合解析器。一个很好的例子是解析URL。让我们立即开始我们的第一个Opa解析器：
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For `first_parser`, the expressions are just literal strings, which means this
    parser will succeed only if fed with the string `"Opa"`. Then how to use this
    parser? The module `Parser` ([http://doc.opalang.org/module/stdlib.core.parser/Parser](http://doc.opalang.org/module/stdlib.core.parser/Parser))
    has a bunch of functions to deal with parsers. The most important one is:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`first_parser`，表达式只是字面字符串，这意味着这个解析器只有在用字符串`"Opa"`喂入时才会成功。那么如何使用这个解析器呢？`Parser`模块([http://doc.opalang.org/module/stdlib.core.parser/Parser](http://doc.opalang.org/module/stdlib.core.parser/Parser))提供了一系列处理解析器的函数。其中最重要的一项是：
- en: '[PRE40]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It takes a parser and a string as parameters and produces an optional value
    of some type. Let''s see how to use this function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个解析器和字符串作为参数，并产生某种类型的可选值。让我们看看如何使用这个函数：
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now let''s consider the following parsers:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑以下解析器：
- en: '[PRE42]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Both `digit1` and `digit2` accept a number string like `"5","100"`, and both
    will assign the value to the identifier `x`. If we feed the parser `digit1` with
    the string `"100"`, x will be the parsing result of the string: a list of characters
    [`''1'',''0'',''0''`]. If we feed the string `"100"` to parser `digit2`, `x` will
    be the input string: `100`. So, if we want to get hold of the input string, we
    need to put the expression in parentheses.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`digit1`和`digit2`都接受像`"5"`、`"100"`这样的数字字符串，并且两者都会将值赋给标识符`x`。如果我们用字符串`"100"`来喂`digit1`解析器，`x`将是字符串的解析结果：字符列表`[''1'',''0'',''0'']`。如果我们用字符串`"100"`来喂`digit2`解析器，`x`将是输入字符串：`100`。因此，如果我们想获取输入字符串，我们需要将表达式放在括号内。'
- en: 'Let''s move it a little further; consider the following parser:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步；考虑以下解析器：
- en: '[PRE43]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This parser accepts an integer string and returns the absolute value. You may
    figure out how it works with the previous knowledge. Note that even if the expression
    of PEG looks like a regular expression, they are different.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此解析器接受一个整数字符串并返回其绝对值。你可以利用之前的知识来理解它是如何工作的。请注意，尽管PEG的表达式看起来像正则表达式，但它们是不同的。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced you to the basic syntax in Opa programming, including
    datatypes, functions, records, tuples, lists, maps, patterns, and parsers. This
    is the basic knowledge that we should know to make a good Opa program. With the
    previous knowledge, we will see how to develop a web application in the next chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Opa编程语言的基本语法，包括数据类型、函数、记录、元组、列表、映射、模式和解析器。这是我们编写良好的Opa程序所应掌握的基本知识。在具备这些知识的基础上，我们将看到如何在下一章中开发一个网络应用程序。
