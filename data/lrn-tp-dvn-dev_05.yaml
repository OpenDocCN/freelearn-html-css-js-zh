- en: Putting Alternative Values in Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将替代值放入类型中
- en: In the previous chapter, we saw how to build values that capture multiple types
    of values together, and the different ways that we can build those types. This
    lets us say that we have a value of the composite (product) type only if we have
    *all* of the values of their composed types. Sometimes though, we need values
    that must be *only one* type out of several types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何构建捕获多种类型值的值，以及构建这些类型的不同方式。这使得我们可以说，只有当我们有它们组成类型的 *所有* 值时，我们才有复合（乘积）类型的值。有时，我们需要的值必须是几种类型中
    *仅一种* 类型。
- en: 'In this chapter, we will cover these *only one* types, namely:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍这些 *仅一种* 类型，即：
- en: Variant types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变体类型
- en: Polymorphic variant types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态变体类型
- en: Generalized algebraic data types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广义代数数据类型
- en: Collectively, these types are known as *sum types* because the number of possible
    values that a sum type can contain is the *sum* of the number of possible values
    of each of its component types. We'll see how this is true in this chapter!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型统称为 *求和类型*，因为求和类型可以包含的可能值的数量是它每个组成部分类型可能值的数量的 *总和*。我们将在本章中看到这一点是如何成立的！
- en: Variant types
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变体类型
- en: 'Variant types are Reason''s simple, idiomatic sum types. You can think of them
    as similar to enums (a limited set of values that are declared to form a type)
    from other languages, only more powerful because each *variant case* (possible
    alternative value) can optionally carry a payload inside it. Here''s an example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 变体类型是 Reason 的简单、惯用的求和类型。你可以把它们想象成类似于其他语言的枚举（一组声明为形成类型的有限值），但更强大，因为每个 *变体情况*（可能的替代值）都可以选择性地携带一个负载。以下是一个例子：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This module defines some types for storing someone''s education level and a
    payment method of either cash or purchase order:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块定义了一些类型，用于存储某人的教育水平和现金或采购订单的支付方式：
- en: Variant type definitions start with `type typeName =` just like any other type
    of definition, and have one or more *variant constructors* (also known as *data
    constructors*) on the right-hand side of the equals sign. These constructors all
    have the exact same type and can be used as literal values.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变体类型定义以 `type typeName =` 开头，就像任何其他类型的定义一样，并在等号右侧有一个或多个 *变体构造函数*（也称为 *数据构造函数*）。这些构造函数具有完全相同的类型，可以用作字面值。
- en: Variant constructors must start with an uppercase letter and can each carry
    any number of payloads, as defined within parentheses. This can be a comma-separated
    list of types that will make up the payload. Here we defined the `poNumber` type
    instead of just using `string` directly, to make the code more self-documenting.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变体构造函数必须以大写字母开头，并且可以携带任意数量的负载，正如括号内定义的那样。这可以是一个类型列表，用逗号分隔，这些类型将组成负载。在这里，我们定义了
    `poNumber` 类型，而不是直接使用 `string`，以便使代码更具自描述性。
- en: We can use variant cases directly as literal values. Now, `bobEducation` has
    the type `education`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以直接使用变体情况作为字面值。现在，`bobEducation` 的类型是 `education`。
- en: For variant constructors that carry payloads, we can pass them in as a comma-separated
    list between parentheses, a syntax that mirrors their definition.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于携带负载的变体构造函数，我们可以将它们作为逗号分隔的列表传递，括号内的语法反映了它们的定义。
- en: The first variant type, `education`, is a simple one that we can find in a lot
    of languages. It just defines an allowed set of values for a person's education.
    Of course, this may not be realistic in all scenarios, but sometimes we just need
    types to be realistic enough to model our problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变体类型 `education` 是一个简单的类型，我们可以在很多语言中找到它。它只是定义了一个人教育允许的值集。当然，在所有场景中这可能并不现实，但有时我们只需要类型足够现实，以模拟我们的问题。
- en: The next variant type, `paymentMethod`, is the really interesting one. It's
    saying that valid payment methods are cash or a purchase order with a PO number.
    Note that for cash we don't need any extra info, but for a purchase order we require
    its number; it's impossible to describe a PO with a corresponding number.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变体类型 `paymentMethod` 是真正有趣的一个。它表示有效的支付方式是现金或带有 PO 号的采购订单。注意，对于现金我们不需要任何额外信息，但对于采购订单，我们需要其号码；不可能用相应的号码来描述
    PO。
- en: 'Let''s think about this for a second. To represent a payment method in other
    languages, you might do something like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微思考一下。在其他语言中表示支付方式，你可能做如下操作：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice the problem? Nothing''s stopping us from creating objects with `type:
    ''PaymentMethod.Cash''` and a `poNumber` property, or even worse, `type: ''PaymentMethod.PurchaseOrder''`
    and no `poNumber` property. We''d have no static guarantees that purchase orders
    would always have an associated ID. Variant types give us this static guarantee.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到问题了吗？没有任何东西阻止我们创建具有`type: ''PaymentMethod.Cash''`和`poNumber`属性的对象，或者更糟糕的是，`type:
    ''PaymentMethod.PurchaseOrder''`但没有`poNumber`属性的`type: ''PaymentMethod.PurchaseOrder''`。我们无法保证采购订单总是有一个相关的ID。变体类型给我们提供了这个静态保证。'
- en: Pattern matching
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: We can construct variant values easily enough—just type in the variant constructors
    and give them any data they need. But variants really shine when we work with
    their values.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地构造变体值——只需输入变体构造函数并给出它们所需的数据。但当我们处理它们的值时，变体才真正发光。
- en: 'For example, suppose you want to write a function that returns a thank you
    message for any given payment. Part of the message will hinge on the payment method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想编写一个函数，该函数返回任何给定支付的感谢信息。信息的一部分将取决于支付方式：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will introduce some new syntax here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里引入一些新的语法：
- en: We use a **type equation** to tell the compiler that this variant type defined
    in this module is the same as the other variant type defined in `Ch05_Variants`,
    and crucially that its constructors are also exactly the same.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用**类型方程**来告诉编译器，在这个模块中定义的这个变体类型与在`Ch05_Variants`中定义的其他变体类型相同，并且关键的是它的构造函数也是完全相同的。
- en: We **pattern match** on the given payment method using Reason's `switch` expression,
    which can **destructure** data that can match against patterns.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Reason的`switch`表达式**模式匹配**给定的支付方式，该表达式可以**解构**可以与模式匹配的数据。
- en: We could have simply redefined the variant type in both modules; but variant
    types in Reason are nominal (that is, even the same variant type definition is
    considered a distinct type if it's in a different module) unless we use a type
    equation. In this simple example it's not critical that the compiler equates the
    two types, but sometimes in a Reason codebase, you'll want to *bring in* the variant
    constructors from another module for ease of access. Otherwise, you'll need to
    either open the other module (risky) or prefix the constructors with the modules
    (verbose), for example, `Ch05_Variants.Cash`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在两个模块中简单地重新定义变体类型；但在Reason中，变体类型是命名（即，即使相同的变体类型定义在不同的模块中，也会被视为不同的类型），除非我们使用类型方程。在这个简单的例子中，编译器将两个类型等同起来并不是关键，但有时在一个Reason代码库中，你可能希望为了方便访问而**引入**另一个模块中的变体构造函数。否则，你可能需要打开另一个模块（风险较大）或者在构造函数前加上模块名（冗长），例如，`Ch05_Variants.Cash`。
- en: The power of switch
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch`表达式的力量'
- en: In the previous section, we saw how to use the `switch` expression. But that
    barely scratched the surface of what `switch` can do. Switch expressions match
    against arbitrary patterns and evaluate the branch that corresponds to the *first*
    matching pattern.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用`switch`表达式。但那只是触及了`switch`能做的事情的表面。`switch`表达式可以匹配任意模式，并评估与**第一个**匹配模式对应的分支。
- en: 'Here''s a slightly more formal syntax for a switch expression:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`switch`表达式的稍微正式一点的语法：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This entire syntactic form evaluates to a single value. Each subsection of the
    expression that starts with a bar character (`|`) is called a **branch**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 整个语法形式评估为单个值。每个以竖线字符（`|`）开始的表达式子部分被称为**分支**。
- en: 'The steps for evaluating the expression are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 评估表达式的步骤如下：
- en: Evaluate `expr`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估`expr`。
- en: Match the  value of `expr` against `pat1`; if it matches, evaluate the entire
    expression to `res1` and ignore all the other branches.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`expr`的值与`pat1`匹配；如果匹配，将整个表达式评估为`res1`并忽略所有其他分支。
- en: Otherwise, continue matching the value against each pattern in turn, and evaluate
    to the first result that corresponds to the matching pattern.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，继续将值依次与每个模式匹配，并评估为与匹配模式对应的结果。
- en: If none of the patterns match, throw a runtime error (called an exception),
    `Match_failure`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有模式匹配，则抛出一个运行时错误（称为异常），`Match_failure`。
- en: Each branch of the expression must have the same return type for it to compile.
    Note that the order of the branches may or may not be important, depending on
    what kind of patterns we're matching. If we're matching against a variant type's
    exact cases, order is not important because variant cases naturally don't have
    any concept of *ordering*. That is, even if we defined `Cash` before `PurchaseOrder`
    in the `paymentMethod` type definition, that doesn't mean that `Cash` is intrinsically
    *less* than `PurchaseOrder`. There is no precedence.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的每一分支都必须具有相同的返回类型，才能编译成功。请注意，分支的顺序可能重要也可能不重要，这取决于我们正在匹配哪种模式。如果我们正在匹配一个变体类型的精确情况，顺序并不重要，因为变体情况自然没有任何*顺序*的概念。也就是说，即使我们在`paymentMethod`类型定义中将`Cash`定义在`PurchaseOrder`之前，这并不意味着`Cash`在本质上*小于*`PurchaseOrder`。这里没有优先级。
- en: However, patterns don't have to be variant cases. They can be any valid combination
    of names and literal values. In this context, a name is anything that is a valid
    Reason identifier, such as `age` or `_123`. Literal values include variant cases,
    but also values of basic types such as `char`, `string`, `int`, `float`, and so
    on; and also tuples and record values. If a pattern matches against the input
    expression, any names it contains get *bound* to the relevant parts of the expression
    and are made available in the scope of the result expression on the right-hand
    side of the `=>`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模式不必是变体情况。它们可以是任何有效的名称和字面值的组合。在这种情况下，一个名称是任何有效的Reason标识符，例如`age`或`_123`。字面值包括变体情况，但也包括基本类型如`char`、`string`、`int`、`float`等的值；以及元组和记录值。如果一个模式与输入表达式匹配，它包含的任何名称都会被*绑定*到表达式的相关部分，并在`=>`右侧的结果表达式的范围内可用。
- en: 'With name binding, literal values, and ordering, patterns can get quite sophisticated;
    let''s see a few examples:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称绑定、字面值和顺序，模式可以变得相当复杂；让我们看看几个例子：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are a few interesting things here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个有趣的地方：
- en: We're switching on an `int` ID, listing multiple alternative patterns on a single
    line, separated by bars. Patterns are in fact recursively defined; this means
    that patterns can contain more patterns! In other words, we can combine several
    individual patterns, such as `1`, `2`, and so on, with the vertical bar to indicate
    that any of these should match. This is called an **or pattern**. Note that the
    ordering of the patterns means that at runtime, the input ID will first be checked
    against the numbers 1 to 5, and only then with the other patterns. In this pattern
    match, the underscore symbol (`_`) means *anything, I don't care and don't bind
    the value*.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在根据一个`int` ID进行条件分支，在一行上列出多个替代模式，用竖线分隔。实际上，模式是递归定义的；这意味着模式可以包含更多的模式！换句话说，我们可以用竖线将几个单独的模式，如`1`、`2`等，组合起来，以表示这些模式中的任何一个都应该匹配。这被称为**或模式**。请注意，模式的顺序意味着在运行时，输入ID将首先与数字1到5进行比较，然后才会与其他模式进行比较。在这个模式匹配中，下划线符号（`_`）表示*任何东西，我不关心，也不绑定值*。
- en: Given a `person` value, we switch on its name and ID. We're actually switching
    on a single expression; the expression `(person.id, person.name)` is a tuple that
    we create on the spot and match against immediately. The really interesting thing
    here is the ordering of the patterns. We're expressing the logic that we always
    show a special message for Dave, and if it's not Dave and if it's someone with
    ID 1, we greet them as the boss, and only if it's not Dave or the boss, we greet
    the person by name and ID.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个`person`值，我们根据其名称和ID进行条件分支。实际上，我们是在对一个单一的表达式进行条件分支；表达式`(person.id, person.name)`是一个即时创建的元组，我们立即对其进行匹配。这里真正有趣的是模式的顺序。我们表达的是逻辑，即我们总是为Dave显示特殊消息，如果不是Dave，如果是ID为1的人，我们将其问候为老板，只有当不是Dave或老板时，我们才按名称和ID问候这个人。
- en: In `greet2`, we switch on the `person` directly using record literal patterns
    and express the same ordered logic as before, only this time we don't need to
    construct a temporary tuple since we know we can pattern match directly against
    records. There's not necessarily a performance benefit to this, but you may find
    the code slightly neater–it's subjective.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`greet2`中，我们直接使用记录字面模式对`person`进行条件分支，并表达与之前相同的有序逻辑，只是这次我们不需要构建一个临时元组，因为我们知道我们可以直接对记录进行模式匹配。这并不一定有性能上的好处，但你可能会觉得代码稍微整洁一些——这是主观的。
- en: 'Pattern matching can handle quite sophisticated data structures, because of
    the special property of patterns that they are *composable.* However, with this
    great power come two warnings: first, we need to understand the order in which
    we list the branches of our switch expressions so that we don''t get unexpected
    results; second, we need to avoid potential runtime errors arising from the use
    of refutable patterns.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配可以处理相当复杂的数据结构，因为模式具有特殊的组合属性。然而，有了这种强大的力量，也带来了两个警告：首先，我们需要理解我们列出 switch 表达式分支的顺序，以免得到意外结果；其次，我们需要避免使用可反驳模式可能引起的潜在运行时错误。
- en: Refutable patterns
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可反驳模式
- en: 'It''s important to understand that the `switch` expression is one form of pattern
    matching in Reason, out of three:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，`switch` 表达式是 Reason 中三种模式匹配中的一种：
- en: Switch expression
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Switch 表达式
- en: Let binding (see [Chapter 2](ff0971a6-9cf3-4680-8010-47acb7663764.xhtml), *Program
    with Types and Values*)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令绑定（见[第2章](ff0971a6-9cf3-4680-8010-47acb7663764.xhtml)，*使用类型和值编程*）
- en: Function arguments (we'll cover functions in a future chapter)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数（我们将在未来的章节中介绍函数）
- en: 'With all three forms of pattern matching, we run the risk of runtime errors
    if we use refutable patterns incorrectly. *Refutable patterns* are patterns that
    type-check, but could *potentially* fail at runtime. Here are a couple of simple
    examples:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三种模式匹配形式中，如果我们错误地使用可反驳模式，我们就会面临运行时错误的风险。*可反驳模式* 是可以类型检查，但可能在运行时*可能*失败的模式。这里有一些简单的例子：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Surprised by `let 3 = 3`? Remember that the left-hand side of the equals sign
    can be any pattern–even a single literal value! Also, let `PurchaseOrder(poNumber)
    = ...` is a destructuring of a variant case, not a function definition. The difference
    is the case of the first letter, `P`. Remember that Reason modules and data constructors
    start with an uppercase letter, while types and values start with a lowercase
    letter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `let 3 = 3` 感到惊讶吗？记住，等号左边的可以是任何模式——甚至是一个单一的文本值！此外，`PurchaseOrder(poNumber)
    = ...` 是一个变体情况的解构，而不是函数定义。区别在于第一个字母的大小写，`P`。记住，Reason 模块和数据构造函数以大写字母开头，而类型和值以小写字母开头。
- en: 'If you try the first binding, you''ll see the following warning:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试第一个绑定，你会看到以下警告：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It''s not really obvious what the problem is: the value being bound is literally
    3, it could never be 0, so how could we forget to handle it? The thing to realize
    is that the compiler looks only at the types–it sees that we used a refutable
    pattern of type `int`, and warns us about the simplest `int` that it knows we
    didn''t handle: `0`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 问题其实并不明显：被绑定的值实际上是 3，它永远不会是 0，所以我们怎么能忘记处理它呢？要意识到的是，编译器只看类型——它看到我们使用了类型为 `int`
    的可反驳模式，并警告我们关于它知道我们没有处理过的最简单的 `int`：`0`。
- en: 'If you try the second:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试第二个：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This time, it''s quite obvious: at runtime, the `getPoNumber` function could
    get called with the `Cash` value (because that type-checks!) but it doesn''t know
    how to handle it. There''s nothing it can do but throw a runtime error. The compiler
    figures this out in the same way as before, by looking at the `paymentMethod`
    type and looking for values of the type that it knows weren''t handled.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，很明显：在运行时，`getPoNumber` 函数可能会被带有 `Cash` 值的参数调用（因为那通过了类型检查！）但它不知道如何处理它。它除了抛出运行时错误外，别无他法。编译器就像以前一样，通过查看
    `paymentMethod` 类型并寻找它知道我们没有处理过的类型值来解决这个问题。
- en: This feature that checks if we handled all possible patterns of any given type
    is called **exhaustivity checking** and is one of the most powerful and useful
    features of Reason's type system. It's also present in a few languages that are
    either derived from the same ML (Meta Language) heritage as Reason or took inspiration
    from it. No matter what language, if you have exhaustivity checking at your disposal,
    try to use it as much as possible because it's a great safety net.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种检查我们是否处理了给定类型的所有可能模式的功能被称为**完备性检查**，并且是 Reason 类型系统中最强大和最有用的功能之一。它也存在于一些从与
    Reason 相同的 ML（元语言）遗产中衍生出来的语言，或者从中汲取了灵感。无论什么语言，如果你有完备性检查可用，尽量尽可能多地使用它，因为它是一个很好的安全网。
- en: The when clause and general branching
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当子句和一般分支
- en: 'Not only do switch expressions pattern match on their inputs, but they can
    also add a general test condition called a `when` **clause** to the end of each
    pattern. This lets you check completely general conditions in each branch to match
    against that branch. Note that using a `when` clause does give up exhaustivity
    checking, though, so before reaching for it, think about if you can do without.
    Sometimes, you just can''t. For example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅开关表达式可以在它们的输入上进行模式匹配，而且它们还可以在每个模式的末尾添加一个称为 `when` **子句** 的一般测试条件。这让你可以在每个分支中检查完全通用的条件以匹配该分支。请注意，使用
    `when` 子句确实会放弃详尽性检查，所以在伸手去拿它之前，考虑一下你是否可以不这么做。有时候，你真的不能。例如：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code sample shows a scenario for using a `when` clause:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例展示了使用 `when` 子句的场景：
- en: We redefine the types we need and equate them for interoperability. Strictly
    speaking, in this case, we didn't need to do that. But in most real-world code,
    you would.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重新定义了我们需要的类型并将它们等价起来以实现互操作性。严格来说，在这种情况下，我们不需要这么做。但在大多数现实世界的代码中，你确实需要这么做。
- en: We add a `when` clause to the `PurchaseOrder(poNumber)` base pattern to check
    that the PO number starts with the word ACME. This is something we can't do with
    pattern matching because we can't match against parts of strings.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `PurchaseOrder(poNumber)` 基本模式中添加了一个 `when` 子句来检查 PO 号码是否以单词 ACME 开头。这是我们不能通过模式匹配来完成的事情，因为我们不能匹配字符串的部分。
- en: We also evaluate the branch to a `Some(poNumber)`. `Some` is a built-in data
    constructor that expresses the idea that *there is a value here (as opposed to
    no value)*. It actually accepts *any* type, not just a `string`, and we'll see
    how that works in the next chapter.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将分支评估为 `Some(poNumber)`。`Some` 是一个内置的数据构造函数，它表达了*这里有一个值（与没有值相对)*的概念。它实际上接受*任何*类型，而不仅仅是
    `string`，我们将在下一章中看到它是如何工作的。
- en: The case where the PO number doesn't start with the word ACME evaluates to `None`,
    which is the same type as `Some(whatever)`, but it expresses the idea that *there's
    no value here*. The type of `Some(whatever)` and `None` is a variant type `option(whateverType)`,
    and it's very useful for safely passing around values that might not logically
    exist. In this case, it's useful for our function `getAcmeOrder` because, given
    any payment method at runtime, it might not actually contain an ACME purchase
    order, so we need a way to say *it's not an ACME PO*, and `None` gives us that.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 PO 号码不以单词 ACME 开头时，其结果为 `None`，这与 `Some(whatever)` 的类型相同，但它表达了*这里没有值*的概念。`Some(whatever)`
    和 `None` 的类型是一种变体类型 `option(whateverType)`，它对于安全地传递可能逻辑上不存在的值非常有用。在这种情况下，它对我们函数
    `getAcmeOrder` 很有用，因为，在运行时给定任何支付方式，它可能实际上不包含 ACME 购买订单，因此我们需要一种方式来说明*这不是一个 ACME
    PO*，而 `None` 就提供了这种可能性。
- en: Reason also has a traditional `if`-`else` syntax, which is also an expression
    and evaluates to a value. Both the `if` and `else` branches must evaluate to values
    of the same type; if we leave out the `else` branch, it's assumed to evaluate
    to `()` of type `unit`. In Reason, `()`—pronounced *unit*—roughly means the same
    thing that `void` means in C, C++, and so on, except that it's an actual assignable
    value and it can come in handy sometimes. In the case of `if` expressions, concretely
    this means that we should either include an `else` clause or ensure that the `if`
    clause evaluates to type `unit`. Typically, this happens with functions that carry
    out an action and don't evaluate to a useful value, for example, `Js.log("Hello")`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reason 还有一个传统的 `if`-`else` 语法，它也是一个表达式，并返回一个值。`if` 和 `else` 分支都必须返回相同类型的值；如果我们省略了
    `else` 分支，它将被假定为返回类型为 `unit` 的 `()`。在 Reason 中，`()`——发音为 *unit*——大致意味着与 C、C++
    等语言中的 `void` 相同的意思，只不过它是一个实际可赋值的值，有时可能会派上用场。在 `if` 表达式的情况下，具体来说，这意味着我们应该包含一个 `else`
    子句，或者确保 `if` 子句返回类型为 `unit`。通常，这发生在执行操作但不返回有用值的函数中，例如，`Js.log("Hello")`。
- en: So far in this book, we've seen a couple of types that look like `typeName(typeParam)`,
    but we haven't delved into what they are or how they work. In the next chapter,
    we'll learn about parameterized types and how they can help write safe, reusable
    code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们看到了一些看起来像 `typeName(typeParam)` 的类型，但我们还没有深入研究它们是什么或它们是如何工作的。在下一章中，我们将学习参数化类型以及它们如何帮助我们编写安全、可重用的代码。
- en: Stricter safety checks
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格的安全检查
- en: 'It''s worth digressing a bit to the compiler''s exhaustivity check warning.
    As you''ll recall, it looks as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 值得稍微偏离一下，谈谈编译器的详尽性检查警告。正如你将记得的，它看起来如下：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The problem with a compile warning is that it doesn't fail the compile. We can
    end up with code running in production that type-checked, but is not actually
    type-safe, because it forgot to handle some corner case. It would really be ideal
    if we could tell the compiler to fail the compile if it finds any non-exhaustive
    patterns, so we can rule out shipping them to production.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 编译警告的问题在于它不会导致编译失败。我们最终可能会在生产环境中运行经过类型检查但实际不安全的代码，因为它忘记处理一些边缘情况。如果编译器在发现任何非穷举模式时能够停止编译，那就真的理想了，这样我们就可以排除将它们部署到生产环境中。
- en: 'Fortunately, we can tell the compiler to *promote* a warning to an error. In
    our case, since we''re using a BuckleScript project, we can edit the `bsconfig.json`
    file slightly:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以告诉编译器将警告提升为错误。在我们的情况下，因为我们使用的是BuckleScript项目，我们可以稍微编辑一下`bsconfig.json`文件：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After editing the file, we can restart `bsb -w` to have the new setting take
    effect. The `"warnings"` property contains an object with potentially a couple
    of properties, one of which is an `"error"` property that has a corresponding
    string value listing the warning numbers that we want to promote into errors with
    the `"+NUM"` syntax. We can get the exact number from the compiler warning message
    (see preceding snippet).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑完文件后，我们可以重新启动`bsb -w`以使新设置生效。`"warnings"`属性包含一个对象，可能包含几个属性，其中之一是具有对应字符串值的`"error"`属性，该字符串值列出了我们想要提升为错误的警告编号，使用`"+NUM"`语法。我们可以从编译器警告消息中获取确切的编号（见前面的片段）。
- en: 'Now, this same warning will fail the compile:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个相同的警告将导致编译失败：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now the compiler will stop the compiling when it encounters a *fatal warning* and
    we can enjoy safer pattern matching.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器在遇到*致命警告*时会停止编译，我们可以享受更安全的模式匹配。
- en: Polymorphic variant types
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态变体类型
- en: 'While Reason''s variant types are conceptually simple, much of their power
    comes from the ability to use them with pattern matching and exhaustivity checking.
    Reason also provides a more powerful, but also more complex sum type, called **polymorphic
    variants***.* As the name suggests, these variants are more flexible than regular
    variants. Here are a few things that we can do with polymorphic variants, but
    not with regular variants:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Reason的变体类型在概念上很简单，但它们的大部分功能来自于能够与模式匹配和穷举检查一起使用。Reason还提供了一个更强大但更复杂的求和类型，称为**多态变体**。正如其名所示，这些变体比常规变体更灵活。以下是一些我们可以使用多态变体做，但不能使用常规变体的事情：
- en: Create values without defining the types beforehand, letting the compiler infer
    the type
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义类型之前创建值，让编译器推断类型
- en: Compose multiple sets of variant cases together
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多组变体情况组合在一起
- en: Define functions that handle *at least* a set of variant cases as input
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义处理至少一组变体情况作为输入的函数
- en: Define functions that output *at most* a set of variant cases as output
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义输出最多一组变体情况的函数
- en: In a sense, we can think of polymorphic variants as being related to regular
    variants in the same way that objects are related to records. They are, in fact,
    structural types in the same way that objects and modules are because the compiler
    infers the types of values by inspecting their structures.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我们可以将多态变体视为与常规变体相关，就像对象与记录相关一样。实际上，它们是结构化类型，就像对象和模块一样，因为编译器通过检查它们的结构来推断值的类型。
- en: Creating and typing values
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和类型化值
- en: 'Let''s see a few examples to get a feel for how polymorphic variants work:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个例子，以了解多态变体是如何工作的：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There''s a lot of new syntaxes here, but hopefully it should look somewhat
    similar to regular variant syntax:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多新的语法，但希望它们看起来与常规变体语法有些相似：
- en: We can define an adhoc polymorphic variant value and let the compiler figure
    out its type. In this case, the editor support should show us a type ``[> `Red]``.
    This means a polymorphic variant type that has at least the `` `Red `` data constructor
    that I've seen, and possibly more. The brackets (`[...]`) around the type syntactically
    distinguish it from regular variants and also suggest that we should think of
    it as like a bounded set.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以定义一个专用的多态变体值，并让编译器确定其类型。在这种情况下，编辑器支持应该显示给我们一个类型`[> `Red]`。这意味着至少包含我看到的`
    `Red ``数据构造函数的多态变体类型，可能还有更多。类型周围的括号（`[...]`）在语法上将其与常规变体区分开来，并暗示我们应该将其视为类似有界集的东西。
- en: Polymorphic variant constructors can contain payloads just like regular variant
    constructors. Also, unlike regular constructors, polymorphic constructors can
    start with a lowercase letter. This is still unambiguous though because polymorphic
    variant constructors must always be prefixed with a back-tick character.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态变体构造函数可以包含有效载荷，就像常规变体构造函数一样。此外，与常规构造函数不同，多态构造函数可以以小写字母开头。尽管如此，这仍然是不明确的，因为多态变体构造函数必须始终以反引号字符作为前缀。
- en: We can explicitly define polymorphic variant types using the syntax shown. Note
    that the compiler doesn't automatically infer any later values that use the defined
    constructors as being of the defined type. I'll explain this a bit more in the
    *fifth* point.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用显示的语法显式定义多态变体类型。请注意，编译器不会自动推断使用定义的构造函数作为后续值的定义类型。我将在第五点中对此进行更多解释。
- en: Polymorphic variant types can compose other polymorphic variant types and become
    an expanded set of cases. This lets us model cases that can be considered part
    of the set (type), but can also be considered separately, for example, device
    input events.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态变体类型可以组合其他多态变体类型，并成为一个更广泛的案例集。这让我们可以模拟那些可以被认为是集合（类型）一部分的案例，但也可以单独考虑，例如设备输入事件。
- en: We must explicitly annotate a value with a polymorphic variant type to tell
    the compiler that it must be *exactly* this type. Without this annotation, within
    the module the compiler will infer the type from the structure of the data constructor,
    that is, in this case ``[> `keypress(char)]``. Note that declaring the exact types
    of the polymorphic variant values in module signatures will work, but only from
    the point of view of other modules, not internally within the module. Usually,
    that's good enough!
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须显式地用多态变体类型注释一个值，以告诉编译器它必须是*正好*这个类型。没有这个注释，在模块内部编译器将根据数据构造函数的结构推断类型，即在这种情况下是`[>
    `keypress(char)]`。请注意，在模块签名中声明多态变体值的精确类型将有效，但仅从其他模块的角度来看，而不是在模块内部。通常，这已经足够了！
- en: 'We can''t declare that a polymorphic variant constructor has some type if that
    type doesn''t actually declare the constructor first. Here''s what the error would
    look like:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该类型没有首先声明构造函数，我们无法声明一个多态变体构造函数具有某种类型。以下是错误可能的样子：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can visualize the error as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样可视化错误：
- en: '![](img/d205b705-478c-4df8-8136-cd6a8659f9aa.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d205b705-478c-4df8-8136-cd6a8659f9aa.png)'
- en: Polymorphic variant type mismatch
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 多态变体类型不匹配
- en: Inputting values into functions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向函数中输入值
- en: 'Now that we can create polymorphic variant values, let''s do something useful
    with them. How can we handle a value that we get at runtime? It turns out, the
    same way we''d handle a normal variant: pattern matching:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以创建多态变体值，让我们用它们做一些有用的事情。我们如何处理在运行时得到的值？结果证明，我们可以像处理正常变体一样处理它：模式匹配：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can pattern match on an input polymorphic variant data constructor the same
    way we''d match against a regular constructor: by writing out the constructor
    as a pattern and binding any of its contained data that we want to use.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以对输入的多态变体数据构造函数进行模式匹配，就像我们对常规构造函数进行匹配一样：通过将构造函数作为模式写出来，并绑定我们想要使用的任何包含的数据。
- en: 'We use a BuckleScript-specific string interpolation syntax for convenience
    here: `{j| ... $name ... |j}`. The `name` must be in scope, and it must be only
    a name, not an arbitrary expression such as `1 + 2`. The `{j|` and `|j}` act as
    string delimiters and can be used for multiline and Unicode string literals as
    well.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里使用BuckleScript特定的字符串插值语法以提高便利性：`{j| ... $name ... |j}`。`name`必须在作用域内，并且它只能是一个名称，不能是像`1
    + 2`这样的任意表达式。`{j|`和`|j`作为字符串分隔符，也可以用于多行和Unicode字符串字面量。
- en: We can call the function with any value that conforms to its inferred input
    type, which `pressA` does because we made sure both its type and our new function
    have the same polymorphic variant cases.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用符合其推断输入类型的任何值来调用该函数，`pressA`就是这样做的，因为我们确保了它的类型和我们的新函数具有相同的多态变体情况。
- en: We can as usual pattern match directly with a `let`-binding, but notice that
    there's no exhaustivity warning here. The compiler now doesn't know what other
    cases there might be, so it doesn't warn us. For this reason, it's best to avoid
    let-binding pattern matching of polymorphic variant values.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像往常一样直接使用`let`绑定进行模式匹配，但请注意，这里没有完全性警告。编译器现在不知道可能存在其他情况，因此它不会警告我们。因此，最好避免对多态变体值进行`let`绑定模式匹配。
- en: Understanding polymorphic variant inference
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多态变体推断
- en: 'If you have type hinting enabled in your editor, it should tell you that the
    type of `eventToString` is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在你的编辑器中启用了类型提示，它应该告诉你 `eventToString` 的类型如下：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The compiler alphabetizes the variant cases when printing them out, but just
    like with regular variants, the cases don't have any intrinsic ordering.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在打印变体情况时按字母顺序排列它们，但就像常规变体一样，情况没有任何内在的顺序。
- en: 'This function type is divided into two main parts: the input on the left of
    the arrow, and the output on the right. The input is a polymorphic variant type
    that can contain any of the listed cases or less, and these cases can have payloads
    in the given positions. Notice that the payloads all have types that look like
    `''x`, that is, starting with an apostrophe character. As we mentioned before,
    this character means that this type will be filled in later. Specifically, it''s
    known as a type parameter.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数类型分为两个主要部分：箭头左边的输入，和箭头右边的输出。输入是一个多态变体类型，它可以包含列出的任何情况或更少的情况，并且这些情况可以在给定位置有负载。注意，所有负载的类型看起来像
    `'x'`，即以撇号字符开头。正如我们之前提到的，这个字符意味着这个类型将在以后填充。具体来说，它被称为类型参数。
- en: The most important thing to understand about this inferred function type is
    that the input polymorphic variant is given an upper bound (`<`), meaning this
    function can handle a polymorphic variant type that has these cases, and also
    polymorphic variant types that have a *subset* of these cases, but it certainly
    can't handle any *more* cases.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个推断函数类型最重要的理解是，输入的多态变体被赋予一个上界（`<`），这意味着这个函数可以处理具有这些情况的变体多态变体类型，以及具有这些情况的子集的多态变体类型，但它肯定不能处理
    *更多* 的情况。
- en: Now, let's tackle the reason why all the payload types are going to be filled
    in later. We already know that they're just ints and floats. Why couldn't the
    compiler figure that out?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨为什么所有负载类型都将稍后填充的原因。我们已经知道它们只是 int 和 float。为什么编译器不能推断出来？
- en: It turns out that when we used the payloads in BuckleScript's special string
    interpolation syntax sugar, the compiler was never told what their exact types
    were. String interpolation just lets us stuff anything in a JavaScript string,
    without having to be specific to the compiler as we usually would, for example,
    with a string concatenation such as `"Hello" ++ " world"`. This is very convenient
    for producing output, but can lead to pitfalls where the compiler can't infer
    a type; so it's good to be aware of this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，当我们使用 BuckleScript 的特殊字符串插值语法糖中的负载时，编译器从未被告知它们的确切类型。字符串插值只是让我们可以在 JavaScript
    字符串中放入任何东西，而不需要像我们通常做的那样对编译器具体化，例如，使用字符串连接如 `"Hello" ++ " world"`。这对于生成输出非常方便，但可能导致陷阱，因为编译器无法推断类型；因此，了解这一点是好的。
- en: 'Overall, notice the important safety property we achieve that''s very similar
    to the type safety of objects: we can (to a certain extent) use adhoc variant
    constructors safely with the compiler''s help.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，请注意我们实现的重要安全属性，这与对象的类型安全非常相似：我们可以在一定程度上安全地使用 adhoc 变体构造函数，并借助编译器的帮助。
- en: Outputting values from functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从函数中输出值
- en: 'What if we want to go in the opposite direction? That is, output polymorphic
    variant values from functions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想反方向操作呢？也就是说，从函数中输出多态变体值：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This time, two interesting things happen:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，发生了两件有趣的事情：
- en: The compiler does exhaustivity checking on the input, which is a string, so
    we need to handle *all* possible string inputs (the last one is the catch-all)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器对输入进行穷举检查，输入是一个字符串，因此我们需要处理 *所有* 可能的字符串输入（最后一个是一个通配符）
- en: 'The compiler swaps the polymorphic variant type''s bound, making the type (of
    the function):'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器交换多态变体类型的界限，使得函数的类型（为）：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This time, the compiler infers a *lower bound* for the polymorphic variant return
    type, because it seems that the function returns those cases and it may potentially
    return more, but it will certainly never return *fewer* cases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，编译器为多态变体返回类型推断出一个 *下界*，因为它似乎函数返回这些情况，并且它可能还会返回更多，但它肯定永远不会返回 *更少* 的情况。
- en: Polymorphic variant types are a deep and powerful part of Reason, and we'll
    explore them a bit more in the coming chapters.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 多态变体类型是 Reason 的一个深奥而强大的部分，我们将在接下来的章节中更深入地探讨它们。
- en: Generalized algebraic data types
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛化代数数据类型
- en: '**Generalized algebraic data types** (**GADTs**) are another deep and powerful
    area of the language. As with polymorphic variant types, much of their true power
    is exposed when they''re used with type parameters. But we can understand their
    surface syntax and how they relate to regular variant types, for now.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛化代数数据类型**（**GADTs**）是语言中另一个深奥而强大的领域。与多态变体类型一样，它们的大部分真正力量是在使用类型参数时展现出来的。但我们可以理解它们的表面语法以及它们与常规变体类型的关系，至少目前是这样。'
- en: 'GADTs are, as the name suggests, a generalized form of algebraic data types.
    The name is a slight misnomer because they are really more of a generalized form
    of regular variant types only. *Algebraic data types* is a general name for both
    product and sum types taken together. Syntactically, GADTs look as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: GADTs，正如其名称所暗示的，是代数数据类型的一种泛化形式。这个名称有一点误导性，因为它们实际上是常规变体类型泛化形式的一种。代数数据类型是一个总称，包括产品类型和求和类型。在语法上，GADTs
    看起来如下：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: GADT definition syntax looks much like regular variant definition syntax, except
    that the data constructors explicitly declare their type at the end. For monomorphic
    types (that is, ones that don't have any type parameters), this doesn't look very
    useful. In the next chapter, we'll see why it's so powerful.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GADT 定义语法看起来与常规变体定义语法非常相似，不同之处在于数据构造函数在末尾明确声明了它们的类型。对于单态类型（即没有类型参数的类型），这看起来不太有用。在下一章中，我们将看到为什么它如此强大。
- en: Value construction looks the same as for regular variants.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值构造看起来与常规变体相同。
- en: Pattern matching also looks the same as for regular variants.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模式匹配看起来与常规变体相同。
- en: Designing for correctness with types
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型进行正确性设计
- en: Now that we've seen the product and sum types in action, let's take a step back
    and ask how they can work together. Intuitively, product types let us group values
    together, and sum types let us choose one among a restricted set of values. Together,
    they express a wide range of data modeling scenarios. Let's look at a couple of
    examples.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了产品类型和求和类型在实际中的应用，让我们退一步思考它们如何协同工作。直观上，产品类型让我们可以将值组合在一起，而求和类型让我们可以从一个受限的值集中选择一个。结合起来，它们可以表达广泛的数据建模场景。让我们看看几个例子。
- en: Products and sums together
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品和求和类型一起
- en: 'First, a simple example to warm up. Suppose we''re asked to track the following
    attributes of a person for a Customer Relationship Management software:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个简单的例子来热身。假设我们被要求为一个客户关系管理软件跟踪以下人员的属性：
- en: 'ID number: A string'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份证号：一个字符串
- en: 'Name: A string'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名：一个字符串
- en: 'Education level: O*ne of* school, college, postgrad, or other'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教育水平：学校、学院、研究生或其他之一
- en: 'A valid person record must have *all of* these attributes. Notice how we''re
    using the specific phrasing *one of* and *all of*. These give us a hint about
    how to model the data: *one of* means a sum type and *all of* means a product
    type! It''s very useful to think about the requirements in these terms as we break
    down a data structure into its component parts.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的人员记录必须具有所有这些属性。注意我们如何使用特定的措辞“之一”和“所有”。这些给我们提供了关于如何建模数据的线索：“之一”意味着求和类型，“所有”意味着产品类型！在我们将数据结构分解为其组成部分时，以这些术语来考虑需求是非常有用的。
- en: 'The main choice after that is specifically which implementations of product
    and sum types to use. Usually, we''ll reach for the simplest possible implementations:
    records and variants. So, in this case:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此后的主要选择是具体使用哪种产品类型和求和类型的实现。通常，我们会选择最简单的可能实现：记录和变体。因此，在这种情况下：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The person record type `Ch05_CrmPerson.t` is a record type composed out of
    three other types: an `int`, a `string`, *and* an `education`. The `education`
    type is a variant type that admits *one of* the four legal education values.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人员记录类型 `Ch05_CrmPerson.t` 是由三种其他类型组成的记录类型：一个 `int`、一个 `string` 和一个 `education`。`education`
    类型是一个变体类型，接受四种合法教育值中的任何一个。
- en: The valid `t` values are built by grouping together all the required component
    values, including the `education` values.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有效的 `t` 值是通过将所有必需的组件值组合在一起构建的，包括 `education` 值。
- en: 'Notice how the values are constructed by obeying the business logic laid out
    by the types: for a person record, we need an ID, a name, and an education; for
    an education value, we need only one of the allowable values.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意值是如何通过遵守类型所规定的业务逻辑来构建的：对于一个人员记录，我们需要一个 ID、一个姓名和一个教育背景；对于一个教育值，我们只需要允许的值之一。
- en: Recursive types
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归类型
- en: Now, let's look at a more interesting example. Suppose we need to model not
    just one, but a *list* of person records. Suppose we also need to be able to walk
    through this list, one person at a time, and carry out some actions based on the
    data from each person. A natural data structure for this would be a *singly linked
    list.* As you might know, a singly linked list is a series of nodes that each
    point to the next node in the list, or to *nothing* in case there is no next node
    (that is, for the last node of the list).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个更有趣的例子。假设我们需要模拟的不是一个人，而是一个*人记录列表*。假设我们还需要能够逐个遍历这个列表，并对每个记录的数据执行一些操作。这种情况下，一个自然的数据结构是*单链表*。正如你可能知道的，单链表是一系列节点，每个节点都指向列表中的下一个节点，或者在没有下一个节点的情况下指向*空值*（即列表的最后一个节点）。
- en: 'In Reason, a natural way to model this list is with a recursive variant type.
    A *recursive type* is one that contains values of its *own* type. This neat trick
    works because Reason internally separates the storage of values from their types,
    so they don''t end up taking infinite storage. Here''s an example implementation
    of our person record list scenario:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reason中，模拟这个列表的自然方式是使用递归变体类型。*递归类型*是包含其自身类型值的类型。这个巧妙的方法之所以有效，是因为Reason内部将值的存储与其类型分开，因此它们不会最终占用无限存储。以下是我们的人记录列表场景的一个示例实现：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using a recursive type reveals some new and interesting syntax:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归类型可以揭示一些新颖且有趣的语法：
- en: 'The type definition of a recursive type doesn''t look any different from what
    we saw before, except that it contains a reference to its own type. We''re not
    having to do anything special because, in Reason, all type definitions are recursive
    by default. In fact, if we want to make a type definition *non-recursive* (which
    we do in some circumstances), we''ll need to use an extra keyword: `type nonrec
    t = ...`.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归类型的类型定义看起来与我们之前看到的没有不同，只不过它包含对其自身类型的引用。在Reason中，我们不需要做任何特别的事情，因为所有类型定义默认都是递归的。事实上，如果我们想使类型定义*非递归*（在某些情况下我们确实这样做），我们需要使用一个额外的关键字：`type
    nonrec t = ...`。
- en: We can define a value of a recursive type like normal, except it can contain
    other values of its own type. We locally open the `Ch05_CrmPerson` module to get
    access to the people values defined there.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像定义普通类型一样定义递归类型的值，只不过它可以包含其自身类型的其他值。我们局部打开`Ch05_CrmPerson`模块以获取对那里定义的人的值的访问权限。
- en: To walk through all the values of a recursive type, we'll usually need a *recursive
    function* (that is, a function that calls itself). Unlike types, functions aren't
    recursive by default, because traditionally recursive functions are slightly more
    expensive in terms of runtime performance. So when we need recursion, we specify
    it with the `let rec ...` syntax.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要遍历递归类型的所有值，我们通常需要一个*递归函数*（即调用自己的函数）。与类型不同，函数默认不是递归的，因为传统上递归函数在运行时性能方面稍微昂贵一些。因此，当我们需要递归时，我们使用`let
    rec ...`语法来指定它。
- en: We can destructure a recursive value in the normal way, just as if it were non-recursive;
    we just need to make sure we pass its recursive portion, `list`, into the recursive
    `greet` call.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像处理非递归值一样解构递归值，只需确保我们将它的递归部分`list`传递给递归的`greet`调用。
- en: To handle the non-recursive portion of `Ch05_PersonList.t` (`Empty`), we just
    need to *do nothing*, so we return unit, the *empty value*.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理`Ch05_PersonList.t`（`Empty`）的非递归部分，我们只需*不做任何事情*，因此我们返回unit，即*空值*。
- en: 'Our recursive `greet` function has an interesting property: it is tail-recursive.
    *Tail recursion* is the property that a recursive function has if it calls itself
    in tail position, that is, if it calls itself as the last (tail) operation of
    any of its branches of evaluation. For example, `greet` calls itself as the last
    operation of its first branch, where it handles the `Node` variant case.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的递归`greet`函数有一个有趣的属性：它是尾递归的。*尾递归*是递归函数具有的属性，如果它在尾位置调用自己，即如果它在任何评估分支的最后一个（尾）操作中调用自己。例如，`greet`在其第一个分支中作为最后一个操作调用自己，处理`Node`变体情况。
- en: We're paying attention to this tail recursion property because the BuckleScript
    compiler has a special ability to convert tail recursion into a simple, efficient
    loop in the output JavaScript. If you examine the output, you'll see that the
    loop looks almost handwritten.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注这个尾递归属性，因为BuckleScript编译器具有将尾递归转换为输出JavaScript中的简单、高效循环的特殊能力。如果你检查输出，你会看到循环看起来几乎像是手写的。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered what collectively are known as sum types: variants
    and pattern matching, polymorphic variants, and GADTs. These are some of the bread-and-butter
    typing techniques in Reason, and they enable powerful data modeling techniques
    when used in the right combinations.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了被称为求和类型（sum types）的总称：变体和模式匹配、多态变体以及GADTs。这些是Reason中一些基本的类型技术，当正确组合使用时，它们能够实现强大的数据建模技术。
- en: However, it's becoming increasingly clear that a lot of typing power still remains
    to be explored. In the next chapter, we will fully cover the type parameters (generics)
    that we've glimpsed at so far while using different kinds of type techniques.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，越来越明显的是，还有很多类型的力量有待探索。在下一章中，我们将全面介绍到目前为止我们只是瞥见过的类型参数（泛型），以及使用不同类型的技巧。
