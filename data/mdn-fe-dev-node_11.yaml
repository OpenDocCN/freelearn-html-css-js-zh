- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Using Alternative Runtimes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用替代运行时
- en: So far, you’ve seen what advantages and benefits the Node.js ecosystem offers
    to create great web applications. However, as with almost everything, there are
    a few downsides to the design decisions forming what we refer to as Node.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了Node.js生态系统为创建优秀的Web应用提供了哪些优势和好处。然而，与几乎所有事情一样，构成我们所说的Node.js的设计决策也有一些缺点。
- en: One of the biggest challenges in Node.js is the so-called *dependency hell*
    – where many small packages are put together to create a slightly larger package.
    Another challenge is that Node.js is not guarding any of these dependencies from
    accessing system resources. As such, importing anything from a third-party package
    may have unwanted side effects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中最大的挑战之一是所谓的*依赖地狱*——将许多小包组合起来创建一个稍微大一点的包。另一个挑战是Node.js没有保护这些依赖免于访问系统资源。因此，从第三方包导入任何内容都可能产生不希望出现的副作用。
- en: While ecosystem reliability and security can help us guard against dependency
    hell, improving performance is also an important strategy. Overall, the performance
    of Node.js can be regarded as decent; however, certain areas such as package resolution
    or processor core utilization could be improved by a fair share. Hence, performance
    is another area that could be regarded as a downside.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然生态系统可靠性和安全性可以帮助我们抵御依赖地狱，但提高性能也是一个重要的策略。总体而言，Node.js的性能可以被认为是相当不错的；然而，某些领域，如包解析或处理器核心利用率，可以通过相当大的份额得到改善。因此，性能也是一个可能被视为缺点的地方。
- en: In this chapter, you’ll get to know the two most popular alternative runtimes
    for mitigating some of the disadvantages that come with Node.js. To evaluate these
    alternatives in depth, we will keep a closer eye on their compatibility status
    with the existing Node.js ecosystem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解两种最流行的替代运行时，以减轻Node.js带来的某些缺点。为了深入评估这些替代方案，我们将密切关注它们与现有Node.js生态系统的兼容性状态。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下关键主题：
- en: Exploring the Deno runtime
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Deno运行时
- en: Using Bun for bundling web apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bun进行Web应用捆绑
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter11](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter11).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可在[https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter11](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter11)找到。
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3Uqi9aq](https://bit.ly/3Uqi9aq).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可通过[https://bit.ly/3Uqi9aq](https://bit.ly/3Uqi9aq)访问。
- en: Exploring the Deno runtime
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Deno运行时
- en: While Node.js is a tremendous success story, not everyone is a fan. Some critics
    say that the huge fragmentation combined with the lack of system controls offers
    too great an attack surface. In the past, we’ve seen countless attacks that have
    abused the vulnerabilities introduced by exactly this problem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Node.js是一个巨大的成功故事，但并非所有人都喜欢它。一些批评者表示，巨大的碎片化加上缺乏系统控制提供了太大的攻击面。在过去，我们看到了无数利用这个问题的漏洞进行的攻击。
- en: Another issue is that Node.js did have to invent a lot of APIs – for example,
    to interact with the filesystem. There was no API available in the browser that
    looked similar to what was desired. Of course, as we now know, the browser APIs
    kept improving and even things such as filesystem access are implemented there.
    However, the APIs never aligned, mostly because the variants for Node.js are neither
    controllable nor fully asynchronous.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题在于，Node.js确实不得不发明了许多API——例如，用于与文件系统交互。浏览器中没有可用的API与期望的类似。当然，正如我们现在所知，浏览器API一直在改进，甚至文件系统访问等功能也被实现。然而，API从未对齐，这主要是因为Node.js的变体既不可控也不是完全异步的。
- en: Surely, the aforementioned problems were all known for a while, but it took
    several years until an alternative implementation to solve these issues appeared.
    Again, it was Ryan Dahl – the original creator of Node.js – who worked on the
    solution. The solution is called **Deno**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，上述问题在一段时间内都是众所周知的，但直到几年后，才出现了替代实现来解决这些问题。再次，是Ryan Dahl——Node.js的原始创造者——致力于解决这个问题。这个解决方案被称为**Deno**。
- en: 'The main benefits of Deno are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Deno的主要好处如下：
- en: It introduces system access controls to allow or block access to resources such
    as the filesystem.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它引入了系统访问控制，以允许或阻止对资源（如文件系统）的访问。
- en: It uses explicit imports instead of magically resolved ones – no more implied
    package lookups or index files.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用显式导入而不是神奇解析的导入——不再有隐含的包查找或索引文件。
- en: It tries to be interchangeable with the browser – bringing exclusively native
    browser APIs instead of custom ones.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它试图与浏览器互换——仅提供原生浏览器 API 而不是自定义 API。
- en: It features first-class TypeScript support, not only improving the development
    experience but also strengthening the reliability of written code.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一等 TypeScript 支持，不仅改善了开发体验，还增强了代码的可靠性。
- en: It comes with handy tooling, such as an application bundler out of the box –
    reducing the need to install dependencies for starting development.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自带了一些实用的工具，例如应用程序打包器，无需安装依赖项即可开始开发。
- en: Under the hood, Deno uses the Rust programming language instead of C++. Here,
    the choice was made to avoid any potential memory leaks or vulnerabilities that
    are just a bit more likely with C++ than **Rust**. This also means that *libuv*,
    which is the main driver for Node.js as discussed in [*Chapter 1*](B18989_01.xhtml#_idTextAnchor015),
    *Learning about the Internals of Node.js*, is gone. Instead, Deno uses another
    event loop system called **Tokio**. Still, both runtimes use **V8** to actually
    run JavaScript.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Deno 使用 Rust 编程语言而不是 C++。在这里，选择 Rust 是为了避免任何潜在的内存泄漏或漏洞，这些漏洞在 C++ 中比 Rust
    更可能发生。这也意味着 *libuv*，正如在 [*第 1 章*](B18989_01.xhtml#_idTextAnchor015) “了解 Node.js
    的内部结构” 中讨论的，作为 Node.js 的主要驱动程序已经不复存在。相反，Deno 使用另一个名为 **Tokio** 的事件循环系统。尽管如此，这两个运行时实际上都使用
    **V8** 来运行 JavaScript。
- en: Tokio
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tokio**'
- en: Tokio is an asynchronous runtime for Rust applications providing everything
    needed for interacting with networks. It is reliable, fast, and flexible. Besides
    being Rust-native, one of the core reasons for Deno to use Tokio was that it is
    also quite easy to integrate. Tokio comes with I/O helpers, timers, filesystem
    access, synchronization, and scheduling capabilities, making it a complete libuv
    replacement. More information can be found at [https://tokio.rs/](https://tokio.rs/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tokio** 是为 Rust 应用程序提供与网络交互所需一切功能的异步运行时。它可靠、快速且灵活。除了是 Rust 原生之外，Deno 选择使用
    Tokio 的一个核心原因也是它非常易于集成。Tokio 包含 I/O 辅助工具、定时器、文件系统访问、同步和调度功能，使其成为完整的 libuv 替代品。更多信息可以在
    [https://tokio.rs/](https://tokio.rs/) 找到。'
- en: 'The architecture of Deno is shown in *Figure 11**.1*. Notably, the diagram
    is almost an exact match for *Figure 1**.1*, which showed the architecture of
    Node.js. The most striking difference is the acceptance of TypeScript, which will
    be translated into JavaScript by a combination of `swc` (transpilation) and `tsc`
    (type checking). Another crucial difference is the additional isolation layer:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 的架构如图 *图 11.1* 所示。值得注意的是，该图几乎与 *图 1.1* 完全匹配，后者展示了 Node.js 的架构。最显著的区别是接受
    TypeScript，它将通过 `swc`（转译）和 `tsc`（类型检查）的组合转换为 JavaScript。另一个关键的区别是增加了额外的隔离层：
- en: '![ Figure 11.1 – The architecture of Deno ](img/Figure_11.1_B18989.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – Deno 的架构](img/Figure_11.1_B18989.jpg)'
- en: Figure 11.1 – The architecture of Deno
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – Deno 的架构
- en: 'The installation of Deno can be done on the command line. For instance, on
    macOS and Linux, you can just run the following Shell script:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Deno 的安装可以通过命令行完成。例如，在 macOS 和 Linux 上，您只需运行以下 Shell 脚本：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Whereas on Windows, you can use the PowerShell for this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 Windows 上，您可以使用 PowerShell 来完成此操作：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Alternative installations for common application package managers such as Scoop,
    Chocolatey, or Homebrew exist, too.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常见的应用程序包管理器，如 Scoop、Chocolatey 或 Homebrew，也存在替代安装方式。
- en: 'To try Deno, you can run the following script:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试 Deno，您可以运行以下脚本：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are a couple of things happening already. First, we are not using a local
    source to run, but an address. Second, since this is an address, the source needs
    to be downloaded. Third, Deno always prefers to receive explicit versions, so
    it will complain that we just used whatever version of `stdlib` here. Instead,
    it redirects to the latest version, which was `0.159.0` at the time of writing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有一些事情发生了。首先，我们不是使用本地源来运行，而是一个地址。其次，由于这是一个地址，源需要被下载。第三，Deno 总是更喜欢接收显式版本，所以它会抱怨我们在这里只使用了
    `stdlib` 的任何版本。相反，它会重定向到最新的版本，写作时为 `0.159.0`。
- en: Finally, if you run the script again, you’ll just see the output without any
    download or warning. This is due to Deno’s cache. In order to stay well performing,
    every downloaded module is assumed to be immutable and will be cached locally.
    Future references will therefore not require another download, which makes their
    startup time acceptable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你再次运行脚本，你将只会看到输出，没有任何下载或警告。这是由于 Deno 的缓存造成的。为了保持良好的性能，假设每个下载的模块都是不可变的，并将它们缓存在本地。因此，未来的引用将不需要再次下载，这使得它们的启动时间是可以接受的。
- en: 'The big question is now: can Deno also just run Node.js libraries and applications?
    The unsatisfying answer is maybe. In theory, just JavaScript files can be used
    – however, Deno only supports ESM modules. Since many Node.js libraries are written
    using CommonJS, we would not have any success here.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的大问题是：Deno 是否也能运行 Node.js 库和应用程序？令人不满意的答案是也许可以。理论上，仅可以使用 JavaScript 文件 – 然而，Deno
    只支持 ESM 模块。由于许多 Node.js 库是使用 CommonJS 编写的，我们在这里将不会成功。
- en: As mitigation, we could just transpile a package – bundle it into one file and
    run it without any trouble – but even then, we might face the issue of incompatibility
    with the ecosystem, as standard packages such as `fs` are available in Node.js
    but not in Deno.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 作为缓解措施，我们只需将包进行转换 – 将其打包成一个文件并运行，而不会遇到任何麻烦 – 但即使在这种情况下，我们也可能面临与生态系统不兼容的问题，因为标准包如
    `fs` 在 Node.js 中可用，但在 Deno 中不可用。
- en: 'A better way out of this is to use the *Node compatibility mode* of Deno. Before
    version *1.25*, it worked by running `deno` with the `--unstable` and `--compat`
    flags. Right now, Deno seems to only allow this via custom imports. Let’s try
    this out to see it in action. For this, you can create a new Node.js project with
    a single third-party package and some code using it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的解决方案是使用 Deno 的 *Node 兼容模式*。在版本 *1.25* 之前，它通过使用 `--unstable` 和 `--compat`
    标志来运行 `deno` 实现。目前，Deno 似乎只允许通过自定义导入来实现这一点。让我们尝试一下，看看它是如何工作的。为此，你可以创建一个新的 Node.js
    项目，其中包含一个第三方包和一些使用它的代码：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To test this, the following code provides a solid basis:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，以下代码提供了一个坚实的基础：
- en: index.node.mjs
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: index.node.mjs
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code uses a third-party dependency made for Node.js together with a Node.js
    core module. It also makes use of modern features such as top-level `await` statements.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用了为 Node.js 制作的第三方依赖项以及 Node.js 核心模块。它还使用了现代特性，如顶层 `await` 语句。
- en: 'You can try running this with Node.js to see it working, but more interesting
    is the case of running this with Deno:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试使用 Node.js 运行它以查看其工作情况，但更有趣的是使用 Deno 运行的情况：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As mentioned, by default, Deno requires explicit paths. Without them, Deno
    does not work. Let’s modify this code to reflect the compatibility:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Deno 默认需要显式路径。没有它们，Deno 将无法工作。让我们修改这段代码以反映兼容性：
- en: index.deno.mjs
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: index.deno.mjs
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While the majority of the preceding code remains unchanged in comparison to
    `index.node.mjs`, the imports have been adapted slightly. The referenced npm packages
    need to be referenced using the `npm:` protocol. For Node.js core modules, we
    can refer to the `std/node` modules provided by Deno.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `index.node.mjs` 相比，尽管前面的代码大部分保持不变，但导入已经略有调整。引用的 npm 包需要使用 `npm:` 协议进行引用。对于
    Node.js 核心模块，我们可以引用 Deno 提供的 `std/node` 模块。
- en: 'Now, we can run the code with the `–``unstable` flag:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `--unstable` 标志来运行代码：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we did not provide any additional CLI flags, Deno will run in a mode where
    every resource request will be reflected by a question on the command line. In
    the session here, every request was confirmed with *yes*, granting the access
    request.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有提供任何额外的 CLI 标志，Deno 将以每项资源请求都会在命令行上反映为问题的模式运行。在这个会话中，每个请求都通过 *yes* 得到确认，从而授予了访问请求。
- en: 'Alternatively, we could have used a Deno feature that we discussed already
    in [*Chapter 2*](B18989_02.xhtml#_idTextAnchor023), *Dividing Code into Modules
    and Packages*, while discussing import maps. Let’s try to run our *unmodified*
    file again with the following import map:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们本可以使用之前在[*第二章*](B18989_02.xhtml#_idTextAnchor023)中讨论过的 Deno 功能，即*将代码划分为模块和包*，当时我们讨论了导入映射。让我们再次尝试使用以下导入映射运行我们的*未修改*文件：
- en: importmap.json
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: importmap.json
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The job of the import map is to teach Deno what to look for. Originally, Deno
    could not make sense of an import to `axios`, but now it knows that this should
    be resolved via npm. Similarly, the core Node.js packages can be added in there,
    too.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 导入映射的作用是教会 Deno 应该查找什么。最初，Deno 无法理解对 `axios` 的导入，但现在它知道这应该通过 npm 解决。同样，也可以在那里添加核心
    Node.js 包。
- en: 'This time, we set the `--allow-all` flag to skip all the access confirmations:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们设置了 `--allow-all` 标志以跳过所有访问确认：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And… it just works. No more work needed – all done with Deno primitives. Of
    course, quite often full compatibility cannot be achieved so easily.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 而且…它就是如此简单。不再需要做任何工作——所有工作都使用 Deno 原语完成。当然，通常无法如此轻松地实现完全兼容。
- en: While Deno is mostly focused on security, a presumably even more interesting
    area is performance. This is where another alternative shines, which is called
    Bun.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Deno 主要关注安全性，但一个可能更有趣的领域是性能。这正是另一个替代品——Bun——发光的地方。
- en: Using Bun for bundling web apps
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bun 打包 Web 应用
- en: While Deno seems quite different from Node.js on first glance, it also offers
    a lot of similarities. After all, both runtimes use V8 and can work with ESMs,
    but what if you want to be even more compatible with Node.js? Another approach
    is to be Node.js-compatible without using libuv or V8 at all. Enter **Bun**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Deno 在第一眼看起来与 Node.js 很不相同，但它也提供了很多相似之处。毕竟，这两个运行时都使用 V8，并且可以与 ESMs 一起工作，但如果你想要与
    Node.js 兼容性更高呢？另一种方法是完全不使用 libuv 或 V8 来实现 Node.js 兼容。这就是 **Bun** 的出现。
- en: Bun is an alternative to Node.js that follows the approach of Deno in terms
    of developer friendliness. Here, tooling such as a npm client or an application
    bundler is also included out of the box. However, to speed things up significantly,
    Bun does not use libuv and V8\. Instead, Bun is created using the programming
    language **Zig** and uses **JavaScriptCore** as its JavaScript runtime. JavaScriptCore
    is also the runtime behind the **Webkit** browser engine, empowering browsers
    such as **Safari**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Bun 是 Node.js 的替代品，它在开发者友好性方面遵循了 Deno 的方法。在这里，例如 npm 客户端或应用程序打包工具等工具也是开箱即用的。然而，为了显著提高速度，Bun
    不使用 libuv 和 V8。相反，Bun 使用编程语言 **Zig** 创建，并使用 **JavaScriptCore** 作为其 JavaScript
    运行时。JavaScriptCore 也是 **Webkit** 浏览器引擎背后的运行时，为如 **Safari** 这样的浏览器提供支持。
- en: 'The main benefits of Bun are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Bun 的主要优势如下：
- en: It comes with useful utilities out of the box, such as a bundler, a transpiler,
    a package manager, and a task runner.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自带了一些有用的实用工具，例如打包器、转译器、包管理器和任务运行器。
- en: It outperforms Node.js, especially in terms of startup performance or request
    handling.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在启动性能或请求处理方面优于 Node.js。
- en: It embraces the Node.js ecosystem, but also includes some standard web APIs
    such as `fetch` or `WebSocket`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它拥抱 Node.js 生态系统，但也包括一些标准 Web API，如 `fetch` 或 `WebSocket`。
- en: 'A comparison of the high-level architecture of Node.js and Bun is shown in
    *Figure 11**.2*. Most importantly, while extra tools such as a package manager
    or a bundler are required with Node.js, Bun comes with batteries already included.
    All these tools are available after installation – and since all of these tools
    are integrated into the Bun executable, they provide the best performance possible:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 11.2* 中展示了 Node.js 和 Bun 的高层次架构比较。最重要的是，虽然 Node.js 需要额外的工具，如包管理器或打包器，但
    Bun 已经内置了所有这些工具。所有这些工具在安装后都可用——并且由于所有这些工具都集成到 Bun 可执行文件中，它们提供了最佳的性能：
- en: '![Figure 11.2 – High-level comparison of Node.js and Bun ](img/Figure_11.2_B18989.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – Node.js 和 Bun 的高层次比较](img/Figure_11.2_B18989.jpg)'
- en: Figure 11.2 – High-level comparison of Node.js and Bun
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – Node.js 和 Bun 的高层次比较
- en: As with Deno, Bun can be installed via a Shell script. At the time of writing,
    Bun is not available as a direct installation for Windows. Instead, you’ll need
    to fall back to the **Windows Subsystem for Linux** (**WSL**) if you want to try
    out Bun.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Deno 一样，Bun 也可以通过 Shell 脚本安装。在撰写本文时，Bun 不可直接在 Windows 上安装。如果你想要尝试 Bun，则需要回退到
    **Windows Subsystem for Linux** （**WSL**）。
- en: 'To install Bun on macOS and Linux, you can run the following Shell script:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 macOS 和 Linux 上安装 Bun，你可以运行以下 Shell 脚本：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Running a simple example (`hello.ts`) with Bun looks as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bun 运行一个简单的示例 (`hello.ts`) 如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding example, the code is really simple – just using the console
    output here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，代码非常简单——只需在这里使用控制台输出即可：
- en: hello.ts
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: hello.ts
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An interesting aspect of Bun is that it also has the ability to automatically
    create a server. If we use a default export with a `fetch` function, then Bun
    will create a server, which, by default, runs on port `3000`. The port can also
    be changed by having another property called `port` in there:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Bun 的一个有趣方面是它还具有自动创建服务器的功能。如果我们使用带有 `fetch` 函数的默认导出，那么 Bun 将创建一个服务器，默认情况下，该服务器运行在端口
    `3000`。端口也可以通过在该处添加另一个名为 `port` 的属性来更改：
- en: http.ts
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: http.ts
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Calling `bun run http.ts` will open the server. To see the result, go to the
    `http://localhost:3000` address using your browser.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `bun run http.ts` 将会启动服务器。要查看结果，请使用您的浏览器访问 `http://localhost:3000` 地址。
- en: 'Finally, let’s use Bun as a bundler for the small demo project we did in [*Chapter
    6*](B18989_06.xhtml#_idTextAnchor057). The first thing you should notice is that
    you don’t need any development dependencies – just the runtime ones. Also, instead
    of running `npm install` or similar, you should resolve the dependencies via `bun
    install`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用 Bun 作为捆绑器来处理我们在 [*第 6 章*](B18989_06.xhtml#_idTextAnchor057) 中所做的那个小型演示项目的捆绑。你应该注意的第一件事是，你不需要任何开发依赖项——只需要运行时依赖项。此外，你不需要运行
    `npm install` 或类似的命令，而应该通过 `bun install` 来解决依赖项：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Frankly, `react`, `react-dom`, `react-router-dom`, and `video.js` comprise
    only four packages, but their installation speed is still quite good. Now, it’s
    time to bundle the JavaScript code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，`react`、`react-dom`、`react-router-dom` 和 `video.js` 只包含四个包，但它们的安装速度仍然相当不错。现在，是时候捆绑
    JavaScript 代码了：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result is quite different to the bundlers we’ve seen beforehand. We get
    a single file, `node_modules.bun`, which contains the resulting JavaScript, as
    well as all the associated metadata. The file itself is an executable – ready
    to spit out the contained code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与之前我们所见到的捆绑器大不相同。我们得到一个单独的文件，`node_modules.bun`，它包含生成的 JavaScript 以及所有相关的元数据。该文件本身是可执行的——准备好输出包含的代码。
- en: 'Extracting the JavaScript contained in the `node_modules.bun` file can be done
    by running the executable – and piping the output to a JavaScript file. For instance,
    see the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行可执行文件提取 `node_modules.bun` 文件中包含的 JavaScript 可以通过将输出管道传输到 JavaScript 文件来实现。例如，请参见以下内容：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Is this sufficient for all our bundling needs? Certainly not. Right now, the
    integrated bundler is essentially ignoring our code and only bundling together
    the code from the external packages sitting in the `node_modules` directory. However,
    even if our code was bundled, the process is not really ideal. Currently, Bun
    only considers JavaScript, TypeScript, JSON, and CSS files. There is no way to
    include assets such as images or videos.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否足够满足我们所有的捆绑需求？当然不是。目前，集成的捆绑器基本上忽略了我们的代码，而只捆绑了位于 `node_modules` 目录中的外部包的代码。然而，即使我们的代码被捆绑，这个过程也并不真正理想。目前，Bun
    只考虑 JavaScript、TypeScript、JSON 和 CSS 文件。无法包含诸如图像或视频之类的资产。
- en: For the future, all these capabilities are planned. While Bun (in version *0.1.13*)
    is still experimental technology, what is out there is promising. All things considered,
    it’s certainly something to keep on the radar, but nothing that can be actively
    used to create production-ready code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未来，所有这些功能都计划实现。虽然 Bun（在版本 *0.1.13*）仍然是实验性技术，但现有的技术很有希望。综合考虑，它当然值得保持关注，但并不是可以积极用于创建生产就绪代码的东西。
- en: Let’s recap what you’ve learned in this chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你在本章中学到的内容。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned why alternatives to Node.js exists and what the
    most popular options are. You’ve explored what Deno is all about and how it distinguishes
    itself from Node.js. You’ve also seen an up-and-coming alternative with Bun.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了为什么存在 Node.js 的替代品以及最受欢迎的选项是什么。你已经了解了 Deno 是什么以及它是如何区别于 Node.js 的。你还看到了一个新兴的替代品——Bun。
- en: Equipped with this knowledge, you are not only capable of writing tools that
    might be able to run in other runtimes than Node.js but you are also capable of
    deciding where your existing tools should run. Overall, this does not constrain
    you to the disadvantages of Node.js and gives you freedom to make the right choice
    aligned with the problem you want to solve.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识，你不仅能够编写可能在 Node.js 以外的运行时中运行的工具，而且你还可以决定你的现有工具应该在哪里运行。总的来说，这并不限制你于 Node.js
    的缺点，并赋予你自由，根据你想要解决的问题做出正确的选择。
- en: Epilogue
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前言
- en: In general, it makes sense to view Node.js as a great helper for getting the
    job done. The whole ecosystem – from its module system to its command-line utilities
    and from its libraries to its frameworks – is vast. Almost every problem has been
    cracked and a solution has been published.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，将 Node.js 视为一个出色的助手来完成任务是有意义的。整个生态系统——从其模块系统到其命令行工具，从其库到其框架——非常庞大。几乎每个问题都已被解决，并已发布了解决方案。
- en: I hope that with this book, you have a proper guide to walk you through the
    jungle of available helpers, making you not only a more efficient user of Node.js
    but also a contributor. While the existing tools are all helpful and powerful,
    they are certainly not the end of the line. Everyone has a unique view and things
    progress all the time. Don’t wait for somebody else to solve a problem – tackle
    it yourself and share your solution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 希望通过这本书，你能够得到适当的指南，帮助你穿越可用的助手丛林，不仅让你成为Node.js的更高效用户，还能成为贡献者。虽然现有的工具都很有帮助且功能强大，但它们当然不是终点。每个人都有独特的视角，事物总是在不断进步。不要等待别人解决问题——自己动手解决，并分享你的解决方案。
- en: All the best!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你一切顺利！
