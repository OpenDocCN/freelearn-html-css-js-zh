- en: 9\. Working with Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 使用 Node.js
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to describe the basics of and use
    `Node.js` to build basic web applications; differentiate between synchronous and asynchronous
    processing; use `Node Package Manager (npm)` to add, remove, and update the packages
    with your command-line interface; use built-in and third-party node modules; run
    MySQL and MongoDB databases; and build real-time web applications using `WebSocket`,
    and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够描述 Node.js 的基础知识，并使用 `Node.js` 构建基本的 Web 应用程序；区分同步和异步处理；使用 `Node
    Package Manager (npm)` 通过命令行界面添加、删除和更新包；使用内置和第三方节点模块；运行 MySQL 和 MongoDB 数据库；并使用
    `WebSocket` 构建实时 Web 应用程序，等等。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, you have covered the fundamentals and core basics of JavaScript. This
    includes understanding the core syntax of building interactive web-based programs
    using JavaScript code. A strong understanding of the foundation of this programming
    language will enable us to take a look at Node.js, which is beyond the browser.
    It forms the basis for the popularity of JavaScript.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了 JavaScript 的基础和核心基础知识。这包括理解使用 JavaScript 代码构建交互式 Web 程序的核心语法。对这种编程语言基础的良好理解将使我们能够了解
    Node.js，它超越了浏览器。它是 JavaScript 流行的基础。
- en: In this chapter, you will be introduced to Node.js. Before Node.js, JavaScript
    was used primarily for client-side scripting as part of the browser. In 2009,
    Ryan Dahl developed Node.js, a cross-platform, open-source JavaScript runtime
    environment that executes JavaScript outside the browser. It allows developers
    to use command-line tools and carry out server-side scripting. Basically, it unites
    the entire process of web application development through a single programming
    language as opposed to the developer having to learn different languages and build
    different projects for the server-side and the client-side.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 Node.js。在 Node.js 之前，JavaScript 主要用于浏览器中的客户端脚本。2009 年，Ryan Dahl 开发了
    Node.js，这是一个跨平台的开源 JavaScript 运行时环境，可以在浏览器之外执行 JavaScript。它允许开发者使用命令行工具并执行服务器端脚本。基本上，它通过单一编程语言统一了整个
    Web 应用程序开发过程，而不是开发者需要学习不同的语言并为服务器端和客户端构建不同的项目。
- en: Node.js is not just considered a programming language but an environment in
    which you can execute JavaScript. It is a popular programming language with a
    huge repository on GitHub that is sustained by contributions from thousands of
    developers all around the world. In this chapter, you will start with the installation
    of Node.js on all platforms, and then you will go through how it works in the
    background and how it processes requests asynchronously. Furthermore, you will
    study the different types of modules and how to use them. You will also do a lot
    of important exercises to get some practical exposure to Node.js. There are a
    lot of things to learn, so let's begin.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 不仅被视为一种编程语言，而且是一个可以执行 JavaScript 的环境。它是一种流行的编程语言，在 GitHub 上拥有庞大的仓库，由世界各地的数千名开发者的贡献所维持。在本章中，你将从所有平台上的
    Node.js 安装开始，然后了解它在后台的工作方式以及如何异步处理请求。此外，你将学习不同类型的模块以及如何使用它们。你还将进行许多重要的练习，以获得 Node.js
    的实际应用经验。有很多东西要学习，所以让我们开始吧。
- en: The Node.js Environment
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 环境
- en: Node.js has an event-driven architecture that is capable of processing requests
    asynchronously. Node.js has a single-threaded architecture. Traditional servers
    had multi-threaded architectures and they spawned a new thread as soon as a new
    request landed, but Node.js handles everything on a single thread. You may wonder
    how a single-threaded Node.js handles millions of requests. Well, the answer is
    the event loop. JavaScript works on a single thread and handles async operations
    thanks to its event-loop architecture. Any request that is taking a long time
    is sent to the background and the next request is addressed and processed. Before
    proceeding, let's understand the difference between synchronous and asynchronous
    processing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 拥有事件驱动的架构，能够异步处理请求。Node.js 采用单线程架构。传统的服务器采用多线程架构，每当有新的请求到来时，就会创建一个新的线程，但
    Node.js 在单个线程上处理所有事情。你可能想知道单线程的 Node.js 如何处理数百万个请求。答案是事件循环。JavaScript 在单线程上运行，并通过事件循环架构处理异步操作。任何耗时较长的请求都会被发送到后台，然后处理下一个请求。在继续之前，让我们了解同步处理和异步处理之间的区别。
- en: Sync versus Async
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步与异步
- en: 'If the execution of a program takes place in a linear sequence, it is synchronous
    processing. For example, in the following code block, an entire line will be read
    and executed before the process moves to the next line:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序的执行是按线性序列进行的，那么这就是同步处理。例如，在以下代码块中，将读取并执行整行，然后进程才会移动到下一行：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This process works best with only one request. In the case of multiple requests,
    you have to wait for the previous request to finish. This can be as exciting as
    watching grass grow. To overcome this, you can handle the request asynchronously.
    This way, you will push any process that is taking too long from the execution
    stack to the background so that other code can be executed. Once the background
    work is done, the program will be pushed back again to the execution stack and
    processed further:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在只有一个请求的情况下效果最好。在多个请求的情况下，你必须等待前一个请求完成。这可能会像看草生长一样令人兴奋。为了克服这个问题，你可以异步处理请求。这样，你将任何耗时太长的过程从执行栈中推送到后台，以便其他代码可以执行。一旦后台工作完成，程序将再次推回到执行栈并进一步处理：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Background of Request Processing
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求处理背景
- en: 'Node.js uses a library named `llibuv`. It handles asynchronous I/O very well.
    Instead of spawning multiple threads for each request, it manages a thread pool
    very efficiently with the help of the OS kernel. As soon as a new request lands
    on a Node.js server, it delegates most of the work to other system workers. As
    soon as the background workers finish their job, they emit events to Node.js callbacks
    registered on that event. This process is visualized in the following figure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js使用一个名为`llibuv`的库。它处理异步I/O非常出色。它不是为每个请求启动多个线程，而是在操作系统的内核帮助下非常高效地管理线程池。一旦新的请求落在Node.js服务器上，它就会将大部分工作委托给其他系统工作者。一旦后台工作者完成他们的工作，他们就会向注册在该事件上的Node.js回调函数发出事件。这个过程在以下图中得到了可视化：
- en: '![Figure 9.1: Node.js event loop architecture'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：Node.js事件循环架构'
- en: '](img/C14377_09_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_09_01.jpg]'
- en: 'Figure 9.1: Node.js event loop architecture'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：Node.js事件循环架构
- en: Node.js is much faster than multithreaded systems, even with a single thread.
    Therefore, Node.js uses event loop architecture with thread pool management, which
    makes it powerful and faster than its competitors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js比多线程系统快得多，即使只有一个线程。因此，Node.js使用具有线程池管理的事件循环架构，这使得它比竞争对手更强大和更快。
- en: What Are Callbacks?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是回调？
- en: Callbacks are a very important concept when it comes to asynchronous programming.
    A callback is a function that can be executed as soon as its primary function
    finishes. Callbacks are heavily used in Node.js.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到异步编程时，回调是一个非常重要的概念。回调是一个可以在其主函数完成时立即执行的功能。回调在Node.js中被广泛使用。
- en: A typical example of where a callback would be useful is reading text from a
    file. While a file is read, you do not want the server to wait for it to finish
    first. Reading a file can be handled by a background worker and as soon as it
    finishes, it will execute an event, which will be processed by the event loop.
    This event will then execute the callback.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 回调可能有用的一个典型例子是从文件中读取文本。在读取文件时，你不想服务器等待它完成。文件读取可以由后台工作者处理，一旦完成，它将执行一个事件，该事件将被事件循环处理。然后，该事件将执行回调。
- en: The Node.js Shell
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js Shell
- en: Node.js comes with a virtual terminal shell. It provides a quick way to use
    Node.js. You can execute expressions in the shell. You can also execute loops
    and define functions in the shell. To enter the shell, open your terminal and
    type node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js自带一个虚拟终端shell。它提供了一种快速使用Node.js的方法。你可以在shell中执行表达式。你还可以在shell中执行循环并定义函数。要进入shell，打开你的终端并输入node。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`REPL` is also a built-in module. You can also import it to your module.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`REPL`也是一个内置模块。你还可以将其导入到你的模块中。'
- en: 'Exercise 9.01: Your First Program'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.01：你的第一个程序
- en: 'Now that you know about the Node.js environment and its workings, you are ready
    to write your first script and execute it with Node.js. Let''s write our first
    very simple Node.js script in which we will just perform the sum of two numbers
    and will show the output on the screen:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Node.js环境和它的运作方式，你准备好编写你的第一个脚本，并用Node.js执行它。让我们编写我们的第一个非常简单的Node.js脚本，我们将只执行两个数字的和，并将输出显示在屏幕上：
- en: 'Create a file named `first.js`. Open the terminal in the same directory and
    add the following lines:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`first.js`的文件。在同一目录下打开终端，并添加以下行：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the function to get the output:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行函数以获取输出：
- en: '![Figure 9.2: Output of your first program'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2：你的第一个程序输出'
- en: '](img/C14377_09_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_09_02.jpg]'
- en: 'Figure 9.2: Output of your first program'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：你的第一个程序的输出
- en: Here, you have written a simple function to add the two numbers, which you will
    pass when you call the function. Then, you will execute this script with Node.js
    and the output will be printed in the console.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已经编写了一个简单的函数来添加两个数字，你将在调用函数时传递这些数字。然后，你将使用 Node.js 执行此脚本，输出将打印在控制台。
- en: How to Import/Require a Module in a Node.js Application
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在 Node.js 应用程序中导入/引入模块
- en: 'Importing/requiring other modules in your program is very easy in Node.js.
    You can use `require` to import other modules into your Node.js application. Let''s
    say we need one of the built-in modules of Node.js in our script. We would use
    the following syntax:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中导入/引入程序中的其他模块非常简单。你可以使用 `require` 将其他模块导入到你的 Node.js 应用程序中。假设我们需要
    Node.js 的一个内置模块在我们的脚本中。我们会使用以下语法：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will look for the package within Node.js modules along with any globally
    or locally installed packages in the project. If it is found, it will import it;
    otherwise, it will throw an exception. When writing modularized code, you can
    create your own custom packages and import them using `require` with a relative
    path, like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 Node.js 模块内以及项目全局或本地安装的任何包中查找包。如果找到，它将导入它；否则，它将抛出异常。在编写模块化代码时，你可以创建自己的自定义包，并使用
    `require` 和相对路径导入它们，如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Node Package Manager (npm)
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点包管理器（npm）
- en: One of the good things about working with Node.js is that you can write highly
    modularized code. There are millions of packages available on the internet that
    can be used in your projects. But as the number of packages used in your projects
    grows, so too does the difficulty of handling them. Node.js comes with its own
    package manager, which is called npm.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Node.js 一起工作的好处之一是你可以编写高度模块化的代码。互联网上有数百万个包可供你的项目使用。但随着你在项目中使用的包的数量增加，处理它们的难度也会增加。Node.js
    自带自己的包管理器，称为 npm。
- en: npm has thousands of packages, and all are easily available through its web
    portal and through your command-line interface. It is used to manage the packages
    your application needs. You can add, remove, and update packages with your command-line
    interface.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: npm 有数千个包，所有这些都可以通过其网络门户和命令行界面轻松访问。它用于管理你的应用程序需要的包。你可以通过命令行界面添加、删除和更新包。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`npm` is preconfigured at the time of node installation on all major platforms.
    In the case of Linux, if you are facing issues while accessing `npm` after successfully
    installing Node.js, then you have to add the path of `npm` to the `$PATH` variables.
    Check the Linux installation part in the *Preface* of the book for more details.
    In the case of Windows and Mac, it''s most likely that you will not face any issues.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm` 在所有主要平台上在安装 Node.js 时预先配置。在 Linux 的情况下，如果你在成功安装 Node.js 后访问 `npm` 时遇到问题，那么你必须将
    `npm` 的路径添加到 `$PATH` 变量中。在书的 *前言* 部分检查 Linux 安装部分以获取更多详细信息。在 Windows 和 Mac 的情况下，你很可能不会遇到任何问题。'
- en: Flags
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志
- en: 'Some of the useful command-line flags are:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有用的命令行标志是：
- en: '`-g` = Install the package globally, that is, in the system.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` = 在系统中全局安装包。'
- en: '`-S` = Save the package as a project dependency. Similar to `–save`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`-S` = 将包保存为项目依赖项。类似于 `–save`。'
- en: '`-D` = Save the package as a `dev` dependency. Similar to `--save-dev`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`-D` = 将包保存为 `dev` 依赖项。类似于 `--save-dev`。'
- en: '`-v` = Check the currently installed version.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v` = 检查当前安装的版本。'
- en: Commands
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令
- en: 'Some of the very useful commands of `npm` are given here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm` 的一些非常有用的命令如下所示：'
- en: '`i` parameters of `npm`. For instance, say you wanted to add `express.js` to
    your program – you would do that as follows:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` 的 `i` 参数。例如，假设你想将 `express.js` 添加到你的程序中——你会这样做：'
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`npm`. For instance, you would use this if you wanted to update `express.js`
    in your program:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm`。例如，如果你想在程序中更新 `express.js`，你会使用这个：'
- en: '[PRE6]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`rm` parameters of `npm`. For instance, say you wanted to remove the previously
    installed package (`express.js`) from your program – you could do so this way:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm` 参数的 `npm`。例如，假设你想从你的程序中删除之前安装的包（`express.js`）——你可以这样做：'
- en: '[PRE7]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`npm` registry. Use the `publish` parameter to push the package to the `npm`
    registry:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` 注册表。使用 `publish` 参数将包推送到 `npm` 注册表：'
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`search` parameter:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search` 参数：'
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: package.json
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: package.json
- en: '`package.json` is a file that always stays in the root of the project. It is
    a manifest file that almost all `Node.js` projects have. This is the file that
    `npm` uses to manage dependencies. Before starting development in `Node.js`, everybody
    should understand what `package.json` is and what it does. It basically serves
    two main purposes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`是一个始终位于项目根目录的文件。它是一个清单文件，几乎所有的`Node.js`项目都有。这是`npm`用来管理依赖项的文件。在开始`Node.js`开发之前，每个人都应该了解`package.json`是什么以及它做什么。它基本上有两个主要用途：'
- en: Managing the dependencies of your project
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理您项目的依赖项
- en: Providing scripts that help to generate builds, run tests, and other stuff related
    to your project
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供帮助生成构建、运行测试以及与您的项目相关的其他内容的脚本
- en: You can define start scripts in this file, which will help you to inject environment
    variables into your project. You can even use this file to configure the production
    and development environments.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在该文件中定义启动脚本，这将帮助您将环境变量注入到您的项目中。您甚至可以使用此文件来配置生产环境和开发环境。
- en: 'To create this file in the project root, execute the following in your terminal:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目根目录中创建此文件，请在您的终端中执行以下操作：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will be prompted to answer a question. You can simply press *Enter* to
    skip it and a file named `package.json` will be created in your current directory:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示回答一个问题。您可以简单地按*Enter*键跳过它，并在当前目录中创建一个名为`package.json`的文件：
- en: '![Figure 9.3: Sample output of package.json'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3：package.json的示例输出'
- en: '](img/C14377_09_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_09_03.jpg)'
- en: 'Figure 9.3: Sample output of package.json'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：package.json的示例输出
- en: Publishing a Package
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布一个包
- en: 'The `npm` registry is completely open to new packages. You can build and upload
    your own package to the `npm` registry, and to do that, you just need a directory
    with a `package.json` file in it. You can just write your module and update the
    `package.json` parameters. Then, you use the following command to push it to the
    registry:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`注册表完全对外开放新包。您可以在`npm`注册表中构建和上传自己的包，为此，您只需要一个包含`package.json`文件的目录。您可以直接编写您的模块并更新`package.json`参数。然后，您使用以下命令将其推送到注册表：'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can now search for your package at [https://www.npmjs.com](https://www.npmjs.com)
    and anyone can install your package as a dependency in their project.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在[https://www.npmjs.com](https://www.npmjs.com)上搜索您的包，任何人都可以将其作为依赖项安装到他们的项目中。
- en: In this section, you were introduced to Node.js and its workings, and you wrote
    and executed your first Node.js program. You learned how to handle Node.js packages
    efficiently. You understood the purpose and importance of `package.json`. This
    was just the introduction. Now that we've introduced you to Node.js, let's dive
    deeper into managing Node.js packages and using them in your projects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了Node.js及其工作原理，并编写并执行了您的第一个Node.js程序。您学习了如何高效地处理Node.js包。您理解了`package.json`的目的和重要性。这只是一个介绍。现在，既然我们已经向您介绍了Node.js，让我们更深入地探讨如何管理Node.js包并在项目中使用它们。
- en: Node Modules
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node模块
- en: To start with, we can say that Node.js modules can vividly comprehend the dependencies
    of an application. Suppose that you have created an easy-to-use payment application,
    say, for a restaurant. You have developed a payment app. Now, you get the idea
    to implement a QR scanner inside your app to make bill payments even easier. Well,
    you have two choices. Either create the entire feature yourself by spending time
    developing, or you can install the same functionality in your application using
    `npm`'s vast inventory of modules.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以这样说，Node.js模块可以生动地理解应用程序的依赖项。假设您已经创建了一个易于使用的支付应用程序，比如为餐厅设计的。您已经开发了一个支付应用程序。现在，您有了在应用程序中实现QR扫描器的想法，以使账单支付更加简单。好吧，您有两个选择。要么自己从头开始创建整个功能，花费时间开发，要么可以使用`npm`的大量模块库存将相同的功能安装到您的应用程序中。
- en: 'All you need to do is follow these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需遵循以下步骤即可：
- en: You need to search for the module name, say, **QR scanner**, to use in your
    Node or Angular application on Google.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要在谷歌上搜索模块名称，例如**QR scanner**，以便在您的Node或Angular应用程序中使用。
- en: The very first link you need is [https://www.npmjs.com/](https://www.npmjs.com/).
    In this inventory, you can see many efficient Node.js modules. You can find a
    vast variety of modules there to use for anything from beautifying your terminal
    to rectifying your code. When you have got the module you need, you will have
    to install and merge it with your application.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要的第一链接是[https://www.npmjs.com/](https://www.npmjs.com/)。在这个库存中，您可以看到许多高效的Node.js模块。您可以在那里找到各种各样的模块，用于美化您的终端或修正您的代码。当您找到所需的模块时，您将需要安装并将其与您的应用程序合并。
- en: 'Now that you have the module, you just need to implement it in your application.
    Finally, the last step is to install the module in your application by entering
    the following command in your terminal:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经有了模块，您只需在您的应用程序中实现它。最后一步是在您的终端中输入以下命令来安装该模块：
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will add your module as a dependency in your `package.json` file. You
    just need to import or require it as per the tech syntax. Just copy and paste
    the functions as per the installed module''s guidelines. Now is the time to run
    your application:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在您的 `package.json` 文件中将您的模块添加为依赖项。您只需按照技术语法导入或引入它。只需按照已安装模块的指南复制并粘贴函数。现在是运行您应用程序的时候了：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You now have some wonderful new features in your application, added in a matter
    of minutes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在在几分钟内就为您的应用程序添加了一些奇妙的新功能。
- en: To summarize this, a Node.js module is a properly bundled magical box consisting
    of one or more JavaScript files destined to fulfill a specific operation in your
    application, in the most efficient and sustainable way, that are maintained by
    its developers consistently.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Node.js 模块是一个由开发者持续维护的、包含一个或多个 JavaScript 文件的、旨在以最有效和可持续的方式在您的应用程序中执行特定操作的、正确打包的神奇盒子。
- en: You can even make your own Node.js modules and publish them. That makes you
    an open source contributor. Before moving onto that, let's jump into an interesting
    discussion about built-in node modules.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以创建自己的 Node.js 模块并发布它们。这使您成为开源贡献者。在继续之前，让我们跳到一个关于内置 node 模块的有趣讨论。
- en: Node.js Modules
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 模块
- en: There are numerous modules included with Node.js that do not require installation.
    One such basic module is the URL module.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 包含了许多不需要安装的模块。其中之一是基本的 URL 模块。
- en: '**URL**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL**'
- en: 'URL is a module provided by Node.js that is used to split complicated URL strings
    into a more readable format. It can be used as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: URL 是 Node.js 提供的一个模块，用于将复杂的 URL 字符串拆分为更易读的格式。它可以如下使用：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are some utilities provided by this module that you can use to resolve
    and parse a URL. If you look at any URL closely, you will find that it contains
    some particular components written in a complex format:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块提供了一些实用工具，您可以使用它们来解析和解析 URL。如果您仔细查看任何 URL，您会发现它包含一些以复杂格式编写的特定组件：
- en: '![Figure 9.4: Breakdown of URL into different terms'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4：将 URL 拆分为不同的术语'
- en: '](img/C14377_09_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_09_04.jpg](img/C14377_09_04.jpg)'
- en: 'Figure 9.4: Breakdown of URL into different terms'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：将 URL 拆分为不同的术语
- en: You can use the URL module to solve any difficulty that you're having. The module
    treats the URL as an object and each component inside the URL is treated as a
    property of the object, meaning you can access each and every part of the URL
    without difficulty.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 URL 模块来解决您遇到的任何困难。该模块将 URL 视为一个对象，URL 内部的每个组件都被视为该对象的属性，这意味着您可以轻松访问 URL
    的每个部分。
- en: 'Some of the useful properties of URL are shown in this table:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本表中显示了 URL 的一些有用属性：
- en: '![Figure 9.5: URL Properties'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5：URL 属性'
- en: '](img/C14377_09_05.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_09_05.jpg](img/C14377_09_05.jpg)'
- en: 'Figure 9.5: URL Properties'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：URL 属性
- en: 'Exercise 9.02: Updating URL Information Using the URL Module'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.02：使用 URL 模块更新 URL 信息
- en: 'To try and understand the different properties of a URL, let''s do an exercise
    where we will try to update the information of a URL, such as the pathname and
    host. This will help us understand how to manipulate the properties of the URL
    object to alter URLs when we need to:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 URL 的不同属性，让我们做一个练习，我们将尝试更新 URL 的信息，例如路径名和主机。这将帮助我们了解如何操作 URL 对象的属性以更改 URL，当我们需要时：
- en: Create an empty file and save it with the `.js` extension. For this exercise,
    let's create `url.js`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空文件，并保存为 `.js` 扩展名。对于这个练习，让我们创建 `url.js`。
- en: 'The first thing to do is to import the URL module:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的事情是导入 URL 模块：
- en: '[PRE15]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s use the `parse` function of the URL module and try to process a
    URL:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 URL 模块的 `parse` 函数尝试处理一个 URL：
- en: '[PRE16]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After calling the `parse` function, in return, you will get a processable object.
    This object will contain all the metadata of that URL. We can then use this object
    to manipulate the URL. Let''s change the host, pathname, and hash of the URL:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `parse` 函数后，您将得到一个可处理的对象。该对象将包含该 URL 的所有元数据。然后我们可以使用此对象来操作 URL。让我们更改 URL
    的主机、路径名和哈希值：
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let''s use the `format` function of the processable URL object to format
    it into a string and print it using the `console.log` function:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用可处理的 URL 对象的 `format` 函数将其格式化为字符串，并使用 `console.log` 函数打印它：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, just execute the script using Node.js. It will print the new URL,
    which you have updated using the properties of the URL object:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，只需使用 Node.js 执行脚本。它将打印出你使用 URL 对象的属性更新后的新 URL：
- en: '![Figure 9.6: Output of the URL program'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.6：URL 程序的输出'
- en: '](img/C14377_09_06.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_09_06.jpg)'
- en: 'Figure 9.6: Output of the URL program'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：URL 程序的输出
- en: In this exercise, we learned how to manipulate the properties of a URL. We modified
    the different components of a URL by using different functions provided by the
    URL module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何操作 URL 的属性。我们通过使用 URL 模块提供的不同函数修改了 URL 的不同组件。
- en: Filesystem
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统
- en: There is a Node.js section that you can use to work with the filesystem. You
    can perform various operations on files and directories using this module, such
    as create, update, read, and delete operations. The `try...catch` statement is
    a block of statements that are used to handle the exceptions that occur using
    synchronous operations. These exceptions may also be allowed to bubble up.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 部分你可以用来处理文件系统。你可以使用此模块执行各种文件和目录操作，例如创建、更新、读取和删除操作。`try...catch` 语句是一块用于处理使用同步操作发生的异常的语句。这些异常也可以被允许向上冒泡。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before proceeding further, know that you will perform all of these operations
    on an `intro.txt` file, which contains the introduction of Node.js. So, make sure
    that you have the `intro.txt` file with some content in the root of the project
    where you will write these scripts. You can run and test scripts by simply typing
    `node NameofYourFile.js` in your terminal window, making sure that you have the
    appropriate rights.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，请了解你将在一个名为 `intro.txt` 的文件上执行所有这些操作，该文件包含 Node.js 的介绍。所以，请确保你已经在项目的根目录中有了包含一些内容的
    `intro.txt` 文件，你将在那里编写这些脚本。你可以通过在终端窗口中简单地输入 `node NameofYourFile.js` 来运行和测试脚本，确保你有适当的权限。
- en: 'The various ways in which you can use this module are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方式使用此模块：
- en: '`read` is used to read files in the filesystem using the `fs.open()` method:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read` 用于使用 `fs.open()` 方法在文件系统中读取文件：'
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will print all the data of the file to the console.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印出文件的所有数据到控制台。
- en: '`append` adds specific content to files using `fs.appendFile()`:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append` 通过使用 `fs.appendFile()` 向文件添加特定内容：'
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It will append the line that you passed as the second parameter to the `appendFile`
    function to the file of the file.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它会将作为 `appendFile` 函数第二个参数传递的行追加到文件中。
- en: 'Renaming the files in the filesystem is done using the `fs.rename()` method:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件系统中重命名文件是通过使用 `fs.rename()` 方法完成的：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code will rename the `intro.txt` file to `introduction.txt` file.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将 `intro.txt` 文件重命名为 `introduction.txt` 文件。
- en: 'Files can be deleted using the `fs.unlink()` method:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `fs.unlink()` 方法删除文件：
- en: '[PRE22]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You use `unlink` to remove any file from the filesystem. Just pass the relative
    path or filename that you want to remove, and it will unlink that file/path from
    the filesystem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `unlink` 从文件系统中删除任何文件。只需传递你想要删除的相对路径或文件名，它将从文件系统中解除链接该文件/路径。
- en: Operating System
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统
- en: 'This section provides a number of operating system-related utility methods.
    It can be imported using:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一些与操作系统相关的实用方法。可以使用以下方式导入：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Some of the important functions of this module are:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块的一些重要功能如下：
- en: '`os.arch()`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.arch()`'
- en: This method will return the operating system's CPU architecture for which the
    Node.js binary was compiled, that is, `arm`, `arm64`, `x32`, `x64`, and so on.
    This module is very helpful if you are designing any architecture-dependent module.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将返回 Node.js 二进制文件编译的操作系统 CPU 架构，即 `arm`、`arm64`、`x32`、`x64` 等。如果你正在设计任何架构相关的模块，此模块非常有用。
- en: '`os.cpus()`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.cpus()`'
- en: This method will return an array of objects that contains all the information
    about each CPU core.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将返回一个对象数组，其中包含每个 CPU 核心的所有信息。
- en: '`os.hostname()`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.hostname()`'
- en: This method will return the hostname of the operating system.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将返回操作系统的主机名。
- en: '`os.platform()`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.platform()`'
- en: This method will return the operating system platform for which Node.js is compiled.
    This will be set during the compile time of Node.js. Some of the famous platforms
    are Darwin, freebsd, linux, openbsd, and win32.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将返回 Node.js 编译的操作系统平台。这将在 Node.js 的编译时间设置。一些著名的平台包括 Darwin、freebsd、linux、openbsd
    和 win32。
- en: '`os.networkInterfaces()`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.networkInterfaces()`'
- en: This method will give us all the information regarding network interfaces that
    have been assigned a network address. It will return an object, and each key will
    identify a network interface.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将为我们提供有关已分配网络地址的网络接口的所有信息。它将返回一个对象，每个键将标识一个网络接口。
- en: 'Exercise 9.03: Fetching Details about the Operating System'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.03：获取操作系统详细信息
- en: 'Let''s explore this module with a simple exercise. In this exercise, you will
    use Node.js'' `OS` module to get details about the operating system:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的练习来探索这个模块。在这个练习中，您将使用 Node.js 的 `OS` 模块来获取有关操作系统的详细信息：
- en: 'You have to import the os module using `require` in your Node.js script:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须在您的 Node.js 脚本中使用 `require` 导入 `os` 模块：
- en: '[PRE24]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, you can access this `os` object to call its properties and get the information
    necessary:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以访问此 `os` 对象来调用其属性并获取必要的信息：
- en: '[PRE25]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can then change the flow of your code execution based on the architecture
    on which the script is running.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以根据脚本运行的架构更改代码执行的流程。
- en: 'The output will be visible as follows:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 9.7: Some useful methods of the built-in os module in REPL mode of
    node'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.7：node 的 REPL 模式内内置的 os 模块的一些有用方法]'
- en: '](img/C14377_09_07.jpg)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14377_09_07.jpg]'
- en: 'Figure 9.7: Some useful methods of the built-in os module in REPL mode of node'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：node 的 REPL 模式内内置的 os 模块的一些有用方法
- en: In this exercise, we learned some useful methods to change the flow of code
    execution based on the architecture of the script and fetch details about the
    operating system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了一些有用的方法来根据脚本的架构更改代码执行的流程，并获取操作系统的详细信息。
- en: Path Module
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径模块
- en: 'The `path` module provides utilities for working with file and directory paths.
    It can be imported as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 模块提供了用于处理文件和目录路径的实用工具。它可以按以下方式导入：'
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Some of the important functions of this module are:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块的一些重要函数包括：
- en: '`path.dirname(pathString)`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`path.dirname(pathString)`'
- en: This method will return the directory name of a path. It is similar to Unix's
    `dirname` command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将返回路径的目录名。它与 Unix 的 `dirname` 命令类似。
- en: '`path.extname(pathString)`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`path.extname(pathString)`'
- en: This method will return the extension of the path. It will move from the last
    occurrence of the . (period) character of the entered path to the end of the path.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将返回路径的扩展名。它将从输入路径中最后一个 .（点）字符开始，到路径的末尾。
- en: '`path.format(pathObject)`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`path.format(pathObject)`'
- en: This method will return a path string from an object with specific keys. This
    is the opposite of `path.parse()`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将从具有特定键的对象中返回一个路径字符串。这是 `path.parse()` 的相反操作。
- en: '`path.join([...pathStrings, pathString... ])`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`path.join([...pathStrings, pathString... ])`'
- en: This method joins all the given path segments together using a platform-specific
    separator as a delimiter, then normalizes the resulting path. It's very useful
    when you are switching directories programmatically.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用平台特定的分隔符作为分隔符将所有给定的路径段连接在一起，然后规范化结果路径。当您需要程序化地切换目录时，它非常有用。
- en: 'Exercise 9.04: How to Extract and Join Directories'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.04：如何提取和连接目录
- en: 'Let''s explore the `path` module in detail by working on an exercise. In this
    exercise, you will extract the directory from absolute and relative paths, join
    directories, and extract file extensions from a path:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个练习来详细探索 `path` 模块。在这个练习中，您将从一个绝对路径和相对路径中提取目录，连接目录，并从一个路径中提取文件扩展名：
- en: Create an empty file and save it with a `.js` extension. For this exercise,
    let's name it `path.js`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空文件，并以 `.js` 扩展名保存它。对于这个练习，让我们称它为 `path.js`。
- en: 'Now, let''s take some sample directories and filenames for you to use to observe
    how the `path` module manipulates paths. Note that these paths are related to
    Windows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们提供一些示例目录和文件名供您使用，以观察 `path` 模块如何处理路径。请注意，这些路径与 Windows 相关：
- en: '[PRE27]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, let''s get the directory from a path. Let''s say that you have one path
    of a file (`/Users/YourUserName/Documents/node/modules/myFile.js`) and you want
    to extract the directory where this file exists:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们从一个路径中获取目录。假设您有一个文件的路径（`/Users/YourUserName/Documents/node/modules/myFile.js`），您想提取该文件所在的目录：
- en: '[PRE28]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s extract the file extension from the path string. For that, you
    have to use the ''`extname''` function of the `path` module:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们从路径字符串中提取文件扩展名。为此，您必须使用 `path` 模块的 `extname` 函数：
- en: '[PRE29]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, let''s try to join multiple directories and files to create a path.
    You can use the `join` method of the `path` module for this:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们尝试将多个目录和文件连接起来以创建路径。您可以使用 `path` 模块的 `join` 方法来完成此操作：
- en: '[PRE30]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that you have the finished code snippet, run `node path.js` in your terminal:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您有了完整的代码片段，请在终端中运行 `node path.js`：
- en: '[PRE31]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The screenshot of this preceding code will be displayed as follows:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码的截图将显示如下：
- en: '![Figure 9.8: Output of the path program'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.8：路径程序的输出'
- en: '](img/C14377_09_08.jpg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_09_08.jpg)'
- en: 'Figure 9.8: Output of the path program'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：路径程序的输出
- en: We can see the path to the directory in the preceding figure. We also learned
    to extract file extensions from a path.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的图中看到目录的路径。我们还学习了如何从路径中提取文件扩展名。
- en: HTTP
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP
- en: '`http` is the most important module of Node.js. It helps you to spin up a server
    that will listen to one specific port. It will let you transfer information over
    **Hypertext Transfer Protocol** (**HTTP**).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`http` 是 Node.js 中最重要的模块。它帮助您启动一个将监听特定端口的服务器。它将允许您通过 **超文本传输协议**（**HTTP**）传输信息。'
- en: 'The `createServer` function takes one function as a parameter, which will be
    called when you make any request to the server. That function has two parameters:
    `req` and `res`. The first, the request parameter, is a stream that holds all
    the details of the request. For instance, if you are using a `POST` request to
    submit a form, then this object will hold all the values in it. The response parameter
    is also a stream, and you can use it to update the response header, status, and
    more:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`createServer` 函数接受一个函数作为参数，当您向服务器发出任何请求时，该函数将被调用。该函数有两个参数：`req` 和 `res`。第一个参数，请求参数，是一个包含请求所有详细信息的流。例如，如果您使用
    `POST` 请求提交表单，那么这个对象将包含其中的所有值。响应参数也是一个流，您可以使用它来更新响应头、状态等：'
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, you are updating one key in the header and writing the status code as
    `200`, which is "OK." The difference between a parameter and a query is highlighted
    in the following figure:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在更新头部的键，并将状态码写入 `200`，即“OK”。参数与查询的区别在以下图中突出显示：
- en: '![Figure 9.9: Difference between a parameter and a query'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9：参数与查询的区别'
- en: '](img/C14377_09_09.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_09_09.jpg)'
- en: 'Figure 9.9: Difference between a parameter and a query'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：参数与查询的区别
- en: You can also get the parameter and the query from the same `req` object, which
    will help you to process the request.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从同一个 `req` 对象中获取参数和查询，这将有助于您处理请求。
- en: 'Exercise 9.05: Using a Node.js Server'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.05：使用Node.js服务器
- en: 'Let''s start our first Node.js server. This will be a very basic server that
    will just greet all requests with a "Hello World!" response. We will learn how
    to start up a server on a particular port and how to write responses to requests.
    Let''s jump straight into coding:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的第一个Node.js服务器。这将是一个非常基础的服务器，它将仅对所有的请求返回一个“Hello World!”响应。我们将学习如何在特定端口上启动服务器以及如何编写对请求的响应。让我们直接进入编码：
- en: 'Create a file named `http_server.js` and copy the following content into the
    file, then save it:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `http_server.js` 的文件，并将以下内容复制到该文件中，然后保存：
- en: '[PRE33]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It should display as follows:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该显示如下：
- en: '![Figure 9.10: Node.js server'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.10：Node.js服务器'
- en: '](img/C14377_09_10.jpg)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_09_10.jpg)'
- en: 'Figure 9.10: Node.js server'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.10：Node.js服务器
- en: 'Run the `http_server.js` file using the following command in your terminal:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中使用以下命令运行 `http_server.js` 文件：
- en: '[PRE34]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then open the browser and go to `http://localhost:3000`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后打开浏览器并访问 `http://localhost:3000`：
- en: '![Figure 9.11: Output from the Node.js server in Chrome'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11：Chrome中Node.js服务器的输出'
- en: '](img/C14377_09_11.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_09_11.jpg)'
- en: 'Figure 9.11: Output from the Node.js server in Chrome'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：Chrome中Node.js服务器的输出
- en: We can see the `Hello World` response in the browser by starting the server.
    We learned how to use a Node.js server and how to write responses to requests.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动服务器，我们可以在浏览器中看到 `Hello World` 响应。我们学习了如何使用Node.js服务器以及如何编写对请求的响应。
- en: Third-Party Modules
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方模块
- en: Node has a huge library of packages where a lot of developers have written and
    published useful modules for you to use. You can simply download these modules
    using `npm` and use them in your projects. There are thousands of packages available
    in the `npm` repository. Let's look at some of the useful third-party packages
    available for Node.js.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 拥有一个庞大的包库，其中许多开发者已经编写并发布了供您使用的有用模块。您可以使用 `npm` 简单地下载这些模块并在您的项目中使用它们。`npm`
    存储库中有数千个包可用。让我们看看一些可用于Node.js的有用第三方包。
- en: Express.js
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Express.js
- en: '`Express` is one of the most popular frameworks of node.js. It is one of the
    reasons why Node.js is so popular. It is a minimal, open-source, and flexible
    web application framework that provides a robust set of features for web and mobile
    applications.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Express` 是 node.js 最受欢迎的框架之一。这也是 Node.js 非常受欢迎的原因之一。它是一个最小化、开源且灵活的 Web 应用程序框架，为
    Web 和移动应用程序提供了一套强大的功能。'
- en: 'You can install it using:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令安装它：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Starting up a web server is extremely simple in `Express`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Express` 中启动 Web 服务器非常简单：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The server is up and running in just four lines of code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器只需四行代码即可启动并运行。
- en: Routing in Express
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Express 中的路由
- en: '`Express` has taken care of routing very well. You can write modularized routes
    in Express. The following code can be used to set up **basic routing**:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Express` 对路由处理得非常好。您可以在 Express 中编写模块化的路由。以下代码可以用来设置**基本路由**：'
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The bodyParser Module
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`bodyParser` 模块'
- en: 'JSON is a very common data sharing format that is used by over 90% of the web
    applications on the internet. Managing JSON is very easy in JavaScript, but when
    it comes to sharing JSON online, it becomes a little more difficult. For this
    purpose, we use the `bodyParser` module. Data is shared as buffer on the internet.
    This module works as a middleware between the request received and your application.
    It converts the buffer to plain JSON and binds it to the request:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是一个非常常见的用于互联网上超过 90% 的网络应用程序的数据共享格式。在 JavaScript 中管理 JSON 非常容易，但当涉及到在线共享
    JSON 时，它就变得稍微困难一些。为此，我们使用 `bodyParser` 模块。数据在互联网上以缓冲区形式共享。此模块作为请求接收和您的应用程序之间的中间件。它将缓冲区转换为纯
    JSON 并将其绑定到请求：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Morgan Logger
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Morgan 日志记录器
- en: '`morgan` is a logging module. Every time a request hits on the server, your
    application logs the request to reveal the real status of your server. A server
    can handle multiple types of requests. So, the application must log all the requests
    to check the health of the server. There are a lot of benefits to using loggers
    on a server. Some of them are listed here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`morgan` 是一个日志模块。每次请求击中服务器时，您的应用程序都会记录请求以揭示服务器真实的状态。服务器可以处理多种类型的请求。因此，应用程序必须记录所有请求以检查服务器的健康状况。在服务器上使用日志记录器有很多好处。其中一些列在这里：'
- en: You can track how many requests the server is processing in a day, week, month,
    and so on.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以跟踪服务器每天、每周、每月等处理了多少请求。
- en: You can see how much time each request is taking to process.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以看到每个请求处理所需的时间。
- en: You can see the types of requests that are getting hit, such as `GET`, `POST`,
    and `PUT`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以看到被击中的请求类型，例如 `GET`、`POST` 和 `PUT`。
- en: You can see what endpoints are being used frequently.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以看到哪些端点被频繁使用。
- en: The module will maintain all the error logs.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模块将维护所有错误日志。
- en: '`morgan` is very easy to use and is a configured middleware `npm` module for
    node applications. You can install it by entering the following command in your
    terminal:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`morgan` 非常容易使用，并且是一个为 Node.js 应用程序配置的中间件 `npm` 模块。您可以通过在终端中输入以下命令来安装它：'
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then use it in your application as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在您的应用程序中如下使用它：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, you just need to add this one line to create a middleware between
    `morgan` and your Node.js application:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您只需添加这一行即可在 `morgan` 和您的 Node.js 应用程序之间创建一个中间件：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will print the following log:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下日志：
- en: '![Figure 9.12: Output from the Node.js server in the terminal'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12：终端中 Node.js 服务器的输出](img/C14377_09_12.jpg)'
- en: '](img/C14377_09_12.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12：终端中 Node.js 服务器的输出](img/C14377_09_12.jpg)'
- en: 'Figure 9.12: Output from the Node.js server in the terminal'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12：终端中 Node.js 服务器的输出
- en: 'In this section, we learned how to use built-in and third-party node packages
    in your project. You learned how to use routing and how to log requests on the
    server. It does not end here, though; you can write your own custom modules as
    well. The only thing you need to do is export one of the entry functions. An example
    is shown in the following figure:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在项目中使用内置和第三方 Node.js 包。您学习了如何使用路由以及如何在服务器上记录请求。但这并不是结束；您还可以编写自己的自定义模块。您需要做的只是导出一个入口函数。以下是一个示例：
- en: '![Figure 9.13: Example of export and require using Node.js'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.13：使用 Node.js 的导出和导入示例](img/C14377_09_13.jpg)'
- en: '](img/C14377_09_13.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.13：终端中 Node.js 服务器的输出](img/C14377_09_13.jpg)'
- en: 'Figure 9.13: Example of export and require using Node.js'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13：使用 Node.js 的导出和导入示例
- en: Think of a module export as a variable. A module export is a variable in which
    you will put some value and you can get the same data wherever your application
    requires this file. You can export functions, JSON, strings, or any type of data
    from any JavaScript file to any other JavaScript file in your application.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块导出视为一个变量。模块导出是一个变量，您可以在其中放置一些值，并且您可以在应用程序需要此文件的地方获取相同的数据。您可以从任何JavaScript文件导出函数、JSON、字符串或任何类型的数据到应用程序中的任何其他JavaScript文件。
- en: Working with Databases
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库一起工作
- en: 'When it comes to the server-side, databases are very important. All the data
    that your applications need to store for future reference have to be stored somewhere.
    In this topic, you will learn how to use two of the most popular databases: MySQL
    and MongoDB.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到服务器端时，数据库非常重要。所有需要存储以供将来参考的应用程序数据都必须存储在某个地方。在本主题中，您将学习如何使用两种最受欢迎的数据库：MySQL和MongoDB。
- en: Setting up Databases
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库
- en: 'In this section, we will work with two of the major database types present
    today. Before proceeding further, let''s go through different ways in which we
    can connect with databases. There are two ways to connect with databases:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将处理今天存在的两种主要数据库类型。在继续之前，让我们看看我们可以用哪些方式与数据库建立连接。与数据库建立连接有两种方式：
- en: 'Locally: When a database server is running on your machine.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地：当数据库服务器在您的机器上运行时。
- en: 'Remotely: When a database server is running on some other machine and you are
    accessing it through the internet.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程：当数据库服务器在另一台机器上运行，并且您通过互联网访问它时。
- en: You can have your database server running somewhere in the cloud and you can
    access it using a URL along with credentials. But for this section, let's set
    up both databases locally on the machine and let's connect to them using Node.js.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将数据库服务器运行在云中的某个地方，并使用带有凭证的URL来访问它。但在这个部分，让我们在本机上设置两个数据库，并使用Node.js来连接它们。
- en: The installation of both databases is pretty straightforward. You can download
    the latest bundles from their official websites and install them as you install
    other applications. For installation guidelines, you can follow their official
    documentation, which is very easy to understand. They have also covered installation
    on all different types of platforms, such as Windows and Linux.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数据库的安装都非常简单。您可以从它们的官方网站下载最新的捆绑包，并像安装其他应用程序一样安装它们。对于安装指南，您可以遵循它们的官方文档，它非常易于理解。它们还涵盖了在所有不同类型的平台上的安装，例如Windows和Linux。
- en: 'MySQL : [https://packt.live/32ypsRH](https://packt.live/32ypsRH) MongoDB: [https://packt.live/2PY7SDV](https://packt.live/2PY7SDV)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'MySQL: [https://packt.live/32ypsRH](https://packt.live/32ypsRH) MongoDB: [https://packt.live/2PY7SDV](https://packt.live/2PY7SDV)'
- en: Connecting with Databases
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与数据库连接
- en: After installing, you have to start both the database servers and configure
    a user. This is the user whose credentials you will use to get access to the database.
    For learning purposes, give this user administrator privileges so that you will
    have all the permissions to perform various types of actions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您必须启动两个数据库服务器并配置一个用户。这个用户就是您将使用其凭证来访问数据库的用户。出于学习目的，请给这个用户管理员权限，这样您将拥有执行各种类型操作的所有权限。
- en: 'In order to connect with databases, we require some information about the server
    machine:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与数据库建立连接，我们需要一些关于服务器机器的信息：
- en: '**Host**: The host will be the domain name or the IP address of the server
    where the database is running.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机**：主机将是数据库运行的服务器的域名或IP地址。'
- en: '**Port**: This will be the port number on which the database server is listening.
    By default, MySQL database runs on port 3306 and MongoDB runs on port 27017\.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口**：这将是在数据库服务器上监听的端口号。默认情况下，MySQL数据库运行在端口3306，MongoDB运行在端口27017。'
- en: '**User**: Here, we have to specify the username of any active user of the database.
    We always create an administrator user just after finishing the installation.
    It is not recommended to use an administrator account with applications in production,
    but for learning purposes, we can use it. In a production environment, we must
    create a database user that has limited and necessary access only.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户**：在这里，我们必须指定数据库任何活跃用户的用户名。我们总是在安装完成后创建一个管理员用户。不建议在生产环境中使用管理员账户，但出于学习目的，我们可以使用它。在生产环境中，我们必须创建一个数据库用户，该用户只有有限的和必要的访问权限。'
- en: '**Password**: The password of the user will go here.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码**：用户的密码将在这里。'
- en: '**Database**: Here, we have to mention the name of the database with which
    we want to initialize the connection.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库**：在这里，我们必须提到我们想要初始化连接的数据库名称。'
- en: 'We have to specify this configuration to the database driver that we will use
    when making connection with database. For example, when making a connection with
    MySQL, we have to specify this configuration:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将此配置指定给我们将在与数据库建立连接时使用的数据库驱动程序。例如，在连接到MySQL时，我们必须指定此配置：
- en: '[PRE42]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the port is not mentioned, it will pick the default value of the port number.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定端口号，它将选择端口号的默认值。
- en: We will learn more about how to make a connection and how to use this connection
    to fetch and save data for both MySQL and MongoDB in the next sections.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何建立连接以及如何使用此连接从MySQL和MongoDB中获取和保存数据。
- en: MySQL
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL
- en: MySQL is a relational SQL database management system. It is one of the oldest,
    most successful, and most popular open-source databases in the world. It is widely
    used for developing various web-based software applications.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 是一个关系型 SQL 数据库管理系统。它是世界上历史最悠久、最成功、最受欢迎的开源数据库之一。它被广泛用于开发各种基于 Web 的软件应用程序。
- en: The MySQL library is one of the most widely used `npm` libraries. Millions of
    developers use this library worldwide. The best way to learn about configuring
    the database is with practice. Let's go through a very useful exercise that will
    help you to learn about database setup in any Node.js project.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 库是最广泛使用的 `npm` 库之一。数百万的开发者在全球范围内使用这个库。了解配置数据库的最佳方式是通过实践。让我们通过一个非常实用的练习来学习在任何
    Node.js 项目中设置数据库的方法。
- en: 'Exercise 9.06: Install, Connect, and Process Responses with a MySQL Server'
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.06：使用 MySQL 服务器安装、连接和处理响应
- en: 'Let''s do an exercise in which we will install a MySQL driver and connect it
    to a MySQL server. We will also take a look at how to fire MySQL queries to the
    database and how to process the responses:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个练习，我们将安装一个 MySQL 驱动程序并将其连接到 MySQL 服务器。我们还将查看如何向数据库发送 MySQL 查询以及如何处理响应：
- en: 'In order to use this module with node, you can install it into your project
    as a dependency:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用此模块与 node 一起，您可以将它作为依赖项安装到您的项目中：
- en: '[PRE43]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After installing it, you can require it in the project using:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，您可以在项目中使用以下方式引入它：
- en: '[PRE44]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After importing it into the project, you have to make a connection with the
    database. For that, you can use the `createConnection` method.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将其导入到项目中后，您必须与数据库建立连接。为此，您可以使用 `createConnection` 方法。
- en: 'If everything went fine, the connection will be ready. You can fire the MySQL
    query using:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，连接将就绪。您可以使用以下方式发送 MySQL 查询：
- en: '[PRE45]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Before closing the connection, note that port 3307 is the author's local port.
    The standard MySQL port is 3306.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在关闭连接之前，请注意端口号 3307 是作者的本地端口。标准的 MySQL 端口号是 3306。
- en: '![Figure 9.14: Passing credentials in MySQL Server'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.14：在 MySQL 服务器中传递凭证'
- en: '](img/C14377_09_14.jpg)'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14377_09_14.jpg]'
- en: 'Figure 9.14: Passing credentials in MySQL Server'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.14：在 MySQL 服务器中传递凭证
- en: 'Make sure that you pass the credentials of the user you created earlier while
    going through the previous section (*Setting Up Databases*):'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在浏览上一节（*设置数据库*）时传递您之前创建的用户凭证：
- en: '[PRE46]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When done querying the database, you can close the connection using:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查询数据库完成后，您可以使用以下方式关闭连接：
- en: '[PRE47]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To check the connection, use the following query to the database:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查连接，请使用以下查询到数据库：
- en: '[PRE48]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this exercise, we connected to a MySQL server and fired MySQL queries to
    the database to process the responses.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们连接到 MySQL 服务器并向数据库发送 MySQL 查询以处理响应。
- en: MongoDB
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB
- en: MongoDB is a leading open-source NoSQL database. It is a document-oriented database
    program written in C++. It uses a JSON-like structure to store data, which is
    why it is most popular for use with node apps. It is also a part of the MEAN stack,
    which is one of the most popular tech stacks in the world today. The MEAN stack
    is a combination of the four major technologies of MongoDB, Express.js, AngularJS,
    and Node.js. In MongoDB, tables are referred to as collections, and data rows
    are referred to as documents. Documents are formatted in JSON format and are,
    by default, schema independent.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是领先的开源 NoSQL 数据库。它是一个用 C++ 编写的面向文档的数据库程序。它使用类似 JSON 的结构来存储数据，这也是它最常用于与
    node 应用程序一起使用的原因。它也是 MEAN 栈的一部分，MEAN 栈是目前世界上最受欢迎的技术栈之一。MEAN 栈是 MongoDB、Express.js、AngularJS
    和 Node.js 四大主要技术的组合。在 MongoDB 中，表被称为集合，数据行被称为文档。文档以 JSON 格式进行格式化，并且默认情况下是模式无关的。
- en: Note
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to run the local MongoDB server first, and then get the URI to the
    connection. A URI contains the protocol, authentication, port, and database name
    a single string. You will learn about the format of the URI soon.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 确保首先运行本地MongoDB服务器，然后获取连接的URI。一个URI包含协议、认证、端口和数据库名称，它是一个单一的字符串。你很快就会了解URI的格式。
- en: 'Exercise 9.07: Installing and Configuring a Connection in MongoDB'
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.07：在MongoDB中安装和配置连接
- en: 'Let''s write some code in Node.js to help us connect our application with MongoDB.
    After this exercise, you will be able to install MongoDB and configure a connection
    with MongoDB using Node.js:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Node.js中编写一些代码来帮助我们连接我们的应用程序与MongoDB。完成这个练习后，你将能够使用Node.js安装MongoDB并配置与MongoDB的连接：
- en: 'In order to install the driver, use the following command in your terminal:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安装驱动程序，请在你的终端中使用以下命令：
- en: '[PRE49]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, in your application, make it a requirement:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在你的应用程序中，使其成为一个要求：
- en: '[PRE50]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then you have to prepare a connection URL. It must be in the following form:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你必须准备一个连接URL。它必须采用以下形式：
- en: '[PRE51]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can use this URI to connect with MongoDB:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用此URI连接到MongoDB：
- en: '[PRE52]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will be displayed as follows:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将显示如下：
- en: '![Figure 9.15: Successful connection with MongoDB'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15：与MongoDB成功连接](img/C14377_09_15.jpg)'
- en: '](img/C14377_09_15.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_09_15.jpg)'
- en: 'Figure 9.15: Successful connection with MongoDB'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：与MongoDB成功连接
- en: Make sure you pass the credentials of the user you created earlier while going
    through the *Setting Up Databases* section.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在通过“设置数据库”部分时传递你之前创建的用户凭据。
- en: In this exercise, you learned about one of the main database that we have in
    the industry today. So far, you have learned about what MySQL and MongoDB are
    and how to use them with node apps.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你了解了我们今天在行业中拥有的主要数据库之一。到目前为止，你已经了解了MySQL和MongoDB是什么以及如何使用它们与Node.js应用一起使用。
- en: Making Real-Time Web Apps
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作实时Web应用
- en: Our world is very dynamic, and we are living in an era where live communication
    is crucial. Whether talking to another person in real life or following cricket
    scores, real-time communication, and data are very important. The best thing about
    Node.js is its support for streams and WebSocket. Node.js is the perfect tool
    for creating a real-time web application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的世界非常动态，我们生活在一个实时通信至关重要的时代。无论是与现实生活中的人交谈还是关注板球比分，实时通信和数据都非常重要。Node.js最好的地方就是其对流和WebSocket的支持。Node.js是创建实时Web应用的完美工具。
- en: WebSocket
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket
- en: WebSocket provides a continuous full-duplex communication channel. This means
    that both the server and the client communicate and exchange data at the same
    time over a single TCP connection. With WebSocket, clients do not have to refresh
    a page to see changes. The server will push the date back to the client. WebSocket
    helps facilitate the dynamic flow of connections, resulting in communication at
    both ends being achieved at considerable speeds. It means that you can now receive
    and send data on one connection only.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket提供了一个连续的全双工通信通道。这意味着服务器和客户端可以在单个TCP连接上同时进行通信和交换数据。使用WebSocket，客户端不需要刷新页面就能看到变化。服务器会将数据推送到客户端。WebSocket有助于促进连接的动态流动，使得两端通信都能以相当高的速度进行。这意味着你现在只需一个连接就可以接收和发送数据。
- en: 'A server can configure the client in real-time because of the lack of lag in
    communication, and the client can continuously share its data with the server,
    which will allow it to analyze and optimize the project:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通信中没有延迟，服务器可以实时配置客户端，并且客户端可以持续将其数据与服务器共享，这将允许它分析和优化项目：
- en: '![Figure 9.16: Duplex tunnel between client and server with WebSocket connection'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16：使用WebSocket连接的客户端和服务器之间的全双工隧道](img/C14377_09_16.jpg)'
- en: '](img/C14377_09_16.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_09_16.jpg)'
- en: 'Figure 9.16: Duplex tunnel between client and server with WebSocket connection'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：使用WebSocket连接的客户端和服务器之间的全双工隧道
- en: The WebSocket connection is made through a process known as the WebSocket handshake.
    This process starts with the client initiating a regular HTTP request to the server.
    Any additional information will be included in the header of this request, which
    informs the server that the client wishes to establish a WebSocket connection.
    If the server has WebSocket configured, it will accept the request. When the handshake
    is complete, the initial HTTP connection is replaced by a WebSocket connection.
    This connection uses the same underlying TCP/IP connection that HTTP uses. Now,
    either the frontend or backend can start sending data.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket连接是通过一个称为WebSocket握手的过程来建立的。这个过程从客户端向服务器发起一个常规HTTP请求开始。任何附加信息都将包含在这个请求的头部中，告知服务器客户端希望建立WebSocket连接。如果服务器已配置WebSocket，它将接受请求。当握手完成时，初始的HTTP连接将被WebSocket连接所取代。这个连接使用与HTTP相同的底层TCP/IP连接。现在，无论是前端还是后端都可以开始发送数据。
- en: Socket.IO
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket.IO
- en: 'Socket.IO is a library that enables real-time, bidirectional, and event-based
    communication between the browser and the server. It is built to make the use
    of WebSocket easier. It only requires two things:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO是一个库，它使得浏览器和服务器之间实现实时、双向和基于事件的通信变得容易。它被构建来简化WebSocket的使用。它只需要两件事：
- en: A Node.js server
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Node.js服务器
- en: A JavaScript library for the browser
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于浏览器的JavaScript库
- en: It supports auto-connect, which means if one client disconnects for any reason,
    it will continuously try to reconnect with the server.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持自动连接，这意味着如果任何客户端由于任何原因断开连接，它将不断尝试与服务器重新连接。
- en: 'Let''s look at how to install it in your project. Use the following command
    in your terminal:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在你的项目中安装它。在你的终端中使用以下命令：
- en: '[PRE53]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, configure it with your app server:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用你的应用服务器配置它：
- en: '[PRE54]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`socket.io` is now configured with the app server. You can bind events and
    listeners using the `io` variable. Now, whenever a new client connects with the
    server, it executes a connection event where you can get all the information regarding
    the sockets:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`现在已与应用服务器配置。你可以使用`io`变量绑定事件和监听器。现在，每当新的客户端与服务器连接时，它将执行一个连接事件，你可以获取有关套接字的所有信息：'
- en: '[PRE55]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That's it. It is really that simple to configure socket.io with your app server.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。配置socket.io与你的应用服务器真的非常简单。
- en: 'Exercise 9.08: Building a Chat Application'
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.08：构建聊天应用程序
- en: 'Let''s make a real-time chat application using node and socket.io. In this
    exercise, we will create an app that will allow us to start multiple sessions
    for different users and develop a real-time chat experience between users. This
    will be a very basic and simple chat application where you will be able to create
    a group where:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用node和socket.io制作一个实时聊天应用程序。在这个练习中，我们将创建一个应用程序，允许我们为不同的用户启动多个会话，并在用户之间开发实时聊天体验。这将是一个非常基础和简单的聊天应用程序，你将能够创建一个群组，其中：
- en: You can chat in real-time.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以进行实时聊天。
- en: More than one person can join the group.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个人可以加入这个群组。
- en: Each member will be assigned fake names by default.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个成员默认将分配一个假名字。
- en: You can change your name.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以更改你的名字。
- en: You can see who is typing at any time.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以看到任何时间谁正在输入。
- en: 'Before proceeding further, let''s go through the file structure of our project:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步操作之前，让我们来看看我们项目的文件结构：
- en: '![Figure 9.17: File structure of this exercise'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.17：本练习的文件结构'
- en: '](img/C14377_09_17.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_09_17.jpg)'
- en: 'Figure 9.17: File structure of this exercise'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17：本练习的文件结构
- en: 'There are two main files:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要文件：
- en: '`App.js`: This file contains all the server-side configuration. In this file,
    we will configure `socket.io`, write all events and listeners, and perform the
    routing of the requests.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.js`：此文件包含所有服务器端配置。在这个文件中，我们将配置`socket.io`，编写所有事件和监听器，并执行请求的路由。'
- en: '`Chat.js`: This file contains all the code required for the client-side.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chat.js`：此文件包含客户端所需的所有代码。'
- en: 'Start the server and configure it to use `socket.io` in `app.js` by adding
    the following code:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器，并在`app.js`中配置它以使用`socket.io`，添加以下代码：
- en: '[PRE56]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, WebSocket is configured with the server. Let''s create some events and
    listeners that will help us communicate with the client (frontend) and listen
    on every connection:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，WebSocket已与服务器配置。让我们创建一些事件和监听器，这将帮助我们与客户端（前端）通信并监听每个连接：
- en: '[PRE57]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The application is listening for two events, `typing` and `change_username`.
    They will be executed whenever a socket emits these events.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序正在监听两个事件，`typing`和`change_username`。每当套接字发出这些事件时，它们将被执行。
- en: Now, you are done with your server-side code. Let's work on the frontend (client).
    First, import the socket.io library to the client-side. After a successful configuration
    of the server, you can open `http://localhost:3000/socket.io/socket.io.js` in
    your browser, which will download a script file. This is the file that you have
    to import on the client-side.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你已经完成了你的服务器端代码。让我们来处理前端（客户端）。首先，将 socket.io 库导入到客户端。在服务器成功配置后，你可以在浏览器中打开
    `http://localhost:3000/socket.io/socket.io.js`，这将下载一个脚本文件。这就是你需要在客户端导入的文件。
- en: 'Add the following `script` tag inside `index.html`:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `index.html` 中添加以下 `script` 标签：
- en: '[PRE58]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The complete file will look like this:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的文件将看起来像这样：
- en: '[PRE59]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Let's configure the client-side by connecting the client-side to the server.
    Create a file named `chat.js` and make sure that both `index.html` and `chat.js`
    are in the same directory or folder. If you want to move the files to different
    locations, then you have to reflect this in the `import` link in your `index.html`
    as well.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过将客户端连接到服务器来配置客户端。创建一个名为 `chat.js` 的文件，并确保 `index.html` 和 `chat.js` 都在同一目录或文件夹中。如果你想要将文件移动到不同的位置，那么你必须在
    `index.html` 中的 `import` 链接中反映这一点。
- en: 'You have to declare the link to the server where the request will be forwarded
    to in `chat.js`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须在 `chat.js` 中声明请求将被转发到的服务器链接：
- en: '[PRE60]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We are using `localhost` because the server is running on our local machine.
    It listens for events that are executed by the server. In this case, we need to
    listen for `keyboard typing`. Enter the following code snippet below the declared
    connection in the `chat.js` file:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `localhost` 是因为服务器运行在我们的本地机器上。它监听由服务器执行的事件。在这种情况下，我们需要监听 `键盘输入`。在 `chat.js`
    文件中声明的连接下方输入以下代码片段：
- en: '[PRE61]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Execute the server file with the following command in your terminal to start
    the server and listen to all requests:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端中执行以下命令以启动服务器并监听所有请求：
- en: '[PRE62]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, open two instances of Chrome and visit `http://localhost:3000`. These
    two instances of Chrome will create two sessions, which will mimic two different
    users. Just start typing and sending messages to have a good conversation in real-time:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开两个 Chrome 实例并访问 `http://localhost:3000`。这两个 Chrome 实例将创建两个会话，这将模拟两个不同的用户。只需开始输入并发送消息，就可以进行实时愉快的对话：
- en: Note
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The code will be available in the GitHub repository for this book at [https://packt.live/36KWlh0](https://packt.live/36KWlh0).
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码将在本书的 GitHub 仓库中提供，网址为 [https://packt.live/36KWlh0](https://packt.live/36KWlh0)。
- en: '![Figure 9.18: Two Chrome sessions conducting a real-time chat'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.18：两个进行实时聊天的 Chrome 会话'
- en: '](img/C14377_09_18.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_09_18.jpg)'
- en: 'Figure 9.18: Two Chrome sessions conducting a real-time chat'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18：两个进行实时聊天的 Chrome 会话
- en: As you can see in this figure, there are two sessions of Chrome running. These
    two sessions represent two users. Both can chat in real-time. They can even see
    whether the other person is typing or not.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，有两个 Chrome 会话正在运行。这两个会话代表两个用户。他们都可以进行实时聊天。他们甚至可以看到对方是否在输入。
- en: In this section, you were introduced to building real-time web applications
    in node using socket.io and you built a cool chat app.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用 socket.io 在 node 中构建实时 Web 应用程序，并构建了一个酷炫的聊天应用程序。
- en: 'Activity 9.01: Create a Web Application to Upload, Store, and Save Image Details'
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 9.01：创建一个上传、存储和保存图像详情的 Web 应用程序
- en: A major part of web development is uploading media and referring to it in the
    future. In this activity, you'll create a web application that will allow you
    to upload images to a server and store them in a directory. To make it even more
    challenging, you'll need to save the image details in a database for further use
    and analytics.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发的一个主要部分是上传媒体并在将来引用它。在这个活动中，你将创建一个 Web 应用程序，允许你将图像上传到服务器并在目录中存储它们。为了使其更具挑战性，你还需要将图像详情保存到数据库中以便进一步使用和分析。
- en: Note
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This activity requires a MySQL database server to be running on the system.
    Please make sure that a MySQL server is installed and running on your machine
    before executing this script.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动需要系统上运行 MySQL 数据库服务器。请在执行此脚本之前确保已安装并运行 MySQL 服务器。
- en: 'When the request reaches the server, it will first rename the file and then
    upload the image to the directory, before sending the path of the images as a
    response back to the client:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达服务器时，它将首先重命名文件，然后将图像上传到目录中，在将图像路径作为响应发送回客户端之前：
- en: '![Figure 9.19: Output of the node server'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.19：node 服务器的输出'
- en: '](img/C14377_09_19.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_09_19.jpg)'
- en: 'Figure 9.19: Output of the node server'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19：node服务器的输出
- en: 'You should get the following log from the server-side:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从服务器端获得以下日志：
- en: '![Figure 9.20: File is uploaded in the image''s directory on the server'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20：文件已上传到服务器上的图像目录'
- en: '](img/C14377_09_20.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_09_20.jpg]'
- en: 'Figure 9.20: File is uploaded in the image''s directory on the server'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20：文件已上传到服务器上的图像目录
- en: 'Once the file is uploaded to the directory successfully, you should see the
    following MySQL output:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件成功上传到目录，您应该看到以下MySQL输出：
- en: '![Figure 9.21: MySQL output'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.21：MySQL输出'
- en: '](img/C14377_09_21.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_09_21.jpg]'
- en: 'Figure 9.21: MySQL output'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21：MySQL输出
- en: Note
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Details about the image file are also successfully stored in the database.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图像文件的详细信息也成功存储在数据库中。
- en: 'Here are the steps that will help you complete the activity:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些步骤将帮助您完成活动：
- en: Define the directory structure.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义目录结构。
- en: Import all of the dependencies.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所有依赖项。
- en: Configure the Node.js `morgan` module to log each of the request details in
    the console.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Node.js的`morgan`模块，以在控制台记录每个请求的详细信息。
- en: Configure your application to use the MySQL database.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置您的应用程序以使用MySQL数据库。
- en: Establish the database connection to configure `Multer`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立数据库连接以配置`Multer`。
- en: Add routing to the application.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序添加路由。
- en: Start the server.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器。
- en: Send a request to upload the image to the server.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向服务器发送请求上传图像。
- en: Note
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 738.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第738页找到。
- en: Summary
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far, you have covered nearly all the basics of web development with Node.js.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经几乎涵盖了使用Node.js进行Web开发的全部基础知识。
- en: You started with an introduction to Node.js, wrote your first program, and ran
    it. You learned about Node's package manager and the Node.js environments. You
    were guided through some of the useful built-in and third-party Node.js modules
    and discovered how you can import these modules in your application and use common
    modules such as `body parse` and `auth`. You created connections with databases
    using Node.js and learned how to make queries in the databases.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 您从Node.js的介绍开始，编写了您的第一个程序，并运行了它。您了解了Node的包管理器和Node.js环境。您被引导了解一些有用的内置和第三方Node.js模块，并发现了如何在您的应用程序中导入这些模块以及如何使用常见的模块，如`body
    parse`和`auth`。您使用Node.js与数据库建立连接，并学习了如何在数据库中执行查询。
- en: Finally, you learned how to make a real-time web application and learned how
    to build a chat application. There are a lot of concepts still to cover because
    node is huge, however, you have the required knowledge to explore node further
    with ease. In the next chapter, you will learn how to use requests to communicate
    with other services. You will look into different types of requests and how to
    process and display data. You will also take a look at **RESTful APIs**.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您学习了如何制作实时网络应用程序，并学习了如何构建聊天应用程序。由于Node.js内容庞大，还有很多概念需要覆盖，但是您已经拥有了进一步轻松探索Node.js所需的知识。在下一章中，您将学习如何使用请求与其他服务进行通信。您将了解不同类型的请求以及如何处理和显示数据。您还将了解**RESTful
    API**。
- en: Let's move on to the next chapter.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一章。
