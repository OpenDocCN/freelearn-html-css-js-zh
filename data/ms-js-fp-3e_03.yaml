- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Starting Out with Functions – A Core Concept
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从函数开始 – 一个核心概念
- en: In [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037), *Thinking Functionally*,
    we discussed an example of FP thinking, but now, let’s look at the basics and
    review functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第2章*](B19301_02.xhtml#_idTextAnchor037) *函数式思考* 中，我们讨论了一个函数式编程思考的例子，但现在，让我们来看看基础知识并回顾一下函数。
- en: 'In this chapter, we’ll do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Discuss functions in JavaScript, including how to define them, with a particular
    focus on arrow functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论JavaScript中的函数，包括如何定义它们，特别关注箭头函数
- en: Learn about currying and functions as first-class objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 currying 和函数作为一等对象
- en: Explore several ways of using functions in an FP way
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索几种以函数式编程方式使用函数的方法
- en: After going through all this content, you’ll be up to date with the generic
    and specific concepts relating to functions, which are, after all, at the core
    of FP!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习完所有这些内容后，你将了解与函数相关的通用和特定概念，毕竟，函数是函数式编程的核心！
- en: All about functions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有关于函数的内容
- en: 'Let’s start with a short review of functions in JavaScript and their relationship
    to FP concepts. We will begin with something that we mainly mentioned in the *Functions
    as first-class objects* section of [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015)*,
    Becoming Functional,* and again in a couple of places in [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037),
    *Thinking Functionally*, and then go on to several considerations about their
    usage in actual coding. In particular, we’ll be looking at the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对 JavaScript 中的函数及其与函数式编程概念的关系的简要回顾开始。我们将从主要在第1章 *成为函数式* 的 *函数作为一等对象* 部分，以及在
    *第2章* *函数式思考* 的几个地方提到的东西开始，然后继续讨论它们在实际编码中的使用。特别是，我们将关注以下内容：
- en: Some basic concepts about lambda calculus, which is the theoretical basis for
    FP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 lambda 演算的一些基本概念，它是函数式编程的理论基础
- en: Arrow functions, which are the most direct translation of lambda calculus into
    JavaScript
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数，这是 lambda 演算直接翻译到 JavaScript 的最直接方式
- en: Using functions as first-class objects, a key concept in FP
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为一等对象使用，这是函数式编程中的一个关键概念
- en: Of lambdas and functions
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 lambda 和函数
- en: In lambda calculus terms, a function can look like λ*x*.2**x*. The understanding
    is that the variable after the λ character (the Greek letter *lambda* in lowercase)
    is the parameter for the function, and the expression after the dot is where you
    would replace whatever value is passed as an argument. Later in this chapter,
    we will see that this particular example could be written as `(x) => 2*x` in JavaScript
    in arrow function form, which, as you can see, is very similar.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 lambda 演算的术语中，一个函数可以看起来像 λ*x*.2**x*。理解是 λ 字符后面的变量（希腊字母 *lambda* 的小写形式）是函数的参数，点号后面的表达式是你要替换传递作为参数的任何值的所在位置。在本章的后面部分，我们将看到这个特定的例子可以用
    JavaScript 的箭头函数形式 `(x) => 2*x` 来编写，正如你所看到的，它非常相似。
- en: An alliterative aid
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个押韵的辅助工具
- en: 'If you sometimes wonder about the difference between arguments and parameters,
    a mnemonic with some alliteration may help: *Parameters are Potential, Arguments
    are Actual*. Parameters are placeholders for potential values that will be passed,
    and arguments are the actual values passed to the function. In other words, when
    you define the function, you list its parameters, and when you call it, you provide
    arguments.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有时想知道参数和参数之间的区别，一个带有一些押韵的助记符可能会有所帮助：*参数是潜在的，参数是实际的*。参数是潜在值的占位符，这些值将被传递，而参数是传递给函数的实际值。换句话说，当你定义函数时，你列出它的参数，当你调用它时，你提供参数。
- en: Applying a function means you provide an actual argument to it, which is written
    in the usual way, using parentheses. For example, (λ*x*.2**x*)(3) would be calculated
    as 6\. What’s the equivalent of these lambda functions in JavaScript? That’s an
    interesting question! There are several ways of defining functions, and not all
    have the same meaning.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用一个函数意味着你向它提供一个实际参数，这通常以括号内的方式书写。例如，(λ*x*.2**x*)(3) 将被计算为 6。这些 lambda 函数在 JavaScript
    中的等效函数是什么？这是一个有趣的问题！定义函数的方式有几种，并且它们并不都具有相同的意义。
- en: 'In how many ways can you define a function in JavaScript? The answer is probably
    in more ways than you thought! (A good article that shows the many ways of defining
    functions, methods, and more is *The Many Faces of Functions in JavaScript*, by
    Leo Balter and Rick Waldron, at [bocoup.com/blog/the-many-faces-of-functions-in-javascript](http://bocoup.com/blog/the-many-faces-of-functions-in-javascript)
    – give it a look!) At the very least, you could write the following – and I’ll
    use vanilla JavaScript because here types aren’t a concern:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，你可以有多少种方式定义函数？答案可能比你想象的要多！（一篇展示定义函数、方法等多种方式的优秀文章是 *JavaScript
    中函数的多种面貌*，作者为 Leo Balter 和 Rick Waldron，可在 [bocoup.com/blog/the-many-faces-of-functions-in-javascript](http://bocoup.com/blog/the-many-faces-of-functions-in-javascript)
    上阅读——值得一读！）至少，你可以写出以下内容——我将使用纯 JavaScript，因为在这里类型不是问题：
- en: 'A named function declaration: `function` `first(...) {...};`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名函数声明：`function` `first(...) {...};`
- en: 'An anonymous function expression: `var second =` `function(...) {...};`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数表达式：`var second =` `function(...) {...};`
- en: 'A named function expression: `var third = function` `someName(…) {...};`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名函数表达式：`var third = function` `someName(…) {...};`
- en: 'An immediately-invoked expression: `var fourth = (function() { ...; return
    function(...) {...}; })();`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即调用的表达式：`var fourth = (function() { ...; return function(...) {...}; })();`
- en: 'A function constructor: `var fifth =` `new Function(...);`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数构造器：`var fifth =` `new Function(...);`
- en: 'An arrow function: `var sixth = (...) => {...};`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数：`var sixth = (...) => {...};`
- en: If you wanted, you could add object method declarations since they also imply
    functions, but the preceding list should be enough.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以添加对象方法声明，因为它们也意味着函数，但前面的列表应该足够了。
- en: More function types
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更多函数类型
- en: JavaScript also allows us to define `function*(...) {...}`) that return a `Generator`
    object and `async` functions that are a mix of generators and promises. You can
    read more about them at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function)
    and [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function),
    respectively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 还允许我们定义 `function*(...) {...}`) 返回一个 `Generator` 对象和 `async` 函数，它们是生成器和承诺的混合体。你可以在
    [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function)
    和 [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
    分别了解更多关于它们的信息。
- en: 'What’s the difference between all these ways of defining functions, and why
    should we care? Let’s go over them one by one:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些定义函数的方式之间有什么区别，为什么我们应该关心？让我们逐一探讨：
- en: The first definition, `function first(...) {...}`, a standalone declaration
    starting with the `function` keyword, is probably the most used in JavaScript
    and defines a function named `first` (that is, `first.name==="first"`). Because
    of `var` definition; with `let` or `const`, hoisting doesn’t apply. You can read
    more about hoisting at [developer.mozilla.org/en-US/docs/Glossary/Hoisting](http://developer.mozilla.org/en-US/docs/Glossary/Hoisting).
    Remember that it applies only to declarations, not to initializations.)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种定义，`function first(...) {...}`，是一个以 `function` 关键字开始的独立声明，可能是 JavaScript
    中使用最广泛的方式，它定义了一个名为 `first` 的函数（即 `first.name==="first"`）。由于 `var` 定义；使用 `let`
    或 `const` 时，不会应用提升。你可以在 [developer.mozilla.org/en-US/docs/Glossary/Hoisting](http://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
    上了解更多关于提升的信息。请记住，它仅适用于声明，而不适用于初始化。
- en: 'The `second = function(...) {...}` definition, which assigns a function to
    a variable, also produces a function, but an *anonymous* (that is, not named)
    one. However, many JavaScript engines can deduce what the name should be and will
    then set `second.name === "second"`. (Look at the following code, which shows
    a case where the anonymous function has no name assigned.) Since the assignment
    isn’t hoisted, the function will only be accessible after the assignment has been
    executed. Also, you’d probably prefer defining the variable with `const` rather
    than `var`, because you wouldn’t (shouldn’t) be changing the function – take a
    look at the ESLint `no-var` and `prefer-const` rules to enforce this:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数赋值给变量的`second = function(...) {...}`定义，也产生了一个函数，但是一个*匿名*（即没有名字）的函数。然而，许多JavaScript引擎可以推断出应该使用的名字，然后设置`second.name
    === "second"`。（查看以下代码，它显示了一个匿名函数没有分配名字的情况。）由于赋值没有提升，函数只有在赋值执行之后才能访问。此外，您可能更喜欢使用`const`而不是`var`来定义变量，因为您不会（不应该）更改函数——查看ESLint的`no-var`和`prefer-const`规则以强制执行此操作：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The third definition, `third = function someName(…) {...}`, is the same as
    the second, except that the function now has its own name: `third.name === "someName"`.
    The name of a function is relevant when you want to call it and is needed for
    recursive calls; we’ll return to this in [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172),
    *Designing Functions*. If you just want a function for, say, a callback, you can
    use one without a name. However, note that named functions are more easily recognized
    in an error traceback, the kind of listing you use when trying to understand what
    happened, and which function called what.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个定义，`third = function someName(…) {...}`，与第二个定义相同，只是函数现在有自己的名字：`third.name
    === "someName"`。当您想要调用函数时，函数的名字是相关的，并且在递归调用时是必需的；我们将在[*第9章*](B19301_09.xhtml#_idTextAnchor172)，*设计函数*中回到这一点。如果您只是需要一个用于，比如说，回调的函数，您可以使用一个没有名字的函数。然而，请注意，有名字的函数在错误跟踪中更容易被识别，这是您在试图理解发生了什么以及哪个函数调用了哪个函数时使用的列表。
- en: 'The fourth definition, `fourth = (function() { ...; return function(...) {...};
    })()`, with an immediately-invoked expression, lets you use a closure. Going back
    to the counter-making function that we saw in the *Closures* section of [*Chapter
    1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*, we could write something
    like the following. An inner function can use variables or other functions, defined
    in its outer function, in a private, encapsulated way. The outer function receives
    an argument (`77`, in this case) that is used as the initial value of `count`
    (if no initial value is provided, we start at `0`). The inner function can access
    `count` (because of the closure), but the variable cannot be accessed anywhere
    else. In all aspects, the returned function is common – the only difference is
    its access to private elements. This is also the basis of the **module** pattern:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个定义，`fourth = (function() { ...; return function(...) {...}; })()`，使用立即执行的表达式，允许您使用闭包。回到我们在[*第1章*](B19301_01.xhtml#_idTextAnchor015)*，*成为函数式开发者*部分的*闭包*部分中看到的计数器制作函数，我们可以编写如下内容。内部函数可以使用在外部函数中定义的变量或其他函数，以私有、封装的方式使用。外部函数接收一个参数（在这种情况下是`77`），用作`count`的初始值（如果没有提供初始值，我们从头开始`0`）。内部函数可以访问`count`（因为闭包），但变量不能在其他任何地方访问。在所有方面，返回的函数都是通用的——唯一的区别是它对私有元素的访问。这也是**模块**模式的基础：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The fifth definition, `fifth = new Function(...)`, isn’t safe and you shouldn’t
    use it! You pass the names of the arguments first, then the actual function body
    as a string, and the equivalent of `eval()` is used to create the function – this
    allows many dangerous hacks, so don’t do this! (Also, TypeScript cannot deduce
    the type of the produced function; it just assumes the generic `Function` type.)
    Just to whet your curiosity, let’s look at an example of rewriting the very simple
    `sum3()` function we saw back in the *Spread* section of [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015)*,*
    *Becoming Functional*:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个定义，`fifth = new Function(...)`，是不安全的，您不应该使用它！您首先传递参数的名字，然后是实际的函数体作为字符串，然后使用`eval()`的等效功能来创建函数——这允许许多危险的漏洞，所以不要这样做！（此外，TypeScript无法推断出产生的函数的类型；它只是假设通用的`Function`类型。）为了激发您的兴趣，让我们看看重写我们在[*第1章*](B19301_01.xhtml#_idTextAnchor015)*，*成为函数式开发者*部分的*展开*部分中看到的非常简单的`sum3()`函数的例子：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Quirks of eval()
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`的怪癖'
- en: This definition is not only unsafe but has some other quirks – they don’t create
    closures with their creation contexts, so they are always global. See [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    for more on this, but remember that this way of creating functions isn’t a good
    idea!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义不仅不安全，还有一些其他的小问题——它们不会创建具有创建上下文的闭包，因此它们总是全局的。有关更多信息，请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)，但请记住，这种方式创建函数并不是一个好主意！
- en: Finally, the last definition, `sixth = (...) => {...}`, which uses an arrow,
    `=>`, is the most compact way to define a function and the one we’ll try to use
    whenever possible.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最后一个定义，`sixth = (...) => {...}`，它使用了箭头`=>`，是定义函数最紧凑的方式，也是我们尽可能尝试使用的方式。
- en: At this point, we have seen several ways of defining a function, so let’s focus
    on arrow functions, a style we’ll favor in our coding for this book.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了几种定义函数的方法，所以让我们专注于箭头函数，这是我们在这本书的编码中将偏好的风格。
- en: Arrow functions – the modern way
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数——现代的方式
- en: 'Even if arrow functions work in pretty much the same way as the other functions,
    there are some crucial differences (see [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions))
    between them and the usual ones: arrow functions can implicitly return a value
    even with no return statement present; the value of `this` (the context for the
    function) is not bound; there is no `arguments` object; they cannot be used as
    constructors; they do not have a prototype property; and they cannot be used as
    generators because they don’t allow the `yield` keyword.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使箭头函数在大多数情况下与其他函数的工作方式相同，它们之间以及与常规函数之间也有一些关键的区别（参见[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)）：箭头函数即使没有`return`语句也可以隐式返回一个值；`this`（函数的上下文）的值没有被绑定；没有`arguments`对象；它们不能用作构造函数；它们没有原型属性；并且由于不允许使用`yield`关键字，它们不能用作生成器。
- en: 'In this section, we’ll go into several JavaScript function-related topics,
    including these:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨几个与JavaScript函数相关的话题，包括以下内容：
- en: How to return different values
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何返回不同的值
- en: How to handle problems with the value of `this`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理`this`值的难题
- en: How to work with varying numbers of arguments
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理不同数量的参数
- en: An important concept, currying, for which we’ll find many usages in the rest
    of this book
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个重要的概念，柯里化（currying），我们将在本书的其余部分找到许多用途
- en: Returning values
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: 'In the lambda coding style, functions only consist of a result. For the sake
    of brevity, the new arrow functions provide a syntax for this. When you write
    something such as `(x,y,z) =>` followed by an expression, a `return` is implied.
    For instance, the following two functions do the same as the `sum3()` function
    that we showed previously:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda编码风格中，函数只包含一个结果。为了简洁起见，新的箭头函数提供了一种语法来表示这一点。当你写一个像`(x,y,z) =>`后面跟着一个表达式的东西时，就隐含了一个`return`。例如，以下两个函数与之前展示的`sum3()`函数做的是同样的事情：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you want to return an object, you must use parentheses; otherwise, JavaScript
    will assume that code follows. Lest you think this is a wildly improbable case,
    check out *Question 3.1* in the *Questions* section later in this chapter for
    a very common scenario!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要返回一个对象，你必须使用括号；否则，JavaScript会假设代码随后。不要认为这是一个极不可能的情况，请查看本章后面的*问题*部分中的*问题3.1*，这是一个非常常见的场景！
- en: A matter of style
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有关风格的问题
- en: When you define an arrow function with only one parameter, you can omit the
    parentheses around it. For consistency, I prefer to always include them. Prettier,
    the formatting tool I use (we mentioned it in [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015),
    *Becoming Functional*), originally didn’t approve, but in version 2.0, it changed
    the default of its `arrow-parens` configuration item from `avoid` (meaning, try
    to do without parentheses) to `always`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个只有一个参数的箭头函数时，你可以省略其周围的括号。为了保持一致性，我更喜欢总是包括它们。我使用的格式化工具Prettier（我们在[*第一章*](B19301_01.xhtml#_idTextAnchor015)，*成为函数式开发者*）最初并不赞成这样做，但在2.0版本中，它将`arrow-parens`配置项的默认值从`avoid`（意味着，尽量不使用括号）更改为`always`。
- en: Handling the `this` value
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理`this`值
- en: 'A classic problem with JavaScript is handling `this`, whose value isn’t always
    what you expect it to be. ES2015 solved this with arrow functions, which inherit
    the proper `this` value so that problems are avoided. Look at the following code
    for an example of the possible problems: by the time the timeout function is called,
    `this` will point to the global (`window`) variable instead of the new object,
    so you’ll get `undefined` in the console:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中有一个经典问题，就是处理 `this`，其值并不总是你期望的。ES2015 通过箭头函数解决了这个问题，箭头函数会继承正确的 `this`
    值，从而避免了问题。看看以下代码的例子，以了解可能存在的问题：当超时函数被调用时，`this` 将指向全局（`window`）变量而不是新对象，因此在控制台你会得到
    `undefined`：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are traditional ways of solving this with old-fashioned JavaScript:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些传统的方法可以用老式的 JavaScript 解决这个问题：
- en: One solution uses a closure and defines a local variable (usually named `that`
    or sometimes `self`) that will get the original value of `this`, so it won’t be
    undefined
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种解决方案是使用闭包并定义一个局部变量（通常命名为 `that` 或有时 `self`），它会获取 `this` 的原始值，因此它不会是 `undefined`。
- en: The second way uses `bind()`, so the timeout function will be bound to the correct
    value of this (we used `bind()` for a similar purpose in the *Of lambdas and*
    *functions* section)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法使用 `bind()`，因此超时函数将被绑定到正确的 `this` 值（我们在 *关于 lambda 和函数* 部分使用 `bind()` 达到类似的目的）。
- en: A third, more modern way just uses an arrow function, so `this` gets the correct
    value (pointing to the object) without further ado
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种，更现代的方法只是使用箭头函数，这样 `this` 就会得到正确的值（指向对象），无需进一步操作。
- en: 'Let’s see the three solutions in actual code. We use a closure for the first
    timeout, binding for the second, and an arrow function for the third:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际的三个解决方案。我们使用闭包处理第一个超时，绑定处理第二个，箭头函数处理第三个：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you run this code, you’ll get `JavaScript` after 1 second, then again after
    another second, and a third time after another second. All three methods worked
    correctly, so whichever you pick just depends on which you like better.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你会在 1 秒后得到 `JavaScript`，然后又过一秒再次得到，再过一秒又得到一次。所有三种方法都正确工作，所以你选择哪一种只取决于你更喜欢哪一种。
- en: Working with arguments
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理参数
- en: In [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*, and
    [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037), *Thinking Functionally*, we saw
    some uses of the spread (`...`) operator. However, the most practical usage we’ll
    be making of it has to do with working with arguments; we’ll see some cases of
    this in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B19301_01.xhtml#_idTextAnchor015)*，《成为函数式开发者》* 和 [*第 2 章*](B19301_02.xhtml#_idTextAnchor037)*，《函数式思考》*
    中，我们看到了一些使用展开（`...`）操作符的例子。然而，我们将最实用地使用它来处理参数；我们将在 [*第 6 章*](B19301_06.xhtml#_idTextAnchor107)*，《生成函数》*
    中看到一些这样的例子。
- en: 'Let’s review our `once()` function from [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037)*,*
    *Thinking Functionally*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下来自 [*第 2 章*](B19301_02.xhtml#_idTextAnchor037)*，《函数式思考》* 的 `once()` 函数：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Why are we writing `return (...args) =>` and then afterward `func(...args)`?
    The answer has to do with the more modern way of handling a variable number (possibly
    zero) of arguments. How did you manage such kinds of code in older versions of
    JavaScript? The answer is the `arguments` object (not an array; read [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments))
    that lets you access the actual arguments passed to the function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们写 `return (...args) =>` 然后紧接着 `func(...args)`？答案与处理可变数量（可能为零）的参数的更现代方式有关。你是如何管理
    JavaScript 旧版本中的这类代码的？答案是 `arguments` 对象（不是一个数组；阅读 [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments)），它允许你访问传递给函数的实际参数。
- en: 'It happens that `arguments` is an *array-like* object, not really an array
    – the only array property it has is `length`. You cannot use methods such as `map()`,
    `forEach()`, and others on `arguments`. To convert `arguments` into a real array,
    you have to use `slice()`; you would also have to use `apply()` to call another
    function, like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`arguments` 是一个类似数组的对象，而不是真正的数组——它唯一的数组属性是 `length`。你不能在 `arguments` 上使用
    `map()`、`forEach()` 等方法。要将 `arguments` 转换为真正的数组，你必须使用 `slice()`；你还需要使用 `apply()`
    来调用另一个函数，如下所示：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In modern JavaScript, you don’t need to use arguments, slicing, or applying:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 JavaScript 中，你不需要使用参数、切片或应用：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should bear in mind the following points when looking at this code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看此代码时，你应该记住以下要点：
- en: By writing `useArguments2(...args)`, we immediately and clearly express that
    our new function receives several (possibly zero) arguments
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写 `useArguments2(...args)`，我们立即清楚地表达我们的新函数接收几个（可能为零）参数。
- en: You don’t need to do anything to get an array; `args` is a genuine array
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要做任何事情来得到一个数组；`args` 是一个真正的数组。
- en: Writing `somethingElse(...args)` is much clearer than using `apply()`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写 `somethingElse(...args)` 比使用 `apply()` 更清晰。
- en: 'By the way, the `arguments` object is still available in the current version
    of JavaScript. If you want to create an array from it, you have two alternative
    ways of doing so without having to resort to the `Array.prototype.slice.call`
    trick:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`arguments` 对象在当前版本的 JavaScript 中仍然可用。如果你想从它创建一个数组，你有两种替代方法来做这件事，而无需求助于
    `Array.prototype.slice.call` 技巧：
- en: Use the `from()` method and write `myArray=Array.from(arguments)`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `from()` 方法并编写 `myArray=Array.from(arguments)`。
- en: Write `myArray=[...arguments]`, which shows yet another type of usage of the
    spread operator
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写 `myArray=[...arguments]`，这显示了扩展运算符的另一种用法。
- en: When we get to the topic of higher-order functions, writing functions that deal
    with other functions, with a possibly unknown number of parameters, will be commonplace.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论到高阶函数时，编写处理其他函数、可能未知数量的参数的函数将变得很常见。
- en: JavaScript provides a much shorter way of doing this, so you’ll have to get
    accustomed to this usage. It’s worth it!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了一种更简洁的方式来完成这个任务，所以你将不得不习惯这种用法。这是值得的！
- en: One argument or many?
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个参数还是多个？
- en: It’s also possible to write functions that return functions, and in [*Chapter
    6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*, we will see more
    of this. For instance, in lambda calculus, you don’t write functions with several
    parameters, but only one; you do this using a technique called **currying**. (But
    why would you do this? Hold that thought; we’ll come to this later.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '还可以编写返回函数的函数，在 [*第6章*](B19301_06.xhtml#_idTextAnchor107) *生成函数* 中，我们将看到更多关于这个的内容。例如，在
    lambda 演算中，你不会写带有多个参数的函数，而只有一个；你使用一种称为 **currying** 的技术来做这件事。（但你为什么要这样做呢？保留这个想法；我们稍后会谈到。） '
- en: Twice recognized
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 双重认可
- en: Currying gets its name from Haskell Curry, who developed the concept. A functional
    language, *Haskell*, is also named after him – double recognition!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Currying 这个名字来源于 Haskell Curry，他提出了这个概念。一种函数式语言，*Haskell*，也是以他的名字命名的——双重认可！
- en: 'For instance, the function that we saw previously that sums three numbers would
    be written as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们之前看到的那三个数字求和的函数可以这样写：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Why did I change the function’s name? Simply put, this is *not* the same function
    we saw previously. The type of `sum3()` is `(x: number, y: number, z: number)
    => number`, while that of `altSum3()` is `(x: number) => (y: number) => (z: number)
    => number`, which is different. (See *Question 3.3* for more on this.) As-is,
    though, it can be used to produce the very same results as our earlier function.
    Let’s look at how you would use it, say, to sum the numbers 1, 2, and 3:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '为什么我改变了函数的名称？简单地说，这 **不是** 我们之前看到的同一个函数。`sum3()` 的类型是 `(x: number, y: number,
    z: number) => number`，而 `altSum3()` 的类型是 `(x: number) => (y: number) => (z: number)
    => number`，这是不同的。（有关更多内容，请参阅 *问题3.3*。）然而，它可以用来说明与我们的早期函数完全相同的结果。让我们看看你如何使用它，比如，来求和数字
    1、2 和 3：'
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Test yourself before reading on, and think about this: what would have been
    returned if you had written `altSum3(1,2,3)` instead? Tip: it would not be a number!
    For the full answer, keep reading.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，先测试一下自己，并思考这个问题：如果你写了 `altSum3(1,2,3)`，会返回什么？提示：它不会是一个数字！要得到完整的答案，请继续阅读。
- en: 'How does this work? Separating it into many calls can help; this would be the
    way the previous expression is calculated by the JavaScript interpreter:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？将其分解为许多调用可以帮助；这将是以这种方式由 JavaScript 解释器计算前一个表达式的：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Think functionally! The result of calling `altSum3(1)` is, according to the
    definition, a function, which, in virtue of a closure, resolves to be equivalent
    to the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下函数式！调用 `altSum3(1)` 的结果，根据定义，是一个函数，由于闭包，它解析为以下内容：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our `altSum3()` function is meant to receive a single argument, not three!
    The result of this call, `fn1`, is also a single-argument function. When you use
    `fn1(2)`, the result is again a function, also with a single parameter, which
    is equivalent to the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `altSum3()` 函数旨在接收单个参数，而不是三个！这个调用的结果，`fn1`，也是一个单参数函数。当你使用 `fn1(2)` 时，结果再次是一个函数，也只有一个参数，它等同于以下内容：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And when you calculate `fn2(3)`, a value is finally returned – great! As we
    said, the function performs the same kind of calculations as we saw earlier, but
    in an intrinsically different way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你计算`fn2(3)`时，最终返回了一个值——太棒了！正如我们所说的，函数执行的计算类型与我们之前看到的相同，但方式本质上不同。
- en: 'You might think that currying is a peculiar trick: who would want to use only
    single-argument functions? You’ll see the reasons for this when we consider how
    to join functions together in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148),
    *Connecting Functions*, and [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, where it won’t be feasible to pass more than one
    parameter from one step to the next.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为柯里化是一个奇特的技巧：谁会想只使用单参数函数呢？当我们考虑如何在[*第8章*](B19301_08.xhtml#_idTextAnchor148)“连接函数”和[*第12章*](B19301_12.xhtml#_idTextAnchor221)“构建更好的容器”中将函数组合在一起时，你会看到这样做的原因，在这些章节中，从一个步骤传递超过一个参数到下一个步骤是不切实际的。
- en: Functions as objects
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为对象
- en: 'The concept of first-class objects means that functions can be created, assigned,
    changed, passed as parameters, and returned as a result of other functions in
    the same way you can with, say, numbers or strings. Let’s start with its definition.
    Let’s look at how you usually define a function – and do you recognize the function’s
    name? (Hint: google “Colossal Cave Adventure”!)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首类对象的概念意味着函数可以被创建、分配、更改、作为参数传递，并且可以作为其他函数的结果返回，就像你可以用数字或字符串一样。让我们从它的定义开始。让我们看看你通常是如何定义一个函数的——你认出函数的名字了吗？（提示：谷歌“Colossal
    Cave Adventure”！）
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is (almost) equivalent to writing the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这（几乎）等同于编写以下内容：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, this is not true for hoisting, as we explained in the *Of lambdas and
    functions* section. JavaScript moves all definitions to the top of the current
    scope but does *not* move the assignments. With the first definition, you can
    invoke `xyzzy(...)` from any place in your code, but with the second, you cannot
    invoke the function until the assignment has been executed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这与提升（hoisting）不同，正如我们在*关于lambda函数和函数*部分中解释的那样。JavaScript将所有定义移动到当前作用域的顶部，但不会移动赋值。在第一个定义中，你可以从代码的任何地方调用`xyzzy(...)`，但在第二个定义中，你必须等到赋值执行后才能调用该函数。
- en: 'The point that we want to make is that a function can be assigned to a variable
    and can also be reassigned if desired. In a similar vein, we can define functions
    on the spot where they are needed. We can even do this without naming them: as
    with common expressions, if they are used only once, you don’t need to name them
    or store them in a variable.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要表达的观点是，一个函数可以被分配给一个变量，如果需要的话也可以重新分配。在类似的方面，我们可以在需要的地方定义函数。我们甚至可以不命名它们来做这件事：就像常见的表达式一样，如果它们只使用一次，你不需要命名它们或将它们存储在变量中。
- en: A colossal parallel
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个巨大的并行
- en: See the parallel with the *Colossal Cave Adventure* game from the 70s? Invoking
    `xyzzy()` anywhere won’t always work! If you have never played that famous interactive
    fiction game, try it online – for example, at [www.web-adventures.org/cgi-bin/webfrotz?s=Adventure](http://www.web-adventures.org/cgi-bin/webfrotz?s=Adventure)
    or [www.amc.com/blogs/play-the-colossal-cave-adventure-game-just-like-halt-and-catch-fires-cameron-howe--1009966](http://www.amc.com/blogs/play-the-colossal-cave-adventure-game-just-like-halt-and-catch-fires-cameron-howe--1009966).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到与70年代的*Colossal Cave Adventure*游戏的平行了吗？在任何地方调用`xyzzy()`并不总是有效的！如果你从未玩过那个著名的交互式小说游戏，可以在线尝试——例如，在[www.web-adventures.org/cgi-bin/webfrotz?s=Adventure](http://www.web-adventures.org/cgi-bin/webfrotz?s=Adventure)或[www.amc.com/blogs/play-the-colossal-cave-adventure-game-just-like-halt-and-catch-fires-cameron-howe--1009966](http://www.amc.com/blogs/play-the-colossal-cave-adventure-game-just-like-halt-and-catch-fires-cameron-howe--1009966)。
- en: Let’s see an actual code example that involves assigning functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际的代码示例，它涉及到函数的赋值。
- en: A React-Redux reducer
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个React-Redux reducer
- en: 'As we mentioned in [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming
    Functional*, React-Redux works by dispatching actions that a *reducer* processes.
    (Read more about this at [redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers](http://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers).)
    Usually, the reducer includes code with a switch. An example follows – and I’m
    using JavaScript (not TypeScript) to focus on logic aspects:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第1章*](B19301_01.xhtml#_idTextAnchor015)“成为函数式”中提到的，React-Redux通过分发由*reducer*处理的动作来工作。（更多关于这个话题的信息，请参阅[redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers](http://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers)。）通常，reducer包含带有switch语句的代码。以下是一个例子——我使用JavaScript（而不是TypeScript）来关注逻辑方面：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Initial state
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 初始状态
- en: Providing `initialState` as a default value for the state is a simple way of
    initializing the global state. Pay no attention to that `default`; it’s irrelevant
    to our example, and I included it just for completeness. I’m also assuming the
    existence of `State`, `Action`, and others as types – see *Question 3.5*!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将`initialState`作为状态的默认值是一种初始化全局状态的方法。不要注意那个`default`；它与我们的例子无关，我之所以包含它，只是为了完整性。我还假设存在`State`、`Action`和其他类型——参见*问题3.5*！
- en: 'By taking advantage of the possibility of storing functions, we can build a
    **dispatch** **table** and simplify the preceding code. First, we initialize an
    object with the code for the functions for each action type. We are just taking
    the preceding code and creating separate functions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用存储函数的可能性，我们可以构建一个**调度** **表**并简化前面的代码。首先，我们初始化一个对象，其中包含每个动作类型的函数代码。我们只是将前面的代码取出来，创建单独的函数：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We store the different functions that process each type of action as attributes
    in an object that will work as a dispatcher table. This object is created only
    once and is constant during the execution of the application. With it, we can
    now rewrite the action-processing code in a single line of code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理每种动作的不同函数存储在作为调度表工作的对象属性中。此对象仅创建一次，并在应用程序执行期间保持不变。有了它，我们现在可以只用一行代码重写动作处理代码：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s analyze it: given the action, if `action.type` matches an attribute in
    the dispatching object, we execute the corresponding function taken from the object
    where it was stored. If there isn’t a match, we just return the current state
    as Redux requires. This kind of code wouldn’t be possible if we couldn’t handle
    functions (storing and recalling them) as first-class objects.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下：给定动作，如果`action.type`与调度对象中的属性匹配，我们执行从对象中取出的相应函数。如果没有匹配，我们只返回当前状态，因为Redux要求这样做。如果没有能够将函数（存储和调用它们）作为一等对象处理，这种类型的代码是不可能的。
- en: An unnecessary mistake
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个不必要的错误
- en: 'There is, however, a common (though, in fact, harmless) mistake that is usually
    made. You often see code like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个常见的（尽管实际上是无害的）错误通常会被犯。你经常看到这样的代码：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What does this code do? The idea is that a remote URL is fetched, and when the
    data arrives, a function is called – and this function calls `processResult` with
    `data` as an argument. That is to say, in the `then()` part, we want a function
    that, given data, calculates `processResult(data)`. But don’t we already have
    such a function?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做什么？其思路是获取远程URL，当数据到达时，调用一个函数——然后这个函数用`data`作为参数调用`processResult`。也就是说，在`then()`部分，我们想要一个函数，给定数据，计算`processResult(data)`。但我们不是已经有了这样的函数吗？
- en: 'There is a rule that you can apply whenever you see something like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个规则，你可以在看到以下内容时应用：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This rule states that you can replace code resembling the preceding code with
    just `someOtherFunction`. So, in our example, we can directly write what follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则指出，你可以用`someOtherFunction`替换类似前面代码的代码。所以，在我们的例子中，我们可以直接写出以下内容：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code is equivalent to the previous method that we looked at (although it
    is infinitesimally quicker since you avoid one function call), but is it simpler
    to understand?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前我们查看的方法等价（尽管由于避免了函数调用，它几乎更快），但它是否更容易理解？
- en: Some terminology
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一些术语
- en: In lambda calculus terms, we are replacing λ*x*.*func* *x* with simply *func*
    – this is called an **η (eta) conversion**, or more specifically, an **η** **reduction**.
    (If you were to do it the other way round, it would be an **η** **abstraction**.)
    In our case, it could be considered a (very, very small!) optimization, but its
    main advantage is shorter, more compact code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在λ演算术语中，我们是用简单的`func`替换了λ*x*.*func* *x*——这被称为**η (eta) 转换**，或者更具体地说，是**η** **归约**。（如果你反过来做，那将是**η**
    **抽象**。）在我们的情况下，它可以被认为是一个（非常，非常小的！）优化，但其主要优势是代码更短，更紧凑。
- en: 'This programming style is called **pointfree** (also **point-free**) or **tacit**
    style, and its defining characteristic is that you never specify the arguments
    for each function application. An advantage of this way of coding is that it helps
    the writer (and the future readers of the code) think about the functions and
    their meanings instead of working at a low level, passing data around, and working
    with it. In the shorter version of the code, there are no extraneous or irrelevant
    details: if you know what the called function does, you understand the meaning
    of the complete piece of code. We’ll often (but not necessarily always) work this
    way in our text.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格被称为**无点**（也称为**无点**）或**隐式**风格，其定义特征是您永远不会为每个函数应用指定参数。这种编码方式的一个优点是它帮助作者（以及未来的代码读者）思考函数及其含义，而不是在低级别上工作，传递数据，并与之交互。在代码的简短版本中，没有无关或无关紧要的细节：如果您知道被调用的函数做什么，您就理解了整个代码片段的含义。我们通常（但不一定总是）会以这种方式在我们的文本中工作。
- en: Old Unix style
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 Unix 风格
- en: Unix/Linux users are already accustomed to this style because they work in a
    similar way when they use pipes to pass the result of a command as input to another.
    When you write something as `ls|grep doc|sort`, the output of `ls` is the input
    to `grep`, and the latter’s output is the input to `sort` – but input arguments
    aren’t written out anywhere; they are implied. We’ll come back to this in the
    *Pointfree style* section of [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148)*,*
    *Connecting Functions*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Unix/Linux 用户已经习惯了这种风格，因为他们使用管道将命令的结果作为输入传递给另一个命令时，以类似的方式进行工作。当您编写`ls|grep doc|sort`时，`ls`的输出是`grep`的输入，而`grep`的输出是`sort`的输入——但输入参数并没有写出来；它们是隐含的。我们将在[*第
    8 章*](B19301_08.xhtml#_idTextAnchor148)的*“无点风格”部分*中回到这一点，*“连接函数”*。
- en: Working with methods
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与方法交互
- en: 'However, there is a case that you should be aware of: what happens if you call
    an object’s method? Look at the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个情况您应该注意：如果您调用一个对象的方法会发生什么？看看以下代码：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If your original code had been something along the lines of the preceding code,
    then the seemingly obvious transformed code would fail:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的原始代码与前面的代码类似，那么看似明显的转换代码将失败：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Why? The reason is that in the original code, the called method is bound to
    an object (`myObject`), but in the modified code, it isn’t bound and is just a
    free function. We can fix it by using `bind()`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？原因是原始代码中，被调用的方法绑定到一个对象（`myObject`），但在修改后的代码中，它没有绑定，只是一个自由函数。我们可以通过使用`bind()`来修复它：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a general solution. When dealing with a method, you cannot just assign
    it; you must use `bind()` so that the correct context will be available. Look
    at the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用的解决方案。在处理方法时，您不能只是分配它；您必须使用 `bind()` 以确保正确的上下文可用。看看以下代码：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Following this rule, such code should be converted into the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 依照这个规则，这样的代码应该转换为以下形式：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Read more on `bind()` at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind)
    上了解更多关于 `bind()` 的信息。
- en: This looks rather awkward and not too elegant, but it’s required so that the
    method will be associated with the correct object. We will see one application
    of this when we *promisify* functions in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*. Even if this code isn’t so nice to look at, whenever you
    have to work with objects (and remember, we didn’t say that we would be trying
    to aim for fully FP code, and did say that we would accept other constructs if
    they made things easier), you’ll have to remember to bind methods before passing
    them as first-class objects in pointfree style.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当笨拙，并不太优雅，但这是必须的，以便方法将与正确的对象相关联。当我们[*第 6 章*](B19301_06.xhtml#_idTextAnchor107)中的函数*“生成函数”进行*“Promise
    化”时，我们将看到这种应用的例子。即使这段代码看起来并不那么令人愉快，但每当您必须与对象（记住，我们并没有说我们会尝试实现完全的函数式编程代码，而是说如果它们使事情变得更容易，我们会接受其他结构）交互时，您必须记得在以无点风格将它们作为一等对象传递之前绑定方法。
- en: So far, we have been discussing many aspects of functions; now, let’s get more
    into functions in FP, and see how we’ll use them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了许多关于函数的方面；现在，让我们更深入地探讨 FP 中的函数，看看我们将如何使用它们。
- en: Using functions in FP ways
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数进行 FP 编程方式
- en: Several common coding patterns take advantage of the FP style, even if you aren’t
    aware of it. In this section, we will go through them and look at the functional
    aspects of the code so that you can get more accustomed to this coding style.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 几种常见的编码模式利用了函数式编程（FP）风格，即使你并没有意识到。在本节中，我们将逐一介绍它们，并查看代码的功能性方面，以便你能够更习惯这种编码风格。
- en: 'Then, we’ll look in detail at using functions in an FP way by considering several
    FP techniques, such as the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将详细探讨以函数式编程（FP）方式使用函数，通过考虑以下几种函数式编程技术：
- en: '**Injection**, which is needed for sorting different strategies, as well as
    other uses'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注入**，这是排序不同策略以及其他用途所必需的'
- en: '**Callbacks** and **promises**, introducing the **continuation-passing** style'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Callbacks** 和 **promises**，引入 **continuation-passing** 风格'
- en: '**Polyfilling** and **stubbing**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Polyfilling** 和 **stubbing**'
- en: '**Immediate** **invocation** schemes'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Immediate** **invocation** schemes'
- en: Injection – sorting it out
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入 - 排序问题
- en: 'The `Array.prototype.sort()` method provides the first example of passing functions
    as parameters. If you have an array of strings and you want to sort it, you can
    just use the `sort()` method. For example, to alphabetically sort an array with
    the colors of the rainbow, we would write something like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.sort()` 方法提供了传递函数作为参数的第一个例子。如果您有一个字符串数组并且想要对其进行排序，您可以直接使用
    `sort()` 方法。例如，要对彩虹的颜色进行字母排序，我们会写如下内容：'
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that we didn’t have to provide any parameters to the `sort()` call, but
    the array got sorted perfectly well. By default, this method sorts strings according
    to their ASCII internal representation. So, if you use this method to sort an
    array of numbers, it will fail because it will decide that 20 must be between
    100 and 3, as 100 precedes 20 (taken as strings!) and the latter precedes 3, so
    this needs fixing! The following code shows the problem:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要向 `sort()` 调用提供任何参数，但数组被完美排序了。默认情况下，此方法根据字符串的 ASCII 内部表示进行排序。因此，如果您使用此方法对数字数组进行排序，它将失败，因为它会决定
    20 必须位于 100 和 3 之间，因为 100 在 20（作为字符串）之前，而后者在 3 之前，所以这需要修复！以下代码显示了问题：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But let’s forget numbers for a while and stick to sorting strings. What would
    happen if we wanted to sort some Spanish words (*palabras*) while following the
    appropriate locale rules? We would be sorting strings, but the results wouldn’t
    be correct:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们暂时忘记数字，专注于排序字符串。如果我们想要按照适当的区域规则对一些西班牙语单词（*palabras*）进行排序，会发生什么？我们会排序字符串，但结果可能不会正确：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What’s in a word?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个词中有什么？
- en: For language or biology buffs, *ñandú* in English is *rhea*, a running bird
    similar to an ostrich. There aren’t many Spanish words beginning with *ñ*, and
    we happen to have these birds in my country, Uruguay, so that’s the reason for
    the odd word!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于语言或生物学爱好者来说，英语中的 *ñandú* 是 *rhea*，一种类似鸵鸟的奔跑鸟类。以 *ñ* 开头的西班牙语单词并不多，而且我们恰好在我所在的国家乌拉圭有这些鸟类，这就是这个奇怪单词的原因！
- en: 'Oops! In Spanish, *ñ* comes between *n* and *o*, but `"ñandú"` got sorted at
    the end. Also, `"mítico"` (in English, mythical; note the accented *í*) should
    appear between `"mano"` and `"musical"` because the tilde should be ignored. The
    appropriate way of solving this is by providing a comparison function to `sort()`.
    In this case, we can use the `localeCompare()` method as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！在西班牙语中，*ñ* 位于 *n* 和 *o* 之间，但 `"ñandú"` 被排序到了最后。此外，`"mítico"`（在英语中意为神话般的；注意重音
    *í*）应该位于 `"mano"` 和 `"musical"` 之间，因为波浪号应该被忽略。解决这个问题的适当方法是提供一个比较函数给 `sort()`。在这种情况下，我们可以使用
    `localeCompare()` 方法，如下所示：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `a.localeCompare(b,"es")` call compares the `a` and `b` strings and returns
    a negative value should `a` precede `b`, a positive value should `a` follow `b`,
    and 0 if `a` and `b` are the same – but according to Spanish (`"es"`) ordering
    rules.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.localeCompare(b,"es")` 调用比较了 `a` 和 `b` 字符串，如果 `a` 在 `b` 之前，则返回负值；如果 `a`
    在 `b` 之后，则返回正值；如果 `a` 和 `b` 相同，则返回 0 - 但根据西班牙语（`"es"`）的排序规则。'
- en: 'Now, things are right! And the code could be made clearer by introducing a
    new function, `spanishComparison()`, to perform the required strings comparison:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切正常！而且可以通过引入一个新的函数 `spanishComparison()` 来执行所需的字符串比较，使代码更清晰：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: International sorting
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 国际排序
- en: 'For more on the `localeCompare()` possibilities, see [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
    You can specify which locale rules to apply, in which order to place upper/lowercase
    letters, whether to ignore punctuation, and much more. But be careful: not all
    browsers may support the required extra parameters.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `localeCompare()` 的可能性，请参阅 [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)。你可以指定要应用哪些区域规则，字母的大小写顺序，是否忽略标点符号，以及更多。但请注意：并非所有浏览器都支持所需的额外参数。
- en: In upcoming chapters, we will discuss how FP lets you write code in a more declarative
    fashion, producing more understandable code, and how this sort of minor change
    helps. When readers of the code get to the `sort` function, they will immediately
    deduce what is being done, even if the comment wasn’t present.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论函数式编程如何让你以更声明性的方式编写代码，生成更易于理解的代码，以及这种微小的变化是如何帮助的。当代码的读者到达 `sort`
    函数时，他们将会立即推断出正在执行的操作，即使注释没有出现。
- en: Of strategies and patterns
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关于策略和模式
- en: This way of changing how the `sort()` function works by injecting different
    comparison functions is a case of the strategy **design pattern**. We’ll learn
    more about this in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing*
    *Design Patterns*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注入不同的比较函数来改变 `sort()` 函数的工作方式，这是一种策略 **设计模式** 的例子。我们将在 [*第11章*](B19301_11.xhtml#_idTextAnchor204)，*实现*
    *设计模式* 中了解更多。
- en: 'Providing a `sort` function as a parameter (in a very FP way!) can also help
    with several other problems, such as the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `sort` 函数作为参数提供（以一种非常函数式编程的方式！）也可以帮助解决几个其他问题，例如以下内容：
- en: '`sort()` only works with strings by default. If you want to sort numbers (as
    we tried to do previously), you have to provide a function that will compare numerically.
    For example, you would write something like `myNumbers.sort((a:number, b:number)
    => a – b)`. (Why? See *Question 3.7*.)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`sort()` 只能与字符串一起使用。如果你想对数字进行排序（就像我们之前尝试的那样），你必须提供一个将数值比较的函数。例如，你会写类似
    `myNumbers.sort((a:number, b:number) => a – b)` 的内容。（为什么？见 *问题 3.7*。）
- en: If you want to sort objects by a given attribute, you will use a function that
    compares to it. For example, you could sort people by age with something like
    `myPeople.sort((a:Person, b:Person) => a.age -` `b.age)`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要根据给定的属性对对象进行排序，你将使用一个与它比较的函数。例如，你可以使用类似 `myPeople.sort((a:Person, b:Person)
    => a.age - b.age)` 的方式对人们按年龄进行排序。
- en: This is a simple example you have probably used before, but it’s an FP pattern,
    after all. Let’s move on to even more common usage of functions as parameters
    when you perform Ajax calls.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你可能之前使用过的简单例子，但毕竟它是一个函数式编程模式。让我们继续探讨在执行 Ajax 调用时将函数作为参数的更常见用法。
- en: Callbacks and promises
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调和承诺
- en: 'Probably the most used example of functions passed as first-class objects has
    to do with callbacks and promises. In Node.js, reading a file is accomplished
    asynchronously with something like the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为一等对象传递的最常用例子之一与回调和承诺有关。在 Node.js 中，读取文件是通过以下类似代码的异步方式完成的：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `readFile()` function requires a callback – in this example, an anonymous
    function – that will get called when the file-reading operation is finished.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile()` 函数需要一个回调（在这个例子中是一个匿名函数），当文件读取操作完成时会被调用。'
- en: 'A better, more modern way is using promises; read more at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
    With this, when performing an Ajax web service call using the `fetch()` function,
    you could write something along the lines of the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好、更现代的方法是使用承诺；更多内容请参阅 [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)。使用这种方式，当使用
    `fetch()` 函数执行 Ajax 网络服务调用时，你可以编写类似以下代码的内容：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, you should also look into using `async`/`await`; read more about them
    at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
    and [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await),
    respectively.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也应该考虑使用`async`/`await`；更多关于它们的信息可以在[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)和[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)中找到。
- en: Continuation-passing style
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延续传递风格
- en: 'The preceding code, in which you call a function but also pass another function
    to be executed when the input/output operation is finished, can be considered
    something called **continuation-passing style** (**CPS**). What is this technique
    of coding? One way of looking at it is by thinking about the question: *how would
    you program if using the return statement* *was forbidden?*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的代码，其中你调用一个函数，同时也传递另一个在输入/输出操作完成后要执行的函数，可以被认为是称为**延续传递风格**（**CPS**）的东西。这种编程技术是什么？一种看待它的方式是思考以下问题：*如果你被禁止使用return语句，你会如何编程？*
- en: At first glance, this may appear to be an impossible situation. However, we
    can get out of our fix by passing a callback to the called function so that when
    that procedure is ready to return to the caller, instead of returning, it invokes
    the given callback. By doing this, the callback provides the called function with
    the way to continue the process, hence the word *continuation*. We won’t get into
    this now, but in [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*,
    we will study it in depth. In particular, CPS will help us to avoid an important
    recursion restriction, as we’ll see.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这似乎是一种不可能的情况。然而，我们可以通过传递一个回调给被调用的函数来摆脱困境，这样当该过程准备好返回给调用者时，而不是返回，它将调用给定的回调。通过这样做，回调为被调用的函数提供了继续过程的方式，因此得名*延续*。我们现在不会深入探讨这个问题，但在[*第9章*](B19301_09.xhtml#_idTextAnchor172)，*设计函数*中，我们将深入研究它。特别是，CPS将帮助我们避免一个重要的递归限制，正如我们将看到的。
- en: Working out how to use continuations is sometimes challenging, but always possible.
    An exciting advantage of this way of coding is that by specifying how the process
    will continue, you can go beyond all the usual structures (`if`, `while`, `return`,
    and so on) and implement whatever mechanisms you want. This can be very useful
    in problems where the process isn’t necessarily linear. Of course, this can also
    lead to you inventing a kind of control structure far worse than the possible
    usage of GOTO statements that you might imagine! *Figure 3**.1* shows the dangers
    of that practice!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 确定如何使用延续有时具有挑战性，但总是可能的。这种编程方式的令人兴奋的优势在于，通过指定过程将如何继续，你可以超越所有常规结构（`if`、`while`、`return`等），并实现你想要的任何机制。这在处理过程不一定是线性的问题中非常有用。当然，这也可能导致你发明一种比你可能想象的GOTO语句的潜在使用更糟糕的控制结构！*图3.1*显示了这种做法的危险！
- en: "![Figure 3.1 – What’s the \uFEFFworst that could happen if you start messing\
    \ with the program ﬂow? (This XKCD comic is available online at xkcd.com/292/)](img/Figure_3.1_B19301.jpg)"
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 如果你开始篡改程序流程，最坏的情况会是什么？（这个XKCD漫画可在xkcd.com/292/在线查看）](img/Figure_3.1_B19301.jpg)'
- en: Figure 3.1 – What’s the worst that could happen if you start messing with the
    program ﬂow? (This XKCD comic is available online at [xkcd.com/292/](http://xkcd.com/292/))
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 如果你开始篡改程序流程，最坏的情况会是什么？（这个XKCD漫画可在[xkcd.com/292/](http://xkcd.com/292/)在线查看）
- en: 'You are not limited to passing a single continuation. As with promises, you
    can provide two or more alternative callbacks. And this, by the way, can provide
    a solution to the problem of how you would work with exceptions. If we simply
    allowed a function to throw an error, it would be an implied return to the caller,
    and we don’t want this. The way out of this is to provide an alternative callback
    (that is, a different continuation) to be used whenever an exception is thrown
    (in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building Better Containers*,
    we’ll find another solution using monads):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于传递单个延续。就像承诺一样，你可以提供两个或更多的替代回调。顺便说一句，这可以提供一种解决方案来解决如何处理异常的问题。如果我们简单地允许一个函数抛出错误，那么它将是对调用者的隐式返回，我们不希望这样。摆脱这种困境的方法是提供一个替代回调（即不同的延续），以便在抛出异常时（在[*第12章*](B19301_12.xhtml#_idTextAnchor221)，*构建更好的容器*中，我们将找到另一种使用单子的解决方案）使用。
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using CPS can even allow you to go beyond the control structures that JavaScript
    provides, but that would be beyond the objectives of this book, so I’ll let you
    research that on your own!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CPS甚至可以让你超越JavaScript提供的控制结构，但这超出了本书的目标，所以我会让你自己研究这一点！
- en: Polyfills
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Polyfills
- en: Being able to assign functions dynamically (in the same way that you can assign
    different values to a variable) also allows you to work more efficiently when
    defining polyfills.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 能够动态分配函数（就像你可以为变量分配不同的值一样）也允许你在定义polyfills时更加高效地工作。
- en: Detecting Ajax
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测Ajax
- en: 'Let’s go back a bit in time to when Ajax started to appear. Given that different
    browsers implemented Ajax calls in distinct fashions, you would always have to
    code around these differences. The following code shows how you would go about
    implementing an Ajax call by testing several different conditions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到Ajax开始出现的时候。鉴于不同的浏览器以不同的方式实现了Ajax调用，你总是必须围绕这些差异进行编码。以下代码展示了你将如何通过测试几个不同的条件来实现Ajax调用：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This worked but implied that you would redo the Ajax check for every call,
    even though the test results wouldn’t ever change. There’s a more efficient way
    to do this, and it has to do with using functions as first-class objects. We could
    define *two* different functions, test for the condition only once, and then assign
    the correct function to be used later; study the following code for such an alternative:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码运行了，但暗示了你会为每个调用重新进行Ajax检查，尽管测试结果永远不会改变。有一种更有效的方法来做这件事，这与使用函数作为一等对象有关。我们可以定义**两个**不同的函数，只测试一次条件，然后分配正确的函数供以后使用；研究以下代码以了解这种替代方案：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This piece of code shows two important concepts. First, we can dynamically
    assign a function: when this code runs, `window.getAjax` (the global `getAjax`
    variable) will get one of three possible values according to the current browser.
    When you later call `getAjax()` in your code, the correct function will execute
    without you needing to do any further browser-detection tests.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了两个重要的概念。首先，我们可以动态地分配一个函数：当这段代码运行时，`window.getAjax`（全局的`getAjax`变量）将根据当前浏览器获得三个可能值之一。当你后来在你的代码中调用`getAjax()`时，正确的函数将执行，而无需你进行任何进一步的浏览器检测测试。
- en: The second interesting idea is that we define the `initializeGetAjax()` function
    and immediately run it – this pattern is called the **immediately invoked function
    expression** (**IIFE**), and we already saw it in the *Solution 7 – using a local
    flag* section in [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037)*, Thinking Functionally*.
    The function runs but cleans up after itself because all its variables are local
    and won’t even exist after the function runs. We’ll learn more about this later
    in this chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个有趣的想法是我们定义了`initializeGetAjax()`函数并立即运行它——这种模式被称为**立即调用的函数表达式**（**IIFE**），我们已经在[*第2章*](B19301_02.xhtml#_idTextAnchor037)*——*函数式思考*中的*解决方案7——使用局部标志*部分中看到了它。函数运行后会自行清理，因为所有变量都是局部的，并且在函数运行后甚至不会存在。我们将在本章后面了解更多关于这一点。
- en: 'Nowadays, you would use a module instead of an IIFE, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会使用模块而不是IIFE，如下所示：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code in the module is guaranteed to run only once. Wherever you need to
    do an Ajax call, you would just `import { getAjax } from "/path/to/ajax.module"`
    and you could use `getAjax()` at will.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中的代码保证只运行一次。无论你需要进行Ajax调用的地方，你只需`import { getAjax } from "/path/to/ajax.module"`，然后你可以随意使用`getAjax()`。
- en: Adding missing functions
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加缺失的函数
- en: 'This idea of defining a function on the run also allows us to write polyfills
    that provide otherwise missing functions. For example, let’s say that we had some
    code such as the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在运行时定义函数的想法也允许我们编写提供其他缺失函数的polyfills。例如，假设我们有一些如下所示的代码：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Instead of this, you might very much prefer using the newer `includes()` method
    and just write this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这样做，你可能会非常倾向于使用较新的`includes()`方法，并简单地写下如下内容：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'What happens if your browser doesn’t provide `includes()`? Once again, we can
    define the appropriate function on the fly, but only if needed. If `includes()`
    is available, you don’t need to do anything, but if it is missing, you need to
    define a polyfill that will provide the same workings. (You can find links to
    polyfills on Mozilla’s developer site.) The following code shows an example of
    such a polyfill:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的浏览器不提供`includes()`会发生什么？再一次，我们可以在运行时定义适当的函数，但仅当需要时。如果`includes()`可用，你不需要做任何事情，但如果它缺失，你需要定义一个polyfill来提供相同的功能。（你可以在Mozilla的开发者网站上找到polyfills的链接。）以下代码展示了这样一个polyfill的示例：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When this code runs, it checks whether the `String` prototype already has the
    `includes()` method. If not, it assigns a function to it that does the same job,
    so from that point onward, you’ll be able to use `includes()` without further
    worries. By the way, there are other ways of defining a polyfill: check the answer
    to *Question 3.7* for an alternative. Yet another solution is the `core-js` package
    ([github.com/zloirock/core-js](http://github.com/zloirock/core-js)), which provides
    polyfills for ECMAScript up to the latest version, and even some proposals that
    haven’t made it into the language yet.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码运行时，它会检查 `String` 原型是否已经有了 `includes()` 方法。如果没有，它会给它分配一个执行相同工作的函数，因此从那时起，你将能够使用
    `includes()` 而无需进一步担心。顺便说一句，还有其他定义 polyfill 的方法：查看 *问题 3.7* 的答案以获取替代方案。另一个解决方案是
    `core-js` 包 ([github.com/zloirock/core-js](http://github.com/zloirock/core-js))，它为
    ECMAScript 提供了直到最新版本的 polyfill，甚至包括尚未进入语言的某些提案。
- en: Good or bad?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 好或不好？
- en: Directly modifying a standard type’s prototype object is usually frowned upon
    because, in essence, it’s equivalent to using a global variable, and thus it’s
    prone to errors; however, in this case (writing a polyfill for a well-established,
    known function) is quite unlikely to provoke any conflicts.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 直接修改标准类型的原型对象通常是不被推荐的，因为本质上，这相当于使用全局变量，因此容易出错；然而，在这种情况下（为已建立且已知的功能编写 polyfill）引发冲突的可能性非常小。
- en: 'Finally, if you happened to think that the Ajax example shown previously was
    old hat, consider this: if you want to use the more modern `fetch()` way of calling
    services, you will also find that not all modern browsers support it (check [caniuse.com/#search=fetch](http://caniuse.com/#search=fetch)
    to verify this), so you’d have to use a polyfill, such as the one at [github.com/github/fetch](http://github.com/github/fetch).
    Study the code, and you’ll see that it uses the same method described previously
    to see whether a polyfill is needed and create it.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你认为之前展示的 Ajax 示例已经过时了，那么考虑一下这个：如果你想使用更现代的 `fetch()` 调用服务的方式，你也会发现并不是所有现代浏览器都支持它（通过访问
    [caniuse.com/#search=fetch](http://caniuse.com/#search=fetch) 来验证这一点），因此你可能需要使用
    polyfill，比如 [github.com/github/fetch](http://github.com/github/fetch) 上的那个。研究一下代码，你会发现它使用了之前描述的相同方法来检查是否需要
    polyfill 并创建它。
- en: Stubbing
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Stubbing
- en: 'Here, we will look at a use case similar to using a polyfill: having a function
    do different work depending on the environment. The idea is to perform stubbing,
    an idea that comes from testing and involves replacing a function with another
    that does a simpler job instead of the actual work.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探讨一个类似于使用 polyfill 的用例：一个函数根据环境执行不同的工作。这个想法是执行 stubbing，这是一个来自测试的概念，涉及用一个执行更简单工作的函数替换实际工作的函数。
- en: 'Stubbing is commonly used with logging functions. You may want the application
    to perform detailed logging when in development but not to say a peep when in
    production. A common solution would be to write something along the lines of the
    following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Stubbing 通常与日志函数一起使用。你可能希望在开发时让应用程序执行详细的日志记录，但在生产时则不希望有任何输出。一个常见的解决方案可能是编写如下内容：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This works, but as in the example of Ajax detection, it does more work than
    it needs to because it checks whether the application is in development every
    time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这方法是可行的，但就像 Ajax 检测的例子一样，它做了比所需更多的工作，因为它每次都会检查应用程序是否处于开发状态。
- en: 'We could simplify the code (and get a really, really tiny performance gain!)
    if we stub out the logging function so that it won’t log anything; an easy implementation
    is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取消日志函数的记录功能，使其不记录任何内容，我们可以简化代码（并且获得一个非常非常小的性能提升！）！一个简单的实现方法如下：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can do even better with the ternary operator:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三元运算符做得更好：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is a bit more cryptic, but I prefer it because it uses `const`, which cannot
    be modified.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点晦涩，但我更喜欢它，因为它使用了 `const`，它不能被修改。
- en: 'There’s yet another possibility: you could modify the original method like
    this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种可能性：你可以像这样修改原始方法：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, we are directly changing how `console.log()` works, so it won’t
    log anything.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们直接改变了 `console.log()` 的工作方式，因此它不会记录任何内容。
- en: Useless arguments – ignore or exclude?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 无用的参数 - 忽略还是排除？
- en: Given that JavaScript allows us to call functions with more arguments than parameters,
    and given that we aren’t doing anything in `myLog()` when we are not in development,
    we could also have written `() => {}` and it would have worked fine. However,
    I do prefer keeping the same signature, and that’s why I specified the `someText`
    argument, even if it wouldn’t be used. But, if you use ESLint’s `no-unused-vars`
    rule to detect unused variables, you may have to tweak its configuration to allow
    unused arguments.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 允许我们用比参数更多的参数调用函数，并且在我们不在开发阶段时，我们并没有在 `myLog()` 中做任何事情，我们也可以写成
    `() => {}` 并正常工作。然而，我更喜欢保持相同的签名，这就是为什么我指定了 `someText` 参数，即使它不会被使用。但是，如果你使用 ESLint
    的 `no-unused-vars` 规则来检测未使用的变量，你可能需要调整其配置以允许未使用的参数。
- en: You’ll notice that we are using the concept of functions as first-class objects
    over and over again; look through all the code samples and you’ll see!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们反复使用函数作为一等对象的概念；浏览所有代码示例，你就会看到这一点！
- en: Immediate invocation (IIFE)
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立即调用（IIFE）
- en: 'There’s yet another common usage of functions, usually seen in popular libraries
    and frameworks, that lets you bring some modularity advantages from other languages
    into JavaScript (even the older versions!). The usual way of writing this is something
    like the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的另一种常见用法，通常在流行的库和框架中看到，它可以让您从其他语言中带来一些模块化优势到 JavaScript（即使是较旧的版本！）！通常的写法如下：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Alternatively, you may find `(function(){ ... }())` – note the different placement
    of the parentheses for the function call. Both styles have their fans; pick whichever
    suits you, and follow it consistently.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能还会发现 `(function(){ ... }())` – 注意函数调用中括号的放置方式不同。这两种风格都有其支持者；选择适合你的，并保持一致。
- en: 'You can also pass some arguments to the function that will be used as the initial
    values for its parameters:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以向函数传递一些参数，这些参数将用作其参数的初始值：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, you could also return something from the function – usually, an object
    (with several methods) or a function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也可以从函数中返回一些内容——通常是对象（带有多个方法）或函数：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note the parentheses around the function. These help the parser understand that
    we are writing an expression. If you were to omit the first set of parentheses,
    JavaScript would think you were writing a function declaration instead of an invocation.
    The parentheses also serve as a visual note, so readers of your code will immediately
    recognize the IIFE.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数周围的括号。这有助于解析器理解我们正在编写一个表达式。如果你省略第一组括号，JavaScript 会认为你正在编写一个函数声明而不是调用。括号还起到视觉提示的作用，因此你的代码的读者会立即识别出
    IIFE。
- en: 'As previously mentioned, the pattern is called IIFE (pronounced *iffy*). The
    name is easy to understand: you define a function and call it right away so that
    it gets executed on the spot. Why would you do this, instead of simply writing
    the code inline? The reason has to do with scopes.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这种模式被称为 IIFE（发音为 *iffy*）。这个名字很容易理解：你定义一个函数并立即调用它，以便它立即执行。你为什么要这样做，而不是简单地内联编写代码呢？原因与作用域有关。
- en: 'If you define any variables or functions within IIFE, then because of how JavaScript
    defines the scope of functions, those definitions will be internal, and no other
    part of your code will be able to access them. Imagine that you wanted to write
    some complicated initialization, such as the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了任何变量或函数在 IIFE 中，那么由于 JavaScript 定义函数的作用域，这些定义将是内部的，并且你的代码的其他部分将无法访问它们。想象一下，你想要编写一些复杂的初始化，如下所示：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'What could go wrong? The problem hinges on the fact that you could (by accident)
    have a function with the same name as any of the three here, and hoisting would
    imply that the last function would be called:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 会出什么问题？问题在于你可能会（意外地）有一个与这三个中的任何一个具有相同名称的函数，提升会导致最后一个函数被调用：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Oops! If you had used IIFE, the problem wouldn’t have happened. (Using ESLint’s
    `no-func-assign` rule would have prevented this, too.) Also, the three inner functions
    wouldn’t even be visible to the rest of the code, which helps to keep the global
    namespace less polluted. The following code shows a widespread pattern for this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！如果你使用了 IIFE，这个问题就不会发生。（使用 ESLint 的 `no-func-assign` 规则也会防止这种情况。）此外，这三个内部函数甚至对代码的其他部分不可见，这有助于保持全局命名空间不太混乱。以下代码展示了这种广泛使用的模式：
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To see an example involving returned values, we could revisit the example from
    [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*, and write
    the following, which would create a single counter:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看涉及返回值的示例，我们可以回顾[*第1章*](B19301_01.xhtml#_idTextAnchor015) *成为函数式*中的示例，并编写以下代码，这将创建一个单独的计数器：
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Then, every call to `myCounter()` would return an incremented count, but there
    is no chance that any other part of your code will overwrite the inner `count`
    variable because it’s only accessible within the returned function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次调用 `myCounter()` 都会返回一个增加的计数，但没有任何其他部分的代码有机会覆盖内部的 `count` 变量，因为它只可以在返回的函数中访问。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went over several ways of defining functions in JavaScript,
    focusing mainly on arrow functions, which have several advantages over standard
    functions, including being terser. We learned about the concept of currying (which
    we’ll be revisiting later), considered some aspects of functions as first-class
    objects, and reviewed several techniques that happen to be fully FP in concept.
    Rest assured that we’ll be using everything in this chapter as the building blocks
    for more advanced techniques in the rest of this book; just wait and see!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在 JavaScript 中定义函数的几种方法，主要关注箭头函数，它们在简洁性方面具有几个优点，优于标准函数。我们学习了柯里化（我们稍后会再次讨论）的概念，考虑了函数作为一等对象的一些方面，并回顾了几种实际上是完全函数式编程概念的技术。请放心，我们将使用本章中的所有内容作为本书其余部分更高级技术的基石；只需等待并观察！
- en: In [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, we
    will delve even more deeply into functions and learn about the concept of pure
    functions, leading us to an even better programming style.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B19301_04.xhtml#_idTextAnchor069) *行为规范*中，我们将更深入地探讨函数，并了解纯函数的概念，这将引导我们走向更好的编程风格。
- en: Questions
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 3.1 `type` attribute, used to determine what kind of action you are creating.
    The following code supposedly produces an action, but can you explain the unexpected
    results?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 3.1 `type` 属性，用于确定你正在创建什么类型的操作。以下代码据说会产生一个操作，但你能否解释意外结果？
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 3.2 `useArguments()` and `useArguments2()` from the *Working with arguments*
    section by using arrow functions instead of the way we did, with the `function`
    keyword?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 3.2 使用箭头函数而不是我们用 `function` 关键字的方式，从*处理参数*部分的 `useArguments()` 和 `useArguments2()`。
- en: 3.3 `sum3()` and `altsum3()`, but we didn’t do that for `fn1`, `fn2`, and `fn3`.
    What are the types of those functions?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3 `sum3()` 和 `altsum3()`，但我们没有对 `fn1`、`fn2` 和 `fn3` 做这样的事情。这些函数的类型是什么？
- en: '3.4 `doAction2()` as a one-liner, even though you can’t tell this from the
    formatting! What do you think: is it correct or isn’t it?'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 3.4 `doAction2()` 作为一行代码，尽管从格式上无法看出这一点！你认为这是正确的还是不正确的？
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 3.5 `doAction()`, `dispatchTable`, and `doAction2()`? Be sure to describe all
    needed types, too.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 3.5 `doAction()`、`dispatchTable` 和 `doAction2()`？务必描述所有需要的类型。
- en: 3.6 `set()` method. After creating the new store object, he wrote the following
    so that the arguments to `store.set()` would be logged before being processed.
    Unfortunately, the code didn’t work as expected. What’s the problem? Can you spot
    the mistake?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 3.6 `set()` 方法。在创建新的存储对象后，他编写了以下代码，以便在处理之前记录 `store.set()` 的参数。不幸的是，代码没有按预期工作。问题是什么？你能找到错误吗？
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 3.7 `bind()` was not available; how could you do a polyfill for it?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 3.7 `bind()` 不可用；你如何为它做 polyfill？
- en: 3.8 `myNumbers.sort((a:number, b:number) => a-b)` – why/how does this work?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8 `myNumbers.sort((a:number, b:number) => a-b)` – 为什么/它是如何工作的？
- en: '3.9 **Negative sort**: Earlier, in the *Injection – sorting it out* section,
    we saw that sorting numbers as strings produces unexpected results. What would
    the result be if the array included both negative and positive numbers?'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 3.9 **负数排序**：在之前的*注入 – 排序它*部分，我们看到了将数字作为字符串排序会产生意外的结果。如果数组中包含负数和正数，结果会是什么？
- en: '3.10 **Lexicographic sorting**: When sorting, say, book titles or personal
    names, special collation rules are applied. For instance, “THE SHINING” would
    be sorted as “SHINING, THE,” and “Stephen King” would be sorted as “King, Stephen.”
    How could you (efficiently) implement such sorting?'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 3.10 **字典序排序**：在排序，比如书籍标题或个人姓名时，会应用特殊的排序规则。例如，“THE SHINING”将被排序为“SHINING, THE”，而“Stephen
    King”将被排序为“King, Stephen”。你如何（高效地）实现这样的排序？
- en: 3.11 `console.log()` method doesn’t have the correct data type – for instance,
    our version just allows a single argument. Can you provide the right data type
    definition?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 3.11 `console.log()` 方法没有正确的数据类型 – 例如，我们的版本仅允许单个参数。你能提供正确的数据类型定义吗？
