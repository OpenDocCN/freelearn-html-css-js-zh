- en: Implementing RESTful Services with Node
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node实现RESTful服务
- en: 'We will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下配方：
- en: Developing a server with Express
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express开发服务器
- en: Adding middleware
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加中间件
- en: Getting request parameters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取请求参数
- en: Serving static files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Adding routes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加路由
- en: Implementing secure connections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现安全连接
- en: Adding security safeguards with Helmet
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helmet添加安全保障
- en: Implementing CORS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现CORS
- en: Adding authentication with JWT
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JWT添加身份验证
- en: Tying it all together – building a REST server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容绑在一起-构建REST服务器
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the last chapter, we looked at a set of important basic Node techniques.
    In this chapter, we will use them to set up a basic server with `Express` and
    build on that until we get to produce a RESTful server that's appropriate for
    a **Services Oriented Architecture** (**SOA**) setup.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了一系列重要的基本Node技术。在本章中，我们将使用它们来建立一个基本的`Express`服务器，并在此基础上进行扩展，直到我们能够生成一个适用于**面向服务的架构**（**SOA**）设置的RESTful服务器。
- en: Developing a server with Express
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express开发服务器
- en: While you can work with plain vanilla `Node` and do everything, today `Express`
    is surely the most used `Node` framework, allowing you to easily develop servers
    by providing a whole bunch of basic functionality. First, let's install it and
    check it's working, and then move on to constructing services and more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用普通的`Node`并做任何事情，但今天`Express`无疑是最常用的`Node`框架，它允许您通过提供大量基本功能来轻松开发服务器。首先，让我们安装它并检查它是否工作，然后继续构建服务等。
- en: In this recipe, we'll start by doing the basic installation of `Express` so
    that we can use it in later sections for more advanced work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将首先进行`Express`的基本安装，以便我们可以在后面的章节中进行更高级的工作。
- en: You can learn more about `Express` at [https://expressjs.com/](https://expressjs.com/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://expressjs.com/](https://expressjs.com/)了解更多关于`Express`的信息。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '如何做... '
- en: 'Let''s install `Express` and make sure that it works. Installation is basically
    trivial because it''s just another `npm` package, so you just need a simple command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装`Express`并确保它可以工作。安装基本上很简单，因为它只是另一个`npm`包，所以你只需要一个简单的命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can add a `--verbose` optional parameter to the `npm` command to get a more
    verbose output and be able to see that things are happening.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`npm`命令中添加一个`--verbose`可选参数，以获得更详细的输出并能够看到发生的事情。
- en: 'Next, let''s redo our basic test server from the previous chapter, but using
    `Express`. And, yes, this is way overkill for such a simple feature, but we just
    want to check that we set everything up in the right fashion! Refer to the following
    code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重新做一下上一章的基本测试服务器，但使用`Express`。是的，对于这样一个简单的功能来说，这实在是过度了，但我们只是想检查我们是否以正确的方式设置了一切！参考以下代码：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Running this server is practically the same as with our very basic `Node` one:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此服务器与我们非常基本的`Node`服务器几乎相同：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can do the same tests as earlier, and note the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行与之前相同的测试，并注意以下内容：
- en: Accessing the `/` address gets back a `Server alive` message
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问`/`地址会返回一个`服务器活着`的消息
- en: 'Other paths produce a 404 (Not Found) error:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他路径会产生404（未找到）错误：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Trying to access other paths (or `/`, but not with `GET`) will return a `404`
    error and a HTML error screen:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问其他路径（或`/`，但不是使用`GET`）将返回一个`404`错误和一个HTML错误屏幕：
- en: '![](img/26f05363-d552-4848-9734-5c8e64c40ded.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26f05363-d552-4848-9734-5c8e64c40ded.png)'
- en: The basic Express configuration shows an error screen for 404 (Not Found) errors
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Express配置显示了404（未找到）错误的错误屏幕
- en: The key line is the `app.get("/", (req, res) => ...)` call. Basically, after
    having created the application object (`app`) you can specify a route (in this
    case, `/`), a HTTP method (such as `.get()`, `.post()`, `.put()`, and `.delete()`),
    and a whole lot more.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的一行是`app.get("/", (req, res) => ...)`调用。基本上，在创建了应用程序对象（`app`）之后，您可以指定一个路由（在本例中为`/`），一个HTTP方法（例如`.get()`，`.post()`，`.put()`和`.delete()`），以及更多内容。
- en: Go to [https://expressjs.com/en/4x/api.html#app.METHOD](https://expressjs.com/en/4x/api.html#app.METHOD)
    for more on the available methods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[https://expressjs.com/en/4x/api.html#app.METHOD](https://expressjs.com/en/4x/api.html#app.METHOD)了解更多可用方法。
- en: You can also use `.all()` as a catch-all for every possible method, and a function
    that will get called when the user hits that particular path. In our case, no
    matter what the request (`req`) is, the response (`res`) is constant, but obviously
    you'd want to do more for an actual service!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`.all()`作为每种可能方法的捕获，以及当用户点击特定路径时将被调用的函数。在我们的情况下，无论请求（`req`）是什么，响应（`res`）都是恒定的，但显然您希望为实际服务做更多事情！
- en: It goes without saying that you will surely have more than one route, and possibly
    process not only `GET` methods. You can certainly add many more routes and methods,
    and we'll get to more advanced routing in upcoming sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，您肯定会有多个路由，可能不仅处理`GET`方法。您肯定可以添加许多更多的路由和方法，我们将在接下来的章节中介绍更高级的路由。
- en: The other interesting line is `app.listen()`, which specifies what port to listen
    to, and a function that will be executed when the server starts up; in our case,
    it's just a log message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一条有趣的线是`app.listen()`，它指定要监听的端口，以及在服务器启动时将执行的函数；在我们的情况下，它只是一个日志消息。
- en: Now that we have managed to get our server running, let's implement some other
    usual server functionality.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功运行了服务器，让我们实现一些其他常见的服务器功能。
- en: Adding middleware
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加中间件
- en: '`Express` bases all of its functionality on a key concept: *middleware*. If
    you work with plain vanilla Node, you have to write a single large *request handler* that
    will have to take care of all of the requests your server may receive. By using
    middleware, `Express` lets you break down this process into smaller pieces, in
    a more functional, pipeline-ish sort of way. If you need to check security, log
    requests, handle routing, and so on, all will be done by appropriately placed
    middleware functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Express`的所有功能都基于一个关键概念：*中间件*。如果你使用纯粹的Node，你必须编写一个单一的大型*请求处理程序*来处理服务器可能收到的所有请求。通过使用中间件，`Express`让你将这个过程分解成更小的部分，以一种更加功能化、管道式的方式。如果你需要检查安全性、记录请求、处理路由等等，所有这些都将由适当放置的中间件函数来完成。'
- en: 'First, let''s understand how `Express` differs from `Node`, see how we can
    add some basic middleware of our own, and only then move on to apply the usual
    functions for common needs. Refer to the following diagram for more information:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解`Express`与`Node`的区别，看看我们如何添加一些基本的自定义中间件，然后再应用常见需求的通常函数。更多信息请参考以下图表：
- en: '![](img/e8a129e0-6943-46e0-a7e1-9bb702789148.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8a129e0-6943-46e0-a7e1-9bb702789148.png)'
- en: Standard processing, in absence of the Express middleware handling – your code
    must do all of the processing
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 标准处理，在没有Express中间件处理的情况下 - 你的代码必须处理所有的处理
- en: 'In standard processing (see the preceding diagram), `Node` gets requests from
    internet clients, passes them to your code for processing, gets the generated
    response, and passes it along to the original client. Your code must handle everything
    in what amounts, basically, to a very large function, dealing with security, encryption,
    routing, errors, and so on. If you add `Express` to the mix, the process changes
    a bit:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准处理中（参见前面的图表），`Node`从互联网客户端获取请求，将它们传递给你的代码进行处理，获取生成的响应，并将其传递给原始客户端。你的代码必须处理所有的东西，基本上相当于一个非常大的函数，处理安全性、加密、路由、错误等等。如果你将`Express`加入其中，这个过程会有所改变：
- en: '![](img/62196a34-5120-48f6-8a5e-5d17adbcfbdb.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62196a34-5120-48f6-8a5e-5d17adbcfbdb.png)'
- en: When Express is added, it handles requests by passing them to a middleware stack
    to produce the response
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当Express被添加时，它通过将请求传递给中间件堆栈来处理响应
- en: In this case, you set up a series of functions that will be called in order
    by `Express`, and each function will deal with a specific aspect of the overall
    process, simplifying the overall logic. Moreover, you won't have to directly deal
    with common problems (say, CORS or zipping, to mention just a few) because there
    are plenty of `Express` packages that already provide such functions; all you
    have to do is add them to the stack, at the appropriate place.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你设置了一系列函数，`Express`会按顺序调用它们，每个函数都处理整个过程的一个特定方面，简化了整体逻辑。此外，你不必直接处理常见问题（比如，CORS或压缩等），因为有很多`Express`包已经提供了这样的功能；你只需要将它们添加到适当的位置。
- en: To get a better idea of how this works, in this recipe let's develop a very
    basic request logger (we'll learn about it in depth in the *Adding HTTP logging
    with Morgan* section of [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml),
    *Testing and Debugging Your Server*) and an error reporter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解这是如何工作的，在这个示例中，让我们开发一个非常基本的请求日志记录器（我们将在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)的*使用Morgan添加HTTP日志记录*部分中深入学习），以及一个错误报告器。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: If you want to add some middleware, you have to place it in the correct order
    among all of the functions that you define. For example, if you want to log something,
    you'd probably want to do it before any processing is done, so you'd add that
    definition at the top of your stack, or very near to it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想添加一些中间件，你必须将它放在你定义的所有函数中的正确顺序中。例如，如果你想要记录一些东西，你可能希望在任何处理之前就这样做，所以你会在堆栈的顶部或者非常靠近顶部添加这个定义。
- en: 'Middleware functions receive three parameters: the incoming HTTP request (let''s
    call it `req`, as we''ve been doing so far), the outgoing HTTP response (`res`),
    and a function that you must call when you want processing to continue with the
    next piece of middleware in the stack (`next()`). When your middleware gets called,
    it must either send a response (by using `res.send()`, `res.sendFile()`, or `res.end()`)
    or call `next()` so that the following functions in the stack will get the chance
    to produce the answer.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数接收三个参数：传入的HTTP请求（我们一直称之为`req`），传出的HTTP响应（`res`），以及当你希望继续处理下一个中间件时必须调用的函数（`next()`）。当你的中间件被调用时，它必须要么发送一个响应（使用`res.send()`、`res.sendFile()`或`res.end()`），要么调用`next()`，以便堆栈中的下一个函数有机会产生答案。
- en: Error functions are a bit different, and they add an error (`err`) parameter
    to the three we just listed; having four parameters is what marks the function
    as an error processor in the eyes of `Express`. If everything works fine, `Express`
    skips the error middleware, but if an error occurs, `Express` will skip every
    function until it gets to the first available error function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 错误函数有些不同，它们在我们刚刚列出的三个参数中添加了一个错误（`err`）参数；有四个参数的函数在`Express`眼中标志着它是一个错误处理器。如果一切正常，`Express`会跳过错误中间件，但如果发生错误，`Express`将跳过每个函数，直到它找到第一个可用的错误函数。
- en: 'Let''s jump to the end and view our complete middleware example, which will
    be as follows; we''ll explain how it works in the next section:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到最后，查看我们完整的中间件示例，如下所示；我们将在下一节中解释它是如何工作的：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start with our logger. We want it to apply to every path so that we
    can just omit the path. An alternative would be writing `app.use("*", ...)`, which
    means exactly the same; we''ll also use it as an example. Your logic could do
    anything, and since we want to log requests, we can just list the current timestamp,
    the `request` method, and the requested path. Afterwards—and this is the most
    important thing—since we haven''t finished dealing with the request, calling `next()`
    is mandatory, or the request will end up in a processing limbo, never sending
    anything to the client:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的日志记录器开始。我们希望它适用于每个路径，这样我们就可以省略路径。另一种方法是编写`app.use("*", ...)`，它的意思完全相同；我们也将使用它作为示例。您的逻辑可以做任何事情，由于我们想要记录请求，我们可以列出当前时间戳、`request`方法和请求的路径。之后——这是最重要的事情——由于我们还没有处理请求，调用`next()`是强制的，否则请求将陷入处理的困境，永远不会向客户端发送任何内容：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since we want to have some errors, let''s define that the `DELETE` methods
    aren''t to be accepted, so `next()` will be called, but passing an error object;
    other requests will just get a simple text answer. Our main request processing
    code could then be as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望有一些错误，让我们定义`DELETE`方法不被接受，因此将调用`next()`，但传递一个错误对象；其他请求将只得到一个简单的文本答复。然后，我们的主要请求处理代码可能如下所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, our error processing code will log the error, and send back a `500`
    status:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的错误处理代码将记录错误，并返回`500`状态：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You'll note the need for disabling the `no-unused-vars` ESLint rule. Recognizing
    errors just by the function signature is not a very good practice, and if you
    are setting your error handler at the end of the stack so that there's no other
    function to call, the next parameter will be unused and cause an error. There
    is some talk of solving this situation in upcoming versions of `Express`, but
    for now the point is moot.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到需要禁用`no-unused-vars`ESLint规则。仅通过函数签名识别错误并不是一个很好的做法，如果您将错误处理程序设置在堆栈的末尾，以便没有其他函数可以调用，那么下一个参数将是未使用的，并且会导致错误。有一些关于在即将推出的`Express`版本中解决这种情况的讨论，但目前这一点并不重要。
- en: The error code we just showed, basic as it is, could be used in practically
    every Node server you write. We will be using it as is in our examples.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚展示的错误代码，尽管很基本，但实际上可以在您编写的几乎每个Node服务器中使用。我们将在我们的示例中使用它。
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We''ve set everything up; now, let''s see our code working:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置好了一切；现在，让我们看看我们的代码是如何工作的：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can use some curl requests to test this; let''s use `GET`, `POST`, and `DELETE`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些curl请求来测试这个；让我们使用`GET`、`POST`和`DELETE`：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The logged output will be as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的输出将如下所示：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we now know how to write our own middleware, but it so happens that `Express`
    provides lots of ready-made functions. Let's give them a whirl and look at how
    we can use them for several common needs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何编写自己的中间件，但恰好`Express`提供了许多现成的函数。让我们试试它们，看看我们如何在几个常见需求中使用它们。
- en: Getting request parameters
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取请求参数
- en: 'Let''s get to a basic problem: how do you get the request parameters? In our
    earlier example, in the *Working with streams to process requests* section of
    the previous chapter, we did it by hand, working with the request stream to get
    the body, and using parsing functions to extract the parameters. However, `Express`
    already provides some middleware you can use before any other function in your
    stack that needs parameters, either from the body or the URL itself. So in this
    recipe, let''s see how we can access the request parameters, which is a very basic
    need.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决一个基本问题：如何获取请求参数？在我们之前的示例中，在上一章的*使用流处理请求*部分中，我们手动处理了请求流以获取主体，并使用解析函数提取参数。但是，`Express`已经提供了一些中间件，您可以在堆栈中的任何其他函数之前使用，这些函数需要来自主体或URL本身的参数。因此，在本教程中，让我们看看如何访问请求参数，这是一个非常基本的需求。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see what it takes to access the parameters. First, you have to require
    the `body-parser` module and ask for the options you want; we''ll get into that
    next:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何访问参数。首先，您必须要求`body-parser`模块，并要求您想要的选项；我们将在下一节中详细介绍：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since you want the parameters to be parsed before any processing, the `app.use()`
    line will be at the top of your stack.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您希望在任何处理之前解析参数，因此`app.use()`行将位于堆栈的顶部。
- en: 'Now, getting into more detail, the `body-parser` module provides four parsers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更详细地了解一下，`body-parser`模块提供了四个解析器：
- en: '*A URL-encoded body parser*, just like we''re using here, to read about the
    differences in using `extended` true or false. Checkout [https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser) for
    more information.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*URL编码的body解析器*，就像我们在这里使用的一样，阅读有关使用`extended` true或false的差异。查看[https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser)获取更多信息。'
- en: '*A JSON body parser*, as in `bodyParser.json()`, to process requests with `Content-Type` is
    done through `application/json`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSON body解析器*，如`bodyParser.json()`，用于处理`Content-Type`为`application/json`的请求。'
- en: '*A raw body parser*, as with `bodyParser.raw()`, to process `application/octet-stream`
    contents by default, though this can be changed by providing a `type` option.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原始body解析器*，如`bodyParser.raw()`，默认情况下用于处理`application/octet-stream`内容，尽管可以通过提供`type`选项进行更改。'
- en: '*A text body parser*, like `bodyParser.text()`, to process `text/plain` content.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文本body解析器*，如`bodyParser.text()`，用于处理`text/plain`内容。'
- en: The three latter parsers may provide extra options; check the documentation
    for more on that. Note, however, that if you have to deal with multipart bodies,
    then you cannot rely on a body-parser; see [https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser) for
    some alternatives, and see what suits you.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 后三个解析器可能提供额外的选项；查看文档以获取更多信息。但是，请注意，如果您必须处理多部分主体，那么您不能依赖于`body-parser`；请参阅[https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser)获取一些替代方案，并查看适合您的内容。
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We only had to add a couple of lines, and everything was set up. We can see
    our code working by either changing our logger from the previous section, or by
    writing code like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要添加几行代码，一切就设置好了。我们可以通过更改前一节中的记录器，或者编写如下代码来看到我们的代码工作：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'URL parameters are automatically separated by `Express` into `req.query`, and
    `req.body` will be parsed by `bodyParser`. We can try a couple of service calls,
    a `GET` and a `POST`, to cover all cases:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: URL参数会被`Express`自动分离为`req.query`，`req.body`将被`bodyParser`解析。我们可以尝试一些服务调用，`GET`和`POST`，以涵盖所有情况：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output will be as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first case (`GET`), we can see that `req.query` is an object with the
    three query parameters, while in the second case (`POST`) there are no query parameters,
    but the `req.body` provides the single parameter (`name`) we provided.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况（`GET`）中，我们可以看到`req.query`是一个带有三个查询参数的对象，而在第二种情况（`POST`）中，没有查询参数，但`req.body`提供了我们提供的单个参数（`name`）。
- en: This should convince you of the merits of Express' design, based on a middleware
    stack, but let's go through some more examples, such as working with static files,
    routing, security, and more.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让您相信Express的设计的优点，基于中间件堆栈，但让我们通过一些更多的例子来看一下，比如处理静态文件、路由、安全性等等。
- en: Serving static files
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: We are planning to create a set of REST services, but it's very possible that
    your server will also have to serve some static files, such as images, PDFs, and
    so on. On principle, you could do this by hand by setting specific routes for
    each static asset, and then writing a function that would read the required file
    and stream its contents to the client; we did something like that in the *Working
    with streams to process requests* section in the previous chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划创建一组REST服务，但您的服务器很可能还需要提供一些静态文件，比如图片、PDF等等。原则上，您可以通过手动设置特定路由来处理每个静态资源，然后编写一个函数来读取所需的文件并将其内容流式传输到客户端；我们在前一章的*使用流处理请求*部分做了类似的事情。
- en: However, this is such a common and reiterative task that `Express` provides
    a simpler solution; let's look at how we can simply serve static files.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个如此常见和重复的任务，`Express`提供了一个更简单的解决方案；让我们看看如何简单地提供静态文件。
- en: An even better solution would be to have another server, such as nginx, in your
    stack and have it handle static files. Standard servers are much better at handling
    this type of simple request, and will leave your Node code free to handle more
    complex, demanding tasks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是在您的堆栈中添加另一个服务器，比如nginx，并让它处理静态文件。标准服务器更擅长处理这种类型的简单请求，并且会让您的Node代码空闲下来处理更复杂、更苛刻的任务。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s suppose we want to have some flag icons served for an application. I
    did the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想为一个应用程序提供一些国旗图标。我做了以下操作：
- en: I created, at the same level as the `/out` directory into which the output files
    go, a `/flags` directory with some subdirectories: `/flags/america/north`, `/flags/america/south`,
    and `/flags/europe`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我在与输出文件所在的`/out`目录同级别创建了一个`/flags`目录，并在其中创建了一些子目录：`/flags/america/north`，`/flags/america/south`和`/flags/europe`。
- en: I placed some free flag icons by *GoSquared*, taken from [https://www.gosquared.com/resources/flag-icons/](https://www.gosquared.com/resources/flag-icons/) in
    those directories. For variety, the flags are accessible at the `/static` path,
    which doesn't actually exist.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我在这些目录中放了一些来自*GoSquared*的免费国旗图标，取自[https://www.gosquared.com/resources/flag-icons/](https://www.gosquared.com/resources/flag-icons/)。为了多样化，这些国旗可以在`/static`路径下访问，实际上并不存在。
- en: 'I wrote the following code; this is the basic server from earlier, with just
    some added code (in bold font) to deal with static files:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我写了以下代码；这是之前的基本服务器，只是添加了一些代码（用粗体字显示）来处理静态文件：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you want to read more about serving static files, check out Node's documentation
    at [https://expressjs.com/en/starter/static-files.html](https://expressjs.com/en/starter/static-files.html).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想阅读更多关于提供静态文件的信息，请查看Node的文档[https://expressjs.com/en/starter/static-files.html](https://expressjs.com/en/starter/static-files.html)。
- en: '`app.use()`, in this case, gets a special function, `express.static()`, which
    takes care of sending files in the given path, with some headers for caching;
    let''s get into the details:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`app.use()`得到了一个特殊的函数`express.static()`，它负责发送给定路径中的文件，并带有一些缓存标头；让我们深入了解一下：
- en: The first parameter to `app.use()` is the base of the path that the user will
    select; note that it doesn't need to exist in the actual directory, as in other
    examples we have seen. We could write `app.use()` if we want to accept all HTTP
    methods, by the way.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.use()`的第一个参数是用户将选择的路径的基础；请注意，它不需要存在于实际目录中，就像我们之前看到的其他示例一样。顺便说一句，如果我们想接受所有HTTP方法，我们可以写`app.use()`。'
- en: 'The first parameter to `express.static()` specifies the path where the files
    are found. I''m using the `path.join()` function to find out the actual path:
    `/flags` at the same level as `/out`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express.static()`的第一个参数指定了文件所在的路径。我使用`path.join()`函数来找到实际路径：`/flags`与`/out`在同一级别。'
- en: The second parameter to `express.static()` lets you add options; in our case,
    I'm sending some caching headers so that browsers will know that the file can
    be safely cached for 30 days.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express.static()`的第二个参数允许您添加选项；在我们的例子中，我发送了一些缓存标头，以便浏览器知道该文件可以安全地缓存30天。'
- en: The format for the `maxAge` parameter can be in a format understood by the `ms`
    package ([https://github.com/zeit/ms](https://github.com/zeit/ms)), which is able
    to convert date and time strings into the equivalent milliseconds, which is standard
    for JS.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxAge`参数的格式可以是`ms`包（[https://github.com/zeit/ms](https://github.com/zeit/ms)）理解的格式，它能够将日期和时间字符串转换为相应的毫秒数，这是JS的标准。'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Whenever the user specifies a path starting with `/static`, it is converted
    into the equivalent starting from `/flags`, and if the file is found, it will
    be sent back, with the caching headers included. Check out the following screenshot
    for an example of this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户指定以`/static`开头的路径时，它会被转换成等效的以`/flags`开头的路径，如果找到文件，它将被发送回来，并包括缓存头。查看以下截图，以了解此示例：
- en: '![](img/a4a1be1a-646c-43ea-9144-6db7632119b0.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4a1be1a-646c-43ea-9144-6db7632119b0.png)'
- en: A static flag icon, served from a non-existing path, /static, mapped to an actual
    path
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静态的标志图标，从一个不存在的路径/static提供，映射到一个实际的路径
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you want to send static files for some specific reason, without using the
    method shown in the preceding section, you can use routing and the `res.sendFile()`
    method, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想出于某种特定原因发送静态文件，而不使用前一节中显示的方法，您可以使用路由和`res.sendFile()`方法，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you access [http://127.0.0.1:8080/uruguay](http://127.0.0.1:8080/uruguay/),
    you''ll get my home country''s flag, and [http://127.0.0.1:8080/license](http://127.0.0.1:8080/license)
    will retrieve the MIT license for the icon set I chose; see the latter in the
    following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问[http://127.0.0.1:8080/uruguay](http://127.0.0.1:8080/uruguay/)，您将得到我的祖国的国旗，而[http://127.0.0.1:8080/license](http://127.0.0.1:8080/license)将检索我选择的图标集的MIT许可证；请参见以下截图：
- en: '![](img/6e7eb6ab-c3f6-4e04-98ad-790ad85067fc.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e7eb6ab-c3f6-4e04-98ad-790ad85067fc.png)'
- en: Testing a different route that sends back a text file
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 测试发送文本文件的不同路由
- en: Of course, you wouldn't use this method if you had lots of static files to provide,
    but if you have only a few, then this alternative solution works very well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您有很多静态文件需要提供，您不会使用这种方法，但如果您只有一些文件，那么这种替代解决方案非常有效。
- en: You may have noticed that I didn't add headers for caching, but it can certainly
    be done. Read more on `res.sendFile()` at [https://expressjs.com/en/api.html#res.sendFile](https://expressjs.com/en/api.html#res.sendFile),
    in particular the `immutable` and `headers` options.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我没有为缓存添加头信息，但这当然是可以做的。在[https://expressjs.com/en/api.html#res.sendFile](https://expressjs.com/en/api.html#res.sendFile)上阅读更多关于`res.sendFile()`的信息，特别是`immutable`和`headers`选项。
- en: Adding routes
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路由
- en: No matter what kind of server you are building (a RESTful one, as we plan to
    do, or any other kind), you'll have to deal with routing, and `Node` and `Express`
    together provide easy ways of doing this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您构建什么样的服务器（我们计划构建一个RESTful服务器，或者其他任何类型的服务器），您都必须处理路由，`Node`和`Express`提供了简单的方法来做到这一点。
- en: 'Going back to our database from the *Working with a database* section in the
    previous chapter, in a RESTful fashion, we should provide the following routes,
    allowing for the given methods:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们在上一章*与数据库一起工作*中的数据库，以RESTful的方式，我们应该提供以下路由，允许给定的方法：
- en: '`/countries` (`GET` to obtain the list of all countries, and `POST` to create
    a new country)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/countries`（`GET`获取所有国家的列表，`POST`创建一个新的国家）'
- en: '`/countries/someCountryId` (`GET` to access a country, `PUT` to update one,
    and `DELETE` to delete one)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/countries/someCountryId`（`GET`访问一个国家，`PUT`更新一个国家，`DELETE`删除一个国家）'
- en: '`/regions` (`GET` to get all regions of all countries, `POST` to create a new
    region)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/regions`（`GET`获取所有国家的所有地区，`POST`创建一个新的地区）'
- en: '`/regions/someCountryId` (`GET` to get all regions of a given country)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/regions/someCountryId`（`GET`获取给定国家的所有地区）'
- en: '`/regions/someCountryId/someRegionId` (`GET` to access a region, `PUT` to update
    one, `DELETE` to delete one)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/regions/someCountryId/someRegionId`（`GET`访问一个地区，`PUT`更新一个地区，`DELETE`删除一个地区）'
- en: '`/cities` (`GET` to get all cities – but we won''t really want to allow this
    because of the resulting set size!—plus `POST` to create a new one)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cities`（`GET`获取所有城市 - 但由于结果集的大小，我们实际上不会想要允许这样做！—再加上`POST`创建一个新的城市）'
- en: '`/cities/someCityId` (`GET` to access a city, `PUT` to update one, and `DELETE`
    to delete a city)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cities/someCityId`（`GET`访问一个城市，`PUT`更新一个城市，`DELETE`删除一个城市）'
- en: You could also allow for extra parameters, for example, to allow paging a result
    set, or to enable some filtering, but what we care about now is setting up the
    routes. You could set up all of the necessary routes in the main file, as we have
    been doing in our short examples so far, but as you start adding more and more
    routes, some organization is needed to avoid ending up with a thousands-of-lines-long
    main file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以允许额外的参数，例如允许对结果集进行分页，或者启用一些过滤，但我们现在关心的是设置路由。您可以在主文件中设置所有必要的路由，就像我们在迄今为止的简短示例中所做的那样，但是随着您开始添加更多的路由，需要一些组织来避免最终得到一个数千行长的主文件。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Thanks to `Express`, we won''t need too much code, with only two new lines
    to enable our routing; check out the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Express`的帮助，我们不需要太多的代码，只需要两行新代码来启用我们的路由；查看以下代码：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `router_home.js` module could have the first level of route branching,
    as shown in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`router_home.js`模块可以具有路由分支的第一级，如下面的代码所示：'
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And, going down one more level, we'd have three more files specifying the next
    levels. For example, routing for countries would be as follows. You'll note a
    weird extra route, `/URUGUAY`, which I added just to show you that we can have
    more routes than a RESTful server would require!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，再往下一级，我们将有三个指定下一级的文件。例如，国家的路由将如下所示。您会注意到一个奇怪的额外路由`/URUGUAY`，我只是为了向您展示我们可以有比RESTful服务器需要的更多路由！
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The regions routing file will be as shown in the following code, and we''ll
    skip the cities routing since it''s quite similar to countries routing:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 地区路由文件将如下所示，并且我们将跳过城市路由，因为它与国家路由非常相似：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can read more about `Express` routing at [https://expressjs.com/en/starter/basic-routing.html](https://expressjs.com/en/starter/basic-routing.html)
    and [https://expressjs.com/en/guide/routing.html](https://expressjs.com/en/guide/routing.html).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://expressjs.com/en/starter/basic-routing.html](https://expressjs.com/en/starter/basic-routing.html)和[https://expressjs.com/en/guide/routing.html](https://expressjs.com/en/guide/routing.html)上阅读更多关于`Express`路由的信息。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Of course, our so-called *RESTful server* is, at least for now, a total joke,
    since it just returns constant answers, doing nothing at all, but the key parts
    are practically all here. First, let's analyze its structure. When you write `app.use(somePath,
    aRouter)`, it means that all of the routes starting with the given path will be
    taken up by the provided router, which will take care of the routes from the given
    path onward. First, we write a basic router starting at `/`, and then break down
    the routes by path (`/countries`, `/regions`, and `/cities`), writing a router
    for each one. These latter routers will go deeper in the paths, until all of your
    routes are mapped out.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们所谓的*RESTful服务器*，至少目前来说，是一个彻头彻尾的笑话，因为它只返回固定的答案，什么都不做，但关键部分基本上都在这里。首先，让我们分析它的结构。当你写`app.use(somePath,
    aRouter)`时，这意味着所有以给定路径开头的路由都将由提供的路由接管，该路由将负责从给定路径开始的路由。首先，我们写一个从`/`开始的基本路由，然后按路径（`/countries`、`/regions`和`/cities`）拆分路由，为每个路径编写一个路由。这些后续的路由将深入到路径中，直到所有的路由都被映射出来。
- en: 'To make it clear: when the server receives a request for, say, `/regions/uy`,
    the request is first handled by our main router (at `routing.js`), which passes
    it to the home router (`router_home.js`), which passes it to the final router
    (`router_regions.js`), where the request is eventually handled.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要搞清楚：当服务器收到一个请求，比如`/regions/uy`，请求首先由我们的主路由（在`routing.js`）处理，然后传递给主页路由（`router_home.js`），再传递给最终路由（`router_regions.js`），最终在那里处理请求。
- en: 'Now, let''s move on to the routes by themselves. There are two kind of routes
    here: *constant* routes such as `/countries` and *variable* routes such as `/regions/uy/4`,
    which include some varying items, such as `uy` and `4`, in this case. When you
    write a route such as `/regions/:country/:id`, Express will pick out the varying
    parts (here, `:country` and `:id`) and make them available as properties of the
    `req.params` object (`req.params.country` and `req.params.id`) so that you can
    use them in your logic.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看路由本身。这里有两种路由：*常量*路由，比如`/countries`，和*变量*路由，比如`/regions/uy/4`，其中包括一些变化的项目，比如在这种情况下的`uy`和`4`。当你写一个路由，比如`/regions/:country/:id`，Express会提取出变化的部分（这里是`:country`和`:id`），并将它们作为`req.params`对象的属性（`req.params.country`和`req.params.id`）提供，这样你就可以在逻辑中使用它们。
- en: 'You can also use regular expressions to define a path, but remember the joke:
    a programmer has a problem; a programmer decides to solve it using regular expressions;
    a programmer now has *two* problems.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用正则表达式来定义路径，但要记住这个笑话：一个程序员有一个问题；一个程序员决定使用正则表达式来解决它；一个程序员现在有*两个*问题。
- en: 'So, if we implement some requests on the preceding path, we''ll see the functioning
    router; all we will be lacking is the actual RESTful code to produce some useful
    results, but we''ll get to that later in this chapter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们在前面的路径上实现一些请求，我们将看到功能路由；我们缺少的只是实际的RESTful代码来产生一些有用的结果，但我们将在本章后面讨论到这一点：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of course, trying some methods that aren't allowed will produce an error; try
    doing a `DELETE` request for `/regions` and you'll see what I mean. We now know
    how to do any kind of routing, but we still must be able to receive JSON objects,
    allow for CORS if needed, and some other considerations, so let's keep working
    and start by enabling secure connections with HTTPS.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，尝试一些不允许的方法会产生错误；尝试对`/regions`进行`DELETE`请求，你就会明白我的意思。我们现在知道如何进行任何类型的路由，但我们仍然必须能够接收JSON对象，如果需要的话允许CORS，以及其他一些考虑，所以让我们继续努力，首先通过HTTPS启用安全连接。
- en: Implementing secure connections
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施安全连接
- en: Sending data over HTTPS instead of HTTP is a good security practice, and actually
    mandatory if your server ever has to send sensitive, secure data over the web.
    There are many kinds of attacks that are avoided by setting up an encrypted connection
    with the client browser, so let's see how we can implement secure connections
    with `Node` and `Express`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTPS发送数据而不是HTTP是一个很好的安全实践，如果你的服务器必须通过网络发送敏感的、安全的数据，那么这实际上是强制性的。通过与客户端浏览器建立加密连接，可以避免许多种类型的攻击，所以让我们看看如何使用`Node`和`Express`实现安全连接。
- en: In this recipe, we will cover how to enable HTTPS so that our server becomes
    more secure.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将介绍如何启用HTTPS，以使我们的服务器更加安全。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We want to enable HTTPS connections, so we'll have to do a bit of work to install
    everything we need.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要启用HTTPS连接，所以我们需要做一些工作来安装我们需要的一切。
- en: The first step in this installation will be getting yourself a certificate that
    properly validates the site that you own. Buying it goes beyond this book, so
    let's do a workaround by generating our own self-signed certificates—which, of
    course, aren't really secure, but will let us do all of the required configuration!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个安装过程中的第一步将是获得一个适当验证你拥有的网站的证书。购买它超出了本书的范围，所以让我们通过生成我们自己的自签名证书来解决这个问题——当然，这并不真正安全，但会让我们完成所有必要的配置！
- en: 'Let''s assume that we want to set up our `www.modernjsbook.com` site. Working
    in Linux, you can create the necessary certificate files by executing the following
    commands and answering some questions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想设置我们的`www.modernjsbook.com`网站。在Linux中工作，你可以通过执行以下命令并回答一些问题来创建必要的证书文件：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After doing this, you will end up with three files: a **Certificate Signing
    Request** (**CSR**), a KEY (Private Key), and a self-signed certificate (CRT)
    file, as follows; in real life, a **Certificate Authority** (**CA**) would be
    the actual signer:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些之后，你将得到三个文件：一个**证书签名请求**（**CSR**），一个KEY（私钥），和一个自签名证书（CRT）文件，如下；在现实生活中，一个**证书颁发机构**（**CA**）将是实际的签发者：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, when you set up your server, you must read in those files (which should
    reside in a safe, read-only directory for added security) and pass their contents
    as options. We will use the `fs` module to do this, as in previous examples, and
    since reading the files is done only when the server is loaded, `fs.readFileSync()`
    can be used. Take look at the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您设置服务器时，您必须读取这些文件（这些文件应该存放在一个安全的只读目录中，以增加安全性），并将它们的内容作为选项传递。我们将使用`fs`模块来做到这一点，就像之前的例子一样，由于只有在服务器加载时才会读取文件，因此可以使用`fs.readFileSync()`。看一下以下代码：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Why port `8443`? The reason has to do with security, and we saw why in the *Checking
    Node's setup* section of the previous chapter; it's the same motive that we had
    behind using port `8080` instead of port `80`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用端口`8443`？原因与安全有关，我们在上一章的*检查Node设置*部分看到了原因；这与我们使用端口`8080`而不是端口`80`的原因相同。
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Running the preceding code is enough to get encrypted connections to your server.
    (Of course, if you use self-signed certificates, the end user will get warnings
    about the lack of actual security, but you would get valid certificates, wouldn't
    you?) We can see the result of this in the following screenshot—and keep in mind
    that with real certificates, the user would get no alerts about your unsafe site!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码就足以使您的服务器获得加密连接。（当然，如果您使用自签名证书，最终用户将收到有关实际安全性缺失的警告，但您会获得有效的证书，不是吗？）我们可以在以下截图中看到这一结果——请记住，使用真正的证书，用户将不会收到有关您不安全网站的警报！
- en: '![](img/0fea9c51-8b9a-48c8-932e-25aba90d2bb0.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fea9c51-8b9a-48c8-932e-25aba90d2bb0.png)'
- en: Installing certificates and using HTTPS instead of HTTP generates a secure server.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安装证书并使用HTTPS而不是HTTP会生成一个安全的服务器。
- en: Of course, since we made up the certificate by ourselves, Google Chrome doesn't
    really like the site!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于我们自己制作了证书，Google Chrome并不真的喜欢这个网站！
- en: 'We can also force HTTP users to work with HTTPS by running a *second* server,
    this time with HTTP, and redirecting all traffic to our first server, which is
    secure:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过运行*第二个*服务器来强制HTTP用户使用HTTPS，这次使用HTTP，并将所有流量重定向到我们的第一个安全服务器：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A `Node` server can only listen to a single port, so you'd run this server as
    a separate instance. Now, if you try to use HTTP to access your server, you'll
    be redirected automatically, a good practice!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node`服务器只能监听一个端口，因此您需要将此服务器作为单独的实例运行。现在，如果您尝试使用HTTP访问服务器，将会自动重定向，这是一个很好的做法！'
- en: Adding secure connections is simple; let's keep on working on more security
    aspects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 添加安全连接很简单；让我们继续处理更多安全方面的工作。
- en: Adding security safeguards with Helmet
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Helmet添加安全保障
- en: Out of the box, `Express` is a very good tool for building your RESTful server,
    or to provide any other kind of service. However, unless you take some extra precautions,
    Express doesn't apply all security best practices, which may doom your server.
    Not everything is lost, in any case, because there are some packages that can
    help you with those practices, and `Helmet` (at [https://helmetjs.github.io/](https://helmetjs.github.io/))
    is one of the best for this.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Express`是一个非常好的工具，可以构建您的RESTful服务器，或者提供任何其他类型的服务。然而，除非您采取一些额外的预防措施，Express并不适用所有的安全最佳实践，这可能会使您的服务器失败。无论如何，还没有丧失一切，因为有一些软件包可以帮助您进行这些实践，`Helmet`（在[https://helmetjs.github.io/](https://helmetjs.github.io/)）是其中最好的之一。'
- en: Don't think of `Helmet`—or any other similar package, by the way—as a magic
    silver bullet that will somehow solve all of your possible present and future
    security headaches! Use it as a step in the right direction, but you must keep
    on top of possible menaces and security holes, and not trust any single package
    to manage everything.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不要认为`Helmet`——或者其他类似的软件包——是一种可以解决您可能出现的当前和未来安全问题的魔法解药！将其视为朝着正确方向迈出的一步，但您必须时刻关注可能的威胁和安全漏洞，并不要相信任何单一软件包可以管理一切。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Given that it works with `Express`, `Helmet` is also a piece of middleware.
    Its installation and setup are rather easy, fortunately. Using `npm` takes care
    of the first part:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于它与`Express`兼容，`Helmet`也是一个中间件。它的安装和设置相当容易，幸运的是。使用`npm`来处理第一部分：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Putting `Helmet` to work is just a matter of adding it at the top of the middleware
    stack:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让`Helmet`发挥作用只是在中间件堆栈的顶部添加它而已：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You''re all set! By default, `Helmet` enables the following list of security
    measures, all of which imply adding, changing, or removing specific headers from
    your response to a request. For more documentation on specific headers or options,
    check out [https://helmetjs.github.io/docs/](https://helmetjs.github.io/docs/):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好了！默认情况下，`Helmet`启用以下安全措施列表，所有这些措施都意味着向请求的响应中添加、更改或删除特定的标头。有关特定标头或选项的更多文档，请查看[https://helmetjs.github.io/docs/](https://helmetjs.github.io/docs)：
- en: '| **Module** | **Effect** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **模块** | **效果** |'
- en: '| `dnsPrefetchControl`  | Sets the `X-DNS-Prefetch-Control` header to the disable
    browsers prefetching (requests done before the user has even clicked on a link)
    to prevent privacy implications for users, who may seem to be visiting pages they
    actually aren''t visiting ([https://helmetjs.github.io/docs/dns-prefetch-control](https://helmetjs.github.io/docs/dns-prefetch-control)).
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `dnsPrefetchControl` | 将`X-DNS-Prefetch-Control`标头设置为禁用浏览器预取（在用户甚至点击链接之前完成的请求），以防止用户的隐私问题，他们可能看起来正在访问实际上并没有访问的页面([https://helmetjs.github.io/docs/dns-prefetch-control](https://helmetjs.github.io/docs/dns-prefetch-control))。
    |'
- en: '| `frameguard ` | Sets the `X-Frame-Options` header to prevent your page from
    being shown in an iframe, and thus avoids some *clickjacking* attacks that may
    cause you to unwittingly click on hidden links ([https://helmetjs.github.io/docs/frameguard/](https://helmetjs.github.io/docs/frameguard/)).
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `frameguard` | 将`X-Frame-Options`标头设置为防止页面显示在iframe中，从而避免一些可能导致您不知不觉点击隐藏链接的*点击劫持*攻击([https://helmetjs.github.io/docs/frameguard/](https://helmetjs.github.io/docs/frameguard/))。
    |'
- en: '| `hidePoweredBy ` | Removes the `X-Powered-By` header, if present, so that
    would-be attackers won''t know what technology powers the server, making targeting
    and taking advantage of vulnerabilities a bit harder ([https://helmetjs.github.io/docs/hide-powered-by](https://helmetjs.github.io/docs/hide-powered-by))
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `hidePoweredBy ` | 移除`X-Powered-By`标头（如果存在），以便潜在的攻击者不会知道服务器的技术，使得针对漏洞的攻击和利用变得更加困难
    ([https://helmetjs.github.io/docs/hide-powered-by](https://helmetjs.github.io/docs/hide-powered-by))
    |'
- en: '| `hsts ` | Sets the `Strict-Transport-Security` header so that browsers will
    keep using HTTPS instead of switching to the insecure HTTP. ([https://helmetjs.github.io/docs/hsts/](https://helmetjs.github.io/docs/hsts/))
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `hsts ` | 设置`Strict-Transport-Security`标头，以便浏览器继续使用HTTPS而不是切换到不安全的HTTP。 ([https://helmetjs.github.io/docs/hsts/](https://helmetjs.github.io/docs/hsts/))
    |'
- en: '| `ieNoOpen ` | Sets the `X-Download-Options` header to prevent old versions
    of Internet Explorer from downloading untrusted HTML in your pages ([https://helmetjs.github.io/docs/ienoopen](https://helmetjs.github.io/docs/ienoopen)).
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `ieNoOpen ` | 设置`X-Download-Options`标头，以防止旧版本的Internet Explorer在您的页面中下载不受信任的HTML
    ([https://helmetjs.github.io/docs/ienoopen](https://helmetjs.github.io/docs/ienoopen))。
    |'
- en: '| `noSniff` | Sets the `X-Content-Type-Options` header to prevent browsers
    from trying to *sniff* (guess) the MIME type of a downloaded file, to disable
    some attacks ([https://helmetjs.github.io/docs/dont-sniff-mimetype](https://helmetjs.github.io/docs/dont-sniff-mimetype)).
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `noSniff` | 设置`X-Content-Type-Options`标头，以防止浏览器尝试*嗅探*（猜测）下载文件的MIME类型，以禁用一些攻击
    ([https://helmetjs.github.io/docs/dont-sniff-mimetype](https://helmetjs.github.io/docs/dont-sniff-mimetype))。
    |'
- en: '| `xssFilter` | Sets the `X-XSS-Protection` header to disable some forms of
    **Cross-side scripting** (**XSS**) attacks, in which you could unwittingly run
    JS code on your page by clicking a link ([https://helmetjs.github.io/docs/xss-filter](https://helmetjs.github.io/docs/xss-filter)).
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `xssFilter` | 设置`X-XSS-Protection`标头，以禁用某些形式的**跨站脚本**（**XSS**）攻击，您可能会在点击链接时无意中在页面上运行JS代码
    ([https://helmetjs.github.io/docs/xss-filter](https://helmetjs.github.io/docs/xss-filter))。
    |'
- en: 'You can also opt to enable some extra options, if they apply to your requirements.
    For notes on how to do this, check out Helmet''s documentation at [https://helmetjs.github.io/docs/](https://helmetjs.github.io/docs/):
    the package, now at version 3.12.0, is often updated, and a plain `npm install`
    may not be enough to enable the newer features. Take a look at the following table:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择启用一些额外的选项，如果它们符合您的要求。有关如何执行此操作的说明，请查看Helmet的文档[https://helmetjs.github.io/docs/](https://helmetjs.github.io/docs/)：该软件包现在已更新到3.12.0版本，经常更新，简单的`npm
    install`可能不足以启用新功能。请查看以下表格：
- en: '| **Module** | **Effect** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **模块** | **效果** |'
- en: '| `contentSecurityPolicy`  | Lets you configure the `Content-Security-Policy`
    header to specify what things are allowed to be on your page, and where they may
    be downloaded from ([https://helmetjs.github.io/docs/xss-filter](https://helmetjs.github.io/docs/xss-filter)).
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `contentSecurityPolicy`  | 允许您配置`Content-Security-Policy`标头，以指定允许在您的页面上的内容和它们可以从哪里下载
    ([https://helmetjs.github.io/docs/xss-filter](https://helmetjs.github.io/docs/xss-filter))。
    |'
- en: '| `expectCt` | Allows you to set the `Expect-CT` header to require **Certificate
    Transparency** (**CT**), to detect possibly invalid certificates or authorities
    ([https://helmetjs.github.io/docs/expect-ct/](https://helmetjs.github.io/docs/expect-ct/)).
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `expectCt` | 允许您设置`Expect-CT`标头，要求**证书透明度**（**CT**），以检测可能无效的证书或授权机构 ([https://helmetjs.github.io/docs/expect-ct/](https://helmetjs.github.io/docs/expect-ct/))。
    |'
- en: '| `hpkp` | Lets you configure the `Public-Key-Pins` header to prevent some
    possible *person-in-the-middle attacks*, by detecting possibly compromised certificates
    ([https://helmetjs.github.io/docs/hpkp/](https://helmetjs.github.io/docs/hpkp/)).
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `hpkp` | 允许您配置`Public-Key-Pins`标头，以防止一些可能的*中间人攻击*，通过检测可能受损的证书 ([https://helmetjs.github.io/docs/hpkp/](https://helmetjs.github.io/docs/hpkp/))。
    |'
- en: '| `noCache`  | Sets several headers to prevent users from using old cached
    versions of files, which might have vulnerabilities or errors, despite newer versions
    being available ([https://helmetjs.github.io/docs/nocache/](https://helmetjs.github.io/docs/nocache/)).
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `noCache`  | 设置几个标头，以防止用户使用旧的缓存文件版本，尽管有更新版本可用，这些旧版本可能存在漏洞或错误 ([https://helmetjs.github.io/docs/nocache/](https://helmetjs.github.io/docs/nocache/))。
    |'
- en: '| `referrerPolicy`  | Lets you set the `Referrer-Policy` header to make browsers
    hide information as to the origin of a request, avoiding some possible privacy
    problems ([https://helmetjs.github.io/docs/referrer-policy](https://helmetjs.github.io/docs/referrer-policy)).
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `referrerPolicy`  | 允许您设置`Referrer-Policy`标头，以便浏览器隐藏请求来源的信息，避免一些可能的隐私问题 ([https://helmetjs.github.io/docs/referrer-policy](https://helmetjs.github.io/docs/referrer-policy))。
    |'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There is not much more to be said about using `Helmet`. After you add it to
    the middleware stack, and configure what to enable or disable, possibly giving
    some options as detailed in the documentation, `Helmet` will simply verify that
    the headers included in any response follow the security considerations that we
    listed in the preceding section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用`Helmet`没有更多要说的了。将其添加到中间件堆栈中，并配置要启用或禁用的内容，可能会根据文档中的详细说明提供一些选项，`Helmet`将简单地验证任何响应中包含的标头是否遵循我们在前一节中列出的安全注意事项。
- en: 'Let''s do a quick check. If you run our `hello_world.js` server, the response
    for [http://localhost:8080/](http://127.0.0.1:8080) will include these headers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速检查一下。如果您运行我们的`hello_world.js`服务器，那么[http://localhost:8080/](http://127.0.0.1:8080)的响应将包括以下标头：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The same results, but running `helmet_world.js`, which is essentially the same
    code but adding `Helmet`, shows more headers, as shown in the following code snippet
    in bold text:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的结果，但是运行`helmet_world.js`，本质上是相同的代码，但添加了`Helmet`，将显示更多标头，如下面的粗体文本所示：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You would get even more headers if you were to individually enable some of
    the optional features, but the difference is clear: we managed to add some security
    controls with essentially almost zero coding!'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您逐个启用一些可选功能，您将获得更多标头，但是差异是明显的：我们成功地添加了一些安全控制，几乎没有编码！
- en: As with all security measures, it's necessary to follow Helmet's functionality
    so that you can possibly add or remove some new middleware options, and protect
    your server against new menaces.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有安全措施一样，有必要遵循Helmet的功能，以便您可能添加或删除一些新的中间件选项，并保护您的服务器免受新的威胁。
- en: Implementing CORS
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施CORS
- en: 'Whenever the browser requests some resource from a server, there are some validation
    rules that apply. For many of these interactions, which only ask for information
    and do not attempt to produce any kind of change in the server, there is no limitation,
    and the requests are always allowed, as in the following cases:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当浏览器从服务器请求某些资源时，都会应用一些验证规则。对于这些交互中的许多情况，这些交互只是请求信息，而不会尝试对服务器进行任何形式的更改，因此没有限制，请求总是被允许，如以下情况：
- en: '*CSS styles* are required via a `<link rel="stylesheet">` tag'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CSS样式*通过`<link rel="stylesheet">`标签进行请求'
- en: '*Images* are required via an `<img>` tag'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图像*通过`<img>`标签进行请求'
- en: '*JS code* is required via a `<script>` tag'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JS代码*通过`<script>`标签进行请求'
- en: '*Media* requests via the `<audio>` or `<media>` tags'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*媒体*通过`<audio>`或`<media>`标签进行请求'
- en: For other types of requests, the **Same Origin Policy** or **Single Origin Policy** (**SOP**)
    limits requests to those that are sent to the same origin (meaning the protocol,
    as in `http://`, host name, as in `modernjsbook.com`, and port, as in `:8080`),
    refusing any other request that doesn't match one or more of the origin URL elements.
    This impacts, for example, all Ajax requests, which will be duly rejected.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类型的请求，**同源策略**或**单一源策略**（**SOP**）限制了只能发送到相同源的请求（意思是协议，如`http://`，主机名，如`modernjsbook.com`，和端口，如`:8080`），拒绝任何不匹配一个或多个源URL元素的其他请求。例如，所有Ajax请求都将被拒绝。
- en: However, if you are willing to accept requests from some or all servers, you
    can apply **Cross Origin Resource Sharing** (**CORS**) to enable such requests.
    Basically, CORS defines an interaction style that lets the server decide whether
    to allow a cross origin request; instead of blocking every request (as SOP would
    imply) or allowing all of them (a huge security breach!), rules can be applied
    to decide one way or the other.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您愿意接受来自一些或所有服务器的请求，您可以应用**跨源资源共享**（**CORS**）来启用此类请求。基本上，CORS定义了一种交互样式，让服务器决定是否允许跨源请求；而不是阻止每个请求（如SOP所暗示的那样）或允许所有请求（这是一个巨大的安全漏洞！），可以应用规则来决定是这样还是那样。
- en: If you want to read the current specification for CORS, see the Fetch Living
    Standard document at [https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/),
    specifically Section 3.2\. A good article about CORS can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想阅读CORS的当前规范，请参阅[https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/)上的Fetch
    Living Standard文档，特别是第3.2节。关于CORS的一篇好文章可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)找到。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start enabling CORS. Basically, it is just a matter of dealing with
    some requests by examining some data in their headers and sending back some other
    headers to the browser so that it will know what to expect. This type of process
    is very easily solved by applying middleware, and a package for this already exists
    (`cors`), which can be installed easily with the help of the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始启用CORS。基本上，这只是处理一些请求的问题，通过检查它们的头部数据并向浏览器发送一些其他头部数据，以便它知道可以期望什么。这种类型的过程非常容易通过应用中间件来解决，而且已经存在一个用于此目的的包（`cors`），可以通过以下代码轻松安装：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can enable CORS for all routes or only a few. The first way only requires
    two lines of code (in bold, in the following code), telling `Express` to apply
    the middleware right at the top, for all requests:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为所有路由或仅为少数路由启用CORS。第一种方式只需要两行代码（在下面的代码中用粗体标出），告诉`Express`在顶部应用中间件，适用于所有请求：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You could also enable it specifically for any given route. Picking one example
    from earlier in this chapter, you could have specified CORS for attempts to get
    a city; the change would have been minimal:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以专门为任何给定的路由启用它。从本章的前面选择一个示例，您可以指定尝试获取城市的CORS；更改将是最小的：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, some requests require a *pre-flight* check, which means that the browser,
    before sending the actual request, will send an `OPTIONS` request to verify whether
    the original request can be accepted. To enable this, you should enable CORS for
    whatever route, as in the following example, or generically, with a single `app.options(''*'',
    cors())` line at the beginning of your middleware stack:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些请求需要进行*预检*，这意味着浏览器在发送实际请求之前，将发送一个`OPTIONS`请求来验证原始请求是否可以被接受。要启用此功能，您应该为任何路由启用CORS，如以下示例中所示，或者在中间件堆栈的开头使用单个`app.options('*',
    cors())`行进行通用设置：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The simplest way to verify that CORS is enabled is by simulating calls from
    different sources using `curl` or a similar tool. (We'll be seeing more of this
    in the following chapter, when we get to do some testing.) We can make it even
    simpler by writing up a small web page that will do a cross-domain `GET`, adding
    a dummy header to force CORS, and checking the network traffic. Our page is simplicity
    itself—totally *no frills*!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 验证CORS是否已启用的最简单方法是使用`curl`或类似工具模拟来自不同来源的调用。（在接下来的章节中，当我们进行一些测试时，我们将看到更多这方面的内容。）我们可以通过编写一个小的网页来简化这个过程，该网页将进行跨域`GET`，添加一个虚拟标头以强制CORS，并检查网络流量。我们的页面非常简单——完全没有花哨的东西！
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will be running our CORS server at `www.corsserver.com:8080` (I''m actually
    hacking the `/etc/hosts` file on my own machine so that the server is actually
    in my machine itself), and we''ll use the Web Server for Chrome to load and run
    our page. Check out the following screenshot for the results of doing this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`www.corsserver.com:8080`上运行我们的CORS服务器（实际上我正在我的机器上黑客攻击`/etc/hosts`文件，以便服务器实际上在我的机器上），我们将使用Web
    Server for Chrome来加载和运行我们的页面。查看以下截图以查看执行此操作的结果：
- en: '![](img/d38f9da2-1c3f-4e63-8beb-bc4706daf2ce.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d38f9da2-1c3f-4e63-8beb-bc4706daf2ce.png)'
- en: Performing a simple cross domain GET shows that our server got an OPTIONS request,
    followed by the GET request afterwards
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 执行简单的跨域GET显示我们的服务器收到了一个OPTIONS请求，然后是GET请求
- en: Using CORS is safer than other alternatives, including the old stalwart JSONP
    (*JSON with Padding*, a way to enable getting information across domains), so
    adding it to your server should be mandatory. However, as we've seen, it's simplicity
    itself with just a tad of Express middleware.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CORS比其他替代方案更安全，包括老牌的JSONP（一种跨域获取信息的方法），因此将其添加到服务器应该是强制性的。然而，正如我们所见，只需使用一点Express中间件就可以轻松实现。
- en: Adding authentication with JWT
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JWT添加身份验证
- en: For any server-based application, one challenge that must be solved is authentication,
    and our RESTful server therefore will need a solution for that. In traditional
    web pages, sessions and cookies may be used, but if you are using an API, there's
    no guarantee that requests will come from a browser; in fact, they may very well
    come from another server. Adding this to the fact that HTTP is stateless, and
    that RESTful services are also supposed to be so, we need another mechanism, and
    **JSON Web Tokens** (**JWT**) is an often used solution.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何基于服务器的应用程序，必须解决的一个挑战是身份验证，因此我们的RESTful服务器需要一个解决方案。在传统的网页中，可能会使用会话和cookie，但是如果您使用API，则无法保证请求来自浏览器；事实上，它们很可能来自另一个服务器。再加上HTTP是无状态的，RESTful服务也应该是如此，我们需要另一种机制，**JSON
    Web Tokens**（**JWT**）是一个经常使用的解决方案。
- en: JWT is sometimes read aloud as *JOT*; see Section 1 of the RFC at [https://www.rfc-editor.org/info/rfc7519](https://www.rfc-editor.org/info/rfc7519).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: JWT有时被读作*JOT*；请参阅RFC的第1节[https://www.rfc-editor.org/info/rfc7519](https://www.rfc-editor.org/info/rfc7519)。
- en: The idea with JWT is that the client will first exchange valid credentials (such
    as username and password) with a server and get back a token, which will afterwards
    give them access to the server's resources. Tokens are created using cryptological
    methods, and are far longer and more obscure than usual passwords. However, tokens
    are small enough to be sent as body parameters or a HTTP header.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的想法是，客户端将首先与服务器交换有效凭据（如用户名和密码），然后得到一个令牌，之后将允许他们访问服务器的资源。令牌是使用密码学方法创建的，比通常的密码要长得多，更加晦涩。但是，令牌足够小，可以作为请求体参数或HTTP头发送。
- en: 'Sending the token in the URL as a query parameter is a bad security practice!
    And, given that the token isn''t actually a part of a request, putting it in the
    body also doesn''t fit very well, so opt for a header; the recommended one is
    `Authorization: Bearer`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '将令牌作为查询参数放在URL中是一种糟糕的安全实践！而且，考虑到令牌实际上不是请求的一部分，将其放在请求体中也不太合适，因此选择一个头部；推荐的是`Authorization:
    Bearer`。'
- en: After getting the token, it must be supplied with every API call, and the server
    will check it before proceeding. The token may include all information about the
    user so that the server won't have to query a database again to re-validate the
    request. In that sense, a token works like the security passes you are given at
    the front desk of a restricted building; you have to prove your identity once
    to the security officer, but afterwards you can move through the building by only
    showing the pass (which will be recognized and accepted) instead of having to
    go through the whole identification procedure again and again.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 获得令牌后，必须在每个API调用中提供它，并且服务器在继续之前将对其进行检查。令牌可能包含有关用户的所有信息，以便服务器无需再次查询数据库来重新验证请求。在这方面，令牌就像您在受限建筑物的前台获得的安全通行证；您必须向安全人员证明您的身份，但之后您只需出示通行证（将被识别和接受）就可以在建筑物内移动，而无需一遍又一遍地进行整个身份验证过程。
- en: Check out [https://jwt.io/](https://jwt.io/) for online tools that allow you
    to work with JWT, and also lots of information about tokens.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://jwt.io/](https://jwt.io/)，可以使用在线工具处理JWT，还有关于令牌的大量信息。
- en: We won't be getting into the details of a JWT's creation, format, and so on;
    read the documentation if you are interested, because we will be working with
    libraries that will handle all such details for us. (We may just keep in mind
    that the token includes a *payload* with some *claims* related to the client or
    the token itself, like an expiration or issue date, and may include more information
    if we need to—but don't include secret data, because the token can be read.)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论JWT的创建、格式等细节；如果您感兴趣，可以阅读文档，因为我们将使用库来处理所有这些细节。（我们可能只需记住令牌包括一个*有效载荷*，其中包含一些与客户端或令牌本身相关的*声明*，比如过期或发布日期，并且如果需要可能包含更多信息——但不包括秘密数据，因为令牌可以被读取。）
- en: In this recipe, let's create a basic server that will be able to first issue
    a JWT to a valid user, and second check the presence of the JWT for specific routes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，让我们创建一个基本服务器，首先能够向有效用户发放JWT，其次检查特定路由的JWT是否存在。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s look at how we can add authentication. To work with JWT, we''ll be using
    `jsonwebtoken` from [https://github.com/auth0/node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken).
    Install it with the help of the following command:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何添加身份验证。为了使用JWT，我们将使用来自[https://github.com/auth0/node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken)的`jsonwebtoken`。使用以下命令安装它：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our code example for JWT will be larger than in previous examples, and it should
    be separated into many files. However, I avoided doing this in order to make it
    clearer. First, we''ll need to make some declarations, and the key lines are in
    bold:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JWT代码示例将比以前的示例更大，并且应该分成多个文件。但是，为了使其更清晰，我避免了这样做。首先，我们需要做一些声明，关键行用粗体标出：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Almost everything is standard, except for the `validateUser()` function and
    the `SECRET_JWT_KEY` string. The latter will be used to sign the tokens, and most
    definitely shouldn't be in the code itself! (If somebody could hack their way
    into the source code, your secret would be out; rather, set the key in an environment
    variable, and get the value from there.)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有内容都是标准的，除了`validateUser()`函数和`SECRET_JWT_KEY`字符串。后者将用于签署令牌，并且绝对不应该出现在代码本身中！（如果有人能够入侵源代码，你的秘密将会泄露；相反，将密钥设置为环境变量，并从那里获取值。）
- en: 'As for the function, checking if a user exists and if their password is correct
    is simple to do, and can be achieved in many ways, such as by accessing a database,
    active directory, service, and so on. Here, we''ll just make do with a hardcoded
    version, which accepts only a single user. The `validate_user.js` source code
    is, then, quite simple:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 至于函数，检查用户是否存在以及他们的密码是否正确是很简单的，可以通过许多方式实现，比如访问数据库、活动目录、服务等。在这里，我们只使用硬编码版本，只接受一个用户。然后，`validate_user.js`源代码非常简单：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s get back to our server. After the initial definitions, we can place
    the routes that need no tokens. Let''s have a `/public` route, and also a `/gettoken` route
    to get a JWT for later. In the latter, we''ll see whether the `POST` included
    `user` and `password` values in its body, and if they are a valid user by means
    of the `validateUser()` function we showed in the preceding code. Any problems
    will mean a `401` status will be sent, while if the user is correct, a token will
    be created, expiring in one hour''s time:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的服务器。在初始定义之后，我们可以放置不需要令牌的路由。让我们有一个`/public`路由，还有一个`/gettoken`路由用于获取稍后的JWT。在后者中，我们将查看`POST`是否在其主体中包含`user`和`password`值，并且如果它们是有效用户，通过我们在前面的代码中展示的`validateUser()`函数。任何问题都意味着将发送`401`状态，而如果用户正确，将创建一个在一小时后过期的令牌：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that the unprotected routes are out of the way, let''s add some middleware
    to verify that a token is present. We expect, according to the JWT RFC, to have
    an `Authorization: Bearer somejwttoken` header included, and it must be accepted.
    If no such header is present, or if it''s not in the right format, a 401 status
    will be sent. If the token is present, but it''s expired or has any other problem,
    a 403 status will be sent. Finally, if there''s nothing wrong, the `userid` field
    will be extracted from the payload, and attached to the request object so that
    future code will be able to use it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '既然不受保护的路由已经处理完毕，让我们添加一些中间件来验证令牌是否存在。根据JWT RFC的预期，我们希望包括一个`Authorization: Bearer
    somejwttoken`标头，并且必须被接受。如果没有这样的标头，或者它的格式不正确，将发送401状态。如果令牌存在，但已过期或有任何其他问题，将发送403状态。最后，如果没有问题，`userid`字段将从有效载荷中提取，并附加到请求对象，以便将来的代码能够使用它：'
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s have some protected routes (in fact, a single one, `/private`,
    just for this example), followed by error checking and setting up the whole server:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些受保护的路由（实际上，只有一个，`/private`，仅供本例使用），然后进行错误检查并设置整个服务器：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We're done! Let's see how this all comes together.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！让我们看看这一切是如何结合在一起的。
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can start by testing the `/public` and `/private` routes, without any token.
    The former won''t cause any problems, but the latter will be caught by our token
    testing code and rejected:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先测试`/public`和`/private`路由，不需要任何令牌。前者不会引起任何问题，但后者将被我们的令牌测试代码捕捉并拒绝：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s try to get a token. Check out the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试获取一个令牌。查看以下代码：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Another way of testing this would be going to [https://jwt.io/](https://jwt.io/)
    and creating a JWT, including `userid:"fkereki"` in the payload, and using `modernJSbook`
    as the secret key. You would have to calculate the expiration date (`exp`) by
    yourself, though.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种测试方法是转到[https://jwt.io/](https://jwt.io/)并创建一个JWT，在有效载荷中包括`userid:"fkereki"`，并使用`modernJSbook`作为密钥。不过，你需要自己计算到期日期(`exp`)。
- en: 'Checking the token at [https://jwt.io](https://jwt.io) shows the following
    payload:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://jwt.io](https://jwt.io)上检查令牌显示以下有效载荷：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `iat` attribute shows that the JWT was issued on 5/20/2018, close to 2:00
    P.M. and the `exp` attributes show that the token is set to expire one hour (3,600
    seconds) later. If we now repeat the curl request to `/private`, but adding the
    appropriate header, it will be accepted. However, if you wait (at least an hour!),
    the result will be different; the JWT checking middleware will detect the expired
    token, and a 403 error will be produced:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`iat`属性显示JWT是在2018年5月20日下午2:00左右发布的，`exp`属性显示令牌设置为一个小时（3,600秒）后过期。如果我们现在重复对`/private`的curl请求，但添加适当的标头，它将被接受。但是，如果你等待（至少一个小时！），结果将不同；JWT检查中间件将检测到过期的令牌，并产生403错误：'
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With this code, we now have a way to add authentication to our RESTful server.
    If you want, you could go further and add specific authorization rules so that
    some users would get access to some features, while others would be restricted.
    Now, let's try to bring everything together, and build ourselves a small REST
    set of services.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们现在有了一种在我们的RESTful服务器中添加身份验证的方法。如果你愿意，你可以进一步添加特定的授权规则，以便一些用户可以访问一些功能，而其他用户将受到限制。现在，让我们尝试将一切整合在一起，并构建一个小型的REST服务。
- en: Tying it all together – building a REST server
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容绑在一起-构建一个REST服务器
- en: In this recipe, let's write at least a part of a complete RESTful server for
    our world database that we started using in the *Working with a database* section
    of the previous chapter, according to the routing scheme that we saw in the *Adding
    Routes* section earlier in this chapter. We'll focus on just working with Regions,
    but only for the sake of brevity; Countries and Cities are very similar in terms
    of coding, and the full code is provided with this book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，让我们至少写一个完整的RESTful服务器的部分，用于我们在上一章的“使用数据库”部分开始使用的世界数据库，根据我们在本章前面的“添加路由”部分看到的路由方案。我们将专注于处理地区，但仅仅是为了简洁起见；国家和城市在编码方面非常相似，完整的代码已经提供在本书中。
- en: 'Our REST services will send JSON answers and require tokens for authorization.
    We will enable CORS so that we can access them from different web pages. The routes
    we will process will be as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的REST服务将发送JSON答案并需要令牌进行授权。我们将启用CORS，以便我们可以从不同的网页访问它们。我们将处理的路由如下：
- en: '`GET /regions` will provide all regions of all countries'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /regions`将提供所有国家的所有地区'
- en: '`GET /regions/:country` will return all regions of the given country'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /regions/:country`将返回给定国家的所有地区'
- en: '`GET /regions/:country/:region` will return a single region'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /regions/:country/:region`将返回一个单独的地区'
- en: '`DELETE /regions/:country/:region` will let us delete a given region'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /regions/:country/:region`将允许我们删除给定的地区'
- en: '`POST /regions/:country` will allow us to create a new region'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /regions/:country`将允许我们创建一个新的地区'
- en: '`PUT /regions/:country/:region` will let us create or update a given region'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /regions/:country/:region`将允许我们创建或更新给定的地区'
- en: 'Dealing with countries and cities is quite similar, with only a couple of exceptions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 处理国家和城市是非常相似的，只有一两个例外：
- en: Because of the size of the result set, we won't accept `GET` `/cities` requests
    to provide all cities in the world; only `GET` `/cities/:city` will be permitted.
    An alternative would be accepting the request, but sending back a `405` status
    code, `Method not allowed`.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于结果集的大小，我们不会接受`GET` `/cities`请求来提供世界上所有的城市；只有`GET` `/cities/:city`将被允许。另一种选择是接受请求，但发送回`405`状态码，`方法不允许`。
- en: Since country codes cannot be assigned at will, we won't allow `POST /countries`.
    Instead, `PUT` `/countries/:country` will be required to add a new country, as
    well as for updating an existing one.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于国家代码不能随意分配，我们不允许`POST /countries`。相反，`PUT` `/countries/:country`将需要添加一个新的国家，以及更新现有的国家。
- en: Each type of request will produce the appropriate HTTP status codes; we'll see
    that in the following sections. Also, `GET` requests will be sent JSON results,
    and `POST` requests will be sent the location of the newly created entity; more
    on this later.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的请求将产生适当的HTTP状态代码；我们将在以下部分看到这一点。此外，`GET`请求将发送JSON结果，`POST`请求将发送新创建实体的位置；稍后会详细介绍。
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s look at how we can write our server. We''ll start with some basic code,
    skipping parts that we already saw earlier, such as CORS and JWT handling:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写我们的服务器。我们将从一些基本代码开始，跳过我们之前看到的部分，比如CORS和JWT处理：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Handling routing is quite standard. Since routes are simple and few, we may
    put them in the same source file; otherwise, we''d set up separate files for different
    sets of routes. The handlers for the routes will certainly go in another file
    (`"restful_regions.js"`) so as not to obscure the main server code. Note that
    country and region codes are, if present, part of the URL; whenever the name for
    a region is needed, it goes in the body parameters:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 处理路由是相当标准的。由于路由简单且少，我们可以将它们放在同一个源文件中；否则，我们将为不同的路由集设置单独的文件。路由的处理程序肯定会放在另一个文件（“restful_regions.js”）中，以免混淆主服务器代码。请注意，如果存在，国家和地区代码是URL的一部分；每当需要地区的名称时，它会放在主体参数中：
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, let''s look at some more code that we''ve already seen to finish up
    the server, error handling and setting up the server itself:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一些我们已经看到的代码，以完成服务器、错误处理和设置服务器本身：
- en: '[PRE48]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Let's move on and see how it works. We'll show the code for handling routes
    in the following section.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看它是如何工作的。我们将在下一节展示处理路由的代码。
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since we have four kinds of requests, let's split our study of the server code
    appropriately.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有四种请求，让我们适当地分割我们对服务器代码的研究。
- en: Handling GETs
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理GET请求
- en: 'As we saw previously, there are three possible routes to handle:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，有三种可能的路由来处理：
- en: '`/regions` to get all regions of all countries'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/regions`获取所有国家的所有地区'
- en: '`/regions/UY` to get all regions of a given country—in this case, Uruguay (`UY`)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/regions/UY`获取给定国家的所有地区-在这种情况下是乌拉圭（`UY`）'
- en: '`/regions/UY/11` to get a specific region of a country—here, region 11 of Uruguay'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/regions/UY/11`获取一个国家的特定地区-这里是乌拉圭的地区11'
- en: 'We can handle all three cases in a similar way by just changing the `SQL SELECT`
    we''ll be doing. Handling the results, however, will require a special case, as
    we''ll note in the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过改变我们将要执行的`SQL SELECT`来以类似的方式处理所有三种情况。然而，处理结果将需要一个特殊情况，正如我们将在下面的代码中注意到的：
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The special case we mentioned in the preceding code is asking for something
    like `/regions/XYZZY`, and providing a wrong country code. In this case, instead
    of sending an empty set (which could imply that the country does exist, as it
    doesn't seem to have any regions) we can send a `404`, so the second `if` statement
    (country provided, region absent) does a special check before proceeding.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中我们提到的特殊情况是请求类似于`/regions/XYZZY`，并提供了错误的国家代码。在这种情况下，我们可以发送`404`，而不是发送一个空集（这可能意味着该国家存在，因为它似乎没有任何地区），所以第二个`if`语句（提供了国家，但地区不存在）在继续之前进行了特殊检查。
- en: 'We can see this code working with several examples. Getting `/regions` with
    no further parameter provides a largish output (22 MB), so adding parameters to
    allow for filtering or paging could be in order:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几个示例看到这段代码的工作。不带进一步参数的`/regions`提供了一个相当大的输出（22 MB），因此可能需要添加参数以进行过滤或分页：
- en: I removed the HTTPS, CORS, and mainly the JWT code from the server to make the
    examples simpler to follow. Doing this meant that I haven't received extra headers,
    and have avoided having to provide a JWT in each call. Yes, I cheated a bit, but
    the source code provided with the book includes everything, so don't worry about
    it!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我从服务器中删除了HTTPS、CORS，主要是JWT代码，以使示例更容易跟踪。这样做意味着我没有收到额外的标头，并且避免了在每次调用中提供JWT。是的，我有点作弊，但随书提供的源代码包括所有内容，所以不用担心！
- en: '[PRE50]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A request for a specific country (such as `/regions/UY`) produces an answer
    very much like the one that we received previously, but including only the regions
    in the country `UY` (Uruguay) and a request for a single region gets a single
    object:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请求特定国家（例如`/regions/UY`）会产生一个与之前收到的答案非常相似的答案，但只包括国家`UY`（乌拉圭）的地区，对单个地区的请求会得到一个单一的对象：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we can try for an error; check out the following screenshot and note
    the 404 status:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以尝试一个错误；查看以下截图并注意404状态：
- en: '![](img/28a633c1-96fa-402a-9210-15273201047a.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28a633c1-96fa-402a-9210-15273201047a.png)'
- en: Asking our RESTful server for regions in a non-existent country produces a 404
    error
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的RESTful服务器请求不存在国家的地区会产生404错误
- en: Handling DELETEs
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理删除操作
- en: 'Deleting a region is simple, except that you must check beforehand whether
    the region has any cities or not. We could solve this by implementing a cascading
    deletion so that when you delete a region, all of its cities get deleted as well,
    or we may forbid the deletion outright. In our case, I opted for the latter, but
    it could be argued that the former is also valid, and would require not very complex
    logic:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个地区很简单，只是必须事先检查地区是否有任何城市。我们可以通过实现级联删除来解决这个问题，这样当你删除一个地区时，它的所有城市也会被删除，或者我们可能会禁止删除。在我们的情况下，我选择了后者，但可以争论说前者也是有效的，并且不需要非常复杂的逻辑：
- en: 'Why are we checking for cities by ourselves, instead of letting the DB server
    do it by using foreign keys? The reason is simple: I wanted to show some code
    that went a bit beyond a single SQL statement. The very same argument could be
    done for cascade deletions, which you could implement with a hand-crafted SQL
    sentence, or by setting up special rules in your database. And, let me state that
    for an actual application, letting the DB do the work would actually be preferable!'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要自己检查城市，而不是让数据库服务器使用外键来做呢？原因很简单：我想展示一些代码，它超出了一个单一的SQL语句。同样的论点也适用于级联删除，你可以用手工编写的SQL语句来实现，或者在数据库中设置特殊规则。并且，让我声明，对于实际的应用程序，让数据库来做这项工作实际上是更可取的！
- en: '[PRE52]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can test this in a similar way. Deleting a region without cities works,
    while attempting to do it for a region with cities or for a non-existing region
    fails:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以类似的方式进行测试。删除没有城市的地区是有效的，而试图对有城市的地区或不存在的地区进行删除是无效的：
- en: '[PRE53]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'See the different status codes that may be returned:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 查看可能返回的不同状态代码：
- en: 204, if a region was deleted with no problems—and in that case, no text response
    is sent
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个地区被删除没有问题，那么返回204，并且在这种情况下，不会发送文本响应
- en: 404, if the requested region doesn't exist
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求的地区不存在，则返回404
- en: 405, if the request couldn't be accepted (because the regions had cities)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求无法被接受（因为地区有城市），则返回405
- en: Of course, you might change the workings of the service and, for example, provide
    for a cascading delete operation if a certain parameter was provided, as in `http://some.server/regions/uy/23?cascade=true`.
    Also, for some services, this operation may happen without even asking for it;
    a user might have a set of preferences, and whenever a user is to be deleted,
    you should also delete their preferences. This would depend on the desired semantics
    of the service.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以改变服务的工作方式，例如，如果提供了某个参数，可以提供级联删除操作，就像`http://some.server/regions/uy/23?cascade=true`。此外，对于一些服务，这个操作可能会在没有要求的情况下发生；用户可能有一组偏好，每当一个用户被删除时，你也应该删除他们的偏好。这将取决于服务的期望语义。
- en: Handling PUTs
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理PUT请求
- en: 'A `PUT` request means that an existing resource is to be updated. In our case,
    a pre-condition is that the specified region must exist; otherwise, a `404` error
    would be appropriate. If the region exists, then we can update it and send a `204`
    status. If `MySQL` detects that no changes have been made to the region, it lets
    you know that the `UPDATE` didn''t change anything; you could either send a `204`
    (as I chose to) or a `409` error, but in any case, you are certain that the region
    has the data you want. We''ll also have to do some parameter checking; in this
    case, just to make sure that a name is given, but the data validation logic could
    be much more complex:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`请求意味着要更新一个现有资源。在我们的情况下，一个先决条件是指定的地区必须存在；否则，`404`错误是合适的。如果地区存在，那么我们可以更新它并发送`204`状态。如果`MySQL`检测到地区没有发生任何变化，它会让你知道`UPDATE`没有改变任何东西；你可以发送`204`（就像我选择的那样）或者`409`错误，但无论如何，你可以确定地区有你想要的数据。我们还需要进行一些参数检查；在这种情况下，只是为了确保给出了一个名称，但数据验证逻辑可能会更加复杂：'
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is easy to test, since there are only two situations (either the region
    exists or it doesn''t), plus a sanity check in case the name is missing. Let''s
    add the missing tilde to a region first; just like before, no content will be
    received because of the 204 status code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易测试，因为只有两种情况（地区存在或不存在），再加上一个健全性检查，以防名称丢失。让我们首先添加缺失的波浪符号到一个地区；就像以前一样，由于204状态代码，不会收到任何内容：
- en: '[PRE55]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The two error cases (non-existent region, missing name) are quickly taken care
    of. The former case is detected by `MySQL`, while the latter is caught by the
    initial `if` statement:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种错误情况（不存在的地区，缺少名称）很快就会被处理。前一种情况是由`MySQL`检测到的，而后一种情况是由最初的`if`语句捕获的：
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Handling `PUT` is just about the simplest case; let's finish our study of the
    server by taking a close look at the most complex request, a `POST`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`PUT`请求只是最简单的情况；让我们通过仔细研究最复杂的请求，即`POST`，来完成对服务器的研究。
- en: Handling POSTs
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理POST请求
- en: 'Finally, handling `POST` requests is a bit more complex, since you are supposed
    to say to which collection (in this case, a country''s) you want to add the new
    resource, and the logic is supposed to do everything, including assigning an ID.
    This means that our code will be a bit longer, since we''ll be adding the need
    to find an unused region code. There will be another difference: when the resource
    is created, the URI for the new resource should be returned in the `Location`
    header, so that will be another extra requirement.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，处理`POST`请求会更加复杂，因为您应该说明要向哪个集合（在这种情况下是一个国家）添加新资源，并且逻辑应该完成所有工作，包括分配一个ID。这意味着我们的代码会更长，因为我们将添加查找未使用的区域代码的需求。还会有另一个区别：当资源被创建时，新资源的URI应该在`Location`头中返回，因此这将是另一个额外的要求。
- en: 'Finally, once again, we''ll have some data validation, as with `PUT` requests:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再次，我们将进行一些数据验证，就像`PUT`请求一样：
- en: '[PRE57]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is the logic that requires the most queries. We must (1) check that the
    country exists, (2) determine the maximum region ID for that country, and only
    then (3) insert the new region and return a 201 status to the user. We can test
    this in a similar way to what we did for `PUT`, so let''s look at a simple case:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要最多查询的逻辑。我们必须（1）检查国家是否存在，（2）确定该国家的最大区域ID，然后（3）插入新区域并向用户返回201状态。我们可以像对`PUT`做的那样测试这个，所以让我们看一个简单的案例：
- en: '[PRE58]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Argentina has 24 provinces, numbered from 1 to 24 in the `regions` table, so
    if we add a new one, it should be #25, and the `Location` header in the answer
    proves that this is so. (We are only returning the route, without the server and
    port, but we could easily add those pieces of data.) Doing a `GET` confirms that
    the `POST` succeeded.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 阿根廷有24个省，编号从1到24在`regions`表中，因此如果我们添加一个新的，它应该是#25，并且答案中的`Location`头证明了这一点。（我们只返回路由，没有服务器和端口，但我们可以很容易地添加这些数据。）进行`GET`确认`POST`成功。
- en: There's more...
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have set up a barebones RESTful server with `Express`, but there is much
    more—enough for a book of its own! Let's finish this chapter by taking a very
    quick glance at several ideas and tools that you might want to consider for your
    own projects.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`Express`建立了一个简单的RESTful服务器，但还有更多内容——足够写一本书！让我们通过快速浏览一些您可能想要考虑用于自己项目的想法和工具来结束本章。
- en: Accepting JSON data
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受JSON数据
- en: We have used `POST` parameters in our examples, but it's also possible to receive,
    parse, and process JSON input. (This can make it easier to call a REST service,
    because at the frontend it's very likely you'll be able to readily produce an
    object with the desired parameters for the request.) Use `express.json()` as middleware,
    and the request body will include the data from the JSON parameter.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了`POST`参数，但也可以接收、解析和处理JSON输入。（这可以使调用REST服务变得更容易，因为在前端很可能您可以轻松地生成一个带有所需请求参数的对象。）使用`express.json()`作为中间件，请求体将包括来自JSON参数的数据。
- en: Go to [http://expressjs.com/en/4x/api.html#express.json](http://expressjs.com/en/4x/api.html#express.json)
    for more information on this.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问[http://expressjs.com/en/4x/api.html#express.json](http://expressjs.com/en/4x/api.html#express.json)了解更多信息。
- en: Adding the PATCH method for partial updates
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加PATCH方法进行部分更新
- en: The PUT method makes you update a complete entity, but sometimes you want to
    affect only a few fields, and in this case you can allow the `PATCH` method. `PATCH`
    is similar to `PUT`, but lets you update only some attributes. Adding support
    for this method is not complex, and is very similar to the `PUT` logic, so you
    may provide a more powerful server with relatively little extra coding.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: PUT方法使您更新完整的实体，但有时您只想影响一些字段，在这种情况下，您可以允许`PATCH`方法。`PATCH`类似于`PUT`，但允许您仅更新一些属性。添加对此方法的支持并不复杂，非常类似于`PUT`逻辑，因此您可以通过相对较少的额外编码提供更强大的服务器。
- en: You can read more about PATCH at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH) and
    if you care about its specification, at [https://datatracker.ietf.org/doc/rfc5789/](https://datatracker.ietf.org/doc/rfc5789/).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH)了解更多关于PATCH的信息，如果您关心其规范，可以在[https://datatracker.ietf.org/doc/rfc5789/](https://datatracker.ietf.org/doc/rfc5789/)找到。
- en: Using Restify instead of Express
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Restify而不是Express
- en: While `Express` is a very popular and widely used package that can be used to
    build any kind of server, if you specifically want just a REST server and no other
    feature, you may consider using other packages, such as `Restify`. The advantages
    of such a change have to do with the orientation of the package, which provides
    similar features to `Express`, but requires a bit less code in order to accomplish
    a RESTful deployment. Some well-known users of `Restify` are `npm` and Netflix,
    but the list is much longer.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Express`是一个非常受欢迎和广泛使用的软件包，可以用来构建任何类型的服务器，但如果您特别想要一个仅REST服务器而没有其他功能，您可以考虑使用其他软件包，比如`Restify`。这种改变的优势与软件包的定位有关，它提供了与`Express`类似的功能，但需要更少的代码来实现RESTful部署。`Restify`的一些知名用户是`npm`和Netflix，但名单还要长得多。
- en: You can read more about `Restify` at [http://restify.com/](http://restify.com/).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://restify.com/](http://restify.com/)了解更多关于`Restify`的信息。
- en: Allowing filtering, sorting, and pagination
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许过滤、排序和分页
- en: Since REST is basically a style and not a specification for services, there
    are aspects that aren't specified, and you have some leeway as to their implementation.
    Three common requirements are *filtering* (so you don't get all entities, but
    just those that satisfy some condition), *sorting* (so that entities are included
    in some order), and *pagination* (because showing hundreds or thousands of entities
    at once isn't practical). Of course, these three requirements interact with each
    other; if you sort and filter, then paging should apply to the sorted filtered
    data.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST基本上是一种风格，而不是服务的规范，因此有一些方面没有规定，您可以在实现上有一些自由。三个常见的要求是*过滤*（这样您就不会得到所有实体，而只会得到满足某些条件的实体）、*排序*（使实体按某种顺序包含）和*分页*（因为一次显示数百或数千个实体是不切实际的）。当然，这三个要求彼此交互；如果您进行排序和过滤，那么分页应该适用于排序后的过滤数据。
- en: 'All of these requirements can be handled by adding some query parameters (or
    possibly headers), but you''ll have to study a bit to understand what''s the best
    way for you:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些要求都可以通过添加一些查询参数（或可能的标头）来处理，但您需要花一些时间来了解对您来说最佳的方式：
- en: '*Filtering* may be specified with a format such as `filter=price[lt]220`, which
    would specify that a given attribute (`price`) must be less than (`lt`) a value
    (`200`). Building up more complex expressions involving logical operators such
    as `and`, `or`, and `not`, plus optional parentheses, can also be done, at the
    cost of more complex parsing and interpreting at the server.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤*可以使用格式进行指定，例如`filter=price[lt]220`，这将指定给定属性（`price`）必须小于（`lt`）某个值（`200`）。构建涉及逻辑运算符（如`and`、`or`和`not`）以及可选括号的更复杂表达式也可以完成，但这会导致服务器进行更复杂的解析和解释。'
- en: '*Sorting* may be specified by parameters such as `sortby=price,name` to order
    first by `price` and then by `name`. You can add other options to allow for ascending
    or descending sorting.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*排序*可以通过参数进行指定，例如`sortby=price,name`，首先按`price`排序，然后按`name`排序。您可以添加其他选项以允许升序或降序排序。'
- en: '*Paging* can be done by using the `limit` and `offset` parameters, with the
    same interpretation that''s used in SQL `SELECT` statements (see [https://dev.mysql.com/doc/refman/8.0/en/select.html](https://dev.mysql.com/doc/refman/8.0/en/select.html)
    for more on that) or by specifying a page size and the page number.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分页*可以通过使用`limit`和`offset`参数来完成，其解释与SQL `SELECT`语句中使用的相同（有关更多信息，请参见[https://dev.mysql.com/doc/refman/8.0/en/select.html](https://dev.mysql.com/doc/refman/8.0/en/select.html)），或者通过指定页面大小和页面编号。'
- en: Adding the handling of these options to your REST server will make it more powerful,
    and enable the client to send more specific, optimized requests. There is one
    more extension that you may want; being able to select extra, related entities,
    so read on.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些选项添加到您的REST服务器的处理中将使其更加强大，并使客户端能够发送更具体、优化的请求。您可能还需要另一个扩展功能；能够选择额外的相关实体，因此请继续阅读。
- en: Using GraphQL instead of REST
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GraphQL而不是REST
- en: REST services are standard and easy to use, but may imply some overhead, mostly
    when you don't need just a single entity, but also some related ones; for example,
    how would you get a country and all of its regions? With our current design, you'd
    have to do separate calls and join the results by yourself, or otherwise extend
    your routes yourself. For example, you would do this for `/regions/uy?include=cities`
    so that the server would add—to each region in `UY`—an array with its cities.
    While this solution may be apt for a small example like the one we're using, for
    bigger, more complex databases, with tables related among themselves in many ways,
    it could easily get out of hand.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务是标准且易于使用的，但在您不仅需要单个实体，还需要一些相关实体时可能会带来一些开销；例如，您如何获取一个国家及其所有地区？根据我们当前的设计，您必须分别调用并自行连接结果，或者自行扩展您的路由。例如，您可以对`/regions/uy?include=cities`执行此操作，以便服务器将在`UY`的每个地区中添加一个包含其城市的数组。虽然这种解决方案可能适用于我们正在使用的这个小例子，但对于更大、更复杂的数据库，其中表之间以多种方式相关联，这可能很容易失控。
- en: There is, however, another option. `GraphQL` is a data query language that was
    developed by Facebook, and it lets you define, at the client, the structure of
    the data you require; the server will do whatever is needed to produce exactly
    that. `GraphQL` lets you get many related resources with a single request by following
    references to build a complex structure, and sending it along with the minimum
    delay. You also get tools to help you define your data schema and perform online
    queries.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种选择。`GraphQL`是由Facebook开发的数据查询语言，它允许您在客户端定义所需数据的结构；服务器将根据需要生成相应的数据。`GraphQL`允许您通过跟踪引用来构建复杂结构，并将其与最小延迟一起发送，从而在单个请求中获取许多相关资源。您还可以使用工具来帮助您定义数据模式和执行在线查询。
- en: 'Let''s look at a very short example, taken from the documentation of GraphQL''s
    own site, at [http://graphql.org/learn/queries/](http://graphql.org/learn/queries/).
    Given a database of *Star Wars* movies, you could write the following query that
    wants to get the hero from a couple of movies, and for each one, the name, the
    list of movies they appear in, and all of their friends'' names:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个非常简短的例子，取自GraphQL官方网站的文档，网址为[http://graphql.org/learn/queries/](http://graphql.org/learn/queries)。假设有一个*星球大战*电影数据库，您可以编写以下查询，想要获取一些电影中的英雄，以及每个英雄的姓名、出现在其中的电影列表和所有朋友的姓名：
- en: '[PRE59]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The result of this query is as follows. Note how the object structure follows
    your specification in the query, and that repeated fields, or foreign key access,
    were all solved by the `GraphQL` server, and in a single request:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的结果如下。请注意对象结构如何遵循您在查询中的规范，并且重复字段或外键访问都由`GraphQL`服务器解决，并在单个请求中完成。
- en: '[PRE60]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: While totally outside the scope of this chapter (we wanted a RESTful server,
    after all), `GraphQL` is a very valid alternative for applications that need to
    work with complex, linked structures, which would require too much processing
    and communication time otherwise.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这超出了本章的范围（毕竟我们想要一个符合REST原则的服务器），但`GraphQL`是一个非常有效的选择，适用于需要处理复杂的、链接的结构的应用程序，否则这些结构需要太多的处理和通信时间。
- en: To learn more about `GraphQL`, check out the official site at [https://graphql.org/](https://graphql.org/).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`GraphQL`的更多信息，请访问官方网站[https://graphql.org/](https://graphql.org/)。
- en: Implementing a microservice-based architecture
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施基于微服务的架构
- en: Now that you're able to develop a server by following the structure in this
    chapter, working in an SOA might evolve into a microservices organization, in
    which the server, instead of being a monolithic piece of code that can provide
    multiple services, is organized as a set of distinct mini-servers, loosely coupled,
    connected by a lightweight protocol, and each having a single responsibility.
    Services may be created by different groups, even using different languages or
    libraries, that are only dependent on following a given interface so that other
    services may freely interact with them as needed.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过遵循本章的结构，您可以开发一个服务器，从而在SOA中工作可能会演变为一个微服务组织，其中服务器不再是一个可以提供多个服务的单片代码，而是作为一组不同的迷你服务器组织，它们之间松散耦合，通过轻量级协议连接，每个服务器都有单一的责任。服务可以由不同的团队创建，甚至可以使用不同的语言或库，只需依赖于遵循给定接口，以便其他服务可以根据需要自由地与它们交互。
- en: This structure, based on independent smaller pieces, greatly helps with scalability,
    modularity, and even development and testing. If changes are needed, their impact
    will be smaller, and strategies such as continuous delivery and deployment become
    feasible. Developing the microservices themselves is readily done, and the necessary
    techniques for doing this are mainly the ones that we saw in this chapter. Only
    adding the requests from one microserver to another to gather all of the required
    information is necessary.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于独立较小组件的结构极大地有助于可伸缩性、模块化，甚至开发和测试。如果需要进行更改，其影响将更小，而诸如持续交付和部署等策略也变得可行。开发微服务本身很容易完成，而进行此操作所需的技术主要是本章中所见的技术。只需将一个微服务器的请求添加到另一个微服务器以收集所有所需的信息即可。
- en: A couple of good starting points on the benefits of a microservice-based architecture
    are the articles by Martin Fowler at [https://martinfowler.com/microservices/](https://martinfowler.com/microservices/) and
    by Chris Richardson at [http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基于微服务架构的好处，一些很好的起点是Martin Fowler在[https://martinfowler.com/microservices/](https://martinfowler.com/microservices/)上的文章，以及Chris
    Richardson在[http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html)上的文章。
