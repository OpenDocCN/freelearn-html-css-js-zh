- en: 'Creating RSS Aggregator with Electron, TypeScript , React, and Redux: Planning,
    Design, and Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Electron、TypeScript、React和Redux创建RSS聚合器：规划、设计和开发
- en: Wading through the previous chapters, we created an application with pure JavaScript,
    React and React + Redux. We are now coming to the optimal technology stack for
    large scalable web applications--TypeScript + React + Redux. We are going to develop
    the RSS Aggregator. I find it a good example to show TypeScript in action as well
    as to examine asynchronous actions. Besides, you will learn to use a new component
    library, React MDL. We will also extend it with custom styles written in SASS
    language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的章节，我们使用纯JavaScript、React和React + Redux创建了一个应用程序。现在，我们将使用最佳技术栈来开发大型可扩展的Web应用程序--TypeScript
    + React + Redux。我们将开发RSS聚合器。我认为这是一个很好的例子，可以展示TypeScript的实际应用，以及检查异步操作。此外，您还将学习使用新的组件库React
    MDL。我们还将使用SASS语言编写自定义样式来扩展它。
- en: Application blueprint
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用蓝图
- en: 'We develop a typical tool that aggregates syndicated content from a manageable
    list of sources. If we split the requirements into user stories, we will get something
    like this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发一个典型的工具，从可管理的来源列表中聚合联合内容。如果我们将需求分解为用户故事，我们会得到类似于这样的东西：
- en: As a user, I can see the list of earlier added sources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以看到先前添加的来源列表
- en: As a user, I can see the aggregated content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以看到汇总内容
- en: As a user, I can filter the content items by selecting a source in the menu
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以通过在菜单中选择来源来过滤内容项
- en: 'Let''s again use **WireframeSketcher** ([http://wireframesketcher.com/](http://wireframesketcher.com/))
    and put it on a wireframe:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用**WireframeSketcher**（[http://wireframesketcher.com/](http://wireframesketcher.com/)）并将其放在线框上：
- en: '![](img/28b5d0ec-abbb-4bb7-88cc-e860dd4d1059.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28b5d0ec-abbb-4bb7-88cc-e860dd4d1059.png)'
- en: As a user, I can open the item link next to the list
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以在列表旁边打开项目链接
- en: '![](img/4a27075f-f019-4693-9055-72eeb410078f.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a27075f-f019-4693-9055-72eeb410078f.png)'
- en: As a user, I can add a source
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以添加一个来源
- en: As a user, I can remove a source
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以删除一个来源
- en: As a user, I can update aggregated content
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以更新汇总内容
- en: '![](img/0969303e-c65b-496e-a481-e123b717a0e0.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0969303e-c65b-496e-a481-e123b717a0e0.png)'
- en: Welcome to TypeScript
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到TypeScript
- en: When working on a large scalable application, it's essential that established
    architecture has been followed by all the team members. In other languages, such
    as Java, C++, C#, and PHP, we can declare types and interfaces. So, no one can
    go with a new functionality unless it fully satisfies the interface intended by
    the system architect. JavaScript has neither strict types nor interfaces. That
    why, in 2012, engineers of Microsoft developed a superset of JavaScript (ES2015)
    called **TypeScript.** This language extends JavaScript with optional static typing
    and compiles back to JavaScript, so is acceptable by any browser and operating
    system. It is similar to how we compile ES.Next to ECMAScript of the fifth edition
    with Babel, but in addition, brings us features that are unlikely to be integrated
    into ECMAScript in the foreseeable future. The language is exceptionally great
    and is documented at [https://www.typescriptlang.org/docs/home.html](https://www.typescriptlang.org/docs/home.html)
    and provided with an excellent specification [http://bit.ly/2qDmdXj](http://bit.ly/2qDmdXj).
    The language is supported by the mainstream IDEs and code editors, and can be
    integrated through plugins in automation tools, such as Grunt, Gulp, Apache Maven,
    Gradle, and others. Some major frameworks are considering migrating to TypeScript,
    while Angular 2+ and Dojo 2 have already embraced it. Other frameworks expose
    their interfaces to TypeScript through definition files.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发大型可扩展应用程序时，确保所有团队成员都遵循已建立的架构是至关重要的。在其他语言中，如Java、C++、C#和PHP，我们可以声明类型和接口。因此，除非新功能完全满足系统架构师预期的接口，否则无法使用。JavaScript既没有严格的类型，也没有接口。因此，2012年，微软的工程师开发了JavaScript的超集（ES2015）称为**TypeScript**。这种语言通过可选的静态类型扩展了JavaScript，并编译回JavaScript，因此可以被任何浏览器和操作系统接受。这类似于我们如何使用Babel将ES.Next编译为第五版ECMAScript，但此外，它还为我们带来了一些不太可能在可预见的未来集成到ECMAScript中的功能。这种语言非常出色，并且在[https://www.typescriptlang.org/docs/home.html](https://www.typescriptlang.org/docs/home.html)有文档支持，并且提供了优秀的规范[http://bit.ly/2qDmdXj](http://bit.ly/2qDmdXj)。这种语言得到了主流IDE和代码编辑器的支持，并且可以通过插件集成到Grunt、Gulp、Apache
    Maven、Gradle等自动化工具中。一些主要的框架正在考虑迁移到TypeScript，而Angular 2+和Dojo 2已经采用了它。其他框架通过定义文件向TypeScript公开它们的接口。
- en: Alternatively for static type checking, one can go with **Flow** ([https://flow.org](https://flow.org))
    by Facebook. Unlike TypeScript, Flow is no compiler, but a checker. Basic typings
    in Flow are pretty similar to the ones of TypeScript, achieved by almost the same
    syntax. Flow also introduces advanced types, such as array, union, intersection,
    and generics, but does it in its own ways. According to Facebook, they created
    Flow because "TypeScript isn't built around bug finding as much as they wanted."
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为静态类型检查的替代，可以选择使用Facebook的**Flow**（[https://flow.org](https://flow.org)）。与TypeScript不同，Flow不是编译器，而是一个检查器。Flow中的基本类型与TypeScript的类型非常相似，几乎使用相同的语法实现。Flow还引入了高级类型，如数组、联合、交集和泛型，但是使用了自己的方式。根据Facebook的说法，他们创建Flow是因为“TypeScript并没有像他们想要的那样建立在发现错误的基础上。”
- en: Setting up the development environment for TypeScript
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为TypeScript设置开发环境
- en: 'TypeScript makes alluring promises regarding one''s development experience.
    Why not fiddle with the code to see it in practice? First, we have to create a
    dedicated directory for upcoming samples. We initialize the project by running
    `npm init -y` and install `typescript` as a dev dependency:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript对开发体验做出了诱人的承诺。为什么不动动手，看看实际操作呢？首先，我们需要为即将到来的示例创建一个专用目录。我们通过运行`npm init
    -y`来初始化项目，并将`typescript`安装为开发依赖项：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the manifest `scripts` section, we add a command to compile sources with
    TypeScript:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单的`scripts`部分，我们添加了一个用于使用TypeScript编译源代码的命令：
- en: '`package.json`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We need to let TypeScript know what exactly we want from it. We will describe
    that in the configuration file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让TypeScript知道我们究竟想要什么。我们将在配置文件中描述这一点：
- en: '`tsconfig.json`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsconfig.json`'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we set the TypeScript compiler to search for `ts` sources anywhere within
    the project directory except `node_modules`. In `compilerOptions`, we specify
    how we want it to treat our sources during compilation. Field `target` is set
    in `ES6`, meaning TypeScript will compile into the ES6/ES2016 syntax, which is
    already fully supported in all the modern browsers. In the field `module`, we
    have `CommonJS`. Thus, TypeScript will bundle sources into CommonJS-compliant
    modules that play nicely with the Node.js environment. With the field `moduleResolution`,
    we choose in favor of the Node.js modules resolution style. In the field `outDir`,
    we determine where TypeScript will store the compiled modules. More information
    about compiler options is available at [http://bit.ly/2t9fckV](http://bit.ly/2t9fckV).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将TypeScript编译器设置为在项目目录中的任何地方搜索`ts`源文件，但不包括`node_modules`。在`compilerOptions`中，我们指定了在编译期间希望如何处理我们的源文件。`target`字段设置为`ES6`，意味着TypeScript将编译为ES6/ES2016语法，这在所有现代浏览器中已经得到充分支持。在`module`字段中，我们使用`CommonJS`。因此，TypeScript将源文件捆绑成符合CommonJS标准的模块，与Node.js环境兼容。在`moduleResolution`字段中，我们选择了Node.js模块解析风格。在`outDir`字段中，我们确定TypeScript将存储编译后的模块的位置。有关编译器选项的更多信息，请访问[http://bit.ly/2t9fckV](http://bit.ly/2t9fckV)。
- en: Basic types
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型
- en: 'The development environment now seems ready, so we can try it out with an elementary
    example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境现在似乎已经准备好了，所以我们可以用一个基本的例子来试一试：
- en: '`example.ts`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`example.ts`'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use the type annotation feature of TypeScript to set a constraint on the
    variable. That's so easy; we just extend the declaration with the so-called **declaration
    space** like `:type`, where type can be one of the basic types (boolean, number,
    string, array, void, any, and a few others), class, interface, type alias, enum,
    and import. Here, we applied `string`, meaning title accepts only strings.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用TypeScript的类型注解功能来对变量设置约束。这很容易；我们只需扩展声明，使用所谓的**声明空间**，比如`:type`，其中type可以是基本类型（boolean、number、string、array、void、any等），类、接口、类型别名、枚举和导入。在这里，我们应用了`string`，意味着title只接受字符串。
- en: 'After compiling with `npm run build`, we can find file `example.js` in the
    `./build` directory with the following content:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后使用`npm run build`，我们可以在`./build`目录中找到`example.js`文件，内容如下：
- en: '`build/example.js`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`build/example.js`'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You see it doesn't do much; it simply removes the type hinting. That's something
    amazing about TypeScript - type checking happens at compilation time and disappears
    by runtime. So, we benefit from TypeScript without any impact on the application's
    performance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现它并没有做太多事情；它只是移除了类型提示。这就是TypeScript的惊人之处 - 类型检查发生在编译时，并在运行时消失。因此，我们可以从TypeScript中受益，而不会对应用程序的性能产生任何影响。
- en: 'Well, let''s do a nasty thing and set a value to the variable violating the
    given constraint:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们做一件不好的事，给变量设置一个违反给定约束的值：
- en: '`example.ts`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`example.ts`'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On compilation, we receive an error message:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时，我们收到了一个错误消息：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Hmm; TypeScript warns us when we do something wrong. What is even more exciting
    is if your IDE supports TypeScript, you get notified on the fly while typing.
    I suggest to check against the list [http://bit.ly/2a8rmTl](http://bit.ly/2a8rmTl)
    and pick up the most suitable IDE for you if, by chance, yours isn't there. I
    would recommend **Alm** ([http://alm.tools](http://alm.tools)) as a great example
    of using TypeScript, React, and Redux together. However, I, myself, pulled in
    **NetBeans** ([https://netbeans.org/](https://netbeans.org/)) a decade ago and
    it has never disappointed me. It does not have native TypeScript support, but
    one can easily get it by installing the **TypeScript Editor plugin** ([https://github.com/Everlaw/nbts](https://github.com/Everlaw/nbts)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯；TypeScript在我们做错事时警告我们。更令人兴奋的是，如果你的IDE支持TypeScript，你在输入时会立即得到通知。我建议对照列表[http://bit.ly/2a8rmTl](http://bit.ly/2a8rmTl)，选择最适合你的IDE，如果你的IDE恰好不在列表中。我会推荐**Alm**([http://alm.tools](http://alm.tools))，它是使用TypeScript、React和Redux的一个很好的例子。然而，我自己十年前就开始使用**NetBeans**([https://netbeans.org/](https://netbeans.org/))，它从未让我失望过。它没有原生的TypeScript支持，但可以通过安装**TypeScript
    Editor插件**([https://github.com/Everlaw/nbts](https://github.com/Everlaw/nbts))轻松获得。
- en: 'Let''s play with type annotation more. We take a function and define a contract
    for entry and exit points:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更多地使用类型注解。我们拿一个函数，并为入口和出口点定义一个契约：
- en: '`example.ts`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`example.ts`'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Actually, we state here that the function accepts two numbers and shall return
    a number. Now, if we even think of giving the function any type different from
    number, the IDE immediately alerts us about it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在这里声明函数接受两个数字，并应返回一个数字。现在，即使我们想给函数赋予与数字不同的任何类型，IDE也会立即提醒我们：
- en: '![](img/f4711d30-5ae2-4723-abea-9a9d85bfdf83.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4711d30-5ae2-4723-abea-9a9d85bfdf83.png)'
- en: Array, plain objects, and indexable types
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组、普通对象和可索引类型
- en: 'Well, I believe, with primitive types, it''s more or less clear, but what about
    the others, for example, arrays? By combining basic type with `[]`, we define
    an array type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，对于原始类型，情况或多或少是清楚的，但其他类型呢，比如数组？通过将基本类型与`[]`结合，我们定义了一个数组类型：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we declare the variable `arr` that is an array of string. We can achieve
    the same with the following syntax:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了变量`arr`，它是一个字符串数组。我们可以使用以下语法实现相同的效果：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, we can do it with interface:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用接口来实现：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While declaring the `StringArray` interface by using the so-called **index
    signature**, we set constraints on the type structure. It accepts numeric indexes
    and string values. In other words, it''s a string array. We can go further and
    set a constraint on the array length:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用所谓的**索引签名**来声明`StringArray`接口，我们对类型结构设置了约束。它接受数字索引和字符串值。换句话说，它是一个字符串数组。我们还可以进一步对数组长度设置约束：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As for plain objects, we can go with an interface describing the intended shape:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 至于普通对象，我们可以使用描述预期形状的接口：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the other hand, we can set constraints inline with the object type literal:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以使用对象类型文字内联设置约束：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we are able to declare a value object ([http://bit.ly/2khKSBg](http://bit.ly/2khKSBg)),
    we need to ensure immutability. Fortunately, TypeScript allows us to specify that
    members of an object are `readonly`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够声明一个值对象（[http://bit.ly/2khKSBg](http://bit.ly/2khKSBg)），我们需要确保不可变性。幸运的是，TypeScript允许我们指定对象的成员为`readonly`：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can access a percentage, for example, red in a color of the `RGB` type.
    But we cannot change the RGB levels for a declared color. If we try this, we will
    get an error as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以访问百分比，例如`RGB`类型的颜色中的红色。但我们不能更改已声明颜色的RGB级别。如果我们尝试这样做，将会得到以下错误：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For an object of arbitrary properties, we can use an index signature to target
    string keys:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意属性的对象，我们可以使用索引签名来定位字符串键：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that, in `DataMap`, we set `any` for member type. By this, we allow any
    value types.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`DataMap`中，我们为成员类型设置了`any`。通过这样做，我们允许任何值类型。
- en: Function type
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'We can set constraints on a function by using the function type literal:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用函数类型文字在函数上设置约束：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I find it quite discouraging and prefer to use interface:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得这相当令人沮丧，更喜欢使用接口：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You may now ask, what if the function has optional parameters? TypeScript makes
    it very simple to define an optional parameter. You just need to append the parameter
    with a question mark:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问，如果函数有可选参数怎么办？TypeScript使定义可选参数非常简单。您只需要在参数后面加上一个问号：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We made `description` optional, so we can call the function both ways:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`description`设置为可选，因此我们可以以两种方式调用该函数：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: None of these violates the declared interface; so far, we give it string.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不违反已声明的接口；到目前为止，我们给它字符串。
- en: 'In pretty much the same way, we can define optional object members:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式，我们可以定义可选对象成员：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Class type
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类类型
- en: 'In other languages, we are used to considering interfaces as closely related
    to classes. TypeScript brings a similar development experience. What is more,
    while Java and PHP interfaces cannot contain instance properties, TypeScript has
    no such limitations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，我们习惯将接口视为与类密切相关。TypeScript带来了类似的开发体验。而且，虽然Java和PHP接口不能包含实例属性，TypeScript没有这样的限制：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the advance of ES2015/2016, classes are used widely in JavaScript. Yet,
    TypeScript allows us to set member accessibility. So, we declare a member as `public`
    when we permit access to it from the code consuming object instance. We use `private`
    to ensure the member will not be accessible outside its containing class. In addition,
    the `protected` members are similar to `private`, except they can be accessed
    in any of the derived class instances:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着ES2015/2016的发展，类在JavaScript中被广泛使用。然而，TypeScript允许我们设置成员的可访问性。因此，当我们允许从消费对象实例的代码中访问成员时，我们将成员声明为`public`。我们使用`private`来确保成员在其包含的类之外不可访问。此外，`protected`成员与`private`类似，只是它们可以在任何派生类实例中被访问：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, the value for `speed` is hardcoded. It would be just proper
    if our class could be configured for the initial speed during initialization.
    Let''s do the refactoring:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`speed`的值是硬编码的。如果我们的类在初始化期间可以配置初始速度，那就更好了。让我们进行重构：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we use another nice feature of TypeScript that I am personally excited
    about. It's called **parameter property**. We often declare private properties
    and populate them from constructor parameters. In TypeScript, we can simply prepend
    the parameter with an accessibility modifier and it will result in a respectively
    named property taking in the value of the parameter. So, in the previous code,
    using `private speed` in the parameter list, we declare the `speed` parameter
    and assign a passed in value to it. By using the ES6 syntax for the default parameter,
    we set `speed` to zero when nothing has passed in the constructor `constructor(
    speed = 0 )`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了TypeScript的另一个我个人很激动的很好的特性。它被称为**参数属性**。我们经常声明私有属性，并从构造函数参数中填充它们。在TypeScript中，我们可以简单地在参数前面加上一个可访问性修饰符，它将导致一个相应命名的属性，接受参数的值。因此，在前面的代码中，使用`private
    speed`在参数列表中，我们声明了`speed`参数，并将传入的值赋给它。通过使用ES6语法来设置默认参数，当在构造函数`constructor( speed
    = 0 )`中没有传入任何值时，我们将`speed`设置为零。
- en: Abstract classes
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'Similar to what you might be used to in other languages, in TypeScript, we
    can use abstract classes and methods. The abstract class is meant only for extending.
    One cannot create instances of the abstract class. Methods defined as abstract
    are required for implementation in any subclasses:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与您在其他语言中可能习惯的类似，在TypeScript中，我们可以使用抽象类和方法。抽象类仅用于扩展。不能创建抽象类的实例。定义为抽象的方法在任何子类中都需要实现：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Abstract classes are quite similar to interfaces, except a class can implement
    multiple interfaces, but extend only one abstract class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类与接口非常相似，只是一个类可以实现多个接口，但只能扩展一个抽象类。
- en: Enum type
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举类型
- en: 'Time after time, we use constants to define a set of logically related entities.
    With TypeScript, we can declare an enumerated type populated with immutable data
    and then refer to the whole set by the type:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，我们使用常量来定义一组逻辑相关的实体。使用TypeScript，我们可以声明一个由不可变数据填充的枚举类型，然后通过类型引用整个集合：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we declare a type `Status` that accepts one of the predefined values
    (`NEEDS_PATCH`, `UP_TO_DATE`, and `NOT_INSTALLED`). The function `setStatus` expects
    the `status` parameter to be of the `Status` type. If you pass in any other value,
    TypeScript reports an error:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个类型`Status`，它接受预定义值之一（`NEEDS_PATCH`，`UP_TO_DATE`和`NOT_INSTALLED`）。函数`setStatus`期望`status`参数是`Status`类型。如果传入任何其他值，TypeScript会报告错误：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, we can use a string literal type that refers to any string value
    of a group:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用字符串字面类型，它指的是一组任何字符串值：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Union and intersection types
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合和交叉类型
- en: 'Interesting so far, isn''t it? What would you say then to it: in TypeScript,
    we can refer to multiple types at once. For example, we have two interfaces `Anakin`
    and `Padmé` and need a new type (`Luke`) that inherits from both of them. We can
    achieve it as easily as this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止很有趣，不是吗？那么你对此怎么看：在TypeScript中，我们可以同时引用多种类型。例如，我们有两个接口`Anakin`和`Padmé`，需要一个从它们两个继承的新类型（`Luke`）。我们可以像这样轻松实现它：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Besides, we can do the intersection without explicitly declaring the type:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在不明确声明类型的情况下进行交集操作：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can also define a union type that allows any type of a group. You know the
    `jQuery` library, right? The function `jQuery` accepts for a selector parameter
    a number of diverse types and returns the `jQuery` instance. How could it possibly
    be covered with an interface?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义一个允许任何类型的组的联合类型。你知道`jQuery`库，对吧？函数`jQuery`接受各种类型的选择器参数，并返回`jQuery`实例。如何可能用接口来覆盖它呢？
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When a function returns a type depending on a passed-in type, we can declare
    an interface that describes all the possible use cases:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数返回依赖于传入类型的类型时，我们可以声明一个描述所有可能用例的接口：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A function implementing this interface accepts a string for the `tagName` parameter.
    If the value is `"button"`, the function returns the `Button` element. If `"a"`,
    then it returns the `Anchor` element.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个接口的函数接受`tagName`参数的字符串。如果值是`"button"`，函数返回`Button`元素。如果是`"a"`，则返回`Anchor`元素。
- en: One can find available DOM-related interfaces in the specification at [https://www.w3.org/TR/DOM-Level-2-HTML/html.html](https://www.w3.org/TR/DOM-Level-2-HTML/html.html).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在规范中找到可用的与DOM相关的接口[https://www.w3.org/TR/DOM-Level-2-HTML/html.html](https://www.w3.org/TR/DOM-Level-2-HTML/html.html)。
- en: Generic type
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: 'The types we have just examined refer to a concrete type combination. In addition,
    TypeScript supports a so-called **generic type** that helps reusing the once created
    interface in different contexts. For example, if we want an interface for a data
    map, we can make it like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚检查的类型是指具体类型组合。此外，TypeScript支持所谓的**泛型类型**，它有助于在不同上下文中重用一次创建的接口。例如，如果我们想要一个数据映射的接口，我们可以这样做：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But this `NumberDataMap` accepts only numbers for the member values. Let''s
    say, for string values, we have to create a new interface, such as `StringDataMap`.
    Alternatively, we can declare a generic `DataMap` that sets an arbitrary value
    type constraint when referred:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`NumberDataMap`只接受成员值为数字。假设对于字符串值，我们必须创建一个新的接口，比如`StringDataMap`。或者，我们可以声明一个泛型`DataMap`，在引用时设置任意值类型的约束：
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Global libraries
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局库
- en: 'Yeah, TypeScript is, indeed, an impressive language when it comes to writing
    a new code. But what about existing none-TypeScript libraries? For example, we
    are going to use React and Redux modules. They are written in JavaScript, not
    in TypeScript. Luckily, mainstream libraries are already provided with TypeScript
    declaration files. We can install these files per module using npm:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，TypeScript确实是一种令人印象深刻的语言，当涉及到编写新代码时。但是对于现有的非TypeScript库呢？例如，我们将使用React和Redux模块。它们是用JavaScript编写的，而不是TypeScript。幸运的是，主流库已经提供了TypeScript声明文件。我们可以使用npm按模块安装这些文件：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, when we try something stupid with any of these modules, we get immediately
    notified about the problem:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试对任何这些模块进行愚蠢的操作时，我们会立即收到有关问题的通知：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On compiling or even while typing, you will get the error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译或输入时，你会得到错误：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Fair enough; instead of the HTML element (for example, `document.getElementById(
    "root" )`) I passed to `ReactDOM.render` a string as the second parameter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，与其传递给`ReactDOM.render`的HTML元素（例如`document.getElementById("root")`），我传递了一个字符串作为第二个参数。
- en: 'Yet, to be honest, not every library is provided with TypeScript declarations.
    For example, in the *RSS Aggregator* application, I am going to use the `feedme`
    library ([https://www.npmjs.com/package/feedme](https://www.npmjs.com/package/feedme))
    to fetch and parse RSS by a URL. As it happens, the library has no declaration
    file. Fortunately, we can quickly create one:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，老实说，并非每个库都提供了TypeScript声明。例如，在*RSS聚合器*应用程序中，我将使用`feedme`库（[https://www.npmjs.com/package/feedme](https://www.npmjs.com/package/feedme)）通过URL获取和解析RSS。不过，该库没有声明文件。幸运的是，我们可以快速创建一个：
- en: '`feedme.d.ts`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`feedme.d.ts`'
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The module `feedme` exposes a class `FeedMe`, but TypeScript doesn't know about
    these modules; it is not yet declared in the TypeScript scope. So, we use ambient
    declaration in `feedme.d.ts (declare class FeedMe)` to introduce a new value in
    the scope. We state the class constructor that accepts an optional flag of the
    type `boolean` and returns the Node.js `WriteStream` object. We use overloading
    to describe two cases of function usage. In the first, it receives a string `"title"`
    for `event` and expects a callback for handling the RSS title. In the second,
    it takes in the event `"title"` and then expects a callback to handle the RSS
    entry.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`feedme`公开了一个类`FeedMe`，但TypeScript并不知道这些模块；它还没有在TypeScript范围内声明。因此，我们在`feedme.d.ts（declare
    class FeedMe）`中使用环境声明来引入作用域中的新值。我们声明接受`boolean`类型的可选标志并返回Node.js`WriteStream`对象的类构造函数。我们使用重载来描述函数使用的两种情况。在第一种情况下，它接收`"title"`字符串作为`event`，并期望回调处理RSS标题。在第二种情况下，它接收`"title"`事件，然后期望回调处理RSS条目。
- en: 'Now, we can consume the newly created declaration file from the service:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从服务中使用新创建的声明文件：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using a triple-slash directive, we include `feedme.d.ts` in the project. After
    it's done, TypeScript validates if `FeedMe` is used according to its interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三斜杠指令，我们将`feedme.d.ts`包含在项目中。完成后，TypeScript会验证`FeedMe`是否根据其接口使用。
- en: Creating static prototype
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建静态原型
- en: I assume, at this point, we are quite enough into TypeScript to start with the
    application. As with to the previous examples, first what we do is the static
    prototype.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，到这一点，我们已经足够了解TypeScript，可以开始应用程序了。与之前的示例一样，首先我们做的是静态原型。
- en: Setting up the development environment for the application
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序设置开发环境
- en: 'We have to set up our development environment for the project. So, we dedicate
    a directory and put the following manifest there:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为项目设置开发环境。因此，我们专门为它分配一个目录，并将以下清单放在其中：
- en: '`./package.json`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`./package.json`'
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As requested by any Electron application, we set the path to our main process
    script in the `main` field. We also define scripts commands to run Webpack for
    building and for watching. We set one scripts command for running the application
    with Electron. Now, we can install the dependencies. We definitely need TypeScript,
    as we are going to build the application using it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据任何Electron应用程序的要求，我们在`main`字段中设置了主进程脚本的路径。我们还定义了运行Webpack进行构建和监视的脚本命令。我们设置了一个脚本命令来使用Electron运行应用程序。现在，我们可以安装依赖项。我们肯定需要TypeScript，因为我们将使用它来构建应用程序：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For bundling, we will use Webpack as we did for Chat and for Screen Capturer
    applications, but this time, instead of `babel-loader`, we go with `ts-loader`,
    because our sources are in the TypeScript syntax:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于打包，我们将使用Webpack，就像我们为Chat和Screen Capturer应用程序所做的那样，但是这次，我们不再使用`babel-loader`，而是使用`ts-loader`，因为我们的源代码是TypeScript语法：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We also install Electron and the accompanying modules that we already examined
    while creating the Chat application:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还安装了Electron和相关模块，这些模块我们在创建Chat应用程序时已经检查过：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we install the React declaration files:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们安装了React声明文件：
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In order to access interfaces of Node.js, we also install the corresponding
    declarations:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问Node.js的接口，我们还安装了相应的声明：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we can configure Webpack:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以配置Webpack了：
- en: '`./webpack.config.js`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`./webpack.config.js`'
- en: '[PRE46]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we set the entry script as `app/ts/index.tsx` and `./app/build/js/bundle.js`
    as the output. We target Webpack on Electron (`electron-renderer`) and enable
    source map generation. Finally, we specify a rule, that makes Webpack process
    any `.ts`/`.tsx` files with the `ts-loader` plugin.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将入口脚本设置为`app/ts/index.tsx`，输出为`./app/build/js/bundle.js`。我们将Webpack目标设置为Electron（`electron-renderer`），并启用源映射生成。最后，我们指定了一个规则，使Webpack使用`ts-loader`插件处理任何`.ts`/`.tsx`文件。
- en: 'So, if we request a file, such as `require("./path/file.ts")` or `import {member}
    from "./path/file.ts"`, Webpack will compile it with TypeScript during the bundling.
    We can make it more convenient using the Webpack option `resolve`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们请求一个文件，比如`require("./path/file.ts")`或`import {member} from "./path/file.ts"`，Webpack将在打包期间使用TypeScript进行编译。我们可以使用Webpack选项`resolve`使其更加方便：
- en: '`./webpack.config.js`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`./webpack.config.js`'
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we state that any encountered module name Webpack tries to resolve against
    both `node_modules` and `app/ts` directories. So, if we access a module like that,
    we will have the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明Webpack会尝试解析遇到的任何模块名，对`node_modules`和`app/ts`目录进行解析。因此，如果我们访问一个模块，我们将得到以下结果：
- en: '[PRE48]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'According to our configuration, Webpack first checks the existence of `node_modules/file.ts`
    and then `app/ts/file.ts`. Since we enlisted the `.ts` extension as resolvable,
    we can omit it from the module name:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的配置，Webpack首先检查`node_modules/file.ts`的存在，然后是`app/ts/file.ts`。由于我们将`.ts`扩展名列为可解析的，所以可以从模块名中省略它：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'What''s left is just configuration for TypeScript:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是TypeScript的配置：
- en: '`tsconfig.json`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsconfig.json`'
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It's pretty much the same as we created for the TypeScript introduction examples,
    except that, here, we do not point the compiler to a directory, but explicitly
    to the entry script. We also inform the compiler that it shall expect JSX.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上和我们为TypeScript介绍示例创建的配置是一样的，只是这里我们不是指向编译器一个目录，而是明确指向入口脚本。我们还告诉编译器它应该期望JSX。
- en: React-MDL
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React-MDL
- en: 'Previously, while working on Screen Capturer, we examined the component library
    Material UI. That''s not the only implementation of material design available
    for React. This time, let''s try another one--**React MDL** ([https://react-mdl.github.io/react-mdl/](https://react-mdl.github.io/react-mdl/)).
    So, we install the library and the accompanying declarations:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，在开发Screen Capturer时，我们研究了组件库Material UI。这并不是React可用的唯一的material design实现。这次，让我们尝试另一个--**React
    MDL** ([https://react-mdl.github.io/react-mdl/](https://react-mdl.github.io/react-mdl/))。所以，我们安装了该库和相应的声明：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'According to the documentation, we enable the library via imports:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，我们通过导入来启用库：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Oh! Oh! Webpack won''t be able to resolve the CSS module until we configure
    it accordingly. First, we have to tell Webpack to look for `react-mdl/extra/material.css`
    and `react-mdl/extra/material.js` in the `node_modules` directory:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！哦！Webpack无法解析CSS模块，直到我们相应地进行配置。首先，我们必须告诉Webpack在`node_modules`目录中查找`react-mdl/extra/material.css`和`react-mdl/extra/material.js`：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Second, we add a rule to handle CSS with the `css-loader` plugin:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们添加了一个规则来处理CSS，使用`css-loader`插件：
- en: '`./webpack.config.js`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`./webpack.config.js`'
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Well, now, when meeting `import "react-mdl/extra/material.css"`, Webpack loads
    the styles and embeds them into the page. But within the CSS content, there are
    links to a custom `.woff` fonts. We need to make Webpack load the referred font
    files:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当遇到`import "react-mdl/extra/material.css"`时，Webpack会加载样式并将其嵌入页面中。但在CSS内容中，有链接到自定义的`.woff`字体。我们需要让Webpack加载所引用的字体文件：
- en: '`./webpack.config.js`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`./webpack.config.js`'
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we have to install both the mentioned loaders:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须安装上述提到的加载器：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Creating the index.html
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建index.html
- en: The first thing we usually take care of in the Electron application is the main
    process script that basically creates the application window. For this application,
    we do not introduce any new concepts about it, so we can reuse `main.js` of the
    Chat application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Electron应用程序中，我们通常首先处理的是主进程脚本，它基本上创建应用程序窗口。对于这个应用程序，我们不会介绍任何新的概念，所以我们可以重用Chat应用程序的`main.js`。
- en: 'The `index.html` will be very simple:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`将非常简单：'
- en: '[PRE57]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Basically, we load Google's Material Icons font and declare out the bounding
    element (`div#root`). Of course, we have to load the generated by the Webpack/TypeScipt
    JavaScript. It is located at `build/js/bundle.js,`, exactly as we configured it
    in `./webpack.config.js`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们加载了Google的Material Icons字体并声明了边界元素（`div#root`）。当然，我们必须加载由Webpack/TypeScipt生成的JavaScript。它位于`build/js/bundle.js`，就像我们在`./webpack.config.js`中配置的那样。
- en: 'Next, we compose the entry script:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们组成入口脚本：
- en: '`./app/ts/index.tsx`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/index.tsx`'
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you see, it's similar to what we had in the Screen Capturer static prototype,
    except for importing React-MDL assets. As for TypeScript, it doesn't really require
    any changes in the code. Yet, now we definitely have typed interfaces for the
    module we use (`./node_modules/@types/react-dom/index.d.ts`), meaning if we violate
    a constraint, for example, of `ReactDOM.render`, we get an error.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它与我们在屏幕捕捉器静态原型中所拥有的相似，除了导入React-MDL资产。至于TypeScript，在代码中并不真正需要任何更改。然而，现在我们确实为我们使用的模块拥有了类型化接口（`./node_modules/@types/react-dom/index.d.ts`），这意味着如果我们违反了约束，例如`ReactDOM.render`，我们会得到一个错误。
- en: Creating the container component
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建容器组件
- en: 'Let''s now create the `container` component that we referred to in the entry
    script:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们在入口脚本中提到的`container`组件：
- en: '`./app/ts/Containers/App.tsx`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Containers/App.tsx`'
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we import the components `Layout` and `Content` from the React-MDL library.
    We use them to layout our custom components `TitleBar`, `Menu`, and `Feed`. According
    to the React declaration file `(./node_modules/@types/react/index.d.ts`), `React.Component`
    is a generic type, so we have to provide it with interfaces for the state and
    props `React.Component<IState, IProps>.` In the static prototype, we have neither
    states nor props, so we can go with empty types.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从React-MDL库中导入`Layout`和`Content`组件。我们使用它们来布局我们的自定义组件`TitleBar`、`Menu`和`Feed`。根据React声明文件（`./node_modules/@types/react/index.d.ts`），`React.Component`是一个泛型类型，所以我们必须为状态和属性提供接口`React.Component<IState,
    IProps>`。在静态原型中，我们既没有状态也没有属性，所以我们可以使用空类型。
- en: Creating the TitleBar component
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TitleBar组件
- en: 'The next component will represent the title bar:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组件将代表标题栏：
- en: '`./app/ts/Components/TitleBar.tsx`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Components/TitleBar.tsx`'
- en: '[PRE60]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we set up the look and feel using the `Header`, `Navigation`, and `Icon`
    components of React MDL and subscribe for the click event on the close icon. Furthermore,
    we import the `remote` object of the `electron` module and, by using the `getCurrentWindow`
    method, we access the current window object. It has the method `close` that we
    apply to close the window.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用React MDL的`Header`、`Navigation`和`Icon`组件来设置外观和感觉，并订阅关闭图标的点击事件。此外，我们导入`electron`模块的`remote`对象，并通过使用`getCurrentWindow`方法访问当前窗口对象。它有一个`close`方法，我们用它来关闭窗口。
- en: Our `Menu` component will contain the list of aggregated feeds. With the buttons
    `add` and `remove`, users will be able to manage the list. The button `autorenew`
    serves to update all the feeds.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Menu`组件将包含聚合源的列表。用户可以使用`add`和`remove`按钮来管理列表。`autorenew`按钮用于更新所有源。
- en: Creating the Menu component
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建菜单组件
- en: 'We are going to keep the feed menu in the `Drawer` component of React MDL that
    shows up automatically on wide screens and hides in the burger menu on smaller
    ones:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持源菜单在React MDL的`Drawer`组件中，它会在宽屏上自动显示，并在较小屏幕上隐藏在汉堡菜单中：
- en: '`./ts/Components/Menu.tsx`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`./ts/Components/Menu.tsx`'
- en: '[PRE61]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Creating the feed component
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建源组件
- en: 'Finally, we take care of the main section where we are going display active
    feed content:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来处理主要部分，我们将在其中显示活动源内容：
- en: '`./app/ts/Components/Feed.tsx`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Components/Feed.tsx`'
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the `.feed-list` container, we display the list of RSS items, each wrapped
    with the `Card` component of React MDL. The container `.feed-contents` is a placeholder
    for the item content.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.feed-list`容器中，我们显示了RSS项的列表，每个都用React MDL的`Card`组件包装。容器`.feed-contents`是项目内容的占位符。
- en: 'Everything is ready. We can build and start:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪。我们可以构建并启动：
- en: '[PRE63]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output is:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '![](img/f6d5f4f5-5d11-4fc4-ba26-2c08655f35b1.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6d5f4f5-5d11-4fc4-ba26-2c08655f35b1.png)'
- en: Adding custom styles with SASS
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SASS添加自定义样式
- en: 'Seemingly, the resulting UI needs additional styling. I suggest that we code
    our custom styles in SASS:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，结果UI需要额外的样式。我建议我们在SASS中编写我们的自定义样式：
- en: '`./app/sass/app.scss`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/sass/app.scss`'
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: First of all, we make the top level element (`./app/ts/Containers/App.tsx`)
    always adapt to the actually window height.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们让顶层元素（`./app/ts/Containers/App.tsx`）始终适应实际的窗口高度。
- en: 'Further, we declare a variable for the fixed height of the title bar and set
    the layout for feed items and item content containers:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个变量来固定标题栏的高度，并设置源项和项目内容容器的布局：
- en: '`./app/sass/app.scss`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/sass/app.scss`'
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Initially, the width of the feed items container (`.feed-list`) is 100%, while
    item content one (`.feed-contents`) is hidden (`width:0`). When the parent container
    (`.feed-index`) receives the new state with the `is-open` class, both the child
    containers shift to `50%` width gracefully.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，源项容器（`.feed-list`）的宽度为100%，而项目内容容器（`.feed-contents`）被隐藏（`width:0`）。当父容器（`.feed-index`）接收到带有`is-open`类的新状态时，两个子容器会优雅地将宽度移动到`50%`。
- en: 'Finally, we layout the action buttons in the Menu component:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在菜单组件中布局操作按钮：
- en: '`./app/sass/app.scss`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/sass/app.scss`'
- en: '[PRE66]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Well, we have introduced a new source type (SASS), so we have to adjust the
    Webpack configuration:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们引入了一个新的源类型（SASS），所以我们必须调整Webpack配置：
- en: '`./webpack.config.js`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`./webpack.config.js`'
- en: '[PRE67]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, Webpack accepts `.scss` module names and look for the source in `app/sass`.
    We also have to configure Webpack to compile SASS in CSS:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Webpack接受`.scss`模块名称，并在`app/sass`中查找源。我们还必须配置Webpack来将SASS编译为CSS：
- en: '`./webpack.config.js`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`./webpack.config.js`'
- en: '[PRE68]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here, we determine that, when resolving the `.scss` file, Webpack uses the
    `sass-loader` plugin to convert SASS to CSS and then `css-loader` and `style-loader`
    to load the generated CSS. So, we now have a missing dependency - `sass-loader`;
    let''s install it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们确定在解析`.scss`文件时，Webpack使用`sass-loader`插件将SASS转换为CSS，然后使用`css-loader`和`style-loader`加载生成的CSS。所以，我们现在缺少一个依赖项
    - `sass-loader`；让我们安装它：
- en: '[PRE69]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This module relies on the `node-sass` compiler, so we need it also:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块依赖于`node-sass`编译器，所以我们也需要它：
- en: '[PRE70]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Why not to check what we get. So we build and start:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不检查一下我们得到了什么。所以我们构建并启动：
- en: '[PRE71]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The application looks better now:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在看起来更好了：
- en: '![](img/8abe2f4f-53e7-4037-ba53-f9dac45751a2.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8abe2f4f-53e7-4037-ba53-f9dac45751a2.png)'
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dived into TypeScript. We examined basic types in variable
    declarations and in parameter constraints. We fiddled with interfaces for arrays
    and plain objects. You learned to interface functions and classes. We took note
    of abstraction features, such as member accessibility modifiers, parameter property,
    abstract classes, and methods. You learned to handle group entities with the enum
    type and string literals. We examined the reuse of interfaces with generic type.
    We have also seen how to install TypeScript declarations for global libraries
    and how to write our own when none is available. We started to work on the application.
    So, we set up Webpack to find and process the `.ts`/`.tsx` modules as well as
    to load CSS and web fonts. We used components of the React MDL library to create
    the UI. We extended the Webpack configuration with the SASS loader to process
    our custom styles. We ended up with a working static prototype.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入学习了TypeScript。我们研究了变量声明和参数约束中的基本类型。我们使用接口来处理数组和普通对象。您学会了如何处理函数和类的接口。我们注意到了抽象特性，比如成员可访问性修饰符、参数属性、抽象类和方法。您学会了如何使用枚举类型和字符串字面量来处理组实体。我们研究了如何使用泛型类型重用接口。我们还看到了如何在全局库中安装TypeScript声明，以及在没有可用声明时如何编写我们自己的声明。我们开始着手应用程序。因此，我们设置了Webpack来查找和处理`.ts`/`.tsx`模块，以及加载CSS和Web字体。我们使用React
    MDL库的组件来创建用户界面。我们通过SASS加载器扩展了Webpack配置，以处理我们的自定义样式。最终我们得到了一个可工作的静态原型。
