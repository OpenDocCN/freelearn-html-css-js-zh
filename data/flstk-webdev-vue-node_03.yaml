- en: Introducing MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MongoDB
- en: The name MongoDB comes from the phrase huMONGOus data, meaning that it can handle
    a lot of data. MongoDB is a document-oriented database architecture. It enables
    us to develop faster and scale better. In relational database designs, we store
    data by creating tables and rows, but with MongoDB, we can model our data as JSON
    documents, which is much simpler compared to those relational databases. If we
    are agile and our requirements keep changing very often, and if we need to do
    continuous deployment, then MongoDB is our choice. Being a document-based data
    model, MongoDB is very flexible as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的名称来源于短语huMONGOus data，意味着它可以处理大量数据。MongoDB是一种面向文档的数据库架构。它使我们能够更快地开发并更好地扩展。在关系型数据库设计中，我们通过创建表和行来存储数据，但与MongoDB相比，我们可以将数据建模为JSON文档，这比那些关系型数据库要简单得多。如果我们是敏捷的，并且我们的需求经常变化，并且如果我们需要持续部署，那么MongoDB是我们的选择。作为一个基于文档的数据模型，MongoDB也非常灵活。
- en: The biggest advantage of using MongoDB is that the data is unstructured. We
    can customize our data in any format we like. In a **relational database management
    system** (**RDBMS**), we have to define exactly the number of fields a table can
    have, but with MongoDB, each document can have its own number of fields. We can
    add new data without even having to worry about changing the schema, which is
    why Mongo has a **schemaless design model** for the database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB的最大优势是数据非结构化。我们可以以任何我们喜欢的格式自定义我们的数据。在**关系型数据库管理系统**（**RDBMS**）中，我们必须精确地定义一个表可以有多少字段，但与MongoDB不同，每个文档都可以有自己的字段数。我们可以添加新数据，甚至无需担心更改模式，这就是为什么Mongo数据库采用了**无模式设计模型**。
- en: If our business is growing fast, we need to scale faster, we need to access
    data in a more flexible way, and if we need to make changes to our data without
    having to worry about updating our application's database schemas, then MongoDB
    is the best choice for us. Adding new columns to tables in RDBMS also creates
    some performance issues. But, since MongoDB is schemaless, adding new fields is
    done in an instant without compromising the performance of our application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的业务增长迅速，我们需要更快地扩展，以更灵活的方式访问数据，如果我们需要更改数据而无需担心更新应用程序的数据库模式，那么MongoDB是我们最佳的选择。在RDBMS的表中添加新列也会引起一些性能问题。但是，由于MongoDB是无模式的，添加新字段可以瞬间完成，而不会影响我们应用程序的性能。
- en: In a relational database, the terminologies that we use are **database**, **tables**,
    and **rows**, whereas in MongoDB, we use **database**, **collections**, and **documents**,
    respectively.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中，我们使用的术语是**数据库**、**表**和**行**，而在MongoDB中，我们分别使用**数据库**、**集合**和**文档**。
- en: 'Here is a brief summary of what we will be covering in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要概述我们将要涵盖的内容：
- en: Introducing to MongoDB and the benefits of using MongoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍MongoDB及其使用MongoDB的好处
- en: Understanding the MongoDB database, collections, and documents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解MongoDB数据库、集合和文档
- en: Introducing to Mongoose, creating a connection with Mongoose, understanding
    Mongoose, and CRUD operations with Mongoose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Mongoose，使用Mongoose建立连接，理解Mongoose，以及使用Mongoose进行CRUD操作
- en: Adding default and custom validations with Mongoose
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mongoose添加默认和自定义验证
- en: Why MongoDB?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择MongoDB？
- en: 'MongoDB provides a lot of advantages, some of which are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB提供了许多优势，其中一些包括：
- en: '**Flexible documents**: A MongoDB collection holds several documents. Each
    document under one collection can have variable field names and can have a different
    size as well, which means we don''t have to define the schema.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的文档**：MongoDB的集合包含多个文档。一个集合下的每个文档可以有不同的字段名，并且可以有不同的尺寸，这意味着我们不需要定义模式。'
- en: '**No complex relationships**: The documents in MongoDB are stored as JSON documents,
    which means we no longer have to scratch our head learning about the relationships
    between various components of the application.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无复杂关系**：MongoDB中的文档以JSON文档的形式存储，这意味着我们不再需要费心学习应用程序各个组件之间的关系。'
- en: '**Easy to scale**: MongoDB is easy to scale as it minimizes the database size
    by using a partitioning method called sharding. Sharding is a database partitioning
    method that allows us to segregate a large database into smaller pieces.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于扩展**：MongoDB易于扩展，因为它通过使用称为分片的方法来最小化数据库大小。分片是一种数据库分区方法，允许我们将大型数据库分割成更小的部分。'
- en: MongoDB queries
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB查询
- en: We did quickly review what Mongo queries look like in [Chapter 1](d95a8844-6413-49ed-8d4a-9607cb550211.xhtml), *Introduction
    to MEVN*. Here, we will dive deep into these queries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 1 章](d95a8844-6413-49ed-8d4a-9607cb550211.xhtml)，“MEVN 简介”中简要回顾了 Mongo
    查询的外观。在这里，我们将深入探讨这些查询。
- en: 'The first thing we need to do is start the MongoDB server. We can do that with
    this command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是启动 MongoDB 服务器。我们可以使用以下命令来完成：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's open the mongo shell by typing `mongo` in our Terminal. When we enter
    the mongo shell, to display the list of databases, we type `show dbs`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在终端中键入 `mongo` 来打开 mongo shell。当我们进入 mongo shell 时，要显示数据库列表，我们键入 `show
    dbs`。
- en: 'If you see the database in the list, type `use {database_name}` to start using
    this database. If we haven''t created our database yet, just using `use {database_name}`
    will create a database for us. It''s as simple as that. For this exercise, let''s
    create a database called `mongo_test_queries`. So for that, we need to use:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到数据库在列表中，键入 `use {database_name}` 以开始使用此数据库。如果我们还没有创建我们的数据库，只需使用 `use {database_name}`
    就会为我们创建一个数据库。就这么简单。对于这个练习，让我们创建一个名为 `mongo_test_queries` 的数据库。为此，我们需要使用：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This should output the following in the Terminal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在终端中输出以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, once we enter the database, the first thing that we need is a collection.
    We have a database but there are no collections. The best way to create a collection
    in MongoDB is by inserting a document. This not only initializes a collection
    but also adds the document to that collection. Simple as that. Now, let's move
    on to Mongo queries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们进入数据库，我们首先需要的是一个集合。我们有一个数据库，但没有集合。在 MongoDB 中创建集合的最佳方式是通过插入一个文档。这不仅初始化了一个集合，还将文档添加到该集合中。就这么简单。现在，让我们继续学习
    Mongo 查询。
- en: Creating documents
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文档
- en: There are different queries to create a document in MongoDB, such as `insertOne()`,
    `insertMany()`, and `insert()`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 中创建文档有不同的查询，例如 `insertOne()`、`insertMany()` 和 `insert()`。
- en: insertOne()
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: insertOne()
- en: 'The `insertOne()` command adds a single document to our collection. For example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertOne()` 命令将单个文档添加到我们的集合中。例如：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command takes only a single parameter, which is an object, and we can
    pass the field names and values we want for our `users` collection. When we run
    the preceding code in our Terminal inside the Mongo shell, we should get the following
    output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令仅接受一个参数，即一个对象，我们可以传递我们想要为 `users` 集合指定的字段名称和值。当我们运行上述代码时，我们应该在 Mongo shell
    的终端中得到以下输出：
- en: '![](img/91f27147-b1ee-4f8f-9121-a09b3d2a3c84.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91f27147-b1ee-4f8f-9121-a09b3d2a3c84.png)'
- en: It returns the `_id` of the document that just got created. We have successfully
    created a collection and a document in the `users` collection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回刚刚创建的文档的 `_id`。我们已经成功在 `users` 集合中创建了一个集合和文档。
- en: The `insertOne()` and `insertMany()` commands only work for Mongo version 3.2
    or higher.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertOne()` 和 `insertMany()` 命令仅适用于 Mongo 版本 3.2 或更高版本。'
- en: insertMany()
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: insertMany()
- en: 'This command is used for inserting multiple documents into a collection. In
    the preceding example, we saw that the `insertOne()` command takes an argument
    that is an object. The `insertMany()` command takes an array as a parameter so
    that we can pass multiple objects inside it and insert multiple documents in the
    collection. Let''s look at an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于将多个文档插入到集合中。在先前的示例中，我们看到了 `insertOne()` 命令接受一个参数，该参数是一个对象。`insertMany()`
    命令接受一个数组作为参数，这样我们就可以在它内部传递多个对象，并将多个文档插入到集合中。让我们看一个例子：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This snippet creates three documents in the `users` collection. When we run
    the command, the output should be:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段在 `users` 集合中创建了三个文档。当我们运行此命令时，输出应该是：
- en: '![](img/2a0b35a8-6ce9-4aea-a11d-92c82bda78cf.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a0b35a8-6ce9-4aea-a11d-92c82bda78cf.png)'
- en: insert()
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: insert()
- en: 'This command inserts single as well as multiple documents into a collection.
    It does the job of both the `insertOne()` and the `insertMany()` commands. To
    insert a single document, we can use:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将单个文档以及多个文档插入到集合中。它同时完成了 `insertOne()` 和 `insertMany()` 命令的工作。要插入单个文档，我们可以使用：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the command is executed successfully, we should see the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令执行成功，我们应该看到以下输出：
- en: '![](img/8a719b2a-0ff8-40a6-aa1a-f68d30c60f64.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a719b2a-0ff8-40a6-aa1a-f68d30c60f64.png)'
- en: 'Now, if we want to insert multiple documents, we can simply use:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想插入多个文档，我们可以简单地使用：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是以下内容：
- en: '![](img/e9a066be-5a9a-49cb-b34e-7d57f8edb430.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9a066be-5a9a-49cb-b34e-7d57f8edb430.png)'
- en: Retrieving documents
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索文档
- en: Retrieving documents from collections in MongoDB is done using the `find()`
    command. There are many ways to use this command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `find()` 命令从 MongoDB 的集合中检索文档。有多种使用此命令的方法。
- en: Finding all documents
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找所有文档
- en: 'To retrieve all documents from a collection, we can use:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集合中检索所有文档，我们可以使用：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This outputs the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出以下内容：
- en: '![](img/493ba105-c15e-4001-bec1-5c33c473e5e8.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/493ba105-c15e-4001-bec1-5c33c473e5e8.png)'
- en: Finding documents via filters
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过过滤器查找文档
- en: 'We can add filters to the `find()` command as well. Let''s retrieve documents
    with the name  `Mike`. For that, we can use:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 `find()` 命令中添加过滤器。让我们检索名为 `Mike` 的文档。为此，我们可以使用：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It should return a document with the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回以下文档：
- en: '![](img/48f4dda2-bd2a-4452-9a6c-6900e11ff9f5.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48f4dda2-bd2a-4452-9a6c-6900e11ff9f5.png)'
- en: We can also specify multiple conditions with `AND` or `OR` queries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `AND` 或 `OR` 查询指定多个条件。
- en: 'To find a collection with the name `Mike` and the email `mike@mongo.com`, we
    can simply use:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找名为 `Mike` 且电子邮件为 `mike@mongo.com` 的集合，我们可以简单地使用：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The comma operator means an `AND` operator. We can specify as many conditions
    as we like with comma-separated values. The preceding command should output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符表示 `AND` 运算符。我们可以使用逗号分隔的值指定任意数量的条件。前面的命令应该输出：
- en: '![](img/5c263d37-43b8-433c-9a47-ff92862d4fe0.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c263d37-43b8-433c-9a47-ff92862d4fe0.png)'
- en: 'Now, specifying conditions with `AND` or comma operators is simple. If we want
    to use the OR operator, then we should use:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在指定 `AND` 或逗号运算符的条件变得简单。如果我们想使用 `OR` 运算符，那么我们应该使用：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are saying: retrieve those documents for users whose name is Mike,
    and the email can be `josh@mongo.com` as well. The output is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们说的是：检索那些名为 Mike 的用户文档，电子邮件可以是 `josh@mongo.com`。输出如下：
- en: '![](img/2fae1443-b58a-48ea-af6a-95deda33f5f3.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fae1443-b58a-48ea-af6a-95deda33f5f3.png)'
- en: Updating documents
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新文档
- en: 'Just like `insert()`, there are three methods of using the `update()` command
    in MongoDB: `updateOne()`, `updateMany()`, and `update()`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `insert()` 一样，在 MongoDB 中使用 `update()` 命令有三种方法：`updateOne()`、`updateMany()`
    和 `update()`。
- en: updateOne()
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: updateOne()
- en: 'This command updates only a single document in the collection. Here, we have
    inserted a couple of user entries with the incorrect emails. For the user with
    the name `Peter`, the email is `jack@mongo.com`. Let''s update this document using
    `updateOne()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令只更新集合中的一个文档。在这里，我们插入了一些用户条目，电子邮件不正确。对于名为 `Peter` 的用户，电子邮件是 `jack@mongo.com`。让我们使用
    `updateOne()` 更新此文档：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command will update Peter''s email to `peter@mongo.com`. The output is:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将更新 Peter 的电子邮件为 `peter@mongo.com`。输出如下：
- en: '![](img/a7c5fd07-4a23-4cad-9dcf-f086003367ba.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7c5fd07-4a23-4cad-9dcf-f086003367ba.png)'
- en: As the output says, the `modifiedCount` is `1` and the `matchedCount` is `1`,
    which means the document with the given condition was found and updated.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如输出所示，`modifiedCount` 是 `1`，`matchedCount` 也是 `1`，这意味着找到了符合给定条件的文档并已更新。
- en: updateMany()
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: updateMany()
- en: 'This command is used to update multiple documents in a collection. The command
    for updating documents with `updateOne()` and `updateMany()` is the same. To update
    the multiple records, we specify the condition and then set the desired values:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于更新集合中的多个文档。`updateOne()` 和 `updateMany()` 更新文档的命令相同。要更新多个记录，我们指定条件并设置所需的值：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only difference between `updateOne()` and `updateMany()` is that `updateOne()`
    updates only the first document that is matched whereas `updateMany()` updates
    all the documents that are matched.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateOne()` 和 `updateMany()` 之间的唯一区别是 `updateOne()` 只更新第一个匹配的文档，而 `updateMany()`
    更新所有匹配的文档。'
- en: update()
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: update()
- en: 'Just like insert, the `update()` command does the job for `updateOne()` and
    `updateMany()`. To remove confusion, we can just use the `update()` command instead
    of `updateOne()` and `updateMany()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像插入一样，`update()` 命令为 `updateOne()` 和 `updateMany()` 做了同样的事情。为了消除混淆，我们可以直接使用
    `update()` 命令而不是 `updateOne()` 和 `updateMany()`：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/acd38c2b-330c-44af-bfe4-d799032d7288.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acd38c2b-330c-44af-bfe4-d799032d7288.png)'
- en: Deleting documents
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文档
- en: MongoDB provides multiple commands for deleting and removing documents from
    collections.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 提供了多个命令用于从集合中删除和移除文档。
- en: deleteOne()
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: deleteOne()
- en: '`deleteOne()` removes only a single document from a collection:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteOne()` 只从集合中删除一个文档：'
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This removes the entry of a user whose name is `John`. The output is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这会删除名为 `John` 的用户条目。输出如下：
- en: '![](img/4a229e2e-ac94-4654-bb52-3e0fc52b7cf8.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a229e2e-ac94-4654-bb52-3e0fc52b7cf8.png)'
- en: As you can see in the output, the `deletedCount` is `1`, which means the record
    has been deleted.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中看到的，`deletedCount` 是 `1`，这意味着记录已被删除。
- en: deleteMany()
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: deleteMany()
- en: 'The command for `deleteMany()` is the same as `deleteOne()`. The only difference
    is that `deleteOne()` removes only a single entry with the matched filter whereas
    `deleteMany()` removes all the documents which match the given criteria:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteMany()` 命令与 `deleteOne()` 相同。唯一的区别是 `deleteOne()` 只删除与匹配过滤器匹配的单个条目，而
    `deleteMany()` 则删除所有符合给定条件的文档：'
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/f45587d2-a32a-44c1-88b3-e3a6f6b71bf6.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f45587d2-a32a-44c1-88b3-e3a6f6b71bf6.png)'
- en: remove()
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: remove()
- en: 'The `remove()` command works to remove a single entry, as well as multiple
    entries, from a collection. If we want to remove only a single document that matched
    certain criteria, then we can pass the count of entries that we wish to delete.
    For example, let''s first create an entry:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()` 命令用于从集合中删除单个条目以及多个条目。如果我们只想删除符合某些条件的单个文档，则可以传递我们希望删除的条目数。例如，让我们首先创建一个条目：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this, now we have two entries for `Mike`. Now, if we want to remove just
    one entry using `remove()`, we can do so with:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，现在我们有两个 `Mike` 的条目。现在，如果我们想使用 `remove()` 删除单个条目，我们可以这样做：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/9c069d94-4b75-4853-855d-d584cbb13044.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c069d94-4b75-4853-855d-d584cbb13044.png)'
- en: 'As you can see, we had two entries with the name `Mike`, but it only removed
    one. Similarly, if we want to remove all the documents, we can just use:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有两个名为 `Mike` 的条目，但它只删除了一个。同样，如果我们想删除所有文档，我们只需使用：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All documents will be removed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文档都将被删除。
- en: We talked about the basic ideas on how we can query the documents in Mongo.
    To find out more details, visit [https://docs.mongodb.com/v3.2/tutorial/query-documents/](https://docs.mongodb.com/v3.2/tutorial/query-documents/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何在 Mongo 中查询文档的基本思路。要了解更多详细信息，请访问 [https://docs.mongodb.com/v3.2/tutorial/query-documents/](https://docs.mongodb.com/v3.2/tutorial/query-documents/)。
- en: Introducing Mongoose
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Mongoose
- en: Mongoose is an elegant MongoDB object modeling library for Node.js. As I mentioned
    earlier, MongoDB is a schemaless database design. While this has its own advantages,
    sometimes we need to add certain validations as well, and this means defining
    the schemas for our documents. Mongoose provides an easy way to add such validations
    and to typecast the fields in a document.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 是一个优雅的 MongoDB 对象建模库，适用于 Node.js。正如我之前提到的，MongoDB 是一种无模式的数据库设计。虽然这有其自身的优势，但有时我们还需要添加某些验证，这意味着我们需要为我们的文档定义模式。Mongoose
    提供了一种简单的方法来添加此类验证以及将文档中的字段类型化。
- en: 'For example, to insert data into a MongoDB document, we can use:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将数据插入 MongoDB 文档中，我们可以使用：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if we want to add another document and we want an extra field in that
    document, we can use:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想添加另一个文档并且想在其中添加一个额外的字段，我们可以使用：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is possible in MongoDB because no schemas are defined. These types of documents
    are also needed when building an application. MongoDB will silently accept any
    kind of document. However, there are times when we need to have documents look
    similar in order to behave in certain validations or to have a specific data type.
    In such situations, Mongoose comes to the rescue. We can also leverage these features
    with raw MongoDB as well, but writing validations in MongoDB is an extremely painful
    task. That's why Mongoose was created.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 MongoDB 中是可能的，因为没有定义模式。这些类型的文档在构建应用程序时也是必需的。MongoDB 会默默地接受任何类型的文档。然而，有时我们需要文档看起来相似，以便在特定的验证中表现良好或具有特定的数据类型。在这种情况下，Mongoose
    就派上用场了。我们也可以利用这些功能与原始 MongoDB 一起使用，但在 MongoDB 中编写验证是一个极其痛苦的任务。这就是为什么创建 Mongoose
    的原因。
- en: 'Mongoose is a data modeling technique for Mongo written in Node.js. Every document
    inside a Mongoose collection requires a fixed amount of fields. We have to explicitly
    define a `Schema` and adhere to it. An example of a Mongoose schema is:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 是用 Node.js 编写的 Mongo 数据建模技术。Mongoose 集合中的每个文档都需要固定数量的字段。我们必须显式定义一个
    `Schema` 并遵守它。一个 Mongoose 模式的例子是：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This means that the name and description fields must be a string, whereas the
    extras can take a whole JSON object in which we can store nested values as well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着名称和描述字段必须是字符串，而额外字段可以是一个完整的 JSON 对象，在其中我们可以存储嵌套值。
- en: Installing Mongoose
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Mongoose
- en: 'Like any other package, Mongoose can be installed in our project using NPM.
    Run the following command in our Terminal inside our `express_app` folder which
    we created in the previous chapter to install Mongoose inside that application:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他包一样，Mongoose 可以使用 NPM 在我们的项目中安装。在上一章中创建的 `express_app` 文件夹内的终端中运行以下命令来安装
    Mongoose：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this is successfully installed, we should have a line added to our `package.json`
    file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功，我们应该在我们的 `package.json` 文件中添加一行：
- en: '![](img/cd4d9ce0-ceaf-45cf-80ca-181b578da24d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd4d9ce0-ceaf-45cf-80ca-181b578da24d.png)'
- en: Connecting Mongoose to MongoDB
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Mongoose 连接到 MongoDB
- en: 'Once Mongoose is installed, we have to connect it to the MongoDB in order to
    start working with it. This is pretty straightforward with Mongoose; we just have
    to add a piece of code to `require` Mongoose in our `app.js` file and use the `mongoose.connect`
    method to connect it to the database. Let''s go ahead and do that. In the `app.js`
    file, add the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Mongoose，我们必须将其连接到 MongoDB 才能开始使用它。使用 Mongoose 来做这件事非常直接；我们只需在 `app.js`
    文件中添加一段代码来 `require` Mongoose，并使用 `mongoose.connect` 方法将其连接到数据库。让我们继续这样做。在 `app.js`
    文件中，添加以下代码：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will import the Mongoose module into our codebase.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 Mongoose 模块导入到我们的代码库中。
- en: 'Now, to connect to the MongoDB database, add the following line of code in
    our `app.js`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了连接到 MongoDB 数据库，请在我们的 `app.js` 文件中添加以下代码行：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This creates a connection with our Mongoose database. Now, let''s run the app
    with the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的 Mongoose 数据库建立了一个连接。现在，让我们使用以下命令运行应用程序：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'and displays a message in our Terminal if it succeeded or failed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 并在我们的终端中显示一条消息，如果成功或失败：
- en: '![](img/a9f674f8-65fb-4746-9de9-b5347303decc.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9f674f8-65fb-4746-9de9-b5347303decc.png)'
- en: That's it! We have successfully made a connection to our MongoDB database. The
    URL here is the locally hosted database URL.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经成功连接到我们的 MongoDB 数据库。这里的 URL 是本地托管的数据库名称。
- en: Creating records in Mongoose
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Mongoose 中创建记录
- en: Let's start by creating a new model in our application's `express_app`. Create
    a folder called `models` in the root of the project and name it `User.js`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在应用程序的 `express_app` 中创建一个新的模型开始。在项目的根目录下创建一个名为 `models` 的文件夹，并将其命名为 `User.js`。
- en: We are using a capital letter for the starting letter of the file name. Also,
    we are using the single form for `models`. Contrary to this, for `controllers`,
    we use the plural form and lowercase letters, such as `users.js`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用文件名的首字母大写。同样，我们使用 `models` 的单数形式。与此相反，对于 `controllers`，我们使用复数形式和小写字母，例如
    `users.js`。
- en: 'Once we create the file, paste the following code into it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了文件，将以下代码粘贴到其中：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first line here just imports the Mongoose module. This Mongoose package
    provides us with several properties, one of which is to define the `Schema`. Now,
    the original `Schema` definition here is this highlighted part:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一行只是导入 Mongoose 模块。这个 Mongoose 包为我们提供了几个属性，其中之一是定义 `Schema`。现在，这里的原始 `Schema`
    定义是以下高亮部分：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What this does is it adds a validation to our `User` data model, where it says
    there must be two fields in total. It will not accept either one or more than
    two data fields while creating a document for a Mongoose collection. Also, it
    adds a validation layer to this `Schema` as well, which says that the two fields,
    both `name`, and `email`, should be a valid string. It won''t accept an integer,
    Boolean, or anything other than a string for both of these fields. This is how
    we define the `Schema`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的就是在我们的 `User` 数据模型中添加了一个验证，其中说明总共必须有两个字段。在为 Mongoose 集合创建文档时，它不会接受一个或多个数据字段。此外，它还向这个
    `Schema` 添加了一个验证层，说明两个字段，即 `name` 和 `email`，应该是一个有效的字符串。它不会接受整数、布尔值或这两个字段之外的任何其他类型。这就是我们定义
    `Schema` 的方式：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The highlighted part of this code represents the way to create a model. The
    first argument of the method is our model name, which maps to the corresponding
    plural version of the collection name. So, when we create a `User` model, this
    automatically maps to the `user` collections in our database.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的高亮部分表示创建模型的方式。该方法的第一参数是我们的模型名称，它映射到集合名称的相应复数形式。因此，当我们创建一个 `User` 模型时，这会自动映射到我们数据库中的
    `user` 集合。
- en: 'Now, to create a user, the first thing to do is to create a resource:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建一个用户，首先要创建一个资源：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, finally, the part that actually creates the `user` is:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，真正创建 `user` 的部分是：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous code uses a Mongoose function called `save`. The save method has
    a callback function that is used for error handling. We can do whatever we want
    when we encounter an error while saving the resource to our database there:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了一个名为`save`的Mongoose函数。`save`方法有一个用于错误处理的回调函数。当我们将资源保存到数据库时遇到错误，我们可以做任何我们想做的事情：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `res.send` method allows us to set what we want to send to the client when
    the resource is successfully saved to the database. The first element of the object
    is `success: true`, which denotes if the execution was successful or not. The
    second element is the status code or the response code. A `200` response code
    denotes successful execution. We will discuss this in further chapters as well.The
    last element is the message that is sent to the client; the users see this in
    the frontend.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.send`方法允许我们在资源成功保存到数据库时向客户端发送我们想要的内容。对象中的第一个元素是`success: true`，表示执行是否成功。第二个元素是状态码或响应码。一个`200`响应码表示成功执行。我们将在后续章节中进一步讨论这一点。最后一个元素是发送给客户端的消息；用户在前端会看到这个消息。'
- en: That's how we create a resource in Mongoose.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在Mongoose中创建资源的方式。
- en: Fetching records from Mongoose
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Mongoose获取记录
- en: 'Now that we have successfully created a user, we have a record in the `users`
    collections in the database. There are two ways to fetch this record in our client:
    fetch all the records of users that we have or fetch a specific user.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了一个用户，我们在数据库的`users`集合中有一个记录。在我们的客户端中，有两种方式可以获取这个记录：获取所有用户的记录或者获取一个特定的用户。
- en: Fetching all records
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有记录
- en: There are lots of methods that come out of the box with a Mongoose model to
    make our lives easier. Two such methods are `find()` and `findById()`. In MongoDB,
    we saw how we could retrieve a collection's records data via raw MongoDB queries.
    This is similar, the only  difference being that Mongoose has a very easy way
    to do it. I recommend you learn MongoDB first instead of Mongoose because MongoDB
    gives you an overall idea of what a database is and you will learn the fundamentals
    of the database and about its queries. Mongoose just adds a layer on top of MongoDB
    to make it look a little bit easier for faster developments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose模型有很多开箱即用的方法，可以使我们的工作更轻松。其中两种方法是`find()`和`findById()`。在MongoDB中，我们看到了如何通过原始MongoDB查询检索集合的记录数据。这与此类似，唯一的区别是Mongoose有一个非常简单的方式来做到这一点。我建议你先学习MongoDB而不是Mongoose，因为MongoDB可以给你一个数据库的整体概念，你将学习数据库的基础知识和其查询。Mongoose只是在MongoDB之上添加了一层，使其看起来更容易，以便更快地开发。
- en: 'With that, let''s look into the code snippet here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，让我们来看看这里的代码片段：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The Mongoose model `User` calls a method called `find()`. The first parameter
    is our query string, which is left empty: `{}` in the preceding query. So, if
    we want to retrieve all users who share the same name, say, Peter, then we can
    replace that empty `{}` with `{ name: ''Peter''}`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mongoose模型`User`调用一个名为`find()`的方法。第一个参数是我们的查询字符串，它是空的：前一个查询中的`{}`。因此，如果我们想检索所有同名用户，比如Peter，那么我们可以将那个空`{}`替换为`{
    name: ''Peter''}`。'
- en: The second parameter denotes which fields we want to retrieve from the database.
    We can leave it blank if we want to retrieve all fields or we can just specify
    it here. For this example, we are just retrieving user names and emails.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数表示我们想从数据库中检索哪些字段。如果我们想检索所有字段，可以将其留空，或者我们也可以在这里指定。对于这个例子，我们只是检索用户名和电子邮件。
- en: 'The third parameter has a callback function attached to it. This function takes
    two parameters, unlike the `create` method. The first parameter handles the error.
    If, somehow, the execution is not done successfully, it returns an error and we
    can customize it the way we want. The second parameter is the important one here;
    it returns the response when the execution is successfully done. In this case,
    the `users` parameter is an array of objects that are retrieved from the `users`
    collection. The output of this call would be:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数附加了一个回调函数。这个函数有两个参数，与`create`方法不同。第一个参数处理错误。如果执行未成功完成，它返回一个错误，我们可以按我们想要的方式自定义它。第二个参数是这里的一个重要参数；它返回执行成功时的响应。在这种情况下，`users`参数是从`users`集合中检索到的对象的数组。这个调用的输出将是：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now we have all the records from the `users` collection.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从`users`集合中获取了所有记录。
- en: Fetching a specific record
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取特定记录
- en: This is also as simple as fetching all records from a collection. We talked
    about using `find()` in the previous section. To fetch a single record, we have
    to use `findById()` or `findOne()`, or we can also use the `where` query. The
    `where` query is the same as we talked about previously when we had to pass a
    parameter to fetch records that fell under the same category.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这与从集合中检索所有记录一样简单。我们在上一节中讨论了使用 `find()`。要检索单个记录，我们必须使用 `findById()` 或 `findOne()`，或者我们也可以使用
    `where` 查询。`where` 查询与我们之前讨论的相同，当时我们需要传递一个参数来检索属于同一类别的记录。
- en: 'Let''s move ahead on using the following query:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用以下查询：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, the syntax for both `find()` and `findById()` are similar.
    Both take the same amount of parameters and behave the same. The only difference
    between these two is that the preceding `find()` method returned an array of records
    as a response, whereas `findById()` returns a single object. So, the response
    to the preceding query would be:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`find()` 和 `findById()` 的语法相似。它们接受相同数量的参数，表现相同。这两个方法之间的唯一区别是，前面的 `find()`
    方法返回了一个记录数组作为响应，而 `findById()` 返回一个单个对象。因此，前面查询的响应将是：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That's it – simple!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单 - 简单！
- en: Updating records in Mongoose
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Mongoose 中更新记录
- en: Let's move on to updating a record in a collection. There are multiple ways
    to update the collection records as well, just as in retrieving data from the
    collections. Updating a document in Mongoose is the combination of `read` and
    `create`(save) methods. To update a document, we first need to find that document
    using the read query of Mongoose, alter that document, and then save the changes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续更新集合中的记录。更新集合记录的方法也很多，就像从集合中检索数据一样。在 Mongoose 中更新文档是 `read`（读取）和 `create`（保存）方法的组合。要更新文档，我们首先需要使用
    Mongoose 的读取查询找到该文档，然后更改该文档，最后保存更改。
- en: findById() and save()
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: findById() 和 save()
- en: 'Let''s look at an example as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, the first thing we need to do is find the user document, which we are doing
    by `findById()`. This method returns back the user with the given ID. Now that
    we have that user, we can alter whatever we like for this user. In the preceding
    case, we are changing the name and email of that person.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先需要找到用户文档，我们通过 `findById()` 来做这件事。此方法返回具有给定 ID 的用户。现在我们有了这个用户，我们可以更改我们想要的任何内容。在前面的例子中，我们更改了那个人的姓名和电子邮件。
- en: 'Now the important part. The job of updating this user''s document is done by
    the `save()` method here. We have already altered the name and email of the user
    by doing:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重要的部分来了。更新此用户文档的工作是由这里的 `save()` 方法完成的。我们已经通过以下方式更改了用户的姓名和电子邮件：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are changing the object that was returned via `findById()` in the first place
    directly. Now, when we use `user.save()`, this method overwrites whatever value
    it was before for this user with this new name and email.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在直接更改最初通过 `findById()` 返回的对象。现在，当我们使用 `user.save()` 时，此方法会使用新的姓名和电子邮件覆盖此用户之前的所有值。
- en: There are other methods we can use to update a document in Mongoose.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其他方法来更新 Mongoose 中的文档。
- en: findOneAndUpdate()
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: findOneAndUpdate()
- en: 'This method can be used when we want to update a single entry. For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要更新单个条目时，可以使用此方法。例如：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, the first parameter defines the criteria describing the record
    we want to update, which, in this case, is the user whose name is Peter. The second
    parameter is the object in which we define what attributes of `user` do we want
    to update, which is defined by `{ $set: { name: "Sara" }`. This sets the `name`
    of `Peter` to `Sara`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，第一个参数定义了描述我们想要更新的记录的准则，在这种情况下，是名为 Peter 的用户。第二个参数是我们定义要更新的 `user` 的哪些属性的对象，它由
    `{ $set: { name: "Sara" }` 定义。这会将 Peter 的 `name` 设置为 Sara。'
- en: 'Now, let''s make a small alteration to the preceding code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对前面的代码进行一些小的修改：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, notice that I have added a second parameter to the callback function called
    `user`.  What this does is that when Mongoose is done updating that document in
    the database, it returns the object. This is very useful when we want to make
    some decisions after we update the record and want to play with the newly updated
    document.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，请注意，我向回调函数 `user` 添加了一个第二个参数。这样做的作用是，当 Mongoose 完成在数据库中更新该文档后，它会返回该对象。当我们更新记录后想要做出一些决定，并想要操作新更新的文档时，这非常有用。
- en: findByIdAndUpdate()
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: findByIdAndUpdate()
- en: 'This is somewhat similar to `findOneAndUpdate()`. This method takes an ID as
    a parameter, unlike `findOneAndUpdate()`, where we can add our own criteria, and
    updates that document:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`findOneAndUpdate()`有些相似。此方法接受一个ID作为参数，与`findOneAndUpdate()`不同，后者我们可以添加自己的条件，并更新该文档：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The only difference here is that the first parameter takes a single integer
    value, which is the ID of the document rather than an object. This method also
    returns the object that is being updated. So we can use:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别在于，第一个参数接受一个单独的整数值，即文档的ID，而不是一个对象。此方法还会返回正在更新的对象。因此，我们可以使用：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Deleting records in Mongoose
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mongoose中删除记录
- en: Just as there are many ways to create, fetch and update records in Mongoose,
    it also provides several ways to delete records from collections as well, such
    as `remove()`, `findOneAndRemove()`, and `findByIdAndRemove()`. We can use `remove()`
    to remove one or many documents. We can also find the documents we want to remove
    first and then use the `remove()` command to remove only those documents. If we
    want to find a specific document with some criteria, we can use `findOneAndRemove()`.
    We can use `findByIdAndRemove()` when we know the ID of the document we wish to
    remove.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Mongoose中有许多创建、获取和更新记录的方法一样，它也提供了几种从集合中删除记录的方法，例如`remove()`、`findOneAndRemove()`和`findByIdAndRemove()`。我们可以使用`remove()`来删除一个或多个文档。我们也可以先找到我们想要删除的文档，然后使用`remove()`命令仅删除那些文档。如果我们想根据某些条件找到特定的文档，我们可以使用`findOneAndRemove()`。当我们知道要删除的文档的ID时，我们可以使用`findByIdAndRemove()`。
- en: remove()
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`remove()`'
- en: 'Let''s look at a sample for using this method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用此方法的示例：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first argument of the `remove()` method takes the criteria for filtering
    which user we want to remove. It takes an ID as a parameter. It finds the user
    with the given ID and removes the document from the collection. The second parameter
    is the callback function, which we talked about before. If something goes wrong
    with the above operation, it returns an error, which we can use to better handle
    the exceptions or the errors that occur in our application. In the case of success,
    we can define our own logic as to what to return. In the preceding case, we are
    returning `{ success: true }`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`方法的第一个参数接受过滤条件，指定我们想要删除哪个用户。它接受一个ID作为参数。它找到具有给定ID的用户，并从集合中删除该文档。第二个参数是之前提到的回调函数。如果上述操作出现错误，它将返回一个错误，我们可以使用它来更好地处理应用程序中发生的异常或错误。在成功的情况下，我们可以定义自己的逻辑来决定返回什么。在前面的例子中，我们返回了`{
    success: true }`。'
- en: findOneAndRemove
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`findOneAndRemove`'
- en: '`findOneAndRemove()` behaves the same way as `remove()` does and takes the
    same amount of parameters:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOneAndRemove()`的行为与`remove()`相同，并且接受相同数量的参数：'
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We just have to define the criteria for which documents we want to delete.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要定义我们想要删除的文档的筛选条件。
- en: 'Now, we can also modify the preceding code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也可以修改前面的代码：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, I have highlighted the added piece of code. We can also pass on a second
    parameter to the callback function which returns the `user` object being deleted. Now,
    this is helpful if we want to display a certain message to the frontend and also
    add some user attributes such as `name` or `email` of the `user`. For example,
    if we want to display a message saying User with name {x} has been deleted. on
    the frontend, then we can pass `user` or other attributes of `user` here; in this
    case, it's the name, to be displayed on the frontend.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我已经突出显示了新增的代码片段。我们还可以向回调函数传递第二个参数，该参数返回被删除的`user`对象。现在，如果我们想在前端显示某些消息并添加一些用户属性，如`user`的`name`或`email`，这将非常有用。例如，如果我们想在前端显示一条消息，说明名为{x}的用户已被删除，那么我们可以在这里传递`user`或其他`user`属性；在这种情况下，是名称，将在前端显示。
- en: The main difference between `remove()` and `findOneAndRemove()` is that remove
    does not return the documents that were deleted but `findOneAndRemove()` does.
    Now we know when to use these two methods.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`和`findOneAndRemove()`之间的主要区别在于，`remove()`不会返回被删除的文档，而`findOneAndRemove()`会。现在我们知道何时使用这两种方法。'
- en: findByIdAndRemove()
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`findByIdAndRemove()`'
- en: 'This is the same as `findOneAndRemove()`, except that this always needs an
    `id` to be passed as a parameter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`findOneAndRemove()`相同，但总是需要传递一个`id`作为参数：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Did you find any difference in the code between `findOneAndRemove()` and the
    preceding code for `findByIdAndRemove()`? If we look at the first parameter of
    this method, it only takes a simple integer value, which is the document ID. Now,
    if we look into the preceding `findOneAndRemove()` code, we will notice that we
    have passed an object in the first parameter. That''s because, for `findOneAndRemove()`,
    we can pass different arguments other than ID as well. For example, we can also
    pass `{ name: ''Anita'' }` in that parameter for `findOneAndRemove()`. But, for `findByIdAndRemove()`,
    as is obvious from the method name, we don''t need to pass an object but just
    an integer that denotes the document''s ID.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '你在`findOneAndRemove()`和前面的`findByIdAndRemove()`代码之间发现了任何区别吗？如果我们查看这个方法的第一参数，它只接受一个简单的整数值，即文档ID。现在，如果我们查看前面的`findOneAndRemove()`代码，我们会注意到我们在第一个参数中传递了一个对象。这是因为对于`findOneAndRemove()`，我们除了ID之外还可以传递其他参数。例如，我们也可以在`findOneAndRemove()`的参数中传递`{
    name: ''Anita'' }`。但是，对于`findByIdAndRemove()`，正如方法名所暗示的，我们不需要传递对象，只需要传递表示文档ID的整数。'
- en: It finds a document with the mentioned ID in the parameter and removes that
    document from the collections. Like `findOneAndRemove()`, this also returns the
    document that is being deleted.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它在参数中找到指定ID的文档，并将其从集合中删除。就像`findOneAndRemove()`一样，这个操作也会返回被删除的文档。
- en: Adding validation with Mongoose
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mongoose添加验证
- en: Validations in Mongoose are defined at the schema level. Validations can be
    set in both strings and in numbers. Mongoose provides us with built-in validation
    techniques for strings and numbers. Also, we can customize these according to
    our need as well. Since validations are defined in the schemas, they are triggered
    when we hit the `save()` method for any document. If we only want to test these
    validations, we can do that as well by executing the validation method only via
    `{doc}.validate()`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose中的验证是在模式级别定义的。验证可以设置在字符串和数字中。Mongoose为我们提供了字符串和数字的内置验证技术。此外，我们也可以根据我们的需求自定义这些验证。由于验证是在模式中定义的，因此当我们在任何文档上调用`save()`方法时，它们会被触发。如果我们只想测试这些验证，我们也可以通过仅通过`{doc}.validate()`执行验证方法来做到这一点。
- en: '`validate()` is also middleware, which means it has control when we are executing
    some methods in an asynchronous way.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate()`也是中间件，这意味着它在以异步方式执行某些方法时具有控制权。'
- en: Default validations
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认验证
- en: Let's talk about some of the default validations that Mongoose provides us with.
    These are also called built-in validators.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈Mongoose为我们提供的默认验证。这些也被称为内置验证器。
- en: required()
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: required()
- en: 'The `required()` validator checks if the field we added this validation on
    has some value or not. Previously, in the `User` model, we had this code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`required()`验证器检查我们添加验证的字段是否有值。在之前的`User`模型中，我们有以下代码：'
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code also has a validation associated with the fields of the user. It requires
    the name and email of a user to be a string and not numbers, or Boolean, or anything
    else. But this code doesn't make sure the name and email fields are set for the
    user.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也与用户的字段相关联的验证有关。它要求用户的名字和电子邮件必须是字符串，而不是数字、布尔值或其他任何东西。但这段代码并没有确保用户的名字和电子邮件字段已被设置。
- en: 'So, if we want to add a `required()` validation, the code should be modified
    in this way:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想添加一个`required()`验证，代码应该这样修改：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, we have changed the value of the name key to an object instead
    of just a string. Here, we can add as many validations as we want. So, the added
    validation `required: true` checks if there is some value set on the name and
    email of the user before saving that document in the collection. It returns an
    error if the validation is not met.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，我们已经将name键的值从字符串更改为对象。在这里，我们可以添加我们想要的任何验证。因此，添加的验证`required: true`检查在将文档保存到集合之前，用户的名字和电子邮件是否已设置某个值。如果验证未通过，它将返回一个错误。'
- en: 'We can also pass a message when the validation returns an error. For example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在验证返回错误时传递一个消息。例如：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This way, we can also customize the messages as per our requirements. Very cool,
    right?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们也可以根据我们的需求自定义消息。非常酷，对吧？
- en: Type validation
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型验证
- en: The type validation method defines the types of fields in a document. The different
    variations of type can be `String`, `boolean`, and `number`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 类型验证方法定义了文档中字段的类型。类型的不同变体可以是`String`、`boolean`和`number`。
- en: String
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: String
- en: The string itself has several validators under it, such as `enum`, `match`,
    `maxlength`, and `minlength`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串本身下面有几个验证器，例如`enum`、`match`、`maxlength`和`minlength`。
- en: '`maxlength` and `minlength` define the length of a string.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxlength` 和 `minlength` 定义了字符串的长度。'
- en: Numbers
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'Numbers have two validators: `min` and `max`. The `min` and `max` values define
    the range of values for a field in a collection.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 数字有两个验证器：`min` 和 `max`。`min` 和 `max` 的值定义了集合中字段值的范围。
- en: Custom validations
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义验证
- en: 'We can also add custom validations in case the default built-in validations
    are not enough.  We can pass a `validate` function and write our custom code into
    that function. Let''s look at an example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认的内置验证不够用，我们还可以添加自定义验证。我们可以传递一个 `validate` 函数并将我们的自定义代码写入该函数。让我们看一个例子：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we have passed a `validate` method to the `Schema`. It takes a validator
    function where we can add our own code for the validation. The preceding method checks
    if the phone number field of the user is in the correct format or not. If it does
    not pass the validation, then it displays the message `{value} is not a valid
    phone number`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们向 `Schema` 传递了一个 `validate` 方法。它接受一个验证器函数，我们可以在其中添加自己的验证代码。前面的方法检查用户的电话号码字段是否处于正确的格式。如果它未通过验证，则显示消息
    `{value} 不是一个有效的电话号码}`。
- en: 'We can also add nested validations in Mongoose: for example, if the name in
    our user collection is saved as `{ name: { first_name: ''Anita'', last_name: ''Sharma''
    } }`, we will need to add validations for both `first_name` and `last_name`. To
    do that, we can use:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以在 Mongoose 中添加嵌套验证：例如，如果我们的用户集合中的名称保存为 `{ name: { first_name: ''Anita'',
    last_name: ''Sharma'' } }`，我们需要为 `first_name` 和 `last_name` 添加验证。为此，我们可以使用：'
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we define the `Schema` for a low-level object, which is `first_name`
    and `last_name`. Then, for the `userSchema`, we pass on the `nameSchema` for the
    name field.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个低级对象的 `Schema`，它包括 `first_name` 和 `last_name` 字段。然后，对于 `userSchema`，我们将
    `nameSchema` 传递给名称字段。
- en: 'Remember, we cannot add nested validations in a single `Schema` like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们无法在这个 `Schema` 中添加嵌套验证，如下所示：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can look into Mongoose validations here: [http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看 Mongoose 验证的相关信息：[http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html)。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered basic information about MongoDB and its benefits,
    how to make CRUD operations and queries in MongoDB, and the basic validations
    with Mongoose.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 MongoDB 的基本信息和它的好处，如何在 MongoDB 中进行 CRUD 操作和查询，以及使用 Mongoose 的基本验证。
- en: Going further, in the next chapter, we will talk more about the REST APIs and
    the RESTful architecture design in our application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步讨论我们的应用程序中的 REST API 和 RESTful 架构设计。
