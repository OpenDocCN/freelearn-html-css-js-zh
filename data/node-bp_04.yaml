- en: Chapter 4. Developing a Chat with Socket.IO
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：使用Socket.IO开发聊天功能
- en: As we learned in the previous chapter, Node.js collaborates really well with
    frontend frameworks such as AngularJS. It's great that we can transfer data from
    the browser to Node.js and vice-versa. It's even better if we can do in this real
    time. Nowadays, real-time communication is heavily integrated in almost every
    web product. It gives a nice user experience and brings a lot of benefits to the
    application's owners. Usually, when we talk about real-time web components, we
    mean **WebSockets**. WebSocket is a protocol that allows us to establish a two-way
    (bidirectional) conversation between the browser and the server. This opens a
    whole new world and gives us the power to implement fast and robust apps. **Node.js**
    supports WebSockets, and we will see how to build a real-time chat with WebSockets.
    The application will use Socket.IO. It is a library that is built on top of WebSockets
    and provides mechanisms to cover the same functionalities if they are not available.
    We will have an input field, and every user who opens the page will be able to
    send messages to every other user who is available.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，Node.js与前端框架如AngularJS协作得非常好。我们可以从浏览器传输数据到Node.js，反之亦然，这真是太棒了。如果我们可以实时做到这一点，那就更好了。如今，实时通信几乎被集成到每个Web产品中。它为用户提供了良好的体验，并为应用的所有者带来了很多好处。通常，当我们谈论实时Web组件时，我们指的是**WebSockets**。WebSocket是一种协议，允许我们在浏览器和服务器之间建立双向（双向）对话。这开辟了一个全新的世界，并赋予我们实施快速和健壮应用的能力。**Node.js**支持WebSockets，我们将看到如何使用WebSockets构建实时聊天。该应用将使用Socket.IO。这是一个建立在WebSockets之上的库，提供机制来覆盖如果它们不可用时的相同功能。我们将有一个输入字段，并且每个打开页面的用户都将能够向所有其他可用的用户发送消息。
- en: In this chapter, we will learn how to set up Socket.IO and how to use it in
    a browser and start a Node.js server, making real-time chat possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何设置Socket.IO，以及如何在浏览器中使用它并启动一个Node.js服务器，使实时聊天成为可能。
- en: Exploring WebSockets and Socket.IO
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索WebSockets和Socket.IO
- en: Let's say that we want to build a chat feature. The first thing that we should
    do is to develop the part that shows the messages on the screen. In a typical
    scenario, we want these messages to be delivered fast, that is, almost immediately
    after they were sent. However, if we don't use sockets to receive the data from
    the server, we need to make an HTTP request. Also, the server should keep the
    information till we request it to do so. So, imagine what would happen if we had
    10 users and each one of them starts sending data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要构建一个聊天功能。我们首先应该做的是开发显示屏幕上消息的部分。在典型场景中，我们希望这些消息能够快速送达，也就是说，在发送后几乎立即送达。然而，如果我们不使用套接字从服务器接收数据，我们需要发起一个HTTP请求。此外，服务器应该保留信息，直到我们请求它这样做。想象一下，如果我们有10个用户，并且他们中的每一个都开始发送数据，会发生什么。
- en: We need to maintain a user session in order to identify the user's requests.
    These problems are easily solved if we use sockets. Once the socket is opened,
    we have a long live channel, and we can send messages back and forth. This means
    that you can start receiving information without requesting it. The architecture
    is analogous to a big net of bridges. The bridge is always open, and if we need
    to go somewhere, we are free to do so. At the center of the net, we have a hub
    that connects every side with each other. In the context of the web, the hub is
    our server. Every time we need to reach some of the users attached to the net,
    we just need to send a message via the socket. The server receives it and bypasses
    it to the right person. This is one of the most effective ways to implement real-time
    communication. It saves time and resources.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要维护一个用户会话，以便识别用户的请求。如果我们使用套接字，这些问题很容易解决。一旦套接字打开，我们就有一个长连接通道，可以来回发送消息。这意味着你可以在不请求的情况下开始接收信息。这种架构类似于一个巨大的桥梁网络。桥梁始终开放，如果我们需要去某个地方，我们可以自由地去。网络中心有一个中心节点，将每一侧连接起来。在Web的背景下，中心节点是我们的服务器。每次我们需要接触到网络上的某些用户时，我们只需通过套接字发送一条消息。服务器接收它并将其转发给正确的人。这是实现实时通信最有效的方法之一。它节省了时间和资源。
- en: 'As it happens with most of the cool technologies, we don''t need to start from
    scratch and write low-level stuff, such as handshake requests for example. There
    are two types of developers: those who work really hard and abstract the complex
    things into simpler APIs and tools, and those who know how to use them. Developers
    in the second group can make use of libraries such as Socket.IO. This chapter
    deals extensively with the Socket.IO module. It acts as an abstraction over WebSockets
    and simplifies the process to a great extent.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数酷技术一样，我们不需要从头开始编写底层的东西，例如握手请求等。有两种类型的开发者：那些非常努力工作并将复杂事物抽象成更简单的 API 和工具的开发者，以及那些知道如何使用它们的人。第二组的开发者可以利用像
    Socket.IO 这样的库。本章将广泛讨论 Socket.IO 模块。它作为 WebSocket 之上的抽象，并在很大程度上简化了过程。
- en: 'Before we continue, **Socket.IO** is actually more than a layer over **WebSockets**.
    In practice, it does a lot more, as mentioned on the website at [http://socket.io/](http://socket.io/):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，**Socket.IO** 实际上不仅仅是 **WebSockets** 之上的一个层。在实践中，它做了更多的事情，如网站 [http://socket.io/](http://socket.io/)
    上所述：
- en: '*"Socket.IO aims to make realtime apps possible in every browser and mobile
    device, blurring the differences between the different transport mechanisms. It''s
    care-free realtime 100% in JavaScript."*'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Socket.IO旨在使实时应用在每一个浏览器和移动设备上成为可能，模糊了不同传输机制之间的差异。它是无压力的实时100% JavaScript。"*'
- en: There are some common situations that we usually encounter with the protocol,
    for example, heartbeats, timeouts, and disconnection support. All these events
    are not natively supported by the WebSocket API. Thankfully, Socket.IO is here
    to solve these issues. The library also eliminates some cross-browser problems
    and makes sure that your app works everywhere.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会遇到一些常见的协议情况，例如心跳、超时和断开连接支持。所有这些事件都不是 WebSocket API 本地支持的。幸运的是，Socket.IO
    正在这里解决这些问题。该库还消除了某些跨浏览器问题，并确保您的应用在所有地方都能工作。
- en: Understanding the basic application structure
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本应用结构
- en: 'In the previous chapter, we used Express and Jade to write the delivery of
    the assets (HTML, CSS, and JavaScript) of the application. Here, we will stick
    to pure JavaScript code and will avoid the usage of additional dependencies. The
    only thing that we need to add to our `package.json` file is Socket.IO:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了 Express 和 Jade 来编写应用资产的交付（HTML、CSS 和 JavaScript）。在这里，我们将坚持使用纯 JavaScript
    代码，并避免使用额外的依赖项。我们需要添加到我们的 `package.json` 文件中的唯一东西是 Socket.IO：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After we call `npm install` in our project''s folder, Socket.IO is placed in
    a newly created `node_modules` directory. Let''s create two new directories. The
    following screenshot shows what the application file structure should look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目文件夹中调用 `npm install` 之后，Socket.IO 被放置在一个新创建的 `node_modules` 目录中。让我们创建两个新的目录。以下截图显示了应用文件结构应该看起来像什么：
- en: '![Understanding the basic application structure](img/00008.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![理解基本应用结构](img/00008.jpeg)'
- en: The file structure
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构
- en: The application will read the `styles.css` file and deliver its content to the
    browser. The same thing will happen with `/html/page.html`, which is the file
    that contains the HTML markup of the project. The Node.js code goes to `/index.js`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用将读取 `styles.css` 文件并将内容交付给浏览器。同样的事情也会发生在 `/html/page.html` 上，这是包含项目 HTML 标记的文件。Node.js
    代码在 `/index.js`。
- en: Running the server
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行服务器
- en: 'Before we start using Socket.IO, let''s first write a simple Node.js server
    code, which responds with the chat''s page. We can see the server code as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 Socket.IO 之前，让我们首先编写一个简单的 Node.js 服务器代码，该代码响应聊天页面。我们可以看到以下服务器代码：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code should be placed in `/index.js`. The script starts with the
    definition of several global variables. The `http` module is used to create the
    server, and the `fs` module is used to read the CSS and HTML files from the disk.
    The `html` and `css` variables contain the actual code that will be sent to the
    browser. In our case, this data is static. That's why we are reading the files
    only once, that is, when the script is run. We are also doing this synchronously
    by using `fs.readFileSync` and not `fs.readFile`. Just after this, our server
    is initialized and run. The `req.url` variable contains the currently requested
    file. According to its value, we respond to it with proper content. Once the server
    is run, the HTML and CSS code stays the same. If we change something, we need
    to stop and start the script again. That's because we are reading the file's content
    before we start the server. This could be considered as a good practice if there
    are no changes in `/css/styles.css` or `/html/page.html`. Inserting the `fs.readFileSync`
    operations in the server's handler will make our chat a bit slow because we will
    read from the disk during every request.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码应该放在 `/index.js` 中。脚本从定义几个全局变量开始。`http` 模块用于创建服务器，而 `fs` 模块用于从磁盘读取 CSS
    和 HTML 文件。`html` 和 `css` 变量包含将被发送到浏览器的实际代码。在我们的案例中，这些数据是静态的。这就是为什么我们只读取一次文件，即在脚本运行时。我们通过使用
    `fs.readFileSync` 而不是 `fs.readFile` 来同步执行此操作。紧接着，我们的服务器被初始化并运行。`req.url` 变量包含当前请求的文件。根据其值，我们以适当的内容响应它。一旦服务器运行，HTML
    和 CSS 代码保持不变。如果我们更改了内容，我们需要停止并重新启动脚本。这是因为我们在启动服务器之前读取了文件的内容。如果没有更改 `/css/styles.css`
    或 `/html/page.html`，这可以被认为是一种良好的实践。在服务器的处理程序中插入 `fs.readFileSync` 操作会使我们的聊天稍微慢一些，因为我们将从磁盘读取数据，每次请求都会这样做。
- en: Adding Socket.IO
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Socket.IO
- en: 'The implementation of the chat requires the code to be written in both places:
    at the server side and the client side. We will continue with the Node.js part
    by extending the previous code, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实现聊天功能需要在两个地方编写代码：服务器端和客户端。我们将通过扩展之前的代码继续 Node.js 部分，如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `http.createServer` method returns a new web server object. We have to pass
    this object to Socket.IO. Once everything is done, we have access to the wonderful
    and simple API. We may listen for incoming events and send messages to the users
    who are attached to the server. The `io.sockets` property refers to all the sockets
    created in the system, while the `socket` object, passed as an argument to the
    `connection` handler, represents only one individual user.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.createServer` 方法返回一个新的网络服务器对象。我们必须将此对象传递给 Socket.IO。一旦一切准备就绪，我们就可以访问这个奇妙且简单的
    API。我们可以监听传入的事件并向连接到服务器的用户发送消息。`io.sockets` 属性指向系统中创建的所有套接字，而作为 `connection` 处理程序参数传递的
    `socket` 对象，仅代表一个单独的用户。'
- en: For example, in the preceding code, we are listening for the `connection` event,
    that is, for a new user to connect to the server. When this happens, the server
    sends a personal message to that user that reads `Welcome!`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在之前的代码中，我们正在监听 `connection` 事件，即新用户连接到服务器。当发生这种情况时，服务器向该用户发送一条个人消息，内容为 `欢迎！`
- en: The next thing that may happen is we receive a new type of message from the
    user, our script should distribute this information to all the available sockets.
    That's what `io.sockets.emit` does. Keep in mind that the `emit` method may receive
    our own custom event names and data. It is not necessary to strictly follow the
    format used here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来可能发生的事情是我们从用户那里收到一种新的消息类型，我们的脚本应该将此信息分发到所有可用的套接字。这正是 `io.sockets.emit` 所做的。请记住，`emit`
    方法可以接收我们自己的自定义事件名称和数据。并不需要严格遵循这里使用的格式。
- en: Writing the client side of the chat
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写聊天客户端
- en: Having completed writing the code for the server side, we can now continue writing
    for the frontend, that is, write the necessary HTML and JavaScript that will communicate
    with the chat server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 完成编写服务器端代码后，我们现在可以继续编写前端代码，即编写与聊天服务器通信所需的必要 HTML 和 JavaScript。
- en: Preparing the HTML markup
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 HTML 标记
- en: 'With the development done so far, our chat feature would look like the following
    screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的开发工作完成后，我们的聊天功能将如下截图所示：
- en: '![Preparing the HTML markup](img/00009.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![准备 HTML 标记](img/00009.jpeg)'
- en: 'We have a container that acts as a holder for the incoming messages. There
    are two input boxes. The first one is for the name of the user and the second
    one accepts the message that we have to send. Every user has a random color applied
    to his/her texts. There is no button to send the data to the server; we can do
    this by pressing the *Enter* key. Let''s continue to read the HTML markup saved
    in `/html/page.html` shown as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个容器，用作接收消息的持有者。有两个输入框。第一个用于用户的名称，第二个接受我们必须发送的消息。每个用户都会为其文本应用一个随机颜色。没有按钮将数据发送到服务器；我们可以通过按
    *Enter* 键来完成。让我们继续阅读保存在 `/html/page.html` 中的 HTML 标记，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The CSS styles are added at the top of the page and to the scripts at the bottom.
    There are just three elements that represent the controls mentioned in the previous
    code. The bootstrap of the logic is placed in a `window.onload` handler. We are
    doing this just to be sure that all the assets are fully loaded. Note that the
    input field, which will accept the message, is disabled by default. Once the socket
    connection is established, we will enable it. There is one last thing that we
    should clarify—the location/source where the `/socket.io/socket.io.js` file is
    coming from. It is not downloaded and saved in the project directories from an
    external source; it is delivered at that location by Socket.IO. That's one of
    the reasons behind passing the `web server` object to Socket.IO at the backend.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 样式被添加到页面顶部和脚本底部。代表之前代码中提到的控制器的只有三个元素。逻辑的启动被放置在 `window.onload` 处理器中。我们这样做只是为了确保所有资源都已完全加载。请注意，将接受消息的输入字段默认是禁用的。一旦建立了套接字连接，我们将启用它。还有最后一件事需要明确——`/socket.io/socket.io.js`
    文件所在的位置/来源。它不是从外部来源下载并保存在项目目录中；它是通过 Socket.IO 交付到该位置的。这也是在后台将 `web server` 对象传递给
    Socket.IO 的原因之一。
- en: Writing the chat logic
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写聊天逻辑
- en: 'The HTML markup itself is useless. The next step in our development process
    will be writing the JavaScript code that will communicate with the backend. We
    will need to catch the user''s input and send it to the server. The messages displayed
    on the screen will be painted in different colors. We will start by defining two
    helper methods as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 标记本身是无用的。我们开发过程中的下一步将是编写与后端通信的 JavaScript 代码。我们需要捕获用户的输入并将其发送到服务器。屏幕上显示的消息将以不同的颜色呈现。我们将首先定义两个辅助方法，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first one, `addEventListener` function, will add an event listener to a
    `DOM` element. To make our chat work in Internet Explorer, we need to use `attachEvent`
    instead of `addEventListener`. The second, `getRandomColor` function, delivers
    a different color every time. We will use this to distinguish messages from the
    different users.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，`addEventListener` 函数，将为 `DOM` 元素添加事件监听器。为了让我们的聊天在 Internet Explorer 中工作，我们需要使用
    `attachEvent` 而不是 `addEventListener`。第二个，`getRandomColor` 函数，每次都会提供不同的颜色。我们将使用这个来区分不同用户的消息。
- en: 'Our client-side logic starts with the defining of a few variables:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们客户端逻辑的起点是定义几个变量：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will use the `socket` variable to communicate with the server. The next three
    variables are shortcuts to the previously used `DOM` elements. It is recommended
    to create such shortcuts because referencing elements all the time with `document.getElementById`
    or `document.querySelector` may cause of performance issues.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `socket` 变量与服务器通信。接下来的三个变量是之前使用的 `DOM` 元素的快捷方式。建议创建这样的快捷方式，因为始终使用 `document.getElementById`
    或 `document.querySelector` 引用元素可能会导致性能问题。
- en: 'The chat does two things: it sends messages to the Node.js part and receives
    messages from there. Let''s wrap everything into two simple functions, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天做两件事：向 Node.js 部分发送消息并从那里接收消息。让我们将所有内容封装到两个简单的函数中，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are sending the message via the `socket.emit` method and wrapping the
    text in a colored `span` element. Of course, if the user types in something in
    the `name` input field, we use the value and send it along with the rest of the
    data. The `display` function is pretty simple. It just changes the `innerHTML`
    property of the `chat` element. What is interesting is the second line. If we
    use the chat feature a bit, we will notice that `div` will be filled out very
    soon, and what we actually see are only the first messages. By setting the `scrollTop`
    property to `scrollHeight`, we make sure that the holder will be always scrolled
    downwards.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过`socket.emit`方法发送消息，并将文本包裹在带颜色的`span`元素中。当然，如果用户在`name`输入字段中输入了某些内容，我们会使用该值并将其与其他数据一起发送。`display`函数相当简单。它只是更改`chat`元素的`innerHTML`属性。有趣的是第二行。如果我们稍微使用一下聊天功能，我们会注意到`div`会很快被填满，而我们实际上看到的是只有第一条消息。通过将`scrollTop`属性设置为`scrollHeight`，我们确保容器始终向下滚动。
- en: 'The next step in our small application is handling the user''s input. This
    can be done using the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们小型应用程序的下一步是处理用户的输入。这可以通过以下代码完成：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only one key that is interesting for us at the moment is the *Enter* key.
    Its key code is 13\. If the key is pressed, the value of the field is emitted
    to the server. We are flushing the input field to allow the user to type in a
    new message.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前对我们来说唯一有趣的是*Enter*键。它的键码是13。如果按下该键，字段中的值就会被发送到服务器。我们正在清空输入字段，以便用户可以输入新的消息。
- en: 'The last thing that we should do is write the code to receive the messages:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后应该编写接收消息的代码：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are two types of events that we are listening to. They are `welcome` and
    `receive`. The `welcome` event is sent when the connection is established. The
    `receive` event is an incoming event, when some of the users send a message (including
    ourselves). We may ask why we need to send our own message to the server and receive
    it after that. Isn't it easier to place the text directly onto the holder? The
    answer to this is that we need consistency of the data, that is, we should provide
    the same message in absolutely the same order to all the users. This can be guaranteed
    by only one piece of the app and that's the server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在监听两种类型的事件。它们是`welcome`和`receive`。当连接建立时，会发送`welcome`事件。`receive`事件是一个传入事件，当一些用户发送消息（包括我们自己）时发生。我们可能会问为什么我们需要将我们的消息发送到服务器并在之后接收它。直接将文本放置在容器上不是更容易吗？这个问题的答案是，我们需要数据的一致性，也就是说，我们应该向所有用户提供完全相同的消息，并且顺序完全相同。这只能由应用程序中的一块保证，那就是服务器。
- en: With this last code snippet, we have finished building our chat feature. In
    the last part of this chapter, we will improve user-to-user communication.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个最后的代码片段，我们已经完成了聊天功能的构建。在本章的最后部分，我们将改进用户间通信。
- en: Implementing user-to-user communication
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用户间通信
- en: 'Our chat is now functioning, but it would be nice if we could send a message
    to one specific user. Such a feature requires changes in both places: at the frontend
    and backend. Let''s first change the Node.js script.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天现在可以正常工作，但如果我们可以向特定用户发送消息那就更好了。这样的功能需要在前后端都进行更改。让我们首先更改Node.js脚本。
- en: Changing the server-side code
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改服务器端代码
- en: 'So far, the users were anonymous in our system. We just passed the received
    message to all the sockets available. However, to implement a user-to-user conversation,
    we need to set unique ID for every user. Along with that, we have to keep references
    to all the created sockets so that we can emit messages to them. This can be done
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的系统中的用户都是匿名的。我们只是将接收到的消息传递给所有可用的套接字。然而，要实现用户间对话，我们需要为每个用户设置唯一的ID。同时，我们必须保留所有创建的套接字的引用，以便我们可以向它们发送消息。这可以通过以下方式完成：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can make use of the `crypto` module, which is available by default in Node.js
    to generate the random unique IDs, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用Node.js中默认可用的`crypto`模块生成随机唯一的ID，如下所示：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We should also notify the people in the chat about the available users. Otherwise,
    they will not be able to pick an appropriate user to chat with. The notification
    is done as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该通知聊天中的人关于可用用户的信息。否则，他们无法选择合适的用户进行聊天。通知如下：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The user''s name was actually passed along with the message. It was a part
    of the message, and the backend doesn''t use it at all. However, in the new scenario,
    we need it with the ID. The previous code sends the `users` array to the browser,
    but before that, it filters it and passes only the ID and the name. As we will
    see in the following code, we also have a `socket` property for every element.
    The following is the updated `connection` handler:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，用户的名字是与消息一起传递的。它是消息的一部分，后端根本不使用它。然而，在新场景中，我们需要它与ID一起。之前的代码将`users`数组发送到浏览器，但在那之前，它过滤了它并只传递ID和名字。正如我们将在以下代码中看到的，我们为每个元素都有一个`socket`属性。以下是更新的`connection`处理程序：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, a new user connection is received at the server. We generate a new ID and
    create a new element inside the `users` array. We keep the socket, the ID, and
    the name of the user. After that, we emit the good old `welcome` message, but
    this time we send the ID as well. Now, the frontend can identify itself into the
    system, and because the `users` variable is updated, we should notify the rest
    of the world about this via the `sendUsers` function. We start listening for the
    `send` message, and once it comes, we update the user''s name in the array with
    the `setUsername` method, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，服务器接收到了一个新的用户连接。我们生成一个新的ID，并在`users`数组中创建一个新的元素。我们保留socket、ID和用户的姓名。之后，我们发出古老的`welcome`消息，但这次我们发送了ID。现在，前端可以识别自己进入系统，因为`users`变量已更新，我们应该通过`sendUsers`函数通知其他人。我们开始监听`send`消息，一旦它到来，我们就使用`setUsername`方法更新数组中的用户名，如下所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The subsequent lines check whether there is a `toUser` property. If there is
    one, we know that it contains IDs of some of the other users. So, we simply find
    the user ID and pass the message to the exact socket. If there is no `toUser`
    property, then the data is again sent to everyone using `io.sockets.emit('receive',
    data)`. Together with `toUser`, the frontend should also send `fromUser`. That's
    because normally the guy who sends the text doesn't see its message on the screen
    until the server sends it back. We will use `fromUser` to achieve this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行检查是否存在`toUser`属性。如果存在，我们知道它包含了一些其他用户的ID。因此，我们只需找到用户ID并将消息传递给确切的socket。如果没有`toUser`属性，那么数据将通过`io.sockets.emit('receive',
    data)`发送给所有人。与`toUser`一起，前端还应发送`fromUser`。这是因为通常发送文本的人直到服务器将其发送回来之前，看不到自己的消息在屏幕上。我们将使用`fromUser`来实现这一点。
- en: Making changes to the frontend of the chat
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改聊天的前端
- en: 'The first thing we have to do is to show the available users on the screen
    so that we can choose one of them to chat with. Just below the input fields, we
    will add a drop-down menu, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是在屏幕上显示可用的用户，这样我们就可以选择其中一个与他们聊天。就在输入字段下方，我们将添加一个下拉菜单，如下所示：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will need a few new variables defined. A new shortcut to the `select` element,
    the currently selected user from the list, and a variable that will hold the current
    user''s ID. This is done as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义几个新的变量。一个指向`select`元素的新的快捷方式，当前列表中选中的用户，以及一个将保存当前用户ID的变量。这可以通过以下方式完成：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `send` method has changed a bit. We can see it as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`方法有所改变。我们可以这样看到：'
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The difference is that we are sending the user''s name in a separate property,
    that is, the ID of the user and the ID of the user we want to chat with. If there
    is no such user, then the value is just an empty string. The `display` method
    can stay the same. We need one more event listener for the drop-down menu changes.
    We will add it as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于我们正在将用户的名字发送到一个单独的属性中，即用户的ID和我们想要与之聊天的用户的ID。如果没有这样的用户，那么值就是一个空字符串。`display`方法可以保持不变。我们还需要一个事件监听器来监听下拉菜单的变化。我们将如下添加它：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Most of the work is done in the listeners of the socket object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作都是在socket对象的监听器中完成的：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, the `welcome` message is received. It comes with the ID, so we will store
    it in our local variable. We show the welcome message, enable the input, and bring
    the focus there. No changes here. What is new is the last message listener. That's
    the place where we populate the drop-down menu with data. We compose an HTML string
    and set it as a value of the `innerHTML` property at the end. There are two checks.
    The first one prevents the current user from showing in the `select` element.
    The second condition automatically selects a user from the list. This is actually
    quite important because the user's message can be sent many times and the menu
    should maintain its selection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们接收到了`欢迎`信息。它包含了ID，因此我们将它存储在我们的局部变量中。我们显示了欢迎信息，启用了输入，并将焦点移至那里。这里没有变化。新的变化在于最后的消息监听器。这是我们将数据填充到下拉菜单的地方。我们编写一个HTML字符串，并将其设置为`innerHTML`属性的值。这里有两个检查。第一个检查防止当前用户在`select`元素中显示。第二个条件会自动从列表中选择一个用户。这实际上非常重要，因为用户的消息可能会发送多次，而菜单应该保持其选择状态。
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned how to create a real-time chat by using Socket.IO.
    It's a great Node.js module that simplifies work with WebSockets. It is a technology
    that is widely used today and is part of the future's applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Socket.IO创建实时聊天。它是一个优秀的Node.js模块，简化了WebSocket的工作。这是一种今天广泛使用的技术，也是未来应用的一部分。
- en: In the next chapter, we will learn how to use BackboneJS to create a simple
    to-do application. Again, we will manage the data with the help of Node.js.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用BackboneJS创建一个简单的待办事项应用。同样，我们将借助Node.js来管理数据。
