- en: Testing Your Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的代码
- en: Up until this point, we've been pretty much flying by the seat of our pants
    when it comes to the code we've been writing. We literally had no way of knowing
    whether the code worked until we tested it out in an actual browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在编写代码时基本上是凭着感觉在进行。我们实际上无法知道代码是否有效，直到在实际浏览器中测试它。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Running tests with the Mocha test framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mocha测试框架运行测试
- en: Writing tests with the Chai.js assertion library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Chai.js断言库编写测试
- en: Spies and stubs with Sinon and Proxyquire
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sinon和Proxyquire进行间谍和存根
- en: Writing your first test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写您的第一个测试
- en: Testing your application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试您的应用程序
- en: Tests are great for ensuring that your code functions properly, but they're
    also awesome for preventing new, unexpected bugs from suddenly popping up because
    of an innocent little change you made to some unsuspecting code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于确保您的代码正常运行非常重要，但它们也非常适用于防止由于您对某些无辜的代码进行了微小更改而突然出现新的意外错误。
- en: The tools of the trade
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行业工具
- en: Let's start by taking a look at the various tools and libraries we will use
    to run and write our tests. There are three main concepts that we will need to
    cover before we can actually start writing real tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下我们将用于运行和编写测试的各种工具和库。在我们实际开始编写真正的测试之前，我们需要掌握三个主要概念。
- en: The first is a test runner, or the framework we use to run our suite of tests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是测试运行器，或者我们用来运行测试套件的框架。
- en: 'Most of the frameworks follow **Test Driven Development** (**TDD**), and their
    process relies on the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数框架都遵循**测试驱动开发**（**TDD**），其过程依赖以下步骤：
- en: It defines a unit test.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它定义了一个单元测试。
- en: It implements the unit.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它实现了该单元。
- en: It executes the test and verifies that the test passes.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它执行测试并验证测试是否通过。
- en: The second concept is the assertion library itself--the language we use to write
    our tests. A special version of using assertion language to design and build pieces
    of functionality incrementally, guided by an expected behavior, is **Behavior
    Driven Development** (**BDD**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个概念是断言库本身——我们用来编写测试的语言。使用断言语言的特殊版本来逐步设计和构建功能块，以期望的行为为指导，称为**行为驱动开发**（**BDD**）。
- en: For both TDD and BDD, we can use the Mocha testing framework; however, we will
    be writing assertions using a special assertion library called `Chai.js`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于TDD和BDD，我们可以使用Mocha测试框架；但是，我们将使用一个名为`Chai.js`的特殊断言库来编写断言。
- en: Finally, we'll take a look at the idea of spies and stubs, which are fake representatives
    of certain parts of our code that are relied on when we need to track function
    calls to ensure an expected behavior.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看一下间谍和存根的概念，它们是我们代码的某些部分的虚假代表，当我们需要跟踪函数调用以确保预期的行为时，我们会依赖它们。
- en: Running tests with the Mocha framework
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mocha框架运行测试
- en: When writing tests for an application, you typically write them in batches that
    are module specific. These batches are referred to as suites or specs. Each suite
    typically contains a batch of tests organized in a way that almost mirrors the
    application itself. With Node, the idea is no different in that each suite of
    tests we write will be specific to an individual module. You'll require the module
    you want to test against and write a collection of tests for each part of the
    module's functionality.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在为应用程序编写测试时，通常会按模块特定的批次编写它们。这些批次被称为套件或规范。每个套件通常包含一批以几乎与应用程序本身相似的方式组织的测试。对于Node，这个想法也是一样的，我们编写的每个测试套件都将针对一个单独的模块。您将需要测试的模块，并为模块的每个部分编写一系列测试。
- en: 'Since you''ll have many different test files testing each and every component
    of your application, you''ll want a way to quickly execute all of the tests. This
    is where the test runner comes in. The test runner that we''ve decided to use
    is called Mocha. You can install Mocha globally, like any other `npm` package,
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您将有许多不同的测试文件来测试应用程序的每个组件，您需要一种快速执行所有测试的方法。这就是测试运行器的作用。我们决定使用的测试运行器称为Mocha。您可以像安装其他`npm`包一样全局安装Mocha，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You might require security privileges when installing on Linux or OS X, which
    can done simply using `sudo` before `npm`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或OS X上安装时可能需要安全权限，可以简单地在`npm`之前使用`sudo`。
- en: Once installed, the Mocha command-line tool is now available. Simply executing
    `mocha` from a command line will execute the test run with a few default options.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，Mocha命令行工具就可以使用了。只需在命令行中执行`mocha`，就会使用一些默认选项执行测试运行。
- en: 'The test runner will look for a folder named `test` and any `.js` file within.
    In our case, we haven''t actually set up any tests yet, so executing `mocha` alone
    won''t accomplish anything; instead, it will throw the following error:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器将查找名为`test`的文件夹和其中的任何`.js`文件。在我们的情况下，我们实际上还没有设置任何测试，因此仅执行`mocha`将不会有任何效果；相反，它会抛出以下错误：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the Mocha test runner does find `.js` files, it executes them like any
    other Node file, except it looks for a few specific keywords within the file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当Mocha测试运行器找到`.js`文件时，它会像执行任何其他Node文件一样执行它们，只是它会在文件中查找一些特定的关键字。
- en: 'Here is some sample code for a typical test block:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型测试块的一些示例代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing Mocha will scan the file for is a `describe` block. A `describe`
    block is a way to define a specific group of test cases in a single line. You
    can have many `describe` blocks in a `test` file, and each `describe` block can
    have many specific tests. In addition, `describe` blocks can be nested as deeply
    as you like to better organize your tests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha首先要扫描文件的是`describe`块。`describe`块是定义单行中特定测试用例组的一种方式。您可以在`test`文件中有许多`describe`块，并且每个`describe`块可以有许多具体测试。此外，`describe`块可以嵌套得很深，以更好地组织您的测试。
- en: Once a `describe` block is found, a few other items are executed within it.
    A `beforeEach` and `afterEach` block is checked to see whether there is any pretest
    work that needs to be executed before each test is executed. Likewise, any clean
    up that needs to occur between tests can be taken care of within the `afterEach`
    block.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到一个`describe`块，其中还会执行一些其他项目。会检查`beforeEach`和`afterEach`块，看是否有任何需要在每次测试执行之前执行的预测试工作。同样，在测试之间需要进行任何清理工作也可以在`afterEach`块中处理。
- en: Both of these blocks are optional and therefore, not required. A good example
    of when you would want to use a `beforeEach` block is if you need to instantiate
    an object that you will be testing--you would want to create a new instance before
    every single test. This way, whatever changes a test might push to the object
    will be reset and will not inadvertently affect any other tests. Likewise, any
    changes you've made during a test to any other related objects can be reset during
    an `afterEach` block.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个块都是可选的，因此不是必需的。如果您需要实例化一个对象进行测试，您可以使用`beforeEach`块。这样，无论测试可能对对象进行了什么更改，都将被重置，并且不会无意中影响任何其他测试。同样，您在测试期间对任何其他相关对象所做的任何更改都可以在`afterEach`块中重置。
- en: Within the `describe` block, defining individual tests is done with `it` statements.
    Within each `it` statement, it's generally considered good practice to include
    a single `expect` to assert the actual test (although you can include as many
    `expect` function calls as you like, it's still only considered a single test
    because of the single `it`).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`describe`块内，使用`it`语句定义单独的测试。在每个`it`语句中，通常认为包括一个单独的`expect`来断言实际测试（尽管您可以包括尽可能多的`expect`函数调用，但由于只有一个`it`，它仍然被认为是单个测试）。
- en: 'We''re using the BDD style syntax when writing our suites, which allows our
    tests to read like user stories. Using the preceding test snippet, you can read
    the tests as `The code should test something` and `The code should test something_else`.
    In fact, if we ran the previous tests, we would see the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试套件时，我们使用BDD风格的语法，这样我们的测试就可以像用户故事一样阅读。使用前面的测试片段，您可以将测试读作`代码应该测试某事`和`代码应该测试其他事情`。实际上，如果我们运行前面的测试，我们会看到以下输出：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Asserting tests with Chai.js
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Chai.js进行断言测试
- en: As you saw in the preceding unit test example, we used special blocks to define
    our test groups with Mocha, but we used a separate language when defining our
    actual individual tests. These tests are called **assertions**, and we chose to
    use the `Chai.js` library. This is purely a personal preference, as there are
    a number of different assertion libraries that exist. Each library does basically
    the same thing, with slight variations on the syntax and style of actually writing
    the tests. Since `Chai.js` is project specific and based on a personal preference,
    we will install it as a project dependency (instead of installing it globally).
    In addition, as our tests are not actually required for our application to run,
    we'll include `Chai.js` under the `devDependencies` list in our `package.json`
    file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的单元测试示例中看到的，我们使用特殊块来定义我们的测试组，但在定义实际的单独测试时使用了不同的语言。这些测试被称为**断言**，我们选择使用`Chai.js`库。这纯粹是个人偏好，因为存在许多不同的断言库。每个库基本上都是做同样的事情，只是在编写测试的语法和风格上略有不同。由于`Chai.js`是项目特定的并且基于个人偏好，我们将其安装为项目依赖项（而不是全局安装）。此外，由于我们的测试实际上并不是应用程序运行所必需的，我们将在`package.json`文件的`devDependencies`列表中包含`Chai.js`。
- en: Performing `npm install` on the developer 's machine will yield all packages
    under normal dependencies, as well as `devDependencies` from `package.json`. When
    the environment changes to production, we will need to execute `npm install --prod`
    to specify the environment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者的机器上执行`npm install`将会将所有包安装到正常的依赖项下，以及`package.json`中的`devDependencies`。当环境变为生产环境时，我们需要执行`npm
    install --prod`来指定环境。
- en: 'This will help `npm` to install packages under dependencies and not `devDependencies`
    from `package.json`. In order to include `Chai.js` in our project as a `devDependency`,
    we will use the `--save-dev` flag instead of `--save` when performing the `npm`
    install:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助`npm`在`package.json`中将包安装到依赖项而不是`devDependencies`下。为了将`Chai.js`作为`devDependency`包含在我们的项目中，我们将在执行`npm`安装时使用`--save-dev`标志而不是`--save`：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting started with Chai
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Chai
- en: Chai itself has a few different flavors of API styles that can be used when
    writing tests. The BDD API, which is what we will use for the tests we write,
    uses `expect` and `should`. There's also the assert API, which is more of a TDD
    style. The benefit of using the BDD style with `expect`/`should` is that you can
    chain the assertion methods to improve readability of the tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Chai本身有几种不同风格的API可以在编写测试时使用。我们将使用BDD API来编写测试，它使用`expect`和`should`。还有一个更多的TDD风格的assert
    API。使用`expect`/`should`的BDD风格的好处是可以链式调用断言方法来提高测试的可读性。
- en: 'You can learn more about BDD and TDD by accessing the following Wikipedia page:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问以下维基百科页面了解更多关于BDD和TDD的信息：
- en: '[http://en.wikipedia.org/wiki/Behavior-driven_development](http://en.wikipedia.org/wiki/Behavior-driven_development)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Behavior-driven_development](http://en.wikipedia.org/wiki/Behavior-driven_development)'
- en: Using the BDD assertion API with `Chai.js` provides a number of methods at our
    disposal, such as `to`, `be`, `is`, and many more. They have no testing capability,
    but instead they improve the assertion readability. All the getters are listed
    at [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Chai.js`的BDD断言API提供了许多方法，比如`to`、`be`、`is`等等。它们没有测试能力，但可以提高断言的可读性。所有的获取器都列在[http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/)上。
- en: All of these getters will follow an `expect()` statement and can be coupled
    with `not`, in case we want to flip the assertion negatively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些获取器都将遵循一个`expect()`语句，并且可以与`not`结合，以便在需要时将断言取反。
- en: The preceding getters are combined with the `chai` assertion methods, such as
    `ok`, `equal`, `within`, and so on, to determine a test's outcome. All those methods
    are listed at [http://chaijs.com/api/assert/](http://chaijs.com/api/assert/).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的获取器与`chai`断言方法相结合，比如`ok`，`equal`，`within`等，以确定测试的结果。所有这些方法都列在[http://chaijs.com/api/assert/](http://chaijs.com/api/assert/)中。
- en: 'Let''s start constructing simple assertions.The `chai` provides three different
    assertion styles: `expect`, `should`, and `assert`. Consider the following simple
    illustration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建简单的断言。`chai`提供了三种不同的断言风格：`expect`，`should`和`assert`。考虑以下简单的例子：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the `expect`/`should` function is based on self-descriptive
    language chains. Both differ in their way of declaration--the `expect` function
    provides a starting point for a chain, whereas the `should` interface extends
    an `Object.prototype`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`expect`/`should`函数是基于自描述语言链的。两者在声明方式上有所不同——`expect`函数提供了链的起点，而`should`接口则扩展了`Object.prototype`。
- en: The `assert` interface provides simple but powerful TDD style assertions. Apart
    from the preceding example that yields a deep equality assertion, exception testing,
    and instance are also available. For more in-depth learning, refer to the Chai
    documentation at [http://chaijs.com/api](http://chaijs.com/api).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`接口提供了简单但强大的TDD风格断言。除了前面的例子产生的深度相等断言，还有异常测试和实例可用。要进行更深入的学习，请参考Chai文档[http://chaijs.com/api](http://chaijs.com/api)。'
- en: Spies and stubs with Sinon.js
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sinon.js进行间谍和存根
- en: Testing your code will prove to be extremely difficult if there isn't an easy
    way to `spy` on functions and know whenever they are called. Additionally, when
    one of your functions is called, it will be nice to know what arguments were passed
    to it and what was returned. In testing a `spy` is a special placeholder function
    that replaces an existing function when you want to check specifically if/when
    `it` was called. Spies track a number of properties for a function when it's called,
    and they can also pass through the expected functionality of the original function.
    The `Sinon.js` library provides both `spy` and `stub` functionalities and is quite
    extensive. For a complete list of the different options available with this powerful
    framework, I strongly recommend that you spend some time reading the documentation
    at [http://sinonjs.org/docs](http://sinonjs.org/docs).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一种简单的方法来监视函数并知道它们何时被调用，测试代码将变得非常困难。此外，当调用你的函数之一时，知道传递给它的参数和返回的内容也是很好的。在测试中，`spy`是一个特殊的占位符函数，当你想要检查特定的函数是否/何时被调用时，它会替换现有的函数。当调用函数时，间谍会跟踪一些属性，并且它们还可以通过原始函数的预期功能。`Sinon.js`库提供了`spy`和`stub`功能，并且非常全面。要了解这个强大框架提供的不同选项的完整列表，我强烈建议你花一些时间阅读文档[http://sinonjs.org/docs](http://sinonjs.org/docs)。
- en: 'Since we will use `Sinon.js` with our tests, we should install it as another
    `devDependency`, exactly the same way we did with `Chai.js`. In addition, we should
    also install the `sinon-chai` helper, which provides additional `chai` assertion
    verbs, specifically for use with Sinon:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在测试中使用`Sinon.js`，我们应该将其安装为另一个`devDependency`，与我们使用`Chai.js`时完全相同。此外，我们还应该安装`sinon-chai`助手，它提供了额外的`chai`断言动词，专门用于与Sinon一起使用：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The inclusion of `sinon-chai` allows us to write special assertions, such as
    `to.be.calledWith`, which would otherwise not work with `chai` alone.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`sinon-chai`允许我们编写特殊的断言，比如`to.be.calledWith`，这在仅使用`chai`时是无法使用的。
- en: 'Imagine that you have a function that simply adds two numbers together and
    returns the sum:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个简单地将两个数字相加并返回总和的函数：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When writing a test for the `doWork` function, we want to assert that the `sum`
    function was called. We don''t necessarily care what the function does or whether
    it even works; we just want to make sure--since `doWork` relies on `sum`--that
    it''s actually calling the `function()` function. In this scenario, the only way
    we could be sure is if we had a way to spy on the `sum` function and know whether
    it was ever called. Using `spy`, we can do just that:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在为`doWork`函数编写测试时，我们希望断言`sum`函数是否被调用。我们并不一定关心函数做什么，或者它是否起作用；我们只是想确保——因为`doWork`依赖于`sum`——它实际上调用了`function()`函数。在这种情况下，我们唯一能确定的方式是如果我们有一种方法来监视`sum`函数并知道它是否被调用。使用`spy`，我们可以做到这一点：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding scenario, the `sum` function is replaced with a `spy` function.
    So its actual functionalities will no longer exist. If we want to ensure that
    the `sum` function is not only spied on but still functions the way we expect,
    we will need to attach `.andCallThrough()` after `sinon.spy()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的场景中，`sum`函数被替换为`spy`函数。因此它的实际功能将不再存在。如果我们想要确保`sum`函数不仅被监视，而且仍然按照我们的期望工作，我们需要在`sinon.spy()`后面添加`.andCallThrough()`：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that by including `andCallThrough` on our `sum` spy, we're able to not
    only spy on it and assert that it was called, but also spy on the `console.log`
    function and assert that it was called with the correct value returned by `sum`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过在我们的`sum`间谍上包含`andCallThrough`，我们不仅能够监视它并断言它是否被调用，还能够监视`console.log`函数并断言它是否被调用并返回`sum`返回的正确值。
- en: Where a `spy` is typically just a watcher of a function and only reports whether
    the function was called, a `stub` allows you to provide custom functionalities
    for a function on the fly during test execution. Test stubs are said to be preprogrammed
    behavioral functions that are used to test wrapped boilerplate code required as
    a module dependency in an application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`spy`通常只是一个函数的观察者，并且只报告函数是否被调用，而`stub`允许你在测试执行期间为函数提供自定义功能。测试存根被称为预编程行为函数，用于测试应用程序中作为模块依赖项的包装样板代码。'
- en: 'Think of `stub` as a super spy, where it reports the same things that a `spy`
    does, but also performs whatever specific tasks you want as well. Using the same
    example, let''s stub the `sum` function to always return the same value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将`stub`视为超级间谍，它报告与`spy`相同的事情，但也执行您想要的特定任务。使用相同的示例，让我们将`sum`函数存根为始终返回相同的值：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Stubbing a function is great when a function performs work that might yield
    unexpected results, and you just want to force the response for the purposes of
    your test. Stubbing is also handy when you're doing TDD and you're testing against
    a function that you haven't even written yet.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数执行可能产生意外结果，并且您只想为测试目的强制响应时，存根函数是很好的。当您进行TDD并且正在针对尚未编写的函数进行测试时，存根也很方便。
- en: Stubbing node modules with Proxyquire
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Proxyquire存根节点模块
- en: Spies and stubs are great when writing tests against code within the same module,
    but when you need to spy on or stub a module required within another Node module,
    things get a little trickier. Fortunately, there's a tool called **Proxyquire**
    that will allow you to stub modules that are required from your code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一模块内编写测试时，间谍和存根非常有用，但是当您需要监视或存根另一个Node模块中所需的模块时，情况就会变得有点棘手。幸运的是，有一个名为**Proxyquire**的工具，它将允许您存根从您的代码中所需的模块。
- en: 'Examine the following code sample:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下代码示例：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see that we require the `request` module. The `request` module accepts
    two parameters, one of which is a `callback` function. This is where things start
    to get tricky. How are we going to implement spies and/or stubs in this type of
    scenario? Furthermore, how can we prevent our tests from explicitly making a network
    call to fetch `google.com`? What if `google.com` is down (ha!) when we run our
    tests?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们需要`request`模块。`request`模块接受两个参数，其中一个是`callback`函数。事情开始变得棘手的地方就在这里。在这种情况下，我们将如何实现间谍和/或存根？此外，我们如何防止我们的测试明确地发出网络调用以获取`google.com`？如果我们运行测试时`google.com`宕机（哈！）会怎么样？
- en: In order to be able to spy on the `request` module, we will need a way to intercept
    actual `require` and attach our own stubbed version of `request` instead. The
    `request` module is actually a great example of a module that you would want to
    stub, because `request` is used to make a network call, and that's something that
    you want to ensure that your tests never actually do. You don't want your tests
    relying on an external resource, such as a network connection or being dependent
    on the data returned from a live request.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够监视`request`模块，我们需要一种拦截实际`require`并附加我们自己的存根版本的`request`的方法。`request`模块实际上是一个您想要存根的模块的很好的例子，因为`request`用于进行网络调用，这是您希望确保您的测试永远不会真正执行的操作。您不希望您的测试依赖外部资源，例如网络连接或依赖从实际请求返回的数据。
- en: 'Using Proxyquire, we can actually set up our tests in a way that they''ll intercept
    the `require` module and replace what gets executed with our own stub. Here''s
    an example of a test file written against the module we created earlier:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Proxyquire，我们实际上可以设置我们的测试，以便它们拦截`require`模块，并用我们自己的存根替换执行的内容。以下是针对我们之前创建的模块编写的测试文件的示例：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first thing the test suite does is set up a `spy` and a generic `stub` function
    that will be used as the `request` module. Then, we include our `google` module,
    but we do it using `proxyquire` instead of a typical `require` module. Using `proxyquire`,
    we pass the path to the module the same way we would with `require`, except the
    second parameter is the module that would be required within that module and the
    `stub` function to use in its place.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件的第一件事是设置一个`spy`和一个通用的`stub`函数，该函数将用作`request`模块。然后，我们包括我们的`google`模块，但我们使用`proxyquire`而不是典型的`require`模块。使用`proxyquire`，我们传递模块的路径，方式与`require`相同，只是第二个参数是在该模块中所需的模块，以及要在其位置使用的`stub`函数。
- en: Before each test, we will execute the original `google` module and assert against
    our `stub` that it was, in fact, called. Additionally, we assert that the `log`
    spy was called with whatever data was returned from the `request` module. Since
    we are in control of that module, we can test, quite literally, that the string
    `google.com` was returned when a request was made to `http://google.com` (which
    we know for a fact is not true--not only that, but we know that a network call
    was never sent to `www.google.com`, either).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '在每个测试之前，我们将执行原始的`google`模块，并断言我们的`stub`实际上被调用。此外，我们断言`log`间谍被调用，并且使用从`request`模块返回的任何数据。由于我们控制该模块，因此我们可以测试确实，当请求发送到`http://google.com`时，返回了字符串`google.com`（我们确切知道这不是真的--不仅如此，我们还知道从未发送网络调用到`www.google.com`）。 '
- en: 'We''re using a special power of a `stub` that allows us to execute a particular
    parameter to the stubbed function, assuming that it was a `callback` function.
    Here, we''re using `callsArgWith` and including the argument `index` (zero based)
    as the first parameter; in this case, one of the two parameters that were passed
    to the request, the first (index 0), was the URL itself, and the second (index
    1) was the `callback` function. Using `callsArgWith`, we can execute the `callback`
    function and specifically provide its parameters, in this case, `null`, `null`,
    and a string. Like `Sinon.js` and `Chai.js`, `proxyquire` will also need to be
    included in our project as `devDependency`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`stub`的特殊功能，该功能允许我们执行特定参数到存根函数，假设它是`callback`函数。在这里，我们使用`callsArgWith`，并将参数`index`（从零开始）包括为第一个参数；在这种情况下，传递给请求的两个参数中的一个，第一个（索引0）是URL本身，第二个（索引1）是`callback`函数。使用`callsArgWith`，我们可以执行`callback`函数并具体提供其参数，例如`null`，`null`和一个字符串。像`Sinon.js`和`Chai.js`一样，`proxyquire`也需要作为`devDependency`包含在我们的项目中。
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Writing and running your first test
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写并运行您的第一个测试
- en: Up to this point, all of the test code we've seen were just demos and examples,
    and we haven't actually run any tests. Let's set up the basic structure of our
    application so that we can start writing real tests.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有测试代码都只是演示和示例，我们实际上还没有运行任何测试。让我们设置应用程序的基本结构，以便我们可以开始编写真正的测试。
- en: 'The first thing to do is to set up the folder structure that will house all
    of our tests. Consider the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是设置一个文件夹结构，用来存放所有的测试。考虑以下步骤：
- en: Within the root of the application project folder, create a folder named `tests`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序项目文件夹的根目录中，创建一个名为`tests`的文件夹。
- en: 'Within the `tests` folder, create three more folders for `controllers`, `models`,
    and `server`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests`文件夹中，创建三个更多的文件夹，分别为`controllers`、`models`和`server`。
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Writing a test helper
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个测试助手
- en: Before we start writing the tests for our application, there's a small amount
    of overhead that we will need to take care of to prepare for our tests. To take
    care of this overhead, we will write a `testhelper` file that will be included
    and run with every test file we execute via Mocha.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为应用程序编写测试之前，有一些额外的开销需要我们准备好以准备进行测试。为了处理这些开销，我们将编写一个`testhelper`文件，它将被包含并与我们通过Mocha执行的每个测试文件一起运行。
- en: 'Create a file named `testhelper.js` within the `tests` folder, and insert the
    following block of code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tests`文件夹中创建一个名为`testhelper.js`的文件，并插入以下代码块：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is code that we would typically need to include at the top of every one
    of our test files; however, by including it in a single file, we can instruct
    Mocha to automatically require this file for every test file that is run. The
    file itself just includes the `chai` and `sinon` modules and defines a few global
    variables as shortcuts for our test writing. Additionally, it instructs `chai`
    to use the `sinonChai` module so that our syntax is extended and we can write
    Sinon-specific Chai assertions. The command to actually run our suite of tests
    is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们通常需要在每一个测试文件的顶部包含的代码；但是，通过将其包含在一个单独的文件中，我们可以指示Mocha自动要求每个运行的测试文件包含这个文件。文件本身只包括`chai`和`sinon`模块，并定义了一些全局变量作为我们测试编写的快捷方式。此外，它指示`chai`使用`sinonChai`模块，以便我们的语法得到扩展，我们可以编写Sinon特定的Chai断言。实际运行我们的测试套件的命令如下：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember that we installed Mocha globally earlier so that we can execute the
    `mocha` command from anywhere.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们之前全局安装了Mocha，这样我们就可以从任何地方执行`mocha`命令。
- en: Based on the path to our tests in the preceding command, it's assumed that the
    command will be executed from the root of the application project folder. The
    `-r` flag instructs Mocha to require the `testhelper.js` module. The `-R` flag
    is an option to define the style of the test reporting output. We chose to use
    the `spec` style, which lists our report in a nested indentation style with each
    `describe` and `it` statement, along with a green checkmark for the passed tests.
    Finally, the last argument is the path to our `test` files; in this case, we provided
    wildcards so that all of our tests will run.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面命令中测试的路径，假设该命令将从应用项目文件夹的根目录执行。`-r`标志指示Mocha要求`testhelper.js`模块。`-R`标志是定义测试报告输出样式的选项。我们选择使用`spec`样式，它以嵌套缩进样式列出我们的报告，每个`describe`和`it`语句，以及通过测试的绿色复选标记。最后一个参数是我们`test`文件的路径；在这种情况下，我们提供了通配符，以便所有的测试都会运行。
- en: Mocha has a few different reporting styles that you can choose from. These include
    dot (repeating dots for each test), list, progress (a percentage bar), JSON, and
    spec. One of the more interesting, albeit somewhat useless, is the `-R nyan` reporting
    style.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha有几种不同的报告样式可供选择。这包括点（每个测试重复一个点）、列表、进度（百分比条）、JSON和spec。其中比较有趣的，尽管有点无用，是`-R
    nyan`报告样式。
- en: 'Let''s write a quick sample test to make sure that our project is properly
    set up. Within the `tests` folder, create a new file named `mocha.test.js` and
    include the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个快速的样本测试，以确保我们的项目设置正确。在`tests`文件夹中，创建一个名为`mocha.test.js`的新文件，并包含以下代码：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding test is pretty straightforward and simply asserts that `1` is
    equal to `1`. Save this file and run the `Mocha` test command again, and you should
    get the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试非常简单，只是断言`1`等于`1`。保存这个文件，再次运行`Mocha`测试命令，你应该会得到以下输出：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You might find it tiresome and frustrating to remember and execute that long,
    convoluted command for `Mocha`. Fortunately, there''s a pretty easy solution.
    Edit the `package.json` file in the application, and add the following section:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得记住和执行`Mocha`的那个冗长而复杂的命令很烦人和令人沮丧。幸运的是，有一个相当简单的解决方案。编辑应用程序中的`package.json`文件，并添加以下部分：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By making this tweak in the `package.json` file, you can now simply execute
    `npm test` from a command line as a quick and easy shortcut. This is a standard
    convention with the `package.json` file, so any developer will know how to simply
    execute `npm test`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`package.json`文件中进行这个调整，现在你可以简单地在命令行中执行`npm test`作为一个快速简便的快捷方式。这是`package.json`文件的一个标准约定，所以任何开发人员都会知道如何简单地执行`npm
    test`：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that our project is set up to properly run and execute tests, let's start
    writing some real tests for the application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目已经设置好了，可以正确运行和执行测试，让我们开始为应用程序编写一些真正的测试。
- en: Testing the application
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: With all of that background information out of the way, let's focus on writing
    some real tests for the application we've built. In the following sections, we
    will write tests for the routes, servers, models, and controllers in our application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了所有这些背景信息之后，让我们专注于为我们构建的应用程序编写一些真正的测试。在接下来的几节中，我们将为应用程序的路由、服务器、模型和控制器编写测试。
- en: Testing the routes
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试路由
- en: Let's start things a little slowly by taking a look at one of the most basic
    files in our application, the `routes.js` file. This file simply defines the number
    of routes that the application should respond to. This will be one of the easiest
    files to write tests for.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们慢慢开始，先看看我们应用程序中最基本的文件之一，`routes.js`文件。这个文件只是定义了应用程序应该响应的路由数量。这将是最容易编写测试的文件之一。
- en: Since the `routes.js` file is in the `server` folder within our main application,
    let's put its corresponding test file in a similar location. Within the `tests/server`
    folder, create a file named `routes.test.js`. Since the `routes.test.js` file
    will be testing the functionalities of our `routes.js` file, we will need it to
    `require` the same modules.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`routes.js`文件位于我们主应用程序中的`server`文件夹中，让我们将其相应的测试文件放在类似的位置。在`tests/server`文件夹中，创建一个名为`routes.test.js`的文件。由于`routes.test.js`文件将测试我们的`routes.js`文件的功能，我们需要它`require`相同的模块。
- en: 'Include the following code in `test/server/routes.test.js`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test/server/routes.test.js`中包含以下代码：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that the paths are different since we require modules from within our
    `test/server` folder, but we also require app-specific modules. Also, note that
    in addition to the modules that our original `routes.js` file requires, we also
    require the `routes` module itself. How else will we be able to test the functionalities
    of the module if it isn''t included? Next, let''s set up the structure of the
    test suite and create a few spies. Include this new block of code following the
    previous code within `tests/server/routes.test.js`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，路径不同，因为我们从`test/server`文件夹中`require`模块，但我们还需要`require`特定于应用程序的模块。另外，请注意，除了我们原始的`routes.js`文件需要的模块之外，我们还需要`require`
    `routes`模块本身。否则，如果没有包含它，我们将无法测试模块的功能。接下来，让我们设置测试套件的结构并创建一些`spy`。在`tests/server/routes.test.js`中的先前代码之后包括这个新的代码块：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you recall, the `routes` module's `initialize` function accepted a single
    parameter, an `app` object. In our tests, we defined `app` as a simple, anonymous
    object with three functions-- `get`, `post`, and `delete`; each of these is a
    `spy`. We include a `beforeEach` block to execute the `initialize` function before
    every one of our test runs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，`routes`模块的`initialize`函数接受一个参数，即`app`对象。在我们的测试中，我们将`app`定义为一个简单的匿名对象，有三个函数--
    `get`、`post`和`delete`；每个都是一个`spy`。我们包括一个`beforeEach`块，在每次测试运行之前执行`initialize`函数。
- en: 'Now, let''s include some tests. First, we''ll test that the `GET` endpoints
    are configured correctly. Immediately after the `// to do: write tests...` comment,
    place the following block of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们包括一些测试。首先，我们将测试`GET`端点是否正确配置。在`// to do: write tests...`注释之后，放置以下代码块：'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, test the `POST` endpoints:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试`POST`端点：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, test the `DELETE` endpoint:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测试`DELETE`端点：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each of these tests asserts the same thing, that is, that `app` object's corresponding
    `get`, `post`, or `delete` function was executed with the correct parameters for
    each route. We were able to test against the parameters because the `app` object
    we used was a `spy`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试都断言了同一件事，即`app`对象的相应`get`、`post`或`delete`函数是否针对每个路由使用了正确的参数。我们能够针对参数进行测试，因为我们使用的`app`对象是一个`spy`。
- en: 'If you run the `mocha` command to execute the suite of tests, you should see
    the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行`mocha`命令来执行测试套件，您应该会看到以下输出：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Testing the server
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试服务器
- en: Testing the `server.js` file will be slightly different than any of our other
    files. The file runs as the root of our application, so it doesn't export a module
    or any object that we can directly test. Since we launch our server using `server.js`,
    we will need to emulate launching our server from our code. We'll create a function
    called `server`, which will require the `server.js` file using `proxyquire`, and
    `stub` each of the modules that it requires. Executing the `server()` function
    will be exactly the same as executing node `server.js` from a command line. All
    of the code within the file will execute via that function, and then we can test
    against each of the calls that are made using `stub`s from within `proxyquire`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`server.js`文件将与我们的其他文件略有不同。该文件作为我们应用程序的根运行，因此它不导出任何我们可以直接测试的模块或对象。由于我们使用`server.js`启动服务器，我们需要模拟从我们的代码启动服务器。我们将创建一个名为`server`的函数，它将使用`proxyquire`需要`server.js`文件，并对它需要的每个模块进行存根。执行`server()`函数将与从命令行执行`node
    server.js`完全相同。文件中的所有代码都将通过该函数执行，然后我们可以使用`proxyquire`中的`stub`对每个调用进行测试。
- en: 'Create a file named `server.test.js` within the `tests/server/` folder and
    insert the following block of code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tests/server/`文件夹中创建名为`server.test.js`的文件，并插入以下代码块：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before each test is run for our server, we reset the stubs for all of the major
    components of the server. These stubs include the `app` object, `express`, `config`,
    and `mongoose`. We're stubbing each of these modules since we want to `spy` on
    them (and we use a `stub` because some of them need to return objects that we'll
    work with in our file). Now that we have all of our spies in place and our `app`
    object scaffold set up, we can start testing the main functionalities of our code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的服务器运行每个测试之前，我们重置服务器的所有主要组件的存根。这些存根包括`app`对象、`express`、`config`和`mongoose`。我们对这些模块进行存根，因为我们想要对它们进行`spy`（并且我们使用存根是因为其中一些需要返回我们将在文件中使用的对象）。现在我们已经准备好了所有的`spy`和我们的`app`对象框架，我们可以开始测试我们代码的主要功能。
- en: 'We will need to check whether the following conditions pass:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查以下条件是否通过：
- en: An application is created
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个应用程序
- en: The views directory is set
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图目录已设置
- en: The port is set and can be configured and/or set to default
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口已设置并且可以配置和/或设置为默认值
- en: The app itself is configured (`config` is called with it)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序本身已配置（`config`已调用）
- en: Mongoose connects to a database URI string
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mongoose连接到数据库URI字符串
- en: The app itself is launched
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序本身已启动
- en: 'Replace the `// to do: write tests...` comment in the earlier code with the
    following block of code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '用以下代码块替换之前代码中的`// to do: write tests...`注释：'
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding group of tests, we test the bootstrapping of our server, which
    are all of the functionalities that initially run within `server.js`. The names
    of the tests are pretty self-explanatory. We're checking against the various methods
    of the `app` object, ensuring that they're called and/or that the correct parameters
    were passed in. For the tests, we want to test that a specific type of parameter
    was called, not what the parameter value was literally; we use Sinon's match element,
    which allows our tests to be a little more generic. We wouldn't want to hardcode
    the MongoDB URI string in our tests, because that's just another place we would
    have to maintain--although you could very well do this if you wanted your test
    to be that strict (that is, to assert that the exact URI string was passed quite
    literally).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的一组测试中，我们测试了服务器的引导，这些都是最初在`server.js`中运行的所有功能。测试的名称相当不言自明。我们检查`app`对象的各种方法，确保它们被调用和/或传递了正确的参数。对于测试，我们希望测试特定类型的参数是否被调用，而不是参数值的确切内容；我们使用Sinon的匹配元素，这使得我们的测试可以更加通用。我们不希望在测试中硬编码MongoDB
    URI字符串，因为这只是我们需要维护的另一个地方--尽管如果您希望测试非常严格（即确切地断言传递了确切的URI字符串），您完全可以这样做。
- en: 'In the second set of tests, we want to ensure that the port is set, that it
    defaults to `3300`, and that it can be changed via the use of a node environment
    variable:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二组测试中，我们希望确保端口已设置，默认为`3300`，并且可以通过使用节点环境变量进行更改：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With these tests in place, run the `npm test` command again, and you should
    get the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些测试，再次运行`npm test`命令，您应该会得到以下输出：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing a model
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模型
- en: When testing our models, we want to include the `model` module itself and then
    write tests against it. The easiest solution here is that we create a test `model`
    object and then assert that the model has all of the fields that we expect, as
    well as any virtuals we might have created.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们的模型时，我们希望包括`model`模块本身，然后针对它编写测试。这里最简单的解决方案是创建一个测试`model`对象，然后断言该模型具有我们期望的所有字段，以及我们可能创建的任何虚拟属性。
- en: 'Create the `tests/models/image.test.js` file and insert the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`tests/models/image.test.js`文件，并插入以下代码：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, we include `ImageModel` using `require` (note the path for the `require`
    statement). The very first test we run is to make sure that `ImageModel` has a
    mongoose schema property. After this test, we define the `beforeEach` block that
    we'll rely on for the remainder of our tests. Before every test, we will want
    to instantiate a new `ImageModel` object that we can test against. We can do this
    in a `beforeEach` block so that we're sure that we're dealing with a fresh object
    in every test and that it hasn't been tainted by any tests that were previously
    run. It's also important to note that the order of the first test and the `beforeEach`
    block doesn't actually matter, as the `beforeEach` block will run before every
    test in its parent `describe` function, regardless of the order it was defined
    in.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`require`包含`ImageModel`（注意`require`语句的路径）。我们运行的第一个测试是确保`ImageModel`具有一个mongoose模式属性。在这个测试之后，我们定义了`beforeEach`块，我们将依赖于这个块进行我们余下的测试。在每个测试之前，我们都希望实例化一个新的`ImageModel`对象，以便我们可以进行测试。我们可以在`beforeEach`块中执行此操作，以确保我们在每个测试中都处理一个新的对象，并且它没有被先前运行的任何测试所污染。还要注意的是，第一个测试和`beforeEach`块的顺序实际上并不重要，因为`beforeEach`块将在其父`describe`函数中的每个测试之前运行，无论它是以何种顺序定义的。
- en: 'Include the following suite of tests replacing the placeholder `// to do: write
    tests...` comment:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '包括以下一组测试，替换占位符`// to do: write tests...`的注释：'
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we will check to ensure that each property that we expect an `ImageModel`
    instance to have is defined. For the properties that have default values set,
    we also check to ensure that the default values are set as well.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将检查确保我们期望的`ImageModel`实例具有的每个属性都已定义。对于已设置默认值的属性，我们还检查确保默认值也已设置。
- en: 'Next, we will test against the `virtuals` that we expect `ImageModel` to have,
    and verify that they function the way they''re supposed to:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对我们期望`ImageModel`具有的`virtuals`进行测试，并验证它们是否按预期工作：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When testing the `uniqueId` virtual, it should return the `image` model's filename
    without the extension. As the `beforeEach` defines our `image` model with a filename
    of `testfile.jpg`, we can assert with our test that the `uniqueId` returned is
    equal to `testfile` (the filename without the extension).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试`uniqueId`虚拟属性时，它应该返回`image`模型的文件名，但不包括扩展名。由于`beforeEach`定义了我们的`image`模型，文件名为`testfile.jpg`，我们可以通过测试断言`uniqueId`返回的值等于`testfile`（不包括扩展名的文件名）。
- en: 'Running the tests for our model should provide the following results:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的模型测试应该提供以下结果：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Testing a controller
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试控制器
- en: 'Last but not least, let''s take a look at the `image` controller, and specifically
    test for the main `index` function. Since the `index` function does a lot of work
    and performs a number of different tasks, the test file will make extensive use
    of stubs and spies. The first thing we need to do before any tests is declare
    a number of global variables for our tests, as well as set up all of our `stub`s,
    spies, and placeholder objects for use with `proxyquire`. Then, we require the
    actual image controller using `proxyquire`. Create a file named `tests/controllers/image.test.js`
    and insert the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看`image`控制器，特别是对主要的`index`函数进行测试。由于`index`函数需要做很多工作并执行许多不同的任务，测试文件将大量使用存根和间谍。在任何测试之前，我们需要声明一些全局变量供我们的测试使用，并设置所有我们的`stub`、间谍和占位符对象以供`proxyquire`使用。然后，我们使用`proxyquire`来引入实际的图像控制器。创建一个名为`tests/controllers/image.test.js`的文件，并插入以下代码：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this code, we define a number of global variables, such as spies, stubs,
    or empty placeholder JavaScript objects. Once our `stub`s are prepared, we will
    call `proxyquire` to include our `image` controller (ensuring that the required
    modules within the `image` controller are actually replaced with our various `stub`s
    and spies). Now that all of our globals, `stub`s, and spies are prepared, let's
    include some tests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们定义了许多全局变量，如间谍、存根或空占位符JavaScript对象。一旦我们的`stub`准备好了，我们将调用`proxyquire`来包含我们的`image`控制器（确保`image`控制器中的所需模块实际上被我们各种`stub`和间谍替换）。现在，所有我们的全局变量、`stub`和间谍都准备好了，让我们包含一些测试。
- en: 'Include the following code after the preceding block of code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码块之后包含以下代码：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once again, we will build up some setup using a `beforeEach` block for our
    tests. This sets spies on each of the `res` object''s functions, including render,
    JSON, and redirect (each of these are used throughout the `image` controller).
    We fake the query string parameter by setting the `req.params` object with an
    `image_id` property. Finally, we will create a test `image` object that will be
    used by our fake mongoose `image` model stub to emulate a database object being
    returned from MongoDB:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用`beforeEach`块为我们的测试构建一些设置。这会在`res`对象的每个函数上设置间谍，包括render、JSON和redirect（这些函数在`image`控制器中都被使用）。我们通过设置`req.params`对象的`image_id`属性来伪造查询字符串参数。最后，我们将创建一个测试`image`对象，该对象将被我们的假mongoose`image`模型存根使用，以模拟从MongoDB返回的数据库对象：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first test we run is to ensure that the `index` function actually exists.
    Within the `index` function, the very first action that occurs is that the `image`
    model is found via the `Models.Image.findOne` function. In order to test that
    function, we will need to first set it as `spy`. The reason we do this here and
    not in `beforeEach` is because we might want the `findOne` method to behave slightly
    differently in each test, so we don't want to set a strict rule to be applied
    for all the tests.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的第一个测试是确保`index`函数实际存在。在`index`函数中，发生的第一个动作是通过`Models.Image.findOne`函数找到`image`模型。为了测试该函数，我们首先需要将其设置为`spy`。我们之所以在这里而不是在`beforeEach`中这样做，是因为我们可能希望在每个测试中`findOne`方法的行为略有不同，所以我们不希望为所有测试设置严格的规则。
- en: In order to emulate that a `GET` call was posted to our server and our image
    `index` controller function was hit, we can just fire the function manually. We
    do this using `image.index(req, res)` and pass in our fake request and response
    objects (defined earlier as globals and stubbed in the `beforeEach` function).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟`GET`调用被发布到我们的服务器，并且我们的图像`index`控制器函数被调用，我们可以手动触发该函数。我们使用`image.index(req,
    res)`并传入我们的假请求和响应对象（在`beforeEach`函数中定义为全局变量并存根）。
- en: Since `ModelsStub.Image.findOne` is a spy, we can test that it was called, and
    then separately test that it was called specifically with the parameters we expect
    it to be called with. In the case of `findOne`, where the second parameter is
    a callback function, we don't care or want to test the very specific function
    that was included, but only ensure that an actual function was included. To do
    this, we can use Sinon's matcher API and specify that a func, or function, was
    included as the second parameter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ModelsStub.Image.findOne`是一个间谍，我们可以测试它是否被调用，然后分别测试它是否被调用时使用了我们期望的参数。在`findOne`的情况下，第二个参数是一个回调函数，我们不关心或不想测试包含的非常具体的函数，而只是确保包含了一个实际的函数。为此，我们可以使用Sinon的匹配器API，并指定一个func或函数作为第二个参数。
- en: 'This last set of `tests` tests the code that executes when an image is found
    and returned from the `findOne` function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这组`tests`测试了当找到图像并从`findOne`函数返回时执行的代码。
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first thing that you will note here is that `findOne` is no longer a spy
    in these tests, but a stub that will manually fire the callback function that's
    provided as its second parameter. The callback function that's fired will include
    our test `image` model. With this stub, we are emulating that the database call
    was in fact made via `findOne` and that a valid `image` model was returned. Then,
    we can test the remainder of the code that executes within that main callback.
    We perform a similar setup with the `Comment.find` call.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你会注意到的第一件事是，在这些测试中`findOne`不再是一个间谍，而是一个存根，它将手动触发作为第二个参数提供的回调函数。被触发的回调函数将包含我们的测试`image`模型。通过这个存根，我们模拟了通过`findOne`实际进行了数据库调用，并且返回了一个有效的`image`模型。然后，我们可以测试在主回调中执行的其余代码。我们使用`Comment.find`调用进行类似的设置。
- en: When the `sidebarStub` gets executed, we use the `callsArgWith` Sinon function,
    which fires the callback function that was originally included as a parameter.
    Within that callback function, we include fake `viewModel` as a parameter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`sidebarStub`时，我们使用`callsArgWith` Sinon函数，该函数触发最初包含的回调函数。在该回调函数中，我们将假的`viewModel`作为参数包含进去。
- en: Once `sidebarStub` does its job, we expect `res.render` to have been called,
    and we specify the exact parameters we expect it to have been called with.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`sidebarStub`完成其工作，我们期望`res.render`已被调用，并且我们指定了我们期望它被调用的确切参数。
- en: 'Running the tests for the `image` controller should yield the following output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`image`控制器的测试应该产生以下输出：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Spy and stub everything!
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间谍和存根一切！
- en: When in doubt, the safest thing you can do when writing your tests is spy on
    everything and stub everything else. There are always going to be times when you'll
    want a function to execute naturally; in that case, leave it alone. Ultimately,
    you never want your tests to be dependent on any other system that includes database
    servers, other network servers, other APIs, and so on. You only want to test that
    your own code works, nothing more. If your code is expected to make a call to
    an API, spy on the actual call and just assert that your code attempted to make
    the call. Likewise, fake the response from the server via a stub and ensure that
    your code handles the response properly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有疑问，编写测试时最安全的做法是对所有内容进行间谍，对其他所有内容进行存根。总会有时候你希望一个函数自然执行；在这种情况下，不要动它。最终，您永远不希望您的测试依赖于任何其他系统，包括数据库服务器、其他网络服务器、其他API等。您只想测试您自己的代码是否有效，仅此而已。如果您的代码预期调用API，请对实际调用进行间谍，并断言您的代码尝试进行调用。同样，通过存根伪造服务器的响应，并确保您的代码正确处理响应。
- en: The easiest way to check for dependencies in your code is to stop any other
    services from running (your local node app, and so on), as well as possibly even
    disabling your network connection. If your tests time out or fail somewhere unexpectedly,
    it's likely because you missed a function you needed to spy on or stub along the
    way.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 检查代码中的依赖项最简单的方法是停止任何其他服务的运行（本地节点应用程序等），甚至可能禁用网络连接。如果您的测试超时或在意外的地方失败，很可能是因为您错过了需要在途中进行间谍或存根的函数。
- en: Don't get stuck going down a rabbit hole when writing your tests. It's easy
    to get carried away and start testing functionalities that can safely be assumed
    to be working. An example of this is writing tests to ensure that a third-party
    module is performing correctly. If it's not a module you wrote, don't test it.
    Don't worry about writing tests to prove the module does what it says it should.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时不要陷入兔子洞。很容易被带入并开始测试可以安全假定正在工作的功能。一个例子是编写测试以确保第三方模块的正确执行。如果不是您编写的模块，请不要测试它。不要担心编写测试来证明模块是否按照其应有的方式工作。
- en: 'To learn more about TDD when writing JavaScript specifically, I would highly
    recommend that you read Christian Johansen''s beast of a book: *Test-Driven JavaScript
    Development*. This book is huge and speaks of the sheer volume of information
    related to TDD. In some circles, TDD truly is a way of life, and it will define
    the style with which you write your code.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关编写JavaScript特定的TDD的更多信息，我强烈建议您阅读Christian Johansen的巨著：*Test-Driven JavaScript
    Development*。这本书内容丰富，涵盖了与TDD相关的大量信息。在某些圈子里，TDD确实是一种生活方式，它将定义您编写代码的风格。
- en: Automating everything
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化一切
- en: Test automation was never so easy without Gulp. Gulp is an open source JavaScript
    library that provides efficient build creation processes and serves as a task
    runner. We will use Gulp to automate our unit tests by a single command in terminal.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Gulp，测试自动化从未如此简单。Gulp是一个开源的JavaScript库，提供高效的构建创建过程，并充当任务运行器。我们将使用Gulp通过终端中的单个命令来自动化我们的单元测试。
- en: 'Let''s start by installing all the required packages using the following commands:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用以下命令安装所有必需的软件包：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that you may require root access to install the global package of `gulp-cli`.
    Use `sudo` in such cases, for example, `sudo npm install gulp-cli -g`. We used
    `--save-dev` to install Gulp locally and save it as a development dependency in
    our `package.json`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可能需要root访问权限来安装`gulp-cli`的全局软件包。在这种情况下使用`sudo`，例如`sudo npm install gulp-cli
    -g`。我们使用`--save-dev`在本地安装Gulp并将其保存为`package.json`中的开发依赖项。
- en: 'Further, we created a Gulp file in the `test` directory. Now, to `test` the
    directory of our app and make sure that we have the following file structure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在`test`目录中创建了一个Gulp文件。现在，要`test`我们应用程序的目录并确保我们有以下文件结构：
- en: '![](img/bfbb4d48-2f9a-4c71-88bc-07ea63285012.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfbb4d48-2f9a-4c71-88bc-07ea63285012.png)'
- en: 'Once we''ve installed the required packages and created a Gulp file, let''s
    start writing some code, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所需的软件包并创建了Gulp文件后，让我们开始编写一些代码，如下所示：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Go back to the terminal, run Gulp, and you will receive the following output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 返回终端，运行Gulp，您将收到以下输出：
- en: '![](img/49d043ab-3d77-48be-a95a-61d6320c1b97.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49d043ab-3d77-48be-a95a-61d6320c1b97.png)'
- en: 'Gulp is faster and simpler; why?: Gulp uses node.js streams to pass a data
    chunk through a series of the piped plugin. This accelerates the in-memory process
    operations and performs the write operation at the end of the task, once and for
    all.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp更快，更简单；为什么呢？Gulp使用node.js流将数据块通过一系列管道插件传递。这加速了内存中的处理操作，并在任务的最后执行写操作。
- en: 'Let''s get ready to expand the scope of learning Gulp and automate our unit
    tests we covered in the previous sections. We will start by installing the other
    required npm packages. Note that we will need to install them in our `project`
    folder and not in the `test` folder. So, let''s go back one step using `cd..`,
    and ensure that you are at your project''s root level and run the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备扩大学习Gulp的范围，并自动化我们在前几节中涵盖的单元测试。我们将首先安装其他所需的npm软件包。请注意，我们需要在`project`文件夹中安装它们，而不是在`test`文件夹中。因此，让我们使用`cd..`回到上一步，并确保您位于项目的根目录，然后运行以下命令：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `gulp-mocha` is a plugin to run the `mocha` test files. Now, let''s modify
    our Gulp file and add some es6 spices, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`gulp-mocha`是运行`mocha`测试文件的插件。现在，让我们修改我们的Gulp文件并添加一些es6调料，如下所示：'
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, run `gulp test-server` to get the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`gulp test-server`以获得以下输出：
- en: '![](img/d8408a50-aebd-4165-863a-12f562c73aee.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8408a50-aebd-4165-863a-12f562c73aee.png)'
- en: Let's discuss how the preceding code works. First, we created the `test-helper`
    task that reads the `testhelper.js` file in memory and does nothing else but store
    the global variables required to test our `server.test.js`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论上述代码的工作原理。首先，我们创建了`test-helper`任务，它在内存中读取`testhelper.js`文件，除了存储测试`server.test.js`所需的全局变量之外什么也不做。
- en: We used mocha as a framework to write test cases. The `gulpMocha` plugin runs
    the test cases in memory by reading the `server.test.js` file and pipes the output
    in terminal. To study about `gulp-mocha` in detail, follow the [https://github.com/sindresorhus/gulp-mocha](https://github.com/sindresorhus/gulp-mocha)
    link.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用mocha作为一个框架来编写测试用例。`gulpMocha`插件通过读取`server.test.js`文件并将输出传输到终端来在内存中运行测试用例。要详细了解`gulp-mocha`，请访问[https://github.com/sindresorhus/gulp-mocha](https://github.com/sindresorhus/gulp-mocha)链接。
- en: 'Note the syntactical structure of how to write dependencies if required. Let''s
    get clarity on adding a dependency by writing one more task, as follows :'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何写入依赖项的语法结构（如果需要）。让我们通过编写一个额外的任务来澄清添加依赖的方式：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This time we will run `gulp test-routes`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将运行`gulp test-routes`。
- en: 'Now, a question may arise regarding managing so many tasks. Gulp also provides
    a solution for automating all the tasks in one go. Let''s add the following snippet
    to our file:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可能会有一个关于管理这么多任务的问题。Gulp也提供了一种解决方案，可以一次性自动化所有任务。让我们向文件中添加以下片段：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run the preceding command; Gulp `build` and automation of unit tests are both
    now complete. Further, we can add all the controllers and respective models so
    as to achieve project-based automation of test cases.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令；Gulp `build`和单元测试的自动化都已经完成。此外，我们可以添加所有的控制器和相应的模型，以实现基于项目的测试用例自动化。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This has definitely been a crash course on testing, but the groundwork has been
    laid, and I hope that you have a solid understanding of the tool chain that you
    can use to write your own tests. Trust this powerhouse suite of tools, and you'll
    be writing bulletproof code in no time!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是一个关于测试的速成课程，但基础已经奠定，我希望你对可以用来编写自己的测试的工具链有一个扎实的理解。相信这套强大的工具组合，你将很快编写出牢固的代码！
- en: The ultimate goal with writing tests is to have 100 percent complete code coverage
    and have unit tests exist for every line of code you write. From here, the true
    test is to switch to TDD, which dictates that you write tests before any code
    exists at all. Obviously, tests against nonexistent code will fail, so you'll
    then need to write the least amount of code to get it to pass, and repeat!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试的最终目标是实现100%的代码覆盖率，并且为你编写的每一行代码都存在单元测试。从这里开始，真正的测试是转向TDD，这要求你在任何代码存在之前先编写测试。显然，对不存在的代码进行测试将会失败，所以你需要编写尽量少的代码来使其通过，并重复这个过程！
- en: In the next chapter, we'll take a look at a number of cloud-based hosting options
    available to get your application up and running online.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看一些云端托管选项，以便让你的应用程序在线上运行起来。
