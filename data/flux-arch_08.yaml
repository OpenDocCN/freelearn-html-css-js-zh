- en: Chapter 8. Information Lifecycle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 信息生命周期
- en: Any information system has a lifecycle. Individual components in these systems
    have their own lifecycles as well. Cumulatively, these can be easy to deal with
    or overwhelmingly difficult. In frontend JavaScript architectures, the tendency
    is toward the latter. The reason is simple, the lifecycles that our components
    go through, fundamentally alter the flow of information over time in ways that
    are close to impossible to predict.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何信息系统都有其生命周期。这些系统中的单个组件也有它们自己的生命周期。累积起来，这些可能很容易处理，也可能非常困难。在前端JavaScript架构中，趋势是后者。原因很简单，我们的组件经历的生命周期，从根本上改变了信息随时间流动的方式，这是几乎无法预测的。
- en: This chapter is about the information life cycle in Flux architectures. Flux
    is different from other architectures in that it puts emphasis on scaling information
    instead of on JavaScript components. We'll begin exploring this theme with a look
    at the difficulties we've faced for years, using the typical component lifecycles
    found in modern JavaScript frameworks. Then, we'll contrast this approach with
    that of Flux, where high-level components are relatively static.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的是Flux架构中的信息生命周期。Flux与其他架构的不同之处在于，它强调信息的扩展而不是JavaScript组件。我们将从审视多年来的困难开始，这些困难是使用现代JavaScript框架中典型的组件生命周期所面临的。然后，我们将这种做法与Flux的方法进行对比，在Flux中，高级组件相对静态。
- en: Next, we'll jump into the concept of scaling information and how this leads
    to more sane architectures that are much easier to maintain than alternative approaches.
    We'll close the chapter with a discussion on inactive stores—stores that aren't
    actively serving a view with data. Let's get to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨信息扩展的概念以及它是如何导致更合理的架构的，这些架构比其他方法更容易维护。我们将以讨论不活跃的存储结束本章——这些存储不活跃地服务于带有数据的视图。让我们开始吧。
- en: Component life cycle difficulties
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期困难
- en: One aspect of scaling a frontend architecture is cleaning up unused resources.
    This frees memory for new resources that get created as the user interacts with
    the application. JavaScript is garbage-collected, meaning that once an object
    doesn't have any references to it, it's eligible for collection the next time
    the collector runs. This gets us partway there; in that, there's no need to manually
    allocate/de-allocate memory. However, we have a whole other category of scaling
    issues, and they're all related to the lifecycle of components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 前端架构扩展的一个方面是清理未使用的资源。这为新创建的资源释放内存，这些资源是在用户与应用程序交互时创建的。JavaScript是垃圾回收的，这意味着一旦一个对象没有任何引用指向它，它就符合在下一次回收器运行时被收集的条件。这让我们前进了一半；也就是说，没有必要手动分配/释放内存。然而，我们还有另一类扩展问题，它们都与组件的生命周期有关。
- en: In this section, we'll talk about the scenarios where we want to reclaim unused
    resources and how this generally happens in frontend architectures. Then, we'll
    look at the challenges that component dependencies present, in the context of
    lifecycle management. Finally, we'll look at memory leak scenarios. Even with
    the best tools in place, there's always the possibility that our code has done
    something to circumvent memory management.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论我们想要回收未使用资源的场景以及这通常在前端架构中是如何发生的。然后，我们将从生命周期管理的角度审视组件依赖带来的挑战。最后，我们将探讨内存泄漏场景。即使有最好的工具，我们的代码也可能做了某些事情来规避内存管理。
- en: Reclaiming unused resources
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回收未使用资源
- en: 'Something that happens a lot throughout the course of an application, is that
    new resources are created while old resources are destroyed. This is in response
    to user interactivity—as they traverse the features of the application, new components
    get created in order to present new information. Much of this creation and destruction
    of JavaScript objects and DOM elements is transparent to us—the tools we employ
    can take care of this for us. The following diagram captures the idea of a component
    that frees internal resources as it changes state:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的整个过程中，经常发生的事情是，在旧资源被销毁的同时，新资源被创建。这是对用户交互的反应——当他们遍历应用程序的功能时，会创建新的组件来展示新的信息。JavaScript对象和DOM元素的这种创建和销毁的大部分对我们来说是透明的——我们使用的工具可以为我们处理这些。以下图表捕捉了组件在改变状态时释放内部资源的概念：
- en: '![Reclaiming unused resources](img/B05419_08_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![回收未使用资源](img/B05419_08_01.jpg)'
- en: The key lies with the lifecycle of our components. Depending on the framework
    that's responsible for managing this lifecycle, different things can happen at
    different times. For instance, your component is instantiated and stored when
    it's parent component is created. When your component is rendered, it inserts
    new DOM elements and keeps a reference to them. Finally, when the component's
    parent is destroyed, our component is instructed to remove its DOM elements and
    release any references to them. This is an oversimplified work-flow, but the general
    idea is the same no matter how many moving parts there are. The job of the tools
    we use is to handle the lifecycle of our components in a way that reclaims unused
    components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于我们组件的生命周期。根据负责管理此生命周期的框架，不同时间可能会发生不同的事情。例如，当父组件创建时，你的组件被实例化并存储。当你的组件被渲染时，它会插入新的DOM元素并保持对它们的引用。最后，当组件的父组件被销毁时，我们的组件被指示移除其DOM元素并释放对它们的任何引用。这是一个过于简化的工作流程，但无论有多少移动部件，基本思想都是相同的。我们使用的工具的职责是以一种回收未使用组件的方式处理我们组件的生命周期。
- en: Why is reclaiming unused components so important? The fundamental limitation
    we face is that memory is finite, and we're trying to build a robust application
    that scales well. Removing components from memory when they're no longer needed,
    makes room for new components to be created when they're needed. So, what's the
    big deal if we're using a framework that has well-defined lifecycles for our components
    and handles a lot of the messy details for us?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么回收未使用的组件如此重要？我们面临的基本限制是内存是有限的，我们正在尝试构建一个健壮的应用程序，它能很好地扩展。当组件不再需要时，从内存中移除组件，为需要时创建新组件腾出空间。那么，如果我们使用一个为我们的组件定义了良好生命周期的框架，并且为我们处理了很多繁琐的细节，这有什么大不了的？
- en: One limiting factor to this approach is that with a complex application that
    has lots of moving parts, the framework is constantly creating and destroying
    objects. This inevitably leads to the garbage collector getting invoked frequently,
    causing pauses in the main JavaScript execution thread. In the worst case, this
    can lead to pauses in the user experience due to unresponsive user events. The
    other potential pitfall of automatically managed component lifecycles is that
    the framework doesn't always know what we're thinking, and this can lead to hidden
    dependencies that end up breaking the flow of the component create/destroy lifecycle.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的限制因素之一是，对于具有许多移动部件的复杂应用程序，框架会不断创建和销毁对象。这不可避免地导致垃圾收集器频繁调用，导致主JavaScript执行线程暂停。在最坏的情况下，这可能导致由于用户事件无响应而导致的用户体验暂停。自动管理组件生命周期的另一个潜在陷阱是，框架并不总是知道我们在想什么，这可能导致最终破坏组件创建/销毁生命流程的隐藏依赖项。
- en: Hidden dependencies
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏的依赖项
- en: 'Patterns that define the lifecycle of a particular type of component are a
    good thing—provided that our components abide by their lifecycle one hundred percent
    of the time. This rarely works out because we''re trying to build something unique
    that solves a problem for our users, not a piece of software that plays nice with
    a framework just for the sake of it. The biggest risk here is that we''ll accidentally
    prevent the framework from properly freeing resources by introducing dependencies.
    These dependencies might make perfect sense in the context of our application,
    but as far as the framework is concerned, it doesn''t know about them, and this
    breaks in unpredictable ways. Take a look at the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 定义特定类型组件生命周期的模式是好事——前提是我们组件始终百分之百遵守其生命周期。这很少能成功，因为我们试图构建一些独特的东西，为我们的用户提供解决方案，而不是仅仅为了与框架友好相处而构建的软件。这里最大的风险是我们可能会意外地通过引入依赖项阻止框架正确释放资源。这些依赖项在我们的应用程序的上下文中可能完全合理，但就框架而言，它并不知道它们，这会导致不可预测的方式中断。看看下面的图示：
- en: '![Hidden dependencies](img/B05419_08_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![隐藏的依赖项](img/B05419_08_02.jpg)'
- en: The actual scenarios we face will be a little more nuanced than the scenario
    depicted here. The general theme is that frameworks that manage lifecycles are
    unforgiving. All it takes is a dependency in the wrong place to completely invalidate
    everything that the framework is doing for the application. However, this is the
    cost/benefit of having lifecycles for architectural components in the first place.
    The benefit being that we need to reclaim components to make way for new ones,
    and if a framework can automate this arduous task for us, all the better. The
    risk is that any time things are created and destroyed, there's a chance that
    this isn't done properly, leading to memory leaks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际面临的情况将比这里描述的场景更为复杂。总体来说，主题是管理生命周期的框架非常严格。只需一个放置错误的位置的依赖项，就可以完全无效化框架为应用程序所做的一切。然而，这正是我们最初为架构组件设置生命周期的成本/收益。好处是我们需要回收组件以腾出空间给新的组件，如果框架能为我们自动化这项艰巨的任务，那就更好了。风险是，每次创建和销毁事物时，都有可能没有正确完成，从而导致内存泄漏。
- en: Memory leaks
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: When our code is constantly creating and destroying objects, the JavaScript
    garbage collector thrashes, and we experience performance hiccups. However, this
    is a minor problem compared to leaky JavaScript components that are never fully
    garbage-collected. This tends to happen when our application code has ideas that
    don't quite fit with those of the framework that manages the lifecycle of our
    components. Obviously memory leaks are a huge scalability issue and one that want
    to avoid at all costs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码不断创建和销毁对象时，JavaScript垃圾回收器会变得不稳定，我们可能会遇到性能问题。然而，与那些从未完全被垃圾回收的泄漏JavaScript组件相比，这只是一个小问题。这种情况通常发生在我们的应用程序代码有一些与负责管理组件生命周期的框架不完全匹配的想法时。显然，内存泄漏是一个巨大的可扩展性问题，我们无论如何都要避免。
- en: So what we have are two related scalability issues with regard to the lifecycle
    of components in our architecture. First, we don't want to constantly create and
    destroy objects because this has garbage-collection pausing problems. Second,
    we don't want to leak memory by introducing hidden dependencies that the framework
    isn't aware of, breaking the intended lifecycle. As we'll see in the following
    section, Flux architectures help with both aspects of component lifecycle issues.
    There isn't a lot of creation/destruction of components in a Flux architecture.
    This reduces the probability of introducing logic that breaks the lifecycle of
    a given component. Later in the chapter, we'll see how Flux focuses on information
    rather than JavaScript components to achieve scale.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在架构组件的生命周期方面有两个相关的可扩展性问题。首先，我们不希望不断创建和销毁对象，因为这会有垃圾回收暂停的问题。其次，我们不希望通过引入框架未知的隐藏依赖而泄漏内存，破坏预期的生命周期。正如我们将在下一节中看到的，Flux架构有助于解决组件生命周期问题的两个方面。在Flux架构中，组件的创建/销毁并不多。这减少了引入逻辑破坏特定组件生命周期的可能性。在本章的后面部分，我们将看到Flux如何专注于信息而不是JavaScript组件来实现可扩展性。
- en: Flux structures are static
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux结构是静态的
- en: Given that the need to constantly create and destroy objects presents an opportunity
    for scaling issues, it seems that we should create and destroy as little as possible.
    It turns out that Flux architectures are different in this area in that much of
    the component infrastructure is static.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 既然不断创建和销毁对象的需要为可扩展性问题提供了机会，那么我们似乎应该尽可能少地创建和销毁。结果证明，在这一点上，Flux架构有所不同，因为大部分组件基础设施是静态的。
- en: In this section, we'll look at what sets Flux apart from other architectures
    in this regard, starting with the singleton pattern that's used by many modules.
    Then, we'll compare the traditional MVC model approach to Flux stores. Lastly,
    we'll take a look at static view components and see if this is an idea worth pursuing
    in order to achieve scale.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Flux在这一点上与其他架构的不同之处，从许多模块使用的单例模式开始。然后，我们将比较传统的MVC模型方法与Flux存储。最后，我们将查看静态视图组件，看看这是否是一个值得追求以实现可扩展性的想法。
- en: Singleton pattern
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: As you've probably noticed by now, most of the modules we've worked with so
    far in this book have exported a single instance. The dispatcher exposes a single
    instance of the `Dispatcher` class from the Facebook Flux package. This is the
    singleton pattern in action.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经注意到的，我们在这本书中迄今为止使用的多数模块都导出了一个单一实例。分发器暴露了来自Facebook Flux包的`Dispatcher`类的一个单一实例。这就是单例模式的应用。
- en: The basic idea is that there's only one instance of a class, creating more is
    never necessary because the first instance is all we'll ever need. This bodes
    well with the scaling issues we've discussed in this chapter, where constant creation
    and destruction makes our code vulnerable to errors. These errors ultimately prevent
    the application from scaling, due to memory leaks or performance problems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是，一个类只有一个实例，创建更多是不必要的，因为第一个实例就是我们需要的所有。这与我们在本章中讨论的扩展问题相吻合，其中不断的创建和销毁使我们的代码容易出错。这些错误最终阻止了应用程序的扩展，因为内存泄漏或性能问题。
- en: Instead, Flux architectures tend to assemble the plumbing between the components
    at startup time, and this pluming stays in place permanently. Think about the
    physical plumbing where you live, it sits idle when it's not being used. However,
    the cost of tearing out the physical plumbing to reclaim the space, and the cost
    of replacing it when needed simply doesn't add up. The overhead of having static
    plumbing structures within our walls isn't a scaling bottleneck in our day-to-day
    lives.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Flux架构倾向于在启动时组装组件之间的管道，并且这些管道永久地保持原位。想想您居住的地方的物理管道，当它没有被使用时，它就处于闲置状态。然而，拆除物理管道以回收空间，以及当需要时更换它的成本，简单地说是不划算的。在我们的墙壁内拥有静态管道结构的开销并不是我们日常生活中的扩展瓶颈。
- en: 'So while we can avoid some of the creation and destruction of objects by following
    the singleton pattern, there are tradeoffs. For example, the single pattern isn''t
    necessarily a good pattern. At least not in all our modules where everything is
    a class, and yet, everything is only instantiated once. Let''s look at a store
    module and see if we can implement something that doesn''t actually require a
    store. First, let''s implement a typical store module which exports a singleton
    class instance for comparison:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然我们可以通过遵循单例模式避免一些对象的创建和销毁，但这是有代价的。例如，单例模式并不一定是一个好的模式。至少在我们所有的模块中，一切都是一个类，而且一切只实例化一次。让我们看看存储模块，看看我们是否可以实施实际上不需要存储的东西。首先，让我们实现一个典型的存储模块，以便进行比较：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There''s only a handful of properties that the outside world requires from
    this module. It needs the state, so other components can read it. It needs the
    identifier of dispatcher registration, so other components can depend on it using
    `waitFor()`. And, it needs the `EventEmitter`, so other components can listen
    for store state changes. Let''s now implement a store that doesn''t actually require
    instantiating a new class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 外部世界从这个模块中需要的属性只有少数几个。它需要状态，以便其他组件可以读取它。它需要调度器注册的标识符，以便其他组件可以使用`waitFor()`依赖它。此外，它还需要`EventEmitter`，以便其他组件可以监听存储状态的变化。现在让我们实现一个实际上不需要实例化新类的存储：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we're exporting the bare necessities that allow other components
    to treat this module as a store. And it is indeed a store, it's simply structured
    differently. Instead of exporting a singleton class instance, which has the essential
    store interface, we're directly exporting the pieces of the interface. Is there
    any fundamental advantage to either approach? No, there's not. If you prefer classes
    and the ability to extend a base class, then stick with the singleton pattern.
    If you feel that classes are ugly and unnecessary, stick with the module approach.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在导出基本需求，使其他组件可以将此模块视为存储。实际上，它确实是一个存储，只是结构不同。我们不是导出一个具有基本存储接口的单例类实例，而是直接导出接口的各个部分。这两种方法有任何根本性的优势吗？没有，没有。如果您喜欢类以及扩展基类的功能，那么请坚持使用单例模式。如果您觉得类很丑陋且不必要，请坚持使用模块方法。
- en: At the end of the day, the architectural result is the same. The store simply
    exists. There's no need to create and destroy the store as the user interacts
    with the application. There's nothing preventing us from doing this—setting up
    and tearing down stores as the state of the application changes. But as we'll
    see later in the chapter, there's really no advantage to doing this, just as there's
    no advantage to tearing your walls apart when the sink isn't running.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，架构结果是相同的。存储简单地存在。当用户与应用程序交互时，没有必要创建和销毁存储。没有任何东西阻止我们这样做——随着应用程序状态的变化，设置和拆除存储。但正如我们将在本章后面看到的那样，这样做实际上并没有优势，就像在下水道不运行时拆掉墙壁一样没有优势。
- en: 'Let''s see these two stores in action. Aside from how they''re imported, they''re
    indistinguishable:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两个存储的实际效果。除了它们如何导入之外，它们是无法区分的：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Comparison to models
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与模型的比较
- en: Remember the idea that stores represent features at the top-level of our application?
    Well, top-level features generally aren't created and destroyed constantly throughout
    the lifetime of the application. Models on the other hand, our friends from the
    family of MV* architectures, often represent more fine-grained data domains. And
    because of this, they need to pop in and out of existence.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 记得存储代表我们应用程序顶级功能的想法吗？嗯，顶级功能通常不会在整个应用程序生命周期中不断创建和销毁。另一方面，模型，我们来自 MV* 架构家族的朋友，通常代表更细粒度的数据域。正因为如此，它们需要出现和消失。
- en: For example, suppose we're on the search page of an application, and there's
    a bunch of results displayed. The individual results are likely models, representative
    of some structure returned by the API. The view that renders the search results
    probably knows how to display these modules. When the results change or the user
    navigates to another part of the application, the models are inevitably destroyed.
    This is part of the whole lifecycle discussion we had earlier in the chapter.
    It's not a simple deletion—there's cleanup steps that need to be performed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在应用程序的搜索页面，并且显示了一堆结果。单个结果可能是模型，代表 API 返回的某些结构。渲染搜索结果的视图可能知道如何显示这些模块。当结果发生变化或用户导航到应用程序的另一个部分时，模型不可避免地会被销毁。这是我们在本章前面讨论的整个生命周期讨论的一部分。这不是一个简单的删除——需要执行一些清理步骤。
- en: With Flux stores, we don't have the same level of complexity. There's views
    that listen to a given store, but that's it. When the state of a store changes,
    like when some search result data is deleted from the store state, the views are
    notified. It's then up to the view to reflect this changed data by re-rendering
    the UI. With Flux, the cleanup is a simple deletion problem, both from the point
    of view of the DOM and of the store. The fact that we're not blowing away entire
    stores while the user interacts with the application means that there's less chance
    for our architectural components to fall out of sync with one another.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flux 存储，我们不需要相同级别的复杂性。存在一些视图会监听特定的存储，但仅此而已。当存储的状态发生变化时，例如当某些搜索结果数据从存储状态中删除时，视图会被通知。然后视图需要通过重新渲染
    UI 来反映这些变化的数据。在 Flux 中，清理工作只是一个简单的删除问题，无论是从 DOM 的角度来看还是从存储的角度来看。在我们用户与应用程序交互时不会删除整个存储的事实意味着我们的架构组件之间出现不同步的机会更小。
- en: Static views
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态视图
- en: Since views are the components responsible for rendering information that the
    user can see, it would make sense that the view is cleaned up when the user isn't
    looking at it, right? Well, not necessarily. Revisiting the plumbing analogy,
    when we leave the kitchen, we turn the tap in the sink off. We don't get a toolbox
    and start ripping out pipes. The notion that views in a Flux architecture can
    be static is in fact viable. It's the water we need to turn off in order to scale,
    not the plumbing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图是负责渲染用户可以看到的信息的组件，当用户没有在查看它时清理视图似乎是有意义的，对吧？嗯，不一定。回顾一下管道类比，当我们离开厨房时，我们会关闭水槽的龙头。我们不会拿一个工具箱开始拆除管道。Flux
    架构中的视图可以是静态的这一观点实际上是可行的。我们需要关闭的是水，而不是管道，以便进行扩展。
- en: 'Let''s look at some views that are created at startup and never destroyed as
    the user interacts with the application. First, we''ll implement a class-based
    static view:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些在启动时创建且在用户与应用程序交互时不会被销毁的视图。首先，我们将实现一个基于类的静态视图：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This looks like your typical class that you would find in a Flux architecture.
    It''s instantiated within the module and exported. The content itself is rendered
    by reducing an array to a `<strong>` tag. We''ll see why we''re rendering such
    a tag like this when we look at the store. But first, let''s look at another static
    view that takes the form of a function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来就像你在 Flux 架构中会找到的典型类。它是在模块内部实例化并导出的。内容本身是通过将数组减少到一个 `<strong>` 标签来渲染的。当我们查看存储时，我们会看到为什么要以这种方式渲染这样的标签。但首先，让我们看看另一个以函数形式存在的静态视图：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the functional style of React components that you were introduced to
    in the previous chapter. As you can see, there''s nothing much to it, as React
    takes care of a lot of the heavy lifting for us. Now let''s take a look at the
    store that both of these views relies on for information:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在上一章中介绍到的 React 组件的函数式风格。正如你所见，并没有什么特别的，因为 React 为我们处理了很多繁重的工作。现在让我们看看这两个视图都依赖的信息存储：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can see that both actions—`SHOW_CLASS` and `SHOW_FUNCTION`—are processed
    the same way. One action sets a piece of state while deleting another. Let''s
    discuss this approach here for a moment. The `classContent` and `functionContent`
    state properties both use single-item arrays for a string value. Both of our views
    iterate over these arrays—using `map()` and `reduce()`. The reason we''re doing
    it this way is to keep logic out of the views. The business logic that operates
    on stores should stay in the store. However, views need to know what to display
    and what to remove. By always iterating over a collection, like an array, the
    content generation is consistent and logic-free. Let''s see how both of these
    views are used in `main.js`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这两个动作——`SHOW_CLASS`和`SHOW_FUNCTION`——被以相同的方式处理。一个动作设置一个状态项，同时删除另一个。让我们在这里讨论一下这种方法。`classContent`和`functionContent`状态属性都使用包含字符串值的单元素数组。我们的两个视图都会遍历这些数组——使用`map()`和`reduce()`。我们这样做的原因是让逻辑不进入视图。在存储上操作的业务逻辑应该留在存储中。然而，视图需要知道显示什么和删除什么。通过始终遍历一个集合，如数组，内容生成是一致的且无逻辑的。让我们看看这两个视图如何在`main.js`中使用：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `classView` is straightforward to use. It's imported and rendered. The store
    state handling is encapsulated within the `view` module. The `FunctionView` React
    component on the other hand, needs to be set up with a handler function that's
    called when `myStore` changes state. Technically, this isn't a static view, because
    it's a function that's called whenever `React.render()` is called. However, in
    the context of Flux, it does behave a lot like a static view, because it's the
    React rendering system that handles the creation and destruction of view components—our
    code isn't creating or destroying anything—only passing components to `render()`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`classView`的使用非常简单。它被导入并渲染。存储状态处理封装在`view`模块中。另一方面，`FunctionView` React组件需要设置一个处理函数，当`myStore`状态改变时会被调用。技术上讲，这并不是一个静态视图，因为它是一个在每次调用`React.render()`时都会被调用的函数。然而，在Flux的上下文中，它确实表现得像静态视图，因为React渲染系统负责创建和销毁视图组件——我们的代码并没有创建或销毁任何东西——只是将组件传递给`render()`。'
- en: Scaling information
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息扩展
- en: As you've seen so far in this chapter, Flux doesn't try to scale things that
    don't need to be scaled. For example, stores and views are often created just
    once during startup. Trying to clean these components repeatedly as the application
    changes state over time is simply error-prone. It's scaling the information that
    Flows through our Flux components that will knock our system over if we're not
    careful.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本章中迄今为止所见，Flux不会尝试扩展那些不需要扩展的事物。例如，存储和视图通常在启动时只创建一次。随着应用程序随时间变化状态，试图反复清理这些组件是容易出错的。如果我们不小心，扩展通过我们的Flux组件流动的信息将会使我们的系统崩溃。
- en: We'll start this section off with a look at how our Flux architectures can scale
    well on their own, without massive amounts of data entering the system. This also
    serves to illustrate the idea that these are in fact two separate problems—scaling
    the infrastructure of our Flux components versus scaling the volume of data that
    our architecture is able to process. Then, we'll discuss the topic of designing
    our user interfaces for less information, to make the design process of scalable
    components straightforward. We'll explore the role of Flux actions when it comes
    time to scale our system up to the next level.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个部分开始，看看我们的Flux架构如何在没有大量数据进入系统的情况下很好地扩展。这也旨在说明这些实际上是两个独立的问题——扩展我们的Flux组件的基础设施与扩展我们的架构能够处理的数据量。然后，我们将讨论为更少的信息设计我们的用户界面，以使可扩展组件的设计过程简单化。我们将探讨在将我们的系统扩展到下一个级别时Flux动作的作用。
- en: What scales well?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么可以很好地扩展？
- en: As our application grows, it needs to scale in response to things like new feature
    requests, and growing datasets. The question is, which of these scaling issues
    is most deserving of our attention? It should be the issue with the highest potential
    to topple our system. Generally speaking, this has more to do with the input data
    than it does with the configuration of our Flux components. For instance, there's
    a potential scaling issue if we're processing input data in polynomial time instead
    of logarithmic time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序增长，它需要响应新功能请求和增长的数据集等问题进行扩展。问题是，这些扩展问题中哪一个最值得我们关注？应该是那些最有潜力使我们的系统崩溃的问题。一般来说，这更多与输入数据有关，而不是与我们的Flux组件的配置有关。例如，如果我们以多项式时间而不是对数时间处理输入数据，就存在潜在的扩展问题。
- en: 'This is why our Flux architecture doesn''t need to concern itself with lifecycles
    and maintaining the plumbing between components the same way other architectures
    do. Will having a lot of components occupy more memory than they need to and is
    this expensive in terms of performance? Sure, this is always a consideration—we
    don''t want to have more components then we need. In practice, this type of overhead
    is hardly noticeable by users. Let''s take look at the impact a large component
    infrastructure has on performance. First, the view:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们的Flux架构不需要像其他架构那样关注生命周期和组件之间的管道维护。拥有大量组件是否会占用比它们需要的更多内存，并且在性能上是否昂贵？当然，这始终是一个考虑因素——我们不希望拥有比我们需要的更多组件。在实践中，这种开销几乎不会被用户注意到。让我们看看大型组件基础设施对性能的影响。首先，看看视图：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There''s nothing much to this view because there doesn''t need to be. We''re
    not testing the rendering performance of the view itself—we''re testing the scalability
    of the architecture. So all that''s required is that the view exists and can listen
    to a store. We''re passing the store instance in through the constructor because
    we''re creating several instances of this view that listen to different stores,
    as we''ll see here in a moment. Let''s look at the store code next:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图没有什么特别的，因为不需要有。我们不是在测试视图本身的渲染性能——我们是在测试架构的可扩展性。所以所需的就是视图存在并且可以监听一个存储。我们通过构造函数传递存储实例，因为我们正在创建几个监听不同存储的视图实例，正如我们稍后将看到的。让我们看看存储代码：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is a pretty basic store that does a pretty basic calculation when `MY_ACTION`
    is dispatched. Again, this is intentional. Now let''s see how these components
    can scale in a Flux architecture without much data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当基本的存储，当`MY_ACTION`被分发时，它会进行相当基本的计算。再次强调，这是故意的。现在让我们看看这些组件如何在Flux架构中几乎没有数据的情况下进行扩展：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We're measuring the startup cost of creating these components and setting up
    their listeners, because this will typically add to the startup cost of a Flux
    application. But as we can see here, getting all these components ready is inconsequential
    in terms of user experience. The big test comes when the actions are dispatched.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在衡量创建这些组件并设置它们的监听器的启动成本，因为这通常会增加Flux应用程序的启动成本。但正如我们所看到的，准备所有这些组件在用户体验方面并不重要。真正的考验是在动作被分发时。
- en: This setup causes one million view render calls to happen, and it takes about
    half a second. This is the plumbing in the wall of our application, and it really
    doesn't benefit us to tear it down and set it all back up again later. This aspect
    of the architecture scales well. It's the data that enters the system, and the
    logic that operates on it that's the real scaling challenge. If we have to run
    this same test again with an action payload of a 1000 item array that was sorted
    by the store, we might have a problem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置会导致发生一百万次视图渲染调用，并且大约需要半秒钟。这是我们应用程序墙上的管道，实际上我们并不想把它拆下来然后再重新搭建起来。这个架构方面具有良好的可扩展性。真正具有挑战性的是进入系统的数据以及对其操作的逻辑。如果我们必须再次运行这个相同的测试，并且有一个由商店排序的1000项数组的操作有效载荷，我们可能会遇到问题。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll address more fine-grained performance testing scenarios in [Chapter 13](ch13.html
    "Chapter 13. Testing and Performance"), *Testing and Benchmarking*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第13章[测试和性能](ch13.html "Chapter 13. Testing and Performance")中讨论更多细粒度的性能测试场景。
- en: Minimal information required
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所需的最小信息
- en: As you just saw, the notion that Flux components and their connections can be
    statically-defined is valid. At least, in terms of scaling challenges, having
    static plumbing in place isn't going to be the thing that knocks our system down
    when we try to scale it. It's the data that flows into the system, and the means
    by which we transform it into information for the user. This is the thing that's
    very difficult to scale, and so, it's best that we do as little of it as possible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Flux组件及其连接可以静态定义的观点是有效的。至少，在可扩展性挑战方面，在系统中放置静态管道不会成为我们在尝试扩展系统时将其击垮的东西。是流入系统的数据以及我们将其转换为用户信息的手段。这是非常难以扩展的事情，因此，我们最好尽可能少做。
- en: It may sound trivially obvious at first, but having less information to display
    scales well. This can easily be overlooked because we're out to build features,
    not to measure the volume of information output from our views. Sometimes, this
    is the most effective way, or possibly the only way, to fix scaling problems.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 起初这可能听起来微不足道，但显示更少的信息可以很好地扩展。这很容易被忽视，因为我们致力于构建功能，而不是衡量我们从视图中输出的信息量。有时，这是最有效的方法，或者可能是唯一的方法，来修复扩展问题。
- en: When we're designing a Flux architecture for our application, we have to keep
    information scalability in mind. Often, the best angle to look at the problem
    is from the UI itself. If there's a way that we can axe certain things, in an
    effort to reduce clutter, we also reduce the amount of information that views
    need to generate. Potentially, we can remove an entire data flow from our application
    simply by changing what the user sees. Lean user interfaces scale well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为应用程序设计Flux架构时，我们必须考虑到信息可扩展性。通常，从UI本身的角度来看问题是最好的角度。如果我们能砍掉某些东西，以减少杂乱，我们也会减少视图需要生成的信息量。潜在地，我们可以通过改变用户看到的内容，简单地从我们的应用程序中移除整个数据流。精简的用户界面可以很好地扩展。
- en: Something else to be on the lookout for is information that leaks out of store
    components. By this, I mean information that a store generates for no real purpose.
    This could have been something that used to be relevant to how the view worked,
    but when the feature changed, we forgot to take out the relevant information.
    Or, it could simply be an oversight in the design—we're generating information
    that the view doesn't actually need, and its been this way from day one. These
    problems are difficult to spot, but easy to fix. The only foolproof approach is
    to periodically audit our views to ensure that they're consuming the information
    that they need and nothing more.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的问题是存储组件中泄露出的信息。通过这个，我指的是存储组件出于没有实际目的而生成的信息。这可能曾经与视图的工作方式相关，但特征改变后，我们忘记了移除相关信息。或者，这可能是设计上的疏忽——我们生成视图实际上不需要的信息，而且这种情况从第一天开始就是这样。这些问题很难被发现，但很容易解决。唯一万无一失的方法是定期审计我们的视图，以确保它们只消耗它们需要的信息，没有更多。
- en: Actions that scale
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展的动作
- en: Actions are the gatekeepers of any data that wants to enter our Flux system—if
    it's not an action payload, then it's not data that we care about. Action creator
    functions aren't problematic to scale, as they don't do much. The most complex
    aspect of an action creator function is managing asynchronous behavior, if necessary.
    But this isn't a fundamental scaling problem, every JavaScript application has
    asynchronous components. There's two fundamental ways that actions can thwart
    our scaling efforts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是任何想要进入我们的Flux系统的数据的守门人——如果不是动作有效载荷，那么就不是我们关心的数据。动作创建者函数在扩展上没有问题，因为它们做得不多。动作创建者函数最复杂的方面是管理异步行为，如果需要的话。但这不是一个基本的扩展问题，每个JavaScript应用程序都有异步组件。动作可以阻碍我们扩展努力的两个基本方法。
- en: The first is having too many actions. This means that there's more opportunity
    for programmer error due to all the possibilities. It becomes less obvious which
    action creator should be used in which context. The same problem can happen when
    there are few actions and too many action creator parameters. This directly inhibits
    our ability to get the right data into the stores of our application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是动作过多。这意味着由于所有可能性的存在，程序员出错的机会更多。在哪个上下文中应该使用哪个动作创建者变得不那么明显。当动作很少而动作创建者参数很多时，同样的问题也可能发生。这直接阻碍了我们将正确数据输入应用程序存储的能力。
- en: The second way that actions can stumble when we try to scale our system is that
    the action creator functions are doing too much. For example, an action creator
    function might try to filter out some of the API response data in an effort to
    slim down the data that's handed off to the stores through the dispatcher. This
    is hugely problematic, because it violates the Flux rule that all state and all
    logic that changes state belongs in stores.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试扩展我们的系统时，动作可能遇到的第二种问题是动作创建者函数做得太多。例如，一个动作创建者函数可能试图过滤掉一些API响应数据，以减少通过调度器传递给存储的数据量。这是一个大问题，因为它违反了Flux规则，即所有状态和所有改变状态的逻辑都属于存储。
- en: It's understandable how something like this can happen though, when under pressure
    to scale an application, the most obvious place to fix data problems is at the
    source. In this case, the source is the handler of the AJAX response. The better
    way to handle this is to tweak the API itself and have the action creator function
    supply the appropriate parameters to get the smaller set of data. When state transformations
    move outside of stores in the frontend, we reduce the likelihood of scaling successfully
    because we increase the likelihood of other issues taking place.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当面临扩展应用程序的压力时，这种事情发生是可以理解的，因为在数据问题的源头进行修复是最明显的地方。在这种情况下，源头是AJAX响应的处理程序。更好的处理方式是调整API本身，并让动作创建函数提供适当的参数以获取更小的数据集。当状态转换移出前端存储之外时，我们增加了其他问题发生的可能性，从而降低了成功扩展的可能性。
- en: Inactive stores
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无活动存储
- en: In the previous section, we explored the idea that we can have a relatively
    static component infrastructure in our Flux architecture. This isn't something
    that causes concerns about scalability. Rather, it's the large amounts of data
    that's held in our stores. In this final section, we'll cover some scenarios in
    which we have a store with lots of data as its state, and we don't want our application
    to become memory-bloated.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了在我们的Flux架构中可以有一个相对静态的组件基础设施的想法。这不是引起我们对可扩展性担忧的事情。相反，是我们存储中持有的大量数据。在本节的最后，我们将讨论一些场景，在这些场景中，我们有一个存储，其状态包含大量数据，我们不想让我们的应用程序变得内存膨胀。
- en: The first approach involves deleting the data from the store, freeing resources.
    We can take this approach a step further by adding heuristics to our store logic
    that determines that nothing has changed and there's no need to touch the DOM
    by emitting a change event. Finally, we'll talk about some of the side-effects
    caused by deleting store data and how to deal with them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法涉及从存储中删除数据，释放资源。我们可以通过向我们的存储逻辑添加启发式方法来进一步采取这种方法，该方法确定没有变化，并且不需要通过触发更改事件来触摸DOM。最后，我们将讨论删除存储数据引起的某些副作用以及如何处理它们。
- en: Deleting store data
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除存储数据
- en: Something we have to think long and hard about with our Flux components is how
    data that enters the system will eventually exit the system. If we only put data
    in without taking any of it out, we've got a problem. In fact, this activity is
    fundamental to Flux architectures, because removing data from store states is
    also how we remove other data structures, such as DOM nodes and event handler
    functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须仔细思考我们的Flux组件的一个问题是进入系统的数据最终将如何退出系统。如果我们只放入数据而不取出任何数据，我们就有了问题。事实上，这种活动是Flux架构的基本，因为从存储状态中删除数据也是删除其他数据结构，如DOM节点和事件处理函数的方式。
- en: Earlier in the chapter, we saw that by emptying an array, we could tell the
    view to remove UI elements. This is essentially how we scale Flux applications—by
    removing the data that has potential to cause scaling headaches. Imagine a store
    that had a collection with thousands of items in it. This collection would not
    only be expensive to process as is, but it also has the potential to grow much
    larger.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们看到通过清空数组，我们可以告诉视图删除UI元素。这正是我们扩展Flux应用程序的方式——通过删除可能导致扩展问题的数据。想象一下，一个存储中有一个包含数千个项目的集合。这个集合不仅处理起来成本高昂，而且还有可能变得更大。
- en: 'The simple solution is to empty this collection out when it''s no longer needed.
    Let''s revisit this approach. First, here''s what the view looks like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的解决方案是在不再需要时清空这个集合。让我们回顾一下这种方法。首先，这是视图的外观：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A couple of buttons and a list of items—pretty simple. When a button is clicked,
    it calls an action creator function. Let''s turn our attention to the store now:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 几个按钮和项目列表——相当简单。当按钮被点击时，它会调用一个动作创建函数。现在让我们把注意力转向存储：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `HIDE_ALL` action simply deletes all the items by assigning an empty array.
    This is exactly what we''re after—deleting data when it''s no longer needed. This
    is the real scaling challenge, cleaning up data that has the potential to be big
    and expensive to process. The `HIDE_ODD` action is a variation that filters out
    even numbers. Lastly, let''s see how this all comes together in `main.js`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`HIDE_ALL`动作简单地通过分配一个空数组来删除所有项目。这正是我们想要的——在不再需要时删除数据。这是真正的扩展挑战，清理可能很大且处理成本高昂的数据。`HIDE_ODD`动作是一个过滤偶数的变体。最后，让我们看看所有这些在`main.js`中的组合方式：'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Optimizing inactive stores
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化无活动存储
- en: One potential scaling issue with the setup we've used in the preceding example
    is that the view itself performs some expensive computation. For example, we can't
    rule out the possibility that even with an empty array as the supplied information
    to render, the view has some implementation issues. This is problematic in a Flux
    architecture, because actions are always being dispatched to stores, which in
    turn notify views that are listening to them. So it's important that views are
    fast.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们使用的设置可能存在的一个潜在扩展问题是视图本身执行了一些昂贵的计算。例如，我们不能排除这样的可能性，即即使提供空数组作为渲染信息，视图本身也存在一些实现问题。在Flux架构中，这是一个问题，因为动作总是被分发到存储，存储随后通知监听它们的视图。因此，视图必须快速。
- en: This is where React fits really well into Flux. React components are meant to
    be re-rendered in a top–down fashion, from the root component all the way down
    to the leaves. It's able to do this efficiently because of the virtual DOM it
    uses under the hood to compute patches that are then applied to the real DOM.
    This eliminates many performance issues because issuing a lot of DOM API calls
    is a performance bottleneck. On the other hand, it would be slightly naive to
    assume that the store will be publishing changes to an efficient React component.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是React在Flux中发挥出色的地方。React组件旨在以自顶向下的方式重新渲染，从根组件一直到底层组件。它能够高效地做到这一点，因为它使用虚拟DOM来计算补丁，然后将这些补丁应用到真实DOM上。这消除了许多性能问题，因为发出大量的DOM
    API调用是一个性能瓶颈。另一方面，假设存储会向高效的React组件发布变更，这会稍微有些天真。
- en: Stores are responsible for emitting change events when the time is right. Therefore,
    we could determine within the store that when a given action is dispatched, there's
    no need to emit a change event. This would involve some sort of heuristic that
    would determine that the view is already displaying the appropriate information
    given the state of the store, and that emitting a change event now would be of
    no value. By doing this, we could avoid any performance challenges in the view.
    The problem with this approach is that we're building up complexity in our store.
    It's probably better that we emit change events consistently and deal with views
    that are doing things inefficiently. Or if we're not using React as the view layer
    yet, perhaps this is an argument in favor of doing so.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在适当的时候负责发出变更事件。因此，我们可以在存储中确定，当给定动作被分发时，没有必要发出变更事件。这可能涉及某种启发式方法，该方法将确定视图已经根据存储的状态显示适当的信息，并且现在发出变更事件将没有任何价值。通过这样做，我们可以避免视图中的任何性能挑战。这种方法的缺点是我们正在我们的存储中构建复杂性。我们可能最好一致地发出变更事件，并处理那些效率低下的视图。或者如果我们还没有使用React作为视图层，这可能是一个支持这样做的好论据。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter, we'll look at implementing advanced change detection heuristics
    in our view components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在视图组件中实现高级变更检测启发式方法。
- en: Keeping store data
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存存储数据
- en: In this chapter, you've seen how to remove data from stores in a way that scales
    well. If the user has moved from one part of the user interface to another, then
    we likely want to delete any store data that's no longer needed in this new section.
    The idea is that rather than take out all of our JavaScript components, we focus
    on the data in our stores, the aspect of our application that's the most difficult
    to scale. However, there's a potential problem with this approach that we need
    to consider.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到了如何以可扩展的方式从存储中删除数据。如果用户已经从一个用户界面部分移动到另一个部分，那么我们可能希望删除在这个新部分中不再需要的任何存储数据。想法是，而不是移除所有的JavaScript组件，我们专注于存储中的数据，这是我们的应用程序中最难扩展的部分。然而，这种方法存在一个潜在问题，我们需要考虑。
- en: What happens if another store depends on the data that we've just removed? For
    example, the user is on a page that's driven by state from store A. They then
    move on to another page, which is driven by store B, which depends on store A.
    But we've just deleted the state inside of store A—isn't this going to be a problem
    for store B?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个存储依赖于我们刚刚删除的数据，会发生什么？例如，用户正在一个由存储A的状态驱动的页面上。然后他们转到另一个页面，该页面由存储B驱动，存储B依赖于存储A。但我们刚刚删除了存储A中的状态——这不会对存储B造成问题吗？
- en: 'This isn''t a common case—the majority of our stores won''t have any dependencies,
    and we should be safe to delete unused data. However, we need to come up with
    a game plan for stores that do have dependencies. Let''s walk through an example
    and start with the views. First, we have the radio button view, which is a simple
    control that allows the user to toggle from a list of users to a list of groups:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个常见的情况——我们的大多数存储都不会有任何依赖关系，我们应该可以安全地删除未使用的数据。然而，我们需要为具有依赖关系的存储制定一个游戏计划。让我们通过一个例子来了解一下，从视图开始。首先，我们有单选按钮视图，这是一个简单的控件，允许用户在用户列表和组列表之间切换：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The change event for both radio buttons is hooked up to an action creator function,
    which affects the display of our two other views—we''ll look at these next, starting
    with the user list view:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 两个单选按钮的变化事件都连接到了一个动作创建函数，它会影响我们另外两个视图的显示——我们将在下面查看这些视图，从用户列表视图开始：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Pretty straightforward, and you can see that there''s a group dependency here,
    as we''re displaying the group that the user belongs to. We''ll dig into that
    dependency momentarily, but for now, let''s look at the group list view:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 非常直接，你可以看到这里存在一个组依赖关系，因为我们正在显示用户所属的组。我们稍后会深入探讨这个依赖关系，但现在，让我们看看组列表视图：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s take a look at the stores that drive these views, starting with
    the radio button store:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看驱动这些视图的存储，从单选按钮存储开始：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see here that we''re using the single-item array technique once again.
    This is why we have the `map()` call in the view that uses this store''s data.
    The idea is that to hide one of these buttons, we can do it right here in the
    store by setting it to an empty collection—keeping logic out of the view. Notice
    that we''ve set up some basic getter functions to make dealing with these single-item
    arrays easier as well. Now let''s check out the groups store:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到我们再次使用了单元素数组技术。这就是为什么在视图中使用这个存储数据的`map()`调用。想法是，为了隐藏这些按钮中的一个，我们可以在存储中直接将其设置为空集合——将逻辑保持在视图之外。注意，我们已经设置了一些基本的获取函数，以便更容易地处理这些单元素数组。现在让我们检查一下组存储：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This store has two pieces of state—`_groups` and `groups`. Yes, they''re basically
    the same thing. The difference is that the view depends on `groups`, not on `_groups`.
    The `Groups` store is able to compute the groups state based on `_groups`. This
    means that we can safely delete the `groups` state to update the view rendering
    while the `_groups` state isn''t touched. Other stores can depend on this store
    now, without risk of any data disappearing. Let''s take a look at the users store
    now:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储有两个状态项——`_groups`和`groups`。是的，它们基本上是同一件事。区别在于视图依赖于`groups`，而不是`_groups`。`Groups`存储能够根据`_groups`计算组状态。这意味着我们可以在不触及`_groups`状态的情况下安全地删除`groups`状态来更新视图渲染。现在，其他存储可以依赖这个存储，而不会存在任何数据消失的风险。现在让我们看看用户存储：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can see that the `Users` store is able to depend on the `_groups` state
    from the `Groups` store in order to build the state that''s needed by the user
    list view. This store follows the same pattern as the `Groups` store in that it
    has a `_users` state and a `users` state. This allows for other views to depend
    on `_users` if necessary, and we can still wipe the `users` state to clear the
    UI. However, if it turns out that nothing is dependent on this store, we can revert
    the pattern so that there''s only one piece of state that''s deleted when no longer
    required by the current view. Lastly, let''s take a look at the `main.js` module
    and see how this all fits together:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`Users`存储能够依赖于`Groups`存储中的`_groups`状态，以便构建用户列表视图所需的状态。这个存储遵循与`Groups`存储相同的模式，即它有一个`_users`状态和一个`users`状态。这允许其他视图在必要时依赖于`_users`，我们仍然可以清除`users`状态以清除UI。然而，如果最终发现没有任何东西依赖于这个存储，我们可以恢复模式，使得在不再需要当前视图时，只有一个状态项被删除。最后，让我们看看`main.js`模块，看看这一切是如何结合在一起的：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The focus of scaling a Flux architecture is on the information that stores produce,
    rather than the various components. This chapter started with a discussion on
    the common practices of other architectures that involve the constant creation
    and destruction of JavaScript components. This is done to free resources, but
    it comes at a cost—the potential for error. Next, we looked at the relatively
    static nature of Flux architectures, where components have a long life. They don't
    have to constantly create and destroy components, which means that there's less
    potential for issues.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Flux 架构的重点在于存储产生的信息，而不是各种组件。本章从讨论其他涉及不断创建和销毁 JavaScript 组件的常见实践开始。这样做是为了释放资源，但代价是潜在的出错可能性。接下来，我们探讨了
    Flux 架构相对静态的特性，其中组件具有较长的生命周期。它们不需要不断创建和销毁组件，这意味着潜在的问题更少。
- en: Next, we covered the concept of scaling information. We did so by demonstrating
    that our JavaScript components and the connections between them were the least
    of our worries when it comes to scaling the architecture. The real challenge comes
    when there's a lot of data to process, and the data that enters the system is
    likely to grow much faster than the number of JavaScript components we have.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了扩展信息的概念。我们通过展示，在扩展架构时，我们的 JavaScript 组件及其之间的连接是最不需要担心的。真正的挑战出现在有大量数据需要处理时，进入系统的数据很可能会比我们拥有的
    JavaScript 组件数量增长得更快。
- en: We closed the chapter with some examples of how to deal with unused store data.
    This is ultimately the most important aspect of scaling a Flux architecture since
    it gives the browser back unused resources. In the next chapter, we'll tackle
    the topic of immutable stores. This is something we've alluded to throughout the
    book, and we'll give it some focused attention now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一些处理未使用存储数据的例子结束了本章。这最终是扩展 Flux 架构最重要的方面，因为它将未使用的资源归还给浏览器。在下一章中，我们将探讨不可变存储的话题。这是我们全书一直提到的，现在我们将给予它一些集中的关注。
