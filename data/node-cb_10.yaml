- en: Chapter 10. Taking It Live
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。让它上线
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Deploying to a server environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到服务器环境
- en: Automatic crash recovery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动崩溃恢复
- en: Continuous deployment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署
- en: Hosting with a Platform as a Service provider
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台即服务提供商进行托管
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Node is an excellent platform of choice for constructing and providing online
    services. Whether it's a simple, lean website, a highly versatile web app, or
    services that transcend beyond HTTP, at some point we must deploy our creations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Node是构建和提供在线服务的绝佳平台选择。无论是简单的、精简的网站，还是高度灵活的Web应用程序，或者超越HTTP的服务，我们都必须在某个时候部署我们的创作。
- en: This chapter focuses on what it takes to bring our Node apps live.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了将我们的Node应用程序上线所需的步骤。
- en: Deploying to a server environment
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到服务器环境
- en: 'Virtual Private Servers (VPS), Dedicated Servers, or Infrastructure as a Service
    (IaaS for example, the likes of Amazon EC2 or Rackspace) and owning our own server
    machines all have one thing in common: total control over the server environment.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟专用服务器（VPS）、专用服务器或基础设施即服务（例如，亚马逊EC2或Rackspace等）以及拥有我们自己的服务器机器都有一个共同点：对服务器环境的完全控制。
- en: However, with great power comes great responsibility, and there are a few challenges
    we need to be aware of. This recipe will demonstrate how to overcome these challenges
    as we safely initialize a Node web app on port `80`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，伴随着巨大的权力而来的是巨大的责任，我们需要意识到一些挑战。本配方将演示如何克服这些挑战，安全地在端口`80`上初始化一个Node Web应用程序。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will, of course, need a remote server environment (or our own setup). It's
    important to research the best package for our needs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要一个远程服务器环境（或我们自己的设置）。研究找到最适合我们需求的最佳套餐非常重要。
- en: Dedicated Servers can be expensive. The hardware to software ratio is one to
    one, we're literally renting a machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 专用服务器可能很昂贵。硬件与软件的比例是一比一，我们实际上是在租用一台机器。
- en: VPS can be cheaper since they share the resources of a single machine (or cluster),
    so we're only renting out the resources it takes to host an instance of an operating
    system. However, if we begin to use resources beyond those assigned, we could
    hit penalties (downtime, excessive charges) since over usage can affect other
    VPS users.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: VPS可能更便宜，因为它们共享单台机器（或集群）的资源，因此我们只租用托管操作系统实例所需的资源。然而，如果我们开始使用超出分配的资源，我们可能会受到处罚（停机时间，额外费用），因为过度使用可能会影响其他VPS用户。
- en: IaaS can be relatively cheap, particularly when up-scaling is involved (when
    we need more resources), though IaaS tends to contain a pay-as-you-go element
    to its pricing which means the costs aren't fixed and could require extra monitoring.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IaaS可能相对便宜，特别是在涉及扩展时（当我们需要更多资源时），尽管IaaS往往包含按使用量计费的元素，这意味着成本不是固定的，可能需要额外的监控。
- en: Our recipe assumes the usage of a Unix/Linux server with the `sshd` (SSH Service)
    running. Furthermore, we should have a domain pointed at our server. In this recipe,
    we'll assume the domain name as `nodecookbook.com`. Finally, we must have Node
    installed on our remote server. If difficulties arise, we can use the instructions
    available at [https://www.github.com/joyent/node/wiki/Installation](https://www.github.com/joyent/node/wiki/Installation),
    or for installing via a package manager we can use the instructions at [https://www.github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://www.github.com/joyent/node/wiki/Installing-Node.js-via-package-manager).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配方假设使用运行`sshd`（SSH服务）的Unix/Linux服务器。此外，我们应该有一个指向我们服务器的域名。在这个配方中，我们将假设域名为`nodecookbook.com`。最后，我们必须在远程服务器上安装Node。如果出现困难，我们可以使用[https://www.github.com/joyent/node/wiki/Installation](https://www.github.com/joyent/node/wiki/Installation)上提供的说明，或者通过包管理器安装，我们可以使用[https://www.github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://www.github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)上的说明。
- en: We'll be deploying the `login` app from the second-to-last recipe of[Chapter
    6](ch06.html "Chapter 6. Accelerating Development with Express"), *Accelerating
    Development with Express*, so we need this at hand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从[第6章](ch06.html "第6章。使用Express加速开发")*使用Express加速开发*的倒数第二个配方中部署`login`应用程序，所以我们需要这个。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To ready our app for transfer to the remote server, we''ll remove the `node_modules`
    folder (we can rebuild it on the server):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备我们的应用程序传输到远程服务器，我们将删除`node_modules`文件夹（我们可以在服务器上重建它）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we compress the `login` directory by executing the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过执行以下命令压缩`login`目录：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will generate a compressed archive named after the app's name and version
    as given in the `package.json` file, which will generate the filename `application-name-0.0.1.tgz`
    for an untouched Express generated `package.json` file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个压缩的存档，名称与`package.json`文件中给出的应用程序名称和版本相同，对于未经修改的Express生成的`package.json`文件，将生成文件名`application-name-0.0.1.tgz`。
- en: Whatever `npm pack` called it, let's rename it to `login.tgz:`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`npm pack`称其为什么，让我们将其重命名为`login.tgz`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we upload `login.tgz` to our server. For example, we could use SFTP:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`login.tgz`上传到我们的服务器。例如，我们可以使用SFTP：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once logged in to the via SFTP, we can issue the following commands:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过SFTP登录，我们可以发出以下命令：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's not necessary to upload to the `/var/www` directory, it's just a natural
    place to put a website.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将上传到`/var/www`目录并不是必需的，这只是放置网站的一个自然位置。
- en: This assumes that we have SFTPed into our server from the directory holding
    `login.tgz`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '这假设我们已经通过SFTP从包含`login.tgz`的目录SFTP到我们的服务器。 '
- en: 'Next, we SSH into the server:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过SSH登录到服务器：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If we''re using a Windows desktop, we could SFTP and SSH into our server using
    putty: [http://www.chiark.greenend.org.uk/~sgtatham/putty/](http://www.chiark.greenend.org.uk/~sgtatham/putty/).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Windows桌面，我们可以使用putty进行SFTP和SSH登录到我们的服务器：[http://www.chiark.greenend.org.uk/~sgtatham/putty/](http://www.chiark.greenend.org.uk/~sgtatham/putty/)。
- en: Once logged in to the remote server, we navigate to `/var/www` and decompress
    `login.tar.gz:`
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦登录到远程服务器，我们就导航到`/var/www`并解压`login.tar.gz`：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As `login.tar.gz` decompresses, it recreates our `login` folder on the server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当`login.tar.gz`解压缩时，它会在服务器上重新创建我们的`login`文件夹。
- en: To rebuild the `node_modules` folder, we enter the `login` folder and use `npm`
    to regenerate the dependencies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要重建`node_modules`文件夹，我们进入`login`文件夹并使用`npm`重新生成依赖项。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Most servers have a shell-based editor, such as `nano, vim`, or `emacs`. We
    can use one of these editors to change one line in `app.js` (or otherwise SFTP
    over a modified `app.js):`
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务器都有基于shell的编辑器，如`nano，vim`或`emacs`。我们可以使用这些编辑器之一来更改`app.js`中的一行（或者通过SFTP传输修改后的`app.js`）：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're now listening on the standard HTTP port, meaning we can access our app
    without suffixing a port number to its web address. However, since we'll be starting
    the app as `root` (necessary in order to bind to port `80)`, we also pass a callback
    to the `listen` method which changes access privileges of the app from `root`
    to `www-data`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在监听标准HTTP端口，这意味着我们可以访问我们的应用程序而无需在其Web地址后加上端口号。但是，由于我们将以`root`身份启动应用程序（为了绑定到端口`80`是必要的），我们还将回调传递给`listen`方法，该方法将应用程序的访问权限从`root`更改为`www-data`。
- en: 'In some cases, dependent upon file permissions, reading or writing to files
    from our app may no longer work. We can fix this by changing ownership:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，根据文件权限，从我们的应用程序读取或写入文件可能不再起作用。我们可以通过更改所有权来解决这个问题：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we can start our app with:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以用以下方式启动我们的应用程序：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can ensure that our app is running as `www-data` with:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确保我们的应用程序正在作为`www-data`运行：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We modified `app.listen` to bind to port `80` and added a callback function
    that resets the user ID from `root` to `www-data`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了`app.listen`以绑定到端口`80`，并添加了一个回调函数，该函数将用户ID从`root`重置为`www-data`。
- en: Adding a callback to `listen` isn't limited to Express, it works the same way
    with a plain `httpServer` instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 向`listen`添加回调不仅限于Express，它在使用普通的`httpServer`实例时也是一样的。
- en: Running a web server as `root` is bad practice. If our app was compromised by
    an attacker, they would have `root` access to our system via our app's privileged
    status.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以`root`身份运行Web服务器是不好的做法。如果我们的应用程序被攻击者入侵，他们将通过我们应用程序的特权状态获得对我们系统的`root`访问权限。
- en: To demote our app, we call `process.setuid` and pass in `www-data. process.setuid`.
    This takes either the name of a user, or the user's UID. By passing in a name,
    we cause `process.setuid` to block the event loop (essentially freezing operations)
    while it cross-references the user string to its UID. This eliminates the potential
    sliver of time where the app is bound to port `80` and also running as `root`.
    In essence, passing a string to `process.setuid` instead of the underlying UID
    means nothing can happen until the app is no longer `root`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了降级我们的应用程序，我们调用`process.setuid`并传入`www-data. process.setuid`。这要么是用户的名称，要么是用户的UID。通过传递一个名称，我们导致`process.setuid`阻塞事件循环（基本上冻结操作），同时它交叉引用用户字符串到其UID。这消除了应用程序绑定到端口`80`并作为`root`运行的潜在时间。实质上，将字符串传递给`process.setuid`而不是底层UID意味着在应用程序不再是`root`之前什么都不会发生。
- en: We call our process with `nohup` and follow up with the ampersand (&). This
    means we freely end our SSH session without causing our app to terminate along
    with the session.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`nohup`调用我们的进程，然后跟上`&`。这意味着我们可以自由结束我们的SSH会话，而不会导致我们的应用程序随着会话终止而终止。
- en: The ampersand turns our process into a background task, so we can do other things
    (like `exit)` while it runs. `nohup` means ignore the hangup signal (HUP). HUP
    is sent to any running processes initiated via SSH whenever the SSH session is
    terminated. Essentially, using `nohup` allows our web app to outlive the SSH session.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安德符号将我们的进程转换为后台任务，因此我们可以在其运行时做其他事情（比如`退出`）。`nohup`意味着忽略挂断信号（HUP）。每当SSH会话终止时，HUP被发送到通过SSH启动的任何运行进程。基本上，使用`nohup`允许我们的Web应用程序在SSH会话结束后继续存在。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are other ways to start our app independent from our session, and to bind
    to port `80` without running the app as `root`. Plus, we can also run multiple
    apps and proxy them to port `80` with `http-proxy`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以独立于我们的会话启动我们的应用程序，并绑定到端口`80`而不以`root`身份运行应用程序。此外，我们还可以运行多个应用程序并使用`http-proxy`将它们代理到端口`80`。
- en: Using screen instead of nohup
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`screen`而不是`nohup`
- en: 'An alternative to using `nohup` to achieve independence from our SSH session
    is `screen`. We would use it as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实现与使用`nohup`独立于我们的SSH会话的另一种方法是使用`screen`。我们将使用它如下：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This would give us a virtual terminal, from which we could say:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个虚拟终端，我们可以说：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we could leave the virtual terminal by pressing `Ctrl + A` followed by
    `D`. We would return to our initial terminal. The virtual terminal would continue
    to run after we had logged out of SSH. We could also log back in to SSH at any
    time and say:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过按下`Ctrl + A`，然后按`D`来离开虚拟终端。我们将返回到我们最初的终端。虚拟终端将在我们注销SSH后继续运行。我们随时可以重新登录SSH并说：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Where we would be able to see any console output and stop `(Ctrl + C)` and start
    the app.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里我们可以看到任何控制台输出并停止`(Ctrl + C)`和启动应用程序。
- en: Using authbind for privileged ports
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用特权端口的authbind
- en: 'For this example, we should SSH into our server as a non-root user:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们应该以非root用户的身份SSH到我们的服务器：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An alternative way to bind to port `80` is with `authbind`, which can be installed
    via our server''s package manager. For instance, if our package manager is `apt-get`
    we could say:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到端口`80`的另一种方法是使用`authbind`，可以通过我们服务器的软件包管理器安装。例如，如果我们的软件包管理器是`apt-get`，我们可以说：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`authbind` works by preempting the operating system policies on port binding
    and exploiting an environment variable called `LD_PRELOAD` upon execution. Therefore,
    it never needs to be run with `root` privileges.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`authbind`通过抢占端口绑定的操作系统策略并在执行时利用一个名为`LD_PRELOAD`的环境变量来工作。因此，它永远不需要以`root`权限运行。'
- en: 'To get it working for us we have to perform some simple configuration work
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使它为我们工作，我们必须进行一些简单的配置工作，如下所示：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This tells `authbind` to allow the user `dave` to bind processes to port `80`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`authbind`允许用户`dave`将进程绑定到端口`80`。
- en: 'We no longer need to change the process UID, so we edit the penultimate line
    of `app.js` to:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要更改进程UID，因此我们编辑`app.js`的倒数第二行为：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We should also change ownership of the `login` folder as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该按以下方式更改`login`文件夹的所有权：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we can start our server without touching the `root` access at all:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在完全不触及`root`访问的情况下启动我们的服务器：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`authbind` can cause our app to work out of the box, no modifications necessary.
    However, it currently lacks IPv6 support so it''s not yet future-proof.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`authbind`可以使我们的应用立即运行，无需任何修改。但是，它目前缺乏IPv6支持，因此尚不具备未来的兼容性。'
- en: Hosting multiple processes from port 80
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从端口80托管多个进程
- en: What about serving multiple processes with the default HTTP port?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用默认HTTP端口提供多个进程？
- en: We can achieve this with the third-party `http-proxy` module.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用第三方`http-proxy`模块来实现这一点。
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's say we have two apps one (our `login` app) to be hosted at `login.nodecookbook.com`
    and the other (the `server.js` file from the very first recipe of this book) to
    be simply at `nodecookbook.com`. Both domains point to the same IP.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个应用程序，一个（我们的`login`应用程序）托管在`login.nodecookbook.com`，另一个（本书第一个示例中的`server.js`文件）简单地托管在`nodecookbook.com`。这两个域指向同一个IP。
- en: '`server.js` will be listening on port `8080`, and we''ll modify `login/app.js`
    to listen again to port `3000` as shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.js`将监听端口`8080`，我们将修改`login/app.js`以再次监听端口`3000`，如下面的代码所示：'
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We also added a second argument defining what address to bind to (rather than
    any address). This prevents our server from being accessed by port.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了第二个参数，定义绑定到哪个地址（而不是任何地址）。这可以防止我们的服务器通过端口被访问。
- en: 'Let''s create a file in a new folder, call it `proxy.js`, and write the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个新文件夹中创建一个文件，称之为`proxy.js`，并写入以下内容：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The object passed to `createServer` contains a router property, which in turn
    is an object instructing `http-proxy` to route incoming traffic on a particular
    domain to the correct locally-hosted process according to its port.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`createServer`传递的对象包含一个路由器属性，该属性本身是一个对象，指示`http-proxy`根据其端口将特定域上的传入流量路由到正确的本地托管进程。'
- en: We finish off by binding to port `80` and degrading from `root` to `www-data`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们绑定到端口`80`，并从`root`降级到`www-data`。
- en: 'To initialize, we must do:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化，我们必须执行：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since we're binding our proxy server to port `80`, these commands must be run
    as `root`. If we're operating SSH with a non-root account, we simply prefix these
    three commands with `sudo`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将代理服务器绑定到端口`80`，这些命令必须以`root`身份运行。如果我们正在使用非root帐户操作SSH，我们只需在这三个命令前加上`sudo`。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Automatic crash recovery* discussed in this chapter'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章讨论的自动崩溃恢复*'
- en: '*Continuous deployment* discussed in this chapter'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章讨论的持续部署*'
- en: '*Hosting with a Platform as a Service provider* discussed in this chapter'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章讨论的作为服务提供商的平台托管*'
- en: Automatic crash recovery
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动崩溃恢复
- en: When we create a site, server and site logic is all tied up in one process.
    Whereas with other platforms, the server code is already in place. If our site
    code has bugs, the server is very unlikely to crash, and thus in many cases the
    site can stay active even if one part of it is broken.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个站点时，服务器和站点逻辑都绑定在一个进程中。而在其他平台上，服务器代码已经就位。如果我们的站点代码有错误，服务器很不可能崩溃，因此在许多情况下，即使其中一部分出现问题，站点也可以保持活动状态。
- en: With a Node-based website, a small bug can crash the entire process, and this
    bug may only be triggered once in a blue moon.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Node的网站，一个小错误可能会导致整个进程崩溃，而这个错误可能只会在很长时间内触发一次。
- en: As a hypothetical example, the bug could be related to character encoding on
    POST requests. When someone like Felix Geisendörfer completes and submits a form,
    suddenly our entire server crashes because it can't handle umlauts.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个假设的例子，错误可能与POST请求的字符编码有关。当像Felix Geisendörfer这样的人完成并提交表单时，突然间我们整个服务器崩溃了，因为它无法处理变音符号。
- en: In this recipe, we'll look at using Upstart, an event-driven init service available
    for Linux servers, which isn't based upon Node, but is nevertheless a very handy
    accomplice.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Upstart，这是一个可用于Linux服务器的事件驱动的init服务，它不是基于Node，但仍然是一个非常方便的助手。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need Upstart installed on our server. [http://upstart.ubuntu.com](http://upstart.ubuntu.com)
    contains instructions on how to download and install. If we're already using an
    Ubuntu or Fedora remote server then Upstart will already be integrated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在服务器上安装Upstart。[http://upstart.ubuntu.com](http://upstart.ubuntu.com)包含有关如何下载和安装的说明。如果我们已经在使用Ubuntu或Fedora远程服务器，则Upstart将已经集成。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s make a new server that purposefully crashes when we access it via HTTP:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的服务器，当我们通过HTTP访问它时故意崩溃：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After the first page loads, the server will crash and the site goes offline.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一页加载后，服务器将崩溃，站点将下线。
- en: Let's call this code `server.js` placing it on our remote server under `/var/www/crashingserver`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这段代码称为`server.js`，将其放在远程服务器上的`/var/www/crashingserver`下
- en: Now we create our Upstart configuration file, saving it on our server as `/etc/init/crashingserver.conf`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建我们的Upstart配置文件，将其保存在服务器上的`/etc/init/crashingserver.conf`。
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we initialize our server as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们初始化我们的服务器如下：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we access `http://nodecookbook.com:8080` and refresh the page, our site
    is still accessible. A quick look at `/var/log/crashingserver.log` reveals that
    the server did indeed crash. We could also check our inbox to find the server
    restart notification.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问`http://nodecookbook.com:8080`并刷新页面时，我们的网站仍然可以访问。快速查看`/var/log/crashingserver.log`，我们可以发现服务器确实崩溃了。我们还可以检查我们的收件箱以查找服务器重新启动通知。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The name of the Upstart service is taken from the particular Upstart configuration
    filename. We initiate the `/etc/init/crashingserver.conf` Upstart service with
    `start crashingserver`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Upstart服务的名称取自特定的Upstart配置文件名。我们使用`start crashingserver`来启动`/etc/init/crashingserver.conf`
    Upstart服务。
- en: The first line of the configuration ensures our web server automatically recovers
    even when the operating system on our remote server is restarted (for example,
    due to a power failure or required reboot, and so on).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的第一行确保我们的Web服务器在远程服务器的操作系统重新启动时自动恢复（例如，由于停电或需要重新启动等）。
- en: '`respawn` is declared twice, once to turn on respawning and then to set a `respawn
    limit — a` maximum of 100 restarts every 5 seconds. The limit must be set according
    to our own scenario. If the website is low traffic this number might be adjusted
    to say 10 restarts in 8 seconds.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`respawn`被声明两次，一次用于打开重生，然后设置一个“重生限制 - 每5秒最多100次重启”。限制必须根据我们自己的情况进行设置。如果网站流量较低，这个数字可能会调整为在8秒内重启10次。'
- en: We want to stay alive if at all possible, but if an issue is persistent we can
    take that as a red flag that a bug is having a detrimental effect on user experience
    or system resources.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望尽可能保持在线，但如果问题持续存在，我们可以将其视为一个警示，表明错误对用户体验或系统资源产生了不利影响。
- en: The next line initializes our server as the `www-data` user, and sends output
    to `/var/log/crashingserver.log`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将我们的服务器初始化为`www-data`用户，并将输出发送到`/var/log/crashingserver.log`。
- en: The final line sends out an email just after our server has been started, or
    restarted. This is so we can be notified that there are probably issues to address
    with our server.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行在我们的服务器启动或重新启动后立即发送电子邮件。这样我们就可以得知可能需要解决服务器问题。
- en: There's more...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's implement another Upstart script that notifies us if the server crashes
    beyond its `respawn limit`, plus we'll look at another way to keep our server
    alive.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现另一个Upstart脚本，如果服务器崩溃超出其“重生限制”，我们还将看另一种方法来保持我们的服务器在线。
- en: Detecting a respawn limit violation
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测重生限制违规
- en: If our server exceeds the `respawn limit`, it's likely there is a serious issue
    that should be solved as soon as possible. We need to know about it immediately.
    To achieve this in Upstart, we can create another Upstart configuration file that
    monitors the `crashingserver` daemon, sending an email if the `respawn limit`
    is transgressed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的服务器超出了“重生限制”，很可能存在严重问题，应尽快解决。我们需要立即了解情况。为了在Upstart中实现这一点，我们可以创建另一个Upstart配置文件，监视“crashingserver”守护程序，如果“重生限制”被违反，则发送电子邮件。
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let's save this to `/etc/init/sitedownmon.conf`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把它保存到`/etc/init/sitedownmon.conf`。
- en: 'Then we do:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们做：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We define this Upstart process as a task (it only has one thing to do, after
    which it exits). We don't want it to stay alive after our server has crashed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个Upstart进程定义为一个任务（它只有一件事要做，之后就退出了）。我们不希望在我们的服务器崩溃后它继续存在。
- en: The task is performed when the `crashingserver` daemon has stopped during a
    respawn (for example, when the `respawn limit` has been broken).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当“crashingserver”守护程序在重生期间停止时执行该任务（例如，当“重生限制”被打破时）。
- en: Our script stanza (directive) contains a small bash script that checks for the
    existence of the `JOB` environment variable (in our case, it would be set to `crashingserver)`
    and then sends an email accordingly. If we don't check its existence, a `sitedownmon`
    seems to trigger false positives when it is first started and sends an email with
    an empty `JOB` variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本段（指令）包含一个小的bash脚本，用于检查`JOB`环境变量的存在（在我们的情况下，它将设置为`crashingserver`），然后相应地发送电子邮件。如果我们不检查它的存在，当它首次启动并发送一个带有空`JOB`变量的电子邮件时，`sitedownmon`似乎会触发错误的警报。
- en: 'We could later extend this script to include more web servers, simply by adding
    one line to `sitedownmon.conf` per server:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们可以通过在每个服务器的`sitedownmon.conf`中添加一行来扩展此脚本：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Staying up with forever
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用forever保持在线
- en: There is a simpler Node-based alternative to Upstart called `forever:`
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更简单的基于Node的替代方案叫做`forever:`
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we simply initiate our server with `forever` as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是用以下方式启动我们的服务器：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And then access our site, some of the terminal output will contain the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后访问我们的网站，一些终端输出将包含以下内容：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But we'll still be able to access our site (although it will have crashed and
    been restarted).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然可以访问我们的网站（尽管它已经崩溃并重新启动）。
- en: 'To deploy our site on a remote server, we log in to our server via SSH, install
    `forever` and say:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要在远程服务器上部署我们的网站，我们通过SSH登录到服务器，安装`forever`并说：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: While this technique is certainly less complex, it's also less robust. Upstart
    provides core kernel functionality and is therefore system critical. If Upstart
    fails, the kernel panics and the whole server restarts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种技术确实较少复杂，但也较不稳健。Upstart提供了核心内核功能，因此是系统关键性的。如果Upstart失败，内核就会发生恐慌，整个服务器就会重新启动。
- en: Nevertheless, `forever` is used widely in production on Nodejitsu's PaaS stack,
    and its attractive simplicity may be viable for less mission-critical production
    environments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Nodejitsu的PaaS堆栈上广泛使用`forever`，其吸引人的简单性可能适用于不太关键的生产环境。
- en: See also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Deploying to a server environment* discussed in this chapter'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了*部署到服务器环境*
- en: '*Hosting with a Platform as a Service provider* discussed in this chapter'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了使用平台即服务提供商进行托管
- en: '*Continuous deployment* discussed in this chapter'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了*持续部署*
- en: Continuous deployment
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续部署
- en: The more streamlined our processes, the more productive we can be. Continuous
    deployment is about committing small ongoing improvements to a production server
    in a time saving, efficient way.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的流程越简化，我们就能更加高效。持续部署是指将小的持续改进提交到生产服务器，以节省时间、高效地进行。
- en: Continuous deployment is especially relevant to team collaboration projects.
    Instead of working on separate forks of the code and spending extra time, money,
    and effort on integration, everyone works on the same code base so integration
    is seamless.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署对团队协作项目尤为重要。与其在代码的不同分支上工作并花费额外的时间、金钱和精力进行集成，不如让每个人都在同一代码库上工作，这样集成就会更加顺畅。
- en: In this recipe, we'll create a deployment flow using Git as a version control
    tool. While this may not be Node, it can certainly boost productivity for coding,
    deploying, and managing Node projects.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Git作为版本控制工具创建部署流程。虽然这可能不是Node，但它肯定可以提高编码、部署和管理Node项目的生产力。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we're a little unfamiliar with Git, we can gain insight from Github's help
    documents, [http://help.github.com](http://help.github.com).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对Git有点陌生，我们可以从Github的帮助文档中获得见解，[http://help.github.com](http://help.github.com)。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We''ll need Git installed on both our server and desktop systems, instructions
    for different systems can be found here [http://book.git-scm.com/2_installing_git.html](http://book.git-scm.com/2_installing_git.html).
    If we''re using Linux with the `apt-get` package manager we can do:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在服务器和桌面系统上都安装Git，不同系统的说明可以在这里找到[http://book.git-scm.com/2_installing_git.html](http://book.git-scm.com/2_installing_git.html)。如果我们使用带有`apt-get`软件包管理器的Linux，我们可以执行：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we are installing Git for the first time, we''ll have to set the personal
    information configuration settings as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是第一次安装Git，我们将不得不按照以下方式设置个人信息配置设置：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We'll be using our `login` app, which we deployed to our server in the first
    recipe. So let's SSH into our server and enter the `/var/www/login` directory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的`login`应用程序，在第一个教程中我们将其部署到服务器上。因此，让我们SSH到服务器并进入`/var/www/login`目录。
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Since we'll not be running our app as root, we'll keep things simple and change
    the listening port in `login/app.js` to `8000:`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将不会以root身份运行我们的应用程序，因此我们将简化事情并将`login/app.js`中的监听端口更改为`8000`：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Once we''ve logged in to our server and installed Git (see *Getting ready)*
    in the `login` folder, we say the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录到服务器并在`login`文件夹中安装了Git（请参阅*准备工作*），我们说：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, we create a bare repository (it has a record of all the changes but no
    actual working files) which we'll be pushing changes to. This helps to keep things
    consistent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个裸存储库（它记录了所有更改，但没有实际的工作文件），我们将向其推送更改。这有助于保持一致。
- en: 'We''ll call the bare repository `repo`, because this is the repository we''ll
    be pushing our changes to and we''ll create it within the `login` folder:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称这个裸存储库为`repo`，因为这是我们将推送更改的存储库，并且我们将在`login`文件夹中创建它：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next. we hook up our bare `repo` to the `login` app repository, and push all
    the commits to `repo`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将裸`repo`连接到`login`应用程序存储库，并将所有提交推送到`repo`。
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we'll write a Git hook that instructs the `login` repository to pull any
    changes from the bare `repo` repository, then restarts our `login` app whenever
    `repo` is updated via a remote Git push.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个Git挂钩，指示`login`存储库从裸`repo`存储库中拉取任何更改，然后在通过远程Git推送更新`repo`时重新启动我们的`login`应用程序。
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With the file open in `nano`, we write the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`nano`中打开文件后，我们编写以下代码：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Saving our hook with *Ctrl* + *O*, then exit with *Ctrl* + *X*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *O*保存我们的挂钩，然后使用*Ctrl* + *X*退出。
- en: 'If we ever make Git commits to the `login` repository, the two repositories
    could go out of sync. To fix this, we create another hook for the `login` repository:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对`login`存储库进行Git提交，这两个存储库可能会不同步。为了解决这个问题，我们为`login`存储库创建另一个挂钩：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We store this in `login/.git/hooks/post-commit`, ensuring it has been made executable
    using `chmod +x post-commit`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其存储在`login/.git/hooks/post-commit`中，并确保使用`chmod +x post-commit`使其可执行。
- en: We'll be making commits to the `repo` remotely via the SSH protocol. Ideally,
    we want to create a system user just for Git interactions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过SSH协议远程向`repo`进行提交。理想情况下，我们希望为Git交互创建一个系统用户。
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We''ve also created home directories for the `git` user to make it easy for
    `forever` to store logs and PID files. We''ll need to make `git` the owner of
    the `login` app, allowing us to manage it using Git through SSH:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为`git`用户创建了主目录，以便`forever`可以轻松存储日志和PID文件。我们需要将`git`设置为`login`应用程序的所有者，以便我们可以通过SSH使用Git来管理它：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally (for the server-side setup), we log in as the `git` user and start our
    app using `forever`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后（对于服务器端设置），我们以`git`用户身份登录并使用`forever`启动我们的应用程序。
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Assuming our server is hosted at `nodecookbook.com`, we could now access the
    `login` app at `http://nodecookbook.com:8000`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的服务器托管在`nodecookbook.com`，我们现在可以在`http://nodecookbook.com:8000`访问`login`应用程序。
- en: 'Back on our desktop, we clone the `repo` repository:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 回到桌面，我们克隆`repo`存储库：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will give us a `repo` directory, containing all the generated files perfectly
    matching our original `login` folder. We can then enter the `repo` folder and
    make a change to our code (say, altering the port in `app.js)`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个`repo`目录，其中包含与我们原始的`login`文件夹完全匹配的所有生成的文件。然后我们可以进入`repo`文件夹并更改我们的代码（比如，在`app.js`中更改端口）。
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Then we commit the change and push to our server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们提交更改并推送到我们的服务器。
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: On the server side, our app should have automatically restarted, resulting in
    our app now being hosted from `http://nodecookbook.com:9000` instead of `http://nodecookbook.com:8000`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们的应用程序应该已自动重新启动，因此我们的应用程序现在是从`http://nodecookbook.com:9000`而不是`http://nodecookbook.com:8000`托管的。
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created two Git repositories. The first is the `login` app itself. When we
    ran `git init`, a `.git` directory was added to the `login` folder. `git add *`
    adds all of the files in the folder and `commit -m "initial commit"` plants our
    additions into Git's version control system. So now our entire code base is recognized
    by Git.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个Git存储库。第一个是`login`应用程序本身。当我们运行`git init`时，`.git`目录将添加到`login`文件夹中。`git
    add *`添加文件夹中的所有文件，`commit -m "initial commit"`将我们的添加放入Git的版本控制系统中。因此，现在我们的整个代码库都被Git识别。
- en: The second is `repo`, which is a created with the `--bare` flag. This is a sort
    of skeleton repository providing all of the expected Git functionality, but lacking
    the actual files (it has no working tree).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`repo`，它是使用`--bare`标志创建的。这是一种骨架存储库，提供了所有预期的Git功能，但缺少实际文件（它没有工作树）。
- en: While it may seem overly complex to use two repositories, it actually simplifies
    things greatly. Since Git does not allow pushes to a branch that is currently
    checked in, we would have to create a separate dummy branch so we can checkout
    of the master and into the dummy branch. This creates problems with the Git hooks
    and restarting our app. The hooks try to start the app for the wrong branch. The
    branches can also quickly become out of sync, and the hooks only add fuel to the
    fire.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用两个存储库可能看起来过于复杂，但实际上大大简化了事情。由于Git不允许将推送到当前签出的分支，因此我们必须创建一个单独的虚拟分支，以便我们可以从主分支签出并进入虚拟分支。这会导致Git挂钩和重新启动我们的应用程序出现问题。挂钩尝试启动错误的分支的应用程序。分支也很快会不同步，而挂钩只会火上浇油。
- en: As `repo` is within the `login` directory, we create a `.gitignore` file telling
    Git to disregard this subdirectory. Even though `login` and `repo` are on the
    same server, we add `repo` as a `remote` repository. This puts some necessary
    distance between the repositories and allows us to later use our first Git hook
    to cause `login` to pull changes from `repo`. A Git push from `repo` to `login`
    wouldn't cause `login` to update its working directory, whereas pulling from `repo`
    into `login` does initiate a merge.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`repo`位于`login`目录中，我们创建一个`.gitignore`文件，告诉Git忽略这个子目录。尽管`login`和`repo`在同一台服务器上，我们将`repo`添加为`remote`存储库。这在存储库之间增加了一些必要的距离，并允许我们稍后使用我们的第一个Git钩子使`login`从`repo`拉取更改。从`repo`到`login`的Git推送不会导致`login`更新其工作目录，而从`repo`到`login`的拉取确实会启动合并。
- en: After our `remote add`, we perform an initial push from the master branch (login)
    to `repo`, now they're singing off the same hymn sheet.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`remote add`之后，我们从主分支（login）向`repo`执行初始推送，现在它们在同一张乐谱上演奏。
- en: Then we created our hooks.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了我们的钩子。
- en: 'Git hooks are executable files which reside in the repository''s `hook` folder.
    There are a variety of available hooks (already in the folder, but suffixed with
    `.sample)`. We used two: `post-update` and `post-commit`. One executes after an
    update (for example, once changes have been pulled and integrated into `repo)`,
    and one after a commit.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Git钩子是可执行文件，驻留在存储库的`hook`文件夹中。有各种可用的钩子（已经在文件夹中，但后缀为`.sample`）。我们使用了两个：`post-update`和`post-commit`。一个在更新后执行（例如，一旦更改已被拉取并集成到`repo`中），另一个在提交后执行。
- en: The first hook, `login/repo/hooks/post-update`, essentially provides our continuous
    deployment functionality. It changes its working directory from `repo` to `login`
    using `cd`, and commands a `git pull`. The `git pull` command is prefixed with
    `env -i`. This prevents problems with certain Git functionality that would otherwise
    execute the Git commands on behalf of `repo` no matter what directory we sent
    our hook script to. Git utilizes a `$GIT_DIR` environment variable to lock us
    in to the repository that the hook is called from. `env -i` deals with this by
    telling `git pull` to ignore (`-i`) all environment variables.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个钩子`login/repo/hooks/post-update`基本上提供了我们的持续部署功能。它使用`cd`将其工作目录从`repo`更改为`login`，并命令`git
    pull`。`git pull`命令前缀为`env -i`。这可以防止某些Git功能出现问题，否则会执行Git命令代表`repo`，无论我们将我们的钩子脚本发送到什么目录。Git利用`$GIT_DIR`环境变量将我们锁定到调用钩子的存储库。`env
    -i`通过告诉`git pull`忽略（`-i`）所有环境变量来处理这个问题。
- en: Having updated the working directory, our hook then goes on to call `forever
    restart`, thus causing our app to reinitialize with the committed changes in place.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 更新工作目录后，我们的钩子继续调用`forever restart`，从而使我们的应用程序重新初始化并应用提交的更改。
- en: Our second hook is little more than a polyfill to ensure code base consistency
    in the event that commits are made directly to the `login` repository. Making
    commits directly to the `login` directory won't update the working tree, nor will
    it cause our app to restart but the code between `login` and `repo` will at least
    maintain synchronicity.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个钩子只是一个填充物，以确保在直接提交到`login`存储库时代码库的一致性。直接向`login`目录提交不会更新工作树，也不会导致我们的应用程序重新启动，但`login`和`repo`之间的代码至少会保持同步。
- en: For the sake of damage limitation (if we were ever compromised), we create a
    specific account for handling Git updates over SSH, giving it a home directory,
    taking ownership of the `login` app and executing the primary initialization of
    our app.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制损害（如果我们曾经受到攻击），我们为处理SSH上的Git更新创建了一个特定的账户，为其提供一个主目录，接管`login`应用程序并执行我们应用程序的主要初始化。
- en: Once the server is configured it's plain sailing. After cloning the `repo` repository
    to our local development environment, we simply make a change, add and commit
    that change, then push to the server.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器配置完成，一切都很顺利。在将`repo`存储库克隆到我们的本地开发环境后，我们只需进行更改，添加和提交，然后推送到服务器。
- en: The server receives our push request, updates `repo`, initiates the `post-update`
    hook which makes `login` pull the changes from `repo`, after which the `post-update`
    hook uses `forever` to restart `app.js`, and thus we have a continuous deployment
    work flow.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接收我们的推送请求，更新`repo`，启动`post-update`钩子，使`login`从`repo`拉取更改，之后`post-update`钩子使用`forever`重新启动`app.js`，因此我们有了一个持续部署工作流程。
- en: We can potentially have as many clones from as many locations as we like, so
    this method lends itself well to geographically-independent team collaboration
    projects both large and small.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从任意位置克隆任意数量的克隆，因此这种方法非常适合于地理位置独立的团队协作项目，无论规模大小。
- en: There's more...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We could avoid uploading modules by using `npm install` in the post-update hook.
    Also, Git hooks don't have to be written in shell script, we can write them in
    Node!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在post-update钩子中使用`npm install`来避免上传模块。此外，Git钩子不一定要用shell脚本编写，我们可以用Node来编写它们！
- en: Building module dependencies on update
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建模块依赖关系的更新
- en: Some Node modules are written in pure JavaScript, others have C or C++ bindings.
    Those with C or C++ bindings have to be built from source — a task which is system
    specific. Unless our live server environment is identical to our development environment,
    we shouldn't simply push code build for one system onto another.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Node模块是纯JavaScript编写的，另一些具有C或C++绑定。具有C或C++绑定的模块必须从源代码构建-这是一个特定于系统的任务。除非我们的实时服务器环境与我们的开发环境完全相同，否则我们不应该简单地将为一个系统构建的代码推送到另一个系统上。
- en: Further, to save on transfer bandwidth and have faster synchronizations, we
    could have our Git hooks install all modules (native bindings and JavaScript)
    and have Git ignore the `node_modules` folder entirely.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，为了节省传输带宽并实现更快的同步，我们可以让我们的Git钩子安装所有模块（本地绑定和JavaScript），并让Git完全忽略`node_modules`文件夹。
- en: 'So in our local repository, let''s do the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的本地存储库中，让我们做以下事情：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then we''ll change the `post-update` hook in our bare remote repository (login/repo/hooks)
    to:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将我们裸远程存储库（login/repo/hooks）中的`post-update`钩子更改为：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We've added`&& npm rebuild && npm install` to the `git pull` line (using`&&`
    to ensure they benefit from the `env -i` command).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`git pull`行中添加了`&& npm rebuild && npm install`（使用`&&`确保它们受益于`env -i`命令）。
- en: Now if we added a module to `package.json`, and did a `git commit -a` followed
    by `git push`, our local `repo` would push the `package.json` to the remote `repo`.
    This would trigger the `post-update` hook to pull changes into the main `login`
    repository, and follow this up with an `npm rebuild` (to rebuild any C / C++ dependencies)
    and an `npm install` (to install any new modules).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们向`package.json`添加了一个模块，并执行了`git commit -a`，然后执行`git push`，我们的本地`repo`将`package.json`推送到远程`repo`。这将触发`post-update`挂钩将更改拉入主`login`存储库，并随后执行`npm
    rebuild`（重新构建任何C / C++依赖项）和`npm install`（安装任何新模块）。
- en: Writing a Node Git hook for integrated testing
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个用于集成测试的Node Git挂钩
- en: Continuous deployment is an extension of continuous integration which generally
    carries the expectation that a thorough test suite is run against any code changes
    for quality assurance.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署是持续集成的延伸，通常期望对任何代码更改运行彻底的测试套件以进行质量保证。
- en: Our `login` app (being a basic demonstration site) doesn't have a test suite
    (for info on test suites, see[Chapter 9](ch09.html "Chapter 9. Writing Your Own
    Node Modules"), *Writing Your Own Node Modules)*, but we can still write a hook
    that executes any tests that could be added to `login` in the future.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`login`应用（作为一个基本的演示站点）没有测试套件（有关测试套件的信息，请参见[第9章](ch09.html "第9章。编写自己的Node模块")中，*编写自己的Node模块*），但我们仍然可以编写一个挂钩，以便在将来为`login`添加任何测试时执行。
- en: What's more, we can write it in Node, which has the added bonus of functioning
    cross platform (on Windows, for example).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以用Node编写它，这样做的额外好处是可以跨平台运行（例如在Windows上）。
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We would place this code on the server into `login/repo/hooks/pre-commit` and
    make it executable (`chmod +x pre-commit)`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这段代码放在服务器上的`login/repo/hooks/pre-commit`中，并使其可执行（`chmod +x pre-commit`）。
- en: The first line sets `node` as the scripts interpreter directive (much as `#!/bin/sh`
    sets the `sh` shell for shell scripts). Now we're in Node country.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将`node`设置为脚本解释器指令（就像`#!/bin/sh`为shell脚本设置`sh` shell一样）。现在我们进入了Node的领域。
- en: We use `npm` programmability, to load the `package.json` file for our app, and
    then run the test script (if any is specified).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`npm`的可编程性，加载我们应用的`package.json`文件，然后运行测试脚本（如果有指定的话）。
- en: 'We then add the following to our `package.json` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将以下内容添加到我们的`package.json`文件中：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then do the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行以下操作：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now whenever we push to `repo`, any changes will only be committed if they pass
    the tests. As long as we have a well-written test suite, this is a great way to
    maintain good code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们推送到`repo`时，只有通过测试的更改才会被提交。只要我们有一个良好编写的测试套件，这是保持良好代码的好方法。
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For our `scripts.test` property, we used `node test` (as In [Chapter 9](ch09.html
    "Chapter 9. Writing Your Own Node Modules"), *Writing Your Own Node Modules)*.
    However, there are more advanced test frameworks available to us, such as Mocha
    [http://visionmedia.github.com/mocha/](http://visionmedia.github.com/mocha/).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`scripts.test`属性，我们使用了`node test`（就像在[第9章](ch09.html "第9章。编写自己的Node模块")中，*编写自己的Node模块*中一样）。然而，我们还可以使用更高级的测试框架，比如Mocha
    [http://visionmedia.github.com/mocha/](http://visionmedia.github.com/mocha/)。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This Node Git hook is adapted (with permission) from a gist by Domenic Denicola,
    which can be found at [https://gist.github.com/2238951](https://gist.github.com/2238951).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Node Git挂钩是根据Domenic Denicola的一个gist（经过许可）进行调整的，可以在[https://gist.github.com/2238951](https://gist.github.com/2238951)找到。
- en: See also
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Deploying to a server environment* discussed in this chapter'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论的*部署到服务器环境*
- en: '*Automatic crash recovery* discussed in this chapter'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论的*自动崩溃恢复*
- en: Creating a test-driven module API discussed In [Chapter 9](ch09.html "Chapter 9. Writing
    Your Own Node Modules"),Writing Your Own Node Modules
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个测试驱动的模块API，在[第9章](ch09.html "第9章。编写自己的Node模块")中讨论，编写自己的Node模块
- en: '*Hosting with a Platform as a Service provider* discussed in this chapter'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论的*使用平台即服务提供商进行托管*
- en: Hosting with a Platform as a Service provider
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平台即服务提供商进行托管
- en: A **Platform as a Service Provider (PaaS)** for Node incorporates all of the
    concepts discussed in the previous three chapters and boils deployment down to
    a very basic, yet powerful, set of commands. When it comes to deployment, PaaS
    can make our lives very easy. With one simple command our app is deployed, and
    with another we can seamlessly update and reinitialize.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Node的**平台即服务提供商（PaaS）**包含了前三章讨论的所有概念，并将部署简化为一组非常基本但强大的命令。在部署方面，PaaS可以让我们的生活变得非常简单。只需一个简单的命令，我们的应用就可以部署，另一个命令可以无缝更新和重新初始化。
- en: In this example, we'll learn how to deploy to Nodejitsu, one of the leading
    Node hosting platform providers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何部署到Nodejitsu，这是领先的Node托管平台提供商之一。
- en: Getting ready
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: First, we'll install `jitsu`, Nodejitsu's deployment and app management command-line
    app.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装`jitsu`，Nodejitsu的部署和应用管理命令行应用程序。
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Before we proceed, we must sign up for an account as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们必须按照以下步骤注册一个帐户：
- en: '[PRE57]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The app will take us through the trivial signup process and create an account
    for us, which we must confirm by email.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将引导我们完成简单的注册过程，并为我们创建一个帐户，我们必须通过电子邮件确认。
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Nodejitsu is not the only Node PaaS, there are others such as no.de, Nodester,
    and Cloud Foundry which follow similar processes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Nodejitsu并不是唯一的Node PaaS，还有其他类似的平台，如no.de、Nodester和Cloud Foundry，它们遵循类似的流程。
- en: 'Once we''ve received our email, we use the provided voucher, for instance:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到了我们的电子邮件，我们就可以使用提供的凭证，例如：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As in the first recipe, we'll use the `login` app from the *Initializing and
    using a session* recipe of[Chapter 6](ch06.html "Chapter 6. Accelerating Development
    with Express"),Accelerating Development with Express
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个示例一样，我们将使用[第6章](ch06.html "第6章。使用Express加速开发")中的*初始化和使用会话*配方中的`login`应用程序，使用`login`应用程序。
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First of all, we enter the `login` folder and make some modifications to `package.json:`
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们进入`login`文件夹并对`package.json`进行一些修改：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: And now we deploy!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们部署！
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If we navigate to our specified subdomain at `http://login.nodejitsu.com`, or
    alternatively `http://login.jit.su`, we will see our `login` app (if a subdomain
    isn't available `jitsu` will suggest alternatives).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`http://login.nodejitsu.com`或者`http://login.jit.su`导航到我们指定的子域，我们将看到我们的`login`应用程序（如果子域不可用，`jitsu`将建议替代方案）。
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We made some modifications to `package.json`. The name of our app is the only
    alteration that is necessarily made by directly editing `package.json`. The other
    additions could have been made on our behalf by the `jitsu` executable. It is
    important to set the name of the app because in `jitsu` apps are managed by their
    name.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`package.json`进行了一些修改。我们的应用程序名称是唯一必须直接编辑`package.json`进行的更改。其他添加可能已经由`jitsu`可执行文件代表我们完成。设置应用程序的名称很重要，因为在`jitsu`中，应用程序是通过其名称进行管理的。
- en: If we had not appended the `subdomain, scripts`, and `engines` properties to
    `package.json, jitsu` would have asked for the particulars when we ran `jitsu
    deploy` and regenerated `package.json` on our behalf.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有将`subdomain, scripts`和`engines`属性附加到`package.json`中，当我们运行`jitsu deploy`并由`jitsu`代表我们重新生成`package.json`时，`jitsu`将要求我们提供详细信息。
- en: '`subdomain` specifies the label prefix to `nodejistu.com`, from where we host
    our app (for example, `login.nodejitsu.com). scripts`, with the `start` sub-property
    informs Nodejitsu of our ignition script, the file that starts the app. `engines`
    defines which versions of Node our app is designed for.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`subdomain`指定了`nodejistu.com`的标签前缀，我们从中托管我们的应用程序（例如，`login.nodejitsu.com`）。`scripts`，带有`start`子属性，通知Nodejitsu我们的启动脚本，启动应用程序的文件。`engines`定义了我们的应用程序设计的Node的哪些版本。'
- en: There's more...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's find out how to access our Nodejitsu app via a custom domain, and how
    to provision a database backend through the `jitsu` executable.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过自定义域名访问我们的Nodejitsu应用，并通过`jitsu`可执行文件为其提供数据库后端。
- en: Assigning custom domains to Nodejitsu apps
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为Nodejitsu应用分配自定义域名
- en: 'To prepare our app for serving through a custom domain, we make an amendment
    to `package.json` as shown in the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的应用程序准备通过自定义域名提供服务，我们对`package.json`进行了修改，如下所示：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then we push our changes with `jitsu` as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`jitsu`推送我们的更改，如下所示：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The app is now ready to receive traffic via [http://login.nodecookbook.com](http://login.nodecookbook.com),
    but before traffic can reach it, we must match our domain's A records with those
    of Nodejitsu.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已准备好通过[http://login.nodecookbook.com](http://login.nodecookbook.com)接收流量，但在流量到达之前，我们必须将我们的域的A记录与Nodejitsu的A记录匹配。
- en: 'We can get the current list of Nodejitsu A records with `dig` (or a similar
    command-line app):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`dig`（或类似的命令行应用程序）获取当前的Nodejitsu A记录列表：
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The process for changing A records depends upon our domain providers. We can
    generally find it in the DNS area of our provider's control panel/administration
    area.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 更改A记录的过程取决于我们的域名提供商。通常可以在提供商的控制面板/管理区域的DNS区域找到它。
- en: Provisioning a database with jitsu
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用jitsu为数据库提供服务
- en: In the last recipe of[Chapter 6](ch06.html "Chapter 6. Accelerating Development
    with Express"), *Accelerating Development with Express*, we built a MongoDB backed
    Express app. Now we're going to take the `profiler` app live with Nodejitsu, making
    use of the database provisioning capabilities of `jitsu`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。使用Express加速开发")的最后一个配方中，*使用Express加速开发*，我们构建了一个使用MongoDB支持的Express应用程序。现在我们将使用Nodejitsu将`profiler`应用程序上线，并利用`jitsu`的数据库提供功能。
- en: 'So let''s provision a Mongo database for the profiler database as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们为`profiler`数据库提供一个Mongo数据库，如下所示：
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`jitsu` will provision our database through a third-party database PaaS provider
    (in Mongo''s case, PaaS provider is MongoHQ). The second-to-last line of output
    provides us with the MongoDB URI for our new database, which will look something
    like the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`jitsu`将通过第三方数据库PaaS提供商（在Mongo的情况下，PaaS提供商是MongoHQ）为我们提供数据库。输出的倒数第二行为我们提供了新数据库的MongoDB
    URI，看起来像以下代码：'
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'So we update the second line of `profiler/tools/prepopulate.js` to:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将`profiler/tools/prepopulate.js`的第二行更新为：
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then we run it from the `profiler/tools` folder:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从`profiler/tools`文件夹运行它：
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This fills our remote database with profiles and login data.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将填充我们的远程数据库与配置文件和登录数据。
- en: 'We update our database URI in two other places `profiler/profiles.js` and `profiler/login/login.js`,
    in both places the second line is altered to say:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在另外两个地方`profiler/profiles.js`和`profiler/login/login.js`中更新了我们的数据库URI，在这两个地方，第二行被修改为：
- en: '[PRE68]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, we type the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们输入以下内容：
- en: '[PRE69]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`jitsu` will ask us for certain settings `(subdomain, scripts.start`, and `engines)`,
    we can just press *Enter* and stick with the defaults (unless of course `profiler.nodejitsu.com`
    is already taken, in which case we should choose a different URL).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`jitsu`将要求我们设置某些设置（`子域，scripts.start`和`engines`），我们可以只需按下*Enter*并使用默认设置（除非`profiler.nodejitsu.com`已被占用，这种情况下我们应该选择不同的URL）。'
- en: '`jitsu` will then deploy our app, we should be able to access it at `profiler.nodejitsu.com.`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`jitsu`将部署我们的应用程序，我们应该能够在`profiler.nodejitsu.com`上访问它。
- en: See also
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Deploying to a server environment* discussed in this chapter'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章讨论的*部署到服务器环境'
- en: '*Automatic crash recovery* discussed in this chapter'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章讨论的*自动崩溃恢复'
- en: '*Continuous deployment* discussed in this chapter'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章讨论的*持续部署'
