- en: Unit Testing and Functional Testing
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和功能测试
- en: Unit testing has become a primary part of good software development practice.
    It is a method by which individual units of source code are tested to ensure they
    function properly. Each unit is theoretically the smallest testable part of an
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试已成为良好软件开发实践的主要部分。这是一种通过测试源代码的各个单元来确保它们正常运行的方法。每个单元在理论上都是应用程序中最小的可测试部分。
- en: In unit testing, each unit is tested separately, isolating the unit under test
    as much as possible from other parts of the application. If a test fails, you
    would want it to be due to a bug in your code rather than a bug in the package
    that your code happens to use. A common technique is to use mock objects or mock
    data to isolate individual parts of the application from one another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，每个单元都是单独测试的，尽可能地将被测试的单元与应用程序的其他部分隔离开来。如果测试失败，你希望它是由于你的代码中的错误而不是你的代码碰巧使用的包中的错误。一个常见的技术是使用模拟对象或模拟数据来将应用程序的各个部分相互隔离开来。
- en: Functional testing, on the other hand, doesn't try to test individual components.
    Instead, it tests the whole system. Generally speaking, unit testing is performed
    by the development team, while functional testing is performed by a **Quality
    Assurance** (**QA**) or **Quality Engineering** (**QE**) team. Both testing models
    are needed to fully certify an application. An analogy might be that unit testing
    is similar to ensuring that each word in a sentence is correctly spelled, while
    functional testing ensures that the paragraph containing that sentence has a good
    structure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，功能测试并不试图测试单独的组件。相反，它测试整个系统。一般来说，单元测试由开发团队执行，而功能测试由**质量保证**（**QA**）或**质量工程**（**QE**）团队执行。这两种测试模型都需要完全认证一个应用程序。一个类比可能是，单元测试类似于确保句子中的每个单词都拼写正确，而功能测试确保包含该句子的段落具有良好的结构。
- en: Writing a book requires not just ensuring the words are correctly spelled, but
    ensuring that the words string together as useful grammatically correct sentences
    and chapters that convey the intended meaning. Similarly, a successful software
    application requires much more than ensuring each "unit" correctly behaves. Does
    the system as a whole perform the intended actions?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 写一本书不仅需要确保单词拼写正确，还需要确保单词串成有用的语法正确的句子和传达预期含义的章节。同样，一个成功的软件应用程序需要远不止确保每个“单元”行为正确。整个系统是否执行了预期的操作？
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Assertions as the basis of software tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言作为软件测试的基础
- en: The Mocha unit testing framework and the Chai assertions library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha单元测试框架和Chai断言库
- en: Using tests to find bugs and fix the bug
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试来查找错误并修复错误
- en: Using Docker to manage test infrastructure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker管理测试基础设施
- en: Testing a REST backend service
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试REST后端服务
- en: UI functional testing in a real web browser using Puppeteer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在真实的Web浏览器中使用Puppeteer进行UI功能测试
- en: Improving UI testability with element ID attributes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元素ID属性改进UI可测试性
- en: By the end of this chapter, you will know how to use Mocha, as well as how to
    write test cases for both directly invoked code under test and for testing code
    accessed via REST services. You will have also learned how to use Docker Compose
    to manage test infrastructure, both on your laptop and on the AWS EC2 Swarm infrastructure
    from [Chapter 12](8551a26c-6834-4df6-b392-60a15c20f6ff.xhtml), *Deploying Docker
    Swarm to AWS EC2 with Terraform*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将知道如何使用Mocha，以及如何为直接调用的测试代码和通过REST服务访问的测试代码编写测试用例。你还将学会如何使用Docker Compose来管理测试基础设施，无论是在你的笔记本电脑上还是在来自[第12章](8551a26c-6834-4df6-b392-60a15c20f6ff.xhtml)的AWS
    EC2 Swarm基础设施上，*使用Terraform部署Docker Swarm到AWS EC2*。
- en: That's a lot of territory to cover, so let's get started.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要覆盖的大片领土，所以让我们开始吧。
- en: Assert – the basis of testing methodologies
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Assert - 测试方法学的基础
- en: Node.js has a useful built-in testing tool known as the `assert` module. Its
    functionality is similar to assert libraries in other languages. Namely, it's
    a collection of functions for testing conditions, and if the conditions indicate
    an error, the `assert` function throws an exception. It's not a complete test
    framework by any stretch of the imagination, but it can still be used for some
    amount of testing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js有一个有用的内置测试工具，称为`assert`模块。其功能类似于其他语言中的assert库。换句话说，它是一组用于测试条件的函数，如果条件表明存在错误，`assert`函数会抛出异常。虽然它并不是完整的测试框架，但仍然可以用于一定程度的测试。
- en: At its simplest, a test suite is a series of `assert` calls to validate the
    behavior of the thing being tested. For example, a test suite could instantiate the
    user authentication service, then make an API call and use `assert` methods to
    validate the result, then make another API call to validate its results, and so
    on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，测试套件是一系列`assert`调用，用于验证被测试对象的行为。例如，一个测试套件可以实例化用户认证服务，然后进行API调用并使用`assert`方法验证结果，然后进行另一个API调用来验证其结果，依此类推。
- en: 'Consider the following code snippet, which you can save in a file named `deleteFile.mjs`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，你可以将其保存在名为`deleteFile.mjs`的文件中：
- en: '[PRE0]js\1'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]js\1'
- en: This is what's called a negative test scenario, in that it's testing whether
    requesting to delete a nonexistent file throws the correct error. The `deleteFile`
    function throws an error containing the text that *does not exist* if the file
    to be deleted does not exist.  This test ensures the correct error is thrown and
    would fail if the wrong error is thrown, or if no error is thrown.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的负面测试场景，它测试的是请求删除一个不存在的文件是否会抛出正确的错误。如果要删除的文件不存在，`deleteFile`函数会抛出一个包含*不存在*文本的错误。这个测试确保正确的错误被抛出，如果抛出了错误的错误，或者没有抛出错误，测试将失败。
- en: If you are looking for a quick way to test, the `assert` module can be useful
    when used this way. Each test case would call a function, then use one or more
    `assert` statements to test the results. In this case, the `assert` statements
    first ensure that `err` has some kind of value, then ensures that value is an
    `Error` instance, and finally ensures that the `message` attribute has the expected
    text. If it runs and no messages are printed, then the test passes. But what happens
    if the `deleteFile` callback is never called? Will this test case catch that error?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找一种快速测试的方法，`assert`模块在这种用法下可能很有用。每个测试用例都会调用一个函数，然后使用一个或多个`assert`语句来测试结果。在这种情况下，`assert`语句首先确保`err`具有某种值，然后确保该值是`Error`实例，最后确保`message`属性具有预期的文本。如果运行并且没有消息被打印，那么测试通过。但是如果`deleteFile`回调从未被调用会发生什么？这个测试用例会捕获到这个错误吗？
- en: '[PRE1]js\1'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]js\1'
- en: This, of course, sets up a `package.json` file and installs the required packages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会设置一个`package.json`文件并安装所需的软件包。
- en: Beyond Mocha and Chai, we've installed two additional tools. The first, `cross-env`,
    is one we've used before and it enables cross-platform support for setting environment
    variables on the command line. The second, `npm-run-all`, simplifies using `package.json`
    to drive build or test procedures.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Mocha和Chai之外，我们还安装了两个额外的工具。第一个是`cross-env`，这是我们以前使用过的，它可以在命令行上设置环境变量的跨平台支持。第二个是`npm-run-all`，它简化了使用`package.json`来驱动构建或测试过程。
- en: For the documentation of `cross-env`, go to [https://www.npmjs.com/package/cross-env](https://www.npmjs.com/package/cross-env).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`cross-env`的文档，请访问[https://www.npmjs.com/package/cross-env](https://www.npmjs.com/package/cross-env)。
- en: For the documentation of `npm-run-all`, go to [https://www.npmjs.com/package/npm-run-all](https://www.npmjs.com/package/npm-run-all).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`npm-run-all`的文档，请访问[https://www.npmjs.com/package/npm-run-all](https://www.npmjs.com/package/npm-run-all)。
- en: With the tools set up, we can move on to creating tests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有了设置好的工具，我们可以继续创建测试。
- en: Notes model test suite
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Notes模型测试套件
- en: Because we have several Notes models, the test suite should run against any
    model. We can write tests using the NotesStore API, and an environment variable
    should be used to declare the model to test. Therefore, the test script will load
    `notes-store.mjs` and call functions on the object it supplies. Other environment
    variables will be used for other configuration settings.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们有几个Notes模型，测试套件应该针对任何模型运行。我们可以使用NotesStore API编写测试，并且应该使用环境变量来声明要测试的模型。因此，测试脚本将加载`notes-store.mjs`并调用它提供的对象上的函数。其他环境变量将用于其他配置设置。
- en: Because we've written the Notes application using ES6 modules, we have a small
    item to consider. Older Mocha releases only supported running tests in CommonJS
    modules, so this would require us to jump through a couple of hoops to test Notes
    modules.  But the current release of Mocha does support them, meaning we can freely
    use ES6 modules.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用ES6模块编写了Notes应用程序，所以我们需要考虑一个小问题。旧版的Mocha只支持在CommonJS模块中运行测试，因此这需要我们跳过一些步骤来测试Notes模块。但是当前版本的Mocha支持它们，这意味着我们可以自由使用ES6模块。
- en: We'll start by writing a single test case and go through the steps of running
    that test and getting the results. After that, we'll write several more test cases,
    and even find a couple of bugs. These bugs will give us a chance to debug the
    application and fix any problems. We'll close out this section by discussing how
    to run tests that require us to set up background services, such as a database
    server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个单独的测试用例，并按照运行该测试和获取结果的步骤进行。之后，我们将编写更多的测试用例，甚至找到一些错误。这些错误将给我们一个机会来调试应用程序并解决任何问题。我们将通过讨论如何运行需要设置后台服务的测试来结束本节。
- en: Creating the initial Notes model test case
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建初始Notes模型测试用例
- en: 'In the `test` directory, create a file named `test-model.mjs` containing the
    following. This will be the outer shell of the test suite:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test`目录中，创建一个名为`test-model.mjs`的文件，其中包含以下内容。这将是测试套件的外壳：
- en: '[PRE2]js\1'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]js\1'
- en: What we've done here is create a `test-all` script that will run the test suite
    against the individual NotesStore implementations. We can run this script to run
    every test combination, or we can run a specific script to test just the one combination.
    For example, `test-notes-sequelize-sqlite` will run tests against `SequelizeNotesStore` using
    the SQLite3 database.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是创建一个`test-all`脚本，它将针对各个NotesStore实现运行测试套件。我们可以运行此脚本来运行每个测试组合，或者我们可以运行特定脚本来测试只有一个组合。例如，`test-notes-sequelize-sqlite`将针对使用SQLite3数据库的`SequelizeNotesStore`运行测试。
- en: 'It uses `npm-run-all` to support running the tests in series. Normally, in
    a `package.json` script, we would write this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`npm-run-all`来支持按顺序运行测试。通常，在`package.json`脚本中，我们会这样写：
- en: '[PRE3]js\1'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]js\1'
- en: This, as the test script name suggests, uses SQLite3 as the underlying database,
    storing it in the named file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如测试脚本名称所示，这使用SQLite3作为底层数据库，并将其存储在指定的文件中。
- en: We are missing two combinations, `test-notes-sequelize-mysql` for `SequelizeNotesStore`
    using MySQL and `test-notes-mongodb`, which tests against `MongoDBNotesStore`.
    We'll implement these combinations later.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缺少两种组合，`test-notes-sequelize-mysql`用于使用MySQL的`SequelizeNotesStore`和`test-notes-mongodb`，它测试`MongoDBNotesStore`。我们稍后将实现这些组合。
- en: 'Having automated the run of all test combinations, we can try it out:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 自动运行所有测试组合后，我们可以尝试一下：
- en: '[PRE4]js\1'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]js\1'
- en: Here, we have a `describe` function that defines a test suite containing another
    `describe` function. That's the structure of a nested test suite.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`describe`函数，它定义了一个包含另一个`describe`函数的测试套件。这是嵌套测试套件的结构。
- en: We do not have test cases in the `it` function defined at the moment, but we
    do have the `before` and `after` functions.  These two functions do what they
    sound like; namely, the `before` function runs before all the test cases, while
    the `after` function runs after all the test cases have finished. The `before`
    function is meant to set up conditions that will be tested, while the `after`
    function is meant for teardown.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在`it`函数中没有测试用例，但是我们有`before`和`after`函数。这两个函数的功能就像它们的名字一样；`before`函数在所有测试用例之前运行，而`after`函数在所有测试用例完成后运行。`before`函数旨在设置将被测试的条件，而`after`函数旨在进行拆卸。
- en: In this case, the `before` function adds entries to `NotesStore`, while the
    `after` function removes all entries. The idea is to have a clean slate after
    each nested test suite is executed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`before`函数向`NotesStore`添加条目，而`after`函数删除所有条目。其想法是在每个嵌套测试套件执行后都有一个干净的状态。
- en: The `before` and `after` functions are what Mocha calls a hook. The other hooks
    are `beforeEach` and `afterEach`. The difference is that the `Each` hooks are
    triggered before or after each test case's execution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`before`和`after`函数是Mocha称之为钩子的函数。其他钩子是`beforeEach`和`afterEach`。区别在于`Each`钩子在每个测试用例执行之前或之后触发。'
- en: These two hooks also serve as test cases since the `create` and `destroy` methods
    could fail, in which case the hook will fail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个钩子也充当测试用例，因为`create`和`destroy`方法可能会失败，如果失败，钩子也会失败。
- en: 'Between the `before` and `after` hook functions, add the following test cases:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`before`和`after`钩子函数之间，添加以下测试用例：
- en: '[PRE5]js\1'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]js\1'
- en: Compare the outputs with the descriptive strings in the `describe` and `it`
    functions. You'll see that the structure of this output matches the structure
    of the test suites and test cases. In other words, we should structure them so
    that they have well-structured test output.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出与`describe`和`it`函数中的描述字符串进行比较。您会发现，此输出的结构与测试套件和测试用例的结构相匹配。换句话说，我们应该将它们结构化，使其具有良好结构化的测试输出。
- en: As they say, testing is never completed, only exhausted. So, let's see how far
    we can go before exhausting ourselves.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如他们所说，测试永远不会完成，只会耗尽。所以，在我们耗尽之前，让我们看看我们能走多远。
- en: More tests for the Notes model
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Notes模型的更多测试
- en: 'That wasn''t enough to test much, so let''s go ahead and add some more tests:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不足以进行太多测试，所以让我们继续添加一些测试：
- en: '[PRE6]js\1'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]js\1'
- en: This is what a failed test looks like. Instead of the checkmark, there is a
    number, and the number corresponds to a report below it. In the failure report,
    the `deepEqual` function gave us clear information about how the object fields
    differed. In this case, it is the test we forced to fail because we wanted to
    see how the `deepEqual` function works.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是失败的测试样子。没有勾号，而是一个数字，数字对应下面的报告。在失败报告中，`deepEqual`函数为我们提供了关于对象字段差异的清晰信息。在这种情况下，这是我们故意让`deepEqual`函数失败的测试，因为我们想看看它是如何工作的。
- en: Notice that for the negative tests – where the test passes if an error is thrown
    – we run it in a `try/catch` block. The `throw new Error` line in each case should
    not execute because the preceding code should throw an error. Therefore, we can
    check if the message in that thrown error is the message that arrives, and fail
    the test if that's the case.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于负面测试——如果抛出错误则测试通过——我们在`try/catch`块中运行它。每种情况中的`throw new Error`行不应该执行，因为前面的代码应该抛出一个错误。因此，我们可以检查抛出的错误中的消息是否是到达的消息，并且如果是这种情况，则使测试失败。
- en: Diagnosing test failures
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 诊断测试失败
- en: 'We can add more tests because, obviously, these tests are not sufficient to
    be able to ship Notes to the public. After doing so, and then running the tests
    against the different test combinations, we will find this result for the SQLite3
    combination:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加更多的测试，因为显然，这些测试还不足以能够将Notes发布给公众。这样做之后，运行测试以针对不同的测试组合，我们将在SQLite3组合的结果中找到这个结果：
- en: '[PRE7]js\1'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]js\1'
- en: If this receives an empty result, an error is thrown. While the database doesn't
    see empty results set as an error, Notes does. Furthermore, Notes already knows
    how to deal with a thrown error in this case. Make this change and that particular
    test case will pass.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这收到一个空结果，就会抛出一个错误。虽然数据库不会将空结果集视为错误，但Notes会。此外，Notes已经知道如何处理这种情况下抛出的错误。进行这个更改，那个特定的测试用例就会通过。
- en: 'There is a second similar error in the `destroy` logic. In SQL, it obviously
    is not an SQL error if this SQL (from `models/notes-sqlite3.mjs`) does not delete
    anything:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`destroy`逻辑中还有第二个类似的错误。在SQL中，如果这个SQL（来自`models/notes-sqlite3.mjs`）没有删除任何内容，这显然不是一个SQL错误：'
- en: '[PRE8]js\1'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]js\1'
- en: Therefore, we read the note and, as a byproduct, we verify the note exists.
    If the note doesn't exist, `read` will throw an error, and the `DELETE` operation
    will not even run.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们读取笔记，并且作为副产品，我们验证笔记是否存在。如果笔记不存在，`read`将抛出一个错误，而`DELETE`操作甚至不会运行。
- en: 'When we run `test-notes-sequelize-sqlite`, there is also a similar failure
    in its `destroy` method. In `models/notes-sequelize.mjs`, make the following change:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`test-notes-sequelize-sqlite`时，它的`destroy`方法也出现了类似的失败。在`models/notes-sequelize.mjs`中，进行以下更改：
- en: '[PRE9]js\1'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]js\1'
- en: As with the other NotesStore implementations, this reads the Note before trying
    to destroy it. If the `read` operation fails, then the test case sees the expected
    error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他NotesStore实现一样，在销毁之前先读取Note。如果`read`操作失败，那么测试用例会看到预期的错误。
- en: These are the bugs we referred to in [Chapter 7](ae8529e5-3a08-45cc-89e9-82895eb45641.xhtml), *Data
    Storage and Retrieval*. We simply forgot to check for these conditions in this
    particular model. Thankfully, our diligent testing caught the problem. At least,
    that's the story to tell the managers rather than telling them that we forgot
    to check for something we already knew could happen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们在[第7章](ae8529e5-3a08-45cc-89e9-82895eb45641.xhtml)中提到的错误，*数据存储和检索*。我们只是忘记在这个特定模型中检查这些条件。幸运的是，我们勤奋的测试捕捉到了问题。至少，这是要告诉经理的故事，而不是告诉他们我们忘记检查我们已经知道可能发生的事情。
- en: Testing against databases that require server setup – MySQL and MongoDB
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对需要服务器设置的数据库进行测试——MySQL和MongoDB
- en: That was good, but we obviously won't run Notes in production with a database
    such as SQLite3 or Level. We can run Notes against the SQL databases supported
    by Sequelize (such as MySQL) and against MongoDB. Clearly, we've been remiss in
    not testing those two combinations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但显然我们不会在生产中使用SQLite3或Level等数据库运行Notes。我们可以在Sequelize支持的SQL数据库（如MySQL）和MongoDB上运行Notes。显然，我们疏忽了没有测试这两种组合。
- en: 'Our test results matrix reads as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试结果矩阵如下：
- en: '`notes-fs`: PASS'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes-fs`: 通过'
- en: '`notes-memory`: PASS'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes-memory`: 通过'
- en: '`notes-level`: 1 failure, now fixed'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes-level`: 1个失败，现已修复'
- en: '`notes-sqlite3`: 2 failures, now fixed'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes-sqlite3`: 2个失败，现已修复'
- en: '`notes-sequelize`: With SQLite3: 1 failure, now fixed'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes-sequelize`: 使用SQLite3：1个失败，现已修复'
- en: '`notes-sequelize`: With MySQL: untested'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes-sequelize`: 使用MySQL：未经测试'
- en: '`notes-mongodb`: Untested'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes-mongodb`: 未经测试'
- en: The two untested NotesStore implementations both require that we set up a database
    server. We avoided testing these combinations, but our manager won't accept that
    excuse because the CEO needs to know we've completed the test cycles. Notes must
    be tested with a configuration similar to the production environments'.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 两个未经测试的NotesStore实现都需要我们设置一个数据库服务器。我们避免测试这些组合，但我们的经理不会接受这个借口，因为CEO需要知道我们已经完成了测试周期。笔记必须使用类似于生产环境的配置进行测试。
- en: In production, we'll be using a regular database server, with MySQL or MongoDB
    being the primary choices. Therefore, we need a way to incur a low overhead to
    run tests against those databases. Testing against the production configuration
    must be so easy that we should feel no resistance in doing so, to ensure that
    tests are run often enough to make the desired impact.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，我们将使用常规的数据库服务器，MySQL或MongoDB是主要选择。因此，我们需要一种低开销的方式来对这些数据库进行测试。对生产配置进行测试必须如此简单，以至于我们在进行测试时不会感到阻力，以确保测试运行得足够频繁，以产生期望的影响。
- en: In this section, we made a lot of progress and have a decent start on a test
    suite for the NotesStore database modules. We learned how to set up test suites
    and test cases in Mocha, as well as how to get useful test reporting. We learned
    how to use `package.json` to drive test suite execution. We also learned about
    negative test scenarios and how to diagnose errors that come up.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们取得了很大的进展，并在NotesStore数据库模块的测试套件上有了一个良好的开端。我们学会了如何在Mocha中设置测试套件和测试用例，以及如何获得有用的测试报告。我们学会了如何使用`package.json`来驱动测试套件执行。我们还学会了负面测试场景以及如何诊断出现的错误。
- en: But we need to work on this issue of testing against a database server. Fortunately,
    we've already worked with a piece of technology that supports easily creating
    and destroying the deployment infrastructure. Hello, Docker!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们需要解决针对数据库服务器进行测试的问题。幸运的是，我们已经使用了一个支持轻松创建和销毁部署基础设施的技术。你好，Docker！
- en: In the next section, we'll learn how to repurpose the Docker Compose deployment
    as a test infrastructure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将Docker Compose部署重新用作测试基础设施。
- en: Using Docker Swarm to manage test infrastructure
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Swarm管理测试基础设施
- en: One advantage Docker gives is the ability to install the production environment
    on our laptop. In [Chapter 12](8551a26c-6834-4df6-b392-60a15c20f6ff.xhtml), *Deploying
    Docker Swarm to AWS EC2 Using Terraform*, we converted a Docker setup that ran
    on our laptop so that it could be deployed on real cloud hosting infrastructure.
    That relied on converting a Docker Compose file into a Docker Stack file, along
    with customization for the environment we built on AWS EC2 instances.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Docker给我们带来的一个优势是能够在我们的笔记本电脑上安装生产环境。在[第12章](8551a26c-6834-4df6-b392-60a15c20f6ff.xhtml)中，*使用Terraform将Docker
    Swarm部署到AWS EC2*，我们将一个在我们的笔记本电脑上运行的Docker设置转换为可以部署在真实云托管基础设施上的设置。这依赖于将Docker Compose文件转换为Docker
    Stack文件，并对我们在AWS EC2实例上构建的环境进行定制。
- en: 'In this section, we''ll repurpose the Stack file as test infrastructure deployed
    to a Docker Swarm. One approach is to simply run the same deployment, to AWS EC2,
    and substitute new values for the `var.project_name` and `var.vpc_name` variables.
    In other words, the EC2 infrastructure could be deployed this way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将将Stack文件重新用作部署到Docker Swarm的测试基础设施。一种方法是简单地运行相同的部署，到AWS EC2，并替换`var.project_name`和`var.vpc_name`变量的新值。换句话说，EC2基础设施可以这样部署：
- en: '[PRE10]js\1'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: As before, this will print a message about the join token. If desired, if you
    have multiple computers in your office, it might be interesting for you to experiment
    with setting up a local Swarm. But for this exercise, that's not important. This
    is because we can do everything required with a single-node Swarm.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，这将打印有关加入令牌的消息。如果需要的话，如果你的办公室有多台电脑，你可能会对设置本地Swarm进行实验感兴趣。但对于这个练习来说，这并不重要。这是因为我们可以用单节点Swarm完成所有需要的工作。
- en: 'This isn''t a one-way street, meaning that when you''re done with this exercise,
    it is easy to turn off swarm mode. Simply shut down anything deployed to your
    local Swarm and run the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是单行道，这意味着当你完成这个练习时，关闭swarm模式是很容易的。只需关闭部署到本地Swarm的任何内容，并运行以下命令：
- en: '[PRE11]js\1'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: This deletes the placement constraints we declared for use on AWS EC2 and sets
    it to one replica for each service. For a single-node cluster, we don't worry
    about placement, of course, and there is no need for more than one instance of
    any service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除我们在AWS EC2上声明的放置约束，并将其设置为每个服务的一个副本。对于单节点集群，当然我们不用担心放置，也没有必要多个服务实例。
- en: For the database services, remove the `volumes` tag. Using this tag is required
    when it's necessary to persist in the database data directory. For test infrastructure,
    the data directory is unimportant and can be thrown away at will. Likewise, remove
    the top-level `volumes` tag.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库服务，删除`volumes`标签。当需要在数据库数据目录中持久保存数据时，使用此标签是必需的。对于测试基础设施，数据目录并不重要，可以随意丢弃。同样，删除顶级`volumes`标签。
- en: 'For the `svc-notes` and `svc-userauth` services, make these changes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`svc-notes`和`svc-userauth`服务，进行以下更改：
- en: '[PRE12]js\1'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: We run `swarm init` to turn on swarm mode on our laptop, then add the two `TWITTER`
    secrets to the swarm. Since it is a single-node swarm, we don't need to run a
    `docker swarm join` command to add new nodes to the swarm.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行`swarm init`在我们的笔记本上打开swarm模式，然后将两个`TWITTER`秘密添加到swarm中。由于它是单节点swarm，我们不需要运行`docker
    swarm join`命令来添加新节点到swarm中。
- en: 'Then, in the `compose-stack-test-local` directory, we can run these commands:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`compose-stack-test-local`目录中，我们可以运行这些命令：
- en: '[PRE13]js\1'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: Because this is a single-host swarm, we don't need to use SSH to access the
    swarm nodes, nor do we need to set up remote access using `docker context`. Instead,
    we run the Docker commands, and they act on the Docker instance on the localhost.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '因为这是单主机swarm，我们不需要使用SSH访问swarm节点，也不需要使用`docker context`设置远程访问。相反，我们运行Docker命令，它们会在本地主机上的Docker实例上执行。 '
- en: 'The `docker ps` command will tell us the precise container name for each service.
    With that knowledge, we can run the following to gain access:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`命令将告诉我们每个服务的精确容器名称。有了这个知识，我们可以运行以下命令来获得访问权限：'
- en: '[PRE14]js\1'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: 'The tests should execute as they did on our laptop, but they''re running inside
    the container instead. However, the MySQL test won''t have run because the `package.json`
    scripts are not set up to run that one automatically. Therefore, we can add this
    to `package.json`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该像在我们的笔记本电脑上一样执行，但是它们是在容器内运行的。但是，MySQL测试不会运行，因为`package.json`脚本没有设置自动运行。因此，我们可以将其添加到`package.json`中：
- en: '[PRE15]js\1'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: The tests should execute correctly against MySQL.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该对MySQL执行正确。
- en: 'To automate this, we can create a file named `run.sh` containing the following
    code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化这一过程，我们可以创建一个名为`run.sh`的文件，其中包含以下代码：
- en: '[PRE16]js\1'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: This runs the preceding script, which will run each test combination individually
    and also make sure the `DEBUG` variable is not set. This variable is set in the
    Dockerfile and causes debugging information to be printed among the test results
    output. Inside the script, the `--workdir` option sets the current directory of
    the command's execution in the `test` directory to simplify running the test scripts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这运行了前面的脚本，将每个测试组合单独运行，并确保`DEBUG`变量未设置。这个变量在Dockerfile中设置，会导致在测试结果输出中打印调试信息。在脚本中，`--workdir`选项将命令的当前目录设置为`test`目录，以简化运行测试脚本。
- en: Of course, this script won't execute as-is on Windows. To convert this for use
    on PowerShell, save the text starting at the second line into `run.ps1`, and then change
    `SVC_NOTES` references into `%SVC_NOTES%` references.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个脚本在Windows上不会直接执行。要将其转换为PowerShell使用，将从第二行开始的文本保存到`run.ps1`中，然后将`SVC_NOTES`引用更改为`%SVC_NOTES%`引用。
- en: We have succeeded in semi-automating test execution for most of our test matrix.
    However, there is a glaring hole in the test matrix, namely the lack of testing
    on MongoDB. Plugging that hole will let us see how we can set up MongoDB under
    Docker.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将大部分测试矩阵的执行部分自动化。但是，测试矩阵中存在一个明显的漏洞，即缺乏对MongoDB的测试。填补这个漏洞将让我们看到如何在Docker下设置MongoDB。
- en: MongoDB setup under Docker and testing Notes against MongoDB
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Docker下设置MongoDB并对Notes进行测试
- en: In [Chapter 7](ae8529e5-3a08-45cc-89e9-82895eb45641.xhtml),* Data Storage and
    Retrieval*, we developed MongoDB support for Notes. Since then, we've focused
    on `Sequelize`. To make up for that slight, let's make sure we at least test our
    MongoDB support. Testing on MongoDB simply requires defining a container for the
    MongoDB database and a little bit of configuration.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ae8529e5-3a08-45cc-89e9-82895eb45641.xhtml)，*数据存储和检索*中，我们为Notes开发了MongoDB支持。从那时起，我们专注于`Sequelize`。为了弥补这一点，让我们确保至少测试我们的MongoDB支持。在MongoDB上进行测试只需要定义一个MongoDB数据库的容器和一点配置。
- en: Visit [https://hub.docker.com/_/mongo/](https://hub.docker.com/_/mongo/) for
    the official MongoDB container. You'll be able to retrofit this in order to deploy
    the Notes application running on MongoDB.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://hub.docker.com/_/mongo/](https://hub.docker.com/_/mongo/)获取官方MongoDB容器。您可以将其改装以部署在MongoDB上运行的Notes应用程序。
- en: 'Add the following code to `compose-stack-test-local/docker-compose.yml`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`compose-stack-test-local/docker-compose.yml`中：
- en: '[PRE17]js\1'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]js\1'
- en: We simply added the MongoDB container to `frontnet`, making the database available
    at the URL shown here. Hence, it's simple to now run the test suite using the
    Notes MongoDB model.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将MongoDB容器添加到了`frontnet`，使得数据库可以在此处显示的URL上使用。因此，现在可以简单地使用Notes MongoDB模型运行测试套件。
- en: The `--no-timeouts` option was necessary to avoid a spurious error while testing
    the suite against MongoDB. This option instructs Mocha to not check whether a
    test case execution takes too long.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`--no-timeouts`选项是必要的，以避免针对MongoDB测试套件时出现错误。此选项指示Mocha不检查测试用例执行是否太长时间。'
- en: 'The final requirement is to add the following line to `run.sh` (or `run.ps1`
    for Windows):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的要求是将以下一行添加到`run.sh`（或`run.ps1`适用于Windows）中：
- en: '[PRE18]js\1'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]js\1'
- en: 'The problem is that the initializer for the MongoClient object has changed
    slightly. Therefore, we must modify `notes/models/notes-mongodb.mjs` with this
    new `connectDB` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于MongoClient对象的初始化程序略有变化。因此，我们必须修改`notes/models/notes-mongodb.mjs`，使用这个新的`connectDB`函数：
- en: '[PRE19]js\1'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]js\1'
- en: This sets up Mocha and the SuperTest client. The `URL_USERS_TEST` environment
    variable specifies the base URL of the server to run the test against. You'll
    almost certainly be using `http://localhost:5858`, given the configuration we've
    used earlier, but it can be any URL pointing to any host. SuperTest initializes
    itself a little differently to SuperAgent.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了Mocha和SuperTest客户端。`URL_USERS_TEST`环境变量指定了要针对其运行测试的服务器的基本URL。鉴于我们之前使用的配置，您几乎肯定会使用`http://localhost:5858`，但它可以是指向任何主机的任何URL。SuperTest的初始化方式与SuperAgent略有不同。
- en: The `SuperTest` module supplies a function, and we call that function with the `URL_USERS_TEST` variable.
    That gives us an object, which we call `request`, that is used for interacting
    with the service under test.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`SuperTest`模块提供了一个函数，我们使用`URL_USERS_TEST`变量调用该函数。这给了我们一个对象，我们称之为`request`，用于与正在测试的服务进行交互。'
- en: We've also set up a pair of variables to store the authentication user ID and
    key. These are the same values that are in the user authentication server. We
    simply need to supply them when making API calls.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了一对变量来存储认证用户ID和密钥。这些值与用户认证服务器中的值相同。我们只需要在进行API调用时提供它们。
- en: 'Finally, there''s the outer shell of the Mocha test suite. So, let''s start
    filling in the `before` and `after` test cases:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是Mocha测试套件的外壳。所以，让我们开始填写`before`和`after`测试用例：
- en: '[PRE20]js\1'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]js\1'
- en: Now, we can test some API methods, such as the `/list` operation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试一些API方法，比如`/list`操作。
- en: We have already guaranteed that there is an account in the `before` method,
    so `/list` should give us an array with one entry.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经保证在`before`方法中有一个帐户，所以`/list`应该给我们一个包含一个条目的数组。
- en: This follows the general pattern for using Mocha to test a REST API method.
    First, we use SuperTest's `request` object to call the API method and `await`
    its result. Once we have the result, we use `assert` methods to validate it is
    what's expected.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了使用Mocha测试REST API方法的一般模式。首先，我们使用SuperTest的`request`对象调用API方法并`await`其结果。一旦我们得到结果，我们使用`assert`方法来验证它是否符合预期。
- en: 'Add the following test cases:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下测试用例：
- en: '[PRE21]js\1'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]js\1'
- en: Finally, we should check the `/destroy` operation. This operation is already
    checked the `after` method, where we `destroy` a known user account. We also need
    to perform the negative test and verify its behavior against an account we know
    does not exist.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该检查`/destroy`操作。这个操作已经在`after`方法中检查过，我们在那里`destroy`了一个已知的用户帐户。我们还需要执行负面测试，并验证其对我们知道不存在的帐户的行为。
- en: The desired behavior is that either an error is thrown or the result shows an
    HTTP `status` indicating an error. In fact, the current authentication server
    code gives a 500 status code, along with some other information.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的行为是抛出错误或结果显示一个指示错误的HTTP `status`。实际上，当前的认证服务器代码给出了500状态码，以及其他一些信息。
- en: This gives us enough tests to move forward and automate the test run.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们足够的测试来继续并自动化测试运行。
- en: 'In `compose-stack-test-local/docker-compose.yml`, we need to inject the `test.js` script
    into the `svc-userauth-test` container. We''ll add that here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compose-stack-test-local/docker-compose.yml`中，我们需要将`test.js`脚本注入到`svc-userauth-test`容器中。我们将在这里添加：
- en: '[PRE22]js\1'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]js\1'
- en: In the dependencies, we list Mocha, Chai, SuperTest, and cross-env. Then, in
    the `test` script, we run Mocha along with the required environment variable. 
    This should run the tests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖项中，我们列出了Mocha，Chai，SuperTest和cross-env。然后，在`test`脚本中，我们运行Mocha以及所需的环境变量。这应该运行测试。
- en: 'We could use this test suite from our laptop. Because the test directory is
    injected into the container the tests, we can also run them inside the container.
    To do so, add the following code to `run.sh`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们的笔记本电脑使用这个测试套件。因为测试目录被注入到容器中，我们也可以在容器内运行它们。要这样做，将以下代码添加到`run.sh`中：
- en: '[PRE23]js\1'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]js\1'
- en: Because `URL_USERS_TEST` can take any URL, we could run the test suite against
    any instance of the user authentication service. For example, we could test an
    instance deployed on AWS EC2 from our laptop using a suitable value for `URL_USERS_TEST`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`URL_USERS_TEST`可以使用任何URL，我们可以针对用户认证服务的任何实例运行测试套件。例如，我们可以使用适当的`URL_USERS_TEST`值从我们的笔记本电脑上测试在AWS
    EC2上部署的实例。
- en: We're making good progress. We now have test suites for both the Notes and User
    Authentication services. We have learned how to test a REST service using the
    REST API. This is different than directly calling internal functions because it
    is an end-to-end test of the complete system, in the role of a consumer of the
    service.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取得了很好的进展。我们现在已经为笔记和用户认证服务准备了测试套件。我们已经学会了如何使用REST API测试REST服务。这与直接调用内部函数不同，因为它是对完整系统的端到端测试，扮演服务的消费者角色。
- en: Our next task is to automate test results reporting.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个任务是自动化测试结果报告。
- en: Automating test results reporting
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试结果报告
- en: It's cool we have automated test execution, and Mocha makes the test results
    look nice with all those checkmarks. But what if management wants a graph of test
    failure trends over time? There could be any number of reasons to report test
    results as data rather than as a user-friendly printout on the console.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经自动化了测试执行，Mocha通过所有这些勾号使测试结果看起来很好。但是，如果管理层想要一个显示测试失败趋势的图表怎么办？报告测试结果作为数据而不是作为控制台上的用户友好的打印输出可能有很多原因。
- en: For example, tests are often not run on a developer laptop or by a quality team
    tester, but by automated background systems. The CI/CD model is widely used, in
    which tests are run by the CI/CD system on every commit to the shared code repository.
    When fully implemented, if the tests all pass on a particular commit, then the
    system is automatically deployed to a server, possibly the production servers.
    In such a circumstance, the user-friendly test result report is not useful, and
    instead, it must be delivered as data that can be displayed on a CI/CD results
    dashboard website.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，测试通常不是在开发人员的笔记本电脑上运行，也不是由质量团队的测试人员运行，而是由自动化后台系统运行。CI/CD模型被广泛使用，其中测试由CI/CD系统在每次提交到共享代码存储库时运行。当完全实施时，如果在特定提交上所有测试都通过，那么系统将自动部署到服务器，可能是生产服务器。在这种情况下，用户友好的测试结果报告是没有用的，而必须以数据的形式传递，可以在CI/CD结果仪表板网站上显示。
- en: Mocha uses what's called a **Reporter** to report test results. A Mocha Reporter
    is a module that prints data in whatever format it supports. More information
    on this can be found on the Mocha website: [https://mochajs.org/#reporters](https://mochajs.org/#reporters).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha使用所谓的**Reporter**来报告测试结果。Mocha Reporter是一个模块，以其支持的任何格式打印数据。有关此信息的更多信息可以在Mocha网站上找到：[https://mochajs.org/#reporters](https://mochajs.org/#reporters)。
- en: 'You will find the current list of available `reporters` like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您将找到当前可用的`reporters`列表如下：
- en: '[PRE24]js\1'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]js\1'
- en: 'In the `npm run script-name` command, we can inject command-line arguments,
    as we''ve done here. The `--` token tells npm to append the remainder of its command
    line to the command that is executed. The effect is as if we had run this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`npm run script-name`命令中，我们可以注入命令行参数，就像我们在这里所做的那样。`--`标记告诉npm将其命令行的其余部分附加到执行的命令上。效果就像我们运行了这个命令：
- en: '[PRE25]js\1'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]js\1'
- en: This installs not just Puppeteer, but Mocha, Chai, and Supertest. We'll also
    be using the `package.json` file to record scripts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅安装了Puppeteer，还安装了Mocha、Chai和Supertest。我们还将使用`package.json`文件记录脚本。
- en: 'During installation, you''ll see that Puppeteer causes Chromium to be downloaded,
    like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，您会发现Puppeteer会导致Chromium被下载，就像这样：
- en: '[PRE26]js\1'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]js\1'
- en: Depending on what you need to do, `docker-compose build` might also be required.
    In any case, this brings up the test infrastructure and lets you see the running
    system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求，可能还需要执行`docker-compose build`。无论如何，这都会启动测试基础架构，并让您看到运行中的系统。
- en: We can use a browser to visit `http://localhost:3000` and so on. Because this
    system won't contain any users, our test script will have to add a test user so
    that the test can log in and add notes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用浏览器访问`http://localhost:3000`等网址。因为这个系统不包含任何用户，我们的测试脚本将不得不添加一个测试用户，以便测试可以登录并添加笔记。
- en: Another item of significance is that tests will be running in an anonymous Chromium
    instance. Even if we use Chrome as our normal desktop browser, this Chromium instance
    will have no connection to our normal desktop setup. That's a good thing from
    a testability standpoint since it means your test results will not be affected
    by your personal web browser configuration. On the other hand, it means Twitter
    login testing is not possible, because that Chromium instance does not have a
    Twitter login session.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事项是测试将在一个匿名的Chromium实例中运行。即使我们在正常的桌面浏览器中使用Chrome，这个Chromium实例也与我们正常的桌面设置没有任何连接。从可测试性的角度来看，这是一件好事，因为这意味着您的测试结果不会受到个人网络浏览器配置的影响。另一方面，这意味着无法进行Twitter登录测试，因为该Chromium实例没有Twitter登录会话。
- en: With those things in mind, let's write an initial test suite. We'll start with
    a simple initial test case to prove we can run Puppeteer inside Mocha. Then, we'll
    test the login and logout functionality, the ability to add notes, and a couple
    of negative test scenarios. We'll close this section with a discussion on improving
    testability in HTML applications. Let's get started.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些，让我们编写一个初始的测试套件。我们将从一个简单的初始测试用例开始，以证明我们可以在Mocha中运行Puppeteer。然后，我们将测试登录和注销功能，添加笔记的能力，以及一些负面测试场景。我们将在本节中讨论如何改进HTML应用程序的可测试性。让我们开始吧。
- en: Creating an initial Puppeteer test for the Notes application stack
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Notes应用程序堆栈创建一个初始的Puppeteer测试
- en: 'Our first test goal is to set up the outline of a test suite. We will need
    to do the following, in order:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个测试目标是建立一个测试套件的大纲。我们需要按顺序执行以下操作：
- en: Add a test user to the user authentication service.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向用户身份验证服务添加一个测试用户。
- en: Launch the browser.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动浏览器。
- en: Visit the home page.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问首页。
- en: Verify the home page came up.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证首页是否正常显示。
- en: Close the browser.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器。
- en: Delete the test user.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除测试用户。
- en: This will establish that we have the ability to interact with the launched infrastructure,
    start the browser, and see the Notes application. We will continue with the policy
    and clean up after the test to ensure a clean environment for subsequent test
    runs and will add, then remove, a test user.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保我们有能力与启动的基础架构进行交互，启动浏览器并查看Notes应用程序。我们将继续执行策略并在测试后进行清理，以确保后续测试运行的干净环境，并添加，然后删除，一个测试用户。
- en: 'In the `notesui` directory, create a file named `uitest.mjs` containing the
    following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`notesui`目录中，创建一个名为`uitest.mjs`的文件，其中包含以下代码：
- en: '[PRE27]js\1'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]js\1'
- en: This adds a user to the authentication service. Refer back and you'll see this
    is similar to the test case in the REST test suite. If you want a verification
    phase, there is another test case that calls the `/find/testme` endpoint to verify
    the result. Since we've already verified the authentication system, we do not
    need to reverify it here. We just need to ensure we have a known test user we
    can use for scenarios where the browser must be logged in.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向身份验证服务添加一个用户。回顾一下，您会发现这与REST测试套件中的测试用例类似。如果您需要验证阶段，还有另一个测试用例调用`/find/testme`端点来验证结果。由于我们已经验证了身份验证系统，因此我们不需要在这里重新验证它。我们只需要确保我们有一个已知的测试用户，可以在需要浏览器登录的场景中使用。
- en: 'Keep this at the very end of `uitest.mjs`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放在`uitest.mjs`的最后：
- en: '[PRE28]js\1'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE28]js\1'
- en: Remember that within `describe`, the tests are the `it` blocks. The `before`
    block is executed before all the `it` blocks, and the `after` block is executed
    afterward.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在`describe`中，测试是`it`块。`before`块在所有`it`块之前执行，`after`块在之后执行。
- en: In the `before` function, we set up Puppeteer by launching a Puppeteer instance
    and starting a new Page object. Because `puppeteer.launch` has the `headless`
    option set to `false`, we'll see a browser window on the screen. This will be
    useful so we can see what's happening. The `sloMo` option also helps us see what's
    happening by slowing down the browser interaction. In the `after` function, we
    call the `close` method on those objects in order to close out the browser. The
    `puppeteer.launch` method takes an `options` object, with a long list of attributes
    that are worth learning about.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`before`函数中，我们通过启动Puppeteer实例并启动一个新的Page对象来设置Puppeteer。因为`puppeteer.launch`的`headless`选项设置为`false`，我们将在屏幕上看到一个浏览器窗口。这将很有用，因为我们可以看到发生了什么。`sloMo`选项也通过减慢浏览器交互来帮助我们看到发生了什么。在`after`函数中，我们调用这些对象的`close`方法来关闭浏览器。`puppeteer.launch`方法接受一个`options`对象，其中有很多值得学习的属性。
- en: The `browser` object represents the entire browser instance that the test is
    being run on. In contrast, the `page` object represents what is essentially the
    currently open tab in the browser. Most Puppeteer functions execute asynchronously.
    Therefore, we can use `async` functions and the `await` keywords.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`browser`对象代表正在运行测试的整个浏览器实例。相比之下，`page`对象代表的是实质上是浏览器中当前打开的标签页。大多数Puppeteer函数都是异步执行的。因此，我们可以使用`async`函数和`await`关键字。'
- en: The `timeout` setting is required because it sometimes takes a longish time
    for the browser instance to launch. We're being generous with the timeout to minimize
    the risk of spurious test failures.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeout`设置是必需的，因为有时浏览器实例启动需要很长时间。我们慷慨地设置了超时时间，以最小化偶发测试失败的风险。'
- en: For the `it` clause, we do a tiny amount of browser interaction. Being a wrapper
    around a browser tab, the `page` object has methods related to managing an open
    tab. For example, the `goto` method tells the browser tab to navigate to the given
    URL. In this case, the URL is the Notes home page, which is passed in as an environment
    variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`it`子句，我们进行了少量的浏览器交互。作为浏览器标签页的包装器，`page`对象具有与管理打开标签页相关的方法。例如，`goto`方法告诉浏览器标签页导航到给定的URL。在这种情况下，URL是笔记主页，作为环境变量传递。
- en: The `waitForSelector` method is part of a group of methods that wait for certain
    conditions. These include `waitForFileChooser`, `waitForFunction`, `waitForNavigation`, `waitForRequest`,
    `waitForResponse`, and `waitForXPath`. These, and the `waitFor` method, all cause
    Puppeteer to asynchronously wait for a condition to happen in the browser. The
    purpose of these methods is to give the browser time to respond to some input,
    such as clicking on a button. In this case, it waits until the web page loading
    process has an element visible at the given CSS selector. That selector refers
    to the Login button, which will be in the header.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForSelector`方法是一组等待特定条件的方法之一。这些条件包括`waitForFileChooser`、`waitForFunction`、`waitForNavigation`、`waitForRequest`、`waitForResponse`和`waitForXPath`。这些方法以及`waitFor`方法都会导致Puppeteer异步等待浏览器中发生的某些条件。这些方法的目的是给浏览器时间来响应某些输入，比如点击按钮。在这种情况下，它会等到网页加载过程中在给定的CSS选择器下有一个可见的元素。该选择器指的是在页眉中的登录按钮。'
- en: In other words, this test visits the Notes home page and then waits until the
    Login button appears. We could call that a simple smoke test that's quickly executed
    and determines that the basic functionality is there.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个测试访问笔记主页，然后等待直到登录按钮出现。我们可以称之为一个简单的冒烟测试，快速执行并确定基本功能是否存在。
- en: Executing the initial Puppeteer test
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行初始的Puppeteer测试
- en: 'We have the beginning of a Puppeteer-driven test suite for the Notes application.
    We have already launched the test infrastructure using `docker-compose`. To run
    the test script, add the following to the scripts section of the `package.json` file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经启动了使用`docker-compose`的测试基础设施。要运行测试脚本，请将以下内容添加到`package.json`文件的脚本部分：
- en: '[PRE29]js\1'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE29]js\1'
- en: We have successfully created the structure that we can run these tests in. We
    have set up Puppeteer and the related packages and created one useful test. The
    primary win is to have a structure to build further tests on top of.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地创建了可以运行这些测试的结构。我们已经设置了Puppeteer和相关的包，并创建了一个有用的测试。主要的收获是有一个结构可以在其基础上构建更多的测试。
- en: Our next step is to add more tests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是添加更多的测试。
- en: Testing login/logout functionality in Notes
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在笔记中测试登录/注销功能
- en: In the previous section, we created the outline within which to test the Notes
    user interface. We didn't do much testing regarding the application, but we proved
    that we can test Notes using Puppeteer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了测试笔记用户界面的大纲。关于应用程序的测试并不多，但我们证明了可以使用Puppeteer测试笔记。
- en: 'In this section, we''ll add an actual test. Namely, we''ll test the login and
    logout functionality. The steps for this are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个实际的测试。也就是说，我们将测试登录和注销功能。具体步骤如下：
- en: Log in using the test user identity.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用测试用户身份登录。
- en: Verify that the browser was logged in.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证浏览器是否已登录。
- en: Log out.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注销。
- en: Verify that the browser is logged out.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证浏览器是否已注销。
- en: 'In `uitest.js`, insert the following test code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`uitest.js`中，插入以下测试代码：
- en: '[PRE30]js\1'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]js\1'
- en: With that, our new tests are passing. Notice that the time required to execute
    some of the tests is rather long. Even longer times were observed while debugging
    the test, which is why we set long timeouts.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的新测试都通过了。请注意，执行一些测试所需的时间相当长。在调试测试时观察到了更长的时间，这就是我们设置长超时时间的原因。
- en: That's good, but of course, there is more to test, such as the ability to add
    a Note.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但当然，还有更多需要测试的，比如添加笔记的能力。
- en: Testing the ability to add Notes
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试添加笔记的能力
- en: We have a test case to verify login/logout functionality. The point of this
    application is adding notes, so we need to test this feature. As a side effect,
    we will learn how to verify page content with Puppeteer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个测试用例来验证登录/注销功能。这个应用程序的重点是添加笔记，所以我们需要测试这个功能。作为副作用，我们将学习如何使用Puppeteer验证页面内容。
- en: 'To test this feature, we will need to follow these steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个功能，我们需要按照以下步骤进行：
- en: Log in and verify we are logged in.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录并验证我们已经登录。
- en: Click the Add Note button to get to the form.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加笔记”按钮进入表单。
- en: Enter the information for a Note.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入笔记的信息。
- en: Verify that we are showing the Note and that the content is correct.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们是否显示了笔记，并且内容是正确的。
- en: Click on the Delete button and confirm deleting the Note.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击删除按钮并确认删除笔记。
- en: Verify that we end up on the home page.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们最终进入了主页。
- en: Log out.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注销。
- en: You might be wondering "*Isn't it duplicative to log in again*?" The previous
    tests focused on login/logout. Surely that could have ended with the browser in
    the logged-in state? With the browser still logged in, this test would not need
    to log in again. While that is true, it would leave the login/logout scenario
    incompletely tested. It would be cleaner for each scenario to be standalone in
    terms of whether or not the user is logged in. To avoid duplication, let's refactor
    the test slightly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想“*再次登录不是重复的吗*？”之前的测试集中在登录/注销上。当然，浏览器可能已经处于登录状态了吧？如果浏览器仍然登录，这个测试就不需要再次登录。虽然这是真的，但这会导致登录/注销场景的测试不完整。每个场景在用户是否登录方面都应该是独立的。为了避免重复，让我们稍微重构一下测试。
- en: 'In the `outermost` describe block, add the following two functions:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`最外层`的描述块中，添加以下两个函数：
- en: '[PRE31]js\1'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE31]js\1'
- en: All we've done is move the code that had been here into their own functions.
    This means we can reuse those functions in other tests, thus avoiding duplicative
    code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是将此处的代码移动到它们自己的函数中。这意味着我们可以在其他测试中重用这些函数，从而避免重复的代码。
- en: 'Add the following code for the Note creation test suite to `uitest.mjs`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`uitest.mjs`中的笔记创建测试套件：
- en: '[PRE32]js\1'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]js\1'
- en: All we did was add the ID attribute. This is an example of improving testability,
    which we'll discuss later.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的就是添加了ID属性。这是改进可测试性的一个例子，我们稍后会讨论。
- en: A technique we're using is to call `page.$` to query whether the given element
    is on the page. This method inspects the page, returning an array containing any
    matching elements. We are simply testing if the return value is non-null because
    `page.$` returns `null` if there are no matching elements. This makes for an easy
    way to test if an element is present.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的一种技术是调用`page.$`来查询给定元素是否在页面上。这种方法检查页面，返回一个包含任何匹配元素的数组。我们只是测试返回值是否非空，因为如果没有匹配元素，`page.$`会返回`null`。这是一种简单的测试元素是否存在的方法。
- en: We end this by logging out by clicking on the **Logout** button.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**注销**按钮退出登录。
- en: 'Having created these test cases, we can run the test suite again:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了这些测试用例后，我们可以再次运行测试套件：
- en: '[PRE33]js\1'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE33]js\1'
- en: There are several methods supported by the `uuid` package, and the `v4` method
    is what generates random strings.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`uuid`包支持几种方法，`v4`方法是生成随机字符串的方法。'
- en: 'Then, add the following scenario:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下场景：
- en: '[PRE34]js\1'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34]js\1'
- en: This computes the bad URL by taking the URL for the home page (`NOTES_HOME_URL`)
    and setting the *pathname* portion of the URL to `/bad-unknown-url`. Since there
    is no route in Notes for this path, we're certain to get an error. If we wanted
    more certainty, it seems we could use the `uuidv4()` function to make the URL
    random.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过获取主页的URL（`NOTES_HOME_URL`）并将URL的*pathname*部分设置为`/bad-unknown-url`来计算错误的URL。由于在笔记中没有这条路径，我们肯定会收到一个错误。如果我们想要更确定，似乎可以使用`uuidv4()`函数使URL变得随机。
- en: Calling `page.goto()` simply gets the browser to go to the requested URL. For
    the subsequent page, we wait until a page with a `header` element shows up. Because
    this page doesn't have much on it, the header element is the best choice for determining
    when we have the subsequent page.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`page.goto()`只是让浏览器转到请求的URL。对于后续页面，我们等到出现一个带有`header`元素的页面。因为这个页面上没有太多内容，所以`header`元素是确定我们是否有了后续页面的最佳选择。
- en: To check the 404 status code, we call `response.status()`, which is the status
    code that's received in the HTTP response. Then, we call `page.$eval` to get a
    couple of items from the page and make sure they contain the text that's expected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查404状态码，我们调用`response.status()`，这是在HTTP响应中收到的状态码。然后，我们调用`page.$eval`从页面中获取一些项目，并确保它们包含预期的文本。
- en: In this case, we did not find any code problems, but we did find another user
    experience problem. The error page is downright ugly and user-unfriendly. We know
    the user experience team will scream about this, so add it to your backlog to
    do something to improve this page.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有发现任何代码问题，但我们发现了另一个用户体验问题。错误页面非常丑陋且不友好。我们知道用户体验团队会对此大声抱怨，所以将其添加到待办事项中，以改进此页面。
- en: In this section, we wrapped up test development by creating a couple of negative
    tests. While this didn't result in finding code bugs, we found a pair of user
    experience problems. We know this will result in an unpleasant discussion with
    the user experience team, so we've proactively added a task to the backlog to
    fix those pages. But we also learned about being on the lookout for any kind of
    problem that crops up along the way. It's well-known that the lowest cost of fixing
    a problem is the issues found by the development or testing team. The cost of
    fixing problems goes up tremendously when it is the user community reporting the
    problems.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们通过创建一些负面测试来结束了测试开发。虽然这并没有导致发现代码错误，但我们发现了一对用户体验问题。我们知道这将导致与用户体验团队进行不愉快的讨论，因此我们已经主动将修复这些页面的任务添加到了待办事项中。但我们也学会了随时留意沿途出现的任何问题。众所周知，由开发或测试团队发现的问题的修复成本最低。当用户社区报告问题时，修复问题的成本会大大增加。
- en: Before we wrap up this chapter, we need to talk a little more in-depth about
    testability.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，我们需要更深入地讨论一下可测试性。
- en: Improving testability in the Notes UI
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进笔记UI的可测试性
- en: While the Notes application displays well in the browser, how do we write test
    software to distinguish one page from another? As we saw in this section, the
    UI test often performed an action that caused a page refresh and had to wait for
    the next page to appear. This means our test must be able to inspect the page
    and work out whether the browser is displaying the correct page. An incorrect
    page is itself a bug in the application. Once the test determines it is the correct
    page, it can then validate the data on the page.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Notes应用程序在浏览器中显示良好，但我们如何编写测试软件来区分一个页面和另一个页面？正如我们在本节中看到的，UI测试经常执行一个导致页面刷新的操作，并且必须等待下一个页面出现。这意味着我们的测试必须能够检查页面，并确定浏览器是否显示了正确的页面。一个错误的页面本身就是应用程序中的一个错误。一旦测试确定它是正确的页面，它就可以验证页面上的数据。
- en: The bottom line is a requirement stating that each HTML element must be easily
    addressable using a CSS selector.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，每个HTML元素必须能够轻松地使用CSS选择器进行定位。
- en: While in most cases it is easy to code a CSS selector for every element, in
    a few cases, this is difficult. The **Software Quality Engineering** (**SQE**)
    manager has requested our assistance. At stake is the testing budget, which will
    be stretched further the more the SQE team can automate their tests.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在大多数情况下，为每个元素编写CSS选择器很容易，在少数情况下，这很困难。**软件质量工程**（**SQE**）经理请求我们的帮助。涉及的是测试预算，SQE团队能够自动化他们的测试，预算将被进一步拉伸。
- en: All that's necessary is to add a few `id` or `class` attributes to HTML elements
    to improve testability. With a few identifiers and a commitment to maintaining
    those identifiers, the SQE team can write repeatable test scripts to validate
    the application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的只是为HTML元素添加一些`id`或`class`属性，以提高可测试性。有了一些标识符和对这些标识符的承诺，SQE团队可以编写可重复的测试脚本来验证应用程序。
- en: 'We have already seen one example of this: the Delete button in `views/noteview.hbs`.
    It proved impossible to write a CSS selector for that button, so we added an ID
    attribute that let us write the test.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个例子：`views/noteview.hbs`中的删除按钮。我们无法为该按钮编写CSS选择器，因此我们添加了一个ID属性，让我们能够编写测试。
- en: In general, *testability* is about adding things to an API or user interface
    for the benefit of software quality testers. For an HTML user interface, that
    means making sure test scripts can locate any element in the HTML DOM. And as
    we've seen, the `id` and `class` attributes go a long way to satisfying that need.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，*可测试性*是为了软件质量测试人员的利益而向API或用户界面添加东西。对于HTML用户界面来说，这意味着确保测试脚本可以定位HTML DOM中的任何元素。正如我们所见，`id`和`class`属性在满足这一需求方面起到了很大作用。
- en: In this section, we learned about user interface testing as a form of functional
    testing. We used Puppeteer, a framework for driving a headless Chromium browser
    instance, as the vehicle for testing the Notes user interface. We learned how
    to automate user interface actions and how to verify that the web pages that showed
    up matched with their correct behavior. That included test scenarios covering
    login, logout, adding notes, and logging in with a bad user ID. While this didn't
    discover any outright failures, watching the user interaction told us of some
    usability problems with Notes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了用户界面测试作为功能测试的一种形式。我们使用了Puppeteer，一个用于驱动无头Chromium浏览器实例的框架，作为测试Notes用户界面的工具。我们学会了如何自动化用户界面操作，以及如何验证显示的网页是否与其正确的行为匹配。这包括覆盖登录、注销、添加笔记和使用错误的用户ID登录的测试场景。虽然这没有发现任何明显的失败，但观察用户交互告诉我们Notes存在一些可用性问题。
- en: With that, we are ready to close out this chapter.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们准备结束本章。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We covered a lot of territory in this chapter and looked at three distinct
    areas of testing: unit testing, REST API testing, and UI functional tests. Ensuring
    that an application is well tested is an important step on the road to software
    success. A team that does not follow good testing practices is often bogged down
    with fixing regression after regression.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多领域，并查看了三个不同的测试领域：单元测试、REST API测试和UI功能测试。确保应用程序经过充分测试是通往软件成功的重要一步。一个不遵循良好测试实践的团队往往会陷入修复回归问题的泥潭。
- en: First, we talked about the potential simplicity of simply using the assert module
    for testing. While the test frameworks, such as Mocha, provide great features,
    we can go a long way with a simple script.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们谈到了只使用断言模块进行测试的潜在简单性。虽然测试框架，比如Mocha，提供了很好的功能，但我们可以用一个简单的脚本走得更远。
- en: There is a place for test frameworks, such as Mocha, if only to regularize our
    test cases and to produce test results reports. We used Mocha and Chai for this,
    and these tools were quite successful. We even found a couple of bugs with a small
    test suite.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架，比如Mocha，有其存在的价值，至少是为了规范我们的测试用例并生成测试结果报告。我们用Mocha和Chai做到了这一点，这些工具非常成功。我们甚至在一个小的测试套件中发现了一些错误。
- en: When starting down the unit testing road, one design consideration is mocking
    out dependencies. But it's not always a good use of our time to replace every
    dependency with a mock version. As a result, we ran our tests against a live database,
    but with test data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始单元测试之路时，一个设计考虑是模拟依赖关系。但并不总是一个好的做法用模拟版本替换每个依赖。因此，我们对一个实时数据库运行了我们的测试，但使用了测试数据。
- en: To ease the administrative burden of running tests, we used Docker to automate
    setting up and tearing down the test infrastructure. Just as Docker was useful
    in automating the deployment of the Notes application, it's also useful in automating
    test infrastructure deployment.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻运行测试的行政负担，我们使用Docker来自动设置和拆除测试基础设施。就像Docker在自动部署Notes应用程序方面很有用一样，它在自动化测试基础设施部署方面也很有用。
- en: Finally, we were able to test the Notes web user interface in a real web browser.
    We can't trust that unit testing will find every bug; some bugs will only show
    up in the web browser.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们能够在真实的Web浏览器中测试Notes网络用户界面。我们不能指望单元测试能够找到每一个错误；有些错误只会在Web浏览器中显示。
- en: In this book, we've covered the full life cycle of Node.js development, from
    concept, through various stages of development, to deployment and testing. This
    will give you a strong foundation from which to start developing Node.js applications.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经涵盖了Node.js开发的整个生命周期，从概念、通过各个开发阶段，到部署和测试。这将为您提供一个坚实的基础，从而开始开发Node.js应用程序。
- en: In the next chapter, we'll explore another critical area – security. We'll start
    by using HTTPS to encrypt and authenticate user access to Notes. We'll use several
    Node.js packages to limit the chances of security intrusions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个关键领域——安全性。我们将首先使用HTTPS对用户访问Notes进行加密和认证。我们将使用几个Node.js包来减少安全入侵的机会。
