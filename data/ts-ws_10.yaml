- en: 9\. Generics and Conditional Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 泛型和条件类型
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces generics and conditional types. This chapter first teaches
    you about what generics are, and some basic generics usage in different contexts
    – interfaces, classes, functions, and so on. Next, you'll learn about generic
    constraints, and how to make your code more type-safe while using generics, to
    avoid errors at runtime. Lastly, you'll learn about conditional types and how
    they make generics even more powerful by introducing type-level *logic* at compile
    time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了泛型和条件类型。本章首先教你了解泛型是什么，以及在不同上下文（如接口、类、函数等）中的一些基本泛型用法。接下来，你将学习泛型约束，以及如何在使用泛型时使你的代码更安全，以避免运行时错误。最后，你将学习条件类型以及它们如何通过在编译时引入类型级别的*逻辑*使泛型更加强大。
- en: By the end of this chapter, you will be able to apply generics to real-world
    use cases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够将泛型应用于实际用例。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we saw how we can use dependency injection in TypeScript.
    In this chapter, we'll cover two of the more advanced features that TypeScript's
    type system offers, useful mostly in advanced applications or when building libraries
    – generics and conditional types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何在TypeScript中使用依赖注入。在本章中，我们将介绍TypeScript类型系统提供的两个更高级的功能，这些功能主要用于高级应用程序或构建库时——泛型和条件类型。
- en: TypeScript includes a very strong type system that covers a lot of use cases
    and advanced types. In earlier chapters, we saw some of the more basic ways in
    which you can utilize the type system while building applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript包含一个非常强大的类型系统，涵盖了大量的用例和高级类型。在早期章节中，我们看到了一些更基本的方法，在构建应用程序时可以利用类型系统。
- en: Generics are one of the building blocks of many languages, such as Java, C#,
    Rust, and of course TypeScript, and they aim to allow developers to write dynamic
    and reuseable *generic* pieces of code with types that are *unknown* when writing
    the code but will be specified later, when using these generic pieces of code.
    In other words, generics are a sort of "placeholder" when the concrete type isn't
    known at the time of creating an application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是许多语言（如Java、C#、Rust和当然还有TypeScript）的构建块之一，它们的目的是允许开发者在编写代码时使用未知类型（但稍后在使用这些泛型代码时会指定）来编写动态和可重用的*泛型*代码片段。换句话说，泛型在创建应用程序时不知道具体类型时是一种“占位符”。
- en: For example, if you want to write a generic *List* data structure, the implementation
    is the same for whatever type of item it may store, but the actual type of item
    is *unknown* when writing the *List* class. We can then use generics as a sort
    of a "placeholder" type when writing it, and the user of the *List* class will
    specify it when they know the concrete type it'll use, thereby filling in this
    "placeholder."
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想编写一个泛型*List*数据结构，其实现在乎存储什么类型的项都是相同的，但实际存储的项类型在编写*List*类时是*未知的*。然后我们可以使用泛型作为编写时的“占位符”类型，而*List*类的使用者将在知道它将使用的具体类型时指定它，从而填充这个“占位符”。
- en: Conditional types allow us to bring *logic* into TypeScript's type system, which
    will be checked at *compile time*. This means that our types can be safer, and
    we can make code stricter, and move some of our logic from runtime to compile
    time, which means that less code needs to run on the server or in the user's browser.
    Additionally, conditional types allow us to write more complex types, with more
    complex relations between them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 条件类型允许我们将*逻辑*引入TypeScript的类型系统，这将在*编译时*进行检查。这意味着我们的类型可以更安全，我们可以使代码更严格，并将一些逻辑从运行时移动到编译时，这意味着服务器或用户浏览器上需要运行的代码更少。此外，条件类型允许我们编写更复杂的类型，它们之间有更复杂的关系。
- en: 'For example, if we want to remove some options from a string literal union,
    we can use the `Extract` type to only take some of them:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想从一个字符串字面量联合中删除一些选项，我们可以使用`Extract`类型只取其中的一些：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While not restricted to usage with generic types, conditional types are usually
    used in these cases, since you want to write some logic on a type unknown and
    ahead of time, because otherwise, you could write it explicitly yourself.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不限于与泛型类型一起使用，但条件类型通常在这些情况下使用，因为你想在未知类型上编写一些逻辑，并且提前编写，否则你可以自己明确地编写它。
- en: In this chapter, we'll explore both generics and conditional types and see how
    they can make your code more robust, resilient to changes, and offer a better
    developer experience when used externally.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨泛型和条件类型，并了解它们如何使您的代码更加健壮，对变化具有更强的抵抗力，并在外部使用时提供更好的开发者体验。
- en: Generics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: As mentioned, generics help us write code that has types that are unknown when
    writing it but will be known later on, when someone uses the code. They allow
    us to put "placeholders" where concrete types would've been used otherwise, and
    for these placeholders to be filled in later, by the user of our code. Generics
    allow us to write a code once, and use it for multiple **types**, without losing
    type-safety along the way, or even increasing the type-safety in comparison to
    what we can achieve without it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，泛型帮助我们编写在编写时类型未知但在稍后使用时类型已知的代码。它们允许我们在其他情况下会使用具体类型的地方放置“占位符”，并且这些占位符可以在稍后由我们代码的使用者填充。泛型允许我们编写一次代码，并用于多个**类型**，而不会在过程中失去类型安全，甚至可以提高与不使用泛型所能达到的类型安全相比的类型安全。
- en: 'Let''s see how generics help us with typing things more correctly, starting
    with a very basic function—`identity`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看泛型如何帮助我们更正确地进行类型化，从一个非常基本的函数——`identity`——开始：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `identity` function takes in a `number`, `x`, and just returns `x`. Now,
    let''s say we want the same functionality for strings too:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`identity`函数接受一个`number`类型的`x`，并仅返回`x`。现在，假设我们还想为字符串提供相同的功能：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since type information is just for compile time, the two functions are the
    exact same in the compiled JavaScript output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型信息仅用于编译时，这两个函数在编译后的JavaScript输出中是完全相同的：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since the output JavaScript code is the same and given that TypeScript only
    adds types on top of existing JavaScript, there''s a way to type this existing
    `identity` function such that it''ll support both use cases. We can type `identity`
    in multiple ways – the most simple way is to type `x` as `any`. However, this
    means we lose type-safety inside the function, not to mention in the `return`
    type:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出JavaScript代码相同，并且鉴于TypeScript只是在现有JavaScript的基础上添加类型，因此有一种方法可以对现有的`identity`函数进行类型化，使其支持这两种用例。我们可以以多种方式对`identity`进行类型化——最简单的方式是将`x`类型化为`any`。然而，这意味着我们在函数内部以及`return`类型中都会失去类型安全：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is probably not what we want. Since `result` is of type `any`, TypeScript
    cannot know that `result.toFixed()` in the preceding code will throw an error
    at runtime (since strings don''t have a `toFixed()` method):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是我们想要的。由于`result`的类型是`any`，TypeScript无法知道前面的代码中的`result.toFixed()`将在运行时抛出错误（因为字符串没有`toFixed()`方法）：
- en: '![Figure 9.1: Running this code results in a TypeError at runtime'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：运行此代码会在运行时引发TypeError](img/B14508_09_01.jpg)'
- en: '](img/B14508_09_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_09_01.jpg)'
- en: 'Figure 9.1: Running this code results in a TypeError at runtime'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：运行此代码会在运行时引发TypeError
- en: 'Instead, we can leverage generics – we''ll type `x` as a generic type `T`,
    and return the same type from the function. Consider the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以利用泛型——我们将`x`类型化为一个泛型类型`T`，并从函数中返回相同的类型。考虑以下代码：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In TypeScript, generics are written using angled brackets, and a placeholder
    type name between them. In the preceding code, `T` is generic and serves as a
    "placeholder." Now if we update the code with the following details, we will get
    a compile-time error as shown here (red underline):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，泛型使用尖括号编写，并在其中放置一个占位符类型名称。在前面的代码中，`T`是泛型，并充当“占位符”。现在，如果我们用以下详细信息更新代码，我们将得到一个编译时错误，如下所示（红色下划线）：
- en: '![Figure 9.2: Compile-time error due to generics being used'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2：由于使用了泛型而导致的编译时错误](img/B14508_09_02.jpg)'
- en: '](img/B14508_09_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_09_02.jpg)'
- en: 'Figure 9.2: Compile-time error due to generics being used'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：由于使用了泛型而导致的编译时错误
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The placeholder type name can be anything, and its name is only useful for the
    developer using the code – so try to give generic types useful names that have
    meaning in the context they're used in.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符类型名称可以是任何名称，其名称仅对使用代码的开发者有用——因此请尝试为泛型类型提供有意义的名称，这些名称在它们使用的上下文中是有意义的。
- en: Note that we only have a single function (identity) implementation that can
    be used with both strings and numbers. TypeScript also knows the return type automatically
    and can provide useful errors at compile time. Moreover, we can pass any other
    type to the `identity` function, without the need to modify it at all.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只有一个（恒等）函数实现，它可以同时用于字符串和数字。TypeScript 还能自动识别返回类型，并在编译时提供有用的错误信息。此外，我们可以将任何其他类型传递给`identity`函数，而无需对其进行任何修改。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We didn't even have to tell TypeScript what the type of the generic is when
    calling `identity()`. TypeScript can usually infer the type of the generic(s)
    itself from the arguments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `identity()` 时，我们甚至不需要告诉 TypeScript 泛型的类型。TypeScript 通常可以从参数中推断泛型（s）的类型。
- en: Usually, having to manually specify the type of the generic when calling a function
    is a code smell (a sign that the underlying code might contain a bigger problem),
    when it can be inferred from the arguments (though there are exceptions to this).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在调用函数时必须手动指定泛型的类型是一个代码异味（一个潜在代码可能存在更大问题的信号），当可以从参数中推断出来时（尽管也有例外）。
- en: Generics come in all sorts of forms—from functions like we just saw, to interfaces,
    types, and classes. They all behave the same, just in their own scope—so function
    generics are only applicable for that function, while class generics are for that
    class's instance, and can also be used inside its methods/properties. In the next
    sections, we'll explore each of these types of generics.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型可以以各种形式出现——从我们刚才看到的函数，到接口、类型和类。它们的行为都是一样的，只是在其各自的范围内——所以函数泛型只适用于该函数，而类泛型适用于该类的实例，也可以在其方法/属性中使用。在接下来的几节中，我们将探索这些泛型类型中的每一种。
- en: Generic Interfaces
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型接口
- en: Generic interfaces are interfaces that have some additional type, not previously
    known to the author of the interface, "attached" to them. This additional type
    gives "context" to the interface and allows better type-safety when using it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型接口是具有一些附加类型的接口，这些类型在接口的作者之前是未知的，这些类型“附加”到接口上。这种附加类型为接口提供了“上下文”，并在使用它时提供了更好的类型安全性。
- en: 'In fact, if you''ve used TypeScript in the past, you''ve probably already interacted
    with generics, maybe without even realizing it. They are at play everywhere—just
    take a look at this basic line of code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你以前使用过 TypeScript，你可能已经与泛型交互过，也许甚至没有意识到。它们无处不在——只需看看这段基本的代码：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you hover over `arr`, you''ll see it''s of type `number[]`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在 `arr` 上，你会看到它的类型是 `number[]`：
- en: '![Figure 9.3: The type of arr is inferred to be number[]'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3：arr 的类型被推断为 number[]]'
- en: '](img/B14508_09_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_09_03.jpg](img/B14508_09_03.jpg)'
- en: 'Figure 9.3: The type of `arr` is inferred to be `number[]`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：`arr` 的类型被推断为 `number[]`
- en: '`number[]` is just a shorter syntax for `Array<number>` —generics at play again.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`number[]` 只是 `Array<number>` 的简写——泛型再次发挥作用。'
- en: In arrays, generics are used for the type of elements that the array holds.
    Without generics, `Array` would have to be typed with `any` all over the place
    or have a separate `interface` for every type possible (including non-built-in
    ones, so that's out of the question).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组中，泛型用于数组持有的元素类型。没有泛型，`Array` 就必须用 `any` 类型在所有地方进行类型化，或者为每种可能的类型（包括非内置类型）都有一个单独的
    `interface`，这是不可能的。
- en: 'Let''s take a look at the `Array<T>` interface definition:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Array<T>` 接口定义：
- en: '![Figure 9.4: Some of the Array<T> interface, where generics are heavily used'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4：`Array<T>` 接口的一部分，其中泛型被大量使用]'
- en: '](img/B14508_09_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_09_04.jpg](img/B14508_09_04.jpg)'
- en: 'Figure 9.4: Some of the Array<T> interface, where generics are heavily used'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：`Array<T>` 接口的一部分，其中泛型被大量使用
- en: 'As you can see, the `pop`, `push`, and `concat` methods all use the `T` generic
    type to know what they return, or what they can accept as arguments. This is why
    the following code doesn''t compile:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`pop`、`push` 和 `concat` 方法都使用 `T` 泛型类型来知道它们返回什么，或者它们可以接受什么作为参数。这就是为什么以下代码无法编译：
- en: '![Figure 9.5: An error when trying to push an incompatible type to an array
    with'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5：尝试将不兼容的类型推送到具有特定泛型的数组时出现的错误]'
- en: a specific generic type
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定的泛型类型
- en: '](img/B14508_09_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_09_05.jpg](img/B14508_09_05.jpg)'
- en: 'Figure 9.5: An error when trying to push an incompatible type to an array with
    a specific generic type'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：尝试将不兼容的类型推送到具有特定泛型的数组时出现的错误
- en: 'This is also how TypeScript can infer the type of the `value` in the callback
    for `map`, `filter`, and `forEach`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是 TypeScript 如何推断 `map`、`filter` 和 `forEach` 的回调中 `value` 的类型的方式：
- en: '![Figure 9.6: Type inference when using the map method of Array'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.6：使用 Array 的 map 方法时的类型推断]'
- en: '](img/B14508_09_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_09_06.jpg](img/B14508_09_06.jpg)'
- en: 'Figure 9.6: Type inference when using the `map` method of `Array`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：使用 `Array` 的 `map` 方法时的类型推断
- en: Generic Types
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型
- en: 'Generics can be used on plain types, for example, to create a `Dictionary<V>`
    type, and also to describe a map between strings of any values of type `V`, which
    is unknown ahead of time, and therefore *generic*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型可以用于普通类型，例如，创建一个 `Dictionary<V>` 类型，也可以用来描述一个在类型 `V` 的任何值（在事先未知的情况下）和字符串之间的映射，因此是**泛型**的：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are more use cases for generic types, but mostly you'll either be using
    them together with generic constraints (explained later in this chapter) or describing
    them with interfaces (though mostly anything that an `interface` can do, a `type`
    can as well).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型还有更多用例，但大多数情况下，你将要么与泛型约束（在本章后面解释）一起使用它们，要么用接口描述它们（尽管几乎任何`interface`能做的事情，`type`也能做到）。
- en: Generic Classes
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类
- en: Generics are also very useful for classes. As we've seen earlier in the chapter,
    the built-in `Array` class uses generics. These generics are specified at the
    class's definition and apply to that instance of the class. Properties and methods
    of the class can then utilize that generic type for their own definitions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型对于类也非常有用。正如我们在本章前面看到的，内置的`Array`类使用了泛型。这些泛型在类的定义中指定，并应用于该类的实例。类的属性和方法可以利用这个泛型类型来定义它们自己的类型。
- en: 'For example, let''s create a simple `Box<T>` class that holds a value of any
    type `T` and allows retrieving it later:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个简单的`Box<T>`类，它可以存储任何类型的`T`值，并允许稍后检索它：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `_value` property, the `constructor`, and the `value` getter use the `T`
    generic type from the class's definition for their own types. This type could
    also be used for other methods in this class if there were any.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`_value`属性、构造函数和`value`获取器使用类定义中的`T`泛型类型作为它们的类型。如果这个类中还有其他方法，这个类型也可以用于这些方法。'
- en: 'Additionally, methods of the class can add their own generics, which will only
    apply to that method''s scope – for example, if we wanted to add a `map` method
    to the `Box` class, we could type it like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类的方法可以添加它们自己的泛型，这只会应用于该方法的作用域——例如，如果我们想向`Box`类添加一个`map`方法，我们可以这样编写：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `U` generic type can be used inside the `map` method declaration, as well
    as within its implementation, but it cannot be used in other class members (like
    the `value` getter from earlier), unlike `T` – which is scoped to the entire class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`U`泛型类型可以在`map`方法声明及其实现中使用，但不能在其他类成员中使用（例如，与之前提到的`value`获取器不同），与`T`不同——`T`的作用域是整个类。'
- en: 'Exercise 9.01: Generic Set class'
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习9.01：泛型集合类
- en: In this exercise, we'll create a `Set<T>` class that implements that `Set` data
    structure – a data structure that can hold items, without a specific order, and
    without duplications, using generics.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个`Set<T>`类，它实现了`Set`数据结构——一种可以存储项目，没有特定顺序，且没有重复的数据结构，使用泛型。
- en: 'Follow these steps to implement this exercise:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个练习：
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/R336a](https://packt.link/R336a).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下链接找到：[https://packt.link/R336a](https://packt.link/R336a)。
- en: 'Start by creating a `Set` class that has a generic `T` type. This type will
    be the type of the items in the set:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个具有泛型`T`类型的`Set`类。这个类型将是集合中项目的类型：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, let''s add a constructor that takes some optional initial values. These
    will need to be an array with items of type `T`, to match our `Set` items:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个构造函数，它接受一些可选的初始值。这些值需要是一个包含类型`T`的项目的数组，以匹配我们的`Set`项目：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use default parameters to initialize `initialItems` with an empty array if
    we haven't been supplied with one – this makes this parameter optional, while
    still making it convenient to work with inside our constructor implementation.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用默认参数来初始化`initialItems`为一个空数组，如果我们没有提供，这使得这个参数是可选的，同时在构造函数实现中仍然方便使用。
- en: 'Let''s add the `size` getter, which returns the size of the set. This will
    simply be our `items` length:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个`size`获取器，它返回集合的大小。这将是我们的`items`长度的简单表示：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, let''s add a `has` method, which checks whether a given item is already
    in the set:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个`has`方法，它检查给定项目是否已经在集合中：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we use the `T` type in the `has` definition – we can use it since
    it's in the scope of the class, where `T` was declared.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在`has`定义中使用`T`类型——我们可以使用它，因为它是类的作用域内，其中`T`被声明。
- en: 'Lastly, we also need a way to add and remove items from our set – let''s add those:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要一种方法来向我们的集合中添加和删除项目——让我们添加这些方法：
- en: '[PRE14]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For the `add` method, we first check whether the given `item` already exists,
    and if not, add it.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`add`方法，我们首先检查给定的`item`是否已经存在，如果不存在，则添加它。
- en: For the `remove` method, we look for the index of the given item. If it exists,
    we remove it from the array.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`remove`方法，我们寻找给定项目的索引。如果它存在，我们就从数组中删除它。
- en: 'Now, write the following two lines of code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写以下两行代码：
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On your IDE, you will see the following:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的集成开发环境（IDE）中，你会看到以下内容：
- en: '![Figure 9.7: Type-safety in the Set class because of generics'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.7：由于泛型而实现的 Set 类中的类型安全'
- en: '](img/B14508_09_07.jpg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_09_07.jpg)'
- en: 'Figure 9.7: Type-safety in the Set class because of generics'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.7：由于泛型而实现的 Set 类中的类型安全
- en: We can see how the `Set` class can be used, and how it keeps itself type-safe,
    not allowing items of multiple types to be mixed together in the same class, for
    instance, in the following *step 7*.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到如何使用 `Set` 类，以及它是如何保持自身类型安全的，不允许在同一个类中将多种类型的项混合在一起，例如在以下 *步骤 7* 中。
- en: 'Lastly, if you go back to the `Set` class implementation, you''ll notice that
    the type of `items` within the class is `T[]`, so if we tried to add an item that
    TypeScript doesn''t know is of type `T` to the `items` array, we''d get an error:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果你回到 `Set` 类的实现，你会注意到类中 `items` 的类型是 `T[]`，所以如果我们尝试向 `items` 数组添加 TypeScript
    不认识的类型为 `T` 的项，我们会得到一个错误：
- en: '![Figure 9.8: Type-safety in the Set class because of generics'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8：由于泛型而实现的 Set 类中的类型安全'
- en: '](img/B14508_09_08.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_09_08.jpg)'
- en: 'Figure 9.8: Type-safety in the Set class because of generics'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：由于泛型而实现的 Set 类中的类型安全
- en: This is expected, since `T` can be of any type, and not just a string – as we
    saw in the preceding example where we created a `Set<number>` – a set that can
    only hold numbers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的，因为 `T` 可以是任何类型，而不仅仅是字符串——正如我们在前面的例子中创建 `Set<number>` 所见——一个只能包含数字的集合。
- en: Generic Functions
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型函数
- en: 'We''ve already briefly seen generic functions at the beginning of this chapter
    with the `identity<T>()` function. But let''s look at a more real-world, more
    useful use case—say you want to write a wrapper around `fetch()` for fetching
    JSON data, such that users won''t have to call `.json()` on the response. Consider
    the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章开头简要地看到了泛型函数，即 `identity<T>()` 函数。但是，让我们看看一个更实际、更有用的用例——比如说，你想围绕 `fetch()`
    编写一个包装器来获取 JSON 数据，这样用户就不必在响应上调用 `.json()`。考虑以下代码：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we use the browser's `fetch` function to make a `GET` call to the given
    `url` and then return an object with the main parts of the response – the `headers`,
    the status code (`status`), and the body, after parsing it as JSON (`data`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用浏览器的 `fetch` 函数向给定的 `url` 发起 `GET` 调用，然后返回一个包含响应主要部分的对象——`headers`、状态码（`status`）和解析后的主体（`data`）。
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`fetch()` is not part of ECMAScript and is therefore not part of the language.
    It''s available natively in all modern browsers and can be used in Node.js via
    packages such as `node-fetch`, `isomorphic-fetch`, and others.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 不是 ECMAScript 的一部分，因此它不是语言的一部分。它在所有现代浏览器中都是原生的，并且可以通过 `node-fetch`、`isomorphic-fetch`
    等包在 Node.js 中使用。'
- en: 'The `json()` method returns `Promise<any>`. This means that the following code
    *may* throw at runtime, if the returned object doesn''t have a `title` property,
    or it isn''t of type `string`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`json()` 方法返回 `Promise<any>`。这意味着如果返回的对象没有 `title` 属性，或者不是 `string` 类型，以下代码在运行时可能会抛出异常：'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It would be useful if a consumer calling the `fetchJson` function could know
    what the type of `data` is. For that, we could add a generic type to the `fetchJson`
    function, which we''d also need to indicate in the return type somehow – that''s
    where `interface` and `type` generics come in again. Consider the following code
    of `fetchJson.ts`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用 `fetchJson` 函数的消费者能够知道 `data` 的类型，那将是有用的。为此，我们可以在 `fetchJson` 函数中添加一个泛型类型，同时我们还需要在返回类型中以某种方式指示——这就是
    `interface` 和 `type` 泛型再次发挥作用的地方。考虑以下 `fetchJson.ts` 的代码：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is very similar to the first declaration of `fetchJson` seen previously.
    Actually, the resulting JavaScript is exactly the same. However, this declaration
    now uses generics to allow the users of the function to specify the return type
    expected from making the `GET` call.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前看到的 `fetchJson` 的第一个声明非常相似。实际上，生成的 JavaScript 代码完全相同。然而，这个声明现在使用泛型来允许函数的用户指定从
    `GET` 调用中期望的返回类型。
- en: 'Now consider the code of `usage.ts`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 `usage.ts` 的代码：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we allow the user to pass in a `T` generic type to `fetchJson<T>()`, which
    the function declaration later passes to the `FetchResponse<T>` interface, tying
    things together.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们允许用户向 `fetchJson<T>()` 传递一个 `T` 泛型类型，该函数声明随后将其传递给 `FetchResponse<T>` 接口，从而将事物联系起来。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Just like interfaces, generics only exist at compile time. So, anything you
    write there is as safe as you make the compiler understand it to be. For example,
    if you were to type `Todo` differently, or pass a different type, then the actual
    result – there is no guard built into TypeScript to verify it at runtime (without
    user/library code – see user type guard in *Chapter 5*, *Inheritance and Interfaces*).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就像接口一样，泛型只存在于编译时。所以，你在那里写的任何内容都和你让编译器理解的一样安全。例如，如果你要输入 `Todo` 的方式不同，或者传递不同的类型，那么实际的结果——TypeScript
    中没有内置的守卫来在运行时验证它（没有用户/库代码——见第 5 章，*继承和接口*中的用户类型守卫）。
- en: 'Note that in the preceding example, the `T` generic is a *convenience generic*—it''s
    only there for the user''s convenience—it''s only used once, and doesn''t offer
    any more type-safety than a simple type assertion would:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的例子中，`T` 泛型是一个 *便利泛型*——它只是为了用户的便利——它只使用一次，并不比简单的类型断言提供更多的类型安全性：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that generics, just like variables, have scopes, and you can define generics
    at multiple levels, letting the user provide them as needed. For example, notice
    how we use the `T` generic type that''s declared in the `map` function, in our
    inner function (in line 2 in the following snippet):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，泛型，就像变量一样，有作用域，你可以在多个级别上定义泛型，让用户按需提供它们。例如，注意我们如何在内部函数中使用在 `map` 函数中声明的 `T`
    泛型类型（在以下代码片段的第 2 行）：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This applies to things such as interfaces and classes too. In the `Array<T>`
    interface, the `map` function takes an additional generic to be used as the output
    type, as can be seen in the `Array<T>` interface declaration in TypeScript:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于接口和类等。在 `Array<T>` 接口中，`map` 函数接受一个额外的泛型作为输出类型，如 TypeScript 中 `Array<T>`
    接口声明所示：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Consider the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下截图：
- en: '![Figure 9.9: The map method of Array<T> has a return type inferred based on
    the type returned from callbackfn'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9：Array<T> 的映射方法基于从 callbackfn 返回的类型推断返回类型]'
- en: '](img/B14508_09_09.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_09_09.jpg)'
- en: 'Figure 9.9: The map method of Array<T> has a return type inferred based on
    the type returned from callbackfn'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9：Array<T> 的映射方法基于从 callbackfn 返回的类型推断返回类型
- en: Once we add the code shown above, again, we don't need to explicitly tell TypeScript
    that `U` is `string` – it can *infer* it from the return type of the callback
    function (though we could explicitly pass it if we wanted to). The `map` method
    of `Array<T>` has a return type inferred based on the type returned from `callbackfn`.
    It's inferred to `string[]` in this case.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了上面的代码，再次，我们不需要明确告诉 TypeScript `U` 是 `string` ——它可以从回调函数的返回类型中 *推断* 它。在这种情况下，`Array<T>`
    的 `map` 方法基于从 `callbackfn` 返回的类型推断返回类型，推断为 `string[]`。
- en: Generic Constraints
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型约束
- en: 'Sometimes you want to define a generic to be constrained to some subset of
    types. At the beginning of this chapter, we looked at the `identity` function
    – there it was easy and made sense to support *any* type. But what about typing
    a `getLength` function – which only makes sense for arrays and strings. It doesn''t
    make sense to accept just *any* type – what would the output of `getLength(true)`
    be? In order to constrain the type of values our function can accept, we can use
    generic constraints. Consider the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你想要定义一个泛型，使其约束在类型的一个子集中。在本章的开头，我们看到了 `identity` 函数——在那里支持 *任何* 类型既简单又合理。但关于
    `getLength` 函数的打字——它只对数组和字符串有意义。接受 *任何* 类型都没有意义——`getLength(true)` 的输出会是什么？为了约束函数可以接受值的类型，我们可以使用泛型约束。考虑以下代码：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This definition *constrains* the given `T` type to be a subtype of either `any[]`
    (an array of anything – `string[]`, `number[]`, or any `Foo[]` would all be valid
    types) or a `string`. If we pass an invalid type, we get a compilation error as
    you can see here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义 *约束* 给定的 `T` 类型成为 `any[]`（任何东西的数组——`string[]`、`number[]` 或任何 `Foo[]` 都会是有效的类型）或
    `string` 的子类型。如果我们传递一个无效的类型，我们会得到一个编译错误，就像你在这里看到的那样：
- en: '![Figure 9.10: Compile-time errors are given for invalid types when passed'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10：当传递给 getLength 函数无效类型时，会给出编译时错误]'
- en: to the getLength function
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 getLength 函数
- en: '](img/B14508_09_10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_09_10.jpg)'
- en: 'Figure 9.10: Compile-time errors are given for invalid types when passed to
    the getLength function'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10：当传递给 getLength 函数无效类型时，会给出编译时错误
- en: There are many use cases for generic constraints, and more often than not you'll
    want to set some of these in place when using generics, since when writing the
    code, you probably assume some underlying type for it. Additionally, putting generic
    constraints lets TypeScript narrow the possible type of the generic type, and
    gives you better suggestions and type-checking.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通用约束有许多用例，而且通常在使用泛型时，你会在代码中设置一些这些约束，因为当你编写代码时，你可能会假设一些底层类型。此外，使用泛型约束可以让 TypeScript
    窄化泛型类型的可能类型，并为你提供更好的建议和类型检查。
- en: 'For example, in a more real-world scenario, we might have some functions that
    return us plain dates while others return an epoch. We want to always work with
    dates, so we can create a function, `toDate`, that accepts these types and normalizes
    a `Date` function from them:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个更现实的情况下，我们可能有一些函数返回给我们普通的日期，而其他函数返回纪元。我们希望始终使用日期，因此我们可以创建一个函数 `toDate`，它接受这些类型并将它们转换为
    `Date` 函数：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we first check if the given value is a date. If so, we can just return
    it. Otherwise, we create a new `Date` function with the `value` and return that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查给定的值是否是日期。如果是，我们可以直接返回它。否则，我们使用 `value` 创建一个新的 `Date` 函数并返回它。
- en: Generic constraints are especially powerful for creating higher-order functions,
    where typing the incoming function can be very hard, and keeping type-safety is
    a big benefit for code maintainability. In the next exercise, we'll see more uses
    for generic constraints in a real-world application and cases where it brings
    better typing to our code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通用约束在创建高阶函数时特别强大，因为输入函数的类型可能很难编写，而保持类型安全对于代码的可维护性是一个很大的好处。在下一个练习中，我们将看到通用约束在现实世界应用中的更多用途，以及它如何为我们的代码带来更好的类型。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Higher-order functions are functions that either take in another function as
    an argument or return a function. We'll explore these more in *Chapter 12*, *Guide
    to Promises in TypeScript*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是接受另一个函数作为参数或返回一个函数的函数。我们将在 *第12章*，*TypeScript中的Promise指南* 中进一步探讨这些内容。
- en: 'Exercise 9.02: The Generic memoize Function'
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.02：泛型缓存函数
- en: In this exercise, we'll create a `memoize` function that, using generics, will
    be completely type-safe—it takes in a function and returns a function of the same
    type.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个 `memoize` 函数，它使用泛型，将完全类型安全——它接受一个函数并返回一个相同类型的函数。
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Memoization is a way to optimize performance, by reducing the number of times
    something is done. A memorization function is a higher-order function that caches
    the results of the inner function passed to it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一种优化性能的方法，通过减少某些操作执行的次数。缓存函数是一个高阶函数，它缓存了传递给它的内部函数的结果。
- en: 'Follow these steps to implement this exercise:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这个练习：
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/zUx6H](https://packt.link/zUx6H).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在此处找到：[https://packt.link/zUx6H](https://packt.link/zUx6H)。
- en: 'Start by implementing the naïve function definition. We''ll add types later:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先实现一个简单的函数定义。我们稍后会添加类型：
- en: '[PRE25]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`memoize` takes in a function, `fn`, to memoize, as well as an optional `keyGetter`
    to serialize the arguments to a key, used for later lookups.'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`memoize` 函数接受一个要缓存的函数 `fn`，以及一个可选的 `keyGetter`，用于将参数序列化为键，用于后续查找。'
- en: 'Next, let''s implement the function itself:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们实现这个函数本身：
- en: '[PRE26]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the `memoize` function, we create an empty `cache` dictionary – the keys
    are the serialized arguments, and the values are the results of running the `fn`
    function on those arguments.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `memoize` 函数中，我们创建一个空的 `cache` 字典——键是序列化的参数，值是运行 `fn` 函数对这些参数的结果。
- en: We then return a function that, given some arguments, `args` will check to see
    if the results for running `fn` with them have already been cached. If they haven't,
    we run `fn` with these arguments and cache the result. Lastly, we return the value
    we have stored in the cache, which is either a past calculation or the one we
    just ran and cached.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们返回一个函数，给定一些参数 `args`，将检查运行 `fn` 并使用这些参数的结果是否已经被缓存。如果没有，我们将使用这些参数运行 `fn`
    并缓存结果。最后，我们返回存储在缓存中的值，这可能是之前的计算结果或我们刚刚运行并缓存的结果。
- en: 'To test this out, we''ll write an "expensive" function with one that loops
    for 10 seconds before adding two numbers:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们将编写一个“昂贵”的函数，该函数在添加两个数字之前会循环10秒钟：
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Since memoization is meant to reduce the number of calls, it is usually effective
    in functions that take a long time to run – to illustrate this, we made `expensiveCalculation`,
    a function that takes a needlessly long time to run (10 seconds).
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于缓存旨在减少调用次数，它通常在运行时间较长的函数中非常有效——为了说明这一点，我们创建了一个 `expensiveCalculation` 函数，它需要不必要地长时间运行（10
    秒）。
- en: 'Next''s let''s `memoize` it:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们 `memoize` 它：
- en: '[PRE28]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the memoized version is not type-safe. It does verify that we give
    it a `function`, but the returned value is a very loosely typed function, which
    may fail at runtime or have unexpected behavior if not typed correctly – you can
    pass in any number of arguments to it, with any type, and it will compile fine,
    even though at runtime the function expects to only be called with two arguments,
    both of which should be of type `number`.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到，缓存的版本不是类型安全的。它确实验证了我们提供了一个 `function`，但返回的值是一个类型非常松散的函数，如果类型不正确，可能在运行时失败或出现意外的行为——你可以向它传递任意数量的任意类型的参数，它仍然可以编译通过，尽管在运行时该函数期望只接受两个参数，这两个参数都应该是
    `number` 类型。
- en: 'Here we are memoizing with the following:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里我们使用以下方式来缓存：
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On your IDE, hover over the preceding two line of code. You will notice the following:![Figure
    9.11: Message on the IDE'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的集成开发环境（IDE）中，将鼠标悬停在前面两行代码上。你会注意到以下内容：![图 9.11：IDE 上的消息
- en: '](img/B14508_09_11.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_09_11.jpg)'
- en: 'Figure 9.11: Message on the IDE'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.11：IDE 上的消息
- en: As can be seen in the preceding screenshot, the memoized version of `expensiveCalculation`
    is not type-safe – it allows passing in a string as the first parameter, when
    it should only accept a number.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，缓存的 `expensiveCalculation` 版本不是类型安全的——它允许传递一个字符串作为第一个参数，而它应该只接受一个数字。
- en: 'Go back to the top of the file and then add generic constraints and make our
    `memoize` function more type-safe. First, we need to define a couple of helper types:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回文件顶部，然后添加泛型约束，并使我们的 `memoize` 函数更加类型安全。首先，我们需要定义几个辅助类型：
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first type, `AnyFunction`, describes a function that takes any number of
    arguments and returns anything. The second type, `KeyGetter`, describes a function
    that takes in the parameters of the generically constrained function `Fn` and
    returns a string. Notice that we constrain `Fn` to be of type `AnyFunction`. This
    ensures that we get a function, and allows us to use the built-in `Parameters<T>`
    type, which takes in a type of a function and returns the parameters it takes.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个类型 `AnyFunction` 描述了一个接受任意数量参数并返回任意内容的函数。第二个类型 `KeyGetter` 描述了一个接受泛型约束函数
    `Fn` 的参数并返回一个字符串的函数。注意，我们将 `Fn` 约束为 `AnyFunction` 类型。这确保了我们得到一个函数，并允许我们使用内置的 `Parameters<T>`
    类型，它接受一个函数的类型并返回它接受的参数。
- en: 'Next, make our `memoize` function definition more type-safe using the two types
    we just defined – typing both arguments in a better way:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用我们刚刚定义的两个类型使我们的 `memoize` 函数定义更加类型安全——以更好的方式对两个参数进行类型化：
- en: '[PRE31]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again, we constrain `Fn` to be of type `AnyFunction` to ensure we get a function,
    as we did before, as well as to be able to use the specific function type later,
    for our return type.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，我们将 `Fn` 约束为 `AnyFunction` 类型以确保我们得到一个函数，就像之前一样，同时也为了能够稍后使用特定的函数类型，作为我们的返回类型。
- en: Now we have a more type-safe function, since `keyGetter` is now type-safe but
    it still doesn't return a typed function back.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有一个更安全的函数，因为 `keyGetter` 现在是类型安全的，但它仍然不返回一个类型化的函数。
- en: 'Let''s fix that by also making the implementation more type-safe:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过使实现更加类型安全来修复这个问题：
- en: '[PRE32]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use `ReturnType<Fn>` for the values of our cache instead of `any`. `ReturnType<T>`
    is another built-in type that types in a type of a function and returns the return
    type of that function. We also use the `Parameters<T>` type again here, to describe
    the function we're returning from `memoize`.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `ReturnType<Fn>` 来表示缓存中的值，而不是 `any`。`ReturnType<T>` 是另一个内置类型，它接受一个函数的类型并返回该函数的返回类型。我们在这里再次使用
    `Parameters<T>` 类型，来描述从 `memoize` 返回的函数。
- en: 'Hover your mouse over `memoizedExpensiveCalculation(''not-a-number'')`. Now,
    our `memoize` implementation is completely type-safe, and the code that didn''t
    cause a compile-time error in *step 4* now runs correctly:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在 `memoizedExpensiveCalculation('not-a-number')` 上。现在，我们的 `memoize` 实现是完全类型安全的，并且在
    *步骤 4* 中没有导致编译时错误的代码现在可以正确运行：
- en: '![Figure 9.12: The type of memoizedExpensiveCalculation is the same as the
    original expensiveCalculation function'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12：memoizedExpensiveCalculation 的类型与原始 expensiveCalculation 函数相同'
- en: '](img/B14508_09_12.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_09_12.jpg)'
- en: 'Figure 9.12: The type of memoizedExpensiveCalculation is the same as the original
    expensiveCalculation function'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12：memoizedExpensiveCalculation 类型的类型与原始的 expensiveCalculation 函数相同
- en: This exercise demonstrates how generics can be used in functions and types,
    and how they integrate with one another. Using generics here is what allows the
    `memoize` function to be completely type-safe, so there is less chance of our
    code hitting errors during runtime.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了如何在函数和类型中使用泛型，以及它们是如何相互集成的。在这里使用泛型使得 `memoize` 函数完全类型安全，因此我们的代码在运行时遇到错误的几率更小。
- en: Generic Defaults
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型默认值
- en: 'Sometimes, you want to *allow* for generics, but not *require* them – you want
    to give some sensible defaults, but allow overriding them as needed. For example,
    consider the following definition of an `Identifiable` interface:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你想要*允许*泛型，但*不要求*它们——你想要提供一些合理的默认值，但允许根据需要覆盖它们。例如，考虑以下 `Identifiable` 接口的定义：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This can be used by other interfaces like so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被其他接口使用，如下所示：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The current implementation requires every implementer of the `Identifiable`
    interface to specify the type of `Id` it has. But maybe we want to give some default,
    so you only have to specify it if you don''t want that default type. Consider
    the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实现要求每个 `Identifiable` 接口的实现者指定其 `Id` 的类型。但也许我们想要提供一个默认值，这样你只有在不想使用该默认类型时才需要指定它。考虑以下代码：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice the `Id` generic type a default type of `number`, which simplifies the
    code for the implementors of this interface:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Id` 泛型类型有一个默认类型 `number`，这简化了此接口实现者的代码：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that now `Person` doesn't have to specify the type of `Id`, and the code
    is equivalent to before.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在 `Person` 不必指定 `Id` 的类型，代码与之前相同。
- en: 'Another, more real-world, scenario is with React components—each React component
    *may* have props and *may* have state, both of which you can specify when declaring
    a component (by extending React''s `Component` type), but it doesn''t have to
    have either, so there''s a default `{}` given to the generic type of both:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更贴近现实世界的场景是与 React 组件相关——每个 React 组件*可能*有属性和*可能*有状态，你可以在声明组件时指定这些（通过扩展 React
    的 `Component` 类型），但它们不必都有，因此为这两个泛型类型提供了一个默认的 `{}`：
- en: '![Figure 9.13: Partial snippet from the @types/react package'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.13：@types/react 包的部分片段'
- en: '](img/B14508_09_13.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_09_13.jpg]'
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This makes React components have no props and no state by default, but these
    can be specified if they need either of them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 React 组件默认没有属性和状态，但如果需要，可以指定它们。
- en: Conditional Types
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件类型
- en: 'Conditional types were introduced in TypeScript 2.8 and allow complex type
    expressions, some of which drive some of the built-in types we saw earlier. These
    are really powerful, since they allow us to write *logic* inside our types. The
    syntax for this is `T extends U ? X : Y`. This is very similar to the regular
    JavaScript ternary operator, which allows for inline conditions, the only difference
    in the syntax is that you have to use the `extends` keyword and that this check
    is done at compile time and *not* runtime.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '条件类型是在 TypeScript 2.8 中引入的，允许复杂的类型表达式，其中一些驱动了我们在之前看到的内置类型。它们非常强大，因为它们允许我们在类型中编写*逻辑*。这种语法的格式是
    `T extends U ? X : Y`。这与常规的 JavaScript 三元运算符非常相似，允许内联条件，唯一的语法区别是你必须使用 `extends`
    关键字，并且这个检查是在编译时进行的，而不是在运行时。'
- en: 'This allows us to write a `NonNullable<T>` type:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们编写一个 `NonNullable<T>` 类型：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is already built into the language, but it's driven by the same code you
    could write in your app.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经内建到语言中，但它是由你可以在你的应用程序中编写的相同代码驱动的。
- en: 'This means that you can check whether a type is nullable at compile time and
    change the type signature or inference based on that. An example use case for
    this would be an `isNonNullable` function. Consider the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以在编译时检查一个类型是否可以为 null，并根据这个检查来更改类型签名或推断。一个这样的用例可能是 `isNonNullable` 函数。考虑以下代码：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code together with the `filter` method of `Array` can allow you
    to filter for relevant items. For example, consider the following definition of
    an array with items of mixed types:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与 `Array` 的 `filter` 方法一起使用，可以让你过滤出相关项。例如，考虑以下混合类型项的数组定义：
- en: '![Figure 9.14: The type of arr is an array, where each element is either number,'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.14：arr 的类型是一个数组，其中每个元素是数字，'
- en: null, or undefined
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: null 或 undefined
- en: '](img/B14508_09_14.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_09_14.jpg]'
- en: 'Figure 9.14: The type of arr is an array, where each element is either number,
    null, or undefined'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：arr的类型是一个数组，其中每个元素是数字、null或undefined
- en: 'When we call `arr.filter(isNonNullable)`, we can get a properly typed array:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`arr.filter(isNonNullable)`时，我们可以得到一个正确类型的数组：
- en: '![Figure 9.15: The type of nonNullalbeArr is inferred to be number[]'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15：nonNullalbeArr的类型被推断为number[]]'
- en: '](img/B14508_09_15.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_09_15.jpg)'
- en: 'Figure 9.15: The type of nonNullalbeArr is inferred to be number[]'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：nonNullalbeArr的类型被推断为number[]
- en: Lastly, another addition to TypeScript in 2.8 was the `infer` keyword, which
    allows you to get help from the compiler in *inferring* the type of something,
    from another type.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，TypeScript 2.8中添加了另一个新特性`infer`关键字，它允许你在*推断*某个类型时从另一个类型中获得编译器的帮助。
- en: 'Here''s a simple example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we want to get the inner type of an array (for example, for an array of
    type `Person[]`, you want to get `Person`). So we check if the passed generic
    type `T extends Array<infer U>` the `infer` keyword suggests to the compiler that
    the compiler should try to understand what the type is, and assign that to `U`,
    which we then use as the return value from this conditional type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们希望得到数组的内部类型（例如，对于类型为`Person[]`的数组，你希望得到`Person`）。因此，我们检查传递的泛型类型`T extends
    Array<infer U>`，`infer`关键字建议编译器尝试理解类型，并将其分配给`U`，然后我们将其用作从这个条件类型返回的值。
- en: Note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This specific example type was also possible in previous versions via `type
    ArrayItem<T extends any[]> = T[number]`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的类型示例在之前的版本中也可以通过`type ArrayItem<T extends any[]> = T[number]`实现。
- en: Another very useful example that was not previously possible outside of arrays
    was to "unbox" a type. For example, given the `Promise<Foo>` type, we want to
    get the `Foo` type back. This is now possible with the `infer` keyword.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的例子是，以前在数组之外不可能的“解包”类型。例如，给定`Promise<Foo>`类型，我们希望得到`Foo`类型。现在这可以通过`infer`关键字实现。
- en: 'Similarly to the last example, where we extracted the array inner type, we
    can use the same technique for any other generic type that "boxes" another type:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于上一个例子，其中我们提取了数组内部类型，我们可以使用相同的技巧处理任何其他“包装”另一个类型的泛型类型：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will yield the following type information on the IDE:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在IDE中产生以下类型信息：
- en: '![Figure 9.16: The type of UnpromisedPerson is Person'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16：UnpromisedPerson的类型是Person]'
- en: '](img/B14508_09_16.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_09_16.jpg)'
- en: 'Figure 9.16: The type of UnpromisedPerson is Person'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：UnpromisedPerson的类型是Person
- en: In the next activity, we'll take a look at a more real-world use case for conditional
    types, as well as usage of the `infer` keyword.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们将探讨条件类型的更多实际用例，以及`infer`关键字的用法。
- en: 'Activity 9.01: Creating a DeepPartial<T> Type'
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动9.01：创建DeepPartial<T>类型
- en: In this activity, we'll be using concepts learned in this chapter—generics,
    conditional types, and the `infer` keyword—to create a `DeepPartial<T>` type.
    This type is like the built-in `Partial<T>` type. But we will work recursively
    and make every property in the object optional, recursively.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用本章学到的概念——泛型、条件类型和`infer`关键字——来创建`DeepPartial<T>`类型。这个类型类似于内置的`Partial<T>`类型。但我们将递归地工作，并使对象中的每个属性都是可选的，递归地。
- en: This will allow you to correctly type variables and so on so that all of their
    properties, at any level, can be optional. For example, a `REST` server will serve
    resources, and allow modifying them using a `PATCH` request, which should get
    a partial structure of the original resource, to modify.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你正确地类型化变量等，以便它们的属性在任意级别都可以是可选的。例如，一个`REST`服务器将提供资源，并允许使用`PATCH`请求修改它们，这应该得到原始资源的部分结构，以便修改。
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this activity can be found here: [https://packt.link/YQUex](https://packt.link/YQUex).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的代码文件可以在以下位置找到：[https://packt.link/YQUex](https://packt.link/YQUex)。
- en: 'To create this type, we''ll need to deal with a few cases:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个类型，我们需要处理几个情况：
- en: Primitives – strings, numbers, and other primitives, in addition to dates, are
    not something we can apply `Partial` to. So `DeepPartial<string> === string`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始类型——字符串、数字和其他原始类型，以及日期，都不是我们可以应用`Partial`的。所以`DeepPartial<string> === string`。
- en: For constructs like objects, `Array`, `Set`, and `Map`, we want to "reach into"
    the construct and apply `DeepPartial` to their values.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于像对象、`Array`、`Set`和`Map`这样的结构，我们希望“深入”到结构中，并将`DeepPartial`应用于它们的值。
- en: For everything else, we want to just apply `Partial`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其他所有内容，我们只想应用`Partial`。
- en: 'Perform the following steps to implement this activity:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现此活动：
- en: Create a `PartialPrimitive` type.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`PartialPrimitive`类型。
- en: Define a basic `DeepPartial<T>` type that can handle primitives and objects
    at the top level.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶级定义一个基本的`DeepPartial<T>`类型，它可以处理原始类型和对象。
- en: Add support for arrays by defining a `DeepPartialArray<T>` type and add handling
    for it in our `DeepPartial<T>` type.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义一个`DeepPartialArray<T>`类型并在此`DeepPartial<T>`类型中添加对其的处理，来支持数组的支持。
- en: Add support for sets by defining a `DeepPartialSet<T>` type and add handling
    for it in our `DeepPartial<T>` type.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义一个`DeepPartialSet<T>`类型并在此`DeepPartial<T>`类型中添加对其的处理，来支持集合的支持。
- en: Add support for maps by defining a `DeepPartialMap<T>` type and add handling
    for it in our `DeepPartial<T>` type.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义一个`DeepPartialMap<T>`类型并在此`DeepPartial<T>`类型中添加对其的处理，来支持映射的支持。
- en: Add support for plain objects, by applying the `?` property modifier on each
    of their properties, and passing their values wrapped in `DeepReadonly`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在每个属性上应用`?`属性修饰符，并传递其值包裹在`DeepReadonly`中，来支持普通对象的支持。
- en: Note
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor426).
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以通过[这个链接](B14508_Solution_ePub.xhtml#_idTextAnchor426)找到。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter got you started with the basics of generics and conditional types.
    We learned about generics in a lot of different use cases, why they are useful,
    as well as some extensions to their basic usage – generic defaults and conditional
    types. We performed a couple of exercises to show how you can include generics
    in your code to make it type-safe and avoid errors at runtime.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使你开始了解泛型和条件类型的基础。我们学习了泛型在许多不同的用例中的使用，为什么它们是有用的，以及它们基本使用的一些扩展——泛型默认值和条件类型。我们进行了一些练习，以展示你如何将泛型包含到你的代码中，使其类型安全并避免运行时错误。
- en: Generics are useful in all kinds of applications, both frontend and backend,
    and are used everywhere, but especially so in libraries, where a lot of the time,
    you want to expose an API that leverages the applications' types, which you might
    not know ahead of time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型在所有类型的应用程序中都很有用，无论是前端还是后端，并且被广泛使用，尤其是在库中，因为在很多情况下，你希望公开一个利用应用程序类型的API，而这些类型你可能事先不知道。
- en: In the next chapter, you'll learn about asynchronous development, some of which
    you encountered briefly in this chapter when typing external APIs.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于异步开发的内容，其中一些内容你在本章中在输入外部API时已经简要接触过。
