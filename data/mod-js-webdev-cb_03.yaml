- en: Developing with Node
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node进行开发
- en: 'The recipes we will be seeing in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将看到的示例有：
- en: Checking Node's setup
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查Node的设置
- en: Working with modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块
- en: Using Flow with Node, directly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接使用Flow与Node
- en: Using Flow with Node through preprocessing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flow与Node通过预处理
- en: Running your Node code with Nodemon
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Nodemon运行您的Node代码
- en: Using promises instead of error first callbacks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用承诺代替错误回调
- en: Working with streams to process requests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流处理请求
- en: Compressing files with streams
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流压缩文件
- en: Working with a database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据库
- en: Executing external processes with exec()
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用exec()执行外部进程
- en: Using spawn() to run a command, and communicating with it
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用spawn()运行命令，并与其通信
- en: Using fork() to run Node commands
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fork()来运行Node命令
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: We installed `Node` in the *Installing Node and npm* section of [Chapter 1](d13c6d45-6e6b-4119-9dcd-a65ee7af9f6f.xhtml), *Working
    with JavaScript Development Tools*, but that was only for setting `npm` up. `Node` can
    be used not only as a web server, which is the most common usage, but also to
    write shell line commands or even desktop applications, as we'll see in [Chapter
    13](2aebad42-65b6-4cb7-bf4f-1e2e0907a70a.xhtml), *Creating a Desktop Application
    with Electron*. However, some configuration and development practices are common
    for all those environments, and that will be the objective of this chapter. In
    this chapter, we will get started on `Node` development.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](d13c6d45-6e6b-4119-9dcd-a65ee7af9f6f.xhtml)的*安装Node和npm*部分安装了`Node`，但那只是为了设置`npm`。`Node`不仅可以用作Web服务器，这是最常见的用法，还可以用来编写shell命令行或者桌面应用程序，正如我们将在[第13章](2aebad42-65b6-4cb7-bf4f-1e2e0907a70a.xhtml)中看到的那样，*使用Electron创建桌面应用程序*。然而，所有这些环境都有一些共同的配置和开发实践，这将是本章的目标。在本章中，我们将开始`Node`的开发。
- en: Checking Node's setup
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Node的设置
- en: For starters, let's verify `Node` is working, by creating a very basic server;
    we'll get into more details in the next [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*, but now we just want to make sure everything
    is fine. In other chapters, we will use `Node` more seriously, but the objective
    here is to verify that it works OK.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过创建一个非常基本的服务器来验证`Node`是否正常工作；我们将在下一章[第4章](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml)中详细介绍*使用Node实现RESTful服务*，但现在我们只是想确保一切正常。在其他章节中，我们将更认真地使用`Node`，但这里的目标是验证它是否正常工作。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Getting ahead a bit, let''s set up a very basic server, which will answer all
    the requests by sending back a `''Server alive!''` string. For this, we will need
    to follow three steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微超前一点，让我们设置一个非常基本的服务器，通过发送`'Server alive!'`字符串来回答所有请求。为此，我们需要遵循三个步骤：
- en: Use `require()` to import the `http` module of `Node`—we'll see more on modules
    in the next section; for the time being, just assume that `require()` is equivalent
    to `import`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`require()`导入`Node`的`http`模块——我们将在下一节中更多地了解模块；暂时假设`require()`等同于`import`。
- en: Then, use the `createServer()` method to set up our server.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`createServer()`方法来设置我们的服务器。
- en: After that, provide a function that will answer all requests by sending back
    a `text/plain` fixed answer.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，提供一个函数，通过发送`text/plain`固定的答案来回答所有请求。
- en: 'The following code represents the most basic possible server, and will let
    us know whether everything has worked correctly. I have named the file `miniserver.js`.
    The line in bold does all the work, which we''ll go over in the next section:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码代表了最基本的服务器，将让我们知道一切是否都正常工作。我将文件命名为`miniserver.js`。粗体字的那一行完成了所有的工作，我们将在下一节中详细讨论：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We wrote a server; now, let''s see it run. With this very simple project, we
    can just directly run the server code. In later sections in this chapter, we''ll
    see that using Flow types will require some extra preprocessing; we can skip that
    part for now, however. We can start our server with the following command line:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写了一个服务器；现在，让我们看看它是如何运行的。通过这个非常简单的项目，我们可以直接运行服务器代码。在本章的后面部分，我们将看到使用Flow类型将需要一些额外的预处理；然而，我们现在可以跳过这部分。我们可以使用以下命令行启动我们的服务器：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To verify if everything is working fine, just open a browser and go to `http://localhost:8080`.
    The following screenshot shows the (admittedly not very impressive) result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证一切是否正常工作，只需打开浏览器，转到`http://localhost:8080`。以下截图显示了（诚然不是很令人印象深刻的）结果：
- en: '![](img/e2fc0537-00c7-4548-a154-47bd8504509c.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2fc0537-00c7-4548-a154-47bd8504509c.png)'
- en: Our minimalistic server is running, showing that we have Node working properly
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的极简服务器正在运行，表明我们的Node正常工作
- en: Now that we know that everything is OK, let's get started with some basic techniques
    that we will be using in several other places of the book.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道一切都正常，让我们开始一些基本技术，这些技术将在书中的其他地方使用。
- en: Why are we running the server at port `8080` instead of `80`? To access ports
    below `1024`, you need administrative (root) rights. However, that would make
    your server highly unsafe; a hacker that somehow managed to get into it would
    have maximum rights at your machine! Thus, the standard practice is to run `Node`
    with normal rights, at ports over `1024` (such as `8080`, for example) and set
    up a reverse proxy to send traffic on ports `80` (HTTP) or `443` (HTTPS).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们将服务器运行在端口`8080`而不是`80`？要访问低于`1024`的端口，您需要管理员（root）权限。然而，这将使您的服务器非常不安全；如果黑客设法进入服务器，他将在您的机器上拥有最高权限！因此，标准做法是以普通权限在端口`1024`以上（例如`8080`）运行`Node`，并设置反向代理以将流量发送到端口`80`（HTTP）或`443`（HTTPS）。
- en: Working with modules
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块
- en: 'In the *Organizing code in modules* section of [Chapter 2](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml),
    *Using JavaScript Modern Features*, we saw how modern JS works with modules. However,
    with `Node`, we have a little setback: it doesn''t do modules the modern JS way—unless
    you are willing to work with experimental features!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml)的*在模块中组织代码*部分，我们看到了现代JS如何使用模块。然而，对于`Node`，我们有一点挫折：它不是用现代JS的方式处理模块的——除非您愿意使用实验性功能！
- en: Why doesn't `Node` work with the modern JS modules? The reason harkens back
    to several years before the new modules with `import` and `export` statements
    existed, and `Node` implemented the CommonJS module format. (We'll be seeing more
    about those modules in the next section.) Obviously, libraries meant to be used
    with `Node` were also developed using that format, and nowadays there are an uncountable
    number of modules that follow those guidelines.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`Node`不能使用现代的JS模块？原因可以追溯到新模块出现之前的几年，那时还不存在`import`和`export`语句，`Node`实现了CommonJS模块格式。（我们将在下一节中更多地了解这些模块。）显然，为了与`Node`一起使用的库也是使用了那种格式开发的，现在有无数个遵循这些指南的模块。
- en: However, since the new standard for modules appeared, a pressure began to apply
    to use the new syntax—but that posed some problems beyond just adjusting the language;
    can you have *two* radically different module styles coexisting? (Because, no
    one can magically transform all the existing code that uses CommonJS into the
    new format, right?) There are some other differences. ES modules are meant to
    be used in asynchronous fashion, while CommonJS modules are synchronous; for most
    cases, this doesn't cause a difference, but there are cases that must be considered.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自从新的模块标准出现以来，开始施加压力使用新的语法——但这带来了一些问题，不仅仅是调整语言；你可以让*两种*截然不同的模块风格共存吗？（因为，没有人能够神奇地将所有使用CommonJS的现有代码转换成新的格式，对吧？）还有一些其他的区别。ES模块是用于异步方式使用的，而CommonJS模块是同步的；在大多数情况下，这并不会造成差异，但也有一些必须考虑的情况。
- en: The solution that was arrived at isn't considered definitive yet. For the time
    being (since version 8.5) you can enable the ES modules by using the `--experimental-modules` command
    line flag. If you invoke node with it, it will recognize the ES modules, if their
    extension is `.mjs` instead of plain `.js`. Hopefully, by version 10, it won't
    be needed, but that cannot be ensured, and there's also a certain risk that some
    details might change by then!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 目前得出的解决方案还不能被认为是最终的。目前（自8.5版本以来），你可以通过使用`--experimental-modules`命令行标志来启用ES模块。如果你用它来调用node，它将识别ES模块，如果它们的扩展名是`.mjs`而不是普通的`.js`。希望到10版本时，这将不再需要，但这并不能保证，而且到那时也有一定的风险，一些细节可能会发生变化！
- en: This solution, using the new `.mjs` file extension to identify new-style modules,
    is whimsically known as the **Michael Jackson Solution** because of the initials
    of the three words.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案使用了新的`.mjs`文件扩展名来识别新式模块，因为这个缘故它被戏称为**迈克尔·杰克逊解决方案**，因为这三个单词的首字母。
- en: So, if I were writing this book in one or two years' time, I'd probably be telling
    you to just go ahead, start using the `.mjs` file extension, and use the new style
    modules.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我在一两年后写这本书，我可能会告诉你，只需继续，开始使用`.mjs`文件扩展名，并使用新的模块风格。
- en: See [https://nodejs.org/api/esm.html](https://nodejs.org/api/esm.html) for current
    information about this feature.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此功能的当前信息，请参阅[https://nodejs.org/api/esm.html](https://nodejs.org/api/esm.html)。
- en: However, at this time, it should not be considered a totally safe step—the feature
    is clearly marked as *experimental* at this point of time—so let's keep going
    with the current (old) standard, and learn how to work with the old-fashioned
    modules. Let's create a math module you might want to use for financial coding,
    so we get to see a `Node` style module built from scratch.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此时，这并不被认为是一个完全安全的步骤——这个功能在这个时间点上显然被标记为*实验性*——所以让我们继续使用当前（旧的）标准，并学习如何使用老式模块。让我们创建一个数学模块，你可能想用它来进行金融编码，这样我们就可以看到一个从头开始构建的`Node`风格模块。
- en: How to do it…
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: With `Node` modules, there are two important changes in how we export and import
    elements. Any file can be a module, as with ES modules. In a nutshell, in order
    to import something from a module, you'll have to use a `require()` function,
    and the module itself will use an `exports` object to specify what it will export.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Node`模块，导出和导入元素的方式有两个重要的变化。任何文件都可以是一个模块，就像ES模块一样。简而言之，为了从一个模块中导入东西，你将不得不使用一个`require()`函数，而模块本身将使用一个`exports`对象来指定它将导出什么。
- en: 'JS math operators (addition, subtraction, and so on) don''t do rounding, so
    let''s write a `roundmath.js` module that will perform arithmetic, but rounding
    to cents, for an imagined business-related application. First, we get started
    with the common two lines that enable `Flow`, and set strict mode:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JS数学运算符（加法、减法等）不会进行四舍五入，所以让我们编写一个`roundmath.js`模块，它将执行算术运算，但是将结果四舍五入到分，用于想象中的与业务相关的应用程序。首先，我们从启用`Flow`和设置严格模式的两行常见代码开始：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don't forget to add the `"use strict"` line in all your modules, before the
    rest of your code, as we mentioned in the *Working in strict mode* section in
    the previous chapter. JS modules are strict by definition, but that doesn't apply
    to `Node` modules, which are *not* strict.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在所有模块的代码之前添加`"use strict"`行，就像我们在上一章的*在严格模式下工作*部分中提到的那样。JS模块在定义上是严格的，但这并不适用于`Node`模块，它们*不*是严格的。
- en: 'Then, let''s define our functions. Just for variety, we''ll have a couple of
    internal (not exported) functions, and several ones that will be exported:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们定义我们的函数。为了多样化，我们将有一些内部（不导出）函数，以及一些将被导出的函数：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, as per usual conventions, all exports will be together, at the bottom,
    so it will be easy to see everything that a module exports. Instead of the modern
    `export` statement, you assign whatever you want to export, to an `exports` object.
    If you want to keep variables or functions private, all you need do is skip assigning
    them; in our case, we are only exporting four of the six functions we coded:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照通常的惯例，所有的输出将在底部放在一起，这样就很容易看到模块导出的所有内容。与现代的`export`语句不同，你可以将想要导出的内容赋值给一个`exports`对象。如果你想要保持变量或函数私有，你只需要跳过赋值；在我们的例子中，我们只导出了我们编写的六个函数中的四个。
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'How would we use this module, and how does it work? If we wanted to import
    some of its functions from other modules, we''d write something as follows; see
    how we use some of the operations we designed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这个模块，它是如何工作的？如果我们想要从其他模块导入一些函数，我们会写如下内容；看看我们如何使用我们设计的一些操作：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first two lines are the usual. Then, we `require()` whatever modules we
    need; in this case, a single one. Also, per convention, all such requirements
    are grouped together, at the start, to make it simpler to understand the needs
    of a module, without having to go all through the code. In our case, `RM` gets
    assigned the `exports` object, so you can refer to `RM.addR()`, `RM.subR()`, and
    so on, and this makes clear to the reader that you are using something from the
    `RM` module.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行是通常的。然后，我们`require()`我们需要的任何模块；在这种情况下，只有一个。此外，按照惯例，所有这些要求都被分组在一起，从头开始，以便更容易理解模块的需求，而不必浏览整个代码。在我们的例子中，`RM`被分配了`exports`对象，所以你可以引用`RM.addR()`，`RM.subR()`等等，这清楚地告诉读者你正在使用`RM`模块的东西。
- en: 'If you want to write a bit less, you can take advantage of the *destructuring
    statement* (which we met in the *Destructuring arrays and objects* section in
    the previous chapter) and directly assign the desired methods to individual variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想写得更少一些，你可以利用*解构语句*（我们在上一章的*解构数组和对象*部分遇到过）直接将所需的方法分配给单独的变量：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is better if you get used to only importing modules that you'll need. In
    other cases (which we'll see in later chapters) we can use tools to just remove
    whatever modules you don't actually use, and if you `require()` everything, that
    wouldn't be possible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最好习惯于只导入你需要的模块。在其他情况下（我们将在后面的章节中看到），我们可以使用工具来删除你实际上没有使用的任何模块，如果你`require()`所有东西，那是不可能的。
- en: Using Flow with Node, directly
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接使用Flow与Node
- en: 'Since we are using `Flow`, and `Node` doesn''t actually know about the data
    types, there will obviously be problems if we just try to execute our data-typed
    code. There are two solutions for this: one not so elegant, but that speeds up
    development, and another more powerful one, but that will require extra work.
    Let''s here consider the first, simpler solution, and leave the second one for
    the next section.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`Flow`，而`Node`实际上并不知道数据类型，如果我们尝试执行我们的数据类型代码，显然会出现问题。对此有两种解决方案：一种不太优雅，但可以加快开发速度，另一种更强大，但需要额外的工作。让我们在这里考虑第一种更简单的解决方案，把第二种留给下一节。
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'It so happens that `Flow` provides two ways of specifying types: the way that
    we have been using so far, with extra type notations, and another more verbose
    one, through the comments. Of course, JS doesn''t *know* about type definitions,
    so the first style won''t work unless we do extra work (as we''ll see) but using
    comments is totally safe.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 碰巧`Flow`提供了两种指定类型的方式：到目前为止我们一直在使用的方式，带有额外的类型标记，以及另一种更冗长的方式，通过注释。当然，JS并不了解类型定义，所以第一种风格不会起作用，除非我们做额外的工作（正如我们将看到的），但使用注释是完全安全的。
- en: 'To define types with comments, all `Flow` specific definitions must be enclosed
    in comments starting with `/*:` (note the extra colon) and finishing with the
    usual `*/`, for simple basic types, or `/*::` and `*/` for everything else. We
    can revisit some examples we saw earlier in [Chapter 2](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml),
    *Using JavaScript Modern Features*. Simple cases are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要用注释定义类型，所有`Flow`特定的定义都必须用以`/*:`开头的注释括起来，以通常的`*/`结束，对于简单的基本类型，或者用`/*::`和`*/`来定义其他类型。我们可以回顾一些我们在[第2章](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml)中看到的例子。简单的情况如下：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'More complex definitions, including optional parameters, types and opaque types,
    class attributes, and so on, require the longer comments:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的定义，包括可选参数、类型和不透明类型、类属性等等，需要更长的注释：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also export and import data types:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以导出和导入数据类型：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Why and how does this work? `Flow` is able to recognize both the `/*::  ... 
    */` and `*/**:  ...  */` comments, and thus can do its job perfectly well. Since
    the `Flow` code is all hidden away in comments, from the point of view of the
    JS engine, the `Flow` parts do not even exist, so an obvious advantage of this
    way of working is that you can directly execute your code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么以及这是如何工作的？`Flow`能够识别`/*::  ...  */`和`*/**:  ...  */`注释，因此可以很好地完成它的工作。由于`Flow`代码都隐藏在注释中，从JS引擎的角度来看，`Flow`部分甚至不存在，因此这种工作方式的明显优势是你可以直接执行你的代码。
- en: Why would you *not* like this? The evident criticism is that the code looks,
    to put it mildly, ugly. If you were used to, say, `TypeScript`, having to wrap
    all type-related things in comments can become a chore, and the code will also
    be harder to read. Also, there is a risk that you'll mistype a comment (forgetting
    one of those many colons is a possibility) and then Flow will just ignore your
    definitions, posing a possible risk of letting a bug go through.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你不喜欢这个？显而易见的批评是，代码看起来，委婉地说，很丑陋。如果你习惯于，比如说，`TypeScript`，不得不把所有与类型相关的东西都用注释包起来可能会变得很繁琐，代码也会变得更难阅读。此外，有可能会出现你会输错注释的风险（忘记其中的一个冒号是可能的），然后Flow将会忽略你的定义，可能会让bug通过。
- en: Is there an alternative? Yes, there is, but it will require some extra processing,
    while giving us the benefit of using standard `Flow` notation; let's turn to that
    now.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有其他选择？是的，有，但这将需要一些额外的处理，同时给我们使用标准`Flow`符号的好处；让我们现在转向这个。
- en: Using Flow with Node through preprocessing
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过预处理使用Flow与Node
- en: Working with comments is a bit overly verbose. If you'd rather work with straightforward
    type annotations and extra statements, you will have to turn to some preprocessing,
    to get rid of the `Flow` paraphernalia before attempting to run your `Node` code.
    The good thing with this is that the required processing can be quite efficient,
    and practically unnoticeable when you develop; let's get into it, and see how
    we can get to keep `Flow` definitions, while not breaking our `Node` code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注释有点过于冗长。如果您更愿意使用直接的类型注释和额外的语句，您将不得不进行一些预处理，以在尝试运行您的`Node`代码之前摆脱`Flow`的装饰。这样做的好处是，所需的处理可以非常高效，并且在开发时几乎不会被注意到；让我们深入研究一下，看看我们如何保留`Flow`定义，同时不破坏我们的`Node`代码。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We want to use the shorter, more concise style of `Flow`, but `Node` cannot
    execute code with such additives.The solution to our conundrum is easy: just remove
    everything related to `Flow` before attempting to run! There is a package, `flow-remove-types`,
    that does just that. To start, as usual, you''ll have to install the needed package:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用更简短、更简洁的`Flow`风格，但`Node`无法执行带有这些附加内容的代码。我们的难题的解决方案很简单：在尝试运行之前，只需删除与`Flow`相关的所有内容！有一个叫做`flow-remove-types`的包可以做到这一点。首先，像往常一样，您需要安装所需的包：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To continue, you will have to enable it by adding a new script. We were writing
    our code in the `src/` directory, so let''s send the `Flow`-cleaned output to
    the `out/` directory. In that directory, we will get the version of the code that
    we will use in our server:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，您将需要通过添加一个新的脚本来启用它。我们是在`src/`目录中编写我们的代码，所以让我们将`Flow`清理后的输出发送到`out/`目录。在那个目录中，我们将得到我们将在服务器中使用的代码版本：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To finish, we should also tell `Git` to ignore the `out/` directory. We were
    already ignoring the `node_modules` and `flow-typed` directories, so let''s add
    one more:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还应该告诉`Git`忽略`out/`目录。我们已经忽略了`node_modules`和`flow-typed`目录，所以让我们再添加一个：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are specifying `**/out` instead of just `out/`, because we are sharing a
    single `Git` repository between many projects, for the sake of the book. If, as
    is more common, you had a separate repository for each project, then you would
    simply specify `out`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定`**/out`而不是只有`out/`，因为我们在许多项目之间共享一个`Git`存储库，为了这本书。如果像更常见的那样，您为每个项目都有一个单独的存储库，那么您只需指定`out`。
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: What will change from the moment you start using `flow-remove-types`? First,
    obviously, you cannot just run your project with a simple `node src/somefilename.js`;
    first you'll have to strip `Flow` by `npm run build`. The effect of this command
    will be to create a copy in `out/`, of everything in `src/`, but without type
    declarations. Then, you will be able to run the project by doing `node out/somefilename.js`—filenames
    won't be changed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从您开始使用`flow-remove-types`起，会有什么变化？首先，显而易见的是，您不能只是用简单的`node src/somefilename.js`来运行您的项目；首先您需要通过`npm
    run build`来剥离`Flow`。这个命令的效果将是在`out/`中创建一个`src/`中的所有内容的副本，但没有类型声明。然后，您将能够通过`node
    out/somefilename.js`来运行项目——文件名不会改变。
- en: 'When `flow-remove-types` package cleans up your files, it replaces all type
    declarations with whitespaces, so the transformed output files have exactly the
    same number of lines, and every function starts at exactly the same line as before,
    removing the need for sourcemaps and keeping the output legible. The following
    code shows how part of our module from the *Working with modules* section would
    look after the process:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当`flow-remove-types`包清理您的文件时，它会用空格替换所有类型声明，因此转换后的输出文件的行数完全相同，每个函数的起始行也完全相同，不需要源映射，输出可读性不变。下面的代码显示了在*使用模块*部分中的我们模块的一部分在处理后的样子：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you would rather have a smaller-sized output (after all, reading code with
    all those blank spaces can be a bit tiresome) you can produce a source map and
    remove all spaces, by adding a couple of parameters to your build script, or by
    adding a different script, as shown in the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢较小的输出（毕竟，阅读带有所有这些空格的代码可能有点令人厌烦），您可以生成一个源映射并删除所有空格，方法是通过向构建脚本添加一些参数，或者通过添加一个不同的脚本，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Node` debugger included in VSC fully supports source maps, so producing
    briefer code won't be a problem. We'll get to see more about this in [Chapter
    5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml), *Testing and Debugging Your Server*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: VSC中包含的`Node`调试器完全支持源映射，因此生成更简洁的代码不会成为问题。我们将在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)中更多地了解这一点，*测试和调试您的服务器*。
- en: Now we have a way to keep working with `Node` and `Flow` together, but running
    our code has become just a tad more complex; let's see if we can fix that!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种方法来继续使用`Node`和`Flow`，但是运行我们的代码变得稍微复杂了一点；让我们看看我们是否可以解决这个问题！
- en: Running your Node code with Nodemon
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nodemon运行您的Node代码
- en: 'With the work we have done so far, after each and every change, running our
    updated `Node` code would require that we perform the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的工作是，每次进行更改后，运行我们更新的`Node`代码都需要执行以下操作：
- en: Stop the current version of the code, if it's still running.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止当前版本的代码，如果它仍在运行。
- en: Rerun the build process to update the `out` directory.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行构建过程以更新`out`目录。
- en: Run the new version of the code.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行新版本的代码。
- en: 'Doing all of this, for every single small change, can quickly become boring
    and tiresome. But, there is a solution: we can install a watcher, that will monitor
    our files for changes and do everything mentioned here by itself, freeing us from
    the repetitive chore. Let''s then see how we can set a tool to watch out for changes,
    and do all the steps shown on its own.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个小的更改，做所有这些事情可能会很快变得无聊和令人厌烦。但是，有一个解决方案：我们可以安装一个监视程序，它将监视我们的文件变化，并自动执行这里提到的所有操作，从而使我们摆脱重复的琐事。让我们看看如何设置一个工具来监视变化，并自动执行所有这些步骤。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will want to install and configure `nodemon`, which will take care of everything
    for us, running updated code as necessary. First, obviously, we must install the
    mentioned package. You could do it globally with `npm install nodemon -g`, but
    I''d rather do it locally:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要安装和配置`nodemon`，它将为我们处理一切，根据需要运行更新的代码。首先，显然，我们必须安装提到的包。您可以使用`npm install
    nodemon -g`全局安装，但我宁愿在本地安装：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we''ll need to add a couple of scripts:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要添加一对脚本：
- en: '`npm start` will build the application and run our main file'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm start`将构建应用程序并运行我们的主文件'
- en: '`npm run nodemon` will start the monitoring'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm run nodemon`将开始监视'
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we are ready to monitor our application for changes, and restart it as
    needed!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好监视我们的应用程序进行更改，并根据需要重新启动它！
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The command most interesting for us is the second one. When you run it, `nodemon`
    will start monitoring, meaning it will watch whatever directory you selected (`out`,
    in this case) and whenever it detects some file change, it will wait one second
    (to make sure, for example, that all files are saved) and then it will rerun the
    application. How did I do this?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们最感兴趣的命令是第二个。当您运行它时，`nodemon`将开始监视，这意味着它将监视您选择的任何目录（在这种情况下是`out`），每当它检测到某个文件更改时，它将等待一秒钟（例如，以确保所有文件都已保存），然后重新运行应用程序。我是如何做到这一点的？
- en: 'Initially, I started `nodemon`. When you do `npm run nodemon`, the project
    is built and then run, and `nodemon` keeps waiting for any changes; see the following
    screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我启动了`nodemon`。当您运行`npm run nodemon`时，项目将被构建然后运行，`nodemon`将继续等待任何更改；请参阅以下截图：
- en: '![](img/bb4c6879-9f4f-494f-b329-4e368b746c39.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb4c6879-9f4f-494f-b329-4e368b746c39.png)'
- en: When you start nodemon, it builds the project, runs it, and keeps watching out
    for any changes that need a restart
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动nodemon时，它会构建项目，运行它，并继续观察是否有任何需要重新启动的更改
- en: 'Afterwards, I just added a simple `console.log()` line, so a file would be
    changed; the following screenshot was the result, showing the rebuilt and restarted
    code, plus the extra output line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我只是添加了一个简单的`console.log()`行，所以文件会被更改；以下截图是结果，显示了重建和重新启动的代码，以及额外的输出行：
- en: '![](img/591781d5-b334-44be-8f39-51cbaa44ef65.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/591781d5-b334-44be-8f39-51cbaa44ef65.png)'
- en: After any change in a watched file, nodemon will restart the project. In this
    case, I had just added a line logging ADDED TEXT JUST FOR THE CHANGE.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察文件发生任何更改后，nodemon将重新启动项目。在这种情况下，我刚刚添加了一行日志，用于更改的添加文本。
- en: That's all there is to it. The application will be rebuilt and restarted automatically,
    without us having to manually rerun `npm start` each and every time; a big help!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。应用程序将自动重新构建和重新启动，而无需我们每次手动重新运行`npm start`；这是一个很大的帮助！
- en: Read more about `nodemon` at [http://nodemon.io/](http://nodemon.io/) and [https://github.com/remy/nodemon.](https://github.com/remy/nodemon)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读更多关于`nodemon`的信息[http://nodemon.io/](http://nodemon.io/)和[https://github.com/remy/nodemon.](https://github.com/remy/nodemon)
- en: Using promises instead of error first callbacks
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺而不是错误优先的回调
- en: Now, let's start considering several techniques that will come in handy when
    writing services.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始考虑在编写服务时会派上用场的几种技术。
- en: '`Node` runs as a single thread, so if every time it had to call a service,
    or read a file, or access a database, or do any other I/O-related operation, it
    would have to wait for it to finish, then attending requests would take a long
    time, blocking other requests from being attended, and the server would show a
    very bad performance. Instead, all operations such as those are always done asynchronically,
    and you must provide a callback that will be called whenever the operation is
    finished; meanwhile, `Node` will be available to process other clients'' requests.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node`作为一个单线程运行，所以如果每次它需要调用一个服务，或者读取一个文件，或者访问一个数据库，或者进行任何其他I/O相关的操作，它都必须等待它完成，那么处理请求将需要很长时间，阻塞其他请求的处理，并且服务器的性能会非常差。相反，所有这些操作都是异步进行的，您必须提供一个回调，当操作完成时将调用该回调；与此同时，`Node`将可用于处理其他客户端的请求。'
- en: There are synchronous versions of many functions, but they can only be applied
    for desktop work, and never for web servers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多函数的同步版本，但它们只能应用于桌面工作，而绝不能用于Web服务器。
- en: '`Node` established a standard that all callbacks should receive two parameters:
    an error and a result. If the operation failed somehow, the error argument would
    describe the reason. Otherwise, if the operation had succeeded, the error would
    be null or undefined (but, in any case, a *falsy* value) and the result would
    have the resultant value.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node`建立了一个标准，即所有回调都应该接收两个参数：一个错误和一个结果。如果操作以某种方式失败，错误参数将描述原因。否则，如果操作成功，错误将为null或undefined（但无论如何都是*假值*），结果将具有结果值。'
- en: This means that the usual `Node` code is full of callbacks, and if a callback
    itself needs another operation, that means yet more callbacks, which themselves
    may have even more callbacks, resulting in what is called *callback hell*. Instead
    of working in this fashion, we want to be able to opt for modern promises, and,
    fortunately, there is a simple way to do so. Let's see how we can simplify our
    code by avoiding callbacks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着通常的`Node`代码充满了回调，如果回调本身需要另一个操作，那就意味着更多的回调，这些回调本身可能有更多的回调，导致所谓的*回调地狱*。我们不想以这种方式工作，我们希望能够选择现代的承诺，幸运的是，有一种简单的方法可以做到这一点。让我们看看如何通过避免回调来简化我们的代码。
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s start by seeing how a common error first callback works. The `fs` (file
    system) module provides a `readFile()` method that can read a file, and either
    produce its text or an error. My `showFileLength1()` function attempts to read
    a file, and list its length. As usual with callbacks, we have to provide a function,
    which will receive two values: a possible error, and a possible result.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下常见的错误优先回调是如何工作的。`fs`（文件系统）模块提供了一个`readFile()`方法，可以读取一个文件，并且可以生成它的文本或错误。我的`showFileLength1()`函数尝试读取一个文件，并列出其长度。与回调一样，我们必须提供一个函数，该函数将接收两个值：可能的错误和可能的结果。
- en: 'This function must check whether the first argument is null or not. If it isn''t
    null, it means there was a problem, and the operation wasn''t successful. On the
    other hand, if the first argument is null, then the second argument has the file
    read operation result. The following code highlights the usual programming pattern
    used with `Node` callbacks; the lines in bold are the key ones:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数必须检查第一个参数是否为null。如果不为null，则意味着存在问题，操作不成功。另一方面，如果第一个参数为null，则第二个参数具有文件读取操作的结果。以下代码突出了与`Node`回调一起使用的通常编程模式；粗体字的行是关键行：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This style of coding is well-known, but doesn''t really fit modern development,
    based on promises and, even better, `async`/`await`. So, since version 8 of `Node`,
    there has been a way to automatically transform an error-first callback function
    into a promise: `util.promisify()`. If you apply that method to any old-style
    function, it will turn into a promise, which you can then work in simpler ways.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码风格是众所周知的，但实际上并不适合基于promise甚至更好的`async`/`await`的现代开发。因此，自`Node`的8版本以来，已经有一种方法可以自动将错误优先的回调函数转换为promise：`util.promisify()`。如果将该方法应用于任何旧式函数，它将变成一个promise，然后您可以以更简单的方式进行处理。
- en: How it works…
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: 'The `util` module is standard with `Node`, and all you have to do to use it
    is the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`util`模块是`Node`的标准模块，您只需执行以下操作即可使用它：'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `util.promisify()` method is actually another example of a Higher Order
    Function, as we saw in the *Producing functions from functions* section of [Chapter
    2](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml), *Using JavaScript Modern Features*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`util.promisify()`方法实际上是另一个高阶函数的示例，正如我们在[第2章](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml)的*使用JavaScript现代特性*部分中看到的那样。'
- en: 'Using `util.promisify()`, we can make `fs.readFile()` return a promise, which
    we''ll process with the `.then()` and `.catch()` methods:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`util.promisify()`，我们可以使`fs.readFile()`返回一个promise，然后使用`.then()`和`.catch()`方法进行处理：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You could have also written `const { promisify } = require("util")`, and then
    it would have been `fs.readFile = promisify(fs.readFile)`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写`const { promisify } = require("util")`，然后它将变成`fs.readFile = promisify(fs.readFile)`。
- en: 'This also allows us the usage of `async` and `await`; I''ll be using an arrow
    `async` function, just for variety:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这还允许我们使用`async`和`await`；我将使用箭头`async`函数，只是为了多样性：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's more…
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Keep in mind that you won''t always be needing `util.promisify()`. There are
    two reasons for this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您并不总是需要`util.promisify()`。这有两个原因：
- en: Some libraries (such as `axios`, which we already used) already return promises,
    so you don't have to do anything
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些库（例如我们已经使用的`axios`）已经返回了promise，因此您无需做任何事情。
- en: Some other methods (such as the `http.request()` method of `Node`; see [https://nodejs.org/dist/latest-v9.x/docs/api/http.html#http_http_request_options_callback](https://nodejs.org/dist/latest-v9.x/docs/api/http.html#http_http_request_options_callback))
    have a different signature altogether, without even an error argument
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他一些方法（例如`Node`的`http.request()`方法；请参见[https://nodejs.org/dist/latest-v9.x/docs/api/http.html#http_http_request_options_callback](https://nodejs.org/dist/latest-v9.x/docs/api/http.html#http_http_request_options_callback)）具有完全不同的签名，甚至没有错误参数
- en: In any case, aiming for a standard usage will help, so we'll adopt the promise-based
    style for the rest of the book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，追求标准用法都会有所帮助，因此我们将在本书的其余部分采用基于promise的风格。
- en: Working with streams to process requests
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流来处理请求
- en: If you have to work with a large enough set of data, it's fairly obvious that
    it will cause problems. Your server may not be able to provide all the required
    memory, or even if that doesn't prove to be a problem, the needed processing time
    would surpass the standard waiting time, causing timeouts—plus the fact that your
    server would close out other requests, because it would be devoted to handling
    your long-time processing one.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须处理大量数据集，很明显会引起问题。您的服务器可能无法提供所有所需的内存，或者即使这不会成为问题，所需的处理时间也会超过标准等待时间，导致超时
    - 再加上您的服务器会关闭其他请求，因为它将致力于处理您的长时间处理请求。
- en: '`Node` provides a way to work with collections of data as streams, being able
    to process the data as it flows, and piping it to compose functionality out of
    smaller steps, much in the fashion of Linux''s and Unix''s pipelines. Let''s see
    a basic example, which you might use if you were interested in doing low-level
    `Node` request processing. (As is, we will be using higher-level libraries to
    do this work, as we''ll see in the next chapter.) When a request comes in, its
    body can be accessed as a stream, thus allowing your server to deal with any size
    of requests.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node`提供了一种使用流来处理数据集合的方法，能够在数据流动时处理数据，并将其传输以将功能组合成更小步骤的方式，非常类似于Linux和Unix的管道。让我们看一个基本示例，如果您有兴趣进行低级`Node`请求处理，可以使用该示例。（正如我们将在下一章中看到的那样，我们将使用更高级的库来完成这项工作。）当请求到来时，其主体可以作为流访问，从而使您的服务器能够处理任何大小的请求。'
- en: The response that will be sent to the client is also a stream; we'll see an
    example of this in the next section, *Compressing files with streams*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将发送给客户端的响应也是一个流；我们将在下一节*使用流压缩文件*中看到一个示例。
- en: 'Streams can be of four kinds:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 流可以有四种类型：
- en: '*Readable*: Which can (obviously!) be read. You would use this to process a
    file, or, as in our following example, to get a web request''s data.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可读*：可以（显然！）读取的地方。您可以使用此选项来处理文件，或者如下例所示，获取网络请求的数据。'
- en: '*Writable*: To which data can be written.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可写*：可以写入数据的地方。'
- en: '*Duplex*: Both readable and writable, such as a web socket.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双工*：可读写，例如网络套接字。'
- en: '*Transform*: Duplex streams that can transform the data as it is read and written;
    we''ll see an example of this for zipping files.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转换*：可以转换读取和写入的双工流；我们将看到一个用于压缩文件的示例。'
- en: How to do it…
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s write some simple code to process a request, and just show what was
    asked. Our main code for the request process will be the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些简单的代码来处理请求，并显示所请求的内容。我们的请求处理的主要代码将如下所示：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `processRequest()` function will be quite simple, limited to showing its
    parameters. This kind of code can become helpful if you need to better understand
    how to process requests, as we''ll see in the next chapter. We will get parameters
    both from the URL and the request body:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`processRequest()`函数将非常简单，仅限于显示其参数。如果您需要更好地理解如何处理请求，这种代码可能会有所帮助，正如我们将在下一章中看到的那样。我们将从URL和请求体中获取参数：'
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output of this code, which we'll see next, will be the the request `url`
    object (`req.url`), its parameters, and the parameters in the body.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们将看到的代码输出将是请求`url`对象（`req.url`），它的参数以及请求体中的参数。
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Let''s run the simple server we just wrote, to see how it works. We can build
    and run it with the following two lines:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行刚刚编写的简单服务器，看看它是如何工作的。我们可以使用以下两行构建并运行它：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After the server is running, we can test it by using `curl`—we''ll get back
    to this in the *Testing simple services from the command line* section of [Chapter
    5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml), *Testing and Debugging Your Server*,
    and we''ll see our `FINISHED...` message:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器运行后，我们可以使用`curl`进行测试——我们将在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)的*从命令行测试简单服务*部分中回到这一点，并且我们将看到我们的`FINISHED...`消息：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The quote characters around the URL are needed, because the `&` character has
    a special meaning by itself for shell line commands.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: URL周围的引号是必需的，因为`&`字符本身对于shell行命令具有特殊含义。
- en: 'The server console will show the following output, but what we care about right
    now are the URL parameters, that match with what was provided in the `curl` call:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器控制台将显示以下输出，但我们现在关心的是URL参数，它与`curl`调用中提供的内容匹配：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This was easy, but if the service request had been a `POST`, we would have
    listened to events to build up the `body` of the request. Refer to the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易，但如果服务请求是`POST`，我们将监听事件来构建请求的`body`。请参考以下：
- en: '`''data''` is fired whenever there is more data to be processed. In our case,
    on each event we add to the `body` string, so as to build up the request body'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''data''`在有更多数据需要处理时触发。在我们的情况下，每次事件中我们都会向`body`字符串添加内容，以便构建请求体'
- en: '`''end''` is fired when there is no more data. Here, we use it to recognize
    when we have got the complete body of the request, and are then ready to move
    on and process it.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有更多数据时，将触发`'end'`。在这里，我们使用它来识别我们已经获得了完整的请求体，并且现在准备继续处理它。
- en: '`''close''` (when a stream is closed) and `''error''` events do not apply here,
    but are also available for stream processing.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''close''`（当流关闭时）和`''error''`事件在这里不适用，但也适用于流处理。'
- en: 'If we were to do `curl -X "POST" --data "gamma=60" --data "delta=FK" "http://127.0.0.1:8080/other/path/"` to
    perform a `POST`, passing a couple of body parameters, the console output would
    change:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`curl -X "POST" --data "gamma=60" --data "delta=FK" "http://127.0.0.1:8080/other/path/"`进行`POST`，传递一对body参数，控制台输出将会改变：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Read more about streams (a lot of information!) at [https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html)上阅读更多关于流的信息（大量信息！）。
- en: Compressing files with streams
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流压缩文件
- en: We can see more examples of using streams, of several types, such as in cases
    where we wanted to zip a file. In this recipe, we will be using a readable stream
    to read from a source, and a writable stream to put the zipped result.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到更多使用流的例子，包括多种类型，比如我们想要压缩文件的情况。在这个示例中，我们将使用可读流从源中读取，使用可写流放置压缩后的结果。
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The code is quite straightforward, and short, too. We just have to `require`
    the needed modules, create an input stream for the file that we''ll read, an output
    stream for the file that we''ll create, and pipe the first stream to the second
    one; nothing could be simpler:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单，而且也很短。我们只需要`require`所需的模块，为我们将要读取的文件创建一个输入流，为我们将要创建的文件创建一个输出流，并将第一个流导入到第二个流中；没有比这更简单的了：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We use the `fs` module to produce two streams: a readable one, with which we
    will be reading a given file (here, a fixed one, but it would be trivial to read
    any other one) and a writable one, where the gzipped output will go. We will pipe
    the input stream through the `gzip` module, which will compress the input before
    passing it on to the output.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`fs`模块生成两个流：一个可读流，用于读取给定文件（这里是一个固定的文件，但读取任何其他文件也很简单），一个可写流，用于存放压缩后的输出。我们将通过`gzip`模块将输入流导入，该模块将在将输入传递到输出之前对其进行压缩。
- en: 'We could as easily have produced a server that would have sent the zipped file
    to the client, to download. The following is the required code; the key difference
    is that the zipped stream now goes to the `response` stream. We must also provide
    some headers, so the client will know that a zipped file is being sent:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以轻松地创建一个服务器，将压缩文件发送给客户端进行下载。以下是所需的代码；关键区别在于压缩流现在转到`response`流。我们还必须提供一些头信息，以便客户端知道正在发送一个压缩文件：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you `npm run build` and then `node out/zip_send.js`, opening `127.0.0.1:8080`
    will get what is shown in the following screenshot; you get the zipped file to
    download:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您`npm run build`然后`node out/zip_send.js`，打开`127.0.0.1:8080`将会得到以下截图中显示的内容；您将获得要下载的压缩文件：
- en: '![](img/c88deced-a53c-4c57-8b0b-568e86a2f7cd.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c88deced-a53c-4c57-8b0b-568e86a2f7cd.png)'
- en: Streams are also used to zip and send a file to the browser
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 流也用于压缩并发送文件到浏览器
- en: Read more about `fs` at [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html),
    and about `zlib` at [https://nodejs.org/api/zlib.html](https://nodejs.org/api/zlib.html).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)上阅读更多关于`fs`的信息，并在[https://nodejs.org/api/zlib.html](https://nodejs.org/api/zlib.html)上阅读更多关于`zlib`的信息。
- en: Working with a database
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库
- en: Let's now see how you would access a database, such as `MySQL`, `PostgreSQL`,
    `MSSQL`, `Oracle`, or more. (We will be needing this in [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*, when we get to build a set of services.)
    Accessing a database is frequently done, so that's what we will be doing. I chose
    some geographical data (with countries, their regions, and the cities in those),
    to which we'll later add something else, to work with more complex examples.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何访问数据库，比如`MySQL`，`PostgreSQL`，`MSSQL`，`Oracle`或其他。 (我们将在[第4章](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml)中需要这个，*使用Node实现RESTful服务*，当我们开始构建一组服务时。)
    经常需要访问数据库，所以这就是我们要做的。我选择了一些地理数据（包括国家，它们的地区以及这些地区的城市），之后我们将添加一些其他内容，以便处理更复杂的例子。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Getting a list of countries was easy: I used the data from [https://github.com/datasets/country-codes](https://github.com/datasets/country-codes),
    which I pruned down to just the country two-character code (as in the ISO 3166-1
    norm) and name. For regions and cities, I used GeoNames'' data from [http://download.geonames.org/export/dump/](http://download.geonames.org/export/dump/);
    in particular, I used `admin1CodesASCII.txt`, which I reworked into `regions.csv`,
    and `cities15000.zip`, which I edited into `cities.csv`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 获取国家列表很容易：我使用了来自[https://github.com/datasets/country-codes](https://github.com/datasets/country-codes)的数据，我将其修剪为只有国家的两个字符代码（如ISO
    3166-1标准中的那样）和名称。对于地区和城市，我使用了GeoNames的数据，来自[http://download.geonames.org/export/dump/](http://download.geonames.org/export/dump/)；特别是我使用了`admin1CodesASCII.txt`，我将其改编为`regions.csv`，以及`cities15000.zip`，我编辑成了`cities.csv`。
- en: If you want to be able to view CSV files in a clearer format, check out the
    EXCEL VIEWER extension for VSC.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想以更清晰的格式查看CSV文件，可以查看VSC的EXCEL VIEWER扩展。
- en: 'What you need to know about these three tables is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这三个表，你需要知道的是：
- en: '*Countries* are identified by a two-letter code (such as *UY* for Uruguay,
    or *IN* for India), and have a name'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*国家*由两个字母的代码标识（比如*UY*代表乌拉圭，*IN*代表印度），并且有一个名称'
- en: '*Regions* belong to a country, and are identified by the country code, plus
    a string; in addition, they have a name'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*地区*属于一个国家，由国家代码加上一个字符串标识；此外，它们有一个名称'
- en: '*Cities* are identified by a numeric code, have a name, latitude and longitude,
    population, and are in a region of a country'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*城市*由数字代码标识，有一个名称，纬度和经度，人口，并且位于一个国家的一个地区'
- en: This is enough to get started; later, we will be adding some more tables, to
    experiment a bit more. I used `MariaDB` (the open fork of `MySQL`; see [https://mariadb.com/](https://mariadb.com/))
    and `MySQL WorkBench` (see [https://www.mysql.com/products/workbench/](https://www.mysql.com/products/workbench/))
    to create the tables and import the data, just because it's even simpler than
    doing it by hand! I also created a `fkereki` user, with `modernJS!!` as the password,
    to access the tables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够开始了；稍后，我们将添加一些更多的表，以便进行更多的实验。我使用了`MariaDB`（`MySQL`的开源分支；参见[https://mariadb.com/](https://mariadb.com/)）和`MySQL
    WorkBench`（参见[https://www.mysql.com/products/workbench/](https://www.mysql.com/products/workbench/)）来创建表并导入数据，因为这比手工操作更简单！我还创建了一个`fkereki`用户，密码为`modernJS!!`，以便访问这些表。
- en: If you want to use a different database, such as PostgreSQL or Oracle, the following
    code will be quite similar, so don't worry much about dealing with a specific
    DB. If you use an ORM, you'll then see some DB-independent ways of accessing data,
    which could help should you really have to deal with different DB products.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用不同的数据库，比如PostgreSQL或Oracle，下面的代码会非常相似，所以不用太担心处理特定的数据库。如果你使用ORM，你会看到一些访问数据的与数据库无关的方法，这可能会帮助你真正需要处理不同的数据库产品时。
- en: How to do it…
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: In order to access a `MariaDB` database, we will install the `mariasql` package
    from [https://github.com/mscdex/node-mariasql](https://github.com/mscdex/node-mariasql)
    and then promisify its `.query()` method, to work in an easier fashion. Installation
    is accomplished with `npm install mariasql --save` and, after a short while (you
    will see some object code being built), the package will be installed. Follow
    the steps mentioned next.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问`MariaDB`数据库，我们将从[https://github.com/mscdex/node-mariasql](https://github.com/mscdex/node-mariasql)安装`mariasql`包，然后将其`.query()`方法promisify，以便更轻松地工作。安装完成后使用`npm
    install mariasql --save`，不久之后（你会看到一些对象代码被构建），包将被安装。按照接下来提到的步骤进行。
- en: Another possibility would be to use `mariasql-promise` from [https://github.com/steelbrain/mariasql-promise](https://github.com/steelbrain/mariasql-promise),
    all of whose methods already return promises. However, getting the connection
    object and storing it for later use is harder with this library, and that's why
    I opted for the original one; after all, we only need to modify `.query()` to
    return a promise.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能性是使用来自[https://github.com/steelbrain/mariasql-promise](https://github.com/steelbrain/mariasql-promise)的`mariasql-promise`，其所有方法都已经返回了promises。然而，使用这个库获取连接对象并存储以供以后使用更加困难，这就是为什么我选择了原始的库；毕竟，我们只需要修改`.query()`来返回一个promise。
- en: Getting a connection
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取连接
- en: 'First, let''s have some constants that we will be using later; apart from the
    `Flow` and strict usage lines, we just require the `MariaDB` library, the `promisify()`
    function, and we define four constants to access the database:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一些以后会用到的常量；除了`Flow`和严格使用行之外，我们只需要`MariaDB`库，`promisify()`函数，并定义四个常量来访问数据库：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s get a database connection. We just create a new object, and `promisify`
    its `.query()` method. The `dbConn` variable will be passed as a parameter to
    every function that will need to access the database:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取一个数据库连接。我们只需创建一个新对象，并`promisify`它的`.query()`方法。`dbConn`变量将作为参数传递给每个需要访问数据库的函数：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Executing some queries
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行一些查询
- en: 'A simple way of testing if the connection works is by executing a trivial query
    that returns a constant value; what really matters here is that the function should
    work without throwing any exceptions. We use `await` to get the result of the
    `.query()` method, that is an array with all the found rows; in this case, the
    array will obviously have a single row:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 测试连接是否正常工作的一个简单方法是执行一个返回常量值的微不足道的查询；这里真正重要的是，函数应该在不抛出任何异常的情况下工作。我们使用`await`来获取`.query()`方法的结果，这是一个包含所有找到的行的数组；在这种情况下，数组显然只有一行：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s try something else: what about finding the ten countries that have more
    cities? We can use `.forEach()` to list the results in a frankly not-very-attractive
    format:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试其他的东西：比如找出有更多城市的十个国家？我们可以使用`.forEach()`以一个相当不太吸引人的格式列出结果：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Updating the database
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新数据库
- en: 'Finally, let''s do some updates. We will first add a new (invented!) country;
    we will then check whether it exists; we will update it and check the changes,
    then we will proceed to delete it, and finally we''ll verify that it''s gone:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们做一些更新。我们将首先添加一个新的（虚构的！）国家；然后我们将检查它是否存在；我们将更新它并检查更改，然后我们将删除它，最后我们将验证它是否已经消失：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Getting everything together
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'All we have to do now, to get a complete working example, is just call the
    three functions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们所要做的就是调用这三个函数，以获得一个完整的工作示例：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, I added a script to automate running all tests, by doing `npm run
    start-db`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我添加了一个脚本来自动运行所有测试，通过执行`npm run start-db`：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let's analyze how the code works, and remark on some interesting points.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下代码的工作原理，并注意一些有趣的地方。
- en: How it works…
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Running `tryDbAccess()` isn''t hard to figure out: the constant query goes
    to the server, and an array with a single row comes back. The output of our code
    would have been as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`tryDbAccess()`并不难理解：常量查询发送到服务器，返回一个包含单行的数组。我们的代码的输出将如下所示：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The second query gets more interesting. Apart from the details of actually
    writing the SQL query (which is beyond the objectives of this book) the interesting
    point is the returned array, each with an object with the selected fields:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个查询变得更有趣。除了实际编写SQL查询的细节（这超出了本书的目标）之外，有趣的是返回的数组，每个数组中都有一个包含所选字段的对象：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, let's get to the last example. We are seeing several ways of creating the
    statement that will be executed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看最后一个例子。我们看到了几种创建将要执行的语句的方式。
- en: 'The `INSERT` uses a prepared statement. A good way to prepare safe queries
    (meaning, they cannot be involved in SQL injection hacks) is by using prepared
    strings. The `.prepare()` method is interesting: given a string, it returns a
    function, that when called with the actual parameters to use, will itself return
    the string to use in the query. Of course, you can also build the function by
    hand, as I did in the other examples—but then it''s up to you to make sure that
    the resulting query is safe!'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT`使用了一个准备好的语句。准备好安全查询的一个好方法（意思是，它们不会涉及到SQL注入攻击）是使用准备好的字符串。`.prepare()`方法很有趣：给定一个字符串，它返回一个函数，当用实际参数调用时，它本身将返回要在查询中使用的字符串。当然，您也可以手动构建函数，就像我在其他示例中所做的那样——但是这时你必须确保生成的查询是安全的！'
- en: The `.escape()` method can help building a safe query string, if you don't want
    to use `.prepare()`. See more at [https://github.com/mscdex/node-mariasql](https://github.com/mscdex/node-mariasql).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`.escape()`方法可以帮助构建一个安全的查询字符串，如果你不想使用`.prepare()`。更多信息请参见[https://github.com/mscdex/node-mariasql](https://github.com/mscdex/node-mariasql)。'
- en: 'The subsequent `SELECT` uses a string created by hand (nothing too original
    here) but the `UPDATE` shows another style: using `?` symbols as *placeholders*.
    In that case, you must also provide an array of values that will replace the placeholders;
    it''s fundamental that the order of the values in the array matches the expected
    arguments.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`SELECT`使用了手工创建的字符串（这里没有什么太原创的东西），但`UPDATE`显示了另一种风格：使用`?`符号作为*占位符*。在这种情况下，您还必须提供一个值数组，用于替换占位符；数组中的值的顺序必须与预期的参数匹配，这是非常重要的。
- en: 'Next, the second `SELECT` also uses placeholders, but adds a tweak: passing
    an object with the `useArray:true` option, the function performs a tad faster,
    because it doesn''t create objects for each row, and simply returns arrays. This
    has a problem, however, because now you have to remember what each position of
    the array means.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，第二个`SELECT`也使用了占位符，但添加了一个小调整：传递一个带有`useArray:true`选项的对象，函数执行速度会稍快一些，因为它不会为每一行创建对象，而是直接返回数组。然而，这也存在一个问题，因为现在你必须记住数组的每个位置代表什么意思。
- en: 'The results of the code are as expected: first a single line, showing that
    a country was actually created, with the values we passed; then, the same record
    but with a changed name, and finally a zero showing that the country doesn''t
    exist any more:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结果如预期的那样：首先是一行，显示实际创建了一个国家，带有我们传递的值；然后是相同的记录，但名称已更改，最后是一个零，表明该国家不再存在：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There's more...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this section, we have gone through several examples of accessing a database
    to perform varied operations on it, by means of a direct connection, working with
    tables and cursors. You could also consider using an **Object-Relational Mapping**
    (**ORM**) library, to work with objects instead: the best known possibility is
    probably `Sequelize` (at[ http://docs.sequelizejs.com/](http://docs.sequelizejs.com/))
    but there are some more packages (such as `TinyORM`, `Objection.js`, or `CaminteJS`,
    just to mention some which are still in development, not abandoned).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经通过直接连接，使用表和游标对数据库执行各种操作的几个示例进行了讨论。您还可以考虑使用**对象关系映射**（**ORM**）库，以处理对象：最为人熟知的可能是`Sequelize`（在[http://docs.sequelizejs.com/](http://docs.sequelizejs.com/)），但还有一些其他包（如`TinyORM`、`Objection.js`或`CaminteJS`，只是提到一些仍在开发中的包，没有被放弃）。
- en: Executing external processes with exec()
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用exec()执行外部进程
- en: If you are implementing some service with `Node`, there may be occasions in
    which you require to do some heavy processing, and that, as we have mentioned
    before, is a *no-no* because you will block all users. If you need to do this
    kind of work, `Node` lets you offload the work to an external process, freeing
    itself and becoming available for continuing work. The external process will work
    on its own, in an asynchronous fashion, and when it is done, you will be able
    to process its results. There are several ways of doing this; let's go into them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`Node`实现一些服务，可能会有一些情况需要进行一些繁重的处理，正如我们之前提到的，这是一个*不行*，因为你会阻塞所有用户。如果你需要做这种工作，`Node`可以让你将工作卸载到外部进程中，从而使自己空闲并可继续工作。外部进程将以异步方式独立工作，完成后，你将能够处理其结果。有几种方法可以做到这一点；让我们来看看。
- en: The first option to run a separate command is the `child_process.exec()` method.
    This will spawn a shell, and execute a given command in it. Whatever output is
    generated will be buffered, and when the command finishes execution, a callback
    function will be called with either the produced output, or an error.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个单独命令的第一种选择是`child_process.exec()`方法。这将生成一个shell，并在其中执行给定的命令。生成的任何输出将被缓冲，当命令执行完成时，将调用一个回调函数，其中包含生成的输出或错误。
- en: Let's see an example of calling an external process, by accessing the filesystem.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个通过访问文件系统调用外部进程的例子。
- en: How to do it…
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: An example, to get a directory listing of all JS files at a given path, could
    be as follows. (Yes, of course you could and should do this using `fs.readDir()`,
    but we want to show how to do it with a child process.)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子，获取给定路径上所有JS文件的目录列表，可能如下所示。（是的，当然你可以和应该使用`fs.readDir()`来做到这一点，但我们想展示如何使用子进程来做到这一点。）
- en: 'As shown in the *Using Promises instead of error first callbacks* section earlier
    in this chapter, we will `promisify()` the call, to simplify coding:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面的*使用Promise代替错误优先回调*部分所示，我们将`promisify()`调用，以简化编码：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works…
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we call the `.exec()` method, a separate shell is created, and the command
    runs in it. If the call is successful, the output will be returned; otherwise,
    an object with a `.stderr` property will be thrown as an exception. A possible
    couple of runs are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`.exec()`方法时，将创建一个单独的shell，并在其中运行命令。如果调用成功，将返回输出；否则，将抛出一个具有`.stderr`属性的对象作为异常。可能的一对运行如下：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The second parameter for `.exec()` provides an object with possible options.
    In our case, we are specifying the current working directory (`cwd`) for the command.
    Another interesting option can let you work with commands that produce lots of
    output. By default, the maximum buffered output will be 200K; if you need more,
    you'll have to add an object with the `maxBuffer` option set to a larger value;
    check [https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback](https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback) for
    more on these and other options.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`.exec()`的第二个参数提供了一个可能选项的对象。在我们的情况下，我们正在指定命令的当前工作目录（`cwd`）。另一个有趣的选项可以让你处理产生大量输出的命令。默认情况下，最大缓冲输出量为200K；如果你需要更多，你将不得不添加一个对象，其中`maxBuffer`选项设置为更大的值；查看[https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback](https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback)了解更多关于这些和其他选项的信息。'
- en: 'There''s no limit to the complexity of the command that you can execute, but
    there''s also a risk. Keep in mind the possibility of being hacked: if you are
    building up your command based on some input provided by an user, you could be
    on the end of a command injection attack. Imagine you wanted to build something
    such as ``ls ${path}`` and the user had provided `"/; rm -rf *"` as the `path`;
    what would happen?'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行的命令的复杂性没有限制，但也存在风险。请记住被黑客攻击的可能性：如果你正在根据用户提供的某些输入构建你的命令，你可能会成为命令注入攻击的受害者。想象一下，如果你想构建类似于``ls
    ${path}``的东西，而用户提供的`path`是`"/; rm -rf *"`，会发生什么？
- en: There's more...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using `.exec()` is very good for short commands, with little output. If you
    don't actually need the shell, you can do even better with `.execFile()`, which
    runs the desired command directly, without first creating a shell and then running
    the command in it. See [https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback](https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback)
    for more information on this.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.exec()`对于短命令和少量输出非常好。如果你实际上不需要shell，你甚至可以使用`.execFile()`更好，它直接运行所需的命令，而不是首先创建一个shell，然后在其中运行命令。有关更多信息，请参阅[https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback](https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback)。
- en: Using spawn() to run a command, and communicating with it
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用spawn()运行命令，并与其通信
- en: 'Using `.exec()` is simple, but you are limited to small-sized outputs, and
    you cannot also get a partial answer: let''s see more about this. Imagine you
    are preparing a large file to be sent to a client. If you were to read that file
    with `.exec()`, you wouldn''t be able to start sending the file contents to a
    client until you had read all the file. However, if the file were too large, that
    would not only imply a delay, but also the possibility of a crash. Using `.spawn()`
    gives you an interesting addition: the possibility of using streams to communicate,
    in a bidirectional way, with the spawned process.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.exec()`很简单，但你只能处理小型输出，并且也无法得到部分答案：让我们更多地了解这一点。想象一下，你正在准备一个大文件要发送给客户端。如果你要用`.exec()`读取该文件，你将无法在读取完整个文件之前开始将文件内容发送给客户端。然而，如果文件太大，这不仅意味着延迟，还可能导致崩溃。使用`.spawn()`给你一个有趣的补充：使用流进行双向通信，与生成的进程。
- en: How to do it…
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Using `.spawn()` is similar to `.exec()` in general terms. Let's now use a separate
    process to read a directory and send its results back. We will be passing the
    path we want to process using a stream, and we'll get the list of found files
    also through streaming.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.spawn()`在一般情况下类似于`.exec()`。现在让我们使用一个单独的进程来读取一个目录并将其结果发送回来。我们将使用流传递要处理的路径，并且我们也将通过流获得找到的文件列表。
- en: 'To start, let''s have the main code, which will spawn a process:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们有主要的代码，它将生成一个进程：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To finish, we need the child process, which would be as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要子进程，它将如下所示：
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Spawned processes show yet another case of events. The process stays there,
    waiting, and the `"data"` event is fired whenever the process receives any data
    via the `stdin` input, as done through the `child.stdin.write("/home/fkereki")`
    line. Then, the process reads the directory, with `fs.readdirSync()`, a synchronous
    call you shouldn't use in normal `Node` code, but that is safe in a subprocess,
    because it won't block anything. The results of the call are sorted, filtered
    to avoid hidden files, and then lines are written to `stdout`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的进程展示了另一种事件的情况。进程保持在那里等待，每当进程通过`stdin`输入接收到任何数据时，就会触发`"data"`事件，就像通过`child.stdin.write("/home/fkereki")`行所做的那样。然后，进程使用`fs.readdirSync()`读取目录，这是一个同步调用，在正常的`Node`代码中不应该使用，但在子进程中是安全的，因为它不会阻塞任何东西。调用的结果被排序，过滤以避免隐藏文件，然后将行写入`stdout`。
- en: In a similar fashion to the child process, the parent process listens to events
    coming from the child's `stdout`. Whenever data arrives (`"data"` events are fired)
    it is simply logged with `console.log()`. When the child signals that no more
    data will be coming, by performing `process.stdout.end()`, the `"end"` event is
    fired, and the parent recognizes it, and can do whatever it wants.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与子进程类似，父进程监听来自子进程`stdout`的事件。每当数据到达时（触发`"data"`事件），它会简单地使用`console.log()`记录。当子进程发出信号表示不会再有数据到来时，通过执行`process.stdout.end()`，将触发`"end"`事件，父进程会识别它，并可以做任何想做的事情。
- en: This way of spawning processes thus allows for bidirectional communication between
    the parent and child processes, which could be used in many different forms.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种生成进程的方式允许父进程和子进程之间进行双向通信，可以用于许多不同的形式。
- en: Using fork() to run Node commands
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fork()来运行Node命令
- en: 'The `Child_process.fork()` method is a special case of `.spawn()`, which specifically
    only spawns new `Node` processes. The spawned child process has a communication
    channel built in that makes it even simpler to pass messages between the parent
    process and itself: you just use the `.send()` method to send a message, and listen
    to the `"message"` event on the other side. Let''s see how to fork off a second
    process, and communicate with the first one.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Child_process.fork()`方法是`.spawn()`的一个特殊情况，它专门只生成新的`Node`进程。生成的子进程内置了一个通信通道，使得在父进程和子进程之间传递消息变得更简单：你只需使用`.send()`方法发送消息，并在另一侧监听`"message"`事件。让我们看看如何分叉出第二个进程，并与第一个进程进行通信。'
- en: How to do it…
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Since the code of the previous section used `.spawn()` to launch a new `Node`
    instance and run some code, it's fairly obvious that we can quickly and simply
    adjust it to use `.fork()` instead. Also, we won't have to use `stdin` and `stdout`
    to communicate, opting for messaging instead.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上一节的代码使用`.spawn()`来启动一个新的`Node`实例并运行一些代码，很明显我们可以很快简单地调整它，改用`.fork()`。此外，我们不必使用`stdin`和`stdout`进行通信，而是选择使用消息传递。
- en: 'First, let''s start with the parent code. It would become the following; the
    key differences are the usage of `.fork()` instead of `.spawn()`, and the way
    that the file path is sent to the child process:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从父代码开始。它将变成以下内容；关键的差异是使用`.fork()`而不是`.spawn()`，以及发送文件路径给子进程的方式：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, the child code would also show small variations, in the way messages
    are received, and data is sent to the parent:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，子代码也会显示一些小的变化，接收消息的方式以及向父进程发送数据的方式：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using `.fork()` implies that the child process is a `Node` process, so instead
    of expressly mentioning it, as we did in the previous section, we just have to
    pass the name of the JS file to be executed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.fork()`意味着子进程是一个`Node`进程，所以我们不需要明确地提到它，就像我们在上一节中所做的那样，我们只需要传递要执行的JS文件的名称。
- en: The second difference, as we mentioned, is that instead of using `stdin` and
    `stdout` for communication, we can `.send()` a message (in any direction, from
    parent to child or vice versa) and we listen to the `"message"` event instead
    of the `"data"` one.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个差异，正如我们所提到的，是我们不再使用`stdin`和`stdout`进行通信，而是可以`.send()`一个消息（从父到子或反之亦然），并且我们监听`"message"`事件而不是`"data"`事件。
- en: If you analyze the highlighted differences in code, you'll realize that the
    differences are really minor, and for the special (but not uncommon) case of needing
    to run a separate `Node` process, `.fork()` is more appropriate, and possibly
    a tad simpler to use.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分析代码中突出显示的差异，你会意识到这些差异实际上是非常小的，对于需要运行一个单独的`Node`进程的特殊情况（但并不罕见），`.fork()`更合适，可能也更简单一些。
