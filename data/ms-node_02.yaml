- en: Understanding Asynchronous Event-Driven Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异步事件驱动编程
- en: '"The best way to predict the future is to invent it."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “预测未来的最好方法是创造它。”
- en: – Alan Kay
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – Alan Kay
- en: Eliminating blocking processes through the use of event-driven, asynchronous
    I/O is Node's primary organizational principle. We've learned how this design
    helps developers in shaping information and adding capacity. Node lets you build
    and organize lightweight, independent, and share-nothing processes that communicate
    through callbacks and synchronize with a predictable event loop.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用事件驱动的异步I/O来消除阻塞进程是Node的主要组织原则。我们已经了解到这种设计如何帮助开发人员塑造信息并增加容量。Node允许您构建和组织轻量级、独立的、无共享的进程，这些进程通过回调进行通信，并与可预测的事件循环同步。
- en: Accompanying the growth in the popularity of Node is a growth in the number
    of well-designed event-driven systems and applications. For a new technology to
    be successful, it must eliminate the existing problems, and/or offer to consumers
    a better solution at a lower cost in terms of time, effort, or price. In its young
    and fertile lifespan, the Node community has collaboratively proven that this
    new development model is a viable alternative to the existing technologies. The
    number and quality of Node-based solutions powering enterprise-level applications
    provides further proof that these new ideas are not only novel, but preferred.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Node的流行度增长，设计良好的事件驱动系统和应用程序的数量也在增加。要使一种新技术成功，它必须消除现有的问题，并/或以更低的时间、精力或价格成本为消费者提供更好的解决方案。在其年轻而富有活力的生命周期中，Node社区已经合作证明了这种新的开发模式是现有技术的可行替代方案。基于Node的解决方案的数量和质量为企业级应用程序提供了进一步的证明，表明这些新想法不仅是新颖的，而且是受欢迎的。
- en: In this chapter, we will delve deeper into how Node implements event-driven
    programming. We will begin by unpacking the ideas and theories that event-driven
    languages and environments derive from and grapple with, in an effort to clear
    away misconceptions and encourage mastery. Following this introduction to events,
    we'll look at the key Node.js technology—the event loop. We'll then go into more
    detail on how Node implements timers, callbacks, and I/O events, and how you as
    a Node developer can use them. We'll further discuss management of concurrency
    using modern tools such as **Promises**, **Generators**, and **async/await**.
    We'll practice the theory as we build up some simple but exemplary file and data-driven
    applications. These examples highlight Node's strengths, and show how Node is
    succeeding in its ambition to simplify network application designs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨Node如何实现事件驱动编程。我们将首先解开事件驱动语言和环境从中获得和处理的想法和理论，以消除误解并鼓励掌握。在介绍事件之后，我们将重点介绍Node.js技术——事件循环。然后，我们将更详细地讨论Node如何实现定时器、回调和I/O事件，以及作为Node开发人员如何使用它们。我们还将讨论使用现代工具（如**Promises**、**Generators**和**async/await**）管理并发的方法。在构建一些简单但典型的文件和数据驱动应用程序时，我们将实践这些理论。这些示例突出了Node的优势，并展示了Node如何成功地简化了网络应用程序设计。
- en: Node's unique design
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node的独特设计
- en: 'First, let''s take an accurate look at the total time cost when your program
    asks the system to perform different kinds of services. I/O is expensive. In the
    following chart (taken from *Ryan Dahl*''s original presentation on Node), we
    can see how many clock cycles typical system tasks consume. The relative cost
    of I/O operations is striking:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们准确地看一下当您的程序要求系统执行不同类型的服务时的总时间成本。I/O是昂贵的。在下图中（取自*Ryan Dahl*关于Node的原始演示），我们可以看到典型系统任务消耗多少个时钟周期。I/O操作的相对成本令人震惊：
- en: '| L1 cache  |    3 cycles |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| L1缓存 | 3个周期 |'
- en: '| L2 cache |   14 cycles |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| L2缓存 | 14个周期 |'
- en: '| RAM  | 250 cycles |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| RAM | 250个周期 |'
- en: '| Disk   |   41,000,000 cycles |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 磁盘 | 41,000,000个周期 |'
- en: '| Network   |   240,000,000 cycles |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 网络 | 240,000,000个周期 |'
- en: 'The reasons are clear enough: a disk is a physical device, a spinning metal
    platter — storing and retrieving that data is much slower than moving data between
    solid-state devices (such as microprocessors and memory chips), or indeed optimized
    on-chip L1/L2 caches. Similarly, data does not move from point to point on a network
    instantaneously. Light itself needs 0.1344 seconds to circle the globe! In a network
    used by many billions of people regularly interacting across great distances at
    speeds much slower than the speed of light, with many detours and few straight
    lines, this sort of latency builds up.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是很明显的：磁盘是一个物理设备，一个旋转的金属盘——存储和检索数据比在固态设备（如微处理器和存储芯片）之间移动数据要慢得多，或者说比在优化的芯片上的L1/L2缓存要慢得多。同样，数据在网络上不是瞬间移动的。光本身需要0.1344秒才能环绕地球！在一个由数十亿人定期在速度远远慢于光速的距离上相互交流的网络中，有许多弯路和少数直线，这种延迟会积累起来。
- en: When our software ran on personal computers on our desks, little or no communication
    was happening over the network. Delays or hiccups in our interactions with a word
    processor or spreadsheet had to do with disk access time. Much work was done to
    improve disk access speeds. Data storage and retrieval became faster, software
    became more responsive, and users now expect this responsiveness in their tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的软件在我们桌子上的个人电脑上运行时，几乎没有或根本没有通过网络进行通信。与文字处理器或电子表格的交互中的延迟或故障与磁盘访问时间有关。为了提高磁盘访问速度，做了大量工作。数据存储和检索变得更快，软件变得更具响应性，用户现在期望在其工具中获得这种响应性。
- en: With the advent of cloud computing and browser-based software, your data has
    left the local disk and exists on a remote disk, and you access this data via
    a network—the internet. Data access times have slowed down again, dramatically.
    Network I/O is slow. Nevertheless, more companies are migrating sections of their
    applications into the cloud, with some software being entirely network-based.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算和基于浏览器的软件的出现，您的数据已经离开了本地磁盘，存在于远程磁盘上，并且您通过网络——互联网访问这些数据。数据访问时间再次显著减慢。网络I/O很慢。尽管如此，越来越多的公司正在将其应用程序的部分迁移到云中，一些软件甚至完全基于网络。
- en: Node is designed to make I/O fast. It is designed for this new world of networked
    software, where data is in many places and must be assembled quickly. Many of
    the traditional frameworks to build web applications were designed at a time when
    a single user working on a desktop computer used a browser to periodically make
    HTTP requests to a single server running a relational database. Modern software
    must anticipate tens of thousands of simultaneously connected clients concurrently
    altering enormous, shared data pools via a variety of network protocols, on any
    number of unique devices. Node is designed specifically to help those building
    that kind of network software.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Node旨在使I/O快速。它是为这个新的网络软件世界设计的，其中数据分布在许多地方，必须快速组装。许多传统的构建Web应用程序的框架是在一个单一用户使用桌面计算机，使用浏览器定期向运行关系数据库的单个服务器发出HTTP请求的时代设计的。现代软件必须预期成千上万个同时连接的客户端通过各种网络协议在任意数量的独特设备上同时更改庞大的共享数据池。Node专门设计为帮助那些构建这种网络软件的人。
- en: 'The breakthrough in thinking reflected by Node''s design is simple to understand
    once one recognizes that most worker threads spend their time waiting—for more
    instructions, a sub-task to complete, and so on. For example, a process assigned
    to service the command *format my hard drive* will dedicate all of its allotted
    resources to managing a workflow, something like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Node设计所反映的思维突破一旦被认识到，就变得简单易懂，因为大多数工作线程都在等待——等待更多指令，等待子任务完成等。例如，被分配为服务命令“格式化我的硬盘”的进程将把所有资源用于管理工作流程，类似以下内容：
- en: Communicate to a device driver that a format request has been made
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向设备驱动程序通知已发出格式请求
- en: Idle, waiting for an *unknowable* length of time
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空闲，等待*不可知*的时间长度
- en: Receive the signal format as complete
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收格式完成的信号
- en: Notify the client
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知客户端
- en: 'Clean up; shut down:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理；关闭：
- en: '![](img/654909f4-ef43-4a75-9199-e145e067c376.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/654909f4-ef43-4a75-9199-e145e067c376.png)'
- en: In the preceding figure, we see that an expensive worker is charging the client
    a fixed fee per unit of time, regardless of whether any useful work is being done
    (the client is paying equally for activity and idleness). To put it another way,
    it is not necessarily true, and most often not true, that the sub-tasks comprising
    a total task each require similar effort or expertise. It's therefore wasteful
    to pay a premium price for such cheap labor.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们看到一个昂贵的工人正在向客户收取固定的时间单位费用，无论是否正在做任何有用的工作（客户对活动和空闲一视同仁地付费）。换句话说，并不一定是真的，而且往往不是真的，组成总任务的子任务每个都需要相似的努力或专业知识。因此，为这种廉价劳动力支付高价是浪费的。
- en: Sympathetically, we must also recognize that this worker can do no better even
    if ready and able to handle more work — even the best-intentioned worker cannot
    do anything about I/O bottlenecks. The worker here is **I/O bound**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同情地说，我们还必须认识到，即使准备好并能够处理更多工作，这个工人也无法做得更好——即使是最有诚意的工人也无法解决I/O瓶颈的问题。这个工人是**I/O受限**的。
- en: Instead, imagine an alternative design. What if multiple clients could share
    the same worker, such that the moment a worker announces availability due to an
    I/O bottleneck, another job from another client can start?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，想象一种替代设计。如果多个客户端可以共享同一个工人，那么当一个工人因I/O瓶颈而宣布可用时，另一个客户端的工作可以开始吗？
- en: Node has commoditized I/O through the introduction of an environment where system
    resources are (ideally) **never** idle. Event-driven programming as implemented
    by Node reflects the simple goal of lowering overall system costs by encouraging
    the sharing of expensive labor, mainly by reducing the number of I/O bottlenecks
    to **zero**. We no longer have a powerless chunk of rigidly-priced unsophisticated
    labor; we can reduce all effort into discrete units with precisely delineated
    shapes, and therefore admit much more accurate pricing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Node通过引入一个系统资源（理想情况下）**永远**不会空闲的环境，使I/O变得通用。Node实现的事件驱动编程反映了降低整体系统成本的简单目标，主要通过减少I/O瓶颈的数量来鼓励共享昂贵的劳动力。我们不再拥有无能为力的僵化定价的劳动力块；我们可以将所有努力减少为精确界定形状的离散单位，因此可以实现更准确的定价。
- en: What would an environment within which many client jobs are cooperatively scheduled
    look like? And how is this message passing between events handled? Additionally,
    what do concurrency, parallelism, asynchronous execution, callbacks, and events
    mean to the Node developer?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个协作调度了许多客户端工作的环境会是什么样子？这种事件之间的消息传递是如何处理的？此外，并发、并行、异步执行、回调和事件对Node开发人员意味着什么？
- en: Collaboration
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协作
- en: What would be preferable to the blocking system described previously is a collaborative
    work environment, where workers are regularly assigned new tasks to do, instead
    of idling. In order to achieve such a goal, what we need is a virtual switchboard,
    where requests for services are dispatched to available workers, and where workers
    notify the switchboard of their availability.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前描述的阻塞系统相比，更可取的是一个协作工作环境，工人定期被分配新任务，而不是空闲。为了实现这样的目标，我们需要一个虚拟交换机，将服务请求分派给可用的工人，并让工人通知交换机他们的可用性。
- en: 'One way to achieve this goal is to have a pool of available labors, improving
    efficiency by delegating tasks to different workers as the tasks come in:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的一种方法是拥有一个可用劳动力池，通过将任务委派给不同的工人来提高效率：
- en: '![](img/57b70667-0b0f-44fa-a901-76806eda58ba.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57b70667-0b0f-44fa-a901-76806eda58ba.png)'
- en: One drawback to this method is the amount of scheduling and worker surveillance
    that needs to be done. The dispatcher must field a steady stream of requests,
    while managing messages coming from workers about their availability, neatly breaking
    up requests into manageable tasks and efficiently sorting them, so that the fewest
    number of workers are idling.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是需要进行大量的调度和工人监视。调度程序必须处理源源不断的请求，同时管理来自工人的关于他们可用性的消息，将请求整理成可管理的任务并高效地排序，以便最少数量的工人处于空闲状态。
- en: Perhaps most importantly, what happens when all workers are fully booked? Does
    the dispatcher begin to drop requests from clients? Dispatching is resource-intensive
    as well, and there are limits even to the dispatcher's resources. If requests
    continue to arrive and no worker is available to service them, what does the dispatcher
    do? Manage a queue? We now have a situation where the dispatcher is no longer
    doing the right job (dispatching), and has become responsible for bookkeeping
    and keeping lists, further extending the time each task takes to complete. Each
    task takes some amount of time, and must be processed in arrival order. This task
    execution model stacks fixed time intervals — *ticks* of time. This is *synchronous* execution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最重要的是，当所有工人都被预订满了会发生什么？调度程序是否开始从客户那里丢弃请求？调度也是资源密集型的，调度程序的资源也是有限的。如果请求继续到达，而没有工人可用来为其提供服务，调度程序会怎么做？管理队列？我们现在有一个情况，调度程序不再做正确的工作（调度），而是负责簿记和保持列表，进一步延长每个任务完成所需的时间。每个任务需要一定的时间，并且必须按到达顺序进行处理。这个任务执行模型堆叠了固定的时间间隔——*时间片*。这是*同步*执行。
- en: Queueing
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排队
- en: In order to avoid overwhelming anyone, we might add a buffer between the clients
    and the dispatcher. This new worker is responsible for managing customer relations.
    Instead of speaking directly with the dispatcher, the client speaks to the services
    manager, passing the manager requests, and at some point in the future, getting
    a call that their task has been completed. Requests for work are added to a prioritized
    work queue (a stack of orders with the most important one on top), and this manager
    waits for another client to walk through the door.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免过载任何人，我们可以在客户和调度程序之间添加一个缓冲区。这个新的工人负责管理客户关系。客户不直接与调度程序交谈，而是与服务经理交谈，将请求传递给经理，并在将来的某个时候接到通知，说他们的任务已经完成。工作请求被添加到一个优先级工作队列（一个订单堆栈，最重要的订单在顶部），这个经理等待另一个客户走进门。
- en: 'The following figure describes the situations:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了情况：
- en: '![](img/bcb39362-b03e-413f-9c99-a8e37f043fc4.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcb39362-b03e-413f-9c99-a8e37f043fc4.png)'
- en: The dispatcher tries to keep all workers busy by pulling tasks from this queue,
    passing back any packages workers have completed, and generally maintaining a
    sane work environment where nothing gets dropped or lost. Rather than proceeding
    task-by-task along a single timeline, multiple simultaneous jobs, on their own
    timelines, run in parallel. If it comes to a point where all the workers are idle
    and the task queue is empty, the office can sleep for a while, until the next
    client arrives.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序试图通过从队列中提取任务，将工人完成的任何包传回，并通常维护一个理智的工作环境，以确保没有任何东西被丢弃或丢失，来使所有工人保持忙碌。与沿着单个时间线逐个进行任务不同，多个同时运行在其自己的时间线上的任务并行运行。如果所有工人都处于空闲状态且任务队列为空，那么办公室可以休息一会儿，直到下一个客户到来。
- en: This is a rough schematic of how Node gains speed by working *asynchronously,*
    rather than *synchronously*. Now, let's dive deeper into how Node's event loop
    works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Node通过*异步*工作而不是*同步*工作来获得速度的粗略示意图。现在，让我们深入了解Node的事件循环是如何工作的。
- en: Understanding the event loop
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: 'The following three points are important to remember, as we break down the
    event loop:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分解事件循环时，以下三点很重要：
- en: The event loop runs in the same (single) thread your JavaScript code runs in.
    Blocking the event loop means blocking the entire thread.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环在与您的JavaScript代码运行的相同（单个）线程中运行。阻塞事件循环意味着阻塞整个线程。
- en: You don't start and/or stop the event loop. The event loop starts as soon as
    a process starts, and ends when no further callbacks remain to be performed. The
    event loop may, therefore, run forever.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不会启动和/或停止事件循环。事件循环在进程启动时开始，并在没有进一步的回调需要执行时结束。因此，事件循环可能永远运行。
- en: The event loop delegates many I/O operations to `libuv`, which manages these
    operations (using the power of the OS itself, such as thread pools), notifying
    the event loop when results are available. An easy-to-reason-about single-threaded
    programming model is reinforced with the efficiency of multithreading.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环将许多I/O操作委托给`libuv`，后者管理这些操作（使用OS本身的能力，如线程池），并在结果可用时通知事件循环。易于理解的单线程编程模型通过多线程的效率得到了加强。
- en: 'For example, the following `while` loop will never terminate:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下`while`循环永远不会终止：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Even though one might expect, in approximately one second, the assignment of
    a Boolean `true` to the variable `stop`, tripping the `while` conditional and
    interrupting its loop; this will never happen. Why? This `while` loop starves
    the event loop by running infinitely, greedily checking and rechecking a value
    that is never given a chance to change, as the event loop is never given a chance
    to schedule our timer callback for execution. This proves the event loop (which
    manages timers), and runs on the same thread.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有人可能期望，在大约一秒钟内，将布尔值`true`分配给变量`stop`，触发`while`条件并中断其循环；这永远不会发生。为什么？这个`while`循环通过无限运行来使事件循环饥饿，贪婪地检查和重新检查一个永远不会有机会改变的值，因为事件循环永远不会有机会安排我们的定时器回调进行执行。这证明了事件循环（管理定时器）并且在同一个线程上运行。
- en: According to the Node documentation, "The event loop is what allows Node.js
    to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded
    — by offloading operations to the system kernel whenever possible." The key design
    choice made by Node's designers was the implementation of an event loop as a concurrency
    manager. For example, notifying your Node-based HTTP server of network connections
    to your local hardware is handled by the OS passing along, via `libuv`, network
    interface events.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Node文档，“事件循环是Node.js执行非阻塞I/O操作的关键，尽管JavaScript是单线程的，但通过尽可能地将操作卸载到系统内核来实现。”
    Node的设计者所做的关键设计选择是将事件循环实现为并发管理器。例如，通过`libuv`，OS传递网络接口事件来通知基于Node的HTTP服务器与本地硬件的网络连接。
- en: 'The following description of event-driven programming (taken from: [http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html](http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html))
    clearly not only describes the event-driven paradigm, but also introduces us to
    how events are handled in Node, and how JavaScript is an ideal language for such
    a paradigm.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是事件驱动编程的描述（摘自：[http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html](http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html)），不仅清楚地描述了事件驱动范式，还向我们介绍了事件在Node中的处理方式，以及JavaScript是这种范式的理想语言。
- en: 'In computer programming, event-driven programming or event-based programming
    is a programming paradigm in which the flow of the program is determined by events—that
    is, sensor outputs or user actions (mouse clicks, key presses) or messages from
    other programs or threads. Event-driven programming can also be defined as an
    application architecture technique in which the application has a main loop that
    is clearly divided down to two sections: the first is event selection (or event
    detection), and the second is event handling […]. Event-driven programs can be
    written in any language, although the task is easier in languages that provide
    high-level abstractions, such as closures. Visit [https://www.youtube.com/watch?v=QQnz4QHNZKc](https://www.youtube.com/watch?v=QQnz4QHNZKc) for
    more information.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，事件驱动编程或基于事件的编程是一种编程范式，其中程序的流程由事件决定 - 即传感器输出或用户操作（鼠标点击，按键）或来自其他程序或线程的消息。事件驱动编程也可以被定义为一种应用架构技术，其中应用程序具有一个主循环，明确定义为两个部分：第一个是事件选择（或事件检测），第二个是事件处理[...]。事件驱动程序可以用任何语言编写，尽管在提供高级抽象的语言中更容易，比如闭包。有关更多信息，请访问[https://www.youtube.com/watch?v=QQnz4QHNZKc](https://www.youtube.com/watch?v=QQnz4QHNZKc)。
- en: Node makes a single thread more efficient by delegating many blocking operations
    to OS subsystems to process, bothering the main V8 thread only when there is data
    available for use. The main thread (your executing Node program) expresses interest
    in some data (such as via `fs.readFile`) by passing a callback, and is notified
    when that data is available. Until that data arrives, no further burden is placed
    on V8's main JavaScript thread. How? Node delegates I/O work to `libuv`, as quoted
    at: [http://nikhilm.github.io/uvbook/basics.html#event-loops](http://nikhilm.github.io/uvbook/basics.html#event-loops).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Node通过将许多阻塞操作委托给OS子系统来使单个线程更有效，只有在有数据可用时才会打扰主V8线程。主线程（执行中的Node程序）通过传递回调来表达对某些数据的兴趣（例如通过`fs.readFile`），并在数据可用时得到通知。在数据到达之前，不会对V8的主JavaScript线程施加进一步的负担。如何做到的？Node将I/O工作委托给`libuv`，如引用所述：[http://nikhilm.github.io/uvbook/basics.html#event-loops](http://nikhilm.github.io/uvbook/basics.html#event-loops)。
- en: In event-driven programming, an application expresses interest in certain events,
    and responds to them when they occur. The responsibility of gathering events from
    the operating system or monitoring other sources of events is handled by `libuv`,
    and the user can register callbacks to be invoked when an event occurs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动编程中，应用程序表达对某些事件的兴趣，并在发生时做出响应。从操作系统收集事件或监视其他事件源的责任由`libuv`处理，用户可以注册回调以在事件发生时被调用。
- en: '*Matteo Collina* has created an interesting module for benchmarking the event
    loop, which is available at: [https://github.com/mcollina/loopbench](https://github.com/mcollina/loopbench).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '* Matteo Collina *创建了一个有趣的模块，用于对事件循环进行基准测试，可在以下网址找到：[https://github.com/mcollina/loopbench](https://github.com/mcollina/loopbench)。'
- en: 'Consider the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of this program is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出是：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s what Node does when executing this program:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此程序时，Node的操作如下：
- en: A process object is created in C++ using the V8 API. The Node.js runtime is
    then imported into this V8 process.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用V8 API在C++中创建了一个进程对象。然后将Node.js运行时导入到这个V8进程中。
- en: The `fs` module is attached to the Node runtime. V8 exposes C++ to JavaScript.
    This provides access to native filesystem bindings for your JavaScript code.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fs`模块附加到Node运行时。V8将C++暴露给JavaScript。这为您的JavaScript代码提供了对本机文件系统绑定的访问权限。'
- en: The `fs.readFile` method has passed instructions and a JavaScript callback.
    Through `fs.binding`, `libuv` is notified of the file read request, and is passed
    a specially prepared version of the callback sent by the original program.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fs.readFile`方法传递了指令和JavaScript回调。通过`fs.binding`，`libuv`被通知文件读取请求，并传递了原始程序发送的回调的特别准备版本。'
- en: '`libuv` invokes the OS-level functions necessary to read a file.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`libuv`调用了必要的操作系统级函数来读取文件。'
- en: The JavaScript program continues, printing `This happens first`. Because there
    is a callback outstanding, the event loop continues to spin, waiting for that
    callback to resolve.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript程序继续运行，打印`This happens first`。因为有一个未解决的回调，事件循环继续旋转，等待该回调解析。
- en: When the file descriptor has been fully read by the OS, `libuv` (via internal
    mechanisms) is informed, and the callback passed to `libuv` is invoked, which
    essentially prepares the original JavaScript callback for re-entrance into the
    main (V8) thread.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当操作系统完全读取文件描述符时，通过内部机制通知`libuv`，并调用传递给`libuv`的回调，从而为原始JavaScript回调准备重新进入主（V8）线程。
- en: The original JavaScript callback is pushed onto the event loop, and is invoked
    on a near-future tick of the loop.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始的JavaScript回调被推送到事件循环，并在循环的近期刻度上被调用。
- en: The file contents are printed to the console.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件内容被打印到控制台。
- en: As there are no further callbacks in flight, the process exits.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有进一步的回调在飞行中，进程退出。
- en: Here, we see the key ideas that Node implements to achieve fast, manageable,
    and scalable I/O. If, for example, there were 10 read calls made for `foo.js`
    in the preceding program, the execution time would, nevertheless, remain roughly
    the same. Each call will be managed by `libuv` as efficiently as possible (by,
    for example, parallelizing the calls using threads). Even though we wrote our
    code in JavaScript, we are actually deploying a very efficient multithreaded execution
    engine while avoiding the difficulties of OS asynchronous process management.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了Node实现的关键思想，以实现快速、可管理和可扩展的I/O。例如，如果在前面的程序中对`foo.js`进行了10次读取调用，执行时间仍然大致相同。每个调用都将由`libuv`尽可能高效地管理（例如，通过使用线程并行化调用）。尽管我们的代码是用JavaScript编写的，但实际上我们部署了一个非常高效的多线程执行引擎，同时避免了操作系统异步进程管理的困难。
- en: Now that we know how a filesystem operation might work, let's dig into how every
    type of asynchronous operation Node capable of spawning is treated on the event
    loop.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了文件系统操作可能是如何工作的，让我们深入了解Node在事件循环中如何处理每种异步操作类型。
- en: Event loop ordering, phases, and priorities
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环排序、阶段和优先级
- en: 'The event loop proceeds through phases, and each phase has a queue of events
    to process. From the Node documentation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环通过阶段进行处理，每个阶段都有一个要处理的事件队列。来自Node文档：
- en: '![](img/d3cdf6c5-7bf6-4a11-8fc0-fdba8cd39ffb.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3cdf6c5-7bf6-4a11-8fc0-fdba8cd39ffb.png)'
- en: 'The phases relevant to developers are the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对开发人员相关的阶段如下：
- en: '**Timers**: Callbacks deferred to some time in the future specified in milliseconds,
    such as `setTimeout` and `setInterval`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定时器**：延迟到未来某个指定的毫秒数的回调，比如`setTimeout`和`setInterval`'
- en: '**I/O callbacks**: Prepared callbacks returned to the main thread after being
    delegated to Node''s managed thread pool, such as filesystem calls and network
    listeners'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I/O回调**：在被委托给Node的管理线程池后返回到主线程的准备好的回调，比如文件系统调用和网络监听器'
- en: '**Poll/check**: Mainly the functions slotted on the stack according to the
    rules of `setImmediate` and `nextTick`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮询/检查**：主要是根据`setImmediate`和`nextTick`的规则排列在堆栈上的函数'
- en: When data becomes available on a socket or other stream interface, we cannot
    simply execute our callback immediately. JavaScript is single-threaded, so results
    must be synchronized. We can't suddenly change the state in the middle of an event
    loop tick — this would create some of the classic multithreaded application problems
    of race conditions, memory access conflicts, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当套接字或其他流接口上有数据可用时，我们不能立即执行回调。JavaScript是单线程的，所以结果必须同步。我们不能在事件循环的中间突然改变状态，这会导致一些经典的多线程应用程序问题，比如竞争条件、内存访问冲突等。
- en: 'To learn more about how Node is bound to `libuv` and other core libraries,
    parse through the `fs` module code at: [https://github.com/nodejs/node/blob/master/lib/fs.js](https://github.com/nodejs/node/blob/master/lib/fs.js). Compare
    the `fs.read` and the `fs.readSync` methods to observe the difference between
    how synchronous and asynchronous actions are implemented; note the wrapper callback
    that is passed to the native `binding.read` method in `fs.read`. To take an even
    deeper dive into the very heart of Node''s design, including the queue implementation,
    read through the Node source at: [https://github.com/joyent/node/tree/master/src](https://github.com/joyent/node/tree/master/src).
    Follow `FSEventWrap` within `fs_event_wrap.cc`. Investigate the `req_wrap` class,
    a wrapper for the V8 engine, deployed in `node_file.cc` and elsewhere and defined
    in `req_wrap.h`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Node如何绑定到`libuv`和其他核心库的信息，请查看`fs`模块的代码：[https://github.com/nodejs/node/blob/master/lib/fs.js](https://github.com/nodejs/node/blob/master/lib/fs.js)。比较`fs.read`和`fs.readSync`方法，观察同步和异步操作的实现方式的不同；注意在`fs.read`中传递给原生`binding.read`方法的包装回调。要深入了解Node设计的核心部分，包括队列实现，请阅读Node源代码：[https://github.com/joyent/node/tree/master/src](https://github.com/joyent/node/tree/master/src)。查看`fs_event_wrap.cc`中的`FSEventWrap`。调查`req_wrap`类，这是V8引擎的包装器，在`node_file.cc`和其他地方部署，并在`req_wrap.h`中定义。
- en: Upon entering an event loop, Node, in effect, makes a copy of the current instruction
    queue (also known as **stack**), empties the original queue, and executes its
    copy. The processing of this instruction queue is referred to as a **tick**. If
    `libuv`, asynchronously, receives results while the chain of instructions copied
    at the start of this tick are being processed on the single main thread (V8),
    these results (wrapped as callbacks) are queued. Once the current queue is emptied
    and its last instruction has completed, the queue is again checked for instructions
    to execute on the next tick. This pattern of checking and executing the queue
    will repeat (loop) until the queue is emptied, and no further data events are
    expected, at which point the Node process exits.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 进入事件循环时，Node实际上会复制当前指令队列（也称为**堆栈**），清空原始队列，并执行其副本。处理这个指令队列被称为**tick**。如果`libuv`在单个主线程（V8）上处理此tick开始时复制的指令链时异步接收到结果（包装为回调），这些结果将被排队。一旦当前队列被清空并且其最后一条指令完成，队列将再次被检查以执行下一个tick上的指令。这种检查和执行队列的模式将重复（循环），直到队列被清空，并且不再期望有更多的数据事件，此时Node进程退出。
- en: Next, let's look at the event interfaces of Node.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看Node的事件接口。
- en: Listening for events
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听事件
- en: Modern network software, for various reasons, is growing in complexity and,
    in many ways, changing how we think about application development. Most new platforms
    and languages are attempting to address these changes. Node is no exception —
    and JavaScript is no exception.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络软件因为各种原因变得越来越复杂，并且在很多方面改变了我们对应用程序开发的看法。大多数新平台和语言都试图解决这些变化。Node也不例外，JavaScript也不例外。
- en: Learning about Node means learning about event-driven programming, composing
    software out of modules, creating and linking data streams, and producing and
    consuming events and their related data. Node-based architectures are often composed
    of many small processes and/or services communicating with events — internally,
    by extending the `EventEmitter` interface and using callbacks, and externally,
    over one of several common transport layers (for example, HTTP, TCP), or through
    a thin messaging layer covering one of these transport layers (for example, 0MQ,
    Redis PUBSUB, and Kafka).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 学习Node意味着学习事件驱动编程，将软件组合成模块，创建和链接数据流，生成和消耗事件及其相关数据。基于Node的架构通常由许多小进程和/或服务组成，这些进程和/或服务通过事件进行通信
    - 内部通过扩展`EventEmitter`接口并使用回调，外部通过几种常见的传输层之一（例如HTTP，TCP），或通过覆盖这些传输层之一的薄消息传输层（例如0MQ，Redis
    PUBSUB和Kafka）。
- en: It is likely that these processes are composed of several free, open source,
    and high-quality npm modules, each distributed with unit tests and/or examples
    and/or documentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些进程很可能由几个免费、开源和高质量的npm模块组成，每个模块都配备了单元测试和/或示例和/或文档。
- en: The previous chapter introduced you to the `EventEmitter` interface. This is
    the primary event interface we will be encountering as we move chapter to chapter,
    as it provides the prototype class for the many Node objects exposing evented
    interfaces, such as file and network streams. Various `close`, `exit`, `data`,
    and other events exposed by different module APIs signal the presence of an `EventEmitter`
    interface, and we will be learning about these modules and use cases as we progress.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您介绍了`EventEmitter`接口。这是我们在逐章移动时将遇到的主要事件接口，因为它为许多暴露事件接口的Node对象提供了原型类，例如文件和网络流。不同模块API暴露的各种`close`、`exit`、`data`和其他事件都表示了`EventEmitter`接口的存在，随着我们的学习，我们将了解这些模块和用例。
- en: 'In this section, our goal is to discuss some lesser-known event sources: signals,
    child process communication, filesystem change events, and deferred execution.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的目标是讨论一些较少为人知的事件源：信号、子进程通信、文件系统更改事件和延迟执行。
- en: Signals
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: Evented programming is like hardware interrupt programming. Interrupts do exactly
    what their name suggests. They use their ability to interrupt whatever a controller,
    or the CPU, or any other device is doing, demanding that their particular need
    be serviced immediately.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动编程就像硬件中断编程。中断正是其名称所暗示的。它们利用中断控制器、CPU或任何其他设备正在执行的任务，要求立即为它们的特定需求提供服务。
- en: In fact, the Node process object exposes standard **Portable Operating System
    Interface (POSIX)** signal names, such that a Node process can subscribe to these
    system events.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Node进程对象公开了标准**可移植操作系统接口（POSIX）**信号名称，因此Node进程可以订阅这些系统事件。
- en: As [http://en.wikipedia.org/wiki/POSIX_signal](http://en.wikipedia.org/wiki/POSIX_signal) defines, "A
    signal is a limited form of inter-process communication used in Unix, Unix-like,
    and other POSIX-compliant operating systems. It is an asynchronous notification
    sent to a process, or to a specific thread, within the same process in order to
    notify it of an event that occurred."
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[http://en.wikipedia.org/wiki/POSIX_signal](http://en.wikipedia.org/wiki/POSIX_signal) 所定义的，“信号是Unix、类Unix和其他符合POSIX标准的操作系统中使用的一种有限的进程间通信形式。它是异步通知，发送给进程或同一进程中的特定线程，以通知其发生的事件。”
- en: This is a very elegant and natural way to expose a Node process to operating
    system signal events. One might configure listeners to catch signals instructing
    a Node process to restart or update some configuration files, or simply clean
    up and shut down.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将Node进程暴露给操作系统信号事件的一种非常优雅和自然的方式。可以配置监听器来捕获指示Node进程重新启动或更新某些配置文件，或者简单地进行清理和关闭的信号。
- en: 'For example, the **SIGINT** signal is sent to a process when its controlling
    terminal detects a *Ctrl* + *C* (or equivalent) keystroke. This signal tells a
    process that an interrupt has been requested. If a Node process has bound a callback
    to this event, that function might log the request prior to terminating, do some
    other cleanup work, or even ignore the request:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当控制终端检测到*Ctrl* + *C*（或等效）按键时，**SIGINT**信号将发送到进程。此信号告诉进程已请求中断。如果Node进程已将回调绑定到此事件，则该函数可能在终止之前记录请求，执行其他清理工作，甚至忽略请求：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the output for `sigint.js`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`sigint.js`的输出：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example starts a long interval, so Node doesn't exit with nothing else
    to do. When you send a *Ctrl* + *C* from your keyboard through the terminal controlling
    the process, Node gets the signal from the operating system. Your code has subscribed
    to that event, and Node runs your function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例启动了一个长时间间隔，因此Node不会因无其他任务而退出。当您通过控制进程的终端从键盘发送*Ctrl* + *C*时，Node会从操作系统接收信号。您的代码已订阅了该事件，Node会运行您的函数。
- en: Now, consider a situation in which a Node process is doing some ongoing work,
    such as parsing logs. It might be useful to be able to send that process a signal,
    such as update your configuration files, or restart the scan. You may want to
    send such signals from the command line. You might prefer to have another process
    do so — a practice known as **Inter-Process Communication** (IPC).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑这样一种情况，即Node进程正在进行一些持续的工作，例如解析日志。能够向该进程发送信号，例如更新配置文件或重新启动扫描，可能是有用的。您可能希望从命令行发送这些信号。您可能更喜欢由另一个进程执行此操作
    - 这种做法称为**进程间通信**（IPC）。
- en: 'Create a file named `ipc.js`, and type in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`ipc.js`的文件，并键入以下代码：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As before, Node will wait for around 16 minutes before running the empty function,
    keeping the process open, so you'll have to *Ctrl *+ *C* to get your prompt back.
    Note that this works just fine even though here, we haven't subscribed to the
    SIGINT signal.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，Node将在运行空函数之前等待大约16分钟，保持进程开放，因此您将不得不使用*Ctrl *+ *C*来恢复提示符。请注意，即使在这里，我们没有订阅SIGINT信号，这也可以正常工作。
- en: '`SIGUSR1` (and `SIGUSR2`) are user-defined signals, triggered by no specific
    action known to the operating system. They''re meant for custom functionality.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGUSR1`（和`SIGUSR2`）是用户定义的信号，由操作系统不知道的特定操作触发。它们用于自定义功能。'
- en: 'To send a command to a process, you must determine its **process ID.** With
    a PID in hand, you can address a process and communicate with it. If the PID assigned
    to `ipc.js` after being run through Node is `123`, then we can send that process
    a `SIGUSR1` signal using the `kill` command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要向进程发送命令，必须确定其**进程ID**。有了PID，您就可以寻址进程并与其通信。如果`ipc.js`在通过Node运行后分配的PID是`123`，那么我们可以使用`kill`命令向该进程发送`SIGUSR1`信号：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A simple way to find the PID for a given Node process in UNIX is to search
    the system process list for the name of the program that says the process is running.
    If `ipc.js` is currently executing, its PID is found by entering the following
    command line in the console/terminal:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX中查找给定Node进程的PID的一个简单方法是在系统进程列表中搜索正在运行的程序名称。如果`ipc.js`当前正在执行，可以通过在控制台/终端中输入以下命令行来找到其PID：
- en: '`ps aux | grep ipc.js`. Try it.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ps aux | grep ipc.js`命令。试试看。
- en: Child processes
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子进程
- en: A fundamental part of Node's design is to create or fork processes when parallelizing
    execution or scaling a system, as opposed to creating a thread pool, for instance.
    We will be using these child processes in various ways throughout this book. Right
    now, the focus will be on understanding how to handle communication events between
    child processes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Node设计的一个基本部分是在并行执行或扩展系统时创建或分叉进程，而不是创建线程池。我们将在本书中以各种方式使用这些子进程。现在，重点将放在理解如何处理子进程之间的通信事件上。
- en: 'To create a child process, require Node''s `child_process` module, and call
    the `fork` method. Pass the name of the program file the new process should execute:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个子进程，需要引入Node的`child_process`模块，并调用`fork`方法。传递新进程应执行的程序文件的名称：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can keep any number of subprocesses running with this method. On multicore
    machines, the operating system will distribute forked processes across the available
    hardware cores. Spreading Node processes across cores, even onto other machines,
    and managing IPC is one way to scale a Node application in a stable, understandable,
    and predictable way.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这种方法保持任意数量的子进程运行。在多核机器上，操作系统将分配分叉出的进程到可用的硬件核心上。将Node进程分布到核心上，甚至分布到其他机器上，并管理IPC是一种稳定、可理解和可预测的方式来扩展Node应用程序。
- en: 'Extending the preceding example, we can now have the forking process (`parent`)
    send, and listen for, messages from the forked process (`child`). Here''s the
    code for `parent.js`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展前面的示例，现在分叉进程（`parent`）可以发送消息，并监听来自分叉进程（`child`）的消息。以下是`parent.js`的代码：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is the output for `parent.js`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`parent.js`的输出：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alongside that file, make another one and name it `lovechild.js`.  The code
    of the child in here can listen for messages and send them back up:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个文件旁边，再创建一个文件，命名为`lovechild.js`。这里的子代码可以监听消息并将其发送回去：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Don't run `lovechild.js` yourself; `--parent.js` will do that for you with fork!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不要自己运行`lovechild.js`；`--parent.js`会为您进行分叉！
- en: 'Running `parent.js` should fork a child process and send that child a message.
    The child should respond in kind:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`parent.js`应该会分叉出一个子进程并向该子进程发送消息。子进程应该以同样的方式回应：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With `parent.js` running, check your operating system's task manager. There
    will be two Node processes, not one, as there were with preceeding examples.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`parent.js`时，请检查您的操作系统任务管理器。与之前的示例不同，这里将有两个Node进程，而不是一个。
- en: Another very powerful idea is to pass a network server an object to a child.
    This technique allows multiple processes, including the parent, to share the responsibility
    for servicing connection requests, spreading load across cores.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常强大的想法是将网络服务器的对象传递给子进程。这种技术允许多个进程，包括父进程，共享服务连接请求的责任，将负载分布到核心上。
- en: 'For example, the following program will start a network server, fork a child
    process, and pass the server reference from the parent down to the child:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下程序将启动一个网络服务器，分叉一个子进程，并将父进程的服务器引用传递给子进程：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In addition to passing a message to a child process as the first argument to
    send, the preceding code also sends the server handle to itself as a second argument.
    Our child server can now help out with the family''s service business:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将消息作为第一个参数发送给子进程之外，前面的代码还将服务器句柄作为第二个参数发送给自己。我们的子服务器现在可以帮助家族的服务业务：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This child process should print out the sent message to your console, and begin
    listening for connections, sharing the sent server handle.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子进程应该会在您的控制台上打印出发送的消息，并开始监听连接，共享发送的服务器句柄。
- en: Repeatedly connecting to this server at `localhost:8080` will result in either
    child-handled connection or parent-handled connection being displayed; two separate
    processes are balancing the server load. This technique, when combined with the
    simple inter-process messaging protocol discussed previously, demonstrates how
    *Ryan Dahl's* creation succeeds in providing an easy way to build scalable network
    programs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重复连接到`localhost:8080`的服务器将显示由子进程处理的连接或由父进程处理的连接；两个独立的进程正在平衡服务器负载。当与之前讨论的简单进程间通信协议相结合时，这种技术展示了*Ryan
    Dahl*的创作如何成功地提供了构建可扩展网络程序的简单方法。
- en: We've connected two nodes with just a few lines of code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只用了几行代码就连接了两个节点。
- en: We will discuss Node's new cluster module, which expands and simplifies the
    previously discussed technique in [Chapter 7](48e16668-9318-4577-b3c0-3f4dbce035d9.xhtml),
    *Using Multiple Processes*. If you are interested in how server handles are shared,
    visit the cluster documentation: [https://nodejs.org/dist/latest-v9.x/docs/api/cluster.html](https://nodejs.org/dist/latest-v9.x/docs/api/cluster.html)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论Node的新集群模块，它扩展并简化了之前在[第7章](48e16668-9318-4577-b3c0-3f4dbce035d9.xhtml)中讨论的技术，*使用多个进程*。如果您对服务器处理共享感兴趣，请访问集群文档：[https://nodejs.org/dist/latest-v9.x/docs/api/cluster.html](https://nodejs.org/dist/latest-v9.x/docs/api/cluster.html)
- en: File events
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件事件
- en: Most applications make some use of the filesystem, in particular, those that
    function as web services. As well, a professional application will likely log
    information about usage, cache pre-rendered data views, or make other changes
    to files and directory structures. Node allows developers to register for notifications
    on file events through the `fs.watch` method. The `watch` method broadcasts changed
    events on both files and directories.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都会对文件系统进行一些操作，特别是那些作为Web服务的应用程序。此外，专业的应用程序可能会记录有关使用情况的信息，缓存预渲染的数据视图，或者对文件和目录结构进行其他更改。Node允许开发人员通过`fs.watch`方法注册文件事件的通知。`watch`方法会在文件和目录上广播更改事件。
- en: 'The `watch` method accepts three arguments, in order:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`方法按顺序接受三个参数：'
- en: The file or directory path being watched. If the file does not exist, an **ENOENT
    (no entity)** error will be thrown, so using `fs.exists` at some prior useful
    point is encouraged.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在被监视的文件或目录路径。如果文件不存在，将抛出**ENOENT（没有实体）**错误，因此建议在某个有用的先前点使用`fs.exists`。
- en: 'An optional options object, including:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的选项对象，包括：
- en: 'Persistent (Boolean default true): Node keeps processes alive, as long as there
    is *something to do*. Set this option to *false* to let Node close the process
    even if your code still has a file watcher watching.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久（默认为true的布尔值）：Node会保持进程活动，只要还有*事情要做*。将此选项设置为*false*，即使你的代码仍然有一个文件监视器在监视，也会让Node关闭进程。
- en: 'Recursive (Boolean default false): Whether to automatically descend into subdirectories.
    Note: This is not consistently implemented across platforms. For this reason,
    and for performance reasons, you should explicitly control the file list you are
    watching, rather than randomly watching directories.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归（默认为false的布尔值）：是否自动进入子目录。注意：这在不同平台上的实现不一致。因此，出于性能考虑，你应该明确控制你要监视的文件列表，而不是随意监视目录。
- en: 'Encoding (String default `utf8`): Character encoding of passed filenames. You
    probably don''t need to change this.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码（默认为`utf8`的字符串）：传递文件名的字符编码。你可能不需要更改这个。
- en: 'The `listener` function, which receives two arguments:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listener`函数，接收两个参数：'
- en: The name of the change event (one of rename or change)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改事件的名称（`rename`或`change`之一）
- en: The filename that was changed (important when watching directories)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已更改的文件名（在监视目录时很重要）
- en: 'This example will set up a watcher on itself, change its own filename, and
    exit:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将在自身上设置一个观察者，更改自己的文件名，然后退出：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Two lines, `rename` and the name of the original file, should have been printed
    to the console.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 两行，`rename`和原始文件的名称，应该已经打印到控制台上。
- en: 'Close your watcher channel whenever you want to use code like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候关闭你的观察者通道，你想使用这样的代码：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It should be noted that `fs.watch` depends a great deal on how the host OS
    handles file events, and the Node documentation says this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，`fs.watch`在很大程度上取决于主机操作系统如何处理文件事件，Node文档中也提到了这一点：
- en: '"The fs.watch API is not 100% consistent across platforms, and is unavailable
    in some situations."'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: “fs.watch API在各个平台上并不完全一致，并且在某些情况下不可用。”
- en: The author has had very good experiences with the module across many different
    systems, noting only that the filename argument is null in callbacks on OS X implementations.
    Different systems may also enforce case sensitivity, one way or the other. Nevertheless,
    be sure to run tests on your specific architecture — trust, but verify.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作者在许多不同的系统上对该模块有非常好的体验，只是在OS X实现中回调函数的文件名参数为空。不同的系统也可能强制执行大小写敏感性，无论哪种方式。然而，一定要在你特定的架构上运行测试
    —— 信任，但要验证。
- en: 'Alternatively, use a third-party package! If you encounter difficulties with
    a Node module, check npm for alternatives. Here, as a problem-fixing wrapper on
    top of `fs.watch`, consider *Paul Miller''s* *chokidar*. It is used as the file-watching
    tool for build systems like gulp, and in many other projects. Refer to: [https://www.npmjs.com/package/chokidar](https://www.npmjs.com/package/chokidar).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用第三方包！如果你在使用Node模块时遇到困难，请检查npm是否有替代方案。在这里，作为`fs.watch`的问题修复包装器，考虑*Paul Miller*的*chokidar*。它被用作构建系统（如gulp）的文件监视工具，以及许多其他项目。参考：[https://www.npmjs.com/package/chokidar](https://www.npmjs.com/package/chokidar)。
- en: Deferred execution
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟执行
- en: One occasionally needs to defer the execution of a function. Traditional JavaScript
    uses timers for this purpose, with the well-known `setTimeout` and `setInterval` functions.
    Node introduces another perspective on defers, primarily as means of controlling
    the order in which a callback executes in relation to I/O events, as well as timer
    events properly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要推迟执行一个函数。传统的JavaScript使用定时器来实现这一目的，使用众所周知的`setTimeout`和`setInterval`函数。Node引入了另一种推迟执行的方式，主要是作为控制回调函数在I/O事件和定时器事件之间执行顺序的手段。
- en: As we saw earlier, managing timers is one of the main jobs of Node's event loop.
    Two types of deferred event sources that give a developer the ability to schedule
    callback executions to occur either before, or after, the processing of queued
    I/O events are `process.nextTick` and `setImmediate`. Let's look at those now.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，管理定时器是Node事件循环的主要工作之一。两种延迟事件源，使开发人员能够安排回调函数的执行在排队的I/O事件之前或之后，分别是`process.nextTick`和`setImmediate`。现在让我们来看看这些。
- en: process.nextTick
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: process.nextTick
- en: A method of the native Node process module, `process.nextTick` is similar to
    the familiar `setTimeout` method in which it delays execution of its callback
    function until some point in the future. However, the comparison is not exact;
    a list of all requested `nextTick` callbacks are placed at the head of the event
    queue, and is processed, in its entirety and in order, before I/O or timer events
    and after execution of the current script (the JavaScript code executing synchronously
    on the V8 thread).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为原生Node进程模块的一种方法，`process.nextTick`类似于熟悉的`setTimeout`方法，它延迟执行其回调函数直到将来的某个时间点。然而，这种比较并不完全准确；所有请求的`nextTick`回调函数列表都被放在事件队列的头部，并在当前脚本的执行之后（JavaScript代码在V8线程上同步执行）和I/O或定时器事件之前，按顺序处理。
- en: The primary use of `nextTick` in a function is to postpone the broadcast of
    result events to listeners on the current execution stack until the caller has
    had an opportunity to register event listeners, giving the currently executing
    program a chance to bind callbacks to `EventEmitter.emit` events.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中使用`nextTick`的主要目的是将结果事件的广播推迟到当前执行堆栈上的监听器在调用者有机会注册事件监听器之前，给当前执行的程序一个机会将回调绑定到`EventEmitter.emit`事件。
- en: Think of this as a pattern to use wherever you want to create your own asynchronous
    behavior. For instance, imagine a lookup system that may either fetch from a cache,
    or pull fresh data from a data store. The cache is fast and doesn't need callbacks,
    while the data I/O call would need them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 把这看作是一个模式，可以在任何想要创建自己的异步行为的地方使用。例如，想象一个查找系统，可以从缓存中获取，也可以从数据存储中获取新鲜数据。缓存很快，不需要回调，而数据I/O调用需要它们。
- en: The need for callbacks in the second case argues for emulation of the callback
    behavior, with `nextTick` in the first case. This allows a consistent API, improving
    clarity of implementation without burdening the developer with the responsibility
    of determining whether or not to use a callback.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况中回调的需求支持对回调行为的模拟，在第一种情况中使用`nextTick`。这允许一致的API，提高了实现的清晰度，而不会使开发人员负担起确定是否使用回调的责任。
- en: 'The following code seems to set up a simple transaction; when an instance of
    `EventEmitter` emits a start event, log `Started` to the console:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码似乎设置了一个简单的事务；当`EventEmitter`的一个实例发出开始事件时，将`Started`记录到控制台：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, the result you might expect will not occur! The event emitter instantiated
    within `getEmitter` emits `start` previous to being returned, wrong-footing the
    subsequent assignment of a listener, which arrives a step late, missing the event
    notification.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能期望的结果不会发生！在`getEmitter`中实例化的事件发射器在返回之前发出`start`，导致后续分配的监听器出现错误，它到达时已经晚了一步，错过了事件通知。
- en: 'To solve this race condition, we can use `process.nextTick`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这种竞争条件，我们可以使用`process.nextTick`：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code attaches the `on("start")` handler before Node gives us the `start`
    event, and works properly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在Node给我们`start`事件之前附加了`on("start")`处理程序，并且可以正常工作。
- en: Erroneous code can recursively call `nextTick`, causing an unending loop of
    code to run. Note that unlike a recursive call to a function within a single turn
    of the event loop, doing this won't cause a stack overflow. Rather, it will starve
    the event loop, churn your process on the microprocessor, and could prevent your
    program from discovering the I/O that Node has finished.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的代码可能会递归调用`nextTick`，导致代码无休止地运行。请注意，与在事件循环的单个轮次内对函数进行递归调用不同，这样做不会导致堆栈溢出。相反，它会使事件循环饥饿，使微处理器上的进程繁忙，并可能阻止程序发现Node已经完成的I/O。
- en: setImmediate
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setImmediate
- en: '`setImmediate` is technically a member of the class of timers, along with `setInterval`
    and `setTimeout` . However, there is no sense of time associated with it — there
    is no *number of milliseconds* to wait for an argument to be sent.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`setImmediate`在技术上是定时器类的成员，与`setInterval`和`setTimeout`一起。但是，它与时间无关——没有*毫秒数*等待发送参数。'
- en: 'This method is really more of a sibling to `process.nextTick`, differing in
    one very important way: while callbacks queued by `nextTick` will execute before
    I/O and timer events, callbacks queued by `setImmediate` will be called after
    I/O events.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法实际上更像是`process.nextTick`的一个同级，有一个非常重要的区别：通过`nextTick`排队的回调将在I/O和定时器事件之前执行，而通过`setImmediate`排队的回调将在I/O事件之后调用。
- en: 'The naming of these two methods is confusing: Node will actually run the function
    you give to `nextTick` before the one you pass to `setImmediate`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的命名令人困惑：Node实际上会在你传递给`setImmediate`的函数之前运行你传递给`nextTick`的函数。
- en: This method does reflect the standard behavior of timers in that its invocation
    will return an object that can be passed to `clearImmediate`, cancelling your
    request to run your function later on in the same way `clearTimeout` cancels timers
    set with `setTimeout`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法确实反映了定时器的标准行为，它的调用将返回一个对象，可以传递给`clearImmediate`，取消你对以后运行函数的请求，就像`clearTimeout`取消使用`setTimeout`设置的定时器一样。
- en: Timers
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器
- en: Timers are used to schedule events in the future. They are used when one seeks
    to delay the execution of some block of code until a specified number of milliseconds
    have passed, to schedule periodic execution of a particular function, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器用于安排将来的事件。当需要延迟执行某些代码块直到指定的毫秒数过去时，用于安排特定函数的周期性执行等等时，就会使用它们。
- en: 'JavaScript provides two asynchronous timers: `setInterval()` and `setTimeout()`.
    It is assumed that the reader is fully aware of how to set (and cancel) these
    timers, so very little time will be spent discussing the syntax. We''ll instead
    focus more on gotchas and less well-known details about timeouts and intervals.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了两个异步定时器：`setInterval()`和`setTimeout()`。假设读者完全了解如何设置（和取消）这些定时器，因此将不会花费太多时间讨论语法。我们将更多地关注定时和间隔的陷阱和不太为人知的细节。
- en: 'The key takeaway will be this: when using timers, one should make no assumptions
    about the amount of actual time that will expire before the callback registered
    for this timer fires, or about the ordering of callbacks. Node timers are not
    interrupts. Timers simply promise to execute as close as possible to the specified
    time (though never before), beholden, as with every other event source, to event
    loop scheduling.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点是：在使用定时器时，不应该对定时器触发注册的回调函数之前实际过去的时间量或回调的顺序做任何假设。Node定时器不是中断。定时器只是承诺尽可能接近指定的时间执行（但绝不会提前），与其他事件源一样，受事件循环调度的约束。
- en: 'At least one thing you may not know about timers-we are all familiar with the
    standard arguments to `setTimeout`: a callback function and timeout interval.
    Did you know that many additional arguments are passed to the `callback` function?
    `setTimeout(callback, time, [passArg1, passArg2…])`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于定时器你可能不知道的一件事是-我们都熟悉`setTimeout`的标准参数：回调函数和超时间隔。你知道传递给`callback`函数的还有许多其他参数吗？`setTimeout(callback,
    time, [passArg1, passArg2…])`
- en: setTimeout
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setTimeout
- en: Timeouts can be used to defer the execution of a function until some number
    of milliseconds into the future.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 超时可以用来推迟函数的执行，直到未来的某个毫秒数。
- en: 'Consider the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One would expect that function `b` would execute after function `a`. However,
    this cannot be guaranteed — `a` may follow `b`, or the other way around.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 人们会期望函数`b`会在函数`a`之后执行。然而，这并不能保证-`a`可能在`b`之后执行，或者反过来。
- en: 'Now, consider the subtle difference present in the following code snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码片段中存在的微妙差异：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The execution order of `a` and `b` are predictable in this case. Node essentially
    maintains an object map grouping callbacks with identical timeout lengths. *Isaac
    Schlueter*, a former leader of the Node project and now CEO of npm Inc., puts
    it in this way:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“a”和“b”的执行顺序是可以预测的。Node基本上维护一个对象映射，将具有相同超时长度的回调分组。*Isaac Schlueter*，Node项目的前任领导，现任npm
    Inc.的首席执行官，这样说：
- en: As we can find on [https://groups.google.com/forum/#!msg/nodejs-dev/kiowz4iht4Q/T0RuSwAeJV0J](https://groups.google.com/forum/#!msg/nodejs-dev/kiowz4iht4Q/T0RuSwAeJV0J), "[N]ode
    uses a single low level timer object for each timeout value. If you attach multiple
    callbacks for a single timeout value, they'll occur in order, because they're
    sitting in a queue. However, if they're on different timeout values, then they'll
    be using timers in different threads, and are thus subject to the vagaries of
    the [CPU] scheduler."
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[https://groups.google.com/forum/#!msg/nodejs-dev/kiowz4iht4Q/T0RuSwAeJV0J](https://groups.google.com/forum/#!msg/nodejs-dev/kiowz4iht4Q/T0RuSwAeJV0J)上发现的，“[N]ode为每个超时值使用单个低级定时器对象。如果为单个超时值附加多个回调，它们将按顺序发生，因为它们位于队列中。但是，如果它们位于不同的超时值上，那么它们将使用不同的线程中的定时器，因此受[CPU]调度程序的影响。”
- en: The ordering of timer callbacks registered within an identical execution scope
    does not predictably determine the eventual execution order in all cases. Additionally,
    there exists a minimum wait time of one millisecond for a timeout. Passing a value
    of zero, -1, or a non-number will be translated into this minimum value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的执行范围内注册的定时器回调的顺序并不能在所有情况下可预测地决定最终的执行顺序。此外，超时的最小等待时间为一毫秒。传递零、-1或非数字的值将被转换为这个最小值。
- en: To cancel a timeout, use `clearTimeout(timerReference)`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消超时，请使用`clearTimeout(timerReference)`。
- en: setInterval
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setInterval
- en: 'One can think of many cases where being able to periodically execute a function
    would be useful. Polling a data source every few seconds and pushing updates is
    a common pattern. Running the next step in an animation every few milliseconds
    is another use case, as is collecting garbage. For these cases, `setInterval`
    is a good tool:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况可以想象到定期执行函数会很有用。每隔几秒轮询数据源并推送更新是一种常见模式。每隔几毫秒运行动画的下一步是另一种用例，还有收集垃圾。对于这些情况，`setInterval`是一个很好的工具：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Every 100 milliseconds the sent callback function will execute, a process that
    can be cancelled with `clearInterval(intervalReference)`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每隔100毫秒，发送的回调函数将执行，这个过程可以使用`clearInterval(intervalReference)`来取消。
- en: Unfortunately, as with `setTimeout`, this behavior is not always reliable. Importantly,
    if a system delay (such as some badly written blocking `while` loop) occupies
    the event loop for some period of time, intervals set prior and completing within
    that interim will have their results queued on the stack. When the event loop
    becomes unblocked and unwinds, all the interval callbacks will be fired in sequence,
    essentially immediately, losing any sort of timing delays they intended.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，与`setTimeout`一样，这种行为并不总是可靠的。重要的是，如果系统延迟（比如一些糟糕的写法的阻塞`while`循环）占据事件循环一段时间，那么在这段时间内设置的间隔将在堆栈上排队等待结果。当事件循环变得不受阻塞并解开时，所有间隔回调将按顺序被触发，基本上是立即触发，失去了它们原本意图的任何时间延迟。
- en: Luckily, unlike browser-based JavaScript, intervals are rather more reliable
    in Node, generally able to maintain expected periodicity in normal use scenarios.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，与基于浏览器的JavaScript不同，Node中的间隔通常更加可靠，通常能够在正常使用场景中保持预期的周期性。
- en: unref and ref
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: unref和ref
- en: A Node program does not stay alive without a reason to do so. A process will
    keep running for as long as there are callbacks still waiting to be processed.
    Once those are cleared, the Node process has nothing left to do, and it will exit.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Node程序没有理由保持活动状态。只要还有等待处理的回调，进程就会继续运行。一旦这些被清除，Node进程就没有其他事情可做了，它就会退出。
- en: 'For example, the following silly code fragment will keep a Node process running
    forever:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下愚蠢的代码片段将使Node进程永远运行：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Even though the set callback function does nothing useful or interesting, it
    continues to be called. This is the correct behavior, as an interval should keep
    running until `clearInterval` is used to stop it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 即使设置的回调函数没有任何有用或有趣的内容，它仍然会被调用。这是正确的行为，因为间隔应该一直运行，直到使用`clearInterval`停止它。
- en: There are cases of using a timer to do something interesting with external I/O,
    or some data structure, or a network interface, where once those external event
    sources stop occurring or disappear, the timer itself becomes unnecessary. Normally,
    one would trap that irrelevant state of a timer somewhere else in the program,
    and cancel the timer from there. This can become difficult or even clumsy, as
    an unnecessary tangling of concerns is now necessary, an added level of complexity.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，使用定时器来对外部I/O、某些数据结构或网络接口进行一些有趣的操作，一旦这些外部事件源停止发生或消失，定时器本身就变得不必要。通常情况下，人们会在程序的其他地方捕获定时器的无关状态，并从那里取消定时器。这可能会变得困难甚至笨拙，因为现在需要不必要地纠缠关注点，增加了复杂性。
- en: 'The `unref` method allows the developer to assert the following instructions:
    when this timer is the only event source remaining for the event loop to process,
    go ahead and terminate the process.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`unref`方法允许开发人员断言以下指令：当这个定时器是事件循环处理的唯一事件源时，继续终止进程。'
- en: 'Let''s test this functionality to our previous silly example, which will result
    in the process terminating rather than running forever:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个功能测试到我们之前的愚蠢示例中，这将导致进程终止而不是永远运行：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that `unref` is a method of the opaque value returned when starting a timer,
    which is an object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`unref`是启动定时器时返回的不透明值的一个方法，它是一个对象。
- en: 'Now, let''s add an external event source, a timer. Once that external source
    gets cleaned up (in about 100 milliseconds), the process will terminate. We send
    information to the console to log what is happening:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个外部事件源，一个定时器。一旦这个外部源被清理（大约100毫秒），进程将终止。我们向控制台发送信息来记录发生了什么：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You may return a timer to its normal behavior with `ref`, which will undo an
    `unref` method:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`ref`将定时器恢复到正常行为，这将撤消`unref`方法：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The listed process will continue indefinitely, as in our original silly example.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的进程将继续无限期地进行，就像我们最初的愚蠢示例一样。
- en: Snap quiz! After running the following code, what is the expected order of logged
    messages?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测验！运行以下代码后，日志消息的预期顺序是什么？
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of this program is:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出是：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s break the preceding code down:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解上述代码：
- en: A, F, and I execute in the main program flow, and as such, they will have the
    first priority in the main thread. This is obvious; your JavaScript executes its
    instructions in the order they are written, including the synchronous execution
    of the emit callback.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: A、F和I在主程序流中执行，因此它们将在主线程中具有第一优先级。这是显而易见的；你的JavaScript按照它们被编写的顺序执行指令，包括发出回调的同步执行。
- en: With the main call stack exhausted, the event loop is now almost reading to
    process I/O operations. This is the moment when `nextTick` requests are honored,
    slotting in at the head of the event queue. This is when B is displayed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 主调用堆栈耗尽后，事件循环现在几乎可以开始处理I/O操作。这是`nextTick`请求被执行的时刻，它们排在事件队列的最前面。这时B被显示出来。
- en: The rest of the order should be clear. Timers and I/O operations will be processed
    next, (C, G, H) followed by the results of the `setImmediate` callback (E), always
    arriving after any I/O and timer responses are executed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的顺序应该是清楚的。定时器和I/O操作将被处理（C、G、H），然后是`setImmediate`回调的结果（E），始终在执行任何I/O和定时器响应之后到达。
- en: Finally, the long timeout (D) arrives, being a relatively far-future event.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，长时间超时（D）到达，这是一个相对遥远的未来事件。
- en: Note that reordering the expressions in this program will not change the output
    order outside of possible reordering of the STAT results, which only implies that
    they have been returned from the thread pool in a different order, remaining as
    a group in the correct order as related to the event queue.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，重新排列此程序中的表达式不会改变输出顺序，除了可能重新排列STAT结果之外，这只意味着它们以不同的顺序从线程池返回，但仍然作为与事件队列相关的正确顺序的一组。
- en: Concurrency and errors
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和错误
- en: Members of the Node community develop new packages and projects every day. Because
    of Node's evented nature, callbacks permeate these codebases. We've considered
    several of the key ways in which events might be queued, dispatched, and handled
    through the use of callbacks. Let's spend a little time outlining the best practices,
    in particular, about conventions for designing callbacks and handling errors,
    and discuss some useful patterns when designing complex chains of events and callbacks.
    In particular, let's look at the new Promise, Generator, and async/await patterns
    that you will see in this book, and other examples of modern Node code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Node社区的成员每天都在开发新的包和项目。由于Node的事件性质，回调渗透到这些代码库中。我们已经考虑了事件可能如何通过回调排队、分发和处理的关键方式。让我们花点时间概述最佳实践，特别是关于设计回调和处理错误的约定，并讨论在设计复杂的事件和回调链时一些有用的模式。特别是，让我们看看在本书中会看到的新Promise、Generator和async/await模式，以及现代Node代码的其他示例。
- en: Managing concurrency
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发管理
- en: Simplifying control flows has been a concern of the Node community since the
    very beginning of the project. Indeed, this potential criticism was one of the
    very first anticipated by *Ryan Dahl*, who discussed it at length during the talk
    in which he introduced Node to the JavaScript developer community.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 自从项目开始以来，简化控制流一直是Node社区关注的问题。事实上，这种潜在的批评是*Ryan Dahl*在向JavaScript开发者社区介绍Node时讨论的第一个预期批评之一。
- en: 'Because deferred code execution often requires the nesting of callbacks within
    callbacks, a Node program can sometimes begin to resemble a sideways pyramid,
    also known as *The Pyramid of Doom*. You''ve seen it: deeply nested code, 4 or
    5 or even more levels deep, curly braces everywhere. Apart from syntactical annoyances,
    you can also imagine that tracking errors across such a call stack might be difficult—if
    a callback at the third level throws, who is responsible for handling that error?
    The second level? Even if level 2 is reading a file and level 3 is querying a
    database? Does that make sense? It can be hard to make sense of asynchronous program
    flows.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于延迟代码执行通常需要在回调中嵌套回调，因此Node程序有时会开始类似于侧向金字塔，也被称为“末日金字塔”。你见过吧：深度嵌套的代码，4层或5层甚至更深，到处都是花括号。除了语法上的烦恼，你也可以想象在这样的调用堆栈中跟踪错误可能会很困难——如果第三层的回调抛出异常，谁负责处理这个错误？第二层吗？即使第二层正在读取文件，第三层正在查询数据库？这有意义吗？很难理解异步程序流的含义。
- en: Callbacks
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: Luckily, Node creators agreed upon sane conventions on how to structure callbacks
    early on. It is important to follow this tradition. Deviation leads to surprises,
    sometimes very bad surprises, and in general, to do so automatically makes an
    API awkward, a characteristic other developers will rapidly tire of.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Node的创建者们早早就就如何构造回调达成了理智的共识。遵循这一传统是很重要的。偏离会带来意外，有时是非常糟糕的意外，总的来说，这样做会自动使API变得笨拙，而其他开发人员会迅速厌倦。
- en: One is either returning a function result by executing a `callback`, handling
    the arguments received by a `callback`, or designing the signature for a `callback`
    within your API. Whichever situation is being considered, one should follow the
    convention relevant to that case.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个要么通过执行`callback`返回函数结果，要么处理`callback`接收到的参数，要么在API中设计`callback`的签名。无论考虑的是哪种情况，都应该遵循与该情况相关的惯例。
- en: The first argument returned to a `callback` function is any error message, preferably
    in the form of an error object. If no error is to be reported, this slot should
    contain a null value.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`callback`函数的第一个参数是任何错误消息，最好是以错误对象的形式。如果不需要报告错误，这个位置应该包含一个空值。
- en: When passing a `callback` to a function, it should be assigned the last slot
    of the function signature. APIs should be consistently designed this way.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`callback`传递给函数时，它应该被分配到函数签名的最后一个位置。API应该一贯地按照这种方式设计。
- en: Any number of arguments may exist between the error and the `callback` slots.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误和`callback`之间可能存在任意数量的参数。
- en: To create an error object: `new Error("Argument must be a String!")`
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 创建错误对象：`new Error("Argument must be a String!")`
- en: Promises
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises
- en: Like some politicians, the Node core was against Promises before it was for
    them. *Mikeal Rogers*, in discussing why Promises were removed from the original
    Node core, makes a strong argument for why leaving feature development to the
    community leads to a stronger core product. You can view this discussion at: [https://web.archive.org/posts/broken-promises.html](https://web.archive.org/posts/broken-promises.html)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一些政客一样，Node核心在支持Promises之前反对它们。*Mikeal Rogers*在讨论为什么Promises从最初的Node核心中被移除时，提出了一个强有力的论点，即将功能开发留给社区会导致更强大的核心产品。你可以在这里查看这个讨论：[https://web.archive.org/posts/broken-promises.html](https://web.archive.org/posts/broken-promises.html)
- en: 'Promises have gained a very large following since then, and Node core has changed
    in response. Promises are essentially a replacement for the standard callback
    pattern seen everywhere in Node. Once, you might have written this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，Promises已经获得了非常庞大的追随者，Node核心也做出了改变。Promises本质上是标准回调模式的替代品，而标准回调模式在Node中随处可见。曾经，你可能会这样写：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If API was instead "Promisified" (recall `util.promisify` from the previous
    chapter?), your description of the preceding asynchronous control flow would be
    described using a Promise chain:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API改为"Promisified"（回想一下前一章中的`util.promisify`？），你对前面的异步控制流的描述将使用Promise链来描述：
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is at least a tighter syntax that reads a little more easily, with long
    chains of operations; however, there is much more going on here that is of value.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这至少是一个更紧凑的语法，读起来更容易一些，操作的链条更长；然而，这里有更多有价值的东西。
- en: '`promiseProfile` references a Promise object. Promises only execute once, reaching
    either an error state (unfulfilled) or fulfilled state, where you can extract
    the last, immutable value via `then`, as we did with profile, previously. Of course,
    Promises can be assigned to a variable, and that variable can be passed around
    to as many consumers as you''d like, even prior to resolving. Since `then` is
    only called when there is a value available, whenever that may be, Promises are
    aptly named as promises of a future state.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`promiseProfile`引用了一个Promise对象。Promises只执行一次，达到错误状态（未完成）或完成状态，你可以通过`then`提取最后的不可变值，就像我们之前对profile所做的那样。当然，Promises可以被分配给一个变量，并且该变量可以传递给尽可能多的消费者，甚至在解决之前。由于`then`只有在有值可用时才会被调用，无论何时，Promises都被称为未来状态的承诺。'
- en: 'Perhaps most importantly, Promises, unlike callbacks, are able to manage errors
    across many asynchronous actions. If you go back and look at the example callback
    code at the head of this section, you''ll see err parameters in each callback,
    reflecting the core error-first callback style of Node. Each of those error objects
    must be handled individually, so the preceding code would actually start to look
    more like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最重要的是，与回调不同，Promises能够管理许多异步操作中的错误。如果你回头看一下本节开头的示例回调代码，你会看到每个回调中都有`err`参数，反映了Node的核心错误优先回调风格。每个错误对象都必须单独处理，因此前面的代码实际上会开始看起来更像这样：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Observe how each error condition must be handled individually. In practice,
    developers would like to be responsible for "hand-rolling" a wrapper around this
    code, such as a `try...catch` block, which would, in some way, catch all errors
    in this logical unit and manage them in a centralized way.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 观察每个错误条件必须单独处理。在实践中，开发人员希望对这段代码进行"手动"包装，比如使用`try...catch`块，以某种方式捕获这个逻辑单元中的所有错误并以集中的方式进行管理。
- en: 'With Promises, you get that for free. Any `catch` statement will catch any
    errors thrown by any `then` prior to it in the chain. This makes creating a common
    error handler a snap. Even more, Promises allows the execution chain to continue
    past an error. You can add the following to the previous Promise chain:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Promises，你可以免费获得这些。任何`catch`语句都会捕获链中之前的任何`then`抛出的错误。这使得创建一个通用的错误处理程序变得轻而易举。更重要的是，Promises允许执行链在错误发生后继续。你可以将以下内容添加到前面的Promise链中：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this way, Promises allows you to compose rather complex, asynchronous, logical
    flows in much less space, with limited indentation, where error handling is much
    easier to work with and values are immutable and exchangeable.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Promises，你可以在更少的空间中组合相当复杂的异步逻辑流，缩进有限，错误处理更容易处理，值是不可变的且可交换的。
- en: 'Another extremely useful feature of the Promise object is that these future-resolving
    states can be managed as a block. For instance, imagine that to fulfill a query
    for a user profile, you needed to make three database calls. Rather than chaining
    these calls which always run serially, one at a time in order, you might use `Promise.all`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Promise对象的另一个非常有用的特性是，这些未来解析的状态可以作为一个块来管理。例如，想象一下，为了满足对用户配置文件的查询，你需要进行三次数据库调用。与其总是串行地链式调用这些调用，你可以使用`Promise.all`：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, all three of the Promises will be triggered *simultaneously,* and will *run
    in parallel*. Running calls in parallel is, of course, much more efficient than
    running them serially. Also, `Promise.all` guarantees that the final thennable
    receives an array of results ordered to synchronize result position with caller
    position.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有三个Promise将被同时触发，并且将并行运行。并行运行调用当然比串行运行更有效率。此外，`Promise.all`保证最终的thenable接收到一个按照调用者位置同步结果位置排序的结果数组。
- en: It would be good for you to familiarize yourself with the full Promise API,
    which you can read about at MDN: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你最好熟悉一下完整的Promise API，你可以在MDN上阅读：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- en: Even though Promises are now native, there remains a "userland" module, bluebird,
    which continues to offer a compelling alternative Promises implementation, with
    added features and oftentimes faster execution speed. You can read more about
    bluebird here: [http://bluebirdjs.com/docs/api-reference.html](http://bluebirdjs.com/docs/api-reference.html).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Promises现在是原生的，但仍然存在一个“用户空间”模块，bluebird，它继续提供一个引人注目的替代Promises实现，具有附加功能，通常执行速度更快。你可以在这里阅读更多关于bluebird的信息：[http://bluebirdjs.com/docs/api-reference.html](http://bluebirdjs.com/docs/api-reference.html)。
- en: async/await
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async/await
- en: Rather than wrap fulfillment in a specialized data structure like a Promise
    with so many function blocks and parentheses and special contexts, why not simply
    make it so that asynchronous expressions can have their cake and eat it, too?
    These expressions do not block the process (asynchronous execution), but they
    nevertheless halt further execution of a program (synchronous) until resolved.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与其用一个专门的数据结构来包装满足条件，比如一个带有许多函数块和括号和特殊上下文的Promise，为什么不简单地让异步表达式既能实现异步执行，又能实现程序的进一步执行（同步）直到解决？
- en: 'The `await` operator is used to wait for a Promise. It only executes within
    an `async` function. The `async/await` concurrency modeling syntax has been available
    since Node 8.x. Here''s a demonstration of `async/await` being used to replicate
    the preceding `Promise.all` example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`操作符用于等待一个Promise。它只在`async`函数内部执行。`async/await`并发建模语法自Node 8.x以来就可用。这里演示了`async/await`被用来复制之前的`Promise.all`的例子：'
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Nice, right? You'll note that `profile()` returned a Promise. An `async` function *always *returns
    a Promise, though as we see here, the function itself can return anything it would
    like.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，对吧？你会注意到`profile()`返回了一个Promise。一个`async`函数*总是*返回一个Promise，尽管我们在这里看到，函数本身可以返回任何它想要的东西。
- en: 'Promises and `async`/`await` work together like old pals. Here is a recursive
    directory walker that demonstrates this teamwork:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Promises和`async`/`await`像老朋友一样合作。这里有一个递归目录遍历器，演示了这种合作：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It's a testament to how terse the code is for this recursive directory walker,
    that it is only slightly longer than the setup code above it. Since `await` expects
    a Promise, which `Promise.all` will return, run through every file that the `readDir`
    Promise returns, and map each file to another awaited Promise that will handle
    any recursive descent into subdirectories, updating the accumulator where appropriate.
    Read like this, the `Promise.all((await readdir(dir)).map` construct reads not
    unlike a basic looping construct, where deep asynchronous recursion  is being
    modelled in a simple and easy-to-follow procedural, synchronous way.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归目录遍历器的代码非常简洁，只比上面的设置代码稍长一点。由于`await`期望一个Promise，而`Promise.all`将返回一个Promise，所以通过`readDir`
    Promise返回的每个文件运行，然后将每个文件映射到另一个等待的Promise，该Promise将处理任何递归进入子目录，根据需要更新累加器。这样阅读，`Promise.all((await
    readdir(dir)).map`的结构读起来不像一个基本的循环结构，其中深层异步递归以一种简单易懂的过程化、同步的方式进行建模。
- en: 'A pure Promise drop-in replacement version might look like this, assuming the
    same dependencies as the `async`/`await` version:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一个纯Promise的替代版本可能看起来像这样，假设与`async`/`await`版本相同的依赖关系：
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Both versions are cleaner than what you would have with callbacks. The `async/await` version
    does take the best of both worlds, and creates a succinct representation resembling
    synchronous code, making it perhaps easier to follow and reason about.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本都比回调函数更清晰。`async/await`版本确实兼顾了两者的优点，并创建了一个简洁的表示，类似于同步代码，可能更容易理解和推理。
- en: Error handling with `async/await` is also quite easy, as it requires no special
    new syntax. With Promises and `catch`, there is a slight problem with synchronous
    code errors. Promises catch errors that occur in `then` blocks. If, for example,
    a third-party library your code is calling throws, that code is not wrapped by
    the Promise and that error *will not be caught by `catch`*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async/await`进行错误处理也很容易，因为它不需要任何特殊的新语法。对于Promises和`catch`，同步代码错误存在一个小问题。Promises捕获发生在`then`块中的错误。例如，如果你的代码调用的第三方库抛出异常，那么该代码不会被Promise包装，而且该错误*不会被`catch`*捕获。
- en: 'With `async/await`, you can use the familiar `try...catch` statement:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async/await`，你可以使用熟悉的`try...catch`语句：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This avoids all problems with special error-catching constructs. This native,
    rock-solid method will catch anything that throws anywhere in the `try` block,
    regardless of whether execution is synchronous or not.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这避免了所有特殊错误捕获结构的问题。这种原生的、非常可靠的方法将捕获`try`块中任何地方抛出的任何东西，无论执行是同步还是异步。
- en: Generators and Iterators
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器和迭代器
- en: Generators are function execution contexts that can be paused and resumed. When
    you call a normal function, it will likely `return` a value; the function fully
    executes, then terminates. A Generator function will yield a value then stop but
    the function context of a Generator is not disposed of (as it is with normal functions).
    You can re-enter the Generator at a later point in time and pick up further results.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是可以暂停和恢复的函数执行上下文。当你调用一个普通函数时，它可能会`return`一个值；函数完全执行，然后终止。生成器函数将产生一个值然后停止，但是生成器的函数上下文不会被销毁（就像普通函数一样）。你可以在以后的时间点重新进入生成器并获取更多的结果。
- en: 'An example might help:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能会有所帮助：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A Generator is declared by marking it with an asterisk (`*`). On the first call
    to `threeThings`, we get don't get a result, but an Generator object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在生成器上标记一个星号（`*`）来声明生成器。在第一次调用`threeThings`时，我们不会得到一个结果，而是得到一个生成器对象。
- en: Generators conform to the new JavaScript iteration protocols ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)),
    which for our purposes mean that a Generator object exposes a `next` method, which
    is used to pull out as many values from a Generator as it is willing to yield.
    This power comes from the fact that Generators implement the JavaScript Iteration
    protocol. So, what's an iterator?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器符合新的JavaScript迭代协议（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)），对于我们的目的来说，这意味着生成器对象公开了一个`next`方法，该方法用于从生成器中提取尽可能多的值。这种能力来自于生成器实现了JavaScript迭代协议。那么，什么是迭代器？
- en: As [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators) says,
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)所说，
- en: '"An object is an iterator when it knows how to access items from a collection
    one at a time, while keeping track of its current position within that sequence.
    In JavaScript an iterator is an object that provides a next() method which returns
    the next item in the sequence. This method returns an object with two properties:
    done and value."'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: “当对象知道如何一次从集合中访问一个项，并跟踪其在该序列中的当前位置时，它就是一个迭代器。在JavaScript中，迭代器是提供了一个next()方法的对象，该方法返回序列中的下一个项。此方法返回一个具有两个属性的对象：done和value。”
- en: 'We can replicate the Generator example using just an Iterator:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仅使用迭代器来复制生成器示例：
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You''ll note that the results are nearly identical with the Generator example,
    with one important difference we can see in the first result: an Iterator is simply
    an object with a next method. It must do all the work of maintaining its own internal
    state (tracking `idx` in the previous example). Generators are factories for Iterators;
    furthermore, they do all the work of maintaining and yielding their own state.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，结果与生成器示例几乎相同，但在第一个结果中有一个重要的区别：迭代器只是一个具有next方法的对象。它必须完成维护自己的内部状态的所有工作（在先前的示例中跟踪`idx`）。生成器是迭代器的工厂；此外，它们完成了维护和产生自己的状态的所有工作。
- en: 'Descended from Iterators, Generators yield objects with two properties:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从迭代器继承，生成器产生具有两个属性的对象：
- en: '**done** : A Boolean. If true, the Generator is indicating that it has nothing
    left to `yield`. If you were to think of Generators as streams (not a bad parallel),
    then you might compare this pattern to the pattern of `Readable.read()` returning
    null when a stream has ended (or if you prefer, the way a `Readable` will push
    null when finished).'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**done**：一个布尔值。如果为true，则生成器表示它没有剩余的内容可以“yield”。如果你把生成器想象成流（这不是一个坏的类比），那么你可能会将这种模式与流结束时`Readable.read()`返回null的模式进行比较（或者如果你愿意，也可以将其与`Readable`在完成时推送null的方式进行比较）。'
- en: '**value**: The value of the last `yield`. Should be ignored if `done` is true.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**：最后一个`yield`的值。如果`done`为true，则应该忽略。'
- en: 'Generators are designed for iterative contexts, not unlike a loop, providing
    the powerful advantage of a function execution context. You may have written something
    like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器被设计用于迭代上下文，与循环类似，提供了函数执行上下文的强大优势。你可能已经写过类似这样的代码：
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is fine, but there are downsides, such as needing to create a local reference
    to an external data provider and maintaining that reference when this block or
    function terminates. Do we make `state` a global? Should it be immutable? If the
    underlying data changes, for example, a new element is added to the array, how
    do we make sure `state` is updated, disconnected as it is from the true state
    of our application? What if something accidentally overwrites `state`? Data observation
    and binding libraries exist, design theories exist, frameworks exist to properly
    encapsulate your data sources and inject immutable versions into execution contexts;
    but what if there was a better way?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，但也有缺点，比如需要创建对外部数据提供程序的本地引用，并在此块或函数终止时维护该引用。我们应该将`state`设置为全局变量吗？它应该是不可变的吗？例如，如果底层数据发生变化，例如向数组添加了一个新元素，我们如何确保`state`被更新，因为它与我们应用程序的真实状态是断开的？如果有什么意外地覆盖了`state`会怎么样？数据观察和绑定库存在，设计理论存在，框架存在，可以正确地封装数据源并将不可变版本注入执行上下文；但如果有更好的方法呢？
- en: 'Generators can contain and manage their own data and `yield` the right answer
    even through change. We can implement the previous code with Generators:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器可以包含和管理自己的数据，并且即使发生变化也可以“yield”正确的答案。我们可以使用生成器实现先前的代码：
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The Generator method handles all the "boilerplate" for sending back a value,
    and naturally encapsulates the state. But there doesn't seem to be a significant
    advantage here. This is because we are using a Generator to execute iterations
    that run sequentially and immediately. Generators are really for situations when
    a series of values are promised, with individual values being generated only when
    requested, over time. Rather than processing an array all at once and in order,
    what we really want to create is a sequential chain of communicating processes,
    each process "tick" calculating a result with visibility into previous process
    results.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器方法处理所有发送回值的“样板”，并自然地封装了状态。但在这里似乎没有显著的优势。这是因为我们正在使用生成器执行顺序和立即运行的迭代。生成器实际上是用于承诺一系列值的情况，只有在请求时才生成单个值，随着时间的推移。我们真正想要创建的不是一次性按顺序处理数组，而是创建一个连续的通信过程链，每个过程“tick”都计算一个结果，并能看到先前过程的结果。
- en: 'Consider the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况：
- en: '[PRE41]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can pass arguments to Generators. We create a `range` state machine by passing
    range bounds, where further calls to the machine will cause an internal state
    change, and yield the current state representation to the caller. While for demonstration
    purposes we use the `for...of` method of traversing Iterators (and therefore Generators),
    this sequential processing (which blocks the main thread until it is finished)
    can be made *asynchronous*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向生成器传递参数。我们通过传递范围边界来创建一个`range`状态机，进一步调用该机器将导致内部状态改变，并将当前状态表示返回给调用者。虽然为了演示目的，我们使用了遍历迭代器（因此生成器）的`for...of`方法，但这种顺序处理（会阻塞主线程直到完成）可以被*异步化*。
- en: The run/halt (not run/stop) design of Generators means that we can think of
    iteration not as running through a list, but of capturing a set of transition
    events over time. This idea is central to the idea of **Reactive Programming**
    ([https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming)),
    for example. Let's think through another example where this particular advantage
    of Generators can be displayed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的运行/暂停（而不是运行/停止）设计意味着我们可以将迭代看作不是遍历列表，而是捕获一组随时间变化的过渡事件。这个想法对于**响应式编程**（[https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming)）是核心的。让我们通过另一个例子来思考一下生成器的这种特殊优势。
- en: 'There are many other things you can do with these sorts of data structures.
    It might be helpful to think this way: Generators are to a sequence of future
    values as Promises are to a single future value. Both Promises and Generators
    can be passed around the instant they are generated (even if some eventual values
    are still resolving, or haven''t yet been queued for resolution), with one getting
    values via the `next()` interface, and the other via the `then()` interface.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些类型的数据结构，还有许多其他操作。这样想可能会有所帮助：生成器对未来值的序列就像Promises对单个未来值一样。Promises和生成器都可以在生成时传递（即使有些最终值仍在解析中，或者尚未排队等待解析），一个通过`next()`接口获取值，另一个通过`then()`接口获取值。
- en: Errors and exceptions
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误和异常
- en: Generally in programming, the terms *error* and *exception* are often used interchangeably.
    Within the Node environment, these two concepts are not identical. Errors and
    exceptions are different. Additionally, the definition of error and exception
    within Node does not necessarily align with similar definitions in other languages
    and development environments.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在编程中，术语*错误*和*异常*经常可以互换使用。在Node环境中，这两个概念并不相同。错误和异常是不同的。此外，在Node中，错误和异常的定义并不一定与其他语言和开发环境中类似的定义相一致。
- en: Conventionally, an **error** condition in a Node program is a non-fatal condition
    that should be caught and handled, seen most explicitly in the *Error as first
    argument* convention displayed by the typical Node callback pattern. An **exception**
    is a serious error (a system error) that a sane environment should not ignore
    or try to handle.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node程序中，**错误**条件通常是应该被捕获和处理的非致命条件，最明显地体现在典型的Node回调模式所显示的*错误作为第一个参数*约定中。**异常**是一个严重的错误（系统错误），一个明智的环境不应该忽视或尝试处理。
- en: 'One comes across four common error contexts in Node, and should respond predictably:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node中会遇到四种常见的错误上下文，并且应该有可预测的响应：
- en: '**A synchronous context**: This will normally happen in the context of a function,
    where a bad call signature or another non-fatal error is detected. The function
    should simply return an error object; `new Error(…)`, or some other consistent
    indicator that the function call has failed.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步上下文**：这通常发生在函数的上下文中，检测到错误的调用签名或其他非致命错误。函数应该简单地返回一个错误对象；`new Error(…)`，或者其他一致的指示函数调用失败的指示器。'
- en: '**An asynchronous context**: When expected to respond by firing a `callback`
    function, the execution context should pass an `Error` object, with appropriate
    message, as the first argument to that `callback`.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步上下文**：当期望通过触发`callback`函数来响应时，执行上下文应该传递一个`Error`对象，并将适当的消息作为该`callback`的第一个参数。'
- en: '**An event context**: Quoting the Node documentation: *"When an `EventEmitter`
    instance experiences an error, the typical action is to emit an error event. Error
    events are treated as a special case in node. If there is no listener for it,
    then the default action is to print a stack trace and exit the program."* Use
    events where events are expected.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件上下文**：引用Node文档：“当`EventEmitter`实例遇到错误时，典型的操作是触发一个错误事件。错误事件在node中被视为特殊情况。如果没有监听器，那么默认操作是打印堆栈跟踪并退出程序。”在预期的情况下使用事件。'
- en: '**A Promise context**: A Promise throws or is otherwise rejected, and this
    error is caught within a `.catch` block. Important note: you should *always* reject
    Promises with true `Error` objects. *Petka Antonov*, author of the popular B*luebird*
    Promises implementation, discusses why: [https://github.com/petkaantonov/bluebird/blob/master/docs/docs/warning-explanations.md](https://github.com/petkaantonov/bluebird/blob/master/docs/docs/warning-explanations.md)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Promise上下文**：Promise抛出或以其他方式被拒绝，并且此错误在`.catch`块中被捕获。重要提示：您应该始终使用真正的`Error`对象拒绝Promises。
    *Petka Antonov*，流行的B*luebird* Promises实现的作者，讨论了为什么：[https://github.com/petkaantonov/bluebird/blob/master/docs/docs/warning-explanations.md](https://github.com/petkaantonov/bluebird/blob/master/docs/docs/warning-explanations.md)'
- en: Clearly, these are situations where an error is caught in a controlled manner,
    prior to it destabilizing the entire application. Without falling too far into
    defensive coding, an effort should be made to check inputs and other sources for
    errors, and properly dismiss them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些情况是在控制的方式下捕获错误，而不是在整个应用程序不稳定之前。在不过分陷入防御性编码的情况下，应该努力检查输入和其他来源的错误，并妥善处理它们。
- en: 'An additional benefit of always returning a proper `Error` object is access
    to the stack property of that object. The error stack shows the provenance of
    an error, each link in the chain of function, and calls the function that led
    to the error. A typical `Error.stack` trace would look like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 始终返回正确的`Error`对象的另一个好处是可以访问该对象的堆栈属性。错误堆栈显示错误的来源，函数链中的每个链接以及导致错误的函数。典型的`Error.stack`跟踪看起来像这样：
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Similarly, the stack is always available via the `console.trace` method:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，堆栈始终可以通过`console.trace`方法获得：
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It should be clear how this information aids in debugging, helping to ensure
    that the logical flow of our application is sound.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 应该清楚这些信息如何帮助调试，有助于确保我们应用程序的逻辑流是正确的。
- en: A normal stack trace truncates after a dozen or so levels. If longer stack traces
    are useful to you, try *Matt Insler's* **longjohn**: [https://github.com/mattinsler/longjohn](https://github.com/mattinsler/longjohn)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的堆栈跟踪在十几个级别后会截断。如果更长的堆栈跟踪对您有用，请尝试*Matt Insler*的**longjohn**：[https://github.com/mattinsler/longjohn](https://github.com/mattinsler/longjohn)
- en: As well, run and examine the `js/stacktrace.js` file in your bundle for some
    ideas on how stack information might be used when reporting errors, or even test
    results.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，运行并检查您的捆绑包中的`js/stacktrace.js`文件，以获取有关在报告错误或测试结果时如何使用堆栈信息的一些想法。
- en: Exception handling is different. Exceptions are unexpected or fatal errors that
    have destabilized the application. These should be handled with care; a system
    in an exception state is unstable, with indeterminate future states, and should
    be gracefully shut down and restarted. This is the smart thing to do.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是不同的。异常是意外或致命错误，已经使应用程序不稳定。这些应该小心处理；处于异常状态的系统是不稳定的，未来状态不确定，并且应该优雅地关闭和重新启动。这是明智的做法。
- en: 'Typically, exceptions are caught in `try`/`catch` blocks:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，异常在`try`/`catch`块中捕获：
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Peppering a codebase with `try`/`catch` blocks and trying to anticipate all
    errors can become unmanageable and unwieldy. Additionally, what if an exception
    you didn't anticipate, an uncaught exception, occurs? How do you pick up from
    where you left off?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码库中使用`try`/`catch`块并尝试预期所有错误可能变得难以管理和笨拙。此外，如果发生您没有预料到的异常，未捕获的异常会怎么样？您如何从上次中断的地方继续？
- en: 'Node does not have a standard built-in way to handle uncaught critical exceptions.
    This is a weakness of the platform. An exception that is uncaught will continue
    to bubble up through the execution stack until it hits the event loop where, like
    a wrench in the gears of a machine, it will take down the entire process. The
    best we have is to attach an `uncaughtException` handler to the process itself:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Node没有标准内置的方法来处理未捕获的关键异常。这是平台的一个弱点。未捕获的异常将继续通过执行堆栈冒泡，直到它到达事件循环，在那里，就像在机器齿轮中的扳手一样，它将使整个进程崩溃。我们最好的办法是将`uncaughtException`处理程序附加到进程本身：
- en: '[PRE45]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: While nothing that follows our exception code will execute, the timeout will
    still fire, as the process managed to catch the exception, saving itself. However,
    this is a very clumsy way of handling exceptions. The `domain` module aimed to
    fix this hole in Node's design, but it has since been deprecated. Properly handling
    and reporting errors remains a real weakness in the Node platform. Work continues
    by the core team to address this problem: [https://nodejs.org/en/docs/guides/domain-postmortem/](https://nodejs.org/en/docs/guides/domain-postmortem/)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们异常代码后面的内容都不会执行，但超时仍然会触发，因为进程设法捕获了异常，自救了。然而，这是处理异常的一种非常笨拙的方式。`domain`模块旨在修复Node设计中的这个漏洞，但它已经被弃用。正确处理和报告错误仍然是Node平台的一个真正弱点。核心团队正在努力解决这个问题：[https://nodejs.org/en/docs/guides/domain-postmortem/](https://nodejs.org/en/docs/guides/domain-postmortem/)
- en: 'Recently, a similar mechanism was introduced to catch runaway Promises, which
    occur when you do not attach a catch handler to your Promise chain:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，引入了类似的机制来捕获无法控制的Promise，当您未将catch处理程序附加到Promise链时会发生这种情况：
- en: '[PRE46]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `unhandledRejection` handler is fired whenever a Promise is rejected and
    no error handler is attached to the Promise within one turn of the event loop.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`unhandledRejection`处理程序在Promise被拒绝并且在事件循环的一个回合内未附加错误处理程序时触发。'
- en: Considerations
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑事项
- en: 'Any developer is regularly making decisions with a far-reaching impact. It
    is very hard to predict all the possible consequences resulting from a new bit
    of code, or a new design theory. For this reason, it may be useful to keep the
    shape of your code simple, and to force yourself to consistently follow the common
    practices of other Node developers. These are some guidelines you may find useful,
    as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 任何开发人员都在经常做出具有深远影响的决定。很难预测从新代码或新设计理论中产生的所有可能后果。因此，保持代码的简单形式并迫使自己始终遵循其他Node开发人员的常见做法可能是有用的。以下是一些您可能会发现有用的准则：
- en: Generally, try to aim for shallow code. This type of refactoring is uncommon
    in non-evented environments. Remind yourself of it by regularly re-evaluating
    entry and exit points, and shared functions.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，尽量追求浅层代码。这种重构在非事件驱动的环境中并不常见。通过定期重新评估入口和出口点以及共享函数来提醒自己。
- en: Consider building your systems using distinct, composable microservices, which
    we'll discuss in [Chapter 9](c8e13bc3-e661-441c-9fbc-bfdf6019f5f8.xhtml), *Microservices*.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑使用不同的、可组合的微服务来构建你的系统，我们将在[第9章](c8e13bc3-e661-441c-9fbc-bfdf6019f5f8.xhtml)中讨论，*微服务*。
- en: Where possible, provide a common context for `callback` re-entry. Closures are
    very powerful tools in JavaScript, and by extension, Node, as long as the context
    frame length of the enclosed callbacks is not excessive.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，为`callback`重新进入提供一个公共上下文。闭包在JavaScript中是非常强大的工具，通过扩展，在Node中也是如此，只要封闭的回调的上下文帧长度不过大。
- en: Name your functions. In addition to being useful in deeply recursive constructs,
    debugging code is much easier when a stack trace contains distinct function names,
    as opposed to anonymous.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给你的函数命名。除了在深度递归结构中非常有用之外，当堆栈跟踪包含不同的函数名称时，调试代码会更容易，而不是匿名函数。
- en: Think hard about priorities. Does the order, in which a given result arrives
    or a `callback` is executed, actually matter? More importantly, does it matter
    in relation to I/O operations? If so, consider `nextTick` and `setImmediate`.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认真考虑优先级。给定结果到达或`callback`执行的顺序实际上是否重要？更重要的是，它是否与I/O操作有关？如果是，考虑使用`nextTick`和`setImmediate`。
- en: Consider using finite state machines for managing your events. State machines
    are surprisingly under-represented in JavaScript codebases. When a `callback`
    re-enters program flow, it has likely changed the state of your application, and
    the issuing of the asynchronous call itself is a likely indicator that state is
    about to change.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑使用有限状态机来管理你的事件。状态机在JavaScript代码库中非常少见。当`callback`重新进入程序流时，它很可能改变了应用程序的状态，而异步调用本身的发出很可能表明状态即将改变。
- en: Building a Twitter feed using file events
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件事件构建Twitter动态
- en: Let's apply what we've learned. The goal is to create a server that a client
    can connect to and receive updates from Twitter. We will first create a process
    to query Twitter for any messages with the hashtag `#nodejs`, and write any found
    messages to a `tweets.txt` file in 140-byte chunks. We will then create a network
    server that broadcasts these messages to a single client. Those broadcasts will
    be triggered by write events on the `tweets.txt` file. Whenever a write occurs,
    140-byte chunks are asynchronously read from the last-known client read pointer.
    This will happen until we reach the end of the file, broadcasting as we go. Finally,
    we will create a simple `client.html` page, which asks for, receives, and displays
    these messages.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用所学知识。目标是创建一个服务器，客户端可以连接并从Twitter接收更新。我们首先创建一个进程来查询Twitter是否有带有`#nodejs`标签的消息，并将找到的消息以140字节的块写入到`tweets.txt`文件中。然后，我们将创建一个网络服务器，将这些消息广播给单个客户端。这些广播将由`tweets.txt`文件上的写事件触发。每当发生写操作时，都会从上次已知的客户端读取指针异步读取140字节的块。这将一直持续到文件末尾，同时进行广播。最后，我们将创建一个简单的`client.html`页面，用于请求、接收和显示这些消息。
- en: 'While this example is certainly contrived, it demonstrates:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子显然是刻意安排的，但它展示了：
- en: Listening to the filesystem for changes, and responding to those events
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听文件系统的更改，并响应这些事件
- en: Using data stream events for reading and writing files
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据流事件来读写文件
- en: Responding to network events
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应网络事件
- en: Using timeouts for polling state
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用超时进行轮询状态
- en: Using a Node server itself as a network event broadcaster
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node服务器本身作为网络事件广播器
- en: To handle server broadcasting, we are going to use the **Server Sent Events**
    (**SSE**) protocol, a new protocol being standardized as part of HTML5.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理服务器广播，我们将使用**服务器发送事件**（**SSE**）协议，这是HTML5的一部分，正在标准化的新协议。
- en: 'We''re first going to create a Node server that listens for changes on a file
    and broadcasts any new content to the client. Open your editor and create a file
    `server.js`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个Node服务器，监听文件的更改，并将任何新内容广播给客户端。打开编辑器，创建一个名为`server.js`的文件：
- en: '[PRE47]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will be accepting a single user connection, whose pointer will be `theUser`.
    The `userPos` will store the last position this client read from in `tweetFile`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接受一个单个用户连接，其指针将是`theUser`。`userPos`将存储此客户端在`tweetFile`中上次读取的位置：
- en: '[PRE48]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create an HTTP server listening on port `8080`, which will listen for and handle
    a single connection, storing the `response` argument, representing the pipe connecting
    the server to the client. The `response` argument implements the writable stream
    interface, allowing us to write messages to the client:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个监听端口`8080`的HTTP服务器，它将监听并处理单个连接，存储`response`参数，表示连接服务器和客户端的管道。`response`参数实现了可写流接口，允许我们向客户端写入消息：
- en: '[PRE49]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We create a function to send the client messages. We will be pulling buffers
    of 140 bytes out of the readable stream bound to our `tweets.txt` file, incrementing
    our file position counter by one on each read. We write this buffer to the writable
    stream binding our server to the client. When done, we queue up a repeat call
    of the same function using `nextTick,` repeating until we get an error, receive
    no data, or the client disconnects:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个函数来向客户端发送消息。我们将从绑定到我们的`tweets.txt`文件的可读流中拉取140字节的缓冲区，每次读取时将我们的文件位置计数器加一。我们将这个缓冲区写入到将我们的服务器与客户端绑定的可写流中。完成后，我们使用`nextTick`排队重复调用相同的函数，重复直到出现错误、不再接收数据或客户端断开连接：
- en: '[PRE50]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, we start the process by opening the `tweets.txt` file and watching
    for any changes, calling `sendNext` whenever new tweets are written. When we start
    the server, there may not yet exist a file to read from, so we poll using `setTimeout`
    until one exists.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过打开`tweets.txt`文件并监视任何更改来启动这个过程，每当写入新的推文时调用`sendNext`。当我们启动服务器时，可能还没有存在要读取的文件，因此我们使用`setTimeout`进行轮询，直到存在一个文件。
- en: Now that we have a server looking for file changes to broadcast, we need to
    generate data. We first install the **TWiT** Twitter package for Node, via **npm.**
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个服务器在寻找文件更改以进行广播，我们需要生成数据。我们首先通过**npm**为Node安装**TWiT** Twitter包。
- en: 'We then create a process whose sole job is to write new data to a file:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个进程，其唯一工作是向文件写入新数据：
- en: '[PRE51]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To use this example, you will need a Twitter Developer account. Alternatively,
    there is also the option of changing the relevant code to simply write random
    140-byte strings to `tweets.txt: require("crypto").randomBytes(70).toString('hex'):`
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '要使用这个示例，您需要一个Twitter开发者帐户。或者，还有一个选项，可以更改相关代码，简单地将随机的140字节字符串写入`tweets.txt:
    require("crypto").randomBytes(70).toString(''hex'')：`'
- en: '[PRE52]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This establishes a stream pointer to the same file that our server will be watching.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这将建立一个流指针，指向我们的服务器将要监视的同一个文件。
- en: 'We will be writing to this file:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将写入这个文件：
- en: '[PRE53]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Because Twitter messages are never longer than 140 bytes, we can simplify the
    read/write operation by always writing 140-byte chunks, even if some of that space
    is empty. Once we receive updates, we will create a buffer that is *number of
    messages* x 140 bytes wide, and write those 140-byte chunks to this buffer:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Twitter消息永远不会超过140字节，所以我们可以通过始终写入140字节的块来简化读/写操作，即使其中一些空间是空的。一旦我们收到更新，我们将创建一个*消息数量*
    x 140字节宽的缓冲区，并将这些140字节的块写入该缓冲区：
- en: '[PRE54]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We now create a function that will be asked every 10 seconds to check for messages
    containing the hashtag `#nodejs`. Twitter returns an array of message objects.
    The one object property we are interested in is the `#text` of the message. Calculate
    the number of bytes necessary to represent these new messages (140 x message count),
    fetch a clean buffer, and fill it with 140-byte chunks until all messages are
    written. Finally, this data is written to our `tweets.txt` file, causing a change
    event to occur that our server is notified of.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个函数，每10秒被要求检查是否包含`#nodejs`标签的消息。Twitter返回一个消息对象数组。我们感兴趣的是消息的`#text`属性。计算表示这些新消息所需的字节数（140
    x 消息数量），获取一个干净的缓冲区，并用140字节的块填充它，直到所有消息都被写入。最后，这些数据被写入我们的`tweets.txt`文件，导致发生变化事件，我们的服务器得到通知。
- en: 'The final piece is the client page itself. This is a rather simple page, and
    how it operates should be familiar to the reader. The only thing to note is the
    use of SSE that listens to port `8080` on localhost. It should be clear how, on
    receipt of a new tweet from the server, a list element is added to the unordered
    list container `#list`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是客户端页面本身。这是一个相当简单的页面，它的操作方式应该对读者来说很熟悉。需要注意的是使用SSE监听本地主机上端口`8080`。当从服务器接收到新的推文时，应该清楚地看到一个列表元素被添加到无序列表容器`#list`中：
- en: '[PRE55]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To read more about SSE, refer to [Chapter 6](7c71fdd2-8060-4363-9ab3-1c5cdc24c8cf.xhtml),
    *Creating Real-time Applications*,
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于SSE的信息，请参阅[第6章](7c71fdd2-8060-4363-9ab3-1c5cdc24c8cf.xhtml)，*创建实时应用程序*，
- en: 'or you can visit: [https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以访问：[https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)。
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Programming with events is not always easy. The control and context switches,
    defining the paradigm, often confound those new to evented systems. This seemingly
    reckless loss of control and the resulting complexity drives many developers away
    from these ideas. Students in introductory programming courses normally develop
    a mindset in which program flow can be dictated, where a program whose execution
    flow does not proceed sequentially from A to B can bend understanding.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件进行编程并不总是容易的。控制和上下文切换，定义范式，通常会使新手对事件系统感到困惑。这种看似鲁莽的失控和由此产生的复杂性驱使许多开发人员远离这些想法。入门编程课程的学生通常会形成这样一种心态，即程序流程可以被指示，一个执行流程不是从A到B顺序进行的程序会使人难以理解。
- en: By examining the evolution of the architectural problems, Node is now attempting
    to solve for network applications—in terms of scaling and code organization, in
    general terms of data and complexity volume, in terms of state awareness, and
    in terms of well-defined data and process boundaries. We learned how managing
    these event queues can be done intelligently. We saw how different event sources
    are predictably stacked for an event loop to process, and how far-future events
    can enter and reenter contexts using closures and smart callback ordering. We
    also learned about the newer Promise, Generator, and async/await structures designed
    to help with managing concurrency.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究架构问题的演变，Node现在正试图解决网络应用程序的问题——在扩展和代码组织方面，一般数据和复杂性量级方面，状态意识方面，以及明确定义的数据和过程边界方面。我们学会了如何智能地管理这些事件队列。我们看到了不同的事件源如何可预测地堆叠以供事件循环处理，以及远期事件如何使用闭包和智能回调排序进入和重新进入上下文。我们还了解了新的Promise、Generator和async/await结构，旨在帮助管理并发。
- en: We now have a basic domain understanding of the design and characteristics of
    Node, in particular, how evented programming is done using it. Let's now move
    on to larger, more advanced applications of this knowledge.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Node的设计和特性有了基本的领域理解，特别是使用它进行事件编程的方式。现在让我们转向更大、更高级的应用程序知识。
