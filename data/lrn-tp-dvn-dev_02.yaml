- en: Programming with Types and Values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型和值进行编程
- en: In the previous chapter, we looked at type-driven development using ReasonML,
    but what are types exactly? And how do they interact with other parts of your
    program? How do they help you on a regular basis, and what does it look like to
    use a strong static type system with type inference?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了使用ReasonML进行类型驱动开发，但类型究竟是什么？它们如何与程序的其余部分交互？它们如何帮助您在日常工作中，使用强静态类型系统和类型推断是什么样的体验？
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up an editor workflow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置编辑器工作流程
- en: Types and values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型与值
- en: Immutable values and memory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变值和内存
- en: Static versus dynamic typing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型与动态类型
- en: Type erasure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型擦除
- en: Syntax errors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法错误
- en: Type errors and inference
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型错误与推断
- en: Unification
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并
- en: Workflow
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作流程
- en: 'To get the most from this chapter, we will set up a comfortable edit-compile
    workflow. We recommend placing two windows side-by-side in your editor. VSCode
    supports this functionality with the View | Split Editor command. On one side,
    load a Reason source file; on the other side, load the JavaScript output file
    (once it is initially compiled). Then in a terminal, run the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章，我们将设置一个舒适的编辑-编译工作流程。我们建议在您的编辑器中将两个窗口并排放置。VSCode通过“视图”|“分割编辑器”命令支持此功能。在一侧，加载一个Reason源文件；在另一侧，加载JavaScript输出文件（一旦最初编译）。然后在终端中，运行以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command starts a build in *watch mode,* which automatically recompiles
    any parts of a project that are affected whenever you change any source code.
    In fact, watch mode is smart enough to also remove an outdated JavaScript output
    file whenever its corresponding Reason source file is deleted. The editor will
    also auto-reload the compiled JavaScript file whenever you save a Reason source
    file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令以 *监视模式* 开始构建，这会自动重新编译项目中的任何受影响的源代码部分，每当您更改任何源代码时。实际上，监视模式足够智能，当相应的Reason源文件被删除时，也会自动删除过时的JavaScript输出文件。当您保存Reason源文件时，编辑器也会自动重新加载编译后的JavaScript文件。
- en: In VSCode, you can also open a terminal session directly below the files using
    the View | Integrated Terminal command and run `bsb -w` to get a single integrated
    view of your entire workflow. This way, when there are compile errors, you won't
    have to switch windows to see them. Of course, you may prefer to work with two
    monitors and keep the terminal and compiler running on another screen so you don't
    have to switch windows—that's feasible, too.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在VSCode中，您还可以使用“视图”|“集成终端”命令直接在文件下方打开一个终端会话，并运行 `bsb -w` 以获得整个工作流程的单个集成视图。这样，当有编译错误时，您不必切换窗口就能看到它们。当然，您可能更喜欢使用两个显示器，并将终端和编译器保持在另一个屏幕上，这样您就不必切换窗口——这也是可行的。
- en: Types and values
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型与值
- en: 'Let''s set the stage for the rest of the book with a discussion of types and
    values. At its core, a type is a set of values. Think of the type `bool`, which
    is what Reason calls the normal Boolean type. A `bool` value can be one of two
    different things: `true` or `false`. We say that these values *inhabit* (live
    in) the type. Anything else is an error.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过讨论类型和值来为本书的其余部分设定场景。在核心上，类型是一组值。想想看，类型 `bool`，这是Reason所称为的正常布尔类型。一个 `bool`
    值可以是两种不同的事物之一：`true` 或 `false`。我们说这些值 *占据*（存在于）这个类型中。其他任何东西都是错误。
- en: 'This raises an interesting question: *what does it mean to say? Anything else
    is an error'' in this context? In fact, why should we care about types at all?*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个有趣的问题：*在这个上下文中，“说任何其他东西都是错误”是什么意思？实际上，我们为什么要关心类型呢？*
- en: To answer these questions, let's think about what should happen if we try to
    do the operation `"Bob" / 5`. What does it mean to divide the string `Bob` by
    the number `5`?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，让我们思考一下如果我们尝试执行操作 `"Bob" / 5` 会发生什么。将字符串 `Bob` 除以数字 `5` 的意义是什么？
- en: If you can't think of a good answer, well neither can anyone else. It's kind
    of a meaningless question. It's like asking, *how does the color green taste?* (Although
    this may be a meaningful question for synesthetic people.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法想出一个好的答案，那么其他人也无法想出。这其实是一个没有意义的问题。就像问，“绿色的味道是怎样的？”（尽管这可能对通感者来说是一个有意义的问题。）
- en: Anyway, this is the simplest answer to why we care about types – to avoid having
    to deal with meaningless questions. To rule out meaningless operations, we simply
    make them type errors in the programs that execute the code. In other words, we
    get our compilers and interpreters to slot all our values into distinct types,
    or errors if any operations can't be meaningfully performed for the given types
    of values.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这是我们关心类型的最简单答案——为了避免不得不处理无意义的问题。为了排除无意义操作，我们只需在执行代码的程序中将它们标记为类型错误。换句话说，我们让我们的编译器和解释器将所有值放入不同的类型中，或者如果有任何操作对于给定的值类型无法有意义地执行，则标记为错误。
- en: Static types
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态类型
- en: 'There are two possible times when type errors can happen: at compile time and
    at runtime. This is the crucial difference between static and dynamic type systems:
    static type systems are so called because they *statically analyze* programs and
    try to find type errors, while dynamic type systems are so called because they
    throw type errors dynamically, while they run the program.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误可能在两个可能的时间发生：编译时和运行时。这是静态类型系统和动态类型系统之间关键的区别：静态类型系统之所以被称为静态，是因为它们会*静态分析*程序并尝试找到类型错误，而动态类型系统之所以被称为动态，是因为它们在程序运行时抛出类型错误。
- en: A dynamic type system will definitely find all the type errors in your program,
    provided it actually runs all the execution paths in it. Any paths that remain
    unexecuted may contain hidden type errors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型系统将肯定会在你的程序中找到所有的类型错误，前提是它实际上运行了程序中的所有执行路径。任何未执行的路径可能包含隐藏的类型错误。
- en: A static type system will try to find as many errors as possible without running
    your program. Normally, this is not a guarantee that you will catch all type errors
    before runtime. Some errors may slip through the **typechecker** and still hit
    you at runtime. Plus, a type system may make it difficult to express a program
    that you know is correct because it thinks it's not. You will want to pay close
    attention when this happens, though, as either the typechecker is correct, or
    your design will benefit from expressing the program in a different, accepted,
    way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型系统会尝试在运行程序之前找到尽可能多的错误。通常，这并不能保证你在运行时之前会捕获所有类型错误。一些错误可能通过**类型检查器**漏网，并在运行时仍然影响你。此外，类型系统可能会使表达一个你知道是正确的程序变得困难，因为它认为它不是。尽管如此，当这种情况发生时，你仍然需要密切关注，因为要么类型检查器是正确的，要么你的设计将受益于以不同、被接受的方式表达程序。
- en: What do you gain?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能得到什么？
- en: With regard to the caveats mentioned earlier, what do static type systems actually
    give you?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面提到的注意事项，静态类型系统实际上能给你带来什么？
- en: A good type system catches almost all type errors for you before runtime
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的类型系统会在运行时之前为你捕获几乎所有的类型错误
- en: It accepts all or almost all programs that do not contain type errors
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受所有或几乎所有不包含类型错误的程序
- en: Being able to catch type errors before runtime is a very nice ability to have.
    It will help you to avoid possible downtime, expenses, lost business, and so on.
    Note that we mentioned a *good* type system. We should try to aim for the best
    type system we can get at our disposal. Since, Reason is OCaml, it automatically
    gets OCaml's powerful, safe, and expressive type system.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时之前能够捕获类型错误是一个非常棒的能力。这将帮助你避免可能的中断、费用、失去的业务等等。请注意，我们提到了*好的*类型系统。我们应该努力争取我们能够得到的最好的类型系统。由于Reason是OCaml，它自动获得了OCaml强大、安全和表达性强的类型系统。
- en: Static and dynamic environments
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态和动态环境
- en: 'Let''s develop a mental model for what happens in a program with types and
    values. At its core, a program is made up of a series of type and value definitions.
    For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为具有类型和值的程序发生的事情建立一个心理模型。在其核心，一个程序由一系列类型和值定义组成。例如：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we're defining `person` and `company` `types`, and then allocating a person
    (`bob`) and a company he works for (`acmeCo`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`person`和`company``类型`，然后分配一个个人（`bob`）和他工作的公司（`acmeCo`）。
- en: Without worrying too much about the syntax (we will introduce this in [Chapter
    4](ba37505a-f222-4238-a13c-259160ca582d.xhtml), *Group Values Together in Types*),
    let's think about how the programming environment sees this program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不必过于担心语法（我们将在[第4章](ba37505a-f222-4238-a13c-259160ca582d.xhtml)，*在类型中将值分组在一起*）中，让我们思考编程环境如何看待这个程序。
- en: In a statically typed programming language, the typechecker and runtime environment
    together make up the *static* and *dynamic environments.* These are areas where
    type definitions are stored while typechecking takes place, and where value definitions
    are stored during program execution (runtime). We can think of these as two distinct
    areas that are only relevant during the distinct phases of compilation and runtime.
    After compilation, all type information is wiped out (*type erasure*), but during
    runtime the dynamic environment becomes active in memory (that is, the stack and
    the heap).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态类型编程语言中，类型检查器和运行时环境共同构成了**静态**和**动态环境**。这些是在类型检查期间存储类型定义的区域，以及在程序执行（运行时）期间存储值定义的区域。我们可以将这些视为仅在编译和运行时不同阶段相关的两个不同区域。在编译之后，所有类型信息都被擦除（*类型擦除*），但在运行时，动态环境在内存中变得活跃（即，栈和堆）。
- en: 'Here is how the static and dynamic environments look for the preceding code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何为前面的代码展示静态和动态环境的：
- en: '| **Static Environment** | **Dynamic Environment** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **静态环境** | **动态环境** |'
- en: '| `type person;` |  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `type person;` |  |'
- en: '| `type company;` (refers to  **`person`**) |  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `type company;` (指代 **`person`**) |  |'
- en: '|  | `let bob;` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  | `let bob;` |'
- en: '|  | `let acmeCo;` (refers to `bob`) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  | `let acmeCo;` (指代 `bob`) |'
- en: Example of static and dynamic environments (evaluated top to bottom)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和动态环境示例（自上而下评估）
- en: In each of the static and dynamic environments, each definition is allowed to
    refer to definitions that came before it. This is a crucial abstraction technique
    – it's how we build larger programs out of smaller ones at both the type and value
    levels.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态和动态环境的每个环境中，每个定义都可以引用它之前的定义。这是一种至关重要的抽象技术——这是我们如何在类型和值级别从较小的程序构建较大程序的方法。
- en: 'There are no references between the static and dynamic environments – values
    don''t exist at compile time and types don''t exist at runtime. This may come
    a surprise as we do mix them in one place: the source code.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 静态环境和动态环境之间没有引用——值在编译时不存在，类型在运行时不存在。这可能会让人感到惊讶，因为我们确实在一个地方混合了它们：源代码。
- en: Among other things, this strict separation balances the needs of safety and
    efficiency. Note that this is in sharp contrast to dynamic typing, where types
    exist at runtime as well, and must be checked before every operation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，这种严格的分离平衡了安全和效率的需求。请注意，这与动态类型形成鲜明对比，在动态类型中，类型在运行时也存在，并且必须在每次操作之前进行检查。
- en: Values
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 价值观
- en: It's important to understand how values work in Reason. We've seen that they
    come into play at runtime and live in memory but it's also important to know that,
    by default, all values are immutable –effectively, constants. There are a couple
    of exceptions, which we will cover, but generally we will work in a style where
    we don't try to change values, and instead just create new values out of old ones.
    This is a style that is well-supported by Reason and is a foundation of functional
    programming.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Reason中的值的工作方式很重要。我们已经看到它们在运行时发挥作用并存在于内存中，但了解默认情况下所有值都是不可变的——实际上，是常量也很重要。有一些例外，我们将在后面介绍，但通常我们将以一种不尝试更改值，而是从旧值中创建新值的方式工作。这种风格在Reason中得到很好的支持，并且是函数式编程的基础。
- en: 'There is a syntax for binding values to names, which is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种语法，可以将值绑定到名称，如下所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding syntax slots the value on the right-hand side into the shape described
    in the left-hand side, as long as their shapes match. The general name for this
    concept is *pattern matching*, and we will see it a lot in this book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法将右侧的值放入左侧描述的形状中，只要它们的形状匹配。这个概念的一般名称是*模式匹配*，我们将在本书中看到很多。
- en: 'So far, the patterns (to the left of `=`) we''ve seen have been just simple
    names, such as:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的（`=`左侧的）模式只是简单的名称，例如：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding pattern has allowed us to capture the entire value in the name
    and reuse it later. The way it works is that Reason checks that the value (`1`)
    can fit inside the pattern (`x`). In this simple case, there is nothing about
    the pattern that prevents the value from fitting inside. We call this an *irrefutable
    pattern.* In further chapters, we will see examples of *refutable* patterns and
    how they behave.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模式使我们能够将整个值捕获在名称中并在以后重用它。它是这样工作的：Reason检查值（`1`）是否可以适合模式（`x`）。在这种情况下，模式中没有阻止值适合的内容。我们称这为*不可反驳的模式*。在后续章节中，我们将看到*可反驳的模式*的示例以及它们的运行方式。
- en: 'Wherever you see the keyword `let`, you should understand that it may be allocating
    memory, if:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你看到关键字 `let`，你应该理解它可能正在分配内存，如果：
- en: The bound value is a literal (for example, `"Bob"`), or
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定值是一个字面量（例如，`"Bob"`），或者
- en: The bound value is the result of a function or operator call, and the function
    or operator call allocates a new value in memory
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定值是函数或运算符调用的结果，并且函数或运算符调用在内存中分配了一个新值
- en: The other cases are mainly of bindings to existing values or bindings to function
    calls that don't allocate.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 其他情况主要是绑定到现有值或绑定到不分配内存的函数调用。
- en: In this book, we won't be worrying too much about allocation and memory use,
    but we will look at a couple of techniques of how to reduce them when necessary,
    which can come in handy when trying to boost performance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会过多地担心分配和内存使用，但我们会探讨一些在必要时如何减少它们的技术，这些技术可以在尝试提高性能时派上用场。
- en: Scoping and shadowing
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域和遮蔽
- en: 'Whenever we define values, they exist (in the dynamic environment) in a scope,
    in which all previously defined names are available but only until the end of
    the scope. Scopes are nested inside each other, starting with the *top level*
    scope (the definitions at the file level), and nested scopes inside braces (`{...}`).
    For example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们定义值，它们（在动态环境中）都存在于一个作用域中，其中所有之前定义的名称都是可用的，但只到作用域的结束。作用域嵌套在彼此内部，从顶层作用域（文件级别的定义）开始，并在大括号
    `{...}` 内嵌套作用域。例如：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `x` and `y` are in the top level scope, where `y` can access `x` by name
    because `x` is defined before `y`; `z` can access both for the same reason. However,
    note the definition of `result` in the nested scope introduced by the braces.
    The name `result` is only available from the point it is defined up until the
    closing brace; outside of that scope, referring to `result` will result in a compile
    error (specifically, a *name error,* which we will talk about later in the chapter).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x` 和 `y` 在顶层作用域中，其中 `y` 可以通过名称访问 `x`，因为 `x` 在 `y` 之前定义；`z` 可以出于同样的原因访问两者。然而，请注意在大括号引入的嵌套作用域中
    `result` 的定义。名称 `result` 只从定义的点开始可用，直到闭合括号；在此作用域之外，引用 `result` 将导致编译错误（具体来说，是一个
    *名称错误*，我们将在本章后面讨论）。
- en: 'Because Reason puts all definitions in certain scopes, we can define the same
    name more than once in the same scope or in a nested scope. This is called **shadowing**
    because the new definition hides the old one until the new one goes out of scope.
    Of course, if the old and new names go out of scope together (that is, they''re
    in the same scope), the old name is effectively hidden forever. The following
    codeblock is an example of this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Reason 将所有定义放在特定的作用域中，我们可以在同一个作用域或嵌套作用域中多次定义同一个名称。这被称为**遮蔽**，因为新的定义隐藏了旧的定义，直到新的定义超出作用域。当然，如果旧的和新的名称同时超出作用域（即，它们在同一个作用域中），旧名称将永久性地被隐藏。下面的代码块是这种情况的一个例子：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s now take a look at the output JavaScript as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看以下输出 JavaScript：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice how Bob's age is `34` in his `greeting `– the `age` in the `greeting`
    scope shadows `age` in the top level scope. However, as soon as that scope ends
    (with the closing brace), the original `age` becomes visible again and is used
    in Jim's `greeting2`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Bob 的年龄在 `greeting ` 中是 `34` – 在 `greeting` 作用域中，`age` 遮蔽了顶层作用域中的 `age`。然而，一旦该作用域结束（通过闭合括号），原始的
    `age` 再次变得可见，并在 Jim 的 `greeting2` 中使用。
- en: However, the second `name` binding (`"Jim"`) permanently shadows the first one
    because they are both in the top level scope. In fact, since the first `name`
    and the inner `age` will never be visible again, the BuckleScript compiler doesn't
    even bother to output them, instead directly inlining their values.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个 `name` 绑定（`"Jim"`）永久性地遮蔽了第一个，因为它们都在顶层作用域中。实际上，由于第一个 `name` 和内部的 `age`
    将永远不会再次可见，BuckleScript 编译器甚至懒得输出它们，而是直接内联它们的值。
- en: Understanding type erasure
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型擦除
- en: 'To concretely grasp the effect of static/dynamic separation, let''s look at
    type erasure, which is something that happens when we compile the preceding code
    to JavaScript. The following is the output with all redundant comments removed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了具体理解静态/动态分离的效果，让我们看看类型擦除，这是当我们将前面的代码编译成 JavaScript 时发生的事情。以下是在移除所有冗余注释后的输出：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we mentioned earlier, BuckleScript compiles Reason record types into JavaScript
    arrays with the corresponding number of elements. BuckleScript, in fact, performs
    quite a number of optimizations for you. Some of these come from its underlying
    OCaml compiler technology, which has been developed since the 1990s, but other
    things are quite unique in the world of language-to-JavaScript compilers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，BuckleScript 将 Reason 记录类型编译成具有相应元素数量的 JavaScript 数组。实际上，BuckleScript
    为你执行了许多优化。其中一些来自其底层 OCaml 编译器技术，该技术自 1990 年代以来一直在发展，但其他一些在语言到 JavaScript 编译器的世界中相当独特。
- en: Notice that BuckleScript has wiped out both the type definitions and has output
    only the minimum number of values it actually needs for runtime. The important
    thing to understand here is that all the output values follow the laws introduced
    by their corresponding types; for example, the `Bob` value, of type `person`,
    can only be an array with two elements (a number and a string, corresponding to
    the two fields in the person record), and the `acmeCo` value can only be an array
    with three elements of the correct types. Anything else is impossible – with a
    mathematical degree of certainty – even in output JavaScript code, because code
    that doesn't pass the typing rules (that is, doesn't typecheck) would not even
    compile.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 BuckleScript 已经删除了类型定义，并且只输出了实际运行时所需的最小数量的值。这里要理解的重要一点是，所有输出值都遵循其对应类型引入的规则；例如，类型为
    `person` 的 `Bob` 值只能是一个包含两个元素（一个数字和一个字符串，对应于人员记录中的两个字段）的数组，而 `acmeCo` 值只能是一个包含正确类型的三元素数组。其他任何东西都是不可能的——以数学上的确定性——即使在输出
    JavaScript 代码中，因为不通过类型规则的代码（即不通过类型检查）甚至无法编译。
- en: Errors
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误
- en: We mentioned earlier that the compiler will raise errors if it cannot make sense
    of a piece of code it comes across. There are a few different kinds of compiler
    errors, and they are as follows
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，如果编译器无法理解它遇到的代码片段，它将引发错误。存在几种不同的编译器错误，如下所述
- en: Syntax errors
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法错误
- en: Type errors
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型错误
- en: Name errors
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称错误
- en: Stale interface errors (which we'll cover in the next chapter)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过时的接口错误（我们将在下一章中介绍）
- en: Compiler bugs (these are rare but shouldn't be discounted)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器错误（这些很少见，但不应被忽视）
- en: 'The two most common types of error that we will deal with are syntax errors
    and type errors. Name errors are fairly simple to avoid: always start type names
    with a lowercase letter and ensure that the names you refer to in your code were
    defined before you refer to them. (Reason supports *cyclic references* but not
    *forward references*;we''ll cover cyclic references later on.)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的两种最常见的错误类型是语法错误和类型错误。名称错误相对简单避免：始终以小写字母开始类型名称，并确保你在代码中引用的名称在你引用它们之前已经定义。
    (Reason 支持 *循环引用* 但不支持 *向前引用*；我们将在稍后讨论循环引用。)
- en: Syntax errors
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法错误
- en: 'Syntax errors are a basic kind of error and happen when the compiler literally
    can''t make sense of the source code, for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误是一种基本错误，发生在编译器字面意义上无法理解源代码时，例如：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Can you spot the error in the preceding code? If you compare it with the `person`
    definition in `src/Ch02/Ch02_Demo.re`, you should be able to. In any case, the
    compiler will tell you (usually fairly accurately) where to look. The only problem
    is you''ll have to learn to sift through the compiler output to find the exact
    error, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否在前面代码中找到错误？如果你将其与 `src/Ch02/Ch02_Demo.re` 中的 `person` 定义进行比较，你应该能够做到。无论如何，编译器会告诉你（通常相当准确）在哪里查找。唯一的问题是，你必须学会筛选编译器输出以找到确切的错误，如下所示：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Syntax errors start with the text `File "/path/to/file", line L, characters
    C1-C2:` (where `L`, `C1`, and `C2` are the actual line and character numbers).
    The error message, `<UNKNOWN SYNTAX ERROR>`, is not too helpful, but the line
    and character positions pinpoint the location pretty well. Confusingly, there
    is also another error message starting in the same way, but this time with `line
    1 and characters 0-0: Error while running external preprocessor`. This is Reason''s
    way of redundantly saying it couldn''t understand the code, and is hopefully going
    away soon!'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '语法错误以文本 `File "/path/to/file", line L, characters C1-C2:` 开头（其中 `L`、`C1` 和
    `C2` 是实际的行和字符编号）。错误消息 `<UNKNOWN SYNTAX ERROR>` 并不是很有帮助，但行和字符位置相当准确地指出了位置。令人困惑的是，还有另一个以相同方式开始的错误消息，但这次是
    `line 1 and characters 0-0: Error while running external preprocessor`。这是 Reason
    以冗余的方式表示它无法理解代码，并且希望很快就会消失！'
- en: In our example, the error points at the 23rd and 24th characters, where you
    see a semicolon and space; if you compare that with the correct version of the
    code, you see that it should be a comma and space.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，错误指向第23和第24个字符，在那里你看到一个分号和一个空格；如果你与正确的代码版本进行比较，你会看到它应该是一个逗号和一个空格。
- en: When you're starting out with Reason, you should expect to see more of these
    syntax errors, and to spend some time working through exactly why they're happening.
    As you learn the syntax, you can expect to be able to tell just by looking at
    it that a piece of code doesn't contain the correct syntax. The correct syntax
    is available in Reason's excellent reference documentation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始使用Reason时，你应该期待看到更多的这些语法错误，并且需要花一些时间来弄清楚它们为什么会发生。随着你对语法的了解，你可以期待仅通过查看代码就能判断出某段代码是否包含正确的语法。正确的语法可以在Reason的优秀参考文档中找到。
- en: Type errors and inference
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型错误和推断
- en: The other main kind of compiler error you will see is a **type error***.* A
    type error is an error that arises when a type (or a value of a type) is used
    in a way that's not allowed by the type definition.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到另一种主要的编译器错误，那就是**类型错误**.* 类型错误是在一个类型（或类型的值）以不符合类型定义的方式被使用时产生的错误。
- en: These are more interesting errors because you're likely to come across them
    for the rest of your programming career, during which you should expect to continue
    seeing large productivity and code quality benefits from type errors forcing better
    design thinking and bug reduction.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误更有趣，因为你很可能在整个编程生涯中都会遇到它们，在这个过程中，你应该期待继续从类型错误强制更好的设计思维和错误减少中获得大量的生产力和代码质量效益。
- en: Type errors are also heavily tied into Reason's type inference engine, which
    through a process of elimination works out exactly what the types should be for
    every piece of the code. Let's look at a few simple type errors and the code that
    will trigger them. We will also explain the type inference rules that led to the
    error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误也与Reason的类型推断引擎紧密相关，该引擎通过排除法的过程确定代码中每一部分的类型。让我们看看几个简单的类型错误和将触发它们的代码。我们还将解释导致错误的类型推断规则。
- en: 'First, let''s try the division problem we posted earlier (the bold parts are
    colored red in Reason''s error message):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试我们之前发布的除法问题（在Reason的错误信息中，粗体部分被涂成红色）：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s look at the process of elimination by which Reason arrives at type errors:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Reason如何通过排除法得出类型错误的处理过程：
- en: Assigns types to the smallest possible parts of the expression, one by one
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐个将类型分配给表达式的最小部分
- en: Tries to fit all the types together like puzzle pieces
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将所有类型像拼图一样拼在一起
- en: If they fit, pass typechecker
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们匹配，则通过类型检查器
- en: If they don't fit, raise a type error
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们不匹配，则引发类型错误
- en: 'The following diagram shows the type inference and checking process (read from
    left to right):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了类型推断和检查过程（从左到右阅读）：
- en: '![](img/7c41a6ac-1481-438b-a8d9-99c671a73adf.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c41a6ac-1481-438b-a8d9-99c671a73adf.png)'
- en: The type error arises from the fact that `"Bob"` is a string (anything inside
    double-quotes is inferred to be a string), whereas the division operator `(/)`
    by definition requires two `int` variables as input. However, Reason can still
    infer `result` to be an `int` because it knows the division operator outputs an
    `int`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误源于“Bob”是一个字符串（双引号内的任何内容都被推断为字符串），而除法运算符（`(/)`）根据定义需要两个`int`类型的变量作为输入。然而，Reason仍然可以推断`result`为`int`类型，因为它知道除法运算符的输出是`int`。
- en: 'Now, let''s try a slightly more interesting type error, from not creating a
    record correctly, shown as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一个稍微有趣一点的类型错误，即未正确创建记录的情况，如下所示：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following diagram shows the typechecking process for a record:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了记录的类型检查过程：
- en: '![](img/42cc87e5-0431-42a1-ab82-e368904ca238.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42cc87e5-0431-42a1-ab82-e368904ca238.png)'
- en: Here, the type error arises because one of the components of the record does
    not have the correct type. You can compare the code in the error message with
    the source code to exact
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，类型错误产生是因为记录的一个组成部分没有正确的类型。你可以将错误信息中的代码与源代码进行比较以精确
- en: You may be curious to know why the division type error was reported the way
    it was, when it may have been more natural to work from left to right and produce
    an error like string does not support division by ints. This is because the typechecker
    works on the *abstract syntax tree* of the program – that is, an internal representation
    of the program itself after it has been parsed (and verified as free of syntax
    errors). The AST is structured, as you might have guessed, as a tree, and in the
    tree, operations and function calls are the parent nodes of their arguments. So,
    the operations are assigned types first and then their arguments. Hence you see
    `"Bob"` as the thing that caused the type mismatch, instead of `(/)`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能好奇为什么除法类型错误是以这种方式报告的，当从左到右工作并产生一个像“字符串不支持整数的除法”这样的错误可能更自然时。这是因为类型检查器在程序的*抽象语法树*上工作——也就是说，在解析（并验证为无语法错误）之后程序本身的内部表示。正如你可能猜到的，AST是结构化的，作为一个树，在树中，操作和函数调用是它们参数的父节点。因此，操作首先被分配类型，然后是它们的参数。所以，你看到`"Bob"`是导致类型不匹配的东西，而不是`(/)`。
- en: Theoretically, though, typechecking could go in either direction – from the
    root of the AST to its leaf nodes or the other way round as normal. You may often
    hear the process of fitting the types together referred to as **unification**,
    which means the same thing. If instead of `"Bob"` , the first operand had been,
    for example, `10` (of type `int`), Reason would have been able to unify their
    types (`int` and `int`) and thus pass typechecking.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，类型检查可以朝两个方向进行——从AST的根节点到其叶节点，或者反过来，就像正常情况一样。你可能经常听到将类型组合在一起的过程被称为**统一**，这指的是同一个概念。如果第一个操作数不是`"Bob"`，而是例如`10`（类型为`int`），Reason就能够统一它们的类型（`int`和`int`），从而通过类型检查。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground, including setting up an editorial
    workflow, learning about types and values, static and dynamic typing, Reason's
    separation between compile time and runtime and its type erasure, syntax, and
    type errors, as well as inference and unification.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容，包括设置编辑工作流程，了解类型和值，静态和动态类型，Reason在编译时间和运行时间之间的分离以及其类型擦除，语法，类型错误，以及推理和统一。
- en: In future chapters, we will build on this chapter and introduce many more static
    typing techniques and the potential type errors that we may see from using them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的章节中，我们将在此基础上构建，并介绍更多静态类型技术以及使用它们可能看到的潜在类型错误。
