- en: Getting Set Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: In this chapter, you'll get your local environment set up for the rest of the
    book. Whether you're on macOS, Linux, or Windows, we'll install Node and look
    at exactly how we can run Node applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将为本书的其余部分设置本地环境。无论您使用的是macOS、Linux还是Windows，我们都将安装Node，并查看我们如何运行Node应用程序。
- en: We'll talk about what Node is, why you would ever want to use it, and why you
    would want to use Node as opposed to something like Rails, C++, Java, or any other
    language that can accomplish similar tasks. By the end of this chapter, you will
    be running your very first Node application. It's going to be simple, but it is
    going to get us to the path to creating real-world production Node apps, which
    is the goal of this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论Node是什么，为什么您会想要使用它，以及为什么您会想要使用Node而不是像Rails、C++、Java或任何其他可以完成类似任务的语言。在本章结束时，您将运行您的第一个Node应用程序。这将是简单的，但它将使我们走上创建真实生产Node应用程序的道路，这是本书的目标。
- en: 'More specifically, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地，我们将涵盖以下主题：
- en: Node.js installation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js安装
- en: What Node is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node是什么
- en: Why use Node
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用Node
- en: Atom
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atom
- en: Hello World
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hello World
- en: Node.js installation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js安装
- en: Before we start talking about what Node is and why it's useful, you need to
    first install Node on your machine, because in the next couple of sections, we'll
    want to run a little bit of Node code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论Node是什么以及它为什么有用之前，您需要先在您的计算机上安装Node，因为在接下来的几节中，我们将想要运行一些Node代码。
- en: Now, to get started, we just need two programs—a browser, I'll be using Chrome
    throughout the book, but any browser will do, and Terminal. I'll use **Spotlight**
    to open up Terminal, which is what it's known as on my operating system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要开始，我们只需要两个程序-一个浏览器，我将在整本书中都使用Chrome，但任何浏览器都可以，还有终端。我将使用**Spotlight**打开终端，在我的操作系统中它就是这个名字。
- en: If you're on Windows, look for the Command Prompt, you can search using the
    Windows key and then by typing `command prompt`, and on Linux, you're looking
    for the command line, although depending on your distribution it might be called
    Terminal or Command Prompt.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Windows，寻找命令提示符，您可以使用Windows键搜索，然后输入`command prompt`，在Linux上，您要寻找命令行，尽管根据您的发行版，它可能被称为终端或命令提示符。
- en: 'Now, once you have that program open, you''ll see a screen, as shown in the
    following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦您打开了该程序，您将看到一个屏幕，如下面的截图所示：
- en: '![](img/a4d7162c-aef9-40d4-98a9-ec1ea68fbca0.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4d7162c-aef9-40d4-98a9-ec1ea68fbca0.png)'
- en: Essentially, it's waiting for you to run a command. We'll run quite a few commands
    from Terminal throughout the book. I'll discuss it in a few sections later, so
    if you've never used this before, you can start navigating comfortably.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，它在等待您运行一个命令。在整本书中，我们将从终端运行相当多的命令。我将在几节后讨论它，所以如果您以前从未使用过这个，您可以开始舒适地进行导航。
- en: Node.js version confirmation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js版本确认
- en: 'In the browser, we can head over to [nodejs.org](http://nodejs.org) to grab
    the installer for the latest version of Node(as shown here). In this book, we''ll
    use the most recent version, version 9.3.0:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们可以转到[nodejs.org](http://nodejs.org)下载最新版本的Node安装程序（如下所示）。在本书中，我们将使用最新版本9.3.0：
- en: '![](img/01739796-c861-4e5e-a192-0e22f6a8c399.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01739796-c861-4e5e-a192-0e22f6a8c399.png)'
- en: It is important that you install a V8 version of Node.js. It doesn't have to
    be 4.0, it could be 1.0, but it is important it's on that V8 branch, because there
    is a ton of new features that come along with V8, including all of the features
    you might have come to love in the browser using ES6.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是安装Node.js的V8版本。它不一定要是4.0，可以是1.0，但重要的是它在V8分支上，因为V8带来了大量新功能，包括您可能在浏览器中使用ES6喜欢的所有功能。
- en: 'ES6 is the next version of JavaScript and it comes with a lot of great enhancements
    we''ll be using throughout the book. If you look at the following image, Node.js
    Long Term Support Release Schedule ([https://github.com/nodejs/LTS](https://github.com/nodejs/LTS)),
    you can see that the current Node version is V8, out in April 2017:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ES6是JavaScript的下一个版本，它带来了很多我们将在整本书中使用的优秀增强功能。如果您查看下面的图片，Node.js长期支持发布计划([https://github.com/nodejs/LTS](https://github.com/nodejs/LTS))，您会看到当前的Node版本是V8，发布于2017年4月：
- en: '![](img/0386ded3-18cb-4911-a3fe-8efd5908b708.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0386ded3-18cb-4911-a3fe-8efd5908b708.png)'
- en: Before going further, I would like to talk about the Node release cycle. What
    I have in the preceding image is the official release cycle, this is released
    by Node. You'll notice that only next to the even Node numbers do you find the
    active LTS, the blue bar, and the maintenance bar. Now, LTS stands for long-term
    support, and this is the version that's recommended for most users. I'd recommend
    that you stick with the currently offered LTS option (Node v 8.9.4 LTS), though
    anything on the left-hand side will do, this is shown as the two green buttons
    on [nodejs.org](http://nodejs.org).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想谈谈Node的发布周期。我在上面的图片中所看到的是官方发布周期，这是由Node发布的。您会注意到，只有在偶数Node版本旁边才会找到活跃的LTS，蓝色条和维护条。现在，LTS代表长期支持，这是推荐大多数用户使用的版本。我建议您坚持当前提供的LTS选项（Node
    v 8.9.4 LTS），尽管左侧的任何内容都可以，这显示在[nodejs.org](http://nodejs.org)上的两个绿色按钮上。
- en: Now, as you can see, the major version numbers, bump every six months. Regardless
    of any sort of big overarching change, this happens like clockwork even if nothing
    drastic has changed. It's not like Angular where jumping from 1.0 to 2.0 was almost
    like using a completely different library. This is just not the case with Node,
    what you're getting from this book is the latest and greatest Node has to offer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到，主要版本号每六个月增加一次。无论有任何大的全面性变化，这都会像钟表一样发生，即使没有发生任何重大变化。这不像Angular，从1.0跳到2.0几乎就像使用完全不同的库一样。这在Node中并不是这种情况，您从本书中得到的是Node所提供的最新和最好的东西。
- en: Installing Node
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Node
- en: 'Once the version is confirmed and selected, all we have to do is to click the
    required version button on the Node website ([nodejs.org](http://nodejs.org))
    and download the installer. The installer is one of those basic *click Next a
    few times and you''re done* type of installers, there''s no need to run any fancy
    commands. I''ll start the installer. As shown in the following screenshot, it''ll
    just ask a few questions, then let''s click on Next or Continue through all of
    them:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认并选择了版本，我们所要做的就是在Node网站([nodejs.org](http://nodejs.org))上点击所需版本按钮并下载安装程序。安装程序是那种基本的*点击几次下一步就完成*类型的安装程序，不需要运行任何花哨的命令。我将启动安装程序。如下截图所示，它只会问几个问题，然后让我们通过所有问题点击下一步或继续：
- en: '![](img/9d793ed5-bdc8-43e9-80af-9c6e539d4a72.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d793ed5-bdc8-43e9-80af-9c6e539d4a72.png)'
- en: You might want to specify a custom destination, but if you don't know what that
    means, and you don't usually do it when installing programs, skip that step too.
    Here, in the next screenshot, you can see that I'm using just 58.6 MB, no problem.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要指定自定义目标，但如果您不知道这意味着什么，并且通常在安装程序时不这样做，请跳过该步骤。在下一个截图中，您可以看到我只使用了58.6 MB，没有问题。
- en: 'I''ll run the installer by entering my password. And once I enter my password,
    it should really only take a couple of seconds to get Node installed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过输入我的密码来运行安装程序。一旦我输入密码，安装Node应该只需要几秒钟：
- en: '![](img/83317cab-1d71-4aaf-ba99-43b150100919.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83317cab-1d71-4aaf-ba99-43b150100919.png)'
- en: 'As shown in the following screenshot, we have a message that says The installation
    was completed successfully, which means we are good to go:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，我们有一条消息，说安装已成功完成，这意味着我们可以开始了：
- en: '![](img/17dde6f1-27e8-43e8-b7ba-d3f342d8261b.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17dde6f1-27e8-43e8-b7ba-d3f342d8261b.png)'
- en: Verifying installation
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证安装
- en: 'Now that Node has been installed successfully, we can go ahead and verify that
    by running Node from Terminal. Inside Terminal, I''ll shut it down by going to
    Quit Terminal and open it up again:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Node已经成功安装，我们可以通过在终端中运行Node来验证。在终端中，我将通过退出终端并重新打开来关闭它：
- en: '![](img/ef346e4a-2e45-4758-9eac-3c7d3a12bada.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef346e4a-2e45-4758-9eac-3c7d3a12bada.png)'
- en: The reason I'm opening it up is because we've installed a new command, and some
    Terminals require a restart before they will be able to run that new command.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以打开它是因为我们安装了一个新的命令，有些终端需要在运行新命令之前重新启动。
- en: 'In our case, we restarted things and we can run our brand new command so, we''ll
    type it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们重新启动了一些东西，我们可以运行我们全新的命令，所以我们会输入它：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What we're doing in this command is we're running the Node command, and we're
    passing in what's called a **flag**, a hyphen sign followed by a letter. It could
    be `a`, it could be `j`, or in our case it's `v`. This command will print the
    version of Node currently installed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们正在运行Node命令，并传入所谓的**标志**，即连字符后跟一个字母。它可以是`a`，可以是`j`，或者在我们的情况下是`v`。这个命令将打印当前安装的Node版本。
- en: 'We might get an error like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到这样的错误：
- en: '![](img/624d0bbe-8758-48a9-a8d5-667582827385.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/624d0bbe-8758-48a9-a8d5-667582827385.png)'
- en: If you try to run a command that doesn't exist, such as `nodeasdf`, you'll see
    command not found. If you see this, it usually means the Node installer didn't
    work correctly, or you haven't run it in the first place.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试运行一个不存在的命令，比如`nodeasdf`，您将看到命令未找到。如果您看到这个，通常意味着Node安装程序没有正确工作，或者您根本没有运行它。
- en: In our case though, running Node with the `v` flag should result in a number.
    In our case, it's version 9.3.0\. If you do have Node installed, and you see something
    like the following screenshot, then you are done. In the next section, we'll start
    exploring exactly what Node is.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，使用`v`标志运行Node应该会得到一个数字。在我们的情况下，它是版本9.3.0。如果您已经安装了Node，并且看到类似下一个截图的东西，那么您已经完成了。在下一节中，我们将开始探索Node到底是什么。
- en: '![](img/c6ad6c47-19b7-41ae-b798-a6cd09c51270.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6ad6c47-19b7-41ae-b798-a6cd09c51270.png)'
- en: What is Node?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Node？
- en: Node came about when the original developers took JavaScript, something you
    could usually only run inside the browser, and they let it run on your machine
    as a standalone process. This means that we could create applications using JavaScript
    outside the context of the browser.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Node诞生于原始开发人员将JavaScript带到了您的机器上作为一个独立的进程，而不仅仅是在浏览器中运行。这意味着我们可以在浏览器之外使用JavaScript创建应用程序。
- en: Now, JavaScript previously had a limited feature set. When I used it in the
    browser, I could do things such as update the URL and remove the Node logo, adding
    click events or anything else, but I couldn't really do much more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JavaScript以前的功能集是有限的。当我在浏览器中使用它时，我可以做一些事情，比如更新URL和删除Node标志，添加点击事件或其他任何东西，但我实际上不能做更多。
- en: 'With Node, we now have a feature set that looks much more similar to other
    languages, such as Java, Python, or PHP. Some of these are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Node，我们现在有了一个看起来更类似于其他语言（如Java、Python或PHP）的功能集。其中一些如下：
- en: We can write Node applications using the JavaScript syntax
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用JavaScript语法编写Node应用程序
- en: You can manipulate your filesystem, creating and removing folders
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以操纵您的文件系统，创建和删除文件夹
- en: You can create query databases directly
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以直接创建查询数据库
- en: You can even create web servers using Node
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您甚至可以使用Node创建Web服务器
- en: These were things that were not possible in the past, and they are because of
    Node.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是过去不可能的事情，现在却因为Node而成为可能。
- en: Now, both Node and the JavaScript that gets executed inside of your browser,
    they're both running on the exact same engine. It's called the V8 JavaScript runtime
    engine. It's an open source engine that takes JavaScript code and compiles it
    into much faster machine code. And that's a big part of what makes Node.js so
    fast.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Node和在浏览器中执行的JavaScript都在完全相同的引擎上运行。它被称为V8 JavaScript运行时引擎。这是一个将JavaScript代码编译成更快的机器代码的开源引擎。这是Node.js如此快速的一个重要部分。
- en: Machine code is low-level code that your computer can run directly without needing
    to interpret it. Your machine only knows how to run certain types of code, for
    example, your machine can't run JavaScript code or PHP code directly without first
    converting it into low-level code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 机器码是低级代码，你的计算机可以直接运行它，而无需解释。你的计算机只知道如何运行某些类型的代码，例如，你的计算机不能直接运行JavaScript代码或PHP代码，而是需要先将其转换为低级代码。
- en: Using this V8 engine, we can take our JavaScript code, compile it to much quicker
    machine code, and execute that. This is where all those new features come in.
    The V8 engine is written in a language called C++. So if you want to extend the
    Node language, you don't write Node code, you write C++ code that builds off of
    what V8 already has in place.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个V8引擎，我们可以将我们的JavaScript代码编译成更快的机器码，并执行它。这就是所有这些新功能的来源。V8引擎是用一种叫做C++的语言编写的。因此，如果你想扩展Node语言，你不会编写Node代码，而是编写建立在V8已有基础上的C++代码。
- en: Now, we'll not be writing any C++ code in this book. This book is not about
    adding onto Node, it is about using Node. So, we will only be writing JavaScript
    code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不会在这本书中编写任何C++代码。这本书不是关于扩展Node，而是关于使用Node。因此，我们只会编写JavaScript代码。
- en: Speaking of JavaScript code, let's start writing some inside Terminal. Now,
    throughout the book, we'll be creating files and executing those files, but we
    can actually create a brand new Node process by running the `node` command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 说到JavaScript代码，让我们开始在终端内编写一些。在整本书中，我们将创建文件并执行这些文件，但我们实际上可以通过运行`node`命令来创建一个全新的Node进程。
- en: 'Referring to the following screenshot, I have a little right caret, which is
    waiting for JavaScript Node code, not a new command-prompt command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 参考下面的截图，我有一个小的右尖括号，它正在等待JavaScript Node代码，而不是一个新的命令提示符命令：
- en: '![](img/c5947e1b-5bd5-472e-993d-6c281a8324d0.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5947e1b-5bd5-472e-993d-6c281a8324d0.png)'
- en: 'This means that I can run something like `console.log`, which, as you probably
    already know, logs a message to the screen. `log` is a function, so I''ll call
    it as such, opening and closing my parentheses, and passing in a string inside
    two single quotes, a message `Hello world!,` as shown in the following command
    line:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我可以运行像`console.log`这样的东西，你可能已经知道，它会将消息记录到屏幕上。`log`是一个函数，所以我会像这样调用它，打开和关闭括号，并在两个单引号内传递一个字符串，一个消息`Hello
    world!`，就像下面的命令行中所示：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will print Hello world to the screen. If I hit *e*n*ter*, Hello world!
    prints just like you''d expect, as shown in the following code output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在屏幕上打印出Hello world。如果我按下*enter*，Hello world！就会像你期望的那样打印出来，就像下面的代码输出中所示：
- en: '![](img/baf96c0b-f956-42f2-9fd4-1ae1d93d86c1.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baf96c0b-f956-42f2-9fd4-1ae1d93d86c1.png)'
- en: Now, what actually happened behind the scenes? Well, this is what Node does.
    It takes your JavaScript code, it compiles it into machine code, and executes
    it. In the preceding code, you can see it executed our code, printing out Hello
    world!. Now, the V8 engine is running behind the scenes when we execute this command,
    and it's also running inside the Chrome browser.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在幕后实际发生了什么？这就是Node的工作原理。它接受你的JavaScript代码，将其编译成机器码，然后执行它。在上面的代码中，你可以看到它执行了我们的代码，打印出了Hello
    world！现在，当我们执行这个命令时，V8引擎在幕后运行，并且也在Chrome浏览器内运行。
- en: 'If I open up the developer tools in Chrome by going to Settings | More Tools
    | Developer Tools:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在Chrome中打开开发者工具，可以通过设置 | 更多工具 | 开发者工具来实现：
- en: '![](img/c50b749f-f331-445c-a2cf-a4e5effb477a.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c50b749f-f331-445c-a2cf-a4e5effb477a.png)'
- en: 'I can ignore most of the things. I''m just looking for the Console tab, as
    shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以忽略大部分的东西。我只是在寻找控制台选项卡，就像下面的截图中所示的那样：
- en: '![](img/46808206-8003-411c-8dca-2745900d99a3.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46808206-8003-411c-8dca-2745900d99a3.png)'
- en: 'The preceding screenshot showing the console is a place where we can run some
    JavaScript code. I can type the exact same command, `console.log(''Hello world!'');`
    and run it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了控制台，这是一个可以运行一些JavaScript代码的地方。我可以输入完全相同的命令`console.log('Hello world!');`并运行它：
- en: '![](img/608f3133-f3d0-4562-9a9b-65c76466c07a.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/608f3133-f3d0-4562-9a9b-65c76466c07a.png)'
- en: As you can see in the preceding screenshot, Hello world! prints to the screen,
    which is the exact same result we got when we ran it up earlier using Terminal.
    In both cases, we're running it through the V8 engine, and in both cases the output
    is the same.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上面的截图中所看到的，Hello world！打印到了屏幕上，这与我们之前在终端中运行时得到的完全相同的结果。在这两种情况下，我们都是通过V8引擎运行它，输出也是相同的。
- en: Now, we already know that the two are different. Node has features such as filesystem
    manipulation, and the browser has features such as manipulating what's shown inside
    the window. Let's take a quick moment to explore their differences.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经知道这两者是不同的。Node具有文件系统操作等功能，而浏览器具有操作窗口内显示内容的功能。让我们花点时间来探索它们的区别。
- en: Differences between JavaScript coding using Node and in the browser
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node和浏览器进行JavaScript编码的区别
- en: 'Inside the browser, you''ve probably used `window` if you''ve done any JavaScript
    development:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，如果你进行过任何JavaScript开发，你可能已经使用过`window`：
- en: '![](img/c86d2ba0-91d4-4829-81fc-5471adbb8604.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c86d2ba0-91d4-4829-81fc-5471adbb8604.png)'
- en: 'Window is the global object, it stores basically everything you have access
    to. In the following screenshot, you can see things such as array, we have all
    sorts of CSS manipulation and Google Analytics keywords; essentially every variable
    you create lives inside Window:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Window是全局对象，它基本上存储了你可以访问的一切。在下面的截图中，你可以看到诸如数组、各种CSS操作和Google Analytics关键字等内容；基本上你创建的每个变量都存在于Window内：
- en: '![](img/29a97655-4da3-4dd9-b5ae-fdafb9a1f4dd.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29a97655-4da3-4dd9-b5ae-fdafb9a1f4dd.png)'
- en: 'We have something similar inside Node called `global`, as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node内部，我们有一个类似的东西叫做`global`，如下所示：
- en: '![](img/1cb4f89c-3e2f-4e20-bdfd-2d67697b1e46.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cb4f89c-3e2f-4e20-bdfd-2d67697b1e46.png)'
- en: 'It''s not called `window` because there is no browser window in Node, thus
    it is called `global`. The `global` object stores a lot of the same things as
    `window`. In the following screenshot, you can see methods that might be familiar,
    such as `setTimeout` and `setInterval`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它不叫`window`，因为在Node中没有浏览器窗口，因此它被称为`global`。`global`对象存储了许多与`window`相同的东西。在下面的截图中，你可以看到一些可能很熟悉的方法，比如`setTimeout`和`setInterval`：
- en: '![](img/586f7689-f17e-430e-8b70-a9c8c0f411c8.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/586f7689-f17e-430e-8b70-a9c8c0f411c8.png)'
- en: 'If we look at this code screenshot, we have most of the things that are defined
    inside the window, with some exceptions, as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下这段代码的截图，我们会发现大部分东西都是在window中定义的，只有一些例外，如下面的截图所示：
- en: '![](img/ddde7001-804c-4a88-a11f-b0c14722b083.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddde7001-804c-4a88-a11f-b0c14722b083.png)'
- en: 'Now, inside the Chrome browser, I also have access to `document`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Chrome浏览器中，我也可以访问`document`：
- en: '![](img/c9ca1af3-26a5-41f2-8d40-a0c092e1d6e4.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9ca1af3-26a5-41f2-8d40-a0c092e1d6e4.png)'
- en: 'The `document` object stores a reference to the **Document Object Model** (**DOM**)
    in the Node website. The `document` object shows exactly what I have inside the
    browser''s viewport, as shown in the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`document`对象在Node网站中存储了对**文档对象模型**（**DOM**）的引用。`document`对象显示了我在浏览器视口中的内容，如下面的截图所示：'
- en: '![](img/4f4e6fb3-b941-4b3a-b829-06187cf3fef4.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f4e6fb3-b941-4b3a-b829-06187cf3fef4.png)'
- en: 'I can make changes to the document to update what gets shown up on the browser''s
    viewport. Now, obviously we don''t have this HTML `document` inside Node, but
    we do have something similar, which is called `process`. You can view it by running
    process from Node, and in the following screenshot, we have a lot of information
    about the specific Node process that''s being executed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以更改文档以更新在浏览器视口中显示的内容。当然，在Node中我们没有这个HTML `document`，但我们有类似的东西，叫做`process`。你可以通过从Node运行process来查看它，在下面的截图中，我们有关于正在执行的特定Node进程的大量信息：
- en: '![](img/dafb06f4-45b7-4327-95e0-ce6f3ac2900f.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dafb06f4-45b7-4327-95e0-ce6f3ac2900f.png)'
- en: 'There''s also methods available here to shut down the current Node process.
    What I''d like you to do is run the `process.exit` command, passing in as an argument
    the number zero, to say that things exited without error:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些方法可以关闭当前的Node进程。我想让你运行`process.exit`命令，并将数字零作为参数传入，表示退出时没有错误：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When I run this command, you can see I''m now back at the command prompt, as
    shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这个命令时，你可以看到我现在回到了命令提示符，如下面的截图所示：
- en: '![](img/07a39364-2899-4019-a0b4-3900fcd8b12e.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07a39364-2899-4019-a0b4-3900fcd8b12e.png)'
- en: I've left Node, and I'm at a place where I can run any regular command prompt
    command, such as checking my Node version. I can always get back into Node by
    running `node`, and I can leave it without using the `process.exit` command by
    using *control* + *C* twice.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经离开了Node，现在可以运行任何常规的命令提示符命令，比如检查我的Node版本。我可以通过运行`node`随时重新进入Node，并且可以通过两次按下*control*
    + *C*来离开，而不使用`process.exit`命令。
- en: '![](img/eb2936f8-a6d8-4880-9ca1-e3232ac78ae1.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb2936f8-a6d8-4880-9ca1-e3232ac78ae1.png)'
- en: Now, I'm back at my regular command prompt. So, these are the notable differences,
    obviously inside the browser you have the viewable area, window gets changed to
    global, and a document basically becomes process. Now, obviously that's a generalization,
    but those are some of the big picture changes. We'll be exploring all the minutiae
    throughout the book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我又回到了我的常规命令提示符。所以，这些是显而易见的差异，在浏览器中你有可视区域，window变成了global，而document基本上变成了process。当然，这是一个概括，但这些是一些大的变化。我们将在整本书中探索所有细微之处。
- en: Now, when someone asks you what is Node? You can say *Node's a JavaScript runtime
    that uses the V8 engine.* When they ask you what the V8 engine is, you can say
    *the V8 engine is an open source JavaScript engine written in C++ that takes JavaScript
    code and compiles it to machine code. It's used inside Node.js and it's used in
    the Chrome browser*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当有人问你什么是Node时，你可以说*Node是一个使用V8引擎的JavaScript运行时*。当他们问你V8引擎是什么时，你可以说*V8引擎是一个用C++编写的开源JavaScript引擎，它接受JavaScript代码并将其编译成机器代码。它被用在Node.js内部，也被用在Chrome浏览器中*。
- en: Why use Node
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用Node
- en: In this section, we'll cover the *why* behind Node.js. Why is it so good at
    creating backend apps? And why is it becoming so popular with companies such as
    Netflix, Uber and Walmart, who are all using Node.js in production?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Node.js背后的原因。为什么它在创建后端应用方面如此出色？为什么像Netflix、Uber和Walmart这样的公司正在越来越多地使用Node.js在生产中？
- en: As you might have noticed since you're taking this course, when people want
    to learn a new backend language, more and more they're turning to Node as the
    language they want to learn. The Node skillset is in hot demand, for both frontend
    developers who need to use Node day to day to do things such as compile their
    applications, to engineers who are creating applications and utilities using Node.js.
    All of this has made Node the backend language of choice.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，由于你正在学习这门课程，当人们想要学习一门新的后端语言时，他们越来越多地转向Node作为他们想要学习的语言。Node技能组合需求很高，无论是需要每天使用Node来编译他们的应用程序的前端开发人员，还是使用Node.js创建应用程序和实用程序的工程师。所有这些都使Node成为了首选的后端语言。
- en: 'Now, if we look at the homepage of Node, we have three sentences, as shown
    in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们看一下Node的主页，我们会发现三个句子，如下面的截图所示：
- en: '![](img/b3212c22-2924-411a-ac57-d8e8db1d71b7.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3212c22-2924-411a-ac57-d8e8db1d71b7.png)'
- en: In the previous section, we addressed the first sentence. We took a look at
    what Node.js is. There's only three sentences in the image, so in this section,
    we'll take a look at the second two sentences. We'll read them now, then we'll
    break it down, learning exactly why Node is so great.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们解释了第一个句子。我们看了Node.js是什么。图片中只有三个句子，所以在本节中，我们将看一下后面的两个句子。我们现在来读一下，然后我们将分解它，学习Node为什么如此出色。
- en: The first sentence, Node.js uses an event-driven, non-blocking I/O model that
    makes it lightweight and efficient; we'll explore all of this now. The second
    sentence we'll explore at the end of the section—Node.js' packaged ecosystem,
    npm, is the largest ecosystem of open source libraries in the world. Now, these
    two sentences have a ton of information packed into them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一句话，Node.js使用事件驱动的、非阻塞I/O模型，使其轻量高效；我们现在将探索所有这些。第二句话，我们将在本节结束时探讨——Node.js的打包生态系统npm是世界上最大的开源库生态系统。现在，这两句话中包含了大量的信息。
- en: We'll go over a few code examples, we'll dive into some charts and graphs, and
    we'll explore what makes Node different and what makes it so great.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍一些代码示例，深入研究一些图表和图形，探讨Node的不同之处以及它的优点。
- en: Node is an event-driven, non-blocking language. Now, what is I/O? I/O is something
    that your application does all of the time. When you're reading or writing to
    a database, that is I/O, which is short form for input/output.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Node是一个事件驱动的、非阻塞的语言。那么，什么是I/O？I/O是您的应用程序一直在做的事情。当您读取或写入数据库时，这就是I/O，它是输入/输出的缩写。
- en: This is the communication from your Node application to other things inside
    of the Internet of Things. This could be a database read and write request, you
    may be changing some files on your filesystem, or you may be making an HTTP request
    to a separate web server, such as a Google API for fetching a map for the user's
    current location. All of these use I/O, and I/O takes time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的Node应用程序与物联网中其他事物的通信。这可能是数据库读写请求，您可能正在更改文件系统中的一些文件，或者您可能正在向单独的Web服务器发出HTTP请求，例如Google
    API，以获取用户当前位置的地图。所有这些都使用I/O，而I/O需要时间。
- en: Now, the non-blocking I/O is great. That means while one user is requesting
    a URL from Google, other users can be requesting a database file read and write
    access, they can be requesting all sorts of things without preventing anyone else
    from getting some work done.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞I/O非常好。这意味着当一个用户从Google请求URL时，其他用户可以请求数据库文件读写访问，他们可以请求各种各样的事情，而不会阻止其他人完成一些工作。
- en: Blocking and non-blocking software development
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞和非阻塞软件开发
- en: 'Let''s go ahead and take a look at the differences between blocking and non
    blocking software development:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看阻塞和非阻塞软件开发之间的区别：
- en: '![](img/d98b8e36-15cf-4a2e-8a6f-74ae6d3a7f03.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d98b8e36-15cf-4a2e-8a6f-74ae6d3a7f03.png)'
- en: In the preceding screenshot, I have two files that we'll be executing. But before
    going to that, first let's explore how each of these files operates, the steps
    that are required in order to finish the program.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的截图中，我有两个将要执行的文件。但在进行之前，首先让我们探索每个文件的操作方式，以及完成程序所需的步骤。 '
- en: This will help us understand the big differences between blocking, which I have
    on the left side of the image, which is not what Node uses, and non-blocking is
    on the right side, which is exactly how all of our Node applications in the book
    are going to operate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们了解阻塞和非阻塞之间的重大差异，我在图像的左侧显示了阻塞，这不是Node使用的方式，而非阻塞在右侧，这正是我们书中所有Node应用程序的运行方式。
- en: You don't have to understand the individual details, such as what require is,
    in order to understand what's going on in this code example. We'll be breaking
    things down in a very general sense. The first line on each code is responsible
    for fetching a function that gets called. This function will be our simulated
    I/O function that is going to a database, fetching some user data and printing
    it to the screen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必了解诸如require之类的具体细节，才能理解这个代码示例中发生了什么。我们将以非常一般的方式来分解事物。每个代码的第一行负责获取一个被调用的函数。这个函数将是我们模拟的I/O函数，它将去数据库，获取一些用户数据并将其打印到屏幕上。
- en: Refer to the preceding code image. After we load in the function, both files
    try to fetch a user with an ID of `123`. When it gets that user, it prints it
    to the screen with the `user1` string first, and then it goes on and it fetches
    the user with `321` as the ID. And it prints that to the screen. And finally both
    files add up `1 + 2`, storing the result, which is 3, in the `sum` variable and
    print it to the screen.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考前面的代码图像。在我们加载函数之后，两个文件都尝试使用ID为`123`的用户。当它获取到该用户时，首先打印`user1`字符串到屏幕上，然后继续获取ID为`321`的用户，并将其打印到屏幕上。最后，两个文件都将`1
    + 2`相加，将结果3存储在`sum`变量中，并将其打印到屏幕上。
- en: 'Now, while they all do the same thing, they do it in very different ways. Let''s
    break down the individual steps. In the following code image, we''ll go over what
    Node executes and how long it takes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们都做同样的事情，但它们的方式却大不相同。让我们逐步分解各个步骤。在下面的代码图像中，我们将介绍Node执行的内容以及所需的时间：
- en: '![](img/cbf26905-e195-4d79-be4f-e6fd874a2483.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbf26905-e195-4d79-be4f-e6fd874a2483.png)'
- en: You can consider the seconds shown in the preceding screenshot; it doesn't really
    matter, it's just to show the relative operating speed between the two files.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以考虑前面截图中显示的秒数；这并不重要，只是为了显示两个文件之间的相对操作速度。
- en: The working of blocking I/O
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞I/O的工作方式
- en: 'The blocking example can be illustrated as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞示例可以如下所示：
- en: '![](img/edacad6f-9299-41ce-a728-a6172afbd4b1.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edacad6f-9299-41ce-a728-a6172afbd4b1.png)'
- en: 'The first thing that happens inside our blocking example, as shown in the preceding
    screenshot, is that we fetch the user on line 3 in the code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的阻塞示例中，首先发生的事情是我们在代码的第3行获取用户：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, this request requires us to go to a database, which is an I/O operation
    to fetch that user by ID. This takes a little bit of time. In our case, we'll
    say it takes three seconds.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个请求需要我们去数据库，这是一个I/O操作，需要一点时间。在我们的例子中，我们将说它需要三秒。
- en: 'Next, on line 4 in the code, we print the user to the screen, which is not
    an I/O operation and it runs right away, printing `user1` to the screen, as shown
    in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在代码的第4行，我们将用户打印到屏幕上，这不是一个I/O操作，它会立即运行，将`user1`打印到屏幕上，如下图所示：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see in the following screenshot, it takes almost no time at all:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下面的屏幕截图中所看到的，这几乎不需要时间：
- en: '![](img/400cbd6b-099e-48ab-81f4-291cf7d055f2.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/400cbd6b-099e-48ab-81f4-291cf7d055f2.png)'
- en: 'Next up, we wait on the fetching of `user2`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们等待获取`user2`：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/0888c6f8-da6d-4320-aafa-4f6692b70f96.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0888c6f8-da6d-4320-aafa-4f6692b70f96.png)'
- en: 'When `user2` comes back, as you might expect, we print it to the screen, which
    is exactly what happens on line 7:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当`user2`返回时，正如你所期望的那样，我们将其打印到屏幕上，这正是第7行发生的事情：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we add up our numbers and we print it to the screen:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将数字相加并将其打印到屏幕上：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: None of this is I/O, so right here we have our sum printing to the screen in
    barely any time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不是I/O操作，所以在这里，我们的总和几乎立即打印到屏幕上。
- en: This is how blocking works. It's called blocking because while we're fetching
    from the database, which is an I/O operation, our application cannot do anything
    else. This means our machine sits around idle waiting for the database to respond,
    and can't even do something simple like adding two numbers and printing them to
    the screen. It's just not possible in a blocking system.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是阻塞的工作原理。它被称为阻塞，因为当我们从数据库获取数据时，也就是进行I/O操作时，我们的应用程序无法做其他任何事情。这意味着我们的机器会空闲地等待数据库的响应，甚至不能做一些简单的事情，比如将两个数字相加并将它们打印到屏幕上。在阻塞系统中这是不可能的。
- en: The working non-blocking I/O
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作中的非阻塞I/O
- en: In our non-blocking example, this is how we'll be building our Node applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的非阻塞示例中，这就是我们将构建我们的Node应用程序的方式。
- en: 'Let''s break this code example down line by line. First up, things start much
    the same way as we discussed in the blocking example. We''ll start the `getUser`
    function for `user1`, which is exactly what we did earlier:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分解这个代码示例。首先，事情的开始方式与我们在阻塞示例中讨论的方式非常相似。我们将为`user1`启动`getUser`函数，这正是我们之前所做的：
- en: '![](img/9c170d20-73ec-417b-a51a-62f13963b8de.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c170d20-73ec-417b-a51a-62f13963b8de.png)'
- en: But we're not waiting, we're simply kicking off that event. This is all part
    of the event loop inside Node.js, which is something we'll be exploring in detail.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们并没有等待，我们只是启动了那个事件。这都是Node.js内部事件循环的一部分，我们将会详细探讨这个问题。
- en: 'Notice it takes a little bit of time; we''re just starting the request, we''re
    not waiting for that data. The next thing we do might surprise you. We''re not
    printing `user1` to the screen because we''re still waiting for that request to
    come back, instead we start the process of fetching our `user2` with the ID of
    `321`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这需要一点时间；我们只是开始请求，我们并没有等待数据。我们接下来要做的可能会让你感到惊讶。我们没有将`user1`打印到屏幕上，因为我们仍在等待该请求返回，而是开始获取ID为`321`的`user2`的过程：
- en: '![](img/e6e86e00-25f0-453b-89f5-063adbfef43e.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6e86e00-25f0-453b-89f5-063adbfef43e.png)'
- en: In this part of the code, we're kicking off another event, which takes just
    a little bit of time to do-it is not an I/O operation. Now, behind the scenes,
    the fetching of the database is I/O, but starting the event, calling this function
    is not, so it happens really quickly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的这一部分中，我们启动了另一个事件，这需要一点时间来完成-这不是一个I/O操作。现在，在幕后，数据库的获取是I/O操作，但启动事件，调用这个函数并不是，所以它会非常快速地发生。
- en: 'Next up, we print the sum. The sum doesn''t care about either of the two user
    objects. They''re basically unrelated, so there''s no need to wait for the users
    to come back before I print that `sum` variable, as shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打印总和。总和与这两个用户对象无关。它们基本上没有关联，所以在打印`sum`变量之前，我们不需要等待用户返回，如下面的屏幕截图所示：
- en: '![](img/989ab9b8-023d-4e73-acd5-ebf2d460f179.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/989ab9b8-023d-4e73-acd5-ebf2d460f179.png)'
- en: 'What happens after we print the sum? Well, we have the dotted box, as shown
    in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 打印总和之后会发生什么？嗯，我们有点线框，如下面的屏幕截图所示：
- en: '![](img/47d4fbae-786a-469b-ba5d-eff9d7b767dd.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47d4fbae-786a-469b-ba5d-eff9d7b767dd.png)'
- en: 'This box signifies the simulated time it takes for our event to get responded
    to. Now, this box is the exact same width as the box in the first part of the
    blocking example (waiting on user1), as shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框表示我们的事件得到响应所需的模拟时间。现在，这个框的宽度与阻塞示例的第一部分（等待user1）中的框完全相同，如下所示：
- en: '![](img/7b946502-ff7c-4c2e-8fe8-2be5a4ae7a62.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b946502-ff7c-4c2e-8fe8-2be5a4ae7a62.png)'
- en: Using non-blocking doesn't make our I/O operations any faster, but what it does
    do is it lets us run more than one operation at the same time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非阻塞并不会使我们的I/O操作变得更快，但它可以让我们同时运行多个操作。
- en: 'In the non-blocking example, we start two I/O operations before the half second
    mark, and in between three and a half seconds, both come back, as shown in the
    following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在非阻塞的例子中，我们在半秒钟之前启动了两个I/O操作，在三秒半之间，两者都返回，如下面的屏幕截图所示：
- en: '![](img/88a19684-fd14-41b8-89d3-9feeee9f4591.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88a19684-fd14-41b8-89d3-9feeee9f4591.png)'
- en: Now, the result here is that the entire application finishes much quicker. If
    you compare the time taken in executing both the files, the non-blocking version
    finishes in just over three seconds, while the blocking version takes just over
    six seconds. A difference of 50%. This 50% comes from the fact that in blocking,
    we have two requests each taking three seconds, and in non-blocking, we have two
    requests each taking three seconds, but they run at the same time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果是整个应用程序完成得更快。如果比较执行这两个文件所花费的时间，非阻塞版本在三秒多一点结束，而阻塞版本则需要六秒多一点。相差50%。这50%来自于阻塞中我们有两个请求，每个请求需要三秒，而在非阻塞中，我们有两个请求，每个请求需要三秒，但它们同时运行。
- en: Using the non-blocking model, we can still do stuff like printing the sum without
    having to wait for our database to respond. Now, this is the big difference between
    the two; blocking, everything happens in order, and in non-blocking we start events,
    attaching callbacks, and these callbacks get fired later. We're still printing
    out `user1` and `user2`, we're just doing it when the data comes back, because
    the data doesn't come back right away.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非阻塞模式，我们仍然可以做一些事情，比如打印总和，而不必等待数据库回应。现在，这就是两者之间的重大区别；阻塞，一切按顺序发生，在非阻塞中，我们启动事件，附加回调，这些回调稍后被触发。我们仍然打印出`user1`和`user2`，只是当数据返回时才这样做，因为数据不会立即返回。
- en: Inside Node.js, the event loop attaches a listener for the event to finish,
    in this case for that database to respond back. When it does, it calls the callback
    you pass in the non-blocking case, and then we print it to the screen.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，事件循环会为事件附加一个监听器，比如数据库回应完成。当它完成时，在非阻塞情况下调用你传递的回调函数，然后我们将其打印到屏幕上。
- en: Now, imagine this was a web server instead of the preceding example. That would
    mean if a web server comes in looking to query the database, we can't process
    other users' requests without spinning up a separate thread. Now, Node.js is single
    threaded, which means your application runs on one single thread, but since we
    have non-blocking I/O, that's not a problem.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下这是一个网页服务器，而不是前面的例子。这意味着如果一个网页服务器来查询数据库，我们不能处理其他用户的请求而不启动一个单独的线程。现在，Node.js是单线程的，这意味着你的应用程序在一个单一的线程上运行，但由于我们有非阻塞I/O，这不是一个问题。
- en: In a blocking context, we could handle two requests on two separate threads,
    but that doesn't really scale well, because for each request we have to beef up
    the amount of CPU and RAM resources that we're using for the application, and
    this sucks because those threads, are still sitting idle. Just because we can
    spin up other threads doesn't mean we should, we're wasting resources that are
    doing nothing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在阻塞的情况下，我们可以在两个单独的线程上处理两个请求，但这并不是很好扩展，因为对于每个请求，我们都必须增加应用程序使用的CPU和RAM资源的数量，而且这很糟糕，因为这些线程仍然处于空闲状态。仅仅因为我们可以启动其他线程并不意味着我们应该这样做，我们正在浪费没有做任何事情的资源。
- en: In the non-blocking case, instead of wasting resources by creating multiple
    threads, we're doing everything on one thread. When a request comes in, the I/O
    is non-blocking so we're not taking up any more resources than we would be if
    it never happened at all.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在非阻塞的情况下，我们不是通过创建多个线程来浪费资源，而是在一个线程上做所有事情。当一个请求进来时，I/O是非阻塞的，所以我们不会占用比根本没有发生更多的资源。
- en: Blocking and non-blocking examples using Terminal
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用终端的阻塞和非阻塞示例
- en: Let's run these examples in real time and see what we get. And we have the two
    files (`blocking` and `non-blocking` files) that we saw in the previous section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实时运行这些示例，看看我们得到什么。我们有两个文件（`blocking`和`non-blocking`文件），我们在上一节中看到了。
- en: We'll run both of these files, and I'm using the Atom editor to edit my text
    files. These are things we'll be setting up later in the section, this is just
    for your viewing purpose, you don't need to run these files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行这两个文件，我正在使用Atom编辑器来编辑我的文本文件。这些是我们将在本节后面设置的东西，这只是为了让你看看，你不需要运行这些文件。
- en: Now, the `blocking` and `non-blocking` files, will both get run and they'll
    do similar things to those we did in the previous section, just in a different
    way. Both use I/O operations, `getUserSync` and `getUser`, that take five seconds
    apiece. The time is no different, it's just the order they execute in that makes
    the non-blocking version much quicker.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`blocking`和`non-blocking`文件，都将被运行，并且它们将以不同的方式做与我们在上一节中所做的类似的事情。两者都使用I/O操作，`getUserSync`和`getUser`，每个操作需要5秒。时间没有区别，只是它们执行的顺序使非阻塞版本快得多。
- en: Now, to simulate and show how things work, I'll add a few `console.log` statements
    as shown in the following code example, `console.log('starting user1')`, `console.log('starting
    user2')`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了模拟和展示工作原理，我将添加一些`console.log`语句，如下面的代码示例所示，`console.log('starting user1')`，`console.log('starting
    user2')`。
- en: 'This will let us visualize how things work inside Terminal. By running `node
    blocking.js`, this is how we run files. We type `node` and we specify the filename,
    as shown in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让我们看到终端内部的工作原理。通过运行`node blocking.js`，这就是我们运行文件的方式。我们输入`node`，然后指定文件名，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When I run the file, we get some output. starting user1 prints to the screen
    and then it sits there:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行文件时，我们会得到一些输出。开始用户1打印到屏幕上，然后停在那里：
- en: '![](img/20b59ccb-f0e6-489a-bfcb-4d12c123e78c.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20b59ccb-f0e6-489a-bfcb-4d12c123e78c.png)'
- en: 'Now, we have the user1 object printing to the screen with the name Andrew,
    and starting user2 prints to the screen, as shown in the following code output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有用户1对象打印到屏幕上，名字是Andrew，并且开始用户2打印到屏幕上，如下面的代码输出所示：
- en: '![](img/1042e6f6-cea0-4939-a0a6-f5ae5687895d.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1042e6f6-cea0-4939-a0a6-f5ae5687895d.png)'
- en: After that, the user2 object comes back around five seconds later with the name
    of Jen.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，大约5秒后，用户2对象带着名字Jen回来。
- en: As shown in the preceding screenshot, our two users have printed to the screen,
    and at the very end our sum, which is 3, prints to the screen; everything works
    great.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们的两个用户已经打印到屏幕上，最后我们的总和，即3，打印到屏幕上；一切都很顺利。
- en: Notice that starting user1 was immediately followed by the finishing of user1,
    and starting user2 was immediately followed by the finishing of user2 because
    this is a blocking application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，开始用户1立即后面就是用户1的完成，开始用户2立即后面就是用户2的完成，因为这是一个阻塞应用程序。
- en: 'Now, we''ll run the non-blocking file, which I''ve called `non-blocking.js`.
    When I run this file, starting user1 prints, starting user2 prints, then the sum
    prints all back to back:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行非阻塞文件，我称之为`non-blocking.js`。当我运行这个文件时，开始用户1打印，开始用户2打印，然后总和连续打印：
- en: '![](img/b2645e90-ed2b-47f9-bc54-0f86d99d7392.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2645e90-ed2b-47f9-bc54-0f86d99d7392.png)'
- en: Around 5 seconds later, at basically the same time, user1 and user2 both print
    to the screen.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大约5秒后，基本上在同一时间，用户1和用户2都在屏幕上打印出来。
- en: This is how non-blocking works. Just because we started an I/O operation doesn't
    mean we can't do other things, such as starting another one and printing some
    data to the screen, in this case just a number. This is the big difference, and
    this is what makes non-blocking apps so fantastic. They can do so many things
    at the exact same time without having to worry about the confusion of multi-threading
    applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是非阻塞的工作原理。仅仅因为我们启动了一个I/O操作，并不意味着我们不能做其他事情，比如启动另一个操作并将一些数据打印到屏幕上，在这种情况下只是一个数字。这就是重大的区别，也是非阻塞应用程序如此出色的地方。它们可以在完全相同的时间做很多事情，而不必担心多线程应用程序的混乱。
- en: 'Let''s move back into the browser and take a look at those sentences again
    in the Node website:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到浏览器，再次查看Node网站上的那些句子：
- en: '![](img/5362f1ab-d1ae-4a24-805f-0c29032f702f.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5362f1ab-d1ae-4a24-805f-0c29032f702f.png)'
- en: Node.js uses an event-driven, non-blocking I/O model that makes it lightweight
    and efficient, and we saw that in action.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js使用事件驱动的、非阻塞的I/O模型，使其轻量级和高效，我们在实际操作中看到了这一点。
- en: Because Node is non-blocking, we were able to cut down the time our application
    took by half. This non-blocking I/O makes our apps super quick, this is where
    the lightweight and efficient comes into play.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Node是非阻塞的，我们能够将应用程序所需的时间减少了一半。这种非阻塞I/O使我们的应用程序非常快速，这就是轻量级和高效的作用所在。
- en: Node community – problem solving open source libraries
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node社区-解决问题的开源库
- en: 'Now, let''s go to the last sentence on the Node website, as shown in the following
    screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们去看Node网站上的最后一句话，如下截图所示：
- en: '![](img/77e0d3cd-2131-4e2b-9e51-24548fa6adaa.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77e0d3cd-2131-4e2b-9e51-24548fa6adaa.png)'
- en: Node.js' package ecosystem, npm, is the largest ecosystem of open-source libraries
    in the world. This is what really makes Node fantastic. This is the cherry on
    top-the community, the people every day developing new libraries that solve common
    problems in your Node.js applications.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的软件包生态系统npm是世界上最大的开源库生态系统。这正是使Node如此出色的地方。这是锦上添花-社区，每天都有人开发新的库，解决Node.js应用程序中的常见问题。
- en: Things such as validating objects, creating servers, and serving up content
    live using sockets. There's libraries already built for all of those so you don't
    have to worry about this. This means that you can focus on the specific things
    related to your application without having to create all this infrastructure before
    you can even write real code, code that does something specific to your apps use
    case.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如验证对象、创建服务器以及使用套接字实时提供内容等事情。所有这些都已经有库构建好了，所以你不必担心这些。这意味着你可以专注于与你的应用程序相关的特定事物，而不必在你甚至写真正的代码之前创建所有这些基础设施，这些代码是针对你应用程序的特定用例的。
- en: 'Now, npm, which is available on [npmjs.org](http://npmjs.org), is the site
    we''ll be turning to for a lot of third-party modules:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，npm可以在[npmjs.org](http://npmjs.org)上找到，这是我们将寻求许多第三方模块的网站：
- en: '![](img/8b3348a0-e931-4ece-a38d-7fbee074a008.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b3348a0-e931-4ece-a38d-7fbee074a008.png)'
- en: If you're trying to solve a problem in Node that sounds generic, chances are
    that someone's already solved it. For example, if I want to validate some objects,
    let's say I want to validate that a name property exists and that there's an ID
    with a length of three. I could go into Google or go into npm; I usually choose
    Google, and I could Google search `npm validate object`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图在Node中解决一个通用的问题，很有可能已经有人解决了。例如，如果我想验证一些对象，比如我想验证一个名字属性是否存在，以及是否有一个长度为三的ID。我可以去谷歌或者去npm；我通常选择谷歌，然后搜索`npm
    validate object`。
- en: 'When I google that, I''ll just look for results from [npmjs.com](http://npmjs.com),
    and you can find the first three or so are from that:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我谷歌搜索时，我只会寻找[npmjs.com](http://npmjs.com)的结果，你可以发现前三个结果都来自那里：
- en: '![](img/83bd9ccc-dcdd-4f5f-aff2-b74cc3b8c031.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83bd9ccc-dcdd-4f5f-aff2-b74cc3b8c031.png)'
- en: 'I can click the first one, and this will let me explore the documentation and
    see if it''s right for me:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以点击第一个，这将让我探索文档，看看它是否适合我：
- en: '![](img/c77764e8-64dc-4c68-947c-e4e74dbb858a.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c77764e8-64dc-4c68-947c-e4e74dbb858a.png)'
- en: This one looks great, so I can add it to my app without any effort.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来很不错，所以我可以毫不费力地将它添加到我的应用程序中。
- en: Now, we'll go through this process. Don't worry, I'm not going to leave you
    high and dry on how to add third-party modules. We'll be using a ton of them in
    the book because this is what real Node developers do. They take advantage of
    the fantastic community of developers, and that's the last thing that makes Node
    so great.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过这个过程。别担心，我不会让你不知所措地如何添加第三方模块。我们将在书中使用大量的第三方模块，因为这才是真正的Node开发者所做的。他们利用了出色的开发者社区，这也是使Node如此出色的最后一点。
- en: This is why Node has come to the position of power that it currently sits at,
    because it's non-blocking, meaning it's great for I/O applications, and it has
    a fantastic community of developers. So, if you ever want to get anything done,
    there's a chance someone already wrote the code to do it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么Node能够达到当前的强大地位，因为它是非阻塞的，这意味着它非常适合I/O应用程序，并且有一个出色的开发者社区。因此，如果你想要完成任何事情，有可能已经有人编写了代码来完成它。
- en: This is not to say you should never use Rails or Python or any other blocking
    language again, that is not what I'm getting at. What I'm really trying to show
    you is the power of Node.js and how you can make your applications even better.
    Languages like Python have things such as the library Twisted, which aims to add
    non-blocking features to Python. Though the big problem is all of the third-party
    libraries, as they are still written in a blocking fashion, so you're really limited
    as to which libraries you can use.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说你永远不应该再次使用Rails或Python或任何其他阻塞语言，这不是我的意思。我真正想向你展示的是Node.js的强大之处，以及你如何使你的应用程序变得更好。像Python这样的语言有一些库，比如旨在为Python添加非阻塞特性的Twisted。尽管存在一个大问题，那就是所有的第三方库仍然是以阻塞方式编写的，所以你在使用哪些库方面受到了很大的限制。
- en: Since Node was built non-blocking from the ground up, every single library on
    [npmjs.com](http://npmjs.com) is non-blocking. So you don't have to worry about
    finding one that's non blocking versus blocking; you can install a module knowing
    it was built from the ground up using a non blocking ideology.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node是从头开始构建的非阻塞式，[npmjs.com](http://npmjs.com)上的每个库都是非阻塞式的。所以你不必担心找到一个是非阻塞式的还是阻塞式的；你可以安装一个模块，知道它是从头开始使用非阻塞式思想构建的。
- en: In the next couple of sections, you'll be writing your very first app and running
    it from Terminal.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，你将编写你的第一个应用程序，并从终端运行它。
- en: Different text editors for node applications
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的文本编辑器用于节点应用程序
- en: In this section, I want to give you a tour of the various text editors you can
    use for this book. If you already have one you love using, you can keep using
    the one you have. There's no need to switch editors to get anything done in this
    book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我想给你介绍一下你可以用来阅读本书的各种文本编辑器。如果你已经有一个你喜欢使用的，你可以继续使用你已经有的。在本书中，没有必要更换编辑器来完成任何工作。
- en: Now, if you don't have one and you're looking for a few options, I always recommend
    using **Atom**, which you can find at [atom.io](http://atom.io). It's free, open
    source, and it's available on all operating systems, Linux, macOS, and Windows.
    It's created by the folks behind GitHub and it's the editor that I'll be using
    inside of this book. There's an awesome community of theme and plug-in developers
    so you really can customize it to your liking.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你没有一个，并且正在寻找一些选择，我总是建议使用**Atom**，你可以在[atom.io](http://atom.io)找到它。它是免费的，开源的，并且可以在所有操作系统上使用，包括Linux、macOS和Windows。它是由GitHub背后的人创建的，这是我在本书中将要使用的编辑器。有一个很棒的主题和插件开发社区，所以你真的可以根据自己的喜好进行定制。
- en: Now, aside from Atom there are a few other options. I've heard a lot of people
    talking about **Visual Studio Code**. It is also open source, free, and available
    on all operating systems. If you don't like Atom, I highly recommend you check
    this out, because I've heard so many good things by word of mouth.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Atom之外，还有一些其他选择。我听到很多人在谈论**Visual Studio Code**。它也是开源的，免费的，并且可以在所有操作系统上使用。如果你不喜欢Atom，我强烈建议你试试这个，因为我听到很多好评。
- en: Next up, we always have **Sublime Text**, which you can find at [sublimetext.com](http://sublimetext.com).
    Now, Sublime Text is not free and it's not open source, but it's a text editor
    that a lot of folks do enjoy using. I prefer Atom because it's very similar to
    Sublime Text, though I find it snappier and easier to use, plus it's free and
    open source.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们总是有**Sublime Text**，你可以在[sublimetext.com](http://sublimetext.com)找到。现在，Sublime
    Text并不是免费的，也不是开源的，但是很多人确实喜欢使用它。我更喜欢Atom，因为它与Sublime Text非常相似，但我觉得它更快速、更容易使用，而且它是免费和开源的。
- en: Now, if you are looking for a more premium editor with all of the bells and
    whistles in IDE as opposed to a text editor, I always recommend **JetBrains**.
    None of their products are free, though they do come with a 30-day free trial,
    but they really are the best tools of the trade. If you find yourself in a corporate
    setting or you're at a job where the company is willing to pay for an editor,
    I always recommend that you go with JetBrains. All of their editors come with
    all of the tools you'd expect, such as version control integration, debugging
    tools, and deploying tools built in.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你正在寻找一个更高级的编辑器，拥有所有IDE的功能，而不是一个文本编辑器，我总是推荐**JetBrains**。他们的产品都不是免费的，尽管它们都有30天的免费试用期，但它们确实是最好的工具。如果你发现自己处于公司环境中，或者你在一家公司愿意为编辑器付费的工作中，我总是建议你选择JetBrains。他们的所有编辑器都配备了你所期望的所有工具，比如版本控制集成、调试工具和内置的部署工具。
- en: So, take a moment, download the one you want to use, play around with it, make
    sure it fits your needs, and if not, try another one.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，请花点时间，下载你想要使用的，玩弄一下，确保它符合你的需求，如果不符合，再尝试另一个。
- en: Hello World – creating and running the first Node app
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World - 创建和运行第一个Node应用程序
- en: In this section, you will be creating and running your very first Node app.
    Well, it will be a simple one. It'll demonstrate the entire process, from creating
    files to running them from Terminal.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将创建并运行你的第一个Node应用程序。嗯，它将是一个简单的应用程序。它将演示整个过程，从创建文件到从终端运行它们。
- en: Creating the Node application
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Node应用程序
- en: The first step will be to create a folder. Every project we create will go live
    inside of its own folder. I'll open up the **Finder** on macOS and navigate to
    my desktop. What I'd like you to do is open up the desktop on your OS, whether
    you're on Linux, Windows, or macOS, and create a brand new folder called `hello-world`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个文件夹。我们创建的每个项目都将放在自己的文件夹中。我将在macOS上打开**Finder**并导航到我的桌面。我希望你也能在你的操作系统上打开桌面，无论你是在Linux、Windows还是macOS上，并创建一个名为`hello-world`的全新文件夹。
- en: I don't recommend using spaces in your project file or folder names, as it only
    makes it more confusing to navigate inside of Terminal. Now, we have this `hello-world`
    folder and we can open it up inside of our editor.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议在项目文件或文件夹名称中使用空格，因为这只会使在终端内导航变得更加混乱。现在，我们有了这个`hello-world`文件夹，我们可以在编辑器中打开它。
- en: 'Now I''ll use c*ommand* + *O* (*Ctrl* + *O* for Windows users) to open up,
    and I''ll navigate to the desktop and double-click my hello-world folder, as shown
    here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将使用c*ommand* + *O*（Windows用户为*Ctrl* + *O*）来打开，然后我将导航到桌面并双击我的hello-world文件夹，如下所示：
- en: '![](img/0f41597b-8ced-4bd1-a43f-84b71697a3d6.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f41597b-8ced-4bd1-a43f-84b71697a3d6.png)'
- en: 'On the left I have my files, which are none. So, let''s create a new one. I''ll
    make a new file in the root of the project, and we''ll call this one `app.js`,
    as shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边，我有我的文件，没有。所以，让我们创建一个新的。我将在项目的根目录中创建一个新文件，我们将把它命名为`app.js`，如下所示：
- en: '![](img/1f21ffe8-49cf-414a-bfa2-e0cab5682fa0.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f21ffe8-49cf-414a-bfa2-e0cab5682fa0.png)'
- en: This will be the only file we have inside our Node application, and in this
    file we can write some code that will get executed when we start the app.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们在Node应用程序中唯一的文件，而且在这个文件中，我们可以编写一些代码，当我们启动应用程序时，它将被执行。
- en: 'In the future, we''ll be doing crazy stuff like initializing databases and
    starting web servers, but for now we''ll simply use `console.log`, which means
    we''re accessing the log property on the console object. It''s a function, so
    we can call it with parentheses, and we''ll pass in one argument as string, `Hello
    world!`. I''ll toss a semicolon on the end and save the file, as shown in the
    following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我们将做一些疯狂的事情，比如初始化数据库和启动Web服务器，但现在我们将简单地使用`console.log`，这意味着我们正在访问控制台对象上的日志属性。这是一个函数，所以我们可以用括号调用它，然后我们将一个字符串作为一个参数传递进去，`Hello
    world!`。我会在末尾加上一个分号并保存文件，如下所示的代码：
- en: '[PRE9]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will be the first app we run.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们运行的第一个应用程序。
- en: Now, remember, there is a basic JavaScript requirement for this course, so nothing
    here should look too foreign to you. I'll be covering everything new and fresh
    inside of this course, but the basics, creating variables, calling functions,
    those should be something you're already familiar with.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请记住，这门课程有一个基本的JavaScript要求，所以这里的任何东西对你来说都不应该太陌生。我将在这门课程中涵盖所有新鲜的内容，但基础知识，比如创建变量，调用函数，这些应该是你已经熟悉的。
- en: Running the Node application
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Node应用程序
- en: Now that we have our `app.js` file, the only thing left to do is to run it,
    and we'll do that over in Terminal. Now, to run this program, we have to navigate
    into our project folder. If you're not familiar with Terminal, I'll give you a
    quick refresher.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`app.js`文件，唯一剩下的事情就是运行它，我们将在终端中进行。现在，要运行这个程序，我们必须导航到我们的项目文件夹中。如果你对终端不熟悉，我会给你一个快速的复习。
- en: 'You can always figure out where you are using `pwd` on Linux or macOS, or the
    `dir` command on Windows. When you run it, you''ll see something similar to the
    following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时使用`pwd`在Linux或macOS上，或者在Windows上使用`dir`命令来查看你所在的位置。当你运行它时，你会看到类似于以下截图的内容：
- en: '![](img/d60c2c2f-132e-4e91-9502-3ac7e918147c.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d60c2c2f-132e-4e91-9502-3ac7e918147c.png)'
- en: I'm in the `Users` folder, and then I'm in my user folder, and my user name
    happens to be `Gary`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`Users`文件夹中，然后我在我的用户文件夹中，我的用户名恰好是`Gary`。
- en: When you open Terminal or Command Prompt, you'll start in your user directory.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开终端或命令提示符时，你将会在你的用户目录中开始。
- en: 'We can use `cd` to navigate into the desktop, and here we are:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`cd`进入桌面，就像这样：
- en: '![](img/8f231b7e-2265-4f50-8652-6f360e5727ee.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f231b7e-2265-4f50-8652-6f360e5727ee.png)'
- en: Now we're sitting in the desktop. The other command you can run from anywhere
    on your computer is `cd /users/Gary/desktop`. And this will navigate to your desktop,
    no matter what folder you're located in. The command `cd desktop`, requires you
    to be in the user directory to work correctly.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们坐在桌面上。你可以从计算机的任何地方运行另一个命令`cd /users/Gary/desktop`。这将导航到你的桌面，无论你位于哪个文件夹。命令`cd
    desktop`要求你在用户目录中才能正确工作。
- en: 'Now we can start by cd-ing into our project directory, which we called `hello-world,`
    as shown in the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过cd进入我们的项目目录，我们称之为`hello-world`，如下命令所示：
- en: '[PRE10]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下截图：
- en: '![](img/3490414c-477f-42bf-a6b8-59748150c574.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3490414c-477f-42bf-a6b8-59748150c574.png)'
- en: 'Once we''re in this directory, we can run at the `ls` command on Linux or Mac
    (which is the `dir` command on Windows) to see all of our files, and in this case
    we just have one, we have `app.js`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在这个目录中，我们可以在Linux或Mac上运行`ls`命令（在Windows上是`dir`命令）来查看我们所有的文件，而在这种情况下，我们只有一个，我们有`app.js`：
- en: '![](img/533e8079-8292-4d97-a74d-ddb45f680e25.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/533e8079-8292-4d97-a74d-ddb45f680e25.png)'
- en: This is the file we'll run.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要运行的文件。
- en: 'Now, before you do anything else, make sure you are in the `hello-world` folder
    and you should have the `app.js` file inside. If you do, all we''ll do is run
    the `node` command followed by a space so we can pass in an argument, and that
    argument will be the filename, `app.js` as shown here:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你做任何其他事情之前，请确保你在`hello-world`文件夹中，并且你应该有`app.js`文件。如果有的话，我们要做的就是运行`node`命令，后面跟一个空格，这样我们就可以传入一个参数，那个参数就是文件名`app.js`，如下所示：
- en: '[PRE11]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once you have this in place, hit *enter* and there we go, Hello world! prints
    to the screen, as shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好了，按下*enter*，然后我们就可以看到，Hello world!打印到屏幕上，如下所示：
- en: '![](img/dcd99b26-6948-473b-a370-a873bf676c13.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcd99b26-6948-473b-a370-a873bf676c13.png)'
- en: And that is all it takes to create and run a very basic Node application. While
    our app doesn't do anything cool, we'll be using this process of creating folders/files
    and running them from Terminal throughout the book, so it's a great start on our
    way to making real-world Node apps.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建和运行一个非常基本的Node应用程序所需的全部步骤。虽然我们的应用程序没有做任何酷炫的事情，但我们将在整本书中使用这个创建文件夹/文件并在终端中运行它们的过程，所以这是我们开始制作真实世界Node应用程序的一个很好的开始。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we touched base with the concept of Node.js. We took a look
    at what Node is and we learned that it's built on top of the V8 JavaScript engine.
    Then we explored why Node has become so popular, its advantages and its disadvantages.
    We took a look at the different text editors we can choose from and, at the end,
    you created your very first Node application.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们接触了Node.js的概念。我们看了一下Node是什么，我们了解到它是建立在V8 JavaScript引擎之上的。然后我们探讨了为什么Node变得如此流行，它的优势和劣势。我们看了一下我们可以选择的不同文本编辑器，最后，你创建了你的第一个Node应用程序。
- en: In the next chapter, we'll dive in and create our first app. I am really excited
    to start writing real-world applications.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入并创建我们的第一个应用程序。我真的很兴奋开始编写真实世界的应用程序。
