- en: Appendix E. Answers to Exercise Questions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 E. 练习题答案
- en: This appendix lists possible answers to the exercises at the end of the chapters.
    Possible answers meaning they are not the only ones, so don't worry if your solution
    is different.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录列出了章节末尾练习题的可能答案。可能答案意味着它们不是唯一的，所以如果你的解决方案不同，请不要担心。
- en: As with the rest of the book, you should try them in your console and play around
    a bit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的其他部分一样，你应该在控制台中尝试它们并稍作玩耍。
- en: The first and the last chapters don't have the *Exercises* section, so let's
    start with [Chapter 2](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops,
    and Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章和最后一章没有 *练习* 部分，所以让我们从 [第二章](ch02.html "第二章. 基本数据类型、数组、循环和条件")，*基本数据类型、数组、循环和条件*
    开始。
- en: Chapter 2, Primitive Data Types, Arrays, Loops, and Conditions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章，基本数据类型、数组、循环和条件
- en: 'Lets try and solve the following exercises:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试解决以下练习：
- en: Exercises
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'The result will be as follows:'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将如下：
- en: '[PRE0]'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you declare a variable but do not initialize it with a value, it automatically
    gets the undefined value. You can also check:'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你声明一个变量但未初始化它时，它将自动获得 `undefined` 值。你也可以检查：
- en: '[PRE1]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The value of `v` will be:'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`v` 的值将是：'
- en: '[PRE2]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding `1` to the string `'1s'` returns the string `'1s1'`, which is *Not A
    Number*, but the `++` operator should return a number; so it returns the special
    `NaN` number.
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将字符串 `'1s'` 中的 `1` 加 `1` 返回的字符串是 `'1s1'`，这不是一个数字，而是 `++` 操作符应该返回的数字；因此它返回了特殊的
    `NaN` 数字。
- en: 'The program is as follows:'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序如下：
- en: '[PRE3]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The tricky part of the question is that `"false"` is a string and all strings
    are `true` when cast to Booleans (except the empty string `""`). If the question
    wasn''t about the string `"false"` but the Boolean `false` instead, the double
    negation !! returns the same Boolean:'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题的难点在于 `"false"` 是一个字符串，并且所有字符串在转换为布尔值时都是 `true`（除了空字符串 `""`）。如果问题不是关于字符串 `"false"`，而是布尔值
    `false`，则双重否定 `!!` 返回相同的布尔值：
- en: '[PRE4]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you''d expect, single negation returns the opposite:'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所预期，单重否定返回相反的值：
- en: '[PRE5]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can test with any string and it will cast to a Boolean `true`, except the
    empty string:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以用任何字符串进行测试，它将被转换为布尔值 `true`，除了空字符串：
- en: '[PRE6]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output after executing `undefined` is as follows:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行 `undefined` 后的输出如下：
- en: '[PRE7]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here `undefined` is one of the falsy values and it casts to `false`. You can
    try with any of the other falsy values, such the empty string `""` in the previous
    example, `NaN`, or `0`.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里 `undefined` 是一个假值之一，并且它被转换为 `false`。你可以尝试使用其他假值，例如前一个示例中的空字符串 `""`、`NaN`
    或 `0`。
- en: '[PRE8]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The number type includes all numbers, `NaN`, positive and negative `Infinity`.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字类型包括所有数字，`NaN`，正 `Infinity` 和负 `Infinity`。
- en: 'The output after executing the following is:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行以下代码后的输出如下：
- en: '[PRE9]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The string `"0"` is cast to the number `0`. Division by `0` is `Infinity`, which
    has no remainder.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字符串 `"0"` 被转换为数字 `0`。除以 `0` 是 `Infinity`，它没有余数。
- en: 'The output after executing the following is:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行以下代码后的输出如下：
- en: '[PRE10]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Comparison with `==` operator doesn''t check the types, but converts the operands;
    in this case both are falsy values. Strict comparison checks the types too:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 `==` 操作符的比较不检查类型，但会转换操作数；在这种情况下，两者都是假值。严格比较也会检查类型：
- en: '[PRE11]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the code line and its output:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一行代码及其输出：
- en: '[PRE12]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Strict comparison between different types (in this case Boolean and string)
    is doomed to fail, no matter what the values are.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同类型（在这种情况下为布尔值和字符串）之间的严格比较注定会失败，无论值是什么。
- en: 'The following is the code line and its output:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一行代码及其输出：
- en: '[PRE13]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Anything in quotes is a string, even though:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何在引号中的内容都是字符串，即使：
- en: '[PRE14]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the code line and its output:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一行代码及其输出：
- en: '[PRE15]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`3e+3` is `3` with three zeroes, meaning `3000`. Then `++` is a post-increment,
    meaning it returns the old value and then it increments it and assigns it to `a`.
    That''s why you get the return value `3000` in the console, although `a` is now
    `3001`:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`3e+3` 是 `3` 后面跟着三个零，意味着 `3000`。然后 `++` 是一个后增量操作符，意味着它返回旧值，然后增加它并将其赋值给 `a`。这就是为什么你在控制台中得到返回值
    `3000`，尽管 `a` 现在是 `3001`：'
- en: '[PRE16]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The value of `v` after executing the following is:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下代码后 `v` 的值如下：
- en: '[PRE17]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If `v` has never been declared, it''s `undefined` so this is the same as:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `v` 从未声明，它是 `undefined`，所以这与以下相同：
- en: '[PRE18]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, if `v` has already been defined and initialized with a non-falsy value,
    you'll get the previous value.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，如果 `v` 已经被定义并且初始化为非假值，你将得到前一个值。
- en: '[PRE19]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The second use of `var` doesn't "reset" the variable.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`var` 的第二次使用不会“重置”变量。'
- en: If `v` was already a falsy value (not a `100`), the check `v || 10` will return
    `10`.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`v`已经是一个假值（不是`100`），则检查`v || 10`将返回`10`。
- en: '[PRE20]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For printing multiplication tables, perform the following:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印乘法表，请执行以下操作：
- en: '[PRE21]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE22]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Chapter 3, Functions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章，函数
- en: 'Lets do the following exercises:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做以下练习题：
- en: Exercises
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习题
- en: 'To convert Hex colors to RGB, perform the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将十六进制颜色转换为RGB，请执行以下操作：
- en: '[PRE23]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: One problem with this solution is that array access to strings like `hex[0]`
    is not in ECMAScript 3, although many browsers have supported it for a long time
    and is now described in ES5.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个解决方案的一个问题是，对字符串如`hex[0]`的数组访问在ECMAScript 3中是不存在的，尽管许多浏览器已经支持了很长时间，现在在ES5中也有描述。
- en: 'However, But at this point in the book, there was as yet no discussion of objects
    and methods. Otherwise an ES3-compatible solution would be to use one of the string
    methods, such as `charAt()`, `substring()`, or `slice()`. You can also use an
    array to avoid too much string concatenation:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，但在本书的这一部分，还没有讨论对象和方法。否则，一个与ES3兼容的解决方案是使用字符串方法之一，例如`charAt()`、`substring()`或`slice()`。您还可以使用数组来避免过多的字符串连接：
- en: '[PRE24]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Bonus exercise**: Rewrite the preceding function using a loop so you don''t
    have to type `parseInt()` three times, but just once.'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**附加练习**：使用循环重写前面的函数，这样您就不必三次输入`parseInt()`，而只需一次。'
- en: 'The result is as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE25]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, the parsing of a string gives up on the first non-integer value. `parseInt()`
    doesn''t understand exponential literals, it expects integer notation:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，字符串解析在第一个非整数值处放弃。`parseInt()`不理解指数文字，它期望整数表示法：
- en: '[PRE26]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is parsing the string `''1e1''` while expecting it to be in decimal notation,
    including exponential:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是在解析字符串`'1e1'`，同时期望它以十进制表示法，包括指数：
- en: '[PRE27]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the code line and its output:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一行代码及其输出：
- en: '[PRE28]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because `0/10` is `0` and `0` is finite.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为`0/10`是`0`，而`0`是有限的。
- en: 'The following is the code line and its output:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一行代码及其输出：
- en: '[PRE29]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Because division by `0` is `Infinity`:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为除以`0`是`Infinity`：
- en: '[PRE30]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the code line and its output:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一行代码及其输出：
- en: '[PRE31]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Parsing the special `NaN` value is `NaN`.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解析特殊值`NaN`是`NaN`。
- en: 'What is the result of:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是什么结果？
- en: '[PRE32]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This snippet alerts `2` even though `n()` was defined before the assignment,
    `a = 2`. Inside the function `n()` you see the variable `a` that is in the same
    scope, and you access its most recent value at the time invocation of `f()` (and
    hence `n()`). Due to hoisting `f()` acts as if it was:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个片段即使`n()`在`a = 2`赋值之前定义，也会弹出一个`2`。在函数`n()`中，您可以看到与`f()`相同的作用域中的变量`a`，并且您在调用`f()`（因此`n()`）时访问了它的最新值。由于提升，`f()`表现得好像是这样的：
- en: '[PRE33]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'More interestingly, consider this code:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更有趣的是，考虑以下代码：
- en: '[PRE34]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It alerts `undefined` and then `2`. You might expect the first alert to say
    `1`, but again due to variable hoisting, the declaration (not initialization)
    of `a` is moved to the top of the function. As if `f()` was:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它会弹出一个`undefined`然后是`2`。您可能期望第一个警报显示`1`，但同样由于变量提升，`a`的声明（而不是初始化）被移动到了函数的顶部。就像`f()`是这样的：
- en: '[PRE35]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The local `a` "shadows" the global `a`, even if it's at the bottom.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 局部变量`a`“遮蔽”了全局变量`a`，即使它在底部。
- en: Why all these alert "Boo!"
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么会有所有这些“Boo！”警报？
- en: 'The following is the result of Example 1:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是示例1的结果：
- en: '[PRE36]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is the result of Example 2\. You can assign a function to a different
    variable. So `f()` points to `alert()`. Evaluating this string is like doing:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是示例2的结果。您可以将函数分配给不同的变量。所以`f()`指向`alert()`。评估这个字符串就像这样做：
- en: '[PRE37]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is the output after we execute `eval()`:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行`eval()`后的输出如下：
- en: '[PRE38]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is the output of Example 3\. `eval()` returns the result on the
    evaluation. In this case it''s an assignment `e = f` that also returns the new
    value of `e`. Like the following:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是示例3的输出。`eval()`返回评估结果。在这种情况下，它是一个赋值`e = f`，它也返回`e`的新值。就像以下这样：
- en: '[PRE39]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So `eval('e=f')` gives you a pointer to `alert()` that is executed immediately
    with `"Boo!"`.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以`eval('e=f')`给你一个指向`alert()`的指针，它立即执行并带有参数`"Boo!"`。
- en: 'The immediate (self-invoking) anonymous function returns a pointer to the function
    `alert()`, which is also immediately invoked with a parameter `"Boo!"`:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 立即（自调用的）匿名函数返回一个指向函数`alert()`的指针，该函数也立即以参数`"Boo!"`调用：
- en: '[PRE40]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Chapter 4, Objects
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章，对象
- en: 'Lets solve the following exercises:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解决以下练习题：
- en: Exercises
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习题
- en: What happens here? What is `this` and what's `o`?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里发生了什么？`this`是什么，`o`又是什么？
- en: '[PRE41]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `this === window` because `C()` was called without `new`.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`this === window`，因为`C()`是在没有`new`的情况下调用的。
- en: Also `o === window` because `new F()` returns the object returned by `C()`,
    which is `this`, and `this` is `window`.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也因为`o === window`，因为`new F()`返回`C()`返回的对象，即`this`，而`this`是`window`。
- en: 'You can make the call to `C()` a constructor call:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以将对`C()`的调用作为一个构造函数调用：
- en: '[PRE42]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, `this` is the object created by the `C()` constructor. So is `o`:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`this`是由`C()`构造函数创建的对象。`o`也是：
- en: '[PRE43]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It becomes more interesting with ES5''s strict mode. In the strict mode, non-constructor
    invocations result in `this` being `undefined`, not the global object. With `"use
    strict"` inside `F()` or `C()` constructor''s body, `this` would be `undefined`
    in `C()`. Therefore, `return C()` cannot return the non-object `undefined` (because
    all constructor invocations return some sort of object) and returns `F` instances''
    `this` (which is in the closure scope). Try it:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在ES5的严格模式下，这会更有趣。在严格模式下，非构造函数调用会导致`this`变为`undefined`，而不是全局对象。在`F()`或`C()`构造函数体内的`"use
    strict"`，`this`在`C()`中将是`undefined`。因此，`return C()`不能返回非对象`undefined`（因为所有构造函数调用都返回某种对象），并返回`F`实例的`this`（它在闭包作用域中）。试试看：
- en: '[PRE44]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Testing:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE45]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What happens when invoking this constructor with `new`?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用`new`调用这个构造函数时会发生什么？
- en: '[PRE46]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`new C()` is an object, not Boolean, because constructor invocations always
    produce an object. It''s the `this` object you get unless you return some other
    object in your constructor. Returning non-objects doesn''t work and you still
    get `this`.'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`new C()`是一个对象，而不是布尔值，因为构造函数调用总是产生一个对象。除非你在构造函数中返回其他对象，否则你得到的是`this`对象。返回非对象不起作用，你仍然得到`this`。'
- en: What does this do?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会做什么？
- en: '[PRE47]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is because `sort()` compares strings. `[1, 2].toString()` is `"1,2"`, so
    it comes after `"1"` and before `"2"`.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为`sort()`比较字符串。`[1, 2].toString()`是`"1,2"`，所以它排在`"1"`之后，排在`"2"`之前。
- en: 'The same thing with `join()`:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`join()`相同：
- en: '[PRE48]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Pretend `String()` doesn't exist and create `MyString()` mimicking `String()`.
    Treat the input primitive strings as arrays (array access officially supported
    in ES5).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`String()`不存在，创建一个模仿`String()`的`MyString()`。将输入的原始字符串视为数组（数组访问在ES5中正式支持）。
- en: Here's a sample implementation with just the methods the exercise asked for.
    Feel free to continue with the rest of the methods. Refer to [Appendix C](apc.html
    "Appendix C. Built-in Objects"), *Built-in Objects* for the full list.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一个仅包含练习要求的方法的示例实现。你可以随意继续其他方法。有关内置对象的完整列表，请参阅[附录C](apc.html "附录 C. 内置对象")，*内置对象*。
- en: '[PRE49]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Testing:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE50]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Feel free to play splitting with a regular expression.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随意使用正则表达式进行拆分。
- en: 'Update `MyString()` with a `reverse()` method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyString()`中添加一个`reverse()`方法：
- en: '[PRE51]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Imagine `Array()` is gone and the world needs you to implement `MyArray()`.
    Here are a handful of methods to get you started:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`Array()`不存在，世界需要你实现`MyArray()`。以下是一些帮助你开始的方法：
- en: '[PRE52]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Testing:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE53]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you found this exercise amusing, don't stop with `join()`; go on with as
    many methods as possible.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你觉得这个练习很有趣，不要只停留在`join()`；尽可能多地继续使用其他方法。
- en: Create `MyMath` object that also has `rand()`, `min([])`, `max([])`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有`rand()`、`min([])`和`max([])`方法的`MyMath`对象。
- en: The point here is that `Math` is not a constructor, but an object that has some
    "static" properties and methods. Below are some methods to get you started.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的问题是`Math`不是一个构造函数，而是一个具有一些“静态”属性和方法的对象。以下是一些帮助你开始的方法。
- en: Let's also use an immediate function to keep some private utility functions.
    You can also take this approach with `MyString` above, where `this._value` could
    be really private.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们再使用一个立即函数来保持一些私有实用函数。你还可以使用这种方法来处理上面的`MyString`，其中`this._value`可以非常私有。
- en: '[PRE54]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After you have finished the book and know about ES5 you can try using `defineProperty()`
    for tighter control and closer replication of the built-ins.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你完成这本书并了解ES5之后，你可以尝试使用`defineProperty()`来实现更紧密的控制和更接近内置对象的复制。
- en: Chapter 5, Prototype
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章，原型
- en: 'Lets try and solve the following exercise:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试解决以下练习：
- en: Exercises
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Create an object called `shape` that has a `type` property and a `getType()`
    method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`shape`的对象，它具有`type`属性和`getType()`方法：
- en: '[PRE55]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following is the program for a `Triangle ()` constructor:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一个`Triangle()`构造函数的程序：
- en: '[PRE56]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To add the `getPerimeter()` method, use the following code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加`getPerimeter()`方法，使用以下代码：
- en: '[PRE57]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Test the following code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试以下代码：
- en: '[PRE58]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Loop over `t` showing only own properties and methods:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历`t`，只显示自有属性和方法：
- en: '[PRE59]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Randomize array elements using the following code snippet:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段随机化数组元素：
- en: '[PRE60]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Testing:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE61]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Chapter 6, Inheritance
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章，继承
- en: 'Lets solve the following exercise:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决以下练习：
- en: Exercises
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Multiple inheritance by mixing into the prototype, for example:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将原型混合到继承中实现多重继承，例如：
- en: '[PRE62]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Testing:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE63]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Property `a` is `2` because `obj_b` overwrote the property with the same name
    from `obj_a` (last one wins):'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 属性`a`是`2`，因为`obj_b`覆盖了来自`obj_a`（最后一个）的同名属性：
- en: '[PRE64]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Practice with the canvas example at [http://www.phpied.com/files/canvas/](http://www.phpied.com/files/canvas/).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[http://www.phpied.com/files/canvas/](http://www.phpied.com/files/canvas/)的画布示例中进行练习。
- en: 'Draw a few triangles using the following code snippet:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下代码片段绘制几个三角形：
- en: '[PRE65]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Draw a few squares using the following code snippet:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下代码片段绘制几个正方形：
- en: '[PRE66]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Draw a few rectangles using the following code snippet:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下代码片段绘制几个矩形：
- en: '[PRE67]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To add Rhombus, Kite, Pentagon, Trapezoid, and Circle (reimplements `draw()`),
    use the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加菱形、风筝、五边形、梯形和圆形（重新实现`draw()`），请使用以下代码：
- en: '[PRE68]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Testing:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE69]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '![Exercises](img/image_69_001.jpg)'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![练习](img/image_69_001.jpg)'
- en: The result of testing new shapes
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试新形状的结果
- en: Think of another way to do the inheritance part. Use `uber` so kids can have
    access to their parents. Also, get parents to be aware of their children.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想想另一种处理继承的方法。使用`uber`以便孩子们可以访问他们的父母。同时，让父母意识到他们的孩子。
- en: 'Keep in mind that not all children inherit `Shape`; for example, `Rhombus`
    inherits `Kite` and `Square` inherits `Rectangle`. You end up with something like
    this:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，并非所有子类都继承自`Shape`；例如，`Rhombus`继承自`Kite`，`Square`继承自`Rectangle`。最终你会得到类似这样的结构：
- en: '[PRE70]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the inheritance pattern from the chapter and the previous exercise, all
    children were sharing the same prototype, for example:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章和前面的练习中提到的继承模式中，所有子类都共享同一个原型，例如：
- en: '[PRE71]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: While this is convenient, it also means no one can touch the prototype because
    it will affect everyone else's prototype. The drawback is that all custom methods
    need to own properties, for example `this.getArea`.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然这样做很方便，但也意味着没有人可以触摸原型，因为它会影响其他人的原型。缺点是所有自定义方法都需要自有属性，例如`this.getArea`。
- en: It's a good idea to have methods shared among instances and defined in the prototype,
    instead of recreating them for every object. The following example moves the custom
    `getArea()` methods to the prototype.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有一个很好的主意是将方法在实例之间共享，并在原型中定义，而不是为每个对象重新创建它们。以下示例将自定义`getArea()`方法移动到原型。
- en: 'In the inheritance function, you''ll see the children only inherit the parent''s
    prototype. So own properties such as `this.lines` will not be set. Therefore,
    you need to have each child constructor call its `uber` in order to get the own
    properties, for example:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在继承函数中，你会看到子类只继承父类的原型。因此，像`this.lines`这样的自有属性将不会被设置。因此，你需要每个子类构造函数调用它的`uber`以获取自有属性，例如：
- en: '[PRE72]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Another nice-to-have feature is carrying over the prototype properties already
    added to the child. This allows the child to inherit first and then add more customizations
    or the other way around as well, which is just a little more convenient.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个很好的特性是继承已经添加到子类的原型属性。这允许子类首先继承，然后添加更多自定义或反之亦然，这要方便一些。
- en: '[PRE73]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Everything about `Shape()`, `Line()`, and `Point()` stays the same. The changes
    are in the children only:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Shape()`、`Line()`和`Point()`的所有内容都保持不变。变化只发生在子类上：'
- en: '[PRE74]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Inheritance:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 继承：
- en: '[PRE75]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Testing:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE76]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Testing that `instanceof` is correct:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试`instanceof`是否正确：
- en: '[PRE77]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `children` arrays:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`children`数组：'
- en: '[PRE78]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And uber looks ok too:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而uber看起来也不错：
- en: '[PRE79]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Calling `isPrototypeOf()` also returns expected results:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用`isPrototypeOf()`也会返回预期的结果：
- en: '[PRE80]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The full code is available at [http://www.phpied.com/files/canvas/index2.html](http://www.phpied.com/files/canvas/index2.html),
    together with the additional `Kite()`, `Circle()`, and so on from the previous
    exercise.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整代码可在[http://www.phpied.com/files/canvas/index2.html](http://www.phpied.com/files/canvas/index2.html)找到，包括前面练习中的`Kite()`、`Circle()`等。
- en: Chapter 7, The Browser Environment
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章，浏览器环境
- en: 'Lets practice the following exercise:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习以下练习：
- en: Exercises
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'The title clock program is as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题时钟程序如下：
- en: '[PRE81]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To animate resizing of a 200 x 200 pop up to 400 x 400, use the following code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将200 x 200的弹出窗口动画调整为400 x 400，请使用以下代码：
- en: '[PRE82]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Every 100 ms (1/10th of a second) the pop-up size increases by five pixels.
    You keep a reference to the interval `i` so you can clear it once done. The variable
    `size` tracks the pop-up size (and why not keep it private inside a closure).
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每100毫秒（1/10秒）弹出窗口的大小增加5像素。你保留对间隔`i`的引用，以便完成后可以清除它。变量`size`跟踪弹出窗口的大小（为什么不将其保留在闭包内部作为私有变量呢）。
- en: 'The earthquake program is as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地震程序如下：
- en: '[PRE83]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Try all of them, but using `requestAnimationFrame()` instead of `setInterval()`.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试所有这些，但使用 `requestAnimationFrame()` 而不是 `setInterval()`。
- en: 'A different `walkDOM()` with a callback is as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有回调函数的不同的 `walkDOM()` 如下所示：
- en: '[PRE84]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Testing:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE85]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To remove content and clean up functions, use the following code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除内容并清理函数，请使用以下代码：
- en: '[PRE86]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Testing:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE87]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'To include scripts dynamically, use the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要动态包含脚本，请使用以下代码：
- en: '[PRE88]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Testing:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE89]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**Events**: The event utility program is as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件**：事件实用程序如下所示：'
- en: '[PRE90]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**Testing**: Go to any page with links, execute the following, and then click
    any link:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**测试**：访问任何带有链接的页面，执行以下操作，然后点击任何链接：'
- en: '[PRE91]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Move a `div` around with the keyboard using the following code:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码通过键盘移动 `div`：
- en: '[PRE92]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Your own Ajax utility:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您自己的Ajax工具：
- en: '[PRE93]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'When testing, remember that same origin restrictions apply, so you have to
    be on the same domain. You can go to [http://www.phpied.com/files/jinc/](http://www.phpied.com/files/jinc/),
    which is a directory listing and then test in the console:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在测试时，请记住同源限制适用，因此您必须在同一域名下。您可以访问 [http://www.phpied.com/files/jinc/](http://www.phpied.com/files/jinc/)，这是一个目录列表，然后在控制台中测试：
- en: '[PRE94]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The result of the two is the same, but if you look into the **Network** tab
    of the Web Inspector, you can see that the second is indeed a `POST` request with
    a body.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个的结果是相同的，但如果您查看网络检查器的 **网络** 选项卡，您可以看到第二个确实是一个带有主体的 `POST` 请求。
