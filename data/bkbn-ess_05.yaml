- en: Chapter 5. Adding and Modifying Elements with Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用视图添加和修改元素
- en: 'In this chapter, we''ll take a look at how to do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Create new `View` classes and instances
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的`View`类和实例
- en: Use Views to render DOM elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图渲染DOM元素
- en: Connect Views to Models and Collections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将视图连接到模型和集合
- en: Respond to DOM events using Views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图响应DOM事件
- en: Decide the rendering style(s) that best fits your project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定最适合您项目的渲染样式
- en: Views are the core of Backbone-powered sites
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图是Backbone网站的核心
- en: While data is certainly important in any application, you can't have an application
    without a user interface at all. On the web, this means that you have a combination
    of DOM elements (to display information to the user) and event handlers (to receive
    input from the user). In Backbone, both of these things are managed by Views;
    in fact, it's only fair to say that Views pretty much control all the input and
    output on a Backbone-powered site.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据在任何应用程序中都很重要，但没有用户界面的应用程序是不完整的。在网络上，这意味着您有一个DOM元素的组合（用于向用户显示信息）和事件处理器（用于接收用户的输入）。在Backbone中，这两者都由视图管理；事实上，可以说视图几乎控制了Backbone网站上的所有输入和输出。
- en: 'Just as Models wrap an `attributes` object and Collections wrap a `models`
    array, `Views` wrap a DOM element inside a property called `el`. Unlike attributes
    and models, however, `el` is not hidden, and Backbone doesn''t watch it for changes,
    so there''s nothing wrong with referencing a View''s `el` directly:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如模型封装一个`attributes`对象和集合封装一个`models`数组一样，`Views`在名为`el`的属性中封装一个DOM元素。然而，与属性和模型不同的是，`el`不是隐藏的，Backbone不会监视其变化，因此直接引用视图的`el`是没有问题的：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To create a new `View` subclass, simply extend `Backbone.View` in the same
    way as you created new `Model` and `Collection` subclasses, as shown here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的`View`子类，只需像创建新的`Model`和`Collection`子类一样扩展`Backbone.View`，如下所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instantiating Views
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化视图
- en: 'As we mentioned in [Chapter 2](part0021.xhtml#aid-K0RQ1 "Chapter 2. Object-Oriented
    JavaScript with Backbone Classes"), *Object-oriented JavaScript with Backbone
    Classes*, Views take only a single `options` argument when instantiated. The most
    important part of these options is the `el` property, which defines the DOM element
    that the View will wrap as its `el`. A View''s `el` option can be defined in one
    of the following three ways:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](part0021.xhtml#aid-K0RQ1 "第2章。使用Backbone类的面向对象JavaScript")中提到的，*使用Backbone类的面向对象JavaScript*，视图在实例化时只接受一个`options`参数。这些选项中最重要的部分是`el`属性，它定义了视图将封装为其`el`的DOM元素。视图的`el`选项可以通过以下三种方式之一定义：
- en: 'HTML (`new Backbone.View ({el: <div id=''foo''></div>})`)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'HTML（`new Backbone.View ({el: <div id=''foo''></div>})`）'
- en: 'jQuery Selector (`new Backbone.View ({el: ''#foo''})`)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jQuery选择器（`new Backbone.View ({el: ''#foo''})`）'
- en: 'DOM element (`new Backbone.View ({el: document.getElementById(''foo'')})`)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DOM元素（`new Backbone.View ({el: document.getElementById(''foo'')})`）'
- en: 'You can also choose not to provide an `el` option, in which case Backbone will
    create the View''s `el` option for you. By default, Backbone will simply create
    an empty `DIV` element (`<div></div>`), although you can change this by providing
    other options when you create your view. You can provide the following options:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以选择不提供`el`选项，在这种情况下，Backbone将为您创建视图的`el`选项。默认情况下，Backbone将简单地创建一个空的`DIV`元素（`<div></div>`），尽管您可以在创建视图时提供其他选项来更改这一点。您可以提供以下选项：
- en: '`tagName`: This changes the generated elements'' tag from `div` to the specified
    value'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tagName`：这更改了生成的元素的标签从`div`到指定的值'
- en: '`className`: This specifies the HTML `class` attribute that the element should
    have'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`className`：这指定了元素应该具有的HTML `class`属性'
- en: '`id`: This specifies the HTML `id` attribute that the element should have'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这指定了元素应该具有的HTML `id`属性'
- en: '`attributes`: This specifies the HTML attributes that the element should have'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes`：这指定了元素应该具有的HTML属性'
- en: Technically, you can specify both the class and ID of a View's element using
    the `attributes` option, but because they are important to the definition of a
    View, Backbone provides separate `id` and `className` options.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，您可以使用`attributes`选项同时指定视图元素的类和ID，但由于它们对于视图的定义非常重要，Backbone提供了单独的`id`和`className`选项。
- en: 'Instead of defining the preceding options when you instantiate your View, you
    can also choose to define them in a `View` class. For instance, if you want to
    create a `View` class that generates a `<form>` element with a class of `nifty`,
    you should do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化视图时，除了定义前面的选项外，你也可以选择在 `View` 类中定义它们。例如，如果你想创建一个生成具有 `nifty` 类的 `<form>`
    元素的 `View` 类，你应该这样做：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rendering view content
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染视图内容
- en: While Views can take an `el` option to define their initial element, it is rare
    for them to leave this `el` option unchanged. For instance, a `list` View might
    take an `<ul>` element as its `el` option but then fill this list with the `<li>`
    elements (possibly using data from a Collection). In Backbone, this generation
    of inner HTML is done inside the View's `render` method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Views 可以通过 `el` 选项来定义它们的初始元素，但它们很少会保持这个 `el` 选项不变。例如，一个 `list` 视图可能会将 `<ul>`
    元素作为其 `el` 选项，然后填充这个列表的 `<li>` 元素（可能使用来自集合的数据）。在 Backbone 中，这种内部 HTML 的生成是在视图的
    `render` 方法中完成的。
- en: 'However, when you try to use the `render` method of an unmodified View, you
    quickly notice a problem with Backbone''s default implementation, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你尝试使用未修改视图的 `render` 方法时，你很快就会注意到 Backbone 默认实现的问题，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the default `render` method doesn't actually render anything.
    This is because different Views can have entirely different content, so it doesn't
    make sense for Backbone to provide only one way of generating that content. Instead,
    Backbone leaves the implementation of your View's `render` method entirely up
    to you.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，默认的 `render` 方法实际上并没有渲染任何内容。这是因为不同的视图可能具有完全不同的内容，所以 Backbone 提供仅一种生成内容的方式并不合理。相反，Backbone
    完全将视图的 `render` 方法的实现留给了你。
- en: Later on, in this chapter, we'll consider the various strategies for how you
    might want to implement `render` methods on your site, but before we get to that,
    let's first examine how to connect Models and Collections to Views as well as
    how Views handle event bindings.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将考虑你可能在网站上实现 `render` 方法的各种策略，但在我们到达那里之前，让我们首先检查如何将模型和集合连接到视图，以及视图如何处理事件绑定。
- en: Connecting Views to Models and Collections
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将视图连接到模型和集合
- en: 'When a View is created, it can take two important options: `Model` and `Collection`.
    Both of these options are simple property options, which is to say that Backbone
    doesn''t actually do anything with them other than add them as properties to the
    View. Even so, these properties can be very useful when you want to display or
    edit data that you''ve previously generated. For instance, if you want to associate
    a View with a `book` Model that you have created, you can do the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建视图时，它可以接受两个重要的选项：`Model` 和 `Collection`。这两个选项都是简单的属性选项，也就是说 Backbone 实际上并没有对它们做任何事情，只是将它们作为属性添加到视图中。即便如此，这些属性在你想要显示或编辑之前生成的数据时非常有用。例如，如果你想将一个视图与一个你创建的
    `book` 模型关联起来，你可以这样做：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you write the `render` method for your `book` View, you can use that Model
    in order to get the data to generate the appropriate HTML. For instance, here''s
    a simple implementation of `render`, loosely borrowed from the Backbone documentation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为你的 `book` 视图编写 `render` 方法时，你可以使用该模型来获取生成适当 HTML 所需的数据。例如，以下是一个简单的 `render`
    实现，借鉴了 Backbone 文档的内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the imaginary `render` method passes the output of the Model's
    `toJSON` to the View's templating system, presumably so that the templating system
    can use the Model's attributes to render the View.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，假想的 `render` 方法将模型的 `toJSON` 方法的输出传递给视图的模板系统，这可能是为了让模板系统可以使用模型的属性来渲染视图。
- en: Accessing a View's el element
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问视图的 `el` 元素
- en: 'Once you''ve created a View, you can access the element that it wraps at any
    time by referring to its `el` property. You can also access a jQuery-wrapped version
    of the same element by referring to the View''s `$el` property. Take an example
    of the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个视图，你可以通过引用其 `el` 属性在任何时候访问它所包裹的元素。你还可以通过引用视图的 `$el` 属性来访问相同元素的 jQuery
    包装版本。以下是一个代码示例：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Backbone also provides another convenient shortcut when you want to access
    elements inside a View''s element: the `$` method. When you use this method, it''s
    effectively the same as calling jQuery''s `find` method from the View''s element.
    Because the search for the element is localized to only look through the View''s
    `el` element and not through the entire page''s DOM, it will perform much better
    than a global jQuery selection.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 还提供了一个方便的快捷方式，当你想要访问视图元素内部的元素时：`$` 方法。当你使用这个方法时，它实际上等同于从视图元素调用 jQuery
    的 `find` 方法。因为元素搜索仅限于仅查看视图的 `el` 元素，而不是整个页面的 DOM，所以它的性能将远远优于全局 jQuery 选择。
- en: 'For example, if you create a View of a `<form>` element with an `<input>` element
    inside it, you can use the View''s `$` method to access the `<input>` element
    , as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你创建了一个包含 `<input>` 元素的 `<form>` 元素的视图，你可以使用视图的 `$` 方法来访问 `<input>` 元素，如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A brief aside on $Variable names
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单谈谈变量命名问题
- en: 'When working with jQuery objects in Backbone (or even just in JavaScript, in
    general), it may often be difficult to tell whether a given variable refers to
    a `View` element or to its `el` element. In order to avoid confusion, many programmers
    (including the authors of both Backbone and jQuery) preface any variable that
    points to a jQuery object with the `$` symbol, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Backbone（或更一般地，在 JavaScript 中）中处理 jQuery 对象时，可能很难判断给定的变量是指 `View` 元素还是其 `el`
    元素。为了避免混淆，许多程序员（包括 Backbone 和 jQuery 的作者）在指向 jQuery 对象的任何变量前都加上 `$` 符号，如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While this practice is certainly not necessary to use Backbone, adopting it
    will likely save you from confusion in the future.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种做法在 Backbone 中并非必需，但采用它可能会让你在未来避免困惑。
- en: Handling events
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理
- en: 'While the Views we''ve described so far are great for creating and/or wrapping
    existing HTML elements, they''re not very good at responding when a user interacts
    with them. One approach to solve this problem will be to hook up event handlers
    inside a View''s `initialize` method, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们之前描述的视图非常适合创建和/或包装现有的 HTML 元素，但它们在响应用户交互方面并不很好。解决这个问题的方法之一是在视图的 `initialize`
    方法内部连接事件处理程序，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, there are two problems with this approach, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种做法有两个问题，如下所述：
- en: It's not terribly readable
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的可读性并不高
- en: We have to bind the event handler when we create it so that we can still reference
    `this` from inside it
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须在创建事件处理程序时绑定它，这样我们才能从其中引用 `this`
- en: 'Luckily, Backbone offers a better way, in the form of an optional property
    called `events`. We can use this `events` property to simplify our previous example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Backbone 提供了一种更好的方法，形式为一个可选属性，称为 `events`。我们可以使用这个 `events` 属性来简化之前的示例：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, using the `events` property saves us from even having to write
    an `initialize` method at all, while at the same time, it also takes care of binding
    the `handleClick` event handler to the View itself. In addition, by defining the
    event handlers in this way, we let Backbone know about them so that it can manage
    to remove or rebind them as needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 `events` 属性甚至可以让我们不必编写任何 `initialize` 方法，同时它还负责将 `handleClick` 事件处理程序绑定到视图本身。此外，通过以这种方式定义事件处理程序，我们让
    Backbone 了解它们，以便它可以根据需要管理它们的移除或重新绑定。
- en: When you instantiate a View, Backbone calls a `delegateEvents` method, which
    checks the `events` property, binds all the handlers found in it, and then creates
    listeners for the appropriate events using jQuery. There is also a corresponding
    `undelegateEvents` method, which can be used to remove all the event handlers.
    Normally, you won't need to call either of these methods yourself because Backbone
    will call them for you.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化一个视图时，Backbone 会调用一个 `delegateEvents` 方法，该方法检查 `events` 属性，绑定其中找到的所有处理程序，然后使用
    jQuery 创建适当事件的监听器。还有一个相应的 `undelegateEvents` 方法，可以用来移除所有事件处理程序。通常，你不需要自己调用这些方法，因为
    Backbone 会为你调用它们。
- en: However, if you change a View's `el` element without telling Backbone (for example,
    `yourView.el = $('#foo')[0]`), Backbone won't know that it needs to hook up the
    events to the new element, and you will have to call `delegateEvents` yourself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在未通知 Backbone 的情况下更改视图的 `el` 元素（例如，`yourView.el = $('#foo')[0]`），Backbone
    就不会知道它需要将事件连接到新元素，你将不得不自己调用 `delegateEvents`。
- en: 'Alternatively, instead of changing a View''s `el` element manually and then
    calling `delegateEvents` afterwards, you can use a View''s `setElement` method
    to do both at the same time, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你不必手动更改视图的 `el` 元素，然后再调用 `delegateEvents`，你可以使用视图的 `setElement` 方法同时完成这两步，如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Rendering strategies
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染策略
- en: Now that we've covered all of View's capabilities, it's time to return to the
    question of how to render a View. Specifically, let's look at the main options
    available to you, which are explained in the sections that follow, when you overwrite
    the `render` method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了视图的所有功能，是时候回到如何渲染视图的问题了。具体来说，让我们看看当你重写 `render` 方法时，你可以选择的主要选项，这些选项将在接下来的章节中解释。
- en: Simple templating
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单模板
- en: 'The first, and perhaps the most obvious, approach for rendering is to use a
    simple, logic-less templating system. The `render` method provided in the Backbone
    documentation is a perfect example of this, as it relies on the Underscore library''s
    `template` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染的第一种，也许是最明显的方法，是使用一个简单、无逻辑的模板系统。Backbone 文档中提供的 `render` 方法是这种方法的完美示例，因为它依赖于
    Underscore 库的 `template` 方法：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `template` method takes a string, which contains one or more specially
    designated sections, and then combines this string with an object, filling in
    the designated sections with that object''s values. This is best explained with
    the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 方法接受一个字符串，该字符串包含一个或多个特别指定的部分，然后将这个字符串与一个对象组合起来，用该对象的值填充指定的部分。以下示例是最好的解释：'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While the `template` function works with any string and data source, when used
    as part of a Backbone View, it is typically used with an HTML string and a `Backbone.Model`
    data source. Underscore's `template` function lets us combine the two to easily
    create a `render` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `template` 函数可以与任何字符串和数据源一起使用，但当它作为 Backbone 视图的一部分使用时，通常与 HTML 字符串和 `Backbone.Model`
    数据源一起使用。Underscore 的 `template` 函数让我们能够将它们结合起来，轻松创建一个 `render` 方法。
- en: For instance, if you want to create a `<div>` tag with an `<h1>` tag inside
    containing an author's name and genre and then add an emphasis (in other words,
    an `<em>` tag) around the genre, you can create a `template` string with the desired
    HTML and placeholders for the first name, last name, and genre. We can then use
    the `_.` template to create a `template` function and then use this `template`
    function in a `render` method with an author Model's attributes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想创建一个包含一个 `<h1>` 标签的 `<div>` 标签，该标签内包含作者姓名和类型，并且围绕类型添加强调（换句话说，一个 `<em>`
    标签），你可以创建一个包含所需 HTML 和用于第一个名字、姓氏和类型的占位符的 `template` 字符串。然后我们可以使用 `_.` 模板创建一个 `template`
    函数，并在 `render` 方法中使用作者模型的属性调用这个 `template` 函数。
- en: 'Of course, as we mentioned in [Chapter 3](part0029.xhtml#aid-RL0A1 "Chapter 3. Accessing
    Server Data with Models"), *Accessing Server Data with Models*, it''s safer if
    we don''t access a Model''s attributes directly; so, we''ll want to use the Model''s
    `toJSON` method instead. Putting all of this together, we get the following block
    of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如我们在[第3章](part0029.xhtml#aid-RL0A1 "第3章。使用模型访问服务器数据")中提到的，*使用模型访问服务器数据*，如果我们不直接访问模型属性，会更安全；因此，我们将想要使用模型的
    `toJSON` 方法。将所有这些放在一起，我们得到以下代码块：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: One major advantage of this approach is that because our HTML is completely
    separated into a string, we can optionally choose to move it out into a separate
    file and then bring it in using jQuery or a dependency library, such as `Require.js`.
    HTML that is stored separately like this can be easier for a designer to work
    with, if you have such a person in your team.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个主要优点是，因为我们的 HTML 完全分离成一个字符串，我们可以选择将其移动到一个单独的文件中，然后使用 jQuery 或依赖库，如 `Require.js`
    带入。如果团队中有这样的设计师，以这种方式存储的 HTML 可以更容易地被设计师处理。
- en: Advanced templating
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级模板
- en: 'Instead of using Underscore''s `template` method, you can also employ one of
    the many quality third-party templating libraries available, such as Handlebars,
    Mustache, Hamljs, or Eco. All these libraries offer the same basic ability to
    combine a data object with a template string, but they also offer the possibility
    to include logic inside the template. For instance, here''s an example of a Handlebars
    template string that uses an `if` statement, which is based on a provided `isMale`
    data property, to select the correct gender pronoun inside a template:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Underscore的`template`方法外，您还可以使用许多高质量的第三方模板库之一，例如Handlebars、Mustache、Hamljs或Eco。所有这些库都提供了将数据对象与模板字符串结合的基本能力，但它们还提供了在模板中包含逻辑的可能性。例如，这里有一个Handlebars模板字符串的例子，它使用基于提供的`isMale`数据属性的`if`语句，在模板中选择正确的性别代词：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we use Handlebars'' `compile` method to turn that into a template, we can
    then use it just as we will use an Underscore template:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Handlebars的`compile`方法将其转换为模板，我们就可以像使用Underscore模板一样使用它：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ll discuss more about Handlebars in [Chapter 11](part0095.xhtml#aid-2QJ5E1
    "Chapter 11. (Not) Re-Inventing the Wheel – Utilizing Third-Party Libraries"),
    *(Not) Re-inventing the Wheel: Utilizing Third-Party Libraries* but the important
    thing to understand for now is that no matter which templating library you choose,
    you can easily incorporate it as part of your View''s `render` method. The difficult
    part is deciding whether or not you want to allow logic inside your templates
    and if so, how much.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](part0095.xhtml#aid-2QJ5E1 "第11章。（不）重新发明轮子 – 利用第三方库")中更详细地讨论Handlebars，*(不)重新发明轮子：利用第三方库*，但您现在需要理解的重要事情是，无论您选择哪个模板库，您都可以轻松地将它作为您视图的`render`方法的一部分。困难的部分是决定您是否想在模板中包含逻辑，如果是的话，包含多少。
- en: Logic-based
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于逻辑
- en: 'Instead of relying on templating libraries, another option is to use Backbone''s
    View logic, jQuery methods, and/or string concatenation to power your `render`
    methods. For instance, you can reimplement the preceding `AuthorView` without
    using templates at all:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了依赖模板库外，另一种选择是使用Backbone的View逻辑、jQuery方法以及/或字符串连接来驱动您的`render`方法。例如，您可以在不使用模板的情况下重新实现前面的`AuthorView`：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, there are both advantages and disadvantages to a purely logic-based
    approach. The main advantage, of course, is that we don't have to deal with a
    template at all. This means that we can see exactly what logic is being used,
    because nothing is hidden inside the template library's code. Also, there is no
    limit on this logic; you can do anything that you will normally do in JavaScript
    code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，纯逻辑方法既有优点也有缺点。当然，主要优点是我们根本不需要处理任何模板。这意味着我们可以清楚地看到正在使用的逻辑，因为模板库的代码中没有隐藏任何内容。此外，这种逻辑没有限制；您可以做任何在JavaScript代码中通常会做的事情。
- en: However, we also lost a good deal of readability by not using a template, and
    if we had a designer on our team who wanted to edit the HTML, they would find
    `that` code very difficult to work with. In the first version, they will see a
    familiar HTML structure, but in the second version, they will have to work with
    the JavaScript code even though they (probably) aren't familiar with programming.
    Yet another downside is that because we've mixed the logic with the HTML code,
    there's no way to store the HTML in a separate file, the way we can if it were
    a template.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于没有使用模板，我们也失去了一部分可读性，如果我们的团队中有设计师想要编辑HTML，他们会发现`that`代码非常难以处理。在第一个版本中，他们会看到熟悉的HTML结构，但在第二个版本中，他们即使（可能）不熟悉编程，也必须与JavaScript代码打交道。另一个缺点是，由于我们将逻辑与HTML代码混合在一起，我们无法将HTML存储在单独的文件中，就像它是模板一样。
- en: The combined approach
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 综合方法
- en: All three preceding approaches have advantages and disadvantages, and rather
    than settling for just one, you can choose to combine some of them instead. There's
    no reason why, for instance, you can't use a templating system (either Underscore's
    for simplicity or an external one for power) and then switch to using logic when
    you want to do something that doesn't fit neatly into a template.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前三种方法都有优点和缺点，您可以选择结合其中一些方法，而不是仅仅满足于一种。例如，您没有理由不能使用模板系统（为了简单起见是Underscore的，为了强大是外部的），然后在需要做不适合模板的事情时切换到使用逻辑。
- en: 'For example, let''s say you want to render a `<ul>` with a `class` HTML attribute
    derived from the attributes of a Model—this sounds like something that will be
    easier with JavaScript logic. However, let''s say you also want this `<ul>` to
    contain `<li>` elements with text based on a template and filled in with the attributes
    of Models in a Collection; that sounds like something we can best handle with
    a template. Luckily, there is nothing stopping you from combining the two approaches,
    as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想要渲染一个带有由模型属性派生的`class` HTML属性的`<ul>`，这似乎是使用JavaScript逻辑更容易做到的事情。然而，假设你还想让这个`<ul>`包含基于模板的文本的`<li>`元素，并用集合中模型的属性填充；这似乎是我们最好用模板来处理的事情。幸运的是，没有任何东西阻止你结合这两种方法，如下所示：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, mixing approaches means that you won't always get the full benefits
    of both. The most notable issue will be that any HTML that you render via Backbone's
    Views or other JavaScript logic won't be accessible to a non-programming designer.
    If you don't have such a role in your team, then this limitation won't bother
    you, but if you do, you should probably try to keep as much HTML inside templates
    as possible.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，混合方法意味着你不会总是得到两种方法的所有好处。最明显的问题将是，通过Backbone的视图或其他JavaScript逻辑渲染的任何HTML将无法被非编程设计师访问。如果你的团队中没有这样的角色，那么这种限制不会让你烦恼，但如果你有，你可能应该尽量将尽可能多的HTML放在模板中。
- en: Other render considerations
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他渲染考虑因素
- en: In addition to deciding whether you can rely on templates and how much you can
    rely on them in your render methods, there are a few other things that you need
    to consider when writing them. None of these choices are completely binary, but
    you should strive for as consistent an approach as possible. This means that the
    real question isn't about which one you should choose, as it is about when you
    will choose one over the other. Ultimately, a consistent strategy will make it
    such that both you and your co-workers don't have to think in order to decide
    which approach to use when writing new `render` methods or editing existing ones.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了决定你能在渲染方法中依赖模板以及你能依赖多少之外，还有一些其他的事情在你编写它们时需要考虑。这些选择都不是完全二元的，但你应努力追求尽可能一致的方法。这意味着真正的疑问不在于你应该选择哪一个，而在于你将在何时选择一个而不是另一个。最终，一个一致的战略将使得你和你的同事在编写新的`render`方法或编辑现有的方法时不需要思考应该使用哪种方法。
- en: Child views
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子视图
- en: 'Very often, in Backbone, you will want to create one View for a container element,
    such as a `<ul>` element, and another View for its child elements, such as its
    `<li>` element. When creating these child Views, you can either choose to have
    a child View create the child elements, or you can have the parent View create
    them and pass a jQuery selector as the child View''s `el` element, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Backbone中，你通常会想要为容器元素（如`<ul>`元素）创建一个视图，并为它的子元素（如`<li>`元素）创建另一个视图。在创建这些子视图时，你可以选择让子视图创建子元素，或者你可以让父视图创建它们并将一个jQuery选择器作为子视图的`el`元素传递，如下所示：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The primary advantage of generating the child element in the View is encapsulation.
    By taking this approach, you can keep all the logic related to the child element
    within the child View. This will make the code easier to work with, as you won't
    have to think about both the child and parent Views at the same time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中生成子元素的主要优势是封装。通过采取这种方法，你可以将所有与子元素相关的逻辑都保持在子视图中。这将使得代码更容易处理，因为你不需要同时考虑子视图和父视图。
- en: On the other hand, when you are using templates, it may be inconvenient to split
    the template into parts in order to render the overall container element. Also,
    rendering the child elements in the parent view provides a good separation between
    DOM-generating Views and purely event handling Views, which can help you to sort
    your logic better.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你使用模板时，可能不方便将模板分成几部分来渲染整体容器元素。此外，在父视图中渲染子元素可以在DOM生成视图和纯粹的事件处理视图之间提供良好的分离，这可以帮助你更好地整理逻辑。
- en: Neither approach has to be taken to the extreme. While you can have a single
    page View with a single template for all your content or you can have every single
    child View generate its DOM elements, you can also choose to have a mix of approaches
    in your Views. In fact, unless you want to have a single page template for a top-level
    render, which generates the entire DOM, you will probably want to take a combined
    approach, so the real question is how much do you want to rely on each technique?
    The more you rely on the parent View, the easier it is to see the big picture;
    but the more you rely on DOM generation in child Views, the easier it will be
    to encapsulate your logic.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都不必走向极端。虽然你可以有一个单页View，其中包含所有内容的单个模板，或者你可以让每个子View生成其DOM元素，但你也可以选择在你的Views中采用混合方法。实际上，除非你想要一个用于顶级渲染的单页模板，该模板生成整个DOM，否则你可能想要采取结合的方法，所以真正的问题是你希望依赖每种技术的程度有多大？你越依赖父View，就越容易看到大局；但如果你更多地依赖子View中的DOM生成，就越容易封装你的逻辑。
- en: Repeatable versus one-time renders
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可重复渲染与一次性渲染
- en: Another thing that you'll want to consider is whether to design your `render`
    methods to be rendered once (usually when the View is first created), or whether
    you want to be able to call your `render` method multiple times in response to
    changes. The render methods that are designed to render only once are the simplest
    to write and the simplest to work with; when something needs to change with your
    View's DOM element, you simply call the View's `render` method again and the DOM
    gets updated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑是否设计你的`render`方法只渲染一次（通常在View首次创建时），或者是否希望能够在响应变化时多次调用你的`render`方法。只设计为渲染一次的`render`方法编写和操作起来最简单；当你的View的DOM元素需要更改时，你只需再次调用View的`render`方法，DOM就会更新。
- en: However, this approach can also lead to performance issues, particularly if
    the View involved contains a great number of child Views. To avoid this, you might
    instead want to write `render` methods that don't blindly replace their content
    but instead update them in response to changes. For instance, if you have a `<ul>`
    elements where you want some of the child `<li>` elements to appear or disappear
    in response to user actions, you might want to have your `render` method check
    whether the `<li>` elements already exist first and then simply apply changes
    to their display style rather than rebuilding the entire `<ul>` from scratch every
    time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也可能导致性能问题，尤其是如果涉及的View包含大量子View。为了避免这种情况，你可能想要编写`render`方法，而不是盲目地替换其内容，而是根据变化来更新它们。例如，如果你有一个`<ul>`元素，其中一些子`<li>`元素需要根据用户操作出现或消失，你可能希望你的`render`方法首先检查`<li>`元素是否已经存在，然后简单地应用更改它们的显示样式，而不是每次都从头开始重建整个`<ul>`。
- en: Again, you'll probably want to mix the two approaches based on the type of View
    you are writing. If performance is a high priority for you, then you'll likely
    want to think carefully about how you can reuse previously-generated DOM elements
    in your `render` methods. On the other hand, if performance is less important,
    designing your `render` method for one-time DOM generation will keep its logic
    a lot simpler. Also, if performance problems crop up, you can always change the
    `render` method in question to reuse existing elements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你可能根据你编写的View类型混合两种方法。如果你将性能视为高优先级，那么你可能会仔细思考如何在`render`方法中重用之前生成的DOM元素。另一方面，如果性能不太重要，为一次性DOM生成设计你的`render`方法将使它的逻辑更加简单。此外，如果出现性能问题，你总是可以更改相关的`render`方法以重用现有元素。
- en: Return value – this or this.$el
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值 – 这个或这个.$el
- en: 'The sample `render` method from the Backbone documentation returns `this` when
    it completes. This approach allows you to easily access the `el` property of the
    render by simply calling it on the `render` method''s return value, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone文档中的示例`render`方法在完成时返回`this`。这种方法允许你通过简单地调用`render`方法的返回值来轻松访问`el`属性，如下所示：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, you can make it even easier to access the View''s `el` by returning
    that `el` instead of this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以让它更容易访问View的`el`，通过返回那个`el`而不是这个：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The downside of returning the `$el` from a `render` method is that you can
    no longer chain other View methods from the return value of the render method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从`render`方法返回`$el`的缺点是，你不能再从`render`方法的返回值链式调用其他View方法：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, what this choice really comes down to is how much you plan to post-render
    your Views and how much you plan to call those post-rendering methods from outside
    the View itself (if you call them from within the render method, their return
    values are irrelevant). If you're not sure, the safest bet is to follow the `render`
    method in Backbone's documentation and return `this`, as it offers maximum flexibility
    (at the cost of a slightly less-concise code).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个选择实际上取决于你计划对视图进行多少次后渲染以及你计划从视图外部调用多少次这些后渲染方法（如果你在渲染方法内部调用它们，它们的返回值是不相关的）。如果你不确定，最安全的做法是遵循
    Backbone 文档中的 `render` 方法，并返回 `this`，因为它提供了最大的灵活性（代价是代码稍微不那么简洁）。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Whatever you choose, you'll likely want to keep it consistent across all your
    Views. If you don't, you will find yourself constantly having to look up a View's
    `render` method every time you want to use it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择什么，你可能会希望在整个视图之间保持一致性。如果不这样做，你将发现自己每次想要使用视图的 `render` 方法时，都需要不断查找。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored Backbone's `View` class. You learned how to create
    DOM elements by instantiating a View as well as how to pass in existing elements
    to new Views. You also learned how to use Views to hook up event handlers on the
    View's `el` and how to remove/reattach these handlers to the `undelegate` and
    `delegate` methods. Finally, we considered how Backbone's (deliberately) empty
    implementation of the `render` method leaves us many different options for how
    to implement our own `render` method and what factors influence those choices.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Backbone 的 `View` 类。你学习了如何通过实例化视图来创建 DOM 元素，以及如何将现有元素传递给新的视图。你还学习了如何使用视图在视图的
    `el` 上设置事件处理器，以及如何使用 `undelegate` 和 `delegate` 方法移除/重新附加这些处理器。最后，我们考虑了 Backbone（故意）为
    `render` 方法提供的空实现，这为我们提供了许多不同的选项来实现自己的 `render` 方法，以及哪些因素影响了这些选择。
- en: In the next chapter, we'll take a look at Backbone's final class, the `Router`
    class. This class lets us simulate traditional web pages, only using Views instead
    of separate HTML files to generate those pages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Backbone 的最后一个类，即 `Router` 类。这个类允许我们仅使用视图而不是单独的 HTML 文件来模拟传统网页。
