- en: Chapter 5. Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 控制器
- en: 'In the previous chapter, we discussed how templates in Ember.js are used to
    present data to users. We also covered how user interactions, in our applications,
    are easily made possible through these templates. We noted that templates serve
    their purpose by communicating with controllers. This chapter will expound on
    this, and will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了Ember.js中模板如何用于向用户展示数据。我们还介绍了如何通过这些模板在我们的应用程序中轻松实现用户交互。我们指出，模板通过与其控制器通信来发挥作用。本章将对此进行深入探讨，并涵盖以下主题：
- en: Defining controllers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义控制器
- en: Storing models and objects in controllers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制器中存储模型和对象
- en: Using object and array controllers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象和数组控制器
- en: Specifying controller dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定控制器依赖项
- en: Registering action handlers in controllers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制器中注册动作处理器
- en: State transitions in controllers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器中的状态转换
- en: Defining controllers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义控制器
- en: 'Just like route handlers, a controller can be defined by extending the `Ember.Controller`
    class, as shown in the following line of code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像路由处理器一样，可以通过扩展`Ember.Controller`类来定义控制器，如下面的代码行所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A defined controller can further be extended to create yet another new controller
    class:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进一步扩展已定义的控制器以创建另一个新的控制器类：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These controller classes can then be instantiated with the `create` method,
    as shown in the following examples:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制器类可以通过`create`方法进行实例化，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Just like objects, if we need to use mixins when instantiating controllers,
    we need to use the `createWithMixins` method instead:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对象一样，如果我们需要在实例化控制器时使用混入，我们需要使用`createWithMixins`方法：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is equivalent to the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下内容：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We rarely instantiate application controllers ourselves because Ember.js does
    it for us when needed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少自己实例化应用程序控制器，因为当需要时，Ember.js会为我们做这件事。
- en: Providing controllers with models
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向控制器提供模型
- en: 'Before we proceed, let''s recap and see how data is loaded and stored in controllers.
    Most of the applications we''ll build will communicate with REST endpoints, and
    therefore, Ember.js comes with features that make the creation of such applications
    trivial. In [Chapter 3](part0029_split_000.html#page "Chapter 3. Routing and State
    Management"), *Routing and State Management*, we learned that data can be loaded
    from the server in an asynchronous fashion via a route handler''s `model` hook.
    For example, let''s define a blog post route that loads a particular blog post
    from our server. First, we''ll define our application''s router as:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们回顾一下数据在控制器中的加载和存储方式。我们将构建的大多数应用程序都将与REST端点进行通信，因此，Ember.js自带了一些使创建此类应用程序变得简单的功能。在[第3章](part0029_split_000.html#page
    "第3章. 路由和状态管理")中，我们学习了数据可以通过路由处理器的`model`钩子以异步方式从服务器加载。例如，让我们定义一个博客文章路由，从我们的服务器加载特定的博客文章。首先，我们将定义我们的应用程序的路由如下：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We just defined a post resource that will handle requests to a post''s detail
    page, as shown in the following line of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一个将处理对文章详情页请求的资源，如下面的代码行所示：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a user visits a post''s path, say `/post/100`, Ember.js expects that the
    post route handler will define a `model` hook that will load the matching post
    from the server. Here''s an example that illustrates this using jQuery:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户访问文章的路径，比如`/post/100`，Ember.js期望文章路由处理器将定义一个`model`钩子，该钩子将从服务器加载匹配的文章。以下是一个使用jQuery说明此点的示例：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding example, the handler''s `model` hook took an `options` object
    that contained the post''s ID. This ID was then used to load the matching post
    from the server using jQuery''s `getJSON()` method that returned a promise with
    which our application resolved on load. Once resolved, Ember.js expected this
    route to define a `setupController` hook that stored the resolved post into the
    corresponding controller. This is the default behavior that is implemented as
    the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，处理器的`model`钩子接受一个包含文章ID的`options`对象。然后，使用jQuery的`getJSON()`方法使用此ID从服务器加载匹配的文章，该方法返回一个承诺，我们的应用程序在加载时解决。一旦解决，Ember.js期望此路由定义一个`setupController`钩子，将解决的文章存储到相应的控制器中。这是作为以下代码实现的默认行为：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `setupController` hook receives two arguments: an instance of the corresponding
    controller and the resolved model. This model is stored inside the controller''s
    `model` property. Note that this is just the default implementation; we can store
    the model in any other desired property or controller.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupController` 钩子接收两个参数：相应控制器的实例和解析的模型。此模型存储在控制器的 `model` 属性中。请注意，这只是默认实现；我们可以将模型存储在任何其他所需的属性或控制器中。'
- en: Rendering dynamic data from controllers
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从控制器渲染动态数据
- en: 'After loading data from the server, the controller''s purpose is to make this
    model available to the corresponding template for display. These templates will
    then register bindings to the properties of the provided model and send updates
    of changes made to these properties using form controls. Since controllers are
    an extension of `Ember.Object`, they realize better management of the evented
    nature of browser environments using the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在从服务器加载数据后，控制器的作用是使这个模型可用于相应的模板进行显示。然后这些模板将注册对提供模型属性的绑定，并使用表单控件发送对这些属性所做的更改的更新。由于控制器是
    `Ember.Object` 的扩展，它们通过以下方式实现了对浏览器环境事件特性的更好管理：
- en: Properties
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Computed properties
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性
- en: Observables
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察者
- en: Properties
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'Templates can display properties of bound controllers using expressions. For
    example, the post template in the previous example will display the loaded post
    as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以使用表达式显示绑定控制器的属性。例如，在先前的示例中，帖子模板将显示已加载的帖子如下：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the post loads, the rendered post template will resemble the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当帖子加载时，渲染的帖子模板将类似于以下内容：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the post''s title changes at a later point in time, the title portion of
    the template will be rerendered to display the new title, as shown:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果帖子标题在以后某个时间点发生变化，模板的标题部分将被重新渲染以显示新的标题，如下所示：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Templates can also push updates back to controllers. This is typically done
    using HTML-form elements. Ember provides Handlebars expressions that abstract
    the use of these controls to create two-way bindings, as we discussed in the previous
    chapter. To illustrate this, let''s add a new route in our blog application, which
    will enable the blog''s admin to add a new post entry, as shown in the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模板还可以将更新推回控制器。这通常是通过 HTML 表单元素完成的。Ember 提供了 Handlebars 表达式，用于抽象这些控件的使用以创建双向绑定，正如我们在上一章中讨论的那样。为了说明这一点，让我们在我们的博客应用程序中添加一个新的路由，这将允许博客的管理员添加一个新的帖子条目，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The admin will of course create the new post on the `/posts/new` page. Ember.js
    will expect a `posts/new` template for this route, which will resemble the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员当然会在 `/posts/new` 页面上创建新的帖子。Ember.js 会期望为这个路由提供一个 `posts/new` 模板，其代码如下：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `PostsNewRoute` handler will also need to provide the model for the template
    that will serve as its context. As you might have guessed, its `model` hook will
    return a new post object to be updated, as shown in the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostsNewRoute` 处理器还需要为将作为其上下文的模板提供模型。正如你可能已经猜到的，它的 `model` 钩子将返回一个新帖子对象以供更新，如下面的示例所示：'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `model` hook returns an Ember.js object that will serve as the post to be
    created by the admin. Since this is common practice, we'll learn how to use `ember-data`,
    a higher level library that helps in the definition and creation of such models
    in a later chapter. Any update to both text controls will update the new post,
    thanks to the two-way bindings.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`model` 钩子返回一个 Ember.js 对象，该对象将作为管理员要创建的帖子。由于这是常见做法，我们将在后面的章节中学习如何使用 `ember-data`，这是一个高级库，有助于定义和创建此类模型。由于双向绑定，任何对文本控件的更新都将更新新帖子。'
- en: Computed properties
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算属性
- en: 'Computed properties are functions that evaluate to properties and depend on
    other properties. We can use computed properties to create states and properties
    that depend on other properties. This is especially helpful when we want to obtain
    states through aggregation or any form of map reduce. Here''s a use case example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性是返回属性并依赖于其他属性的函数。我们可以使用计算属性创建依赖于其他属性的 states 和 properties。这在我们需要通过聚合或任何形式的
    map reduce 获取状态时特别有用。以下是一个用例示例：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, the template is able to display the user''s `fullName` based
    on their first and last names. We already mentioned that such an implementation
    is impossible to accomplish in the template layer alone, as shown in the following
    example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，模板能够根据用户的第一个和最后一个名字显示用户的 `fullName`。我们之前已经提到，仅使用模板层是无法完成这种实现的，如下面的示例所示：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'One thing to note is that instances of objects are never set on a class definition
    unless they''re meant to be static. For example, if the template is a form that
    updates the values of the model, we might be tempted to provide the default model
    of the controller as:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，除非对象实例被设计为静态的，否则它们永远不会在类定义上设置。例如，如果模板是一个更新模型值的表单，我们可能会倾向于提供控制器的默认模型为：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding implementation can lead to updates not being isolated as intended.
    Here''s another example of a search feature that can be added in our blog application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前实现的代码可能导致更新没有像预期那样被隔离。以下是我们博客应用中可以添加的另一个搜索功能示例：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example contains some features that we already discussed. If a user visits
    the search page at `say/search`, they will be presented with a search input that
    automatically updates the search controller's `queryTerm` property on input. As
    you might notice, this controller's `results` property will be recalculated because
    it depends on the controller's `queryTerm` property.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包含一些我们之前讨论过的功能。如果用户访问`say/search`搜索页面，他们将看到一个搜索输入框，该输入框会自动在输入时更新搜索控制器的`queryTerm`属性。正如你可能注意到的，这个控制器的`results`属性将重新计算，因为它依赖于控制器的`queryTerm`属性。
- en: 'One feature that we introduced is the ability of the controller to reference
    other controllers. We will discuss this in a later section, but the important
    thing to note is that we are able to generate results by filtering the model of
    the `posts` controller. The search template automatically redisplays results as
    the user types along. This example demonstrates how trivial it is to add such
    seemingly difficult features in single-page applications. Here are a few other
    features that you can try adding into the application:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入的一个功能是控制器能够引用其他控制器的能力。我们将在稍后的部分讨论这个问题，但重要的是要注意，我们能够通过过滤`posts`控制器的模型来生成结果。搜索模板会自动在用户输入时重新显示结果。这个示例演示了在单页应用中添加这种看似困难的功能是多么简单。以下是一些你可以尝试添加到应用中的其他功能：
- en: A spinner that shows up new posts every time are being loaded from the server.
    Now is a good time to revisit the loading-and-error action hooks we discussed
    in [Chapter 3](part0029_split_000.html#page "Chapter 3. Routing and State Management"),
    *Routing and State Management*.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次从服务器加载新帖子时都会显示一个旋转器。现在是一个很好的时机来回顾我们在[第3章](part0029_split_000.html#page "第3章。路由和状态管理")中讨论的加载和错误操作钩子，*路由和状态管理*。
- en: Define a `humanizedDate` computed property for each of the loaded posts. Let
    this property return the post's date in a readable format such as `Mon, 15th`.
    Moment.js ([http://momentjs.com](http://momentjs.com)) can come in handy.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个加载的帖子定义一个`humanizedDate`计算属性。让这个属性以可读的格式返回帖子的日期，例如`Mon, 15th`。Moment.js ([http://momentjs.com](http://momentjs.com))可能会很有用。
- en: Observables
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察对象
- en: 'In addition to computed properties, we also learned how to use observables.
    These are functions that react to changes made on other properties. For example,
    let''s make the search functionality previously mentioned more user friendly.
    Most users expect the search request to kick off after a second or two, after
    they''ve stopped typing the query term. We, therefore, need a way to *debounce*
    this search. Ember.js provides a function that serves this purpose and can be
    referenced as `Ember.run.debounce`. Here''s a possible implementation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算属性之外，我们还学习了如何使用可观察对象。这些是响应其他属性更改的函数。例如，让我们使之前提到的搜索功能更加用户友好。大多数用户期望在停止输入查询词后的几秒钟内启动搜索请求。因此，我们需要一种方法来*防抖*这个搜索。Ember.js提供了一个提供此功能的函数，可以引用为`Ember.run.debounce`。以下是一个可能的实现：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The controller defines an observer, `queryTermDidChange`, which invokes the
    search function after only a second of typing. As illustrated, the `debounce`
    function ([http://emberjs.com/api/classes/Ember.run.html#method_debounce](http://emberjs.com/api/classes/Ember.run.html#method_debounce))
    takes three arguments—a context, a function to invoke within the specified context,
    and the time to wait for invocation if no other calls are made.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器定义了一个观察者`queryTermDidChange`，它在输入仅一秒钟后调用搜索函数。如图所示，`debounce`函数([http://emberjs.com/api/classes/Ember.run.html#method_debounce](http://emberjs.com/api/classes/Ember.run.html#method_debounce))接受三个参数——一个上下文、一个在指定上下文中调用的函数，以及在没有其他调用时等待调用的时长。
- en: Object and array controllers
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象和数组控制器
- en: 'Ember.js ships with the following controllers that are meant to easily represent
    objects and enumerable data, respectively:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js附带以下控制器，旨在轻松表示对象和可枚举数据：
- en: Object controller
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象控制器
- en: Array controller
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组控制器
- en: 'These controllers are a bit different from the other controllers in the sense
    that the data being represented is usually set as the `model` property of the
    controller, for example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制器在某种程度上与其他控制器不同，因为表示的数据通常被设置为控制器的`model`属性，例如：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: An object controller
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个对象控制器
- en: 'An object controller is used to proxy properties of the object being represented.
    This means that if a controller property is accessed, Ember.js will look for the
    property first in the controller, and then the model. For example, let''s create
    a post model class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对象控制器用于代理表示的对象的属性。这意味着如果访问控制器属性，Ember.js将首先在控制器中查找该属性，然后是模型。例如，让我们创建一个帖子模型类：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, create a new post from this model as:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从这个模型创建一个新的帖子：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This post''s properties can obviously be accessed using the object''s getter
    and setter methods as:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以显然使用对象的getter和setter方法访问此帖子的属性：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When this post is set as the model of an `ObjectController` instance, as shown,
    access to the controller properties translates to access to the post, for example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当此帖子被设置为`ObjectController`实例的模型时，如图所示，访问控制器属性将转换为访问帖子，例如：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that using a normal controller will not yield the same results:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用普通控制器不会产生相同的结果：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Object properties are useful when we wish to create computed properties on
    the controller whose dependent properties are those of the model. For example,
    let''s pass the preceding defined post as a route''s model:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望在控制器上创建依赖于模型属性的计算属性时，对象属性非常有用。例如，让我们将前面定义的帖子作为路由的模型传递：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, suppose we want to compute a `tags` property based on the given array
    of IDs, we will implement this in the corresponding controller as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要根据给定的ID数组计算一个`tags`属性，我们将在相应的控制器中实现它，如下所示：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With the computed property defined, we can go ahead and use it in the post
    template as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了计算属性后，我们可以在帖子模板中使用它，如下所示：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will yield something like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下所示的结果：
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we do not have to prefix the variables with `model.`, as we did in
    the preceding sections, because the template's context, the controller, forwarded
    these requests to the model. This type of controller uses the `Ember.ObjectProxy`
    ([http://emberjs.com/api/classes/Ember.ObjectProxy.html](http://emberjs.com/api/classes/Ember.ObjectProxy.html))
    mixin, which enables a proxy (in this case, the controller) to forward all requests
    to the properties that it has not defined, and to its model, as we already discussed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要像前面章节中那样在变量前加上`model.`前缀，因为模板的上下文、控制器将这些请求转发给了模型。这种类型的控制器使用`Ember.ObjectProxy`([http://emberjs.com/api/classes/Ember.ObjectProxy.html](http://emberjs.com/api/classes/Ember.ObjectProxy.html))混合，这使得代理（在这种情况下，控制器）可以将所有请求转发到它未定义的属性以及其模型，正如我们之前讨论的那样。
- en: An array controller
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个数组控制器
- en: 'Likewise, array controllers are used to represent enumerable data. An example
    of enumerable data is the JavaScript `Array` primitive:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，数组控制器用于表示可枚举数据。可枚举数据的一个例子是JavaScript的`Array`原始数据类型：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this case, the corresponding template will list the items as:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，相应的模板将列出项目，如下所示：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that we also did not need to reference the model, as shown in the following
    cases:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也不需要像以下情况那样引用模型：
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since array controllers represent enumerable data, they provide the following
    useful methods that can be used to manipulate their models.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组控制器表示可枚举数据，它们提供了以下有用的方法，可以用来操作它们的模型。
- en: addObject(object)
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: addObject(object)
- en: 'The `addObject(object)` method adds the given object to the end of the controller
    model if the latter does not contain the former, as shown in the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`addObject(object)`方法如果控制器模型不包含该对象，则将给定的对象添加到控制器模型的末尾，如下例所示：'
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the model already contains the object, this method call fails silently.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型已经包含该对象，此方法调用将静默失败。
- en: pushObject(object)
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pushObject(object)
- en: 'The `pushObject(object)` method always adds the object, regardless of whether
    the model contains it or not, for example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushObject(object)`方法始终添加对象，无论模型是否包含它，例如：'
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: removeObject(object)
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: removeObject(object)
- en: 'The `removeObject(object)` method is used to remove the given object from the
    controller''s model, as shown in the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeObject(object)`方法用于从控制器模型中移除指定的对象，如下例所示：'
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method also does nothing if the model doesn't contain the object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型不包含该对象，此方法将不执行任何操作。
- en: addObjects(objects), pushObjects(objects), and removeObjects(objects)
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: addObjects(objects), pushObjects(objects), 和 removeObjects(objects)
- en: 'The three methods mentioned previously are used to perform the three methods
    we just discussed using multiple objects, for example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的三种方法用于使用多个对象执行我们刚才讨论的三个方法，例如：
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: contains(object)
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: contains(object)
- en: 'To check if a model contains an object, we can use the `contains(object)` method
    that returns a Boolean:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查模型是否包含一个对象，我们可以使用返回布尔值的 `contains(object)` 方法：
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: compact()
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: compact()
- en: 'The `compact()` method returns a copy of the underlying model, with undefined
    and null items removed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`compact()` 方法返回一个底层模型的副本，其中已删除 undefined 和 null 项：'
- en: '[PRE38]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: every(callback)
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: every(callback)
- en: 'The `every(callback)` method is used to check if each of the items contained
    in the model satisfies a given condition:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`every(callback)` 方法用于检查模型中包含的每个项是否满足给定的条件：'
- en: '[PRE39]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: filter(object)
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: filter(object)
- en: 'Filter works in the same as way as the native JavaScript array object, `Array.filter`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器的工作方式与原生的 JavaScript 数组对象 `Array.filter` 相同：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: filterBy(property)
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: filterBy(property)
- en: 'Sometimes, we want to compact a model, but only if the items contained define
    the given property. We can use the preceding `filter` method, as shown:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们想要压缩一个模型，但只有当包含的项定义了给定的属性时才这样做。我们可以使用前面的 `filter` 方法，如下所示：
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also use a shorter version, as shown:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用更简短的形式，如下所示：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: find(callback)
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: find(callback)
- en: 'In the preceding example, we can use the `filter` method to return the first
    occurrence of a primary color, as shown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以使用 `filter` 方法来返回第一个主要颜色的出现，如下所示：
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is inefficient because we always loop through all the model items. The
    `find` method can be used to achieve this need as:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不高效的，因为我们总是遍历所有模型项。可以使用 `find` 方法来实现这个需求，如下所示：
- en: '[PRE44]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As soon as a match is found, the check iteration is aborted.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到匹配项，检查迭代就会终止。
- en: findBy(key, value)
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: findBy(key, value)
- en: 'Just as in the `filter` versus `filterBy` case, we can reimplement the preceding
    example using the `findBy` method instead of `find`, as shown:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 `filter` 与 `filterBy` 的情况下，我们可以使用 `findBy` 方法而不是 `find` 来重新实现前面的例子，如下所示：
- en: '[PRE45]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: insertAt(index, object), objectAt(index), and removeAt(index, length)
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: insertAt(index, object), objectAt(index), 和 removeAt(index, length)
- en: The `insertAt(index, object)`, `objectAt(index)`, and `removeAt(index, length)`
    methods are used to perform operations using item indices. The first method is
    used to add an object at the given index. An error is thrown if the index is out
    of bounds. The second method is used to retrieve an object at the specified index.
    Again, if the index is out of bounds, an undefined value is returned.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertAt(index, object)`、`objectAt(index)` 和 `removeAt(index, length)` 方法用于使用项索引执行操作。第一个方法用于在指定的索引处添加一个对象。如果索引超出范围，则抛出错误。第二个方法用于检索指定索引处的对象。如果索引超出范围，则返回
    undefined 值。'
- en: 'Note that we cannot use negative indices for lookups, as shown in the following
    example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无法使用负索引进行查找，如下例所示：
- en: '[PRE46]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The last method removes objects matching the given index by an optional range:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法通过可选的范围删除与给定索引匹配的对象：
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: map(callback)
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: map(callback)
- en: 'A map works in the same way as `Array.map`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 映射与 `Array.map` 的工作方式相同：
- en: '[PRE48]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: mapBy(property)
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mapBy(property)
- en: 'With the result generated in the preceding example, we can use the `mapBy`
    method to get back the original array as:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面例子中生成的结果，我们可以使用 `mapBy` 方法来获取原始数组，如下所示：
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As illustrated, this method returns a new array containing the values evaluated
    on the model items.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，此方法返回一个新数组，包含在模型项上评估的值。
- en: forEach(function)
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: forEach(function)
- en: 'This is a commonly used method that invokes the given function on each of the
    items contained in the model:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常用的方法，它对模型中包含的每个项调用给定的函数：
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: uniq()
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: uniq()
- en: 'As the name suggests, the `uniq()` method returns a new array devoid of duplicates:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`uniq()` 方法返回一个不包含重复项的新数组：
- en: '[PRE51]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: sortProperties and sortAscending
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sortProperties 和 sortAscending
- en: 'The `sortProperties` and `sortAscending` methods are used to sort the represented
    data. For example, we might have a music catalog that we want to sort by album
    name, and later by song name, as shown in the following table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`sortProperties` 和 `sortAscending` 方法用于对表示的数据进行排序。例如，我们可能有一个音乐目录，我们希望按专辑名称排序，然后按歌曲名称排序，如下表所示：'
- en: '| Album name | Song name |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 专辑名称 | 歌曲名称 |'
- en: '| --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Folie a deux | Tiffany Blews |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 双重幻想 | Tiffany Blews |'
- en: '| Folie a deux | W.A.M.S |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 双重幻想 | W.A.M.S |'
- en: '| Infinity on high | Thriller |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 高地上的无限 | 惊悚 |'
- en: 'To accomplish this, we need to define the following properties in the controller:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，我们需要在控制器中定义以下属性：
- en: '`sortProperties`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortProperties`'
- en: '`sortAscending`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortAscending`'
- en: 'The first property specifies the properties to use when ordering the items,
    while the second property specifies the sort direction. In our cases, we will
    sort the music catalog as:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性指定了排序项时使用的属性，而第二个属性指定了排序方向。在我们的例子中，我们将按以下方式对音乐目录进行排序：
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To sort the songs in the reverse order, we need to set the `sortAscending` property
    as `False`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要按相反顺序对歌曲进行排序，我们需要将`sortAscending`属性设置为`False`。
- en: These are just a few of the common methods that are provided by the `Ember.ArrayProxy`
    ([http://emberjs.com/api/classes/Ember.ArrayProxy.html](http://emberjs.com/api/classes/Ember.ArrayProxy.html))
    mixin, which `Ember.ArrayController` uses.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是`Ember.ArrayProxy`([http://emberjs.com/api/classes/Ember.ArrayProxy.html](http://emberjs.com/api/classes/Ember.ArrayProxy.html))混合提供的一些常见方法，而`Ember.ArrayController`正是使用了这些方法。
- en: Handling event actions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事件动作
- en: 'In the previous chapter, we learned how user actions can easily be delegated
    to controllers and routes from templates. Let''s have a recap with an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何将用户动作从模板轻松委托给控制器和路由。让我们通过一个例子来回顾一下：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In this example, we defined two actions that will be handled by the corresponding
    controller as:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了两个将由相应控制器处理的动作，如下所示：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We already learned that all action handlers are defined in the `actions` property
    of the target controller or route. In this case, when the user submits the form
    either by clicking on the **submit** button or by hitting the *Enter* key, the
    `save` hook in the controller is called with the post context as the only argument.
    Likewise, clicking on the **cancel** button calls the corresponding `cancel` hook.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，所有的动作处理器都定义在目标控制器或路由的`actions`属性中。在这种情况下，当用户通过点击**提交**按钮或按*Enter*键提交表单时，控制器中的`save`钩子会以post上下文作为唯一参数被调用。同样，点击**取消**按钮会调用相应的`cancel`钩子。
- en: 'A typical widget consisting of tabs can be implemented in the same way, as
    shown in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的由标签组成的部件可以以相同的方式实现，如下面的截图所示：
- en: '![Handling event actions](img/00009.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![处理事件动作](img/00009.jpeg)'
- en: 'In this case, the widget template might look like the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，小部件模板可能看起来像以下代码：
- en: '[PRE55]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This template contains the `tabs` element group generated from the `tabs` context
    property. If any of the tabs are clicked on, they will need to acquire a `selected`
    class. Here''s suitable styling that will achieve this effect:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板包含由`tabs`上下文属性生成的`tabs`元素组。如果点击了任何标签，它们将需要获取一个`selected`类。以下适合的样式将实现此效果：
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `selected` action handler for the controls will then be implemented as:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 控件的`selected`行为处理器将实现如下：
- en: '[PRE57]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that these actions don't have to be caught in the context controller as
    we discussed in the previous chapter. When an action is triggered, typically from
    a template element, Ember.js checks to see if the appropriate action handler is
    defined inside the actions property of the immediate controller. If this is not
    the case, Ember.js proceeds to search for the action handler in the corresponding
    route. If this route still doesn't implement the handler, Ember.js will continue
    searching for the action handler in higher routes. One thing to note is that if
    an action handler returns `True`, Ember.js will still continue to search for this
    handler, constituting **action bubbling**.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些动作不需要像我们在上一章中讨论的那样在上下文控制器中捕获。当一个动作被触发时，通常是从模板元素触发的，Ember.js会检查是否在直接控制器的`actions`属性中定义了适当的行为处理器。如果不是这种情况，Ember.js将继续在相应的路由中搜索行为处理器。需要注意的是，如果一个行为处理器返回`True`，Ember.js仍然会继续搜索这个处理器，这构成了**动作冒泡**。
- en: Specifying controller dependencies
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定控制器依赖项
- en: 'Controller dependencies enable controllers to associate. Therefore, whenever
    a controller needs to access the properties of another controller, it should first
    declare the controller as a dependency in order for it to be able to do so. These
    dependencies are defined in the `needs` property of the affected controller. For
    example, let''s say we decided to add a commenting system to our blog application:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器依赖项使控制器能够关联。因此，每当一个控制器需要访问另一个控制器的属性时，它应该首先将控制器声明为依赖项，以便能够这样做。这些依赖项在受影响控制器的`needs`属性中定义。例如，假设我们决定向我们的博客应用程序添加一个评论系统：
- en: '[PRE58]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In a typical blog, comments are usually displayed on a separate page, and in
    our case, at a page with a path such as `/post/100/comments`. We will need to
    define a `comments` template that lists the loaded comments as:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的博客中，评论通常显示在单独的页面上，在我们的案例中，是在路径如 `/post/100/comments` 的页面上。我们需要定义一个 `comments`
    模板，该模板列出已加载的评论如下：
- en: '[PRE59]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you might have noticed, the template needs to display the title of the comments''
    post. To do this, it needs to be able to access a loaded post in the `post` controller.
    By specifying a dependency to the post controller, the comments controller will
    be able to access the post controller in its `controllers` object property. For
    example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，模板需要显示评论帖子的标题。为此，它需要能够访问 `post` 控制器中加载的帖子。通过指定对 `post` 控制器的依赖项，评论控制器将能够在其
    `controllers` 对象属性中访问 `post` 控制器。例如：
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, the `comments` template will be updated to the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`comments` 模板将更新为以下内容：
- en: '[PRE61]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You might be wondering whether this can lead to an infinite dependency loop.
    Well, controllers can depend on each other without suffering from this fate:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道这是否会引发无限依赖循环。好吧，控制器可以相互依赖而不会遭受这种命运：
- en: '[PRE62]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This association serves as the correct channel of communication between the
    different components of the application.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关联充当了应用程序不同组件之间正确沟通的渠道。
- en: State transitions in controllers
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器中的状态转换
- en: 'In [Chapter 3](part0029_split_000.html#page "Chapter 3. Routing and State Management"),
    *Routing and State Management*, we learned that routes can transition the state
    of an application into other routes by invoking their `transitionTo` method, as
    shown in the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](part0029_split_000.html#page "第 3 章。路由和状态管理")，*路由和状态管理* 中，我们了解到路由可以通过调用它们的
    `transitionTo` 方法将应用程序的状态转换到其他路由，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Likewise, controllers also have this capability through the use of the provided
    `transitionToRoute` method. For example, we can change states in a controller''s
    action handler as:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，控制器也通过使用提供的 `transitionToRoute` 方法具有这种能力。例如，我们可以在控制器的事件处理程序中更改状态，如下所示：
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This has been an exciting chapter that helped us understand the primary purpose
    of controllers, which is data representation. We learned how controllers are defined
    based on the defined application routes. We also learned how to use object and
    array controllers to represent models. Lastly, we learned how to set up dependencies
    between controllers, which might handle different concerns of the application.
    At this point of the book, we really should be ready to start thinking of ways
    to architect Ember.js applications. The next chapter will cover the view layer,
    for which a good amount of knowledge in the use of controllers will be required.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章令人兴奋的章节，帮助我们理解控制器的主要目的，即数据表示。我们学习了控制器是如何根据定义的应用程序路由来定义的。我们还学习了如何使用对象和数组控制器来表示模型。最后，我们学习了如何设置控制器之间的依赖关系，这些控制器可能处理应用程序的不同关注点。在本书的这个阶段，我们真的应该开始思考构建
    Ember.js 应用程序的方法。下一章将涵盖视图层，这需要大量关于控制器使用的知识。
