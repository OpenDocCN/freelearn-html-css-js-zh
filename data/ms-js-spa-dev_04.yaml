- en: Chapter 4. REST is Best – Interacting with the Server Side of Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. REST最佳实践 – 与应用程序的后端进行交互
- en: The majority of development work involved in creating a JavaScript single page
    application is generally going to be on the frontend, but not to be overlooked
    is the all-important data-transfer layer of your application, which communicates
    with the server and the database. **Representational State Transfer** (**REST**)
    is the standard architectural style of data transfer between client and server
    for the World Wide Web and the **Internet of Things** (**IoT**). Any time you
    use a web application, chances are that REST is being used to communicate data
    and transitions of state from the UI.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建JavaScript单页应用程序所涉及的大多数开发工作通常将集中在前端，但不可忽视的是至关重要的数据传输层，它与服务器和数据库进行通信。**表征状态转移**（**REST**）是万维网和**物联网**（**IoT**）客户端和服务器之间数据传输的标准架构风格。每次你使用Web应用程序时，很可能会使用REST来从UI通信数据状态转换。
- en: The beauty of using the REST architectural style for a SPA is that the frontend
    of your application can be entirely agnostic of what type of software is being
    used to retrieve requests on your server, as long as your application can be used
    over **Hypertext Transfer Protocol** (**HTTP**), the standard application protocol
    for the World Wide Web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST架构风格为SPA带来的好处是，你的应用程序的前端可以完全不受用于在服务器上检索请求的软件类型的影响，只要你的应用程序可以通过**超文本传输协议**（**HTTP**），即万维网的标准化应用协议。
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: The fundamental aspects of the REST architectural style
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST架构风格的基本方面
- en: How to write basic REST API endpoints for performing CRUD operations in a single
    page web application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为单页Web应用程序编写基本的REST API端点以执行CRUD操作
- en: How to work with REST requests on your application frontend using AJAX
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用AJAX在你的应用程序前端处理REST请求
- en: The basics of some alternatives to REST, such as SOAP, WebSockets, MQTT, CoAP,
    and DDP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些REST替代方案的基本知识，如SOAP、WebSockets、MQTT、CoAP和DDP
- en: Understanding the fundamentals of REST
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解REST的基本原理
- en: REST is the architectural style used to serve web pages and make requests on
    the World Wide Web, or simply the Web. Although the Internet and the Web are often
    referred to interchangeably, they differ in the fact that the Web is merely a
    *part* of the Internet.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: REST是用于在万维网或简称为Web上提供网页和发起请求的架构风格。尽管互联网和Web经常被互换使用，但它们在Web仅仅是互联网的*一部分*这一事实上有所不同。
- en: The Web is a collection of documents, or *web pages*, which are served or hosted
    on computers all over the world and are connected via *hyperlinks*, or what are
    commonly referred to as links. These links are served over HTTP, the language
    of communication for the Web. REST is often confused with HTTP because of its
    mutual relationship with the Web, but HTTP and REST are far from the same thing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Web是一组文档，或称为*网页*，这些网页托管在世界各地的计算机上，并通过*超链接*或通常所说的链接连接。这些链接通过HTTP提供，这是Web的通信语言。由于与Web的相互关系，REST经常与HTTP混淆，但HTTP和REST远非同一事物。
- en: Understanding an architectural style versus a protocol
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解架构风格与协议的区别
- en: REST is an architectural style, while HTTP is an application layer protocol.
    This means that while HTTP is the language of communication on the Web, REST is
    simply a set of rules for performing requests and operations on the Web. These
    operations performed through a REST architectural style are commonly referred
    to as *Web Services*. In this way, HTTP is simply the method of transport for
    the Web Services performed by an application using REST.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种架构风格，而HTTP是一种应用层协议。这意味着虽然HTTP是网络上的通信语言，但REST仅仅是执行网络上的请求和操作的一组规则。通过REST架构风格执行的操作通常被称为*Web服务*。这样，HTTP仅仅是使用REST的应用程序执行Web服务的方法。
- en: Architectural style
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构风格
- en: An architectural style, or architectural pattern, is a set of rules which provides
    developers with the ability to build abstraction layers as frameworks that are
    built to achieve a common language of interaction that is to ultimately be consumed
    by some type of client, or user agent. In the case of the Web, that user agent
    is a web browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 架构风格，或架构模式，是一组规则，它为开发者提供了构建抽象层作为框架的能力，这些框架旨在实现一个最终将被某种类型的客户端或用户代理消费的通用交互语言。在Web的情况下，那个用户代理是网络浏览器。
- en: A web abstraction layer, or web framework, can be written in any number of languages
    to provide Web Services via REST, or RESTful services, as long as that language
    can be hosted on a web server. When that framework follows the REST architectural
    style, the UI for any application using it can be completely *agnostic*, or unbiased,
    as to the technology behind the RESTful service.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络抽象层，或网络框架，可以用任何数量的语言编写，以通过 REST 或 RESTful 服务提供 Web 服务，只要该语言可以在 Web 服务器上托管。当该框架遵循
    REST 架构风格时，使用它的任何应用程序的 UI 可以完全 **无偏见**，即对 RESTful 服务的背后技术保持中立。
- en: Protocol
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**协议**'
- en: A protocol, as it relates to the Web, is part of an abstraction layer of the
    **Internet Protocol Suite**, or TCP/IP, providing a common method of communication
    between connected computers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在与网络相关的情况下，协议是 **互联网协议套件** 或 TCP/IP 的抽象层的一部分，为连接的计算机之间提供了一种通用的通信方法。
- en: Transport layer protocols
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**传输层协议**'
- en: 'The term TCP/IP is a combination of the Internet Protocol Suite''s most widely
    used protocols: **Transmission Control Protocol** (**TCP**) and **Internet Protocol**
    (**IP**).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 TCP/IP 是互联网协议套件中最广泛使用的协议的组合：**传输控制协议** (**TCP**) 和 **互联网协议** (**IP**)。
- en: '**TCP**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP**'
- en: TCP is a transport layer protocol, which lies underneath the application layer.
    This means that services and information are *transported* up to the top-level
    application layer of the Internet Protocol Suite.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP** 是一种传输层协议，位于应用层之下。这意味着服务和信息被 **传输** 到互联网协议套件的最顶层应用层。'
- en: '**IP**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP**'
- en: IP is also a transport layer protocol. You have most likely seen this protocol
    associated with the term IP address, or Internet Protocol address, which is a
    unique numerical identifier for a device on a network. On the Web, domain names
    are commonly used to point to an IP address to make it easier for people to remember
    how to reach that address.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP** 也是一种传输层协议。你很可能已经看到这个协议与术语 IP 地址或互联网协议地址相关联，这是网络上设备的唯一数字标识符。在互联网上，域名通常用于指向
    IP 地址，以便人们更容易记住如何到达该地址。'
- en: Application layer protocols
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**应用层协议**'
- en: The application layer of TCP/IP is the abstraction layer that defines methods
    of communication between host computers that are connected through the Web. This
    layer specifies several protocols, with some of the most common being HTTP, FTP,
    SSH, and SMTP.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 的应用层是定义通过互联网连接的主机之间通信方法的抽象层。该层指定了多个协议，其中一些最常见的是 HTTP、FTP、SSH 和 SMTP。
- en: '**HTTP**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP**'
- en: HTTP is the primary protocol for data exchange within the application layer
    of TCP/IP, and it provides the foundation of communication for RESTful web services.
    HTTP is also responsible for serving a web page for display within a browser,
    and for sending data from a form on a web page to a server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP** 是 TCP/IP 应用层内数据交换的主要协议，并为 RESTful 网络服务提供了通信的基础。HTTP 还负责在浏览器中显示网页，并将网页上的表单数据发送到服务器。'
- en: '**FTP**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**FTP**'
- en: The **File Transfer Protocol** (**FTP**), is another standard protocol within
    the TCP/IP application layer that is used for transferring files between computers.
    FTP communication requires an FTP server and an FTP client.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件传输协议** (**FTP**) 是 TCP/IP 应用层中的另一种标准协议，用于在计算机之间传输文件。FTP 通信需要一个 FTP 服务器和一个
    FTP 客户端。'
- en: '**SSH**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSH**'
- en: '**Secure Shell** (**SSH**) is another common protocol in the application layer
    which is used to allow secure remote logins to a non-secure network entry point.
    For SSH connections to work, a SSH server must be available to receive requests
    from a SSH client. A SSH client most often comes in the form of a terminal application
    with a **command line interface** (**CLI**).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Secure Shell** (**SSH**) 是应用层中另一种常见的协议，它用于允许对非安全网络入口点进行安全的远程登录。为了使 SSH 连接工作，必须有一个
    SSH 服务器来接收来自 SSH 客户端的请求。SSH 客户端通常以终端应用程序的形式出现，具有 **命令行界面** (**CLI**)。'
- en: '**SMTP**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**SMTP**'
- en: '**Simple Mail Transfer Protocol** (**SMTP**) is the standard method of sending
    e-mail, or electronic mail, in the application layer of TCP/IP. SMTP may also
    be used to receive e-mail and is typically used for this purpose by e-mail servers.
    SMTP is not typically used by user-level e-mail clients for receiving e-mail,
    however. Instead, these clients more commonly use POP3 or IMAP.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单邮件传输协议** (**SMTP**) 是在 TCP/IP 应用层发送电子邮件或电子邮件的标准方法。SMTP 也可以用来接收电子邮件，并且通常由电子邮件服务器用于此目的。然而，SMTP
    通常不用于用户级电子邮件客户端接收电子邮件。相反，这些客户端更常见地使用 POP3 或 IMAP。'
- en: POP3 is the third version of the **Post Office Protocol**, which is a standard
    application layer protocol for receiving e-mail over TCP/IP connections. POP3
    is generally used to download e-mail to a local computer and then delete it from
    the host server.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: POP3是**邮局协议**的第三个版本，它是一种标准的应用层协议，用于通过TCP/IP连接接收电子邮件。POP3通常用于将电子邮件下载到本地计算机，然后从主机服务器上删除。
- en: IMAP is the **Internet Message Access Protocol**. It is also a standard application
    layer protocol for receiving e-mail over TCP/IP connections. IMAP is generally
    used as way to manage a host server e-mail inbox by multiple clients, and therefore
    it does not delete the e-mail from the server after downloading it to a local
    computer like POP3\. The latest versions of IMAP also support tracking the state
    of an e-mail on the host server, such as read, replied to, or deleted.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: IMAP是**互联网消息访问协议**。它也是一种标准的应用层协议，用于通过TCP/IP连接接收电子邮件。IMAP通常用作管理多个客户端通过主机服务器电子邮件收件箱的方式，因此它不会像POP3那样在将电子邮件下载到本地计算机后从服务器上删除电子邮件。IMAP的最新版本也支持跟踪主机服务器上电子邮件的状态，例如已读、已回复或已删除。
- en: Using HTTP as a transfer protocol for REST
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用HTTP作为REST的传输协议
- en: REST defines a set of rules by which to make HTTP requests for a web application
    or service. HTTP requests can be made in any number of ways, but they are only
    RESTful if they follow that set of rules. HTTP provides the transport layer upon
    which those requests are made.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: REST定义了一套规则，用于在Web应用程序或服务中发出HTTP请求。HTTP请求可以通过任何数量的方式发出，但只有遵循这些规则，它们才是RESTful的。HTTP提供了请求所依赖的传输层。
- en: In the same way that a web application interacting with a REST API is agnostic
    of the type of software framework being used to serve the API endpoints, HTTP
    is agnostic of the types of operating systems being used across all of the servers
    which it communicates with.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像与REST API交互的Web应用程序对用于提供API端点的软件框架类型一无所知一样，HTTP对所有与之通信的服务器上使用的操作系统类型也是一无所知的。
- en: The constraints of REST
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST的约束
- en: The REST architectural style is governed by a set of constraints, or rules,
    that dictate how it should be implemented, interacted with, and handle data. REST
    was first defined by the American computer scientist Roy Fielding in a doctoral
    dissertation in 2000, along with these constraints.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: REST架构风格由一系列约束或规则所管理，这些规则规定了它应该如何实现、交互和处理数据。REST最初由美国计算机科学家Roy Fielding在2000年的一篇博士论文中定义，并伴随着这些约束。
- en: REST is considered to be a *hybrid* architectural style in that it borrows from
    other architectural styles that existed before its conception. These other architectural
    styles lend greatly to the REST constraints outlined here.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: REST被认为是一种*混合*架构风格，因为它借鉴了在其构思之前存在的其他架构风格。这些其他架构风格极大地促进了这里概述的REST约束。
- en: Client-server
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端-服务器
- en: 'The first constraint of REST is the client-server architectural style. This
    constraint exists to enforce the agnostic nature of REST, or the *separation of
    concerns* that is so fundamental to it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: REST的第一个约束是客户端-服务器架构风格。这个约束存在是为了强制执行REST的不可知性，或者说是其基础性的*关注点分离*：
- en: '![Client-server](img/B05228_04_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![客户端-服务器](img/B05228_04_01.jpg)'
- en: This diagram shows the client-server relationship, and how they are separated.
    The **client**, or web browser, needs only display the UI for an application.
    The UI can be as simple or as sophisticated as deemed necessary, without affecting
    the REST architecture on the server. This REST constraint provides for scalability.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了客户端-服务器关系以及它们是如何分离的。**客户端**，或网页浏览器，只需要显示应用程序的用户界面。UI可以简单或复杂，只要认为有必要，而不会影响服务器上的REST架构。此REST约束提供了可伸缩性。
- en: Stateless
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无状态
- en: The second constraint of REST builds upon the client-server constraint in that
    the communication between client and server must be stateless. This means that
    any request from a web browser to the REST server must supply all expected information
    needed for the context of the request and the current session in order to expect
    the appropriate response from the server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: REST的第二个约束建立在客户端-服务器约束之上，即客户端和服务器之间的通信必须是无状态的。这意味着任何来自网页浏览器的REST服务器的请求都必须提供所有预期信息，这些信息对于请求的上下文和当前会话是必需的，以便期望从服务器获得适当的响应。
- en: 'The server will have no stored information to help delineate the request, thereby
    making the REST server *stateless* and putting the burden of session state on
    the web browser:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将没有存储信息来帮助界定请求，因此使REST服务器*无状态*并将会话状态的压力放在了网页浏览器上：
- en: '![Stateless](img/B05228_04_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![无状态](img/B05228_04_02.jpg)'
- en: This diagram depicts the client-stateless-server architectural style in which
    the web browser state can change and the REST server remains consistent. This
    REST constraint provides for visibility, reliability, and scalability, which are
    a few of the key benefits of using REST.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了客户端无状态-服务器架构风格，其中网页浏览器的状态可以改变，而REST服务器保持一致性。这种REST约束提供了可见性、可靠性和可扩展性，这些都是使用REST的一些关键好处。
- en: Cache
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存
- en: 'The third constraint of REST builds again upon the client-server and stateless
    constraints. A cache, or data stored for reuse, can be permitted for use by the
    browser for any given request based on the cacheability of that request as delegated
    by the REST server. If the server''s cache component indicates that a request
    is cacheable, then the browser can cache it for future requests. Cacheability
    is often indicated in the case where a request made multiple times to a particular
    REST endpoint will likely result in an identical response each time:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: REST的第三个约束再次建立在客户端-服务器和无状态约束之上。一个缓存，或为重用存储的数据，可以根据REST服务器委托的该请求的可缓存性，允许浏览器用于任何给定的请求。如果服务器的缓存组件指示请求是可缓存的，那么浏览器可以将其缓存以供未来的请求使用。可缓存性通常在多次向特定REST端点发出请求的情况下表示，每次请求都可能导致相同的响应：
- en: '![Cache](img/B05228_04_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![缓存](img/B05228_04_03.jpg)'
- en: This diagram depicts the client-cache-stateless-server architectural style.
    This style is just like client-stateless-server, but with the added component
    of a client cache.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了客户端-缓存-无状态服务器架构风格。这种风格与客户端-无状态服务器类似，但增加了客户端缓存的组件。
- en: Uniform interface
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统一接口
- en: 'The fourth constraint of REST is the use of a uniform interface among components
    of the system. This refers to the simplistic nature of the architecture involved
    in a REST implementation in which the components are decoupled. This allows each
    component of the architecture to evolve on its own, without affecting the others:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: REST的第四个约束是在系统的组件之间使用统一接口。这指的是REST实现中涉及的架构的简单性，其中组件是解耦的。这允许架构的每个组件独立发展，而不会影响其他组件：
- en: '![Uniform interface](img/B05228_04_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![统一接口](img/B05228_04_04.jpg)'
- en: This diagram shows the uniform-client-cache-stateless-server architectural style.
    This combines the three previous architectural style constraints with the added
    constraint of uniform interface.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了统一客户端-缓存-无状态服务器架构风格。这结合了前三种架构风格约束，并增加了统一接口的约束。
- en: The uniform interface constraint is further subdivided into four of its own
    constraints.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 统一接口约束进一步细分为其自身的四个约束。
- en: Identification of resources
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 资源标识
- en: A resource in REST is any conceptual mapping of information to a uniquely identifiable
    object. This object can be a person, place, or thing. An example of this in the
    case of the Web is a Uniform Resource Identifier (URI). More specifically, a Uniform
    Resource Locator (URL) is a special type of URI that provides a method to find
    a web resource and specifies how to obtain a representation of information from
    that resource. A URL is also commonly referred to as a web address. In relation
    to REST, a URL may also be referred to as an endpoint.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: REST中的资源是对信息到唯一可识别对象的任何概念映射。这个对象可以是人、地点或事物。在Web的例子中，这是一个统一资源标识符（URI）。更具体地说，统一资源定位符（URL）是一种特殊的URI，它提供了一种查找网络资源的方法，并指定了如何从该资源获取信息表示。URL也常被称为网络地址。在REST的相关性中，URL也可能被称为端点。
- en: Manipulation of resources through representations
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过表示形式操作资源
- en: A representation in REST is a set of data which represents the current state
    of a resource. In a web architecture using REST, a JSON document can be used as
    a representation to pass between client and server, and manipulate or change a
    resource.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: REST中的表示是一组数据，它代表了资源的当前状态。在采用REST的Web架构中，JSON文档可以用作表示，在客户端和服务器之间传递，以操作或更改资源。
- en: Self-descriptive messages
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自描述消息
- en: Messages in REST are the communication between components. In keeping with the
    constraint for a REST server to be stateless, the messages must be self-descriptive,
    meaning it carries all the information necessary to tell each component how it
    should be processed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: REST中的消息是组件之间的通信。根据REST服务器无状态的约束，消息必须是自描述的，这意味着它携带了所有必要的信息，以告诉每个组件如何处理。
- en: Hypermedia as the engine of application state
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 超媒体作为应用程序状态引擎
- en: Hypermedia refers to web pages, or hypertext, and the hyperlinks that connect
    them. In order to remain stateless, a RESTful architecture uses hypermedia to
    convey the state of the application based on representations received from the
    server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 超媒体指的是网页或超文本，以及连接它们的超链接。为了保持无状态，RESTful架构使用超媒体根据从服务器接收到的表示来传达应用程序的状态。
- en: Layered system
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分层系统
- en: The fifth constraint of REST is a layered system, which is a hierarchy of architectural
    components, where each layer provides services to the layer above it and uses
    the services from the layer below it. In this manner, each layer only has visibility
    into one layer below it, thus making it agnostic of any layers down.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: REST的第五个约束是分层系统，这是一个架构组件的层次结构，其中每一层为其上层提供服务并使用下层的服务。以这种方式，每一层只能看到其下一层，因此对任何下层的层都是不可知的。
- en: This concept is applied to distributed servers on the Web that are used to enhance
    the scalability of an application. For example, a web browser may communicate
    with any number of *intermediate* servers based on its location, but it is never
    aware of whether it is connected to the end server or one of those intermediate
    servers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念应用于用于增强应用程序可扩展性的Web分布式服务器。例如，一个网络浏览器可能根据其位置与任何数量的**中间**服务器通信，但它永远不会意识到它是连接到端服务器还是那些中间服务器之一。
- en: 'A layered system is also used to implement load balancing across servers. This
    allows additional servers to take on requests when the primary server is inundated
    with too many requests:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器之间实现负载均衡也使用了分层系统。这允许当主服务器因请求过多而超负荷时，额外的服务器可以承担请求：
- en: '![Layered system](img/B05228_04_05.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Layered system](img/B05228_04_05.jpg)'
- en: This diagram depicts a uniform-layered-client-cache-stateless-server. This architectural
    style combines the previous four with the added constraint of a layered system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了统一分层客户端缓存无状态服务器。这种架构风格结合了前四种风格，并增加了分层系统的约束。
- en: Code-on-demand
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按需代码
- en: The sixth and final constraint of REST is the **code-on-demand** architectural
    style, and it is the only *optional* constraint. In this style, the server provides
    a set of executable code encapsulated in some form that is consumable by the browser.
    Some examples of this are Java applets, Flash animations running ActionScript,
    and client-side widgets running JavaScript.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: REST的第六个也是最后的约束是**按需代码**的架构风格，并且这是唯一的**可选**约束。在这种风格中，服务器提供一组封装在某种形式中、可以被浏览器消费的可执行代码。这种风格的例子包括Java小程序、运行ActionScript的Flash动画以及运行JavaScript的客户端小工具。
- en: 'Using code-on-demand can improve the flexibility of a REST application, but
    it also reduces *visibility* by encapsulating some functionality. This is why
    code-on-demand is an optional constraint for REST:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用按需代码可以提高REST应用程序的灵活性，但它也通过封装一些功能来减少**可见性**。这就是为什么按需代码是REST的一个可选约束：
- en: '![Code-on-demand](img/B05228_04_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Code-on-demand](img/B05228_04_06.jpg)'
- en: This diagram depicts the final REST architectural style. This combines all previously
    described constraints, which are required for REST, with the optional constraint
    of code-on-demand.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了最终的REST架构风格。它结合了之前描述的所有必须用于REST的约束，以及可选的按需代码约束。
- en: Benefits of REST
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST的好处
- en: The REST constraints were designed with separation of concerns and forward-compatibility
    in mind, and this design allows for the individual components of REST to evolve
    without compromising the underlying architectural style itself.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: REST约束的设计考虑到了关注点的分离和向前兼容性，这种设计允许REST的各个组件独立演变，而不会损害底层架构风格本身。
- en: By enforcing the constraints of REST, some particular architectural properties
    are exposed that reveal the beneficial nature of this architectural style. Let's
    explore some specific benefits of REST more closely.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强制实施REST的约束，一些特定的架构属性被揭示出来，这揭示了这种架构风格的益处。让我们更深入地探讨REST的一些具体好处。
- en: Performance
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: Performance is a major benefit of REST, and it is exposed by using cache, simple
    representations such as JSON, a layered system with multiple servers and load
    balancing, and the decoupling of components through a uniform interface.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是REST的主要好处之一，它通过使用缓存、简单的表示形式如JSON、具有多个服务器和负载均衡的分层系统以及通过统一接口解耦组件来体现。
- en: Simplicity
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单性
- en: Simplicity is another key benefit of REST, and it is primarily exposed by the
    uniform resource constraint in which individual components of the system are decoupled.
    Simplicity is also seen in the server component, which needs only to support HTTP
    requests, and does not have to support state for any request.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 简单性是REST的另一个关键优势，它主要通过统一资源约束来体现，其中系统的各个组件是解耦的。简单性也体现在服务器组件上，它只需要支持HTTP请求，而不需要为任何请求支持状态。
- en: Separation of concerns
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离
- en: Separation of concerns lends to the simplicity of REST, but is also a benefit
    itself. This is seen in the separate server-client relationship, the burden of
    caching being put on the frontend, and the use of a layered system. Separation
    of concerns is a common pattern seen not only in architecture but in software
    design as well, such as the MVW architectural patterns discussed in *[Chapter
    2](ch02.html "Chapter 2. Model-View-Whatever")* , *Model-View-Whatever*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点分离有助于REST的简单性，同时本身也是一个优势。这体现在独立的客户端-服务器关系、将缓存负担放在前端以及分层系统的使用上。关注点分离是一个常见的模式，不仅体现在架构中，也体现在软件设计上，例如在*[第2章](ch02.html
    "第2章。模型-视图-任何")*中讨论的MVW架构模式，*模型-视图-任何*。
- en: Scalability
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: The architectural property of scalability is exposed in REST through the simplicity
    of the client-server relationship and the separation of concerns properties. By
    combining these key attributes, the system becomes more scalable because the complexity
    of relationships between the components is reduced by having specific guidelines
    around how they should work together.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过客户端-服务器关系的简单性和关注点分离属性，REST在可扩展性方面表现出其架构属性。通过结合这些关键属性，系统变得更加可扩展，因为组件之间关系的复杂性通过具体的指导原则来降低，这些原则规定了它们应该如何协同工作。
- en: Portability
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可移植性
- en: Portability is a benefit of REST that is exposed through the client-server separation
    of concerns. This allows the user interface layer of the application to be *portable*
    because it is agnostic of the underlying server software being used to host the
    REST endpoints.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植性是REST的一个优势，它通过关注点分离的客户端-服务器模型来体现。这使得应用程序的用户界面层可以*可移植*，因为它对用于托管REST端点的底层服务器软件是中立的。
- en: Portability is also exposed through code-on-demand, giving REST the ability
    to transport application code from server to client.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植性也通过代码按需功能体现出来，这使得REST能够将应用程序代码从服务器传输到客户端。
- en: Visibility
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视性
- en: Visibility simply refers to the ability to understand what is happening in a
    system based on the components' interactions with each other. With REST, high
    visibility is a benefit because of the decoupled nature of components and the
    fact that they need little to no knowledge of each other. This allows interactions
    made within the architecture to be easily understood, such as requests for endpoints.
    To determine the full nature of a request, one need not look beyond the representation
    of that request itself.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可视性简单来说是指根据组件之间的交互理解系统发生情况的能力。在REST中，由于组件的解耦性质以及它们之间几乎不需要相互了解，高可视性是一个优势。这允许在架构内部进行的交互，如对端点的请求，容易被理解。为了确定请求的完整性质，不需要查看请求本身的表示之外的内容。
- en: The code-on-demand constraint of REST is one that actually reduces visibility,
    but for this reason, it is optional. In following, code-on-demand is not often
    used by modern-day web applications, aside from simple JavaScript widgets that
    are found on web pages and used for advertising, social networks, and other third-party
    interactions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: REST的代码按需约束实际上会降低可视性，但正因为这个原因，它是可选的。在接下来的内容中，除了在网页上发现的简单JavaScript小部件，用于广告、社交网络和其他第三方交互之外，现代网络应用很少使用代码按需功能。
- en: Reliability
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可靠性
- en: Reliability is a benefit of REST that is exposed primarily through the stateless
    server constraint. With a stateless server, a failure in the application can be
    analyzed at the system level because you know that the origin of that failure
    is from a single, decoupled component of the system.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠性是REST的一个优势，主要通过无状态服务器约束来体现。在无状态服务器中，应用程序的故障可以在系统级别进行分析，因为你知道该故障的来源是系统的一个单独、解耦的组件。
- en: For example, if you receive an error message in the UI for a web application
    that indicates to the user that information was entered incorrectly, then this
    failure can be handled at the UI level. If, on the other hand, you receive a HTTP
    400 response code error from the server after entering the correct information,
    you can further deduce that the REST server endpoint is not configured correctly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在Web应用的UI中收到一个错误消息，提示用户输入的信息不正确，那么这个错误可以在UI级别进行处理。另一方面，如果你在输入正确信息后从服务器收到HTTP
    400响应代码错误，你可以进一步推断出REST服务器端点配置不正确。
- en: RESTful web services
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful Web服务
- en: As mentioned earlier, the REST architectural style is often used to perform
    , **Read**, **Update** and **Delete** (**Create**, **Read**, **Update**, **and
    Delete** (**CURD**)) operations in modern web single page applications, and these
    operations are known as web services. To employ RESTful web services for your
    own application, you will need not only a HTTP server, but a hosted database or
    database server in order to perform CRUD operations on the data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，REST架构风格常用于在现代Web单页应用中执行**读取**、**更新**和**删除**（**创建**、**读取**、**更新**、**删除**（**CRUD**））操作，这些操作被称为Web服务。为了在你的应用程序中使用RESTful
    Web服务，你不仅需要一个HTTP服务器，还需要一个托管数据库或数据库服务器，以便在数据上执行CRUD操作。
- en: Setting up a simple database with MongoDB
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MongoDB设置简单数据库
- en: MongoDB is the database used for the MEAN stack. It is an open source, document-oriented
    database system and can easily be added to your stack via download or package
    manager, depending upon the operating system you are using.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是MEAN栈使用的数据库。它是一个开源的、面向文档的数据库系统，可以很容易地通过下载或包管理器添加到你的栈中，具体取决于你使用的操作系统。
- en: Installing MongoDB
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装MongoDB
- en: MongoDB can be installed on systems running Linux, Windows, and OS X. Direct
    downloads are available for these operating systems and, additionally, MongoDB
    can be installed using Homebrew on OS X. Homebrew is a popular CLI package manager
    for OS X. For instructions on installing Homebrew, visit brew.sh.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB可以安装在运行Linux、Windows和OS X的系统上。这些操作系统都有可用的直接下载，此外，在OS X上还可以使用Homebrew安装MongoDB。Homebrew是OS
    X上流行的CLI包管理器。有关安装Homebrew的说明，请访问brew.sh。
- en: If you are running OS X and have Homebrew installed, you can use the following
    instructions to install MongoDB using a CLI. For installation on other systems,
    you can find instructions on MongoDB's documentation site at [docs.mongodb.com/manual/installation/](http://docs.mongodb.com/manual/installation/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行OS X并且已经安装了Homebrew，你可以使用以下说明通过CLI安装MongoDB。对于其他系统的安装，你可以在MongoDB的文档网站上找到说明，网址为[docs.mongodb.com/manual/installation/](http://docs.mongodb.com/manual/installation/)。
- en: Installing MongoDB on Mac using Homebrew
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Homebrew在Mac上安装MongoDB
- en: 'Start by updating Homebrew to the latest version before using it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Homebrew之前，首先将其更新到最新版本：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, install the `mongodb` package:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装`mongodb`包：
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once MongoDB is installed, you will want to add it to your command-line `PATH`
    for convenience. To do so, add the following to your user directory `.profile`,
    `.bash_profile`, or `.bashrc` file if you have one of them already. If you don''t
    have any of these files, then create `.profile`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了MongoDB，你可能希望将其添加到你的命令行`PATH`中以便于使用。为此，将以下内容添加到你的用户目录下的`.profile`、`.bash_profile`或`.bashrc`文件中，如果你已经有其中之一的话。如果你没有这些文件，那么创建`.profile`：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you have added MongoDB to your `PATH`, you will need to create a directory
    for storing your data before you can run it. The default data directory for MongoDB
    is `/data/db`. You will most likely have to run this command as the superuser.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将MongoDB添加到你的`PATH`中，你需要在运行它之前创建一个用于存储数据的目录。MongoDB的默认数据目录是`/data/db`。你很可能会需要以超级用户身份运行此命令。
- en: Creating a MongoDB data directory
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建MongoDB数据目录
- en: 'First, go to the CLI and create a database directory using `sudo`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前往CLI并使用`sudo`创建一个数据库目录：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, you will need to set the permissions on the directory to give you read
    and write access:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要设置目录权限，以便你能够进行读写操作：
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running MongoDB
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行MongoDB
- en: 'Now you should be all set and you can go ahead and run MongoDB using the mongod
    command on the CLI:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该已经设置好了，你可以继续在CLI上使用`mongod`命令运行MongoDB：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If everything is set up properly, you should see several lines of output with
    the last line showing something similar to the following line:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，你应该会看到几行输出，最后一行显示的内容类似于以下行：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Port 27017 is the default port for MongoDB but it can be changed, if necessary,
    using the `--port` option on the CLI:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 端口 27017 是 MongoDB 的默认端口，但必要时可以使用 CLI 上的 `--port` 选项进行更改：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To stop MongoDB from running at any time, press *Ctrl* + *C* at the command
    prompt where it is running.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要在任何时候停止 MongoDB 的运行，请在它运行的命令提示符中按 *Ctrl* + *C*。
- en: Creating a collection with MongoDB
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 MongoDB 创建集合
- en: 'A collection in MongoDB is analogous to a table in a traditional relational
    database. Let''s set up a test database and collection using the `user.json` document
    we have been working with in our example application. From the root directory
    of the application, run the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 中的集合类似于传统关系数据库中的表。让我们使用我们在示例应用程序中使用的 `user.json` 文档设置一个测试数据库和集合。从应用程序的根目录运行以下命令：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command will create a database named test and a collection named users,
    then it will import the data from the user.json file to the users collection.
    You should see two lines of output after running this command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个名为 test 的数据库和一个名为 users 的集合，然后它将从 user.json 文件中导入数据到 users 集合。运行此命令后，你应该看到两行输出：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This output indicates that the `user.json` document was imported to the MongoDB
    instance running on localhost.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出指示 `user.json` 文档已导入到运行在本地的 MongoDB 实例中。
- en: Installing the Node.js MongoDB driver
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Node.js MongoDB 驱动程序
- en: 'MongoDB provides drivers for several programming languages. We will be using
    the Node.js driver. The Node.js driver for MongoDB can be installed using NPM.
    Go to the root directory of the application and install it there and save to your
    local `package.json`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 为几种编程语言提供了驱动程序。我们将使用 Node.js 驱动程序。可以使用 NPM 安装 MongoDB 的 Node.js 驱动程序。转到应用程序的根目录并安装它，并将其保存到本地的
    `package.json` 文件中：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now you can start using MongoDB within your Node.js application. First, let''s
    add some additional lines to the `server.js` file we created earlier:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在你的 Node.js 应用程序中使用 MongoDB。首先，让我们向之前创建的 `server.js` 文件中添加一些额外的行：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will set up a connection to your local MongoDB test database and output
    a message to the console if it is successful.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置与本地 MongoDB 测试数据库的连接，如果成功，将在控制台输出一条消息。
- en: 'If you added these lines to the additional code we wrote to `server.js` in
    [*Chapter 3*](ch03.html "Chapter 3. SPA Essentials – Creating the Ideal Application
    Environment"),*SPA Essentials - Creating the Ideal Application Environment*, the
    entire content of the file should look like the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些行添加到我们在 [*第 3 章*](ch03.html "第 3 章。SPA 基础 - 创建理想的应用程序环境") 中为 `server.js`
    编写的附加代码中，*SPA 基础 - 创建理想的应用程序环境*，文件的整个内容应如下所示：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The assert module we added provides a simple set of assertion tests that can
    be used for testing invariants, or values that cannot change. Now let''s save
    the file and run the server again:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的 assert 模块提供了一组简单的断言测试，可用于测试不变量，或不能更改的值。现在让我们保存文件并再次运行服务器：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If everything is working properly and your Node.js server is connected to the
    database, you should see the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，并且你的 Node.js 服务器连接到了数据库，你应该看到以下输出：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This indicates that your Node.js server is running and connected to MongoDB.
    If the MongoDB connection is not successful, an error will be thrown in the console.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你的 Node.js 服务器正在运行并连接到 MongoDB。如果 MongoDB 连接不成功，控制台将抛出错误。
- en: Now that we've got a Node.js server running with a connection to the test database
    in MongoDB, we can begin writing some REST API endpoints.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个 Node.js 服务器在运行，并且连接到了 MongoDB 中的测试数据库，我们可以开始编写一些 REST API 端点了。
- en: Writing basic REST API endpoints
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基本的 REST API 端点
- en: The most common type of RESTful request on the Web is a HTTP `GET` or `Read`
    operation. An example of this is a simple request to view a web page through a
    URL. GET requests can be performed to read any kind of data and do not need to
    be supported by a database, but in order to implement the Create, Update, and
    Delete operations on data, some type of database or data store must be used, along
    with a REST **Application Programming Interface** (**API**).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 上最常见的一种 RESTful 请求是 HTTP `GET` 或 `Read` 操作。一个例子是通过 URL 查看网页的简单请求。GET 请求可以执行以读取任何类型的数据，并且不需要由数据库支持，但为了实现数据的创建、更新和删除操作，必须使用某种类型的数据库或数据存储，以及一个
    REST **应用程序编程接口** (**API**)。
- en: CRUD with REST
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 REST 进行 CRUD
- en: Performing full CRUD operations with your web application can be done using
    the simple NPM, Bower, and Grunt application you have been working with thus far;
    we just need to write some API endpoints now to make this possible. Let's go back
    to our application CLI to make some changes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您迄今为止一直在使用的简单 NPM、Bower 和 Grunt 应用程序执行您的 Web 应用程序的完整 CRUD 操作；我们只需要编写一些 API
    端点来实现这一点。让我们回到我们的应用程序 CLI 进行一些更改。
- en: Handling request data with Node.js and Express
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Node.js 和 Express 处理请求数据
- en: 'Before we can handle any API request data sent to our server, we have to add
    the ability to parse that data. In most cases, this will be data that is sent
    from a web page through a form or some other means. This type of data is referred
    to as the **body** of the request, and in order to parse it we will need to add
    another Node.js package:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够处理发送到我们服务器的任何 API 请求数据之前，我们必须添加解析这些数据的能力。在大多数情况下，这将是从网页通过表单或其他方式发送的数据。这类数据被称为请求的
    **正文**，为了解析它，我们需要添加另一个 Node.js 包：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will add the Node.js `body-parser` package to our application dependencies.
    Now let''s go back to editing `server.js` and add some additional code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 Node.js `body-parser` 包添加到我们的应用程序依赖项中。现在让我们回到编辑 `server.js` 并添加一些额外的代码：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add the bodyParser variable declaration below the other variable declarations
    at the top of the file, and then call `app.use(bodyParser.json())` just below
    it and above all route definitions. This will now allow us to handle and parse
    any JSON data sent as the body of any request to the server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部的其他变量声明下方添加 bodyParser 变量声明，然后在其下方调用 `app.use(bodyParser.json())`，并在所有路由定义之上。现在这将允许我们处理和解析任何作为请求正文的
    JSON 数据。
- en: Creating with a POST request
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 POST 请求创建
- en: Express follows REST vernacular by providing method names for routes that match
    their respective HTTP request type. In REST, a HTTP POST request is the standard
    method used for a Create operation. The respective Express method for this is
    `.post()`. Let's set up a simple POST request with Express that will allow us
    to add additional records to our users collection in MongoDB.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Express 通过提供与各自 HTTP 请求类型匹配的方法名称来遵循 REST 术语。在 REST 中，HTTP POST 请求是用于创建操作的标准化方法。对应的
    Express 方法是 `.post()`。让我们使用 Express 设置一个简单的 POST 请求，这将允许我们向 MongoDB 中的用户集合添加额外的记录。
- en: 'First, let''s remove the MongoDB connection test code in `server.js` and replace
    it with the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从 `server.js` 中删除 MongoDB 连接测试代码，并替换为以下代码：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Make sure this code is *above* the `app.use('/', ...)` and `app.get('*', ...)`
    definitions we created in [*Chapter 3*](ch03.html "Chapter 3. SPA Essentials –
    Creating the Ideal Application Environment"), *SPA Essentials - Creating the Ideal
    Application Environment*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 确保此代码位于我们创建的 `app.use('/', ...)` 和 `app.get('*', ...)` 定义之上，这些定义在 [*第 3 章*](ch03.html
    "第 3 章。SPA 基础 - 创建理想的应用程序环境")，*SPA 基础 - 创建理想的应用程序环境*中。
- en: 'The entire content of `server.js` should now look like the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.js` 的全部内容现在应该看起来像以下代码：'
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The .post() request endpoint or handler we added will first log the `request.body`
    object, which has been parsed and converted from JSON, to the server console on
    the command line. It will then connect to MongoDB and call the MongoDB `insertOne()`
    method to insert the `request.body` document into the users collection in our
    database.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的 `.post()` 请求端点或处理程序将首先记录已解析并从 JSON 转换的 `request.body` 对象，并将其输出到命令行上的服务器控制台。然后，它将连接到
    MongoDB 并调用 MongoDB 的 `insertOne()` 方法，将 `request.body` 文档插入到我们数据库中的用户集合中。
- en: There are many libraries available that can handle this type of interaction
    and database inserts from a request much more gracefully, but it is important
    to understand how the Express server is interacting with MongoDB, so for that
    reason, we are using the native MongoDB API to perform these operations.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多库可以优雅地处理这种交互和从请求中插入数据库，但了解 Express 服务器如何与 MongoDB 交互非常重要，因此，出于这个原因，我们使用原生的
    MongoDB API 来执行这些操作。
- en: Testing the POST request on the frontend
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在前端测试 POST 请求
- en: 'Now that we have a POST handler set up in our server, let''s test that it works
    by sending a request from the frontend. Inserting information is commonly done
    from user entry in a form, so let''s edit the application layout index.html file
    and add one:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在服务器中设置了 POST 处理程序，让我们通过从前端发送请求来测试它是否工作。从用户表单输入插入信息是常见的做法，因此让我们编辑应用程序布局
    `index.html` 文件并添加一个：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Add this HTML code just under the opening `<body>` tag in the page. We will
    again use the `Payload.js` API for making a request to the server; this time,
    a simple POST request. Notice that the `data-url` attribute of the `<form>` tag
    is set to the API endpoint URL, and the `data-method` attribute is set to *post*.
    When the form is submitted, this will take the form data and convert it to JSON
    and send it as the request body to the server via a POST request.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的 `<body>` 标签下方添加此 HTML 代码。我们再次使用 `Payload.js` API 向服务器发送请求；这次是一个简单的 POST
    请求。注意，`<form>` 标签的 `data-url` 属性设置为 API 端点 URL，而 `data-method` 属性设置为 *post*。当表单提交时，这将获取表单数据并将其转换为
    JSON，然后通过 POST 请求将请求体发送到服务器。
- en: 'Now run the app from the CLI and go to `localhost:8080` in your browser. You
    should see the form there. Add some sample data to the form inputs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从 CLI 运行应用程序，并在浏览器中转到 `localhost:8080`。你应该在那里看到表单。向表单输入中添加一些示例数据：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now click to submit the form just once. If all goes well, you should see something
    like the following displayed in your console:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在单击一次提交表单。如果一切顺利，你应该会在你的控制台中看到以下内容：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The JSON document created from the form should now be inserted into the users
    collection in the MongoDB test database. This means there are now two documents
    in the collection - the document we inserted originally from the user.json file,
    and the one we just added from the form POST.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从表单创建的 JSON 文档现在应该被插入到 MongoDB 测试数据库的用户集合中。这意味着现在集合中有两个文档 - 我们最初从 user.json
    文件中插入的文档，以及我们从表单 POST 中添加的文档。
- en: Now that we've got a couple of records in our database, we need a way to retrieve
    those documents and display them in the browser. We can do this by first creating
    an endpoint to read data from the database.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们数据库中已经有了一些记录，我们需要一种方法来检索这些文档并在浏览器中显示它们。我们可以通过首先创建一个端点来从数据库中读取数据来实现这一点。
- en: Reading with a GET request
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 GET 请求进行读取
- en: A HTTP `GET` request is the standard method used for a Read operation in REST.
    The respective Express method for this is `.get()`. We previously set up a GET
    request in *Chapter 3* to load our layout page, but this time we want to write
    a REST API request that will return the user records from MongoDB in JSON format.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `GET` 请求是 REST 中用于读取操作的标准方法。相应的 Express 方法是 `.get()`。我们之前在第 3 章中设置了一个 GET
    请求来加载我们的布局页面，但这次我们想要编写一个 REST API 请求，该请求将以 JSON 格式返回 MongoDB 中的用户记录。
- en: 'First, hit *Ctrl* + *C* on the command line to stop the server, then open up
    `server.js` again for editing. Just below the `.post()` endpoint we wrote, add
    the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在命令行中按 *Ctrl* + *C* 停止服务器，然后再次打开 `server.js` 进行编辑。在我们的 `.post()` 端点下方，添加以下代码：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will notice that this handler is requested through the same URL as the `.post()`
    handler, but it will be handled differently because of the HTTP request method
    being a GET instead of a POST.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个处理程序是通过与 `.post()` 处理程序相同的 URL 请求的，但由于 HTTP 请求方法是 GET 而不是 POST，所以它将被不同地处理。
- en: First, the request will connect to the test database and then call the MongoDB
    .find() method on the users collection, which will return a cursor. A cursor in
    MongoDB is a pointer to the results of a database query. As we mentioned in *[Chapter
    3](ch03.html "Chapter 3. SPA Essentials – Creating the Ideal Application Environment")*
    , *SPA Essentials - Creating the Ideal Application Environment*, MongoDB uses
    the BSON data format internally, so in order to format the cursor for use in our
    application, we have to convert the BSON data to a format that is consumable over
    HTTP. For this purpose, we chain the `.toArray()` method to the `.find()` operation,
    which will convert the result set to an array of documents. We can also access
    the length property of the resulting array and log the number of documents retrieved
    to the server console.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请求将连接到测试数据库，然后对用户集合调用 MongoDB 的 `.find()` 方法，这将返回一个游标。在 MongoDB 中，游标是指向数据库查询结果的指针。正如我们在
    *[第 3 章](ch03.html "第 3 章。SPA 基础 - 创建理想的应用程序环境")* 中提到的，*SPA 基础 - 创建理想的应用程序环境*，MongoDB
    在内部使用 BSON 数据格式，因此为了将游标格式化以供我们的应用程序使用，我们必须将 BSON 数据转换为 HTTP 可消费的格式。为此，我们将 `.toArray()`
    方法链接到 `.find()` 操作，这将把结果集转换为文档数组。我们还可以访问结果数组的长度属性，并将检索到的文档数量记录到服务器控制台。
- en: Next, we pass an anonymous callback function to the `.toArray()` method and
    return the resulting data as a JSON response.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将一个匿名回调函数传递给 `.toArray()` 方法，并将结果数据作为 JSON 响应返回。
- en: Testing the GET request on the frontend
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试前端上的 GET 请求
- en: 'Now let''s set up some HTML to test our GET request on the frontend. Edit the
    application layout index.html page and edit the HTML we added to retrieve and
    display data from the `user.json` file in *[Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"),
    Model-View-Whatever*. This should be right underneath the form we just added for
    the POST request:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置一些 HTML 来测试我们在前端上的 GET 请求。编辑应用程序布局 index.html 页面，并编辑我们添加的用于从 `[第 2 章](ch02.html
    "第 2 章。模型-视图- Whatever")`，*模型-视图- Whatever* 中检索和显示 `user.json` 文件中的数据的 HTML。这应该就在我们刚刚添加的用于
    POST 请求的表单下面：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have now changed the URL for the GET request from `/user.json` to `/api/users`.
    Payload.js will handle an API request as a GET by default, so there is no need
    to add the d`ata-method="get"` attribute to this URL, other than to provide more
    transparency. Additionally, the empty .results <div> is indicated as where we
    want to display our resulting data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将 GET 请求的 URL 从 `/user.json` 更改为 `/api/users`。Payload.js 默认会将 API 请求作为
    GET 处理，因此除了提供更多透明度外，无需为此 URL 添加 `data-method="get"` 属性。此外，空的 `.results <div>`
    被标记为我们想要显示结果数据的地方。
- en: 'We also have changed the `data-template` attribute value here from user (singular)
    to users (plural). This indicates that we want to load a Handlebars template named
    users. Create a new file in the root of your app directory called `users.handlebars`
    and add the following code to it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更改了这里的 `data-template` 属性值，从用户（单数）更改为用户（复数）。这表明我们想要加载一个名为 users 的 Handlebars
    模板。在你的应用程序目录的根目录中创建一个名为 `users.handlebars` 的新文件，并将以下代码添加到其中：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we need to recompile the Handlebars templates and save them to the `templates.js`
    file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要重新编译 Handlebars 模板并将它们保存到 `templates.js` 文件中：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run this from the command line and you will be just about ready to load the
    MongoDB data into the template. First, run the server again, and then go to or
    refresh `localhost:8080` in your browser. Click the Load user data link and you
    should see only one name show up below it: the `first_name` and `last_name` fields
    from the document you just inserted into the database. If you check the console,
    you should see output like the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中运行此操作，你差不多就可以将 MongoDB 数据加载到模板中了。首先，再次运行服务器，然后在浏览器中转到或刷新 `localhost:8080`。点击“加载用户数据”链接，你应该会看到下面只显示一个名称：你刚刚插入到数据库中的文档的
    `first_name` 和 `last_name` 字段。如果你检查控制台，你应该会看到如下输出：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So two documents were actually retrieved from the database, but only one name
    is displayed in the browser. Why is this? The reason is quite simple, but easy
    to overlook. The data from the document we first inserted from `user.json` looks
    like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际上从数据库中检索到了两个文档，但在浏览器中只显示了一个名称。为什么是这样呢？原因很简单，但很容易被忽视。我们从 `user.json` 首次插入的文档中的数据看起来如下：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The new document we added from the form `POST` request, however, looks like
    this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从表单的 `POST` 请求中添加的新文档看起来是这样的：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the document we created from the form does not have a name object
    with the first and last properties nested in it like the `user.json` document,
    but instead has the explicit `first_name` and `last_name` properties, and those
    are the properties that we are looking to display in the Handlebars template.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们从表单创建的文档没有像 `user.json` 文档那样嵌套着具有首字母和姓氏属性的对象名称，而是明确地具有 `first_name` 和
    `last_name` 属性，而这些正是我们希望在 Handlebars 模板中显示的属性。
- en: This is the reason why the HTML view only displays one name, but how did we
    overlook this? The reason for this is attributed to the fact that MongoDB is a
    document-oriented database with no strict data typing, like a relational database.
    As we discussed in *[Chapter 3](ch03.html "Chapter 3. SPA Essentials – Creating
    the Ideal Application Environment")* , *SPA Essentials – Creating the Ideal Application
    Environment*, this is one of the things that makes NoSQL document-oriented databases
    completely different than traditional SQL databases.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 HTML 视图只显示一个名称的原因，但我们是如何忽略这个问题的呢？这个问题的原因归因于 MongoDB 是一个没有严格数据类型的面向文档的数据库，就像关系型数据库一样。正如我们在
    *[第 3 章](ch03.html "第 3 章。SPA 基础 - 创建理想的应用程序环境")* 中讨论的，*SPA 基础 - 创建理想的应用程序环境*，这是使
    NoSQL 面向文档的数据库与传统 SQL 数据库完全不同的一个原因。
- en: So when we inserted the new data into our collection from the form POST, MongoDB
    did nothing to check that the format of the new document matched the format of
    the existing document. Self-defined document structure is a powerful feature of
    a document-oriented database, but it can also lead to application errors and missing
    data for the UI when the document collections are not normalized.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们从表单POST中插入新数据到我们的集合时，MongoDB并没有检查新文档的格式是否与现有文档的格式匹配。自定义文档结构是面向文档数据库的一个强大功能，但如果不进行规范化，也可能导致应用程序错误和UI缺失数据。
- en: Now let's write an Update endpoint to change one of our existing documents and
    have it match the other.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个更新端点，以更改我们现有的文档，并使其与另一个匹配。
- en: Updating with a PUT request
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PUT请求进行更新
- en: In REST, a HTTP `PUT` request is the standard method used for an Update operation.
    The respective Express method for this is .put().
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST中，HTTP `PUT`请求是用于更新操作的标准方法。对应的Express方法是.put()。
- en: 'Now hit *Ctrl* + *C* to stop the Node.js server, then open up the server.js
    file again and add the following code below the `.get()` handler:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按*Ctrl* + *C*停止Node.js服务器，然后再次打开server.js文件，在`.get()`处理程序下方添加以下代码：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are again using the same endpoint URL, but this will only handle a `PUT`
    request made from the frontend. This method will first connect to our test database,
    and then it will call the MongoDB `.udpateOne()` method to update an existing
    document. The first argument passed to this method is a filter, or data to look
    for and find a match. The `.updateOne()` method will only look for the first document
    that matches a filter and then end the query.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用相同的端点URL，但这次只会处理从前端发出的`PUT`请求。这个方法首先会连接到我们的测试数据库，然后调用MongoDB的`.updateOne()`方法来更新现有的文档。传递给这个方法的第一个参数是一个过滤器，或者是要查找并匹配的数据。`.updateOne()`方法只会查找与过滤器匹配的第一个文档，然后结束查询。
- en: 'Notice that the filter passed to the method here is `{ "id": 1 }`. This is
    the `id` field that was passed in from the `user.json` file. Remember that MongoDB
    actually creates its own internal id for every document if one is not supplied,
    and this field is called `_id`. So in the case of our original user object we
    supplied, it will have an `_id` field set to a BSON `ObjectId` and the original
    *id* field we supplied set to 1\. Since we know that the new document we created
    from the form POST does not have the extraneous *id* field, we can safely filter
    on that field to find the original document and update it.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，传递给这个方法的过滤器是`{ "id": 1 }`。这是从`user.json`文件中传递进来的`id`字段。记住，如果未提供，MongoDB会为每个文档创建自己的内部id，这个字段称为`_id`。所以，在我们的原始用户对象中，它将有一个设置为BSON
    `ObjectId`的`_id`字段，以及我们提供的原始`*id*`字段设置为1。由于我们知道我们从表单POST创建的新文档没有多余的`*id*`字段，我们可以安全地基于该字段进行过滤，以找到原始文档并更新它。'
- en: The second parameter we are passing to the `.updateOne()` method is the entire
    request body, which will be an object produced from a form submission. Typically,
    with a PUT request, the intention is to update existing fields with new values,
    but in this case we actually want to change the structure of the document to match
    the structure of the new record we created using the form POST.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`.updateOne()`方法的第二个参数是整个请求体，它将是从表单提交中生成的一个对象。通常，在PUT请求中，意图是使用新值更新现有字段，但在这个情况下，我们实际上想要改变文档的结构，以匹配我们使用表单POST创建的新记录的结构。
- en: The third parameter passed to the `.updateOne()` method is an anonymous callback
    function to which the result of the update request is passed. Here, we log that
    result to the console and return it as JSON to the frontend.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`.updateOne()`方法的第三个参数是一个匿名回调函数，更新请求的结果会被传递给它。在这里，我们将结果记录到控制台，并以JSON格式返回给前端。
- en: Testing the PUT request on the frontend
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在前端测试PUT请求
- en: 'Now let''s go back to the application layout index.html file and add some more
    HTML just below the GET request HTML we added previously. To do this, copy the
    HTML from the `POST` request form and change it to look like the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到应用程序布局index.html文件，并在之前添加的GET请求HTML下方添加一些更多的HTML。为此，复制`POST`请求表单中的HTML，并修改它看起来像以下这样：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code matches the POST request HTML save for a few minor changes. We have
    edited the `<h2>` title to show that this is the PUT request form, and the `data-method`
    attribute on the form is now set to `put`. Leave all form inputs as they are because
    we will want the updated document to match the new document we created.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 POST 请求的 HTML 相匹配，除了几个小的改动。我们已编辑 `<h2>` 标题以显示这是一个 PUT 请求表单，并且表单上的 `data-method`
    属性现在设置为 `put`。保留所有表单输入不变，因为我们希望更新的文档与我们所创建的新文档相匹配。
- en: 'Now start the server again from the command line and then go to or refresh
    localhost:8080 in your browser. You should see the new `PUT` Request form we added
    below the `POST` request and `GET` request areas on the page. Now enter the data
    from the original `user.json` object into the corresponding form fields:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从命令行重新启动服务器，然后在浏览器中转到或刷新 localhost:8080。你应该会在页面上的 `POST` 请求和 `GET` 请求区域下方看到我们添加的新
    `PUT` 请求表单。现在将原始 `user.json` 对象中的数据输入到相应的表单字段中：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now click the submit button once and check your console output. You should
    see a lot of information printed to the console. At the very top of it, you should
    see the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击提交按钮一次，检查你的控制台输出。你应该看到大量信息打印到控制台。在最上面，你应该看到以下内容：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This result indicates that one record was modified. If the update was successful,
    the original `user.json` document should now match the format of the second one
    we added from the form POST. To test this, click on the Load user data link to
    GET the user documents and list the names using the Handlebars template and the
    `first_name` and `last_name` properties. You should now see each of the two names
    listed in the browser:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此结果表示已修改了一条记录。如果更新成功，原始的 `user.json` 文档现在应与我们在表单 POST 中添加的第二份文档的格式相匹配。为了测试这一点，点击“加载用户数据”链接以获取用户文档，并使用
    Handlebars 模板和 `first_name` 以及 `last_name` 属性列出名称。你现在应该在浏览器中看到两个名称都被列出：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To complete our RESTful API endpoints in server.js, let's add a final `Delete`
    handler and use it to remove one of the two user records.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 server.js 中完成我们的 RESTful API 端点，让我们添加一个最终的 `Delete` 处理程序，并使用它来删除两个用户记录中的一个。
- en: Deleting with a DELETE request
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 DELETE 请求进行删除
- en: A HTTP `DELETE` request is the standard method used for the homonymous Delete
    operation in REST. Naturally, the respective Express method for this is `.delete()`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `DELETE` 请求是用于 REST 中同名的 Delete 操作的标准方法。自然，Express 中对应的方法是 `.delete()`。
- en: 'Hit *Ctrl* + *C* on the command to stop the server and then open *server.js*
    again for editing. Add the following code just below the `.put()` handler:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *C* 停止服务器，然后再次打开 *server.js* 进行编辑。在 `.put()` 处理程序下方添加以下代码：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This handler will first connect to the database, then it will call the MongoDB
    `.deleteOne()` method on the users collection. The first parameter passed to the
    `.deleteOne()` method is a condition to match against a record to delete. In this
    case, we want to delete the new record we created earlier from the form POST,
    so we are using the unique `first_name` value of `Peebo` for this.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序将首先连接到数据库，然后将在用户集合上调用 MongoDB 的 `.deleteOne()` 方法。传递给 `.deleteOne()` 方法的第一个参数是一个条件，用于匹配要删除的记录。在这种情况下，我们想要删除从表单
    POST 中创建的新记录，因此我们使用 `Peebo` 的唯一 `first_name` 值。
- en: The second parameter passed to the `.deleteOne()` method is an anonymous callback
    function which is passed the result of the delete request. We are again going
    to log that result to the console and return it to the frontend as JSON.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `.deleteOne()` 方法的第二个参数是一个匿名回调函数，该函数传递删除请求的结果。我们再次将此结果记录到控制台，并将其作为 JSON
    返回到前端。
- en: Testing the DELETE request on the frontend
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在前端测试 DELETE 请求
- en: 'Open the application layout index.html file again and add the following code
    below the `PUT` request form we added previously:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开应用程序布局的 index.html 文件，并在之前添加的 `PUT` 请求表单下方添加以下代码：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here we have added a simple button with the Payload.js attributes necessary
    to send a HTTP `DELETE` request.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个简单的按钮，并包含了发送 HTTP `DELETE` 请求所需的 Payload.js 属性。
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It should be noted that no request body, such as form data, can be sent with
    a `DELETE` request.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，不能在 `DELETE` 请求中发送请求体，例如表单数据。
- en: 'Start up the Node.js server again and then go to or reload index.html in your
    browser. You should see the **Delete Peebo** button at the bottom of the page.
    Click the button just once and then check the console output. You will see a lot
    of information from the result. At the very top of the output, you should see
    the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 再次启动 Node.js 服务器，然后在浏览器中打开或重新加载 index.html。你应该在页面底部看到 **删除 Peebo** 按钮。单击该按钮一次，然后检查控制台输出。你将看到大量结果信息。在输出的最顶部，你应该看到以下内容：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The n: 1 property shown here indicates that one record was successfully deleted.
    To verify this, go back to the browser and scroll up to the Load user data link
    under the **GET Request** title. Click that link, and you should now see only
    the original `user.json` document `first_name` and `last_name` shown. The console
    will also indicate that only a single result was found in the users collection:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '这里显示的 n: 1 属性表示一条记录已成功删除。要验证这一点，请返回浏览器并滚动到 **GET 请求**标题下的“加载用户数据”链接。点击该链接，你现在应该只看到原始的
    `user.json` 文档的 `first_name` 和 `last_name`。控制台也将指示在用户集合中只找到单个结果：'
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Congratulations, you now have a full RESTful set of endpoints written to perform
    CRUD operations with Express and MongoDB. Although quite primitive, these example
    methods should give you a foundation for learning more and building upon them
    to create a more robust single page application. They should also give you a better
    understanding of the REST architectural style, and how Node.js interacts with
    MongoDB.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你现在已经使用 Express 和 MongoDB 编写了一个完整的 RESTful 端点集，用于执行 CRUD 操作。尽管这些示例方法相当原始，但它们应该为你学习更多知识并在此基础上构建更健壮的单页应用程序提供一个基础。它们还应该帮助你更好地理解
    REST 架构风格以及 Node.js 如何与 MongoDB 交互。
- en: Alternatives to REST
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 的替代方案
- en: REST is arguably the most widely used architectural style across the Web and
    the IoT, but there are many other technologies, protocols, and architectural styles
    available to use for web services and single page web application data exchange.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 无疑，REST 是跨 Web 和物联网最广泛使用的架构风格，但还有许多其他技术、协议和架构风格可供用于 Web 服务和单页 Web 应用程序的数据交换。
- en: TCP versus UDP
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP 与 UDP
- en: 'As mentioned earlier, TCP is the transport layer protocol upon which HTTP travels
    to the application layer. Some of the beneficial attributes of TCP connections
    are that they are reliable, serial, and checked for errors while sending information.
    These benefits, however, can sometimes lead to undesirable latency:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TCP 是 HTTP 运行到应用层的传输层协议。TCP 连接的一些有益属性是它们是可靠的、串行的，并且在发送信息时检查错误。然而，这些好处有时会导致不希望的延迟：
- en: '![TCP versus UDP](img/image_04_007.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![TCP 与 UDP](img/image_04_007.jpg)'
- en: The Internet Protocol Suite includes many other protocols alongside TCP. One
    of these protocols is **User Datagram Protocol** (**UDP**). UDP is also a core
    member of the *transport layer* of TCP/IP. The primary difference between UDP
    and TCP is that UDP is *connectionless*. This means that individual units of data
    are transmitted with self-identifying information and the receiving end of that
    information has no prior knowledge of when or how it will be received. UDP does
    nothing to ensure that a recipient endpoint is actually available to receive that
    information, and thus this risk must be taken into consideration when using UDP.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议套件包括许多其他协议，与 TCP 一起。其中之一是 **用户数据报协议**（**UDP**）。UDP 也是 TCP/IP 的 *传输层* 的核心成员。UDP
    与 TCP 的主要区别在于 UDP 是 *无连接的*。这意味着数据单元以自识别信息传输，接收端对该信息没有先前的了解，不知道何时或如何接收。UDP 不会确保接收端点实际上可以接收该信息，因此在使用
    UDP 时必须考虑这种风险。
- en: Since UDP uses no connection, it is inherently not *reliable*, and that is what
    sets it apart from a connection-based protocol such as TCP. TCP allows for error
    checking and correction during a transmission because both parties are aware of
    each other due to their *connection*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 UDP 不使用连接，它本质上不是 *可靠的*，这也是它与基于连接的协议（如 TCP）的区别所在。TCP 允许在传输过程中进行错误检查和纠正，因为双方都了解对方，这是由于它们的
    *连接*。
- en: 'Messages sent over UDP and other connectionless protocols are called *datagrams*.
    UDP and datagrams should only be used when error checking and correction is not
    needed or is performed within the application layer itself. Checking errors at
    the application level is often the model that is used with UDP since error checking
    and correction is almost always a necessity with any application. Some examples
    of application types that use UDP are:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过UDP和其他无连接协议发送的消息被称为*数据报*。UDP和数据报仅在不需要错误检查和纠正或这些操作在应用层本身执行时才应使用。由于错误检查和纠正几乎总是任何应用程序的必要条件，因此在UDP中通常使用在应用层检查错误的应用程序类型模型。使用UDP的一些应用程序类型示例包括：
- en: Streaming media
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流媒体
- en: '**Voice over IP** (**VoIP**)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP语音**（**VoIP**）'
- en: Massively multiplayer online games
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大规模多人在线游戏
- en: '**Domain Name System** (**DNS**)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域名系统**（**DNS**）'
- en: Some **Virtual Private Network** (**VPN**) systems
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些**虚拟专用网络**（**VPN**）系统
- en: The most obvious disadvantages with UDP and a connectionless protocol are that
    there is no guarantee of message delivery, no error checking, and, consequently,
    no error correction. This can be a major disadvantage in an application where
    a user is interacting with the system on their own and most events are user generated.
    In a system where hundreds or thousands of users may be interacting with each
    other, however, a connectionless protocol allows the application to be free of
    latency due to error correction. A massively multiplayer online game is a good
    example of a system in which thousands or even millions of messages may need to
    be transported across a network consistently, but this cannot be done reliably
    while also maintaining connections with error checking and correction.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP和无连接协议的最明显缺点是没有消息传递的保证，没有错误检查，因此也没有错误纠正。在用户自己与系统交互的应用程序中，这可能会成为一个主要缺点，因为大多数事件都是用户生成的。然而，在一个可能有数百或数千个用户相互交互的系统中，无连接协议允许应用程序免受错误纠正导致的延迟。一个大规模多人在线游戏就是一个很好的例子，其中可能需要在网络上持续传输数千甚至数百万条消息，但同时在保持带有错误检查和纠正的连接的情况下可靠地完成这一点是不可能的。
- en: SOAP
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOAP
- en: REST is often compared to **Simple Object Access Protocol** (**SOAP**), although
    SOAP is actually a protocol and not an architectural style like REST. The reason
    for the comparison is because both are used for web services, and in this context,
    REST is synonymous with HTTP, which is a protocol. Even though SOAP is a protocol,
    it also interacts with HTTP to transmit messages for implementing web services.
    It can also be used over SMTP.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: REST经常被与**简单对象访问协议**（**SOAP**）相比较，尽管SOAP实际上是一个协议，而不是像REST那样的架构风格。比较的原因是因为两者都用于Web服务，在这个背景下，REST等同于HTTP，这是一个协议。尽管SOAP是一个协议，但它也与HTTP交互以传输消息以实现Web服务。它也可以通过SMTP使用。
- en: 'The message format for SOAP is XML. An XML message sent with SOAP is referred
    to as an *envelope*. The structure of a SOAP envelope follows a particular pattern
    involving elements including a mandatory *body* element and an optional *header*
    element. The body may also include nested *fault* constructs which carry information
    regarding exceptions. An example of a SOAP message is shown as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP的消息格式是XML。使用SOAP发送的XML消息被称为*信封*。SOAP信封的结构遵循特定的模式，包括一个强制性的*主体*元素和一个可选的*头部*元素。主体还可以包括嵌套的*故障*结构，这些结构携带有关异常的信息。以下是一个SOAP消息的示例：
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: REST can also use XML for data exchange, but more commonly uses JSON in modern-day
    web applications.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: REST也可以使用XML进行数据交换，但在现代Web应用程序中更常用JSON。
- en: WebSockets
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSockets
- en: WebSockets is a protocol that allows interactive communication between a web
    browser and a server. The term *interactive* in this context means that the server
    can *push* messages to the web browser without the browser needing to periodically
    *poll* the server for new data, as might typically be done in a web application
    using HTTP, AJAX, and REST.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets是一种允许Web浏览器和服务器之间进行交互式通信的协议。在这个上下文中，“交互式”一词意味着服务器可以在浏览器不需要定期*轮询*服务器以获取新数据的情况下向浏览器*推送*消息，这在使用HTTP、AJAX和REST的典型Web应用程序中可能会这样做。
- en: You may have heard of *push* technology before. This paradigm is evident in
    many smartphone applications that push update notifications to a phone as soon
    as new data is available. This is also referred to as *real-time data*. HTTP is
    limited in that it does not support open connections that can receive real-time
    data. Instead, HTTP requires that a request be made and a connection or *socket*
    is opened, a response is received, information is downloaded, and the connection
    is then closed. Once new information becomes available, this will not be evident
    to the application needing that information without making periodic requests to
    the server, which is referred to as *polling*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前听说过*推送*技术。这种模式在许多智能手机应用中都很明显，它们会在新数据可用时立即将更新通知推送到手机上。这也被称为*实时数据*。HTTP的局限性在于它不支持接收实时数据的开放连接。相反，HTTP需要发起一个请求并打开一个连接或*套接字*，接收响应，下载信息，然后关闭连接。一旦新信息可用，如果没有定期向服务器请求数据，应用程序将不会意识到这一点，这种做法被称为*轮询*。
- en: 'In 2011, WebSockets became officially standardized and supported by modern
    web browsers. This protocol allows data to be transferred to and from a server
    by using an *open* socket connection, allowing the client to request data at will
    but also allowing the server to *push* data to the client in real time:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，WebSockets被正式标准化并由现代网络浏览器支持。该协议允许通过使用*开放*套接字连接将数据从服务器传输到客户端，允许客户端随意请求数据，同时也允许服务器在实时中将数据推送到客户端：
- en: '![WebSockets](img/image_04_008.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![WebSockets](img/image_04_008.jpg)'
- en: Web applications using REST are limited by the open/close connection constraint
    with HTTP. This makes sense for many web applications that do not need a server
    response without a user interaction, or that can implement periodic server polling
    without too much overhead required. Web applications that want to provide real-time
    data to the user without an action, however, may be better served by using WebSockets.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST的Web应用程序受HTTP的开放/关闭连接约束限制。这对于许多不需要服务器响应的用户交互或可以实施定期服务器轮询而不需要太多开销的Web应用程序是有意义的。然而，对于那些想要向用户提供实时数据而不需要用户动作的Web应用程序，使用WebSockets可能更合适。
- en: MQTT
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MQTT
- en: MQTT originally stood for **MQ Telemetry Transport**. It is a messaging protocol
    designed to be used on top of TCP/IP, or the Internet Protocol Suite. MQTT employs
    a *publish-subscribe*, or PubSub, messaging pattern in which events or messages
    are published by publishers and available to any number of subscribers. In following,
    subscribers receive messages from any number of publishers. In this paradigm,
    publishers are entirely agnostic of subscribers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT最初代表**MQ遥测传输**。它是一种设计用于TCP/IP或互联网协议套件之上的消息协议。MQTT采用*发布-订阅*或PubSub的消息模式，其中事件或消息由发布者发布，可供任何数量的订阅者获取。在后续过程中，订阅者会从任何数量的发布者那里接收消息。在这个模式中，发布者对订阅者是完全不知情的。
- en: In contrast to SOAP and WebSockets, MQTT is not designed to be used for web
    services over HTTP, but instead is primarily use for **machine-to-machine **(**M2M**)
    communication. MQTT is often used for satellite communications, home or **smart
    home** automation, and for mobile applications. MQTT is considered to be lightweight
    and have a small code footprint, making it ideal for mobile applications which
    may be using slower, wireless mobile network connections.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与SOAP和WebSockets相比，MQTT不是为在HTTP上使用Web服务而设计的，而是主要用于**机器到机器**（**M2M**）通信。MQTT常用于卫星通信、家庭或**智能家居**自动化以及移动应用程序。MQTT被认为是轻量级且代码占用空间小，非常适合可能使用较慢的无线移动网络连接的移动应用程序。
- en: The "MQ" in MQTT was originally derived from IBM's **Message Queuing** (**MQ**)
    protocol. Message queuing is not actually a requirement for MQTT, however, which
    is why it is no longer a true acronym and is simply referred to as MQTT.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT中的“MQ”最初来源于IBM的**消息队列**（**MQ**）协议。然而，消息队列并不是MQTT的必要要求，这就是为什么它不再是一个真正的缩写，而只是被称为MQTT。
- en: MQTT is an **Organization for the Advancement of Structured Information Standards**
    (**OASIS**) standard. OASIS is an organization that defines standards for the
    IoT and other areas of technology.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT是**结构化信息标准推进组织**（**OASIS**）的一个标准。OASIS是一个定义物联网和其他技术领域标准的组织。
- en: 'Any software that implements MQTT is referred to as an MQTT broker, which is
    a type of message broker architectural pattern that translates messages sent from
    an application to the proprietary format of the receiver, or the message broker
    itself:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现 MQTT 的软件都被称为 MQTT 代理，它是一种消息代理架构模式，将应用程序发送的消息转换为接收者的专用格式，或者消息代理本身：
- en: '![MQTT](img/image_04_009.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![MQTT](img/image_04_009.jpg)'
- en: 'The purpose of the message broker is to take the messages received by an application
    and perform some type of action on them. For example, some actions might be:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理的目的是接收应用程序接收到的消息并对它们执行某种操作。例如，一些操作可能包括：
- en: Initiating web service requests
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 Web 服务请求
- en: Forwarding messages to other destinations
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息转发到其他目的地
- en: Transforming messages to a different type of representation for consumption
    by anther application or endpoint
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息转换为另一种类型的表示，以便由另一个应用程序或端点消费
- en: Storing messages to be used for publish-subscribe events and responses
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储用于发布/订阅事件和响应的消息
- en: Logging and/or responding to application errors
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和/或响应应用程序错误
- en: There are many popular message broker applications and services that can be
    used for message exchange in single page applications. Some of these are Mosquitto,
    CloudMQTT, IBM MessageSight, and ActiveMQ.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多流行的消息代理应用程序和服务可用于单页应用程序中的消息交换。其中一些是 Mosquitto、CloudMQTT、IBM MessageSight
    和 ActiveMQ。
- en: AMQP
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AMQP
- en: '**Advanced Message Queuing Protocol** (**AMQP**) is similar to MQTT. It is
    an open standard application layer protocol for use with message brokers.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级消息队列协议**（**AMQP**）与 MQTT 类似。它是一种用于消息代理的开放标准应用层协议。'
- en: 'One of the most popular open source message brokers for modern-day web applications
    is RabbitMQ, which employs AMQP. In an AMQP architecture using something like
    RabbitMQ, messages are *produced* by an application and then *queued* or stored
    in the RabbitMQ server. A queue is also, in a sense, a *buffer* because it can
    store any amount of information for any amount of time until it is needed:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代 Web 应用程序来说，RabbitMQ 是最受欢迎的开源消息代理之一，它使用 AMQP。在类似 RabbitMQ 的 AMQP 架构中，消息由应用程序*产生*，然后*排队*或存储在
    RabbitMQ 服务器中。在某种程度上，队列也是一个*缓冲区*，因为它可以存储任何数量的信息，直到需要时：
- en: '![AMQP](img/image_04_010.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![AMQP](img/image_04_010.jpg)'
- en: Although it uses AMQP, RabbitMQ also includes an adapter for MQTT. It additionally
    supports HTTP and **Streaming Text Oriented Messaging Protocol** (**STOMP**).
    The fact that RabbitMQ is open source and that it also includes adapters for other
    protocols, most notably HTTP, contributes greatly to its popularity today.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 RabbitMQ 使用 AMQP，但它还包括 MQTT 的适配器。它还支持 HTTP 和**流文本导向消息协议**（**STOMP**）。RabbitMQ
    是开源的，并且它还包括对其他协议的适配器，特别是 HTTP，这极大地促进了它今天的普及。
- en: CoAP
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CoAP
- en: '**Constrained Application Protocol** (**CoAP**) is a web transfer protocol
    designed for M2Mcommunication. The machines primarily targeted for CoAP services
    are IoT devices.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**受限应用协议**（**CoAP**）是一种为机器对机器通信设计的 Web 传输协议。CoAP 服务主要针对的机器是物联网设备。'
- en: CoAP is actually quite similar to HTTP and employs the REST architectural style
    as part of its specification. The difference with CoAP is that it strictly adheres
    to REST principles, while HTTP merely supports REST but does not require it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: CoAP 实际上与 HTTP 非常相似，并在其规范中采用 REST 架构风格。与 CoAP 的不同之处在于，它严格遵循 REST 原则，而 HTTP 仅支持
    REST，但不强制要求。
- en: 'Since CoAP uses the REST architectural style, it can actually be connected
    to over HTTP because, like with any RESTful architecture, the client is agnostic
    of the RESTful server it is accessing. In this scenario, a cross-protocol proxy
    is used to make the CoAP services available to a HTTP client:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CoAP 使用 REST 架构风格，它实际上可以通过 HTTP 连接，因为与任何 RESTful 架构一样，客户端对其访问的 RESTful 服务器是无关的。在这种情况下，使用跨协议代理使
    CoAP 服务对 HTTP 客户端可用：
- en: '![CoAP](img/image_04_011.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![CoAP](img/image_04_011.jpg)'
- en: DDP
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DDP
- en: '**Distributed Data Protocol** (**DDP**) is not commonly used but gaining ground
    through the popular Meteor JavaScript framework. DDP is a simple protocol used
    for explicitly retrieving representations from a server, and also receiving updates
    regarding modifications on those representations in real time.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式数据协议**（**DDP**）虽然不太常用，但通过流行的 Meteor JavaScript 框架正在获得认可。DDP 是一种简单的协议，用于显式地从服务器检索表示，并在实时接收有关这些表示修改的更新。'
- en: DDP allows Meteor applications to use WebSockets for services, providing a framework
    around those services to be connectionless. JSON data is used, but instead of
    being explicitly requested like it is with a RESTful architecture, the JSON data
    messages can be *pushed* in real time to an application.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: DDP 允许 Meteor 应用程序使用 WebSocket 进行服务，为这些服务提供了一个无连接的框架。使用 JSON 数据，但与 RESTful 架构中明确请求不同，JSON
    数据消息可以实时 *推送* 到应用程序。
- en: DDP was originally developed for Meteor by its founders; however, it is not
    specific to Meteor and can be used in other frameworks. Meteor's implementation
    of DDP is written entirely in JavaScript and is open source.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: DDP 最初是由 Meteor 的创始人为其开发的；然而，它并不仅限于 Meteor，也可以在其他框架中使用。Meteor 对 DDP 的实现完全用 JavaScript
    编写，并且是开源的。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You have now learned the fundamental aspects of the REST architectural style,
    the differences between an architectural style and a protocol, the relationship
    between REST and the HTTP protocol, and the constraints of REST. You have also
    learned to write some basic REST API endpoints using Express and MongoDB. A good
    understanding of REST and the server side of a single page application is paramount
    to becoming a skilled web SPA developer. In the next chapter, we will transition
    our focus to the frontend of SPA development, learn a few things about SPA UI
    frameworks and best practices, and take everything we have learned so far and
    apply it to the View layer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学习了 REST 架构风格的基本方面，架构风格与协议之间的区别，REST 与 HTTP 协议之间的关系，以及 REST 的约束。你还学会了使用
    Express 和 MongoDB 编写一些基本的 REST API 端点。对 REST 和单页应用程序后端有良好的理解对于成为一名熟练的 Web SPA
    开发者至关重要。在下一章中，我们将把重点转向 SPA 开发的前端，学习一些关于 SPA UI 框架和最佳实践的知识，并将我们迄今为止所学的一切应用到视图层。
