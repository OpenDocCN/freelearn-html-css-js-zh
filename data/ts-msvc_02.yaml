- en: Gearing up for the Journey
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为旅程做好准备
- en: 'After learning the theory about microservices, we will now move on to hands-on
    implementation. This chapter will lay the foundation for the journey ahead and
    will revisit Node.js and TypeScript concepts essential to the book. It will tell
    you about the trends and adoption rates of both languages. We will go through
    all the required installations, and we will prepare our development environment.
    We will test the development environment by implementing the customary `Hello
    World` microservice. In this chapter, we will focus on the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了关于微服务的理论之后，我们现在将转向实际实现。本章将为前进的旅程奠定基础，并重新审视对本书至关重要的Node.js和TypeScript概念。它将告诉您关于这两种语言的趋势和采纳率。我们将通过所有必需的安装，并准备好我们的开发环境。我们将通过实现传统的`Hello
    World`微服务来测试开发环境。在本章中，我们将重点关注以下主题：
- en: '**Setting up the primary development environment**: We will set up a primary
    environment with all the prerequisites needed. We will understand all aspects
    required for microservice development.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置主要开发环境**：我们将设置一个带有所有必需先决条件的主要环境。我们将了解微服务开发所需的所有方面。'
- en: '**Primer to TypeScript**: In this section, we are going to walk through some
    of the major TypeScript topics that we are going to use throughout the book. We
    will justify usage of TypeScript as our language in Node.js, and understand how
    applications can be written in TypeScript and Node.js.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript入门**：在本节中，我们将介绍一些我们将在整本书中使用的主要TypeScript主题。我们将证明在Node.js中使用TypeScript作为我们的语言，并了解如何使用TypeScript和Node.js编写应用程序。'
- en: '**Primer to Node.js**: In this section, we will go through some advanced Node.js
    topics such as clustering in Node.js, the recently introduced async/await, and
    others. We will understand the Event Loop, and briefly look at Node streams and
    latest trends in Node.js.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js入门**：在本节中，我们将介绍一些高级的Node.js主题，如Node.js中的集群、最近引入的async/await等。我们将了解事件循环，并简要介绍Node流和Node.js的最新趋势。'
- en: '**Microservice implementation**: We will write a `Hello World` microservice
    that will use our development environment.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务实现**：我们将编写一个`Hello World`微服务，该微服务将使用我们的开发环境。'
- en: Setting up primary environment
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置主要环境
- en: In this section, we will set up our environment required for our journey ahead.
    You already installed Node.js and TypeScript globally. At the time of writing,
    the available version of Node.js was **9.2.0** and TypeScript was **2.6.2**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将设置我们前进旅程所需的环境。您已经全局安装了Node.js和TypeScript。在撰写本文时，Node.js的可用版本是**9.2.0**，TypeScript的版本是**2.6.2**。
- en: Visual Studio Code (VS Code)
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code（VS Code）
- en: '**VS Code** is one of the best available editors right now for TypeScript.
    By default, VS Code TypeScript displays warnings on incorrect code, which helps
    us to write better code. Linters, debugging, build issues, errors, and so on are
    provided out of the box by VS Code. It has supports for JSDoc, sourcemaps, setting
    different out-files for files that are generated, hiding derived JavaScript files,
    and so on. It has support for auto-imports, generating method skeletons directly
    just like Eclipse for Java developers. It also provides options for version control
    systems. Hence, it will be our primary choice as IDE. You can download it from [https://code.visualstudio.com/download](https://code.visualstudio.com/download).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**VS Code**是目前最好的TypeScript编辑器之一。默认情况下，VS Code TypeScript会显示有关不正确代码的警告，这有助于我们编写更好的代码。VS
    Code提供了Linter、调试、构建问题、错误等功能。它支持JSDoc、sourcemaps、为生成的文件设置不同的输出文件、隐藏派生的JavaScript文件等。它支持自动导入，直接生成方法骨架，就像Java开发人员的Eclipse一样。它还提供了版本控制系统的选项。因此，它将是我们作为IDE的首选。您可以从[https://code.visualstudio.com/download](https://code.visualstudio.com/download)下载它。'
- en: 'Installing it for Windows is the easiest thing, as it''s an `.exe` file and
    all you have to do is select a path and follow the steps. Installing it on a Unix/Ubuntu
    machine involves downloading the `deb` file and then executing the following command
    lines:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上安装它是最简单的，因为它是一个`.exe`文件，您只需选择一个路径并按照步骤操作即可。在Unix/Ubuntu机器上安装它涉及下载`deb`文件，然后执行以下命令行：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once VS Code is available, open extensions and download [https://marketplace.visualstudio.com/items?itemName=pmneo.tsimporter](https://marketplace.visualstudio.com/items?itemName=pmneo.tsimporter) and
    [https://marketplace.visualstudio.com/items?itemName=steoates.autoimport](https://marketplace.visualstudio.com/items?itemName=steoates.autoimport).
    We will use the advantages of these extensions, which will be helpful for easy
    code management, prebuilt skeletons, and more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦VS Code可用，打开扩展并下载[https://marketplace.visualstudio.com/items?itemName=pmneo.tsimporter](https://marketplace.visualstudio.com/items?itemName=pmneo.tsimporter)和[https://marketplace.visualstudio.com/items?itemName=steoates.autoimport](https://marketplace.visualstudio.com/items?itemName=steoates.autoimport)。我们将使用这些扩展的优势，这将有助于轻松管理代码、预构建骨架等。
- en: PM2
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PM2
- en: 'It is the advanced processor manager for Node.js. Node.js, being single threaded,
    requires some add-on tools for server management such as restarting server, memory
    management, multiple process management, and so on. It has a built-in load balancer,
    and it allows you to keep the application running forever. It has zero downtime
    and other system admin options that has eased up life. It is also exposed as a
    module, so we can runtime trigger various options at any phase of Node.js applications.
    To install PM2, open up a Terminal and shoot the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它是Node.js的高级处理器管理器。Node.js是单线程的，需要一些附加工具来进行服务器管理，如重新启动服务器、内存管理、多进程管理等。它有一个内置的负载均衡器，并允许您使应用程序永久运行。它具有零停机时间和其他简化生活的系统管理选项。它还作为一个模块暴露出来，因此我们可以在Node.js应用程序的任何阶段运行时触发各种选项。要安装PM2，请打开终端并输入以下命令：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: More detailed options and APIs can be found at [http://pm2.keymetrics.io/docs/usage/pm2-api/](http://pm2.keymetrics.io/docs/usage/pm2-api/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的选项和API可以在[http://pm2.keymetrics.io/docs/usage/pm2-api/](http://pm2.keymetrics.io/docs/usage/pm2-api/)找到。
- en: NGINX
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NGINX
- en: '**NGINX** is one of the most popular web servers. It can be used as a load
    balancer, HTTP cache, reverse proxy, and shock absorber. It has a capacity for
    handling more than 10,000 simultaneous connections with a very low footprint (approximately
    2.5 MB per 10,000 inactive [https://en.wikipedia.org/wiki/HTTP_persistent_connection](https://en.wikipedia.org/wiki/HTTP_persistent_connection)).
    It was specifically designed to overcome Apache. It can roughly handle four times
    more requests per second than Apache. NGINX can be used in various ways, such
    as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**NGINX**是最受欢迎的Web服务器之一。它可以用作负载均衡器、HTTP缓存、反向代理和减震器。它具有处理超过10,000个同时连接的能力，占用空间非常小（大约每10,000个非活动连接占用2.5
    MB [https://en.wikipedia.org/wiki/HTTP_persistent_connection](https://en.wikipedia.org/wiki/HTTP_persistent_connection)）。它专门设计用来克服Apache。它大约可以处理比Apache多四倍的每秒请求。NGINX可以以各种方式使用，例如以下方式：'
- en: Deployed standalone
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立部署
- en: As a frontend proxy for Apache acting as a network offload device
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Apache的前端代理，充当网络卸载设备
- en: Act as a shock absorber, providing servers from a sudden spike in traffic or
    slow internet connections
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充当减震器，防止服务器突然出现的流量激增或慢的互联网连接
- en: It is our perfect fit for microservice applications, as containerized microservice
    applications need a frontend that is able to conceal and deal with the complex
    and ever-changing nature of applications running behind it. It performs some major
    things such as forward HTTP requests to different applications, shock absorber
    protection, routing, consolidated logging, Gzip compression, zero downtime, caching,
    scalability, and fault tolerance. Hence, it is our ideal application delivery
    platform. Let's begin NGINX 101.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它是我们微服务应用程序的完美选择，因为容器化的微服务应用程序需要一个前端，能够隐藏和处理其后运行的应用程序的复杂和不断变化的特性。它执行一些重要的功能，如将HTTP请求转发到不同的应用程序，减震保护，路由，日志记录，Gzip压缩，零停机时间，缓存，可伸缩性和容错性。因此，它是我们理想的应用交付平台。让我们开始NGINX
    101。
- en: Download the latest version from this site, [http://nginx.org/en/download.html](http://nginx.org/en/download.html),
    based on your operating system. At the time of writing, the mainline Version was
    **1.13.7**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个网站[http://nginx.org/en/download.html](http://nginx.org/en/download.html)下载最新版本，根据你的操作系统。在撰写本文时，主线版本是**1.13.7**。
- en: 'Once extracted, you can simply start NGINX as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 解压后，您可以按照以下方式简单地启动NGINX：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To check whether NGINX is up or not you, can hit the following command in Windows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查NGINX是否启动，可以在Windows中输入以下命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the case of Linux, you can use the following command line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux的情况下，您可以使用以下命令行：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following are other useful NGINX commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其他有用的NGINX命令：
- en: '| `nginx -s stop` | Fast shutdown |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `nginx -s stop` | 快速关闭 |'
- en: '| `nginx -s quit` | Graceful shutdown |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `nginx -s quit` | 优雅关闭 |'
- en: '| `nginx -s reload` | Changing configuration, starting new worker processes
    with a new configuration, and graceful shutdown of old worker processes |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `nginx -s reload` | 更改配置，使用新配置启动新的工作进程，并优雅地关闭旧的工作进程 |'
- en: '| `nginx -s reopen` | Re-opening log files |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `nginx -s reopen` | 重新打开日志文件 |'
- en: Docker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: '**Docker** is an open source platform for developing, shipping, and running
    applications with the major advantage of separating your application from your
    infrastructure so you can adapt to major changes easily and quickly. Docker promotes
    the philosophy of containers. A **container** is a runnable instance of any configured
    image. A container is totally isolated from the other containers and the host
    machine. This very much resembles our microservice philosophy. We will see Docker
    in much more detail when we come to the deployment part. Let''s install Docker
    on our system.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker**是一个开源平台，用于开发、发布和运行应用程序，其主要优势是将应用程序与基础架构分离，因此您可以轻松快速地适应重大变化。Docker提倡容器的理念。**容器**是任何配置图像的可运行实例。容器与其他容器和主机完全隔离。这非常类似于我们的微服务理念。当我们进行部署时，我们将更详细地了解Docker。让我们在系统上安装Docker。'
- en: 'Docker for Windows requires Windows 10 Pro edition and Hyper-V. So as a generally
    available alternative, we will go for Linux. Windows users can download Oracle
    VM VirtualBox, download any Linux image, and then follow the same process. Follow
    along with the steps given here: [https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Windows的Docker需要Windows 10专业版和Hyper-V。因此，作为一个普遍可用的替代方案，我们将选择Linux。Windows用户可以下载Oracle
    VM VirtualBox，下载任何Linux镜像，然后按照相同的过程进行。请按照这里给出的步骤进行操作：[https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/)。
- en: 'To check the installation, hit the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查安装情况，请输入以下命令：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see output like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到如下输出：
- en: '![](img/845b957e-1d50-43e4-8650-6dd48e2bd2d0.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/845b957e-1d50-43e4-8650-6dd48e2bd2d0.jpg)'
- en: Docker installation
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker安装
- en: Primer to TypeScript
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript入门
- en: '**TypeScript** originated from shortcomings in JavaScript development with
    the advent of using JavaScript for large-scale applications. TypeScript introduced
    a JavaScript compiler with presets of syntactical language extensions, class-based
    programming, and ways to convert extensions into regular JavaScript. TypeScript
    became extremely popular as it introduced type safety in JavaScript, which happens
    to be one of the most flexible languages ever. This enables JavaScript to be a
    more object-oriented and compile safe language. TypeScript is more of a superset
    of ES standards, which enables developers to write cleaner, easy-to-refactor,
    and upgradable code. In this section, we will go through various primary topics
    of TypeScript, which are essential for our journey ahead. TypeScript is JavaScript
    with type annotations. TypeScript has a transpiler and type checker, which throws
    an error if there is a mismatch in types, and converts TypeScript code to JavaScript
    code. We will look at the following topics briefly, which will essentially help
    us to write Node.js in TypeScript:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript**起源于JavaScript开发中的缺陷，随着将JavaScript用于大规模应用的出现。TypeScript引入了一个JavaScript编译器，具有语法语言扩展的预设、基于类的编程和将扩展转换为常规JavaScript的方法。TypeScript因引入了JavaScript的类型安全而变得极为流行，而JavaScript恰好是最灵活的语言之一。这使JavaScript成为了一种更面向对象和编译安全的语言。TypeScript更像是ES标准的超集，它使开发人员能够编写更清晰、易于重构和可升级的代码。在本节中，我们将介绍TypeScript的各种主要主题，这对我们未来的旅程至关重要。TypeScript是带有类型注释的JavaScript。TypeScript具有一个转译器和类型检查器，如果类型不匹配，则会抛出错误，并将TypeScript代码转换为JavaScript代码。我们将简要介绍以下主题，这些主题基本上将帮助我们编写TypeScript中的Node.js：'
- en: Understanding `tsconfig.json`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`tsconfig.json`
- en: Understanding types
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类型
- en: Debugging TypeScript in Node.js
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js中调试TypeScript
- en: Understanding tsconfig.json
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解tsconfig.json
- en: 'Adding a `tsconfig.json` file is an indication of having a directory that is
    of a TypeScript project, and a configuration file is needed to compile the TypeScript
    into JavaScript. You compile the TypeScript into JavaScript by using the `tsc`
    command. Invoking it, the compiler searches for configurations loaded in `tsconfig.json`.
    You can specify compilation for a complete project (from the current directory
    to the parent directory) or you can specify `tsc` for a particular project. You
    can find all possible options using the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`tsconfig.json`文件表示有一个TypeScript项目的目录，并且需要一个配置文件来将TypeScript编译成JavaScript。您可以使用`tsc`命令将TypeScript编译成JavaScript。调用它，编译器会搜索在`tsconfig.json`中加载的配置。您可以指定对整个项目（从当前目录到父目录）的编译，或者您可以为特定项目指定`tsc`。您可以使用以下命令找到所有可能的选项：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s have a look at what the command does:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个命令做了什么：
- en: '![](img/33387b74-28e6-4c61-ae9b-48fe117bb972.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33387b74-28e6-4c61-ae9b-48fe117bb972.png)'
- en: The tsc help command
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: tsc帮助命令
- en: 'At the time of writing, the version of TypeScript is **2.6.2** and all context
    would be made from the same version. If you do not have the updated version, run
    the following commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写时，TypeScript的版本为**2.6.2**，所有上下文都将基于相同的版本进行。如果您没有更新的版本，请运行以下命令：
- en: '`npm uninstall typescript -g`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm uninstall typescript -g`'
- en: '`npm install typescript@latest -g`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install typescript@latest -g`'
- en: 'Let''s now look into the sample `tsconfig.json` file and all options that are
    available:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下示例`tsconfig.json`文件和所有可用的选项：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's now dissect this file and understand the most common options used.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解析这个文件，并了解最常用的选项。
- en: compilerOptions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: compilerOptions
- en: 'All settings required to compile the project are mentioned here. A detailed
    list of all the compiler options, along with default values, can be found at this
    site: [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html).
    If we don''t specify this option, then the default values will be picked up. This
    is the file from where we instruct TypeScript on how to handle various things
    such as various decorators, supporting JSX files, and transpiling pure JavaScript
    files. The following are some of the most commonly used options, which we can
    understand with respect to the preceding sample code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到了编译项目所需的所有设置。可以在此网站找到所有编译器选项的详细列表，以及默认值：[https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)。如果我们不指定此选项，那么将选择默认值。这是我们指示TypeScript如何处理各种事物的文件，例如各种装饰器、支持JSX文件和转译纯JavaScript文件。以下是一些最常用的选项，我们可以根据前面的示例代码了解：
- en: '| `noImplicitAny` | This tells the `tsc` compiler to shout if it finds variable
    declarations that have declarations which accept any types, but the explicit type
    definition for any type is missing. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `noImplicitAny` | 这告诉`tsc`编译器，如果发现变量声明具有接受任何类型的声明，但缺少任何类型的显式类型定义，则会发出警告。
    |'
- en: '| `experimentalDecorators` | This option enables using decorators in TypeScript
    projects. ES has not yet introduced decorators, so they are disabled by default.
    A decorator is any declaration that can be attached to class declarations, method,
    accessors, properties, or parameters. Using decorators simplifies programming.
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `experimentalDecorators` | 此选项启用在TypeScript项目中使用装饰器。ES尚未引入装饰器，因此默认情况下它们是禁用的。装饰器是可以附加到类声明、方法、访问器、属性或参数的任何声明。使用装饰器简化了编程。
    |'
- en: '| `emitDecoratorMetaData` | TypeScript supports emitting certain types of metadata
    for any declarations that have decorators. To enable this option, it must be set
    to true in `tsconfig.json`. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `emitDecoratorMetaData` | TypeScript支持为具有装饰器的任何声明发出某些类型的元数据。要启用此选项，必须在`tsconfig.json`中将其设置为true。
    |'
- en: '| `watch` | This option is more like `livereload`; whenever any of the source
    file is changed, then the compiling process is re-triggered to generate the transpiled
    files again. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `watch` | 此选项更像是`livereload`；每当源文件中的任何文件更改时，编译过程将重新触发，以再次生成转译文件。 |'
- en: '| `reflect-metadata` | It preserves the type information in an object''s metadata.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `reflect-metadata` | 它保留对象元数据中的类型信息。 |'
- en: '| `module` | It is the output module type. Node.js uses CommonJS, so that is
    why there are CommonJS in modules. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `module` | 这是输出模块类型。Node.js 使用 CommonJS，所以模块中有 CommonJS。|'
- en: '| `target` | The output presets we are targeting; Node.js uses ES6, so we use
    ES6. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `target` | 我们正在针对的输出预设；Node.js 使用 ES6，所以我们使用 ES6。|'
- en: '| `moduleResolution` | This option will tell TypeScript which resolution strategy
    to use. Node.js users require a module strategy, so TypeScript then uses this
    behavior to resolve these dependencies. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `moduleResolution` | 此选项将告诉 TypeScript 使用哪种解析策略。Node.js 用户需要一个模块策略，因此 TypeScript
    使用此行为来解析这些依赖项。|'
- en: '| `sourceMap` | This tells TypeScript to generate the sourcemaps, which can
    be easily used to debug TypeScript just like we debug JavaScript. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `sourceMap` | 这告诉 TypeScript 生成源映射，可以像调试 JavaScript 一样轻松地用于调试 TypeScript。|'
- en: '| `outDir` | The location in which the transpiled files should be kept. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `outDir` | 应该保存转换后文件的位置。|'
- en: '| `baseUrl` and `paths` | Instructing TypeScript where it can find the type
    files. We basically tell TypeScript that for every (`*`) found in the `.ts` file,
    it needs to look in the file location `<base_url> + src/types/*`. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `baseUrl` 和 `paths` | 指导 TypeScript 在哪里可以找到类型文件。我们基本上告诉 TypeScript 对于每个（`*`）在
    `.ts` 文件中找到的内容，它需要在文件位置 `<base_url> + src/types/*` 中查找。|'
- en: include and exclude
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包括和排除
- en: Here, we define our project context. It basically takes an array of global patterns
    that need to be included in the compilation path. You can include or exclude an
    array of global patterns that adds or removes files to the transpilation process.
    Note that this is not the final value; there are property files that take an array
    of filenames and they override include and exclude.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了项目的上下文。它基本上采用了一个需要包含在编译路径中的全局模式数组。您可以包含或排除一组全局模式，以添加或删除文件到转换过程中。请注意，这不是最终值；还有属性文件，它们接受文件名数组，并覆盖包含和排除。
- en: extends
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: extends
- en: If we want to extend any of the base configurations, then we use this option
    and specify the file path that it has to extend. You can find the complete schema
    of `tsconfig.json` at [http://json.schemastore.org/tsconfig](http://json.schemastore.org/tsconfig).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要扩展任何基本配置，那么我们可以使用此选项并指定它必须扩展的文件路径。您可以在 [http://json.schemastore.org/tsconfig](http://json.schemastore.org/tsconfig)
    找到 `tsconfig.json` 的完整模式。
- en: Understanding types
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型
- en: TypeScript needs to span across other JavaScript libraries too if we want to
    efficiently and globally use TypeScript. TypeScript uses the `.d.ts` files to
    provide types of JavaScript libraries that were not written in ES6 or TypeScript.
    Once the `.d.ts` file is defined, it becomes very easy to see the return types
    and provide easy type checking. The TypeScript community is very active and it
    provides types for most files: [https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要有效地和全局地使用 TypeScript，TypeScript 需要跨越其他 JavaScript 库。TypeScript 使用 `.d.ts`
    文件来提供未在 ES6 或 TypeScript 中编写的 JavaScript 库的类型。一旦定义了 `.d.ts` 文件，就可以很容易地看到返回类型并提供简单的类型检查。TypeScript
    社区非常活跃，并为大多数文件提供类型：[https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types)。
- en: 'Revisiting our `tsconfig.json` file, we have specified the option `noImplicitAny:
    true` and we need a mandatory `*.d.ts` file for any of the libraries we use. If
    we set that option to false, `tsc` will not give any errors, but that''s not a
    recommended practice at all. Having an `index.d.ts` file for every library we
    use is one of the standard practices. We''ll look at various topics such as how
    to install types, what if types are not available, how to generate types, and
    what the general processes for types are.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '重新审视我们的 `tsconfig.json` 文件，我们已经指定了选项 `noImplicitAny: true`，并且我们需要为我们使用的任何库都有一个强制的
    `*.d.ts` 文件。如果将该选项设置为 false，`tsc` 将不会给出任何错误，但这绝对不是推荐的做法。为我们使用的每个库都有一个 `index.d.ts`
    文件是标准做法之一。我们将看看各种主题，比如如何安装类型，如果类型不可用怎么办，如何生成类型，以及类型的一般流程是什么。'
- en: Installing types from DefinitelyTyped
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 DefinitelyTyped 安装类型
- en: 'Types from any library would be a `dev` dependency and all you have to do is
    install it from `npm`. The following command installs express types:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 任何库的类型都将是一个 `dev` 依赖项，您只需从 `npm` 安装它。以下命令安装 express 类型：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command downloads the express type to the `@types` folder, and TypeScript
    looks in the `@types` folder to resolve mappings for that type. As we only need
    it during development time, we have added the `--save-dev` option.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将下载 express 类型到 `@types` 文件夹，并且 TypeScript 会在 `@types` 文件夹中查找以解析该类型的映射。由于我们只在开发时需要它，所以我们添加了
    `--save-dev` 选项。
- en: Writing your own types
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的类型
- en: Many times we may need to write our own `.d.ts` file in order to efficiently
    use TypeScript. We will look at how we can generate our own typing and instruct
    TypeScript from where to find the types. We will use the automated tool and learn
    ways to manually write our own `.d.ts` file, then tell TypeScript where to find
    a location of custom types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，我们可能需要编写自己的 `.d.ts` 文件，以便有效地使用 TypeScript。我们将看看如何生成我们自己的类型，并指导 TypeScript
    从哪里找到这些类型。我们将使用自动化工具，并学习如何手动编写我们自己的 `.d.ts` 文件，然后告诉 TypeScript 在哪里找到自定义类型的位置。
- en: Using the dts-gen tool
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 dts-gen 工具
- en: 'This is an open sourced utility provided by Microsoft. We will use it to generate
    our typings for any project. Shoot up a Terminal as Admin or use `sudo su -` and
    enter the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微软提供的一个开源实用工具。我们将使用它为任何项目生成我们的类型。作为管理员启动终端，或者使用 `sudo su -` 并输入以下内容：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For all global modules, we will use the command prompt as Admin for Windows,
    and for Linux/Mac we will use the root user or `sudo su -`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有全局模块，我们将在 Windows 上使用命令提示符作为管理员，而在 Linux/Mac 上，我们将使用 root 用户或 `sudo su -`。
- en: 'We will use one globally available module and generate its typing. Install
    `lusca` and generate its typing using the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个全局可用的模块并生成其类型。安装 `lusca` 并使用以下命令生成其类型：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should see output such as `Wrote 83 Lines to lusca.d.ts`, and when you check,
    you can see all method declarations there, just like an interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到输出，比如`Wrote 83 Lines to lusca.d.ts`，当你检查时，你可以看到所有的方法声明，就像一个接口一样。
- en: Writing your own *.d.ts file
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你自己的*.d.ts文件
- en: 'When you are writing your own `*.d.ts` file, the stakes are very high. Let''s
    create our own `*.d.ts` file for any module. Say we want to write a module for
    `my-custom-library`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写自己的`*.d.ts`文件时，风险非常高。让我们为任何模块创建我们自己的`*.d.ts`文件。比如我们想为`my-custom-library`编写一个模块：
- en: 'Create one blank file called `my-custom-library.d.ts` and write the following
    inside it:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`my-custom-library.d.ts`的空文件，并在其中写入以下内容：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will silence the compiler and won't throw any errors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使编译器静音，不会抛出任何错误。
- en: 'Next, you need to define all the methods there and what the return type expected
    out of each method is. You can find several templates here: [http://www.typescriptlang.org/docs/handbook/declaration-files/templates.html](http://www.typescriptlang.org/docs/handbook/declaration-files/templates.html).
    Here, we need to define the available methods and what they are returning. For
    example, take a look at the following code snippet:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要在那里定义所有的方法以及每个方法期望的返回类型。你可以在这里找到几个模板：[http://www.typescriptlang.org/docs/handbook/declaration-files/templates.html](http://www.typescriptlang.org/docs/handbook/declaration-files/templates.html)。在这里，我们需要定义可用的方法以及它们的返回值。例如，看一下以下代码片段：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Debugging
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: The next big important question would how to debug a Node.js application return
    in TypeScript. Debugging JavaScript was easy, and to give the same experience
    TypeScript has a feature called **sourcemaps**. When sourcemaps are enabled in
    TypeScript, it allows us to drop breakpoints in TypeScript code, which will be
    paused when the equivalent line of JavaScript is hit. The sole purpose of sourcemaps
    is to map the generated source to the original source that generated it. We will
    briefly see debugging a Node.js, and TypeScript application in our editor VS Code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的问题是如何调试返回TypeScript的Node.js应用程序。调试JavaScript很容易，为了提供相同的体验，TypeScript有一个名为**sourcemaps**的功能。当TypeScript中启用sourcemaps时，它允许我们在TypeScript代码中设置断点，当命中等效的JavaScript行时会暂停。sourcemaps的唯一目的是将生成的源映射到生成它的原始源。我们将简要看一下在我们的编辑器VS
    Code中调试Node.js和TypeScript应用程序。
- en: 'Primarily, we need to enable sourcemaps. First of all, we need to ensure that
    TypeScript has sourcemap generation enabled. Go to your `tsconfig.json` file and
    write the following content:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要启用sourcemaps。首先，我们需要确保TypeScript已启用sourcemaps生成。打开你的`tsconfig.json`文件，并写入以下内容：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now when you transpile your project, next to every JavaScript file you generate
    you will see a `.js.map` file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你转译你的项目时，你会在生成的每个JavaScript文件旁边看到一个`.js.map`文件。
- en: The next thing is to configure VS Code for debugging. Go create a folder, `.vscode`,
    and add a file named `launch.json`. This is very similar to using `node-inspector`.
    We will debug the `node-clusters` project, which you can find in the source code.
    Open that project in VS Code; if it doesn't have a `dist` folder then generate
    a distribution by executing the `tsc` command at the main level, which will create
    the `dist` folder.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是配置VS Code进行调试。创建一个名为`.vscode`的文件夹，并添加一个名为`launch.json`的文件。这与使用`node-inspector`非常相似。我们将调试`node-clusters`项目，你可以在源代码中找到。在VS
    Code中打开该项目；如果没有`dist`文件夹，则在主级别执行`tsc`命令生成一个分发，这将创建`dist`文件夹。
- en: 'Next, create a folder named `.vscode` and inside it create a `launch.json`
    file with the following configurations:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`.vscode`的文件夹，在其中创建一个名为`launch.json`的文件，并进行以下配置：
- en: '![](img/2482e26a-b450-4d4d-82a0-d2400b8ad5ca.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2482e26a-b450-4d4d-82a0-d2400b8ad5ca.png)'
- en: VS Code debugging
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code调试
- en: 'When you click on Start Debugging, the following screen appears. Look at the
    screen, which has a detailed description of debugging points:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击开始调试时，会出现以下屏幕。看一下屏幕，其中有关调试点的详细描述：
- en: '![](img/bf105aad-376e-4e7d-840a-bc795f0b03d3.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf105aad-376e-4e7d-840a-bc795f0b03d3.png)'
- en: VS debugger
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: VS调试器
- en: Primer to Node.js
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js入门
- en: Node.js has evolved over the years and has now become the go-to technology for
    anyone who wants to embrace microservices. Node.js was created to solve the massive
    I/O scaling problem, which when applied to our microservice design will result
    in a match made in heaven. The package manager for Node.js has more modules than
    Maven, RubyGems, and NuGet, which can be used directly and save lots of productive
    hours. Characteristics such as an asynchronous nature, event-driven I/O, and non-blocking
    mode make it one of the best solutions for creating high-end, efficient performance,
    real-time applications. When applied to microservices, it will be able to handle
    an extreme amount of load with low response times and low infrastructure. Let's
    look at one of the success stories of Node.js and microservices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js经过多年的发展，现在已成为任何想要拥抱微服务的人的首选技术。Node.js是为了解决大规模I/O扩展问题而创建的，当应用于我们的微服务设计时，将会产生一种天作之合。Node.js的包管理器比Maven、RubyGems和NuGet拥有更多的模块，可以直接使用并节省大量的生产时间。异步性质、事件驱动I/O和非阻塞模式等特性使其成为创建高端、高效性能、实时应用程序的最佳解决方案之一。当应用于微服务时，它将能够处理极大量的负载，响应时间低，基础设施低。让我们来看一下Node.js和微服务的成功案例之一。
- en: '**PayPal**, seeing the trending Node.js, decided to go with Node.js in their
    accounts overview page. They were bewildered by the following results:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**PayPal**看到Node.js的趋势，决定在他们的账户概览页面使用Node.js。他们对以下结果感到困惑：'
- en: Node.js application development was developed at twice the rate of Java development
    and with fewer people
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js应用程序开发的速度是Java开发的两倍，而且人手更少
- en: The code had 33% fewer **Lines of Code** (**LOC**) and 40% fewer files
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的**行数**（**LOC**）减少了33%，文件减少了40%
- en: A single core Node.js application handled double the requests per second when
    compared to five core Java application setups
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单核Node.js应用程序处理的请求每秒是五核Java应用程序设置的两倍
- en: Netflix, GoDaddy, Walmart, and many more have similar stories.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix、GoDaddy、Walmart等许多公司都有类似的故事。
- en: Let's look at some of the primary and useful concepts essential for Node.js
    development that we will use throughout our journey. We will see various topics
    such as the Event Loop, how to achieve clustering, async fundamentals, and more.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些对Node.js开发至关重要的主要和有用的概念，这些概念将贯穿我们的旅程。我们将涉及各种主题，如事件循环、如何实现集群、异步基础知识等。
- en: Event Loop
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环
- en: Due to the single-threaded design of Node.js, it is considered to be one of
    the most complicated architectures. Being completely event-driven, understanding
    Event Loop is key to mastering Node.js. Node.js is designed as an event-based
    platform, meaning anything that occurs in Node.js is just a reaction to an event.
    Any operation done in Node.js passes through a series of callbacks. The complete
    logic is abstracted from developers and is handled by a library called `libuv`.
    We will gain a thorough understanding of the Event Loop in this section including
    how it works, common misconceptions, its various phases, and more.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node.js的单线程设计，它被认为是最复杂的架构之一。作为完全事件驱动的，理解事件循环对于掌握Node.js至关重要。Node.js被设计为一个基于事件的平台，这意味着在Node.js中发生的任何事情都只是对事件的反应。在Node.js中进行的任何操作都会经过一系列的回调。完整的逻辑被开发人员抽象出来，并由一个名为`libuv`的库处理。在本节中，我们将对事件循环有一个全面的了解，包括它的工作原理、常见误解、各种阶段等。
- en: 'The following are some of the common myths about Event Loop and a brief on
    the actual workings:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于事件循环的一些常见谬误以及实际工作的简要介绍：
- en: '**Myth#1—Event Loop works in a different thread than the use code**: There
    are two threads maintained, one parent thread where the user-related code or user-related
    operations run, and another where the event looping code runs. Any time  an operation
    is executed, the parent thread passes over the work to the child thread, and once
    the child thread operation is completed, it pings the main thread to execute the
    callback:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谬误#1—事件循环在与用户代码不同的线程中工作**：有两个线程，一个是用户相关代码或用户相关操作运行的父线程，另一个是事件循环代码运行的线程。任何时候执行操作，父线程将工作传递给子线程，一旦子线程操作完成，就会通知主线程执行回调：'
- en: '**Fact**: Node.js is single-threaded and everything runs inside the single
    thread. Event Loop maintains the execution of the callback.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事实**：Node.js是单线程的，一切都在单个线程内运行。事件循环维护回调的执行。'
- en: '**Myth#2—Thread pool handles asynchronous events**: All asynchronous operations,
    such as callbacks to data returned by a database, reading filestream data, and
    WebSockets streams, are off loaded from a thread pool maintained by `libuv`:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谬误#2—线程池处理异步事件**：所有异步操作，如回调到数据库返回的数据，读取文件流数据和WebSockets流，都会从`libuv`维护的线程池中卸载：'
- en: '**Fact**: The `libuv` library indeed creates a thread pool with four threads
    to pass on the asynchronous work, but today''s operating systems already provide
    such interfaces. So as a golden rule, `libuv` will use those asynchronous interfaces
    rather than the thread pool. The thread pool will only be used as the last alternative.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事实**：`libuv`库确实创建了一个包含四个线程的线程池来传递异步工作，但今天的操作系统已经提供了这样的接口。因此，作为一个黄金法则，`libuv`将使用这些异步接口而不是线程池。线程池只会被用作最后的选择。'
- en: '**Myth#3—Event Loop, like a CPU, maintains a stack or queue of operations**:
    The Event Loop goes through a maintained queue of asynchronous tasks maintained
    via the *FIFO rule*, and executes the defined callbacks maintained in a queue:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谬误#3—事件循环像CPU一样维护操作的堆栈或队列**：事件循环按照*FIFO规则*维护一系列异步任务的队列，并执行队列中维护的定义的回调：'
- en: '**Fact**: While there are queue-like structures involved in `libuv`, the callbacks
    are not processed through a stack. The Event Loop is more of a phase executioner
    with tasks processed in a round-robin manner.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事实**：虽然`libuv`中涉及类似队列的结构，但回调并不是通过堆栈处理的。事件循环更像是一个阶段执行器，任务以循环方式处理。'
- en: Understanding Event Loop
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: 'Now that we have ruled out basic misconceptions regarding Event Loop in Node.js,
    let''s look at the workings of Event Loop in detail and all the phases that are
    in the Event Loop phase execution cycle. Node.js processes everything occurring
    in the environment in the following phases:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经排除了关于Node.js中事件循环的基本误解，让我们详细了解事件循环的工作原理以及事件循环阶段执行周期中的所有阶段。Node.js在以下阶段处理环境中发生的所有事情：
- en: '**Timers**: This is the phase where all the `setTimeout()` and `setInterval()`
    callbacks are executed. This phase will run early because it has to be executed
    in the time interval specified in the calling functions. When the timer is scheduled,
    then as long as the timer is active the Node.js Event Loop will continue to run.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定时器**：这是所有`setTimeout()`和`setInterval()`回调被执行的阶段。这个阶段会尽早运行，因为它必须在调用函数中指定的时间间隔内执行。当定时器被安排时，只要定时器是活动的，Node.js事件循环将继续运行。'
- en: '**I/O callbacks**: Most common callbacks are executed here except timers, close
    connection events, `setImmediate()`. An I/O request can be blocking as well as
    non-blocking. It executes more things such as connection error, failed to connect
    to a database, and so on.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I/O回调**：除了定时器、关闭连接事件、`setImmediate()`之外，大多数常见的回调都在这里执行。I/O请求既可以是阻塞的，也可以是非阻塞的。它执行更多的事情，比如连接错误，无法连接到数据库等。'
- en: '**Poll**: This phase executes the scripts for timers when the threshold has
    elapsed. It processes events maintained in the poll queue. If the poll queue is
    not empty, the Event Loop will iterate through the entire queue synchronously
    until the queue empties out or the system hard peak size is reached. If the poll
    queue is empty, the Event Loop continues with the next phase—it checks and executes
    those timers. If there are no timers, the poll queue is free; it waits for the
    next callback and executes it immediately.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮询**：当阈值已经过去时，这个阶段执行定时器的脚本。它处理轮询队列中维护的事件。如果轮询队列不为空，事件循环将同步迭代整个队列，直到队列为空或系统达到硬峰值大小。如果轮询队列为空，事件循环将继续下一个阶段——检查并执行那些定时器。如果没有定时器，轮询队列是空闲的，它将等待下一个回调并立即执行它。'
- en: '**Check**: When the poll phase is idle, the check phase is executed. Scripts
    that have been queued with `setImmediate()` will be executed now. `setImmediate()`
    is a special timer that has use of the `libuv` API and it schedules callbacks
    to be executed after the poll phase. It is designed in such a way that it executes
    after the poll phase.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查**：当轮询阶段处于空闲状态时，将执行检查阶段。现在将执行使用`setImmediate()`排队的脚本。`setImmediate()`是一个特殊的计时器，它使用`libuv`
    API，并且安排在轮询阶段之后执行回调。它被设计成在轮询阶段之后执行。'
- en: '**Close callbacks**: When any handle, socket, or connection is closed abruptly,
    the close event is emitted in this phase, such as `socket.destroy()`, connection
    `close()`, that is, all on (`close`) event callbacks are processed here. Not technically
    parts of the Event Loop, but two other major phases are `nextTickQueue` and other
    micro tasks queue. The `nextTickQueue` processes after the current operation gets
    completed, regardless of the phase of Event Loop. It is fired immediately, in
    the same phase it was called, and is independent from all phases. The `nextTick` function
    can contain any tasks and they are just invoked as follows:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭回调**：当任何句柄、套接字或连接突然关闭时，将在此阶段发出关闭事件，例如`socket.destroy()`，连接`close()`，也就是说，所有(`close`)事件回调都在此处处理。虽然不是事件循环的技术部分，但另外两个主要阶段是`nextTickQueue`和其他微任务队列。`nextTickQueue`在当前操作完成后处理，不管事件循环的阶段如何。它会立即触发，在调用它的同一阶段，并且独立于所有阶段。`nextTick` 函数可以包含任何任务，它们只是按照以下方式调用：'
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The next important part is the micro and the macro tasks. `NextTickQueue` has
    higher priority over micro and macro tasks. Any task that is in `nextTickQueue`
    will be executed first. Micro tasks include functions such as resolved promise
    callbacks. Some examples of micro tasks can be `promise.resolve`, `Object.resolve`.
    An interesting point to note here is native promises only come under micro tasks.
    If we use libraries such as `q` or `bluebird`, we will see them getting resolved
    first.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来重要的部分是微任务和宏任务。`NextTickQueue`的优先级高于微任务和宏任务。任何在`nextTickQueue`中的任务都将首先执行。微任务包括已解决的promise回调等函数。一些微任务的例子可以是`promise.resolve`，`Object.resolve`。这里有一个有趣的地方要注意，原生promise只属于微任务。如果我们使用`q`或`bluebird`等库，我们会看到它们首先被解决。
- en: Node.js clusters and multithreading
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js集群和多线程
- en: 'Any Node.js instance runs in a single thread. If any error occurs, the thread
    breaks, the server stops, and you need to restart the server. To take advantage
    of all the cores available in a system, Node.js provides an option to launch a
    cluster of Node.js processes so that the load is evenly distributed. There are
    many tools available that do the same thing. We will look at a basic example and
    then learn about automated tools such as **PM2**. Let''s get started:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Node.js实例都在单个线程中运行。如果发生任何错误，线程会中断，服务器会停止，你需要重新启动服务器。为了利用系统中所有可用的核心，Node.js提供了启动一组Node.js进程的选项，以便负载均衡。有许多可用的工具可以做同样的事情。我们将看一个基本的例子，然后学习关于**PM2**这样的自动化工具。让我们开始吧：
- en: 'The first step is to create an express server. We will need `express`, `debug`,
    `body-parser`, and `cookie-parser`. Open up a Terminal and hit the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个express服务器。我们需要`express`，`debug`，`body-parser`和`cookie-parser`。打开终端并输入以下命令：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we download the types for these modules:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们下载这些模块的类型：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we create our `app.ts` and `www.ts` files. Construct your `app.ts` file
    as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的`app.ts`和`www.ts`文件。构建你的`app.ts`文件如下：
- en: '![](img/5668248a-a9ed-4562-95b5-64d65ca58e95.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5668248a-a9ed-4562-95b5-64d65ca58e95.png)'
- en: Express the TypeScript way
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表达TypeScript的方式
- en: 'For `www.ts`, we will use the `cluster` module and create workers available
    as a number of cores. Our logic would be divided as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`www.ts`，我们将使用`cluster`模块，并创建可用作核心数量的工作进程。我们的逻辑将分为以下几部分：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now when we transpile the source and run `www.js`, we will see multiple workers
    online.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在当我们转译源代码并运行`www.js`时，我们会看到多个工作进程在线。
- en: Complete files can be found at `node-clusters/src/bin/www.ts`. Go and run the
    application. You should see multiple workers online now.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文件可以在`node-clusters/src/bin/www.ts`中找到。去运行应用程序。现在你应该看到多个工作进程在线了。
- en: 'An alternative approach is to use *PM2* ([https://www.npmjs.com/package/pm2](https://www.npmjs.com/package/pm2)).
    PM2 has various options for `livereload`, reload with zero downtime, and starting
    mode in clusters. Some sample commands available in PM2 are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用*PM2* ([https://www.npmjs.com/package/pm2](https://www.npmjs.com/package/pm2))。PM2有各种选项，如`livereload`，零停机重新加载和集群启动模式。PM2中可用的一些示例命令如下：
- en: '| `pm2 start www.js -i 4` | Start four instances of an application in cluster
    mode. It will load balance requests to each node. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 start www.js -i 4` | 在集群模式下启动应用程序的四个实例。它将平衡负载到每个节点。|'
- en: '| `pm2 reload www.js` | Zero downtime needed for reloading `www.js` with changes.
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 reload www.js` | 重新加载`www.js`并进行零停机时间。|'
- en: '| `pm2 scale www.js 10` | Scaling clustered apps to 10 processes. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 scale www.js 10` | 将集群应用程序扩展到10个进程。|'
- en: Async/await
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步/等待
- en: 'As JavaScript is asynchronous in nature, it becomes very difficult to maintain
    the execution of tasks once a process is completed. What once started with callbacks
    soon turned to promises, async module, generators and yield, and async and await.
    Let''s start with async/await 101:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript是异步的，一旦一个进程完成，就很难维护任务的执行。曾经以回调开始，很快就转向了promises、async模块、生成器和yield，以及async和await。让我们从async/await
    101开始：
- en: Async/await is one of the modern ways to write asynchronous code
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步/等待是编写异步代码的现代方式之一
- en: Built on top of promises, it cannot be used with plain callbacks or Node promises
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立在promise之上，不能与普通回调或Node promises一起使用
- en: Async/await is non-blocking code even though it appears synchronous, which is
    its main power
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步/等待是非阻塞代码，尽管它看起来是同步的，这是它的主要优势
- en: Based on `node-fibers`, it is lightweight and is TypeScript friendly as typings
    are embedded
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于`node-fibers`，它是轻量级的，并且对TypeScript友好，因为类型已嵌入其中
- en: 'Let''s now see a practical implementation of async/await. What once started
    as huge callback hell and nested chains of `.then()` can simply be reduced to
    the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下async/await的实际实现。曾经作为巨大的回调地狱和嵌套的`.then()`链的东西现在可以简化为以下内容：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will now look into two common async/await design patterns.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将研究两种常见的async/await设计模式。
- en: Retrying failed requests
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试失败的请求
- en: 'Often, we add back safe or retry requests in our system to make sure that if
    the service returns errors, we can retry the service if it is down for some time.
    In this sample, we have used an async/await pattern efficiently as an exponential
    retry parameter, that is, retry after 1, 2, 4, 8, and 16 seconds. A working example
    can be found in `retry_failed_req.ts` in a source code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在系统中添加安全或重试请求，以确保如果服务返回错误，我们可以在服务暂时关闭时重试服务。在此示例中，我们有效地使用了异步/等待模式作为指数重试参数，即1、2、4、8和16秒后重试。可以在源代码中的`retry_failed_req.ts`中找到一个工作示例：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will see output like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![](img/0133f7eb-5ef3-4e79-a29e-49463ddb510a.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0133f7eb-5ef3-4e79-a29e-49463ddb510a.jpg)'
- en: Retrying request exponentially
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 指数重试请求
- en: Multiple requests in parallel
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行多个请求
- en: 'Executing multiple parallel requests becomes a piece of cake with async/await.
    Here, we can execute several asynchronous tasks at once, and use their values
    in different places. The complete source code can be found at `multiple_parallel.ts`
    in `src`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用async/await执行多个并行请求变得非常简单。在这里，我们可以同时执行多个异步任务，并在不同的地方使用它们的值。完整的源代码可以在`src`中的`multiple_parallel.ts`中找到：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Streams
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流
- en: 'Briefly, a **stream** is an abstract interface for streaming data continuously
    in Node.js. A stream can be a sequence of data coming over time from a source
    and running to a destination. The source can be anything—a database of 50 million
    records, a file of size 4.5 GB, some HTTP call, and so on. Streams are not available
    all at once; they don''t fit in memory, they just come some chunks at a time.
    Streams are not only for handling large files or a huge amount of data, but also
    they give us a good option of composability through piping and chaining. Streams
    are one of the ways to do reactive programming, which we will look at in more
    detail in the next chapter. There are four streams available in Node.js:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**流**是Node.js中用于连续流式传输数据的抽象接口。流可以是从源头不断传输数据到目的地的数据序列。源头可以是任何东西——5000万条记录的数据库，大小为4.5GB的文件，一些HTTP调用等等。流不是一次性全部可用的；它们不适合内存，它们只是一次传输一些数据块。流不仅用于处理大文件或大量数据，而且它们通过管道和链接提供了一个很好的组合选项。流是响应式编程的一种方式，我们将在下一章中更详细地讨论。Node.js中有四种流可用：
- en: '**Readable stream**: The streams from which data can be read only; that is,
    here data can only be consumed. Examples of readable streams can be HTTP responses
    on the client, `zlib` streams, and `fs` read streams. Data at any stage in this
    stream will either be in a flowing state or paused state. On any readable stream,
    various events can be attached such as data, error, end, and readable.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读流**：只能从中读取数据的流；也就是说，这里只能消耗数据。可读流的示例可以是客户端上的HTTP响应、`zlib`流和`fs`读取流。该流中的任何阶段的数据都处于流动状态或暂停状态。在任何可读流上，可以附加各种事件，如数据、错误、结束和可读。'
- en: '**Writable stream**: Streams to which data can be written. For example, `fs.createWriteStream()`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可写流**：可以写入数据的流。例如，`fs.createWriteStream()`。'
- en: '**Duplex stream**: Streams that are both readable and writable. For example,
    `net.socket` or a TCP socket.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双工流**：可读可写的流。例如，`net.socket`或TCP套接字。'
- en: '**Transform stream**: A transform stream is basically a duplex stream that
    can be used to transform data while it is being written or read. For example,
    `zlib.createGzip` is one of the streams to compress a lot of data using gzip.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换流**：基本上是一个双工流，可以在写入或读取数据时用于转换数据。例如，`zlib.createGzip`是用于使用gzip压缩大量数据的流之一。'
- en: 'Now, let''s understand the workings of a stream via an example. We will create
    a custom `Transform` stream and extend the `Transform` class, thus seeing read,
    write, and transform operations all at once. Here, the output of the transform
    stream will be computed from its input:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个示例来了解流的工作原理。我们将创建一个自定义的`Transform`流，并扩展`Transform`类，从而一次看到读取、写入和转换操作。在这里，转换流的输出将从其输入中计算出来：
- en: '**Problem**: We have a user''s information and we want to hide sensitive parts
    such as email address, phone number, and so on.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：我们有用户的信息，我们想隐藏敏感部分，如电子邮件地址、电话号码等。'
- en: '**Solution**: We will create one transform stream. The transform stream will
    read data and transform it by removing sensitive information. So, let''s start
    coding. Create one empty project with `npm init`, add one folder, `src`, and the `tsconfig.json` file
    of the earlier section. Now, we will add Node.js typings from `DefinitelyTyped`.
    Open up a Terminal and type the following:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：我们将创建一个转换流。转换流将读取数据并通过删除敏感信息来进行转换。所以，让我们开始编码。创建一个空项目，使用`npm init`，添加一个文件夹`src`和之前部分的`tsconfig.json`文件。现在，我们将从`DefinitelyTyped`中添加Node.js类型。打开终端并输入以下内容：'
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we will write our custom filter transform stream. Create a `filter_stream.ts`
    file and inside it, let''s write the transform logic:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写我们自定义的过滤器转换流。创建一个`filter_stream.ts`文件，在其中编写转换逻辑：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What did we just do?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做了什么？
- en: We created a custom transform and exported it, so it can be used anywhere in
    other files.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义的转换并导出它，这样它可以在其他文件中的任何地方使用。
- en: Options are not mandatory in a constructor if they aren't passed; we create
    the default options.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果构造函数中的选项不是必需的，我们可以创建默认选项。
- en: By default, streams expect buffer/string values. There is an `objectMode` flag
    that we have to set in the stream so it can accept any JavaScript object, which
    we did in the constructor.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，流期望缓冲区/字符串值。有一个`objectMode`标志，我们必须在流中设置它，以便它可以接受任何JavaScript对象，这是我们在构造函数中做的。
- en: We overrode the transform method to suit it to our needs. In the transform method,
    we removed those keys that are passed out in filter options and created a filtered
    object.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们重写了transform方法以适应我们的需求。在transform方法中，我们删除了在过滤选项中传递的那些键，并创建了一个经过过滤的对象。
- en: 'Next, we will create an object of filter stream, to test out our results. Create
    a file called `stream_test.ts` parallelly to `filter_stream.ts` and add the following
    contents:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个过滤器流的对象，以测试我们的结果。并行创建一个名为`stream_test.ts`的文件，添加以下内容：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open up your `package.json` file and add `"start":"tsc && node .\\dist\\stream_test.js"`
    in your `scripts` tag. Now when you run `npm start`, you will be able to see the
    transformed output.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`package.json`文件，并在`scripts`标签中添加`"start":"tsc && node .\\dist\\stream_test.js"`。现在当您运行`npm
    start`时，您将能够看到转换后的输出。
- en: Note that if you are on Linux/macOS, replace `\\` with `//`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您使用的是Linux/macOS，请用`//`替换`\\`。
- en: Writing your first Hello World microservice
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个Hello World微服务
- en: 'Let''s start by writing our first microservice. Based on the previous topics,
    we will construct our first microservice with best practices and the widely used
    `node_modules`. We will use:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写我们的第一个微服务开始。基于之前的主题，我们将使用最佳实践和广泛使用的`node_modules`构建我们的第一个微服务。我们将使用：
- en: '| **CORS** ([https://www.npmjs.com/package/cors](https://www.npmjs.com/package/cors))
    | Adds CORS headers, so that cross applications can access it. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| **CORS** ([https://www.npmjs.com/package/cors](https://www.npmjs.com/package/cors))
    | 添加CORS标头，以便跨应用程序可以访问它。 |'
- en: '| **Routing Controllers** ([https://www.npmjs.com/package/routing-controllers](https://www.npmjs.com/package/routing-controllers))
    | Beautiful decorators provided in this module, which help us to write our API''s
    and routes easily. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **Routing Controllers** ([https://www.npmjs.com/package/routing-controllers](https://www.npmjs.com/package/routing-controllers))
    | 此模块提供了美丽的装饰器，帮助我们轻松编写API和路由。 |'
- en: '| **Winston** ([https://www.npmjs.com/package/winston](https://www.npmjs.com/package/winston))
    | Perfect logging module with many advanced features. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **Winston** ([https://www.npmjs.com/package/winston](https://www.npmjs.com/package/winston))
    | 具有许多高级功能的完美日志记录模块。 |'
- en: 'So, open up a Terminal and create one Node project with a default `package.json`.
    Follow these steps. The full source code for reference is available in the `first-microservice`folder
    in the extracted source:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开终端并创建一个带有默认`package.json`的Node项目。按照以下步骤进行。可在提取源中的`first-microservice`文件夹中找到用于参考的完整源代码：
- en: 'First of all, we will download the preceding dependencies and basic express
    dependencies. Enter the following command lines:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将下载前面的依赖项和基本的express依赖项。输入以下命令行：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Download the types of necessary modules as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式下载必要模块的类型：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we will create our application structure, as shown in the following screenshot:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的应用程序结构，如下截图所示：
- en: '![](img/fcd1e54d-7c71-41e4-9793-65ca1a840a45.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcd1e54d-7c71-41e4-9793-65ca1a840a45.png)'
- en: Folder structure
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: 'So, let''s create our express file and configure it using the `routing_controllers`
    module. Create one express config class and instruct it to use our directory controllers
    as the source from where it can find the routes:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们创建我们的express文件，并使用`routing_controllers`模块进行配置。创建一个express配置类，并指示它使用我们的目录控制器作为可以找到路由的源：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s write our application startup logic inside `application.ts`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`application.ts`中编写我们的应用程序启动逻辑：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next step is to write our controller and to return JSON:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是编写我们的控制器并返回JSON：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next step is to create a new object of our `Application` file inside `index.ts`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在`index.ts`中创建我们的`Application`文件的新对象：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You are all done; compile your TypeScript and start a transpiled version of
    `index.ts`. When you hit `localhost:3000/hello-world`, you will see JSON output—`{"msg":"This
    is first Typescript Microservice"}`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经完成了；编译您的TypeScript并启动`index.ts`的转译版本。当您访问`localhost:3000/hello-world`时，您将看到JSON输出—`{"msg":"This
    is first Typescript Microservice"}`。
- en: 'To add the automation of all the tasks while starting a server, we define scripts
    in our `package.json`. The first script is to always clean before transpiling:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在启动服务器时自动执行所有任务，我们在`package.json`中定义脚本。第一个脚本是始终在转译之前进行清理：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next script is for building TypeScript using the `typescript` version available
    inside the `node` modules:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本是使用`node`模块中可用的`typescript`版本构建TypeScript：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The final one basically instructs it to clean, build, and start the server
    by executing `index.js`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个基本上指示它清理、构建并通过执行`index.js`启动服务器：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next step is to create a Docker build. Create one `Docker` file and let''s
    write the Docker image script:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建Docker构建。创建一个`Docker`文件，让我们编写Docker镜像脚本：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will learn about Docker in more detail in future chapters. Now, go ahead
    and enter the following command:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在以后的章节中更详细地学习Docker。现在，继续并输入以下命令：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Don't forget the dot at the end of the command while building the image. A dot
    indicates that we are using Dockerfile in the local directory.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像时，不要忘记命令的末尾加上点。点表示我们在本地目录中使用Dockerfile。
- en: 'Your Docker image will be built. You will see output like the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Docker镜像将被构建。您将看到以下类似的输出：
- en: '![](img/28607eda-e3e4-4929-8be0-c80a21019443.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28607eda-e3e4-4929-8be0-c80a21019443.jpg)'
- en: Docker create image
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Docker创建镜像
- en: 'You can use the `sudo docker images` command to check the image, which you
    can later use anywhere. To run the image, just use the following command line:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`sudo docker images`命令来检查镜像，稍后您可以在任何地方使用它。要运行镜像，只需使用以下命令行：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After that, you can hit `localhost:8080/hello-world` to check the output.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您可以访问`localhost:8080/hello-world`来检查输出。
- en: While we just exposed the REST API, for the outer world it's just another service
    on port `8080`; the inner implementation is abstracted from the consumer. This
    is one of the major differences between REST API and microservices. Anything within
    the container can change at any time.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只是暴露了REST API，对外部世界来说，它只是8080端口上的另一个服务；内部实现对消费者来说是抽象的。这是REST API和微服务之间的主要区别之一。容器内的任何内容都可以随时更改。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we had a primary introduction to some of the most fundamental
    concepts of Node.js and TypeScript that are essential for making scalable applications
    suitable for enterprise needs. We set up our primary environment and learned about
    Docker, PM2, and NGINX. At the end, we created our traditional `Hello World` microservice
    the TypeScript way in Node.js.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了一些Node.js和TypeScript的最基本概念，这些概念对于开发适合企业需求的可扩展应用程序至关重要。我们搭建了我们的主要环境，并学习了Docker、PM2和NGINX。最后，我们用Node.js的TypeScript方式创建了我们传统的“Hello
    World”微服务。
- en: In the next chapter, we are going to learn the fundamentals of reactive programming,
    the advantages of reactive programming, and how you can do reactive programming
    in Node.js. We will see various operators available in reactive programming, which
    shorten and streamline our day-to-day development. We will see a combination of
    traditional SOA-based orchestration and reactive processes, and go through various
    situations to see which approach fits where.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习响应式编程的基本原理、响应式编程的优势，以及如何在Node.js中进行响应式编程。我们将了解响应式编程中提供的各种操作符，这些操作符可以简化我们日常开发工作。我们将结合传统的基于SOA的编排和响应式流程，通过各种情况来看看哪种方法适用于哪里。
