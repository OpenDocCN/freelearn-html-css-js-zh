- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Producing Functions – Higher-Order Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成函数 – 高阶函数
- en: 'In [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    we worked with some declarative code so that we could gain understandability and
    more compact, shorter code. In this chapter, we will go further toward **higher-order
    functions** (**HOFs**) and develop our own. We can roughly classify the results
    that we are going to get into three groups:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B19301_05.xhtml#_idTextAnchor084)，*声明式编程*中，我们使用了一些声明式代码，以便我们能够提高可读性并获得更紧凑、更短的代码。在本章中，我们将进一步探讨**高阶函数**（**HOFs**）并开发自己的。我们可以将我们预期得到的结果大致分为三类：
- en: '**Wrapped functions**: These keep their original functionality while adding
    some kind of new feature. In this group, we can consider logging (adding log production
    capacity to any function), timing (producing time and performance data for a given
    function), and memoization of functions and promises (caching results to avoid
    future rework).'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装函数**：这些函数在保持原有功能的同时，添加了一些新的功能。在这个类别中，我们可以考虑日志记录（为任何函数添加日志生成能力）、计时（为特定函数生成时间和性能数据），以及函数和承诺的缓存（缓存结果以避免未来的重复工作）。'
- en: '`once()` function (we covered this in [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037),
    *Thinking Functionally*), which changes the original function so that it only
    runs once; functions such as `not()` or `invert()`, which alter what the function
    returns; arity-related conversions, which produce a new function with a fixed
    number of parameters; and throttling and debouncing functions for performance.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`once()` 函数（我们曾在[*第2章*](B19301_02.xhtml#_idTextAnchor037)，*函数式思维*中介绍过），它改变了原始函数，使其只运行一次；例如
    `not()` 或 `invert()` 函数，它们会改变函数的返回值；与函数的元数相关的转换，它们会生成一个具有固定参数数量的新函数；以及节流和去抖函数，用于提高性能。'
- en: '**Other productions**: These provide new operations, turn functions into promises,
    allow enhanced search functions, decouple methods from objects, transform them
    into plain functions, and go the other way around, converting functions into methods.
    We shall leave a special case – *transducers* – for [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148),
    *Connecting Functions*.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他生成**：这些提供新的操作，将函数转换为承诺，允许增强搜索功能，将方法从对象中解耦，将它们转换为普通函数，以及相反的操作，将函数转换为方法。我们将特别案例
    – *转换器* – 留到[*第8章*](B19301_08.xhtml#_idTextAnchor148)，*连接函数*中讨论。'
- en: Wrapping functions – keeping behavior
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装函数 – 保持行为
- en: In this section, we’ll consider some HOFs that provide a wrapper around other
    functions to enhance them in some way but without altering their original objective.
    In terms of design patterns (which we’ll be revisiting in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204),
    *Implementing Design Patterns*), we can also speak of **decorators**. This pattern
    is based on the concept of adding some behavior to an object (in our case, a function)
    without affecting other objects. The term decorator is also popular because of
    its usage in frameworks, such as Angular, or (in an experimental mode) for general
    programming in JavaScript.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑一些高阶函数，它们为其他函数提供包装，以某种方式增强它们，但不会改变它们原有的目标。从设计模式的角度来看（我们将在[*第11章*](B19301_11.xhtml#_idTextAnchor204)，*实现设计模式*中重新讨论），我们也可以谈论**装饰器**。这种模式基于向对象添加某些行为（在我们的情况下，是函数）而不影响其他对象的概念。装饰器这个术语也因其用于框架，如Angular，或（在实验模式下）用于JavaScript的一般编程而流行。
- en: Waiting for decorators
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 等待装饰器
- en: Decorators are being considered for general adoption in JavaScript. Currently
    (as of December 2022), they are at Stage 3, Candidate level, so it may still be
    a while until they get to Stage 4 (Finished, meaning “officially adopted”). You
    can read more about the proposal for decorators at [tc39.github.io/proposal-decorators/](http://tc39.github.io/proposal-decorators/)
    and about the JavaScript adoption process, called TC39, at [tc39.es/process-document/](http://tc39.es/process-document/).
    See the *Questions* section in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204)*,
    Implementing Design Patterns,* for more information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器正在考虑在JavaScript中普遍采用。目前（截至2022年12月），它们处于第3阶段，候选级别，因此可能还需要一段时间才能达到第4阶段（完成，意味着“正式采用”）。您可以在[tc39.github.io/proposal-decorators/](http://tc39.github.io/proposal-decorators/)上阅读有关装饰器提案的更多信息，以及关于JavaScript采用过程的更多信息，称为TC39，请参阅[tc39.es/process-document/](http://tc39.es/process-document/)。有关更多信息，请参阅[*第11章*](B19301_11.xhtml#_idTextAnchor204)*，实现设计模式*中的*问题*部分。
- en: As for the term *wrapper*, it’s more important and pervasive than you might
    have thought; in fact, JavaScript uses it widely. Where? You already know that
    object properties and methods are accessed through dot notation. However, you
    also know that you can write code such as `myString.length` or `22.9.toPrecision(5)`,
    so where are those properties and methods coming from, given that neither strings
    nor numbers are objects? JavaScript actually creates a *wrapper object* around
    your primitive value. This object inherits all the methods that are appropriate
    to the wrapped value. As soon as the needed evaluation has been done, JavaScript
    throws away the just-created wrapper. We cannot do anything about these transient
    wrappers, but there is a concept we will come back to regarding a wrapper that
    allows methods to be called on things that are not of the appropriate type. This
    is an interesting idea; see [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, for more applications of that!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 至于术语*包装器*，它比你想象的更重要和普遍；事实上，JavaScript广泛地使用它。在哪里？你已经知道对象属性和方法是通过点符号访问的。然而，你也知道你可以编写像`myString.length`或`22.9.toPrecision(5)`这样的代码，那么这些属性和方法从何而来，鉴于字符串和数字都不是对象？JavaScript实际上在你的原始值周围创建了一个*包装对象*。这个对象继承了适用于包装值的所有方法。一旦完成所需的评估，JavaScript就会丢弃刚刚创建的包装器。我们无法对这些短暂的包装器做任何事情，但有一个概念我们将回到，关于允许在不是适当类型的事物上调用方法的包装器。这是一个有趣的想法；参见[*第12章*](B19301_12.xhtml#_idTextAnchor221)，*构建更好的容器*，了解更多关于该技术的应用！
- en: 'In this section, we’ll look at three examples:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨三个示例：
- en: Adding logging to a function
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向函数添加日志
- en: Getting timing information from functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数中获取时间信息
- en: Using caching (*memoizing*) to improve the performance of functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存（*记忆化*）来提高函数的性能
- en: Let’s get to work!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作！
- en: Logging
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'Let’s start with a common problem. When debugging code, you usually need to
    add some logging information to see whether a function was called, with what arguments,
    what it returned, and so on. (Yes, of course, you can simply use a debugger and
    set breakpoints, but bear with me for this example!) Working normally, this means
    that you’ll have to modify the code of the function itself, both at entry and
    on exit, to produce some logging output. For example, your original code could
    be something like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个问题开始。当调试代码时，你通常需要添加一些日志信息来查看函数是否被调用，使用了什么参数，返回了什么，等等。（是的，当然，你可以简单地使用调试器并设置断点，但请耐心听我解释这个例子！）正常工作，这意味着你将不得不修改函数本身的代码，在进入和退出时，以产生一些日志输出。例如，你的原始代码可能如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this case, you would have to modify it to look like the following. Here,
    we need to add an `auxValue` variable to store the value that we want to log and
    return:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将不得不修改它，如下所示。在这里，我们需要添加一个`auxValue`变量来存储我们想要记录并返回的值：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the function can return at several places, you’ll have to modify all the
    `return` statements to log the values to be returned. And if you are just calculating
    the return expression on the fly, you’ll need an auxiliary variable to capture
    that value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数可以在多个地方返回，你必须修改所有的`return`语句来记录要返回的值。如果你只是即时计算返回表达式，你需要一个辅助变量来捕获那个值。
- en: In the next section, we’ll learn about logging and some special cases, such
    as functions that throw exceptions, and we’ll work more purely.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习关于日志记录和一些特殊情况，例如抛出异常的函数，我们将更加纯粹地工作。
- en: Logging in a functional way
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以函数式方式记录日志
- en: Logging by modifying your functions isn’t difficult, but modifying code is always
    dangerous and prone to accidents. So, let’s put our FP hats on and think of a
    new way of doing this. We have a function that performs some work, and we want
    to know the arguments it receives and the value it returns.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改你的函数来记录日志并不困难，但修改代码总是危险的，容易出错。所以，让我们戴上我们的FP帽子，并考虑一种新的方法来做这件事。我们有一个执行一些工作的函数，我们想知道它接收到的参数和返回的值。
- en: 'Here, we can write an HOF that will have a single parameter – the original
    function – and return a new function that will do the following in sequence:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以编写一个HOF（高阶函数），它将有一个单一参数——原始函数——并返回一个新的函数，该函数将按以下顺序执行：
- en: Log the received arguments.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录接收到的参数。
- en: Call the original function, catching its returned value.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用原始函数，捕获其返回值。
- en: Log that value.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录那个值。
- en: Return it to the caller.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回给调用者。
- en: 'A possible solution would be as follows, and let’s use plain JavaScript first
    to focus on the implementation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案如下，让我们首先使用纯JavaScript来关注实现：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The function returned by `addLogging()` behaves as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由`addLogging()`返回的函数表现如下：
- en: The first `console.log(...)` line shows the original function’s name and its
    list of arguments.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行`console.log(...)`显示了原始函数的名称及其参数列表。
- en: Then, the original function, `fn()`, is called, and the returned value is stored.
    The second `console.log(...)` line shows the function name (again) and its returned
    value.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，调用原始函数`fn()`，并将返回值存储起来。第二行`console.log(...)`显示了函数名（再次）及其返回值。
- en: Finally, the value that `fn()` calculated is returned.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，返回`fn()`计算出的值。
- en: 'A small comment: If you were doing this for a Node.js application, you would
    probably opt for a better way of logging than `console.log()` by using libraries
    such as *Winston*, *Morgan*, or *Bunyan*, depending on what you wanted to log.
    However, our focus is on how to wrap the original function, and the needed changes
    for using those libraries would be negligible.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小注释：如果你是在Node.js应用程序中做这件事，你可能会选择比`console.log()`更好的日志记录方式，比如使用*Winston*、*Morgan*或*Bunyan*等库，具体取决于你想要记录什么。然而，我们的重点是了解如何包装原始函数，使用这些库所需的变化可以忽略不计。
- en: 'Let’s turn to a TypeScript implementation now:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向TypeScript实现：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our `addLogging()` function applies to a generic function `T` type and returns
    a new function of precisely the same type: its arguments (`Parameters<T>`) are
    those of `T`, and its result (`ReturnType<T>`) is also the same type as `T`’s.
    We will be using this kind of definition many times in this chapter and the rest
    of the book.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`addLogging()`函数适用于泛型函数`T`类型，并返回一个与原始函数类型完全相同的新函数：它的参数（`Parameters<T>`）是`T`的参数，它的结果（`ReturnType<T>`）也是与`T`相同的类型。我们将在本章和本书的其余部分多次使用这种定义。
- en: 'Let’s have an example now. We can use `addLogging()` with the upcoming functions—which
    are written, I agree, in an overly complicated way, just to have an appropriate
    example! We’ll have a function that accomplishes subtraction by changing the sign
    of the second number and then adding it to the first. And, just to have an error
    case, we’ll have the function throw an error if we attempt to subtract zero. (Yes,
    of course, you can subtract zero from another number! But I wanted to have some
    kind of an error-throwing situation at any cost!) The following code does this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们举一个例子。我们可以使用`addLogging()`与即将到来的函数——我同意，这些函数的编写方式过于复杂，只是为了有一个合适的例子！我们将有一个通过改变第二个数的符号然后加到第一个数上来完成减法的函数。而且，为了有一个错误情况，如果尝试从零减去，我们将让该函数抛出错误。（是的，当然，你可以从另一个数中减去零！但我无论如何都想有一种抛出错误的情况！）以下代码就是这样做的：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What’s that `@ts-expect-error` comment? TypeScript rejects the assignment in
    the following line, saying `Cannot assign to 'subtract' because it is a function.ts(2630)`.
    This prohibition keeps code safe, but since we are very sure that we won’t be
    changing the `subtract()` type, we can include the comment, and TypeScript will
    let us get away with it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`@ts-expect-error`注释是什么意思？TypeScript拒绝以下行的赋值，说“不能将`subtract`赋值，因为它是一个函数.ts(2630)`。这种禁止可以保持代码的安全性，但既然我们非常确定我们不会更改`subtract()`的类型，我们可以包含这个注释，TypeScript会让我们绕过它。
- en: 'The result of executing this would be the following lines of logging:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的结果将是以下日志行：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All the changes we had to make in our code were the reassignments of `subtract()`
    and `changeSign()`, which essentially replaced them everywhere with their new
    log-producing wrapped versions. Any call to those two functions will produce this
    output.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中必须做的所有更改都是重新分配`subtract()`和`changeSign()`，这实际上是在所有地方用它们新的日志生成包装版本替换了它们。对这两个函数的任何调用都将产生这个输出。
- en: This works fine for most functions, but what would happen if the wrapped function
    threw an exception? Let’s take a look.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这对大多数函数都很好，但如果包装函数抛出异常会发生什么呢？让我们看看。
- en: Taking exceptions into account
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑异常情况
- en: 'Let’s enhance our logging function a bit by considering an adjustment. What
    happens to your log if the function throws an error? Fortunately, this is easy
    to solve. We have to add a `try`/`catch` structure, as shown in the following
    code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑一个调整来增强我们的日志记录函数。如果你的日志在函数抛出错误时会发生什么？幸运的是，这很容易解决。我们必须添加一个`try`/`catch`结构，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this change, if the function threw an error, you’d also get an appropriate
    logging message, and the exception would be rethrown for processing. The following
    is a quick demo of this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，如果函数抛出错误，你也会得到适当的日志消息，异常将被重新抛出以进行处理。以下是一个快速演示：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Other changes to get an even better logging output would be up to you – adding
    date and time data, enhancing the way parameters are listed, and so on. However,
    our implementation still has an important defect; let’s make it better and purer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得更好的日志输出，其他更改将取决于你——添加日期和时间数据，增强参数的列表方式等等。然而，我们的实现仍然有一个重要的缺陷；让我们让它变得更好、更纯粹。
- en: Working in a purer way
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以更纯粹的方式工作
- en: 'When we wrote the `addLogging()` function, we ignored some precepts we saw
    in [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, because
    we included an impure element (`console.log()`) in our code. With this, not only
    did we lose flexibility (would you be able to select an alternate way of logging?),
    but we also complicated our testing. We could manage to test it by spying on the
    `console.log()` method, but that isn’t very clean: we depend on knowing the internals
    of the function we want to test instead of doing a purely black-box test. Take
    a look at the following example for a clearer understanding of this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写`addLogging()`函数时，我们忽略了一些在[*第4章*](B19301_04.xhtml#_idTextAnchor069)，“*正确行为*”中看到的教条，因为我们把一个不纯的元素（`console.log()`）包含在我们的代码中。因此，我们不仅失去了灵活性（你能否选择另一种日志记录方式？），而且也使我们的测试变得复杂。我们可以通过监视`console.log()`方法来测试它，但这并不干净：我们依赖于了解我们想要测试的函数的内部结构，而不是进行纯粹的黑盒测试。请看以下示例以获得更清晰的理解：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Running this test shows that `addLogging()` behaves as expected, so this is
    a solution. Our first test just does a simple subtraction and verifies that logging
    was called with appropriate data. The second test checks that our (purposefully
    failing) `subtract()` function throws an error to also verify that the correct
    logs were produced.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试表明`addLogging()`的行为符合预期，因此这是一个解决方案。我们的第一个测试只是进行简单的减法运算，并验证是否以适当的数据调用了日志记录。第二个测试检查我们的（故意失败的）`subtract()`函数是否抛出错误，以验证是否生成了正确的日志。
- en: 'Even so, being able to test our function this way doesn’t solve the lack of
    flexibility we mentioned. We should pay attention to what we wrote in the *Injecting
    impure functions* section in [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069)*,
    Behaving Properly*; the logging function should be passed as an argument to the
    wrapper function so that we can change it if we need to:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，能够以这种方式测试我们的函数并不能解决我们提到的缺乏灵活性。我们应该注意我们在[*第4章*](B19301_04.xhtml#_idTextAnchor069)中“*正确行为*”部分提到的内容，在[*第4章*](B19301_04.xhtml#_idTextAnchor069)，“注入不纯函数”；日志函数应该作为参数传递给包装函数，这样我们就可以在需要时更改它：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we don’t do anything, the logging wrapper will produce the same results
    as in the previous section. However, we could provide a different logger – for
    example, with Node.js, we could use the *winston* logging tool (see [github.com/winstonjs/winston](http://github.com/winstonjs/winston)
    for more on it), and the results would vary accordingly:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不采取任何行动，日志包装器将产生与上一节相同的结果。然而，我们可以提供一个不同的记录器——例如，使用Node.js，我们可以使用*winston*日志工具（有关更多信息，请参阅[github.com/winstonjs/winston](http://github.com/winstonjs/winston)），结果将相应变化：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The log format is JSON by default. It’s more usual to route it to a file for
    storage, so it isn’t so clear as console output, but we could (if needed) reformat
    it more legibly. However, this suffices for our example, and we won’t do anything
    else.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，日志格式是JSON。通常会将它路由到文件进行存储，因此它不如控制台输出清晰，但如果我们需要的话，可以重新格式化使其更易读。然而，这对我们的示例来说已经足够了，我们不会做任何其他的事情。
- en: 'Now that we have followed our own advice, we can take advantage of stubs. The
    code for testing is practically the same as before; however, we are using a `dummy.logger()`
    stub with no provided functionality or side effects, so it’s safer all around.
    In this case, the real function that was being invoked originally, `console.log()`,
    can’t do any harm, but that’s not always the case, so using a stub is recommended:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经遵循了自己的建议，我们可以利用存根。测试代码实际上与之前相同；然而，我们正在使用一个没有任何提供功能或副作用`dummy.logger()`存根，因此从各方面来说都更安全。在这种情况下，最初被调用的实际函数`console.log()`不会造成任何伤害，但并不总是这样，因此使用存根是推荐的：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding tests work exactly like the previous ones we wrote earlier (though,
    for variety, in the *Working in a purer way* section, we used `expect(…).toThrow()`,
    and here we used a `try`/`catch` structure to test error-throwing functions).
    We used and inspected the dummy logger instead of dealing with the original `console.log()`
    calls. Writing the test in this way avoids all possible problems due to side effects,
    so it’s much cleaner and safer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试与我们在之前编写的测试完全一样（尽管，为了多样性，在*以更纯净的方式工作*部分，我们使用了`expect(…).toThrow()`，而在这里我们使用了`try`/`catch`结构来测试抛出错误的函数）。我们使用了并检查了虚拟日志记录器，而不是处理原始的`console.log()`调用。以这种方式编写测试避免了所有可能由于副作用引起的问题，因此它更干净、更安全。
- en: When applying FP techniques, remember that if you are somehow complicating your
    job – for example, making it difficult to test any of your functions – then you
    must be doing something wrong. In our case, the mere fact that the output of `addLogging()`
    was an impure function should have raised the alarm. Of course, given the simplicity
    of the code, in this particular case, you might decide that it’s not worth a fix,
    that you can do without testing, and that you don’t need to be able to change
    the way logging is produced. However, long experience in software development
    suggests that, sooner or later, you’ll come to regret that sort of decision, so
    try to go with the cleaner solution instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用函数式编程（FP）技术时，请记住，如果你在以某种方式使自己的工作复杂化——例如，使测试任何函数变得困难——那么你肯定是在做错事。在我们的例子中，仅仅因为`addLogging()`的输出是一个不纯函数，就应该引起警觉。当然，鉴于代码的简单性，在这个特定情况下，你可能会决定修复它不值得，你可以不进行测试，而且你不需要能够改变日志生成的方式。然而，长期的软件开发经验表明，迟早你会后悔这种决定，所以尽量选择更干净的解决方案。
- en: 'Now that we have dealt with logging, we’ll look at another need: timing functions
    for performance reasons.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了日志记录，我们将看看另一个需求：出于性能原因对函数进行计时。
- en: Timing functions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时函数
- en: Another possible application for wrapped functions is to record and log the
    timing of each function invocation in a fully transparent way. Simply put, we
    want to be able to tell how long a function call takes, most likely for performance
    studies. However, in the same way we dealt with logging, we don’t want to have
    to modify the original function and will use an HOF instead.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 包装函数的另一个可能的应用是以完全透明的方式记录和记录每个函数调用的计时。简单来说，我们希望能够知道函数调用花费了多长时间，这很可能是为了性能研究。然而，就像我们处理日志一样，我们不想修改原始函数，而将使用高阶函数（HOF）。
- en: The three rules for optimization
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 优化的三条规则
- en: 'If you plan to optimize your code, remember the following three rules: *Don’t
    do it*, *Don’t do it yet*, and *Don’t do it without measuring*. It has been mentioned
    that a lot of bad code arises from early attempts at optimization, so don’t start
    by trying to write optimal code, don’t try to optimize until you recognize the
    need for it, and don’t do it haphazardly without trying to determine the reasons
    for the slowdown by measuring all the parts of your application.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划优化你的代码，请记住以下三条规则：*不要做*，*不要急于做*，*不要在没有测量的情况下做*。已经提到，很多糟糕的代码都源于早期的优化尝试，所以不要试图编写最优化的代码，不要在你认识到需要它之前尝试优化，不要在没有尝试通过测量应用程序的所有部分来确定减速原因的情况下随意进行。
- en: 'Along the lines of the preceding example, we can write an `addTiming()` function
    that, given any function, will produce a wrapped version that will write out timing
    data on the console but will otherwise work in exactly the same way. Data types
    are very much what we saw in the previous section, so let’s write TypeScript at
    once:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着前面的例子，我们可以编写一个`addTiming()`函数，它给定任何函数，将产生一个包装版本，该版本将在控制台上输出计时数据，但除此之外将以完全相同的方式工作。数据类型与我们在上一节中看到的内容非常相似，所以让我们立即编写TypeScript代码：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Along the lines of the enhancement we applied in the previous section to the
    logging function, we are providing separate logger and time access functions.
    Writing tests for our `addTiming()` function should prove easy, given that we
    can inject both impure functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着我们在上一节中对日志功能进行的增强，我们提供了独立的日志记录器和时间访问函数。鉴于我们可以注入不纯函数，为我们的`addTiming()`函数编写测试应该很容易。
- en: 'We can see how this works here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到它是如何工作的：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Accuracy matters
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 准确性很重要
- en: Using `performance.now()` provides the highest accuracy. If you don’t need such
    precision as what’s provided by that function (arguably, it is overkill), you
    could use `Date.now()` instead. For more on these alternatives, see [developer.mozilla.org/en-US/docs/Web/API/Performance/now](http://developer.mozilla.org/en-US/docs/Web/API/Performance/now)
    and [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now).
    Consider using `console.time()` and `console.timeEnd()`; see [developer.mozilla.org/en-US/docs/Web/API/Console/time](http://developer.mozilla.org/en-US/docs/Web/API/Console/time)
    for more information.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`performance.now()`提供最高的精度。如果你不需要该函数提供的那么高的精度（可以说，这是过度杀鸡用牛刀），你可以使用`Date.now()`代替。有关这些替代方案，请参阅[developer.mozilla.org/en-US/docs/Web/API/Performance/now](http://developer.mozilla.org/en-US/docs/Web/API/Performance/now)和[developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now)。考虑使用`console.time()`和`console.timeEnd()`；有关更多信息，请参阅[developer.mozilla.org/en-US/docs/Web/API/Console/time](http://developer.mozilla.org/en-US/docs/Web/API/Console/time)。
- en: 'The preceding code is quite similar to the previous `addLogging()` function,
    and that’s reasonable: in both cases, we add some code before the actual function
    call and then some new code after the function returns. You might even consider
    writing a *higher* HOF, which would receive three functions and produce a new
    HOF as output (such as `addLogging()` or `addTiming()`) that would call the first
    function at the beginning, and then the second function if the wrapped function
    returned a value, or the third function if an error had been thrown! How about
    that?'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与之前的`addLogging()`函数非常相似，这是合理的：在两种情况下，我们都在实际函数调用之前添加一些代码，然后在函数返回之后添加一些新代码。你甚至可以考虑编写一个*更高阶*的HOF（高阶函数），它将接收三个函数并输出一个新的HOF（例如`addLogging()`或`addTiming()`），该HOF会在开始时调用第一个函数，如果包装函数返回了一个值，则调用第二个函数，如果抛出了错误，则调用第三个函数！怎么样？
- en: Memoizing functions
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存函数
- en: 'In [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, we
    considered the case of the Fibonacci function and learned how we could transform
    it, by hand, into a much more efficient version using *memoization*: caching calculated
    values to avoid recalculations. A *memoized* function would avoid redoing a process
    if the result was found earlier. We want to be able to turn any function into
    a memoized one so that we can get a more optimized version. However, a real-life
    memoizing solution should also take into account the available RAM and have some
    ways of avoiding filling it up; however, this is beyond the scope of this book,
    and we won’t be looking into performance issues either; those optimizations are
    also beyond the scope of this book.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B19301_04.xhtml#_idTextAnchor069)“行为规范”中，我们考虑了斐波那契函数的情况，并学习了如何通过手动操作将其转换为使用*缓存*的更高效版本：缓存计算值以避免重复计算。一个*缓存过的*函数会在之前找到结果的情况下避免重复执行过程。我们希望能够将任何函数转换为缓存过的版本，以便获得更优化的版本。然而，现实中的缓存解决方案还应考虑可用的RAM，并有一些避免填满它的方法；然而，这超出了本书的范围，我们也不会探讨性能问题；这些优化也超出了本书的范围。
- en: Of frameworks and memos
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于框架和缓存
- en: Some memoizing functionality is provided by tools such as React (the `useMemo()`
    hook) or Vue (the `v-memo` directive), but it’s not really the same. In these
    cases, only the previous result is kept, and re-rendering is avoided if a value
    changes. With the kind of memoization we’re discussing, *all* previous values
    are cached for reuse; React and Vue cache just one value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些缓存功能由React（`useMemo()`钩子）或Vue（`v-memo`指令）等工具提供，但这并不完全相同。在这些情况下，只保留前一个结果，如果值发生变化，则避免重新渲染。在我们讨论的这种缓存方式中，*所有*前一个值都会被缓存以供重用；React和Vue只缓存一个值。
- en: 'For simplicity, let’s only consider functions with a single, non-structured
    parameter and leave functions with more complex parameters (objects and arrays)
    or more than one parameter for later. The kind of values we can handle with ease
    are JavaScript’s primitive values: data that aren’t objects and have no methods.
    JavaScript has six of these: `boolean`, `null`, `number`, `string`, `symbol`,
    and `undefined`. Usually, we only see the first four as actual arguments. You
    can find out more by going to [developer.mozilla.org/en-US/docs/Glossary/Primitive](http://developer.mozilla.org/en-US/docs/Glossary/Primitive).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们只考虑具有单个非结构化参数的函数，并将具有更复杂参数（对象和数组）或多个参数的函数留待以后讨论。我们可以轻松处理的值类型是 JavaScript
    的原始值：不是对象且没有方法的日期。JavaScript 有六种这样的值：`boolean`、`null`、`number`、`string`、`symbol`
    和 `undefined`。通常，我们只看到前四种作为实际参数。你可以通过访问 [developer.mozilla.org/en-US/docs/Glossary/Primitive](http://developer.mozilla.org/en-US/docs/Glossary/Primitive)
    了解更多。
- en: We’re not aiming to produce the best-ever memoizing solution, but let’s study
    the subject a bit and produce several variants of a memoizing HOF. First, we’ll
    deal with functions with a single parameter and then consider functions with several
    parameters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标不是产生最佳的缓存化解决方案，但让我们研究一下这个主题，并产生几个缓存化高阶函数（HOF）的变体。首先，我们将处理具有单个参数的函数，然后考虑具有多个参数的函数。
- en: Simple memoization
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单缓存化
- en: 'We will work with the Fibonacci function we mentioned previously, which is
    a simple case: it receives a single numeric parameter. This function is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前提到的斐波那契函数，这是一个简单的情况：它接收一个数值参数。该函数如下所示：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The solution we previously created was general in concept but not particularly
    good in its implementation: we had to directly modify the function’s code to take
    advantage of said memoization. Let’s look into how to do this automatically, in
    the same fashion as other wrapped functions. The solution would be a `memoize()`
    function that wraps any other function to apply memoization. For clarity, let’s
    work with JavaScript first and just for functions with a single numeric parameter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的解决方案在概念上是通用的，但在实现上并不特别出色：我们必须直接修改函数的代码来利用这种缓存化。让我们看看如何自动完成这项工作，就像其他包装函数一样。解决方案将是一个
    `memoize()` 函数，它将包装任何其他函数以应用缓存化。为了清晰起见，让我们首先使用 JavaScript，并且只针对具有单个数值参数的函数：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How does this work? The returned function, for any given argument, checks whether
    the argument was already received; that is, whether it can be found as a key in
    the cache object. (See *Question 6.2* for an alternative implementation of the
    cache.) If so, there’s no need for calculation, and the cached value is returned.
    Otherwise, we calculate the missing value and store it in the cache. (We use a
    closure to hide the cache from external access.) Here, we assume that the memoized
    function receives only one argument (`x`) and that it is a numeric value, which
    can then be directly used as a key value for the cache object; we’ll consider
    other cases later.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？返回的函数对于任何给定的参数，都会检查该参数是否已经被接收；也就是说，是否可以在缓存对象中找到它作为键。（参见 *问题 6.2* 了解缓存的不同实现。）如果是这样，则不需要计算，直接返回缓存值。否则，我们计算缺失的值并将其存储在缓存中。（我们使用闭包来隐藏缓存以防止外部访问。）在这里，我们假设缓存化的函数只接收一个参数（`x`）并且它是一个数值，这样就可以直接用作缓存对象的键值；我们稍后会考虑其他情况。
- en: 'We now need to go to TypeScript; here’s the equivalent version of `memoize()`.
    The generic data typing is along the same lines as what we saw in the *Logging
    in a functional way* section, with the only difference being that now we work
    with functions that get a single numeric argument:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要转向 TypeScript；这是 `memoize()` 的等效版本。泛型数据类型与我们在 *以函数式方式记录* 部分中看到的是一样的，唯一的区别是现在我们处理的是接收单个数值参数的函数：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Is memoization working? We’ll have to time it – and we happen to have a useful
    `addTiming()` function for that! First, we time the original `fib()` function.
    We want to time the complete calculation and not each recursive call, so we write
    an auxiliary `testFib()` function, which is the one we’ll time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存化是否有效？我们需要对其进行计时——幸运的是，我们有一个有用的 `addTiming()` 函数来做这件事！首先，我们计时原始的 `fib()` 函数。我们想要计时整个计算过程，而不是每个递归调用，因此我们编写了一个辅助的
    `testFib()` 函数，这是我们将会计时的函数。
- en: 'We should repeat the timing operations and do an average, but since we just
    want to confirm that memoizing works, we’ll tolerate differences:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该重复计时操作并计算平均值，但既然我们只想确认缓存化是否有效，我们可以容忍差异：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Of course, your times will depend on your specific CPU, RAM, and so on. However,
    the results seem logical: the exponential growth we mentioned in [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069),
    *Behaving Properly*, appears to be present, and times grow quickly. Now, let’s
    memoize `fib()`. We should get shorter times... shouldn’t we?'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你的时间将取决于你的具体CPU、RAM等等。然而，结果似乎是有逻辑的：我们在[*第4章*](B19301_04.xhtml#_idTextAnchor069)中提到的指数增长似乎存在，时间增长得很快。现在，让我们记忆化`fib()`。我们应该得到更短的时间……不是吗？
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Something’s wrong! The times should have gone down, but they are just about
    the same. This is because of a common error, which I’ve even seen in some articles
    and web pages. We are timing `testMemoFib()`, but nobody calls that function except
    for timing, which only happens once! Internally, all recursive calls are to `fib()`,
    which isn’t memoized. If we called `testMemoFib(45)` again, *that* call would
    be cached, and it would return almost immediately, but that optimization doesn’t
    apply to the internal `fib()` calls. This is the reason why the calls for `testMemoFib(40)`
    and `testMemoFib(35)` weren’t optimized – when we did the calculation for `testMemoFib(45)`,
    that was the only value that got cached.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 出了点问题！时间应该下降，但它们几乎是一样的。这是因为一个常见的错误，我甚至在一些文章和网页中见过。我们在计时`testMemoFib()`，但除了计时之外，没有人调用那个函数，而计时只发生一次！内部，所有的递归调用都是到`fib()`，它没有被记忆化。如果我们再次调用`testMemoFib(45)`，*那个*调用将被缓存，并且它将几乎立即返回，但这个优化不适用于内部的`fib()`调用。这就是为什么`testMemoFib(40)`和`testMemoFib(35)`的调用没有被优化——当我们计算`testMemoFib(45)`时，那才是唯一被缓存的价值。
- en: 'The correct solution is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的解决方案如下：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, when calculating `fib(45)`, all the intermediate Fibonacci values (from
    `fib(0)` to `fib(45)` itself) are stored, so the forthcoming calls have practically
    no work to do.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当计算`fib(45)`时，所有的中间斐波那契值（从`fib(0)`到`fib(45)`本身）都被存储起来，所以接下来的调用实际上没有多少工作要做。
- en: Now that we know how to memoize single-argument functions, let’s look at functions
    with more arguments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何记忆化单参数函数，让我们看看多参数函数。
- en: More complex memoization
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更复杂的记忆化
- en: 'What can we do if we have to work with a function that receives two or more
    arguments, or can receive arrays or objects as arguments? Of course, like in the
    problem that we looked at in [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037),
    *Thinking Functionally*, about having a function do its job only once, we could
    simply ignore the question: if the function to be memoized is unary, we go through
    the memoization process; otherwise, we don’t do anything!'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须与一个接收两个或更多参数的函数一起工作，或者可以接收数组或对象作为参数，我们能做什么呢？当然，就像我们在[*第2章*](B19301_02.xhtml#_idTextAnchor037)中讨论的“函数只做一次工作”的问题一样，我们可以简单地忽略这个问题：如果需要记忆化的函数是一元函数，我们就进行记忆化过程；否则，我们不做任何事情！
- en: On the length of functions
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数长度的讨论
- en: 'The number of parameters of a function is called the function’s *arity,* or
    *valence*, and JavaScript provides it as the function’s `length` attribute; see
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length).
    You may speak in three different ways: you can say a function has arity one, two,
    three, and so on; you can say that a function is unary, binary, ternary, and so
    on; or you can say it’s monadic, dyadic, triadic, and so on. Take your pick!'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数数量被称为函数的*arity*，或*valence*，JavaScript将其作为函数的`length`属性提供；参见[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length)。你可以用三种不同的方式说话：你可以说你有一个一元、二元、三元……的函数；你也可以说它是一元、二元、三元……；或者你可以说你有一个单子、二元、三元……。随便选一个！
- en: 'Our first attempt could be just memoizing unary functions and leaving the rest
    alone, as in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一种尝试可能是只记忆化一元函数，其余的保持不变，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Working more seriously, if we want to be able to memoize any function, we must
    find a way to generate cache keys. To do this, we must find a way to convert any
    argument into a string. We cannot use a non-primitive as a cache key directly.
    We could attempt to convert the value into a string with something such as `strX
    = String(x)`, but we''d have problems. With arrays, it seems this could work.
    However, take a look at the following three cases that involve different arrays
    but with a twist:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更加认真地工作，如果我们想要能够记忆化任何函数，我们必须找到一种方法来生成缓存键。为此，我们必须找到一种方法将任何参数转换为字符串。我们不能直接使用非原始值作为缓存键。我们可以尝试使用`strX
    = String(x)`之类的将值转换为字符串，但我们会遇到问题。对于数组来说，这似乎可以工作。然而，看看以下三个涉及不同数组但带有转折的案件：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These three cases produce the same result. If we were only considering a single
    array argument, we’d be able to make do, but when different arrays produce the
    same key, that’s a problem. Things become worse if we have to receive objects
    as arguments because the `String()` representation of any object is, invariably,
    `"[``object Object]"`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个案例产生了相同的结果。如果我们只考虑单个数组参数，我们可能可以应付，但当不同的数组产生相同的键时，这就成为一个问题。如果我们必须接收对象作为参数，情况会更糟，因为任何对象的`String()`表示法不可避免地是`"[object
    Object]"`：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The simplest solution is to use `JSON.stringify()` to convert whatever arguments
    we have received into a useful, distinct string:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是使用`JSON.stringify()`将我们收到的任何参数转换为有用的、独特的字符串：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For performance, our logic should be as follows: if the function we are memoizing
    receives a single argument that’s a primitive value, we can use that argument
    directly as a cache key. In other cases, we would use the result of `JSON.stringify()`
    that’s applied to the array of arguments. Our enhanced memoizing HOF could be
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能，我们的逻辑应该是这样的：如果我们正在记忆化的函数接收到的参数是一个原始值，我们可以直接使用该参数作为缓存键。在其他情况下，我们会使用对参数数组应用`JSON.stringify()`的结果。我们增强的记忆化高阶函数（HOF）可能如下所示：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In terms of universality, this is the safest version. If you are sure about
    the type of parameters in the function you will process, it’s arguable that our
    first version was faster. On the other hand, if you want to have easier-to-understand
    code, even at the cost of some wasted CPU cycles, you could go with a simpler
    version:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用性方面，这是最安全的版本。如果你确定你将要处理的函数的参数类型，那么可以说我们的第一个版本更快。另一方面，如果你想编写更容易理解的代码，即使是以一些浪费的CPU周期为代价，你也可以选择一个更简单的版本：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Birth of a speeder
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 速度者的诞生
- en: If you want to learn about the development of a top-performance memoizing function,
    read Caio Gondim’s *How I wrote the world’s fastest JavaScript memoization library*
    article, available online at [blog.risingstack.com/the-worlds-fastest-javascript-memoization-library/](https://blog.risingstack.com/the-worlds-fastest-javascript-memoization-library/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解顶级性能记忆化函数的开发，请阅读Caio Gondim的*我如何编写世界上最快的JavaScript记忆化库*文章，该文章可在网上找到，链接为[blog.risingstack.com/the-worlds-fastest-javascript-memoization-library/](https://blog.risingstack.com/the-worlds-fastest-javascript-memoization-library/)。
- en: So far, we have achieved several interesting memoizing functions, but how will
    we write tests for them? Let’s analyze this problem now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了几个有趣的记忆化函数，但我们将如何为它们编写测试？现在让我们分析这个问题。
- en: Memoization testing
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记忆化测试
- en: 'Testing the memoization HOF poses an interesting problem – how would you go
    about it? The first idea would be to look into the cache, but that’s private and
    not visible. Then, of course, we could change `memoize()` so that it uses a global
    cache or somehow allows external access to the cache, but doing that sort of internal
    exam is frowned upon: you should try to do your tests based on external properties
    only.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 测试记忆化高阶函数（HOF）提出了一个有趣的问题——你将如何着手？第一个想法可能是查看缓存，但它是私有的且不可见的。然后，当然，我们可以修改`memoize()`使其使用全局缓存或以某种方式允许外部访问缓存，但这种内部审查是不被提倡的：你应该尝试仅基于外部属性进行测试。
- en: 'Accepting that we shouldn’t try to examine the cache, we could go for a time
    control: calling a function such as `fib(n)` for a large value of `n` should take
    longer if the function isn’t memoized. This is certainly possible, but it’s also
    prone to possible failures: something external to your tests could run at just
    the wrong time, and it could be possible that your memoized run would take longer
    than the original one. Okay, it’s possible, but not probable – but your test isn’t
    entirely reliable.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 承认我们不应该尝试检查缓存后，我们可以尝试时间控制：对于大数值的 `n` 调用函数 `fib(n)` 应该花费更长的时间，如果函数没有被记忆化。这当然是有可能的，但它也容易受到可能的失败的影响：测试之外的东西可能在完全错误的时间运行，而且有可能你的记忆化运行会比原始运行更长。好吧，这是可能的，但不太可能——但你的测试并不完全可靠。
- en: 'We could think about calculating some Fibonacci numbers and testing how many
    times the function was called – once directly and all the other times because
    of recursion. (See *Question 6.3* for more on this.) The preceding code is fairly
    straightforward: we are using the Fibonacci function we developed earlier and
    testing that it produces correct values. For instance, we can find out that calculating
    `fib(6)` requires 25 calls by revisiting the diagram we looked at in [*Chapter
    4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, and seeing that there
    are 25 nodes (each one representing a call to `fib()`) in it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以思考计算一些斐波那契数并测试函数被调用的次数——一次直接调用，其余的调用都是由于递归。有关更多内容，请参阅 *问题 6.3*。前面的代码相当直接：我们正在使用我们之前开发的斐波那契函数，并测试它是否产生正确的值。例如，我们可以发现计算
    `fib(6)` 需要 25 次调用，通过重新查看我们在 [*第 4 章*](B19301_04.xhtml#_idTextAnchor069) 中看到的图表，“行为正确”，我们可以看到其中包含
    25 个节点（每个节点代表对 `fib()` 的一个调用）：
- en: '![Figure 6.1 – 25 calls are needed for calculating ﬁb(6)](img/Figure_4.2_B19301.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 计算 ﬁb(6) 需要 25 次调用](img/Figure_4.2_B19301.jpg)'
- en: Figure 6.1 – 25 calls are needed for calculating ﬁb(6)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 计算 ﬁb(6) 需要 25 次调用
- en: The first idea would be counting calls, as shown here – but it won’t work!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个想法是计数，如这里所示——但这不会起作用！
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We first calculate `fib(6)` – which correctly returns `8` – and then we check
    that there should have been 25 calls to `fib()`, but only one was found; what’s
    going on? The problem is in Jest: when you spy on a function, you are actually
    spying on a wrapper that calls the function you want to check. *This* wrapper
    function is called only once; our `fib()` function was called 25 times, but Jest
    doesn’t see that!'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算 `fib(6)`——它正确地返回 `8`——然后我们检查应该有 25 次对 `fib()` 的调用，但只找到一次；发生了什么？问题出在 Jest
    上：当你监视一个函数时，你实际上是在监视一个调用你想要检查的函数的包装器。*这个*包装器函数只被调用了一次；我们的 `fib()` 函数被调用了 25 次，但
    Jest 没有看到这一点！
- en: 'We’ll have to do something else in a very non-functional way! Let’s test a
    modified `fib()` function that will update an external counter; we’ll call it
    `fibM()`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不以一种非常非功能性的方式来做些别的事情！让我们测试一个修改过的 `fib()` 函数，它将更新一个外部计数器；我们将其称为 `fibM()`：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that the test works out, how about testing the memoized, modified version
    instead? In this case, the count of calls should be lower because of cached results.
    In fact, it should just be `7` because we’ll need all values from `fib(6)` down
    to `fib(0)`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试通过了，我们再测试一下记忆化、修改过的版本怎么样？在这种情况下，由于缓存的结果，调用次数应该会更低。实际上，它应该是 `7`，因为我们需要从 `fib(6)`
    到 `fib(0)` 的所有值：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this section, we’ve dealt with several examples that implied wrapping functions
    so that they keep working but with some extra features added in. Now, let’s look
    at a different case where we want to change how a function works.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们处理了几个示例，这些示例暗示了包装函数，以便它们能够继续工作，但增加了额外的功能。现在，让我们看看一个不同的案例，其中我们想要改变函数的工作方式。
- en: Memoizing promises
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记忆化承诺
- en: Let’s go a bit further and consider memoizing `async` functions, which return
    promises. In a complex web application with many related components, it may very
    well be the case that redundant, repeated API calls go out for no good reason,
    harming performance and producing a bad user experience. Imagine, for instance,
    a dashboard-style web page with several tabs. Whenever a user selects a tab, several
    API calls go out to get the data that the page needs. However, if the user selects
    a different tab but later returns to the first one, the very same API calls will
    go out again. For many applications, data is basically constant, meaning “not
    changing in real time.” You don’t then need to re-send API calls; re-using previously
    fetched data also works.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，考虑记忆化返回promise的`async`函数。在一个复杂的Web应用程序中，有许多相关的组件，完全有可能出现没有良好理由的冗余、重复的API调用，这会损害性能并产生糟糕的用户体验。例如，想象一个具有多个标签的仪表板风格的Web页面。每次用户选择一个标签时，都会发出几个API调用以获取页面所需的数据。然而，如果用户选择不同的标签但后来又返回到第一个标签，相同的API调用将再次发出。对于许多应用程序来说，数据基本上是恒定的，意味着“不是实时变化的。”因此，你不需要重新发送API调用；重用之前获取的数据也行。
- en: 'Some solutions are not practical: we could modify the server to enable caching,
    but what if that’s not possible? Or we could work with a cache, checking before
    every call whether that data was already fetched, but that would entail hand-modifying
    every single API call to check the cache first! We want a solution that requires
    no code changes, and memoizing comes to mind.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案并不实用：我们可以修改服务器以启用缓存，但如果这不可能呢？或者我们可以使用缓存，在每次调用之前检查数据是否已经被获取，但这将涉及手动修改每个API调用以首先检查缓存！我们想要一个不需要代码更改的解决方案，而记忆化（memoizing）就浮现在脑海中。
- en: 'Assume we call the API with an `async` function that returns a promise. Given
    the `memoize()` function we developed, we could memoize the `async` function,
    and it would be a start. The first time you call the function with some arguments,
    the API call will go out, and a promise will be returned (since that’s what the
    function returns). If you call the function again with the same arguments, the
    memoized promise will be immediately returned. Great! Except there’s a catch…
    what would happen if the API call failed? We need to add some error-catching logic:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用返回promise的`async`函数调用API。鉴于我们开发的`memoize()`函数，我们可以记忆化`async`函数，这将是一个开始。第一次用一些参数调用该函数时，API调用将会发出，并返回一个promise（因为这是函数返回的内容）。如果你再次用相同的参数调用该函数，记忆化的promise将会立即返回。太好了！但是有一个问题……如果API调用失败会怎样？我们需要添加一些错误捕获逻辑：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'All logic is as before, with a couple of additional details:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有逻辑与之前相同，但有几点额外的细节：
- en: We are now making explicit that the memoized function returns a promise (`Promise<A>`)
    of some generic type `A`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在明确指出，记忆化的函数返回一个泛型类型`A`的promise (`Promise<A>`)
- en: If the promise is rejected, we add code to delete the cached promise, so a future
    call will go out again
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果promise被拒绝，我们添加代码来删除缓存的promise，以便未来的调用将再次发出
- en: Our new `promiseMemoize()` function can deal with errors, allowing future retries
    of rejected calls; good! Now let’s look at a different case, where we want to
    change the way a function actually works.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`promiseMemoize()`函数可以处理错误，允许未来重试被拒绝的调用；很好！现在让我们看看另一个不同的情况，我们想要改变函数的实际工作方式。
- en: Altering a function’s behavior
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改函数的行为
- en: In the previous section, we considered some ways of wrapping functions so that
    they maintain their original functionality, even though they’ve been enhanced
    in some way. Now, we’ll turn to modifying what the functions do so that the new
    results will differ from their original ones.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们考虑了一些封装函数的方法，以便它们在某种程度上得到增强的同时，仍能保持其原始功能。现在，我们将转向修改函数的行为，以便新的结果与原始结果不同。
- en: 'We’ll be covering the following topics:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Revisiting the problem of having a function work, but just once
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次探讨函数只工作一次的问题
- en: Negating or inverting a function’s result
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取反或反转函数的结果
- en: Changing the arity of a function
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变函数的阶数
- en: Throttling and debouncing functions for performance
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数节流和去抖动以提高性能
- en: Let’s get started!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Doing things once, revisited
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次性完成任务，再次探讨
- en: 'In [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037), *Thinking Functionally*,
    we went through an example of developing an FP-style solution for a simple problem:
    fixing things so that a given function works only once. We defined `once()` with
    an arrow function then; let’s go with a standard function for variety:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [(*第二章*](B19301_02.xhtml#_idTextAnchor037)，*函数式思考*) 中，我们通过一个例子了解了如何为简单问题开发函数式编程风格的解决方案：确保一个给定的函数只被调用一次。我们当时使用箭头函数定义了
    `once()`；让我们为了多样性使用一个标准函数：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is a perfectly acceptable solution; it works well, and we have nothing
    to object to. We can, however, think of a variation. We could observe that the
    given function gets called once, but its return value gets lost. This is easy
    to fix: we need to add a `return` statement. However, that wouldn’t be enough;
    what would the function return if it’s called more than once? We can take a page
    from the memoizing solution and store the function’s return value for future calls.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全可接受的解决方案；它运行良好，我们没有任何反对意见。然而，我们可以考虑一个变体。我们可以观察到给定的函数只被调用了一次，但其返回值丢失了。这很容易修复：我们需要添加一个
    `return` 语句。然而，这还不够；如果函数被多次调用，它应该返回什么？我们可以借鉴记忆化解决方案，为未来的调用存储函数的返回值。
- en: 'Let’s store the function’s value in a `result` variable so that we can return
    it later:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将函数的值存储在 `result` 变量中，以便我们可以在以后返回它：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first time the function gets called, its value is stored in `result`; further
    calls just return that value with no further process. You could also think of
    making the function work only once but for each set of arguments. You wouldn’t
    have to do any work for that – `memoize()` would be enough!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用函数时，其值存储在 `result` 中；后续的调用只需返回该值，无需进行进一步处理。你也可以考虑使函数只对每一组参数工作一次。你不必为此做任何工作——`memoize()`
    就足够了！
- en: 'Back in the *Producing an even better solution* section of [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037),
    *Thinking Functionally*, we considered a possible alternative to `once()`: another
    HOF that took two functions as parameters and allowed the first function to be
    called only once, calling the second function from that point on. Adding a `return`
    statement to the previous code and rewriting it as a standard function would result
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第二章* 的 *产生更好的解决方案* 部分 [(*Chapter 2*](B19301_02.xhtml#_idTextAnchor037)，*函数式思考*)
    中，我们考虑了 `once()` 的一个可能的替代方案：另一个接受两个函数作为参数的高阶函数（HOF），允许第一个函数只被调用一次，从那时起调用第二个函数。在之前的代码中添加一个
    `return` 语句并将其重写为一个标准函数，结果如下：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can rewrite this if we remember that functions are first-order objects.
    Instead of using a flag to remember which function to call, we can use a `toCall`
    variable to directly store whichever function needs to be called. Logically, that
    variable will be initialized to the first function but will then change to the
    second one. The following code implements that change:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记得函数是一阶对象，我们可以重写这个例子。而不是使用一个标志来记住要调用哪个函数，我们可以使用一个 `toCall` 变量直接存储需要被调用的函数。从逻辑上讲，该变量将被初始化为第一个函数，但随后将更改为第二个函数。以下代码实现了这一变化：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `toCall` variable is initialized with `f`, so `f()` will get called the
    first time, but then `toCall` gets the `g` value, implying that all future calls
    will execute `g()` instead. The very same example we looked at earlier in this
    book would still work:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`toCall` 变量被初始化为 `f`，因此第一次调用将会执行 `f()`，但随后 `toCall` 获取了 `g` 的值，这意味着所有后续的调用都将执行
    `g()`。我们之前在这本书中看到的相同示例仍然有效：'
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In terms of performance, the difference may be negligible. The reason for showing
    this further variation is to show that you should keep in mind that, by storing
    functions, you can often produce results more simply. Using flags to store state
    is a common technique in procedural programming. However, here, we manage to skip
    that usage and produce the same result. Now, let’s look at some new examples of
    wrapping functions to change their behaviors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，差异可能微不足道。展示这种进一步变体的原因是为了表明你应该记住，通过存储函数，你通常可以更简单地产生结果。在过程编程中使用标志来存储状态是一种常见的技术。然而，在这里，我们设法跳过了这种用法并产生了相同的结果。现在，让我们看看一些新的示例，展示如何包装函数以改变它们的行为。
- en: Logically negating a function
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑否定一个函数
- en: Let’s consider the `filter()` method from [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*. Given a predicate, we can filter the array to only
    include those elements for which the predicate is true. But how would you do a
    reverse filter and exclude the elements for which the predicate is true?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑来自 [*第5章*](B19301_05.xhtml#_idTextAnchor084)，*声明式编程* 的 `filter()` 方法。给定一个谓词，我们可以过滤数组，只包含那些谓词为真的元素。但你是如何进行反向过滤并排除那些谓词为真的元素的？
- en: 'The first solution should be pretty obvious: rework the predicate to return
    the opposite of whatever it originally returned. In the mentioned chapter, we
    looked at the following example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案应该是相当明显的：重新编写谓词以返回其原本返回值的相反。在提到的章节中，我们看到了以下示例：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: (For the `serviceResult` object, see the *A filter() example* section in the
    previous chapter.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: （有关 `serviceResult` 对象，请参阅前一章中的 *filter() 示例* 部分。）
- en: 'So, we could write it the other way round, in either of these equivalent fashions.
    Note the different ways of writing the same predicate to test for non-negative
    values:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以以相反的方式编写它，以这两种等效的方式之一。注意以下不同方式来编写相同的谓词以测试非负值：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That’s perfectly fine, but we could also have had something like the following
    in our code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全没问题，但我们的代码中也可以有类似以下的内容：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this case, rewriting the original `isNegativeBalance()` function isn’t possible.
    (Another possibility: the function could be defined in a separate module, which
    you can’t or shouldn’t modify.) However, working in a functional way, we can write
    an HOF that will take any predicate, evaluate it, and then negate its result.
    A possible implementation would be pretty straightforward, thanks to modern JavaScript
    syntax – and for the TypeScript version, check *Question 6.5*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重写原始的 `isNegativeBalance()` 函数是不可能的。（另一种可能性：该函数可能定义在单独的模块中，你无法或不应修改。）然而，以函数式的方式工作，我们可以编写一个高阶函数，它将接受任何谓词，评估它，然后否定其结果。可能的实现相当简单，多亏了现代
    JavaScript 语法 – 对于 TypeScript 版本，请参阅 *问题 6.5*：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Working in this way, we could have rewritten the preceding filter as follows;
    to test for non-negative balances, we use the original `isNegativeBalance()` function,
    which is negated via our `not()` HOF:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式工作，我们可以将前面的过滤器重写如下；为了测试非负余额，我们使用原始的 `isNegativeBalance()` 函数，该函数通过我们的 `not()`
    高阶函数被否定：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There is an additional solution we might want to try out. Instead of reversing
    the condition (as we did), we could write a new filtering method (possibly `filterNot()`?)
    that would work in the opposite way to `filter()`. The following code shows how
    this new function would be written. Given an `arr` array of values and an `fn`
    predicate, we’d have the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想尝试另一种解决方案。而不是反转条件（如我们所做的那样），我们可以编写一个新的过滤方法（可能是 `filterNot()`？），它将以与 `filter()`
    相反的方式工作。以下代码显示了如何编写这个新函数。给定一个值数组 `arr` 和一个谓词 `fn`，我们将有如下内容：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This solution doesn’t fully match `filter()` since you cannot use it as a method,
    but we could either add it to `Array.prototype` or apply some methods. We’ll look
    at these ideas in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting
    Functions*. However, it’s more interesting to note that we used the negated function,
    so `not()` is necessary for both solutions to the reverse filtering problem. In
    the upcoming *Demethodizing – turning methods into functions* section, we will
    see that we have yet another solution since we can decouple methods such as `filter()`
    from the objects they apply to, thereby changing them into common functions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案并不完全匹配 `filter()`，因为你不能将其用作方法，但我们可以将其添加到 `Array.prototype` 中，或者应用一些方法。我们将在
    [*第8章*](B19301_08.xhtml#_idTextAnchor148)，*连接函数* 中探讨这些想法。然而，更有趣的是注意到我们使用了否定函数，因此
    `not()` 对于解决反向过滤问题的两种解决方案都是必要的。在即将到来的 *去方法化 – 将方法转换为函数* 部分，我们将看到我们还有另一个解决方案，因为我们可以将像
    `filter()` 这样的方法与其应用的对象解耦，从而将其转换为通用函数。
- en: 'As for negating the function versus using a new `filterNot()` function, even
    though both possibilities are equally valid, I think using `not()` is clearer.
    If you already understand how filtering works, then you can practically read the
    code aloud, and it will be understandable: we want those accounts that don’t have
    a negative balance, right? Now, let’s consider a related problem: inverting the
    results of a function.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于否定函数与使用新的 `filterNot()` 函数，尽管这两种可能性同样有效，但我认为使用 `not()` 更清晰。如果你已经理解了过滤的工作原理，那么你可以几乎大声朗读代码，并且它将是可理解的：我们想要那些没有负余额的账户，对吧？现在，让我们考虑一个相关的问题：反转函数的结果。
- en: Inverting the results
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转结果
- en: 'In the same vein as the preceding filtering problem, let’s revisit the sorting
    problem from the *Injection – sorting it out* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*,
    Starting Out with Functions*. Here, we wanted to sort an array with a specific
    method. Therefore, we used `sort()`, providing it with a `comparison` function
    that basically pointed out which of the two strings should go first. To refresh
    your memory, given two strings, the function should do the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的过滤问题类似，让我们回顾一下 [*第3章*](B19301_03.xhtml#_idTextAnchor054) 的 *Injection –
    sorting it out* 部分的排序问题，即 *Starting Out with Functions*。在这里，我们想要用一种特定的方法对数组进行排序。因此，我们使用了
    `sort()`，并向它提供了一个 `comparison` 函数，该函数基本上指出了两个字符串中哪一个应该排在前面。为了刷新你的记忆，给定两个字符串，该函数应该执行以下操作：
- en: Return a negative number if the first string should precede the second one
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个字符串应该排在第二个字符串之前，则返回一个负数
- en: Return `0` if the strings are the same
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符串相同，则返回 `0`
- en: Return a positive number if the first string should follow the second one
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个字符串应该排在第二个字符串之后，则返回一个正数
- en: 'Let’s go back to the code we looked at for sorting in Spanish. We had to write
    a specialized `comparison` function so that sorting would take into account the
    character-ordering rules from Spanish, such as placing the letter *ñ* between
    *n* and *o*, and more. The code for this was as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前查看的用于西班牙语排序的代码。我们必须编写一个专门的 `comparison` 函数，以便排序时考虑到西班牙语的字符排序规则，例如将字母
    *ñ* 放在 *n* 和 *o* 之间，等等。这个代码如下：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are facing a similar problem: how can we sort in descending order? Given
    what we saw in the previous section, some options should immediately come to mind:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临着一个类似的问题：我们如何按降序排序？鉴于我们在上一节中看到的内容，一些选项应该立刻浮现在脑海中：
- en: Sort into ascending order, and afterward reverse the array. While this solves
    the problem, we still only sort into ascending order, and we would want to avoid
    the extra reversing step.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按升序排序，然后反转数组。虽然这解决了问题，但我们仍然只按升序排序，我们希望避免额外的反转步骤。
- en: Write a function that will invert the result from the comparing function. This
    will invert the result of all the decisions as to which string should precede,
    and the final result will be an array sorted in exactly the opposite way.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，将比较函数的结果反转。这将反转所有关于哪个字符串应该排在前面所做的决定，最终结果将是一个按完全相反的顺序排序的数组。
- en: Write a `sortDescending()` function or method that does its work in the opposite
    fashion to `sort()`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 `sortDescending()` 函数或方法，使其工作方式与 `sort()` 相反。
- en: 'Let’s opt for the second option and write an `invert()` function that will
    change the comparison result. The code itself is quite similar to that of `not()`.
    Again, check *Question 6.5* for the TypeScript equivalent:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择第二个选项，编写一个 `invert()` 函数来改变比较结果。代码本身与 `not()` 的代码非常相似。再次检查 *问题6.5* 以获取
    TypeScript 的等效代码：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Given this HOF, we can sort in descending order by providing a suitably inverted
    `comparison` function. Take a look at the last few lines, where we use `invert()`
    to change the result of the sorting comparison:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个高阶函数（HOF），我们可以通过提供一个适当反转的 `comparison` 函数来按降序排序。看看最后几行，我们使用 `invert()` 来改变排序比较的结果：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as expected: when we `invert()` the `comparison` function, the
    results are in the opposite order. Writing unit tests would be quite easy, given
    that we already have some test cases with their expected results, wouldn’t it?'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出符合预期：当我们 `invert()` `comparison` 函数时，结果顺序相反。考虑到我们已经有一些带有预期结果的测试用例，编写单元测试应该相当容易，不是吗？
- en: Arity changing
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数数量变化
- en: Back in the *Parsing numbers tacitly* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, we saw that using `parseInt()` with `reduce()` produces
    problems because of the unexpected arity of that function, which took more than
    one argument—remember the example from earlier?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [*第5章*](B19301_05.xhtml#_idTextAnchor084) 的 *Parsing numbers tacitly* 部分，在
    *Programming Declaratively* 中，我们看到了使用 `parseInt()` 与 `reduce()` 产生问题，因为该函数的预期参数数量不正确，它接受了一个以上的参数——还记得之前的例子吗？
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have more than one way to solve this. In the mentioned chapter, we went
    with an arrow function. This was a simple solution, with the added advantage of
    being clear to understand. In [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128),
    *Transforming Functions*, we will look at yet another, based on partial application.
    For now, let’s go with an HOF We need a function that will take another function
    as a parameter and turn it into a unary function. Using JavaScript’s spread operator
    and an arrow function, this is easy to manage:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不止一种方法来解决这个问题。在提到的章节中，我们选择了箭头函数。这是一个简单的解决方案，并且具有易于理解的额外优势。在第 [*第 7 章*](B19301_07.xhtml#_idTextAnchor128)
    *转换函数* 中，我们将探讨另一种基于偏应用的方法。现在，让我们使用一个高阶函数（HOF）。我们需要一个函数，它将接受另一个函数作为参数，并将其转换为单参数函数。使用
    JavaScript 的展开操作符和箭头函数，这很容易处理：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following is the example in TypeScript:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用 TypeScript 编写的示例：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our `unary()` function works with a generic `T` function. It produces a new
    function with just a single argument (the first one, `Parameters<T>[0]`) that
    returns the same type of result (`ReturnType<T>`) as the original function does.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `unary()` 函数与一个通用的 `T` 函数一起工作。它产生一个新的函数，只有一个参数（第一个参数，`Parameters<T>[0]`），该参数返回与原始函数相同类型的结果（`ReturnType<T>`）。
- en: 'Using this function, our number parsing problem goes away:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们的数字解析问题就消失了：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It goes without saying that it would be equally simple to define further `binary()`
    or `ternary()`functions, and others that would turn any function into an equivalent
    but restricted-arity version. Let’s not go overboard and just look at a couple
    of all the possible functions – see *Question 6.10* for more on this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，定义进一步的 `binary()` 或 `ternary()` 函数，以及其他将任何函数转换为等价但限制参数版本的函数同样简单。我们不要做得太过分，只看看所有可能函数中的一小部分——有关更多信息，请参阅
    *问题 6.10*：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This works, but spelling out all the parameters can become tiresome. We can
    even go one better by using array operations and spreading and make a generic
    function to deal with all of these cases, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这方法可行，但逐个列出所有参数可能会变得令人厌烦。我们可以更进一步，通过使用数组操作和展开操作，创建一个通用函数来处理所有这些情况，如下所示：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this generic `arity()` function, we can give alternative definitions for
    `unary()`, `binary()`, and so on. We could even rewrite the earlier functions
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个通用的 `arity()` 函数，我们可以为 `unary()`、`binary()` 等函数提供不同的定义。我们甚至可以将之前的函数重写如下：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You may think that there aren’t many cases in which you would want to apply
    this kind of solution, but there are many more than you would expect. Going through
    all of JavaScript’s functions and methods, you can quickly produce a list starting
    with `apply()`, `assign()`, `bind()`, `concat()`, `copyWithin()`, and many more!
    If you wanted to use any of those in a tacit way, you would probably need to fix
    their arity so that they would work with a fixed, non-variable number of parameters.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为你不太可能需要应用这种解决方案，但比你预期的要多得多。通过遍历 JavaScript 的所有函数和方法，你可以快速生成一个以 `apply()`、`assign()`、`bind()`、`concat()`、`copyWithin()`
    等开始的列表！如果你想在隐式方式下使用这些函数，你可能需要固定它们的参数数量，以便它们能够与固定数量的参数一起工作。
- en: Everything under the sun
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 世间万物
- en: If you want a nice list of JavaScript functions and methods, check out [developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions)
    and [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index).
    As for tacit programming (or pointfree style), we’ll return to it in [*Chapter
    8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看 JavaScript 函数和方法的良好列表，请查看 [developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions)
    和 [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index)。至于隐式编程（或点免费风格），我们将在
    [*第 8 章*](B19301_08.xhtml#_idTextAnchor148) *连接函数* 中再次讨论。
- en: There will be a problem with TypeScript, though. TypeScript deals with static
    typing, but the type of the result of a call to `arity()` is determined at runtime.
    The most we may manage is, by a series of overloads, to say that given a function
    with several parameters, the result of applying `arity()` to it will have zero,
    one, two, and so on different possibilities – but we won’t be able to do more.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TypeScript 会遇到一个问题。TypeScript 处理静态类型，但 `arity()` 函数调用的结果类型是在运行时确定的。我们最多可以通过一系列重载来说明，给定一个具有多个参数的函数，应用
    `arity()` 后的结果将有零个、一个、两个等不同可能性——但我们无法做得更多。
- en: So far, we have learned how to wrap functions while keeping their original behavior
    or changing it in some fashion. Now, let’s consider some other ways of modifying
    functions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何包装函数，同时保持其原始行为或以某种方式改变它。现在，让我们考虑一些修改函数的其他方法。
- en: Throttling and debouncing
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻尼和节流
- en: 'Let’s finish this section with two techniques that limit when and how often
    a function “does its thing”: **debouncing** and **throttling**. Both techniques
    share the same concept, so we’ll tackle them together:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以两种限制函数何时以及如何频繁执行的技术来结束本节：**阻尼**和**节流**。这两种技术具有相同的概念，因此我们将一起探讨：
- en: '*Debouncing* a function means we delay for some time, doing nothing *until*
    we actually call the function'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*阻尼*一个函数意味着我们延迟一段时间，直到我们实际调用该函数才执行任何操作'
- en: '*Throttling* a function means we delay for some time, doing nothing *after*
    we actually call the function'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*节流*一个函数意味着我们延迟一段时间，在实际上调用函数之后不执行任何操作'
- en: These techniques are very efficient for web pages and allow for better performance.
    In a sense, they are related to memoizing. With memoization, you modify a function
    so it will get called only once (for some given arguments) but never more. With
    the techniques here, we do not go that far – we will allow a function to do its
    thing again, but in a restricted way, with some delays added in.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术在网页中非常高效，允许更好的性能。从某种意义上说，它们与记忆化（memoization）相关。通过记忆化，你修改一个函数，使其只会在某些给定参数的情况下被调用一次，但不会更多。在这里的技术中，我们不会走那么远——我们将允许函数再次执行，但以一种受限制的方式，并添加一些延迟。
- en: Debouncing functions
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阻尼函数
- en: The idea of debouncing comes from electronics and involves waiting to do something
    until a stable state has been reached. For example, if you write an autocomplete
    component, every time the user types a letter, you could query an API to fetch
    the possible options. However, you wouldn’t want to do this keypress by keypress
    because you’d be generating lots of calls, most of which you won’t even use since
    you’ll only care for the last one you made. Other usual examples involve mouse
    movement or page scrolling events; you don’t want to run associated handlers too
    often since that will negatively impact the page’s performance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 阻尼（debouncing）这一概念源自电子学，它涉及到等待直到达到一个稳定状态。例如，如果你编写了一个自动完成组件，每次用户输入一个字母时，你可能会查询一个API来获取可能的选择。然而，你并不想逐个按键地这样做，因为你会产生大量的调用，其中大部分你甚至不会使用，因为你只关心你最后做出的那个调用。其他常见的例子包括鼠标移动或页面滚动事件；你不想频繁地运行相关的处理程序，因为这会负面影响页面的性能。
- en: 'If you debounced the API-calling function, you could still call it for every
    keypress, but no API call would be made until some time elapsed without any more
    calls. See *Figure 6**.2* for an example of this; events are shown as circles,
    and the actual call goes only given some event-less time after the last event:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阻尼了API调用函数，你仍然可以每次按键时调用它，但直到一段时间内没有更多调用，不会进行任何API调用。请参见*图6.2*中的示例；事件以圆圈表示，实际的调用只在最后一个事件之后的一段时间内发生，没有事件发生：
- en: '![Figure 6.2 – A debounced function executes only after a pause in calls to
    it](img/Figure_6.2_B19301.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 阻尼函数仅在调用暂停后执行](img/Figure_6.2_B19301.jpg)'
- en: Figure 6.2 – A debounced function executes only after a pause in calls to it
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 阻尼函数仅在调用暂停后执行
- en: 'We can implement this with a timeout as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式使用超时来实现这一点：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A debounced function is a new one that can be called as often as desired but
    won’t do anything until a `timer` has run. If you call the function once and then
    call it again, the timer will be reset and start running again. The only way for
    the function to actually do its thing is if a given `delay` period passes without
    any new calls.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一个阻尼函数是一个新的函数，它可以被频繁调用，但在`计时器`运行之前不会执行任何操作。如果你调用一次函数，然后再次调用它，计时器将被重置并重新开始运行。函数真正执行其操作的唯一方式是在给定`延迟`期间没有新的调用。
- en: Throttling functions
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制函数
- en: For the complementary throttling transformation, imagine a web form with a **FETCH**,
    **APPLY FILTERS**, or **RETRIEVE** button. When you click on it, an API call is
    made to get some data. However, if the user starts clicking again and again, too
    many calls will be made, even if they will get the same results. We want to throttle
    the calls so the first call will go through, but further calls will be disabled
    until some time has passed. A similar use case applies to *infinite scrolling*;
    as the user scrolls down the page, you want to fetch more data, but you neither
    want to do it very often for performance reasons nor wait until the user reaches
    the bottom (as would be the case with debouncing) because then scrolling would
    be stopped.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于互补的节流转换，想象一个带有**FETCH**、**APPLY FILTERS**或**RETRIEVE**按钮的网页表单。当你点击它时，会发起API调用以获取一些数据。然而，如果用户不断点击，即使会得到相同的结果，也会发起过多的调用。我们希望节流调用，以便第一次调用通过，但进一步的调用将在一段时间后禁用。类似的使用场景也适用于*无限滚动*；当用户向下滚动页面时，你想要获取更多数据，但出于性能原因，你既不想非常频繁地执行，也不想等到用户到达底部（就像防抖那样），因为那样滚动就会停止。
- en: 'Throttling is similar to debouncing, but a throttled function runs but then
    waits until the next run, while a debounced function first waits and then runs.
    *Figure 6**.3* shows how throttling works. As in the previous section, events
    are shown as circles. After a call to the API, no further calls are done unless
    some time has passed:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 节流与防抖类似，但节流函数运行后等待下一次运行，而防抖函数先等待然后运行。*图6.3*显示了节流的工作原理。与上一节一样，事件以圆圈表示。在调用API之后，除非经过一段时间，否则不会进行进一步的调用：
- en: '![Figure 6.3 – A throttled function runs the first time it’s called but then
    delays until running again](img/Figure_6.3_B19301.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 节流函数第一次调用时运行，但随后延迟直到再次运行](img/Figure_6.3_B19301.jpg)'
- en: Figure 6.3 – A throttled function runs the first time it’s called but then delays
    until running again
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 节流函数第一次调用时运行，但随后延迟直到再次运行
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A throttled function is a new one, which you can call as often as desired, but
    it will “do its thing” the first time and not again until a certain `delay`. When
    you call the function, it first checks whether the `timer` is set; if so, it won’t
    do anything. If the timer isn’t set, a timeout will be set to clear the `timer`
    after some `delay`, and the function will be called. We are using the `timer`
    variable both for the timeout and as a flag (“are we waiting?”).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 节流函数是一个新的函数，你可以按需多次调用，但它在第一次“做其事”后不会再次运行，直到某个`delay`。当你调用函数时，它首先检查是否设置了`timer`；如果是，则不会做任何事情。如果没有设置`timer`，则会设置一个超时，在一段时间后清除`timer`，然后调用函数。我们正在使用`timer`变量作为超时以及作为标志（“我们在等待吗？”）。
- en: So far, we have learned how to wrap functions while keeping their original behavior
    or by altering them in some fashion. Now, let’s consider some other ways of modifying
    functions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何包装函数，同时保持其原始行为或以某种方式修改它们。现在，让我们考虑一些修改函数的其他方法。
- en: Changing functions in other ways
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以其他方式更改函数
- en: 'Let’s end this chapter by considering other sundry functions that provide results,
    such as new finders, decoupling methods from objects, and more. Our examples will
    include the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑其他一些提供结果的函数来结束这一章，例如新的查找器、从对象中解耦的方法等。我们的例子将包括以下内容：
- en: Turning operations (such as adding with the `+` operator) into functions
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将操作（如使用`+`运算符进行加法）转换为函数
- en: Turning functions into promises
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数转换为承诺
- en: Accessing objects to get the value of a property
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问对象以获取属性的值
- en: Turning methods into functions
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将方法转换为函数
- en: A better way of finding optimum values
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找最优值的一种更好的方法
- en: Turning operations into functions
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将操作转换为函数
- en: 'We have already seen several cases where we needed to write a function just
    to add or multiply a pair of numbers. For example, in the *Summing an array* section
    of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    we had to write code equivalent to the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到几个需要编写函数来仅对一对数字进行加法或乘法运算的例子。例如，在[*第5章*](B19301_05.xhtml#_idTextAnchor084)的“求和数组”部分中，*声明式编程*，我们不得不编写以下等效代码：
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the *Working with ranges* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, we wrote this to calculate a factorial:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B19301_05.xhtml#_idTextAnchor084)的“处理范围”部分中，*声明式编程*，我们编写了以下代码来计算阶乘：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It would have been easier if we could just turn a binary operator into a function
    that calculates the same result. The preceding two examples could have been written
    more succinctly, as follows. Can you understand the change we made?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以将二元运算符转换为一个计算相同结果的函数，那就简单多了。前两个例子可以更简洁地写成如下。你能理解我们做出的改变吗？
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We haven’t looked at how `binaryOp()` is implemented yet, but the key notion
    is that instead of an infix operator (like we use when we write `22+9`), we now
    have a function (as if we could write our sum like `+(22,9)`, which certainly
    isn’t valid JavaScript). Let’s see how we can make this work.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有查看 `binaryOp()` 的实现方式，但关键概念是，我们不再使用中缀运算符（就像我们在写 `22+9` 时使用的那样），我们现在有一个函数（就像我们能够将求和写成
    `+(22,9)` 一样，这当然不是有效的 JavaScript）。让我们看看我们如何实现这一点。
- en: Implementing operations
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现操作
- en: 'How would we write this `binaryOp()` function? There are at least two ways
    of doing so: a safe but long one and a riskier and shorter alternative. The first
    would require listing each possible operator. The following code does this by
    using a longish switch:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何编写这个 `binaryOp()` 函数？至少有两种方法：一种安全但较长的方案，另一种风险更高但更短的替代方案。第一种方案需要列出每个可能的运算符。以下代码通过使用较长的
    switch 语句来实现这一点：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This solution is perfectly fine but requires too much work. By the way, we
    should have separate `binaryMathOp()` and `binaryLogicalOp()` functions; the first
    would be `(op: string) => ((x: number, y: number) => number)` while the second
    would be `(op: string) => ((x: boolean, y: boolean) => boolean)` because, as in
    the previous section, TypeScript cannot deduce the type of the returned function.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '这个解决方案完全可行，但需要做太多的工作。顺便说一句，我们应该有单独的 `binaryMathOp()` 和 `binaryLogicalOp()`
    函数；第一个会是 `(op: string) => ((x: number, y: number) => number)`，而第二个会是 `(op: string)
    => ((x: boolean, y: boolean) => boolean)`，因为，正如前一个部分中提到的，TypeScript 无法推断返回函数的类型。'
- en: 'There’s a second solution, which is shorter but more dangerous. Please consider
    this only as an example for learning purposes; using `eval()` isn’t recommended
    for security reasons! Our second version would use `Function()` to create a new
    function that uses the desired operator, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是更短但更危险的。请仅将其视为学习目的的示例；出于安全原因，不建议使用 `eval()`！我们的第二个版本将使用 `Function()`
    创建一个新的函数，该函数使用所需的运算符，如下所示：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Again, TypeScript cannot determine the type of the returned function because
    that will be determined only at runtime. So, we need to write the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，TypeScript 无法确定返回函数的类型，因为这将仅在运行时确定。因此，我们需要编写以下代码：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We don’t have to specify the type of `binaryOp2()` because TypeScript can work
    it out to be `(o: string) => (x: number, y: number) => number` by itself, given
    the cast that we applied to the result.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '我们不需要指定 `binaryOp2()` 的类型，因为 TypeScript 可以根据我们应用到的类型转换自行推断出 `(o: string) =>
    (x: number, y: number) => number`。'
- en: The (easier) way out
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: （更简单）的出路
- en: Some libraries, such as Lodash, already provide functions such as `_.multiply()`
    and `_.sum()`, so that’s a more straightforward solution! You could quickly whip
    up your own and create your own mini-library of mathematical and logical essential
    functions.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库，如 Lodash，已经提供了 `_.multiply()` 和 `_.sum()` 等函数，因此这是一个更直接的解决方案！你可以快速创建自己的，并创建自己的数学和逻辑基本函数的迷你库。
- en: If you follow this train of thought, you may also define a `unaryOp()` function,
    even though there are fewer applications for it. (I leave this implementation
    to you; it’s similar to what we already wrote.) In [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128),
    *Transforming Functions*, we will look at an alternative way of creating this
    unary function by using a partial application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这个思路，你也可以定义一个 `unaryOp()` 函数，尽管它的应用较少。（我将这个实现留给你；它与我们已经写过的类似。）在[*第7章*](B19301_07.xhtml#_idTextAnchor128)，*转换函数*中，我们将探讨通过使用部分应用来创建这个一元函数的另一种方法。
- en: A handier implementation
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个更方便的实现
- en: 'Let’s get ahead of ourselves. Doing FP doesn’t always mean getting down to
    the simplest possible functions. For example, in an upcoming section of this book,
    we will need a function to check whether a number is negative, and we’ll consider
    (see the *Converting to pointfree style* section of [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148)*,
    Connecting Functions*) using `binaryOp2()` to write it:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先不要急于求成。进行函数式编程（FP）并不总是意味着要深入到最简单的函数。例如，在这本书的一个即将到来的部分，我们需要一个函数来检查一个数字是否为负，我们将考虑（参见[*第8章*](B19301_08.xhtml#_idTextAnchor148)*，将函数转换为无参数风格*部分）使用
    `binaryOp2()` 来编写它：
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Don’t worry about the `curry()` function for now (we’ll get to it soon, in
    the following chapter) – the idea is that it fixes the first argument to `0` so
    that our function will check for a given `n` number if `0>n`. The point is that
    the function we just wrote isn’t very clear. We could do better if we defined
    a binary operation function that lets us specify one of its parameters – the left
    or the right one – in addition to the operator to be used. Here, we can write
    the following couple of functions, which define the functions where the left or
    right operators are missing:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心`curry()`函数（我们将在下一章中详细介绍）——其想法是将第一个参数固定为`0`，这样我们的函数将检查给定的`n`数字是否`0>n`。关键是，我们刚刚编写的函数不是很清晰。如果我们定义一个二元操作函数，它允许我们指定其中一个参数——左边的或右边的——以及要使用的运算符，我们会做得更好。在这里，我们可以编写以下两个函数，它们定义了左操作符或右操作符缺失的函数：
- en: '[PRE60]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'With these new functions, we could write either of the following two definitions,
    though I think the second is clearer. I’d rather test whether a number is less
    than `0` than whether `0` is greater than the number:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些新函数，我们可以写出以下两种定义中的任意一种，尽管我认为第二种更清晰。我更愿意测试一个数字是否小于`0`，而不是`0`是否大于该数字：
- en: '[PRE61]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: What is the point of this? Don’t strive for some basic simplicity or go down
    to basics. We can transform an operator into a function, but if you can do better
    and simplify your coding by specifying one of the two parameters for the operation,
    just do it! The idea of FP is to help write better code, and creating artificial
    limitations won’t help anybody.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么意义？不要追求一些基本的简单性或回到基础。我们可以将运算符转换为函数，但如果你能通过指定操作的两个参数之一来做得更好并简化你的编码，那就这么做吧！函数式编程（FP）的目的是帮助编写更好的代码，而创造人为的限制对任何人都没有帮助。
- en: 'Of course, for a simple function such as checking whether a number is negative,
    I would never want to complicate things with currying, binary operators, pointfree
    style, or anything else, and I’d write the following with no further ado:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于像检查一个数字是否为负这样的简单函数，我永远不会想通过currying、二元运算符、pointfree风格或其他任何东西来使事情复杂化，我会毫不犹豫地写出以下内容：
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: So far, we have seen several ways of solving the same problem. Keep in mind
    that FP doesn’t force you to pick one way of doing things; instead, it allows
    you a lot of freedom in deciding which way to go!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了解决相同问题的几种方法。请记住，函数式编程（FP）并不强迫你选择一种做事的方式；相反，它为你提供了很多自由来决定走哪条路！
- en: Turning functions into promises
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数转换为承诺
- en: 'In Node.js, most asynchronous functions require a callback such as `(err,data)=>{...}`:
    if `err` is falsy, the function was successful, and `data` is its result; otherwise,
    the function failed, and `err` gives the cause. (See [nodejs.org/api/errors.html#error-first-callbacks](http://nodejs.org/api/errors.html#error-first-callbacks)
    for more on this.)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，大多数异步函数需要一个回调，例如`(err,data)=>{...}`：如果`err`是假的，函数执行成功，`data`是它的结果；否则，函数失败，`err`给出原因。（有关更多信息，请参阅[nodejs.org/api/errors.html#error-first-callbacks](http://nodejs.org/api/errors.html#error-first-callbacks)。）
- en: However, you might prefer to work with promises instead. So, we can think of
    writing an HOF that will transform a function that requires a callback into a
    promise that lets you use the `then()` and `catch()` methods. (In [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, we will see that promises are actually *monads*,
    so this transformation is interesting in yet another way.) This will be an exercise
    for some developers because Node.js (since version 8) already provides the `util.promisify()`
    function, which turns an `async` function into a promise. See [nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original](http://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original)
    for more on that.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能更喜欢使用承诺。因此，我们可以考虑编写一个高阶函数（HOF），它将需要一个回调的函数转换为一个承诺，让你可以使用`then()`和`catch()`方法。（在[*第12章*](B19301_12.xhtml#_idTextAnchor221)，*构建更好的容器*中，我们将看到承诺实际上是*单子*，所以这种转换在另一个方面也很有趣。）这将是一些开发者的练习，因为Node.js（自版本8起）已经提供了`util.promisify()`函数，它将异步函数转换为承诺。有关更多信息，请参阅[nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original](http://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original)。
- en: 'So, how can we manage this? The transformation is relatively simple. Given
    a function, we produce a new one: this will return a promise that, upon calling
    the original function with some parameters, will either `reject()` or `resolve()`
    the promise appropriately.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何管理这个问题呢？转换过程相对简单。给定一个函数，我们生成一个新的函数：这个新函数会在调用原始函数并传入一些参数后，适当地`reject()`或`resolve()`一个承诺。
- en: 'The `promisify()` function does precisely that. Its parameter is an `fn` function
    that returns either an `err` error of generic type `E`, or some `data` of generic
    type `D`. The arguments of `fn` may be any type, except that the last one must
    be a callback; this requires using *variadic* data types, available in TypeScript
    since version 4.0, from 2020:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`promisify()`函数正是如此。它的参数是一个返回通用类型`E`的`err`错误或一些通用类型`D`的`data`的`fn`函数。`fn`的参数可以是任何类型，除了最后一个参数必须是回调；这需要使用自TypeScript
    4.0版本以来可用的*可变参数*数据类型，从2020年开始：'
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The given `fn` function is turned into a promise. The promise calls `fn` with
    a special callback: if that callback gets a non-null `err` value, the promise
    is rejected with that error; otherwise, the promise is resolved with `data`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的`fn`函数被转换成一个承诺。这个承诺调用`fn`并使用一个特殊的回调：如果那个回调得到一个非空`err`值，承诺会因那个错误而被拒绝；否则，承诺会因`data`而被解决。
- en: 'When working in Node.js, the following style is fairly common:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中工作的时候，以下风格相当常见：
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You can use promises instead by using our `promisify()` function – or in current
    versions of Node.js, `util.promisify()` (but see the following, by the end of
    this section!):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用我们的`promisify()`函数来使用承诺，或者在当前版本的Node.js中，使用`util.promisify()`（但请参见本节末尾的内容！）：
- en: '[PRE65]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, you can use `fspromise()` instead of the original method. To do so, we
    had to bind `fs.readFile`, as we mentioned in the *An unnecessary mistake* section
    of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting Out* *with Functions*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`fspromise()`代替原始方法。为此，我们必须绑定`fs.readFile`，正如我们在[*第3章*](B19301_03.xhtml#_idTextAnchor054)*，从函数开始*的*不必要的错误*部分中提到的：
- en: By the way, when using Node.js, be aware that many modules already provide a
    promise-based API in addition to the older callback-based API; for example, see
    [nodejs.org/api/fs.html#promises-api](http://nodejs.org/api/fs.html#promises-api)
    and compare it to [nodejs.org/api/fs.html#callback-api](http://nodejs.org/api/fs.html#callback-api).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，当使用Node.js时，请注意，许多模块已经提供了基于承诺的API，除了较老的基于回调的API；例如，参见[nodejs.org/api/fs.html#promises-api](http://nodejs.org/api/fs.html#promises-api)并与[nodejs.org/api/fs.html#callback-api](http://nodejs.org/api/fs.html#callback-api)进行比较。
- en: Getting a property from an object
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从对象中获取属性
- en: 'There is a simple function that we could also produce. Extracting an attribute
    from an object is a commonly required operation. For example, in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, we had to get latitudes and longitudes to calculate
    an average. The code for this was as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以生成一个简单的函数。从对象中提取属性是一个常见的操作。例如，在[*第5章*](B19301_05.xhtml#_idTextAnchor084)，*声明式编程*中，我们需要获取纬度和经度来计算平均值。这段代码如下：
- en: '[PRE66]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We saw another example when we learned how to filter an array; in our example,
    we wanted to get the IDs for all the accounts with a negative balance. After filtering
    out all other accounts, we still needed to extract the `id` field:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习如何过滤数组时，我们看到了另一个例子；在我们的例子中，我们想要获取所有账户的ID，这些账户的余额为负。在过滤掉所有其他账户后，我们仍然需要提取`id`字段：
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'What do we need? We need an HOF that will receive the name of an attribute
    and produce a new function that can extract an attribute from an object. Using
    the arrow function syntax, this function is easy to write; `f` is the name of
    the field we want, and `obj` is the object from which to get the field:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要什么？我们需要一个HOF（高阶函数），它将接收一个属性的名称并生成一个新的函数，可以从对象中提取属性。使用箭头函数语法，这个函数很容易编写；`f`是我们想要的字段名称，而`obj`是从中获取字段的对象：
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The full TypeScript version is a bit longer, but not much; mainly, we need
    to specify that `f` must be a key of the object:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的TypeScript版本要长一些，但并不多；主要，我们需要指定`f`必须是对象的一个键：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'With this function, the coordinate extraction process could have been written
    as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，坐标提取过程可以写成如下形式：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'But that won’t be accepted! The issue is that TypeScript cannot detect the
    type of the result of the call to `getField()` because that will be decided at
    runtime. We must help by informing it that our two calls will return numbers.
    We can define the type of a generic number-returning function as `NumFn`, and
    then write the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不会被接受！问题是TypeScript无法检测`getField()`调用结果的类型，因为这将由运行时决定。我们必须通过通知它我们的两个调用将返回数字来帮助它。我们可以将泛型数字返回函数的类型定义为`NumFn`，然后编写以下内容：
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For variety, we could have used an auxiliary variable to get the delinquent
    IDs and avoid using an extra type similar to `NumFn`, as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了多样化，我们可以使用一个辅助变量来获取拖欠的ID，并避免使用类似于`NumFn`的额外类型，如下所示：
- en: '[PRE72]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Make sure that you fully understand what’s going on here. The result of the
    `getField()` call is a function that will be used in further expressions. The
    `map()` method requires a mapping function and is what `getField()` produces.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你完全理解这里发生的事情。`getField()`调用的结果是将在后续表达式中使用的函数。`map()`方法需要一个映射函数，这正是`getField()`产生的。
- en: Demethodizing – turning methods into functions
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去方法化——将方法转换为函数
- en: Methods such as `filter()` and `map()` are only available for arrays; however,
    you may want to apply them to, say, `NodeList` or `String`, and you’d be out of
    luck. Also, we are focusing on strings, so having to use these functions as methods
    is not exactly what we had in mind. Finally, whenever we create a new function
    (such as `none()`, which we saw in the *Checking negatives* section of [*Chapter
    5*](B19301_05.xhtml#_idTextAnchor084)*, Programming Declaratively*), it cannot
    be applied in the same way as its peers (`some()` and `every()`, in this case)
    unless you do some prototype trickery. This is rightly frowned upon and not recommended,
    but we’ll look into it anyhow; another case of “do as I say, not as I do!”
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`和`map()`等方法仅适用于数组；然而，你可能希望将它们应用于`NodeList`或`String`等，这将很不幸。此外，我们专注于字符串，因此不得不将这些函数作为方法使用，这并不完全符合我们的初衷。最后，每次我们创建一个新函数（例如，我们在[*第5章*](B19301_05.xhtml#_idTextAnchor084)的*检查负数*部分中看到的`none()`函数），它不能像它的同伴（在这种情况下是`some()`和`every()`）那样应用，除非你做一些原型技巧。这是正确的，不推荐这样做，但我们将探讨它；这是“说一套，做一套”的另一个案例。'
- en: Read the *Extending current data types* section of [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, where we will make `map()` available for most basic
    types.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读[*第12章*](B19301_12.xhtml#_idTextAnchor221)中的*扩展当前数据类型*部分，即《构建更好的容器》，我们将在这里使`map()`函数适用于大多数基本类型。
- en: So, what can we do? We can apply the old saying *If the mountain won’t come
    to Muhammad, then Muhammad must go to the mountain*. Instead of worrying about
    not being able to create new methods, we will turn the existing methods into functions.
    We can do this if we convert each method into a function that will receive, as
    its first parameter, the object it will work on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能做什么呢？我们可以应用古老的谚语“如果山不来穆罕默德，那么穆罕默德就去山”。我们不再担心无法创建新方法，而是将现有方法转换为函数。如果我们把每个方法转换成一个函数，它将作为其第一个参数接收它将工作的对象。我们可以这样做。
- en: Decoupling methods from objects can help you because once you achieve this separation,
    everything turns out to be a function, and your code will be simpler. (Remember
    what we wrote in the *Logically negating a function* section, regarding a possible
    `filterNot()` function in comparison to the `filter()` method?) A decoupled method
    works similarly to generic functions in other languages since they can be applied
    to diverse data types.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法从对象中解耦可以帮助你，一旦你实现了这种分离，一切都会变成函数，你的代码将会更简单。（记得我们在*逻辑上否定函数*部分写的内容，关于与`filter()`方法相比可能的`filterNot()`函数？解耦的方法在其他语言中的泛型函数工作方式相似，因为它们可以应用于不同的数据类型）。
- en: 'An important ABC: apply, bind, call'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 重要ABC：应用、绑定、调用
- en: Take a look at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    for explanations on `apply()`, `call()`, and `bind()`. We are going to use these
    for our implementation. Back in [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015),
    *Becoming Functional*, we saw the equivalence between `apply()` and `call()` when
    we used the spread operator.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 查看developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function，了解`apply()`、`call()`和`bind()`的解释。我们将使用这些来实现我们的功能。回到[*第1章*](B19301_01.xhtml#_idTextAnchor015)的*成为函数式开发者*，我们使用了展开运算符时，看到了`apply()`和`call()`之间的等价性。
- en: 'There are three distinct but similar ways to implement this decoupling in JavaScript.
    The first argument in the list (`arg0`) will correspond to the object, and the
    other arguments (`...args`) to the actual ones for the called method. The three
    equivalent versions would be as follows, and any of them could be used as a `demethodize()`
    function; pick your favorite! Let’s go with a plain JavaScript version to understand
    how they work; see *Question 6.15* for TypeScript versions:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中实现这种解耦有三种不同但相似的方法。列表中的第一个参数（`arg0`）将对应于对象，其他参数（`...args`）对应于被调用方法的实际参数。三个等效版本如下，任何一种都可以用作
    `demethodize()` 函数；选择你喜欢的！让我们用一个纯 JavaScript 版本来理解它们是如何工作的；有关 TypeScript 版本的详细信息，请参阅
    *问题 6.15*：
- en: '[PRE73]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: A fourth way
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种方法
- en: 'There’s yet another way of doing this: `const demethodize = Function.prototype.bind.bind(Function.prototype.call)`.
    If you want to understand how this works, read Leland Richardson’s *Clever Way
    to Demethodize Native JS Methods*, at [www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods](http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法来做这件事：`const demethodize = Function.prototype.bind.bind(Function.prototype.call)`。如果你想了解它是如何工作的，请阅读
    Leland Richardson 的 *Clever Way to Demethodize Native JS Methods*，网址为 [www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods](http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods)。
- en: Let’s look at some applications of these! Let’s start with a simple one that
    will also serve as a warning. We can make the `sort()` method into a function
    – but don’t think it will be made pure!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些应用的一些例子！让我们从一个简单但也会起到警示作用的例子开始。我们可以将 `sort()` 方法转换为一个函数——但不要认为它会变得纯净！
- en: '[PRE74]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now we can use `sort()` as a function – but it still produces the same side
    effect; `a` and `b` are the same array since `sort()` keeps working “in place.”
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将 `sort()` 作为函数使用——但它仍然会产生相同的外部效应；`a` 和 `b` 是同一个数组，因为 `sort()` 仍然在原地工作。
- en: 'A more contrived case: we can use `map()` to loop over a string without converting
    it into an array of characters first. Say you wanted to separate a string into
    individual letters and make them uppercase; we could achieve this by using `split()`
    and `toUpperCase()`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的情况：我们可以使用 `map()` 来遍历一个字符串，而无需先将其转换为字符数组。比如说，如果你想将一个字符串拆分成单独的字母并将它们转换为大写；我们可以通过使用
    `split()` 和 `toUpperCase()` 来实现这一点：
- en: '[PRE75]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'By demethodizing `map()` and `toUpperCase()`, we can simply write the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通过去方法化 `map()` 和 `toUpperCase()`，我们可以简单地写出以下代码：
- en: '[PRE76]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Yes, of course, for this particular case, we could have turned the string into
    uppercase and then split it into separate letters, as in `name.toUpperCase().split("")`,
    but it wouldn’t have been such a nice example, with two usages of demethodizing
    being used.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于这个特定的情况，我们可以将字符串转换为大写，然后将其拆分为单独的字母，就像 `name.toUpperCase().split("")` 一样，但这不会是一个很好的例子，因为这里使用了两次去方法化。
- en: 'Similarly, we could convert an array of decimal amounts into properly formatted
    strings with thousands separators and decimal points:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将一系列十进制金额转换为带有千位分隔符和小数点的正确格式的字符串：
- en: '[PRE77]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Alternatively, given the preceding demethodized `map()` function, we could have
    done the mapping with `map(numbers,` `toLocaleString)` instead.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，鉴于前面的去方法化 `map()` 函数，我们也可以用 `map(numbers,` `toLocaleString)` 来进行映射。
- en: The idea of demethodizing a method to turn it into a function will prove to
    be quite useful in diverse situations. We have already seen some examples where
    we could have applied it, and there will be more such cases in the rest of this
    book.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法去方法化以将其转换为函数的想法将在各种情况下证明非常有用。我们已经在一些例子中看到了它的应用，这本书的其余部分还将出现更多这样的案例。
- en: Methodizing – turning functions into methods
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法化——将函数转换为方法
- en: In the previous section, we saw how we could separate methods from objects to
    transform them into independent, standalone functions. Then, for fairness, let’s
    consider the complementary transformation, adding a function (as a method) to
    objects. We should call this operation *methodizing*, shouldn’t we?
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何将方法从对象中分离出来，将它们转换成独立的、独立的函数。然后，为了公平起见，让我们考虑相应的转换，即向对象添加一个函数（作为方法）。我们应该称这个操作为
    *方法化*，不是吗？
- en: We already saw something of this when we defined and worked with polyfills in
    the *Adding missing functions* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*,
    Starting Out with Functions*. Modifying prototypes is usually frowned upon because
    of the possibility of clashes with different libraries, at the very least. However,
    it’s an interesting technique, so let’s study it anyway.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第 3 章*](B19301_03.xhtml#_idTextAnchor054)*的*添加缺失功能*部分定义和操作 polyfills 时，我们已经看到了一些这样的内容。修改原型通常是不受欢迎的，因为可能会与不同的库发生冲突，至少在理论上是这样。然而，这是一个有趣的技巧，所以无论如何让我们来研究它。
- en: Reversing strings
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反转字符串
- en: 'Let’s start with a simple example. Back in the *Folding left and right* section
    of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively,*
    we defined a `reverseString()` function to reverse a string. Since we already
    have a `reverse()` method that works with arrays, we could implement a `reverse()`
    method for strings. For variety, let’s do a new implementation of the string-reversing
    logic. We’ll add a Boolean parameter; if set to `true`, the function will add
    dashes between letters; this is just to show that methodizing also works with
    functions with more parameters. What we want to achieve is the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。回到[*第 5 章*](B19301_05.xhtml#_idTextAnchor084)*的*左右折叠*部分，我们在*声明式编程*中定义了一个
    `reverseString()` 函数来反转字符串。由于我们已经有了一个可以与数组一起工作的 `reverse()` 方法，我们可以为字符串实现一个 `reverse()`
    方法。为了增加多样性，让我们对字符串反转逻辑进行新的实现。我们将添加一个布尔参数；如果设置为 `true`，函数将在字母之间添加破折号；这只是为了表明方法化也可以与具有更多参数的函数一起工作。我们想要实现的是以下内容：
- en: '[PRE78]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The needed function is as follows (as a curiosity, note that we are using the
    array `reverse()` method to implement our `reverse()` string one!):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的函数如下（作为一个好奇的观察，请注意，我们正在使用数组的 `reverse()` 方法来实现我们的 `reverse()` 字符串方法！）：
- en: '[PRE79]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We used a standard function (instead of an arrow one) because of the implicit
    handling of `this`, which wouldn’t be bound otherwise. Another crucial detail:
    the first argument to the function must be the string with which it will operate.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个标准函数（而不是箭头函数），因为如果没有额外的定义，`this` 将不会被绑定。另一个关键细节：函数的第一个参数必须是它将要操作的字符串。
- en: 'Now, we must tell TypeScript that we’ll be extending the `String.prototype`
    object with a new method (see [www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html](http://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html)
    for more on this):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须告诉 TypeScript 我们将扩展 `String.prototype` 对象以添加新方法（有关更多信息，请参阅 [www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html](http://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html)）：
- en: '[PRE80]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Without this definition (which could also have been in a separate `.d.ts` file),
    when we try to assign the new method, we’ll get the error shown in *Figure 6**.4*:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个定义（它也可以在单独的 `.d.ts` 文件中），当我们尝试分配新方法时，我们会得到 *图 6.4* 中显示的错误：
- en: '![Figure 6.4 – You cannot add new methods to an existing object without an
    extra definition](img/Figure_6.4_B19301.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 没有额外定义，您不能向现有对象添加新方法](img/Figure_6.4_B19301.jpg)'
- en: Figure 6.4 – You cannot add new methods to an existing object without an extra
    definition
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 没有额外定义，您不能向现有对象添加新方法
- en: 'How do we add a new method to the `String.prototype` object? In essence, we
    want to achieve the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何向 `String.prototype` 对象添加新方法？本质上，我们想要实现以下内容：
- en: '[PRE81]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We add a function that calls our original one. Note that `this` (the current
    string object) is passed as the first argument. Other parameters are passed untouched.
    We can implement all this with a `methodize()` function; let’s see it first in
    JavaScript and then get into typing details. We want to do the following to achieve
    this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个调用我们原始函数的函数。注意，`this`（当前字符串对象）被作为第一个参数传递。其他参数保持不变。我们可以使用 `methodize()`
    函数来实现所有这些；让我们首先在 JavaScript 中看看，然后再深入了解类型细节。我们想要做以下事情来实现这一点：
- en: '[PRE82]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is what we did before. We are using the function’s name for the newly
    added method’s name. In TypeScript, this is a bit more complex, but we need the
    data type checks, so let’s do this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们之前所做的事情。我们使用函数的名称作为新添加的方法的名称。在 TypeScript 中，这要复杂一些，但我们需要数据类型检查，所以让我们这样做：
- en: '[PRE83]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let’s see the data types we added:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们添加的数据类型：
- en: '`T` is the generic type of the parameters that we’ll pass to our new methodized
    function'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T` 是我们将传递给新方法化函数的参数的泛型类型'
- en: '`O` is the object’s type to whose prototype we’ll add the new method'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O` 是我们将添加新方法的那个对象的类型'
- en: '`F` is the function we’ll be methodizing; the first argument (`arg0`) is key,
    and we’ll be assigned the value of `this`. The other arguments (if any) are of
    a `T` type'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F`是我们将要方法化的函数；第一个参数（`arg0`）是关键，我们将分配`this`的值。其他参数（如果有）是`T`类型'
- en: 'How do we use this `methodize()` function? Simple, with just one line:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这个`methodize()`函数？很简单，只需一行代码：
- en: '[PRE84]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'With this, we can use our new method as planned:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以按计划使用我们的新方法：
- en: '[PRE85]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Averaging arrays
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组求平均值
- en: 'Let’s see one more example, to highlight a possible detail with typing. We’ll
    take the `average()` function that we wrote in the *Calculating an average* section
    of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084)*, Programming Declaratively,*
    and add it to `Array.prototype`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子，以突出一个可能的类型细节。我们将取我们在[*第5章*](B19301_05.xhtml#_idTextAnchor084)*计算平均值*部分中编写的`average()`函数，并将其添加到`Array.prototype`：
- en: '[PRE86]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The problem is that we want our function to only apply to arrays of numbers.
    We want TypeScript to detect and reject a line such as the following because of
    the wrong data type of the array:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们希望我们的函数只应用于数字数组。我们希望TypeScript能够检测并拒绝以下错误数据类型的数组行：
- en: '[PRE87]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'When writing the global declaration for the added method, an error will pop
    up:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写添加方法的全局声明时，将出现错误：
- en: '[PRE88]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The definition of `Array` must be bound to a generic `Array<T>`. However, our
    definition for `average()` doesn’t depend on `T`. This means we have an unused
    definition to which ESLint objects. Since there’s no way of including `T` in our
    function, we’ll have to tell ESLint to let the error be; no other solution!
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array`的定义必须绑定到泛型`Array<T>`。然而，我们的`average()`函数定义并不依赖于`T`。这意味着我们有一个未使用的定义，ESLint会对此提出警告。由于我们无法在我们的函数中包含`T`，我们不得不告诉ESLint忽略这个错误；没有其他解决方案！'
- en: 'There’s nothing more to this; we can now methodize the `average()` function
    and use it as a method:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多的事情了；我们现在可以方法化`average()`函数，并使用它作为一个方法：
- en: '[PRE89]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: You can now extend all base classes as desired – but remember our advice about
    being very, very careful!
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以按需扩展所有基类——但记住我们关于非常非常小心的建议！
- en: Finding the optimum
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找最佳值
- en: 'Let’s end this section by creating an extension of the `find()` method. Suppose
    we want to find the optimum value – let’s suppose it’s the maximum – of an array
    of numbers. We could make do with this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以创建`find()`方法的扩展来结束本节。假设我们想要找到一组数字中的最佳值——让我们假设是最大值——我们可以这样做：
- en: '[PRE90]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now, is this sufficiently general? There are at least a pair of problems with
    this approach. First, are you sure that the optimum of a set will always be the
    maximum? If you were considering several mortgages, the one with the lowest interest
    rate would be the best, right? To assume that you always want the maximum of a
    set is too constrictive.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种方法是否足够通用？至少存在两个问题。首先，你能确定一组数据的最佳值总是最大值吗？如果你在考虑几个抵押贷款，利率最低的那个可能是最好的，对吧？假设你总是想要一组数据的最大值是过于限制性的。
- en: A negative maximum?
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 负的最大值？
- en: 'You could do a roundabout trick: if you change the signs of all the numbers
    in an array, find its maximum, and change its sign, you actually get the minimum
    of the array. In our case, `-findOptimum(myArray.map((x) => -x))` would correctly
    produce `4`, but it’s not easily understandable code.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以玩一个绕弯子的技巧：如果你改变数组中所有数字的符号，找到它的最大值，并改变它的符号，你实际上得到了数组的最低值。在我们的例子中，`-findOptimum(myArray.map((x)
    => -x))`会正确地产生`4`，但这不是容易理解的代码。
- en: 'Second, this way of finding the maximum depends on each option having a numeric
    value. But how would you find the optimum if such a value didn’t exist? The usual
    way depends on comparing elements with each other and picking the one that comes
    out on top:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，这种寻找最大值的方法依赖于每个选项都有一个数值。但如果没有这样的值，你将如何找到最佳值？通常的方法是相互比较元素，并选择出类拔萃的那个：
- en: Compare the first element with the second and keep the best of those two.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个元素与第二个元素进行比较，并保留这两个元素中最好的。
- en: Then compare that value with the third element and keep the best.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将该值与第三个元素进行比较，并保留最好的。
- en: Keep at it until you have finished going through all the elements.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续这样做，直到你完成对所有元素的遍历。
- en: The way to solve this problem with more generality is to assume the existence
    of a comparator function, which takes two elements as arguments and returns the
    best of those. If you could associate a numeric value with each element, the comparator
    function could simply compare those values. In other cases, it could do whatever
    logic is needed to decide what element comes out on top.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 以更通用的方式解决这个问题的方法是假设存在一个比较函数，它接受两个元素作为参数并返回最好的那个。如果你能将每个元素与一个数值相关联，比较函数就可以简单地比较这些值。在其他情况下，它可能需要进行任何必要的逻辑判断以决定哪个元素胜出。
- en: 'Let’s try to create an appropriate HOF; our newer version will use `reduce()`
    as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个适当的高阶函数；我们的新版本将使用 `reduce()` 如下所示：
- en: '[PRE91]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This generic function takes a comparator that returns the best of two elements
    of a `T` type and then applies that function to an array of elements of a `T`
    type to produce the optimum.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用函数接受一个返回 `T` 类型两个元素中最好的比较器，然后将其应用于 `T` 类型元素的数组以产生最佳结果。
- en: 'With this, we can easily replicate the maximum- and minimum-finding functions;
    we only have to provide the appropriate reducing functions:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以轻松地复制最大值和最小值查找函数；我们只需要提供适当的归约函数：
- en: '[PRE92]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let’s go one better and compare non-numeric values. Let’s imagine a superhero
    card game: each card represents a hero and has several numeric attributes, such
    as `strength`, `powers`, and `tech`. The corresponding class could be the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，比较非数值值。让我们想象一个超级英雄卡牌游戏：每张卡片代表一个英雄，并具有多个数值属性，例如 `strength`（力量）、`powers`（能力）和
    `tech`（技术）。相应的类可能如下所示：
- en: '[PRE93]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'When two heroes fight each other, the winner is the one with more categories
    with higher values than the other. Let’s implement a comparator for this; a suitable
    `compareHeroes()` function could be as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个英雄相互战斗时，胜利者是拥有更多具有更高值的类别的一方。让我们实现一个比较器来处理这种情况；一个合适的 `compareHeroes()` 函数可能如下所示：
- en: '[PRE94]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, we can apply this to our tournament of heroes. First, let’s create our
    own league of heroes:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将此应用于我们的英雄锦标赛。首先，让我们创建我们自己的英雄联盟：
- en: '[PRE95]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'With these definitions, we can write a `findBestHero()` function to get the
    top hero:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些定义，我们可以编写一个 `findBestHero()` 函数来获取最佳英雄：
- en: '[PRE96]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Order does matter
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序很重要
- en: When you rank elements according to one-to-one comparisons, unexpected results
    may be produced. For instance, with our superheroes comparison rules, you could
    find three heroes where the results show that the first beats the second, the
    second beats the third, but the third beats the first! In mathematical terms,
    the comparison function is *not transitive*, and you don’t have a *total ordering*
    for the set.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当你根据一对一的比较对元素进行排序时，可能会产生意外结果。例如，根据我们的超级英雄比较规则，你可能会发现三个英雄，结果显示第一个打败了第二个，第二个打败了第三个，但第三个又打败了第一个！在数学术语中，比较函数是*非传递的*，并且对于该集合你没有*完全排序*。
- en: With this, we have seen several ways of modifying functions to produce newer
    variants with enhanced processing; think of particular cases you might be facing
    and consider whether an HOF might help you out.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经看到了几种修改函数以产生具有增强处理功能的新变体的方法；考虑你可能遇到的具体情况，并考虑是否高阶函数（HOF）可能对你有所帮助。
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to write HOFs of our own that can either wrap
    another function to provide some new feature, alter a function’s objective so
    that it does something else, or even provide totally new features, such as decoupling
    methods from objects or creating better finders. The main takeaway from this chapter
    is that you have a way of modifying a function’s behavior without actually having
    to modify its own code; HOFs can manage this in an orderly way.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何编写我们自己的高阶函数（HOFs），这些函数可以包装另一个函数以提供一些新功能，改变函数的目标以便它执行其他操作，甚至提供全新的功能，例如将方法从对象中解耦或创建更好的查找器。本章的主要收获是，你有一种修改函数行为的方法，而无需实际修改其代码；高阶函数可以有序地管理这一点。
- en: In [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*,
    we’ll keep working with HOFs and learn how to produce specialized versions of
    existing functions with predefined arguments by using currying and partial application.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B19301_07.xhtml#_idTextAnchor128)，*转换函数*中，我们将继续使用高阶函数（HOFs）并学习如何通过使用柯里化和部分应用来产生具有预定义参数的现有函数的专用版本。
- en: Questions
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 6.1 `addLogging()` using a function, and its typing was not simple. Just to
    deal with a different syntax, can you provide an alternate implementation of `addLogging()`
    but using an arrow function?
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 6.1 使用函数`addLogging()`，并且它的类型并不简单。只是为了处理不同的语法，你能提供一个使用箭头函数的`addLogging()`的替代实现吗？
- en: '6.2 **Mapping for memory**: We implemented our memoizing functions by using
    an object as a cache. However, using a map would be better; make the necessary
    changes.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 6.2 **映射内存**：我们通过使用对象作为缓存来实现我们的记忆化函数。然而，使用映射会更好；进行必要的更改。
- en: 6.3 `fib(50)` without memoizing? For example, one call and no further recursion
    were needed to calculate `fib(0)` or `fib(1)`, and 25 calls were required for
    `fib(6)`. Can you find a formula to do this calculation?
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 6.3 `fib(50)`不使用记忆化？例如，一个调用和不需要进一步递归来计算`fib(0)`或`fib(1)`，而`fib(6)`需要25次调用。你能找到一个公式来完成这个计算吗？
- en: 6.4 `randomizer(fn1, fn2, ...)`, that will receive a variable number of functions
    as arguments and return a new function that will, on each call, randomly call
    one of `fn1`, `fn2`, and so on. You could use this to balance calls to different
    services on a server if each function did an AJAX call. For bonus points, ensure
    that no function will be called twice in a row.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 6.4 `randomizer(fn1, fn2, ...)`，它将接收一个可变数量的函数作为参数，并返回一个新的函数，该函数将在每次调用时随机调用`fn1`、`fn2`等中的一个。你可以使用这个功能来平衡服务器上不同服务的调用，如果每个函数都执行AJAX调用。为了加分，确保没有函数会连续调用两次。
- en: 6.5 `not()` and `invert()` functions.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 6.5 `not()`和`invert()`函数。
- en: 6.6 `not()` function that worked with Boolean functions and a `negate()` function
    that worked with numerical ones. Can you go one better and write a single `opposite()`
    function that will behave as `not()` or `negate()`, as needed?
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 6.6 与布尔函数一起工作的`not()`函数以及与数值一起工作的`negate()`函数。你能更进一步，写一个单一的`opposite()`函数，该函数将根据需要表现为`not()`或`negate()`吗？
- en: 6.7 `invert()`, as suggested.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 6.7 `invert()`，如建议所示。
- en: 6.8 `filterNot()` function with a slight change, as shown here, TypeScript will
    object; why?
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 6.8 `filterNot()`函数略有变化，如所示，TypeScript会提出异议；为什么？
- en: '[PRE97]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 6.9 `arity()` function works well, but the produced functions don’t have the
    correct `length` attribute. Can you write a different arity-changing function
    without this defect?
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 6.9 `arity()`函数工作得很好，但产生的函数没有正确的`length`属性。你能写一个不同的arity-changing函数，没有这个缺陷吗？
- en: 6.10 `binary()` and `ternary()`?
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 6.10 `binary()`和`ternary()`？
- en: 6.11 `async` function, every time you call it with the same arguments, you’ll
    get the same promise as a result. But imagine we were calling a weather API, which
    updates its data every 5 minutes. We don’t want to call it just once and never
    again (as with memoization), but we don’t want to call it every time either. Can
    you add throttling behavior to our `promiseMemoize()` function so, after a given
    delay, a new call to the API will be made?
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 6.11 `async`函数，每次你用相同的参数调用它时，你都会得到相同的结果。但想象一下，我们正在调用一个每5分钟更新其数据的天气API。我们不想只调用一次就再也不调用（就像记忆化一样），但我们也不想每次都调用。你能否向我们的`promiseMemoize()`函数添加节流行为，以便在给定延迟后，将再次调用API？
- en: 6.12 `binaryOp()` function that would work with numbers, what is the list of
    all the operators you should consider?
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 6.12 一个`binaryOp()`函数，它将与数字一起工作，你应该考虑的所有操作符列表是什么？
- en: 6.13 `getField()` function, we should also have a `setField()` function, so
    can you define it? We’ll need both in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188),
    *Ensuring Purity*, when we work with getters, setters, and lenses. Note that `setField()`
    shouldn’t directly modify an object; instead, it should return a new object with
    a changed value – it should be a pure function!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 6.13 `getField()`函数，我们还应该有一个`setField()`函数，所以你能定义它吗？当我们处理获取器、设置器和透镜时，在[*第10章*](B19301_10.xhtml#_idTextAnchor188)
    *确保纯净性*时，我们需要这两个函数。请注意，`setField()`不应该直接修改一个对象；相反，它应该返回一个具有更改值的新对象——它应该是一个纯函数！
- en: 6.14 `getField()` function if we apply it to a null object? What should its
    behavior be? If necessary, modify the function. This question has different answers
    in JavaScript and TypeScript; be careful!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 6.14 如果我们将`getField()`函数应用于一个空对象，会发生什么？它的行为应该是什么？如果需要，请修改该函数。在JavaScript和TypeScript中，这个问题有不同的答案；请小心！
- en: '6.15 `demethodize()` functions. A tip: once you get one of them right, the
    other two will be pretty similar!'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 6.15 `demethodize()`函数。提示：一旦你正确地得到其中一个，其他两个将非常相似！
- en: 6.16 `findMaximum()` and `findMinimum()`, we wrote our own functions to compare
    two values – but JavaScript already provides appropriate functions for that! Can
    you figure out alternative versions of our code based on that hint?
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 6.16 `findMaximum()` 和 `findMinimum()`，我们编写了自己的函数来比较两个值——但 JavaScript 已经提供了相应的函数！你能根据这个提示想出我们代码的替代版本吗？
- en: '6.17 `const wins2 = 3 – wins1` in our `compareHeroes()` function? Wouldn’t
    that have been faster? Or even better: avoid calculating `wins2` at all, and change
    the final line to `return wins1 >=` `2`?'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 6.17 在我们的 `compareHeroes()` 函数中，`const wins2 = 3 – wins1`？这不会更快吗？或者甚至更好：根本避免计算
    `wins2`，并将最后一行改为 `return wins1 >=` `2`？
