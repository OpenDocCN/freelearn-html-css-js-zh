- en: 3\. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 函数
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: Functions are a basic building block of any application. This chapter teaches
    you how to unleash the power of TypeScript using versatile functions that have
    capabilities you may not find in other programming languages. We will talk about
    the `this` key and look at function expressions, member functions, and arrow functions.
    This chapter also discusses function arguments, including rest and default parameters.
    We will also look at the `import` and `export` keywords.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是任何应用程序的基本构建块。本章将教你如何利用 TypeScript 的多功能函数释放其力量，这些功能可能在其他编程语言中找不到。我们将讨论 `this`
    关键字，并查看函数表达式、成员函数和箭头函数。本章还讨论了函数参数，包括剩余参数和默认参数。我们还将查看 `import` 和 `export` 关键字。
- en: This chapter also teaches you how to write tests that pass different combinations
    of arguments and compare the expected output with the actual output. We will close
    the chapter by designing a prototype application and completing it with unit tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将教你如何编写通过不同参数组合的测试用例，并将预期的输出与实际输出进行比较。我们将通过设计一个原型应用程序并完成单元测试来结束本章。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we've learned some of the basics of TypeScript, how to set up a project,
    and the use of definition files. Now we will delve into the topic of functions,
    which are going to be the most important tools in your arsenal. Even object-oriented
    programming paradigms depend heavily on functions as a basic building block of
    business logic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了 TypeScript 的一些基础知识，如何设置项目以及定义文件的使用。现在我们将深入探讨函数的主题，这些函数将成为你工具箱中最重要的工具。甚至面向对象编程范式也严重依赖于函数作为业务逻辑的基本构建块。
- en: Functions, sometimes called routines or methods, are part of every high-level
    programming language. The ability to reuse segments of code is critical, but functions
    provide an even more important role than that in that they can be given different
    arguments, or variables, to act against and produce different results. Writing
    good functions is the difference between a good program and a great one. You first
    need to start by learning the syntax before thinking about crafting a good function
    by considering what arguments it should take and what it should produce.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，有时也称为例程或方法，是每种高级编程语言的一部分。重用代码段的能力至关重要，但函数提供的作用比这更为重要，因为它们可以接受不同的参数或变量来执行并产生不同的结果。编写好的函数是优秀程序与卓越程序之间的区别。你首先需要从学习语法开始，然后再考虑通过考虑它应该接受什么参数以及它应该产生什么来编写一个好的函数。
- en: In this chapter, we will cover three different ways to create functions. We
    will describe the pitfalls and the proper use of the `this` keyword. We will look
    at powerful programming techniques, including currying, functional programming,
    and the use of closures. We will explore the TypeScript module system and how
    to share code between modules by means of the `import` and `export` keywords.
    We'll see how functions can be organized into classes and how to refactor JavaScript
    code into TypeScript. Then we will learn how to use the popular Jest testing framework.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍创建函数的三种不同方法。我们将描述使用 `this` 关键字的陷阱和正确用法。我们将探讨强大的编程技术，包括柯里化、函数式编程和闭包的使用。我们将探讨
    TypeScript 模块系统以及如何通过 `import` 和 `export` 关键字在模块之间共享代码。我们将看到函数如何组织到类中，以及如何将 JavaScript
    代码重构为 TypeScript。然后我们将学习如何使用流行的 Jest 测试框架。
- en: Putting these skills to use, we will design, build, and test a prototype flight
    booking system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些技能付诸实践，我们将设计、构建和测试一个原型航班预订系统。
- en: Functions in TypeScript
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 中的函数
- en: A simple definition of function is a set of statements that can be invoked;
    however, the use and conventions of functions cannot be summarized so easily.
    Functions in TypeScript have greater utility than in some other languages. In
    addition to being invoked as normal, functions can also be given as arguments
    to other functions and can be returned from functions. Functions are actually
    a special kind of object that can be invoked. This means that in addition to parameters,
    functions can actually have properties and methods of their own, though this is
    rarely done.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的简单定义是一组可以被调用的语句；然而，函数的使用和约定并不能如此简单地总结。TypeScript 中的函数比某些其他语言具有更大的实用性。除了正常调用外，函数还可以作为其他函数的参数，并可以从函数中返回。实际上，函数是一种可以调用的特殊对象。这意味着除了参数外，函数实际上还可以有自己的属性和方法，尽管这很少发生。
- en: Only the smallest of programs will ever avoid making heavy use of functions.
    Most programs will be made up of many `.ts` files. Those files will typically
    export functions, classes, or objects. Other parts of the program will interact
    with the exported code, typically by calling functions. Functions create patterns
    for reusing your application logic and allow you to write **DRY** (**don't repeat
    yourself**) code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 只有极小的程序才会避免大量使用函数。大多数程序将由许多`.ts`文件组成。这些文件通常导出函数、类或对象。程序的其它部分将通过调用函数与导出的代码进行交互。函数创建了你应用程序逻辑的重用模式，并允许你编写**DRY**（**不要重复自己**）的代码。
- en: Before diving into functions, let's perform an exercise to get a glimpse of
    how functions in general are useful. Don't worry if you do not understand some
    of the function-related syntax in the exercise. You will be studying all of this
    later in the chapter. The purpose of the following exercise is only to help you
    understand the importance of functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究函数之前，让我们进行一个练习，以了解函数在一般情况下是如何有用的。如果你不理解练习中的一些与函数相关的语法，请不要担心。你将在本章的后面学习所有这些内容。以下练习的目的是帮助你理解函数的重要性。
- en: 'Exercise 3.01: Getting Started with Functions in TypeScript'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.01：在 TypeScript 中开始使用函数
- en: To give an example of the usefulness of functions, you will create a program
    that calculates an average. This exercise will first create a program that does
    not make use of any functions. Then, the same task of calculating the average
    will be performed using functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明函数的有用性，你将创建一个计算平均值的程序。这个练习首先创建一个不使用任何函数的程序。然后，将使用函数执行相同的计算平均值任务。
- en: 'Let''s get started:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code file for this exercise can be found at https://packt.link/ZHrsh.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在 https://packt.link/ZHrsh 找到。
- en: 'Open VS Code and create a new file called `Exericse01.ts`. Write the following
    code that makes no use of functions other than the `console.log` statement:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VS Code 并创建一个名为 `Exericse01.ts` 的新文件。编写以下不使用除`console.log`语句以外的任何函数的代码：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the file by executing `npx ts-node Exercise 01.ts` on the terminal. You
    will get the following output:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中执行`npx ts-node Exercise 01.ts`来运行文件。你会得到以下输出：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, rewrite the same code using built-in functions and a function of our own, `calcAverage`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用内置函数和我们的自定义函数`calcAverage`重写相同的代码：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the file and observe the output:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行文件并观察输出：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output is the same, but this code is more concise and more expressive. We
    have written our own function, but we also make use of the built-in `array.reduce`
    function. Understanding how functions work will both enable us to write our own
    useful functions and make use of powerful built-in functions.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出相同，但这段代码更简洁、更易于理解。我们编写了自己的函数，同时也使用了内置的`array.reduce`函数。理解函数的工作原理将使我们能够编写自己的有用函数，并利用强大的内置函数。
- en: 'Let''s continue to build upon this exercise. Instead of just getting the average,
    consider a program to calculate a standard deviation. This can be written as procedural
    code without functions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在此基础上进行练习。除了获取平均值之外，考虑一个计算标准差的程序。这可以写成没有函数的过程化代码：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will get the following output once you run the file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 运行文件后，你会得到以下输出：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While we have the correct output, this code is very inefficient as the details
    of implementation (summing an array in a loop, then dividing by its length) are
    repeated. Additionally, since functions aren''t used, the code would be difficult
    to debug as individual parts of the program can''t be run in isolation. If we
    have an incorrect result, the entire program must be run repeatedly with minor
    corrections until we are sure of the correct output. This will not scale to programs
    that contain thousands or millions of lines of code, as many major web applications
    do. Now consider the following program:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们得到了正确的结果，但这段代码非常低效，因为实现细节（在循环中求和数组，然后除以它的长度）被重复了。此外，由于没有使用函数，代码调试起来会很困难，因为程序的不同部分不能单独运行。如果我们得到一个错误的结果，整个程序必须反复运行，进行微小的修正，直到我们确信得到正确的结果。这对于包含数千或数百万行代码的程序来说是不适用的，因为许多主要的网络应用程序就是这样。现在考虑以下程序：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, the output is correct and we've reused `calcAverage` twice in this program,
    proving the value of writing that function. Even if all the functions and syntax
    don't make sense yet, most programmers will agree that more concise and expressive
    code is preferable to large blocks of code that offer no patterns of reuse.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，输出是正确的，并且在这个程序中我们两次重用了`calcAverage`函数，证明了编写该函数的价值。即使所有函数和语法现在还不明白，大多数程序员都会同意更简洁、更具表达力的代码比没有重用模式的代码块更可取。
- en: The function Keyword
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字函数
- en: 'The simplest way to create a function is with a function statement using the
    `function` keyword. The keyword precedes the function name, after which a parameter
    list is given, and the function body is enclosed with braces. The parameter list
    for a function is always wrapped in parentheses, even if there are no parameters.
    The parentheses are always required in TypeScript, unlike some other languages,
    such as Ruby:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数的最简单方法是使用`function`关键字的功能声明。关键字位于函数名之前，之后是一个参数列表，函数体用大括号括起来。函数的参数列表始终用括号括起来，即使没有参数也是如此。在TypeScript中，括号始终是必需的，与一些其他语言（如Ruby）不同：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A function that completes successfully will always return either one or zero
    values. If nothing is returned, the `void` identifier can be used to show nothing
    was returned. A function cannot return more than one value, but many developers
    get around this limitation by returning an array or object that itself contains
    multiple values that can be recast into individual variables. Functions can return
    any of the built-in types in TypeScript or types that we write. Functions can
    also return complex or inline types (described in later chapters). If the type
    a function might return can''t easily be inferred by the body of the function
    and a `return` statement, it is a good idea to add a return type to the function.
    That looks like this. The return type of `void` indicates that this function doesn''t
    return anything:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功完成的函数总是会返回一个或零个值。如果没有返回任何内容，可以使用`void`标识符来表示没有返回任何内容。一个函数不能返回超过一个值，但许多开发者通过返回一个包含多个值的数组或对象来绕过这个限制，这些值可以被重新分配到单独的变量中。函数可以返回TypeScript中的任何内置类型或我们编写的类型。函数还可以返回复杂或内联类型（在后面的章节中描述）。如果一个函数可能返回的类型不能通过函数体和`return`语句轻松推断，那么给函数添加一个返回类型是一个好主意。它看起来像这样。`void`的返回类型表示这个函数不返回任何内容：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Function Parameters
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'A parameter is a placeholder for a value that is passed into the function.
    Any number of parameters can be specified for a function. As we are writing TypeScript,
    parameters should have their types annotated. Let''s change our function so that
    it requires a parameter and returns something:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是传递给函数的值的占位符。可以为函数指定任意数量的参数。由于我们正在编写TypeScript，参数应该有它们的类型注解。让我们改变我们的函数，使其需要一个参数并返回一些内容：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In contrast to the previous example, this function expects a single parameter
    identified by `name`, the type of which has been defined as `string` – `(name:
    string)`. The function body has changed and now uses a string template to return
    our greeting message as a template string. We could invoke the function like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '与前面的例子相比，这个函数期望一个名为`name`的单个参数，其类型已被定义为`string` - `(name: string)`。函数体已更改，现在使用字符串模板将问候消息作为模板字符串返回。我们可以这样调用函数：'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will get the following output once you run the file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行文件后，你会得到以下输出：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code invokes `myFunction` with an argument of `'world'` and assigns the
    result of the function call to a new constant, `message`. The `console` object
    is a built-in object that exposes a `log` function (sometimes called a method
    as an object member) that will print the given string to the console. Since `myFunction`
    concatenates the given parameter to a template string, `Hello world!` is printed
    to the console.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用参数`'world'`调用`myFunction`，并将函数调用的结果赋值给一个新的常量`message`。`console`对象是一个内置对象，它公开了一个`log`函数（有时称为对象成员的方法）将给定的字符串打印到控制台。由于`myFunction`将给定的参数连接到一个模板字符串，因此`Hello
    world!`被打印到控制台。
- en: 'Of course, it isn''t necessary to store the function result in a constant before
    logging it out. We could simply write the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在将函数结果记录之前，没有必要将其存储在常量中。我们可以简单地写下以下代码：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code will invoke the function and log its result to the console, as shown
    in the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将调用函数并将结果记录到控制台，如下面的输出所示：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Many of the examples in this chapter will take this form because this is a very
    simple way to validate the output of a function. More sophisticated applications
    use unit tests and more robust logging solutions to validate functions, and so
    the reader is cautioned against filling applications with `console.log` statements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多示例都将采用这种形式，因为这是一种验证函数输出的简单方法。更复杂的应用程序使用单元测试和更健壮的日志解决方案来验证函数，因此读者应小心不要在应用程序中填充
    `console.log` 语句。
- en: Argument versus Parameter
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数与参数
- en: Many developers use the terms argument and parameter interchangeably; however,
    the term argument refers to a value passed to a function, while parameter refers
    to the placeholder in the function. In the case of `myFunction('world');`, the
    `'world'` string is an argument and not a parameter. The `name` placeholder with
    an assigned type in the function declaration is a parameter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者将参数和参数互换使用；然而，参数一词指的是传递给函数的值，而参数指的是函数中的占位符。在 `myFunction('world');` 的例子中，`'world'`
    字符串是一个参数，而不是参数。函数声明中具有指定类型的 `name` 占位符是一个参数。
- en: Optional Parameters
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'One important difference from JavaScript is that TypeScript function parameters
    are only optional if we postfix them with `?`. The function in the previous example,
    `myFunction`, expects an argument. Consider the case where we don''t specify any arguments:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 相比，TypeScript 函数参数只有在后缀加上 `?` 时才是可选的。前一个示例中的函数 `myFunction` 期望一个参数。考虑以下情况，我们未指定任何参数：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code will give us a compilation error: `Expected 1 arguments, but got
    0`. That means the code won''t even compile, much less run. Likewise, consider
    the following snippet, where we provide an argument of the wrong type:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将导致编译错误：`期望 1 个参数，但得到 0`。这意味着代码甚至无法编译，更不用说运行了。同样，考虑以下代码片段，其中我们提供了一个错误类型的参数：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, the error message reads: `Argument of type ''5'' is not assignable to
    parameter of type ''string''`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的错误信息显示：`类型 '5' 无法分配给类型 'string' 的参数`。
- en: It's interesting that this error message has given the narrowest possible type
    for the value we tried to pass. Instead of saying `argument of type 'number'`,
    the compiler sees the type as simply the number `5`. This gives us a hint that
    types can be far narrower than the primitive `number` type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息给出了我们尝试传递的值的可能最窄的类型。而不是说 `参数类型为 'number'`，编译器将类型视为简单的数字 `5`。这给我们一个提示，即类型可以比原始的
    `number` 类型窄得多。
- en: 'TypeScript automatically prevents us from making mistakes such as this by enforcing
    types. But what if we actually do want to make the parameter optional? One option
    is, as previously mentioned, to postfix the parameter with `?`, as shown in the
    following code snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 通过强制类型来防止我们犯这样的错误。但如果我们确实想使参数可选怎么办？一个选项是，如前所述，在参数后缀加上 `?`，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can successfully invoke it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以成功调用它：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running this command will display the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将显示以下输出：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In TypeScript, any variable that has yet to be assigned will have the value
    of `undefined`. When the function is executed, the `undefined` value gets converted
    to the `undefined` string at runtime, and so `Hello undefined!` is printed to
    the console.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，任何尚未分配的变量都将具有 `undefined` 的值。当函数执行时，`undefined` 值在运行时被转换为 `undefined`
    字符串，因此 `Hello undefined!` 被打印到控制台。
- en: Default Parameters
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'In the preceding example, the `name` parameter has been made optional and since
    it never got a value, we printed out `Hello undefined!`. A better way to do this
    would be to give `name` a default value, as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`name` 参数已被设置为可选，并且由于它从未获得过值，所以我们打印了 `Hello undefined!`。更好的方法是给 `name`
    赋予一个默认值，如下所示：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, the function will give us the default value if we don''t provide one:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们不提供参数，函数将给出默认值：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And it will give us the value we passed if we do provide one using the following
    code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下代码提供参数，它将给出我们传递的值：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will then display the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This was pretty straightforward. Now, let's try working with multiple arguments.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。现在，让我们尝试处理多个参数。
- en: Multiple Arguments
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个参数
- en: Functions can have any number or type of arguments. The argument list is separated
    by commas. Although your compiler settings can allow you to omit argument types,
    it is a best practice to enable the `noImplicitAny` option. This will raise a
    compiler error if you accidentally omit a type. Additionally, the use of the broad
    `any` type is discouraged whenever possible, as was covered in *Chapter 1*, *TypeScript
    Fundamentals and Overview of Types*. *Chapter 6*, *Advanced Types*, will give
    us a deeper dive into advanced types, in particular, intersection and union types,
    that will help us to ensure that all of our variables have good, descriptive types.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有任意数量或类型的参数。参数列表由逗号分隔。尽管您的编译器设置可以允许您省略参数类型，但启用`noImplicitAny`选项是一种最佳实践。这将导致编译器错误，如果您意外省略了类型。此外，尽可能避免使用广泛的`any`类型，正如在*第一章*，*TypeScript基础知识与类型概述*中所述。*第六章*，*高级类型*将更深入地探讨高级类型，特别是交集和联合类型，这将帮助我们确保所有变量都有良好、描述性的类型。
- en: Rest Parameters
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剩余参数
- en: 'The spread operator (`…`) may be used as the final parameter to a function.
    This will take all arguments passed into the function and place them in an array.
    Let''s look at an example of how this works:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符（`…`）可以用作函数的最后一个参数。这将接受传递给函数的所有参数并将它们放入一个数组中。让我们看看这个是如何工作的：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, the function can be called with a variable argument list:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数可以用可变参数列表来调用：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first argument is required. The rest will be optional. We could just decline
    to specify any chapters to read. However, if we do give additional arguments,
    they must be of the `number` type because that's what we've used as the type (`number[]`)
    for our rest parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是必需的。其余的是可选的。我们完全可以不指定任何章节来阅读。然而，如果我们提供了额外的参数，它们必须是`number`类型，因为这是我们用作类型（`number[]`）的剩余参数的类型。
- en: 'You will obtain the following output once you run the preceding code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，您将获得以下输出：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that this syntax specifically requires single arguments of the `number`
    type. It would be possible to implement the function without a rest parameter
    and instead expect an array as a single argument:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个语法特别要求单个参数为`number`类型。我们可以不使用剩余参数来实现该函数，而是期望一个数组作为单个参数：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The function will now require precisely two arguments:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数现在将精确需要两个参数：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Which is better? That's something you'll need to decide for yourself. In this
    case, the chapters we want to read are already in array form, and then it probably
    makes the most sense to pass that array to the function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个更好？这需要你自己决定。在这种情况下，我们想要阅读的章节已经以数组形式存在，然后将其传递给函数可能最有意义。
- en: Notice that the `readBook` function includes an arrow function inside it. We'll
    cover arrow functions in an upcoming section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`readBook`函数中包含一个箭头函数。我们将在下一节中介绍箭头函数。
- en: Destructuring Return Types
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构返回类型
- en: At times, it may be useful for a function to return more than one value. Programmers
    who have embraced functional programming paradigms often want a function that
    will return a tuple, or an array of two elements that have different types. Going
    back to our previous example, if we wanted to calculate both the average and standard
    deviation for a number array, it might be convenient to have a single function
    that handles both operations, rather than having to make multiple function calls
    with the same number array.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个函数返回多个值可能是有用的。采用函数式编程范式的程序员通常希望有一个返回元组或包含不同类型两个元素的数组函数。回到我们之前的例子，如果我们想计算数字数组的平均值和标准差，可能有一个同时处理这两个操作的单一函数会更方便，而不是需要多次调用同一个数字数组。
- en: 'A function in TypeScript will only return one value. However, we can simulate
    returning multiple arguments using destructuring. Destructuring is the practice
    of assigning parts of an object or array to different variables. This allows us
    to assign parts of a returning value to variables, giving the impression we are
    returning multiple values. Let''s look at an example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript中的函数只能返回一个值。然而，我们可以通过解构来模拟返回多个参数。解构是将对象或数组的一部分分配给不同变量的实践。这允许我们将返回值的各个部分分配给变量，给人一种返回多个值的感觉。让我们看一个例子：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code uses the `filter` method of the built-in array object to iterate
    through each value in an array and test it. If the test returns a `true` Boolean,
    the value is pushed into a new array, which is returned. Using the modulus operator
    to test the remainder will filter our number array into two separate arrays. The
    function then returns those arrays as properties of an object. We can take advantage
    of this destructuring. Consider the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用内置数组对象的 `filter` 方法遍历数组中的每个值并对其进行测试。如果测试返回 `true` 布尔值，则该值将被推入一个新数组，该数组将被返回。使用模运算符来测试余数将我们的数字数组过滤成两个单独的数组。然后函数将返回这些数组作为对象属性。我们可以利用这一点进行解构。考虑以下代码：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, we give the function the arguments `1, 2, 3, 4`, and it returns the following output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们给函数传递参数 `1, 2, 3, 4`，它返回以下输出：
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The Function Constructor
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数构造函数
- en: Note that the TypeScript language contains an uppercase `Function` keyword.
    This is not the same as the lowercase `function` keyword and should not be used
    as it is not considered to be secure due to its ability to parse and execute arbitrary
    code strings. The `Function` keyword only exists in TypeScript because TypeScript
    is a superset of JavaScript.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，TypeScript 语言包含一个大写的 `Function` 关键字。这不同于小写的 `function` 关键字，不应使用，因为它被认为不安全，因为它能够解析和执行任意代码字符串。`Function`
    关键字仅在 TypeScript 中存在，因为 TypeScript 是 JavaScript 的超集。
- en: 'Exercise 3.02: Comparing Number Arrays'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.02：比较数字数组
- en: TypeScript comparison operators such as `===` or `>` only work on primitive
    types. If we want to compare more complex types, such as arrays, we need to either
    use a library or implement our own comparison. Let's write a function that can
    compare a pair of unsorted number arrays and tell us whether the values are equal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 比较运算符如 `===` 或 `>` 仅适用于原始类型。如果我们想比较更复杂的数据类型，如数组，我们需要使用库或实现自己的比较。让我们编写一个函数，可以比较一对未排序的数字数组，并告诉我们值是否相等。
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code file for this exercise can be found at [https://packt.link/A0IxN](https://packt.link/A0IxN).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可在 [https://packt.link/A0IxN](https://packt.link/A0IxN) 找到。
- en: Create a new file in VS Code and name it `array-equal.ts`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中创建一个新文件，并将其命名为 `array-equal.ts`。
- en: 'Start with this code, which declares three different arrays and outputs, irrespective
    of whether or not they are equal:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下代码开始，该代码声明了三个不同的数组并输出，无论它们是否相等：
- en: '[PRE34]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output will be true for all three comparisons because the function has not
    been implemented and just returns `true`.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于函数尚未实现，它仅返回 `true`，因此所有三个比较的输出都将为 true。
- en: Our function, `arrayCompare`, takes two arrays as arguments and returns a Boolean
    value to represent whether or not they are equal. Our business rule is that arrays
    can be unsorted and will be considered equal if all their values match when sorted.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的功能 `arrayCompare` 接受两个数组作为参数，并返回一个布尔值，表示它们是否相等。我们的业务规则是，如果所有值在排序后匹配，则未排序的数组将被视为相等。
- en: 'Update `arrayCompare` with the following code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `arrayCompare`：
- en: '[PRE35]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we are testing to see whether the two arrays passed in
    are equal. The first check we should make is to test whether the arrays have equal
    length. If they aren't equal in length, then the values can't possibly be equal,
    so we'll return `false` from the function. If we hit a return statement during
    execution, the rest of the function won't be executed.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在测试传入的两个数组是否相等。我们首先应该检查数组长度是否相等。如果它们长度不相等，那么值就不可能相等，因此我们将从函数中返回 `false`。如果在执行过程中遇到返回语句，则函数的其余部分将不会执行。
- en: At this point, the function will only tell us whether the arrays are equal in
    length. To complete the challenge, we'll need to compare each value in the arrays.
    This task will be considerably easier if we sort the values before trying to compare
    them. Fortunately, the array object prototype includes a `sort()` method, which
    will handle this for us. Using built-in functions can save a lot of development hours.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一点上，该函数将只能告诉我们数组是否长度相等。为了完成挑战，我们需要比较数组中的每个值。在尝试比较之前对值进行排序将使这项任务容易得多。幸运的是，数组对象原型包括一个
    `sort()` 方法，这将为我们处理这一切。使用内置函数可以节省大量开发时间。
- en: 'Implement the `sort()` method to sort array values:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现排序 `sort()` 方法以排序数组值：
- en: '[PRE36]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `sort()` method sorts the array elements in place, so it isn't necessary
    to assign the result to a new variable.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sort()` 方法就地排序数组元素，因此没有必要将结果分配给新变量。'
- en: Finally, we need to loop over one of the arrays to compare each element at the
    same index. We use a `for` loop to iterate through the first array and compare
    the value at each index to the value at the same index in the second array. Since
    our arrays use primitive values, the `!==` comparison operator will work.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们需要遍历其中一个数组，比较相同索引处的每个元素。我们使用 `for` 循环遍历第一个数组，并将每个索引处的值与第二个数组中相同索引处的值进行比较。由于我们的数组使用原始值，`!==`
    比较运算符将起作用。
- en: 'Use the following `for` loop to loop over the arrays:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 `for` 循环遍历数组：
- en: '[PRE37]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Again, we'll return `false` and exit the function if any of the comparisons
    fail.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，如果任何比较失败，我们将返回 `false` 并退出函数。
- en: 'Execute the program using `ts-node`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ts-node` 执行程序：
- en: '[PRE38]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The program will produce the following output:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序将产生以下输出：
- en: '[PRE39]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Experiment with different array combinations and validate the program is working
    correctly.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不同的数组组合，并验证程序是否正确运行。
- en: A good function takes an argument list and returns a single value. You now have
    experience writing a function as well as utilizing built-in functions to solve
    problems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的函数接受一个参数列表并返回一个单一值。你现在既有编写函数的经验，也有利用内置函数解决问题的经验。
- en: Function Expressions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数表达式
- en: 'Function expressions differ from function declarations in that they can be
    assigned to variables, used inline, or invoked immediately – an immediately invoked
    function expression or IIFE. Function expressions can be named or anonymous. Let''s
    look at a few examples:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式与函数声明不同之处在于它们可以被分配给变量、内联使用或立即调用——立即调用的函数表达式或IIFE。函数表达式可以是命名的或匿名的。让我们看看几个例子：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You will get the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This looks quite a lot like a previous example we looked at, and it works almost
    exactly the same. Here is the function declaration for comparison:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与之前我们看过的例子非常相似，并且几乎以相同的方式工作。以下是用于比较的函数声明：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The one slight difference is that function declarations are *hoisted*, meaning
    they are loaded into memory (along with any declared variables) and, as such,
    can be used before they are declared in code. It is generally considered bad practice
    to rely on hoisting and, as such, it is now allowed by many linters. Programs
    that make heavy use of hoisting can have bugs that are difficult to track down
    and may even exhibit different behaviors in different systems. One of the reasons
    why function expressions have become popular is because they don't allow hoisting
    and therefore avoid these issues.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的一点不同是函数声明是 *提升的*，这意味着它们被加载到内存中（连同任何声明的变量一起），因此可以在代码中声明之前使用。通常认为依赖提升是一种不好的做法，因此现在许多代码检查工具不允许这样做。过度使用提升的程序可能存在难以追踪的bug，甚至可能在不同的系统中表现出不同的行为。函数表达式之所以受欢迎，其中一个原因就是它们不允许提升，因此避免了这些问题。
- en: 'Function expressions can be used to create anonymous functions, that is, functions
    that do not have names. This is impossible with function declarations. Anonymous
    functions are often used as callbacks to native functions. For example, consider
    the following code snippet with the `Array.filter` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式可以用来创建匿名函数，即没有名字的函数。这与函数声明不同。匿名函数通常用作原生函数的回调。例如，考虑以下使用 `Array.filter` 函数的代码片段：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Remember that in TypeScript (as well as JavaScript), functions are can be given
    as arguments to, or returned from, other functions. This means that we can give
    the anonymous function, `function(val) { return val < 3 }`, as an argument to
    the `Array.filter` function. This function is not named and cannot be referred
    to or invoked by other code. That''s fine for most purposes. If we wanted to,
    we could give it a name:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 TypeScript（以及 JavaScript）中，函数可以作为参数传递给其他函数，或者从其他函数返回。这意味着我们可以将匿名函数 `function(val)
    { return val < 3 }` 作为 `Array.filter` 函数的参数。这个函数没有名字，不能被其他代码引用或调用。这在大多数情况下是可以的。如果我们想，我们可以给它起一个名字：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There's little point in doing this in most cases, but it might be useful if
    the function needed to be self-referential, for example, a recursive function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这样做没有太大意义，但如果函数需要自引用，例如递归函数，这可能会很有用。
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about callbacks, refer to *Chapter 11*, *Higher-Order Functions
    and Callbacks in TypeScript*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于回调的信息，请参阅 *第11章*，*TypeScript中的高阶函数和回调*。
- en: 'Immediately invoked function expressions look like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 立即调用的函数表达式看起来像这样：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The function outputs the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 函数输出以下内容：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The function is declared inline and then the additional `()` parentheses at
    the end invoke the function. The primary use case for an IIFE in TypeScript involves
    another concept known as closure, which will be discussed later in this chapter.
    For now, just learn to recognize this syntax where a function is declared and
    invoked right away.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是内联声明的，然后末尾的额外`()`括号调用函数。TypeScript中IIFE的主要用例涉及另一个称为闭包的概念，这将在本章后面讨论。现在，只需学会识别这种立即声明和调用的函数语法即可。
- en: Arrow Functions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Arrow functions present a more compact syntax and also offer an alternative
    to the confusing and inconsistent rules surrounding the `this` keyword. Let's
    look at the syntax first.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数提供了一种更紧凑的语法，同时也为围绕`this`关键字令人困惑且不一致的规则提供了一个替代方案。让我们首先看看语法。
- en: 'An arrow function removes the `function` keyword and puts a "fat arrow" or
    `=>` between the parameter list and the function body. Arrow functions are never
    named. Let''s rewrite the function that logs `Hello`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数移除了`function`关键字，并在参数列表和函数体之间放置了一个“胖箭头”或`=>`。箭头函数从不命名。让我们重写一个打印`Hello`的函数：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This function can be made even more compact. If the function simply returns
    a value, the braces and the `return` keyword can both be omitted. Our function
    now looks like this.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以变得更加紧凑。如果函数只是返回一个值，则可以省略大括号和`return`关键字。我们的函数现在看起来是这样的。
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Arrow functions are very frequently used in callback functions. The callback
    to the preceding filter function can be rewritten using an arrow function. Again,
    callbacks will be discussed in more detail in *Chapter 11*, *Higher-Order Functions
    and Callbacks in TypeScript*. Here is another example of an arrow function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数在回调函数中非常常用。前一个过滤器函数的回调可以使用箭头函数重写。再次强调，回调将在第11章“TypeScript中的高阶函数和回调”中更详细地讨论。下面是箭头函数的另一个示例：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This concise syntax may look confusing at first, so let's break it down. The
    `filter` function is a built-in method of the array object in TypeScript. It will
    return a new array containing all the items in the array that match the criteria
    in the callback function. So, we are saying for each `val`, add it to the new
    array if `val` is less than `3`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简洁的语法一开始可能看起来有些令人困惑，所以让我们来分解一下。`filter`函数是TypeScript中数组对象的一个内置方法。它将返回一个新数组，包含所有在回调函数中符合标准的数组项。因此，我们说对于每个`val`，如果`val`小于`3`，就将其添加到新数组中。
- en: Arrow functions are more than just a different syntax. While function declarations
    and function expressions create a new execution scope, arrow functions do not.
    This has implications when it comes to using the `this` (see below) and `new`
    (see *Chapter 4*, *Classes and Objects*) keywords.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数不仅仅是语法上的不同。虽然函数声明和函数表达式创建一个新的执行作用域，但箭头函数不会。这在使用`this`（见下文）和`new`（见第4章，“类和对象”）关键字时具有影响。
- en: Type Inference
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'Let''s consider the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Notice that in the preceding code, we aren''t specifying a type for the `numbers`
    constant. But wait, isn''t this a book on TypeScript? Yes, and now we come to
    one of the best features of TypeScript: type inference. TypeScript has the ability
    to assign types to variables when we omit them. When we declare `const numbers
    = [1, 2, 3];`, TypeScript will intuitively understand that we are declaring an
    array of numbers. If we wanted to, we could write `const numbers: number[] = [1,
    2, 3];`, but TypeScript will see these declarations as equal.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，在上述代码中，我们没有为`numbers`常量指定类型。但是等等，这不是一本关于TypeScript的书吗？是的，现在我们来到了TypeScript的一个最佳特性：类型推断。TypeScript有在省略类型的情况下为变量分配类型的能力。当我们声明`const
    numbers = [1, 2, 3];`时，TypeScript会直观地理解我们正在声明一个数字数组。如果我们想的话，我们可以写`const numbers:
    number[] = [1, 2, 3];`，但TypeScript会认为这些声明是相等的。'
- en: The preceding code is 100% valid ES6 JavaScript. This is great because any JavaScript
    developer will be able to read and understand it, even if they have no experience
    with TypeScript. However, unlike JavaScript, TypeScript will prevent you from
    making an error by putting the wrong type of value into the `numbers` array.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是100%有效的ES6 JavaScript。这很好，因为任何JavaScript开发者都能阅读和理解它，即使他们没有TypeScript的经验。然而，与JavaScript不同，TypeScript会通过将错误类型的值放入`numbers`数组来防止你出错。
- en: 'Because TypeScript has inferred the type of our `numbers` array, we would not
    be able to add a value other than a number to it; for example, `numbers.push(''hello'');`
    will result in a compiler error. If we wanted to declare an array that would allow
    other types, we''d need to declare that explicitly – `const numbers: (number |
    string)[] = [1, 3, 2];`. Now, we can later assign a string to this array. Alternatively,
    an array declared as `const numbers = [1, 2, 3, ''abc''];` would already be of
    this type.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '因为TypeScript推断出了我们的`numbers`数组类型，所以我们无法向其中添加除了数字以外的值；例如，`numbers.push(''hello'');`将导致编译器错误。如果我们想声明一个允许其他类型的数组，我们需要明确声明这一点——`const
    numbers: (number | string)[] = [1, 3, 2];`。现在，我们可以稍后向这个数组赋值一个字符串。或者，声明为`const
    numbers = [1, 2, 3, ''abc''];`的数组已经具有这种类型。'
- en: Going back to our `filter` function, this function is also not specifying any
    type for the parameter or the return type. Why is this allowed? It's our friend,
    type inference, again. Because we're iterating over an array of numbers, each
    item in that array must be a number. Therefore, `val` will always be a number
    and the type need not be specified. Likewise, the expression `val < 3` is a Boolean
    expression, so the return type will always be a Boolean. Remember that optional
    means you can always opt to provide a required type and you definitely should
    if that improves the clarity or readability of your code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`filter`函数，这个函数也没有指定参数或返回类型。为什么允许这样做？又是我们的朋友，类型推断。因为我们正在遍历一个数字数组，该数组中的每个项目都必须是数字。因此，`val`将始终是数字，无需指定类型。同样，表达式`val
    < 3`是一个布尔表达式，所以返回类型将始终是布尔类型。记住，可选意味着你总是可以选择提供所需类型，如果你认为这可以提高代码的清晰度或可读性，那么你绝对应该这样做。
- en: 'When an arrow function has a single parameter and the type can be inferred,
    we can make our code slightly more concise by omitting the parentheses around
    the parameter list. Finally, our `filter` function may look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个箭头函数只有一个参数且类型可以推断时，我们可以通过省略参数列表周围的括号来使我们的代码稍微简洁一些。最后，我们的`filter`函数可能看起来像这样：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE55]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The syntax you choose is really a matter of taste, but many experienced programmers
    gravitate to the more concise syntax, so it's important to at least be able to
    read and understand it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的语法完全是个人品味的问题，但许多经验丰富的程序员倾向于更简洁的语法，因此至少能够阅读和理解它。
- en: 'Exercise 3.03: Writing Arrow Functions'
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.03：编写箭头函数
- en: Now, let's write some arrow functions and get used to that syntax, as well as
    start to build our utility library. A good candidate for a utility library is
    a function that might be called. In this exercise, we'll write a function that
    takes a subject, verb, and list of objects and returns a grammatically correct
    sentence.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些箭头函数，熟悉这种语法，并开始构建我们的实用库。实用库的一个好候选函数是可能被调用的函数。在这个练习中，我们将编写一个函数，它接受一个主语、谓语和对象列表，并返回一个语法正确的句子。
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code file for this exercise can be found at [https://packt.link/yIQnz](https://packt.link/yIQnz).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在[https://packt.link/yIQnz](https://packt.link/yIQnz)找到。
- en: Create a new file in VS Code and save it as `arrow-cat.ts`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中创建一个新文件，并将其保存为`arrow-cat.ts`。
- en: 'Start with a pattern for the function we need to implement, along with some
    calls to it:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们需要实现的函数的模式开始，以及一些对其的调用：
- en: '[PRE56]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Our `sentence` function obviously isn't doing what we need it to do. We can
    modify the implementation to use a template string to output the subject, verb,
    and objects.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`sentence`函数显然没有做我们需要的。我们可以修改实现以使用模板字符串来输出主语、谓语和宾语。
- en: 'Use the following code to implement a template string to output the subject,
    verb, and objects:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现一个模板字符串来输出主语、谓语和宾语：
- en: '[PRE57]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, when we execute our program, we get the following output:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当我们执行我们的程序时，我们得到以下输出：
- en: '[PRE58]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is readable, but we have a number of issues with capitalization and word
    spacing. We can add some additional functions to help with these problems. Thinking
    through what should logically happen for these cases, if there are multiple objects,
    we'd like commas between them and to use "and" before the final object. If there's
    a single object, there shouldn't be commas or "and," and if there's no object,
    there shouldn't be an empty space, as there is here.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这看起来是可读的，但我们有关于大小写和单词间距的几个问题。我们可以添加一些额外的函数来帮助解决这些问题。思考这些情况应该逻辑上发生什么，如果有多个对象，我们希望在它们之间添加逗号，并在最后一个对象之前使用“and”。如果只有一个对象，则不应有逗号或“and”，如果没有对象，则不应有空格，就像这里一样。
- en: 'Implement a new function to add this logic to our program:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个新的函数，将此逻辑添加到我们的程序中：
- en: '[PRE59]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we implement the easier cases. If there are no objects, we want to return
    an empty string. If there is just one, we return that object with a leading space.
    Now, let's tackle the case of multiple objects.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们实现了较简单的情况。如果没有对象，我们希望返回一个空字符串。如果只有一个对象，我们返回该对象，前面加一个空格。现在，让我们来处理多个对象的情况。
- en: We will need to add the objects to a comma-separated list, and if we have reached
    the last object, join it with "and".
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要将对象添加到一个以逗号分隔的列表中，如果已经到达最后一个对象，则用“and”连接。
- en: 'To do this, we''ll initialize an empty string and loop over the array of objects:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将初始化一个空字符串，并遍历对象的数组：
- en: '[PRE60]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: By breaking the problem down into small components, we've come up with a function
    that solves all our use cases. Our `return` statement from `sentence` can now
    be ``return `${subject} ${verb}${arrayToObjectSegment(objects)}.`;``.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将问题分解成小的组件，我们提出了一个解决所有用例的函数。现在，我们的`sentence`函数的`return`语句可以写成`return `${subject}
    ${verb}${arrayToObjectSegment(objects)}.`;`。
- en: 'Notice how the function that returns a string can fit right into our string
    template. Running this, we get the following output:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，返回字符串的函数可以完美地嵌入我们的字符串模板中。运行这个程序，我们得到以下输出：
- en: '[PRE61]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: That's almost correct, but the first letter of the sentence should be capitalized.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这几乎是对的，但句子的第一个字母应该大写。
- en: 'Use another function to handle capitalization and wrap the whole string template
    with it:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用另一个函数来处理大小写，并用它来包裹整个字符串模板：
- en: '[PRE62]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This function uses several built-in functions: `charAt`, `toUpperCase`, `slice`,
    and `toLowerCase`, all inside a string template. These functions grab the first
    character from our sentence, make it uppercase, and then concatenate it with the
    rest of the sentence, all cast to lowercase.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数使用了几个内置函数：`charAt`、`toUpperCase`、`slice`和`toLowerCase`，所有这些都在字符串模板内部。这些函数从我们的句子中获取第一个字符，将其转换为大写，然后将其与句子的其余部分连接起来，所有内容都转换为小写。
- en: 'Now, when we execute the program, we get the desired result:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当我们执行程序时，我们得到期望的结果：
- en: '[PRE63]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To complete this exercise, we wrote three different functions, each serving
    a single purpose. We could have jammed all the functionality into a single function,
    but that would make the resulting code less reusable and more complicated to read
    and test. Building software from simple, single-purpose functions remains one
    of the best ways to write clean, maintainable code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个练习，我们编写了三个不同的函数，每个函数都服务于单一目的。我们本可以将所有功能都塞进一个函数中，但那样会使生成的代码的可重用性降低，并且更难以阅读和测试。从简单的单一目的函数构建软件仍然是编写干净、可维护代码的最好方法之一。
- en: Understanding this
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解这一点
- en: Many developers have been frustrated by the `this` keyword. `this` nominally
    points to the runtime of the current function. For example, if a member function
    of an object is invoked, `this` will usually refer to that object. The use of
    `this` across other contexts may seem inconsistent, and its use can result in
    a number of unusual bugs. Part of the problem lies in the fact that the keyword
    is relatively straightforward to use in languages such as C++ or Java and programmers
    with experience in those languages may expect the TypeScript `this` to behave
    similarly.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者都曾因`this`关键字而感到沮丧。`this`名义上指向当前函数的运行时。例如，如果调用一个对象的成员函数，`this`通常指向该对象。在其他上下文中使用`this`可能看起来不一致，其使用可能导致许多异常错误。部分问题在于，在C++或Java等语言中，关键字的使用相对简单，那些有经验的程序员可能会期望TypeScript中的`this`有类似的行为。
- en: 'Let''s look at a very simple use case for `this`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`this`的一个非常简单的用例：
- en: '[PRE64]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here we declare an object that has a property, `name`, and a method, `sayHello`.
    In order for `sayHello` to read the `name` property, we use `this` to refer to
    the object itself. There's nothing wrong with this code and many programmers will
    find it quite intuitive.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个具有属性`name`和方法`sayHello`的对象。为了让`sayHello`读取`name`属性，我们使用`this`来引用对象本身。这段代码没有问题，许多程序员会认为它非常直观。
- en: The problem will come in when we need to declare another function inline, likely
    as a callback function for something like the `filter` function we looked at earlier.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要声明另一个内联函数时，问题就会出现，这可能是作为之前查看的`filter`函数等回调函数的一部分。
- en: 'Let''s imagine we want to encapsulate the `arrayFilter` function in an object
    that can have a property to specify the maximum number allowed. This object will
    have some resemblance to the previous one, and we might expect to be able to employ
    `this` to get that maximum value. Let''s see what happens when we try:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想我们想要将`arrayFilter`函数封装在一个对象中，该对象可以有一个属性来指定允许的最大数量。这个对象将与之前的对象有些相似，我们可能会期望能够使用`this`来获取那个最大值。让我们看看当我们尝试时会发生什么：
- en: '[PRE65]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: TypeScript doesn't like my code. I'll have a red squiggly line under `this`,
    depending on my editor, and I won't be able to execute my program. Even if the
    program executes, you will not obtain the intended output.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript不喜欢我的代码。根据我的编辑器，`this`下面会出现一条红色的波浪线，我将无法执行我的程序。即使程序执行了，你也不会得到预期的输出。
- en: The problem here is that my use of the `function` keyword creates a new scope
    and `this` no longer has the value I want it to. In fact, it has no value. It
    is `undefined`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，我使用`function`关键字创建了一个新的作用域，`this`不再具有我想要的值。事实上，它没有任何值。它是`undefined`。
- en: The reason for this is that unlike object-oriented languages, such as C++ and
    Java, the value of `this` will be determined at runtime and it will be set to
    the calling scope. In this case, our callback function is not part of any set
    context or object, and so `this` is `undefined`. The fact that it's `undefined`
    is really immaterial here. The important part is that it's not what we want.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，与C++和Java这样的面向对象语言不同，`this`的值将在运行时确定，并将其设置为调用范围。在这种情况下，我们的回调函数不属于任何设置上下文或对象，因此`this`是`undefined`。实际上，`undefined`在这里并不重要。重要的是它不是我们想要的。
- en: There have been a number of workarounds to this problem over the years. One
    of them is that we cache the `this` reference to another variable and make that
    variable available in our callback function. Another is that we use the `bind`
    member function of the `Function` prototype to set the `this` reference. You may
    come across code that looks like this.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年来，已经出现了许多解决这个问题的方法。其中之一是我们将`this`引用缓存到另一个变量中，并在我们的回调函数中使该变量可用。另一种方法是使用`Function`原型的`bind`成员函数来设置`this`引用。你可能会遇到类似这样的代码。
- en: 'A better solution is to simply use arrow functions instead of function expressions.
    Not only is the syntax more concise and more modern, but arrow functions do not
    create a new `this` context. You get the `this` reference that you want, that
    of a top-level object. Let''s rewrite the code using an arrow function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是简单地使用箭头函数而不是函数表达式。不仅语法更简洁、更现代，而且箭头函数不会创建新的`this`上下文。你将得到你想要的`this`引用，即顶层对象的引用。让我们使用箭头函数重写代码：
- en: '[PRE66]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The function produces the following output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数产生以下输出：
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: TypeScript no longer complains about `this` and the code works correctly.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript不再对`this`提出抱怨，代码运行正确。
- en: But wait, why are we using a function expression for the `filter` function and
    an arrow function for the callback? It's because we actually need the scope-creating
    capability of `function` in order for `this` to have a value. If we rewrote the
    `filter` function as an arrow function, `this` would never be set and we wouldn't
    be able to access the `max` property.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，为什么我们为`filter`函数使用函数表达式，而为回调使用箭头函数？这是因为我们实际上需要`function`的作用域创建能力，以便`this`具有值。如果我们把`filter`函数重写为箭头函数，`this`将永远不会设置，我们就无法访问`max`属性。
- en: This is confusing, to be sure, and it's the reason `this` is dreaded in TypeScript
    and JavaScript more than in other languages. The important thing to remember is
    that when you are programming with `this`, you want any object or class methods
    to be function expressions and any callbacks to be arrow functions. That way,
    you'll always have the correct instance of `this`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实令人困惑，这也是为什么在TypeScript和JavaScript中，`this`比其他语言更让人讨厌的原因。重要的是要记住，当你使用`this`编程时，你希望任何对象或类方法都是函数表达式，任何回调都是箭头函数。这样，你将始终拥有正确的`this`实例。
- en: '*Chapter 4* , *Classes and Objects*, will contain a deeper dive into classes
    and explore other patterns. Let''s now use `this` in an object in the following
    exercise.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4章*，*类和对象*，将更深入地探讨类并探索其他模式。现在让我们在下面的练习中使用对象中的`this`。'
- en: 'Exercise 3.04: Using this in an Object'
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.04：在对象中使用this
- en: For this exercise, we will imagine that we have to implement some accounting
    software. In this software, each account object will track the total amount due,
    along with the amount that has been paid, and will have a couple of utility methods
    to get the current state of the account and the balance that needs to be paid.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将想象我们必须实现一些会计软件。在这个软件中，每个账户对象将跟踪应付款总额，以及已付款金额，并将有几个实用方法来获取账户的当前状态和需要支付的余额。
- en: 'Let''s start by creating the object with its methods unimplemented. This example
    will demonstrate a simplified workflow where we print out the account, attempt
    to pay more than is due (receiving an error), then pay the amount due, and finally
    the full amount due:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个对象，其方法尚未实现。这个例子将演示一个简化的工作流程，其中我们打印出账户，尝试支付超过应付款额（收到错误），然后支付应付款额，最后支付全额应付款额：
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code file for this exercise can be found at [https://packt.link/P6YIf](https://packt.link/P6YIf).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在[https://packt.link/P6YIf](https://packt.link/P6YIf)找到。
- en: 'Write the following code, which is the basis for starting our program:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码，这是我们程序的起点：
- en: '[PRE68]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We need to implement both methods. The `printStatus` method will just output
    the total that was due, the amount paid so far, and whether the account is open
    or closed (or fully paid).
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要实现两种方法。`printStatus`方法将只输出应付款总额、已付款金额以及账户是开放还是关闭（或已全额支付）。
- en: 'Use a string template to output the status, but in order to access the properties
    on the `account` object, use the `this` keyword:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字符串模板来输出状态，但为了访问`account`对象上的属性，请使用`this`关键字：
- en: '[PRE69]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We implement the `printStatus` function expression as a string template that
    uses `this` to access properties on the same object. As a reminder, we must use
    a function expression here and cannot use an arrow function, even if we might
    prefer that syntax, because arrow functions do not create a new execution context.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`printStatus`函数表达式实现为一个使用`this`来访问同一对象属性的字符串模板。作为提醒，我们必须在这里使用函数表达式，而不能使用箭头函数，即使我们可能更喜欢那种语法，因为箭头函数不会创建一个新的执行上下文。
- en: In case there's any confusion, there's no double dollar sign operator here.
    The first is a literal indicating the currency, and the second is part of the
    template string.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果有任何疑问，这里没有双美元符号运算符。第一个是表示货币的文本，第二个是模板字符串的一部分。
- en: Now let's handle the payment. Our requirements are that if the amount paid exceeds
    the amount due, we should throw an error and not apply any payment. Otherwise,
    we track the additional payment. If the balance reaches `$0`, then we close the
    account. We should also print the current status following each transaction.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们处理付款。我们的要求是，如果支付的金额超过应付款额，我们应该抛出一个错误，并且不应用任何付款。否则，我们跟踪额外的付款。如果余额达到$0，则关闭账户。我们应在每次交易后打印当前状态。
- en: 'Write the code to handle the payment:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写处理付款的代码：
- en: '[PRE70]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Execute the program and check the output:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行程序并检查输出：
- en: '[PRE71]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this exercise, we used function expressions as object methods to access properties
    on the object. Methods can not only read properties on an object, they can also
    update them. It's a common pattern in object-oriented programming to have objects
    that both contain data and have the methods available to access and mutate them.
    Sometimes, those methods will be set to private and only accessed via accessors
    such as `get` and `set`. More on this subject will be covered in *Chapter 4*,
    *Classes and Objects*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了函数表达式作为对象方法来访问对象上的属性。方法不仅可以读取对象上的属性，还可以更新它们。在面向对象编程中，有一个常见的模式是对象既包含数据，又具有访问和修改这些数据的方法。有时，这些方法会被设置为私有，并且只能通过`get`和`set`等访问器来访问。关于这个主题的更多内容将在*第4章*，*类和对象*中介绍。
- en: As we've seen in this exercise, when implementing object-oriented patterns,
    function expressions are still important to know and understand.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这次练习中看到的，在实现面向对象模式时，了解和掌握函数表达式仍然很重要。
- en: Closures and Scope
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包和作用域
- en: In addition to everything else we've discussed so far, functions do something
    special in TypeScript. When a function is declared (be it a function statement,
    expression, or arrow function), it encloses any variables in a higher scope. This
    is called a closure. Any function can be a closure. A closure is simply a function
    that has enclosed variables.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前讨论的所有内容之外，在TypeScript中函数还有一些特殊的行为。当一个函数被声明时（无论是函数声明、表达式还是箭头函数），它会封闭任何更高作用域中的变量。这被称为闭包。任何函数都可以是闭包。闭包简单地是一个封闭了变量的函数。
- en: 'The concept of scope simply means that each function creates a new scope. As
    we''ve seen, functions can be declared inside other functions. The `inner` function
    can read any variables declared in the outer function, but the outer function
    cannot see variables declared in the inner function. This is scope. The following
    code establishes an outer scope and an inner scope by declaring a second function
    inline inside an outer function. The inner function is able to access the variables
    in the outer scope, but the `world` variable declared in the inner scope is not
    visible outside that function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 范围的概念简单地说就是每个函数创建一个新的作用域。正如我们所看到的，函数可以在其他函数内部声明。`内部`函数可以读取在`外部`函数中声明的任何变量，但`外部`函数无法看到在`内部`函数中声明的变量。这就是作用域。以下代码通过在`外部`函数内部声明第二个函数来建立外部作用域和内部作用域。`内部`函数能够访问`外部`作用域中的变量，但`内部`作用域中声明的`world`变量在该函数外部不可见：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The function produces the following output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数产生以下输出：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When this function is invoked, the inner log statement is reached and logs
    `"Hello world!"`, and then the outer log statement is reached and we get `ReferenceError`.
    We can fix `ReferenceError` by adding `let world;` to the outer function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个函数被调用时，会到达内部日志语句并记录`"Hello world!"`，然后到达外部日志语句，我们得到`ReferenceError`。我们可以通过在`外部`函数中添加`let
    world;`来修复`ReferenceError`：
- en: '[PRE74]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The function produces the following output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数产生以下输出：
- en: '[PRE75]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is because the `inner` function declared a new `world` variable that the
    `outer` function cannot access. We can drop `const` from the `inner` declaration:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`内部`函数声明了一个新的`world`变量，而`外部`函数无法访问它。我们可以从`内部`声明中删除`const`：
- en: '[PRE76]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The function produces the following output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数产生以下输出：
- en: '[PRE77]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The function finally works because the `inner` function operates against a variable
    that was declared in the scope of the `outer` function. It is still visible after
    the inner scope is exited, so it can be printed out.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 函数最终可以工作，因为`内部`函数是在`外部`函数的作用域中声明的变量上操作的。在退出内部作用域后，它仍然可见，因此可以打印出来。
- en: 'Let''s look at a more useful example. The Fibonacci sequence is a number set
    in which the next number is the sum of the two previous numbers: `[0, 1, 1, 2,
    3, 5, 8, 13, 21, …]`. The Fibonacci sequence is often used to help explain recursive
    functions. In this case, we will instead use it to demonstrate closures by writing
    a function that will return the next value in the sequence each time it is called.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更有用的例子。斐波那契数列是一个数集，其中下一个数是前两个数的和：`[0, 1, 1, 2, 3, 5, 8, 13, 21, …]`。斐波那契数列通常用于帮助解释递归函数。在这种情况下，我们将用它来通过编写一个每次调用都返回序列中下一个值的函数来演示闭包。
- en: 'The logic of our program will be that we will track the current number being
    returned by our function, the next one that should be, and the amount to increment
    the number. Each time it is called, all three numbers will be updated to prepare
    for the next call. One way to do that is to define these values as global scoped
    variables and write a simple function to update and track them. That might look
    like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的逻辑将是，我们将跟踪函数返回的当前数字，下一个应该是什么数字，以及增加数字的数量。每次调用时，这三个数字都将更新以准备下一次调用。实现这一点的一种方法是将这些值定义为全局作用域变量，并编写一个简单的函数来更新和跟踪它们。这可能看起来像这样：
- en: '[PRE78]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The function produces the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数产生以下输出：
- en: '[PRE79]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This program works and returns the desired result, but since it isn''t a function,
    the program will just execute once and stop. If you wanted to get the next Fibonacci
    number as part of some other process, you wouldn''t be able to. If you just wrap
    it in a function, that won''t work either:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序可以运行并返回期望的结果，但由于它不是一个函数，程序将只执行一次然后停止。如果你想在其他过程中获取下一个斐波那契数，你将无法做到。如果你只是将它包裹在一个函数中，这也不会起作用：
- en: '[PRE80]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The function produces the following output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数产生以下输出：
- en: '[PRE81]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This function will just return `0` every time it's called because all the variables
    get re-declared when it's invoked. We can fix that by moving the variables outside
    the function. That way, they are declared once and modified by the function being invoked.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数每次被调用时都会返回`0`，因为所有变量在调用时都会被重新声明。我们可以通过将变量移出函数来修复这个问题。这样，它们只声明一次，并由被调用的函数修改。
- en: 'Our function now sets up the next value to be returned, the amount to increment,
    and the most recent returned value. On each function call in the loop, it will
    replace the current value with the next value, the next value with the increment
    amount, and the increment amount to the sum of the next value plus the previous
    increment amount. Then it logs out the current value:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能现在设置了下一个要返回的值，增量值以及最近返回的值。在循环中的每次函数调用，它将当前值替换为下一个值，下一个值替换为增量值，增量值替换为下一个值加上前一个增量值的总和。然后它记录当前值：
- en: '[PRE82]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The function produces the following output:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 函数产生了以下输出：
- en: '[PRE83]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This works! The reason it works is that the `getNext` function is able to access
    the variables in the higher scope. The function is a closure. This will seem standard
    and expected, but what might be unexpected is that this will work even if the
    function is exported and called by some other part of the program. This can be
    illustrated better by creating another function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这成功了！它之所以能成功，是因为`getNext`函数能够访问更高作用域中的变量。这个函数是一个闭包。这可能会显得很标准且预期，但可能意想不到的是，即使函数被导出并由程序的其他部分调用，这也能工作。这可以通过创建另一个函数来更好地说明：
- en: '[PRE84]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output hasn''t changed:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 输出没有变化：
- en: '[PRE85]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Calling the `fibonacci` function will return a new function that has access
    to the variables declared in `fibonacci`. If we wanted to run another Fibonacci
    sequence, we could call `fibonacci()` again to get a fresh scope with initialized
    variables:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`fibonacci`函数将返回一个新的函数，该函数可以访问`fibonacci`中声明的变量。如果我们想运行另一个斐波那契数列，我们可以再次调用`fibonacci()`以获得一个新的作用域和初始化的变量：
- en: '[PRE86]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We''ll see the same output again, but twice this time:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次看到相同的输出，但这次是两次：
- en: '[PRE87]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For ease of presentation, only a section of the actual output is displayed.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于展示，这里只显示实际输出的部分。
- en: In both cases, the closures have closed over the variables in a higher scope
    and are still available on function calls. This is a powerful technique, as has
    been shown, but could potentially lead to memory leaks if not used correctly.
    Variables declared in a closure like this cannot be garbage-collected while a
    reference to them still exists.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，闭包都覆盖了更高作用域中的变量，并且在函数调用中仍然可用。这是一个强大的技术，正如所展示的，但如果使用不当可能会导致内存泄漏。在这种闭包中声明的变量，在存在对其的引用时无法被垃圾回收。
- en: 'Exercise 3.05: Creating the Order Factory with Closures'
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.05：使用闭包创建订单工厂
- en: Closures can be tricky to work with, but a common pattern that really brings
    out the usefulness is sometimes called a factory pattern. This is, simply, a function
    that returns another function that is all set up and ready for use. In this pattern,
    a closure is used to make sure that variables can persist between function calls.
    We'll explore this pattern in this exercise.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可能难以处理，但一个真正体现其有用性的常见模式有时被称为工厂模式。简单来说，这是一个返回另一个已经设置好并准备好使用的函数的函数。在这个模式中，闭包被用来确保变量可以在函数调用之间持久化。我们将在本练习中探讨这个模式。
- en: 'Let''s start with some code that almost does what we want it to do. We are
    working on an order system for some sort of garment. Each order that comes in
    will specify a quantity of the garment in identical color and size. We just have
    to produce a record of each garment with a unique ID for tracking:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从几乎实现我们想要的功能的代码开始。我们正在为某种服装的订单系统工作。每个订单将指定相同颜色和大小的服装的数量。我们只需要为每件服装生成一个具有唯一ID的记录以进行跟踪：
- en: Note
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code file for this exercise can be found at [https://packt.link/fsqdd](https://packt.link/fsqdd).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在[https://packt.link/fsqdd](https://packt.link/fsqdd)找到。
- en: 'Create a new file in VS Code and save it as `order.ts`. Begin with the following
    code with some sample calls:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中创建一个新文件，并将其保存为`order.ts`。从以下代码和一些示例调用开始：
- en: '[PRE88]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The code looks OK. Let''s run it and see how it works. You will obtain the
    following output:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码看起来没问题。让我们运行它看看效果如何。你会得到以下输出：
- en: '[PRE89]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: That's not right. We can't start the ID numbers over at zero again each time.
    How can we fix this problem?
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是不正确的。我们不能每次都从零开始重新开始ID号码。我们该如何解决这个问题？
- en: There are a couple of ways to fix this. The easiest way to do it would be to
    declare the ID number outside of `orderFactory`. However, doing that might lead
    to bugs as system complexity grows. Variables that are in a topmost or even global
    scope are accessible to every part of the system and may get modified by some
    edge case.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题。最简单的方法是在 `orderFactory` 之外声明 ID 号码。然而，这样做可能会随着系统复杂性的增长而导致错误。位于最高层或甚至全局作用域中的变量可以由系统的任何部分访问，并且可能被某些边缘情况修改。
- en: 'Use a closure to solve this problem instead. Create an `orderFactory` function
    that returns an instance of `createOrder`, which will put the ID number in the
    scope just over `createOrder`. That way, the ID will be tracked between multiple
    calls of `createOrder`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用闭包来解决这个问题。创建一个 `orderFactory` 函数，它返回 `createOrder` 的一个实例，将 ID 号码放在 `createOrder`
    上方的范围中。这样，ID 就会在 `createOrder` 的多次调用之间跟踪。
- en: '[PRE90]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This factory function returns another function, which is defined inline as an
    arrow function. Before that function is returned, the `id` variable is declared
    in the scope just above it. Each invocation of the returned function will see
    the same instance of `id` and thus it will retain its value between calls.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个工厂函数返回另一个函数，该函数作为箭头函数内联定义。在返回该函数之前，`id` 变量在其上方的作用域中声明。每次调用返回的函数都会看到相同的 `id`
    实例，因此它将在调用之间保留其值。
- en: 'In order to make use of the factory, call the function once:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用工厂，请调用一次函数：
- en: '[PRE91]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Calling `orderFactory` once will initialize the ID variable and make it available
    in the returned function that is now assigned to `createOrder`. That variable
    is now enclosed. No other code will be able to access it or, more importantly,
    modify it.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用一次 `orderFactory` 将初始化 ID 变量，并使其在现在分配给 `createOrder` 的返回函数中可用。该变量现在是封装的。没有其他代码能够访问它，或者更重要的是，修改它。
- en: 'Run the program and observe that we now get the correct output:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并观察我们现在得到了正确的输出：
- en: '[PRE92]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Closures can be very difficult to understand without practice. Beginner TypeScript
    programmers shouldn't worry about mastering them immediately, but it's very important
    to recognize factory patterns and the behavior of enclosed variables.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 没有实践，闭包可能很难理解。TypeScript 初学者不应该担心立即掌握它们，但认识到工厂模式和封装变量的行为非常重要。
- en: Currying
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化
- en: Currying (named after Haskell Brooks Curry, the mathematician after whom the
    Haskell, Brooks, and Curry programming languages are also named) is the act of
    taking a function (or a formula in mathematics) and breaking it down into individual
    functions, each with a single parameter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化（以数学家 Haskell Brooks Curry 命名，Haskell、Brooks 和 Curry 编程语言也是以他的名字命名的）是将一个函数（或数学中的公式）分解成具有单个参数的单独函数的行为。
- en: Note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on currying, refer to the following URL: [https://javascript.info/currying-partials](https://javascript.info/currying-partials).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于柯里化的信息，请参考以下网址：[https://javascript.info/currying-partials](https://javascript.info/currying-partials)。
- en: 'Since functions in TypeScript can return functions, arrow syntax gives us a
    special concise syntax that makes currying a popular practice. Let''s start with
    a simple function:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TypeScript 中的函数可以返回函数，箭头语法为我们提供了一个特殊的简洁语法，使得柯里化成为一种流行的实践。让我们从一个简单的函数开始：
- en: '[PRE93]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The output is as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE94]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Here, we''ve used arrow syntax to describe a function body without braces or
    the `return` keyword. The function returns the result of the single expression
    in the body. This function expects two parameters and can be rewritten as curried
    functions with a single parameter each:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了箭头语法来描述一个没有花括号或 `return` 关键字的函数体。该函数返回体中的单个表达式的结果。这个函数期望两个参数，可以重写为每个参数只有一个参数的柯里化函数：
- en: '[PRE95]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output is as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE96]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This is actually two function declarations. The first function returns another
    function, which actually does the calculation. Because of closures, the `a` parameter
    is available within the second function, as well as its own parameter, `b`. The
    two sets of parentheses mean that the first one returns a new function that is
    then invoked immediately by the second one. The preceding code could be rewritten
    in a longer form:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这是两个函数声明。第一个函数返回另一个函数，实际上执行计算。由于闭包，`a` 参数在第二个函数内部可用，以及它自己的参数 `b`。两组括号意味着第一个返回一个新的函数，然后立即被第二个函数调用。前面的代码可以重写为更长的形式：
- en: '[PRE97]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The output is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE98]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: It looks a bit silly when written that way, but these do exactly the same thing.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当这样写的时候看起来有点傻，但它们确实做了完全相同的事情。
- en: So what use is currying?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 Currying 有什么用途呢？
- en: Higher-order functions are a variety of curried functions. Higher-order functions
    both take a function as an argument and return a new function. These functions
    are often wrapping or modifying some existing functionality. How can we wrap our
    REST client in a higher-order function to ensure that all responses, whether successful
    or in error, are handled in a uniform way? This will be the focus of the next
    exercise.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是 Curried 函数的一种形式。高阶函数既接受一个函数作为参数，又返回一个新的函数。这些函数通常封装或修改一些现有的功能。我们如何将我们的
    REST 客户端封装在一个高阶函数中，以确保所有响应，无论是成功还是错误，都以统一的方式处理？这将是下一个练习的重点。
- en: 'Exercise 3.06: Refactoring into Curried Functions'
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.06：将代码重构为 Curried 函数
- en: 'Currying makes use of closures and is closely related to the last exercise,
    so let''s return to it and establish the solution from the last exercise as the
    starting point for this one. Our `orderFactory` function is doing its job and
    tracking IDs properly, but the initialization of each type of garment is too slow.
    The first time an order for red medium comes in, we expect some time will be taken
    in spinning up this particular recipe, but subsequent red mediums suffer the same
    latency. Our system isn''t efficient enough to handle the demand for popular items.
    We need some way to cut into the setup time each time a similar order comes in:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Currying 技术利用闭包，并且与上一个练习紧密相关，因此让我们回到它，并将上一个练习的解决方案作为本练习的起点。我们的 `orderFactory`
    函数正在正常工作并正确跟踪 ID，但每种服装类型的初始化太慢了。当第一次收到红色中号的订单时，我们预计启动这个特定配方需要一些时间，但随后的红色中号订单也遭受了相同的延迟。我们的系统在处理热门商品的需求方面效率不足。我们需要一种方法来减少每次类似订单到来时的设置时间：
- en: Note
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code file for this exercise can be found at [https://packt.link/jSKic](https://packt.link/jSKic).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在 [https://packt.link/jSKic](https://packt.link/jSKic) 找到。
- en: 'Review the code from *Exercise 3.05, Creating the Order Factory with Closures*
    (`order-solution.ts`):'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看来自 *练习 3.05，使用闭包创建订单工厂* (`order-solution.ts`) 的代码：
- en: '[PRE99]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How can we use currying to increase efficiency? You need to refactor the code
    into curried functions.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们如何使用 Currying 来提高效率？你需要将代码重构为 Curried 函数。
- en: 'Refactor `orderFactory` to return a curried function by breaking up the returned
    function into three separate functions, each of which returns the next function:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `orderFactory` 重构为返回 Curried 函数，通过将返回的函数分解为三个单独的函数，每个函数都返回下一个函数：
- en: '[PRE100]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In this case, our refactor is as simple as putting an arrow in between each
    parameter. Note that this code omits return types from the functions. There are
    two reasons for this. One is that the type can be reasonably inferred from the
    code and is quite clear. The other is that adding all of the return types will
    significantly clutter the code.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的重构就像在每个参数之间放置一个箭头一样简单。请注意，此代码省略了函数的返回类型。有两个原因。一个是类型可以从代码中合理推断，并且非常清晰。另一个是添加所有返回类型将显著使代码杂乱。
- en: 'If we add all the return types together, the code will look like this:'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们将所有返回类型相加，代码将看起来像这样：
- en: '[PRE101]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: TypeScript gives us the flexibility of choosing between explicitly declaring
    types and allowing type inference, when clear, to supply the correct types.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TypeScript 给我们提供了在显式声明类型和允许类型推断之间进行选择的灵活性，当类型清晰时，可以提供正确的类型。
- en: Now that `orderFactory` returns a curried function, we can take advantage of it.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在 `orderFactory` 返回 Curried 函数，我们可以利用它。
- en: 'Instead of passing every argument to `createOrder`, call `createOrder` with
    just the first argument to establish our line of red garments:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是将每个参数传递给 `createOrder`，我们可以只使用第一个参数来调用 `createOrder`，以建立我们的红色服装线：
- en: '[PRE102]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Then, further break out the individual items available:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，进一步分解可用的单个项目：
- en: '[PRE103]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'When necessary or appropriate, create an item on one line:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当需要或适当的时候，在一行中创建一个项目：
- en: '[PRE104]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Try creating many different combinations of orders and printing out the results:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试创建许多不同的订单组合并打印出结果：
- en: '[PRE105]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'When you run the program, you''ll see the following output:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会看到以下输出：
- en: '[PRE106]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For ease of presentation, only a section of the actual output is shown here.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了便于展示，这里只显示了实际输出的部分。
- en: Currying is a powerful technique for caching variables and partial function
    results. At this point, we've explored closures, higher-order functions, and currying,
    all of which show the power and versatility of functions in TypeScript.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Currying 是一种强大的技术，用于缓存变量和部分函数结果。到目前为止，我们已经探讨了闭包、高阶函数和 Currying，这些都展示了 TypeScript
    中函数的强大功能和多功能性。
- en: Functional Programming
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: 'Functional programming is a deep topic and the subject of many books by itself.
    This book can only touch on the topic. One of the foundational concepts in functional
    programming is to use simple functions that have an input and an output and do
    not modify variables that are outside their scope:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一个深奥的话题，本身就是一个许多书籍的主题。本书只能触及这个话题的皮毛。函数式编程的一个基础概念是使用具有输入和输出且不修改其作用域之外变量的简单函数：
- en: '[PRE107]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The function produces the following output:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 函数产生以下输出：
- en: '[PRE108]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The output of this program is correct. We have indeed added `5` to the initial
    value of `3`, but the `addFive` method accesses a variable in a higher scope and
    mutates it. It is greatly preferred in functional programming paradigms to instead
    return the new value and allow the outer scope to control the variables that have
    been declared in it. We can change `addFive` so that it no longer operates on
    variables outside its scope and instead only operates against its argument and
    returns the correct value:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出是正确的。我们确实将`5`加到了初始值`3`上，但`addFive`方法访问了更高作用域中的变量并对其进行了修改。在函数式编程范式下，更倾向于返回新值并允许外部作用域控制在其中声明的变量。我们可以修改`addFive`，使其不再操作其作用域之外的变量，而是仅对其参数操作并返回正确的值：
- en: '[PRE109]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The function produces the following output:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 函数产生以下输出：
- en: '[PRE110]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The function is now much more portable. It would be easier to test or reuse
    since it's not reliant on something in a higher scope. A functional programming
    paradigm encourages the use of smaller functions. Sometimes, programmers can write
    functions that do too many different things and are hard to read and maintain.
    This is often a source of bugs or a negative impact on team velocity. By keeping
    functions small and simple, we can chain logic together in ways that support maintenance
    and reusability.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 函数现在更加便携。由于它不依赖于更高作用域中的任何东西，因此更容易测试或重用。函数式编程范式鼓励使用更小的函数。有时，程序员可能会编写执行太多不同功能的函数，这些函数难以阅读和维护。这通常是错误或对团队速度产生负面影响的原因。通过保持函数小而简单，我们可以以支持维护和可重用的方式链接逻辑。
- en: 'A popular concept in functional programming is immutability. That is the concept
    whereby once a variable is declared, its value should not change. To understand
    why this would be a desirable trait, consider a program that has a requirement
    to print out a customer ID after the customer''s name:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的一个流行概念是不可变性。这就是一旦声明了变量，其值就不应该改变的概念。为了理解这为什么会是一个理想的特性，考虑一个需要打印客户ID的程序，客户名称之后：
- en: '[PRE111]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This program does as expected. When the customer''s name is printed out, it
    has the ID behind it; however, we''ve actually changed the name in the customer
    object:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序按预期运行。当打印客户名称时，它后面有ID；然而，我们实际上已经更改了客户对象中的名称：
- en: '[PRE112]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'What happens If `formatForPrint` is called repeatedly? With a minor refactor,
    our code is much safer and more consistent:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`formatForPrint`被反复调用会发生什么？通过微小的重构，我们的代码更加安全和一致：
- en: '[PRE113]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output is as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE114]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: It would be even better to pass in the customer object rather than having `formatForPrint`
    access it in a higher scope.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将客户对象传递进去而不是让`formatForPrint`在更高作用域中访问它，会更好。
- en: TypeScript supports both functional programming and object-oriented paradigms.
    Many applications borrow from both.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持函数式编程和面向对象范式。许多应用程序都借鉴了两者。
- en: Organizing Functions into Objects and Classes
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数组织成对象和类
- en: Sometimes, it makes sense to organize functions into member functions of objects
    and classes. These concepts will be addressed in greater detail in *Chapter 4*,
    *Classes and Objects*, but for now we can examine how we take a function declaration
    and add it to an object or class.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将函数组织成对象和类的成员函数是有意义的。这些概念将在第4章“类和对象”中更详细地介绍，但就目前而言，我们可以考察如何将一个函数声明添加到对象或类中。
- en: 'Let''s take a simple function:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的函数：
- en: '[PRE115]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'If we wanted to have an object that contains a number of math functions, we
    could simply add the following function to it:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个包含多个数学函数的对象，我们可以简单地添加以下函数到其中：
- en: '[PRE116]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE117]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Note that the syntax used in the `mathUtils` object is shorthand, meaning the
    left and right side of the assignment are the same. This could also be written
    like this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`mathUtils`对象中使用的语法是简写，意味着赋值语句的左右两侧是相同的。这也可以写成这样：
- en: '[PRE118]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We also have the option of defining the method inline with a function expression:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以选择使用函数表达式定义方法：
- en: '[PRE119]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The output in either case will be as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是哪种情况，输出结果如下：
- en: '[PRE120]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Remember that function expressions are usually the best thing to use in objects
    because they will have the correct `this` reference. In the case of our `mathUtils`
    object, we aren't using the `this` keyword, so an arrow function *could* be used,
    but bear in mind that if, later on, another developer refactors this object, they
    might not think to change from an arrow function to a function expression and
    you might wind up with buggy code.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，函数表达式通常是在对象中使用最好的东西，因为它们将具有正确的`this`引用。在我们的`mathUtils`对象中，我们没有使用`this`关键字，所以可以使用箭头函数，但请注意，如果稍后其他开发者重构此对象，他们可能不会想到将箭头函数更改为函数表达式，你可能会得到有错误的代码。
- en: 'Adding functions to classes can be done in exactly the same way and, in fact,
    the syntax is very similar. Let''s say we want to use a class instead of a plain
    object and we want to define `addTwoNumbers` inline. The `MathUtils` class might
    look something like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 向类中添加函数可以完全以相同的方式进行，实际上语法也非常相似。假设我们想使用类而不是普通对象，并希望内联定义`addTwoNumbers`。`MathUtils`类可能看起来像这样：
- en: '[PRE121]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now that we''re using a class, in order to call the function, we need to instantiate
    an object:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用类，为了调用函数，我们需要实例化一个对象：
- en: '[PRE122]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output is as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE123]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: For more information on classes, see *Chapter 4*, *Classes and Objects*.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 有关类的更多信息，请参阅*第4章*，*类和对象*。
- en: 'Exercise 3.07: Refactoring JavaScript into TypeScript'
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.07：将JavaScript重构为TypeScript
- en: 'Updating older JavaScript code to TypeScript isn''t difficult. If the original
    code was well written, we can retain much of the structure, but enhance it with
    interfaces and types. In this exercise, we will use an example legacy JavaScript
    code that prints the area of various shapes given the dimensions:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 将较旧的JavaScript代码更新为TypeScript并不困难。如果原始代码编写得很好，我们可以保留大部分结构，并通过接口和类型来增强它。在这个练习中，我们将使用一个示例遗留JavaScript代码，该代码根据给定的尺寸打印各种形状的面积：
- en: Note
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code file for this exercise can be found at [https://packt.link/gRVxx](https://packt.link/gRVxx).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在[https://packt.link/gRVxx](https://packt.link/gRVxx)找到。
- en: 'Start with the following legacy code and make some decisions about what we''d
    like to improve by converting it to TypeScript:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下遗留代码开始，并决定我们希望通过将其转换为TypeScript来改进什么：
- en: '[PRE124]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Note
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Only a section of the actual code is presented here. You can find the complete
    code at [https://packt.link/pahq2](https://packt.link/pahq2).
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里只展示了实际代码的一部分。完整的代码可以在[https://packt.link/pahq2](https://packt.link/pahq2)找到。
- en: A few of the changes are easy. We'll substitute `var` with `const`. The functions
    that determine area are pretty good, but `getArea` mutates the shape objects.
    It would be better to just return the area. All of our shapes are pretty well
    defined, but they would be improved with interfaces.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中一些更改很简单。我们将用`const`替换`var`。确定面积的函数相当不错，但`getArea`会修改形状对象。最好是只返回面积。我们的所有形状都定义得相当好，但通过接口可以进一步改进。
- en: Let's create some interfaces. Create a new file in VS Code and save it as `refactor-shapes-solution.ts`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一些接口。在VS Code中创建一个新文件，并将其保存为`refactor-shapes-solution.ts`。
- en: 'First, create a `Shape` interface that includes an enumerated type and an area
    property. We can extend our `Circle`, `Square`, `Rectangle`, and `RightTriangle`
    interfaces from that one:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个包含枚举类型和面积属性的`Shape`接口。我们可以从这个接口扩展我们的`Circle`、`Square`、`Rectangle`和`RightTriangle`接口：
- en: '[PRE125]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, let''s improve and simplify `getArea`. Instead of accessing properties
    on each shape, `getArea` can simply pass the shape to the correct function to
    determine the area and then return the calculated value:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们改进并简化`getArea`。而不是访问每个形状上的属性，`getArea`可以简单地传递形状到正确的函数以确定面积，然后返回计算值：
- en: '[PRE126]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This change requires that we make minor changes to all the functions that calculate
    area.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个更改要求我们对所有计算面积的函数进行一些小的修改。
- en: 'Instead of each individual property being passed in, now pass in the shape
    and then grab the props inside the functions:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在不是每个单独的属性都传递进来，而是传递形状，然后在函数内部获取属性：
- en: '[PRE127]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This pattern is very common among modern web app development and works very
    well in TypeScript development.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种模式在现代Web应用开发中非常常见，在TypeScript开发中也非常有效。
- en: 'Add some type hints to our object declarations:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的对象声明中添加一些类型提示：
- en: '[PRE128]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Running the program yields the correct output:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序会得到正确的输出：
- en: '[PRE129]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This exercise provided us with practical experience in refactoring legacy JavaScript
    code into TypeScript. These skills can help us to identify what constituted code
    quality problems in the original JavaScript code and improve them as we move the
    code to TypeScript.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习为我们提供了将遗留JavaScript代码重构为TypeScript的实际经验。这些技能可以帮助我们识别原始JavaScript代码中的代码质量问题，并在将代码迁移到TypeScript时进行改进。
- en: Import, Export, and Require
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入、导出和需求
- en: Very small programs, such as the kind often found in books on programming, can
    work just fine with all the code in a single file. Most of the time, applications
    will be made up of multiple files, often referred to as modules. Some modules
    may be dependencies installed from Node Package Manager (`npm`) and some may be
    modules you or your team have written. When you look at other projects, you may
    see the keywords `import`, `export`, `module`, and `require` used to link different
    modules together. `import` and `require` both serve the same purpose. They allow
    you to use another module in the module (file) you are currently working in. `export`
    and `module` are the opposite. They allow you to make part or all of your module
    available for other modules to use.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 非常小的程序，如编程书籍中经常找到的那种，可以与单个文件中的所有代码一起工作得很好。大多数时候，应用程序将由多个文件组成，通常被称为模块。一些模块可能是从Node包管理器（`npm`）安装的依赖项，而另一些可能是你或你的团队编写的模块。当你查看其他项目时，你可能会看到用于链接不同模块的关键字`import`、`export`、`module`和`require`。`import`和`require`都服务于相同的目的。它们允许你在当前正在工作的模块（文件）中使用另一个模块。`export`和`module`则相反。它们允许你使你的模块的部分或全部可供其他模块使用。
- en: We'll go over the different syntax options here. The reason for multiple ways
    to do things has, as usual, to do with the way the languages and runtimes have
    evolved. Node.js is by far the most popular runtime for server-side JavaScript,
    and this is where most of our compiled server-side TypeScript will run. Node.js
    was released in 2009 and, at that time, there was no standard module system for
    JavaScript. Many JavaScript web applications at that time would simply attach
    functions and objects to the global window object. This could work fine for web
    applications, since the window object is refreshed upon loading the page and exists
    in the web browser, so it's only used by a single user.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面介绍不同的语法选项。之所以有这么多做事情的方法，通常是因为语言和运行时的发展方式。Node.js是目前最流行的服务器端JavaScript运行时，大多数编译的服务器端TypeScript代码都将在这里运行。Node.js于2009年发布，当时JavaScript还没有标准模块系统。当时许多JavaScript网络应用程序会简单地将函数和对象附加到全局window对象上。对于网络应用程序来说，这可以工作得很好，因为window对象在页面加载时会刷新，存在于网络浏览器中，所以它只被单个用户使用。
- en: Although there is a global object in Node.js, this is not a practical way to
    link modules together. Doing so would risk one module overwriting another, memory
    leaks, exposing customer data, and all manner of other catastrophes. The great
    thing about the module system is that you can share only the bits of your module
    that you intend to.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Node.js中存在全局对象，但这并不是将模块链接在一起的实际方法。这样做可能会风险一个模块覆盖另一个模块，内存泄漏，暴露客户数据，以及各种其他灾难。模块系统的好处在于，你可以只共享你打算共享的模块部分。
- en: Because there was a need for a more robust solution, Node.js adopted the CommonJS
    spec and the `module` and `require` keywords. `module` is used to share all or
    part of your module and `require` is used to consume another module. These keywords
    were standard in Node.js for many years until ECMAScript 6 introduced the `import`
    and `export` syntax. The latter has been supported in TypeScript for many years
    and is preferred, although the `require` syntax is still valid and can be used.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要更健壮的解决方案，Node.js采用了CommonJS规范以及`module`和`require`关键字。`module`用于共享你的模块的全部或部分，而`require`用于消费另一个模块。这些关键字在Node.js中是标准的，直到ECMAScript
    6引入了`import`和`export`语法。后者在TypeScript中已经支持多年，并且是首选的，尽管`require`语法仍然是有效的，并且可以继续使用。
- en: This book will use `import` and `export` syntax, as this is standard. The examples
    that follow will use this syntax, but will also feature the `require` syntax as
    a comment so readers can compare.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用`import`和`export`语法，因为这是标准的。下面的示例将使用这种语法，但也将包含`require`语法的注释，以便读者可以进行比较。
- en: 'Any file with the `import` or `export` keyword is considered to be a module.
    Modules may export any variables or functions they declare, either as part of
    the declaration or by explicitly doing so:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含`import`或`export`关键字的文件都被视为模块。模块可以导出它们声明的任何变量或函数，无论是作为声明的一部分还是通过显式地这样做：
- en: '[PRE130]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'That is equivalent to explicit exports. Here is the complete code for `utils.ts`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这与显式导出等效。以下是 `utils.ts` 的完整代码：
- en: '[PRE131]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We can now import our exports into another module (another `.ts` file – `app.ts`):'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的导出导入到另一个模块中（另一个 `.ts` 文件 - `app.ts`）：
- en: '[PRE132]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Once you run `app.ts`, you will obtain the following output:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行 `app.ts`，你将获得以下输出：
- en: '[PRE133]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Note
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for the preceding example can be found here: [https://packt.link/zsCDe](https://packt.link/zsCDe)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 前例的代码文件可以在以下位置找到：[https://packt.link/zsCDe](https://packt.link/zsCDe)
- en: Modules that are part of our application are imported via the relative path
    from the root of the project. Modules that are imported from our installed dependencies
    are imported by name. Note that the file extension is not part of the required
    path, just the filename.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的一部分模块通过从项目根目录的相对路径导入。从我们安装的依赖项导入的模块通过名称导入。注意，文件扩展名不是必需路径的一部分，只是文件名。
- en: 'Modules can also have default exports that use the `default` keyword. Default
    exports are imported without brackets. Consider the following examples:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也可以有默认导出，使用 `default` 关键字。默认导出不需要括号。考虑以下示例：
- en: '[PRE134]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The code for `app.ts` is as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.ts` 的代码如下：'
- en: '[PRE135]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Once you run the `app.ts` file, you will get the following output:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行 `app.ts` 文件，你将得到以下输出：
- en: '[PRE136]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Exercise 3.08: import and export'
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.08：导入和导出
- en: 'Looking back at the last exercise, we have a single file that has a bunch of
    utility functions, and then we have procedural code that establishes some objects,
    calls the functions, and logs out the output. Let''s refactor the result from
    Exercise 3.07, Refactoring JavaScript into TypeScript to use the `import` and
    `export` keywords and move those functions to a separate module:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾上一个练习，我们有一个包含许多实用函数的单个文件，然后我们有过程式代码创建一些对象，调用函数并输出日志。让我们重构练习 3.07，将 JavaScript
    重构为 TypeScript，使用 `import` 和 `export` 关键字，并将这些函数移动到单独的模块中：
- en: Note
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code file for this exercise can be found at [https://packt.link/2K4ds](https://packt.link/2K4ds).
    The first step of this exercise requires you to copy-paste some lines of code
    to your exercise file. Hence, we suggest you either download the code files from
    this repository or migrate it your desktop before you begin this exercise.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在 [https://packt.link/2K4ds](https://packt.link/2K4ds) 找到。本练习的第一步要求你将一些代码行复制粘贴到练习文件中。因此，我们建议你在开始此练习之前，要么从本存储库下载代码文件，要么将其迁移到您的桌面。
- en: Cut and paste the first 61 lines of `shapes.ts` into `shapes-lib.ts`. Your IDE
    should start warning you that it can no longer find the relevant functions.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `shapes.ts` 的前 61 行剪切粘贴到 `shapes-lib.ts` 中。您的 IDE 应该开始警告您它无法再找到相关的函数。
- en: 'Look over the code in `shapes-lib.ts`. Which functions and interfaces need
    to be exported? Square, circle, and the rest are utilized directly in `shapes.ts`,
    but the shapes interface isn''t, so only those four need to be exported. Likewise,
    the PI constant is only used in `shapes-lib.ts`, so no need to export that one:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看代码在 `shapes-lib.ts` 中的情况。哪些函数和接口需要导出？正方形、圆形以及其他直接在 `shapes.ts` 中使用，但形状接口没有使用，所以只需要这四个导出。同样，PI
    常量仅在 `shapes-lib.ts` 中使用，因此不需要导出该常量：
- en: '[PRE137]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The only function that needs to be exported is `getArea`, as that''s the only
    one referenced in `shapes.ts`:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需要导出的函数是 `getArea`，因为它是 `shapes.ts` 中唯一引用的：
- en: '[PRE138]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Now, let''s import the exported interfaces and function into `shapes.ts`. Your
    IDE may assist you in this task. For example, in VS Code, if you hover over a
    module that can be imported, it should ask you whether you''d like to add the import:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将导出的接口和函数导入到 `shapes.ts` 中。您的 IDE 可能会协助您完成此任务。例如，在 VS Code 中，如果将鼠标悬停在可以导入的模块上，它应该询问您是否要添加导入：
- en: '[PRE139]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'With all the imports and exports set, run the program again. You should get
    the correct result:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好所有导入和导出后，再次运行程序。你应该得到正确的结果：
- en: '[PRE140]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: One of the more challenging things about learning a new programming language
    is how to structure modules. A good rule of thumb is to always be prepared to
    break them into smaller chunks if they grow too large. This exercise helps us
    to understand how we can separate our application logic from utilities or reusable
    functions, a practice that will lead to clean, maintainable code.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门新编程语言更具挑战性的事情之一是如何构建模块。一个好的经验法则是，如果模块变得太大，总是准备好将它们拆分成更小的块。这个练习帮助我们理解如何将应用程序逻辑与实用程序或可重用函数分开，这种做法将导致代码整洁、易于维护。
- en: 'Activity 3.01: Building a Flight Booking System with Functions'
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 3.01：使用函数构建航班预订系统
- en: As a developer at a start-up for online bookings, you need to implement a system
    that manages airline bookings. The architecture for this system has already been
    decided upon. There will be a system for managing flights and seat availability
    on them and a system for managing bookings. Users will interact directly with
    the booking system and it, in turn, will search and update flight information.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一家在线预订初创公司的开发者，你需要实现一个管理航空公司预订的系统。这个系统的架构已经确定。将有一个用于管理航班和座位可用性的系统，以及一个用于管理预订的系统。用户将直接与预订系统交互，而该系统将搜索并更新航班信息。
- en: 'For the sake of keeping this activity to a manageable size, we''ll abstract
    a number of things, such as customer information, payments, the dates of flights,
    and even the city of origin. In understanding the problem we need to solve, it
    can be very helpful to create a diagram describing the flows we need to implement.
    The following diagram shows the expected workflow for our user:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这项活动保持可管理的规模，我们将抽象出许多事物，例如客户信息、支付、航班日期，甚至出发城市。在理解我们需要解决的问题时，创建一个描述我们需要实现的流程的图表非常有帮助。以下图表显示了我们的用户预期的流程：
- en: Note
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'The code files for this activity can be found here: [https://packt.link/o5n0t](https://packt.link/o5n0t).'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的代码文件可以在以下位置找到：[https://packt.link/o5n0t](https://packt.link/o5n0t)。
- en: '![Figure 3.1: Flows that need to be implemented in the flight booking system'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1：需要在航班预订系统中实现的流程]'
- en: '](img/B14508_03_01.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![备注](img/B14508_03_01.jpg)'
- en: 'Figure 3.1: Flows that need to be implemented in the flight booking system'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：需要在航班预订系统中实现的流程
- en: 'Here''s how the program flows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的流程如下：
- en: Get a list of flights to choose from.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取可供选择的航班列表。
- en: Start a booking with one of those flights.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这些航班中选择一个开始预订。
- en: Pay for the flight.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为航班支付费用。
- en: Complete the booking with seats reserved on the flight.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在航班上预留座位后完成预订。
- en: As the diagram shows, the user will interact with two different systems, a Bookings
    system and a Flights system. In most scenarios, the user interacts with the Bookings
    system, but they go directly to the Flights system to search for flights.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如图表所示，用户将与两个不同的系统交互，即预订系统和航班系统。在大多数情况下，用户与预订系统交互，但他们直接访问航班系统来搜索航班。
- en: 'In this activity, these systems can be represented by a `bookings.ts` file
    and a `flights.ts` file, which are two TypeScript modules. To complete the activity,
    implement these two modules in TypeScript. Here are some steps to help you:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，这些系统可以用一个`bookings.ts`文件和一个`flights.ts`文件来表示，这两个文件是两个TypeScript模块。为了完成这个活动，请使用TypeScript实现这两个模块。以下是一些步骤来帮助你：
- en: Since both the user and the Bookings system depend on the Flights system, start
    with flights – `flights.ts`. As the activity is simplified, we can simply return
    a list of destinations when the user wants to access flights. To allow access
    to the `bookings.ts` module, we'll want to use the `export` keyword on a function.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于用户和预订系统都依赖于航班系统，因此我们应该从航班系统开始，即`flights.ts`。由于活动被简化了，当用户想要访问航班时，我们可以简单地返回一个目的地列表。为了允许访问`bookings.ts`模块，我们将在一个函数上使用`export`关键字。
- en: Although the user has already fetched the flights, we need to check availability
    before initiating a booking. This is because our system will have many users and
    availability can change minute by minute. Expose a function for checking availability
    and another to hold seats while the transaction is completed.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管用户已经获取了航班信息，但在开始预订之前，我们需要检查可用性。这是因为我们的系统将有多个用户，可用性可能会每分钟变化。公开一个用于检查可用性的函数，另一个用于在交易完成前保留座位。
- en: The process payment step really hints at a third system for payments, but we
    won't include that system in this activity, so just mark the booking as paid when
    the user gets to the payment step. The Flights system doesn't need to be aware
    of payment status as that is managed by Bookings.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支付流程实际上暗示了支付系统的第三个系统，但我们将不会在这个活动中包含该系统，所以当用户到达支付步骤时，只需将预订标记为已支付即可。航班系统不需要知道支付状态，因为这是由预订系统管理的。
- en: When we complete the booking, held seats convert to reserved seats. Our booking
    is finalized and the seats are no longer available on the flight.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们完成预订时，保留的座位将转换为预留座位。我们的预订已经完成，座位不再在航班上可用。
- en: 'A typical output for such an activity would look like this:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种活动的典型输出将看起来像这样：
- en: '[PRE141]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Note
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备注
- en: For ease of presentation, only a part of the actual output is shown here. The solution
    to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor394).
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了便于展示，这里只显示了实际输出的部分。此活动的解决方案可以通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor394)找到。
- en: There are many other scenarios here that could be explored. Try holding all
    remaining seats, failing to start a new booking for that flight, and then complete
    the original booking. That should work with the logic we've implemented here!
    This exercise uses several functions to create a cohesive program. It uses closures,
    currying, functional programming concepts, and the `import` and `export` keywords
    to share functions between modules.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里还有许多其他场景可以探索。尝试保留所有剩余的座位，未能为该航班启动新的预订，然后完成原始预订。这应该会与我们在这里实现的逻辑兼容！这个练习使用了几个函数来创建一个连贯的程序。它使用了闭包、柯里化、函数式编程概念以及`import`和`export`关键字在模块之间共享函数。
- en: Unit Testing with ts-jest
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ts-jest进行单元测试
- en: Large systems require constant testing to ensure they are correct. This is where
    unit testing comes in. Some of the biggest software projects in the world have
    hundreds of millions of lines of code and thousands of features and views. It's
    simply not possible to manually test every feature. This is where unit tests come
    in. Unit tests test the smallest unit of code, often a single statement or function,
    and give us quick feedback if we've done something to change the behavior of an
    application. Short feedback cycles are a developer's best friend and unit tests
    are one of the most powerful tools to achieve them.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 大型系统需要持续测试以确保它们是正确的。这就是单元测试发挥作用的地方。世界上一些最大的软件项目有数亿行代码和数千个特性和视图。手动测试每个特性是不可能的。这就是单元测试发挥作用的地方。单元测试测试代码的最小单元，通常是单个语句或函数，并给我们提供快速反馈，如果我们做了什么来改变应用程序的行为。短的反馈周期是开发者的好朋友，而单元测试是实现它们的强大工具之一。
- en: There are many testing frameworks that can help us to unit test our code. Jest
    is a popular testing framework from Facebook. You may also come across other frameworks,
    such as Jasmine, Mocha, or Ava. Jest is a "batteries included" framework that
    will seem familiar to users of those other frameworks as it has tried to incorporate
    the best features of all of them.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多测试框架可以帮助我们进行单元测试我们的代码。Jest 是来自 Facebook 的一个流行的测试框架。你也可能遇到其他框架，如 Jasmine、Mocha
    或 Ava。Jest 是一个“包含电池”的框架，对于使用那些其他框架的用户来说会感觉熟悉，因为它试图整合它们中的所有最佳特性。
- en: Jest, Mocha, Ava, and the rest are JavaScript libraries, not TypeScript libraries,
    and so some special preparation is required to use them. `ts-jest` is a library
    that helps us to write TypeScript tests written in TypeScript and to use the Jest
    test runner and all the good parts of Jest.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Jest、Mocha、Ava以及其他都是JavaScript库，而不是TypeScript库，因此在使用它们之前需要做一些特殊准备。`ts-jest`是一个库，它帮助我们用TypeScript编写TypeScript测试，并使用Jest测试运行器和Jest的所有优点。
- en: 'To get started, we''ll install `jest`, `ts-jest`, and `typings` for `jest`
    (`@types/jest`):'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将安装`jest`、`ts-jest`和用于`jest`的`typings`（`@types/jest`）：
- en: '[PRE142]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Once the library is installed, we can use `npx` to initialize `ts-jest` with
    a default configuration that will let us write our first test:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了库，我们就可以使用`npx`来使用默认配置初始化`ts-jest`，这将允许我们编写我们的第一个测试：
- en: '[PRE143]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Running this command will create a config file called `jest.config.js`. As you
    become more comfortable writing tests with Jest, you may wish to modify this file,
    but for now, the default will work just fine.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将创建一个名为`jest.config.js`的配置文件。随着你越来越习惯于使用Jest编写测试，你可能希望修改此文件，但到目前为止，默认设置将完全适用。
- en: Some developers put unit tests in a tests directory, and some put the tests
    directly alongside the source code. Our default Jest config will find both kinds
    of tests. The convention for unit tests is the name of the module under test,
    followed by a dot, then the word `spec` or `test`, and then the file extension,
    which will be `ts` in our case. If we create files with that naming convention
    anywhere under our project root, Jest will be able to find and execute the tests.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者将单元测试放在测试目录中，而另一些则将测试直接放在源代码旁边。我们的默认Jest配置将找到这两种类型的测试。单元测试的惯例是测试模块的名称，后面跟着一个点，然后是单词`spec`或`test`，然后是文件扩展名，在我们的情况下将是`ts`。如果我们创建符合这种命名约定的文件，并且这些文件位于我们的项目根目录下，Jest将能够找到并执行这些测试。
- en: 'Let''s add a simple test. Create a file named `example.spec.ts`. Then add this
    code to the file. This code is just a placeholder for the test and doesn''t actually
    do anything other than verify that Jest is working correctly:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个简单的测试。创建一个名为 `example.spec.ts` 的文件。然后向该文件添加以下代码。这段代码只是测试的占位符，实际上并没有做任何事情，只是验证
    Jest 是否正确工作：
- en: '[PRE144]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'We can run Jest by typing `npx jest` at the console or we can add an `npm`
    script. Try typing `npm test` at the console. If you haven''t changed the default
    test, you should see something like the following:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在控制台输入 `npx jest` 来运行 Jest，或者我们可以添加一个 `npm` 脚本。尝试在控制台输入 `npm test`。如果你没有更改默认测试，你应该看到以下类似的内容：
- en: '[PRE145]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Let''s now update the `package.json` file so that it runs Jest instead of just
    failing. Find the `package.json` file and you''ll see this configuration inside
    it:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新 `package.json` 文件，使其运行 Jest 而不是直接失败。找到 `package.json` 文件，你会在其中看到以下配置：
- en: '[PRE146]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'We can replace the entire test with simply `jest`:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用简单的 `jest` 替换整个测试：
- en: '[PRE147]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Now, try `npm test` again:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次尝试 `npm test`：
- en: '[PRE148]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Of course, this test doesn''t do anything useful. Now, let''s import the functions
    we want to test and write some tests that are actually useful. First, let''s clean
    up the `arrow-cat-solution.ts` file (from Exercise 3.03, Writing Arrow Functions)
    a little. We can remove all the console statements because we''re going to validate
    our code by writing tests, not by just logging the console. Then, let''s add the
    `export` keyword to each of the functions so that our test can import them. `arrow-cat-solution.ts`
    now looks like this:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个测试没有做任何有用的事情。现在，让我们导入我们想要测试的函数，并编写一些真正有用的测试。首先，让我们清理一下 `arrow-cat-solution.ts`
    文件（来自练习 3.03，编写箭头函数）。我们可以删除所有的控制台语句，因为我们将通过编写测试来验证我们的代码，而不是仅仅记录控制台。然后，让我们为每个函数添加
    `export` 关键字，以便我们的测试可以导入它们。`arrow-cat-solution.ts` 现在看起来是这样的：
- en: '[PRE149]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Let''s try writing a test for the `capitalize` function. We simply need to
    call the function and test the outcome against the expected outcome. First, import
    the function in a new file (`arrow-cat-solution.spec.ts`):'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编写一个针对 `capitalize` 函数的测试。我们只需要调用该函数，并将结果与预期结果进行比较。首先，在一个新文件中导入该函数 (`arrow-cat-solution.spec.ts`)：
- en: '[PRE150]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Then, write an expectation. We expect our function to turn all-caps "HELLO"
    into "Hello". Let''s now write that test and execute it:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编写一个期望。我们期望我们的函数将全大写的 "HELLO" 转换为 "Hello"。现在让我们编写这个测试并执行它：
- en: '[PRE151]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Did it work?
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作了吗？
- en: '[PRE152]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The `describe` keyword is used to group tests and its only purpose is to affect
    the output of your test report. The `test` keyword should wrap the actual test.
    Instead of `test`, you can write `it`. Tests that use `it` are often written as
    an assertion with `should`:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 关键字用于分组测试，它的唯一目的是影响测试报告的输出。`test` 关键字应该包装实际的测试。除了 `test`，你还可以写 `it`。使用
    `it` 的测试通常写成带有 `should` 的断言：'
- en: '[PRE153]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Now, write tests for the other functions.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为其他函数编写测试。
- en: 'Activity 3.02: Writing Unit Tests'
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动三.02：编写单元测试
- en: In the last activity, we built a booking system for airlines and applied TypeScript
    functions to the scenarios involved in securing a flight reservation. We executed
    these scenarios from a single `index.ts` file, representing user interactions.
    This approach works well enough while we're learning, but it's a bit messy and
    doesn't actually assert that any of the scenarios are correct. To put that another
    way, it's almost a unit test, but it's not as good as a unit test.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个活动中，我们为航空公司构建了一个预订系统，并将 TypeScript 函数应用于确保航班预订涉及的场景。我们从单个 `index.ts` 文件中执行这些场景，代表用户交互。这种方法在我们学习时足够好，但它有点杂乱，实际上并没有断言任何场景是正确的。换句话说，它几乎是一个单元测试，但并不如单元测试那样好。
- en: 'We''ve learned about how to install Jest, so let''s use it to unit test *Activity
    3.01, Building a Flight Booking System with Functions*. For each function we wrote,
    we''ll write a test that invokes the function and tests the output:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何安装 Jest，所以让我们使用它来对 *活动 3.01，使用函数构建航班预订系统* 进行单元测试。对于每个我们编写的函数，我们将编写一个测试来调用该函数并测试输出：
- en: Note
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this activity can be found at [https://packt.link/XMOZO](https://packt.link/XMOZO).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的代码文件可以在 [https://packt.link/XMOZO](https://packt.link/XMOZO) 找到。
- en: The code stubs provided for this activity include `bookings.test.ts` and `flights.test.ts`
    with a number of unimplemented tests. Implement those tests to complete this activity.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为本活动提供的代码占位符包括 `bookings.test.ts` 和 `flights.test.ts`，其中包含一些未实现的测试。实现这些测试以完成本活动。
- en: You can execute the tests by running `npm test`. You can also run just the solutions
    with `npm run test:solution`.
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过运行 `npm test` 来执行测试。你也可以只运行解决方案，使用 `npm run test:solution`。
- en: To test a function, you will need to `import` it into your test file.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试一个函数，你需要将其 `import` 到你的测试文件中。
- en: Invoke the function with sample input, and then use Jest's `expect` assertions
    to test the output, for example, `expect(value).toBe(5);`.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用示例输入调用函数，然后使用 Jest 的 `expect` 断言来测试输出，例如，`expect(value).toBe(5);`。
- en: Error scenarios can be tested with `try/catch` blocks, catching the error thrown
    by the function, and then testing the error condition. When using `catch` in a
    unit test, it's a best practice to use `expect.assertions` to indicate how many
    assertions you want to test. Otherwise, your test might complete without the `catch`
    block being invoked.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用 `try/catch` 块来测试错误场景，捕获函数抛出的错误，然后测试错误条件。在单元测试中使用 `catch` 时，使用 `expect.assertions`
    来指示你想要测试多少断言是一个最佳实践。否则，你的测试可能在没有调用 `catch` 块的情况下完成。
- en: Try to reach 100% line coverage in the coverage report (already configured with `--coverage`).
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在覆盖率报告中达到 100% 的行覆盖率（已经使用 `--coverage` 配置）。
- en: Note
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor396).
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor396)找到。
- en: In this activity, we took a program we'd written and applied best practices
    with some good unit tests. It will now be much easier to add additional functionality
    and scenarios knowing that the existing code is tested. Instead of writing out
    an index file to call various functions, we now have things logically grouped,
    ordered, and tested. We have a mechanism to track line coverage and understand
    how much of our code is under test.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们使用了一些好的单元测试来应用最佳实践，我们编写的一个程序。现在，我们知道现有代码已经过测试，添加额外的功能和场景会容易得多。我们不再需要编写索引文件来调用各种函数，现在我们有逻辑上分组、排序和测试的东西。我们有一个机制来跟踪行覆盖率，并了解我们的代码中有多少是经过测试的。
- en: Error Handling
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'When we write functions, we need to bear in mind that not everything always
    works perfectly. What will we do if the function receives unexpected input? How
    will our program react if some other function that we need to call doesn''t work
    perfectly? It''s always a good idea to validate function input. Yes, we''re using
    TypeScript, and we can be reasonably sure that if we expect a string, we won''t
    get an object instead, but sometimes, external input doesn''t conform to our types.
    Sometimes, our own logic may be erroneous. Consider this function:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写函数时，我们需要牢记并非所有事情总是完美无缺。如果函数接收到意外的输入，我们会怎么做？如果我们需要调用的某个函数工作不完美，我们的程序会如何反应？始终验证函数输入是一个好主意。是的，我们正在使用
    TypeScript，我们可以合理地确信，如果我们期望一个字符串，我们不会得到一个对象，但有时，外部输入不符合我们的类型。有时，我们自己的逻辑可能是错误的。考虑这个函数：
- en: '[PRE154]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: It looks fine, but what if I pass in the number `0` as the denominator? We cannot
    divide by zero, and so the result will be the constant, `NaN`. `NaN`, when used
    in any mathematical equation, will always return `NaN`. This could introduce a
    serious bug into our system, and this needs to be avoided.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，但如果我们传入数字 `0` 作为分母会怎样？我们不能除以零，所以结果将是常数，`NaN`。`NaN` 在任何数学方程中使用时，总会返回 `NaN`。这可能会在我们的系统中引入一个严重的错误，这需要避免。
- en: 'To solve this problem, we need to figure out what should happen if we get invalid
    input. Log it? Throw an error? Just return zero? Exit the program? Once that is
    decided, we can add some validation to our function:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要弄清楚如果得到无效输入会发生什么。记录它？抛出错误？只是返回零？退出程序？一旦决定，我们就可以在我们的函数中添加一些验证：
- en: '[PRE155]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Now at least we won't fail silently as we are displaying a warning on the screen,
    `Cannot divide by zero!`. It's always better to raise an exception than for a
    function to fail without anybody noticing.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 至少我们现在不会默默失败，因为我们已经在屏幕上显示了一个警告，`Cannot divide by zero!`。抛出异常总比函数失败而无人察觉要好。
- en: Summary
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now, you know how to create the most important building blocks of any TypeScript
    program – functions. We have explored the difference between function expressions
    and arrow functions and when to use which. We looked at immediately invoked function
    expressions, closures, currying, and other powerful TypeScript techniques.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你知道如何创建任何 TypeScript 程序最重要的构建块——函数。我们已经探讨了函数表达式和箭头函数之间的区别，以及何时使用哪一个。我们研究了立即执行的函数表达式、闭包、柯里化和其他强大的
    TypeScript 技术。
- en: We talked about functional programming paradigms and looked at how to include
    functions in objects and classes. We've looked at how to convert legacy JavaScript
    code into modern TypeScript and how we can improve our software by doing so.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了函数式编程范式，并探讨了如何在对象和类中包含函数。我们还研究了如何将遗留的JavaScript代码转换为现代TypeScript，以及通过这样做如何改进我们的软件。
- en: We have had an overview of the TypeScript module system and the critically important
    `import` and `export` keywords. We wrote a lot of our own TypeScript code and
    learned how to test it with `ts-jest`.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们概述了TypeScript模块系统和至关重要的`import`和`export`关键字。我们编写了大量的TypeScript代码，并学习了如何使用`ts-jest`对其进行测试。
- en: Finally, we rounded out this chapter with a discussion of error handling. We'll
    look at more advanced error-handling techniques in *Chapters 12*, *Guide to Promises
    in TypeScript*, and *Chapter 13*, *Async Await in TypeScript*, when it comes to asynchronous programming.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过讨论错误处理来完善了本章内容。在异步编程方面，我们将更深入地探讨更高级的错误处理技术，包括在第12章“TypeScript中的Promise指南”和第13章“TypeScript中的Async
    Await”。
- en: We covered quite a few topics in this chapter, and most readers won't retain
    all of them immediately. That's OK! You have written a number of functions in
    this chapter and you'll write many more in chapters to come. Writing good functions
    is a skill that comes with practice and you'll be able to refer back to this chapter
    to check your learning as you progress in your mastery of TypeScript.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了相当多的主题，大多数读者可能不会立即记住所有内容。这没关系！你已经在本章中编写了许多函数，在接下来的章节中你还将编写更多。编写好的函数是一种随着实践而提高的技能，随着你在TypeScript掌握方面的进步，你将能够回过头来参考本章以检查你的学习情况。
- en: In the next chapter, we will further explore the object-oriented programming paradigm
    by studying the `class` keyword and how we can construct type-safe objects.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过研究`class`关键字以及如何构建类型安全的对象，进一步探索面向对象编程范式。
