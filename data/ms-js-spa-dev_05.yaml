- en: Chapter 5. Its All About the View
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 一切都关于视图
- en: The UI layer, or **View**, is the most visible component of any application.
    No matter what is going on underneath the hood, be it REST, Websockets, MQTT,
    or SOAP, the view is where everything culminates for a full, interactive application
    experience. Just as with the server side, the view has its own set of complexities
    and myriad of architectural choices to make from a development perspective. We
    will now explore some of these choices along with some different design patterns
    that can be used in the all-encompassing view layer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面层，或**视图**，是任何应用程序中最明显的组件。无论底层发生什么，无论是REST、Websockets、MQTT还是SOAP，视图都是所有内容汇聚以提供完整、交互式应用程序体验的地方。就像服务器端一样，视图有其自己的复杂性和从开发角度出发的众多架构选择。现在，我们将探讨一些这些选择以及可以在全面视图层中使用的不同设计模式。
- en: 'In this chapter, we will cover the following images:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: The differences among various JavaScript templating engines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的JavaScript模板引擎之间的差异
- en: The advantages of precompiling JavaScript templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预编译JavaScript模板的优势
- en: How to optimize your application layout
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何优化您的应用程序布局
- en: JavaScript templating engines
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript模板引擎
- en: Maintaining the view on the frontend of your application goes a long way toward
    keeping it server-side agnostic. Even if you are using a MVC framework underneath
    to serve REST endpoints for your application, keeping the view templates and logic
    on the frontend will ensure that you can more easily swap out the MVC backend
    in the future without significantly altering the logical and architectural structure
    of your application. JavaScript templating engines provide an effective way to
    manage view templates entirely on the frontend.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的前端维护视图对于保持其服务器端无关性大有裨益。即使您在底层使用MVC框架来为应用程序提供REST端点，保持前端视图模板和逻辑也将确保您可以在未来更容易地更换MVC后端，而不会显著改变应用程序的逻辑和架构结构。JavaScript模板引擎提供了一种有效的方法，可以在前端完全管理视图模板。
- en: 'There are many open source JavaScript templating engines available. Next, we
    will cover the basics of some of the more popular ones:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多开源JavaScript模板引擎可用。接下来，我们将介绍一些更受欢迎的模板引擎的基础知识：
- en: Underscore.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Underscore.js
- en: Mustache.js
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mustache.js
- en: Handlebars.js
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Handlebars.js
- en: Pure.js
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pure.js
- en: Pug
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pug
- en: EJS
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJS
- en: Underscore.js
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Underscore.js
- en: The **Underscore.js** library is well known for its useful JavaScript functional
    programming helpers and utility methods. One of those utility methods is `_.template()`.
    This method is used to compile strings with expressions into functions that replace
    those expressions with dynamic values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Underscore.js**库因其有用的JavaScript函数式编程辅助工具和实用方法而闻名。其中一种实用方法是`_.template()`。此方法用于将带有表达式的字符串编译成函数，这些函数用动态值替换那些表达式。'
- en: 'Underscore.js template syntax delimiters resemble those of the **ERB**, or
    **Embedded Ruby** template syntax, with an **equals** sign following the opening
    tag:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js模板的语法分隔符类似于**ERB**或**嵌入式Ruby**模板语法，在开标签后跟一个**等于**符号：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An Underscore.js template expression used within HTML looks like the preceding
    example. The variable name would be dynamically passed in to the compiled function
    for this template.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中使用的Underscore.js模板表达式看起来像前面的示例。变量名将动态传递给编译后的函数，用于此模板。
- en: 'The `_.template()` method can also be used to parse and execute arbitrary JavaScript
    code within a template. JavaScript code within Underscore.js templates is delimited
    by using the ERB style tags *without* an equals sign following the opening tag:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`_.template()`方法还可以用于在模板中解析和执行任意JavaScript代码。Underscore.js模板中的JavaScript代码使用ERB风格标签进行分隔，但开标签后不跟一个等于符号：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in this example, the ERB tags within the template give the script
    access to the global `_` object and allow it to iterate over a given object or
    array contained in that context or even up the scope chain from that context using
    the library's `_.each()` method. The fact that the script has access to the `_`
    object shows that any global variable attached to the `window` namespace is available
    to the script.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个示例中可以看到的，模板中的ERB标签使脚本能够访问全局`_`对象，并允许它使用库的`_.each()`方法遍历该上下文中包含的给定对象或数组，甚至可以从该上下文向上遍历作用域链。脚本对`_`对象的访问表明，任何附加到`window`命名空间的全局变量都对脚本可用。
- en: Giving templates the ability to execute arbitrary JavaScript code is a subject
    that has met with much debate in the community, and the general consensus is that
    the practice is frowned upon. This is due to the lessons learned from other web
    scripting languages, such as PHP.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 给模板赋予执行任意JavaScript代码的能力，在社区中引发了广泛的讨论，普遍的看法是这种做法是不被提倡的。这主要是因为从其他网络脚本语言，如PHP中吸取的教训。
- en: Mixing code for dynamic business logic with HTML directly in your templates
    can lead to a codebase that is difficult to maintain and debug by other developers
    and future generations. This type of code also violates the principles of MVC
    and MVW architectural patterns. It should go without saying that it is up to the
    developer writing the code how much or how little business logic they choose to
    include in their templates, but for the creators of many JavaScript templating
    engines, leaving that door open was not an option. For these reasons, the concept
    of *logic-less* templates was born.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将动态业务逻辑的代码与HTML直接混合在模板中，可能会导致代码库难以维护和调试，其他开发人员和未来几代人也会遇到困难。这种类型的代码也违反了MVC和MVW架构模式的原则。不言而喻，开发者编写代码时，选择在模板中包含多少或多少业务逻辑取决于他们自己，但许多JavaScript模板引擎的创造者认为，打开这扇门并不是一个选择。因此，*无逻辑*模板的概念应运而生。
- en: You can learn more about Underscore.js at `underscorejs.org`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`underscorejs.org`了解更多关于Underscore.js的信息。
- en: Mustache.js
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mustache.js
- en: '**Mustache.js** is an implementation of the popular **Mustache template system**
    for JavaScript templating. Mustache touts itself as a *logic-less* template syntax.
    The idea behind this concept is not necessarily to have templates completely void
    of logic, but more to discourage the practice of including a large amount of business
    logic within your templates.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mustache.js**是流行的**Mustache模板系统**在JavaScript模板中的实现。Mustache自诩为一种*无逻辑*的模板语法。这个概念背后的想法并不是要使模板完全没有逻辑，而是更多地劝阻在模板中包含大量业务逻辑的做法。'
- en: Mustache gets its name from the use of double curly braces, which resemble the
    shape of a mustache, as the default delimiter tags for templates. The major difference
    between Mustache templates and Underscore.js templates is that Mustache does not
    allow for the placement of arbitrary JavaScript within an alternate form of its
    tags; it only allows for expressions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache的名字来源于使用双大括号作为模板的默认分隔符标签，这些大括号形状类似于胡须。Mustache模板与Underscore.js模板的主要区别在于，Mustache不允许在标签的另一种形式中放置任意JavaScript代码；它只允许使用表达式。
- en: 'In its simplest form, a Mustache template maps values from a JavaScript object
    directly to their respective template expressions, represented by the keys for
    those object values. Take an object such as the one shown here, for example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，Mustache模板将JavaScript对象中的值直接映射到相应的模板表达式，这些表达式由对象值的键表示。以这里显示的示例对象为例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The values from this object can be represented in a Mustache template like
    this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象中的值可以用以下方式表示在Mustache模板中：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, you can see that even nested object values can be accessed
    by using JavaScript dot notation, as shown with `{{name.first}}` and `{{name.last}}`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到，即使嵌套对象值也可以通过使用JavaScript点表示法来访问，如`{{name.first}}`和`{{name.last}}`所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Sections
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分
- en: Mustache templates also include the ability to render *sections*, or *blocks
    of text*. This involves using an alternate expression syntax that includes an
    opening and closing tag syntax. How a section is rendered depends on the value
    of the key being called for it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache模板还包括渲染*部分*或*文本块*的能力。这涉及到使用包含开标签和闭标签语法的替代表达式语法。一个部分如何渲染取决于被调用的键的值。
- en: Boolean values
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'Given a Boolean value, a section will render or not render depending on if
    that Boolean is `true` or `false`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个布尔值，一个部分将根据该布尔值是`true`还是`false`来渲染或不渲染：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The delimiter syntax for sections consists of opening curly braces followed
    by the pound `#` symbol and the name of the property to start the section, and
    closing curly braces followed by the `/` symbol and the property name to end the
    section. This syntax is similar to HTML opening and closing tags:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 部分的分隔符语法由开有大括号、后跟井号`#`符号和用于开始部分的属性名，以及闭有大括号、后跟斜杠`/`符号和用于结束部分的属性名组成。这种语法与HTML的打开和关闭标签类似：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, the `email_subscriber` property is set to false, so the template
    would render the following HTML:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`email_subscriber`属性被设置为false，因此模板将渲染以下HTML：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Essentially, the use of a section with a Boolean value is equivalent to an `if`
    conditional statement. Such a use case does indeed include logic, though in its
    most basic form. In this way, the term *logic-less* is proven to not be as stringent
    as it may initially be perceived.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，使用具有布尔值的部分等同于一个`if`条件语句。这种用法确实包括逻辑，尽管它是最基本的形式。这样，*无逻辑*这个术语被证明并不像最初感知的那样严格。
- en: Lists
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'Additionally, sections can be used to iterate over a list of items set as the
    value for a given object key. Within a section, the context, or variable scope,
    is shifted to that of the key that is being iterated over. Take the following
    parent key and corresponding list of values, for example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，部分可以用来遍历作为给定对象键值的列表项。在部分内部，上下文或变量作用域将转移到正在迭代的键上。以下是一个父键及其对应值列表的例子：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Given a list of people and their names, a section can be used to render each
    person''s name in an HTML unordered list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个包含人和他们名字的列表，可以使用一个部分来将每个人的名字渲染为HTML无序列表：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This template code would render the following HTML, given the preceding example
    object:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 给定前面的示例对象，此模板代码将渲染以下HTML：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lambdas
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda
- en: 'Object property values can also be returned from *lambdas*, or functions that
    are passed to return values as data, to the current section''s context:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对象属性值也可以从*lambda*或函数中返回，这些函数作为数据传递回当前部分的上下文：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the case of a list, a lambda will return a value based on the context of
    the current list item for an iteration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的情况下，lambda将基于当前列表项的上下文返回一个值，用于迭代：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this manner, the preceding template will produce the same output as the
    previous example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，前面的模板将产生与上一个示例相同的输出：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Inverted sections
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 倒置部分
- en: 'An inverted section in a Mustache template is one that is rendered only when
    the value for that section''s key is `false` or *falsy*, such as `null`, `undefined`,
    `0`, or an empty list `[]`. Take the following object, for example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache模板中的倒置部分是在该部分的键值是`false`或*假值*时才渲染的，例如`null`、`undefined`、`0`或一个空列表`[]`。以下是一个对象的例子：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'An inverted section begins with a caret `^` symbol following the opening curly
    braces, rather than the pound `#` symbol used for a standard section. Given the
    preceding example object, the following template syntax can be used to render
    HTML for the `false` property value:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 倒置部分以一个反引号`^`符号开头，而不是用于标准部分的井号`#`符号。给定前面的示例对象，以下模板语法可以用来渲染`false`属性值的HTML：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This template would render the following HTML, based on the `false` property
    value in the object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据对象中的`false`属性值，此模板将渲染以下HTML：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Comments
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'Mustache templates also give you the ability to include comments within your
    templates. The advantage to using the Mustache syntax for your comments over HTML
    comments is that they will not be rendered in the HTML output, as would be the
    case with standard HTML comments:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache模板还允许您在模板中包含注释。使用Mustache语法而不是HTML注释的优点是，它们不会被渲染到HTML输出中，就像标准HTML注释那样：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Mustache comments are denoted by a *bang*, or exclamation point, following
    the opening curly braces. The preceding template code would render the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache注释由一个*感叹号*或感叹号紧跟在开括号之后表示。前面的模板代码将渲染以下内容：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As shown, the Mustache template comment is not part of the rendered HTML, but
    the standard HTML comment is. The advantage to using Mustache template comments
    is in the payload size of the rendered HTML, which you want to keep as small as
    possible, and there are probably not many cases in which you would actually want
    to render comments in dynamic HTML. This allows you to have helpful comments for
    other developers in your template code without it putting a burden on the frontend
    of the application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，Mustache模板注释不是渲染的HTML的一部分，但标准的HTML注释是。使用Mustache模板注释的优势在于渲染的HTML的负载大小，您希望将其保持尽可能小，并且可能没有很多情况您实际上想要在动态HTML中渲染注释。这允许您在模板代码中为其他开发者提供有用的注释，而不会给应用程序的前端带来负担。
- en: Partials
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分
- en: One of the most useful features of Mustache templates is the ability to include
    *partials*, or separate templates rendered at runtime within a compiled template.
    Conceptually, this feature is similar to *includes* for server-side template languages.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache模板中最有用的功能之一是能够在编译的模板中包含*部分*，或在运行时渲染的单独模板。从概念上讲，这个功能与服务器端模板语言的*包含*类似。
- en: 'The syntax for partials uses a greater than `>` sign after the opening curly
    braces followed by the name of the partial. A common file naming convention is
    to prepend the uncompiled partial filenames with an underscore `_.` Consider the
    following two files:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 部分的语法在开有大括号 `>` 符号后跟部分名称。一个常见的文件命名约定是在未编译的部分文件名前加上下划线 `_`。考虑以下两个文件：
- en: '`user.hbs`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`user.hbs`'
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`_user-details.hbs`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`_user-details.hbs`'
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The call to include the partial file is indicated on the second line of user.hbs.
    This will parse _user-details.hbs in the same context as user.hbs. In a standard
    compiler setup, the underscore on the partial filename would be excluded from
    the key name, and the template would be stored within the partials namespace:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 user.hbs 的第二行指示了包含部分文件的调用。这将解析与 user.hbs 相同上下文中的 _user-details.hbs。在标准的编译器设置中，部分文件名中的下划线会被排除在键名之外，模板将存储在部分命名空间内：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Given the preceding example object, the fully rendered HTML from the template
    would look like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 给定前面的示例对象，模板完全渲染的 HTML 将看起来像以下内容：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see in the example, the key names from the object were used directly
    in the partial from the same context as the parent template.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，对象中的键名直接用于与父模板相同上下文的部分。
- en: Set alternative delimiters
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置替代定界符
- en: 'One of the more unusual features of Mustache templates is the ability to set
    *alternative* delimiters from inside standard Mustache delimiter tags in a template.
    This is done by using an equals sign `=` following the opening standard delimiter
    tags, inserting the new opening delimiter followed by the new closing delimiter,
    and an equals sign followed by the standard closing delimiter tags:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache 模板的一个较不寻常的特性是能够在模板内部的标准 Mustache 定界符标签中设置*替代*定界符。这是通过在开有大括号定界符后跟一个等号
    `=`，插入新的开定界符，然后是新的闭定界符，以及一个等号后跟标准闭定界符标签来完成的：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this code is placed anywhere inside of a Mustache template, the delimiter
    tags from below that point will then use the new syntax:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码放在 Mustache 模板的任何地方，那么下面的定界符标签将使用新的语法：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Given the preceding object, a template could be constructed using that data
    combined with alternative delimiter tags for parsing it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 给定前面的对象，可以使用该数据结合替代定界符标签来构建模板：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, the standard tags are used once, then the set delimiters feature
    is used to change the tags to use the ERB style delimiters, then the tags are
    again changed back to the original standard delimiters:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，标准标签使用了一次，然后使用集合定界符功能将标签更改为使用 ERB 风格的定界符，然后标签再次更改为原始的标准定界符：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The resulting HTML would look like the preceding code, rendered with two entirely
    different sets of delimiters inside of one template.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 HTML 将看起来像前面的代码，在一个模板中使用两组完全不同的定界符。
- en: You can learn more about Mustache.js at [github.com/janl/mustache.js](http://github.com/janl/mustache.js),
    or learn about the original Mustache templates at [mustache.github.io](http://mustache.github.io).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [github.com/janl/mustache.js](http://github.com/janl/mustache.js) 上了解更多关于
    Mustache.js 的信息，或者了解原始的 Mustache 模板在 [mustache.github.io](http://mustache.github.io)。
- en: Handlebars.js
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Handlebars.js
- en: Handlebars.js templates are also considered *logic-less* and are largely based
    on Mustache templates, but provide some additional features. They also exclude
    some of the features of Mustache templates that the creators did not consider
    useful.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars.js 模板也被认为是*无逻辑*的，并且主要基于 Mustache 模板，但提供了一些额外的功能。它们还排除了 Mustache 模板中一些创建者认为不实用的功能。
- en: Handlebars is one of the more prominent templating engines in the JavaScript
    community. It is used by several major open source JavaScript frameworks including
    Backbone.js, Ember.js, and the popular Meteor.js framework. It uses their own
    reactive flavor of Handlebars templating engine called Spacebars. Due to its popularity,
    we will cover Handlebars in a bit more depth here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 是 JavaScript 社区中较突出的模板引擎之一。它被包括 Backbone.js、Ember.js 和流行的 Meteor.js
    框架在内的几个主要开源 JavaScript 框架所使用。它使用自己的反应式 Handlebars 模板引擎，称为 Spacebars。由于其流行，我们将在下面更深入地介绍
    Handlebars。
- en: Explicit path lookup versus recursive path lookup
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式路径查找与递归路径查找
- en: 'One of the features that differentiates Handlebars templates from Mustache
    templates is that Handlebars does not support recursive path lookup as Mustache
    templates do. This concerns sections, or blocks, as they are referred to in Handlebars.
    When you are in the context of a child property of an object, Handlebars will
    not automatically look up the scope chain for an expression reference. Instead,
    you must explicitly define the path to the scope for the variable that you are
    looking for. This makes the scope in Handlebars templates more meaningful and
    understandable:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 模板与 Mustache 模板区分开来的一个特性是，Handlebars 不支持递归路径查找，正如 Mustache 模板所做的那样。这涉及到
    Handlebars 中的“部分”或“块”。当你处于对象子属性上下文时，Handlebars 不会自动查找作用域链中的表达式引用。相反，你必须显式定义你要查找的变量的路径。这使得
    Handlebars 模板中的作用域更有意义和可理解：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Given this object, the following template syntax would work with Mustache templates:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 给定此对象，以下模板语法将适用于 Mustache 模板：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This template would render the value for the `profession` key inside of the
    block scope for `#profession` because Mustache supports recursive path lookup.
    In other words, a nested context always has access to variables on the parent
    context above it. This is not the case by default, however, with Handlebars:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板将渲染 `#profession` 块作用域内 `profession` 键的值，因为 Mustache 支持递归路径查找。换句话说，嵌套上下文始终可以访问其上方的父上下文中的变量。然而，Handlebars
    默认情况下并不是这样：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As shown in this example, the `this` keyword is used to reference the variable
    for which the current block context is set. If the `profession` variable itself
    were referenced, this would throw an error in Handlebars.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，`this` 关键字用于引用当前块上下文设置的变量。如果直接引用 `profession` 变量，这将在 Handlebars 中引发错误。
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Additionally, Handlebars can look up the scope chain for a variable with an
    **explicit path** reference using the `../` syntax shown in the preceding code.
    This syntax mimics that of recursive file path lookups in command-line interfaces.
    In this example, the `../profession` reference simply looks up the variable for
    which the current block context is set:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Handlebars 可以使用前面代码中显示的 `../` 语法通过**显式路径**引用查找作用域链中的变量。这种语法模仿了命令行界面中递归文件路径查找的方式。在这个例子中，`../profession`
    引用简单地查找当前块上下文设置的变量：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The reason Handlebars does not support recursive path lookup by default is for
    speed. By limiting the path lookup to the current block context, Handlebars templates
    can render more quickly. A compile time `compat` flag is provided to override
    this functionality and allow recursive path lookups, but the creators of Handlebars
    advise against this and note that there is a performance cost in doing this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 默认不支持递归路径查找的原因是为了提高速度。通过将路径查找限制在当前块上下文中，Handlebars 模板可以更快地渲染。提供了一个编译时
    `compat` 标志来覆盖此功能并允许递归路径查找，但 Handlebars 的创建者建议不要这样做，并指出这样做会有性能成本。
- en: Helpers
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助函数
- en: 'Handlebars templates do not support the use of lambdas defined in objects such
    as Mustache templates, but instead use helpers for added functionality. Helpers
    in Handlebars are a way to abstract away view logic that might otherwise be done
    directly in the templates when using a less restrictive templating engine such
    as Underscore.js. Instead, you can write a helper in the form of a regular JavaScript
    function, register it on the Handlebars namespace, and in your template, use it
    as a single expression or a block expression:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 模板不支持 Mustache 模板中定义的 lambda 表达式，而是使用辅助函数来增加功能。Handlebars 中的辅助函数是一种将视图逻辑抽象化的方式，这些逻辑在其他情况下可能直接在模板中完成，尤其是在使用限制较少的模板引擎（如
    Underscore.js）时。相反，你可以编写一个以常规 JavaScript 函数形式存在的辅助函数，将其注册到 Handlebars 命名空间中，并在模板中使用它作为一个单独的表达式或块表达式：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Given this example object, a helper can be written to return the user''s full
    name based on the object properties:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 给定此示例对象，可以编写一个辅助函数来根据对象属性返回用户的完整姓名：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As shown here, the `Handlebars` object provides a `registerHelper` method that
    gives you the ability to define a helper by defining the name as the first argument
    and a lambda as the second argument. Arguments to the lambda can be provided directly
    from the template context at the point the helper is invoked; in this case, as
    an expression:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，`Handlebars` 对象提供了一个 `registerHelper` 方法，它允许你通过定义第一个参数为名称，第二个参数为 lambda
    表达式来定义一个辅助函数。lambda 表达式的参数可以直接从模板上下文中在辅助函数被调用的点提供；在这种情况下，作为一个表达式：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The syntax for the helper, as shown in the preceding example, uses the name
    of the helper immediately following the opening Handlebars tags followed by any
    arguments to be passed to the helper; in this case, the `name` argument:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，辅助函数的语法使用辅助函数的名称紧随 Handlebars 开启标签之后，后跟传递给辅助函数的任何参数；在这种情况下，是 `name` 参数：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The template would then be rendered as HTML with the full name returned from
    the helper by passing the required object property from the template context.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 模板随后将作为 HTML 渲染，显示从辅助函数返回的完整名称，这是通过从模板上下文中传递所需的对象属性来实现的。
- en: Helpers as block expressions
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 辅助函数作为块表达式
- en: Handlebars templates use block expression syntax to invoke helpers as well.
    The context for the block expression, however, is entirely dependent upon the
    way the helper is written. Several built-in block helpers are provided with Handlebars.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 模板使用块表达式语法来调用辅助函数。然而，块表达式的上下文完全取决于辅助函数的编写方式。Handlebars 提供了几个内置的块辅助函数。
- en: '#if block helper'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`#if` 块辅助函数'
- en: A simple `#if` block helper is provided with Handlebars for rendering content
    or not based on Boolean values or truthy versus falsy value resolution. This means
    that values such as `0`, `null`, `undefined`, and empty lists `[]` will resolve
    as false.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 提供了一个简单的 `#if` 块辅助函数，用于根据布尔值或真值与假值解析来渲染内容或不渲染内容。这意味着像 `0`、`null`、`undefined`
    和空列表 `[]` 这样的值将被解析为假。
- en: 'Consider the following object:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下对象：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Rather than using the standard Mustache style section implementation, the `#if`
    helper can be invoked on a Boolean value here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用标准的 Mustache 风格部分实现，这里的 `#if` 辅助函数可以用于布尔值：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This template would not render the portion inside of the `#if` block because
    `email_subscriber` is `false`. The built-in `#if` helper also provides the ability
    to include an `{{else}}` section within the `#if` block that will render if the
    passed variable evaluates to `false`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板不会渲染 `#if` 块内的部分，因为 `email_subscriber` 是 `false`。内置的 `#if` 辅助函数还提供了在 `#if`
    块内包含 `{{else}}` 部分的选项，如果传递的变量评估为 `false`，则将渲染该部分：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Given the example object, this template would render the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 给定示例对象，此模板将渲染以下内容：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Another difference between the `#if` helper in Handlebars and a section in Mustache
    templates is that the context inside of the `#if` helper does not change, whereas
    the context inside of a section is changed to the object property for which it
    is called.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 中的 `#if` 辅助函数与 Mustache 模板中的部分之间的另一个区别是，`#if` 辅助函数内的上下文不会改变，而部分内的上下文会改变为被调用的对象属性。
- en: '#unless block helper'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`#unless` 块辅助函数'
- en: 'The `#unless` block helper in Handlebars is similar to the inverted section
    feature in Mustache templates, and it can also be considered the inverse of the
    Handlebars `#if` helper. If the value passed to the `#unless` helper is falsy,
    the block will be rendered:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 中的 `#unless` 块辅助函数类似于 Mustache 模板中的反转部分功能，也可以被认为是 Handlebars `#if`
    辅助函数的反面。如果传递给 `#unless` 辅助函数的值是假的，则该块将被渲染：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Consider a template similar to the previous `#if` example and based on the
    preceding object:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个类似于先前 `#if` 示例的模板，并基于前面的对象：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This template would render the content inside of the `#unless` block because
    the value of `email_subscriber` is `false`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板将渲染 `#unless` 块内的内容，因为 `email_subscriber` 的值为 `false`：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '#each block helper'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`#each` 块辅助函数'
- en: 'The `#each` block helper is used to iterate over both lists and objects. In
    its most basic form, it works just like a Mustache section in the context of a
    list, but it has additional features that make it much more powerful:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`#each` 块辅助函数用于遍历列表和对象。在其最基本的形式中，它就像在列表上下文中使用 Mustache 部分，但它具有额外的功能，使其功能更强大：'
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `#each` context for a list, the `this` keyword can be used to refer
    to the current value in the list:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的 `#each` 上下文中，可以使用 `this` 关键字来引用列表中的当前值：
- en: '[PRE44]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is similar to the lambda example of iteration for Mustache templates, except
    that no lambda property value is needed to access the iterated object properties
    in this case.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Mustache 模板的迭代 lambda 示例类似，但在此情况下不需要 lambda 属性值来访问迭代的对象属性。
- en: 'Since the scope for each iteration is constrained to the object that is currently
    being iterated over in this example, the preceding template could also be more
    simply written as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在此示例中，每个迭代的范围都限制在当前正在迭代的对象上，因此前面的模板也可以更简单地写成以下形式：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, the `this` keyword is not necessary to access the properties
    for each object since the context for each iteration is set to that object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于每个迭代的上下文都设置为该对象，因此不需要`this`关键字来访问每个对象的属性。
- en: '#with block helper'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`#with`块辅助函数'
- en: 'The `#with` block helper works much like a standard section in Mustache templates
    by constraining the context of the current block to the parent key that is passed
    in:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`#with`块辅助函数的工作方式与Mustache模板中的标准部分非常相似，通过将当前块的上下文限制为传入的父键：'
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Given this example object, a template can be constructed using the `#with`
    helper to constrain a block to the context of the `name` key:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个示例对象，可以使用`#with`辅助函数来限制一个块到`name`键的上下文中来构建一个模板：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This template would render the following HTML:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板将渲染以下HTML：
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Other differences in Handlebars from Mustache templates
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Handlebars与Mustache模板的其他差异
- en: Many of the features in Handlebars.js that differentiate it from Mustache.js
    are designed to make the templates render more quickly in a browser. One of the
    main features in Handlebars that allows this is the ability to precompile templates,
    as we covered in [Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars.js中的许多功能都是为了让模板在浏览器中渲染得更快而设计的，这些功能使Handlebars.js与Mustache.js区分开来。Handlebars中允许这一点的其中一个主要功能是预编译模板，正如我们在[第2章](ch02.html
    "第2章。模型-视图-任意")中讨论的，“模型-视图-任意”。
- en: Precompiling templates
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预编译模板
- en: Precompiling the templates converts them to the JavaScript functions that are
    normally compiled in an application before rendering with other templating engines.
    Using this feature increases the speed of an application by skipping that step,
    and it additionally reduces the load on the browser for the application because
    the JavaScript compiler does not need to be included in the frontend asset payload.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 预编译模板将它们转换为在渲染之前通常在应用程序中编译的JavaScript函数。使用此功能通过跳过该步骤来提高应用程序的速度，并且它还减少了浏览器对应用程序的负载，因为JavaScript编译器不需要包含在前端资产负载中。
- en: No alternative delimiters
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有替代分隔符
- en: The creators of Handlebars also decided that the ability to set alternative
    delimiters within a template is not necessary. This further reduces the asset
    payload for an application if you are not precompiling your templates.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars的创建者还决定，在模板内设置替代分隔符的能力并非必要。如果你没有预先编译你的模板，这将进一步减少应用程序的资产负载。
- en: Usually, the only reason you would want to change the delimiter style for templates,
    other than personal preference, is to avoid conflicts with another templating
    language, for example, a server-side templating language that uses the same delimiters.
    If you were to include your Handlebars templates inside of JavaScript blocks within
    a server-side template, this issue would materialize. If you precompile your templates
    or abstract them from your server-side templates by keeping them in their own
    external JavaScript files, however, that issue can be avoided entirely and there
    is no need to set alternative delimiters.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，除了个人偏好之外，你想要更改模板分隔符样式的唯一原因是为了避免与其他模板语言的冲突，例如，使用相同分隔符的服务器端模板语言。如果你要在服务器端模板中的JavaScript块内包含Handlebars模板，这个问题就会出现。然而，如果你预先编译你的模板或者通过将它们保存在自己的外部JavaScript文件中从服务器端模板中抽象它们，那么这个问题可以完全避免，并且不需要设置替代分隔符。
- en: You can learn more about Handlebars.js at `handlbarsjs.com`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`handlbarsjs.com`了解更多关于Handlebars.js的信息。
- en: Pure.js
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pure.js
- en: Pure.js is a JavaScript templating engine that takes the concept of logic-less
    templates to an even greater extreme than Mustache and Handlebars do. Pure.js
    uses no special template expression syntax that has to be interpolated before
    rendering. Instead, it uses only pure HTML tags and CSS selectors, combined with
    JSON data, to render values in the DOM. In this way, Pure.js uses entirely logic-less
    views because there is no template markup in which to include any logic.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Pure.js是一个JavaScript模板引擎，它将无逻辑模板的概念推向了比Mustache和Handlebars更极端的程度。Pure.js不使用在渲染之前必须插值的特殊模板表达式语法。相反，它仅使用纯HTML标签和CSS选择器，结合JSON数据，在DOM中渲染值。因此，Pure.js使用完全无逻辑的视图，因为没有模板标记可以包含任何逻辑。
- en: Markup
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记
- en: 'Using plain HTML, a simple Pure.js template can be constructed like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯HTML，一个简单的Pure.js模板可以构建如下：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The empty `<span>` element is where you might add data for a particular template,
    but you can use any HTML tag.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 空的`<span>`元素是你可以为特定模板添加数据的地方，但你可以使用任何HTML标签。
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this example, we provide the data for the template in the `data` variable,
    and then provide what is called a `directive` that tells the templating engine
    how to map that data:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 `data` 变量中提供了模板的数据，然后提供了一个所谓的 `directive`，它告诉模板引擎如何映射这些数据：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Pure.js provides a global `$p` object upon which methods for interacting with
    templates are available. In this case, we are calling the `render()` method and
    passing the `data` and the `directive` as the arguments:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Pure.js 在全局范围内提供了一个 `$p` 对象，该对象提供了与模板交互的方法。在这种情况下，我们调用 `render()` 方法，并将 `data`
    和 `directive` 作为参数传递：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This would be the rendered result of this simple example. You can learn more
    about Pure.js at `beebole.com/pure/.`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是这个简单示例的渲染结果。您可以在 `beebole.com/pure/.` 上了解更多关于 Pure.js 的信息。
- en: Pug
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pug
- en: Pug, formally named Jade, is a JavaScript templating engine that is prominent
    in the Node.js community. It is largely influenced by **HTML abstraction markup
    language** (**Haml**), which was originally designed to make authoring ERB templates
    easier by using a cleaner and less verbose syntax than raw HTML. In this way,
    Pug requires the compilation of not only its expressions, but of the markup language
    itself.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Pug，正式名称为 Jade，是一个在 Node.js 社区中非常突出的 JavaScript 模板引擎。它主要受到 **HTML 抽象标记语言**（**Haml**）的影响，最初设计用来通过使用比原始
    HTML 更简洁、更简洁的语法来简化 ERB 模板的编写。因此，Pug 需要编译其表达式，以及标记语言本身。
- en: 'Pug is similar to YAML in that hierarchy is denoted by whitespace with indentation
    for delimiters. This means that no closing element tags are necessary:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Pug 与 YAML 类似，其层次结构通过缩进来表示，定界符使用空格。这意味着不需要关闭元素标签：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As shown in this example, Pug can be used as a simple shorthand syntax for
    HTML. It can also include simple conditionals with variables, all following the
    same fluid syntax. HTML element attributes are added by including parenthesis
    after the tag name with the attributes defined inside them, such as `html(lang="en")`
    in the example. Elements populated with variables are indicated by placing an
    equals sign after the tag name and following it with a JavaScript key name, as
    shown by `title= pageTitle` in the example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，Pug 可以用作 HTML 的简单缩写语法。它还可以包含带有变量的简单条件，所有这些都遵循相同的流畅语法。通过在标签名后包含括号并定义属性，可以添加
    HTML 元素属性，例如示例中的 `html(lang="en")`。用变量填充的元素通过在标签名后放置等号并跟随 JavaScript 键名来表示，如示例中的
    `title= pageTitle` 所示：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Using this example JavaScript object, the preceding template would render the
    following HTML:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个示例 JavaScript 对象，前面的模板将渲染以下 HTML：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Inline variables can also be used with another syntax that allows for accessing
    top level properties and nested properties. Consider the following object:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 内联变量还可以使用另一种语法，允许访问顶层属性和嵌套属性。考虑以下对象：
- en: '[PRE56]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A Pug template can be written to access all variables in this object as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Pug 模板可以编写来访问这个对象中的所有变量，如下所示：
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this template, you can see that the inline variable syntax `#{}` is used
    along with a conditional and an element populated with a variable using the `=`
    syntax.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，您可以看到使用了内联变量语法 `#{}`，以及一个条件和用 `=` 语法填充变量的元素。
- en: 'You will also notice that the `h1` tag has a `#` symbol immediately following
    it with the word `title`, and the `h2` tags have .`className` following them.
    This demonstrates another feature of Pug which allows the use of standard CSS
    selector syntax to include IDs and classes. The rendered HTML from this template
    would look as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到，`h1` 标签后面紧跟着一个 `#` 符号和单词 `title`，而 `h2` 标签后面跟着 `.className`。这展示了 Pug
    的另一个特性，它允许使用标准的 CSS 选择器语法来包含 ID 和类。从这个模板渲染的 HTML 将如下所示：
- en: '[PRE58]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This example shows how much less verbose writing with Pug can be compared to
    standard HTML combined with another type of template syntax, and that is probably
    the reason it has become so popular. You can learn more about Pug at [pug-lang.com](http://pug-lang.com).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了使用 Pug 编写比标准 HTML 结合另一种模板语法更简洁的写作方式，这可能是它变得如此受欢迎的原因。您可以在 [pug-lang.com](http://pug-lang.com)
    上了解更多关于 Pug 的信息。
- en: Embedded JavaScript (EJS)
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式 JavaScript (EJS)
- en: '**EJS** is a JavaScript templating engine that works much like Underscore.js
    and also uses ERB `<% %>` style delimiters. Alternatively, it also allows the
    use of `[% %]` style tags for delimiters.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**EJS** 是一个类似于 Underscore.js 的 JavaScript 模板引擎，它也使用 ERB `<% %>` 样式的定界符。或者，它还允许使用
    `[% %]` 样式的标签作为定界符。'
- en: Just like Underscore.js, EJS allows arbitrary JavaScript to be parsed when used
    with the standard `<% %>` ERB style syntax, and allows the evaluation of expressions
    using an equals sign `=` following the opening delimiter tag `<%= %>:`
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Underscore.js 一样，EJS 允许在使用标准 `<% %>` ERB 风格语法时解析任意 JavaScript，并允许使用等于号 `=`
    后跟开标签 `<%= %>` 来评估表达式：
- en: '[PRE59]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This template can be used to iterate over a list of objects from which key
    names are evaluated as variables with different values:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板可用于遍历一个对象列表，其中键名作为具有不同值的变量进行评估：
- en: '[PRE60]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Iterating over this object with the example template would render the following
    HTML:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用示例模板遍历此对象将渲染以下 HTML：
- en: '[PRE61]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Synchronous template loading
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步模板加载
- en: In a typical EJS use case, each template is stored in a file with the proprietary
    `.ejs` extension. A template is compiled from JavaScript code by creating a new
    `EJS` object, supplying the path to the template file, and calling the render
    method with the data you want to be interpolated.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 EJS 用例中，每个模板都存储在一个具有专有 `.ejs` 扩展名的文件中。通过创建一个新的 `EJS` 对象，提供模板文件的路径，并使用要插入的数据调用渲染方法，从
    JavaScript 代码编译模板。
- en: 'Let''s assume the EJS template is saved in a file located in your project at
    `templates/people.ejs`. The following JavaScript could then be written to render
    it as the HTML shown for this example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 EJS 模板保存在您项目中的一个文件中，文件名为 `templates/people.ejs`。然后可以编写以下 JavaScript 代码来将其渲染为示例中显示的
    HTML：
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The global `EJS` object is a constructor for which you create a new instance
    to parse a template and call methods on it for rendering. Note that since the
    path to the file is referenced in the JavaScript, a *synchronous* call must be
    made to initially load the template for parsing. This keeps the initial page load
    for your application low, but can lead to longer response times when interacting
    with your app, depending upon both the complexity of the template being loaded
    and the speed of the server upon which your app is running.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 全局 `EJS` 对象是一个构造函数，您可以通过创建一个新实例来解析模板，并对其调用方法进行渲染。请注意，由于文件路径在 JavaScript 中被引用，必须进行
    *同步* 调用来最初加载模板以进行解析。这保持了您应用程序初始页面加载的低延迟，但可能会根据加载的模板的复杂性和应用程序运行的服务器速度导致交互时的响应时间更长。
- en: 'Once you have the rendered HTML created in your JavaScript code, you simply
    insert it into the DOM in your application:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在您的 JavaScript 代码中创建了渲染后的 HTML，您只需将其插入到应用程序的 DOM 中：
- en: '[PRE63]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Asynchronous data loading
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步数据加载
- en: 'One unique feature of EJS is the ability to render a template using asynchronous
    data loaded from an external source. Using the previous example, imagine the JSON
    data is in an external file named `people.json`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: EJS 的一个独特功能是能够使用从外部源异步加载数据来渲染模板。使用前面的示例，假设 JSON 数据在一个名为 `people.json` 的外部文件中：
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example, the `.update()` method is called instead of `.render()`. The
    object instance is also not assigned to a variable because the DOM insertion is
    handled by the `.update()` method as well by passing a DOM node ID. For this method
    to work, no other CSS selectors can be used for injecting the HTML into the DOM;
    only an ID will work.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，调用的是 `.update()` 方法而不是 `.render()`。对象实例也没有被分配给变量，因为 DOM 插入由 `.update()`
    方法以及通过传递 DOM 节点 ID 来处理。为了使此方法工作，不能使用其他 CSS 选择器来将 HTML 注入 DOM；只有 ID 才有效。
- en: Caching
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: EJS caches templates by default after the first time they are loaded synchronously.
    This provides an advantage in that templates used multiple times will always load
    more quickly after the first request, and unused templates will not take up any
    memory. This approach is in stark contrast to precompiling in which all templates
    are loaded into memory at the initial page load of the application. Both of these
    approaches have advantages and disadvantages, so care must be taken to choose
    the best approach for your particular app.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: EJS 默认在模板首次同步加载后缓存模板。这提供了一个优势，即多次使用的模板在第一次请求之后将始终加载得更快，而未使用的模板不会占用任何内存。这种方法与在应用程序初始页面加载时将所有模板加载到内存中的预编译方法形成鲜明对比。这两种方法都有优缺点，因此必须仔细选择最适合您特定应用程序的最佳方法。
- en: 'Caching can be also be turned off for any template by including a `cache` key
    in the object of options passed into any template instantiation:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在传递给任何模板实例化的选项对象中包含一个 `cache` 键来关闭任何模板的缓存：
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: View helpers
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图辅助函数
- en: EJS includes some view helpers that are similar to the concept of helpers in
    Handlebars templates. They allow the use of shorter syntax for some common HTML
    elements. We will illustrate a few examples here.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: EJS 包含一些与 Handlebars 模板中辅助函数概念类似的视图辅助函数。它们允许使用更短的语法来表示一些常见的 HTML 元素。以下我们将展示几个示例。
- en: The link_to view helper
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: link_to 视图辅助函数
- en: 'The `link_to` view helper provides a simple template syntax for insuring HTML
    hyperlinks:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`link_to` 视图辅助函数提供了一个简单的模板语法，以确保 HTML 超链接：'
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The first parameter to the `link_to` view helper is the displayed text for
    the link, and the second parameter is the path to be passed to the `href` attribute
    for the link. Also notice that the delimiters for view helpers use the opening
    expression delimiter syntax. This example would render the following HTML:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`link_to` 视图辅助函数的第一个参数是链接的显示文本，第二个参数是要传递给链接的 `href` 属性的路径。注意，视图辅助函数的定界符使用的是开表达式定界符语法。以下示例将渲染以下
    HTML：'
- en: '[PRE67]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The img_tag view helper
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: img_tag 视图辅助函数
- en: 'This `img_tag` view helper provides an easy syntax for including images in
    your rendered HTML:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `img_tag` 视图辅助函数提供了一个在渲染的 HTML 中包含图像的简单语法：
- en: '[PRE68]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The first parameter to the `link_to` view helper is the path to the image,
    and the second parameter is the text for the image''s `alt` attribute. This example
    would render the following HTML:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`link_to` 视图辅助函数的第一个参数是图像的路径，第二个参数是图像的 `alt` 属性的文本。以下示例将渲染以下 HTML：'
- en: '[PRE69]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The form_tag view helper
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: form_tag 视图辅助函数
- en: 'The `form_tag` view helper provides a syntax for building HTML forms and can
    be used in conjunction with other view helpers for creating input elements:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`form_tag` 视图辅助函数提供了一个构建 HTML 表单的语法，可以与其他视图辅助函数结合使用，以创建输入元素：'
- en: '[PRE70]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this example, four view helpers are used to construct the form. The `form_tag`
    view helper creates the opening form body providing the form action to the first
    parameter, and other form attributes in the second parameter using a JavaScript
    object syntax with curly braces. The `input_field_tag` view helper is used to
    create a standard input text field, taking the input name as the first parameter,
    and optionally, the input value as the second parameter. The `submit_tag` view
    helper creates a form submit input with the button text passed as the first parameter.
    Finally, the `form_tag_end` view helper is used to close the body of the form.
    This example would render the following HTML:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，使用了四个视图辅助函数来构建表单。`form_tag` 视图辅助函数创建表单的主体，提供表单操作作为第一个参数，并使用大括号中的 JavaScript
    对象语法在第二个参数中提供其他表单属性。`input_field_tag` 视图辅助函数用于创建标准输入文本字段，输入名称作为第一个参数，可选地，输入值作为第二个参数。`submit_tag`
    视图辅助函数创建一个带有按钮文本的表单提交输入，作为第一个参数传递。最后，使用 `form_tag_end` 视图辅助函数关闭表单的主体。此示例将渲染以下
    HTML：
- en: '[PRE71]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: EJS also includes many other view helpers for common HTML elements using the
    _tag suffix.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: EJS 还包括许多其他视图辅助函数，用于常见的 HTML 元素，使用 `_tag` 后缀。
- en: Partials
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分模板
- en: 'EJS has its own implementation of partials that works using its synchronous
    template loading technique inside of template delimiter tags. To use this feature,
    a call to the partial template file is made directly inside of the parent template.
    Consider the following two template files:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: EJS 有自己的部分实现，它使用同步模板加载技术，在模板定界符标签内工作。要使用此功能，需要在父模板中直接调用部分模板文件。考虑以下两个模板文件：
- en: templates/parent.ejs
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: templates/parent.ejs
- en: '[PRE72]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: templates/partial.ejs
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: templates/partial.ejs
- en: '[PRE73]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Notice that the call to the partial template references the URL inside of the
    parent template using the expression syntax delimiters and a call to the `this.partial`
    method. To load the partial template inside of another, only the parent template
    has to be initialized from your JavaScript code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用部分模板时，使用表达式定界符和 `this.partial` 方法的调用引用了父模板中的 URL。要在另一个模板中加载部分模板，只需从你的 JavaScript
    代码中初始化父模板即可：
- en: '[PRE74]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The final rendered HTML would look like the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最终渲染的 HTML 将如下所示：
- en: '[PRE75]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: These examples provide a brief overview of EJS, but we will use this templating
    engine in more depth later. For additional information on EJS templates, visit
    `embeddedjs.com`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例提供了 EJS 的简要概述，但稍后我们将更深入地使用这个模板引擎。有关 EJS 模板的更多信息，请访问 `embeddedjs.com`。
- en: Optimizing your application layout
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化你的应用程序布局
- en: Building a JavaScript SPA can often involve many layers of abstraction including
    custom application code, third party libraries, frontend frameworks, task runners,
    transpilers, and more. All of this can end up amounting to a whole lot of JavaScript
    to be downloaded for the application on the frontend, so steps should always be
    taken to minimize this impact as much as possible.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个 JavaScript 单页应用（SPA）通常涉及许多抽象层，包括自定义应用程序代码、第三方库、前端框架、任务运行器、转译器等等。所有这些最终可能导致前端应用程序需要下载大量的
    JavaScript 代码，因此应始终采取措施尽可能最小化这种影响。
- en: 'Let''s go back to the Node.js example application we have been working with
    so far. In [Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*
    we wrote the index.html layout page for the app with the following script tags
    included for third party libraries and the compiled templates:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们迄今为止一直在工作的 Node.js 示例应用程序。在 [第 2 章](ch02.html "第 2 章。模型-视图-任何事物") 中，我们为应用程序编写了
    index.html 布局页面，其中包含了以下脚本标签，用于第三方库和编译后的模板：
- en: '[PRE76]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This is actually a minimal example compared to how many JavaScript files a full-scale
    application might include.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与一个完整规模的应用程序可能包含的 JavaScript 文件数量相比，这实际上是一个最小示例。
- en: UglifyJS and grunt-contrib-uglify
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UglifyJS 和 grunt-contrib-uglify
- en: 'A common tool for minifying and concatenating JavaScript files is **UglifyJS**.
    We can leverage this tool on the command line and automate it using the Grunt
    task runner and the **grunt-contrib-uglify** task:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '用于最小化和连接 JavaScript 文件的常见工具是 **UglifyJS**。我们可以利用这个工具在命令行上，并通过 Grunt 任务运行器和
    **grunt-contrib-uglify** 任务来自动化它： '
- en: '[PRE77]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Once installed, open up Gruntfile.js and add the following task to existing
    tasks immediately above the watch task:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，打开 Gruntfile.js 并立即在 watch 任务上方添加以下任务：
- en: '[PRE78]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This sets up the uglify task to remove all comments with the `preserveComments`
    option set to false, to mangle or shorten variable and function names, and to
    concatenate the indicated list of JavaScript files into the single target filename
    of `all.min.js`. With this setup, UglifyJS will create the smallest possible download
    size for your JavaScript based on the input files.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了 uglify 任务，以移除所有注释（`preserveComments` 选项设置为 false），打乱或缩短变量和函数名称，并将指示的 JavaScript
    文件列表连接到单个目标文件名 `all.min.js`。使用此设置，UglifyJS 将根据输入文件创建尽可能小的 JavaScript 下载大小。
- en: 'Next, make sure to load the new uglify task at the bottom of Gruntfile.js with
    the other tasks:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保在 Gruntfile.js 的底部加载新的 uglify 任务，与其他任务一起：
- en: '[PRE79]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, all you have to do is run the task on the command line:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需在命令行上运行任务：
- en: '[PRE80]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'After running the task, you should see output similar to the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行任务后，你应该看到类似以下内容的输出：
- en: '[PRE81]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You will notice that the CLI output indicates the original size of the JavaScript
    files, and what it is reduced to in the final output on the second line; in this
    example, showing 322.28 kB → 108.6 kB. In this case, it is compressed to less
    than half of its original size.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 CLI 输出显示了 JavaScript 文件的原始大小，以及第二行中最终输出的大小；在这个例子中，显示 322.28 kB → 108.6
    kB。在这种情况下，它被压缩到原始大小的一半以下。
- en: 'Now, you can change your index.html layout file to make a call to only one
    JavaScript file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以更改你的 index.html 布局文件，使其仅调用一个 JavaScript 文件：
- en: '[PRE82]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Placing the `<script>` tag at the bottom of the page also ensures that anything
    above it will be loaded and visible to the user before the JavaScript is entirely
    downloaded. This is another common practice in optimizing SPAs by preventing a
    delay before the user sees anything.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `<script>` 标签放置在页面底部也确保了在 JavaScript 完全下载之前，任何位于其上方的内容都将被加载并可见给用户。这是通过防止用户在看到任何内容之前出现延迟来优化
    SPAs 的另一种常见做法。
- en: grunt-contrib-handlebars
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: grunt-contrib-handlebars
- en: 'If you are using Handlebars templates in an application, the **grunt-contrib-handlebars**
    task is available for precompiling them easily from the command line and via the
    watch task. In [Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*
    we created the example `user.handlebars` file in the root directory of the project,
    and in [Chapter 4](ch04.html "Chapter 4. REST is Best – Interacting with the Server
    Side of Your App"), *REST is Best - Interacting with the Server Side of Your App*
    we created `users.handlebars`. Let''s now create a new directory in `js/templates`
    and move the files there. Next, rename the files `user.hbs` and `users.hbs` for
    brevity. The `.hbs` extension is also widely accepted for Handlebars files:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在应用程序中使用 Handlebars 模板，则 `grunt-contrib-handlebars` 任务可用于从命令行和通过监视任务轻松预编译它们。在
    [第 2 章](ch02.html "第 2 章。模型-视图- Whatever") 中，我们创建了项目根目录下的示例 `user.handlebars`
    文件，在 [第 4 章](ch04.html "第 4 章。REST 是最佳选择 – 与应用程序后端交互") 中，我们创建了 `users.handlebars`。现在，在
    `js/templates` 目录下创建一个新的目录，并将文件移到那里。接下来，将文件重命名为 `user.hbs` 和 `users.hbs` 以便简洁。`.hbs`
    扩展名也广泛接受为 Handlebars 文件：
- en: '[PRE83]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, install the grunt-contrib-handlebars plugin:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装 grunt-contrib-handlebars 插件：
- en: '[PRE84]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Once installed, add the following task configuration to `Gruntfile.js`, just
    above the `uglify` task configuration:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，将以下任务配置添加到 `Gruntfile.js` 文件中，位于 `uglify` 任务配置之上：
- en: '[PRE85]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The Grunt plugin for Handlebars makes fewer assumptions for you than the Handlebars
    command-line tool does out of the box, so this configuration does several things
    for you.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 的 Grunt 插件为您做出的假设比 Handlebars 命令行工具默认的假设要少，因此此配置为您做了几件事情。
- en: Options configuration
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项配置
- en: First, the `options` object is passed four parameters. The `namespace` option
    simply tells the compiler what global namespace to use to store the compiled Handlebars
    template functions. `Handlebars.templates`is the default namespace for this with
    the command line utility, so we will go with that.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`options` 对象传递了四个参数。`namespace` 选项简单地告诉编译器使用哪个全局命名空间来存储编译后的 Handlebars 模板函数。`Handlebars.templates`
    是使用命令行工具的默认命名空间，因此我们将采用这个。
- en: The `processName` parameter is passed a function that takes a Handlebars file
    as the argument and uses it to create the key name for that template in the `Handlebars.templates`namespace.
    In this case, we are using a regex to take the path and filename and remove everything
    except for the prefix of the filename, so the compiled template function for `user.hbs`,
    for example, would be available at `Handlebars.templates.user`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`processName` 参数传递一个函数，该函数接受一个 Handlebars 文件作为参数，并使用它来创建 `Handlebars.templates`
    命名空间中该模板的键名。在这种情况下，我们使用正则表达式来获取路径和文件名，并移除除了文件名前缀之外的所有内容，因此 `user.hbs` 的编译模板函数，例如，将在
    `Handlebars.templates.user` 下可用。'
- en: The `partialRegex` option accepts a regex that is used to identify a pattern
    for partial filenames. The default for this is a file prefixed with an underscore
    `_`, but in this case, we will be using a directory for partials, so the `partialRegex`
    option is set to `.*`, meaning it will identify any file on the given path as
    a partial.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`partialRegex` 选项接受一个正则表达式，用于识别部分文件名的模式。默认情况下，这是一个以下划线 `_` 为前缀的文件，但在此情况下，我们将使用目录来存储部分，因此
    `partialRegex` 选项设置为 `.*`，这意味着它将识别给定路径上的任何文件作为部分。'
- en: The `partialsPathRegex` options accepts a regex that is used to identify the
    path to a directory of partials. We have set it to `/\/partials\//` , which will
    be evaluated as the `/partials` directory beneath the main template path that
    is passed in. Combined with the `partialRegex` option, this tells the compiler
    to parse every file in the `/partials` directory as a partial and add its compiled
    template function to the `Handlebars.partials` namespace.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`partialsPathRegex` 选项接受一个正则表达式，用于识别部分目录的路径。我们将其设置为 `/\/partials\//`，这将评估为主模板路径下传递的
    `/partials` 目录。结合 `partialRegex` 选项，这告诉编译器解析 `/partials` 目录中的每个文件作为部分，并将编译后的模板函数添加到
    `Handlebars.partials` 命名空间中。'
- en: Files configuration
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件配置
- en: 'The files configuration object passed to the Handlebars Grunt task is used
    to tell the compiler what file pattern to use for finding templates for compiling,
    and for defining the output filename of the compiled templates:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 Handlebars Grunt 任务的文件配置对象用于告诉编译器使用什么文件模式来查找编译模板，以及定义编译模板的输出文件名：
- en: '[PRE86]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In this case, we have defined the templates `src` directory to be located in
    the `js/templates/` under the root path, and to parse all files with the extension
    `.hbs` in that directory and every directory underneath it. The recursive directory
    lookup is indicated by the `/**/*.hbs` syntax.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们已经定义了模板 `src` 目录位于根路径下的 `js/templates/`，并且解析该目录及其所有子目录下扩展名为 `.hbs`
    的所有文件。递归目录查找由 `/**/*.hbs` 语法表示。
- en: The `dest` key tells the compiler to create the `js/src/templates.js` file with
    the final compiled output of all the templates.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`dest` 键告诉编译器使用所有模板的最终编译输出创建 `js/src/templates.js` 文件。'
- en: Running the Grunt Handlebars task
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 Grunt Handlebars 任务
- en: 'In order to run the handlebars task, we first need to load the plugin at the
    bottom of Gruntfile.js:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行 handlebars 任务，我们首先需要在 Gruntfile.js 的底部加载该插件：
- en: '[PRE87]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, run the grunt handlebars command from the CLI:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从命令行运行 grunt handlebars 命令：
- en: '[PRE88]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'After running the task, you should see output similar to the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 运行任务后，您应该会看到类似以下内容的输出：
- en: '[PRE89]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, if you look in the `js/src/` directory, you should see that a `templates.js`
    file has been created there next to the `app.js` file we created in [Chapter 1](ch01.html
    "Chapter 1. Getting Organized with NPM, Bower, and Grunt"), *Getting Organized
    with NPM, Bower, and Grunt*. Now that we are storing the `templates.js` file here,
    go ahead and delete the original `templates.js` file in the root directory and
    edit the `files` object in the Grunt uglify task to look as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您查看 `js/src/` 目录，应该会看到在那里创建了一个 `templates.js` 文件，它与我们在 [第 1 章](ch01.html
    "第 1 章。使用 NPM、Bower 和 Grunt 进行组织") 中创建的 `app.js` 文件相邻，即 *使用 NPM、Bower 和 Grunt
    进行组织*。现在我们在这里存储 `templates.js` 文件，请继续删除根目录中的原始 `templates.js` 文件，并编辑 Grunt uglify
    任务中的 `files` 对象，使其如下所示：
- en: '[PRE90]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now we have added the new `templates.js` file to the uglify task so it is included
    in the full minified application JavaScript.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将新的 `templates.js` 文件添加到 uglify 任务中，以便将其包含在完整的压缩应用程序 JavaScript 中。
- en: Watching for changes
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视更改
- en: Now that you are loading the minified JavaScript file, you will probably want
    to add a watch task to create the file while you are developing so that you do
    not have to constantly run the command from the CLI.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您正在加载压缩的 JavaScript 文件，您可能希望添加一个监视任务，在您开发时创建该文件，这样您就不必不断从 CLI 运行命令。
- en: 'For this example, let''s assume that we want to detect changes to any files
    in the `js/src` directory where we are actively working. Edit the `watch` task
    configuration in `Gruntfile.js` and add the following directly underneath the
    `jshint` target for that task:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们假设我们想要检测 `js/src` 目录中任何文件的更改，我们在那里积极工作。编辑 `Gruntfile.js` 中的 `watch`
    任务配置，并在该任务的 `jshint` 目标下方直接添加以下内容：
- en: '[PRE91]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This tells Grunt to run the `uglify` task `main` target when it detects changes
    to files matching the pattern. Additionally, change the `jshint` watch task above
    the `uglify` watch task to the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Grunt 在检测到匹配模式的文件更改时运行 `uglify` 任务的 `main` 目标。此外，将 `jshint` 监视任务上面的 `uglify`
    监视任务更改为以下内容：
- en: '[PRE92]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This tells the watch task to ignore changes to `templates.js` for running the
    jshint task. We want to ignore this file because it is compiled and will not pass
    JSHint tests.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉监视任务在运行 jshint 任务时忽略对 `templates.js` 的更改。我们想忽略此文件，因为它已编译并且不会通过 JSHint 测试。
- en: 'Add the same file ignore path to the *main* `jshint` task `files` configuration
    near the top of the file:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的文件忽略路径添加到文件顶部附近的 *main* `jshint` 任务 `files` 配置中：
- en: '[PRE93]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This will prevent JSHint from checking `templates.js` against its defined rules
    when the `jshint` task is run.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止 JSHint 在运行 `jshint` 任务时将 `templates.js` 与其定义的规则进行比较。
- en: 'We also need a `watch` task for changes to Handlebars template files. Add the
    following configuration underneath the `uglify` target in the `watch` task:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个监视 Handlebars 模板文件更改的 `watch` 任务。在 `watch` 任务中，在 `uglify` 目标下方添加以下配置：
- en: '[PRE94]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This will watch for any changes to the Handlebars templates and partials and
    run the `handlebars` task accordingly. Doing so will generate the `templates.js`
    file, which will then trigger the uglify watch task to run and compile the full
    application JavaScript to `all.min.js`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这将监视 Handlebars 模板和部分文件的任何更改，并相应地运行 `handlebars` 任务。这样做将生成 `templates.js` 文件，然后触发
    uglify 监视任务运行，并将完整的应用程序 JavaScript 编译为 `all.min.js`。
- en: 'Next, run the Grunt `watch` command from the CLI:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从命令行运行 Grunt `watch` 命令：
- en: '[PRE95]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now open `user.hbs` and change the markup to look like the following example.
    Note that the `{{name.first}}` and `{{name.last}}` expressions are updated to
    the properties we created in MongoDB in *[Chapter 4](ch04.html "Chapter 4. REST
    is Best – Interacting with the Server Side of Your App"), REST is Best - Interacting
    with the Server Side of Your App* :'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`user.hbs`，将标记修改为以下示例所示。注意，`{{name.first}}`和`{{name.last}}`表达式已更新为我们之前在MongoDB中创建的属性，参见*[第4章](ch04.html
    "第4章。最佳实践 - 与应用程序的后端交互")，最佳实践 - 与应用程序的后端交互*：
- en: '[PRE96]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Save the file, then check your console where you are running the `watch` task.
    You should see output similar to the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，检查运行`watch`任务的控制台。你应该会看到以下类似的输出：
- en: '[PRE97]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The change to `user.hbs` set off a chain reaction of two tasks to run and your
    application JavaScript is compiled to the latest version. If you open the compiled
    `templates.js` file, you will see that both a user and a user''s property have
    been created with associated template functions:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对`user.hbs`的更改触发了两个任务的连锁反应，并且你的应用程序JavaScript被编译成最新版本。如果你打开编译后的`templates.js`文件，你会看到已经创建了一个用户及其属性，并关联了模板函数：
- en: '[PRE98]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, while the `handlebars` task is still running, move the `user.hbs` file
    to the `js/templates/partials` directory. This will again trigger the watch task.
    When it has completed, open `templates.js` again and you will notice that the
    `Handlebars.templates.user` property is no longer defined. Instead, a function
    call to `.registerPartial()` is made instead:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当`handlebars`任务仍在运行时，将`user.hbs`文件移动到`js/templates/partials`目录。这将再次触发监视任务。当它完成后，再次打开`templates.js`，你会注意到`Handlebars.templates.user`属性不再定义。相反，使用`.registerPartial()`函数调用来代替：
- en: '[PRE99]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This will invoke the `user.hbs` partial when it is included in a parent template
    using the Handlebars partials syntax. Now open up `users.hbs` and change it to
    use the `user.hbs` partial:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在父模板中使用Handlebars部分语法包含`user.hbs`部分时调用`user.hbs`部分。现在打开`users.hbs`，将其修改为使用`user.hbs`部分：
- en: '[PRE100]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This will iterate over the user's data provided. In [Chapter 4](ch04.html "Chapter 4. REST
    is Best – Interacting with the Server Side of Your App"), *REST is Best - Interacting
    with the Server Side of Your App* we left the test database with only one entry,
    so let's add another one now to make this example more illustrative.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遍历提供的用户数据。在[第4章](ch04.html "第4章。最佳实践 - 与应用程序的后端交互")，*最佳实践 - 与应用程序的后端交互*中，我们留下了只有一个条目的测试数据库，所以现在让我们添加另一个条目以使此示例更具说明性。
- en: 'In a separate console session, run your local Node.js server with Express:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个控制台会话中，使用Express运行你的本地Node.js服务器：
- en: '[PRE101]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now go to localhost:8080 in your browser and add another entry to the database
    using the POST Request form:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中转到localhost:8080，并使用POST请求表单添加另一个条目到数据库：
- en: '[PRE102]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Once you''ve added an additional record, click on the Load user data link under
    the GET Request form. You should see output similar to the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 添加额外记录后，点击GET请求表单下的“加载用户数据”链接。你应该会看到以下类似的输出：
- en: '[PRE103]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This content was rendered by looping over the user data from MongoDB in `users.hbs`
    and populating the expressions in the `user.hbs` partial.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此内容是通过在`users.hbs`中循环遍历MongoDB中的用户数据并填充`user.hbs`部分中的表达式来渲染的。
- en: Putting it all together
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: Using a single, minified JavaScript file for your application code, precompiling
    your JavaScript templates, and loading your JavaScript at the bottom of your application
    layout page are all good practices to follow in optimizing the download time of
    your SPA. Including all of the JavaScript in one file versus multiple files is
    just as important as minifying the JavaScript because it reduces the number of
    HTTP requests a client has to make in order to load your SPA. This same practice
    should be used with CSS and can be done with Grunt using plugins such as `grunt-contrib-cssmin`
    and `grunt-postcss`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个、压缩的JavaScript文件作为你的应用程序代码，预编译你的JavaScript模板，并在应用程序布局页面的底部加载JavaScript，这些都是优化你的SPA下载时间的好做法。将所有JavaScript包含在一个文件中而不是多个文件中，与压缩JavaScript一样重要，因为它减少了客户端为加载你的SPA而必须发出的HTTP请求的数量。同样的做法也应该用于CSS，并且可以使用Grunt和插件如`grunt-contrib-cssmin`和`grunt-postcss`来实现。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have a good understanding of the differences among some of the
    more popular JavaScript templating engines, how to use them for basic views, and
    some of their advantages and disadvantages. You should also understand the difference
    between using precompiled templates and templates that are compiled in the browser.
    Additionally, you have learned about optimizations to use in your layout file
    to minimize the download size of your app including minification, concatenation
    into one file, and including JavaScript at the bottom of the document. In the
    next chapter, we will dive further into the View layer by deconstructing the technique
    of data binding.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对一些流行的 JavaScript 模板引擎之间的区别有了很好的理解，包括如何使用它们进行基本视图，以及它们的一些优缺点。你还应该了解使用预编译模板和浏览器中编译的模板之间的区别。此外，你已经学习了在布局文件中使用的优化方法，以最小化应用程序的下载大小，包括压缩、合并成一个文件，以及在文档底部包含
    JavaScript。在下一章中，我们将通过分解数据绑定技术来进一步深入到视图层。
