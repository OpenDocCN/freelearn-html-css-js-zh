- en: Chapter 8. Mastering the Google Maps JavaScript API through Advanced Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章.通过高级教程精通Google Maps JavaScript API
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Adding WMS layers to maps
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将WMS图层添加到地图中
- en: Adding Fusion Tables layers to maps
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Fusion Tables图层添加到地图中
- en: Adding CartoDB layers to maps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CartoDB图层添加到地图中
- en: Accessing ArcGIS Server with the Google Maps JavaScript API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google Maps JavaScript API访问ArcGIS Server
- en: Accessing GeoServer with the Google Maps JavaScript API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google Maps JavaScript API访问GeoServer
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The Google Maps JavaScript API may seem like a simple library that only shows
    basic geo-related features, but there are a lot of capabilities that could be
    explored. The Google Maps JavaScript API gives developers many foundation classes
    to build complex solutions for different cases, especially for **Geographical
    Information Systems** (**GIS**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API可能看起来像是一个仅显示基本地理相关功能的简单库，但实际上有很多功能可以探索。Google Maps
    JavaScript API为开发者提供了许多基础类，用于构建针对不同情况的复杂解决方案，特别是对于**地理信息系统**（GIS）。
- en: The Google Maps JavaScript API has a lot of potential with GIS services and
    tools. Most of the GIS solutions need base maps and services to support the tool
    itself and the Google Maps JavaScript API is the best solution with its base maps
    and services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API与GIS服务和工具具有很大的潜力。大多数GIS解决方案都需要基础地图和服务来支持工具本身，而Google
    Maps JavaScript API凭借其基础地图和服务是最佳解决方案。
- en: There are different GIS solutions from proprietary software and services to
    open source ones, such as Google Fusion Tables, CartoDB, ArcGIS Server, or GeoServer.
    In this chapter, we will integrate these servers or services with the Google Maps
    JavaScript API. Some of the GIS service creation processes are skipped due to
    space constraints. If you need more information, please check other books by *Packt
    Publishing* to dive into details.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的GIS解决方案，从专有软件和服务到开源解决方案，如Google Fusion Tables、CartoDB、ArcGIS Server或GeoServer。在本章中，我们将将这些服务器或服务与Google
    Maps JavaScript API集成。由于篇幅限制，省略了一些GIS服务创建过程。如果您需要更多信息，请查阅Packt Publishing的其他书籍，深入了解细节。
- en: Adding WMS layers to maps
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将WMS图层添加到地图中
- en: '**Web Map Service** (**WMS**) is an **Open Geospatial Consortium** (**OGC**)
    standard for publishing georeferenced map images over the Internet that are generated
    by a map server using data from various geospatial sources such as shapefiles
    or geospatial databases. There are various versions used in WMS services but the
    most used ones are 1.1.1 or 1.3.0\. WMS has two required request types: `GetCapabilities`
    and `GetMap`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web Map Service**（WMS）是**开放地理空间联盟**（OGC）的一个标准，用于通过互联网发布由地图服务器使用来自各种地理空间源（如shapefiles或地理空间数据库）生成的地理参照地图图像。WMS服务中使用了各种版本，但最常用的版本是1.1.1或1.3.0。WMS有两个必需的请求类型：`GetCapabilities`和`GetMap`。'
- en: This recipe shows how to add a WMS layer to the Google Maps JavaScript API by
    extending the `google.maps.OverlayView` class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程展示了如何通过扩展`google.maps.OverlayView`类将WMS图层添加到Google Maps JavaScript API中。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: By now, you should already know how to create a map, so only additional code
    lines are explained in this recipe.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经知道如何创建地图，所以本教程中只解释了额外的代码行。
- en: You can find the source code at `Chapter 8/ch08_wms_map.html`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Chapter 8/ch08_wms_map.html`中找到源代码。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Adding WMS layers to the map is quite easy if you perform the following steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照以下步骤操作，将WMS图层添加到地图上相当简单：
- en: 'First, create a `wms.js` file to include in the HTML later. This JavaScript
    file has a `WMSUntiled` class that is written as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`wms.js`文件，稍后将其包含在HTML中。此JavaScript文件包含一个`WMSUntiled`类，编写方式如下：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, extend our base class by inheriting the `google.maps.OverlayView` class:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过继承`google.maps.OverlayView`类扩展我们的基类：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The next step is to implement three methods of the `OverlayView` class.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现`OverlayView`类的三种方法。
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, add the following methods to finish the `WMSUntiled` class:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下方法来完成`WMSUntiled`类：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now this JavaScript class file must be added to the HTML after adding the Google
    Maps JavaScript API:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在必须将此JavaScript类文件添加到HTML中，在添加Google Maps JavaScript API之后：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After initializing the map, we create our WMS options as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化地图后，我们创建以下WMS选项：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At the end, we initialize the WMS layer with the WMS options created in steps
    1 to 4:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用步骤1到4中创建的WMS选项初始化WMS图层：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Go to your local URL where your HTML file is stored in your favorite browser
    and see the result. The following topological map coming from WMS is shown on
    the satellite base map of Google Maps:![How to do it…](img/8825OT_08_01.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您在浏览器中存储 HTML 文件的本地 URL，并查看结果。以下来自 WMS 的拓扑地图显示在谷歌地图的卫星基础地图上：![如何操作…](img/8825OT_08_01.jpg)
- en: As you can see in the preceding screenshot, we added a WMS layer to our map.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，我们向我们的地图添加了一个 WMS 层。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: WMS is a standard for serving georeferenced images. The main idea behind WMS
    is serving the image according to the width/height and bounding box of the map
    with additional parameters such as projection type, layer names, and return format.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: WMS 是一个用于提供地理参考图像的标准。WMS 的主要思想是根据地图的宽度/高度和边界框以及额外的参数（如投影类型、图层名称和返回格式）来提供图像。
- en: Most of the WMS classes for the Google Maps JavaScript API around the Web are
    based on a tiled structure, which is the base for most mapping APIs. This tiled
    structure gets the bounding box of each tile and sends it to the server. This
    can be a good usage for user interactivity wherein users only get missing tiles
    when dragging the map, but there is a problem with map servers. Getting lots of
    tiles instead of a single image causes a big load on map servers if there isn't
    a caching mechanism with a high volume of usage.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 网上大多数针对谷歌地图 JavaScript API 的 WMS 类都是基于瓦片结构的，这是大多数地图 API 的基础。这种瓦片结构获取每个瓦片的边界框并将其发送到服务器。这在用户交互方面可能是一个好的用法，因为用户只有在拖动地图时才会得到缺失的瓦片，但地图服务器存在一个问题。如果没有缓存机制，大量瓦片而不是单个图像会导致地图服务器负载很大。
- en: In this recipe, we used the untiled structure to get WMS images from the server.
    This approach is getting one image from the server on each user interaction that
    can be useful in some cases. There isn't much information about this approach,
    so we encourage you to read and implement both approaches for your geo-web applications.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了无瓦片结构从服务器获取 WMS 图像。这种方法在用户交互中每次都从服务器获取一个图像，在某些情况下可能很有用。关于这种方法的信息不多，所以我们鼓励您阅读并实现这两种方法，用于您的地理网络应用程序。
- en: 'The JavaScript class named `WMSUntiled` is created in a different file in order
    to make the HTML file readable. This class is created with functional style and
    methods are added to the prototype of the constructor function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `WMSUntiled` 的 JavaScript 类是在不同的文件中创建的，以便使 HTML 文件易于阅读。这个类以函数式风格创建，并将方法添加到构造函数的原型上：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Google Maps JavaScript API has a base class to extend in these cases named
    as `google.maps.OverlayView`. The `WMSUntiled` class extends this class to create
    a WMS overlay on top of the map:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌地图 JavaScript API 有一个基类可以扩展，称为 `google.maps.OverlayView`。`WMSUntiled` 类扩展了这个类，在地图上创建
    WMS 叠加层：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `OverlayView` class has three methods to implement in order to show the
    overlays as `draw()`, `onAdd()`, and `onRemove()`. The `onAdd()` and `onRemove()`
    methods are called during initialization and removal respectively. The `div` element
    is created and added to the map with the help of the `appendChild` function in
    the `onAdd()` method. Also, the `drag` event of the map is started to listen and
    draw the WMS layer on each user drag in this method. The `onRemove()` method removes
    the `div` element created earlier:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`OverlayView` 类需要实现三个方法来显示叠加层，分别是 `draw()`、`onAdd()` 和 `onRemove()`。`onAdd()`
    和 `onRemove()` 方法分别在初始化和移除时被调用。在 `onAdd()` 方法中，通过 `appendChild` 函数创建并添加 `div`
    元素到地图上。同时，在这个方法中启动监听地图的 `drag` 事件，以便在用户拖动时绘制 WMS 层。`onRemove()` 方法移除之前创建的 `div`
    元素：'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The most important part of the class is the `draw()` method. This method creates
    an `img` element and attaches this element to the created `div` element in the
    `onAdd()` method. If there is an `img` element created before, it is removed from
    the `div` element. The `img` source is obtained from another method of the class
    named `prepareWMSUrl()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类中最重要的部分是 `draw()` 方法。这个方法创建一个 `img` 元素，并在 `onAdd()` 方法中将这个元素附加到创建的 `div` 元素上。如果之前创建了
    `img` 元素，它将被从 `div` 元素中移除。`img` 的源是从类的另一个方法 `prepareWMSUrl()` 获取的：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need pixel coordinates to place the `div` element. We get a projection of
    the layers in order to locate the `div` and `img` elements in the right place
    on the map. The `fromLatLngToDivPixel()` method converts the `LatLng` coordinates
    to screen pixels, which are used for placing the `div` element in the correct
    place:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要像素坐标来放置`div`元素。我们获取图层的投影，以便在地图上正确定位`div`和`img`元素。`fromLatLngToDivPixel()`方法将`LatLng`坐标转换为屏幕像素，这些像素用于将`div`元素放置在正确的位置：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: WMS has a bounding box parameter (`BBOX`) that defines the boundaries of a georeferenced
    image. The `BBOX` parameter must be in the same unit defined in the CRS parameter.
    Google Maps is based on the Web Mercator projection, which is defined as `EPSG:900913`
    or `EPSG:3857`. The Google Maps JavaScript API used Web Mercator as a base projection,
    but gives us the `LatLng` objects in geographic projection defined as `EPSG:4326`.
    In order to get the right WMS image on Google Maps, there is a need for transformation
    of coordinates from `EPSG:4326` to `EPSG:3857`. This transformation can be done
    via the `toMercator()` method of the class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: WMS有一个边界框参数（`BBOX`），它定义了地理参照图像的边界。`BBOX`参数必须与CRS参数中定义的单位相同。Google Maps基于Web
    Mercator投影，定义为`EPSG:900913`或`EPSG:3857`。Google Maps JavaScript API使用Web Mercator作为基础投影，但给我们的是定义为`EPSG:4326`的地理投影的`LatLng`对象。为了在Google
    Maps上获取正确的WMS图像，需要将坐标从`EPSG:4326`转换为`EPSG:3857`。这种转换可以通过类的`toMercator()`方法完成。
- en: 'The `prepareWMSUrl()` method gets most of the parameters from the `wmsoptions`
    object and creates a WMS URL to get the georeferenced image. The `BBOX` and `width`/`height`
    parameters are gathered from the map functions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepareWMSUrl()`方法从`wmsoptions`对象获取大多数参数并创建一个WMS URL来获取地理参照图像。`BBOX`和`width`/`height`参数从地图函数中收集：'
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `WMSUntiled` class handles almost everything. In order to add WMS layers
    to the Google Maps JavaScript API, you need to define the parameters of WMS layers
    and create an object from the `WMSUntiled` class. Since we give `map` as a parameter,
    there is no need to add the WMS layer to the `map` object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`WMSUntiled`类处理几乎所有事情。为了将WMS图层添加到Google Maps JavaScript API中，你需要定义WMS图层的参数并从`WMSUntiled`类创建一个对象。由于我们提供了`map`作为参数，因此不需要将WMS图层添加到`map`对象中：'
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are lots of parameters to get WMS from the server, but that is out of
    the scope of this book. The sample WMS server used in this example cannot be available
    when you want to use it, so please use your own WMS servers in order to be sure
    of the availability of the services.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器获取WMS有很多参数，但这本书的范围之外。本例中使用的示例WMS服务器在你想要使用时可能不可用，因此请使用你自己的WMS服务器以确保服务的可用性。
- en: There's more…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: As stated at the beginning of the recipe, we create an overlay class to add
    WMS layers to the Google Maps JavaScript API without using the tiled structure.
    This is just a use case for developers. You should check for both tiled and untiled
    structures for your cases. There is an example use of the tiled structure in the
    *Accessing GeoServer with the Google Maps JavaScript API* recipe in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如食谱开头所述，我们创建一个叠加类来将WMS图层添加到Google Maps JavaScript API中，而不使用瓦片结构。这只是一个针对开发者的用例。你应该检查你的情况中的瓦片和非瓦片结构。本章中有一个使用瓦片结构的示例，即*使用Google
    Maps JavaScript API访问GeoServer*食谱。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。Google Maps JavaScript API基础知识")中*在自定义DIV元素中创建简单地图*的食谱，*Google
    Maps JavaScript API基础知识*'
- en: The *Accessing GeoServer with the Google Maps JavaScript API* recipe
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Google Maps JavaScript API访问GeoServer*食谱'
- en: Adding Fusion Tables layers to maps
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Fusion Tables图层添加到地图中
- en: Fusion Tables ([http://tables.googlelabs.com/](http://tables.googlelabs.com/))
    is an experimental tool provided by Google to store different types of tabular
    data. Fusion Tables is important for geo developers because it supports feature
    types such as points, polylines, and polygons. There is also support for geocoding
    of the address, place names, or countries that make Fusion Tables a powerful database
    for your features. Fusion Tables also has an API so that developers can connect
    it to different applications. There are some limitations in Fusion Tables but
    these limitations are enough for most developers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Fusion Tables([http://tables.googlelabs.com/](http://tables.googlelabs.com/))是Google提供的一个实验性工具，用于存储不同类型的表格数据。对于地理开发者来说，Fusion
    Tables非常重要，因为它支持点、折线和多边形等要素类型。它还支持地址、地点名称或国家的地理编码，使Fusion Tables成为您要素的强大数据库。Fusion
    Tables还有一个API，允许开发人员将其连接到不同的应用程序。Fusion Tables有一些限制，但这些限制对于大多数开发者来说已经足够了。
- en: The OpenStreetMap POI database can be downloaded via different sources. We downloaded
    the restaurant POI database of Switzerland in the KML format and imported it into
    Fusion Tables. There are 7967 points in this table. In this recipe, we will use
    this table as a sample to help us visualize.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStreetMap POI数据库可以通过不同的来源下载。我们以KML格式下载了瑞士的餐厅POI数据库并将其导入到Fusion Tables中。这个表中共有7967个点。在这个菜谱中，我们将使用这个表作为示例来帮助我们可视化。
- en: 'The map view of the Switzerland POI database of restaurants can be seen using
    Fusion Tables as shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，可以使用Fusion Tables查看瑞士POI数据库的餐厅地图视图：
- en: '![Adding Fusion Tables layers to maps](img/8825OT_08_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![将Fusion Tables层添加到地图中](img/8825OT_08_02.jpg)'
- en: This is how we achieve adding a Fusion Tables layer to the map that shows thousands
    of points without a problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们实现将Fusion Tables层添加到显示数千个点的地图中而不会出现问题的方法。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We assume that you already know how to create a simple map. We will only cover
    the code that is needed for adding a Fusion Tables layer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您已经知道如何创建一个简单的地图。我们只会介绍添加Fusion Tables层所需的代码。
- en: You can find the source code at `Chapter 8/ch08_fusion_tables.html`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`第8章/ch08_fusion_tables.html`中找到源代码。
- en: How to do it…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'If you want to add Fusion Tables layers to the map, you should perform the
    following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将Fusion Tables层添加到地图中，应执行以下步骤：
- en: 'First, add the following line for jQuery to simplify our work after the Google
    Maps JavaScript API is added:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在添加Google Maps JavaScript API之后，添加以下行以简化我们的工作：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, add the following HTML code before the map''s DIV element for interactivity
    with the Fusion Tables layer:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在地图的DIV元素之前添加以下HTML代码，以便与Fusion Tables层进行交互：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, create the Fusion Tables layers and add it to the map after the initialization
    of the `map` object as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`map`对象初始化后创建Fusion Tables层并将其添加到地图中，如下所示：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next step is to listen to the `click` event of the checkbox to switch between
    the normal view and the heat map view:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是监听复选框的`click`事件，在普通视图和热力图视图之间切换：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following lines to listen to the `click` event of the **Search** button
    to filter the Fusion Tables layer according to the value entered in the textbox:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下行以监听**搜索**按钮的`click`事件，根据文本框中输入的值过滤Fusion Tables层：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Go to your local URL where your HTML is stored in your favorite browser and
    click on the map to see the result. If you click on the heat map checkbox, the
    Fusion Tables layer will change into a heat map. You can also search for the names
    of restaurants with the **Search** button:![How to do it…](img/8825OT_08_03.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您本地存储HTML的URL，并在您喜欢的浏览器中点击地图以查看结果。如果您点击热力图复选框，Fusion Tables层将转换为热力图。您还可以使用**搜索**按钮搜索餐厅名称：![如何操作…](img/8825OT_08_03.jpg)
- en: The preceding screenshot is also showing a filtered Fusion Tables layers added
    to a map.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图还显示了添加到地图中的过滤后的Fusion Tables层。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As stated earlier, Fusion Tables is an experimental tool to use and classes
    related to Fusion Tables that are under the Google Maps JavaScript API are also
    experimental according to the documentation. As far as we have used them, both
    Fusion Tables and classes under Google Maps JavaScript API are stable and can
    be ready for production environments, but it is at your own risk to use them in
    your geo-web application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Fusion Tables是一个实验性工具，根据文档，Google Maps JavaScript API下与Fusion Tables相关的类也是实验性的。就我们所知，Fusion
    Tables和Google Maps JavaScript API下的类都是稳定的，可以用于生产环境，但使用它们在您的地理Web应用程序中存在风险。
- en: By the way, please make sure that your tables do not pass 100,000 rows in order
    to use them properly, because there is a limitation written in the API.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，请确保您的表不超过 100,000 行，以便正确使用，因为 API 中有写入的限制。
- en: Fusion Tables supports the importing of various data types such as CSV, TSV,
    TXT, or KML with coordinates of geometries. Fusion Tables geometry columns can
    be in different formats, such as a geometry column in the KML format, address
    column, or latitude/longitude coordinates in single column or two separate columns.
    If you have addresses or city names, these columns can also be geocoded in order
    to be used in your applications. We uploaded a KML file to Fusion Tables gathered
    from OpenStreetMap that is full of restaurant points with names.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Fusion Tables 支持导入各种数据类型，如 CSV、TSV、TXT 或带有几何坐标的 KML。Fusion Tables 的几何列可以有不同的格式，例如
    KML 格式的几何列、地址列，或单列或两列单独的纬度/经度坐标。如果您有地址或城市名称，这些列也可以进行地理编码，以便在您的应用程序中使用。我们上传了一个从
    OpenStreetMap 收集的 KML 文件到 Fusion Tables，其中包含许多带有名称的餐厅点。
- en: There is also a REST API for Fusion Tables to access and manipulate the data
    within tables with/without OAuth regardless of the Google Maps JavaScript API.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Fusion Tables 还有一个 REST API，用于访问和操作表格中的数据，无论是否使用 OAuth，都可以与 Google Maps JavaScript
    API 无关。
- en: 'There is a `google.maps.FusionTablesLayer` class in the Google Maps JavaScript
    API to access and visualize the data from Fusion Tables. We need the table ID
    and name of the geometry column to access the Fusion Tables layer in the Google
    Maps JavaScript API. Remember that your table must be shared as public or unlisted
    in order to be accessible from the Google Maps JavaScript API. Developers can
    get the table ID by navigating to **File** | **About** in the Fusion Tables web
    interface. The following code block is needed to add Fusion Tables to the Google
    Maps JavaScript API:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Maps JavaScript API 中有一个 `google.maps.FusionTablesLayer` 类，用于访问和可视化来自
    Fusion Tables 的数据。我们需要表 ID 和几何列的名称来访问 Google Maps JavaScript API 中的 Fusion Tables
    层。请记住，您的表必须共享为公开或未列出，才能通过 Google Maps JavaScript API 访问。开发者可以通过在 Fusion Tables
    网页界面中导航到 **文件** | **关于** 来获取表 ID。以下代码块是添加 Fusion Tables 到 Google Maps JavaScript
    API 所必需的：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you want to enable the heat map option at the beginning of the API, you
    should set the enabled option to `true` under the `heatmap` parameter. We will
    switch these parameters with the `checkbox` options in our recipe as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 API 开启时启用热图选项，应在 `heatmap` 参数下将启用选项设置为 `true`。我们将在我们的菜谱中用 `checkbox` 选项切换这些参数，如下所示：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using heat maps is a good way to summarize the data you have and show where
    most of the points are gathered. Heat maps are mostly used in various fields in
    order to show the important places such as most dense crime spots in crime mapping.
    If users enable the heat map, you will see the following results in the application.
    The following map shows in red where the restaurant population is crowded:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用热图是总结您拥有的数据并显示大多数点聚集位置的好方法。热图主要在各种领域中用于显示重要地点，例如犯罪地图中最密集的犯罪地点。如果用户启用了热图，您将在应用程序中看到以下结果。以下地图用红色显示了餐厅人口密集的区域：
- en: '![How it works...](img/8825OT_08_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8825OT_08_04.jpg)'
- en: 'Fusion Tables also supports filtering rows with SQL-like queries. SQL queries
    can be added to the `query` parameter with the `where` field. This can be a starting
    value or added later to filter the visualized data. In this recipe, we filter
    our data according to the value entered in the textbox. The following code listens
    to the **Search** button and when a click occurs, it gets the value of the textbox
    and set the options of the Fusion Tables layer according to the textbox value.
    The filtered data is immediately shown on the map:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Fusion Tables 还支持使用类似 SQL 的查询过滤行。可以将 SQL 查询添加到 `query` 参数的 `where` 字段。这可以是一个起始值，也可以稍后添加以过滤可视化的数据。在这个菜谱中，我们根据文本框中输入的值过滤我们的数据。以下代码监听
    **搜索** 按钮，当点击发生时，它获取文本框的值，并根据文本框的值设置 Fusion Tables 层的选项。过滤后的数据立即显示在地图上：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `google.maps.FusionTablesLayer` class also has the ability to change the
    style of the map according to filters. You can change the marker type of points,
    line color of polylines, or fill color of polygons consistent with the values
    of columns.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`google.maps.FusionTablesLayer` 类还具有根据过滤器更改地图样式的能力。您可以根据列的值更改点的标记类型、多边形的线颜色或填充颜色。'
- en: Fusion Tables can be a good candidate to store, analyze, and visualize your
    data if developers know the limitations. Also, developers do not forget that Fusion
    Tables are still in the experimental stage, so Google can change something in
    Fusion Tables in the future that can cause your application to stop.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者了解限制，Fusion Tables 可以成为存储、分析和可视化您数据的良好候选。开发者也不要忘记 Fusion Tables 仍然处于实验阶段，因此
    Google 未来可能会在 Fusion Tables 中做出一些改变，这可能导致您的应用程序停止。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More about data**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于数据更多信息**'
- en: The data used in this application can be downloaded from [http://poi-osm.tucristal.es/](http://poi-osm.tucristal.es/),
    which uses OpenStreetMap as a source. The data used in this recipe is available
    with the code. The data is also available from Fusion Tables as a public share.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用程序使用的数据可以从 [http://poi-osm.tucristal.es/](http://poi-osm.tucristal.es/) 下载，该数据使用
    OpenStreetMap 作为来源。本食谱中使用的数据与代码一起提供。数据也可以从 Fusion Tables 作为公开共享获取。
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 1 章 *Google Maps JavaScript API 基础* 的 *在自定义 DIV 元素中创建简单地图* 食谱中，*Google Maps
    JavaScript API 基础*
- en: The *Creating a heat map* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 2 章 *添加栅格图层* 的 *创建热图* 食谱中，*添加栅格图层*
- en: Adding CartoDB layers to maps
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 CartoDB 图层添加到地图中
- en: 'CartoDB is a geospatial database on the cloud that allows for the storage and
    visualization of data on the Web. Using CartoDB will allow you to quickly create
    map-based visualizations. According to the CartoDB website ([www.cartodb.com](http://www.cartodb.com)),
    you can use CartoDB in the following ways:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CartoDB 是一个云上的地理空间数据库，允许在网络上存储和可视化数据。使用 CartoDB 将允许您快速创建基于地图的可视化。根据 CartoDB
    网站 ([www.cartodb.com](http://www.cartodb.com))，您可以使用 CartoDB 以以下方式：
- en: Upload, visualize, and manage your data using the CartoDB dashboard
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CartoDB 控制台上传、可视化和管理您的数据
- en: Quickly create and customize maps that you can embed or share via public URL
    using the map-embedding tool
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地图嵌入工具快速创建和自定义您可以通过公共 URL 嵌入或共享的地图
- en: Analyze and integrate data you store on CartoDB into your applications using
    the SQL API
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQL API 分析和整合您存储在 CartoDB 上的数据到您的应用程序中
- en: For more advanced integrations of CartoDB maps on your website or application,
    use `CartoDB.js`
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于您网站或应用程序上 CartoDB 地图的更高级集成，请使用 `CartoDB.js`
- en: CartoDB is an open source project for which you can fork the code from GitHub
    and start your own CartoDB instance on your own hardware, but the power of CartoDB
    is the cloud backend. CartoDB is based on PostgreSQL, PostGIS, and Mapnik, which
    are the most popular and powerful open source geo tools nowadays.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: CartoDB 是一个开源项目，您可以从 GitHub 分叉代码并开始在您自己的硬件上启动自己的 CartoDB 实例，但 CartoDB 的力量在于云后端。CartoDB
    基于 PostgreSQL、PostGIS 和 Mapnik，这些是目前最受欢迎和功能强大的开源地理工具。
- en: There is a free tier for developers to explore the power of CartoDB, which has
    a limit of up to 5 MB storage and five tables.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者有一个免费层来探索 CartoDB 的功能，存储限制最高为 5 MB，并且有五个表。
- en: 'In this recipe, the simplified version of world borders is imported from the
    CartoDB dashboard to play with. The following screenshots show both the tabular
    and map view of the world borders. This data will be published on the Google Maps
    JavaScript API with the help of the `CartoDB.js` library:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，从 CartoDB 控制台导入简化版的世界边界数据以进行操作。以下截图显示了世界边界的表格视图和地图视图。这些数据将在 Google Maps
    JavaScript API 的帮助下通过 `CartoDB.js` 库发布：
- en: '![Adding CartoDB layers to maps](img/8825OT_08_05.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![将 CartoDB 图层添加到地图中](img/8825OT_08_05.jpg)'
- en: 'And now the map view of the world border is shown in the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以下截图显示了世界边界的地图视图：
- en: '![Adding CartoDB layers to maps](img/8825OT_08_06.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![将 CartoDB 图层添加到地图中](img/8825OT_08_06.jpg)'
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we assume you already know how to create a simple map. So, we
    will only show the extra code lines to add CartoDB layers on top of the Google
    Maps base maps.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们假设您已经知道如何创建一个简单的地图。因此，我们只展示添加 CartoDB 图层到 Google Maps 基础地图上的额外代码行。
- en: You can find the source code at `Chapter 8/ch08_cartodb_layer.html`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `Chapter 8/ch08_cartodb_layer.html` 找到源代码。
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'If you perform the following steps, you can add CartoDB layers to the map:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行以下步骤，您可以将 CartoDB 图层添加到地图中：
- en: 'First, CartoDB-related files are added to the HTML document:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将 CartoDB 相关文件添加到 HTML 文档中：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, the jQuery file is added after CartoDB files:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 CartoDB 文件之后添加 jQuery 文件：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next step is to add a global variable to access from everywhere after the
    `map` variable:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在`map`变量之后添加一个全局变量，以便从任何地方访问：
- en: '[PRE24]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After initialization of the map, the following lines are added to define the
    cartography of the layers. This can be single line string, but it is separated
    into multiple lines in order to improve readability:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地图初始化后，添加以下行以定义层的制图。这可以是一个单行字符串，但为了提高可读性，将其分为多行：
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The important part of the code is the initialization of the CartoDB layer as
    follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码中的重要部分是以下CartoDB层的初始化：
- en: '[PRE26]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, add the following part to listen to the `click` event of the **Search**
    button in order to update the map contents according to the textbox value:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下部分以监听**搜索**按钮的`click`事件，以便根据文本框的值更新地图内容：
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Do not forget to add the following lines before and after the map''s `div`
    element:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在地图的`div`元素前后添加以下行：
- en: '[PRE28]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Go to your local URL where your HTML is stored in your favorite browser and
    take a look at the CartoDB layer on top of the Google Maps base map. When you
    move on the map, the bottom line of the map changes according to where your mouse
    is placed. When you click on the map, you will also see an info window about that
    country as shown in the following screenshot:![How to do it…](img/8825OT_08_07.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您在最喜欢的浏览器中存储HTML的本地URL，并查看位于Google Maps基础地图之上的CartoDB层。当您在地图上移动时，地图的底部行会根据鼠标放置的位置而改变。当您点击地图时，您还会看到有关该国家的信息窗口，如图中所示：![如何操作…](img/8825OT_08_07.jpg)
- en: As a result of this recipe, we can add CartoDB layers to the map, which gets
    live data from your data source.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个菜谱的结果，我们可以将CartoDB层添加到地图中，该地图从您的数据源获取实时数据。
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As mentioned earlier, CartoDB is based on PostGIS and Mapnik technologies,
    so you can use CartoCSS as a styling language of the layer. CartoCSS is much like
    CSS with some additional tags to define the cartography. In this recipe, we will
    define a choropleth cartography according to population values. Using population
    values seems to be simple for cartography but this is the most easiest way to
    understand CartoCSS:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，CartoDB基于PostGIS和Mapnik技术，因此您可以使用CartoCSS作为层的样式语言。CartoCSS类似于CSS，但有一些额外的标签来定义制图。在本菜谱中，我们将根据人口值定义一个面状制图。使用人口值对于制图来说似乎很简单，但这是最容易理解CartoCSS的方法：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `#world_borders` layer is the name of the layer defined in the CartoDB dashboard.
    The first brackets include all the features in the layer with a polygon-fill and
    a polygon-opacity. The second brackets target the features with a population of
    more than 10 million with a different color. The third brackets and fourth brackets
    target the features with a population of more than 40 and 70 million respectively
    with different colors. So, we have four different categories defined in this CartoCSS
    tag according to the population of countries. Each CartoCSS rule overwrites the
    one written before.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`#world_borders`层是CartoDB仪表板中定义的层的名称。第一个括号包括具有多边形填充和多边形不透明度的层中所有要素。第二个括号针对人口超过1000万的要素，使用不同的颜色。第三个括号和第四个括号分别针对人口超过4000万和7000万的要素，使用不同的颜色。因此，我们在这个CartoCSS标签中根据国家的人口定义了四个不同的类别。每个CartoCSS规则都会覆盖之前写入的规则。'
- en: 'Now that we have the cartography of the layer, it is time to create the layer
    and add it to the map:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了层的制图，是时候创建层并将其添加到地图中了：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have used chaining methods to create the layer and add it to the map. The
    following part is explained later. There is a `user_name` field to define your
    CartoDB account. The important part to define the layer is the `sublayers` field.
    You can define more than one layer but we will add only one layer at this time.
    The JavaScript object within the `sublayers` field is very important. The `sql`
    field defines, which features to be shown on the map. You can even write very
    complex SQL queries here like your own PostGIS database. The `cartocss` field
    is the part where you define the cartography of your layer. This is defined before,
    so just pass that variable to this field.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了链式方法来创建层并将其添加到地图中。以下部分将在稍后解释。有一个`user_name`字段来定义您的CartoDB账户。定义层的重点在于`sublayers`字段。您可以定义多个层，但我们将在此处只添加一个层。`sublayers`字段中的JavaScript对象非常重要。`sql`字段定义了要在地图上显示哪些要素。您甚至可以在这里编写非常复杂的SQL查询，就像您的PostGIS数据库一样。`cartocss`字段是您定义层制图的部分。这已经在之前定义了，所以只需将那个变量传递到这个字段即可。
- en: The next field is the `interactivity` field. This is important due to the technology
    behind it called **UTFGrid**. UTFGrid is a specification for rasterized interaction
    data. According to MapBox, who introduced this standard, UTFGrid's solution to
    this problem is to rasterize polygons and points in JSON as a grid of text characters.
    Each feature is referenced by a distinct character and associated to JSON data
    by its character code. The result is a cheap, fast lookup that even Internet Explorer
    7 can do instantly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字段是 `interactivity` 字段。这很重要，因为它背后是称为 **UTFGrid** 的技术。UTFGrid 是一个用于栅格化交互数据的规范。根据引入此标准的
    MapBox，UTFGrid 解决这个问题的方法是将多边形和点在 JSON 中栅格化为文本字符的网格。每个特征由一个独特的字符引用，并通过其字符代码与 JSON
    数据相关联。结果是便宜、快速的查找，即使是 Internet Explorer 7 也能立即完成。
- en: With UTFGrid, you can load some attribute data to the client with the loading
    of layer tile images and you can show this attribute data while your mouse is
    moving without sending any requests to the server. This is the quickest way to
    interact with users and remove the load from servers. You can still get detailed
    information from the server when it is really needed. Most of the time, users
    are very happy with this fast data interaction and there is no need to get more
    information from the server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 UTFGrid，你可以在加载层瓦片图像的同时将一些属性数据加载到客户端，并且可以在鼠标移动时显示这些属性数据，而无需向服务器发送任何请求。这是与用户交互最快的方式，并从服务器卸载负载。当真正需要时，你仍然可以从服务器获取详细信息。大多数时候，用户对这种快速的数据交互非常满意，无需从服务器获取更多信息。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More about UTFGrid**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于 UTFGrid 的更多信息**'
- en: 'If you are interested in more technical details of UTFGrid, the following web
    addresses are suggested for further reference:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 UTFGrid 的更多技术细节感兴趣，以下网址建议进一步参考：
- en: '[https://github.com/mapbox/utfgrid-spec](https://github.com/mapbox/utfgrid-spec)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mapbox/utfgrid-spec](https://github.com/mapbox/utfgrid-spec)'
- en: '[https://www.mapbox.com/developers/utfgrid/](https://www.mapbox.com/developers/utfgrid/)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.mapbox.com/developers/utfgrid/](https://www.mapbox.com/developers/utfgrid/)'
- en: As we have previously covered, there is a field named `interactivity`. This
    should be filled with the column names that will be used for interactivity; it
    is important to make sure that interactivity is quick for users. So, adding complex
    text columns to show on interactivity is not advised in order to increase the
    loading of UTFGrids. Then we add this layer to the map with the chaining method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所讨论的，有一个名为 `interactivity` 的字段。这个字段应该填写将要用于交互的列名；确保交互对用户来说快速是很重要的。因此，不建议添加复杂的文本列以显示在交互中，以增加
    UTFGrid 的加载。然后我们使用链式方法将此层添加到地图中。
- en: 'We added the CartoDB layer to the map but there are still missing pieces to
    activate the interactivity. We add another chaining method to add the necessary
    functionality as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 CartoDB 层添加到地图中，但仍有缺失的部分来激活交互。我们添加另一个链式方法来添加必要的功能，如下所示：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This `done()` method is called when the layer is created and added to the map.
    First, we assign the local variable `layer` to the global variable `cartoLayer`
    to manipulate the SQL query of the `layer` variable later. Then, we activate the
    info window with the `cartodb.vis.Vis.addInfoWindow()` method. But there are still
    required code parts for activating UTFGrid, which are given as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当层被创建并添加到地图中时，会调用 `done()` 方法。首先，我们将局部变量 `layer` 赋值给全局变量 `cartoLayer`，以便稍后操作
    `layer` 变量的 SQL 查询。然后，我们使用 `cartodb.vis.Vis.addInfoWindow()` 方法激活信息窗口。但激活 UTFGrid
    还需要一些代码部分，如下所示：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first line activated the UTFGrid interaction, but we still need to know
    where and when to show the data. With the `featureOver` event of the layer, we
    catch each mouse move, get the related data from UTFGrid, and show it on the `div`
    element defined. We only show the `name` and `pop2005` fields of the layer on
    each mouse move.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行激活了 UTFGrid 交互，但我们仍然需要知道在哪里以及何时显示数据。通过层的 `featureOver` 事件，我们捕捉到每个鼠标移动，从 UTFGrid
    获取相关数据，并在定义的 `div` 元素上显示。我们只在鼠标移动时显示层的 `name` 和 `pop2005` 字段。
- en: 'The final part of the recipe is to search for the countries by typing their
    names. This part is like writing the SQL query. On each `click` event of the **Search**
    button, we get the value of the textbox and assign it to a local variable named
    `txtValue`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱的最后部分是通过输入国家名称来搜索国家。这部分就像编写 SQL 查询。在 **搜索** 按钮的每个 `click` 事件中，我们获取文本框的值并将其赋值给一个名为
    `txtValue` 的局部变量：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we have the `txtValue` variable, we set the query of the CartoDB layer
    by using the `setQuery()` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有 `txtValue` 变量时，我们通过使用 `setQuery()` 方法设置 CartoDB 图层的查询：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the `txtValue` variable is empty, we recover the defined cartography; otherwise,
    we change the cartography of the layers to a black color to see which countries
    are selected by using the `setCartoCSS()` method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `txtValue` 变量为空，我们将恢复定义的制图；否则，我们将使用 `setCartoCSS()` 方法将图层的制图颜色更改为黑色，以查看哪些国家被选中：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following screenshot is taken after searching countries whose names include
    `Turk`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是在搜索包含 `Turk` 的国家名称后获取的：
- en: '![How it works...](img/8825OT_08_08.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8825OT_08_08.jpg)'
- en: As we have seen in this recipe, CartoDB is a complete solution for everyone,
    from basic map visualization to complex GIS analysis. You can use the complete
    power of PostGIS behind your geo-web applications.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本配方中看到的，CartoDB 是一个面向所有人的完整解决方案，从基本的地图可视化到复杂的 GIS 分析。您可以使用 PostGIS 的全部功能在您的地理网络应用程序后面。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。Google Maps JavaScript API 基础")中 *Google Maps JavaScript
    API 基础* 的 *在自定义 DIV 元素中创建简单地图* 配方'
- en: Accessing ArcGIS Server with the Google Maps JavaScript API
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Maps JavaScript API 访问 ArcGIS Server
- en: ArcGIS Server is the mapping and spatial server developed by ESRI. It is a proprietary
    software, but the capabilities and integration with desktop software make ArcGIS
    Server better than other spatial server products. ArcGIS Server is a complete
    spatial server solution for enterprise corporations or institutions. ArcGIS Server
    is used for creating and managing GIS web services, applications, and data. ArcGIS
    Server is typically deployed on-premises within the organization's **Service-oriented
    Architecture** (**SOA**) or off-premises in a cloud computing environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS Server 是由 ESRI 开发的地图和空间服务器。它是一款专有软件，但它的功能和与桌面软件的集成使 ArcGIS Server 比其他空间服务器产品更出色。ArcGIS
    Server 是面向企业公司或机构的完整空间服务器解决方案。ArcGIS Server 用于创建和管理 GIS 网络服务、应用程序和数据。ArcGIS Server
    通常在组织内部署在 **面向服务的架构**（**SOA**）或云计算环境中。
- en: ESRI releases APIs for the ArcGIS Server to use in multiple platforms, but ESRI
    does not support the Google Maps JavaScript API v3\. There was an extension for
    the Google Maps JavaScript API v2, but it does not work with the new API. There
    is an open source library to extend the Google Maps JavaScript API v3 to work
    with ArcGIS Server.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ESRI 为 ArcGIS Server 发布了适用于多个平台的 API，但 ESRI 不支持 Google Maps JavaScript API v3。曾经有一个
    Google Maps JavaScript API v2 的扩展，但它不与新 API 一起工作。有一个开源库可以将 Google Maps JavaScript
    API v3 扩展以与 ArcGIS Server 一起工作。
- en: In this recipe, we will use the open source library to work with ArcGIS Server.
    We will add both a tiled and dynamic layer to the Google Maps JavaScript API.
    We also identify the dynamic layer with mouse clicks and show the underlying information.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将使用开源库与 ArcGIS Server 一起工作。我们将向 Google Maps JavaScript API 添加瓦片和动态图层。我们还通过鼠标点击识别动态图层，并显示底层信息。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More about the open source ArcGIS Server library**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于开源 ArcGIS Server 库的更多信息**'
- en: ArcGIS Server link for the Google Maps JavaScript API v3 is an open source library
    and can be found the following web address. It is advised to download and check
    the library at [https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html](https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API v3 的 ArcGIS 服务器链接是一个开源库，可以在以下网址找到。建议下载并检查该库：[https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html](https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html)。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is still using the same map creation process defined in [Chapter
    1](ch01.html "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript
    API Basics*, but there are some additional code blocks to add ArcGIS tiled/dynamic
    layers and listen for mouse clicks to identify the dynamic layer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方仍在使用[第 1 章](ch01.html "第 1 章。Google Maps JavaScript API 基础")中定义的相同地图创建过程，即
    *Google Maps JavaScript API 基础*，但有一些额外的代码块用于添加 ArcGIS 瓦片/动态图层，并监听鼠标点击以识别动态图层。
- en: You can find the source code at `Chapter 8/ch08_arcgis_layer.html`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `Chapter 8/ch08_arcgis_layer.html` 找到源代码。
- en: How to do it…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following are the steps we need to access ArcGIS Server with the Google
    Maps JavaScript API:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要使用 Google Maps JavaScript API 访问 ArcGIS Server 的步骤：
- en: 'First, download the ArcGIS Server link for the Google Maps JavaScript API v3
    from the following address: [https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html](https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html).'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从以下地址下载Google Maps JavaScript API v3的ArcGIS Server链接：[https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html](https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html)。
- en: 'The next step is to add the downloaded library to your HTML file:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将下载的库添加到你的HTML文件中：
- en: '[PRE36]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The jQuery library is also needed in this recipe:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个菜谱中还需要jQuery库：
- en: '[PRE37]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We also need some global variables as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一些全局变量，如下所示：
- en: '[PRE38]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, create a tiled map layer named `tiledMap` with an opacity of `0.6`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`tiledMap`的瓦片地图图层，其不透明度为`0.6`：
- en: '[PRE39]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, create a dynamic map layer named `dynamicMap` with an opacity of `0.8`.
    Also, a copyright control is added to the map:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`dynamicMap`的动态地图图层，其不透明度为`0.8`。同时，添加版权控制到地图中：
- en: '[PRE40]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We also need a map service for identifying with the same URL used in the dynamic
    map layer:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个与动态地图图层使用的相同URL进行识别的地图服务：
- en: '[PRE41]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, start listening to the `map` object for each mouse click event:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始监听`map`对象上的每个鼠标点击事件：
- en: '[PRE42]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s create the function that is called on each mouse click event:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个在每个鼠标点击事件上被调用的函数：
- en: '[PRE43]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Afterward, we will show the results in an info window:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将在信息窗口中显示结果：
- en: '[PRE44]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we add the function used for showing polygons. This function is used
    in the previous recipes:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加用于显示多边形的函数。这个函数在之前的菜谱中使用：
- en: '[PRE45]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, add the following function for removing all the polygons:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下用于删除所有多边形的函数：
- en: '[PRE46]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following code block listens to the checkboxes and switches the visibility
    of both tiled and dynamic layers:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块监听复选框并切换瓦片和动态图层的可见性：
- en: '[PRE47]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The last step is to add the necessary HTML tags for checkboxes:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是添加必要的复选框HTML标签：
- en: '[PRE48]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Go to your local URL where the HTML is stored in your favorite browser and enable
    **Add Topo Map Overlay** by clicking on the checkbox nearby. The following topological
    map is shown on the satellite base map:![How to do it…](img/8825OT_08_09.jpg)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你最喜欢的浏览器中存储HTML的本地URL，并通过点击附近的复选框启用**添加拓扑地图覆盖**。以下拓扑地图显示在卫星基础地图上：![如何操作…](img/8825OT_08_09.jpg)
- en: Thus, we have successfully created a map that accesses the ArcGIS Server layers
    with the Google Maps JavaScript API.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经成功创建了一个使用Google Maps JavaScript API访问ArcGIS Server图层的地图。
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: ArcGIS Server has different capabilities to use with the Google Maps JavaScript
    API. The library used to access ArcGIS Server in this recipe has almost every
    method for the REST API of the ArcGIS Server. The library is created on the Google
    Maps JavaScript API base classes, so using it is not as difficult as expected.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS Server具有与Google Maps JavaScript API一起使用的不同功能。在这个菜谱中用于访问ArcGIS Server的库几乎包含了ArcGIS
    Server REST API的所有方法。该库基于Google Maps JavaScript API的基类创建，因此使用它并不像预期的那样困难。
- en: The service URLs used in this recipe are serving by ESRI, so you can use them
    for developing purposes without any problems. If you want to use them in a production
    environment, please contact ESRI to get valid licenses.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中使用的服务URL由ESRI提供服务，因此你可以无任何问题地用于开发目的。如果你想在生产环境中使用它们，请联系ESRI获取有效许可证。
- en: 'In the first step, we will add a tiled map showing the topology of the world
    on the satellite base map. With the help of the `gmaps.ags.MapType` class, you
    can easily create a tiled map with a URL to the map service:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们将添加一个在卫星基础地图上显示世界拓扑的瓦片地图。借助`gmaps.ags.MapType`类，你可以轻松地创建一个带有地图服务URL的瓦片地图：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Adding and removing the tiled map is done in the the same way as we did in
    [Chapter 2](ch02.html "Chapter 2. Adding Raster Layers"), *Adding Raster Layers*.
    Please get the index of the layer. This index is used when removing the layer
    from map:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和删除瓦片地图的方式与我们在[第2章](ch02.html "第2章。添加栅格图层")中做的一样，*添加栅格图层*。请获取图层的索引。这个索引在从地图中移除图层时使用：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Creating a dynamic layer is also very easy thanks to the library. The library
    handles all the code for drawing the dynamic layer. The sample dynamic layer used
    in this recipe is the CENSUS data layer, which has the demographic information
    about states, counties, or census blocks of the U.S.:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于库的存在，创建动态图层也非常简单。库处理绘制动态图层所需的所有代码。在这个菜谱中使用的示例动态图层是CENSUS数据层，它包含有关美国各州、县或人口普查区的人口统计信息：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following is the screenshot of the CENSUS layer:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 CENSUS 层的截图：
- en: '![How it works...](img/8825OT_08_10.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8825OT_08_10.jpg)'
- en: 'Adding and removing the dynamic layer are the same as overlays because the
    `gmaps.ags.MapOverlay` class is extended from the `google.maps.OverlayView` base
    class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和删除动态图层与覆盖层相同，因为 `gmaps.ags.MapOverlay` 类是从 `google.maps.OverlayView` 基类扩展而来的：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Identifying a map layer is a very important task for most geo-web applications.
    This gives information to users about the layer at known points. To achieve this,
    we need to define a map service as follows. The `gmaps.ags.MapService` class only
    gets the URL parameters, which are defined for the dynamic layer before:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 识别地图图层对于大多数地理网络应用来说是一项非常重要的任务。这为用户提供了关于已知点的图层信息。为了实现这一点，我们需要定义一个地图服务，如下所示。`gmaps.ags.MapService`
    类仅获取在动态图层之前定义的 URL 参数：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When a map `click` event occurs, we need to handle it with a function named
    `identify`. This function gets the `latLng` object and trigger the `identify`
    method of the `gmaps.ags.MapService` class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当地图发生 `click` 事件时，我们需要使用名为 `identify` 的函数来处理它。这个函数获取 `latLng` 对象并触发 `gmaps.ags.MapService`
    类的 `identify` 方法：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `identify` method gets some parameters as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`identify` 方法获取以下参数：'
- en: '`geometry`: This gets `LatLng`, `Polyline`, or `Polygon` objects.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometry`: 这将获取 `LatLng`、`Polyline` 或 `Polygon` 对象。'
- en: '`tolerance`: This is the distance in screen pixels where the mouse is clicked.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tolerance`: 这是鼠标点击处的屏幕像素距离。'
- en: '`layerIds`: This array contains layer IDs. The value `5` in this recipe defines
    the state''s layer.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layerIds`: 这个数组包含图层 ID。在这个菜谱中，值 `5` 定义了该州图层。'
- en: '`layerOption`: These options can be `top`, `visible`, or `all`.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layerOption`: 这些选项可以是 `top`、`visible` 或 `all`。'
- en: '`bounds`: This gets an object created from the `LatLngBounds` class. This defines
    the current bounds of the map.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bounds`: 这将获取由 `LatLngBounds` 类创建的对象。这定义了地图的当前边界。'
- en: '`width`: This is the width of the map `div` element.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`: 这是指地图 `div` 元素的宽度。'
- en: '`height`: This is the height of the map `div` element.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`: 这是指地图 `div` 元素的高度。'
- en: 'The return of the function contains an array of features that contains both
    the attribute and geometry data. The result function can iterate over this array
    and show the attribute data in an info window. The geometry of each feature can
    also be shown on the map. The result of the `identify` operation is shown in the
    following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值包含一个包含属性和几何数据的特征数组。结果函数可以遍历这个数组，并在信息窗口中显示属性数据。每个特征的几何也可以在地图上显示。`identify`
    操作的结果如下截图所示：
- en: '![How it works...](img/8825OT_08_11.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8825OT_08_11.jpg)'
- en: ArcGIS Server is a powerful tool to use with the Google Maps JavaScript API
    if you have the license. There are also other GIS functionalities such as geoprocessing,
    geocoding, or geometry service, which are not included in this recipe due to the
    scope, but their usage is no different from the `identify` operation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有许可证，ArcGIS Server 是与 Google Maps JavaScript API 一起使用的强大工具。还有一些其他 GIS 功能，如地理处理、地理编码或几何服务，由于范围限制，这些功能不包括在这个菜谱中，但它们的用法与
    `identify` 操作没有不同。
- en: The Google Maps JavaScript API is a perfect mapping tool and is powerful with
    this kind of service and libraries.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API 是一种完美的地图工具，并且与这类服务和库结合使用非常强大。
- en: There's more…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In this recipe, we focused on the ArcGIS Server, but ESRI also has an alternative
    cloud solution named ArcGIS Online ([www.arcgis.com](http://www.arcgis.com)).
    It is the cloud version of the ArcGIS Server and the usage of its services are
    almost the same as ArcGIS Server's services.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们专注于 ArcGIS Server，但 ESRI 还有一个名为 ArcGIS Online 的替代云解决方案([www.arcgis.com](http://www.arcgis.com))。它是
    ArcGIS Server 的云版本，其服务的使用几乎与 ArcGIS Server 的服务相同。
- en: See also
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章. Google Maps JavaScript API 基础") 的 *在自定义 DIV 元素中创建简单地图*
    菜谱中，*Google Maps JavaScript API 基础*
- en: The *Adding popups to markers or maps* recipe in [Chapter 3](ch03.html "Chapter 3. Adding
    Vector Layers"), *Adding Vector Layers*
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章. 添加矢量图层") 的 *向标记或地图添加弹出窗口* 菜谱中，*添加矢量图层*
- en: The *Adding polygons to maps* recipe in [Chapter 3](ch03.html "Chapter 3. Adding
    Vector Layers"), *Adding Vector Layers*
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章. 添加矢量图层") 的 *向地图添加多边形* 菜谱中，*添加矢量图层*
- en: The *Getting coordinates of a mouse click* recipe in [Chapter 5](ch05.html "Chapter 5. Understanding
    Google Maps JavaScript API Events"), *Understanding Google Maps JavaScript API
    Events*
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。理解Google Maps JavaScript API事件")中*理解Google Maps JavaScript
    API事件*的*获取鼠标点击坐标*食谱'
- en: Accessing GeoServer with the Google Maps JavaScript API
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Google Maps JavaScript API访问GeoServer
- en: GeoServer is an open source map server written in Java that allows users to
    share and edit geospatial data. It is one of the popular open source map servers
    that can publish OGC compliant services such as WMS and WFS. **Web Map Service**
    (**WMS**) is used for publishing georeferenced images and simple querying. On
    the other side, **Web Feature Service** (**WFS**) is used for publishing vector
    data to any kind of GIS clients. WFS is mostly used for data sharing purposes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: GeoServer是一个用Java编写的开源地图服务器，允许用户共享和编辑地理空间数据。它是可以发布OGC兼容服务（如WMS和WFS）的流行开源地图服务器之一。**Web地图服务**（**WMS**）用于发布地理参考图像和简单查询。另一方面，**Web要素服务**（**WFS**）用于将矢量数据发布到任何类型的GIS客户端。WFS主要用于数据共享目的。
- en: In this recipe, we will use one of GeoServer's standard published service named
    `topp:states` in WMS format. As stated in the *Adding WMS layers to maps* recipe
    of this chapter, WMS has different request types such as `GetMap` or `GetCapabilities`.
    We will also use a `GetFeatureInfo` addition to the `GetMap` request. This new
    request gets the information of the point on the map. Also, we used a tiled structure
    in this recipe to get WMS images in order to make a comparison between the untiled
    structure in the *Adding WMS layers to maps* recipe and the tiled structure in
    this recipe.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用GeoServer的一个标准已发布服务，名为`topp:states`，格式为WMS。正如本章中*将WMS图层添加到地图*食谱中所述，WMS有不同的请求类型，如`GetMap`或`GetCapabilities`。我们还将使用`GetFeatureInfo`对`GetMap`请求的附加功能。这个新请求获取地图上点的信息。此外，在本食谱中，我们使用瓦片结构来获取WMS图像，以便将本章中*将WMS图层添加到地图*食谱中的无瓦片结构与本食谱中的瓦片结构进行比较。
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the first recipe defined in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*,
    as a template in order to skip the map creation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用[第1章](ch01.html "第1章。Google Maps JavaScript API基础")中定义的第一个食谱，即*Google
    Maps JavaScript API基础*，作为模板以跳过地图创建。
- en: You can find the source code at `Chapter 8/ch08_geoserver.html`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter 8/ch08_geoserver.html`找到源代码。
- en: How to do it…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'You can easily access GeoServer with the Google Maps JavaScript API after performing
    the following steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行以下步骤后，你可以轻松地使用Google Maps JavaScript API访问GeoServer：
- en: 'First, we create a `wms-tiled.js` file to include in the HTML later. This JavaScript
    file has the `WMSTiled` and `WMSFeatureInfo` classes. Let''s add the `WMSTiled`
    class as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`wms-tiled.js`文件，稍后将其包含在HTML中。这个JavaScript文件包含了`WMSTiled`和`WMSFeatureInfo`类。让我们按照以下方式添加`WMSTiled`类：
- en: '[PRE55]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, create the `WMSFeatureInfo` class and its `getUrl` method:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建`WMSFeatureInfo`类及其`getUrl`方法：
- en: '[PRE56]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The last step in the `wms-tiled.js` file is to add the `toMercator()` method:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`wms-tiled.js`文件的最后一步是添加`toMercator()`方法：
- en: '[PRE57]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we have our JavaScript class file; add the following line after adding
    the Google Maps JavaScript API:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了我们的JavaScript类文件；在添加Google Maps JavaScript API后，添加以下行：
- en: '[PRE58]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We also need to add a jQuery library to the HTML file:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将jQuery库添加到HTML文件中：
- en: '[PRE59]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, create a tiled WMS from the class written in the `wms-tiled.js` file:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`wms-tiled.js`文件中创建一个瓦片WMS：
- en: '[PRE60]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The next step is to create an object from the `WMSFeatureInfo` class to be
    used later in the event listener:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是从`WMSFeatureInfo`类创建一个对象，以便稍后在事件监听器中使用：
- en: '[PRE61]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The last step is to listen to the `click` event of the map to get information
    from the map:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是监听地图的`click`事件以从地图获取信息：
- en: '[PRE62]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Go to your local URL where the HTML is stored in your favorite browser and try
    to click on the map where you want to get info.![How to do it…](img/8825OT_08_12.jpg)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你喜欢的浏览器中存储HTML的本地URL，并尝试点击你想要获取信息的地图位置。![如何操作…](img/8825OT_08_12.jpg)
- en: The previous screenshot is the result of the recipe that shows WMS layers created
    by GeoServer on the Google Maps JavaScript API.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图是本食谱的结果，显示了在Google Maps JavaScript API上由GeoServer创建的WMS图层。
- en: How it works...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用原理...
- en: Accessing GeoServer is not much different from accessing a WMS server because
    they share the same standards. With GeoServer, you can publish your data on your
    own servers with your security standards.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 访问GeoServer与访问WMS服务器没有太大区别，因为它们共享相同的标准。使用GeoServer，你可以根据你的安全标准在自己的服务器上发布你的数据。
- en: In this recipe, we installed a fresh GeoServer to our Mac OS X and its sample
    data is ready for serving WMS and WFS. We used the sample states data of the U.S.
    on WMS to show the interaction.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们在Mac OS X上安装了一个新的GeoServer，其示例数据已准备好提供WMS和WFS服务。我们使用美国示例州数据在WMS中显示交互。
- en: In our case, we are serving HTML files from `localhost` on port 80, but GeoServer
    is working from `localhost` on port 8080\. This is a problem for our case, because
    we cannot access GeoServer when getting information due to the cross-site scripting
    security limitation of HTML. The solution is using a JSONP format to pass over
    the limitation. GeoServer can give the JSONP format, but you should activate it
    from the options.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们从`localhost`的80端口提供HTML文件，但GeoServer在`localhost`的8080端口运行。这在我们案例中是一个问题，因为我们无法在获取信息时访问GeoServer，这是由于HTML的跨站脚本安全限制。解决方案是使用JSONP格式来跨越限制。GeoServer可以提供JSONP格式，但您应该从选项中激活它。
- en: In the *Adding WMS layers to maps* recipe of this chapter, we used the untiled
    structure to get WMS images, but this time, we are using the tiled structure to
    get WMS images. The difference can be seen in the screenshot of untiled and tiled
    usage of WMS that the abbreviation of states' names occurring more than once on
    tiled WMS because the geometry of the same state can be seen in different images
    of tiled WMS. As said, the choice is yours whether it is tiled or untiled according
    to your geo-web application's needs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的*将WMS层添加到地图*食谱中，我们使用了无瓦片结构来获取WMS图像，但这次我们使用瓦片结构来获取WMS图像。在无瓦片和瓦片WMS使用的截图中的差异可以观察到，瓦片WMS中州名的缩写出现多次，因为同一州的几何形状可以在瓦片WMS的不同图像中看到。正如所说，选择权在你，根据你的地理Web应用需求，选择瓦片或无瓦片。
- en: 'Creating a tiled structure in WMS is done in exactly the same way as we did
    in the *Adding tile overlays to maps* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*. The important part here is to create
    the URL for each tile. The `BBOX` parameter for each tile is calculated as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在WMS中创建瓦片结构的方式与我们在[第2章](ch02.html "第2章。添加栅格层")的*将瓦片覆盖添加到地图*食谱中做的方式完全相同，*添加栅格层*。这里的重要部分是创建每个瓦片的URL。每个瓦片的`BBOX`参数计算如下：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There is a need for projection transformation to get tiles that will fit exactly
    on the Google Maps' base map. Google Maps has a Web Mercator projection so the
    overlays need to be in this projection.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行投影变换以获取恰好适合Google Maps基础地图的瓦片。Google Maps具有Web Mercator投影，因此覆盖层需要使用此投影。
- en: One of the other parameters needed for URL is the WMS standard parameter, but
    be sure about the difference of parameters according to the WMS versions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: URL需要的另一个参数是WMS标准参数，但请确保根据WMS版本了解参数的差异。
- en: The `SRS` parameter used in this recipe is `EPSG:3857`, which is the equivalent
    of `EPSG:900913`, `ESRI:102113`, or `ESRI:102100`. All `SRS` parameters mentioned
    here define the Web Mercator projection systems.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中使用的`SRS`参数是`EPSG:3857`，它与`EPSG:900913`、`ESRI:102113`或`ESRI:102100`等价。这里提到的所有`SRS`参数都定义了Web
    Mercator投影系统。
- en: 'The `WMSFeatureInfo` class is written for creating WMS get info requests. The
    parameters of the URL are important, which are as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`WMSFeatureInfo`类是为创建WMS获取信息请求而编写的。URL的参数很重要，如下所示：'
- en: '`x`: This is the x coordinate of the mouse in pixels.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：这是鼠标的像素x坐标。'
- en: '`y`: This is the y coordinate of the mouse in pixels.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`：这是鼠标的像素y坐标。'
- en: '`width`: This is the width of the map `div` element.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`：这是地图`div`元素的宽度。'
- en: '`height`: This is the height of the map `div` element.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`：这是地图`div`元素的高度。'
- en: '`info_format`: This is a string that describes the return format of information.
    In this case, `Text`/`JavaScript` is used for getting info in the format of JSONP.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_format`：这是一个字符串，描述了信息的返回格式。在这种情况下，使用`Text`/`JavaScript`以JSONP格式获取信息。'
- en: '`query_layers`: This is the comma-separated list of layers to be queried.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query_layers`：这是要查询的层的逗号分隔列表。'
- en: '`layers`: This is the comma- separated list of layers to be shown (coming from
    the `GetMap` request).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layers`：这是要显示的层的逗号分隔列表（来自`GetMap`请求）。'
- en: '`bbox`: This is the bounding box of the map shown.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bbox`：这是显示的地图的边界框。'
- en: '`format_options`: This is required for JSONP to define the name of the `callback`
    function. The `callback` function''s name must be the same as in the jQuery AJAX
    request to get information without any errors.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format_options`：对于JSONP是必需的，用于定义`callback`函数的名称。`callback`函数的名称必须与jQuery AJAX请求中获取信息时相同，以避免任何错误。'
- en: 'The `getUrl` method gets the `LatLng` object as an input, but there is a need
    for screen coordinates in the `GetFeatureInfo` request. We came up with a trick
    in order to convert `LatLng` to screen coordinates in the `getUrl` method. In
    the constructor, we create an overlay with the `google.maps.OverlayView` class
    and use its functions to convert `LatLng` to screen coordinates:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUrl`方法接受`LatLng`对象作为输入，但在`GetFeatureInfo`请求中需要屏幕坐标。我们想出了一个技巧，以便在`getUrl`方法中将`LatLng`转换为屏幕坐标。在构造函数中，我们使用`google.maps.OverlayView`类创建一个覆盖层，并使用其功能将`LatLng`转换为屏幕坐标：'
- en: '[PRE64]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `google.maps.Projection` class has a method named `fromLatLngToPoint()`
    to convert the `LatLng` object to screen coordinates but this does not work as
    it is expected to. This converts the `LatLng` coordinates to screen coordinates
    in world scale, but we need to get the screen coordinates in the map's `div` reference.
    To achieve this, we use the `google.maps.MapCanvasProjection` class method named
    `fromLatLngToContainerPixel()`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`google.maps.Projection`类有一个名为`fromLatLngToPoint()`的方法，用于将`LatLng`对象转换为屏幕坐标，但这个方法并不像预期的那样工作。这个方法将`LatLng`坐标转换为世界比例的屏幕坐标，但我们需要获取地图`div`引用中的屏幕坐标。为了实现这一点，我们使用`google.maps.MapCanvasProjection`类的方法`fromLatLngToContainerPixel()`。'
- en: We didn't go into detail with listening to the map `click` event and showing
    popups. Also, we used the `ajax` method of jQuery to get a JSONP request, which
    is also out of the scope of this book. If you want to get details of these topics,
    please refer to previous recipes of related chapters.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有详细讲解如何监听地图`click`事件并显示弹出窗口。此外，我们使用了jQuery的`ajax`方法来获取JSONP请求，这也不在本书的范围之内。如果您想了解这些主题的详细信息，请参考相关章节的先前菜谱。
- en: See also
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。Google Maps JavaScript API基础知识")的“在自定义DIV元素中创建简单地图”菜谱中，*Google
    Maps JavaScript API基础知识*
- en: The *Adding popups to markers or maps* recipe in [Chapter 3](ch03.html "Chapter 3. Adding
    Vector Layers"), *Adding Vector Layers*
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。添加矢量图层")的“向标记或地图添加弹出窗口”菜谱中，*添加矢量图层*
- en: The *Getting coordinates of a mouse click* recipe in [Chapter 5](ch05.html "Chapter 5. Understanding
    Google Maps JavaScript API Events"), *Understanding Google Maps JavaScript API
    Events*
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。理解Google Maps JavaScript API事件")的“获取鼠标点击坐标”菜谱中，*理解Google
    Maps JavaScript API事件*
- en: The *Adding WMS layers to maps* recipe
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向地图添加WMS图层*的菜谱'
