- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Asynchronous Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: This chapter will explain in detail how to use all the asynchronous mechanisms
    that JavaScript offers today, including how to convert callbacks to promises and
    perform bulk asynchronous operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细解释如何使用JavaScript今天提供的所有异步机制，包括如何将回调转换为Promise以及执行批量异步操作。
- en: You will gain an in-depth understanding of all the tools at your disposal for
    managing both simple and complex asynchronous activities. We’ll begin with callbacks
    following Node.js Core conventions, then progress to effectively handling asynchronous
    operations using promises, and `async`/`await`. Toward the end of the chapter,
    we’ll employ the **Immediately Invoked Function Expression (IIFE)** pattern to
    execute asynchronous code. Additionally, we will provide a comprehensive overview
    of how to convert asynchronous operations between different handlers, including
    callbacks and promises.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将深入了解您可用于管理简单和复杂异步活动的所有工具。我们将从遵循Node.js核心约定的回调开始，然后过渡到有效地使用Promise和`async`/`await`处理异步操作。在章节的末尾，我们将使用**立即执行的函数表达式（IIFE）**模式来执行异步代码。此外，我们还将提供如何在不同处理程序之间转换异步操作的全面概述，包括回调和Promise。
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是本章我们将探讨的主要主题：
- en: Asynchronous programming in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中的异步编程
- en: Understanding callbacks and how to avoid callback hell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解回调函数以及如何避免回调地狱
- en: Mastering promises
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握Promise
- en: Using `async` and `await` for handling asynchronous code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`async`和`await`处理异步代码
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该章节的代码文件可以在[https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)找到。
- en: Check out the code in action video for this chapter on [https://youtu.be/FHzqWr4dK7s](https://youtu.be/FHzqWr4dK7s)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本章的代码演示视频，链接为[https://youtu.be/FHzqWr4dK7s](https://youtu.be/FHzqWr4dK7s)
- en: Asynchronous programming in JavaScript
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的异步编程
- en: In JavaScript, asynchronous programming is a fundamental part of the language.
    It is the mechanism that allows us to perform operations in the background, without
    blocking the execution of the main thread. This is especially important in the
    browser, where the main thread is responsible for updating the user interface
    and responding to user actions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，异步编程是语言的基本组成部分。它是允许我们在后台执行操作而不阻塞主线程执行的机制。这在浏览器中尤为重要，因为主线程负责更新用户界面和响应用户操作。
- en: Overall, asynchronous programming is a complex topic that requires a lot of
    practice to master, but in my opinion, it requires a change in your mindset. You
    will need to start thinking about how to break down your code into small chunks
    that can be executed in the background, and how to combine them to achieve the
    desired result. You’ll encounter asynchronous programming regularly while coding
    with JavaScript. Most operations involving interactions with external resources,
    such as sending and receiving data from a server or a database and reading the
    content from a file, will necessitate its use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，异步编程是一个复杂的主题，需要大量的实践才能掌握，但在我看来，它需要改变你的思维方式。你需要开始思考如何将代码分解成可以在后台执行的小块，以及如何将它们组合起来以实现预期的结果。在用JavaScript编码时，你将经常遇到异步编程。大多数涉及与外部资源交互的操作，例如从服务器或数据库发送和接收数据以及从文件中读取内容，都需要使用它。
- en: Previous knowledge
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前置知识
- en: In [*Chapter 1*](B21678_01.xhtml#_idTextAnchor015) we introduced the concept
    of the event loop, which is the mechanism that allows JavaScript to be asynchronous.
    In this chapter, we will see how to use this mechanism to our advantage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B21678_01.xhtml#_idTextAnchor015)中，我们介绍了事件循环的概念，这是允许JavaScript异步执行的一种机制。在本章中，我们将探讨如何利用这一机制来发挥我们的优势。
- en: In [*Chapter 3*](B21678_03.xhtml#_idTextAnchor056)*,* we learned how to use
    JavaScript in detail; this chapter requires a solid knowledge of functions and
    arrays.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第三章*](B21678_03.xhtml#_idTextAnchor056)中，我们详细学习了JavaScript的使用；本章需要具备对函数和数组有扎实的了解。
- en: Let’s begin by exploring how asynchronous programming differs from conventional
    programming and how we need to adopt a different mindset.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探讨异步编程与常规编程的不同之处以及我们需要采取不同的思维方式开始。
- en: This chapter uses isomorphic JavaScript snippets, so the code can be executed
    in Node.js or in the browser.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用同构JavaScript代码片段，因此代码可以在Node.js或浏览器中执行。
- en: The asynchronous mindset
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步思维
- en: The first step in mastering asynchronous programming is to change your mindset.
    You need to start thinking about your code in a non-linear way; you will think
    more about “what should happen next” rather than “what should happen first.”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握异步编程的第一步是改变你的思维方式。你需要开始以非线性方式思考你的代码；你将更多地考虑“接下来应该发生什么”，而不是“首先应该发生什么。”
- en: When we learned about functions in [*Chapter 3*](B21678_03.xhtml#_idTextAnchor056),
    we saw that a function is *just* a piece of code that can be executed at any time.
    In this section, we will connect that piece of code to previous events, and to
    future events.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第三章*](B21678_03.xhtml#_idTextAnchor056)中学习函数时，我们看到了函数*仅仅*是一段可以在任何时间执行的代码。在本节中，我们将这段代码与之前的事件以及未来的事件联系起来。
- en: 'There are many ways to perform asynchronous operations in JavaScript. In this
    chapter, we will focus on the most common ones, which are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中执行异步操作有许多方法。在本章中，我们将重点关注其中最常见的一些，如下所示：
- en: '**Callbacks**: A callback is a function that is passed as an argument to another
    function, and it is executed when a certain event happens. This is the most basic
    way to perform asynchronous operations in JavaScript, and it is the foundation
    of all the other mechanisms.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调**：回调是一个作为另一个函数参数的函数，它在某个事件发生时执行。这是在JavaScript中执行异步操作最基本的方式，也是所有其他机制的基础。'
- en: '**Promises**: ES6 introduced the concept of promises, which you can use to
    handle asynchronous operations in an advanced way because they use a state machine
    with several states (pending, fulfilled, and rejected) to keep track of operations.
    Promises have many advantages over callbacks in terms of readability, reusability,
    and overall simplicity. This is the most common way to perform asynchronous operations
    in modern JavaScript today. For more details, check out the *Mastering promises*
    section in this chapter.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Promises**：ES6引入了promise的概念，你可以用它以更高级的方式处理异步操作，因为它们使用具有多个状态（挂起、已解决和拒绝）的状态机来跟踪操作。与回调相比，promises在可读性、可重用性和整体简单性方面具有许多优势。这是现代JavaScript中执行异步操作最常见的方式。有关更多详细信息，请参阅本章中的*掌握promises*部分。'
- en: '**Async/await**: Async/await acts as a wrapper over promises to make code more
    readable (syntax sugar). Currently is the most popular way of handling asynchronous
    operations.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Async/await**：Async/await作为promises的包装器，使代码更易读（语法糖）。目前是处理异步操作最受欢迎的方式。'
- en: In the next section, we will explore how we can use callbacks effectively in
    our applications, the error first pattern, and other good practices to follow.
    Later on, we will explore how to wrap callbacks inside promises.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在我们的应用程序中有效地使用回调，错误优先模式，以及其他应遵循的良好实践。稍后，我们将探讨如何将回调包装在promises中。
- en: Understanding callbacks
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解回调
- en: 'Callbacks exploit JavaScript’s capability to pass functions. There are two
    essential parts to this technique:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 回调利用JavaScript传递函数的能力。这个技术有两个基本部分：
- en: A function that is passed as an argument to another function
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为另一个函数参数传递的函数
- en: The passed function is executed when a certain event happens
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当某个事件发生时，传递的函数将被执行
- en: 'Let’s create a basic example to illustrate this concept. In the following code
    snippets, we will show how the callback is defined as an argument and how a function
    is passed as an argument when the execution occurs:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本示例来阐述这个概念。在下面的代码片段中，我们将展示回调是如何作为一个参数定义的，以及当执行发生时，一个函数是如何作为一个参数传递的：
- en: 'In this example, we will define a function (`doSomething`) that expects a function
    as an argument:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将定义一个函数（`doSomething`），它期望一个函数作为参数：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At this point, we have a function called `doSomething` that receives a function
    as an argument and executes it as the last step, this illustrates the idea that
    the callbacks are just a pattern where we expect that the next function to the
    executed is actually called as the final step (call me back when you are done
    - callback) . Let’s see how we can use this function:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个名为`doSomething`的函数，它接收一个函数作为参数，并在最后一步执行它，这说明了回调只是这样一个模式，我们期望下一个被执行的函数实际上是作为最终步骤调用的（完成后再调用我
    - 回调）。让我们看看我们如何使用这个函数：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the function is executed, the expected output will be the following:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数执行后，预期的输出将是以下内容：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we have a function called `nextStep` that is passed as an argument to `doSomething`.
    When `doSomething` is executed, it will print `Doing something...`, and then it
    will execute the function that was passed as an argument, which will print `Callback
    called` as the last step.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为 `nextStep` 的函数，它作为参数传递给 `doSomething`。当 `doSomething` 执行时，它将打印 `Doing
    something...`，然后执行传递给它的函数，最后一步将打印 `Callback called`。
- en: 'It is important to note that the function that is passed as an argument is
    not executed immediately , as we only want to execute them when the operation
    is complete. On the other hand, the immediate execution will require the use of
    parentheses (`doSomething(nextStep())`) and will produce a different result and
    an error:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，作为参数传递的函数不是立即执行的，因为我们只想在操作完成时执行它们。另一方面，立即执行将需要使用括号（`doSomething(nextStep())`）并会产生不同的结果和错误：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also pass an anonymous function as an argument. This is the most common
    way to use callbacks, as we don’t need to define the functions previously. In
    most cases, we don’t reuse that function later:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传递一个匿名函数作为参数。这是使用回调函数最常见的方式，因为我们不需要事先定义函数。在大多数情况下，我们不会在之后重用该函数：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is also possible to pass a function that receives arguments:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以传递一个接收参数的函数：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the callback technique is very simple, but we haven’t seen any
    asynchronous operations yet. At the end of the day, we assume that a callback
    is literally a “call me back when you are done” approach. Now, let’s see how this
    can be used to manage asynchronous operations with timers and intervals.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，回调技术非常简单，但我们还没有看到任何异步操作。最终，我们假设回调函数字面意思是“当你完成时叫我回来”的方法。现在，让我们看看如何使用定时器和间隔来管理异步操作。
- en: Timers and intervals
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定时器和间隔
- en: There are two functions that are commonly used to delay the execution of a function,
    `setTimeout` and `setInterval`. Both functions receive a callback as an argument
    and execute it after a certain amount of time. Now, let’s define and use these
    functions in examples.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个常用的函数用于延迟函数的执行，即 `setTimeout` 和 `setInterval`。这两个函数都接收一个回调函数作为参数，并在一定时间后执行它。现在，让我们通过示例定义和使用这些函数。
- en: The `setTimeout` function is employed to defer the execution of a function by
    a specified amount of time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout` 函数用于通过指定的时间延迟来推迟一个函数的执行。'
- en: 'Let’s see how `setTimeout` works with a simple example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子看看 `setTimeout` 是如何工作的：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we execute this code, we will see the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此代码，我们将看到以下输出：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the callback is executed after the rest of the code, even though
    it was defined before. This is because the callback is executed asynchronously,
    which means that it is executed in the background, and the rest of the code is
    executed in the main thread.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，回调函数是在其他代码执行完毕后执行的，即使它是在之前定义的。这是因为回调函数是异步执行的，这意味着它在后台执行，而其他代码则在主线程中执行。
- en: The `setTimeout` function receives two arguments. The first one is the callback,
    and the second one is the amount of time that the callback should be delayed.
    The amount of time is expressed in milliseconds, so in this case, we are delaying
    the execution of the callback by 1,000 milliseconds, which is 1 second.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout` 函数接收两个参数。第一个参数是回调函数，第二个参数是回调函数应该延迟的时间量。时间量以毫秒为单位表示，因此在这种情况下，我们延迟回调函数的执行
    1,000 毫秒，即 1 秒。'
- en: The `setInterval` function is used to execute a function repeatedly, with a
    fixed time delay between each execution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval` 函数用于在每次执行之间有固定时间延迟的情况下重复执行一个函数。'
- en: 'Let’s see how `setInterval` works with a simple example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子看看 `setInterval` 是如何工作的：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we execute this code, we will see the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此代码，我们将看到以下输出：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the callback is executed every second, and it is executed in
    the background, so the rest of the code is executed in the main thread.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，回调函数每秒执行一次，并且它在后台执行，因此其他代码在主线程中执行。
- en: The `setInterval` function receives two arguments. The first one is the callback,
    and the second one is the amount of time that the callback should be delayed.
    The amount of time is expressed in milliseconds, so in this case, we are delaying
    the execution of the callback by 1,000 milliseconds, which is 1 second.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval` 函数接收两个参数。第一个参数是回调函数，第二个参数是回调函数应该延迟的时间量。时间量以毫秒为单位表示，因此在这种情况下，我们延迟回调函数的执行
    1,000 毫秒，即 1 秒。'
- en: Error first callbacks
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误优先回调
- en: In the examples in the preceding sections, we saw how to use callbacks to manage
    asynchronous operations, but we didn’t see how to handle errors. In this section,
    we will see how to handle errors in callbacks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用回调来管理异步操作，但没有看到如何处理错误。在本节中，我们将看到如何处理回调中的错误。
- en: 'The most common way to handle errors in callbacks is to use the error first
    pattern. This pattern consists of passing an error as the first argument of the
    callback, and the result as the second argument. Let’s see how this works with
    a simple example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中处理错误最常见的方式是使用错误优先模式。这个模式包括将错误作为回调的第一个参数传递，将结果作为第二个参数。让我们通过一个简单的例子看看它是如何工作的：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of this code will be as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出将如下所示：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we have a function called `doSomething` that receives a callback
    as an argument. This callback receives two arguments. The first one is an error,
    and the second one is the result. In this case, we are passing an error as the
    first argument, and `null` as the second argument because an error occurred. When
    the callback is executed, we check if the first argument is an error, and if it
    is, we print `There was an error`. Otherwise, we print `Everything` `went well`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个名为 `doSomething` 的函数，它接收一个回调作为参数。这个回调接收两个参数。第一个是一个错误，第二个是结果。在这种情况下，我们将错误作为第一个参数传递，将
    `null` 作为第二个参数，因为发生了错误。当回调执行时，我们检查第一个参数是否是错误，如果是，我们打印 `There was an error`。否则，我们打印
    `Everything` `went well`。
- en: 'Let’s see how this works when everything goes well:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当一切顺利时它是如何工作的：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of this code will be as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出将如下所示：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, we are passing `null` as the first argument as there is no error,
    and the result as the second argument. When the callback is executed, we check
    if the first argument is an error, and if it is, we print `There was an error`.
    Otherwise, we print the result, and `Everything` `went well`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们传递 `null` 作为第一个参数，因为没有错误，将结果作为第二个参数。当回调执行时，我们检查第一个参数是否是错误，如果是，我们打印
    `There was an error`。否则，我们打印结果，并打印 `Everything` `went well`。
- en: Callback hell
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调地狱
- en: Previously, we saw how to use callbacks to manage asynchronous operations and
    how to handle errors with the error first pattern.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何使用回调来管理异步操作，以及如何使用错误优先模式来处理错误。
- en: The problem with callbacks is that they are not very easy to read, and when
    we have a lot of nested callbacks, the code becomes very difficult to read. This
    is called callback hell, and it is a very common problem when using callbacks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 回调的问题在于它们不是很容易阅读，当我们有很多嵌套的回调时，代码变得非常难以阅读。这被称为回调地狱，这是使用回调时一个非常常见的问题。
- en: 'In the following pseudocode example, you can see how the functions are generated
    in an inclined pyramid with nested callbacks that make the code really hard to
    follow. In the following code example, observe how the functions are structured
    in an inclined pyramid with nested callbacks, making the code challenging to comprehend:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的伪代码示例中，你可以看到函数是如何以倾斜的金字塔形式生成的，嵌套的回调使得代码难以跟踪。在下面的代码示例中，观察函数是如何以倾斜的金字塔形式结构化，嵌套的回调使得代码难以理解：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the code is very difficult to read, and it is very easy to make
    mistakes. This is why we need a better way to manage asynchronous operations.
    There are some ways to prevent callback hell, such as using named functions instead
    of anonymous functions, but one of the most common ways to avoid callback hell
    is to use promises.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码非常难以阅读，并且很容易出错。这就是为什么我们需要一种更好的方式来管理异步操作。有一些方法可以防止回调地狱，例如使用命名函数而不是匿名函数，但避免回调地狱最常见的方法之一是使用承诺。
- en: Promises are a great solution when you need to chain asynchronous operations,
    let’s explore it in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要链式处理异步操作时，承诺是一个很好的解决方案，让我们在下一节中探讨它。
- en: Mastering promises
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握承诺
- en: 'A promise functions as a state machine, symbolizing the eventual success or
    failure of an asynchronous operation, along with its resultant value. It can exist
    in any of three states: pending, fulfilled, or rejected.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺作为一个状态机工作，表示异步操作最终的成功或失败，以及其结果值。它可以处于以下三种状态之一：挂起、实现或拒绝。
- en: When a promise is created, it is in the pending state. When a promise is fulfilled,
    it is in the fulfilled state. When a promise is rejected, it is in the rejected
    state.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当承诺被创建时，它处于挂起状态。当承诺被实现时，它处于实现状态。当承诺被拒绝时，它处于拒绝状态。
- en: 'The following diagram shows the various states of a promise and the connections
    between them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了承诺的各种状态及其之间的连接：
- en: '![Figure 4.1 – Attributions and copyright licensing by Mozilla Contributors
    is licensed under CC-BY-SA 2.5\. https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license](img/B21678_04_01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 由 Mozilla 贡献者提供的归属和版权许可受 CC-BY-SA 2.5 许可](img/B21678_04_01.jpg)'
- en: Figure 4.1 – Attributions and copyright licensing by Mozilla Contributors is
    licensed under CC-BY-SA 2.5\. [https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license](https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 由 Mozilla 贡献者提供的归属和版权许可受 CC-BY-SA 2.5 许可。[https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license](https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license)
- en: After a promise is fulfilled or rejected, it becomes unchangeable. To manage
    fulfillment, the `then` method is employed, while the `catch` method is used to
    address the rejection of the promise.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在承诺被解决或拒绝后，它变得不可更改。为了管理解决，我们使用 `then` 方法，而 `catch` 方法用于处理承诺的拒绝。
- en: Now that it is clear what the promises are and how the states are related, it
    is time to observe them in action. In the next section, we will explore how to
    use them and control any asynchronous flow effortlessly in JavaScript.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经清楚承诺是什么以及状态是如何相关的，现在是时候观察它们在实际中的应用了。在下一节中，我们将探讨如何使用它们，并在 JavaScript 中轻松控制任何异步流程。
- en: Using promises
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用承诺
- en: Let’s see how this works with a simple example using `fetch` to make a request
    to an external **application programming interface** (**API**). This example will
    be using my simple-api project ([https://github.com/UlisesGascon/simple-api](https://github.com/UlisesGascon/simple-api)),
    which is available at [https://api.demo.foo/__/docs/](https://api.demo.foo/__/docs/)
    and is a fake online **Representational State Transfer** (**REST**) API for testing
    and fast prototyping.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来看看使用 `fetch` 向外部 **应用程序编程接口**（**API**）发起请求是如何工作的。此示例将使用我的简单-api
    项目 ([https://github.com/UlisesGascon/simple-api](https://github.com/UlisesGascon/simple-api))，该项目可在
    [https://api.demo.foo/__/docs/](https://api.demo.foo/__/docs/) 找到，并且是一个用于测试和快速原型设计的假在线
    **表示状态转移**（**REST**）API。
- en: 'So, in the following code example, we will perform a network request and bring
    data to our application using the internet, as this operation requires network
    I/O, it is asynchronous, so we will need to use promises:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在以下代码示例中，我们将执行网络请求，并通过互联网将数据带到我们的应用程序中，因为这个操作需要网络 I/O，它是异步的，所以我们需要使用承诺：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of this code will be as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出将如下所示：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, we are using the `fetch` function to make a request to the
    API. The function yields a promise, allowing us to employ the `then` method to
    manage successful fulfillment and the `catch` method to handle potential rejections.
    In this case, we are using the `then` method twice: the first time to parse the
    response as JSON, and the second time to print the result to the console. We are
    also using the `catch` method to print the error to the console.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `fetch` 函数向 API 发起请求。该函数产生一个承诺，允许我们使用 `then` 方法来管理成功的解决，并使用 `catch`
    方法来处理潜在的拒绝。在这种情况下，我们使用了两次 `then` 方法：第一次是将响应解析为 JSON，第二次是将结果打印到控制台。我们还使用了 `catch`
    方法将错误打印到控制台。
- en: Creating promises
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建承诺
- en: 'You can create a promise using the `Promise` constructor, which receives a
    callback as an argument. This callback receives two arguments, `resolve` and `reject`.
    The `resolve` function is used to resolve the promise, and the `reject` function
    is used to reject the promise. Let’s see how this works with a simple example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Promise` 构造函数创建一个承诺，该构造函数接收一个回调作为参数。此回调接收两个参数，`resolve` 和 `reject`。`resolve`
    函数用于解决承诺，而 `reject` 函数用于拒绝承诺。让我们通过一个简单的例子看看它是如何工作的：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of this code will be as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出将如下所示：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we have a function called `setTimeoutPromise` that receives
    a `time` as an argument. This function returns a promise that will be resolved
    after the specified time. When the promise is resolved, we print `one second later`
    to the console.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个名为 `setTimeoutPromise` 的函数，它接收一个 `time` 作为参数。此函数返回一个承诺，该承诺将在指定时间后解决。当承诺解决时，我们将
    `one second later` 打印到控制台。
- en: Callback hell with promises
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用承诺的回调地狱
- en: Promises are a great way to deal with the limitations that callbacks introduce
    when we need to perform multiple asynchronous operations that should be executed
    in a consecutive order.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是处理当需要执行多个应按顺序执行的异步操作时，回调引入的限制的绝佳方式。
- en: Promises will handle errors more easily, so the readability of the code should
    be clearer and easier to maintain in long term.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺更容易处理错误，因此代码的可读性应该更清晰，长期维护也更简单。
- en: 'In the previous section, we saw that callback hell is a very real thing in
    JavaScript. By now, you should be more familiar with the inclined pyramid and
    nested callbacks. Here is the snippet that we used to explain how Callback hell
    can be easily achieved in a previous section:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了回调地狱在JavaScript中是一个非常真实的问题。到目前为止，您应该对倾斜的金字塔和嵌套回调更加熟悉。以下是我们在前一个部分中用来解释如何轻松实现回调地狱的代码片段：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let’s see how we can solve this problem using promises:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何使用承诺解决这个问题：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the code is much easier to read, and it is much easier to make
    changes to. This is one of the main advantages of using promises. Now the errors
    are handled in the last `catch` method, so we don’t need to handle the errors
    in each `then` method, which makes the code much cleaner.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码更容易阅读，并且更容易进行修改。这是使用承诺的主要优势之一。现在错误处理在最后的`catch`方法中完成，因此我们不需要在每个`then`方法中处理错误，这使得代码更加简洁。
- en: Parallel promises
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行承诺
- en: Another advantage of using promises is that we can run multiple promises in
    parallel. Basically, we provide an array of promises and we choose a strategy
    to handle the results (`Promise.race()` or `Promise.all()`). This is a great way
    to reduce the execution time, as we are using Node.js’ abilities to manage I/O
    operations asynchronously.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺的另一个优点是我们可以在并行中运行多个承诺。基本上，我们提供一个承诺数组，并选择一个策略来处理结果（`Promise.race()`或`Promise.all()`）。这是一个减少执行时间的好方法，因为我们正在使用Node.js异步管理I/O操作的能力。
- en: 'In the following examples, we will use this function to generate a random timeout
    promise as an example of an asynchronous operation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用此函数来生成一个随机超时承诺，作为异步操作的示例：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function will return a promise that will be resolved after a random time
    between 0 and 100 milliseconds. Now that we have an asynchronous function, we
    can employ various strategies to group multiple requests together based on our
    specific needs. In this instance, our goal is to initiate several requests in
    parallel and await their resolution.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将在0到100毫秒之间的随机时间后解决一个承诺。现在我们有一个异步函数，我们可以根据我们的具体需求采用各种策略来组合多个请求。在这个例子中，我们的目标是并行发起多个请求并等待它们的解决。
- en: '`Promise.all()`: The `all` method produces a singular promise that resolves
    once all the promises are resolved or if any of the promises are rejected:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all()`: `all`方法产生一个承诺，一旦所有承诺都解决或任何承诺被拒绝，它就会解决：'
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of this code will be something like this when all the promises are
    resolved successfully:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有承诺都成功解决时，这段代码的输出将类似于以下内容：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the `then` method will be called when all the promises are resolved,
    and it will receive an array with the results of each promise in the order they
    are being added in the promise array, not by the order in which they are resolved.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当所有承诺都解决时，将调用`then`方法，并且它将接收一个数组，其中包含每个承诺的结果，按照它们在承诺数组中添加的顺序，而不是按照它们解决的顺序。
- en: In the previous example, all the promises were successfully resolved as they
    are based on timer operation. But when we relay on promises to access external
    resources like files in our system or fetching data from the Internet, then we
    need to take into account that these resources might not be always available.
    For example, if the Internet is down, then one or multiple promises can fail and
    this will make our application to crash. Obviously, this crashing situation can
    be avoided if we handle the errors using a `catch` statement, but even in that
    case, it is very important to remember that when we use this parallelism approach,
    we need to take into account that if a single promise generates an error, the
    resolved ones will be ignored just the same as if we were using a single promise.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，所有承诺都成功解决，因为它们基于计时器操作。但当我们依赖于承诺来访问外部资源，如系统中的文件或从互联网获取数据时，我们需要考虑这些资源可能并不总是可用。例如，如果互联网断开，那么一个或多个承诺可能会失败，这将使我们的应用程序崩溃。显然，如果使用`catch`语句处理错误，可以避免这种情况，但即使在那种情况下，也非常重要记住，当我们使用这种并行方法时，我们需要考虑如果单个承诺生成错误，已解决的承诺将被忽略，就像我们使用单个承诺一样。
- en: An alternative approach to `Promise.all()` is to aggregate all the requests
    but resolve the promise as soon as the first one is complete. This way, there’s
    no need to wait for the fulfillment of all requests.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all()`的另一种方法是聚合所有请求，但一旦第一个请求完成就解决承诺。这样，就无需等待所有请求的解决。'
- en: '`Promise.race()`: The `race` method returns a single promise that is fulfilled
    or rejected as soon as one of the promises gets fulfilled or rejected. This can
    lead to unexpected results if not carefully managed, as the promises won’t stop
    running even if one of the promises was rejected or fulfilled already:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.race()`: `race`方法返回一个承诺，只要其中一个承诺解决或拒绝，它就会解决或拒绝。如果不小心管理，这可能会导致意外的结果，因为即使其中一个承诺已经解决或拒绝，承诺也不会停止运行：'
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of this code will be something like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出将类似于以下内容：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the `then` method will be called when the first promise is resolved,
    and it will receive the result of the first promise that is resolved. The other
    promises will continue running, but the `then` method will not be called again.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当第一个承诺解决时，将调用`then`方法，并且它将接收到已解决的第一个承诺的结果。其他承诺将继续运行，但`then`方法将不会再次被调用。
- en: Error handling
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'In the previous examples, we saw how to handle errors using the `catch` method,
    but there is another way to handle errors: using the `reject` function. Let’s
    see how this works with this example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了如何使用`catch`方法处理错误，但还有另一种处理错误的方法：使用`reject`函数。让我们看看这个例子是如何工作的：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It’s important to notice that the `reject` function will not stop the execution
    of the code, so we need to `return` the function after calling the `reject` function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`reject`函数不会停止代码的执行，因此我们需要在调用`reject`函数后`return`函数。
- en: The final approach is when we need to perform an action once a promise has been
    concluded, regardless of whether it was successful or rejected. It is important
    to remember that unhandled promise rejections can lead to runtime errors that
    will crash your application. We will learn more about this in [*Chapter 15*](B21678_15.xhtml#_idTextAnchor394).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况是我们需要在承诺解决后执行一个动作，无论它是成功还是拒绝。重要的是要记住，未处理的承诺拒绝可能导致运行时错误，这会使您的应用程序崩溃。我们将在[*第15章*](B21678_15.xhtml#_idTextAnchor394)中了解更多。
- en: '`Promise.finally()`: Sometimes, we don’t care if the promise is resolved or
    rejected; we just want to know when the promise has been resolved or rejected.
    For this case, we can use the `finally` method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.finally()`: 有时候，我们不在乎承诺是解决还是拒绝；我们只想知道承诺何时解决或拒绝。在这种情况下，我们可以使用`finally`方法：'
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Chaining promises
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺链式调用
- en: 'We can also chain promises; we can return a promise in the `then` method, and
    this promise will be resolved before calling the next `then` method. The `catch`
    method will be called if any of the promises in the chain are rejected. Let’s
    see an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以链式调用承诺；我们可以在`then`方法中返回一个承诺，这个承诺将在调用下一个`then`方法之前解决。如果链中的任何承诺被拒绝，将调用`catch`方法。让我们看一个例子：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the third `generatePromise` is called, it will return a promise that will
    be rejected, so the `catch` method will be called and then the last `then` won’t
    be executed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用第三个`generatePromise`时，它将返回一个将被拒绝的承诺，因此将调用`catch`方法，然后最后一个`then`将不会执行。
- en: We have been utilizing promises for some time, and the syntax can be quite verbose,
    requiring keywords such as `then` and `catch` consistently. A more advanced and
    aesthetically pleasing syntax involves using `async` and `await`. We will delve
    into this approach in the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用承诺有一段时间了，其语法可能相当冗长，需要像 `then` 和 `catch` 这样的关键字。一种更高级且更美观的语法涉及使用 `async`
    和 `await`。我们将在下一节深入探讨这种方法。
- en: Using async and await to handle asynchronous code
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `async` 和 `await` 处理异步代码
- en: ES2017 introduced a new way to handle asynchronous code, the `async` and `await`
    keywords. These keywords are syntactic sugar for promises; they are not a new
    way to handle asynchronous code, but they make the code much easier to read and
    write.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ES2017 引入了一种处理异步代码的新方法，即 `async` 和 `await` 关键字。这些关键字是承诺的语法糖；它们不是处理异步代码的新方法，但它们使代码更容易阅读和编写。
- en: Essentially, the `async` keyword is employed to define an asynchronous function,
    while the `await` keyword is used to pause and await the resolution of a promise
    within that function. Even if you use the word `async` it doesn’t make you code
    asynchronously, that will only occur when you actually have asynchronous code
    on it (a promise). To make it more simple, we can say that in order to use `await`,
    we need to define the code block using `async`. Let’s explore more in detail how
    we can use `async`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`async` 关键字用于定义一个异步函数，而 `await` 关键字用于在函数内部暂停并等待一个承诺的解决。即使你使用了 `async` 这个词，它也不会让你的代码变为异步，只有当你实际上在代码中使用了异步代码（一个承诺）时，才会发生这种情况。为了使其更简单，我们可以这样说，为了使用
    `await`，我们需要使用 `async` 来定义代码块。让我们更详细地探讨一下我们如何使用 `async`。
- en: async
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: async
- en: 'When a function is defined with the `async` keyword, it will always return
    a promise that can be handled as any regular promise. Let’s see an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数使用 `async` 关键字定义时，它将始终返回一个承诺，可以像任何常规承诺一样处理。让我们看看一个例子：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As this is syntactic sugar for promises, we can build a similar function using
    promises:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是承诺的语法糖，我们可以使用承诺构建一个类似的功能：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, let’s acquaint ourselves with `await`; we’ll be able to seamlessly combine
    both keywords and eliminate the need to use `then` or `catch`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们熟悉一下 `await`；我们将能够无缝地结合这两个关键字，并消除使用 `then` 或 `catch` 的需要。
- en: await
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: await
- en: 'Let’s see how we can use the `await` keyword in order to wait for promises:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `await` 关键字来等待承诺：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the code is much easier to read and write using `async` and
    `await`. The `await` keyword can only be used inside an `async` function. We need
    to use the `try`/`catch` block to handle the errors.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 `async` 和 `await` 可以使代码更容易阅读和编写。`await` 关键字只能用在 `async` 函数内部。我们需要使用
    `try`/`catch` 块来处理错误。
- en: '`try`/`catch` is a mechanism provided by JavaScript that allows us to encapsulate
    certain code inside the `try` block, and handle any possible errors with the `catch`
    block. So, in the previous example, as we are doing an HTTP request we depend
    on external factors such as connectivity to the internet or the ability of the
    external server to return the information that we are asking for in our request.
    In our specific case, we are “silently failing” this error because in the `catch`
    block we only print the information about the error, but in other scenarios we
    might show an alert message in the UI or trigger a retry strategy to try to perform
    this HTTP request again. It is important to remember that If we don’t handle errors
    properly, our application might crash. We will explore this topic in detail in
    [*Chapter 15*](B21678_15.xhtml#_idTextAnchor394).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`catch` 是 JavaScript 提供的一种机制，允许我们将某些代码封装在 `try` 块中，并使用 `catch` 块处理任何可能出现的错误。所以，在上一个例子中，由于我们正在进行
    HTTP 请求，我们依赖于外部因素，如互联网的连接性或外部服务器返回我们请求的信息的能力。在我们的特定情况下，我们“静默失败”这个错误，因为在 `catch`
    块中我们只打印有关错误的信息，但在其他情况下，我们可能在 UI 中显示一个警告消息或触发重试策略来尝试再次执行此 HTTP 请求。重要的是要记住，如果我们没有正确处理错误，我们的应用程序可能会崩溃。我们将在
    [*第 15 章*](B21678_15.xhtml#_idTextAnchor394) 中详细探讨这个主题。'
- en: Now, let’s explore how we can blend `async` to employ this syntactic sugar even
    in older Node.js versions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨如何将 `async` 与此语法糖结合使用，即使在较旧的 Node.js 版本中。
- en: IIFEs
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IIFEs
- en: 'In some cases, we want to use the `await` keyword outside an `async` function,
    for example, when we are using the `await` keyword in the top level of a module.
    In this case, we can use an IIFE to wrap the `await` keyword inside an `async`
    function. An IIFE is a function that is executed immediately after it is created.
    It is a design pattern that is used to avoid polluting the global scope with variables
    and functions. In the subsequent example, we can observe the fundamental syntax:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望在 `async` 函数外部使用 `await` 关键字，例如，当我们想在模块的最高级别使用 `await` 关键字时。在这种情况下，我们可以使用
    IIFE 将 `await` 关键字包裹在 `async` 函数内。IIFE 是在创建后立即执行的函数。这是一种设计模式，用于避免将变量和函数污染全局作用域。在下面的示例中，我们可以观察到基本的语法：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The idea is to create an anonymous function and execute it immediately after
    it is created. In order to achieve this, we need to wrap the function between
    parentheses, and then add another pair of parentheses to execute the function:
    `(...)()`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是创建一个匿名函数，并在创建后立即执行它。为了实现这一点，我们需要在函数之间添加括号，然后添加另一对括号来执行函数：`(...)()`。
- en: 'We can use `async` and `await` inside an IIFE easily:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在立即执行函数表达式（IIFE）中轻松使用 `async` 和 `await`：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This guarantees that the code will be executed immediately after it is created,
    and we can use the `await` keyword inside the IIFE.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这保证了代码将在创建后立即执行，我们可以在 IIFE 中使用 `await` 关键字。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about asynchronous programming in JavaScript. We
    explored asynchronous APIs such as `setTimeout` and `fetch`, and we learned how
    to handle asynchronous code using callbacks, promises, and `async`/`await`. Additionally,
    we learned about the error first callback convention and how to prevent callback
    hell using named functions and promises. Finally, we learned how to manage promises,
    how to bulk operations using the `Promise.all` and `Promise.race` methods, and
    how to use the `async` and `await` keywords to handle asynchronous code in a cleaner
    way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 JavaScript 中的异步编程。我们探讨了异步 API，如 `setTimeout` 和 `fetch`，并学习了如何使用回调、promises
    和 `async`/`await` 来处理异步代码。此外，我们还学习了错误优先回调约定以及如何使用命名函数和 promises 来避免回调地狱。最后，我们学习了如何管理
    promises，如何使用 `Promise.all` 和 `Promise.race` 方法进行批量操作，以及如何使用 `async` 和 `await`
    关键字以更干净的方式处理异步代码。
- en: In the next chapter, we will learn about HTTP and how the modern web works using
    REST APIs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 HTTP 以及现代网络如何使用 REST API 工作。
- en: Further reading
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Asynchronous programming in JavaScript is a broad topic that necessitates a
    considerable amount of time to master and comprehend fully. With the following
    links, you will discover valuable resources that will aid you in delving deeper
    into the subjects covered in this chapter:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的异步编程是一个广泛的主题，需要相当多的时间来掌握和完全理解。以下链接将向您展示一些宝贵的资源，这些资源将帮助您深入了解本章涵盖的主题：
- en: '*JavaScript Promise in 100* *Seconds*: [https://www.youtube.com/watch?v=RvYYCGs45L4](https://www.youtube.com/watch?v=RvYYCGs45L4)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript Promise 100秒内理解*: [https://www.youtube.com/watch?v=RvYYCGs45L4](https://www.youtube.com/watch?v=RvYYCGs45L4)'
- en: '*Asynchrony: Under the Hood – Shelley Vohr – JSConf* *EU*: [https://www.youtube.com/watch?v=SrNQS8J67zc](https://www.youtube.com/watch?v=SrNQS8J67zc)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步编程：内部机制 – Shelley Vohr – JSConf EU*: [https://www.youtube.com/watch?v=SrNQS8J67zc](https://www.youtube.com/watch?v=SrNQS8J67zc)'
- en: '*async/await in JavaScript – What, Why and How – Fun Fun* *Function:* [https://www.youtube.com/watch?v=568g8hxJJp4](https://www.youtube.com/watch?v=568g8hxJJp4)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript 中的 async/await – 什么是、为什么以及如何 – Fun Fun Function:* [https://www.youtube.com/watch?v=568g8hxJJp4](https://www.youtube.com/watch?v=568g8hxJJp4)'
- en: 'Part 2: Node.js Ecosystem and Architecture'
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：Node.js 生态系统和架构
- en: In *Part 2*, you will learn how to use the Node.js core libraries and third-party
    libraries by using the vast npm ecosystem ecosystem. Also, you will learn how
    to use and implement event-driven architectures in detail, and you will understand
    how to use testing and implement unit testing in your projects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第2部分* 中，您将学习如何通过使用庞大的 npm 生态系统来使用 Node.js 核心库和第三方库。您还将详细了解如何使用和实现事件驱动架构，并了解如何在项目中使用和实现单元测试。
- en: 'This part includes the following chapters:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 5*](B21678_05.xhtml#_idTextAnchor156), *Node.js Core Libraries*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B21678_05.xhtml#_idTextAnchor156), *Node.js 核心库*'
- en: '[*Chapter 6*](B21678_06.xhtml#_idTextAnchor171), *External Modules and npm*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21678_06.xhtml#_idTextAnchor171), *外部模块和npm*'
- en: '[*Chapter 7*](B21678_07.xhtml#_idTextAnchor206), *Event-Driven Architecture*'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21678_07.xhtml#_idTextAnchor206), *事件驱动架构*'
- en: '[*Chapter 8*](B21678_08.xhtml#_idTextAnchor218), *Testing in Node.js*'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21678_08.xhtml#_idTextAnchor218), *Node.js中的测试*'
