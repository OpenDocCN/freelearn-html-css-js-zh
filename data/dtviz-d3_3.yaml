- en: Chapter 3. Making Data Useful
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：使数据有用
- en: At its core, d3.js is a data manipulation library. We're going to take a look
    at making our datasets useful with both d3.js and plain old JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心上，d3.js 是一个数据操作库。我们将探讨如何使用 d3.js 和普通的 JavaScript 使我们的数据集变得有用。
- en: We start with a quick dip into functional programming to bring everyone up to
    speed. You can skip this part if you use Haskell, Scala, or Lisp, or already write
    JavaScript in a functional style.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先快速了解一下函数式编程，以便让每个人都能跟上进度。如果你使用 Haskell、Scala 或 Lisp，或者已经以函数式风格编写 JavaScript，你可以跳过这部分内容。
- en: We continue loading external data, taking a closer look at the scales I can't
    stop writing about, and finish with some temporal and geographic data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续加载外部数据，更仔细地研究我无法停止谈论的刻度，并以一些时间和地理数据结束。
- en: Thinking about data functionally
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以函数式思维考虑数据
- en: Due to the functional design of d3.js, we have to start thinking of our code
    and data with a functional mindset.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 d3.js 的函数式设计，我们不得不开始用函数式思维来思考我们的代码和数据。
- en: The good news is that JavaScript almost counts as a functional language; there
    are enough features to get the benefits of a functional style, and also provides
    enough freedom to do things imperatively or in an object-oriented way. The bad
    news is that, unlike real functional languages, the environment gives no guarantee
    about our code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，JavaScript 几乎可以算作是一种函数式语言；它有足够的功能来获得函数式风格的好处，同时也提供了足够的自由度，可以以命令式或面向对象的方式做事。坏消息是，与真正的函数式语言不同，环境对我们的代码没有任何保证。
- en: In this section, we'll go through the basics of functional-style coding and
    look at wrangling the data so that it's easier to work with. If you want to try
    proper functional programming, I suggest looking at Haskell and *Learn You a Haskell
    for Great Good* available at [http://learnyouahaskell.com/](http://learnyouahaskell.com/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍函数式编程的基础，并查看如何处理数据，使其更容易处理。如果你想尝试真正的函数式编程，我建议查看 Haskell 和 [http://learnyouahaskell.com/](http://learnyouahaskell.com/)
    上的 *Learn You a Haskell for Great Good*。
- en: The idea behind functional programming is simple—compute by relying only on
    function arguments. Simple, but the consequences are far reaching.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程背后的想法很简单——通过仅依赖函数参数来计算。简单，但其后果是深远的。
- en: The biggest consequence is that we don't have to rely on state, which in turn
    gives us referential transparency. This means functions executed with the same
    parameters will always give the same results regardless of when or how they're
    called.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的后果是我们不必依赖于状态，这反过来又给了我们引用透明性。这意味着使用相同参数执行的功能将始终给出相同的结果，无论何时或如何调用。
- en: In practice this means we design the code and dataflow, that is, get data as
    input, execute a sequence of functions that pass changed data down the chain,
    and eventually get a result.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这意味着我们设计代码和数据流，即获取数据作为输入，执行一系列函数，将更改后的数据传递到链中，并最终得到一个结果。
- en: You've already seen this in previous examples.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你在之前的例子中已经见过这个了。
- en: Our dataset started and ended as an array of values. We performed some actions
    for each item and we relied only on the current item when deciding what to do.
    We also had the current index, so we could cheat a little with an imperative approach
    by looking ahead and behind in the stream.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集开始和结束都是一个值数组。我们对每个项目执行了一些操作，并且在决定做什么时只依赖于当前项。我们还拥有当前索引，因此我们可以通过向前和向后查看流来稍微作弊，采用命令式方法。
- en: Built-in array functions
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置数组函数
- en: JavaScript comes with a slew of array-manipulation functions. We'll focus on
    those which are more functional in nature, the iteration methods.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 带有一系列数组操作函数。我们将关注那些更具有函数性质的函数，即迭代方法。
- en: A smart man once told me you can model any algorithm by using `map` and `reduce`.
    But he was wrong. What you need is recursion, a way to add two arrays together,
    the ability to get the first and second element of an array, an equality comparator,
    and a way to decide if something is a value or an array. In fact that's how LISP
    is defined.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有位智者曾告诉我，你可以通过使用 `map` 和 `reduce` 来模拟任何算法。但他错了。你需要的是递归，一种将两个数组相加的方法，获取数组中第一和第二个元素的能力，一个相等比较器，以及决定某物是值还是数组的方法。实际上这正是
    LISP 的定义方式。
- en: But you will get pretty far with `map`, `reduce`, and `filter` in combination
    with their predicates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但通过结合使用 `map`、`reduce` 和 `filter` 以及它们的谓词，你将能走得很远。
- en: 'The `map` command applies a function on every element of an array and returns
    a new array with changed values:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 命令对数组中的每个元素应用一个函数，并返回一个包含更改后值的新数组：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `reduce` function uses a combining function and a starting value to collapse
    an array into a single value:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 函数使用一个组合函数和一个起始值来将数组折叠成一个单一值：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `filter` function goes through an array and keeps elements for which the
    predicate returns `true`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 函数遍历一个数组，并保留那些谓词返回 `true` 的元素：'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Two more useful functions are `.every()` and `.some()`, which are true if every
    or some items in the array are true. Sometimes, using `.forEach()` instead of
    `.map()` is better because `forEach` operates on the original array instead of
    creating a copy, which is important for working with large arrays and is mainly
    used for the side-effect.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 两个更有用的函数是 `.every()` 和 `.some()`，如果数组中的每个或某些元素都为真，则这两个函数返回真。有时，使用 `.forEach()`
    而不是 `.map()` 更好，因为 `forEach` 在原始数组上操作而不是创建一个副本，这对于处理大型数组非常重要，并且主要用于副作用。
- en: These functions are relatively new to JavaScript, whereas `map` and `filter`
    have existed since JavaScript 1.7, and `reduce` since 1.8; these are also a part
    of the emerging ECMAScript 6 standard and, thus, not supported on older browsers.
    You can use libraries, such as underscore.js or one of the various es6 shims to
    support older browsers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数相对较新，而 `map` 和 `filter` 自 JavaScript 1.7 以来就存在了，`reduce` 自 1.8 以来就存在了；它们也是新兴的
    ECMAScript 6 标准的一部分，因此不支持旧浏览器。您可以使用库，如 underscore.js 或各种 es6 shims 之一来支持旧浏览器。
- en: Data functions of d3.js
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: d3.js 的数据函数
- en: d3.js comes with plenty of its own array functions. They mostly have to do with
    handling data; it comprises calculating averages, ordering, bisecting arrays,
    and many helper functions for associative arrays.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: d3.js 自带了许多自己的数组函数。它们大多与处理数据有关；它包括计算平均值、排序、分割数组以及许多关联数组的辅助函数。
- en: Let's play with data functions and draw an unsolved mathematical problem named
    Ulam spiral. Discovered in 1963, it reveals patterns in the distribution of prime
    numbers on a two-dimensional plane. So far, nobody has found a formula that explains
    them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩一玩数据函数，并绘制一个未解决的数学问题——乌拉姆螺旋。乌拉姆螺旋是在1963年被发现的，它揭示了二维平面上质数分布的规律。到目前为止，还没有人找到解释它们的公式。
- en: We'll construct the spiral by simulating Ulam's pen-and-paper method; we'll
    write natural numbers in a spiraling pattern, and then remove all non-primes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过模拟乌拉姆的笔和纸方法来构建螺旋；我们将以螺旋模式写下自然数，然后移除所有非质数。
- en: 'Instead of numbers we''ll draw dots. The first stage in our experiment will
    look as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是用数字来画，而是用点。我们实验的第一阶段看起来如下：
- en: '![Data functions of d3.js](img/0007OS_03_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![d3.js 的数据函数](img/0007OS_03_01.jpg)'
- en: Doesn't look like much, but that's only the first 5,000 primes in a spiral.
    Notice the diagonals? Some can be described with polynomials, which brings interesting
    implications about predicting prime numbers and by extension, the safety of cryptography.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来并不多，但这只是螺旋中的前5,000个质数。注意对角线吗？有些可以用多项式来描述，这带来了关于预测质数以及由此延伸出的密码学安全性的有趣含义。
- en: 'We begin with a drawing area:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个绘图区域开始：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we define the algorithm that generates a list of numbers and their spiraling
    coordinates on a grid. We start with some helpful variables:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在函数的底部定义生成数字及其在网格上螺旋坐标的算法。我们开始时使用一些有用的变量：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We defined a `spiral` function that takes a single upper-bound argument, `n`.
    The function starts with four directions of travel and some variables for our
    algorithm. The combination of `min` and `max` known coordinates will tell us when
    to turn; `x` and `y` will be the current position, whereas `direction` will tell
    us which part of the spiral we're tracing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `spiral` 函数，它接受一个单一的界限参数 `n`。该函数从四个旅行方向和一些算法变量开始。`min` 和 `max` 已知坐标的组合将告诉我们何时转弯；`x`
    和 `y` 将是当前位置，而 `direction` 将告诉我们我们正在追踪螺旋的哪个部分。
- en: 'Next we add the algorithm itself to the bottom of our function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将算法本身添加到函数的底部：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`d3.range()` generates an array of numbers between the two arguments that we
    iterate with `forEach`. Each iteration adds a new `{x: x, y: y, n: i}` triplet
    to the spiral array. The rest is just using `min` and `max` to change the direction
    on the spiral''s corners. Yes it''s repetitive, but we don''t always have to be
    clever.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.range()` 生成一个介于两个参数之间的数字数组，我们用 `forEach` 来迭代。每次迭代都会将一个新的 `{x: x, y: y,
    n: i}` 三元组添加到螺旋数组中。其余的只是使用 `min` 和 `max` 来改变螺旋角落的方向。是的，这很重复，但并不总是需要我们很聪明。'
- en: 'Now we get to draw stuff:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始绘制：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've defined a `dot` generator and two functions to help us turn grid coordinates
    from the `spiral` function into pixel positions. `l` is the length and width of
    a square in the grid.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`dot`生成器，以及两个帮助我们将螺旋函数中的网格坐标转换为像素位置的函数。`l`是网格中一个方块的长度和宽度。
- en: We can avoid the dirty work of calculating primes by getting a list online.
    I found a list at [http://www.mathsisfun.com/](http://www.mathsisfun.com/) and
    placed it on GitHub next to the code examples at [https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/primes-to-100k.txt](https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/primes-to-100k.txt).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在线获取一个列表来避免计算素数的繁琐工作。我在[http://www.mathsisfun.com/](http://www.mathsisfun.com/)找到一个列表，并将其放在GitHub上，与代码示例[https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/primes-to-100k.txt](https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/primes-to-100k.txt)并列放置。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We load the primes as a text file, split it into lines, use `.slice()` to get
    the first `5000` elements, then turn them into numbers using `.map(Number)`. We'll
    use `l` to tell the `x` and `y` functions how big the grid is.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将素数作为文本文件加载，将其拆分为行，使用`.slice()`获取前`5000`个元素，然后使用`.map(Number)`将它们转换为数字。我们将使用`l`来告诉`x`和`y`函数网格有多大。
- en: We call `spiral` with the largest prime on our list, (`d3.max()`), to generate
    the spiraling sequence of numbers and then use `.filter()` to remove all non-primes
    from the spiral when feeding them into the drawing code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用列表中的最大素数（`d3.max()`）调用`spiral`，生成数字的螺旋序列，然后使用`.filter()`从螺旋中移除所有非素数，当它们被输入到绘图代码中时。
- en: We used `_.indexOf` of underscore.js to search for primes because it uses binary
    search and makes our code faster. The caveat is that we have to know our list
    is ordered. You can get underscore.js from [http://underscorejs.org](http://underscorejs.org).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用underscore.js的`_.indexOf`来搜索素数，因为它使用二分搜索，使我们的代码更快。但要注意，我们必须知道我们的列表是有序的。你可以从[http://underscorejs.org](http://underscorejs.org)获取underscore.js。
- en: My aging machine still takes about two seconds to draw the interesting pixelated
    image.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我那台老机器仍然需要大约两秒钟的时间来绘制有趣的像素化图像。
- en: Let's make it more interesting by visualizing the density of primes. We'll define
    a grid with larger squares, and then color them depending on how many dots they
    contain. Squares will be red when there are fewer primes than median, and green
    when there are more. The shading will tell us how far they are from the median.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过可视化素数的密度来让它更有趣。我们将定义一个具有更大方块的网格，然后根据它们包含的点数来着色。当素数少于中位数时，方块为红色，当素数多于中位数时，方块为绿色。阴影将告诉我们它们离中位数有多远。
- en: 'First, we''ll use the `nest` structure of d3.js to define a new grid:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用d3.js的`nest`结构定义一个新的网格：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We scale by a factor of `8`, that is, each new square contains 64 of the old
    squares.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以`8`的倍数进行缩放，也就是说，每个新的方块包含64个旧的方块。
- en: '`d3.nest()` is handy for turning data into nested dictionaries according to
    a key. The first `.key()` function creates our columns; every `x` is mapped to
    the corresponding `x` of the new grid. The second `.key()` function does the same
    for `y`. We then use `.rollup()` to turn the resulting lists into a single value,
    a count of the dots.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.nest()`根据一个键将数据转换为嵌套字典，这非常方便。第一个`.key()`函数创建我们的列；每个`x`都映射到新网格中对应的`x`。第二个`.key()`函数对`y`做同样的处理。然后我们使用`.rollup()`将结果列表转换成一个单一值，即点的数量。'
- en: 'The data goes in with `.map()` and we get a structure as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通过`.map()`输入，我们得到以下结构：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Not very self-explanatory, but that's a collection of columns containing rows.
    The (`0`, `0`) square contains `5` primes, (`-1`, `0`) contains `2`, and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很直观，但这是一个包含行的列的集合。`(0, 0)`的方块包含`5`个素数，`(-1, 0)`包含`2`，以此类推。
- en: 'To get the median and the number of shades, we need those counts in an array:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到中位数和阴影数量，我们需要在数组中有这些计数：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We map through the keys of our regions (`x` coordinates) to get a list of values
    for each column, and then use `d3.merge()` to flatten the resulting array of arrays.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过遍历区域的键（`x`坐标）来获取每个列的值列表，然后使用`d3.merge()`将结果数组的数组展平。
- en: '`d3.median()` gives us the middle value of our array and `d3.extent()` gives
    us the lowest and highest number, which we used to calculate the number of shades
    we needed.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.median()`给我们数组的中间值，`d3.extent()`给我们最低和最高的数字，我们用这些来计算所需的阴影数量。'
- en: 'Finally, we walk the coordinates again to color the new grid:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次遍历坐标来为新网格着色：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our image looks like one of those Chiptunes album covers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形象看起来像那些Chiptunes专辑封面：
- en: '![Data functions of d3.js](img/0007OS_03_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![d3.js的数据函数](img/0007OS_03_02.jpg)'
- en: Loading data
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载数据
- en: One of the greatest features of d3.js is that it can asynchronously load external
    data without any help from third-party libraries or a programmer. We've already
    glanced at data loading, but it's time to take a closer look.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: d3.js最伟大的特性之一是它可以在没有任何第三方库或程序员的帮助下异步加载外部数据。我们已经浏览了数据加载，但现在需要更仔细地研究。
- en: The reason we want to load data externally is that bootstrapping large datasets
    into the page with predefined variables isn't very practical. Loading hundreds
    of kilobytes of data takes a while and doing so asynchronously lets the rest of
    the page render in the meantime.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要从外部加载数据的原因是，将大量数据集通过预定义变量加载到页面中并不太实用。加载数百千字节的数据需要一段时间，而异步加载则允许在同时渲染页面的其余部分。
- en: 'To make HTTP requests, d3.js uses XMLHttpRequests (XHR for short). This limits
    us to a single domain because of the browser''s security model, but we can do
    cross-domain requests if the server sends an `Access-Control-Allow-Origin: *`
    header.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '为了进行HTTP请求，d3.js使用XMLHttpRequests（简称XHR）。由于浏览器的安全模型，这限制了我们只能访问单个域名，但如果服务器发送了`Access-Control-Allow-Origin:
    *`头部，我们就可以进行跨域请求。'
- en: The core
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心内容
- en: At the core of all this loading, is the humble `d3.xhr()`, the manual way of
    issuing an XHR request.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些加载的核心是谦逊的`d3.xhr()`，这是手动发出XHR请求的方式。
- en: It takes a URL and an optional callback. If present, the callback will immediately
    trigger the request and receives data as an argument once the request finishes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要一个URL和一个可选的回调函数。如果存在，回调函数将立即触发请求，并在请求完成后将数据作为参数接收。
- en: If there's no callback, we get to tweak the request; everything from the headers
    to the request method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有回调函数，我们可以调整请求；从头部到请求方法的一切都可以调整。
- en: 'To make a request you might have to write the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行请求，你可能需要编写以下代码：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will send a GET request expecting a JSON response and tell the server we're
    an example. One way to shorten this is by defining a callback immediately, but
    then you can't define custom headers or listen for other request events.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发送一个期望JSON响应的GET请求，并告诉服务器我们是一个示例。缩短这一点的办法是立即定义一个回调，但这样就不能定义自定义头部或监听其他请求事件。
- en: Another way is convenience functions. We'll be using these throughout the book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是便利函数。我们将在整本书中使用这些函数。
- en: Convenience functions
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 便利函数
- en: d3.js comes with several convenience functions that use `d3.xhr()` behind the
    scenes, and parse the response before giving it back to us. This lets us limit
    our workflow to calling the appropriate function and defining a callback, which
    takes an `error` and a `data` argument. d3.js is nice enough to let us throw caution
    to the wind and use callbacks with a single `data` argument that will be undefined
    in case of error.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: d3.js附带了一些便利函数，这些函数在幕后使用`d3.xhr()`，并在将其返回给我们之前解析响应。这使得我们可以将我们的工作流程限制为调用适当的函数并定义一个回调，该回调接受一个`error`和一个`data`参数。d3.js足够好，让我们可以抛掉谨慎，使用只有一个`data`参数的回调，在出错的情况下该参数将是未定义的。
- en: 'We have a choice of data formats such as TEXT, JSON, XML, HTML, CSV, and TSV.
    JSON and CSV/TSV are used the most: JSON for small structured data, and CSV/TSV
    for large data dumps where we want to conserve space.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择多种数据格式，如TEXT、JSON、XML、HTML、CSV和TSV。JSON和CSV/TSV使用得最多：JSON用于小型结构化数据，CSV/TSV用于我们想要节省空间的大型数据转储。
- en: 'A lot of our code will follow this kind of pattern:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分代码将遵循这种模式：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Scales
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规模
- en: Scales are functions that map a domain to a range. Yeah, yeah, I keep saying
    that, but there really isn't much more to say.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 规模是映射定义域到值域的函数。是的，我一直在说这个，但真的没有更多可说的。
- en: The reason we use them is to avoid math. This makes our code shorter, easier
    to understand, and more robust as mistakes in high school mathematics are some
    of the hardest bugs to track down.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用它们的原因是为了避免数学。这使得我们的代码更短，更容易理解，并且更健壮，因为高中数学中的错误是一些最难追踪的bug。
- en: If you haven't just spent four years listening to mathematics at school, a function's
    domain are those values where it is defined (the input), and the range are those
    values it returns.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在学校里听过四年的数学，一个函数的定义域是它定义的值（输入），值域是它返回的值。
- en: 'The following figure is borrowed from Wikipedia:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图是从维基百科借用的：
- en: '![Scales](img/0007OS_03_03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Scales](img/0007OS_03_03.jpg)'
- en: Here, **X** is the domain, **Y** is the range, and arrows are the functions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**X**是定义域，**Y**是值域，箭头是函数。
- en: 'We need a bunch of code to implement this manually:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一大堆代码来手动实现这一点：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You could also do it with a dictionary, but `d3.scale` will always be more
    elegant and flexible:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用字典来做，但 `d3.scale` 总是更加优雅和灵活：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Much better!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！
- en: Scales come in three types; ordinal scales have a discrete domain, quantitative
    scales have a continuous domain, and time scales have a time-based continuous
    domain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 规模分为三种类型；序数尺度具有离散域，定量尺度具有连续域，时间尺度具有基于时间的连续域。
- en: Ordinal scales
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序数尺度
- en: Ordinal scales are the simplest, essentially just a dictionary where keys are
    the domain and values are the range.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 序数尺度是最简单的，本质上就是一个字典，其中键是域，值是范围。
- en: In the preceding example, we defined an ordinal scale by explicitly setting
    both the input domain and the output range. If we don't define a domain, it's
    inferred from use, but that can give unpredictable results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过显式设置输入域和输出范围来定义序数尺度。如果我们不定义域，它将从使用中推断出来，但这可能会产生不可预测的结果。
- en: A cool thing about ordinal scales is that having a range smaller than the domain
    makes the scale cycle values. Furthermore, we'd get the same result if the range
    was just `['red', 'yellow', 'green']`. But, cutting a continuous interval into
    chunks can make an even better range, histograms, for instance.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 序数尺度的一个有趣之处在于，当范围小于域时，尺度会循环值。此外，如果范围只是 `['red', 'yellow', 'green']`，我们也会得到相同的结果。但是，将连续区间切割成块可以创建一个更好的范围，例如直方图。
- en: Let's try.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。
- en: 'First we need a drawing area:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个绘图区域：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we define the three scales we need, and generate some data:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了我们需要的三个尺度，并生成了一些数据：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our data is just a list of numbers going upto `30`, and the `colors` scale is
    from [Chapter 2](ch02.html "Chapter 2. A Primer on DOM, SVG, and CSS"), *A Primer
    on DOM, SVG, and CSS*. It is a predefined ordinal scale with an undefined domain
    and a range of ten colors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据只是一个包含 `30` 个数字的列表，而 `colors` 尺度来自[第2章](ch02.html "第2章。DOM、SVG和CSS入门")，*DOM、SVG和CSS入门*。它是一个预定义的序数尺度，具有未定义的域和十个颜色的范围。
- en: Then we defined two scales that split our drawing into equal parts. `points`
    uses `.rangePoints()` to distribute `30` equally-spaced points along the height
    of our drawing. We set the edge padding with a factor of `1.0`, which sets the
    distance from the last point to the edge to half the distance between the points.
    End points are moved inwards from the range edge using `point_distance*padding/2`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了两个尺度，将我们的绘图分成相等的部分。`points` 使用 `.rangePoints()` 在绘图高度上分布 `30` 个等间距的点。我们使用因子
    `1.0` 设置边缘填充，这设置了最后一个点到边缘的距离为点之间距离的一半。端点使用 `point_distance*padding/2` 从范围边缘向内移动。
- en: '![Ordinal scales](img/0007OS_03_11.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![序数尺度](img/0007OS_03_11.jpg)'
- en: '`bands` uses `.rangeBands()` to divide the width into `30` equal bands with
    a padding factor of `0.1` between bands. This time we''re setting the distance
    between bands, using `step*padding`, and a third argument would set edge padding
    using `step*outerPadding`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`bands` 使用 `.rangeBands()` 将宽度划分为 `30` 个等宽的带，带之间的填充因子为 `0.1`。这次我们设置带之间的距离，使用
    `step*padding`，第三个参数将使用 `step*outerPadding` 设置边缘填充。'
- en: '![Ordinal scales](img/0007OS_03_12.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![序数尺度](img/0007OS_03_12.jpg)'
- en: 'We''ll use code you already know from [Chapter 2](ch02.html "Chapter 2. A Primer
    on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*, to draw two lines using
    these scales:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用您在[第2章](ch02.html "第2章。DOM、SVG和CSS入门")中已经了解的代码，*DOM、SVG和CSS入门*，来使用这些尺度绘制两条线：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To get the positions for each dot or rectangle, we called the scales as functions
    and used `bands.rangeBand()` to get the rectangle width.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取每个点或矩形的坐标，我们调用尺度作为函数，并使用 `bands.rangeBand()` 获取矩形宽度。
- en: 'The picture looks as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图片看起来如下：
- en: '![Ordinal scales](img/0007OS_03_04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![序数尺度](img/0007OS_03_04.jpg)'
- en: Quantitative scales
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定量尺度
- en: Quantitative scales come in a few different flavors, but they all share a common
    characteristic that the input domain is continuous. Instead of a set of discrete
    values, a continuous scale can be modeled with a simple function. The seven types
    of quantitative scales are linear, identity, power, log, quantize, quantile, and
    threshold. They define different transformations of the input domain. The first
    four have a continuous output range while the latter three map to a discrete range.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 定量尺度有多种不同的风味，但它们都有一个共同的特征，即输入域是连续的。连续尺度可以用一个简单的函数来建模，而不是一组离散值。七种定量尺度是线性、恒等、幂、对数、量化、分位数和阈值。它们定义了输入域的不同转换。前四种具有连续的输出范围，而后三种映射到离散范围。
- en: To see how they behave, we'll use all these scales to manipulate the `y` coordinate
    when drawing the `weierstrass` function; the first discovered function that is
    continuous everywhere but differentiable nowhere. This means that even though
    you can draw the function without lifting your pen, you can never define the angle
    you're drawing at (calculate a derivative).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解它们的行为，我们将使用所有这些刻度在绘制`weierstrass`函数时操纵`y`坐标；这是第一个在所有地方连续但无处可微分的函数。这意味着尽管你可以不抬起笔来绘制函数，但你永远无法定义你正在绘制的角度（计算导数）。
- en: 'We begin with a drawing area and the `weierstrass` function as found on Wikipedia
    is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个绘图区域和维基百科上找到的`weierstrass`函数开始，如下所示：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A drawing function will help us avoid code repetition:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个绘图函数将帮助我们避免代码重复：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We generate some data, get the `extent` of the `weierstrass` function, and
    use a linear scale for `x`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成一些数据，获取`weierstrass`函数的`extent`，并使用线性刻度来表示`x`：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Continuous range scales
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连续范围刻度
- en: 'We can draw using the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来绘制：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We defined a linear scale with the domain encompassing all the values returned
    by the `weierstrass` function, and a range from zero to the drawing width. The
    scale will use linear interpolation to translate between the input and the output,
    and will even predict values that fall outside its domain. If we don't want that
    happening, we can use `.clamp()`. Using more than two numbers in the domain and
    range, we can create a polylinear scale where each section behaves like a separate
    linear scale.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个线性刻度，其定义域包含`weierstrass`函数返回的所有值，范围从零到绘图宽度。该刻度将使用线性插值在输入和输出之间进行转换，甚至可以预测其定义域之外的价值。如果我们不希望发生这种情况，我们可以使用`.clamp()`。在定义域和范围内使用超过两个数字，我们可以创建一个多线性刻度，其中每个部分都像是一个独立的线性刻度。
- en: 'The linear scale creates the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 线性刻度创建了以下截图：
- en: '![Continuous range scales](img/0007OS_03_05.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![连续范围刻度](img/0007OS_03_05.jpg)'
- en: 'Let''s add the other continuous scales in one fell swoop:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一次性添加其他连续刻度：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We keep re-using the same `line` definition, changing the scale used for `y`,
    except for the `power` scale, because changing `x` makes a better example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续重复使用相同的`line`定义，改变用于`y`的刻度，除了`power`刻度，因为改变`x`可以更好地说明例子。
- en: We also took into account that `log` is only defined on positive numbers, but
    you usually wouldn't use it for periodic functions anyway. It's much better at
    showing large and small numbers on the same graph.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还考虑了`log`仅在正数上有定义，但你通常不会用它来表示周期函数。它在同一张图上显示大数和小数方面做得更好。
- en: 'Now our picture looks as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的图片看起来如下所示：
- en: '![Continuous range scales](img/0007OS_03_06.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![连续范围刻度](img/0007OS_03_06.jpg)'
- en: The `identity` scale is orange and wiggles around by barely a pixel because
    the data we feed into the function only goes from -0.5 to 0.5, the `power` scale
    is green, and the `logarithmic` scale is red.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`identity`刻度是橙色，几乎不跳动，因为我们输入到函数中的数据只从-0.5到0.5，`power`刻度是绿色，而`logarithmic`刻度是红色。'
- en: Discrete range scales
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 离散范围刻度
- en: 'The interesting scales for our comparison are `quantize` and `threshold`. The
    `quantize` scale cuts the input domain into equal parts and maps them to values
    in the output range, while `threshold` scales let us map arbitrary domain sections
    to discrete values:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较中有趣的刻度是`quantize`和`threshold`。`quantize`刻度将输入域划分为相等的部分，并将它们映射到输出范围中的值，而`threshold`刻度允许我们将任意域部分映射到离散值：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `quantize` scale will divide the `weierstrass` function into discrete values
    between 1 and 2 with a step of 0.5 (-1, -0.5, 0, and so on), and threshold will
    map values smaller than -1 to -50, -1 to 0, and so on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`quantize`刻度将`weierstrass`函数划分为1到2之间的离散值，步长为0.5（-1, -0.5, 0，等等），而阈值将小于-1的值映射到-50，-1映射到0，等等。'
- en: 'The result looks as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Discrete range scales](img/0007OS_03_07.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![离散范围刻度](img/0007OS_03_07.jpg)'
- en: Time
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: You don't understand time. You might think you do, but you don't.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你不理解时间。你可能认为你理解了，但你并没有。
- en: Keep this in mind next time you want to add 3,600 seconds to a timestamp to
    advance it by an hour, or basically `now+24*3600` is tomorrow.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下次当你想要将3,600秒加到时间戳上以推进一小时，或者基本上`now+24*3600`就是明天时，请记住这一点。
- en: Time is a complicated beast. An hour can last 3600 seconds or 3599 seconds,
    if there's a leap second. Tomorrow can be 23 to 25 hours away, months range from
    28 to 31 days, and a year can be 365 or 366 days. Some decades have fewer days
    than others.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 时间是一个复杂的生物。一小时可以是3600秒或3599秒，如果有闰秒。明天可以是23到25小时，月份从28到31天不等，一年可以是365天或366天。有些十年比其他十年天数少。
- en: Considering many datasets are closely tied to time, this can become a big problem.
    Just how do you handle time?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到许多数据集与时间紧密相关，这可能会成为一个大问题。你该如何处理时间呢？
- en: Luckily, d3.js comes with a bunch of time-handling features.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，d3.js提供了一系列处理时间的功能。
- en: Formatting
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化
- en: You can create a new formatter by giving `d3.time.format()` a format string.
    You can then use it for parsing strings into `Date` objects and vice-versa.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过给`d3.time.format()`提供一个格式字符串来创建一个新的格式化器。然后你可以用它将字符串解析为`Date`对象，反之亦然。
- en: 'The whole language is explained in the documentation of d3.js, but let''s look
    at a few examples:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 整个语言都在d3.js的文档中解释，但让我们看看一些例子：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We defined a new formatter with `d3.time.format()` (year-month-day), then parsed
    a date as they often appear in datasets. This gave us a proper `date` object with
    default values for hours, minutes, and seconds.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`d3.time.format()`定义了一个新的格式化器（年-月-日），然后解析了数据集中常见的日期。这给了我们一个带有默认小时、分钟和秒的适当`date`对象。
- en: 'The same formatter works the other way:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的格式化器也可以反过来使用：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can find the full ISO standard time formatter at `d3.time.format.iso`. That
    often comes in handy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`d3.time.format.iso`找到完整的ISO标准时间格式化器。这通常很有用。
- en: Time arithmetic
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间算术
- en: 'We also get a full suite of time arithmetic functions that work with JavaScript''s
    `Date` objects and follow a few simple rules:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还得到了一套完整的时间算术函数，它们与JavaScript的`Date`对象一起工作，并遵循一些简单的规则：
- en: '`d3.time.interval`, where `interval` can be a `second`, `minute`, `hour`, and
    so on. It returns a new time interval. For instance, `d3.time.hour` will be an
    hour long.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`d3.time.interval`，其中`interval`可以是`second`、`minute`、`hour`等。它返回一个新的时间间隔。例如，`d3.time.hour`将是一个小时的长度。'
- en: '`d3.time.interval`(`Date`), is an alias for `interval.floor()`, which rounds
    `Date` down so that more specific units than the `interval` are set to zero.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`d3.time.interval`(`Date`)是一个`interval.floor()`的别名，它将`Date`向下取整，使得比`interval`更具体的单位被设置为零。'
- en: '`interval.offset`(`Date`, `step`), will move the date by a specified number
    of steps to the correct unit.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interval.offset`(`Date`, `step`)将根据指定的步数将日期移动到正确的单位。'
- en: '`interval.range`(`Date_start`, `Date_stop`), will return every `interval` between
    the two specified dates.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interval.range`(`Date_start`, `Date_stop`)将返回两个指定日期之间的每个`interval`。'
- en: '`d3.time.intervals`, where an `interval` is `seconds`, `minutes`, `hours`,
    and so on. They are helpful aliases for `interval.range`.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`d3.time.intervals`，其中`interval`是`seconds`、`minutes`、`hours`等。它们是`interval.range`的有用别名。'
- en: 'For instance, if you want to find the time an hour from now, you''d do this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想找到一小时后的时间，你会这样做：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And find out it's getting really late and you should stop writing books about
    JavaScript, and go to bed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 发现已经很晚了，你应该停止写关于JavaScript的书，去睡觉了。
- en: Geography
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理学
- en: Other useful data types are geospatial coordinates, often used for weather or
    population data; anything where you want to draw a map.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的数据类型是地理坐标，通常用于天气或人口数据；任何需要绘制地图的地方。
- en: 'd3.js gives us three tools for geographic data: paths produce the final pixels,
    projections turn sphere coordinates into Cartesian coordinates, and streams speed
    things up.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: d3.js为我们提供了三个用于地理数据的工具：路径生成最终像素，投影将球坐标转换为笛卡尔坐标，流加速处理。
- en: The main data format we'll use is TopoJSON, a more compact extension of GeoJSON,
    created by Mike Bostock. In a way, TopoJSON is to GeoJSON what DivX is to video.
    While GeoJSON uses the JSON format to encode geographical data with points, lines,
    and polygons, TopoJSON instead encodes basic features with arcs and re-uses them
    to build more and more complex features. As a result, files can be as much as
    80 percent smaller than when we use GeoJSON.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的主要数据格式是TopoJSON，它是GeoJSON的一个更紧凑的扩展，由Mike Bostock创建。从某种意义上说，TopoJSON是GeoJSON相对于视频的DivX。虽然GeoJSON使用JSON格式来编码地理数据，包括点、线和多边形，但TopoJSON使用弧线来编码基本特征，并重复使用它们来构建越来越复杂的特征。因此，文件可以比使用GeoJSON时小80%以上。
- en: Getting geodata
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取地理数据
- en: Now, unlike many other datasets, geodata can't be found just lying around the
    Internet. Especially not in a fringe format such as TopoJSON. We'll find some
    data in Shapefile or GeoJSON formats, and then use the `topojson` command-line
    utility to transform them into TopoJSON. Finding detailed data can be difficult,
    but is not impossible, look for your country's census bureau. For instance, the
    US Census Bureau has many useful datasets available at [http://www.census.gov/geo/www/cob/index.html](http://www.census.gov/geo/www/cob/index.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与许多其他数据集不同，地理数据不能在互联网上随意找到。特别是在像TopoJSON这样的边缘格式中。我们将找到一些Shapefile或GeoJSON格式的数据，然后使用`topojson`命令行工具将它们转换为TopoJSON。找到详细数据可能很困难，但并非不可能，查找您国家的统计局。例如，美国人口普查局在[http://www.census.gov/geo/www/cob/index.html](http://www.census.gov/geo/www/cob/index.html)提供了许多有用的数据集。
- en: Natural Earth is another magnificent resource for geodata at different levels
    of detail. The biggest advantage is that different layers (oceans, countries,
    roads, and so on) are carefully made to fit together without discrepancies and
    are frequently updated. You can find the datasets at [http://www.naturalearthdata.com/](http://www.naturalearthdata.com/).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Natural Earth是另一个提供不同细节级别地理数据的出色资源。最大的优势是不同的层（海洋、国家、道路等）被精心制作以相互匹配，没有差异，并且经常更新。您可以在[http://www.naturalearthdata.com/](http://www.naturalearthdata.com/)找到这些数据集。
- en: Let's prepare some data for the next example. Go to [http://www.naturalearthdata.com/](http://www.naturalearthdata.com/)
    and download the `ocean`, `land`, `rivers and lake centerlines`, and `land boundary
    lines` datasets at 50m detail level, and the `urban areas` dataset at 10m. You'll
    find them in the **Downloads** tab. The files are also in the examples on GitHub
    available at [https://github.com/Swizec/d3.js-book-examples/tree/master/ch3/data](https://github.com/Swizec/d3.js-book-examples/tree/master/ch3/data).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为下一个示例准备一些数据。访问[http://www.naturalearthdata.com/](http://www.naturalearthdata.com/)并下载50米细节级别的`ocean`、`land`、`rivers
    and lake centerlines`和`land boundary lines`数据集，以及10米的`urban areas`数据集。您可以在**下载**标签页中找到它们。这些文件也位于GitHub上的示例中，可在[https://github.com/Swizec/d3.js-book-examples/tree/master/ch3/data](https://github.com/Swizec/d3.js-book-examples/tree/master/ch3/data)找到。
- en: Unzip the five files. We'll combine them into three TopoJSON files to save the
    request time, three big files are quicker than five small files, and we prefer
    TopoJSON because of the smaller file size.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 解压这五个文件。我们将它们合并成三个TopoJSON文件以节省请求时间，三个大文件比五个小文件更快，我们更喜欢TopoJSON，因为它文件大小更小。
- en: We'll merge categorically so that we can reuse the files later; one for water
    data, another for land data, and a third for cultural data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按类别合并，这样我们以后可以重用这些文件；一个用于水数据，另一个用于土地数据，第三个用于文化数据。
- en: 'You''ll need to install `topojson`, which needs node.js. Follow the installation
    instructions for your computer on `nodejs.org`, then open a terminal, and run
    this command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装`topojson`，它需要node.js。按照`nodejs.org`上您电脑的安装说明进行操作，然后打开终端，并运行以下命令：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`npm` is node''s built-in package manager. It downloads and installs the `topojson`
    library globally. You might have to run this as a super user.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`是node的内置包管理器。它全局下载并安装`topojson`库。您可能需要以超级用户身份运行此命令。'
- en: 'Next, we transform the files with three simple commands:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用三个简单的命令转换这些文件：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `topojson` library transforms shape files into TopoJSON files and merges
    the files we wanted. We specified where to put the results with `-o`; the other
    arguments were source files.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`topojson`库将形状文件转换为TopoJSON文件，并合并我们想要合并的文件。我们使用`-o`指定了结果存放的位置；其他参数是源文件。'
- en: 'We''ve generated three files: `water.json`, `land.json`, and `cultural.json`.
    Feel free to look at them, but they aren''t very human-friendly.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已生成三个文件：`water.json`、`land.json`和`cultural.json`。您可以随意查看它们，但它们并不非常适合人类阅读。
- en: Drawing geographically
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制地理数据
- en: '`d3.geo.path()` is going to be the work horse of our geographic drawings. It''s
    similar to the SVG path generators we learned about earlier, except it draws geographic
    data and is smart enough to decide whether to draw a line or an area.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.geo.path()`将成为我们地理绘图的得力助手。它与之前我们了解的SVG路径生成器类似，但它绘制的是地理数据，并且足够智能，能够决定是绘制线条还是区域。'
- en: To flatten spherical objects such as planets into a 2D image, `d3.geo.path()`
    uses projections. Different kinds of projections are designed to showcase different
    things about the data, but the end result is you can completely change what the
    map looks like, just by changing the projection or moving its focal point.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将球形对象（如行星）展平为二维图像，`d3.geo.path()`使用投影。不同的投影类型被设计来展示数据的不同方面，但最终结果是，你只需更改投影或移动其焦点，就可以完全改变地图的外观。
- en: With the right projection you can even make the data of Europe look like the
    U.S. Rather unfortunately then, the default projection is `albersUsa` designed
    specifically to draw the standard map of U.S.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的投影，你甚至可以使欧洲的数据看起来像美国。遗憾的是，默认投影是专门为绘制标准地图而设计的`albersUsa`。
- en: Let's draw a map of the world, centered and zoomed into Europe because that's
    where I'm from. We'll make it navigable in [Chapter 4](ch04.html "Chapter 4. Making
    Things Move"), *Making Things Move*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制一个以欧洲为中心并放大到欧洲的地图，因为这是我来自的地方。我们将在[第4章](ch04.html "第4章。让事物移动")*让事物移动*中使其可导航。
- en: We first need to add some things to our standard HTML file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要向我们的标准HTML文件中添加一些内容。
- en: 'Add an empty `style` definition above the main div; we''ll use it later to
    make our map look better:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`div`上方添加一个空的`style`定义；我们稍后会用它来使我们的地图看起来更好：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also need two more JavaScript files right after d3.js:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在d3.js之后立即添加两个更多的JavaScript文件：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These load the TopoJSON parser and a queue utility to help us load more than
    one dataset.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容加载了TopoJSON解析器和队列工具，以帮助我们加载多个数据集。
- en: 'We continue in our JavaScript file with a drawing area:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在JavaScript文件中继续使用绘图区域：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we define a geographic `projection`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义地理`投影`：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `equirectangular` projection is one of the twelve projections that come
    with d3.js, and is perhaps the most common projection we're used to seeing ever
    since high school.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`等角投影`是d3.js附带十二种投影之一，可能是我们自高中以来最常见的一种投影。'
- en: The problem with `equirectangular` is that it doesn't preserve areas or represent
    the earth's surface all that well. A full discussion of projecting a sphere onto
    a two dimensional surface would take too much time, so I suggest looking at the
    Wikipedia page of d3.js and the visual comparison of all the projections implemented
    in the projection plugin. It is available at [https://github.com/mbostock/d3/wiki/Geo-Projections](https://github.com/mbostock/d3/wiki/Geo-Projections).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`等角投影`的问题在于它不保留面积或很好地表示地球表面。关于将球体投影到二维表面的全面讨论需要太多时间，所以我建议查看d3.js的维基百科页面以及投影插件中实现的所有投影的可视比较。它可在[https://github.com/mbostock/d3/wiki/Geo-Projections](https://github.com/mbostock/d3/wiki/Geo-Projections)找到。'
- en: The next two lines define where our map is centered and how zoomed in it is.
    By fiddling I got all three values latitude of `8`, longitude of `56`, and a scaling
    factor of `800`. Play around to get a different look.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行定义了地图的中心位置和缩放程度。通过调整，我得到了三个值：纬度为`8`，经度为`56`，缩放因子为`800`。尝试调整以获得不同的外观。
- en: 'Now we load our data:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们加载我们的数据：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We're using Mike Bostock's `queue` library to run the three loading operations
    in sequence. Each will use `d3.json` to load and parse the data, and when they're
    all done, `queue` will call `draw` with the results.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Mike Bostock的`queue`库按顺序运行三个加载操作。每个操作都将使用`d3.json`来加载和解析数据，当它们全部完成后，`queue`将使用结果调用`draw`。
- en: 'We need one more thing before we start drawing; a function that adds a feature
    to the map, which will help us reduce code repetition:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始绘图之前，我们还需要一个函数，该函数可以向地图添加一个功能，这将帮助我们减少代码重复：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This function takes a collection of objects and a key to choose which object
    to display. `topojson.object()` translates a TopoJSON topology into a GeoJSON
    one for `d3.geo.path()`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个对象集合和一个键，用于选择要显示的对象。`topojson.object()`将TopoJSON拓扑转换为GeoJSON，以便`d3.geo.path()`使用。
- en: Whether it's more efficient to transform to GeoJSON than transferring data in
    the target representation depends on your use case. Transforming data takes some
    computational time, but transferring megabytes instead of kilobytes can make a
    big difference in responsiveness.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 是否将数据转换为GeoJSON比在目标表示中传输数据更高效，取决于你的使用情况。转换数据需要一些计算时间，但将兆字节而不是千字节传输可以大大提高响应速度。
- en: Finally, we create a new `d3.geo.path()`, and tell it to use our projection.
    Other than generating the SVG path string, `d3.geo.path()` can also calculate
    different properties of our feature, such as the area (`.area()`) and the bounding
    box (`.bounds()`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个新的 `d3.geo.path()`，并告诉它使用我们的投影。除了生成 SVG 路径字符串外，`d3.geo.path()` 还可以计算我们特征的不同属性，如面积
    (`.area()`) 和边界框 (`.bounds()`).
- en: 'Now we can start drawing:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始绘制：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Our `draw` function takes the error returned from loading data, and the three
    datasets then lets `add_to_map` do the heavy lifting.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `draw` 函数接收加载数据返回的错误，以及三个数据集，然后让 `add_to_map` 执行繁重的工作。
- en: 'Add some styling to the HTML:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 给 HTML 添加一些样式：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Refreshing the page will reveal some oceans.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面将显示一些海洋。
- en: '![Drawing geographically](img/0007OS_03_08.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![地理绘制](img/0007OS_03_08.jpg)'
- en: 'We add four more `add_to_map` calls to the `draw` function to fill in the other
    features:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `draw` 函数中添加了四个额外的 `add_to_map` 调用，以填充其他功能：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add some style definitions as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下样式定义：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We now have a slowly rendering world map zoomed into Europe, displaying the
    world''s urban areas as blots:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个缓慢渲染的欧洲地区放大地图，显示世界城市区域作为斑点：
- en: '![Drawing geographically](img/0007OS_03_09.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![地理绘制](img/0007OS_03_09.jpg)'
- en: There are many reasons why it's so slow. We transform between TopoJSON and GeoJSON
    on every call to `add_to_map`. Even when using the same dataset, we're using data
    that's too detailed for such a zoomed out map, and we render the whole world to
    look at a tiny part. We traded flexibility for rendering speed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多原因导致它如此缓慢。我们在每次调用 `add_to_map` 时都在 TopoJSON 和 GeoJSON 之间转换。即使使用相同的数据集，我们也使用过于详细的数据来绘制如此缩放的地图，并且我们渲染整个世界来查看一个小部分。我们为了渲染速度而牺牲了灵活性。
- en: Using geography as a base
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用地理作为基础
- en: Geography isn't just about drawing maps. A map is usually a base we build to
    show some data.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 地理不仅仅是绘制地图。地图通常是我们构建的基础，用于展示一些数据。
- en: Let's turn this into a map of the world's airports. I wanted to make a map of
    the routes between airports at first, but it looked too crowded.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其转换为世界机场地图。最初我想制作机场之间的路线图，但它看起来太拥挤了。
- en: The first step is fetching the `airports.dat` and `routes.dat` datasets from
    [http://openflights.org/data.html](http://openflights.org/data.html). You can
    also find it in the examples on GitHub at [https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/data/airports.dat](https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/data/airports.dat).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从 [http://openflights.org/data.html](http://openflights.org/data.html) 获取
    `airports.dat` 和 `routes.dat` 数据集。你也可以在 GitHub 上的示例中找到它：[https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/data/airports.dat](https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/data/airports.dat)。
- en: 'Add a call to `add_airlines()` at the bottom of `draw`. We''ll use it to load
    more data and draw the airports:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `draw` 的底部添加对 `add_airlines()` 的调用。我们将使用它来加载更多数据并绘制机场：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The function loads the two datasets, and then calls `draw_airlines` to draw
    them. We use `d3.text` instead of `d3.csv` because the files don't have a header
    line so we have to parse them manually.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 函数加载了两个数据集，然后调用 `draw_airlines` 来绘制它们。我们使用 `d3.text` 而不是 `d3.csv`，因为文件没有标题行，所以我们必须手动解析。
- en: 'In `draw_airlines`, we first wrangle the data into JavaScript objects, airports
    into a dictionary by `id`, and routes into a mapping of source to the target airport:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `draw_airlines` 中，我们首先将数据整理成 JavaScript 对象，通过 `id` 将机场整理成字典，并将路线整理成源到目标机场的映射：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We used `d3.csv.parseRows` to parse CSV files into arrays and manually turned
    them into dictionaries. The array indices aren''t very legible unfortunately,
    but they make sense when you look at the raw data:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `d3.csv.parseRows` 将 CSV 文件解析成数组，并手动将它们转换为字典。不幸的是，数组索引不太易读，但当你查看原始数据时它们是有意义的：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The radius of each airport circle will show how many routes are leaving from
    it. So, we need a scale:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每个机场圆圈的半径将显示有多少路线从这里出发。因此，我们需要一个比例：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We took an array of route counts and turned it into a linear scale.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将路线计数数组转换为线性比例。
- en: 'Now we can draw the airports:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以绘制机场：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The tricky part is that we used the same `projection` we gave to `d3.geo.path()`
    to turn airport positions into circle coordinates. We avoided the `cx` and `cy`
    attributes so that we can take advantage of `projection` working on two coordinates
    at once. By now, everything else should be familiar from [Chapter 2](ch02.html
    "Chapter 2. A Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的部分在于我们使用了与`d3.geo.path()`相同的`projection`，将机场位置转换为圆坐标。我们避免了`cx`和`cy`属性，以便我们可以利用`projection`同时处理两个坐标。到目前为止，其他所有内容都应该来自[第2章](ch02.html
    "第2章。DOM、SVG和CSS入门"), *DOM、SVG和CSS入门*。
- en: Airports without routes will be very small dots.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 没有航线的机场将是非常小的点。
- en: 'Later we add some more CSS to our HTML:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在我们的HTML中添加了一些更多的CSS：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following screenshot displays the result:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了结果：
- en: '![Using geography as a base](img/0007OS_03_10.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![使用地理作为基础](img/0007OS_03_10.jpg)'
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You've made it through the chapter on data!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了关于数据的章节！
- en: We really got to the core of what d3.js is about, that is, data wrangling. The
    part about functional programming hopefully inspired you to take up functional-style
    programming, if you were still on the fence. Learning about data wrangling we
    saw some interesting properties of prime numbers, learned all about loading external
    data, and effectively used scales to avoid calculation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正触及了d3.js的核心，即数据处理。关于函数式编程的部分可能激发了你尝试函数式风格的编程，如果你还在犹豫不决的话。在了解数据处理的过程中，我们看到了一些素数的有趣属性，学习了如何加载外部数据，并有效地使用比例来避免计算。
- en: Finally, we made a cool map to learn how simple geographic data can be once
    you get a hand on a good source and transform it into a better format.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们制作了一张酷炫的地图，来学习一旦掌握了良好的数据源并将其转换为更好的格式，简单的地理数据可以变得多么简单。
