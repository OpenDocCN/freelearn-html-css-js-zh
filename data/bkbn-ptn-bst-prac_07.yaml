- en: Chapter 7. Organizing Backbone Applications – Structure, Optimize, and Deploy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 组织Backbone应用程序 – 结构、优化和部署
- en: In the previous chapters of this book, we looked at the individual components
    of Backbone.js and learned about several good practices that help create a better
    application. However, Backbone itself doesn't provide any application structure
    or guidance on how to organize the application source code. This makes it quite
    difficult for beginner-level programmers to understand how to create a folder
    structure, add proper namespaces, load script files in the appropriate order,
    and follow patterns to create a robust app architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们探讨了Backbone.js的各个组件，并学习了几个有助于创建更好应用程序的良好实践。然而，Backbone本身并不提供任何应用程序结构或关于如何组织应用程序源代码的指导。这使得初级程序员很难理解如何创建文件夹结构、添加适当的命名空间、按适当顺序加载脚本文件，并遵循模式创建健壮的应用程序架构。
- en: Almost every Backbone.js developer, at some point of time, faces this issue.
    You can find many articles (check the blog links on application architecture in
    [Appendix A](apa.html "Appendix A. Books, Tutorials, and References"), *Books,
    Tutorials, and References*) on the Web where developers have described how they
    tried to structure their Backbone code base. But that again makes the task difficult
    because you may need to choose a particular solution from a number of different
    opinions and understand whether that is the best solution or not. In this chapter,
    we will look at a step-by-step process on how to organize the structure for both
    small- and large-scale applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个Backbone.js开发者，在某个时刻都会遇到这个问题。您可以在网络上找到许多文章（检查[附录A](apa.html "附录 A. 书籍、教程和参考资料")中的应用程序架构博客链接，*书籍、教程和参考资料*），其中开发者们描述了他们如何尝试结构化他们的Backbone代码库。但这又使得任务变得困难，因为您可能需要从众多不同意见中选择一个特定的解决方案，并理解这是否是最佳解决方案。在本章中，我们将逐步探讨如何为小型和大型应用程序组织结构的过程。
- en: '**Application directory structure**: Code organization is crucial in order
    to start developing a nontrivial JavaScript application. This section illustrates
    a boilerplate directory structure that may help you to conceptualize your application
    structure.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序目录结构**：代码组织对于开始开发非平凡JavaScript应用程序至关重要。本节展示了一个样板目录结构，可能有助于您概念化应用程序结构。'
- en: '**Asynchronous module definition**: Rather than stacking a number of JavaScript
    files in your HTML file, **Asynchronous Module Definition** (**AMD**) helps in
    defining modules and loading its dependencies asynchronously in a subtle way.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步模块定义**：与在HTML文件中堆叠多个JavaScript文件不同，**异步模块定义**（**AMD**）以微妙的方式帮助定义模块并异步加载其依赖项。'
- en: '**Application architecture**: This section provides a complete step-by-step
    guide on the patterns and best practices that you should follow in your application
    architecture to make it flexible and maintainable.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序架构**：本节提供了一个完整的逐步指南，介绍您在应用程序架构中应遵循的模式和最佳实践，以使其灵活且易于维护。'
- en: Understanding the application directory structure
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用程序目录结构
- en: 'Code organization in a filesystem plays an important role in application development.
    It provides solutions to several problems such as the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中进行代码组织在应用程序开发中扮演着重要角色。它为以下问题提供了解决方案：
- en: Managing the separation of concern for views, models, collections, and routers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理视图、模型、集合和路由的关注点分离
- en: Defining a clear entry point to the application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序的清晰入口点
- en: Proper namespacing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的命名空间
- en: 'The directory structure that we are going to propose here is not something
    that will work universally for every application. As JavaScript doesn''t provide
    an inherent code organization mechanism, there is no single pattern that is best
    for all the applications; it solely depends on the situation. You are free to
    use the following structure, and lots of developers use it for their projects
    without any issues:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要提出的目录结构并不是适用于每个应用程序的通用解决方案。由于JavaScript没有提供固有的代码组织机制，没有一种适用于所有应用程序的最佳模式；它完全取决于具体情况。您可以使用以下结构，许多开发者都在他们的项目中使用它而没有问题：
- en: '![Understanding the application directory structure](img/3576OS_07_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![理解应用程序目录结构](img/3576OS_07_02.jpg)'
- en: We kept all of the static assets inside the `assets` folder. You can add more
    folders if you have other types of static resources. The templates are stored
    in a separate directory that matches the `views` folder structure. We will load
    these templates dynamically as needed and optimize them later to create a single
    file with all the templates (refer to [Appendix C](apc.html "Appendix C. Organizing
    Templates with AMD and Require.js"), *Organizing Templates with AMD and Require.js*,
    for more details). The `main.js` file is the entry point of the application. You
    will see its usage in the following section when we will discuss working with
    AMD. The `app.js` file holds the application class that acts as the topmost parent
    class of the application. All the utility files such as `utility.js` or `helper.js`,
    which mostly contain the helper methods, sit in the `util` folder. The `test`
    folder is the main directory in which all the test scripts are stored. The `config`
    and `mixin` folders are there to store the config and reusable mixin files respectively.
    This file structure is basic and can work as the boilerplate of your application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有静态资源都保存在`assets`文件夹内。如果您有其他类型的静态资源，可以添加更多文件夹。模板存储在一个单独的目录中，与`views`文件夹结构相匹配。我们将根据需要动态加载这些模板，并在之后对其进行优化，以创建包含所有模板的单个文件（有关更多详细信息，请参阅[附录C](apc.html
    "附录 C. 使用AMD和Require.js组织模板")，*使用AMD和Require.js组织模板*）。`main.js`文件是应用的入口点。在下一节讨论使用AMD时，您将看到它的用法。`app.js`文件包含作为应用最高父类的应用类。所有如`utility.js`或`helper.js`之类的实用文件，主要包含辅助方法，都位于`util`文件夹中。`test`文件夹是存储所有测试脚本的主体目录。`config`和`mixin`文件夹分别用于存储配置和可重用混合文件。这种文件结构是基本的，可以作为您应用的模板。
- en: 'There is another pattern that became popular for large and complex applications
    recently—the modular approach. In this case, we divide the complete application
    into multiple small modules; each module will add a specific functionality to
    the app. We will look into it later in this chapter, but we can discuss the file
    structure of this pattern here. A module consists of its own views, models, and
    collections. You can have one `templates` folder for each module and place that
    module''s templates separately in that folder, or you can leave it as it is as
    a single `templates` folder for the complete project. We will go for the latter;
    the `app` folder will look like the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，对于大型和复杂的应用程序，另一种模式变得流行起来——模块化方法。在这种情况下，我们将完整的应用程序划分为多个小型模块；每个模块将为应用添加特定的功能。我们将在本章的后面部分探讨它，但我们可以在这里讨论这种模式的文件结构。一个模块包括它自己的视图、模型和集合。您可以每个模块有一个`templates`文件夹，并将该模块的模板分别放置在该文件夹中，或者您可以将它们作为一个单独的`templates`文件夹保留在完整项目中。我们将选择后者；`app`文件夹将类似于以下截图：
- en: '![Understanding the application directory structure](img/3576OS_07_03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![理解应用目录结构](img/3576OS_07_03.jpg)'
- en: As you can see, there is no separate `models`, `collections`, or `views` folder;
    instead, there is a `modules` directory that includes all the modules of the application.
    Each module contains a `main.js` file that works as the starting point of that
    module.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里没有单独的`models`、`collections`或`views`文件夹；相反，有一个包含应用所有模块的`modules`目录。每个模块都包含一个`main.js`文件，该文件作为该模块的起点。
- en: 'Now, how will you benefit by using such a modular pattern over the directory
    structure? Actually this is not just a change in the directory structure, but
    a completely new application architecture. We noticed that beginner-level developers,
    who are not very familiar with the module patterns, find it difficult to start
    with this structure—probably because it''s a new concept. However, once you start
    using it, you will realize that it is quite easy to work with and flexible too.
    The advantages of using such structures are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将如何从使用这种模块化模式中受益呢？实际上，这不仅仅是对目录结构的改变，而是一种全新的应用架构。我们注意到，对于不太熟悉模块模式的初级开发者来说，从这种结构开始可能会觉得有些困难——可能是因为这是一个新概念。然而，一旦您开始使用它，您会发现它相当容易操作，并且也很灵活。使用这种结构的优点如下：
- en: The modules are generally independent of each other. So, you can re-use one
    module elsewhere with minimum changes.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块通常相互独立。因此，您可以在其他地方重新使用一个模块，只需进行最小限度的修改。
- en: The modules generally do not communicate with each other directly; they use
    a common medium to communicate. So, you can change or delete one module while
    the others stay untouched.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块通常不会直接相互通信；它们使用一个公共媒介进行通信。因此，您可以在其他模块保持不变的情况下更改或删除一个模块。
- en: Your code base becomes modular and more flexible as each module encapsulates
    their functionality. For example, a `User` module performs all of the user-related
    functions; no other part of your application will handle any user-related job.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着每个模块封装其功能，您的代码库变得更加模块化和灵活。例如，一个`User`模块执行所有与用户相关的功能；应用程序的任何其他部分都不会处理任何与用户相关的任务。
- en: The previous structure is not the only way to make the app modular. There are
    several other concepts and you can choose any of them as per your requirements.
    For example, I often use the AuraJS directory structure (the `TodoMVC` app from
    [https://github.com/aurajs/todomvc](https://github.com/aurajs/todomvc)) while
    working with this framework. It is similar yet different and useful. So, if you
    are aware of multiple such directory structures and do not know which one to choose,
    go for the one that we mentioned previously. There is no harm in following a standard
    structure; it is better than going for an unstructured project directory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的结构并不是使应用程序模块化的唯一方式。还有其他几个概念，您可以根据需求选择其中任何一个。例如，我在使用这个框架时经常使用AuraJS目录结构（来自[https://github.com/aurajs/todomvc](https://github.com/aurajs/todomvc)的`TodoMVC`应用程序）。它既相似又不同，且很有用。所以，如果您了解多个这样的目录结构但不知道选择哪一个，就选择我们之前提到的那个。遵循标准结构没有坏处；这比选择一个无结构的项目目录要好。
- en: Working with Asynchronous Module Definition
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步模块定义（AMD）进行工作
- en: So far, we have learned to add all our script files in HTML files within `SCRIPT`
    tags. The browser loads these files synchronously and hence we always need to
    ensure that if one file has a dependency over another file, the latter should
    always be loaded prior to the former. Since all of the references to these dependencies
    are made via global variables, these dependencies must be loaded in the proper
    order, and a developer must take care of them before he adds a new script file
    to the application. Although this process works just fine, it may become difficult
    to manage large applications as too many dependencies will overlap. AMD provides
    a solution to this problem.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了在HTML文件中的`SCRIPT`标签内添加所有我们的脚本文件。浏览器会同步加载这些文件，因此我们始终需要确保如果一个文件依赖于另一个文件，那么后者应该始终在前者之前加载。由于所有这些依赖项的引用都是通过全局变量进行的，因此这些依赖项必须按正确的顺序加载，并且开发者在添加新的脚本文件到应用程序之前必须注意它们。尽管这个过程运行得很好，但随着依赖项数量的增加，管理大型应用程序可能会变得困难。AMD提供了解决这个问题的方案。
- en: AMD is a mechanism used to define a module such that the module and its dependencies
    can be asynchronously loaded. So, multiple AMD modules can be loaded in parallel,
    and once the last dependent module is loaded, the main module will execute. In
    addition, AMD omits the use of global variables by encapsulating the module definition,
    and provides a way to load multiple modules into one file and obviates the need
    for explicit namespacing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: AMD是一种机制，用于定义一个模块，使得模块及其依赖项可以异步加载。因此，可以并行加载多个AMD模块，一旦最后一个依赖模块加载完成，主模块就会执行。此外，AMD通过封装模块定义来避免使用全局变量，并提供了一种将多个模块加载到单个文件中的方法，从而消除了显式命名空间的需求。
- en: Presently, the most popular script loader that supports AMD is Require.js ([http://requirejs.org](http://requirejs.org)).
    It provides an implementation of the module patterns and allows us to create a
    centrally-managed dependency mapping using its map configuration. Discussing Require.js
    in detail is beyond the scope of this chapter. So, if you want to get a complete
    overview of the concept, we recommend you visit their website first before proceeding
    to the following sections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，支持AMD的最流行的脚本加载器是Require.js ([http://requirejs.org](http://requirejs.org))。它提供了模块模式的实现，并允许我们使用其map配置创建一个集中管理的依赖映射。详细讨论Require.js超出了本章的范围。因此，如果您想全面了解这个概念，我们建议您首先访问他们的网站，然后再继续阅读以下部分。
- en: Adding Require.js to your project
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Require.js添加到您的项目中
- en: 'While `require.js` loads all the modules of your application, it is the only
    file that you need to include in your `index.html` file. Add the following script
    tag within the `HEAD` tag:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当`require.js`加载您应用程序的所有模块时，它是您需要在`index.html`文件中包含的唯一文件。在`HEAD`标签内添加以下脚本标签：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `data-main` attribute specifies the JavaScript file that will act as the
    starting point of the application. In this case, it is our `main.js` file. Once
    the `require.js` file is loaded, it looks into the `data-main` attribute's entry
    point and loads that script. We are going to add the entire `require.js` configuration
    to this file along with all of the libraries and their dependencies. You do not
    need to add a `.js` extension to any file as RequireJS automatically appends that.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-main` 属性指定了作为应用程序起点的 JavaScript 文件。在这种情况下，它是我们的 `main.js` 文件。一旦 `require.js`
    文件被加载，它会查找 `data-main` 属性的入口点并加载该脚本。我们将把整个 `require.js` 配置以及所有库及其依赖项添加到该文件中。你不需要为任何文件添加
    `.js` 扩展名，因为 RequireJS 会自动添加。'
- en: Configuring dependencies
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置依赖项
- en: 'We are going to add all the library files in the RequireJS config option, along
    with their paths and dependencies, to the `main.js` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把所有库文件及其路径和依赖项添加到 `main.js` 文件中：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We call the `require.config()` method in the `data-main` entry file and pass
    a configuration object with a set of properties to it. There are quite a number
    of properties that can go as config options, but we will discuss only those that
    are the most important at this point. You can find a complete list in the `require.js`
    API ([http://requirejs.org/docs/api.html](http://requirejs.org/docs/api.html)):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `data-main` 入口文件中调用 `require.config()` 方法，并向它传递一个包含一组属性的配置对象。有许多属性可以作为配置选项使用，但我们将只讨论目前最重要的那些。你可以在
    `require.js` API 中找到完整的列表（[http://requirejs.org/docs/api.html](http://requirejs.org/docs/api.html)）：
- en: '`baseUrl`: This config defines the root path so you do not need to include
    it every time in your file paths.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseUrl`: 此配置定义了根路径，因此你不需要在文件路径中每次都包含它。'
- en: '`paths`: This config specifies the shortcut alias of each file and the paths
    to the files are given relative to `baseUrl`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths`: 此配置指定了每个文件的快捷别名以及文件路径相对于 `baseUrl` 的位置。'
- en: '`shim`: This config should be used only for the non-AMD files, that is, the
    scripts that do not already call the `define()` method. It will not work properly
    for AMD files.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shim`: 此配置仅适用于非 AMD 文件，即尚未调用 `define()` 方法的脚本。它对 AMD 文件不起作用。'
- en: '`exports`: This config is the global variable name of that module.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports`: 此配置是该模块的全局变量名。'
- en: '`deps`: This config is an array of dependencies that must be loaded first before
    the respective module loads.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deps`: 此配置是一个依赖项数组，必须在相应模块加载之前先加载。'
- en: You need to look for the AMD-enabled version of the library files if you want
    to use them directly. Otherwise, you have to go via the `shim` option.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要直接使用库文件，需要查找其 AMD 启用版本。否则，你必须通过 `shim` 选项进行访问。
- en: Defining a module
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模块
- en: 'RequireJS provides two important methods—`define()` and `require()`, which
    facilitate module definition and dependency loading respectively. The `define()`
    method takes an optional module ID, an optional array that includes the dependencies
    that this module may require, and a function that gets executed in order to instantiate
    the module. The most basic module definition of a Backbone model will look like
    this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS 提供了两个重要的方法——`define()` 和 `require()`，分别用于模块定义和依赖项加载。`define()` 方法接受一个可选的模块
    ID、一个可选的数组，该数组包含此模块可能需要的依赖项，以及一个函数，该函数按顺序执行以实例化模块。Backbone 模型最基本的模块定义看起来像这样：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, this model can be used in another file just as the other dependencies.
    The interesting thing is that RequireJS makes sure that a particular file is loaded
    only once, irrespective of how many times you include it in several files. Now,
    let''s create a `Users` collection and use our `User` model there:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个模型可以像其他依赖项一样在另一个文件中使用。有趣的是，RequireJS 确保特定文件只加载一次，无论你在多个文件中包含它的次数有多少。现在，让我们创建一个
    `Users` 集合并使用我们的 `User` 模型：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is pretty simple, right? Also, notice that we loaded the dependencies in
    a pattern other than what we used for our model definition. This pattern is called
    the `Sugar` syntax and it utilizes the `require()` method to load the dependencies.
    You can use either of the syntaxes with your module definitions. When there are
    lots of dependencies, using the `Sugar` syntax makes it easier to organize the
    dependency variables rather than just putting them as arguments of a function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很简单，对吧？此外，请注意，我们加载依赖项的方式与我们用于模型定义的方式不同。这种模式被称为`Sugar`语法，它利用`require()`方法来加载依赖项。你可以使用这两种语法之一来定义你的模块。当有大量依赖项时，使用`Sugar`语法比仅仅将它们作为函数的参数更容易组织依赖变量。
- en: So, with AMD, you can define all of your files in the same way. The script dependencies
    are loaded as we saw previously, and the text dependencies can be loaded using
    the `text` plugin ([https://github.com/requirejs/text](https://github.com/requirejs/text))
    of RequireJS. We already discussed this thoroughly in [Appendix C](apc.html "Appendix C. Organizing
    Templates with AMD and Require.js"), *Organizing Templates with AMD and Require.js*,
    when we loaded the external template files using this plugin. In the following
    section, we are going to see how we can initiate a complete application architecture
    using these concepts.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用AMD，你可以以相同的方式定义所有文件。脚本依赖项的加载方式与我们之前看到的方式相同，而文本依赖项可以使用RequireJS的`text`插件（[https://github.com/requirejs/text](https://github.com/requirejs/text)）来加载。我们已经在[附录C](apc.html
    "附录 C. 使用AMD和Require.js组织模板")中详细讨论了这一点，*使用AMD和Require.js组织模板*，当时我们使用此插件加载外部模板文件。在下一节中，我们将看到如何使用这些概念启动完整的应用程序架构。
- en: Creating application architecture
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序架构
- en: The essential premise at the heart of Backbone has always been to try and discover
    the minimal set of data-structuring (Models and Collections) and user interface
    (Views and URLs) primitives that are useful when building web applications with
    JavaScript.
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Backbone的核心前提始终是尝试发现构建JavaScript Web应用时最有用的最小数据结构（模型和集合）和用户界面（视图和URL）原语。
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jeremy Ashkenas, creator of Backbone.js, Underscore.js, and CoffeeScript
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Jeremy Ashkenas，Backbone.js、Underscore.js和CoffeeScript的创造者
- en: As Jeremy mentioned, Backbone.js has no intention, at least in the near future,
    to raise its bar to provide application architecture. Backbone will continue to
    be a lightweight tool to produce the minimal features required for web development.
    So, should we blame Backbone.js for not including such functionality even though
    there is a huge demand for this in the developer community? Certainly not! Backbone.js
    only yields the set of components that are necessary to create the backbone of
    an application and gives us complete freedom to build the app architecture in
    whichever way we want.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如Jeremy所提到的，Backbone.js至少在近期内没有打算提高其标准以提供应用程序架构。Backbone将继续作为一个轻量级工具，以产生开发Web应用所需的最小功能。那么，我们应该责怪Backbone.js没有包括这种功能，尽管在开发者社区中对此有巨大的需求吗？当然不是！Backbone.js只提供创建应用程序骨架所需的组件，并给我们完全的自由，以我们想要的方式构建应用程序架构。
- en: If working on a significantly large JavaScript application, remember to dedicate
    sufficient time to planning the underlying architecture that makes the most sense.
    It's often more complex than you may initially imagine.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果正在开发一个规模较大的JavaScript应用程序，请记住为规划底层架构投入足够的时间，这个架构应该是最有意义的。它通常比你最初想象的要复杂。
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Addy Osmani, author of Patterns For Large-Scale JavaScript Application Architecture
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Addy Osmani，大型JavaScript应用程序架构模式书籍的作者
- en: So, as we start digging into more detail on creating an application architecture,
    we are not going to talk about trivial applications or something similar to a
    to-do-list app. Rather, we will investigate how to structure a medium- or large-level
    application. After discussions with a number of developers, we found that the
    main issue they face here is that there are several methodologies the online blog
    posts and tutorials offer to structure an application. While most of these tutorials
    talk about good practices, it becomes difficult to choose exactly one from them.
    Keeping that in mind, we will explore a number of steps that you should follow
    to make your app robust and maintainable in the long run.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们开始深入探讨创建应用程序架构的更多细节时，我们不会谈论简单的应用程序或类似待办事项列表应用程序的内容。相反，我们将研究如何构建中等或大型应用程序的结构。在与许多开发者讨论后，我们发现他们面临的主要问题是，在线博客文章和教程提供了多种方法来组织应用程序。虽然大多数这些教程都讨论了良好的实践，但很难从中选择一个。考虑到这一点，我们将探索一系列你应该遵循的步骤，以确保你的应用程序在长期内既健壮又易于维护。
- en: Managing a project directory
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理项目目录
- en: This is the first step towards creating a solid app architecture. We have already
    discussed this in detail in the previous sections. If you are comfortable using
    another directory layout, go ahead with it. The directory structure will not matter
    much if the rest of your application is organized properly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建稳固的应用程序架构的第一步。我们已经在前面的章节中详细讨论了这一点。如果你习惯于使用另一种目录布局，那就继续使用吧。如果应用程序的其他部分组织得当，目录结构就不会很重要。
- en: Organizing code with AMD
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AMD组织代码
- en: 'We will use RequireJS for our project. As discussed earlier, it comes with
    a bunch of facilities such as the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的项目中使用RequireJS。如前所述，它附带了一系列功能，例如以下内容：
- en: Adding a lot of script tags in one HTML file and managing all of the dependencies
    on your own may work for a medium-level project, but will gradually fail for a
    large-level project. Such a project may have thousands of lines of code; managing
    a code base of that size requires small modules to be defined in each individual
    file. With RequireJS, you do not need to worry about how many files you have—you
    just know that if the standard is followed properly, it is bound to work.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个HTML文件中添加大量的脚本标签并自己管理所有依赖项可能适用于中等规模的项目，但对于大型项目来说，这种方法最终会失败。这样的项目可能有数千行代码；管理如此规模的代码库需要在每个单独的文件中定义小的模块。使用RequireJS，你不需要担心你有多少个文件——你只需知道，如果正确遵循标准，它肯定能工作。
- en: The global namespace is never touched and you can freely give the best names
    to something that matches with it the most.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局命名空间永远不会被触及，你可以自由地为与之最匹配的东西赋予最佳名称。
- en: Debugging the RequireJS modules is a lot easier than other approaches because
    you know what the dependencies and path to each of them are in every module definition.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试RequireJS模块比其他方法容易得多，因为你知道每个模块定义中每个依赖项的依赖关系和路径。
- en: You can use `r.js`, an optimization tool for RequireJS that minifies all the
    JavaScript and CSS files, to create the production-ready build.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`r.js`，这是RequireJS的一个优化工具，它可以最小化所有的JavaScript和CSS文件，来创建生产就绪的构建。
- en: Setting up an application
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用程序
- en: For a Backbone app, there must be a centralized object that will hold together
    all the components of the application. In a simple application, most people generally
    just make the main router work as the central object. But that will surely not
    work for a large application and you need an `Application` object that should
    work as the parent component. This object should have a method (mostly `init()`)
    that will work as the entry point to your application and initialize the main
    router along with the Backbone history. In addition, either your `Application`
    class should extend `Backbone.Events` or it should include a property that points
    to an instance of the `Backbone.Events` class. The benefit of doing this is that
    the `app` or `Backbone.Events` instance can act as a central event aggregator,
    and you can trigger application-level events on it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Backbone应用程序，必须有一个中心化的对象来整合应用程序的所有组件。在简单的应用程序中，大多数人通常只是让主路由器作为中心对象工作。但这对大型应用程序肯定不起作用，你需要一个`Application`对象，它应该作为父组件工作。这个对象应该有一个方法（通常是`init()`），它将作为应用程序的入口点并初始化主路由器以及Backbone历史记录。此外，你的`Application`类应该扩展`Backbone.Events`，或者它应该包含一个指向`Backbone.Events`类实例的属性。这样做的好处是`app`或`Backbone.Events`实例可以作为中心事件聚合器，你可以在其上触发应用程序级事件。
- en: 'A very basic `Application` class will look like the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常基本的 `Application` 类将类似于以下代码片段：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Application` is a simple class with an `init()` method and a `PubSub` instance.
    The `init()` method acts as the starting point of the application and `PubSub`
    works as the application-level event manager. You can add more functionality to
    the `Application` class, such as starting and stopping modules and adding a region
    manager for view layout management. It is advisable to keep this class as short
    as you can.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application` 是一个简单的类，具有 `init()` 方法和 `PubSub` 实例。`init()` 方法作为应用程序的起点，而 `PubSub`
    作为应用程序级的事件管理器。您可以为 `Application` 类添加更多功能，例如启动和停止模块，以及添加用于视图布局管理的区域管理器。建议尽可能保持此类尽可能简短。'
- en: Using the module pattern
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模块模式
- en: We often see that intermediate-level developers find it a bit confusing to initially
    use a module-based architecture. It can be a little difficult for them to make
    the transition from a simple MVC architecture to a modular MVC architecture. While
    the points we are discussing in this chapter are valid for both these architectures,
    we should always prefer to use a modular concept in nontrivial applications for
    better maintainability and organization.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常看到中级开发者最初使用基于模块的架构时感到有些困惑。对于他们来说，从简单的 MVC 架构过渡到模块化 MVC 架构可能有点困难。虽然本章讨论的点适用于这两种架构，但我们始终应优先使用模块化概念，以实现更好的可维护性和组织。
- en: 'In the directory structure section, we saw how the module consists of a `main.js`
    file, its views, models, and collections all together. The `main.js` file will
    define the module and have different methods to manage the other components of
    that module. It works as the starting point of the module. A simple `main.js`
    file will look like the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录结构部分，我们看到了模块由一个 `main.js` 文件、其视图、模型和集合组成。`main.js` 文件将定义模块并具有管理该模块其他组件的不同方法。它作为模块的起点。一个简单的
    `main.js` 文件将类似于以下代码：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the responsibility of this file is to initiate the module and
    manage the components of that module. We have to make sure that it handles only
    parent-level tasks; it shouldn't contain a method that one of its views should
    ideally have.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，此文件的责任是初始化模块并管理该模块的组件。我们必须确保它只处理父级任务；它不应包含其视图理想中应该有的方法。
- en: The concept is not very complex, but you need to set it up properly in order
    to use it for a large application. You can even go for an existing app and module
    setup and integrate it with your Backbone app. For instance, Marionette provides
    an application infrastructure for Backbone apps. You can use its inbuilt `Application`
    and `Module` classes to structure your application. It also provides a general-purpose
    `Controller` class—something that doesn't come with the Backbone library but can
    be used as a mediator to provide generic methods and work as a common medium among
    the modules.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念并不复杂，但您需要正确设置它，以便在大型应用程序中使用。您甚至可以采用现有的应用程序和模块设置，并将其与您的 Backbone 应用程序集成。例如，Marionette
    为 Backbone 应用程序提供了一个应用程序基础设施。您可以使用其内置的 `Application` 和 `Module` 类来构建您的应用程序。它还提供了一个通用的
    `Controller` 类——这是 Backbone 库中没有的，但可以用作中介来提供通用方法，并在模块之间作为共同媒介。
- en: 'You can also use AuraJS ([https://github.com/aurajs/aura](https://github.com/aurajs/aura)),
    a framework-agonistic event-driven architecture developed by Addy Osmani ([http://addyosmani.com](http://addyosmani.com))
    and many others; it works quite well with Backbone.js. A thorough discussion on
    AuraJS is beyond the scope of this book, but you can grab a lot of useful information
    about it from its documentation and examples ([https://github.com/aurajs/todomvc](https://github.com/aurajs/todomvc)).
    It is an excellent boilerplate tool that gives your app a kick-start and we highly
    recommend it, especially if you are not using the Marionette application infrastructure.
    The following are a few benefits of using AuraJS; they may help you choose this
    framework for your application:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 AuraJS ([https://github.com/aurajs/aura](https://github.com/aurajs/aura))，这是一个由
    Addy Osmani ([http://addyosmani.com](http://addyosmani.com)) 和许多人开发的框架无关的事件驱动架构；它与
    Backbone.js 工作得相当好。AuraJS 的详细讨论超出了本书的范围，但您可以从其文档和示例 ([https://github.com/aurajs/todomvc](https://github.com/aurajs/todomvc))
    中获取大量有用的信息。它是一个出色的样板工具，可以为您的应用程序提供一个起点，我们强烈推荐它，尤其是如果您不使用 Marionette 应用程序基础设施。以下是使用
    AuraJS 的一些好处；它们可能有助于您为应用程序选择此框架：
- en: AuraJS is framework-agnostic. Though it works great with Backbone.js, you can
    use it for your JavaScript module architecture even if you aren't using Backbone.js.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AuraJS是框架无关的。尽管它与Backbone.js配合得很好，但你即使不使用Backbone.js，也可以用它来构建你的JavaScript模块架构。
- en: It utilizes the module pattern, application-level and module-level communication
    using the facade (sandbox) and mediator patterns.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它利用了模块模式，使用外观（沙盒）和中介者模式进行应用级和模块级通信。
- en: It abstracts away the utility libraries that you use (such as templating and
    DOM manipulation) so you can swap alternatives anytime you want.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它抽象了你使用的实用库（例如模板和DOM操作），这样你就可以在需要时随时替换替代方案。
- en: Managing objects and module communication
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理对象和模块通信
- en: One of the most important ways to keep the application code maintainable is
    to reduce the tight coupling between modules and objects. If you are following
    the module pattern, you should never let one module communicate with another directly.
    Loose coupling adds a level of restriction in your code, and a change in one module
    will never enforce a change in the rest of the application. Moreover, it lets
    you re-use the same modules elsewhere. But how can we communicate if there is
    no direct relationship? The two important patterns we use in this case are the
    observer and mediator patterns.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 保持应用程序代码可维护的最重要方法之一是减少模块和对象之间的紧密耦合。如果你遵循模块模式，你永远不应该让一个模块直接与另一个模块通信。松散耦合在你的代码中增加了一层限制，一个模块的变化永远不会强制应用程序其他部分发生变化。此外，它还允许你在其他地方重用相同的模块。但是如果没有直接关系，我们如何进行通信呢？在这种情况下，我们使用的两个重要模式是观察者和中介者模式。
- en: Using the observer/PubSub pattern
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用观察者/PubSub模式
- en: The PubSub pattern is nothing but the event dispatcher concept that we discussed
    in [Chapter 6](ch06.html "Chapter 6. Working with Events, Sync, and Storage"),
    *Working with Events, Sync, and Storage*. It works as a messaging channel between
    the object (publisher) that fires the event and another object (subscriber) that
    receives the notification.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: PubSub模式不过是我们在[第6章](ch06.html "第6章。处理事件、同步和存储")中讨论的事件分发概念，*处理事件、同步和存储*。它作为触发事件的对象（发布者）和接收通知的另一个对象（订阅者）之间的消息通道。
- en: '![Using the observer/PubSub pattern](img/3576OS_07_01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![使用观察者/PubSub模式](img/3576OS_07_01.jpg)'
- en: We mentioned earlier that we can have an application-level event aggregator
    as a property of the `Application` object. This event aggregator can work as the
    common channel via which the other modules can communicate, and that too without
    interacting directly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，我们可以将应用级事件聚合器作为`Application`对象的属性。这个事件聚合器可以作为其他模块通信的公共通道工作，而且无需直接交互。
- en: Even at the module-level, you may need a common event dispatcher only for that
    module; the views, models, and collections of that module can use it to communicate
    with each other. However, publishing too many events via a dispatcher sometimes
    makes it difficult to manage them and you must be careful enough to understand
    which events you should publish via a generic dispatcher and which ones you should
    fire on a certain component only. Anyhow, this pattern is one of the best tools
    to design a decoupled system, and you should always have one ready for use in
    your module-based application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在模块级别，你也可能只需要为该模块提供一个公共事件分发器；该模块的视图、模型和集合可以使用它来相互通信。然而，通过分发器发布太多事件有时会使管理它们变得困难，你必须足够小心地理解哪些事件应该通过通用分发器发布，哪些事件应该在特定组件上触发。无论如何，这种模式是设计解耦系统的最佳工具之一，你应该始终为你的基于模块的应用程序准备一个可供使用的模式。
- en: Using the mediator pattern
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用中介者模式
- en: Sometimes, you may find that too many relationships exist between the modules
    of your app, and you need a central point of control that will help manage all
    the communication. This centralized system is called the mediator; it works as
    a *shared subject* between a set of modules and promotes loose coupling by not
    referring to the modules explicitly. All the modules will have a reference to
    this mediator.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能会发现你的应用程序模块之间存在太多的关系，你需要一个中心控制点来帮助管理所有通信。这个集中式系统被称为中介者；它作为一组模块之间的*共享主题*工作，通过不明确引用模块来促进松散耦合。所有模块都将引用这个中介者。
- en: 'The mediator pattern is somewhat similar to the observer pattern, but it doesn''t
    work as a broadcasting system. It includes a set of methods that are accessible
    to all modules that share this mediator. A mediator can be a simple object with
    a number of required methods:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 调解模式在某种程度上类似于观察者模式，但它不作为一个广播系统工作。它包括一组对所有共享此调解者的模块都适用的方法。调解者可以是一个具有多个必需方法的简单对象：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Any module can access any method of this mediator.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 任何模块都可以访问这个调解者的任何方法。
- en: '|   | *A mediator is best applied when two or more objects have an indirect
    working relationship, and business logic or workflow needs to dictate the interactions
    and coordination of these objects.* |   |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|   | *调解者最好应用于两个或更多对象具有间接工作关系，并且业务逻辑或工作流程需要规定这些对象的交互和协调时。* |   |'
- en: '|   | --*Addy Osmani* |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Addy Osmani* |'
- en: 'The concept of a mediator will get more clear once we look at a simple example.
    Assume that we have two modules: `User` and `Event`. The `User` module has a `getUserDetails()`
    method to retrieve a user''s details based on the user ID. The `Event` module
    has a `loadEvents()` method whose job it is to load all the events near the user''s
    current location. Now, getting the currently logged-in user''s ID or current location
    is a functionality that isn''t particularly module-specific, and it is better
    to keep it in a `Mediator` instance. Look at the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们查看一个简单的示例，调解者的概念就会变得更加清晰。假设我们有两个模块：`User`和`Event`。`User`模块有一个`getUserDetails()`方法，可以根据用户ID检索用户的详细信息。`Event`模块有一个`loadEvents()`方法，其任务是加载用户当前位置附近的所有事件。现在，获取当前登录用户的ID或当前位置是一个不是特别模块特定的功能，最好将其保存在`Mediator`实例中。看看以下示例：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, we just pass the `Mediator` instance in both the module definitions
    and place the reusable and shared methods inside the mediator so that they can
    be accessed from any module. This is a basic example; we hope that it conveys
    the idea of using a mediator. In a complete application level, a mediator may
    take care of a lot of its functionality. Using a mediator without knowing its
    proper use is not a good idea—let''s look at the pros and cons of using a mediator
    pattern:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是在模块定义中传递`Mediator`实例，并将可重用和共享的方法放在调解者内部，以便可以从任何模块访问它们。这是一个基本示例；我们希望它能传达使用调解者的概念。在完整的应用程序级别，调解者可能负责很多功能。不了解其正确使用方法就使用调解者不是一个好主意——让我们来看看使用调解模式的优缺点：
- en: 'The pros are as follows:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点如下：
- en: The biggest advantage of using the mediator pattern is that it enforces the
    communication channel between modules to change from many-to-many to many-to-one.
    So, the modules will not communicate directly with each other but via the `mediator`
    object.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调解模式的最大优点是它强制模块之间的通信渠道从多对多变为多对一。因此，模块将不会直接相互通信，而是通过`mediator`对象进行通信。
- en: It omits the tight coupling between modules and thus reduces the architectural
    complexity in large applications.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它消除了模块之间的紧密耦合，从而减少了大型应用程序的架构复杂性。
- en: 'The cons are as follows:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: The main drawback of this pattern is that it can introduce a single point of
    failure.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式的最大缺点是它可能引入一个单点故障。
- en: Communicating back and forth via a mediator may sometimes result in a performance
    hit.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调解者进行来回沟通有时可能会导致性能下降。
- en: Anyhow, both these patterns—observer and mediator, if you have noticed already,
    are one of the simplest to implement. If used properly, they can become the best
    resources for organizing and maintaining your application. It is not a big deal
    to use them; you can implement these concepts even in small- and medium-level
    applications. Whenever you feel the need for module or component communication,
    a mediator or PubSub pattern can become handy.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这两种模式——观察者和调解者，如果您已经注意到，它们是实施起来最简单的之一。如果使用得当，它们可以成为组织和管理您应用程序的最佳资源。使用它们并不是什么大问题；您甚至可以在小型和中型应用程序中实现这些概念。每当您感到需要模块或组件通信时，调解者或PubSub模式就可以派上用场。
- en: Understanding view management
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解视图管理
- en: 'Backbone views are very lightweight components, and you need to add some custom
    functions to handle event binding, proper layout, data integration, and life cycle
    management in almost every app. So, it is always preferable to have a base view
    that will handle this common functionality; all other views will extend from it.
    For this purpose, we recommend you choose MarionetteJS, which provides three extremely
    useful view classes: `ItemView`, `CollectionView`, and `CompositeView`. These
    classes, along with Marionette''s base `View` class, facilitate the most important
    boilerplate functionality that one may need to use for his/her app views.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone视图是非常轻量级的组件，你几乎需要在每个应用中添加一些自定义函数来处理事件绑定、适当的布局、数据集成和生命周期管理。因此，始终有一个处理这些常见功能的基础视图是更可取的；所有其他视图都将从这个视图扩展出来。为此，我们建议你选择MarionetteJS，它提供了三个极其有用的视图类：`ItemView`、`CollectionView`和`CompositeView`。这些类，连同Marionette的基础`View`类，简化了一个人可能需要为其应用视图使用的最重要的样板功能。
- en: 'There are two more important aspects of view management: the layout manager
    and the template handler. We discussed both these topics in detail in [Chapter
    2](ch02.html "Chapter 2. Working with Views"), *Working with Views*. In a large
    application, a single page consists of multiple views and a major task involves
    creating, switching, and destroying these views. While you can always handle this
    layout management yourself, an existing robust layout manager will help you to
    maintain these views and clean up the memory. You can choose either the `Backbone.LayoutManager`
    plugin or the `Marionette.RegionManager` extension for this job. Both of them
    provide similar functionality and are well-accepted in the developer community.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 视图管理的两个更重要方面是布局管理器和模板处理器。我们在[第2章](ch02.html "第2章。与视图一起工作")*与视图一起工作*中详细讨论了这两个主题。在一个大型应用中，一个页面可能包含多个视图，主要任务涉及创建、切换和销毁这些视图。虽然你可以自己处理这种布局管理，但现有的强大布局管理器将帮助你维护这些视图并清理内存。你可以选择`Backbone.LayoutManager`插件或`Marionette.RegionManager`扩展来完成这项工作。这两个都提供了类似的功能，并且在开发者社区中得到了良好的接受。
- en: 'For templates, we advise you to observe the following important points for
    a large application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模板，我们建议你在开发大型应用时注意以下重要点：
- en: Use Handlebars instead of Underscore's template engine, although there is no
    restriction in choosing other template engines. Just make sure that you do not
    evaluate JavaScript code in your template—this increases the complexity, as we
    discussed in [Chapter 2](ch02.html "Chapter 2. Working with Views"), *Working
    with Views*.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Handlebars而不是Underscore的模板引擎，尽管选择其他模板引擎没有限制。只需确保你不在模板中评估JavaScript代码——正如我们在[第2章](ch02.html
    "第2章。与视图一起工作")*与视图一起工作*中讨论的那样，这会增加复杂性。
- en: Keep your view templates in separate and individual files.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的视图模板保存在单独的文件中。
- en: Always precompile your templates. A number of processes that we discussed in
    [Chapter 2](ch02.html "Chapter 2. Working with Views"), *Working with Views*,
    [Appendix B](apb.html "Appendix B. Precompiling Templates on the Server Side"),
    *Precompiling Templates on the Server Side*, and [Appendix C](apc.html "Appendix C. Organizing
    Templates with AMD and Require.js"), *Organizing Templates with AMD and Require.js*,
    describe how you should precompile your templates and load them.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是预先编译你的模板。我们在[第2章](ch02.html "第2章。与视图一起工作")、[附录B](apb.html "附录B。在服务器端预编译模板")*在服务器端预编译模板*和[附录C](apc.html
    "附录C。使用AMD和Require.js组织模板")*使用AMD和Require.js组织模板*中讨论的许多过程描述了如何预编译你的模板并将它们加载。
- en: Understanding other important features
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解其他重要特性
- en: 'There are few more things that you need to take care of while developing complex
    apps. They are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发复杂应用时，还有一些其他需要注意的事项。具体如下：
- en: '**Multiple routers**: It''s always preferable to have multiple routers compared
    to a gigantic router class. We discussed the concept of subrouters in [Chapter
    5](ch05.html "Chapter 5. Routing Best Practices and Subrouting"), *Routing Best
    Practices and Subrouting*.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个路由器**：与一个巨大的路由器类别相比，拥有多个路由器总是更可取。我们已经在[第5章](ch05.html "第5章。路由最佳实践和子路由")*路由最佳实践和子路由*中讨论了子路由的概念。'
- en: '**Utility methods**: Each application needs a set of utility methods that are
    generic and can be used by any component of the application. You should always
    have one or more than one `Utility` class depending on the requirements, and these
    classes should take care of all the common utility methods.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用方法**：每个应用都需要一套通用的实用方法，这些方法可以被应用的任何组件使用。根据需求，你应该始终有一个或多个“实用”类，并且这些类应该负责所有常见的实用方法。'
- en: '**DOM handling**: The more you interact with the DOM in your views, the more
    difficult will it be to maintain in the later stage. Always try to reduce direct
    DOM manipulation as much as you can.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DOM处理**：你在视图中与DOM交互越多，后期维护就会越困难。始终尽量减少直接DOM操作。'
- en: '**Error handler**: Keep a generic error/exception handler ready; it should
    work as a single point for the errors/warnings and display messages to the users.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理器**：准备一个通用的错误/异常处理器；它应该作为一个错误/警告的单一点，并向用户显示消息。'
- en: '**Memory management**: In single-page large applications, memory leak is a
    real point of concern. So, you must be very much careful about not initiating
    global variables, cleaning up references when they are not in use, and unbinding
    events when the related element or component is removed.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理**：在单页大型应用中，内存泄漏是一个真正需要关注的问题。因此，你必须非常小心，不要初始化全局变量，在它们不再使用时清理引用，以及当相关元素或组件被移除时解绑事件。'
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter dealt with one of the most important topics of Backbone.js-based
    application development. At the framework level, learning Backbone is quite easy
    and developers get a complete grasp over it in a very short period of time. Developing
    simple applications with a few pages never seems to be an issue. But when it comes
    to a large complex application, laying out the architecture becomes quite confusing,
    with what to include and what not to. In this chapter, we tried to discuss every
    point associated with the app's architecture and mentioned when and why you should
    use a particular pattern. Moreover, most of these patterns are applied to a number
    of large applications with success. So, you can adopt these concepts without any
    hesitation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了基于Backbone.js的应用开发中最重要的主题之一。在框架层面，学习Backbone相当容易，开发者可以在非常短的时间内完全掌握它。用几页简单应用开发从未成为问题。但当涉及到大型复杂应用时，布局架构变得相当混乱，包括什么和不包括什么。在本章中，我们试图讨论与应用架构相关的每一个点，并说明了何时以及为什么应该使用特定的模式。此外，这些模式中的大多数都成功应用于多个大型应用。因此，你可以毫不犹豫地采用这些概念。
- en: Until this chapter, we talked about almost everything related to Backbone.js
    application development. However, no project is complete without proper testing,
    and that is what we are going to learn in our next and final chapter, [Chapter
    8](ch08.html "Chapter 8. Unit Test, Stub, Spy, and Mock Your App"), *Unit Test,
    Stub, Spy, and Mock Your App*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了几乎所有与Backbone.js应用开发相关的内容。然而，没有适当的测试，任何项目都是不完整的，这就是我们在下一章和最后一章将要学习的内容，[第8章](ch08.html
    "第8章。单元测试、存根、间谍和模拟你的应用")，*单元测试、存根、间谍和模拟你的应用*。
