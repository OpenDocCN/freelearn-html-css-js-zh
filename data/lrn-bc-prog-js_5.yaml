- en: Synchronizing the Network
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步网络
- en: In the previous chapters, we built a network that was made up of five nodes.
    Every node was aware of all the other nodes in the network, which created a decentralized
    blockchain network. We now need to create a synchronized network, so that the
    blockchain on every node is the same and data is consistent throughout. We can't
    afford to have different versions of the blockchains running on different nodes,
    because this would totally destroy the purpose of having a blockchain. There should
    only be one version of the blockchain that is consistent across every node. Therefore,
    in this chapter, let's synchronize the network that we built in [Chapter 4](c20cb1a2-adc8-41e7-960d-5fd43abf8754.xhtml),
    *Creating a Decentralized Blockchain Network*. We'll do this by broadcasting transactions
    and new blocks that have been mined across all the nodes in the network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们构建了一个由五个节点组成的网络。每个节点都知道网络中的所有其他节点，这创建了一个去中心化的区块链网络。现在我们需要创建一个同步的网络，以便每个节点上的区块链都是相同的，数据在整个网络中是一致的。我们不能容忍在不同节点上运行不同版本的区块链，因为这将完全破坏区块链的目的。应该只有一个版本的区块链在每个节点上是一致的。因此，在本章中，让我们同步在[第4章](c20cb1a2-adc8-41e7-960d-5fd43abf8754.xhtml)中构建的网络，*创建一个去中心化的区块链网络*。我们将通过在网络中的所有节点之间广播已挖掘的交易和新区块来实现这一点。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: Understanding the need to synchronize the network
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解同步网络的需求
- en: Building the `/transaction/broadcast` endpoint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建/transaction/broadcast端点
- en: Refactoring the `createTransaction` method and the `/transaction` endpoint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构`createTransaction`方法和`/transaction`端点
- en: Testing the transaction endpoints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试交易端点
- en: Updating the mining information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新挖矿信息
- en: Building the `/receive-new-block` endpoint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建/receive-new-block端点
- en: Testing the new and updated `/mine` endpoints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试新的和更新的/mine端点
- en: Let's get started with synchronizing the network.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始同步网络。
- en: Understanding the need to synchronize the network
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解同步网络的需求
- en: 'Let''s try to understand why the network needs to be synchronized. We currently
    have a decentralized blockchain network that consists of five nodes. The data
    across these nodes is not consistent; data on each node might vary, which would
    lead to the failure of the purpose of having a blockchain. Let''s try to understand
    this situation with the help of an example. Go to Postman and send a sample transaction,
    as shown in the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解为什么网络需要同步。我们目前有一个由五个节点组成的去中心化区块链网络。这些节点之间的数据不一致；每个节点上的数据可能不同，这将导致区块链的目的失败。让我们通过一个例子来理解这种情况。在Postman中发送一个示例交易，如下截图所示：
- en: '![](img/95e23e83-399c-4276-8668-a3db6e116ee3.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95e23e83-399c-4276-8668-a3db6e116ee3.png)'
- en: 'Send this transaction to the node that''s hosted on `localhost:3001` by clicking
    on the Send button. This transaction will appear in the `pendingTransactions`
    array of `localhost:3001/blockchain`, which you can observe in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单击“发送”按钮将此交易发送到托管在`localhost:3001`上的节点。此交易将出现在`localhost:3001/blockchain`的`pendingTransactions`数组中，您可以在以下截图中观察到：
- en: '![](img/b5479e71-514c-4ebf-b15e-858d0f704ec1.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5479e71-514c-4ebf-b15e-858d0f704ec1.png)'
- en: Now, go to any of the other nodes and check for the transactions that were sent.
    We won't be able to view the transactions in the `pendingTransactions` array on
    those nodes. The sample transaction that is sent will only be present in the node
    on `localhost:3001`. It isn't broadcast to any other nodes in the network.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到任何其他节点并检查发送的交易。我们将无法在这些节点的`pendingTransactions`数组中查看交易。发送的示例交易只会出现在`localhost:3001`节点中。它不会广播到网络中的任何其他节点。
- en: What you are going to do in this chapter is to refactor the `/transaction` endpoint,
    so that whenever a transaction is created, it is broadcast to all nodes. This
    means that all nodes will have the same data. We need to do the same thing in
    order to mine a block. Let's refactor the `/mine` endpoint so that whenever a
    new block is mined, it is also broadcast throughout the entire network. This means
    that the entire network is synchronized and has the exact same number of blocks. Having
    data synchronized through the network is an important feature of blockchain technology.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您要做的是重构/transaction端点，以便每当创建交易时，它都会广播到所有节点。这意味着所有节点将具有相同的数据。我们需要做同样的事情来挖掘一个区块。让我们重构/mine端点，以便每当挖掘出一个新块时，它也会广播到整个网络。这意味着整个网络是同步的，并且具有相同数量的区块。通过网络同步数据是区块链技术的一个重要特性。
- en: Refactoring the createNewTransaction method and the /transaction endpoint
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构createNewTransaction方法和/transaction端点
- en: In this section, let's refactor the `createNewTransaction` method by splitting
    it into two separate parts. One part will simply create a new transaction and
    then return that transaction, and the other part will push the new transaction
    into the `pendingTransactions` array. We'll do the latter part by creating a separate
    method for it. We also create a new transaction endpoint called `/transaction/broadcast`.
    This endpoint will allow us to broadcast transactions throughout the entire blockchain
    network, so that every node has the same data and so that the entire network is synchronized.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们通过将`createNewTransaction`方法拆分为两个独立的部分来重构。一部分将简单地创建一个新交易，然后返回该交易，另一部分将把新交易推送到`pendingTransactions`数组中。我们还将创建一个名为`/transaction/broadcast`的新交易端点。此端点将允许我们在整个区块链网络中广播交易，以便每个节点具有相同的数据，并且整个网络是同步的。
- en: Modifications to the createNewTransaction method
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改createNewTransaction方法
- en: 'Here, let''s split up the `createNewTransaction` method into two separate methods,
    by modifying it as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，让我们将`createNewTransaction`方法拆分为两个独立的方法，修改如下：
- en: 'Go to the `createNewTransaction` method in your `dev/blockchain.js` file. We
    built this method in [Chapter 2](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml),
    *Building a Blockchain* in the *Creating createNewTransaction method* section. For
    reference, take a look at the following `createNewTransaction` method:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`dev/blockchain.js`文件中的`createNewTransaction`方法。我们在[第2章](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml)中构建了这个方法，*构建区块链*中的*创建createNewTransaction方法*部分。参考以下`createNewTransaction`方法：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s make the following highlighted modifications to the method:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对该方法进行以下突出显示的修改：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, an ID is added to every transaction. To create this ID, a unique string
    is used, which is very similar to what we had used for creating the node addresses
    in [Chapter 3](fc6f37c3-df49-46cc-8618-704953dea6a9.xhtml), *Accessing the Blockchain
    through an API.*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为每个交易添加了一个ID。为了创建这个ID，使用了一个唯一的字符串，这与我们在[第3章](fc6f37c3-df49-46cc-8618-704953dea6a9.xhtml)中用于创建节点地址的方法非常相似，*通过API访问区块链*。
- en: 'Unique strings for the IDs are created with the use of the `uuid` library.
    Therefore, at the start of the `dev/blockchain.js `file, where all the constants
    are defined, you need to add the following line of code in order to use the `uuid`
    library in our project:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`uuid`库创建ID的唯一字符串。因此，在`dev/blockchain.js`文件的开头，定义所有常量的地方，您需要添加以下代码行，以便在我们的项目中使用`uuid`库：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the modified method, you can observe that the following line of code was
    added to create unique strings for the `transactionId` values. This is where the
    use of the `uuid` library was implemented:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改后的方法中，您可以观察到添加了以下代码行，以为`transactionId`值创建唯一的字符串。这是实现`uuid`库的地方：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the `.split()` function will take out the dashes that are added to the
    unique string, and then, the `.join()` function will rejoin the string to give
    an output of a unique `Id` for each transaction.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`.split()`函数将去除添加到唯一字符串的破折号，然后`.join()`函数将重新连接字符串，以输出每个交易的唯一`Id`。
- en: Building the addTransactionToPendingTransactions method
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建addTransactionToPendingTransactions方法
- en: 'Next, we need to push the `newTransaction` that was returned to the `pendingTransactions`
    array of the blockchain. Therefore, let''s create another method, called `addTransactionToPendingTransactions`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将返回的`newTransaction`推送到区块链的`pendingTransactions`数组中。因此，让我们创建另一个名为`addTransactionToPendingTransactions`的方法：
- en: 'In the `dev/blockchain.js` file, the `addTransactionToPendingTransactions` method
    will be defined as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dev/blockchain.js`文件中，`addTransactionToPendingTransactions`方法将定义如下：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, take the `transactionObj` and push it to the `pendingTransactions` array
    of the blockchain:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，获取`transactionObj`并将其推送到区块链的`pendingTransactions`数组中：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we simply want to return the index of the block to which the transaction
    is added:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需返回添加了交易的区块的索引：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To recap quickly, we modified the `createNewTransaction` method which creates
    a new transaction, and returns that new transaction. We then created a new method,
    called `addTransactionToPendingTransactions`. This method takes in a `transactionObj` and
    adds it to the `pendingTransactions` array on the blockchain. After that, we simply
    returned the index of the block to which the new transaction was added.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们修改了`createNewTransaction`方法，该方法创建一个新的交易，并返回该新交易。然后，我们创建了一个名为`addTransactionToPendingTransactions`的新方法。该方法接受一个`transactionObj`并将其添加到区块链上的`pendingTransactions`数组中。之后，我们只需返回添加了新交易的区块的索引。
- en: Building the /transaction/broadcast endpoint
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建/transaction/broadcast端点
- en: 'In this section, let''s build a new endpoint called `/transaction/broadcast`. Anytime
    we want to create a new transaction from now on, we''re going to hit this `/transaction/broadcast`
    endpoint. This endpoint will do two things:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们构建一个名为`/transaction/broadcast`的新端点。从现在开始，每当我们想要创建一个新的交易时，我们将访问此`/transaction/broadcast`端点。此端点将执行两项操作：
- en: It will create a new transaction.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将创建一个新的交易。
- en: It will then broadcast that new transaction to all the other nodes in the network.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它将向网络中的所有其他节点广播该新交易。
- en: 'Let''s go through the following steps to create the endpoint:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下步骤创建端点：
- en: 'To add this endpoint, go to the `dev/networkNode.js` file where we have defined
    all the endpoints, and add this new endpoint as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加此端点，请转到`dev/networkNode.js`文件，我们在其中定义了所有端点，并按以下方式添加新端点：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, in order for the endpoint to carry out the aforementioned functionalities,
    add the following highlighted code to the endpoint:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了使端点执行上述功能，将以下突出显示的代码添加到端点：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `createNewTransaction()` method here is the modified method from the previous
    section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`createNewTransaction()`方法是上一节中修改过的方法。
- en: 'The `createNewTransaction()` method takes in the `amount`, `sender`, and `recipient` parameters.
    For our endpoint, let''s assume that all of that data is being sent on the `req.body`.
    Therefore, those parameters will be defined as shown highlighted in the following
    code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createNewTransaction()`方法接受`amount`、`sender`和`recipient`参数。对于我们的端点，让我们假设所有这些数据都被发送到`req.body`上。因此，这些参数将如下所示在以下代码中进行定义：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, let''s add the `newTransaction` variable to the `pendingTransactions`
    array on the node with the help of the `addTransactionToPendingTransactions` method.
    Therefore, after the preceding line of code, add the following line:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们借助`addTransactionToPendingTransactions`方法将`newTransaction`变量添加到节点的`pendingTransactions`数组中。因此，在前面的代码行之后，添加以下行：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, broadcast the new transactions to all the other nodes inside the network.
    This can be done as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将新交易广播到网络中的所有其他节点。可以按以下方式完成：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside this `forEach` loop, let''s define the code to broadcast the transactions.
    To do this, make requests to the `/transaction` endpoints on all the other nodes
    inside the network. Therefore, define some options for these requests. Inside
    of the loop, let''s add the following line:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`forEach`循环中，让我们定义广播交易的代码。为此，向网络中的所有其他节点的`/transaction`端点发出请求。因此，在循环内，添加以下行：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, define all our options, as shown here:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义我们所有的选项，如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, let''s create an array of promises to push all the requests into that
    array, so that we can run all the requests at the same time. Let''s define the
    array before the `forEach` loop as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个承诺数组，将所有请求推送到该数组中，以便我们可以同时运行所有请求。让我们在`forEach`循环之前定义数组如下：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, after defining all of the options, make the request as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在定义所有选项之后，进行请求如下：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this preceding line of code, we're going to push all the requests into
    the `requestPromises` array. After the `forEach` loop has run, we should have
    all of the requests that we have defined inside the `requestPromises` array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这行代码之前，我们将把所有请求推送到`requestPromises`数组中。`forEach`循环运行后，我们应该在`requestPromises`数组中有所有我们定义的请求。
- en: 'Next, let''s run all of the requests. After the `forEach` loop, add the following
    line:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行所有请求。在`forEach`循环之后，添加以下行：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, after all the requests have run, we''ll add the following line:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在所有请求运行后，我们将添加以下行：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''re not actually going to use the data that comes back from all of these requests,
    but we are going to send a response, because, at this point, the entire broadcast
    is complete. Therefore, inside the preceding block of code, add the following
    highlighted code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实际上不会使用所有这些请求返回的数据，但我们会发送一个响应，因为在这一点上，整个广播已经完成。因此，在上述代码块中，添加以下突出显示的代码：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By adding this preceding line of code, we have successfully completed building
    the `/transaction/broadcast` endpoint.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加上述代码行，我们已成功完成了构建`/transaction/broadcast`端点。
- en: Refactoring the /transaction endpoint
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构/transaction端点
- en: 'We''re going to refactor the `/transaction` endpoint in this section, so that
    it works perfectly with the new `/transaction/broadcast` endpoint. Let''s apply
    the following steps to modify the endpoint:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重构`/transaction`端点，以便它可以与新的`/transaction/broadcast`端点完美配合。让我们应用以下步骤修改端点：
- en: 'To get started, go to the `dev/networkNode.js` file and delete everything that
    is in the `/transaction` endpoint. The only time the `/transaction` endpoint will
    be hit is when the broadcast takes place. When the `/transaction` endpoint is
    being hit, the `newTransaction` variable will be sent as data. This condition
    can be defined as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到`dev/networkNode.js`文件，并删除`/transaction`端点中的所有内容。只有在进行广播时，才会访问`/transaction`端点。当访问`/transaction`端点时，`newTransaction`变量将作为数据发送。可以定义如下条件：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding highlighted line, the `newTransaction` variable is sent to
    the `/transaction` endpoint with the help of `req.body`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面突出显示的行中，`newTransaction`变量通过`req.body`发送到`/transaction`端点。
- en: 'Next, add the new transaction to the `pendingTransactions` array of whichever
    node receives the call. To do this, the new `addTransactionToPendingTransactions` method
    will be used. Therefore, after the preceding line of code, add the following line:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将新交易添加到接收调用的任何节点的`pendingTransactions`数组中。为此，将使用新的`addTransactionToPendingTransactions`方法。因此，在上述代码的后面，添加以下行：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This method simply takes in the `newTransaction` variable that is received:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法简单地接收`newTransaction`变量：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, from the `addTransactionToPendingTransactions` method, we get the index
    of the block in which the transaction will be added. Let''s save this block index
    in the new `/transaction` endpoint. At the start of the preceding line of code,
    add the variable as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`addTransactionToPendingTransactions`方法中，我们得到交易将被添加到的块的索引。让我们在新的`/transaction`端点中保存这个块索引。在上述代码的开始处，添加变量如下：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The final thing to do is to send back a response. After the preceding line,
    add the following:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要做的是发送一个响应。在上述行之后，添加以下内容：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've now finished refactoring the `/transaction` endpoint.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了对`/transaction`端点的重构。
- en: Testing the transaction endpoints
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试交易端点
- en: Let's test the `/transaction/broadcast` and `/transaction` endpoints to make
    sure that they are both working together correctly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试`/transaction/broadcast`和`/transaction`端点，确保它们能够正确配合工作。
- en: For this test, the first thing that we need to do is connect all the nodes together
    to make a network. You might remember how to do this, as we learned about it in
    [Chapter 4](c20cb1a2-adc8-41e7-960d-5fd43abf8754.xhtml), *Creating a Decentralized
    Blockchain Network*. We'll run through the steps quickly anyway, to refresh your
    memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我们需要做的第一件事是将所有节点连接在一起，以构建一个网络。您可能还记得如何做到这一点，因为我们在[第4章](c20cb1a2-adc8-41e7-960d-5fd43abf8754.xhtml)中学习过，*创建分散的区块链网络*。无论如何，我们将快速浏览一遍这些步骤，以便您记起来。
- en: Recapping how to create the network
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾如何创建网络
- en: 'Take a look at the following steps to understand how to connect all the nodes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下步骤，了解如何连接所有节点：
- en: Go to Postman and hit the `/register-and-broadcast-node` route. This can be
    done on any of your nodes. In our example, let's use `localhost:3001`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Postman并访问`/register-and-broadcast-node`路由。这可以在任何一个节点上完成。在我们的示例中，让我们使用`localhost:3001`。
- en: 'Now, inside the body, we want to add a new node to our network by passing its
    URL. Let''s start with our second node. Take a look at the following screenshot:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在正文中，我们要通过传递其URL来向我们的网络添加一个新节点。让我们从第二个节点开始。看一下以下的截图：
- en: '![](img/87b035cc-5c80-4530-bb18-f0aea1856317.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87b035cc-5c80-4530-bb18-f0aea1856317.png)'
- en: Then, click on the Send button to send the request. After sending the request,
    you'll receive a response that says New node registered with the network successfully.
    You can send all the remaining nodes in the same way.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击发送按钮发送请求。发送请求后，您将收到一个响应，上面写着“新节点已成功注册到网络”。您可以以相同的方式发送所有剩余的节点。
- en: To verify if all the nodes are connected properly to form a network, head over
    to the browser, type `localhost:3001/blockchain` in the address bar, and press
    *Enter*. You will see all the nodes in the `networkNodes` array.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证所有节点是否正确连接以形成网络，请转到浏览器，输入`localhost:3001/blockchain`在地址栏中，然后按*Enter*。您将在`networkNodes`数组中看到所有节点。
- en: Testing the transaction endpoints
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试交易端点
- en: Now that the blockchain network is set up, let's the test the endpoints that
    we created in the previous sections.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在区块链网络已经建立，让我们测试一下我们在之前部分创建的端点。
- en: 'Let''s create a transaction and send it to the `/transaction/broadcast` endpoint.
    Go back to Postman and hit the `/transaction/broadcast` endpoint at the node,
    which is hosted on port `3001`. Here, send some data as a transaction, as shown
    in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个交易并将其发送到`/transaction/broadcast`端点。返回到Postman，命中端口为`3001`的节点的`/transaction/broadcast`端点。在这里，发送一些数据作为交易，如下面的屏幕截图所示：
- en: '![](img/a2f60fb5-2915-4f33-8eed-905d7fcc8109.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2f60fb5-2915-4f33-8eed-905d7fcc8109.png)'
- en: The transaction data that you're sending can be any random data. All we need
    is the amount, the sender, and the recipient. Once the transaction data is added,
    let's send this request by clicking on the Send button. If the transaction is
    sent successfully, a response will be received that says, Transaction created
    and broadcast successfully.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您发送的交易数据可以是任意随机数据。我们只需要金额、发送方和接收方。一旦添加了交易数据，让我们点击发送按钮发送此请求。如果交易成功发送，将收到一个响应，上面写着“交易已成功创建和广播”。
- en: 'Now, go to the browser, and you should be able to see the transaction that
    we created on every single node of the network. Let''s check whether this worked.
    In the address bar of the browser, type `localhost:3001/blockchain` and then press
    *Enter*. You should see the transaction data inside the `pendingTransactions`
    array, as shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到浏览器，您应该能够在网络的每个节点上看到我们创建的交易。让我们检查一下这是否有效。在浏览器的地址栏中，输入`localhost:3001/blockchain`，然后按*Enter*。您应该看到`pendingTransactions`数组中的交易数据，如下面的屏幕截图所示：
- en: '![](img/3b969bc3-62c2-44e6-bedd-56cdbb94b9ad.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b969bc3-62c2-44e6-bedd-56cdbb94b9ad.png)'
- en: Here, the transaction that is inside the `pendingTransactions` array now also
    has a `transactionId` value, which starts with a random hash.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`pendingTransactions`数组中的交易现在也有一个以随机哈希开头的`transactionId`值。
- en: 'Next, open another tab and type `localhost:3002/blockchain` in the address
    bar, then press *Enter*. You can see that the same transaction data can be seen
    in the array:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开另一个标签页，输入`localhost:3002/blockchain`在地址栏中，然后按*Enter*。您可以看到相同的交易数据可以在数组中看到：
- en: '![](img/2ba59d42-0dbb-4812-ba14-19c3db20d31e.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ba59d42-0dbb-4812-ba14-19c3db20d31e.png)'
- en: If you go over to the other nodes in the network, you can carry out a similar
    check for all the remaining nodes. You can observe the same transaction data in
    the `pendingTransactions` array of each node. Every node inside the blockchain
    network is now aware that a new transaction was created.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您转到网络中的其他节点，您可以对所有剩余节点进行类似的检查。您可以观察到每个节点的`pendingTransactions`数组中的相同交易数据。区块链网络中的每个节点现在都知道已创建新交易。
- en: You can try testing the endpoints with other transaction data as well. Try to
    change the amount to `500`, and the address of the sender and the recipient to
    a random hash string, and try sending this request to the node that's hosted on
    `localhost:3004`. This shouldn't make a difference, because the broadcast endpoint
    sends the transaction data to all the nodes inside of the network. Therefore, this
    request should work just like the last one. Checking the response on the browser,
    you should be able to see two transactions with different transaction IDs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以尝试使用其他交易数据测试端点。尝试将金额更改为`500`，将发送方和接收方的地址更改为随机哈希字符串，并尝试将此请求发送到托管在`localhost:3004`上的节点。这不会有任何影响，因为广播端点将交易数据发送到网络中的所有节点。因此，这个请求应该像上一个一样工作。在浏览器上检查响应，您应该能够看到两个具有不同交易ID的交易。
- en: Try experimenting with different transaction data to gain a clear understanding
    of how the `/transaction` and `/transaction/broadcast` endpoints work.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的交易数据进行实验，以清楚了解`/transaction`和`/transaction/broadcast`端点的工作原理。
- en: From the test, we can conclude that the `/transaction/broadcast` endpoint and
    the `/transaction` endpoint are both working properly as we expected them to.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试中，我们可以得出结论，`/transaction/broadcast`端点和`/transaction`端点都按我们预期的那样正常工作。
- en: In the next section, we'll continue synchronizing the network by refactoring
    the `/mine` endpoint, so that it will broadcast the new blocks that are created
    to the entire network.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过重构`/mine`端点来继续同步网络，以便它将新创建的新块广播到整个网络。
- en: Updating the mining information
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新挖矿信息
- en: The next thing that is required to synchronize the network is to update the
    `/mine` endpoint. We are also going to add a new endpoint, called `/receive-new-block`.
    There's a need to update the `/mine` endpoint so that whenever a new block is
    created by a node, that new block is broadcast to all the other nodes in the network.
    This means that every node on the network is aware that a new block has been created
    and all the nodes hosting the blockchain stay synchronized.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同步网络所需的下一步是更新`/mine`端点。我们还将添加一个新的端点，称为`/receive-new-block`。有必要更新`/mine`端点，以便每当一个节点创建一个新块时，该新块被广播到网络中的所有其他节点。这意味着网络中的每个节点都知道已创建新块，并且托管区块链的所有节点保持同步。
- en: The updated mining process
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新后的挖矿流程
- en: 'Whenever a new block is mined, it will be mined on a particular node. To understand
    the updated mining process, let''s assume that we want a node, hosted on port `3001`,
    to mine a new block for the blockchain:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每当挖掘出一个新块时，它将在特定节点上被挖掘。为了理解更新后的挖矿流程，让我们假设我们希望一个托管在端口`3001`上的节点为区块链挖掘一个新块：
- en: Firstly, the `/mine` endpoint will be hit on the selected node. When the `/mine`
    endpoint is hit, a new block is created by doing a proof of work.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将在所选节点上命中`/mine`端点。当命中`/mine`端点时，通过工作证明创建一个新块。
- en: 'Once the new block is created, it is broadcast to all the other nodes in the
    network. All the other nodes will receive that new block at their `/receive-new-block` endpoint. This
    is shown in the following diagram:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新块创建后，它将被广播到网络中的所有其他节点。所有其他节点将在其`/receive-new-block`端点接收到该新块。如下图所示：
- en: '![](img/47f680ef-e0fc-49c0-ba54-d009efa5bd36.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47f680ef-e0fc-49c0-ba54-d009efa5bd36.png)'
- en: After the broadcast is complete, the entire network will be synchronized and
    all the nodes will host the same blockchain.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 广播完成后，整个网络将同步，并且所有节点将托管相同的区块链。
- en: Another thing to note is that when a new block is broadcast and a node receives
    it, that new block will be added to the chain after the chain has validated that
    the block is legitimate. Then, the node clears out its `pendingTransactions` array,
    because all the pending transactions are now within the new block they just received.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事需要注意的是，当新区块被广播并且节点接收到它时，该新区块将在链验证该区块合法后被添加到链中。然后，节点清除其`pendingTransactions`数组，因为所有待处理交易现在都在它们刚刚收到的新区块中。
- en: In the next couple of sections, we're going to build this whole process step
    by step. As we build each of these steps, it should be easier to see how everything
    works together.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将逐步构建整个过程。随着我们构建每个步骤，应该更容易看到所有内容是如何协同工作的。
- en: Refactoring the /mine endpoint
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构`/mine`端点
- en: 'Let''s refactor the `/mine` endpoint by implementing the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施以下步骤来重构`/mine`端点：
- en: 'Head over to the `dev/networkNode.js` file. In the `/mine` endpoint, beneath
    the part where we had defined the `newBlock` variable, let''s add the functionality
    to broadcast the new block to all the other nodes in the network. To do this,
    follow the same process that we introduced in the previous sections—that is, to
    loop through all the other nodes inside the network, make a request to the nodes,
    and send the `newBlock` variable as data:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`dev/networkNode.js`文件。在`/mine`端点中，在我们定义了`newBlock`变量的部分下面，让我们添加将新区块广播到网络中所有其他节点的功能。为此，请按照我们在前几节中介绍的相同过程进行，即循环遍历网络中的所有其他节点，向节点发出请求，并将`newBlock`变量作为数据发送：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding line mentions that for each of the `networkNodes`, we're going
    to make a request and send along the `newBlock`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的一行提到，对于每个`networkNodes`，我们将发出请求并发送`newBlock`。
- en: 'We then need some request options to send. These options will be defined as
    follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要发送一些请求选项。这些选项将定义如下：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first option in this object is the `uri`. The `uri` to which we want to
    send the request will be the `networkNodeUrl` and the new endpoint that we are
    going to create, which will be `/receive-new-block`. We''ll work on this endpoint
    in the next section:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该对象中的第一个选项是`uri`。我们要发送请求的`uri`将是`networkNodeUrl`和我们将要创建的新端点，即`/receive-new-block`。我们将在下一节中处理此端点：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next option to be added is the method that will be used, which is the `POST`
    method:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加的下一个选项是将使用的方法，即`POST`方法：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, let''s send along the data that will be inside the body. We also want
    to send along a `newBlock` instance:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们发送将在`body`中的数据。我们还想发送一个`newBlock`实例：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, after the `body`, set `json` to `true`, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`body`之后，将`json`设置为`true`，如下所示：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After that, make the request by adding the following highlighted line of code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，通过添加以下突出显示的代码，进行请求：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Every time one of these requests is made, it''s going to return a promise.
    Let''s make an array of all of these promises by adding the following highlighted
    code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次进行这些请求时，它都会返回一个promise。通过添加以下突出显示的代码，让我们创建所有这些promises的数组：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After our `forEach` loop has run, we should have an array that is filled with
    promises.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`forEach`循环运行后，我们应该有一个充满了promises的数组。
- en: 'Next, let''s run all of those promises. Therefore, after the `forEach` block,
    add the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行所有这些promises。因此，在`forEach`块之后，添加以下代码：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After all of the requests have run, we want to carry out another calculation
    inside `.then(data => {    })`. If you remember, when a new transaction is created,
    the mining rewards transaction code, `bitcoin.createNewTransaction(12.5, "00"
    , nodeAddress);`, needs to be broadcast throughout the entire blockchain network.
    At the moment, when a new block is mined, we create a mining reward transaction,
    but it is not broadcast to the whole network. To broadcast it, the request will
    be sent to the `/transaction/broadcast` endpoint, because it already has the functionality
    to broadcast transactions. We're just going to make a call to this endpoint with
    the mining reward transaction data passed in.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有请求运行后，我们希望在`.then(data => { })`内执行另一个计算。如果记得，当创建新交易时，挖矿奖励交易代码`bitcoin.createNewTransaction(12.5,
    "00", nodeAddress);`需要在整个区块链网络中广播。目前，当挖掘出新区块时，我们创建了一个挖矿奖励交易，但它没有广播到整个网络。为了广播它，请求将被发送到`/transaction/broadcast`端点，因为它已经具有广播交易的功能。我们只需使用传递的挖矿奖励交易数据调用此端点。
- en: 'Before passing the mining reward transaction data, however, we need some request
    options:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在传递挖矿奖励交易数据之前，我们需要一些请求选项：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `body` data will be sent as an object. In the `body`, let''s add the mining
    reward transaction data:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`body`数据将作为对象发送。在`body`中，让我们添加挖矿奖励交易数据：'
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, after the `body`, set `json` to `true` by adding the following line:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`body`之后，通过添加以下行将`json`设置为`true`：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, after the `requestOptions`, let''s send the following request:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`requestOptions`之后，让我们发送以下请求：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At this point, inside the `/mine` endpoint, a bunch of calculations are being
    carried out to create a new block. Then, once the new block is created, it is
    broadcast to all the other nodes inside the network. After the broadcast is complete
    inside the `.then` block, a new request to the `/transaction/broadcast` endpoint
    is made. This request will create a mining reward transaction and the nodes will
    then broadcast it to the entire blockchain network. Then, after the request runs
    and all of the calculations are complete, a response is sent: New block mined
    successfully.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/mine`端点内部，正在进行一系列计算以创建新的区块。然后，一旦创建了新的区块，它将被广播到网络中的所有其他节点。广播完成后，在`.then`块内，将发出对`/transaction/broadcast`端点的新请求。此请求将创建一个挖矿奖励交易，然后节点将其广播到整个区块链网络。然后，在请求运行并完成所有计算后，将发送响应：成功挖掘新区块。
- en: You can view the complete updated mine endpoint code at [https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js](https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js](https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js)上查看完整更新的mine端点代码。
- en: Building the /receive-new-block endpoint
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建/receive-new-block端点
- en: 'The next thing that we''re going to do is build the `/receive-new-block` endpoint
    that we use in the updated `/mine` endpoint. Let''s get started on building the
    endpoint:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是构建我们在更新的/mine端点中使用的/receive-new-block端点。让我们开始构建这个端点：
- en: 'In the `dev/networkNode.js` file, before the `/register-and-broadcast-node`
    endpoint, define the `/receive-new-block` endpoint as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dev/networkNode.js`文件中，在`/register-and-broadcast-node`端点之前，定义`/receive-new-block`端点如下：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inside this endpoint, the code expects to receive a new block that is being
    broadcast. Let''s save that new block in a variable, as highlighted in the following
    code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此端点内，代码期望接收正在广播的新区块。让我们将新区块保存在一个变量中，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When all of the other nodes receive this new block, they need to check whether
    it''s actually a real block and whether it fits into the chain properly. To verify
    this, the `previousBlockHash` on the `newBlock` is checked to make sure that it''s
    equal to the hash on the last block in the chain. For this, access to the last
    block in the chain is required:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有其他节点接收到这个新区块时，它们需要检查它是否真的是一个真实的区块，并且是否正确地适应了链。为了验证这一点，检查`newBlock`上的`previousBlockHash`，以确保它等于链中最后一个区块上的哈希。为此，需要访问链中的最后一个区块：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, let''s test if the hash of the last block in the chain is equal to the `previousBlockHash` in
    the `newBlock` instance:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们测试链中最后一个区块的哈希是否等于`newBlock`实例中的`previousBlockHash`：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This way, we know that this `newBlock` does indeed come right after the `lastBlock`
    in the chain. The preceding statement that is defined will return either `true`
    or `false`. The `true` or `false` value will be saved in a `correctHash` variable:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，我们知道这个`newBlock`确实紧跟在链中的`lastBlock`之后。定义的前面语句将返回`true`或`false`。`true`或`false`值将保存在`correctHash`变量中：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After the preceding check, we also want to make sure that the `newBlock` has
    the correct index. This means that the `newBlock` should be one index above the
    `lastBlock` in the chain. Add the following check:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行上述检查之后，我们还希望确保`newBlock`具有正确的索引。这意味着`newBlock`的索引应该比链中的`lastBlock`高一个。添加以下检查：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, two different actions need to be taken depending on whether or not the `newBlock`
    is legitimate. If the `newBlock` is legitimate, it should be accepted and added
    to the chain. If not, it should simply be rejected. In order to define this condition,
    let''s use an `if`-`else` statement:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据`newBlock`是否合法需要采取两种不同的行动。如果`newBlock`是合法的，应该被接受并添加到链中。如果不合法，应该被拒绝。为了定义这个条件，让我们使用一个`if`-`else`语句：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, since the `newBlock` has been added to the chain, the `pendingTransactions` array
    needs to be cleared out, because the pending transactions are now inside the new
    block. Therefore, inside the `if` statement, the next condition to be added is
    as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于`newBlock`已经被添加到链中，`pendingTransactions`数组需要被清空，因为待处理的交易现在已经在新区块中。因此，在`if`语句中，需要添加下一个条件如下：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, the final thing that needs to be done is to send a response back, saying
    that the block has been accepted and added to the chain. Inside the `if` statement,
    below the preceding line, add the response as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要做的最后一件事是发送一个响应，表示该区块已被接受并添加到链中。在`if`语句中，在前面的行下面，添加以下响应：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If the `newBlock` is not legitimate and does not pass either of the tests defined
    previously, then a response is sent inside of the `else` statement to indicate
    that the block was rejected:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`newBlock`不合法并且未通过先前定义的任何测试，则在`else`语句中发送响应以指示该区块已被拒绝：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With the addition of this previous condition, we've finished building the `/receive-new-block`
    endpoint.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加上述条件，我们已经完成了/receive-new-block端点的构建。
- en: Testing the new and updated /mine endpoints
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试新的和更新的/mine端点
- en: 'Let''s test the updated `/mine` endpoint and the `/receive-new-block` endpoint
    that we just created. Basically, the `/mine` endpoint will mine the new block
    for us. It will also take that block and broadcast it across the entire blockchain
    network so that every node is synchronized and all the nodes have the same blocks
    and the same data. This is the result we expect to observe when we test the `/mine`
    endpoint:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试更新的/mine端点和我们刚刚创建的/receive-new-block端点。基本上，/mine端点将为我们挖掘新的区块。它还将获取该区块并将其广播到整个区块链网络，以便每个节点都同步，并且所有节点都具有相同的区块和相同的数据。这是我们在测试/mine端点时期望观察到的结果：
- en: To get started, you should have all five of the nodes running. You should also
    have connected them together to create a blockchain network.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，您应该让所有五个节点都在运行。您还应该将它们连接在一起，以创建一个区块链网络。
- en: 'Next, go to the browser. The first thing to do here is to choose a node to
    mine the new block. We have got five nodes to choose from but in our case, we
    will just stick with the first node. Therefore, type `localhost:3001/mine` in
    the address bar and then hit *Enter*. You will get an output like the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到浏览器。这里要做的第一件事是选择一个节点来挖掘新的区块。我们有五个节点可供选择，但在我们的情况下，我们将坚持使用第一个节点。因此，在地址栏中键入`localhost:3001/mine`，然后按*Enter*。您将得到以下输出：
- en: '![](img/23699e8a-d66a-44cb-9621-c9eb26d4a4a5.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23699e8a-d66a-44cb-9621-c9eb26d4a4a5.png)'
- en: It looks like the mine endpoint has worked perfectly. The response indicates
    that the new block has been mined and broadcast successfully. You can also see
    the new block in the preceding screenshot with its index.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 矿端点似乎已经完美地工作了。响应表明新区块已经被成功挖掘和广播。您还可以在前面的屏幕截图中看到新的区块及其索引。
- en: 'Let''s verify if the new block has been added to the network. First, verify
    it on the first node. In the browser, open another tab, type `localhost:3001/blockchain` in
    the address bar, and then press *Enter*. You can see that the new block has been
    added to the network as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证新区块是否已添加到网络中。首先，在第一个节点上进行验证。在浏览器中打开另一个标签页，输入`localhost:3001/blockchain`，然后按*Enter*。您可以看到新区块已添加到网络中，如下所示：
- en: '![](img/070cd0e5-35f0-4ba8-9d7b-eafda9c28a20.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/070cd0e5-35f0-4ba8-9d7b-eafda9c28a20.png)'
- en: In the preceding screenshot, you might also notice that there are some transactions
    present in the `pendingTransactions` array.  This pending transaction is actually
    the mining reward for the block that we just mined. The updated `/mine` endpoint
    defines that the mining reward transaction should be broadcast after a new block
    is created.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，您可能还注意到`pendingTransactions`数组中存在一些交易。这些待处理交易实际上是我们刚刚挖掘的区块的挖矿奖励。更新的`/mine`端点定义了在创建新区块后应广播挖矿奖励交易。
- en: From now on, whenever a new block is created, the mining reward for that block
    will go into the `pendingTransactions` array and will be added to the next block.
    This is how mining rewards work in the Bitcoin blockchain. When we first created
    our blockchain in the first two chapters, we put the mining reward right into
    the block that we mined. Now that the blockchain is more advanced and we've got
    a decentralized network, it's important for us to follow best practices and put
    the mining reward into the next block.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每当创建新区块时，该区块的挖矿奖励将进入`pendingTransactions`数组，并将添加到下一个区块中。这就是比特币区块链中挖矿奖励的工作原理。在前两章中创建区块链时，我们将挖矿奖励直接放入了我们挖掘的区块中。现在区块链更加先进，我们拥有了一个去中心化的网络，遵循最佳实践并将挖矿奖励放入下一个区块对我们来说非常重要。
- en: Let's get back to the `/mine` endpoint and continue with the testing. Let's
    check the other nodes inside the network and verify whether the new block that
    was mined is added to those nodes or not. Also, let's check that the mining reward
    that was generated is also broadcast to the other nodes in the network.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`/mine`端点并继续测试。让我们检查网络内的其他节点，并验证挖掘的新区块是否已添加到这些节点中。此外，让我们检查生成的挖矿奖励是否也已广播到网络中的其他节点。
- en: 'Open another tab, type `localhost:3002/blockchain` in the address bar, and
    then press *Enter*. You will see the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开另一个标签页，输入`localhost:3002/blockchain`，然后按*Enter*。您将看到以下输出：
- en: '![](img/f734e62b-ecbf-42b6-92b6-4399269bacce.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f734e62b-ecbf-42b6-92b6-4399269bacce.png)'
- en: In the preceding screenshot, you can see that the node on port `3002` received
    the newly mined block, along with the mining reward transaction. You can verify
    this for the remaining nodes in the network.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，您可以看到端口为`3002`的节点接收到了新挖掘的区块，以及挖矿奖励交易。您可以验证网络中其余节点的情况。
- en: 'Let''s now mine another block from a different node. Instead of going to `localhost:3001`,
    type `localhost:3004/mine` in the browser''s address bar, and then press *Enter*.
    The new block will be mined; the output will look as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从另一个节点挖掘另一个区块。不要转到`localhost:3001`，而是在浏览器的地址栏中输入`localhost:3004/mine`，然后按*Enter*。将挖掘新的区块；输出将如下所示：
- en: '![](img/94a59daa-dcdc-4080-96ac-ada1e5e99ea6.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94a59daa-dcdc-4080-96ac-ada1e5e99ea6.png)'
- en: From the preceding screenshot, you can observe that this is the third block.
    This is correct because we have mined two blocks already. Inside the block's `transactions`
    array, you can see that we've got the mining reward from the previous block. This
    transaction was the mining reward that was generated when the node on port `3001`
    mined the previous block.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述截图中，您可以观察到这是第三个区块。这是正确的，因为我们已经挖掘了两个区块。在区块的`transactions`数组中，您可以看到我们从上一个区块获得的挖矿奖励。这笔交易是端口为`3001`的节点在挖掘上一个区块时生成的挖矿奖励。
- en: 'Let''s go to `localhost:3001/blockchain` and verify if this new block that
    we just mined has been added to the network. You will see the following response:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到`localhost:3001/blockchain`，验证我们刚刚挖掘的新区块是否已添加到网络中。您将看到以下响应：
- en: '![](img/f4040f16-0989-4758-aff8-66b3416b0bca.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4040f16-0989-4758-aff8-66b3416b0bca.png)'
- en: In this screenshot, you can observe that the new block that was mined has been
    added to the node hosted on `3001`. The transaction array of this block consists
    of the mining reward from the previous block. We now also have a new mining reward
    in the `pendingTransactions` array, which was generated when the third block was
    mined. Following a similar process of verification, as we used before, you can
    check if the third block that we mined has been added to all the remaining nodes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在此截图中，您可以观察到刚刚挖掘的新区块已添加到端口为`3001`的节点中。该区块的交易数组包括来自上一个区块的挖矿奖励。我们现在在`pendingTransactions`数组中也有一个新的挖矿奖励，这是在挖掘第三个区块时生成的。通过之前使用的类似验证过程，您可以检查我们挖掘的第三个区块是否已添加到所有剩余节点中。
- en: From these tests, it looks like the `/mine` endpoint is working just as it should.
    It's creating new blocks and broadcasting them to the entire network. This means
    the entire network is synchronized and has the exact same blockchain data, which
    is really important for a blockchain to work properly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些测试中，看起来`/mine`端点正在按照预期工作。它正在创建新区块并将其广播到整个网络。这意味着整个网络是同步的，并且具有完全相同的区块链数据，这对于区块链正常工作非常重要。
- en: 'Let''s test the endpoint a little further. Head over to Postman, create a couple
    of transactions, and then broadcast them. After that, let''s mine a new block
    to see if the new transactions have been added to the blockchain correctly:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步测试端点。转到Postman，创建一些交易，然后广播它们。之后，让我们挖掘一个新的区块，以查看新交易是否已正确添加到区块链中：
- en: 'Go to your Postman now and create the following transaction:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到您的Postman并创建以下交易：
- en: '![](img/b1d4bf96-cfd8-465a-a696-bd85c8ebe6b6.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1d4bf96-cfd8-465a-a696-bd85c8ebe6b6.png)'
- en: 'Next, in order to broadcast the transaction, hit the `/transaction/broadcast`
    endpoint. You can send this transaction data to any node and it should be broadcast
    to the entire network. In our example, let''s send this transaction to the node
    on port `3002`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了广播交易，请访问`/transaction/broadcast`端点。您可以将此交易数据发送到任何节点，并且应该会广播到整个网络。在我们的示例中，让我们将此交易发送到端口`3002`上的节点：
- en: '![](img/f5d8682a-6ae2-403d-a1a7-991f9fe295a4.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5d8682a-6ae2-403d-a1a7-991f9fe295a4.png)'
- en: Now, click on the Send button. You'll then receive a response as the transaction
    was created and broadcast successfully.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击发送按钮。然后，您将收到响应，表示交易已成功创建和广播。
- en: You can also try making other transactions just as we did previously, by changing
    the amount value and the sender's and recipient's addresses. Another test would
    be sending the transaction data to different nodes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以尝试进行其他交易，就像我们之前所做的那样，通过更改金额值和发送方和接收方的地址。另一个测试是将交易数据发送到不同的节点。
- en: 'Let''s now head back to the browser and check the nodes to verify that they''ve
    all received the transactions that we just created. As we loaded the node `3001`
    previously in our browser, let''s refresh it. You should get the following output:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们返回浏览器，检查节点，以验证它们是否都收到了我们刚刚创建的交易。因为我们之前在浏览器中加载了节点`3001`，让我们刷新它。您应该会得到以下输出：
- en: '![](img/615252da-d04b-4aeb-8638-a48cb160e6aa.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/615252da-d04b-4aeb-8638-a48cb160e6aa.png)'
- en: From the preceding screenshot, you can observe that the node has all three of
    the transactions that we created, plus it has the mining reward from the previous
    block inside the `pendingTransactions` array. Similarly, you can verify the `pendingTransaction`
    array for the remaining nodes. Thus, we can conclude that all of the transactions
    that we created are being broadcast to the entire network perfectly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，您可以观察到该节点有我们创建的所有三笔交易，以及上一个区块中的挖矿奖励，都在`pendingTransactions`数组中。同样，您可以验证其他节点的`pendingTransaction`数组。因此，我们可以得出结论，我们创建的所有交易都被完美地广播到整个网络。
- en: 'Now, let''s mine a new block to verify whether all the pending transactions
    have been added to the new block. For this example, let''s mine a new block on node
    `3003` by typing `localhost:3003/mine` in the address bar of the new tab. The
    response will indicate that the block was mined and broadcast successfully:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们挖掘一个新的区块，以验证所有待处理的交易是否已添加到新的区块中。在本例中，让我们在`3003`节点上挖掘一个新的区块，方法是在新标签的地址栏中键入`localhost:3003/mine`。响应将指示区块已成功挖掘和广播：
- en: '![](img/9f5d3c19-68fc-4856-8426-5ef408dbe097.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f5d3c19-68fc-4856-8426-5ef408dbe097.png)'
- en: 'From the preceding screenshot, in the `transactions` array, it looks like all
    the transactions that we have created are present in the newly mined block. Let''s
    go to all the nodes and verify whether the transactions that we created are added
    to the new block. On `localhost:3001`, you can observe the following output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，在`transactions`数组中，看起来我们创建的所有交易都存在于新挖掘的区块中。让我们去所有的节点，验证我们创建的交易是否已添加到新的区块中。在`localhost:3001`上，您可以观察到以下输出：
- en: '![](img/acb06fbf-885b-42cb-9e42-47f77aa2a7c1.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acb06fbf-885b-42cb-9e42-47f77aa2a7c1.png)'
- en: 'From this screenshot, we can observe that we''ve now got a fourth block that
    contains all the transactions that we sent. Then, if you check the `pendingTransactions`
    array, you can see that the transaction data has been cleared out and the new
    mining reward is present in it:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个屏幕截图中，我们可以观察到我们现在有了一个包含我们发送的所有交易的第四个区块。然后，如果您检查`pendingTransactions`数组，您会看到交易数据已被清除，并且新的挖矿奖励存在其中：
- en: '![](img/f703b8ef-1858-413a-8d6d-fe11a57bacf7.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f703b8ef-1858-413a-8d6d-fe11a57bacf7.png)'
- en: In this section, we created a couple of new transactions on different nodes.
    These were then broadcast to the whole network successfully. Then, we mined a
    new block and all the transactions we created were added to that new block successfully.
    On top of that, our newly mined block was broadcast to all the nodes inside our
    blockchain network. All of the nodes across our entire network are now synchronized
    and all contain the same blockchain data.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在不同的节点上创建了一对新的交易。然后，这些交易成功地被广播到整个网络。然后，我们挖掘了一个新的区块，我们创建的所有交易都成功地添加到了新的区块中。除此之外，我们新挖掘的区块被广播到了区块链网络中的所有节点。我们整个网络中的所有节点现在都是同步的，并且都包含相同的区块链数据。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Up to now, you've achieved a lot in this book. You have created a decentralized
    blockchain network that's currently running across five nodes, and you built the
    functionality to synchronize the entire network, so that all the nodes have the
    exact same data. This mirrors how a blockchain would function in a real-world
    application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您在本书中取得了很大的成就。您已经创建了一个分散的区块链网络，目前正在五个节点上运行，并且您构建了功能，以同步整个网络，以便所有节点都具有完全相同的数据。这反映了区块链在实际应用中的功能。
- en: 'In this chapter, we successfully synchronized the entire blockchain network
    by refactoring the endpoints to broadcast the data to all the nodes present in
    the network. We started by splitting the functionality of the `/createNewTransaction`
    method into two separate parts: the `/createNewTransaction` method and the `addTransactionToPendingTransactions`
    method. Then, we built the `/transaction/broadcast` endpoint to broadcast the
    newly created transaction to all the nodes in the network. We also refactored
    the `/transaction` endpoint, so that the `/transaction/broadcast` endpoint and
    the `/transaction` endpoint could work together. Later on in the chapter, we refactored
    the `/mine` endpoint and also built a new endpoint, `/receive-new-block`. With
    the help of these endpoints, the newly created blocks can be broadcast to all
    the nodes in the network.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过重构端点将整个区块链网络成功同步，将数据广播到网络中的所有节点。我们首先将`/createNewTransaction`方法的功能拆分为两个部分：`/createNewTransaction`方法和`addTransactionToPendingTransactions`方法。然后，我们构建了`/transaction/broadcast`端点，将新创建的交易广播到网络中的所有节点。我们还重构了`/transaction`端点，使得`/transaction/broadcast`端点和`/transaction`端点能够一起工作。在本章的后面，我们重构了`/mine`端点，并构建了一个新的端点`/receive-new-block`。借助这些端点，新创建的区块可以广播到网络中的所有节点。
- en: In the next chapter, we'll be building consensus algorithms to make sure that
    all of the nodes inside our network can agree on the correct data to hold inside
    the blockchain.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建共识算法，以确保网络中的所有节点都能就区块链中应持有的正确数据达成一致。
