- en: Creating Real-Time Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实时应用程序
- en: '"Nothing endures but change."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “唯一不变的是变化。”
- en: – Heraclitus
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 赫拉克利特'
- en: What is real-time software? A list of friends gets updated the instant one joins
    or exits. Traffic updates automatically stream into the smartphones of drivers
    looking for the best route home. The sports page of an online newspaper immediately
    updates scoreboards and standings as points are scored in an actual game. Users
    of this type of software expect reactions to change to be communicated quickly,
    and this expectation demands a particular focus on reducing network latency from
    the software designer. Data I/O updates must occur along subsecond time frames.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是实时软件？好友列表在有人加入或退出时立即更新。交通信息会自动流入正在寻找最佳回家路线的司机的智能手机。在线报纸的体育版会在实际比赛中得分时立即更新比分和排名。这类软件的用户期望对变化的反应能够快速传达，这种期望要求软件设计者特别关注减少网络延迟。数据I/O更新必须在亚秒级时间范围内发生。
- en: Let's step back and consider the general characteristics of the Node environment
    and community that make it an excellent tool for creating these kinds of responsive
    network applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，考虑一下Node环境和社区的一般特点，使其成为创建这类响应式网络应用程序的绝佳工具。
- en: Some validation of Node's design, it may be argued, is found in the enormous
    community of open developers contributing enterprise-grade Node systems. Multicore,
    multiserver enterprise systems are being created using free software mostly written
    in JavaScript.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，Node设计的一些验证可以在庞大的开发者社区中找到，这些开发者正在贡献企业级Node系统。多核、多服务器的企业系统正在使用大部分用JavaScript编写的免费软件创建。
- en: 'Why are so many companies migrating toward Node when designing or updating
    their products? The following list enumerates the reasons why:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有这么多公司在设计或更新产品时都向Node迁移？以下列举了原因：
- en: Node offers the excellent npm package management system, which integrates easily
    with the Git version control system. A shallow learning curve helps even inexperienced
    developers safely store, modify, and distribute new modules, programs, and ideas.
    Developers can develop private modules on private Git repositories and distribute
    these repositories securely within a private network using npm. As a result, the
    community of Node users and developers has rapidly expanded, some members gaining
    great fame. *If you build it, they will come*.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node提供了出色的npm包管理系统，可以轻松与Git版本控制系统集成。浅显易懂的学习曲线帮助即使是经验不足的开发人员也能安全地存储、修改和分发新的模块、程序和想法。开发人员可以在私人Git存储库上开发私有模块，并使用npm在私人网络中安全地分发这些存储库。因此，Node用户和开发人员的社区迅速扩大，一些成员声名鹊起。*如果你建造它，他们就会来*。
- en: 'Node lifted the system-access barrier for a large group of skilled programmers,
    suddenly releasing pent-up talent into an empty volume, offering the ecosystem
    of opportunity that a popular new project in need of many improvements in infrastructure
    brings. The point is this: Node merged the opportunity of concurrency with native
    JavaScript events; its brilliantly designed API allowed users of a well-known
    programming paradigm to take advantage of high-concurrency I/O. *If you reward
    them, they will come*.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node打破了系统访问的障碍，突然释放了大批技术娴熟的程序员的才华，为一个需要在基础设施上进行许多改进的热门新项目提供了机遇生态系统。关键在于：Node将并发的机会与原生JavaScript事件相结合；其设计精巧的API允许使用众所周知的编程范式的用户利用高并发I/O。*如果你奖励他们，他们就会来*。
- en: Node lifted the network-access barrier for a large group of JavaScript developers
    whose work and ambition had begun to outgrow the tiny sandbox available to client
    developers. It should not be forgotten that the period of time extending from
    the introduction of JavaScript in 1995 to the present is now over 20 years. Nearly
    a generation of developers has struggled trying to implement new ideas for network
    applications within an event-driven development environment known for, even defined
    by, its limitations. Overnight, Node removed those limitations. *If you clear
    paths, they will come*.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node打破了网络访问的障碍，让一大批JavaScript开发人员的工作和抱负开始超越客户端开发者可用的小沙盒。不应忘记，从1995年引入JavaScript到现在已经过去了20多年。几乎一个开发人员的一代人一直在努力尝试在以事件驱动的开发环境中实现新的网络应用想法，而这个环境以其限制而闻名，甚至被定义。Node一夜之间消除了这些限制。*如果你清理路径，他们就会来*。
- en: Node provides an easy way to build scalable network programs, where network
    I/O is no longer a bottleneck. The real shift is not from another popular system
    to Node—it is away from the idea that expensive and complex resources are needed
    to build and maintain efficient applications demanding burstable concurrency.
    If a resilient and scalable network architecture can be achieved cheaply, freed
    resources can be directed to solving other pressing software challenges, such
    as parallelizing data filtering, scaling massively multiplayer games, building
    real-time trading platforms or collaborative document editors, even implementing
    live code changes in hot systems. Confidence breeds progress. *If you make it
    easy, they will come*.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node提供了一种构建可扩展网络程序的简单方法，其中网络I/O不再是瓶颈。真正的转变不是从另一个流行系统到Node，而是摆脱了需要昂贵和复杂资源来构建和维护需要突发并发的高效应用程序的观念。如果可以廉价实现一个弹性和可扩展的网络架构，那么释放出的资源可以用来解决其他紧迫的软件挑战，比如并行化数据过滤、构建大规模多人游戏、构建实时交易平台或协作文档编辑器，甚至在热系统中实现实时代码更改。信心带来进步。*如果你让它变得容易，他们就会来*。
- en: 'Node arrived at a time when those building dynamic web pages had begun to run
    up against the limitations of servers not equipped to smoothly field many small,
    simultaneous requests. The software architect must now solve some interesting
    problems: what are the rules of *real time*—will the user be satisfied with *soon*,
    or is *now* the only right response? And, what is the best way to design systems
    responsible for satisfying these user desires?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Node在那些构建动态网页的人已经开始遇到服务器无法顺利处理许多小型同时请求的限制时出现。软件架构师现在必须解决一些有趣的问题：*实时*的规则是什么——用户是否满意于*很快*，还是*现在*是唯一正确的响应？最好的设计系统满足这些用户需求的方式是什么？
- en: 'In this chapter, we will investigate three standard techniques available to
    developers to use when constructing real-time network applications: AJAX, WebSockets,
    and server-sent events (SSE). Our goals for this chapter are to learn the benefits
    and drawbacks of each of these techniques, and to implement each technique with
    Node. Remembering that we are aiming to achieve a consistent architecture reflecting
    the evented-streams design of Node, we will also consider how well each technique
    lends itself to representation as a readable, writable, or duplex stream.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将调查开发人员在构建实时网络应用程序时可以使用的三种标准技术：AJAX、WebSockets和服务器发送事件（SSE）。我们本章的目标是了解每种技术的优缺点，并使用Node实现每种技术。记住我们的目标是实现一个一致的架构，反映Node的事件流设计，我们还将考虑每种技术作为可读、可写或双工流的表现能力。
- en: 'We will close this chapter with the construction of a collaborative code editor,
    which should demonstrate the opportunities Node provides for those seeking to
    build real-time groupware. As you work your way through the examples, and build
    your own applications, these are some questions that are worth asking yourself:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以构建一个协作代码编辑器来结束本章，这应该展示了Node为那些希望构建实时协作软件的人提供的机会。当您逐步学习示例并构建自己的应用程序时，这些都是值得自问的一些问题：
- en: What is the volume of messages I expect to transact per second? How many simultaneously
    connected clients are expected at peak times and at off-peak times?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我预计每秒要处理的消息量是多少？在高峰时段和非高峰时段，预计会有多少同时连接的客户端？
- en: What is the average size of the messages being transmitted?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输的消息的平均大小是多少？
- en: Can I accept occasional communication breakdowns or dropped messages if this
    concession buys me lower average latency?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我能接受偶尔的通信中断或丢失的消息，是否可以通过这种让我获得更低的平均延迟？
- en: Do I really need bidirectional communication, or is one side responsible for
    nearly all message volume? Do I need a complicated communication interface at
    all?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我真的需要双向通信吗，还是一方几乎负责所有消息量？我是否需要一个复杂的通信接口？
- en: What sorts of networks will my application run within? Will there be proxy servers
    between a client and my Node server? Which protocols are supported?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的应用程序将在哪些网络中运行？在客户端和我的Node服务器之间会有代理服务器吗？支持哪些协议？
- en: Do I need a complex solution or will simple and straightforward, even slightly
    slower, solutions bring other benefits in the long run?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要一个复杂的解决方案，还是简单直接，甚至稍慢一些的解决方案会在长远带来其他好处？
- en: Introducing AJAX
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入AJAX
- en: In 2005, Jesse James Garrett published an article in which he tried to condense
    the changes he had been seeing in the way that websites were being designed into
    a pattern. After studying this trend, Garrett proposed that dynamically updating
    pages represented a new wave of software, resembling desktop software, and he
    coined the acronym, *AJAX***,** to describe the technological concept powering
    such rapid movement toward *web applications*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年，Jesse James Garrett发表了一篇文章，试图将他所看到的网站设计方式的变化压缩成一种模式。在研究了这一趋势之后，Garrett提出，动态更新页面代表了一种新的软件浪潮，类似于桌面软件，他创造了缩写*AJAX*来描述推动这种快速向*Web应用程序*发展的技术概念。
- en: 'This was the diagram he used to demonstrate the general pattern:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是他用来展示一般模式的图表：
- en: '![](img/705a2392-c4f4-4f16-b238-d58c5e77eca4.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/705a2392-c4f4-4f16-b238-d58c5e77eca4.png)'
- en: 'The original article can be found at:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 原始文章链接：
- en: '[http://adaptivepath.org/ideas/ajax-new-approach-web-applications/](http://adaptivepath.org/ideas/ajax-new-approach-web-applications/).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://adaptivepath.org/ideas/ajax-new-approach-web-applications/](http://adaptivepath.org/ideas/ajax-new-approach-web-applications/).'
- en: The "*AJAX engine*" *Garrett's* diagram referred to had in fact existed in most
    common browsers by the year 2000, and even earlier in some. JavaScript implementations
    of the **XMLHttpRequest** (**XHR**) object in these browsers gave web pages the
    ability to request *chunks* of HTML or other data from servers. Partial updates
    could be dynamically applied to a web page, creating the opportunity for new kinds
    of user interfaces. For example, the latest pictures from an event could magically
    appear to a user, without that user actively requesting a page refresh, or clicking
    a Next Picture button.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年前后，*Garrett*的图表中提到的"*AJAX引擎*"实际上已经存在于大多数常见的浏览器中，甚至在一些浏览器中更早。这些浏览器中的JavaScript实现了**XMLHttpRequest**
    (**XHR**)对象，使网页能够从服务器请求HTML或其他数据的*片段*。部分更新可以动态应用于网页，从而为新型用户界面创造了机会。例如，最新的活动图片可以神奇地出现在用户面前，而无需用户主动请求页面刷新或点击下一张图片按钮。
- en: More importantly, Garrett also understood how the synchronous, stateless world
    of the *old* internet was becoming an asynchronous, stateful one. The conversation
    between clients and servers was no longer being derailed by sudden amnesia and
    could continue usefully for longer periods of time, sharing increasingly useful
    information. Garret saw this as a shift to a new generation of network software.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，Garrett还理解了*旧*互联网的同步、无状态世界正在变成异步、有状态的世界。客户端和服务器之间的对话不再因突然失忆而中断，可以持续更长时间，共享越来越有用的信息。Garret将此视为网络软件新一代的转变。
- en: Responding to calls
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回应呼叫
- en: If changes can be introduced into a web application without requiring a complete
    reconstruction of state and state display, updating client information becomes
    cheaper. The client and server can talk more often, regularly exchanging information.
    Servers can recognize, remember, and respond immediately to client desires, aided
    by reactive interfaces gathering user actions and reflecting the impact of those
    actions within a UI in near real time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以在不需要完全重建状态和状态显示的情况下引入更改到Web应用程序中，更新客户端信息将变得更加便宜。客户端和服务器可以更频繁地交流，定期交换信息。服务器可以识别、记住并立即响应客户端的愿望，通过反应式界面收集用户操作，并几乎实时地在UI中反映这些操作的影响。
- en: 'With AJAX, the construction of a multiuser environment supporting real-time
    updates to each client''s view on the overall application state involves regular
    polling of the server by clients checking for important updates:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AJAX，支持实时更新每个客户端对整个应用程序状态的视图的多用户环境的构建涉及客户端定期轮询服务器以检查重要更新：
- en: '![](img/1f9a7fcf-e3cd-460c-b6ac-2759125b945a.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f9a7fcf-e3cd-460c-b6ac-2759125b945a.png)'
- en: The significant drawback to this method of polling for state is that many of
    these requests will be fruitless. The client has become a broken record, constantly
    asking for status updates regardless of whether those updates are available or
    forthcoming. When an application spends time or energy performing unnecessary
    tasks, there should exist some clear benefit to the user or the provider (or both)
    offsetting this cost. Additionally, each futile call adds to the cost of building
    up then tearing down HTTP connections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询状态的重大缺点是，其中许多请求将是徒劳的。客户端变成了一个破碎的记录，不断地请求状态更新，无论这些更新是否可用或即将到来。当应用程序花费时间或精力执行不必要的任务时，应该存在一些明显的好处，以抵消这种成本。此外，每次徒劳的调用都会增加建立然后拆除HTTP连接的成本。
- en: Such a system can only take snapshots of the state at periodic intervals, and
    as that polling interval may increase to several seconds in an effort to reduce
    redundant network chatter, our awareness of state changes can begin to appear
    dull, just a little behind the latest news.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的系统只能在定期间隔内获取状态的快照，由于轮询间隔可能增加到几秒钟，以减少冗余的网络通信，我们对状态变化的意识可能开始显得迟钝，稍微落后于最新消息。
- en: 'We saw a better solution in the previous chapter—long polling, the technique
    of letting a server hold on to a client connection until new data is available:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了一个更好的解决方案——长轮询，即让服务器保持与客户端的连接，直到有新数据可用。
- en: '![](img/e75d3f2e-60b1-43ad-90b5-302707dde4c5.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e75d3f2e-60b1-43ad-90b5-302707dde4c5.png)'
- en: This improved AJAX technique does not fully escape the cost of building up and
    tearing down network connections, yet a significant reduction in the number of
    such costly operations is achieved. In general, AJAX fails to deliver a smooth,
    stream-like evented interface, requiring a great deal of attending services to
    persist state as connections are regularly broken and then reestablished.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改进的AJAX技术并没有完全摆脱建立和拆除网络连接的成本，但显著减少了这类昂贵操作的数量。总的来说，AJAX无法提供流畅的、类似流的事件接口，需要大量的服务来持久化状态，因为连接经常中断然后重新建立。
- en: Nevertheless, AJAX remains a real option for some applications, in particular
    simple applications where the ideal polling interval is fairly well known, each
    poll standing a good chance of gathering useful results. Let's use Node to build
    a server able to communicate with a stock reporting service, and build a polling
    client that periodically requests this server to check for changes and report
    them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，AJAX仍然是一些应用的真正选择，特别是简单的应用，其中理想的轮询间隔相当明确，每次轮询都有很大机会收集有用的结果。让我们使用Node构建一个能够与股票报告服务通信的服务器，并构建一个定期请求该服务器以检查更改并报告它们的轮询客户端。
- en: Creating a stock ticker
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建股票行情
- en: 'Ultimately, we will create an application that allows clients to pick a stock
    and watch for changes in the data points related to that stock, such as its price,
    and to highlight positive or negative changes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将创建一个应用程序，允许客户端选择一只股票，并观察与该股票相关的数据点的变化，如其价格，并突出正面或负面的变化：
- en: '![](img/daf8e1a5-a9f3-430a-9a96-822e15020901.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/daf8e1a5-a9f3-430a-9a96-822e15020901.png)'
- en: 'To create the client, our work is minimal. We need to simply poll our server
    every few seconds or so, updating our interface to reflect any data changes. Let''s
    use jQuery as our AJAX library provider. To fetch JSON from a server using jQuery,
    you will normally do something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建客户端，我们的工作很少。我们只需要每隔几秒钟轮询我们的服务器，更新我们的界面以反映任何数据更改。让我们使用jQuery作为我们的AJAX库提供程序。要使用jQuery从服务器获取JSON，通常会这样做：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A Node server will receive this request for an update, perform some I/O (check
    a database, call an external service), and respond with data, which the client
    can use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Node服务器将接收此更新请求，执行一些I/O（检查数据库，调用外部服务），并以数据响应，客户端可以使用。
- en: In our example, Node will be used to connect to the IEX Developer Platform ([https://iextrading.com/developer/](https://iextrading.com/developer/)),
    which provides stock quotes for free.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，Node将用于连接到IEX Developer Platform ([https://iextrading.com/developer/](https://iextrading.com/developer/))，该平台免费提供股票报价。
- en: We will construct a Node server that listens for clients requesting an update
    to the data for a given stock symbol, such as "IBM". The Node server will then
    create a YQL query for that stock symbol and execute that query via `http.get`,
    packaging the received data nicely for the calling client and sending it back.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个Node服务器，监听客户端请求更新给定股票代码（如“IBM”）的数据。然后，Node服务器将为该股票代码创建一个YQL查询，并通过`http.get`执行该查询，将接收到的数据包装好发送回调用客户端。
- en: This package will also be assigned a new `callIn` property, indicating the number
    of milliseconds the client should wait before calling again. This is a useful
    technique to remember, as our stock data server will have a much better idea of
    the traffic conditions and the update frequency than the client will. Instead
    of a client blindly checking on a fixed schedule, our server can recalibrate this
    frequency after each call, even demanding that the client stop calling!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包还将被分配一个新的`callIn`属性，表示客户端在再次调用之前应该等待的毫秒数。这是一个有用的技术要记住，因为我们的股票数据服务器将比客户端更好地了解交通状况和更新频率。我们的服务器可以在每次调用后重新校准这个频率，甚至要求客户端停止调用，而不是盲目地按照固定的时间表检查。
- en: 'As this design, particularly the visual design, can be done through any number
    of ways, we will simply look at the core functionality necessary for our client,
    contained within the following `fetch` method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种设计，特别是视觉设计，可以通过多种方式完成，我们将简单地看一下我们客户需要的核心功能，包含在以下的`fetch`方法中：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Users on this page enter stock symbols into an input box with ID `#symbol`.
    This data is then fetched from our data service. In the preceding code, we see
    the service call being made via the `$.getJSON jQuery` method, the JSON data being
    received, and a `setTimeout` property being set using the `callIn` interval sent
    back by Node.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，用户将股票符号输入到ID为`#symbol`的输入框中。然后从我们的数据服务中获取这些数据。在前面的代码中，我们看到通过`$.getJSON
    jQuery`方法进行服务调用，接收到JSON数据，并使用Node发送回来的`callIn`间隔设置了`setTimeout`属性。
- en: 'Our server is responsible for brokering the preceding client call with the
    data service. Assuming that we have a properly configured server that successfully
    receives stock symbols from clients, we need to open an HTTP connection to the
    service, read any response, and return this data:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器负责与数据服务协商前面的客户端调用。假设我们有一个正确配置的服务器成功地从客户端接收股票符号，我们需要打开到服务的HTTP连接，读取任何响应，并返回这些数据：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we see a good example of why it is a good idea to let the server, the
    primary observer of state, modulate the frequency with which clients poll. If
    a successful data object is received, we set the poll interval (`callIn`) to about
    five seconds. Should an error occur, we increase that delay to 10 seconds. It
    is easy to see how we might do more, perhaps, throttling connections further if
    repeated errors occur. Given that, there will often be limits on the rate at which
    an application may make requests to an external service (such as limiting the
    number of calls that can be made in one hour); this is also a useful technique
    for ensuring that constant client polling doesn't exceed these rate limits.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了一个很好的例子，说明为什么让服务器，作为主要的状态观察者，调节客户端轮询的频率是一个好主意。如果成功接收到数据对象，我们将轮询间隔(`callIn`)设置为大约五秒。如果发生错误，我们将延迟增加到10秒。很容易看出，如果重复发生错误，我们可能会做更多的事情，例如进一步限制连接。鉴于这一点，应用程序可能会对向外部服务发出请求的速率有限制（例如限制一小时内可以发出的调用次数）；这也是一个确保不断的客户端轮询不会超过这些速率限制的有用技术。
- en: 'AJAX is the original technique for creating real-time applications. It remains
    useful in some cases, but has been superseded by more efficient transports. As
    we leave this section, let''s keep in mind some of the advantages and disadvantages
    of polling:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX是创建实时应用程序的原始技术。在某些情况下仍然有用，但已被更高效的传输方式取代。在离开这一部分时，让我们记住一些轮询的优缺点：
- en: '| **Pros** | **Cons** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **优点** | **缺点** |'
- en: '| The theory and practice of REST is available, allowing more standardized
    communication | Making and breaking connections imposes a cost on network latency,
    especially if done very often |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| REST的理论和实践是可用的，允许更标准化的通信 | 建立和断开连接会对网络延迟产生成本，特别是如果经常这样做 |'
- en: '| No need for any special protocol server, with polling easily implemented
    using a standard HTTP server | Clients must request data; servers are unable to
    unilaterally update clients as new data arrives |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 不需要任何特殊的协议服务器，轮询可以很容易地使用标准的HTTP服务器实现 | 客户端必须请求数据；服务器无法单方面更新客户端以响应新数据的到来 |'
- en: '| HTTP is well-known and consistently implemented | Even long polling doubles
    the network traffic needed to maintain a persistent connection |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| HTTP是众所周知且一贯实施的 | 即使长轮询也会使需要维持持久连接的网络流量翻倍 |'
- en: '|  | Data is blindly pushed and pulled, rather than smoothly broadcast and
    listened for on channels |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  | 数据是盲目地推送和拉取，而不是在频道上平稳地广播和监听 |'
- en: 'Let''s move on now into a discussion of some newer protocols, in part designed
    to solve some of the issues we''ve found with AJAX: WebSockets and SSE.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入讨论一些较新的协议，部分设计用于解决我们在AJAX中发现的一些问题：WebSockets和SSE。
- en: Bidirectional communication with socket.io
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用socket.io进行双向通信
- en: We're already familiar with what sockets are. In particular, we know how to
    establish and manage TCP socket connections using Node, as well as how to pipe
    data through them bidirectionally or unidirectionally.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉套接字是什么。特别是，我们知道如何使用Node建立和管理TCP套接字连接，以及如何通过它们双向或单向地传输数据。
- en: The W3C has proposed a socket API that allows browsers to communicate with a
    socket server over a persistent connection. `socket.io` is a library that facilitates
    the establishment of persistent socket connections for those developing with Node,
    providing both a Node-based socket server and an emulation layer for browsers
    that do not support the `WebSocket` API natively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: W3C提出了一个套接字API，允许浏览器通过持久连接与套接字服务器通信。`socket.io`是一个库，为那些使用Node开发的人提供了一个基于Node的套接字服务器和一个用于不支持原生`WebSocket`
    API的浏览器的仿真层，从而便于建立持久套接字连接。
- en: Let's first take a brief look at how the native WebSocket API is implemented,
    and how to build a socket server supporting this protocol using Node. We will
    then build a collaborative drawing application using `socket.io` with Node.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先简要看一下原生WebSocket API是如何实现的，以及如何使用Node构建支持该协议的套接字服务器。然后，我们将使用`socket.io`和Node构建一个协作绘图应用程序。
- en: 'The full specification for the `WebSocket` API can be found at: [http://www.w3.org/TR/websockets/. ](http://www.w3.org/TR/websockets/)Documentation
    and installation instructions for `socket.io` can be found at: [https://socket.io/](http://socket.io/)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocket` API的完整规范可以在以下网址找到：[http://www.w3.org/TR/websockets/. ](http://www.w3.org/TR/websockets/)有关`socket.io`的文档和安装说明可以在以下网址找到：[https://socket.io/](http://socket.io/)'
- en: Using the WebSocket API
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebSocket API
- en: 'Socket communication is efficient, only occurring when one of the parties has
    something useful to say:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字通信是高效的，只有当其中一方有有用的东西要说时才会发生：
- en: '![](img/20c55a5c-de5a-4eb0-8151-7e06441bdb44.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20c55a5c-de5a-4eb0-8151-7e06441bdb44.png)'
- en: This lightweight model is an excellent choice for applications that require
    high-frequency message passing between a client and a server, such as found in
    multiplayer network games or chat rooms.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种轻量级模型非常适合需要在客户端和服务器之间进行高频消息传递的应用程序，例如在多人网络游戏或聊天室中发现的情况。
- en: 'According to the W3C, the WebSocket API is intended *to "enable web applications
    to maintain bidirectional communications with server-side processes."* Assuming
    that we have established a socket server running at `localhost:8080`, we can connect
    to this server from a browser containing the following line of JavaScript:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据W3C，WebSocket API旨在“使Web应用程序能够与服务器端进程保持双向通信。”假设我们已经在`localhost:8080`上运行了一个套接字服务器，我们可以从包含以下JavaScript行的浏览器连接到此服务器：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`WebSocket` expects two arguments: an URL prefixed by the URI scheme `ws://`,
    and an optional subprotocol list, which can be an array or a single string of
    protocols that a server may implement.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocket`需要两个参数：以`ws://`为前缀的URL和一个可选的子协议列表，可以是服务器可能实现的协议的数组或单个字符串。'
- en: To establish a secure socket connection, use the `wss://` prefix. As with HTTPS
    servers, you'll need an SSL certificate.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立安全的套接字连接，请使用`wss://`前缀。与HTTPS服务器一样，您将需要SSL证书。
- en: 'Once a socket request is made, the connection events, open, close, error, and
    message can be handled by a browser:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发出套接字请求，浏览器可以处理连接事件、打开、关闭、错误和消息：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For this example, we''ll implement a `WebSocket` server in Node using the ws
    module at: [https://github.com/websockets/ws](https://github.com/websockets/ws).
    After installing ws using npm (`npm i ws`), establishing a Node socket server
    is straightforward:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用ws模块在Node中实现一个`WebSocket`服务器：[https://github.com/websockets/ws](https://github.com/websockets/ws)。使用npm安装ws（`npm
    i ws`）后，建立一个Node套接字服务器非常简单：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we see how the server simply listens for the `connection` and `message`
    events from clients, responding as necessary. Should there be a need to terminate
    a connection (perhaps, if the client loses authorization), the server can simply
    emit a `close` event, which a client can listen for:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到服务器只是简单地监听来自客户端的`connection`和`message`事件，并根据需要做出响应。如果有必要终止连接（也许是如果客户端失去授权），服务器可以简单地发出`close`事件，客户端可以监听该事件：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The general schematic for an application using the WebSocket API to create
    bidirectional communication therefore looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用WebSocket API创建双向通信的应用程序的一般示意图如下：
- en: '![](img/3c6e068c-8269-4d4d-b0da-61edf9fce8fa.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c6e068c-8269-4d4d-b0da-61edf9fce8fa.png)'
- en: The native WebSocket browser implementation is used here to communicate with
    our custom Node socket server, which fields requests from the client as well as
    broadcasting new data or information to the client when necessary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本地WebSocket浏览器实现用于与我们的自定义Node套接字服务器进行通信，该服务器处理来自客户端的请求，并在必要时向客户端广播新数据或信息。
- en: socket.io
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: socket.io
- en: 'As mentioned previously, `socket.io` aims to provide an emulation layer that
    will use the native `WebSocket` implementation in browsers that support it, reverting
    to other methods (such as long polling) to simulate the native API in legacy browsers
    that don''t. This is an important fact to keep in mind: there are still some old
    browsers out there.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`socket.io`旨在提供一个仿真层，将在支持它的浏览器中使用本机`WebSocket`实现，并在旧浏览器中（如长轮询）使用其他方法来模拟本机API。这是一个重要的事实要记住：仍然有一些旧的浏览器存在。
- en: Nevertheless, `socket.io` does a very good job of hiding browser differences
    and remains a good choice when the control flow made available by sockets is a
    desirable model of communication for your application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`socket.io`在隐藏浏览器差异方面做得非常好，并且在套接字提供的控制流对于您的应用程序的通信模型是一种理想选择时，它仍然是一个很好的选择。
- en: 'In the `WebSocket` implementation used in the preceding example (`ws`), it
    is clear that the socket server is independent of any specific client file. We
    wrote some JavaScript to establish a `WebSocket` connection on a client, independently
    running a socket server using Node. Unlike this native implementation, `socket.io`
    requires a custom client library to be installed on a server in addition to the
    `socket.io` server module:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面示例中使用的`WebSocket`实现（`ws`）中，可以清楚地看到套接字服务器独立于任何特定的客户端文件。我们编写了一些JavaScript来在客户端上建立`WebSocket`连接，独立地使用Node运行套接字服务器。与这种本机实现不同，`socket.io`需要在服务器上安装自定义客户端库以及`socket.io`服务器模块：
- en: '![](img/ba61389a-37f6-422b-9be3-5cb98714aa72.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba61389a-37f6-422b-9be3-5cb98714aa72.png)'
- en: '`socket.io` can be installed using the `npm` package manager:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`可以使用`npm`包管理器进行安装：'
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Setting up a client/server socket pairing is straightforward.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 设置客户端/服务器套接字配对非常简单。
- en: 'On the server:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the client:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see how both the client and the server are using the same file, `socket.io.js`.
    A server using `socket.io` handles the serving of the `socket.io.js` file to clients
    automatically when requested. It should also jump out how closely the `socket.io`
    API resembles a standard Node `EventEmitter` interface.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到客户端和服务器都使用相同的文件`socket.io.js`。使用`socket.io`的服务器在请求时会自动处理向客户端提供`socket.io.js`文件。还应该注意到`socket.io`
    API与标准Node`EventEmitter`接口非常相似。
- en: Drawing collaboratively
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协作绘图
- en: 'Let''s create a collaborative drawing application using `socket.io` and Node.
    We want to create a blank canvas that will simultaneously display all the *pen
    work* being done by connected clients:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`socket.io`和Node创建一个协作绘图应用。我们想要创建一个空白画布，同时显示所有连接客户端所做的*笔迹*：
- en: '![](img/2fcb18fa-585d-4dce-aef8-cb16bde157b2.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fcb18fa-585d-4dce-aef8-cb16bde157b2.png)'
- en: 'From the server end, there is very little to do. When a client updates coordinates
    by moving their mouse, the server simply broadcasts this change to all connected
    clients:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器端来看，要做的事情很少。当客户端通过移动鼠标更新坐标时，服务器只需将此更改广播给所有连接的客户端：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`socket.io` automatically generates a unique ID for each socket connection.
    We will pass this ID along whenever new draw events occur, allowing the receiving
    clients to track how many users are connected. Similarly, when a client disconnects,
    all other clients are instructed to remove their references to this client. Later,
    we will see how this ID is used within the application UI to maintain a pointer
    representing all connected clients.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`会自动生成一个唯一的ID用于每个socket连接。每当发生新的绘图事件时，我们将传递这个ID，允许接收端客户端跟踪有多少用户连接。同样，当一个客户端断开连接时，所有其他客户端都会被指示删除对这个客户端的引用。稍后，我们将看到这个ID在应用UI中如何使用，以维护表示所有连接客户端的指针。'
- en: This is an excellent example of just how simple it is to create multiuser network
    applications using Node and the packages created by the Node community. Let's
    break down what this server is doing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，展示了使用Node和Node社区创建的包来创建多用户网络应用是多么简单。让我们来分析一下这个服务器在做什么。
- en: 'Because we will need to deliver the HTML file that clients will use to draw,
    half of the server setup involves creating a static file server. For convenience,
    we''ll use the node-static package at: [https://github.com/cloudhead/node-static](https://github.com/cloudhead/node-static).
    Our implementation will serve an `index.html` file to any client who connects.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要提供客户端用于绘制的HTML文件，所以服务器设置的一半涉及创建一个静态文件服务器。为了方便起见，我们将使用node-static包：[https://github.com/cloudhead/node-static](https://github.com/cloudhead/node-static)。我们的实现将为任何连接的客户端提供一个`index.html`文件。
- en: Our `socket.io` implementation expects to receive `mousemove` events from clients,
    and its only task is to send to all connected clients these new coordinates, which
    it does by emitting a moving event through its `broadcast` method. As one client
    changes the canvas state by drawing a line, all clients will receive the information
    necessary to update their view of the canvas state in real time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`socket.io`实现期望从客户端接收`mousemove`事件，它的唯一任务是向所有连接的客户端发送这些新坐标，它通过其`broadcast`方法通过发出一个移动事件来实现。当一个客户端通过绘制一条线改变画布状态时，所有客户端都将收到更新画布状态所需的信息，以实时更新他们的画布状态视图。
- en: 'With the communication layer built, we now must create client views. As mentioned,
    each client will load an `index.html` file containing the necessary canvas element,
    and the JavaScript necessary to listen for moving events, as well the `socket.io`
    emitter broadcasting client draw events to our server:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通信层建立完成后，我们现在必须创建客户端视图。如前所述，每个客户端将加载一个包含必要的canvas元素和监听移动事件的JavaScript的`index.html`文件，以及将客户端绘制事件广播到我们的服务器的`socket.io`发射器：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A `pointers` element is created to hold visible representations for the cursors
    of all connected clients, which will update as connected clients move their pointers
    and/or draw something.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`pointers`元素来保存所有连接客户端光标的可见表示，这些表示将随着连接客户端移动其指针和/或绘制某些东西而更新。
- en: 'Within the `script.js` file, we first set up event listeners on the `canvas`
    element, watching for the combination of `mousedown` and `mousemove` events indicating
    a draw action. Note how we create a time buffer of 50 milliseconds, delaying the
    broadcast of each draw event, slightly reducing the resolution of drawings but
    avoiding an excessive number of network events:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`script.js`文件中，我们首先在`canvas`元素上设置事件监听器，监听`mousedown`和`mousemove`事件的组合，指示绘图动作。请注意，我们创建了一个50毫秒的时间缓冲，延迟每次绘制事件的广播，略微降低了绘图的分辨率，但避免了过多的网络事件：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Whenever a draw action occurs (a combination of a `mousedown` and a `mousemove`
    event), we draw the requested line on the client''s machine, and then broadcast
    these new coordinates to our `socket.io` server via `socket.emit(''mousemove'',
    …)`, remembering to pass along the `id` value of the drawing client. The server
    in turn will broadcast them via `socket.broadcast.emit(''moving'', data)`, allowing
    client listeners to draw equivalent lines on their `canvas` element:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生绘图动作（`mousedown`和`mousemove`事件的组合），我们会在客户端的机器上绘制请求的线条，然后通过`socket.emit('mousemove',
    ...)`将这些新坐标广播到我们的`socket.io`服务器，记得传递绘图客户端的`id`值。服务器将通过`socket.broadcast.emit('moving',
    data)`广播它们，允许客户端监听器在它们的`canvas`元素上绘制等效的线条：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Within this listener, a client will establish a new client pointer if the sent
    client ID has not been seen previously, and animate both the drawing of a line
    and the client pointer, creating the effect of multiple cursors drawing distinct
    lines within a single client view.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个监听器中，如果发送的客户端ID以前没有看到过，客户端将建立一个新的客户端指针，并且动画化一条线的绘制和客户端指针，从而在单个客户端视图中创建多个光标绘制不同线条的效果。
- en: 'Recalling the `clientdisconnect` event we track on our server, we also enable
    clients to listen for these disconnects, removing references to lost clients from
    both the view (visual pointer) and our `clients` object:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在服务器上跟踪的`clientdisconnect`事件，我们还使客户端能够监听这些断开连接，从视图（可视化指针）和我们的`clients`对象中删除丢失客户端的引用：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`socket.io` is an excellent tool to consider when building interactive, multiuser
    environments where continuous rapid bidirectional data transfer is necessary.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`是一个很好的工具，用于构建交互式的、多用户的环境，需要连续快速的双向数据传输。'
- en: 'Now, take a look at the pros and cons of `socket.io`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`socket.io`的优缺点：
- en: '| **Pros** | **Cons** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **优点** | **缺点** |'
- en: '| Rapid bidirectional communication essential to real-time games, collaborative
    editing tools, and other applications | The number of allowed persistent socket
    connections can be limited on the server side or anywhere in between |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 对于实时游戏、协作编辑工具和其他应用程序来说，快速的双向通信至关重要 | 允许的持久套接字连接数量可以在服务器端或任何中间位置进行限制 |'
- en: '| Lower overhead than standard HTTP protocol requests, lowering the price of
    sending a package across the network | Many proxies and reverse proxies are known
    to confound socket implementations, leading to lost clients |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 比标准HTTP协议请求的开销更低，降低了在网络上发送数据包的价格 | 许多代理和反向代理都会使套接字实现混乱，导致客户端丢失 |'
- en: '| The evented, streaming nature of sockets fits conceptually with the Node
    architecture—clients and servers are simply piping data back and forth through
    consistent interfaces | Requires a custom protocol server, and often a custom
    client library |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 套接字的事件驱动和流式特性在概念上与Node架构相吻合——客户端和服务器只是通过一致的接口来回传递数据 | 需要自定义协议服务器，通常需要自定义客户端库
    |'
- en: 'Another interesting project is SockJS, which implements socket servers in many
    different languages, including Node.js. Check out: [https://github.com/sockjs/sockjs-node](https://github.com/sockjs/sockjs-node).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的项目是SockJS，它在许多不同的语言中实现了套接字服务器，包括Node.js。查看：[https://github.com/sockjs/sockjs-node](https://github.com/sockjs/sockjs-node)。
- en: Listening for Server Sent Events
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听服务器发送的事件
- en: SSE are uncomplicated and specific. They are to be used when the majority of
    data transfer proceeds unidirectionally from a server to clients. A traditional
    and similar concept is the *push* technology. SSE pass text messages with simple
    formatting. Many types of applications passively receive brief status updates
    or data state changes. SSE are an excellent fit for these types of applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SSE是简单而具体的。它们在大多数数据传输是从服务器到客户端单向进行时使用。传统和类似的概念是*推送*技术。SSE传递带有简单格式的文本消息。许多类型的应用程序被动地接收简短的状态更新或数据状态更改。SSE非常适合这些类型的应用程序。
- en: 'Like `WebSocket`, SSE also eliminate the redundant chatter of AJAX. Unlike
    `WebSocket`, an SSE connection is only concerned with broadcasting data from servers
    to connected clients:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与`WebSocket`一样，SSE也消除了AJAX的冗余交流。与`WebSocket`不同，SSE连接只关注从服务器向连接的客户端广播数据：
- en: '![](img/6e993b38-8ad7-41c4-9e68-b340567b01f2.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e993b38-8ad7-41c4-9e68-b340567b01f2.png)'
- en: 'A client connects to a server supporting SSE by passing the `EventSource` constructor
    a path:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将路径传递给`EventSource`构造函数，客户端连接到支持SSE的服务器：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This instance of `EventSource` will now emit subscribable data events whenever
    new data is received from the server.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSource`的这个实例现在将在从服务器接收到新数据时发出可订阅的数据事件。'
- en: Using the EventSource API
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EventSource API
- en: 'The way in which `EventSource` instances emit subscribable data events whenever
    new data is received from the server is like the way `Readable` streams emit data
    events in Node, as we can see in this example client:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSource`实例发出可订阅的数据事件，每当从服务器接收到新数据时，就像`Readable`流在Node中发出数据事件一样，正如我们在这个示例客户端中所看到的：'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An `EventSource` instance emits three default events:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSource`实例会发出三个默认事件：'
- en: '`open`: When a connection is successfully opened, this event will fire'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`：当连接成功打开时，将触发此事件'
- en: '`message`: The handler assigned to this event will receive an object whose
    `data` property contains the broadcast message'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：分配给此事件的处理程序将接收一个对象，其`data`属性包含广播消息'
- en: '`error`: This fires whenever a server error occurs, or the server disconnects
    or otherwise severs its connection with this client'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：每当服务器发生错误，或服务器断开连接或以其他方式与此客户端断开连接时，都会触发此事件'
- en: 'Forming part of the standard HTTP protocol, a server responsive to SSE requests
    requires minimal configuration. The following server will accept `EventSource`
    bindings and broadcast the current date to the bound client every second:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准HTTP协议的一部分，响应SSE请求的服务器需要进行最少的配置。以下服务器将接受`EventSource`绑定并每秒向绑定的客户端广播当前日期：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This server listens for requests and selects those made on the path `/login`,
    which it interprets as a request for an `EventSource` binding. Establishing an
    `EventSource` connection is simply a matter of responding to the request with
    a `Content-Type` header of `text/event-stream`. Additionally, we indicate that
    the client's `Cache-Control` behavior should be set to `no-cache`, as we expect
    a lot of original material on this channel.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务器监听请求并选择在路径`/login`上进行的请求，将其解释为对`EventSource`绑定的请求。建立`EventSource`连接只是简单地通过使用`Content-Type`头部为`text/event-stream`来响应请求。此外，我们指示客户端的`Cache-Control`行为应设置为`no-cache`，因为我们期望在此通道上有大量原始材料。
- en: 'From the point of connection, the `response` object of this client will remain
    an open pipe that messages can be sent through using `write`. Let''s look at the
    next two lines:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从连接点开始，此客户端的`response`对象将保持一个开放的管道，可以通过`write`发送消息。让我们看看接下来的两行：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This first write is adjusting for an XHR implementation feature in some browsers,
    which ultimately requires all SSE streams to be prefixed by a 2-KB padding. This
    write action need happen only once, and has no relevance to subsequent messages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一次写入是为了调整一些浏览器中XHR实现的特性，最终需要所有SSE流都以2KB填充为前缀。这个写入操作只需要发生一次，对后续消息没有影响。
- en: One of the advantages of SSE is that clients will automatically try to reconnect
    with the server, should that connection be severed. The number of milliseconds
    before retrying will vary from client to client, and can be controlled using the
    retry field, which we use here to set a two-millisecond retry interval.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SSE的一个优点是，客户端在连接断开时会自动尝试重新连接服务器。重试的毫秒数将因客户端而异，并且可以使用重试字段进行控制，我们在这里使用它来设置两毫秒的重试间隔。
- en: 'Finally, we listen for the client''s close event, which fires when a client
    disconnects, and begins broadcasting the time on a one-second interval:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们监听客户端的关闭事件，当客户端断开连接时触发，并开始以一秒的间隔广播时间：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A website might bind to this time server and display the current server time:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网站可能会绑定到这个时间服务器并显示当前的服务器时间：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because the connection is one way, any number of services can be set up as publishers
    very easily, with clients binding individually to these services via new `EventSource`
    instances. Server monitoring, for example, could be achieved easily by modifying
    the preceding server so that it periodically sends the value of `process.memoryUsage()`.
    As an exercise, use SSE to reimplement the stocks service we covered earlier in
    the section on AJAX.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为连接是单向的，任意数量的服务可以很容易地设置为发布者，客户端通过新的`EventSource`实例分别绑定到这些服务。例如，可以通过修改前面的服务器，使其定期发送`process.memoryUsage()`的值，轻松实现服务器监视。作为练习，使用SSE重新实现我们在AJAX部分中介绍的股票服务。
- en: The EventSource stream protocol
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EventSource流协议
- en: 'Once a server has established a client connection, it may now send new messages
    across this persistent connection at any time. These messages consist of one or
    more lines of text, demarcated by one or several of the following four fields:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器建立了客户端连接，它现在可以随时通过这个持久连接发送新消息。这些消息由一个或多个文本行组成，由以下四个字段中的一个或多个分隔：
- en: '`event`: This is an event type. Messages sent without this field will trigger
    the client''s general `EventSource` event handler for any message. If set to a
    string such as *latestscore*, the client''s `message` handler will not be called,
    with handling being delegated to a handler bound using `EventSource.addEventListener(''latestscore''…)`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`：这是一个事件类型。发送此字段的消息将触发客户端的一般`EventSource`事件处理程序处理任何消息。如果设置为诸如*latestscore*之类的字符串，客户端的`message`处理程序将不会被调用，处理将委托给使用`EventSource.addEventListener(''latestscore''…)`绑定的处理程序。'
- en: '`data`: This is the message being sent. This is always of the `String` type,
    though it can usefully transport objects passed through `JSON.stringify()`.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是要发送的消息。这始终是`String`类型，尽管它可以有用地传输通过`JSON.stringify()`传递的对象。'
- en: '`id`: If set, this value will appear as the `lastEventID` property of the sent
    message object. This can be useful for ordering, sorting, and other operations
    on the client.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：如果设置，此值将出现为发送的消息对象的`lastEventID`属性。这对于对客户端进行排序、排序和其他操作非常有用。'
- en: '`retry`: The reconnection interval, in milliseconds.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试：重新连接间隔，以毫秒为单位。
- en: 'Sending messages involves composing strings containing relevant field names
    and ending with newlines. These are all valid messages:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息涉及组成包含相关字段名称并以换行符结尾的字符串。这些都是有效的消息：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see that multiple `data` fields can be set as well. An important thing
    to note is the double newline (`"\n\n"`) to be sent after the final data field.
    Previous fields should just use a single newline.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到也可以设置多个`data`字段。需要注意的一点是在最后一个数据字段之后发送双换行（`"\n\n"`）。之前的字段应该只使用单个换行。
- en: The default `EventSource` client events (`open`, `message`, and `close`) are
    sufficient for modeling most application interfaces. All broadcasts from the server
    are caught within the solitary `message` handler, which takes responsibility for
    routing the message or otherwise updating the client, in the same way that event
    delegation would work when working with events in the DOM using JavaScript.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`EventSource`客户端事件（`open`，`message`和`close`）足以对大多数应用程序接口进行建模。服务器发送的所有广播都在唯一的`message`处理程序中捕获，该处理程序负责路由消息或以其他方式更新客户端，就像在使用JavaScript处理DOM中的事件时工作时事件委托会起作用一样。
- en: This system may not be ideal in cases where many unique message identifiers
    are needed, overwhelming a single handling function. We can use the `event` field
    of SSE messages to create custom event names that can be individually bound by
    a client, neatly separating concerns.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要许多唯一的消息标识符的情况下，压倒一个单一处理函数可能不是理想的。我们可以使用SSE消息的`event`字段来创建自定义事件名称，客户端可以单独绑定，从而整洁地分离关注点。
- en: 'For example, if two special events `actionA` and `actionB` are being broadcast,
    our server would structure them like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果正在广播两个特殊事件`actionA`和`actionB`，我们的服务器将像这样结构化它们：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our client would bind to them in the normal way, as shown in the following
    code snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端将以正常方式绑定到它们，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In cases where a single message handling function is becoming too long or too
    complex, consider uniquely named messages and handlers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个消息处理函数变得过长或过于复杂的情况下，考虑使用唯一命名的消息和处理程序。
- en: Asking questions and getting answers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提问和获取答案
- en: 'What if we wanted to create an interface to interests? Let''s build an application
    enabling any number of people to ask and/or answer questions. Our users will join
    the community server, see a list of open questions and answers to those questions,
    and get real-time updates whenever a new question or answer is added. There are
    two key activities to model:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个与兴趣相关的接口怎么办？让我们构建一个应用程序，使任意数量的人可以提问和/或回答问题。我们的用户将加入社区服务器，看到一个开放问题的列表以及对这些问题的答案，并在添加新问题或答案时实时获取更新。有两个关键活动需要建模：
- en: Each client must be notified whenever another client asks a question or posts
    an answer
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个客户端必须在另一个客户端提问或发布答案时得到通知。
- en: A client can ask questions or supply answers
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以提问或提供答案
- en: '![](img/1d168c9c-c488-4c1d-b08b-5f7910f26b61.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d168c9c-c488-4c1d-b08b-5f7910f26b61.png)'
- en: Where would the greatest amount of change happen in a large group of simultaneous
    contributors to this community?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大量的同时贡献者的大型群体中，最大的变化会发生在哪里？
- en: Any individual client can potentially ask a few questions or provide a few answers.
    Clients will also select questions and have the answers displayed to them. We
    will need to satisfy merely a handful of client-to-server requests, such as when
    sending a new question or answer to the server. Most of the work will be in satisfying
    client requests with data (a list of answers to a question) and broadcasting application
    state changes to all connected clients (new question added; new answer given).
    The one-to-many relationship existing for clients within such collaborative applications
    implies that a single client broadcast may create a number of server broadcasts
    equal to the number of connected clients—1 to 10,000 or more. SSE are a great
    fit here, so let's get started.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 任何个别的客户端都可以提出几个问题或提供几个答案。客户端还可以选择问题，并查看答案。我们只需要满足少量的客户端到服务器的请求，比如向服务器发送新问题或答案。大部分工作将在满足客户端请求数据（问题的答案列表）和向所有连接的客户端广播应用程序状态更改（添加新问题；给出新答案）方面。在这种协作应用程序中存在的一对多关系意味着单个客户端广播可能会创建与连接的客户端数量相等的服务器广播，从
    1 到 10,000 或更多。SSE 在这里非常合适，所以让我们开始吧。
- en: 'The three main operations for this application are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的三个主要操作如下：
- en: Asking a question
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提问
- en: Answering a question
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回答问题
- en: Selecting a question
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择问题
- en: 'Either of these actions will change the application state. As this state must
    be reflected across all clients, we will store the state of our application on
    our server—all questions, answers, and the relationships of clients to these data
    objects. We will also need to uniquely identify each client. Normally, one would
    use a database to persist some of this information, but for our purposes, we will
    simply store this data in our Node server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作中的任何一个都会改变应用程序的状态。由于这个状态必须在所有客户端上反映出来，我们将在服务器上存储应用程序的状态——所有问题、答案以及客户端与这些数据对象的关系。我们还需要唯一标识每个客户端。通常，人们会使用数据库来持久化其中一些信息，但出于我们的目的，我们将简单地将这些数据存储在我们的
    Node 服务器中：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In addition to the `questions` and `answers` storage objects, we will also need
    to store client objects themselves—clients are assigned a unique ID that can be
    used to look up information (such as the client's socket) when broadcasts are
    made.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `questions` 和 `answers` 存储对象之外，我们还需要存储客户端对象本身——客户端被分配一个唯一的 ID，可以用来查找信息（比如客户端的套接字），当进行广播时使用。
- en: We only want to broadcast answer data to clients that have expressed an interest
    in the specific question—as client UIs are only displaying answers for a single
    question, we, of course, would not broadcast answers to clients indiscriminately.
    For this reason, we keep a `clientQMap` object, which maps a question to all clients
    listening to that question, by the ID.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想向对特定问题感兴趣的客户端广播答案数据——因为客户端 UI 只显示单个问题的答案，当然我们不会向客户端不加区分地广播答案。因此，我们保留了一个
    `clientQMap` 对象，它将一个问题映射到所有关注该问题的客户端，通过 ID。
- en: 'The `removeClient` method is straightforward: when a client disconnects, the
    method removes its data from the pool. We''ll see this again later.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeClient` 方法很简单：当客户端断开连接时，该方法会从池中删除其数据。稍后我们会再次看到这一点。'
- en: 'With this setup in place, we next need to build our server to respond the `/login`
    path, which is used by `EventSource` to grab a connection. This service is responsible
    for configuring a proper event-stream for clients, storing this `Response` object
    for later use, and assigning the user a unique identifier, which will be used
    on future client requests to identify the client and fetch that client''s communication
    socket:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，接下来我们需要构建我们的服务器来响应 `/login` 路径，这是由 `EventSource` 用于建立连接的。这个服务负责为客户端配置一个适当的事件流，将这个
    `Response` 对象存储起来以备后用，并为用户分配一个唯一标识符，这个标识符将在将来的客户端请求中用于识别客户端并获取该客户端的通信套接字：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After establishing request parameters, our servers check the request for a
    `_sse_user_id_` header, which is the unique string that is assigned to a user
    within `/login` on the initial `EventSource` bind:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立请求参数之后，我们的服务器会检查请求中的 `_sse_user_id_` 头部，这是在初始 `EventSource` 绑定中分配给用户的唯一字符串，位于
    `/login` 中：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This ID is then sent to the client via an immediate broadcast, an opportunity
    we use to send along the current batch of questions:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过即时广播将此 ID 发送给客户端，我们利用这个机会发送当前批次的问题：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The client is now responsible for passing along this ID whenever it makes a
    call. By listening for the `/login` event and storing the ID that is passed, a
    client can self-identify when making HTTP calls:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端负责在进行调用时传递这个 ID。通过监听 `/login` 事件并存储传递的 ID，客户端可以在进行 HTTP 调用时自我识别：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Recall that we have just created a unidirectional event-stream from our server
    to our client. This channel is used to communicate with clients—not `response.end()`
    or similar. The broadcast method, referenced in `/login`, accomplishes this task
    of broadcasting stream events, as shown in the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们刚刚从服务器到客户端创建了一个单向事件流。这个通道用于与客户端通信，而不是 `response.end()` 或类似的方法。在 `/login`
    中引用的广播方法完成了广播流事件的任务，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Scan this code from the bottom up. Note how the primary purpose of broadcast
    is to take a client ID, look up that client's event stream, and write to it, accepting
    a custom event name if needed. However, as we will regularly broadcast to all
    connected clients, we allow for a special `*` flag to indicate mass broadcast.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从下往上扫描这段代码。注意广播的主要目的是获取客户端 ID，查找该客户端的事件流，并向其写入，如果需要，接受自定义事件名称。然而，由于我们将定期向所有连接的客户端广播，我们允许使用特殊的
    `*` 标志来指示大规模广播。
- en: 'Everything is now set up, requiring only the definition of services for the
    three main operations for this application: adding new questions and answers,
    and remembering the question each client is following.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都设置好了，只需要为此应用程序的三个主要操作定义服务：添加新问题和答案，以及记住每个客户端正在关注的问题。
- en: 'When questions are asked, we ensure that the question is unique, add it to
    our `question` collection, and tell everyone the new question list:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当提出问题时，我们确保问题是唯一的，将其添加到我们的“question”集合中，并告诉所有人新的问题列表：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Handling answers is nearly identical, except that here we want to broadcast
    new answers only to clients asking the right questions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 处理答案几乎相同，只是这里我们只想将新答案广播给询问正确问题的客户端：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we store changes to the client''s interests by updating `clientQMap`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过更新“clientQMap”来存储客户端兴趣的更改：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While we won't go too deeply into the client-side HTML and JavaScript necessary
    to render this interface, we will look at how some of the core events would be
    handled.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会深入讨论客户端HTML和JavaScript，但我们将看看如何处理一些核心事件。
- en: 'Assuming a UI rendered in HTML, which lists answers on one side and questions
    on the other, containing forms for adding new questions and answers, as well as
    for selecting questions to follow, our client code is very lightweight and easy
    to follow. After negotiating the initial `/login` handshake with our server, this
    client need simply send new data via HTTP when submitted. The handling of server
    responses is neatly encapsulated into three events, making for easy-to-follow
    event stream handling:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 假设UI以HTML呈现，一侧列出答案，另一侧列出问题，包含用于添加新问题和答案的表单，以及用于选择要跟随的问题的表单，我们的客户端代码非常轻量且易于跟踪。在与服务器进行初始“/login”握手后，此客户端只需通过HTTP发送新数据即可。服务器响应的处理被整洁地封装成三个事件，使得事件流处理变得易于跟踪：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This interface needs only to wait for new question and answer data, and display
    it in lists. Three callbacks are enough to keep this client up to date, regardless
    of how many different clients update the application's state.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此界面只需等待新的问题和答案数据，并在列表中显示它。三个回调足以使此客户端保持最新状态，无论有多少不同的客户端更新应用程序的状态。
- en: '| **Pros** | **Cons** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **优点** | **缺点** |'
- en: '| Lightweight: By using the native HTTP protocol, an SSE server can be created
    with a couple of simple headers | Inconsistent browser support requires a custom
    library for client-to-server communication, where unsupported browsers will normally
    long poll |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 轻量级：通过使用原生HTTP协议，可以使用几个简单的标头创建SSE服务器 | 不一致的浏览器支持需要为客户端到服务器通信创建自定义库，不支持的浏览器通常会进行长轮询
    |'
- en: '| Able to send data to a client unilaterally, without requiring matching client
    calls | One way only: Does not bring its advantages to cases where bidirectional
    communication is needed |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 能够单方面向客户端发送数据，而无需匹配客户端调用 | 单向：不适用于需要双向通信的情况 |'
- en: '| Automatic reconnection of dropped connections, making SSE a reliable network
    binding | Server must send a "heartbeat" every 10 seconds or so in order to keep
    the connection alive |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 自动重新连接断开的连接，使SSE成为可靠的网络绑定 | 服务器必须每隔大约10秒发送“心跳”以保持连接活动 |'
- en: '| Simple, easily customizable, and an easy-to-understand messaging format |  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 简单，易于定制，易于理解的消息格式 |  |'
- en: '`EventSource` is not supported by all browsers (in particular, IE). An excellent
    emulation library for SSE can be found at: [https://github.com/Yaffle/EventSource](https://github.com/Yaffle/EventSource).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSource`不受所有浏览器支持（特别是IE）。可以在以下网址找到SSE的出色仿真库：[https://github.com/Yaffle/EventSource](https://github.com/Yaffle/EventSource)。'
- en: Building a collaborative document editing application
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建协同文档编辑应用程序
- en: Now that we've examined various techniques to consider when building a collaborative
    application, let's put together a collaborative code editor using **Operational
    transformation** (**OT**).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了构建协同应用程序时要考虑的各种技术，让我们使用**操作转换**（**OT**）来组合一个协同代码编辑器。
- en: 'For our discussion here, OT will be understood as a technology that allows
    many people to edit the same document concurrently—collaborative document editing.
    Google described their (now defunct) Wave project in the following way:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，OT将被理解为一种允许许多人同时编辑同一文档的技术——协同文档编辑。Google以以下方式描述了他们（现已关闭的）Wave项目：
- en: As [https://svn.apache.org/repos/asf/incubator/wave/whitepapers/operational-transform/operational-transform.html](https://svn.apache.org/repos/asf/incubator/wave/whitepapers/operational-transform/operational-transform.html) says, "Collaborative
    document editing means multiple editors are able to edit a shared document at
    the same time. It is live and concurrent when a user can see the changes another
    person is making, keystroke by keystroke. Google Wave offers live concurrent editing
    of rich text documents.".
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[https://svn.apache.org/repos/asf/incubator/wave/whitepapers/operational-transform/operational-transform.html](https://svn.apache.org/repos/asf/incubator/wave/whitepapers/operational-transform/operational-transform.html)所说，“协同文档编辑意味着多个编辑者能够同时编辑共享文档。当用户可以逐个按键地看到另一个人所做的更改时，它是实时和并发的。Google
    Wave提供了富文本文档的实时并发编辑。”。
- en: One of the engineers involved in the Wave project was Joseph Gentle, and Mr.
    Gentle was kind enough to write a module bringing OT technology to the Node community,
    named **ShareJS**, which later became **ShareDB**, the OT backend for the Derby
    web framework ([http://derbyjs.com/](http://derbyjs.com/)). We are going to use
    this module to create an application that allows anyone to create a new collaboratively
    editable document.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 参与Wave项目的工程师之一是Joseph Gentle，Gentle先生很友好地编写了一个模块，将OT技术带到了Node社区，命名为**ShareJS**，后来成为了**ShareDB**，Derby
    web框架的OT后端（[http://derbyjs.com/](http://derbyjs.com/)）。我们将使用此模块创建一个允许任何人创建新的协同编辑文档的应用程序。
- en: 'This example liberally borrows from the many examples contained in the ShareDB
    GitHub repository. To delve deeper into the possibilities of ShareDB, visit: [https://github.com/share/sharedb](https://github.com/share/sharedb).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例大量借鉴了ShareDB GitHub存储库中包含的许多示例。要深入了解ShareDB的可能性，请访问：[https://github.com/share/sharedb](https://github.com/share/sharedb)。
- en: 'To begin with, we will need a code editor to bind our OT layer to. For this
    project, we will use the excellent Quill editor, which can be cloned from: [https://github.com/quilljs/quill](https://github.com/quilljs/quill).
    Quill is especially suited to working with ShareDB, as it is designed to represent
    documents as a sequence of changesets represented in JSON ([https://github.com/ottypes/rich-text](https://github.com/ottypes/rich-text)),
    which can be mapped to the OT types that ShareDB understands. While out of scope
    for this section, it might benefit the reader to dig into how OT works, especially
    with these two libraries.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个代码编辑器来绑定我们的OT层。对于这个项目，我们将使用优秀的Quill编辑器，可以从以下地址克隆：[https://github.com/quilljs/quill](https://github.com/quilljs/quill)。Quill特别适用于与ShareDB一起使用，因为它被设计为将文档表示为JSON中的一系列变更集（[https://github.com/ottypes/rich-text](https://github.com/ottypes/rich-text)），这些变更集可以映射到ShareDB理解的OT类型。虽然超出了本节的范围，但读者可能会对OT如何工作，特别是这两个库如何工作感兴趣。
- en: Being a collaborative, real-time application, we will use the **ws** socket
    server to manage communication between clients and the database, and **Express**
    to manage serving static files, such as `index.html`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个协作的实时应用程序，我们将使用**ws**套接字服务器来管理客户端和数据库之间的通信，并使用**Express**来管理提供静态文件，如`index.html`。
- en: 'In your code bundle for this chapter, there will be a sharedb folder. To install
    and try it out, run the following commands:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的代码捆绑包中，将会有一个sharedb文件夹。要安装并尝试它，请运行以下命令：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The two main files there will be `client.js` and `server.js`. The `client.js` file
    will be bundled using **Browserify**, generating the JavaScript the client will
    use. Let''s look at the `client.js` file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 主要文件将是`client.js`和`server.js`。将使用**Browserify**捆绑`client.js`文件，生成客户端将使用的JavaScript。让我们看看`client.js`文件：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The header of this file simply instantiates ShareDB, setting its document type
    to `rich-text`, and providing the instance with a communication socket to the
    server. For the purposes of this demonstration, we're going to operate on a single
    collection `examples` and the one file `richtext`. This collection/document pairing
    is how you work with documents in ShareDB, and is reflected in the `server.js`
    file we'll be looking at shortly. In a more advanced implementation, you will
    likely need to create some sort of collection/document management layer, linking
    those collections to certain users, adding user accounts, permissions, and so
    forth.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的标题只是实例化了ShareDB，将其文档类型设置为`rich-text`，并为实例提供了与服务器的通信套接字。为了演示的目的，我们将在单个集合`examples`和一个文件`richtext`上操作。这种集合/文档配对是您在ShareDB中处理文档的方式，并且很快将在我们即将看到的`server.js`文件中反映出来。在更高级的实现中，您可能需要创建某种集合/文档管理层，将这些集合链接到特定用户，添加用户帐户、权限等。
- en: 'Once we''ve established a subscription to the server, we bind a new Quill instance
    to the `#editor` element, set its contents (`quill.setContents`) to whatever the
    server returns as the current document, declaring that we''d like to use the `snow` theme,
    whose css we''ve included in `index.html`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们订阅了服务器，我们就将一个新的Quill实例绑定到`#editor`元素，将其内容（`quill.setContents`）设置为服务器返回的当前文档，并声明我们想要使用`snow`主题，其css已包含在`index.html`中：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'All that is left to do is create the Node server exposing the functionality
    of OT to the client. To do this, we will need to accept OT changes (deltas) from
    the server and apply those changes to the Quill editor, and report changes to
    the server as a user uses the Quill editor:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是创建将OT功能暴露给客户端的Node服务器。为此，我们需要接受来自服务器的OT更改（增量）并将这些更改应用到Quill编辑器，并在用户使用Quill编辑器时向服务器报告更改：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We're now set up to update the document database whenever there is a `text-change`
    in the Quill editor, and to `updateContents` of any connected client editor whenever
    there is a new `op` on the shared document.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置好了，每当Quill编辑器中有`text-change`时，我们将更新文档数据库，并在共享文档上有新的`op`时，我们将`updateContents`到任何连接的客户端编辑器。
- en: 'The server implementation largely reflects the client implementation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器实现在很大程度上反映了客户端实现：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We require all of the libraries, making a note of the websocket-json-stream
    requirement, a library that creates a JSON object stream across the socket, needed
    to represent the JSON changesets we will be working with.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要所有的库，注意websocket-json-stream的要求，这是一个在套接字上创建JSON对象流的库，需要表示我们将使用的JSON变更集。
- en: 'We then establish the collection/document setup our client expects, creating
    the document with some dummy text, "Say something!" if the document does not exist.
    The only thing left to do is to bind the ShareDB backend to this bidirectional
    JSON Object stream:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们建立客户端期望的集合/文档设置，如果文档不存在，则使用一些虚拟文本“说点什么！”创建文档。唯一剩下的事情就是将ShareDB后端绑定到这个双向JSON对象流：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This server can now be used to share document state across all clients requesting
    identically named documents, facilitating collaborative editing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务器现在可以用于在所有请求具有相同名称的文档的客户端之间共享文档状态，从而促进协作编辑。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we''ve gone over three of the major strategies employed when
    building real-time applications: AJAX, WebSocket, and SSE. We''ve shown that non-trivial
    collaborative applications can be developed with very little code using Node.
    We''ve also seen how some of these strategies enable the modeling of client/server
    communication as an evented data stream interface. We''ve considered the pros
    and cons of these various techniques, and we''ve gone through some clear examples
    of the best places to use each one.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经讨论了构建实时应用程序时使用的三种主要策略：AJAX、WebSocket和SSE。我们已经展示了使用Node可以用非常少的代码开发复杂的协作应用程序。我们还看到了一些策略如何使客户端/服务器通信建模为事件数据流接口。我们考虑了这些各种技术的优缺点，并且通过一些清晰的示例介绍了每种技术的最佳使用场景。
- en: Additionally, we've shown how client identifiers and state data can be built
    and managed within a Node server, so that state changes can be safely encapsulated
    in a central location and broadcast out to many connected clients safely and predictably.
    Demonstrating the quality of the modules being developed with the Node community,
    we created a collaborative code editing system through the use of operational
    transformation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经展示了如何在Node服务器中构建和管理客户端标识符和状态数据，以便状态更改可以安全地封装在一个中心位置，并安全可靠地广播到许多连接的客户端。通过使用操作转换，展示了与Node社区开发的模块的质量，我们创建了一个协作代码编辑系统。
- en: In the next chapter, we will be looking at how to coordinate the efforts of
    multiple Node processes running simultaneously. Through examples, we will learn
    how to achieve parallel processing with Node, from spawning many child processes
    running Unix programs to creating clusters of load-balancing Node socket servers.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何协调多个同时运行的Node进程的努力。通过示例，我们将学习如何使用Node实现并行处理，从生成运行Unix程序的许多子进程到创建负载均衡Node套接字服务器集群。
