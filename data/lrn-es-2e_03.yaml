- en: Using Iterators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器
- en: ES8 and earlier versions introduced new object interfaces and loops for iteration.
    The addition of the new iteration protocols opens up a new world of algorithms
    and abilities for JavaScript. We will start the chapter by introducing the symbols
    and various properties of the `Symbol` object. We will also learn how execution
    stacks are created for the nested function calls, their impacts, and how to optimize
    their performance and memory usage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ES8 及更早版本引入了新的对象接口和循环迭代。新迭代协议的添加为 JavaScript 打开了算法和能力的新世界。我们将从介绍符号和 `Symbol`
    对象的各种属性开始本章。我们还将学习嵌套函数调用如何创建执行栈，它们的影响，以及如何优化它们的性能和内存使用。
- en: Although symbols are a separate topic to iterators, we will still be covering
    symbols in this chapter, because to implement the iterable protocol, you need
    to use symbols.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然符号是迭代器的一个独立主题，但我们仍将在本章中涵盖符号，因为要实现迭代协议，你需要使用符号。
- en: 'In this chapter, we''ll cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖：
- en: Using symbols as the object property keys
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号作为对象属性键
- en: Implementing the iteration protocols in objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象中实现迭代协议
- en: Creating and using the `generator` object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用 `generator` 对象
- en: Using the `for…of` loop for iterating
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `for…of` 循环进行迭代
- en: The tail call optimization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: Symbols – primitive data type
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号 – 原始数据类型
- en: '**Symbols** are a primitive type that was first introduced in ES6\. A symbol
    is a unique and immutable value. Here is an example that shows how to create a
    symbol:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号** 是一种在 ES6 中首次引入的原始类型。符号是一个唯一且不可变的值。以下是一个示例，展示了如何创建一个符号：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Symbols don't have a literal form; therefore, we need to use the `Symbol()`
    function to create a symbol. The `Symbol()` function returns a unique symbol every
    time it is called.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 符号没有字面形式；因此，我们需要使用 `Symbol()` 函数来创建一个符号。每次调用 `Symbol()` 函数时，它都会返回一个唯一的符号。
- en: 'The `Symbol()` function takes an optional string parameter that represents
    the description of the symbol. A description of a symbol can be used for debugging,
    but not to access the symbol itself. Two symbols with the same description are
    not equal at all. Here is an example to demonstrate this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol()` 函数接受一个可选的字符串参数，表示符号的描述。符号的描述可用于调试，但不能用来访问符号本身。具有相同描述的两个符号完全不等于彼此。以下是一个示例来演示这一点：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding example, we can also say that a symbol is a string-like value
    that can't clash with any other value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，我们也可以说符号是一个类似于字符串的值，它不会与其他任何值冲突。
- en: The typeof operator
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`typeof` 操作符'
- en: 'The `typeof` operator is used to determine the type of value a particular variable/constant
    is held for `Symbol`, `typeof` outputs `symbol`. Here is an example to demonstrate
    the same:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 操作符用于确定特定变量/常量持有的值的类型。对于 `Symbol`，`typeof` 输出 `symbol`。以下是一个示例来演示相同的内容：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `typeof` operator is the only way to identify whether a variable holds
    a symbol.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `typeof` 操作符是唯一识别变量是否持有符号的方法。
- en: The new operator
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新操作符
- en: You cannot apply the `new` operator to the `Symbol()` function. The `Symbol()`
    function detects whether it's being used as a constructor, and if `true`, it then
    throws an exception.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将 `new` 操作符应用于 `Symbol()` 函数。`Symbol()` 函数会检测它是否被用作构造函数，如果是，则抛出异常。
- en: 'Here is an example to demonstrate this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例来演示这一点：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But the JavaScript engine can use the `Symbol()` function internally as a constructor to
    wrap a symbol in an object. Therefore, `s` will be equal to object(s).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但 JavaScript 引擎可以使用 `Symbol()` 函数作为构造函数在内部包装一个符号。因此，`s` 将等于对象(s)。
- en: All primitive types introduced from ES6 onward will not allow their constructors
    to be invoked manually.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ES6 开始引入的所有原始类型都不允许手动调用它们的构造函数。
- en: Using symbols as the object property keys
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用符号作为对象属性键
- en: 'Until ES5, the JavaScript object property keys had to be string type. But since
    ES6, the JavaScript object property keys can be strings or symbols. Here is an
    example that demonstrates how to use a symbol as an object property key:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 ES5，JavaScript 对象属性键必须是字符串类型。但自从 ES6 以来，JavaScript 对象属性键可以是字符串或符号。以下是一个示例，演示了如何使用符号作为对象属性键：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the preceding code, you can see that in order to create or retrieve a property
    key using symbols, you need to use the `[]` token. We saw the `[]` token while
    discussing the computed property names in [Chapter 2](1240cafe-4f1d-4e0f-bc46-6c2ed8bb3efe.xhtml),
    *Knowing Your Library*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，你可以看到，为了使用符号创建或检索属性键，你需要使用 `[]` 符号。我们在讨论第 2 章中的计算属性名时看到了 `[]` 符号，[第
    2 章](1240cafe-4f1d-4e0f-bc46-6c2ed8bb3efe.xhtml)，*了解你的库*。
- en: To access a symbol property key, we need the symbol. In the previous example,
    both `s1` and `s2` hold the same symbol value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个符号属性键，我们需要符号。在先前的例子中，`s1` 和 `s2` 都持有相同的符号值。
- en: The Object.getOwnPropertySymbols() method
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertySymbols()` 方法'
- en: 'The `Object.getOwnPropertyNames()` method cannot retrieve the symbol properties.
    Therefore, ES6 introduced `Object.getOwnPropertySymbols()` to retrieve an array
    of symbol properties of an object. Here is an example to demonstrate this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertyNames()` 方法无法检索符号属性。因此，ES6 引入了 `Object.getOwnPropertySymbols()`
    来检索对象的一组符号属性。以下是一个示例来演示这一点：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the previous example, you can see that the `Object.getOwnPropertySymbols()` method
    can also retrieve the non-enumerable symbol properties.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的例子中，你可以看到 `Object.getOwnPropertySymbols()` 方法也可以检索不可枚举的符号属性。
- en: The `in` operator can find the symbol properties in an object, whereas the `for…in`
    loop and `Object.getOwnPropertyNames()` cannot find the symbol properties in an
    object for the sake of backward compatibility.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 操作符可以在对象中找到符号属性，而 `for…in` 循环和 `Object.getOwnPropertyNames()` 由于向后兼容性的原因，不能在对象中找到符号属性。'
- en: The Symbol.for(string) method
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Symbol.for(string)` 方法'
- en: The `Symbol` object maintains a registry of the key/value pairs, where the key
    is the symbol description, and the value is the symbol. Whenever we create a symbol
    using the `Symbol.for()` method, it gets added to the registry and the method
    returns the symbol. If we try to create a symbol with a description that already
    exists, then the existing symbol will be retrieved.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol` 对象维护了一个键/值对的注册表，其中键是符号描述，值是符号。每次我们使用 `Symbol.for()` 方法创建符号时，它都会被添加到注册表中，并且该方法返回符号。如果我们尝试使用已存在的描述来创建符号，那么将检索现有的符号。'
- en: 'The advantage of using the `Symbol.for()` method instead of the `Symbol()`
    method to create symbols is that while using the `Symbol.for()` method, you don''t
    have to worry about making the symbol available globally, because it''s always
    available globally. Here is an example to demonstrate this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Symbol.for()` 方法而不是 `Symbol()` 方法创建符号的优势在于，在使用 `Symbol.for()` 方法时，你不必担心使符号在全局范围内可用，因为它始终在全局范围内可用。以下是一个示例来演示这一点：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Well-known symbols
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已知符号
- en: 'In addition to your own symbols, ES6 comes up with a built-in set of symbols,
    known as well-known symbols. Here is a list of properties, referencing some important
    built-in symbols:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你自己的符号外，ES6 还提供了一套内置的符号集合，称为已知符号。以下是一个属性列表，引用了一些重要的内置符号：
- en: '`Symbol.iterator`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.iterator`'
- en: '`Symbol.match`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.match`'
- en: '`Symbol.search`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.search`'
- en: '`Symbol.replace`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.replace`'
- en: '`Symbol.split`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.split`'
- en: '`Symbol.hasInstanceSymbol.species`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.hasInstanceSymbol.species`'
- en: '`Symbol.unscopables`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.unscopables`'
- en: '`Symbol.isContcatSpreadable`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.isContcatSpreadable`'
- en: '`Symbol.toPrimitive`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.toPrimitive`'
- en: You will come across the use of these symbols in various chapters of this book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书的各个章节中遇到这些符号的使用。
- en: When referring to the well-known symbols in the text, we usually prefix them
    using the `@@` notation. For example, the `Symbol.iterator` symbol is referred
    to as the `@@iterator` method. This is done to make it easier to refer to these
    symbols in the text.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当在文本中引用已知的符号时，我们通常使用 `@@` 符号来作为前缀。例如，`Symbol.iterator` 符号被称为 `@@iterator` 方法。这样做是为了使在文本中引用这些符号更加容易。
- en: The iteration protocol
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代协议
- en: An iteration protocol is a set of rules that an object needs to follow for implementing
    the interface. When this protocol is used, a loop or a construct can iterate over
    a group of values of the object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代协议是一组规则，对象需要遵循这些规则来实现接口。当使用此协议时，循环或构造可以遍历对象的一组值。
- en: JavaScript has two iteration protocols known as the **iterator**** protocol**
    and the **iterable protocol**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有两个名为 **iterator** 和 **iterable** 的迭代协议。
- en: The iterator protocol
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代协议
- en: Any object that implements the iterator protocol is known as an **iterator**.
    According to the iterator protocol, an object needs to provide a `next()` method
    that returns the next item in the sequence of a group of items.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了迭代器协议的对象都被称为**迭代器**。根据迭代器协议，一个对象需要提供一个`next()`方法，该方法返回一组项目序列中的下一个项目。
- en: 'Here is an example to demonstrate this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来演示这一点：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you look closely, you''ll realize that the `next` method inside the `obj`
    object is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现`obj`对象内部的`next`方法如下：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This can be written as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以写成以下形式：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This clearly tells us that we''ll increment `nextIndex` and send the next element
    from the `array` in the object `obj` if a new element exists there. When there''s
    no element left, we return `{ done: true }`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '这清楚地告诉我们，如果对象`obj`中存在新元素，我们将增加`nextIndex`并从对象`obj`中发送`array`的下一个元素。当没有元素剩下时，我们返回`{
    done: true }`。'
- en: The iterable protocol
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可迭代协议
- en: Any object that implements the **iterable protocol** is known as an iterable.
    According to the iterable protocol, an object needs to provide the `@@iterator`
    method; that is, it must have the `Symbol.iterator` symbol as a property key.
    The `@@iterator` method must return an iterator object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了**可迭代协议**的对象都被称为可迭代对象。根据可迭代协议，一个对象需要提供一个`@@iterator`方法；也就是说，它必须有一个`Symbol.iterator`符号作为属性键。`@@iterator`方法必须返回一个迭代器对象。
- en: 'Here is an example to demonstrate this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来演示这一点：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is all well and good, but what is the use of doing it?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来都很不错，但这样做有什么用呢？
- en: 'The preceding two code blocks show you how to implement the iterable protocol
    on your own. However, things such as **arrays** come with the iterable protocol
    (that is, their `__proto__` chain implements the `Symbol.iterator` method), which
    is implemented by default thus saving a developer''s time. Let''s take a look
    at an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个代码块展示了如何在自身上实现可迭代协议。然而，像**数组**这样的东西自带可迭代协议（即，它们的`__proto__`链实现了`Symbol.iterator`方法），这是默认实现的，从而节省了开发者的时间。让我们来看一个例子：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Based on what we've learned so far, what do you think the output should be?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今为止所学到的，你认为输出应该是什么？
- en: 'The output is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let us now take a look at generators, which are more or less, similar to iterators.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看生成器，它们或多或少与迭代器相似。
- en: Generator function
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器函数
- en: A `generator` is a normal function, but instead of returning a single value,
    it returns multiple values one by one. Calling a `generator` function doesn't
    execute its body immediately, but rather returns a new instance of the `generator`
    object (that is, an object that implements both, iterable and iterator protocols).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`generator`是一个普通的函数，但它不是返回一个单一值，而是逐个返回多个值。调用`generator`函数不会立即执行其主体，而是返回一个新的`generator`对象实例（即，一个实现了可迭代和迭代器协议的对象）。
- en: Every `generator` object holds a new execution context of the `generator` function.
    When we execute the `next()` method of the `generator` object, it executes the
    `generator` function's body until the `yield` keyword is encountered. It returns
    the yielded value and pauses the function. When the `next()` method is called
    again, it resumes the execution and then returns the next yielded value. The `done`
    property is `true` when the `generator` function doesn't yield any value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`generator`对象都持有`generator`函数的新执行上下文。当我们执行`generator`对象的`next()`方法时，它会在遇到`yield`关键字之前执行`generator`函数的主体。它返回产生的值并暂停函数。当再次调用`next()`方法时，它继续执行并返回下一个产生的值。当`generator`函数没有产生任何值时，`done`属性为`true`。
- en: 'A `generator` function is written using the `function*` expression. Here is
    an example to demonstrate this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`generator`函数是用`function*`表达式编写的。这里有一个例子来演示这一点：'
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is an expression following the `yield` keyword. The value of the expression
    is what is returned by the `generator` function via the iterable protocol. If
    we omit the expression, then `undefined` is returned. The value of the expression
    is what we call, the yielded value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`yield`关键字后面有一个表达式。该表达式的值是通过可迭代协议由`generator`函数返回的。如果我们省略这个表达式，那么返回`undefined`。这个表达式的值就是我们所说的，产生的值。
- en: 'We can also pass an optional argument to the `next()` method. This argument
    becomes the value returned by the `yield` statement, where the `generator` function
    is currently paused. Here is an example to demonstrate this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以向 `next()` 方法传递一个可选参数。这个参数成为 `yield` 语句返回的值，其中 `generator` 函数当前处于暂停状态。以下是一个示例来演示这一点：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s the explanation of this output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对这个输出的解释：
- en: On the first `generator.next()` call, `yield 12` is called and the value `12`
    is returned.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一次调用 `generator.next()` 时，调用 `yield 12` 并返回值 `12`。
- en: 'On the second `generator.next(5)` call, the previous yield (which was stored
    in `const a`) gets the passed value (that is, `5`), and then the second yield
    (`a + 1`). Then, `yield 5 + 1` is called and the value `6` is returned (careful:
    `a` is not `12` here).'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二次调用 `generator.next(5)` 时，之前的 `yield`（存储在 `const a` 中）获取传递的值（即 `5`），然后是第二个
    `yield`（`a + 1`）。然后，调用 `yield 5 + 1` 并返回值 `6`（注意：这里的 `a` 不是 `12`）。
- en: On the third `generator.next(11)` call, `const b` becomes `11`, and then because
    it's the sum of  *11 + 2*, `13` is yielded.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三次调用 `generator.next(11)` 时，`const b` 变为 `11`，然后因为它是 `11 + 2` 的和，所以返回 `13`。
- en: This is followed till the last process, that is, until the line `Final Line`,
    as mentioned in the example.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一直持续到最后一个过程，即直到示例中提到的 `Final Line` 行。
- en: As `yield` finally returns a value and its `done` status, after executing `yield
    c + 3`, there is apparently no value to yield. Hence, the value returned is `undefined`
    and `done` is `true`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `yield` 最终返回一个值和其 `done` 状态，在执行 `yield c + 3` 之后，显然没有值可以 `yield`。因此，返回的值是
    `undefined`，`done` 是 `true`。
- en: The return(value) method
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回(value)方法
- en: You can end a `generator` function any time before it has yielded all the values
    by using the `return()` method of the `generator` object. The `return()` method
    takes an optional argument, representing the final value to return.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `generator` 函数完成所有值 `yield` 之前，使用 `generator` 对象的 `return()` 方法随时结束它。`return()`
    方法接受一个可选参数，表示要返回的最终值。
- en: 'Here is an example demonstrating this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The throw(exception) method
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`throw(exception)` 方法'
- en: 'You can manually trigger an exception inside a `generator` function using the
    `throw()` method of the `generator` object. You must pass an exception to the
    `throw()` method that you want to throw. Here is an example to demonstrate this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `generator` 对象的 `throw()` 方法在 `generator` 函数内部手动触发异常。你必须向 `throw()` 方法传递你想要抛出的异常。以下是一个示例来演示这一点：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, you can see that the exception is thrown where the
    function was last paused. After the exception is handled, the `throw()` method
    continues execution, and returns the next yielded value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到异常是在函数最后暂停的地方抛出的。在异常被处理后，`throw()` 方法继续执行，并返回下一个 `yield` 的值。
- en: The yield* keyword
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`yield*` 关键字'
- en: 'The `yield*` keyword inside a `generator` function takes an iterable object
    as the expression and iterates it to yield its values. Here is an example to demonstrate
    this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `generator` 函数内部，`yield*` 关键字将可迭代对象作为表达式并迭代它以 `yield` 其值。以下是一个示例来演示这一点：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The for…of loop
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for...of` 循环'
- en: Until now, we have been iterating over an iterable object using the `next()`
    method, which is a cumbersome task. ES6 introduced the `for…of` loop to make this
    easier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用 `next()` 方法迭代可迭代对象，这是一个繁琐的任务。ES6 引入了 `for...of` 循环来简化这个过程。
- en: 'The `for…of` loop was introduced to iterate over the values of an iterable
    object. Here is an example to demonstrate this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...of` 循环被引入来迭代可迭代对象的值。以下是一个示例来演示这一点：'
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tail call optimization
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: Whenever a function call is made, an execution stack is created in the stack
    memory to store the variables of the function. **Tail call optimization** basically
    means that you reuse the allocated stack in memory if there's no information in
    that stack that is required later in the code execution sequence.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每当进行函数调用时，在堆栈内存中创建一个执行栈来存储函数的变量。**尾调用优化**基本上意味着如果没有信息在代码执行序列的后续部分中需要该堆栈分配的信息，你可以重用分配的堆栈。
- en: Why tail call optimization?
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要尾调用优化？
- en: 'When a function call is made inside another function call, a new execution
    stack is created for the inner function call. However, the problem is that the
    inner function execution stack takes up some extra memory--that is, it stores
    an extra address, representing where to resume the execution when this function
    finishes executing. Switching and creating the execution stacks also takes some
    additional CPU time. This problem is not noticeable when there are a couple  of hundred,
    nested levels of calls, but it''s noticeable when there are thousands or more
    nested levels of calls--that is, the JavaScript engines throw the `RangeError:
    Maximum call stack size exceeded` exception. You might have, at some point, experienced
    the `RangeError` exception while creating a recursive function.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '当在另一个函数调用内部进行函数调用时，会为内部函数调用创建一个新的执行栈。然而，问题是内部函数执行栈会占用一些额外的内存——也就是说，它存储了一个额外的地址，表示当这个函数执行完毕后如何恢复执行。切换和创建执行栈也会消耗一些额外的
    CPU 时间。当调用嵌套层级只有几百层时，这个问题并不明显，但当有数千层或更多嵌套层级时，这个问题就很明显了——即 JavaScript 引擎抛出 `RangeError:
    Maximum call stack size exceeded` 异常。你可能在创建递归函数时遇到过 `RangeError` 异常。'
- en: A tail call is a function call that is performed optionally at the very end
    of a function with the `return` statement. If a tail call leads to the same function
    call again and again, then it's called a **tail-recursion**, which is a special
    case of recursion. What's special about tail calls is that there is a way to actually
    prevent the extra CPU-time and memory usage while making the tail calls, and that
    is by reusing the stack of the out function, instead of creating a new execution
    stack. Reusing the execution stack while making a tail call is called tail call
    optimization.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尾调用是在函数的末尾，通过 `return` 语句可选执行的函数调用。如果一个尾调用反复调用同一个函数，那么它被称为**尾递归**，这是递归的一个特殊情况。尾调用特殊之处在于，实际上有一种方法可以防止在尾调用时额外的
    CPU 时间和内存使用，那就是重用外函数的栈，而不是创建新的执行栈。在尾调用时重用执行栈称为尾调用优化。
- en: 'JavaScript supports tail call optimization in specific browsers if the script
    is written in the `"use strict"` mode. Let''s see an example of a tail call:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本以 `"use strict"` 模式编写，JavaScript 支持在特定浏览器中进行尾调用优化。让我们看看一个尾调用的例子：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, the `_add()` call in the `add1()` function is a tail call, as it's the
    final action of the `add1()` function. However, the `_add()` call in the `add2()`
    function is not a tail call, as it's not the final act; adding `0` to the result
    of `_add()` is the final act.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`add1()` 函数中的 `_add()` 调用是一个尾调用，因为它是 `add1()` 函数的最终操作。然而，`add2()` 函数中的 `_add()`
    调用不是一个尾调用，因为它不是最终的操作；将 `0` 添加到 `_add()` 的结果是最终的操作。
- en: The `_add()` call in `add1()` doesn't create a new execution stack. Instead,
    it reuses the `add1()` function's execution stack; in other words, the tail call
    optimization occurs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `add1()` 函数中的 `_add()` 调用不会创建新的执行栈。相反，它重用了 `add1()` 函数的执行栈；换句话说，发生了尾调用优化。
- en: Tail call optimization spec is **not actively** being developed for Chrome and
    is only implemented in Safari as of now. Hence, you can only use TCO in Safari.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尾调用优化规范目前**没有积极**开发，目前仅在 Safari 中实现。因此，你只能在 Safari 中使用 TCO。
- en: Converting non-tail calls into tail calls
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将非尾调用转换为尾调用
- en: As tail calls are optimized, you must use tail calls whenever possible, instead
    of non-tail calls. You can optimize your code by converting the non-tail calls
    into tail calls.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于尾调用得到了优化，因此你应尽可能使用尾调用，而不是非尾调用。你可以通过将非尾调用转换为尾调用来优化你的代码。
- en: 'Let''s see an example of this, which is similar to the previous one:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个类似的例子：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the previous code, the `_add()` call was not a tail call, and therefore,
    two execution stacks were created. We can convert it into a tail call in this
    way:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`_add()` 调用不是一个尾调用，因此创建了两个执行栈。我们可以这样将其转换为尾调用：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we omitted the use of the `result` variable and instead lined up the function
    call with the `return` statement. There are many other similar strategies to convert
    non-tail calls into tail calls.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们省略了 `result` 变量的使用，而是将函数调用与 `return` 语句对齐。还有许多其他类似的策略可以将非尾调用转换为尾调用。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned a new way of creating the object property keys using
    symbols. We saw the iterator and iterable protocols and learned how to implement
    these protocols in custom objects. Then, we learned how to iterate over an iterable
    object using the `for…of` loop. Finally, we ended the chapter by learning what
    tail calls are, and how they are optimized.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一种使用符号创建对象属性键的新方法。我们了解了迭代器和可迭代协议，并学习了如何在自定义对象中实现这些协议。然后，我们学习了如何使用`for…of`循环遍历可迭代对象。最后，我们通过学习尾调用及其优化来结束本章。
- en: In the next chapter, we will learn about how to do asynchronous programming
    with Promises and the recently launched async/await feature in ES8, which makes
    asynchronous code look much more like synchronous code. Let's go!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Promises以及ES8中最近推出的async/await特性进行异步编程，这使得异步代码看起来更像是同步代码。让我们开始吧！
