- en: Chapter 10. Building a Custom Processor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：构建自定义处理器
- en: One of the key benefits of using PostCSS is its modular approach—we're not forced
    to use a large library, particularly if we only need to make use of a small part
    of its functionality! In this chapter, we'll pull together some of the themes
    we've discussed throughout earlier chapters, and create a fully working preprocessor,
    customized to our needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PostCSS的一个关键好处是其模块化方法——我们不必使用一个大型的库，尤其是如果我们只需要使用其功能的一小部分！在本章中，我们将汇集我们在前几章中讨论的一些主题，并创建一个完全符合我们需求的完整预处理器。
- en: 'We''ll use it to compile code for a simple site, explore using it for CMS systems
    such as WordPress, then take a look at extending it to work with frameworks such
    as CSStyle. We will cover a number of topics throughout this chapter, which will
    include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用它来编译一个简单网站的代码，探索使用它为WordPress等CMS系统，然后看看如何将其扩展到与CSStyle等框架一起工作。在本章中，我们将涵盖多个主题，包括以下内容：
- en: Creating our processor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的处理器
- en: Optimizing the output
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化输出
- en: Adding source map and vendor prefix support
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加源映射和供应商前缀支持
- en: Testing the final preprocessor on a simple site system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个简单的网站系统上测试最终的预处理器
- en: Extending our preprocessor to use the CSStyle framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的预处理器扩展到使用CSStyle框架
- en: Let's make a start!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Creating your processor
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的处理器
- en: Many developers who work with existing processors such as SASS, less, or Stylus
    will be accustomed to working with a library that is a necessary dependency, and
    where it is unlikely that they will be using 100% of the functionality available
    for their chosen processor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多与现有处理器（如SASS、less或Stylus）一起工作的开发者将习惯于使用一个必要的依赖库，并且不太可能使用他们选择的处理器提供的100%的功能。
- en: This is not the case with PostCSS. One of the key attractions is its flexibility;
    gone are the days when we have excess baggage in our processor that is redundant
    for our needs! The power of flexibility can also be a shortcoming, where does
    one start deciding what to include in our processor, I hear you ask?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是PostCSS的情况。一个主要的吸引力是其灵活性；我们不再需要携带那些对我们需求来说是冗余的处理器中的额外负担！灵活性的力量也可能是一个缺点，你可能会问，我们如何开始决定在我们的处理器中包含什么？
- en: Throughout the course of this chapter, we will bring together the various elements
    of the processor we've used in the demos, and work through changes we can make
    to improve or extend functionality. The key, though, to any processor is that
    there is no right or wrong answer; each will be different, and they will depend
    on your requirements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将汇集我们在演示中使用的处理器的各种元素，并探讨我们可以做出的改进或扩展功能的变化。然而，任何处理器的关键在于没有正确或错误答案；每个都会不同，并且它们将取决于你的需求。
- en: As time goes by, it is likely that you will find common elements that can be
    reused between projects, ultimately, it is up to you as the developer to find
    the combination that meets your requirements. This aside, let's begin with a detailed
    look at the processor we've used in recent examples, and explore some of the ideas
    and tips we can use to create our own version.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你可能会发现可以在项目之间重用的常见元素，最终，作为开发者，找到满足你需求的组合取决于你。在此之外，让我们开始详细研究我们在最近示例中使用的处理器，并探索我们可以用来创建我们自己的版本的一些想法和技巧。
- en: Exploring our processor
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索我们的处理器
- en: As part of creating the demos we've worked through in this book, we concentrated
    on ensuring plugins are installed, and that we have the right files in the right
    place. There is something missing though, and that is—what actually happens in
    the files? Why do we have tasks in a particular order? What is the reasoning behind
    choosing some of the plugins that we've used…and so on—you get the idea!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书中创建的演示的一部分，我们专注于确保插件已安装，并且我们有正确的文件在正确的位置。然而，还有一些东西缺失，那就是——文件中实际上发生了什么？为什么我们有特定的任务顺序？选择我们使用的某些插件背后的推理是什么……你大概明白了！
- en: Over the next few pages, we're going to try to answer some of these questions
    (and more), by exploring the processor that we've used in some of the recent examples;
    you will see that there isn't a one-answer-fits-all approach, but more a case
    of working through your requirements, and picking plugins to suit your needs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将通过探索我们在一些最近示例中使用的处理器来尝试回答这些问题（以及更多），你会发现没有一种一刀切的方法，而更多的是根据你的需求进行工作，并选择适合你需求的插件。
- en: Before we go into depth, though, let's just quickly recap the make-up of our
    processor, starting with the `package.json` file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨之前，让我们快速回顾一下我们处理器的组成，从 `package.json` 文件开始。
- en: Dissecting the package.json file
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析 package.json 文件
- en: 'The `package.json` file tells PostCSS which plugins to use, and may contain
    some of the key configuration settings to be used during compilation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 文件告诉 PostCSS 使用哪些插件，并可能包含一些在编译期间使用的键配置设置：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The top half of our processor contains a number of key properties that tell
    us details such as the version, description, who created it, any dependencies,
    and the license being used for the project:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理器的上半部分包含许多关键属性，这些属性告诉我们有关版本、描述、创建者、任何依赖项以及项目使用的许可证等详细信息：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In comparison, the key part for us is in the bottom half; this lists all of
    the plugins that will be used within our project. In many of our projects, we've
    installed the plugin—at point of installation, the plugin will add an entry into
    this file that contains the name and the minimum version required (represented
    by the `^` symbol).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，对我们来说关键部分在底部；这部分列出了我们项目中将使用的所有插件。在我们的许多项目中，我们在安装时安装了插件——插件将添加一个包含名称和所需最小版本（由
    `^` 符号表示）的条目到此文件中。
- en: It is worth noting that we can manually add entries to, or remove entries from
    this file, or even copy `package.json` files from one project to another if needed.
    This is particularly useful if we know that a new project has identical (or very
    similar) requirements to an existing one; plugins will only add an entry into
    this file at installation, if one does not already exist.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们可以手动向此文件添加条目，或从该文件中删除条目，甚至在需要时将 `package.json` 文件从一个项目复制到另一个项目。如果我们知道新项目与现有项目具有相同（或非常相似）的需求，这尤其有用；插件在安装时只会将条目添加到此文件中，如果该条目尚未存在。
- en: Exploring the Gulp task file
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Gulp 任务文件
- en: The `gulpfile.js` file is where the real magic happens—this contains all of
    the tasks that need to be performed on each style sheet within our project. Outside
    of the style sheet, this is the second of two files that we've simply copied across
    from the code download to our project area. Now that we've been using it in anger,
    it's worth taking a moment to explore what happens in more detail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`gulpfile.js` 文件是真正魔法发生的地方——它包含了对我们项目中每个样式表需要执行的所有任务。除了样式表之外，这是我们简单地从代码下载复制到项目区域的第二个文件。现在我们已经在使用它了，值得花点时间更详细地探索它的工作原理。'
- en: 'The `gulpfile.js` file is made up of several sections—in our example, we begin
    with a list of variables that define references to each of our plugins:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`gulpfile.js` 文件由几个部分组成——在我们的示例中，我们从一个定义每个插件的引用变量的列表开始：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first task in our list is the most important one—this picks up and compiles
    the source code into a valid CSS file and deposits it in the `dest` folder. As
    part of this, we provide links to any PostCSS plugin that is needed to transform
    our code—in this example, we''re using Rucksack, set to include fallback support
    but not add vendor prefixes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的第一个任务是最重要的一个——它将源代码拾取并编译成有效的 CSS 文件，并将其存放在 `dest` 文件夹中。作为此过程的一部分，我们提供了任何需要用于转换我们代码的
    PostCSS 插件的链接——在这个例子中，我们使用 Rucksack，设置为包含回退支持但不添加供应商前缀：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This chunky task is less complicated than it looks—it checks our code for consistency,
    based on the rules set; it outputs any warnings or errors on screen using the
    reporter plugin. The key here is the `[''styles'']` attribute—this tells PostCSS
    not to perform this task until the styles task has been completed:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来复杂的任务实际上并不复杂——它根据设置的规则检查我们的代码的一致性，使用报告插件在屏幕上输出任何警告或错误。这里的关键是 `['styles']`
    属性——这告诉 PostCSS 在样式任务完成之前不要执行此任务：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In comparison, the next two tasks are relatively straightforward—this one takes
    care of compressing our compiled code, and renaming it with a `.min.css` extension:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，接下来的两个任务相对简单直接——这个任务负责压缩我们的编译代码，并将其重命名为 `.min.css` 扩展名：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This task is equally straightforward—it creates a source map of our style sheet,
    and sets it in a format that PostCSS can release into a file within the `dest`
    folder of our project area:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务同样简单直接——它创建我们的样式表的源映射，并将其设置为 PostCSS 可以将其发布到我们项目区域 `dest` 文件夹中的文件格式：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last two steps play the most important role in any Gulp task file—the first
    will fire off calls to each of our tasks if we enter `gulp` in a command line
    prompt:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何 Gulp 任务文件中，最后两个步骤扮演着最重要的角色——第一个步骤将在命令行提示符中输入 `gulp` 时触发对每个任务的调用：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This task, although not obligatory, watches out for any changes to our code
    and sets off the tasks in our Gulp file automatically. It will respect any constraints
    set, although for consistency, it is preferable to list the tasks being performed
    in the same order as they are shown in the file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务虽然不是强制性的，但它会监视代码的任何更改，并自动触发 Gulp 文件中的任务。它将尊重任何设置的约束，尽管为了保持一致性，最好按照文件中显示的顺序列出正在执行的任务：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is more to the compilation process than these two files—thought should
    also be given to how we structure our working environment. A quick look at the
    Gulp task file should reveal that we've used a simple in-tray/out-tray approach;
    code is picked up from the `src` folder, and the results placed into the `dest`
    folder at the end of compilation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程不仅仅是这两个文件——我们也应该考虑如何构建我们的工作环境。快速查看 Gulp 任务文件应该会揭示我们已经使用了一个简单的输入/输出方法；代码从
    `src` 文件夹中提取，并在编译结束时将结果放入 `dest` 文件夹。
- en: This is an important part of the process—after all, there is no benefit in using
    PostCSS if we don't give any thought to the structure of our project area! Part
    of this is to maintain separation between source and compiled files, but also
    that we may decide to expand our compilation process to include tasks such as
    shrinking images. There is no right or wrong in how this area should be structured—this
    will be dictated by our project requirements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是流程的重要部分——毕竟，如果我们不对项目区域的结构进行思考，使用 PostCSS 就没有好处！这包括保持源文件和编译文件之间的分离，也可能决定将图像缩小等任务纳入编译过程。在这个区域的结构上没有对错之分——这将由我们的项目需求决定。
- en: Dissecting issues with our processor
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析处理器的问题
- en: 'With a Gulp task file and associated `package.json` file in place, we should
    be good to go, right? Well, not quite—yes, our processor has been used on demos
    throughout the book to great effect. But there is more that we can do: our Gulp
    file should never be static; we should always look to review it periodically,
    to ensure it is working at optimal efficiency.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了 Gulp 任务文件和相关的 `package.json` 文件后，我们应该可以顺利进行了，对吧？嗯，并不完全是这样——是的，我们的处理器在整本书的演示中都被使用，效果很好。但我们可以做得更多：我们的
    Gulp 文件永远不应该是静态的；我们应该定期审查它，以确保它以最佳效率运行。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To see an updated version of our Gulp file, take a look in the `T49 – fixing
    issues in Gulpfile` folder within the code download that accompanies this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Gulp 文件的更新版本，请查看随本书提供的代码下载中的 `T49 – fixing issues in Gulpfile` 文件夹。
- en: 'Our Gulp file does have a few issues we need to address, so let''s look at
    these now:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目 Gulp 文件确实存在一些需要解决的问题，所以现在让我们来看看这些问题：
- en: Some of our tasks are not correctly named—for example, the styles task could
    be renamed to better reflect that we're using Rucksack in this task.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的一些任务命名不正确——例如，样式任务可以被重命名为更好地反映我们在该任务中使用 Rucksack。
- en: There is a question about the use of source maps; so far we've used a dedicated
    source map plugin to create them. An upcoming change in Gulp 4 will reduce the
    need for a plugin—support for creating them is being added to Gulp core, so a
    separate plugin won't be required so often!
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于源映射的使用有一个问题；到目前为止，我们使用了一个专用的源映射插件来创建它们。Gulp 4 的即将到来的更改将减少对插件的需求——创建它们的支持被添加到
    Gulp 核心中，因此不需要经常使用单独的插件！
- en: In the rename task, we've hard-coded a `style.min.css` filename as the output;
    this isn't going to suit all requirements, so we should change this to make it
    dynamic.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重命名任务中，我们硬编码了一个 `style.min.css` 文件名作为输出；这并不适合所有需求，所以我们应该将其改为动态的。
- en: Staying with the rename task—we're combining two tasks, when they should be
    split into two separate processes.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重命名任务中保持——我们将两个任务合并在一起，而它们应该被分成两个独立的过程。
- en: Take a look at the processor list within the styles task at line 16; this isn't
    too bad now, but over time it could become long and awkward to read! Instead,
    we need to change it so that at the point of calling PostCSS, we can use an array
    instead to provide the names.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看一下第 16 行样式任务中的处理器列表；现在这还不算太糟糕，但长期来看，它可能会变得很长且难以阅读！相反，我们需要更改它，以便在调用 PostCSS
    的点上，我们可以使用数组来提供名称。
- en: When creating source maps, our current setup provides both a full fat and minified
    version; is this really necessary? The issue comes from `cssnano`, which is compressing
    every `.css` file it sees; this isn't necessary, so needs to be changed.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建源映射时，我们当前的设置提供了完整和压缩版本；这真的有必要吗？问题来自 `cssnano`，它会压缩它看到的每一个 `.css` 文件；这不是必要的，所以需要更改。
- en: The use of `cssnano` that should be run as a task within PostCSS is causing
    issues—even though it would make sense to run it this way, it needs to be run
    independently, to satisfy our needs.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`cssnano`的使用作为PostCSS中的一个任务运行正在引起问题——尽管以这种方式运行是有道理的，但它需要独立运行，以满足我们的需求。
- en: We should make a decision on whether we use a dedicated plugin for providing
    vendor prefix support, or rely on the use of other plugins that may have this
    built in already.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该决定是否使用一个专门的插件来提供供应商前缀支持，还是依赖使用可能已经内置了这一功能的其他插件。
- en: When compiling source files, our processor is producing two minified files;
    one is correctly named, but the other is meant to be the uncompressed version
    for development purposes.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译源文件时，我们的处理器正在生成两个最小化文件；一个是正确命名的，但另一个是为了开发目的而打算的不压缩版本。
- en: Over the next few pages, we will explore ways of fixing and improving our Gulp
    task file—it's key to understand that whilst many of these changes are specific
    to our task file, they are ones that may crop up for your future projects. Above
    all, it is essential that we should continually review our production process
    to ensure it is working as needed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将探讨修复和改进我们的Gulp任务文件的方法——关键是要理解，虽然许多这些更改是针对我们的任务文件的，但它们也可能是你未来项目可能会遇到的问题。最重要的是，我们应该不断审查我们的生产过程，以确保它按需工作。
- en: Let's begin the process of fixing and improving our Gulp file before we put
    it to test on a sample site.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将Gulp文件放在一个示例网站上测试之前，让我们开始修复和改进Gulp文件的过程。
- en: Fixing our Gulp task file
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复我们的Gulp任务文件
- en: It has to be said that there are a few issues we need to resolve—the key here
    is that none of them will stop our compilation process; we should consider them
    more as rough edges on a diamond, which need polishing to make our process sparkle
    (pun intended!).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不得不说，我们有一些问题需要解决——关键在于这些问题都不会阻止我们的编译过程；我们应该把它们看作是钻石的粗糙边缘，需要抛光才能使我们的过程更加闪耀（当然，这里是一个双关语！）。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note, the line numbers in the next exercise refer to the *unmodified
    version* of the source code from the `T48 – existing processor` folder, prior
    to making any changes. If you want to keep existing copies of files, please move
    them prior to starting the exercise.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，下一项练习中的行号指的是来自`T48 – existing processor`文件夹的源代码的*未修改版本*，在做出任何更改之前。如果您想保留现有文件的副本，请在开始练习之前将它们移动。
- en: 'Okay, let''s get cracking: there are a few changes to make, so we will start
    with the key task, which compiles the source file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始吧：有一些更改要做，所以我们将从关键任务开始，该任务编译源文件：
- en: For this process, we need a copy of the `gulpfile.js` file from the `T48 – existing
    processor` folder within the code download that accompanies this book; go ahead
    and save it as `gulpfile.js` at the root of our project area.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了这个过程，我们需要从代码下载中的`T48 – existing processor`文件夹中的`gulpfile.js`文件的副本；请将其保存为`gulpfile.js`到我们的项目区域根目录。
- en: The first change we need to make is to enable `autoprefixer` support in the
    file—you should find it there but commented out on line 5; go ahead and remove
    the comment.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一个更改是启用文件中的`autoprefixer`支持——你应该在那里找到它，但在第5行被注释掉了；请继续移除注释。
- en: 'On or around line 16, look for this line:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第16行或附近，寻找以下行：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re not going to include fallback support, and will take care of `autoprefixer`
    separately, so for now, alter it as shown:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不会包括回退支持，并将单独处理`autoprefixer`，所以现在，按照以下方式更改它：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our next change is in the lint-styles task—two changes are required here; first,
    add this block at line 13, below the declaration for Rucksack:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来的更改是在lint-styles任务中——这里需要两个更改；首先，在Rucksack声明下方第13行添加以下代码块：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, go ahead and replace the entire lint-styles task with this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将整个lint-styles任务替换为以下内容：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the rename task, we have three changes to make—first, remove the `cssnano`
    line at line 38; we're splitting the task into two, and this will be handled in
    a new task.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重命名任务中，我们需要进行三个更改——首先，在第38行删除`cssnano`行；我们将任务拆分为两个，这将在新任务中处理。
- en: 'This task has a prerequisite, which we''ve renamed—go ahead and change line
    36 to this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个任务有一个先决条件，我们已经将其重命名——请将第36行改为以下内容：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, alter the rename command as indicated—this is on line 39:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照指示更改重命名命令——这是在第39行：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the next task, `sourcemap`, we have one alteration to make—on or around
    line 47, change this line as shown:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个任务`sourcemap`中，我们需要进行一个更改——在第47行或附近，按照以下方式更改该行：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ve talked about splitting out the minification task—go ahead and add this
    below the `sourcemap` task:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经讨论了将最小化任务拆分出来——请在此处的`sourcemap`任务下方添加以下内容：
- en: '[PRE16]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ve made changes to the task names, so we need to update the default task
    and watch facility—look for the string of names in square brackets on or around
    lines 50 and 52\. Replace it with this string:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经更改了任务名称，因此我们需要更新默认任务和监视设施——在 50 行和 52 行附近或周围查找方括号中的名称字符串。将其替换为以下字符串：
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our watch task can also be put on a diet—there is no need to specify all of
    the tasks twice! Instead, go ahead and change the code as indicated—when changes
    are made, the watch facility will run the default task, which already has the
    requisite tasks:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的任务监视器也可以进行减肥——没有必要两次指定所有任务！相反，按照指示更改代码——当进行更改时，监视设施将运行默认任务，该任务已经包含了必要的任务：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''re almost done—there are some additional declarations we need to add at
    the top of our file, to ensure everything works as expected. Below the `stylerules`
    declaration added in step *4*, go ahead and add these extra lines:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了——我们还需要在文件顶部添加一些额外的声明，以确保一切按预期工作。在步骤 *4* 中添加的 `stylerules` 声明下方，继续添加以下额外行：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We now have an updated Gulp task file—we now need to copy the `style.css` from
    the `src` folder under `T49 – fixing issues in Gulpfile` to the `src` folder at
    the root of our project area. If all is well, we should have something akin to
    this in the `dest` folder of our project area when we compile our file, and a
    file named `style.css.map` in the maps folder:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个更新的 Gulp 任务文件——我们现在需要将 `style.css` 从 `T49 – fixing issues in Gulpfile`
    下的 `src` 文件夹复制到我们项目区域的根目录下的 `src` 文件夹。如果一切顺利，当我们编译文件时，我们项目区域的 `dest` 文件夹中应该会有类似的内容，并且在地图文件夹中有一个名为
    `style.css.map` 的文件：
- en: '![Fixing our Gulp task file](img/BO5194_10_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![修复我们的 Gulp 任务文件](img/BO5194_10_01.jpg)'
- en: At this point, I am sure you will have a few questions about some of the changes
    we've made—the demo highlights a few key points, so it's worth taking time out
    to explore these in more detail.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我相信你们肯定对我们所做的某些修改有一些疑问——演示突出了几个关键点，所以花时间详细探索这些内容是值得的。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you come across any issues with changing the gulp file, then check out a
    completed version in the `T49 - fixing issues in Gulpfile` folder in the code
    download that accompanies this book.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在更改 gulp 文件时遇到任何问题，请查看本书附带的代码下载中 `T49 - fixing issues in Gulpfile` 文件夹中的完整版本。
- en: Understanding the changes made
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解所做的更改
- en: Throughout the course of our demo, we made a number of changes to our Gulp task
    file—the key thing to note is that none of them are compulsory. Our task file
    worked perfectly well prior to making the changes, so if they aren't compulsory,
    why are we making them?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示过程中，我们对 Gulp 任务文件做了一些修改——需要注意的是，这些修改都不是强制性的。在做出这些修改之前，我们的任务文件运行得非常完美，所以如果不是强制性的，我们为什么要做出这些修改呢？
- en: The answer to this is simple—using a task runner such as Gulp is about automating
    processes so that you arrive at just the content you need. We had that, but the
    task runner produced extra files, didn't compress them as expected, and our Gulp
    file contained tasks that had multiple steps within the same task. The work we
    completed was about adding polish to the process—although our Gulp task file worked,
    we explored how we could improve on it by tweaking some of the processes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案很简单——使用像 Gulp 这样的任务运行器是为了自动化流程，以便你得到所需的内容。我们已经有这个了，但任务运行器产生了额外的文件，没有按预期压缩它们，并且我们的
    Gulp 文件中包含了在同一任务内有多个步骤的任务。我们完成的工作是给这个过程添加一些润色——尽管我们的 Gulp 任务文件可以工作，但我们探索了如何通过调整一些流程来改进它。
- en: We kicked off with changes to how vendor prefixes were added—our existing task
    completed this as part of compiling using the Rucksack plugin. The Rucksack plugin
    was to provide fallback support—I'm not a fan of working with older browsers,
    so we don't need it. This makes it less beneficial to incorporate vendor prefix
    support from such a large plugin, thus support is not enabled.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从修改添加供应商前缀的方式开始——我们现有的任务在编译时使用 Rucksack 插件来完成这一部分。Rucksack 插件是为了提供回退支持——我不喜欢与旧浏览器一起工作，所以我们不需要它。这使得从这样一个大型插件中整合供应商前缀支持变得不那么有益，因此支持未启用。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is another plugin available for PostCSS that handles vendor prefixes—`doiuse`,
    available at [https://github.com/anandthakker/doiuse](https://github.com/anandthakker/doiuse).
    Just another option to try!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PostCSS，还有一个处理供应商前缀的插件可用——`doiuse`，可在 [https://github.com/anandthakker/doiuse](https://github.com/anandthakker/doiuse)
    找到。只是另一个尝试的选项！
- en: The lint-styles task worked well—the changes we made focus on making the code
    easier to read in the task file. We moved the configuration block to the start
    of the file, and rearranged the format of the task; this means that we should
    not have to change the task, even though we may change the configuration!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: lint-styles 任务运行良好——我们所做的更改集中在使任务文件中的代码更容易阅读。我们将配置块移动到文件开头，并重新排列了任务的格式；这意味着我们不应该需要更改任务，即使我们可能更改配置！
- en: Most of the remaining changes focus on splitting multiple roles into single
    tasks, and correcting some anomalies in the output. Our compilation process produced
    a minified file with the right extension, but also minified the original source
    file. We also had two source map files produced in a similar fashion—this is clearly
    not ideal! The changes we made now mean that our original source file is not minified,
    but only one minified file is produced, and that we have a single uncompressed
    style sheet created during the process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数剩余的更改集中在将多个角色拆分为单个任务，并纠正输出中的一些异常。我们的编译过程生成了一个带有正确扩展名的压缩文件，但也压缩了原始源文件。我们还以类似的方式生成了两个源映射文件——这显然不是理想的！我们现在所做的更改意味着我们的原始源文件没有被压缩，但只生成了一个压缩文件，并且在过程中创建了一个单一的未压缩样式表。
- en: Perfect, we now have a polished compilation process, which is producing the
    right files at the appropriate point; what next? Well, we can now add additional
    functionality to our compilation process. Using a task runner such as Gulp is
    about automating menial tasks, so let's explore what we might achieve in more
    detail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 完美，我们现在有一个经过抛光的编译过程，在适当的时候生成正确的文件；接下来是什么？好吧，我们现在可以向我们的编译过程添加额外的功能。使用任务运行器如 Gulp
    是关于自动化繁琐的任务，让我们更详细地探索我们可以实现什么。
- en: Optimizing the output
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化输出
- en: The PostCSS system will quite happily play nicely with other plugins, be they
    Gulp-based, or using another task runner such as Grunt or Broccoli. This opens
    up a real world of possibilities, limited only by your imagination! There is one
    small but important point, though—it makes it crucial that we not only optimize
    our processor output (as we have done), but also fine tune it to ensure that we've
    added functionality that suits our needs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS 系统将非常乐意与其他插件友好地协作，无论是基于 Gulp 的，还是使用其他任务运行器，如 Grunt 或 Broccoli。这打开了一个真实世界中的可能性，仅限于您的想象力！不过，有一个小但重要的观点——它使得我们不仅优化处理器输出（如我们所做的），而且还需要对其进行微调，以确保我们添加了符合我们需求的功能。
- en: 'So, what can we add? Well, here''s a starter for ten: how about compressing
    images? Another common task relates to adding responsive content—we''ve already
    covered this earlier in the book with the `postcss-responsive-type` plugin. We
    could take that further, by adding a task that resizes images automatically to
    different sizes; we can then use these as appropriate in a responsive site.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们可以添加什么呢？好吧，这里有一个起点：压缩图片怎么样？另一个常见任务与添加响应式内容相关——我们在本书中已经使用 `postcss-responsive-type`
    插件对此进行了介绍。我们可以进一步扩展，通过添加一个自动调整图片大小的任务；然后我们可以根据需要将这些图片用于响应式网站。
- en: Ultimately, it is up to you—as time goes by and you get more accustomed to using
    PostCSS, then it is likely that you will find yourself using some plugins more
    than others. The key here, though, is *not* about simply adding in plugins haphazardly—instead,
    we're looking for plugins that we would use regularly in our development workflow,
    and can form the basis of a baseline processor. Any additional functionality that
    is needed to support a particular project can then be added at the appropriate
    time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这取决于您——随着时间的推移，您越来越习惯使用 PostCSS，您可能会发现自己比其他插件更频繁地使用某些插件。不过，这里的关键并不是简单地随意添加插件——相反，我们正在寻找那些我们会在我们的开发工作流程中经常使用的插件，并可以作为基本处理器的基石。任何需要支持特定项目的附加功能都可以在适当的时候添加。
- en: A great place to look is the PostCSS plugin directory at [http://postcss.parts](http://postcss.parts)—it's
    worth taking a look to see what is there, and giving them a try! To get us started,
    we're going to work through a few ideas that are likely to be useful additions
    to your processor, beginning with improving support for source maps.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的查找地方是 PostCSS 插件目录，位于 [http://postcss.parts](http://postcss.parts)——看看那里有什么，尝试一下是值得的！为了让我们开始，我们将探讨一些可能对您的处理器有用的想法，首先是改进对源映射的支持。
- en: Altering our source map support
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改我们的源映射支持
- en: 'If we take a look back at our gulp file prior to completing the exercise in
    *Fixing our gulp task file*, we can see it worked, but it suffered from a major
    drawback. The compilation process produced an extra source map which was minified
    by name, but not in reality! This is clearly something we didn''t need—the changes
    made to this task transformed it into what we have now:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下在*修复我们的gulp任务文件*练习之前我们的gulp文件，我们可以看到它确实工作，但它有一个主要的缺点。编译过程产生了一个额外的源映射文件，按名称进行了压缩，但实际上并没有！这显然是我们不需要的东西——对这个任务所做的更改将其转变成了我们现在拥有的样子：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a much better version—it only produces one source map file, which is
    not compressed; compression is not needed. That being said, we can still improve
    on it; it's simply a matter of working through the documentation to really explore
    what is available, and see if it can help us. As a starter, try this for size.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好的版本——它只产生一个源映射文件，该文件未压缩；不需要压缩。话虽如此，我们仍然可以改进它；这只是一个通过查阅文档真正探索可用内容，并看看它是否可以帮助我们的简单问题。作为起点，尝试这个。
- en: 'There may be instances where we need control over the full URL when compiling
    our code and creating the source map, for example, if we''re transferring from
    a test environment to a production one. In an ideal world, we would use a relative
    file structure to avoid this issue, but for those occasions where this isn''t
    possible, a simple change to our Gulp task will suffice:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译我们的代码和创建源映射时，我们可能需要控制完整的URL，例如，如果我们正在从测试环境转移到生产环境。在理想的世界里，我们会使用相对文件结构来避免这个问题，但对于那些不可能的情况，对我们的Gulp任务进行简单的更改就足够了：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see the result in this screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面的屏幕截图中看到结果：
- en: '![Altering our source map support](img/BO5194_10_02.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![修改我们的源映射支持](img/BO5194_10_02.jpg)'
- en: Ultimately, the requirements for our projects will determine how source map
    support needs to be configured—we may even have to go as far as compiling multiple
    files into one larger master file, if our project requirements dictate.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们项目的需求将决定源映射支持需要如何配置——如果我们的项目需求要求，我们甚至可能需要将多个文件编译成一个更大的主文件。
- en: There's one thing to bear in mind, though—there are plans to include native
    source map support in Gulp 4; this will likely mean that the need for a separate
    plugin will become redundant. It pays to keep abreast of changes, particularly
    if it might affect our processor!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一点需要注意——计划在Gulp 4中包含原生源映射支持；这可能会意味着不再需要单独的插件。了解变化是有益的，尤其是如果它可能影响我们的处理器！
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For a completed version of our Gulp file, which includes these changes, take
    a look at the `T50 - adjusting source map settings` folder in the code download
    that accompanies this book.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含这些更改的我们的Gulp文件的完整版本，请查看随本书附带的代码下载中的`T50 - 调整源映射设置`文件夹。
- en: Let's change tack at this point, changing the source map compilation process
    was a straightforward alteration. We can take it up a notch with another key area—vendor
    prefixes. We've already covered the basics, so we'll take a look at how we can
    improve support.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，让我们改变策略，改变源映射编译过程是一个简单的修改。我们可以通过另一个关键领域——供应商前缀来提高一个档次。我们已经涵盖了基础知识，所以我们将看看我们如何可以改进支持。
- en: Taking care of prefixes
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意前缀
- en: 'Aha, prefixes! The bane of any designer: adding them and keeping them up to
    date can be a real chore.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，前缀！任何设计师的噩梦：添加它们并保持它们更新确实是一项真正的苦差事。
- en: 'The `autoprefixer` task that has already featured throughout these pages goes
    some way to reducing the burden: it will add the current prefixes and remove any
    that are no longer needed. This is good…but we can do better! This time around,
    though, the emphasis is less on code, and more on the kinds of decisions we need
    to make:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 已经在这些页面中出现的`autoprefixer`任务有助于减轻负担：它会添加当前的前缀并移除不再需要的任何前缀。这很好……但我们能做得更好！然而，这次的重点更少在于代码，而更多在于我们需要做出的决策：
- en: 'What browser versions do you need to support? The `autoprefixer` plugin already
    uses data from [http://caniuse.com/](http://caniuse.com/), which is sufficient
    for most requirements. However, we can tweak our code to use Browserslist (hosted
    at [https://github.com/ai/browserslist](https://github.com/ai/browserslist)) to
    determine which versions to support. For example, we might add *> 5%* to limit
    support to browsers which have over *5%* of global use:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要支持哪些浏览器版本？`autoprefixer`插件已经使用了来自[http://caniuse.com/](http://caniuse.com/)的数据，这对于大多数需求来说已经足够了。然而，我们可以调整我们的代码以使用Browserslist（托管在[https://github.com/ai/browserslist](https://github.com/ai/browserslist)），以确定要支持哪些版本。例如，我们可能添加`>
    5%`来限制支持到全球使用率超过`5%`的浏览器：
- en: '[PRE22]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In an ideal world, I would push that as high as 10%, but that might be taking
    it too far!
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，我会将其提高到10%，但这可能有点过分了！
- en: 'From a consistency perspective, we should make it clear that `autoprefixer`
    is `disabled` from within Rucksack—my preference is not to enable it there, as
    it can get confusing as to which plugin is adding prefixes (given that `cssnano`
    can add them too). To correct this, all we need to do is to change this line:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一致性的角度来看，我们应该明确指出`autoprefixer`在Rucksack内部是`禁用`的——我的偏好是不在那里启用它，因为它可能会让人混淆，不知道哪个插件添加了前缀（考虑到`cssnano`也可以添加前缀）。为了纠正这一点，我们只需要更改这一行：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It''s not obligatory, but it at least makes it clear! If we wanted to be real
    purists, we would split this task into two separate ones, so that we''re keeping
    to the one task: one role mantra:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是强制性的，但至少能使其清晰！如果我们想真正成为纯粹主义者，我们会将这项任务分成两个独立的任务，这样我们就能保持一个任务：一个角色咒语：
- en: 'Although `autoprefixer` handles the removal of redundant prefixes, there is
    a useful trick we can use: add support for the `postcss-remove-prefixes` and `postcss-unprefix`
    plugins. The reason for this is simple—we may well not have a level playing field
    when running `autoprefixer`, where some vendor prefixes may be missing from our
    code. Adding these two plugins ensures that our code is as terse as possible prior
    to running `autoprefixer`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然`autoprefixer`可以处理冗余前缀的移除，但我们有一个有用的技巧可以使用：添加对`postcss-remove-prefixes`和`postcss-unprefix`插件的支援。这样做的原因很简单——在运行`autoprefixer`时，我们可能并不在一个公平的竞争环境中，因为我们的代码中可能缺少一些供应商前缀。添加这两个插件确保我们的代码在运行`autoprefixer`之前尽可能简洁。
- en: If our code is based on using SASS, then there is a good chance that the Compass
    library is being used—it is worth checking to see if this is being used to add
    vendor prefixes. If it is, it may be worth switching to using `autoprefixer`,
    as it is reported to be more efficient at removing code. Don't forget that we
    can compile SASS code within our Gulp file at the same time as running PostCSS
    plugins—we will explore more of this later in this book.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的代码基于使用SASS，那么有很大可能性正在使用Compass库——检查一下是否正在使用它来添加供应商前缀是有意义的。如果是的话，可能值得切换到使用`autoprefixer`，因为它报告称在移除代码方面更有效率。别忘了我们可以在运行PostCSS插件的同时在Gulp文件中编译SASS代码——我们将在本书的后面更详细地探讨这一点。
- en: It goes without saying that vendor prefixes continually change; with careful
    planning and the right use of plugins, we can be safe in the knowledge that no
    matter what happens, our code will be updated at the next compilation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商前缀不断变化是不言而喻的；通过仔细规划和正确使用插件，我们可以放心地知道，无论发生什么，我们的代码将在下一次编译时得到更新。
- en: 'Now, moving on: I am sure you are familiar with the ubiquitous pseudo-selector,
    such as hover. This is one area where we need to carefully consider what we might
    incorporate into our baseline processor; PostCSS has a number of plugins that
    can facilitate handling pseudo-selectors in our code. Let''s take a look at this
    in more detail.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进：我相信您对无处不在的伪选择器，如hover，已经很熟悉了。这是我们仔细考虑可能纳入基本处理器的内容的一个领域；PostCSS有几个插件可以帮助我们在代码中处理伪选择器。让我们更详细地看看这一点。
- en: Adding support for pseudo-selectors
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加对伪选择器的支持
- en: When designing sites, pseudo-selectors are a key part of providing interaction—they
    can be anything from the simple hover, all the way through to newer elements such
    as :range or :placeholder. We also have to be mindful of support—thankfully most
    elements will work in reasonably recent browsers (yes, even IE8!), but not all
    browsers use the same format of single or double colons when referencing the selector
    in CSS.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计网站时，伪选择器是提供交互的关键部分——它们可以是简单的悬停，一直到更新的元素，如:range或:placeholder。我们还得注意兼容性——幸运的是，大多数元素在合理近期的浏览器中都能正常工作（是的，甚至IE8！），但不是所有浏览器在引用CSS中的选择器时都使用相同的单冒号或双冒号格式。
- en: 'To help with both styling and providing consistency, PostCSS has a number of
    options we can use; we will explore using the `postcss-pseudo-elements-content`
    plugin in a moment, but for now, let''s take a quick look at some of the options
    to give you a flavor of what is available:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助样式化和提供一致性，PostCSS提供了一些我们可以使用的选项；我们将在稍后探索使用`postcss-pseudo-elements-content`插件，但现在，让我们快速看看一些选项，以给你一个可用的感觉：
- en: Do you often find yourself adding the `focus` pseudo-selector to your code?
    If the answer is yes, then the `postcss-focus` plugin will be of interest. Available
    from [https://github.com/postcss/postcss-focus](https://github.com/postcss/postcss-focus),
    this plugin will add a `focus` pseudo-selector automatically, when compiling code.
    The styles will be the same as the `:hover` element.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你经常发现自己需要在代码中添加`focus`伪选择器吗？如果答案是肯定的，那么`postcss-focus`插件可能会引起你的兴趣。该插件可在[https://github.com/postcss/postcss-focus](https://github.com/postcss/postcss-focus)找到，当编译代码时，它会自动添加`focus`伪选择器。样式将与`:hover`元素相同。
- en: We've just talked about adding a `focus` element automatically—the developer
    Jonathan Neal had the idea of creating a polyfill to add support for an `:enter
    pseudo-selector`, which would replace both :hover and :focus within code. When
    compiled, the code would transpile any instance of `:enter` into `:hover` and
    `:active` styles in our code. Head over to [https://github.com/jonathantneal/postcss-pseudo-class-enter](https://github.com/jonathantneal/postcss-pseudo-class-enter)
    for more details on this plugin.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了自动添加`focus`元素——开发者Jonathan Neal有了一个想法，创建一个polyfill来添加对`:enter`伪选择器的支持，这将替换代码中的`:hover`和`:focus`。当编译时，代码会将任何`:enter`实例转换为我们的代码中的`:hover`和`:active`样式。前往[https://github.com/jonathantneal/postcss-pseudo-class-enter](https://github.com/jonathantneal/postcss-pseudo-class-enter)了解更多关于此插件的信息。
- en: This next plugin could be euphemistically described as being one for those who
    have better things to do than write styles for links…. In plain speak, this is
    a real shortcut of a plugin! It adds styles for *all* of the link-related classes
    automatically; browse to [https://github.com/jedmao/postcss-all-link-colors](https://github.com/jedmao/postcss-all-link-colors)
    for an example of how to be really lazy…
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个插件可以被委婉地描述为为那些有比编写链接样式更好的事情要做的人准备的。简单来说，这是一个真正的插件快捷方式！它会自动为所有与链接相关的类添加样式；浏览到[https://github.com/jedmao/postcss-all-link-colors](https://github.com/jedmao/postcss-all-link-colors)查看如何真正地偷懒的例子...
- en: 'For those of you who regularly have to style form buttons (and face it, who
    doesn''t?), then this next plugin from [https://github.com/andrepolischuk/postcss-pseudo-class-any-button](https://github.com/andrepolischuk/postcss-pseudo-class-any-button)
    will be of interest: it allows us to use the `:any-button` selector (which isn''t
    an official selector). When compiled, it transpiles this into four different types—plain
    button and three inputs (reset, submit, and button).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于那些经常需要为表单按钮添加样式（说实话，谁不是呢？），那么来自[https://github.com/andrepolischuk/postcss-pseudo-class-any-button](https://github.com/andrepolischuk/postcss-pseudo-class-any-button)的下一个插件可能会引起你的兴趣：它允许我们使用`:any-button`选择器（这不是一个官方选择器）。当编译时，它会将其转换为四种不同类型——普通按钮和三个输入（重置、提交和按钮）。
- en: 'This is just a small selection of the handful of plugins currently available
    in the PostCSS ecosystem, for handling pseudo-selectors. We can talk about using
    them, but in reality, the best way to understand their usefulness is to see them
    in action! With this in mind, let''s take a look at one in action: `postcss-pseudo-elements-content`.
    This little beauty has but one purpose in life: to add a content: attribute to
    appropriate pseudo-selectors, if one is not present in our code.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是PostCSS生态系统中目前可用的少量插件中的一小部分，用于处理伪选择器。我们可以讨论如何使用它们，但现实中，了解它们有用性的最好方法是看到它们在实际中的应用！考虑到这一点，让我们看看一个实际应用的例子：`postcss-pseudo-elements-content`。这个小巧的插件只有一个目的：在我们的代码中，如果适当的选择器没有添加`content:`属性，就添加这个属性。
- en: Updating our code
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的代码
- en: There are a few examples of plugins that help handle pseudo-selectors better;
    our projects will dictate whether we should use them on a per case basis, or can
    incorporate some or all of them into our baseline processors.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个插件示例可以帮助更好地处理伪选择器；我们的项目将决定我们是否应该根据每个案例使用它们，或者可以将其中一些或全部集成到我们的基本处理器中。
- en: 'One example that might suit being added to our baseline processor is postcss-pseudo-elements-content,
    which is available from [https://github.com/omgovich/postcss-pseudo-elements-content](https://github.com/omgovich/postcss-pseudo-elements-content).
    This simple plugin parses our code and will add a content: '''' statement to our
    code, when it sees instances of appropriate pseudo-selectors. It doesn''t require
    any configuration, so without further ado, let''s get stuck into using it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '可能适合添加到我们的基本处理器的一个例子是`postcss-pseudo-elements-content`，它可以从[https://github.com/omgovich/postcss-pseudo-elements-content](https://github.com/omgovich/postcss-pseudo-elements-content)获取。这个简单的插件解析我们的代码，并在看到适当的伪选择器实例时，将`content:
    ''''`语句添加到我们的代码中。它不需要任何配置，所以无需多言，让我们开始使用它：'
- en: We'll start as always with installing the plugin—for this, fire up a Node.js
    command prompt window and change the working folder to our project area.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样从安装插件开始——为此，打开一个Node.js命令提示符窗口，并将工作文件夹更改为我们的项目区域。
- en: 'In the prompt, go ahead and run this command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中，运行此命令：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If all is well, we should see something akin to this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该会看到类似以下内容：
- en: '![Updating our code](img/BO5194_10_03.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![更新我们的代码](img/BO5194_10_03.jpg)'
- en: From a copy of the code download that accompanies this book, extract a copy
    of `style.css` and `content.html` from the `T51 - adding before and after content`
    folder. Save the style sheet to the `src` folder, and the `content.html` to the
    root of our project area.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书附带的代码副本中，从`T51 - 添加前后内容`文件夹中提取`style.css`和`content.html`。将样式表保存到`src`文件夹中，将`content.html`保存到我们项目区域的根目录。
- en: 'Open up a copy of `gulpfile.js` that is at the root of our project area, then
    add this line in at line 11:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于我们项目区域根目录的`gulpfile.js`副本，然后在第11行添加此行：
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A little further down, we need to update our first task to allow for the additional
    plugin; go ahead and alter the line as indicated:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一点更往下，我们需要更新我们的第一个任务以允许额外的插件；按照指示更改该行：
- en: '[PRE26]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the Node.js command prompt, enter `gulp` then press *Enter*—if all is well,
    we should see our style sheet files and source map appear in the `dest` folder.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Node.js命令提示符中输入`gulp`然后按*Enter*键——如果一切顺利，我们应该会在`dest`文件夹中看到我们的样式表文件和源映射。
- en: Copy the contents of this folder to the `css` folder at the root of our project
    areas; if we preview `content.html`, we should see our menu appear:![Updating
    our code](img/BO5194_10_04.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件夹的内容复制到我们项目区域根目录的`css`文件夹中；如果我们预览`content.html`，我们应该会看到我们的菜单出现：![更新我们的代码](img/BO5194_10_04.jpg)
- en: 'In a sense, this could be treated as a shortcut plugin (in a similar fashion
    to ones we worked with earlier in the book). The magic happens by adding `–c`
    after our pseudo-selector, as shown in this code extract:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，这可以被视为一个快捷插件（与我们在本书早期使用的方式类似）。魔法在于在伪选择器后添加`–c`，如图中代码片段所示：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When compiled, it adds the `content: ''''` attribute, as shown in this screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '当编译时，它会添加`content: ''''`属性，如图所示：'
- en: '![Updating our code](img/B05194_10_12.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![更新我们的代码](img/B05194_10_12.jpg)'
- en: Although it is debatable whether it is worth adding a plugin for something this
    small, it does at least ensure that we keep a consistent code base when compiling
    our style sheet.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然是否值得为这么小的事情添加插件是有争议的，但它至少确保我们在编译样式表时保持一致的代码库。
- en: The real decision is whether your code has sufficient instances of pseudo-selectors
    to warrant installing these plugins as part of a baseline, or if your projects
    dictate their use on a case-by-case basis.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的决定是，你的代码是否有足够的伪选择器实例，值得将插件作为基本部分安装，或者如果你的项目需要根据具体情况使用。
- en: Let's change tack, most of the improvements we've covered relate to text. Text
    sites can be very unappealing without images—thankfully, there are some plugins
    available to help extend our baseline processor, and better manage images. I feel
    a demo coming on, so let's go explore this in more detail.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变一下方向，我们之前提到的多数改进都与文本相关。没有图像的文本站点可能非常不吸引人——幸运的是，有一些插件可以帮助扩展我们的基本处理器，并更好地管理图像。我感觉一个演示即将到来，所以让我们更详细地探索这一点。
- en: Dealing with images
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理图像
- en: If we were to consider our processor as being solely for compiling PostCSS code,
    then we are selling ourselves short—we've already covered how the use of a task
    runner such as Gulp allows us to add additional tasks such as `autoprefixer` and
    `cssnano`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将处理器视为仅用于编译PostCSS代码，那么我们可能低估了自己——我们已经介绍了如何使用Gulp这样的任务运行器添加额外的任务，如`autoprefixer`和`cssnano`。
- en: 'A great one to consider adding is the ability to compress our images for optimum
    size; would you want to do this manually, no matter how much or how little might
    be saved in size? I thought not. Automating this process means we can get on with
    tasks that add more value to the process. We can achieve this with the `gulp-imagemin`
    plugin, available from [https://github.com/sindresorhus/gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)—let''s
    take a look at what might be involved in minifying our images:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得考虑添加的功能是压缩我们的图片以获得最佳大小；你愿意手动进行，无论大小节省多少？我想你不会这么做。自动化这个过程意味着我们可以继续进行那些能增加过程价值的任务。我们可以通过来自[https://github.com/sindresorhus/gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)的`gulp-imagemin`插件来实现这一点——让我们看看在最小化我们的图片时可能涉及的内容：
- en: Fire up a Node.js command prompt window, then change the working directory to
    our project area.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个Node.js命令提示符窗口，然后更改工作目录到我们的项目区域。
- en: 'In the prompt, enter both commands, pressing *Enter* after each:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中输入两个命令，每个命令后按*Enter*键：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Keep the prompt open—we will use it again shortly.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持提示符打开——我们很快还会用到它。
- en: From the code download that accompanies this book, go ahead and extract copies
    of the `gulpfile.js` and `package.json` files from the `T52 - optimizing images`
    folder; save these to the root of our project area.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书附带的代码下载中，请从`T52 - optimizing images`文件夹中提取`gulpfile.js`和`package.json`文件的副本；将这些文件保存到我们项目区域的根目录。
- en: Create a folder called `img` at the root of our project folder; this will be
    used as a temporary replacement for the `dest` folder already present.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目文件夹的根目录下创建一个名为`img`的文件夹；这将被用作现有`dest`文件夹的临时替代。
- en: Find some large images—they should be JPEG format, and ideally be several megabytes
    in size; about four to six images will suffice.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找一些大图片——它们应该是JPEG格式，理想情况下大小为几兆字节；大约四到六张图片就足够了。
- en: Go back to the Node.js prompt, then enter `gulp` and press *Enter*—the screenshot
    below shows an example I performed with a handful of images:![Dealing with images](img/BO5194_10_05.jpg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Node.js提示符，然后输入`gulp`并按*Enter*键——下面的截图显示了我在一些图片上执行的一个示例：![处理图片](img/BO5194_10_05.jpg)
- en: If all is well, we should see our newly compressed images in the `img` folder—this
    is a useful task to have within our processor, so let's go through a few points
    in more detail.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在`img`文件夹中看到我们新压缩的图片——这是一个在处理器中非常有用的任务，所以让我们更详细地讨论几个要点。
- en: Exploring the process
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索过程
- en: 'Image compression is key to a performant site—users will be turned off if the
    text appears within a couple of seconds, but images take much longer to appear!
    There are a few points to consider, though, with this approach:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图片压缩是高性能网站的关键——如果文本在几秒钟内出现，用户可能会感到厌烦，但图片出现需要更长的时间！然而，这种方法有几个需要考虑的点：
- en: It's not particularly fast—minifying a dozen images each around 2 MB in size
    isn't too bad, but this isn't going to improve if you have to minify large numbers
    of images.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它并不特别快——压缩大约2MB大小的十几张图片还不错，但如果你需要压缩大量图片，这不会有所改善。
- en: 'We''ve limited our support to JPEG images—it is possible to optimize SVG and
    PNG images, but this will require changes to our code. If we look closely at the
    code used, we can see this:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只支持JPEG图片——优化SVG和PNG图片是可能的，但这将需要更改我们的代码。如果我们仔细查看使用的代码，我们可以看到这一点：
- en: '[PRE29]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The latter plugin is installed automatically by `gulp-imagemin`, and would
    need to be changed if working with SVG or PNG images:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 后者插件由`gulp-imagemin`自动安装，如果处理SVG或PNG图片，则需要更改：
- en: Tests performed locally seem to indicate that the size of reduction isn't as
    good as one might expect; I suspect that this will improve with much larger images.
    It is worth experimenting with changing the compression level—make sure your source
    images are as large as possible!
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地执行的测试似乎表明，尺寸的减少并不像预期的那样好；我怀疑这将在更大的图片上得到改善。尝试改变压缩级别是值得的——确保你的源图片尽可能大！
- en: 'Once our images have been optimized for size, we can then explore further options—here
    are a couple worth considering:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的图片已经针对大小进行了优化，我们就可以探索更多的选项——这里有一些值得考虑的：
- en: In the age of development over multiple devices, we need our images to be responsive;
    the gulp-responsive plugin available from [https://github.com/azat-io/postcss-responsive-images](https://github.com/azat-io/postcss-responsive-images)
    can help create these images.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多设备发展的时代，我们需要我们的图片具有响应性；来自[https://github.com/azat-io/postcss-responsive-images](https://github.com/azat-io/postcss-responsive-images)的gulp-responsive插件可以帮助创建这些图片。
- en: 'We might want to use sprites instead. Thankfully, adding sprite support is
    easy within PostCSS: take a look at the postcss-sprites plugin for this task.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想使用精灵图代替。幸运的是，在PostCSS中添加精灵图支持很容易：查看postcss-sprites插件来完成这项任务。
- en: You may like to consider using an asset manager to resolve URLs—the postcss-assets
    plugin is a perfect candidate for this task. The source and details for using
    are available from [https://github.com/assetsjs/postcss-assets](https://github.com/assetsjs/postcss-assets).
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能想考虑使用资产管理器来解析URLs——postcss-assets插件是这项任务的理想选择。使用方法和详细信息可在[https://github.com/assetsjs/postcss-assets](https://github.com/assetsjs/postcss-assets)找到。
- en: There's an important point to note, though—although plugins are available for
    the purpose, it is not worth considering minifying HTML; it is unlikely that you
    will get any significant space back, and the code will become hard to read. It
    is best to reserve minifying files for those external assets that have to be linked
    to your HTML pages, in order to get the most benefit.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要观点是——尽管有插件可以实现这个目的，但考虑压缩HTML并不值得；你不太可能获得任何显著的空间节省，而且代码将变得难以阅读。最好将压缩文件保留给那些必须链接到你的HTML页面的外部资源，以便获得最大的好处。
- en: 'Okay, let''s move on: before we test our processor, there is one more idea
    that may be worth consideration. Adding an automatic reload capability to our
    code means that we do not need to reload our pages to view updated content. There
    is a heavy reliance on the use of Chrome to make it work, so it won''t be for
    everyone: let''s look at what would be involved in more detail.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续：在我们测试我们的处理器之前，还有一个可能值得考虑的想法。将自动重新加载功能添加到我们的代码意味着我们不需要重新加载页面来查看更新内容。这很大程度上依赖于Chrome的使用来使其工作，所以它可能不是每个人都需要的：让我们更详细地看看这会涉及哪些内容。
- en: Adding reload capabilities
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加重新加载功能
- en: Adding a reload capability reduces the amount of time spent manually reloading
    our pages after a code change; the latter can be a real pain, especially when
    working with complex CSS styles!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 添加重新加载功能可以减少在代码更改后手动重新加载页面所花费的时间；后者可能真的令人头疼，尤其是在处理复杂的CSS样式时！
- en: 'The downside to this is that it only works in Chrome—if this isn''t an issue,
    then these are the steps you would need to follow to make this work:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是它只能在Chrome中工作——如果这不是问题，那么你需要遵循以下步骤来使它工作：
- en: We'll start by extracting copies of the `gulpfile.js` and `package.json` files
    from the `T53 – adding livereload capabilities` folder, from the code download
    that accompanies this book. Save both copies to the root of our project area.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从“T53 – 添加LiveReload功能”文件夹中提取`gulpfile.js`和`package.json`文件的副本，从本书附带的代码下载中。将这两个副本保存到我们项目区域的根目录下。
- en: From the same `T53 – adding livereload capabilities` folder, extract and save
    a copy of the `style.css` file from the `src` folder within, to the `src` folder
    at the root of our project area.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从相同的“T53 – 添加LiveReload功能”文件夹中，提取并保存`src`文件夹内的`style.css`文件副本，到我们项目区域的根目录下的`src`文件夹。
- en: Fire up a Node.js command prompt, then change the working folder to our project
    area.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Node.js命令提示符，然后更改工作文件夹到我们的项目区域。
- en: In the prompt, enter `npm install gulp-livereload –save-dev` and press *Enter*—let
    this install.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中输入`npm install gulp-livereload –save-dev`并按*Enter*——让这个安装完成。
- en: Download and install the Chrome applet for LiveReload from [http://bit.ly/IKI2MY](http://bit.ly/IKI2MY).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://bit.ly/IKI2MY](http://bit.ly/IKI2MY)下载并安装Chrome LiveReload小程序。
- en: 'Add this line at the end of the `sourcemap` task:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sourcemap`任务末尾添加此行：
- en: '[PRE30]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remove the semi-colon at the end of line 60.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除第60行末尾的分号。
- en: 'Add this line to our `watch` task:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此行添加到我们的`watch`任务：
- en: '[PRE31]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our task file will look like this, with the changes made at lines 61 and 68:![Adding
    reload capabilities](img/BO5194_10_06.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的任务文件将如下所示，其中第61行和第68行进行了更改：![添加重新加载功能](img/BO5194_10_06.jpg)
- en: At this point, we can test to ensure it works by making a change to our style
    sheet—if all is well, Gulp will kick in and recompile our code; if we have a site
    open in a browser that we're developing, then this would be automatically reloaded
    by the plugin.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以通过更改样式表来测试它是否工作——如果一切顺利，Gulp将启动并重新编译我们的代码；如果我们正在浏览器中打开我们正在开发的网站，那么插件将自动重新加载。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For those of you interested in using this plugin in more detail, please refer
    to the documentation available on the GitHub site at [https://github.com/vohof/gulp-livereload](https://github.com/vohof/gulp-livereload).
    There is a full version of the code used in this example, within the `T53 - adding
    livereload capabilities` folder in the code download that accompanies this book.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想要更详细地使用此插件的人，请参阅 GitHub 网站上提供的文档，网址为 [https://github.com/vohof/gulp-livereload](https://github.com/vohof/gulp-livereload)。示例中使用的完整代码版本位于本书附带的代码下载中的
    `T53 - 添加 livereload 功能` 文件夹内。
- en: Right, onwards we go! We're almost at the end of our journey through the art
    of the possible; before we move onto testing our processor, I thought I would
    leave you with a few more ideas that you may like to consider using in your processors.
    All of them should install using the same process that we've seen throughout this
    book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，继续前进！我们几乎到达了探索可能的技艺的终点；在我们开始测试我们的处理器之前，我想给你留下一些你可能想要考虑在处理器中使用的新想法。所有这些都应该使用我们在这本书中看到的相同过程进行安装。
- en: Extending our processor further
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步扩展我们的处理器
- en: Over the last few pages, we've explored a number of ways to improve our existing
    processor, as well as a few ideas for extending functionality. Although we can
    always keep to PostCSS plugins, we run the risk of limiting the "art of the possible",
    or what is available for us to use.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几页中，我们探讨了多种改进现有处理器的方法，以及一些扩展功能性的想法。尽管我们总是可以坚持使用 PostCSS 插件，但我们面临的风险是限制“可能的技艺”，或者我们可用的选择。
- en: Sometimes, we might want to go a little further afield—creating a processor
    isn't just about the nitty-gritty of compiling code, but also about our working
    environment and the processes required to support it (at least in part). To prove
    this, we're going to explore installing the `postcss-stats` plugin as an example
    of how we can extend both our plugin and working environment.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能想要走得更远一些——创建一个处理器不仅仅是关于编译代码的细节，还涉及到我们的工作环境以及支持它的过程（至少部分如此）。为了证明这一点，我们将以安装
    `postcss-stats` 插件为例，展示我们如何扩展我们的插件和工作环境。
- en: This plugin helps provide useful statistics about each project as it is compiled—it's
    based on the CSS Stats system, and is available online at [http://www.cssstats.com](http://www.cssstats.com).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件有助于在编译项目时提供有关每个项目的有用统计数据——它基于 CSS Stats 系统，并在网上提供，网址为 [http://www.cssstats.com](http://www.cssstats.com)。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Throughout the demo, you may see a few issues with deprecated warnings—at the
    time of writing, the plugin needs a little polishing/updating. Don''t worry though:
    the plugin will still work fine for the purposes of our demo.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个演示过程中，你可能会看到一些关于弃用警告的问题——在撰写本文时，该插件需要一点打磨/更新。不过不用担心：该插件在我们的演示中仍然可以正常工作。
- en: 'The source for this plugin is available on GitHub at [https://github.com/cssstats/postcss-cssstats](https://github.com/cssstats/postcss-cssstats),
    and can be installed using the usual route. Let''s dive in and take a look:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件的源代码可在 GitHub 上找到，网址为 [https://github.com/cssstats/postcss-cssstats](https://github.com/cssstats/postcss-cssstats)，可以使用常规方式安装。让我们深入了解一下：
- en: We'll start by firing up a Node.js command prompt session, then changing the
    working directory to the root of our project area.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先启动一个 Node.js 命令提示符会话，然后更改工作目录到我们项目区域的根目录。
- en: 'We need to install the plugin, so in the prompt, enter this command and press
    *Enter*:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要安装该插件，所以在提示符中输入以下命令并按 *Enter* 键：
- en: '[PRE32]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Keep this open—we will need it later in the exercise.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 保持打开状态——我们将在练习的稍后部分需要它。
- en: 'Next, we need to update our `gulpfile.js` and `package.json` files—go ahead
    and extract copies of both files from the `T54 - using cssstats` folder in the
    code download that accompanies this book. Save both files to the root of our project
    area:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的 `gulpfile.js` 和 `package.json` 文件——请从本书附带的代码下载中的 `T54 - 使用 cssstats`
    文件夹中提取这两个文件的副本。将两个文件都保存到我们项目区域的根目录下：
- en: With our files in place, we can now test that it works—go ahead and save a copy
    of `style.css` from the same folder into the `src` folder of our project area.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的文件就绪后，我们现在可以测试它是否工作——请将同一文件夹中的 `style.css` 文件的副本保存到我们项目区域的 `src` 文件夹中。
- en: Revert to the Node.js command prompt we had open earlier—in the prompt, enter
    `gulp`, and press *Enter*.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回我们之前打开的 Node.js 命令提示符——在提示符中输入 `gulp`，然后按 *Enter* 键。
- en: PostCSS will compile our code—if all is well, we should see files appear in
    the now familiar `dest` folder…and we should also see something akin to this screenshot:![Extending
    our processor further](img/BO5194_10_07.jpg)
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PostCSS 将编译我们的代码——如果一切顺利，我们应该在现在熟悉的 `dest` 文件夹中看到文件……我们也应该看到类似下面的截图：![进一步扩展我们的处理器](img/BO5194_10_07.jpg)
- en: If I were a betting man (I'm not, but assume I am for this)—I would bet even
    odds that you're probably thinking "What on earth does all of that text mean?"
    Well, let me shed some light on what it all means.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我是一个赌徒（我不是，但为了这个假设我就是这样）——我会打赌你可能在想“这一切文字究竟是什么意思？”好吧，让我来解释一下这一切的含义。
- en: 'In a nutshell, we''ve installed what is effectively a reporting system—this
    details a bunch of statistics about our code. It contains details about all kinds
    of information, including the number of selectors, colors, the level of CSS specificity,
    declarations, and so on. It''s an easy way to get information about our code,
    as a means of documenting it for later use. The reason it is so easy to get the
    information lies in how it is configured—take a look at the `gulpfile.js` file;
    we will add a call to the plugin at the top:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们安装了一个实际上是一个报告系统——它详细说明了我们代码的一组统计数据。它包含了各种信息的详细信息，包括选择器的数量、颜色、CSS 特异性级别、声明等。这是一种获取我们代码信息、作为记录以供以后使用的方法。它之所以如此容易获取信息，在于它的配置方式——看看
    `gulpfile.js` 文件；我们将在顶部添加对插件的调用：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then modify the styles single task, by adding this line near the end:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过在末尾附近添加这一行来修改单个样式任务：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The trouble is, whilst it might be easy to get the information, it''s not so
    easy to store it! We can absolutely improve on it; instead of getting the information
    via our processor, we can go directly to the source. Let''s explore how to make
    this happen:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，虽然获取信息可能很容易，但存储它却不容易！我们可以绝对地改进它；而不是通过我们的处理器获取信息，我们可以直接从源获取。让我们看看如何实现这一点：
- en: We'll start by firing up a Node.js command prompt, then changing the working
    folder to the root of our project area.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先启动一个 Node.js 命令提示符，然后更改工作文件夹到我们的项目区域根目录。
- en: At the prompt, go ahead and enter `npm install gulp-stylestats --save-dev`,
    then press *Enter*.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，请继续输入 `npm install gulp-stylestats --save-dev`，然后按 *Enter* 键。
- en: 'We now need to edit the `gulpfile.js` and `package.json` files we used in the
    previous exercise, so open the `gulpfile.js` file in a text editor, and add these
    lines immediately below the closing bracket of the `sourcemap` task:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要编辑之前练习中使用的 `gulpfile.js` 和 `package.json` 文件，所以请在文本编辑器中打开 `gulpfile.js`
    文件，并在 `sourcemap` 任务的结束括号下方立即添加这些行：
- en: '[PRE35]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we need to update the default task—alter it as indicated:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新默认任务——按照指示进行更改：
- en: '[PRE36]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Revert to the Node.js command prompt, then enter `gulp` and press *Enter*—assuming
    we still have the same `style.css` file in the `src` folder, we should see this
    appear in the `dest` folder at the root of our project area:![Extending our processor
    further](img/BO5194_10_08.jpg)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Node.js 命令提示符，然后输入 `gulp` 并按 *Enter* 键——假设我们仍然在项目区域的 `src` 文件夹中有相同的 `style.css`
    文件，我们应该在我们的项目区域的根目录下的 `dest` 文件夹中看到这个文件：![进一步扩展我们的处理器](img/BO5194_10_08.jpg)
- en: Whilst we clearly need to alter the parameters of our Gulp file to prevent it
    producing minified JSON files, we can at least see the result of the (uncompressed)
    JSON file. Go ahead and open it up—it will look something like this:![Extending
    our processor further](img/BO5194_10_09.jpg)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们显然需要更改 Gulp 文件的参数以防止它生成压缩的 JSON 文件，但我们至少可以看到（未压缩的）JSON 文件的结果。打开它——它看起来可能像这样：![进一步扩展我们的处理器](img/BO5194_10_09.jpg)
- en: Although we're still only seeing code, we can now parse the content at will;
    we could, for instance, use jQuery to explore the contents and render it on screen
    using an appropriate style and format. I am sure you will agree though that this
    is a much easier way to view (and store) the information! The plugin needs minimal
    configuration to get started. We can use it to view any standard CSS file, once
    it has been through the compilation process.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们仍然只看到代码，但我们现在可以随意解析内容；例如，我们可以使用 jQuery 来探索内容，并使用适当的样式和格式将其渲染到屏幕上。我相信你也会同意，这确实是一种查看（和存储）信息的方法！插件需要最少的配置即可开始使用。我们可以用它来查看任何标准的
    CSS 文件，一旦它通过了编译过程。
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are a number of options we can use with the `gulp-stylestats` plugin—for
    details, take a look at `https://github.com/t32k/stylestats`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `gulp-stylestats` 插件的一组选项——有关详细信息，请参阅 `https://github.com/t32k/stylestats`。
- en: Right, we now have a completed processor; hopefully, this will also include
    a style guide that is running, using one of the plugins we've just discussed in
    the previous exercise. It's time we moved on—there is one task we should complete,
    though, before we embark on the next stage of our journey. It's time we put our
    processor to the test…
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在有一个完成的处理器；希望这也会包括一个运行中的风格指南，使用我们在上一个练习中讨论过的插件之一。是我们继续前进的时候了——在我们开始下一阶段的旅程之前，我们还需要完成一个任务。是时候对我们的处理器进行测试了…
- en: Testing the final pre-processor
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试最终的预处理器
- en: Throughout this book, we've explored a number of different plugins and concepts
    to help construct a processor; over the last few pages, we've brought together
    some of those concepts as the final version of our processor—at least one we can
    start using in anger.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们探索了许多不同的插件和概念来构建处理器；在过去的几页中，我们将这些概念整合到了我们处理器的最终版本中——至少是我们可以开始使用的版本。
- en: There is one key step left to complete—we've compiled code for simple exercises,
    this works well, but doesn't really represent the kind of processes we might go
    through as developers! For this, we need to construct a real-world example, and
    put our processor through its paces.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下最后一个关键步骤需要完成——我们已经为简单的练习编译了代码，这效果很好，但并不能真正代表我们作为开发者可能会经历的过程！为此，我们需要构建一个真实世界的例子，并让我们的处理器经受考验。
- en: 'As luck would have it, there is an example web page we can use from the code
    download that accompanies this book—let''s take a look at putting its style sheet
    code through our processor. We''ll begin by running the normal tasks we''ve done
    before, but will add a selection of plugins to make for a more realistic example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以从本书附带的代码下载中找到一个示例网页——让我们看看如何将它的样式表代码通过我们的处理器。我们将先运行之前做过的正常任务，但会添加一些插件以使示例更加真实：
- en: We'll start by extracting a copy of the `T55 - testing our processor` folder
    from the code download that accompanies this book; go ahead and save it to the
    root of our project area.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先从本书附带的代码下载中提取`T55 - testing our processor`文件夹的副本；将其保存到我们项目区域的根目录。
- en: Copy the `gulpfile.js` and `package.json` files from within this sub-folder
    to the root of our project area.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此子文件夹中的`gulpfile.js`和`package.json`文件复制到我们项目区域的根目录。
- en: Fire up a Node.js command prompt, then change the working folder to our project
    area.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个Node.js命令提示符，然后更改工作文件夹到我们的项目区域。
- en: 'In the prompt, go ahead and enter these three lines, pressing *Enter* after
    each:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中，输入以下三行，每行输入后按*Enter*键：
- en: '[PRE37]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Copy the `site.css` file from within the `css – completed version` folder under
    `T55 – testing our processor`, to the `src` folder at the root of our project
    area.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`T55 – testing our processor`下的`css – completed version`文件夹中的`site.css`文件复制到我们项目区域的根目录下的`src`文件夹。
- en: Revert to the Node.js session, then enter `gulp` at the prompt and press *Enter*—wait
    for it to complete compiling.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Node.js会话，然后在提示符中输入`gulp`并按*Enter*键——等待它完成编译。
- en: When compilation has finished, copy the contents of the `dest` folder to the
    `css` folder within `T55 – testing our processor`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当编译完成后，将`dest`文件夹的内容复制到`T55 – testing our processor`中的`css`文件夹。
- en: Try previewing the results of the compiled file—if all is well, we should see
    something akin to this screenshot:![Testing the final pre-processor](img/BO5194_10_10.jpg)
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试预览编译文件的成果——如果一切顺利，我们应该看到类似于以下截图的内容：![测试最终的预处理器](img/BO5194_10_10.jpg)
- en: Try resizing the browser window, or enabling Responsive Design mode in your
    browser (if supported)—we should see that content automatically flows or resizes,
    according to the size you set for the browser window. Overall, a successful result!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整浏览器窗口大小，或者在浏览器中启用响应式设计模式（如果支持的话）——我们应该看到内容会根据你为浏览器窗口设置的大小自动流动或调整大小。总体来说，这是一个成功的成果！
- en: The question is—what happened here? If we take a look at our code, the sharp-eyed
    should spot the addition of three plugins, plus a lot more code in the compiled
    version; let's take a moment to digest the results of our exercise.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是——这里发生了什么？如果我们查看我们的代码，细心的读者应该会注意到增加了三个插件，以及编译版本中大量额外的代码；让我们花点时间来消化我们练习的结果。
- en: Digesting the results of our exercise
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消化我们的练习结果
- en: If we look through our Gulp task file carefully, there should not be much in
    there that comes as a surprise—many of the tasks used are ones we have used on
    many occasions throughout the book.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看我们的Gulp任务文件，其中不应该有太多令人惊讶的内容——许多使用的任务我们在书中已经多次使用过。
- en: 'The key here, though, is that whilst we can run the standard processor that
    we''ve already used before, it''s unlikely to suit all occasions. It''s more likely
    that we can use it as our base (as stated earlier), then add any extra plugins
    as needed. The great thing about this is that most of the configuration work is
    done—it keeps a consistent approach to our work. All that remains is to install
    any plugins that we *don''t* already have in place—we of course have most of them,
    but need to install three additional ones, as highlighted here:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关键在于，尽管我们可以运行之前已经使用过的标准处理器，但它可能不太适合所有场合。更有可能的是，我们可以将其作为基础（如前所述），然后根据需要添加任何额外的插件。这个的好处是，大多数配置工作已经完成——它保持了我们对工作的持续方法。剩下的只是安装我们尚未安装的任何插件——我们当然拥有其中大部分，但需要安装三个额外的插件，如这里所示：
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These have to be accompanied with the relevant calls at the top of our Gulp
    task file:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些必须在我们的 Gulp 任务文件顶部进行相关调用：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In turn, these plugins are as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，这些插件如下：
- en: '**Rucksack**: This is to handle responsive/media queries, fallback colors from
    rgba to hex, and implement `@font-face`.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背包**：这是为了处理响应式/媒体查询，将 rgba 颜色从十六进制中回退，并实现 `@font-face`。'
- en: '**Pixrem**: Available at [https://github.com/robwierzbowski/node-pixrem](https://github.com/robwierzbowski/node-pixrem),
    this takes care of providing a fallback mechanism for the rem unit values used
    throughout our style sheet.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pixrem**：可在 [https://github.com/robwierzbowski/node-pixrem](https://github.com/robwierzbowski/node-pixrem)
    获取，它负责为我们样式表中的 rem 单位值提供回退机制。'
- en: '**Nesting**: Downloadable from [https://github.com/jonathantneal/postcss-nesting](https://github.com/jonathantneal/postcss-nesting)
    (via Node), this covers an instance of nesting used in our code.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套**：可以从 [https://github.com/jonathantneal/postcss-nesting](https://github.com/jonathantneal/postcss-nesting)（通过
    Node）下载，这涵盖了我们在代码中使用的嵌套实例。'
- en: '**Shorthand Color**: In a couple of instances, we combined `background-color`
    and `color` attributes in a shorthand form that is later transpiled by the plugin.
    You can see more about this plugin at [https://github.com/jonathantneal/postcss-short-color](https://github.com/jonathantneal/postcss-short-color).'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简写颜色**：在几个实例中，我们将 `background-color` 和 `color` 属性以简写形式结合在一起，该插件随后将其转换。您可以在
    [https://github.com/jonathantneal/postcss-short-color](https://github.com/jonathantneal/postcss-short-color)
    上了解更多关于此插件的信息。'
- en: We can of course add others, and continue converting our code—there are other
    instances where Nesting can be applied, such as in the rules that control styling
    for our navigation. The key here, though, is that success is measured in how much
    we have to change our processor's *default* setup—in this instance, we didn't
    have to change it at all! We of course added extra plugins that required a change
    to one line of code in the processor, but none of the other tasks required any
    changes at all.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以添加更多，并继续转换我们的代码——还有其他一些地方可以应用嵌套，例如在控制我们导航样式的规则中。但关键在于，成功衡量的是我们不得不改变处理器**默认**设置的多少——在这个例子中，我们根本不需要改变它！我们当然添加了需要更改处理器中一行代码的额外插件，但其他所有任务都不需要任何更改。
- en: It's at this stage that we have effectively completed the journey to create
    our processor—well, strictly speaking, our journey should always be considered
    without end; this will help ensure our tool remains up to date. This aside, though,
    there are some useful tips we can use when creating our processor, so let's take
    a moment to cover these in more detail.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这个阶段，我们实际上已经完成了创建我们处理器的旅程——严格来说，我们的旅程应该始终被视为没有尽头；这将有助于确保我们的工具保持最新。尽管如此，还有一些有用的技巧，我们可以在创建处理器时使用，所以让我们花点时间更详细地介绍这些技巧。
- en: Getting started with some hints and tips
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一些提示和技巧开始入门
- en: 'The time has come when it is over to you as developers to start creating your
    own processor! It may seem a daunting task at first, depending on the size and
    nature of your project; I''ve listed a few tips to help you over the initial hurdle
    of planning and creating your processor:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候轮到开发者们开始创建自己的处理器了！这可能会在最初看起来是一项艰巨的任务，取决于项目的规模和性质；我列出了一些提示，以帮助您克服规划和创建处理器的初步障碍：
- en: Every processor is unique—do not be afraid to experiment. The processor of course
    must meet your requirements, but there are several ways to crack a nut, so if
    the first plugin you try doesn't work, then move on and try another.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个处理器都是独特的——不要害怕实验。处理器当然必须满足您的需求，但破解坚果的方法有很多，所以如果您尝试的第一个插件不起作用，那么继续尝试另一个。
- en: Don't fall into the trap that many do, and consider PostCSS as either a pre-processor
    or a post-processor; it is neither and yet it is also both. The library itself
    does nothing; the magic lies in the plugins you add, which determine how it performs.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要陷入许多人都会犯的陷阱，将 PostCSS 视为预处理程序或后处理程序；它既不是也不是。库本身不做任何事情；魔法在于你添加的插件，它们决定了它的性能。
- en: Start small—PostCSS was designed to be modular, so if all you need to begin
    with is a facility to add vendor prefixes, then fine. Over time, you can easily
    add extra plugins to your processor; it does not matter if this is adding to existing
    functionality, or replacing an old process that is no longer efficient or works.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从小开始——PostCSS 是设计成模块化的，所以如果你一开始只需要一个添加供应商前缀的功能，那就没问题。随着时间的推移，你可以轻松地向你的处理器添加额外的插件；无论是添加到现有功能，还是替换不再高效或工作的旧流程，都没有关系。
- en: Think iteratively—don't even try to convert something as large as the style
    sheet for WordPress in one go! You will soon lose patience and momentum, and potentially
    abandon a project before you get the benefits of using PostCSS.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑迭代性——不要试图一次性转换像 WordPress 样式表这样大的东西！你很快就会失去耐心和动力，并且可能会在获得 PostCSS 的好处之前放弃项目。
- en: The only time a processor should be retired is if there is a fundamental change
    in the architecture of your project, which makes it incompatible with PostCSS.
    The versatility of PostCSS is such that this isn't likely to happen—you should
    always review the functionality periodically to ensure you are getting the best
    out of your processor. Plugins change, are deprecated, or new ones are added—a
    check will ensure your solution still works as efficiently as possible.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器唯一应该被淘汰的时候是，如果你的项目架构发生了根本性的变化，使其与 PostCSS 不兼容。PostCSS 的多功能性使得这种情况不太可能发生——你应该定期审查功能，以确保你从处理器中获得最佳效果。插件会更改、被弃用，或者添加新的插件——检查将确保你的解决方案尽可能高效地工作。
- en: Any processor should not be limited to PostCSS plugins only—even though this
    is what we've focused on, there are thousands of other plugins available for your
    task runner of choice, which will likely work with PostCSS. The key here is that
    if it helps automate a mundane task that saves you time as a developer, then consideration
    should be given to whether it can be included in your processor.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何处理器都不应该仅限于 PostCSS 插件——尽管这是我们关注的焦点，但还有数千个其他插件可供你选择的任务运行器使用，它们很可能与 PostCSS
    兼容。关键在于，如果它有助于自动化一个可以节省你作为开发者时间的日常任务，那么应该考虑是否可以将它包含在你的处理器中。
- en: I personally take the view that if it can be automated reliably, then include
    a task for it—we live in an age where time is precious; there is no value in manually
    resizing images, for example, if it can be done automatically!
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我个人认为，如果可以可靠地自动化，那么就包括一个任务——我们生活在一个时间宝贵的时代；例如，如果可以自动处理，手动调整图片就没有价值！
- en: Although we've talked about some of the tasks we can complete using a task runner,
    we must not forget the folder structure too. There is nothing worse than compiling
    files for different environments, for example, if they land up in badly-organized
    folders! Gulp can automate a multitude of tasks, so the fewer changes we have
    to do, or the fewer files we have to copy, the better.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们已经讨论了一些可以使用任务运行器完成的任务，但我们不能忘记文件夹结构。最糟糕的事情莫过于为不同的环境编译文件，例如，如果它们最终落在组织混乱的文件夹中！Gulp
    可以自动化大量任务，所以我们需要做的更改越少，或者需要复制的文件越少，就越好。
- en: Hopefully, they are a few tips to get you started! The great thing about PostCSS
    is that no two processors will be the same; whilst some may count that as a shortcoming,
    it should be noted that there is a wealth of possibilities out there to be explored,
    and that you can make your processor as simple or as complex as your project requirements
    dictate.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些建议能帮助你开始！关于 PostCSS 的好处是，没有两个处理器会是相同的；虽然有些人可能认为这是一个缺点，但应该注意的是，有大量的可能性等待探索，你可以根据项目需求将处理器做得尽可能简单或复杂。
- en: Before we bow out from our journey through building a custom processor, there
    is something we should consider. Our processor was constructed entirely using
    PostCSS plugins; in reality, our processor is more likely to go through a transitional
    phase, where we convert from the likes of SASS or less to using PostCSS.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束构建自定义处理器的旅程之前，我们应该考虑一些事情。我们的处理器完全使用 PostCSS 插件构建；实际上，我们的处理器更有可能经历一个过渡阶段，从
    SASS 或 less 等转换到使用 PostCSS。
- en: To help with this process, we can always make use of a library such as CSStyle—this
    little interesting gem can work with either SASS or PostCSS, and could be a useful
    addition to the transition process. Over the course of the next two chapters,
    we will learn how to create custom syntaxes and explore some of the ways we can
    process both PostCSS and SASS content through the same process. As a taster for
    what is coming, let's take a quick tour through CSSStyle and see how it works
    in action.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助这个过程，我们可以始终使用像CSStyle这样的库——这个有趣的小宝石可以与SASS或PostCSS一起工作，并且可能是过渡过程中的一个有用补充。在接下来的两章中，我们将学习如何创建自定义语法，并探索一些我们可以通过相同的过程处理PostCSS和SASS内容的方法。作为即将到来的内容的预览，让我们快速浏览CSSStyle，看看它是如何实际工作的。
- en: Introducing the CSStyle library
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍CSStyle库
- en: 'Cast your mind back to [Chapter 3](ch03.html "Chapter 3. Nesting Rules"), *Nesting
    Rules*, where we explored the concepts behind BEM, or the Block, Element, Modifier
    way of writing CSS. The key benefit of using this method is to help reduce CSS
    specificity, or where we might otherwise end up using something such as the following
    to style a simple button:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第3章](ch03.html "第3章。嵌套规则")，*嵌套规则*，其中我们探讨了BEM背后的概念，或者说是块、元素、修饰符编写CSS的方式。使用这种方法的关键好处是帮助减少CSS的特定性，或者我们可能否则会使用以下内容来为简单的按钮设置样式：
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Okay, it''s a little contrived, but you get the idea: the level of specificity
    makes it awkward to manage and potentially reuse in future projects.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这有点牵强，但你应该明白了：特定性的级别使得管理和将来在项目中重用变得尴尬。
- en: 'We took a look at BEM as a possible alternative—it has the benefit of reducing
    styles down to one or two classes, but can be awkward to remember which conventions
    to use:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑了BEM作为可能的替代方案——它有将样式减少到一到两个类的优点，但可能难以记住使用哪些约定：
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Okay, so how can we get around this? Well, here''s an option we can consider
    using: the CSStyle library. There are several reasons why this can help us—let''s
    take a look in more detail.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么我们如何解决这个问题呢？嗯，这里有一个我们可以考虑使用的选项：CSStyle库。有几个原因可以说明为什么这可以帮助我们——让我们更详细地看看。
- en: Exploring the benefits of using CSStyle
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索使用CSStyle的好处
- en: The key behind CSStyle (available from [http://csstyle.io/](http://csstyle.io/))
    is that it is made up of modular blocks, in a similar fashion to BEM. The difference,
    though, is that instead of having to remember a set of conventions that aren't
    the most intuitive, we can use a simpler set to create cleaner code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: CSStyle（可在[http://csstyle.io/](http://csstyle.io/)获取）的关键在于它由模块化块组成，类似于BEM的风格。然而，区别在于，我们不需要记住一组不太直观的约定，而可以使用更简单的集合来创建更干净的代码。
- en: 'The real beauty, though, is that we can use either SASS or PostCSS to create
    our site—we can begin with SASS, but we can also begin to transition over to using
    PostCSS with minimal changes. Let''s put this into practice, and explore a quick
    demo to see how easy it is to make these changes—before we do so, take a look
    at [http://codepen.io/alibby251/pen/pgmqjJ](http://codepen.io/alibby251/pen/pgmqjJ);
    this is a Pen that illustrates what we''re going to create:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 但真正的美在于，我们可以使用SASS或PostCSS来创建我们的网站——我们可以从SASS开始，但也可以开始过渡到使用PostCSS，而只需进行最小更改。让我们将其付诸实践，并探索一个快速演示，看看进行这些更改有多容易——在我们这样做之前，请查看[http://codepen.io/alibby251/pen/pgmqjJ](http://codepen.io/alibby251/pen/pgmqjJ)；这是一个Pen，展示了我们将要创建的内容：
- en: '![Exploring the benefits of using CSStyle](img/BO5194_10_11.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![探索使用CSStyle的好处](img/BO5194_10_11.jpg)'
- en: 'It won''t win any style awards, but the purpose of this demo is to show you
    the *process* and not necessarily produce anything that is stunning! With that
    in mind, let''s make a start:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会赢得任何风格奖项，但这个演示的目的是向您展示*过程*，而不仅仅是产生令人惊叹的东西！考虑到这一点，让我们开始：
- en: We'll begin by extracting a copy of the `T56 - using csstyle with sass` folder
    from the code download that accompanies this book; save the folder to the root
    of our project area.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从从本书附带的代码下载中提取`T56 - 使用csstyle与sass`文件夹的副本开始；将文件夹保存到项目区域的根目录中。
- en: Copy the contents of the `src` folder within `T56 - using csstyle with sass`
    to the `src` folder at the root of our project area.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`T56 - 使用csstyle与sass`文件夹内的`src`文件夹的内容复制到项目区域的根目录下的`src`文件夹中。
- en: Go ahead and replace the `gulpfile.js` and `package.json` files at the root
    of our project area with copies from within the `T56 - using csstyle with sass`
    folder.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目区域根目录下的`gulpfile.js`和`package.json`文件替换为`T56 - 使用csstyle与sass`文件夹内的副本。
- en: Fire up a Node.js command prompt session, then change the working folder to
    the root of our project area.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个 Node.js 命令提示符会话，然后更改工作文件夹到我们项目区域的根目录。
- en: At the prompt, enter gulp and press *Enter*—if all is well, we should see a
    compiled `style.css` file appear in the `dest` folder in our project area.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入 gulp 并按 *Enter* 键——如果一切顺利，我们应该在我们的项目区域 `dest` 文件夹中看到一个编译后的 `style.css`
    文件。
- en: Copy the contents of the `dest` folder back to the `css` folder within the `T56
    - using csstyle with sass` folder.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dest` 文件夹的内容复制回 `T56 - using csstyle with sass` 文件夹内的 `css` 文件夹。
- en: At this point, try previewing the results in a browser. If all is well, we will
    see the three buttons appear, just as they show in the Pen we mentioned at the
    start of this exercise.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，尝试在浏览器中预览结果。如果一切顺利，我们将看到三个按钮出现，就像我们在本练习开始时提到的笔中显示的那样。
- en: 'All looks good…we have a working demo, with a compiled style sheet—but hold
    on…in *SASS*? Yes, if you look carefully, the demo was indeed set to use SASS,
    but with good reason: we''re going to see how easy it is to change to using PostCSS
    *without* making material changes to our style sheet or our compilation process.
    Let''s make a start:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很顺利……我们有一个可以运行的演示，有一个编译后的样式表——但是等等……在 *SASS* 中？是的，如果你仔细看，演示确实设置为使用 SASS，但这是有原因的：我们将看到在不改变我们的样式表或编译过程的情况下使用
    PostCSS 是多么容易。让我们开始吧：
- en: In the `gulpfile.js` that is at the root of our project area, comment out line
    5, and uncomment lines 6 and 7; this switches our task file from using SASS to
    PostCSS.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目区域根目录下的 `gulpfile.js` 中，注释掉第 5 行，取消注释第 6 和第 7 行；这会将我们的任务文件从使用 SASS 切换到使用
    PostCSS。
- en: Rename the `[sass]` task `[style]`, on line 9.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第 9 行的 `[sass]` 任务重命名为 `[style]`。
- en: On line 10, the `gulp.src` call is looking for SASS files; change it to `src/*.css`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第 10 行，`gulp.src` 调用正在寻找 SASS 文件；将其更改为 `src/*.css`。
- en: 'Replace line 11 with this line: `.pipe(postcss([nested, csstyle]))`—this removes
    the dependency on SASS and switches to using PostCSS.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第 11 行替换为这一行：`.pipe(postcss([nested, csstyle]))`——这消除了对 SASS 的依赖，并切换到使用 PostCSS。
- en: On line 15, our default task will call the `[sass]` task; change `[sass]` to
    `[style]`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第 15 行，我们的默认任务将调用 `[sass]` 任务；将 `[sass]` 更改为 `[style]`。
- en: 'Change the watch task on line 17 to monitor CSS files, and not SASS:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第 17 行的监视任务更改为监视 CSS 文件，而不是 SASS：
- en: '[PRE42]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Go ahead and open up the SASS style sheet in the `src` folder at the root of
    our project area—rename the file as `style.css`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，打开我们项目区域根目录下的 `src` 文件夹中的 SASS 样式表——将文件重命名为 `style.css`。
- en: In `style.css`, go ahead and remove the `@import 'csstyle'` line at the top
    of our style sheet.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `style.css` 中，请移除样式表顶部的 `@import 'csstyle'` 行。
- en: Do a search and replace for `@include`—remove all instances in our style sheet.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行搜索和替换 `@include`——在我们的样式表中移除所有实例。
- en: That's it for our demo, sorry to disappoint if you were expecting more! All
    that remains is to replace the `gulpfile.js` and `package.json` files at the root
    of the project area with copies from the `T57 –` `using csstyle with postcss`
    folder, and compile as normal.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的演示就到这里，很抱歉让您失望，如果您期待更多的话！剩下的只是将项目区域根目录下的 `gulpfile.js` 和 `package.json` 文件替换为
    `T57 –` `using csstyle with postcss` 文件夹中的副本，并按正常方式编译。
- en: Dissecting our demo
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析我们的演示
- en: Making the transition from SASS to PostCSS can be as easy or as complex as we
    make it. Using the CSStyle library can go a long way to easing the transition
    away from existing processors such as SASS.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SASS 转换到 PostCSS 可以像我们让它变得一样简单或复杂。使用 CSStyle 库可以在很大程度上简化从现有处理器（如 SASS）的转换过程。
- en: 'Although our demo was just a quick whistle-stop tour through using CSStyle
    (and we will revisit it in [Chapter 12](ch12.html "Chapter 12. Mixing Preprocessors"),
    *Mixing Preprocessors*), it nevertheless illustrates a few important points of
    interest:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的演示只是对使用 CSStyle 的快速浏览（我们将在 [第 12 章](ch12.html "第 12 章。混合预处理器")，*混合预处理器*）进行回顾），但它仍然说明了几个重要的要点：
- en: The library uses the concept of components, options, parts, and tweaks to create
    the base components, pass styling to override base rules, add extra elements (such
    as icons), or tweak code. Careful design means that we can reduce or remove the
    need to alter our HTML as part of the transition to using PostCSS.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库使用组件、选项、部分和微调的概念来创建基本组件，传递样式以覆盖基本规则，添加额外元素（如图标），或微调代码。精心设计意味着我们可以减少或消除在转换为使用
    PostCSS 过程中修改 HTML 的需要。
- en: It is perfectly possible to compile the SASS version of our demo using a standard
    SASS compiler; the reason for choosing to use a task runner version (in this case
    for Gulp) means that we can centralize the compilation process in one task file,
    and remove the need to use separate compilers in our process.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全可以使用标准的SASS编译器编译我们演示的SASS版本；选择使用任务运行器版本（在这种情况下是Gulp）的原因是，我们可以将编译过程集中在一个任务文件中，并消除在过程中使用单独编译器的需求。
- en: When planning the design or transition of our site to use PostCSS, it pays to
    choose plugins carefully within PostCSS; this will determine how easy or complex
    it will be to make the changes in our code and processor.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计划我们的网站设计或过渡到使用PostCSS时，在PostCSS中选择插件要小心；这将决定我们在代码和处理器中做出更改的难易程度。
- en: Our demo focused on the core compilation process, and didn't include the extra
    tasks we used in the past, such as adding source maps. This was purely for clarity—there
    is no reason why we can't add the remaining tasks we've used before, once we've
    confirmed our compilation process works as expected.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的演示重点在于核心编译过程，并且没有包括过去使用的额外任务，例如添加源映射。这纯粹是为了清晰起见——我们没有理由不能在确认我们的编译过程按预期工作后，添加之前使用的剩余任务。
- en: Ultimately though, the use of this library is about helping to ease the process
    of making the transition to using PostCSS. There are different ways to approach
    this—using CSSStyle means that we have to completely redesign our HTML, but can
    easily alter the processor with minimal fuss. The flip side to this is that we
    can use PostCSS plugins that mimic SASS coding standards, or create our own custom
    syntax—we will explore these concepts in the next two chapters.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这个库的目的是帮助简化过渡到使用PostCSS的过程。有不同的方式来处理这个问题——使用CSSStyle意味着我们必须完全重新设计我们的HTML，但可以轻松地以最小的麻烦更改处理器。另一方面，我们可以使用模仿SASS编码标准的PostCSS插件，或者创建我们自己的自定义语法——我们将在下一两章中探讨这些概念。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Creating our own processor can be a satisfying experience—we have total control
    over what elements should be included, and can add or remove elements at any time.
    Throughout the course of this book, we've explored a number of elements that make
    up what might be a typical processor; in this chapter, we pulled together all
    of these elements to create our final article. Let's take a moment to review what
    we have learnt.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的处理器可以是一种令人满意的经验——我们完全控制应该包含哪些元素，并且可以在任何时候添加或删除元素。在整个本书的过程中，我们探讨了构成可能典型处理器的多个元素；在本章中，我们将所有这些元素结合起来创建我们的最终文章。让我们花点时间回顾一下我们已经学到的内容。
- en: We began with a look at some of the key elements of our processor, which we've
    already used previously, but have not really understood in detail how it all fits
    together. With this in mind, we moved on to examine some of the issues with our
    processor, before working out ways of correcting those issues and altering our
    code.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先回顾了我们处理器的一些关键元素，我们之前已经使用过，但并没有真正详细了解它们是如何结合在一起的。考虑到这一点，我们继续检查我们处理器的一些问题，然后找出纠正这些问题和修改我们代码的方法。
- en: With our updated processor in place, we then took a look at ways of optimizing
    our output by altering existing functionality, or including new options that may
    or may not make up a baseline processor or one customized for a specific project.
    We then took a look at extending our functionality, that includes options we would
    not normally consider, but will complement our work processes perfectly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的更新处理器到位后，我们研究了通过改变现有功能或包括可能或可能不构成基线处理器或针对特定项目定制的选项来优化我们的输出的方法。然后我们研究了扩展我们的功能，包括我们通常不会考虑的选项，但将完美补充我们的工作流程。
- en: We then rounded out our chapter with a quick test of our processor on a sample
    site, before exploring some of the hints and tips that will help us when creating
    our processors. The final step in our journey took a quick look at the CSSStyle
    library, as a precursor to creating custom syntaxes for PostCSS, which we will
    explore in the next chapter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在本章的最后，快速测试了我们的处理器在一个示例网站上，然后探索了一些有助于我们创建处理器的提示和技巧。我们旅程的最后一站是快速查看CSSStyle库，作为创建PostCSS自定义语法的先导，我们将在下一章中探讨。
