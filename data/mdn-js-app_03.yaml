- en: Chapter 3. Communication between Browsers in Real Time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 实时浏览器间的通信
- en: To implement features such as audio/video chat or some other features in websites
    that require real-time peer-to-peer (browser-to-browser) data transfer, or need
    to retrieve audio/video stream from a microphone, webcam, or any other device,
    we had to use browser plugins such as Java and Flash. There are various issues
    with making websites depend on browser plugins, such as mobile browsers not supporting
    plugins and plugins requiring to be kept up to date. Therefore, WebRTC was introduced
    to solve these problems, that is, browsers that support WebRTC provide APIs to
    exchange data in real time directly between browsers and also retrieve stream
    from physical media sources without the use of plugins. In this chapter, we will
    discuss WebRTC and also the PeerJS library that wraps the WebRTC APIs to provide
    an easy to use API to work with WebRTC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在网站中实现音频/视频聊天或其他需要实时点对点（浏览器到浏览器）数据传输的功能，或者需要从麦克风、摄像头或其他设备检索音频/视频流，我们不得不使用浏览器插件，如Java和Flash。网站依赖浏览器插件存在各种问题，例如移动浏览器不支持插件，以及插件需要保持更新。因此，引入了WebRTC来解决这些问题，即支持WebRTC的浏览器提供API，以实现浏览器之间的实时数据交换，并且无需使用插件即可从物理媒体源检索流。在本章中，我们将讨论WebRTC以及PeerJS库，该库封装了WebRTC
    API，以提供一个易于使用的API来与WebRTC一起工作。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Discussing various APIs provided by WebRTC
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论WebRTC提供的各种API
- en: Retrieving stream from physical media input devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从物理媒体输入设备检索流
- en: Displaying a media stream
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示媒体流
- en: Discussing protocols used by WebRTC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论WebRTC使用的协议
- en: Exchanging media stream and arbitrary data between peers using PeerJS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PeerJS在节点之间交换媒体流和任意数据
- en: Discussing topics related to the fundamentals of WebRTC and PeerJS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论与WebRTC和PeerJS基础相关的主题
- en: Terminologies
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: Before we get into WebRTC and PeerJS, you need to know the meaning of some terms
    that we are going to use. These terms are discussed in the following sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解WebRTC和PeerJS之前，您需要了解我们将要使用的某些术语的含义。这些术语将在以下部分中进行讨论。
- en: Stream
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流
- en: A **stream** is a sequence of any kind of data that is made available over time.
    A stream object represents a stream. Usually, an event handler or callback is
    attached to the stream object, which is invoked whenever new data is available.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**流**是一系列随时间提供的任何类型的数据。流对象表示一个流。通常，将事件处理程序或回调函数附加到流对象上，每当有新数据可用时，就会调用该函数。'
- en: A **media stream** is a stream whose data is either audio or video. Similarly,
    a **media source** is a physical device, file, or something that provides data
    that is audio or video. A **media consumer** is also a physical device, API, or
    something that uses media stream.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**媒体流**是一个数据为音频或视频的流。同样，**媒体源**是一个物理设备、文件或提供音频或视频数据的某种东西。**媒体消费者**也是一个物理设备、API或使用媒体流的某种东西。'
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebRTC allows us to retrieve a media stream of physical media sources, such
    as microphones, webcams, screens, and so on. We will discuss more about it later
    in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC允许我们从物理媒体源（如麦克风、摄像头、屏幕等）检索媒体流。我们将在本章后面进一步讨论这一点。
- en: Peer-to-peer network model
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点对点网络模型
- en: Peer-to-peer model is the opposite of the client-server model. In the client-server
    model, the server provides resources to the clients, whereas in peer-to-peer model,
    every node in the network acts as a server and client, that is, every node provides
    and consumes resources. Peers in the peer-to-peer model communicate with each
    other directly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点模型是客户端-服务器模型的相反。在客户端-服务器模型中，服务器向客户端提供资源，而在点对点模型中，网络中的每个节点都充当服务器和客户端，即每个节点提供和消耗资源。点对点模型中的节点直接相互通信。
- en: To establish a peer-to-peer connection, we need a signaling server, which is
    used for signaling. **Signaling** refers to the exchange of data by peers that
    is required to establish a peer-to-peer connection. Data such as session control
    messages, network configuration, and so on is required to establish a peer-to-peer
    connection. A signaling server implements a signaling protocol such as SIP, Jingle,
    or some other protocol.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立点对点连接，我们需要一个信令服务器，它用于信令。**信令**是指用于建立点对点连接的节点之间交换的数据。例如，会话控制消息、网络配置等数据需要建立点对点连接。信令服务器实现信令协议，如SIP、Jingle或某些其他协议。
- en: 'A model is selected depending on the requirements and resource availability
    for the application. Let''s consider some examples:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用的需求和资源可用性选择一个模型。让我们考虑一些例子：
- en: To build a video chat app, we should use the peer-to-peer model instead of the
    client-server model. As each node, in this case, is going to produce a lot data
    (or frames), and send the data to other node in real time, the server requires
    a lot of networks and other resources, increasing the server running cost. So,
    the peer-to-peer model is the best option for a video chat app. For example, Skype
    video chat is based on the peer-to-peer model.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建一个视频聊天应用，我们应该使用点对点模型而不是客户端-服务器模型。因为在这种情况下，每个节点都将产生大量数据（或帧），并实时将数据发送到其他节点，服务器需要大量的网络和其他资源，这增加了服务器运行成本。因此，点对点模型是视频聊天应用的最佳选择。例如，Skype
    视频聊天就是基于点对点模型的。
- en: To build a text chat app that stores messages in a centralized database, we
    should use the client-server model as the amount of data that a client produces
    is not very high and you would also want to store the messages in a centralized
    database. For example, the Facebook messenger is based on the client-server model.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建一个将消息存储在集中式数据库中的文本聊天应用，我们应该使用客户端-服务器模型，因为客户端产生的数据量不是很高，而且你也会希望将消息存储在集中式数据库中。例如，Facebook
    消息应用就是基于客户端-服务器模型的。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To establish a peer-to-peer connection using WebRTC, you will need a signaling
    server, STUN server, and optional TURN server. We will discuss more about it later
    in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 WebRTC 建立点对点连接，你需要一个信令服务器、STUN 服务器和可选的 TURN 服务器。我们将在本章后面进一步讨论这个问题。
- en: Real-time data
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时数据
- en: '**Real-time data** is the data that needs to be processed and transferred without
    much delay. For example, video chatting, live analytics, live stock price, live
    streaming, text chat, live score, online multiplayer game data, and so on are
    all real-time data.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时数据** 是需要无延迟处理和传输的数据。例如，视频聊天、实时分析、实时股价、实时流媒体、文本聊天、实时比分、在线多人游戏数据等等都是实时数据。'
- en: Real-time data transfer is a difficult task to achieve. The techniques and technologies
    used for real-time data transfer depend on the amount of data and whether the
    loss of data during data transfer is tolerable or not. If the real-time data is
    large, and the loss of data is intolerable, then it requires a lot of resources
    to achieve real-time data transfer, making it practically impossible to achieve
    real-time data transfer. For example, while video chatting, every user generates
    a lot of frames. If some frames are lost, then it is tolerable, therefore in this
    case, we can use the UDP protocol as a transport layer protocol that is unreliable
    and also has less overhead than TCP, making UDP very suitable for video chat application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实时数据传输是一个难以实现的任务。用于实时数据传输的技术和技术取决于数据量以及数据传输过程中数据丢失是否可容忍。如果实时数据量很大，且数据丢失不可容忍，那么需要大量资源来实现实时数据传输，这使得实现实时数据传输在实际上变得不可能。例如，在视频聊天时，每个用户都会生成大量的帧。如果某些帧丢失，那么这是可容忍的，因此在这种情况下，我们可以使用
    UDP 协议作为传输层协议，它不可靠且比 TCP 有更少的开销，这使得 UDP 非常适合视频聊天应用。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebRTC allows us to transfer real-time media stream produced by it using the
    SRTP protocol. To transfer arbitrary data, it uses the SCTP protocol. We will
    discuss more about what these protocols are later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC 允许我们使用 SRTP 协议传输它产生的实时媒体流。为了传输任意数据，它使用 SCTP 协议。我们将在本章后面进一步讨论这些协议。
- en: Introduction to WebRTC
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebRTC 简介
- en: '**Web Real-Time Communications (WebRTC)** is a browser technology that enables
    retrieval of media stream of physical media sources and exchange media stream
    or any other data in real time. It comprises of three APIs: the `MediaStream`
    constructor, `RTCPeerConnection` constructor, and `RTCDataChannel` interface.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 实时通信（WebRTC）** 是一种浏览器技术，它能够检索物理媒体源的媒体流，并实时交换媒体流或任何其他数据。它包括三个 API：`MediaStream`
    构造函数、`RTCPeerConnection` 构造函数和 `RTCDataChannel` 接口。'
- en: In short, `MediaStream` is used to retrieve the stream of physical media source,
    `RTCPeerConnection` is used to exchange `MediaStream` among peers in real time,
    and finally, `RTCDataChannel` is used to exchange arbitrary data among peers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`MediaStream` 用于检索物理媒体源的流，`RTCPeerConnection` 用于在实时点对点之间交换 `MediaStream`，最后，`RTCDataChannel`
    用于在点对点之间交换任意数据。
- en: Let's see how these APIs work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些 API 是如何工作的。
- en: MediaStream API
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MediaStream API
- en: Two main components of MediaStream API are the `MediaStream` constructor and
    `MediaStreamTrack` interface.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体流API的两个主要组件是`MediaStream`构造函数和`MediaStreamTrack`接口。
- en: A track represents the stream of a media source. A track implements the `MediaStreamTrack`
    interface. A track can either be an audio track or be a video track. That is,
    a track attached to an audio source is an audio track, and a track attached to
    a video source is a video track. There can be multiple tracks attached to a particular
    media source. We can also attach constraints to a track. For example, a track
    attached to a webcam can have constraints such as the minimum video resolution
    and FPS. Each track has its own constraints.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道代表媒体源的流。轨道实现了`MediaStreamTrack`接口。轨道可以是音频轨道或视频轨道。也就是说，连接到音频源的轨道是音频轨道，连接到视频源的轨道是视频轨道。可以有一个或多个轨道连接到特定的媒体源。我们还可以将约束附加到轨道上。例如，连接到网络摄像头的轨道可以具有最小视频分辨率和FPS等约束。每个轨道都有自己的约束。
- en: You can change the constraints of a track after it's created using the `applyConstraints()`
    method of the `MediaStreamTrack` interface. You can retrieve the constraints applied
    to a track anytime using the `getSettings()` method of the `MediaStreamTrack`
    interface. To detach a track from a media source, that is, to stop the track permanently,
    we can use the `stop()` method of the `MediaStreamTrack` interface. To pause a
    track, that is, to stop the track temporarily, we can assign `false` to the `enabled`
    property of the `MediaStreamTrack` interface.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`MediaStreamTrack`接口的`applyConstraints()`方法在创建轨道后更改轨道的约束。您可以使用`MediaStreamTrack`接口的`getSettings()`方法随时检索应用于轨道的约束。要从一个媒体源断开轨道，即永久停止轨道，我们可以使用`MediaStreamTrack`接口的`stop()`方法。要暂停轨道，即暂时停止轨道，我们可以将`MediaStreamTrack`接口的`enabled`属性赋值为`false`。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Find out more about the `MediaStreamTrack` interface at [https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack)了解更多关于`MediaStreamTrack`接口的信息。
- en: A track can either be a local or remote track. A local track represents the
    stream of a local media source; whereas, a remote track represents the stream
    of a remote media source. You cannot apply constraints to the remote track. To
    find whether a track is local or remote, we can use the `remote` property of the
    `MediaStreamTrack` interface.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道可以是本地轨道或远程轨道。本地轨道代表本地媒体源的流；而远程轨道代表远程媒体源的流。您不能对远程轨道应用约束。要确定轨道是本地还是远程，我们可以使用`MediaStreamTrack`接口的`remote`属性。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will come across the remote track while exchanging tracks between peers.
    When we send a local track to a peer, the other peer receives the remote version
    of the track.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在交换对等方之间的轨道时，我们会遇到远程轨道。当我们向对等方发送本地轨道时，另一个对等方会接收到该轨道的远程版本。
- en: A `MediaStream` holds multiple tracks together. Technically, it doesn't do anything.
    It just represents a group of tracks that should be played, stored, or transferred
    together in a synchronized manner.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaStream`将多个轨道组合在一起。技术上，它不做任何事情。它只是代表应该以同步方式一起播放、存储或传输的一组轨道。'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Find out more about the `MediaStream` constructor at [https://developer.mozilla.org/en/docs/Web/API/MediaStream](https://developer.mozilla.org/en/docs/Web/API/MediaStream).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developer.mozilla.org/en/docs/Web/API/MediaStream](https://developer.mozilla.org/en/docs/Web/API/MediaStream)了解更多关于`MediaStream`构造函数的信息。
- en: 'The `getSources()` method of the `MediaStreamTrack` object allows us to retrieve
    the ID of all the media devices, such as speakers, microphones, webcams, and so
    on. We can use the ID to create a track if the ID represents a media input device.
    The following is an example that demonstrates this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaStreamTrack`对象的`getSources()`方法允许我们检索所有媒体设备的ID，例如扬声器、麦克风、网络摄像头等。如果ID代表媒体输入设备，我们可以使用该ID创建一个轨道。以下是一个演示此功能的示例：'
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output will vary for everyone. Here is the output I got:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人的输出结果都可能不同。以下是我得到的输出结果：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: navigator.getUserMedia
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: navigator.getUserMedia
- en: 'There are various APIs that return `MediaStream` with tracks in it. One such
    method is `navigator.getUserMedia()`. Using `navigator.getUserMedia()`, we can
    retrieve a stream from media input sources, such as microphones, webcams, and
    so on. The following is an example to demonstrate:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种API返回包含轨道的`MediaStream`。其中一种方法是`navigator.getUserMedia()`。使用`navigator.getUserMedia()`，我们可以从媒体输入源检索流，例如麦克风、网络摄像头等。以下是一个演示此功能的示例：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run the preceding code, the browser will display a popup seeking permission
    from the user. The user has to give the permission to the code to access the media
    input devices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行前面的代码时，浏览器将显示一个弹出窗口，请求用户授权。用户必须授权代码访问媒体输入设备。
- en: By default, the media input devices to which the tracks are attached while using
    `getUserMedia()` depends on the browser. Some browsers let the user choose the
    audio and video device that they want to use, while other browsers use the default
    audio and video devices listed in the operating system configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用 `getUserMedia()` 时附加到轨道的媒体输入设备取决于浏览器。一些浏览器允许用户选择他们想要使用的音频和视频设备，而其他浏览器则使用操作系统中列出的默认音频和视频设备。
- en: We can also provide the `sourceId` property assigned to the ID of the media
    input device in the constraint object's `audio` or `video` property's `mandatory`
    property to make `getUserMedia()` attach tracks to these devices. So, if there
    are multiple webcams and microphones, then you can use `MediaStreamTrack.getSources()`
    to let the user choose a media input device and provide this media input device
    ID to `getUserMedia()` instead of relying on the browser, which doesn't guarantee
    whether it will let the user choose a media input device.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在约束对象的 `audio` 或 `video` 属性的 `mandatory` 属性中提供 `sourceId` 属性，将其分配给媒体输入设备的
    ID，以便 `getUserMedia()` 将轨道附加到这些设备。因此，如果有多个网络摄像头和麦克风，则可以使用 `MediaStreamTrack.getSources()`
    允许用户选择媒体输入设备，并将此媒体输入设备 ID 提供给 `getUserMedia()`，而不是依赖于浏览器，因为浏览器不能保证它是否会允许用户选择媒体输入设备。
- en: The first parameter that it takes is a constraint object with audio and video
    track constraints. Mandatory constraints are those constraints that must be applied.
    Optional indicates that they are not very important, so they can be omitted if
    it's not possible to apply them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受的第一个参数是一个包含音频和视频轨道约束的约束对象。强制约束是必须应用的约束。可选表示它们不是非常重要，因此如果无法应用它们，则可以省略。
- en: Some important constraints of an audio track are `volume`, `sampleRate`, `sampleSize`,
    and `echoCancellation`. Some important constraints of a video track are `aspectRatio`,
    `facingMode`, `frameRate`, `height`, and `width`. If a constraint is not provided,
    then its default value is used.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 音频轨道的一些重要约束是 `volume`、`sampleRate`、`sampleSize` 和 `echoCancellation`。视频轨道的一些重要约束是
    `aspectRatio`、`facingMode`、`frameRate`、`height` 和 `width`。如果没有提供约束，则使用其默认值。
- en: You can simply set the `audio` or `video` property to `false` if you don't want
    to create the audio or video tracks respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想创建音频或视频轨道，可以简单地将 `audio` 或 `video` 属性设置为 `false`。
- en: We can retrieve the tracks of `MediaStream` using the `getTracks()` method of
    `MediaStream`. Similarly, we can add or remove a track using the `addTrack()`
    and `removeTrack()` methods, respectively. Whenever a track is added, the `onaddtrack`
    event is triggered. Similarly, whenever a track is removed, the `onendtrack` is
    triggered.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `MediaStream` 的 `getTracks()` 方法检索 `MediaStream` 的轨道。同样，我们可以使用 `addTrack()`
    和 `removeTrack()` 方法分别添加或删除轨道。每当添加一个轨道时，就会触发 `onaddtrack` 事件。同样，每当删除一个轨道时，就会触发
    `onendtrack` 事件。
- en: If we already have some tracks, then we can directly use the `MediaStream` constructor
    to create `MediaStream` with the tracks. The `MediaStream` constructor takes an
    array of tracks and returns `MediaStream` with the reference of the tracks added
    to it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经有了一些轨道，则可以直接使用 `MediaStream` 构造函数创建带有这些轨道的 `MediaStream`。`MediaStream`
    构造函数接受一个轨道数组，并返回带有添加到其中的轨道引用的 `MediaStream`。
- en: An API that reads data from tracks of `MediaStream` is called a `MediaStream`
    consumer. Some of the `MediaStream` consumers are the `<audio>` tag, `<video>`
    tag, `RTCPeerConnection`, `Media Recorder` API, `Image Capture` API, `Web Audio`
    API, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `MediaStream` 轨迹读取数据的 API 被称为 `MediaStream` 消费者。一些 `MediaStream` 消费者包括 `<audio>`
    标签、`<video>` 标签、`RTCPeerConnection`、`Media Recorder` API、`Image Capture` API、`Web
    Audio` API 等。
- en: 'Here is an example that demonstrates how to display data of tracks of `MediaStream`
    in the video tag:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何在视频标签中显示 `MediaStream` 轨迹的数据：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we have a `<video>` tag and a button to pause it. A video tag takes a URL
    and displays the resource.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个 `<video>` 标签和一个用于暂停它的按钮。视频标签接受一个 URL 并显示资源。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before HTML5, HTML tags and CSS attributes could only read data from `http://`
    and `file://` URLs. However, in HTML5, they can read `blob://`, `data://`, `mediastream://`,
    and other such URLs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML5 之前，HTML 标签和 CSS 属性只能从 `http://` 和 `file://` URLs 读取数据。然而，在 HTML5 中，它们可以读取
    `blob://`、`data://`、`mediastream://` 和其他类似 URL。
- en: To display the output of `MediaStream` in the `<video>` tag, we need to use
    the `URL.createObjectURL()` method, which takes a blob, file object, or `MediaStream`
    and provides a URL to read its data. `URL.createObjectURL()` takes extra memory
    and CPU time to provide access to the value passed on to it via a URL, therefore,
    it is wise to release the URL using `URL.revokeObjectURL()` when we don't need
    the URL anymore.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `<video>` 标签中显示 `MediaStream` 的输出，我们需要使用 `URL.createObjectURL()` 方法，该方法接受一个
    blob、文件对象或 `MediaStream`，并提供一个 URL 来读取其数据。`URL.createObjectURL()` 会占用额外的内存和 CPU
    时间来通过 URL 提供对传递给它的值的访问，因此，当我们不再需要 URL 时，明智的做法是使用 `URL.revokeObjectURL()` 来释放 URL。
- en: If there are multiple audio and video tracks in `MediaStream`, then `<video>`
    reads the first audio and video tracks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `MediaStream` 中有多个音频和视频轨道，那么 `<video>` 会读取第一个音频和视频轨道。
- en: RTCPeerConnection API
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTCPeerConnection API
- en: '`RTCPeerConnection` allows two browsers to exchange `MediaStream` in real time.
    `RTCPeerConnection` is an instance of the `RTCPeerConnection` constructor.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTCPeerConnection` 允许两个浏览器实时交换 `MediaStream`。`RTCPeerConnection` 是 `RTCPeerConnection`
    构造函数的一个实例。'
- en: Establishing peer-to-peer connection
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立点对点连接
- en: For a peer-to-peer connection to be established, a signaling server is needed.
    Through the signaling server, the peers exchange data required to establish a
    peer-to-peer connection. Actual data transfer takes place directly between peer-to-peer.
    The signaling server is just used to exchange pre-requirements to establish a
    peer-to-peer connection. Both the peers can disconnect from the signaling server
    once the peer-to-peer connection has been established. The signaling server doesn't
    need to be a highly configured server as the actual data is not transferred through
    it. Data transfer for a single peer-to-peer connection will be in some KB, so
    a decent server can be used for signaling.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立点对点连接，需要一个信令服务器。通过信令服务器，端点交换建立点对点连接所需的数据。实际的数据传输是在端对端之间直接进行的。信令服务器仅用于交换建立点对点连接的先决条件。一旦建立了点对点连接，两个端点都可以从信令服务器断开连接。信令服务器不需要是一个高度配置的服务器，因为实际数据不是通过它传输的。单个点对点连接的数据传输量将在一些
    KB 左右，因此可以使用一个相当不错的服务器来进行信令。
- en: A signaling server usually uses a signaling protocol, but it is also okay if
    it's an HTTP server as long as it can pass messages between two peers. WebRTC
    doesn't force us to use any particular signaling protocol.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 信令服务器通常使用信令协议，但如果它是一个能够传递两个端点之间消息的 HTTP 服务器，也是可以的。WebRTC 并不强制我们使用任何特定的信令协议。
- en: 'For example, say that there are two users, Alice and Bob, on two different
    browsers. If Alice wants to establish a peer-to-peer connection with Bob for chatting,
    then this is how a peer-to-peer connection would be established between them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有两个用户，Alice 和 Bob，他们分别在不同的浏览器上。如果 Alice 想与 Bob 建立点对点连接进行聊天，那么他们之间建立点对点连接的方式如下：
- en: They both will connect to a signaling server.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们都将连接到信令服务器。
- en: Alice will then send a request to Bob via the signaling server, requesting to
    chat.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后 Alice 将通过信令服务器向 Bob 发送请求，请求聊天。
- en: The signaling server can optionally check whether Alice is allowed to chat with
    Bob, and also if Alice and Bob are logged in. If yes, then the signaling server
    passes the message to Bob.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信令服务器可以可选地检查 Alice 是否允许与 Bob 聊天，以及 Alice 和 Bob 是否已登录。如果是的话，信令服务器将消息传递给 Bob。
- en: Bob receives the request and sends a message to Alice via the signaling server,
    confirming to establish a peer-to-peer connection.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob 收到请求并通过信令服务器向 Alice 发送消息，确认建立点对点连接。
- en: Now both of them need to exchange messages related to session control, network
    configuration, and media capabilities. All these messages are exchanged between
    them by the `RTCPeerConnection`. So, they both need to create an `RTCPeerConnection`,
    initiate it, and attach an event handler to `RTCPeerConnection` that will be triggered
    by `RTCPeerConnection` when it wants to send a message via the signaling server.
    `RTCPeerConnection` passes the message to the event handler in the **Session Description
    Protocol** (**SDP**) format, and the messages for the `RTCPeerConnection` received
    from the signaling server must be fed to `RTCPeerConnection` in the SDP format,
    that is, `RTCPeerConnection` only understands the SDP format. You need to use
    your own programming logic to split custom messages and messages for `RTCPeerConnection`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在它们两个都需要交换与会话控制、网络配置和媒体能力相关的消息。所有这些消息都是通过 `RTCPeerConnection` 交换的。因此，它们两个都需要创建一个
    `RTCPeerConnection`，初始化它，并将事件处理器附加到 `RTCPeerConnection` 上，当它想要通过信令服务器发送消息时，`RTCPeerConnection`
    会将消息以 **会话描述协议** (**SDP**) 格式传递给事件处理器。从信令服务器接收到的 `RTCPeerConnection` 消息必须以 SDP
    格式提供给 `RTCPeerConnection`，也就是说，`RTCPeerConnection` 只能理解 SDP 格式。你需要使用自己的编程逻辑来分割自定义消息和
    `RTCPeerConnection` 的消息。
- en: The preceding steps seem to have no problem; however, there are some major problems.
    The peers may be behind a NAT device or firewall, so finding their public IP address
    is a challenging task, sometimes it is practically impossible to find their IP
    address. So, how does `RTCPeerConnection` find an IP address of the peers when
    they may be behind a NAT device or firewall?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤似乎没有问题；然而，存在一些主要问题。对等方可能位于 NAT 设备或防火墙后面，因此找到它们的公网 IP 地址是一项挑战性任务，有时实际上不可能找到它们的
    IP 地址。那么，当对等方可能位于 NAT 设备或防火墙后面时，`RTCPeerConnection` 如何找到对等方的 IP 地址？
- en: '`RTCPeerConnection` uses a technique called **Interactive Connectivity Establishment**
    (**ICE**) to resolve all these issues.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTCPeerConnection` 使用一种称为 **交互式连接建立** (**ICE**) 的技术来解决所有这些问题。'
- en: ICE involves **Session Traversal Utilities for NAT** (**STUN**) and **Traversal
    Using Relays around NAT** (**TURN**) server to solve the problems. A STUN server
    is used to find the public IP address of a peer. In case the IP address of a peer
    cannot be found, or due to some other reason a peer-to-peer cannot be established,
    then a TURN server is used to redirect the traffic, that is, both the peers communicate
    via the TURN server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ICE 涉及 **NAT 会话遍历实用工具** (**STUN**) 和 **NAT 旁路使用中继** (**TURN**) 服务器来解决这些问题。STUN
    服务器用于找到对等方的公网 IP 地址。如果对等方的 IP 地址找不到，或者由于其他原因无法建立点对点连接，则使用 TURN 服务器来重定向流量，也就是说，两个对等方通过
    TURN 服务器进行通信。
- en: We just need to provide the addresses of the STUN and TURN servers and `RTCPeerConnection`
    handles the rest. Google provides a public STUN server, which is used by everyone.
    Building a TURN server requires a lot of resources as the actual data flows throw
    it. Therefore, WebRTC makes it optional to use a TURN server. If `RTCPeerConnection`
    fails to establish a direct communication between two peers and a TURN server
    is not provided, there is no other way for the peers to communicate and a peer-to-peer
    connection establishment fails.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要提供 STUN 和 TURN 服务器的地址，`RTCPeerConnection` 会处理其余部分。Google 提供了一个公共 STUN 服务器，被每个人使用。构建
    TURN 服务器需要大量资源，因为实际数据流通过它。因此，WebRTC 使使用 TURN 服务器成为可选的。如果 `RTCPeerConnection` 无法在两个对等方之间建立直接通信，并且没有提供
    TURN 服务器，对等方就没有其他通信方式，对等方连接建立失败。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebRTC doesn't provide any way to make signaling secure. It's your job to make
    the signaling secure.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC 不提供任何使信令安全的方法。确保信令安全是你的工作。
- en: Transferring MediaStream
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输 MediaStream
- en: We saw how `RTCPeerConnection` establishes a peer-to-peer connection. Now, to
    transfer `MediaStream`, we just need to pass the reference of `MediaStream` to
    `RTCPeerConnection` and it will transfer `MediaStream` to the connected peer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了 `RTCPeerConnection` 如何建立点对点连接。现在，为了传输 `MediaStream`，我们只需要将 `MediaStream`
    的引用传递给 `RTCPeerConnection`，它就会将 `MediaStream` 传输给已连接的对等方。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we say that `MediaStream` is transferred, we mean the stream of individual
    tracks is transferred.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 `MediaStream` 被传输时，我们指的是单个轨道的流被传输。
- en: 'The following are some of the things you need to know regarding the transfer
    of `MediaStream`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于 `MediaStream` 传输你需要了解的事项：
- en: '`RTCPeerConnection` uses SRTP as an application layer protocol and UDP as a
    transport layer protocol to transfer `MediaStream`. SRTP is designed for media
    stream transfer in real time.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTCPeerConnection` 使用 SRTP 作为应用层协议和 UDP 作为传输层协议来传输 `MediaStream`。SRTP 是为实时媒体流传输而设计的。'
- en: UDP doesn't guarantee the order of packets, but SRTP takes care of the order
    of the frames.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP 不保证数据包的顺序，但 SRTP 会处理帧的顺序。
- en: The **Datagram Transport Layer Security** (**DTLS**) protocol is used to secure
    the `MediaStream` transfer. So, you don't have to worry about the security while
    transferring `MediaStream`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据报传输层安全性**（**DTLS**）协议用于确保 `MediaStream` 传输的安全性。因此，在传输 `MediaStream` 时，你不必担心安全问题。'
- en: Constraints of the tracks that the remote peer receives may be different from
    the constraints of the local tracks, as `RTCPeerConnection` modifies the stream
    automatically, depending on the bandwidth and other network factors to speed up
    the transfer, achieving real-time data transfer. For example, `RTCPeerConnection`
    may decrease the resolution and frame rate of video stream while transferring.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程对等方接收的轨道约束可能与本地轨道的约束不同，因为 `RTCPeerConnection` 会根据带宽和其他网络因素自动修改流，以加快传输速度，实现实时数据传输。例如，在传输过程中，`RTCPeerConnection`
    可能会降低视频流的分辨率和帧率。
- en: If you add or remove a track from `MediaStream` that is already being sent,
    then `RTCPeerConnection` updates `MediaStream` of the other peer by communicating
    to the other peer via the signaling server.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你向正在发送的 `MediaStream` 中添加或移除轨道，那么 `RTCPeerConnection` 会通过与其他对等方通过信令服务器通信来更新另一对等方的
    `MediaStream`。
- en: If you pause a track that is being sent, then `RTCPeerConnection` pauses transfer
    of the track.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你暂停正在发送的轨道，那么 `RTCPeerConnection` 会暂停轨道的传输。
- en: If you stop a track that is being sent, `RTCPeerConnection` stops the transfer
    of the track.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你停止正在发送的轨道，`RTCPeerConnection` 会停止轨道的传输。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can send and receive multiple `MediaStream` instances via single `RTCPeerConnection`,
    that is, you don't have to create multiple `RTCPeerConnection` instances to send
    and receive multiple `MediaStream` instances to and from a peer. Whenever you
    add or remove a new `MediaStream` to or from `RTCPeerConnection`, the peers exchange
    information related to this via the signaling server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过单个 `RTCPeerConnection` 发送和接收多个 `MediaStream` 实例，也就是说，你不需要创建多个 `RTCPeerConnection`
    实例来发送和接收来自对等方的多个 `MediaStream` 实例。每次你向 `RTCPeerConnection` 添加或移除新的 `MediaStream`
    时，对等方都会通过信令服务器交换与此相关的信息。
- en: RTCDataChannel API
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTCDataChannel API
- en: '`RTCDataChannel` is used to transfer data other than `MediaStream` between
    peers to transfer arbitrary data. The mechanism to establish a peer–to-peer connection
    to transfer arbitrary data is similar to the mechanism explained in the earlier
    section.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTCDataChannel` 用于在对等方之间传输除 `MediaStream` 之外的数据，以传输任意数据。建立点对点连接以传输任意数据的机制与前面章节中解释的机制类似。'
- en: '`RTCDataChannel` is an object that implements the `RTCDataChannel` interface.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTCDataChannel` 是一个实现了 `RTCDataChannel` 接口的对象。'
- en: 'The following are some of the things you need to know regarding `RTCDataChannel`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于 `RTCDataChannel` 你需要知道的事情：
- en: '`RTCDataChannel` uses SCTP over UDP as a transport layer protocol to transfer
    data. It doesn''t use unlayered SCTP protocol as the SCPT protocol is not supported
    by many operating systems.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTCDataChannel` 使用 SCTP over UDP 作为传输层协议来传输数据。它不使用无层的 SCTP 协议，因为 SCPT 协议不被许多操作系统支持。'
- en: SCTP can be configured for reliability and delivery order, unlike UDP, which
    is unreliable and unordered.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCTP 可以配置为可靠性和交付顺序，与 UDP 不同，UDP 不可靠且无序。
- en: '`RTCDataChannel` also uses DTLS to secure data transfer. So, you don''t have
    to worry about the security at all while transferring data via `RTCDataChannel`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTCDataChannel` 也使用 DTLS 来确保数据传输的安全性。因此，在通过 `RTCDataChannel` 传输数据时，你不必担心安全问题。'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can have multiple peer-to-peer connections open between browsers. For example,
    we can have three peer-to-peer connections, that is, first one for webcam stream
    transfer, second one for text message transfer, and third one for file transfer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器之间打开多个点对点连接。例如，我们可以有三个点对点连接，即第一个用于网络摄像头流传输，第二个用于文本消息传输，第三个用于文件传输。
- en: WebRTC applications using PeerJS
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PeerJS 的 WebRTC 应用程序
- en: '**PeerJS** is a client-side JavaScript library that provides an easy-to-use
    API to work with WebRTC. It only provides an API to exchange `MediaStream` and
    arbitrary data between peers. It doesn''t provide an API to work with `MediaStream`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**PeerJS** 是一个客户端 JavaScript 库，它提供了一个易于使用的 API 来处理 WebRTC。它仅提供 API 用于在节点之间交换
    `MediaStream` 和任意数据。它不提供用于处理 `MediaStream` 的 API。'
- en: PeerServer
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PeerServer
- en: '**PeerServer** is an open source signaling server used by PeerJS to establish
    a peer-to-peer connection. PeerServer is written in Node.js. If you don''t want
    to run your own PeerServer instance, then you can use PeerServer cloud, which
    hosts PeerServer for public use. PeerServer cloud allows you to establish a maximum
    of 50 concurrent connections for free.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**PeerServer** 是一个开源的信令服务器，PeerJS 使用它来建立点对点连接。PeerServer 使用 Node.js 编写。如果您不想运行自己的
    PeerServer 实例，则可以使用 PeerServer 云，该云为公共使用托管 PeerServer。PeerServer 云允许您免费建立最多 50
    个并发连接。'
- en: A unique ID identifies every peer connected to PeerServer. PeerServer itself
    can generate the ID, or else the peers can provide their own ID. For a peer to
    establish a peer-to-peer connection with another peer, it just needs to know the
    other peer's ID.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个唯一的 ID 识别连接到 PeerServer 的每个节点。PeerServer 本身可以生成 ID，或者节点可以提供自己的 ID。为了使一个节点与另一个节点建立点对点连接，它只需要知道另一个节点的
    ID。
- en: You might want to run your own PeerServer instance when you want to add more
    functionality to PeerServer or you want to support more than 50 concurrent connections.
    For example, if you want to check whether the user is logged in to PeerServer,
    then you need to add this feature and host your own customized PeerServer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想向 PeerServer 添加更多功能或需要支持超过 50 个并发连接时，您可能想运行自己的 PeerServer 实例。例如，如果您想检查用户是否已登录到
    PeerServer，那么您需要添加此功能并托管自己的定制 PeerServer。
- en: In this chapter, we will use PeerServer cloud, but in the next chapter, we will
    create our own instance of PeerServer. Therefore, to continue further with this
    chapter, create an account on the PeerServer cloud and retrieve the API key. Every
    application gets an API key to access the PeerServer cloud. If you are hosting
    your own PeerServer, then you won't need an API key. The API key is used by PeerServer
    cloud to track the total connections established by an application. To create
    an account and retrieve an API key, visit [http://peerjs.com/peerserver](http://peerjs.com/peerserver).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 PeerServer 云，但在下一章中，我们将创建自己的 PeerServer 实例。因此，为了继续本章的内容，请在 PeerServer
    云上创建一个账户并检索 API 密钥。每个应用程序都会获得一个 API 密钥来访问 PeerServer 云。如果您正在托管自己的 PeerServer，那么您不需要
    API 密钥。API 密钥由 PeerServer 云用于跟踪应用程序建立的连接总数。要创建账户并检索 API 密钥，请访问 [http://peerjs.com/peerserver](http://peerjs.com/peerserver)。
- en: PeerJS API
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PeerJS API
- en: Let's discuss the PeerJS API by creating a simple app that allows the users
    to exchange video and text messages with any user whose ID they have.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个简单的应用程序来讨论 PeerJS API，该应用程序允许用户与任何他们拥有 ID 的用户交换视频和文本消息。
- en: Create a `peerjs-demo` directory in your web server and place a file named `index.html`
    in it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Web 服务器上创建一个名为 `peerjs-demo` 的目录，并在其中放置一个名为 `index.html` 的文件。
- en: 'In the `index.html` file, we need to first enqueue the `PeerJS` library. Download
    `PeerJS` from [http://peerjs.com/](http://peerjs.com/). At the time of writing,
    the latest version of PeerJS was 0.3.14\. I would recommend that you stick to
    this version for the following examples. Place this starting code in the `index.html`
    file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.html` 文件中，我们首先需要入队 `PeerJS` 库。从 [http://peerjs.com/](http://peerjs.com/)
    下载 `PeerJS`。在撰写本文时，PeerJS 的最新版本是 0.3.14。我建议您在以下示例中坚持使用这个版本。将以下起始代码放置在 `index.html`
    文件中：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, I enqueued the minified version of PeerJS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我入队了 PeerJS 的精简版本。
- en: 'PeerJS API comprises of three main constructors, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PeerJS API 包含三个主要构造函数，如下所示：
- en: '`Peer`: An instance of `Peer` represents a peer in the network. A peer is connected
    to the signaling server and STUN, and optionally, to a TURN.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Peer`：`Peer` 实例代表网络中的一个节点。节点连接到信令服务器和 STUN，并且可选地连接到 TURN。'
- en: '`DataConnection`: DataConnection (that is, the instance of `DataConnection`)
    represents a peer-to-peer connection, which is used to exchange the arbitrary
    data. Technically, it wraps `RTCDataChannel`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataConnection`：DataConnection（即 `DataConnection` 的实例）代表一个点对点连接，用于交换任意数据。技术上，它封装了
    `RTCDataChannel`。'
- en: '`MediaConnection`: MediaConnection (that is, the instance of `MediaConnection`)
    represents a peer-to-peer connection that is used to exchange `MediaStream`. Technically,
    it wraps `RTCPeerConnection`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaConnection`：MediaConnection（即 `MediaConnection` 的实例）代表一个用于交换 `MediaStream`
    的点对点连接。技术上，它封装了 `RTCPeerConnection`。'
- en: If a peer wants to establish `DataConnection` or `MediaConnection` with another
    peer, then it simply needs to know the other peer's ID. PeerJS doesn't give the
    other peer an option to accept or reject `DataConnection`. Also, in the case of
    `MediaConnection`, PeerJS doesn't give the other peer an option to accept or reject
    `MediaConnection`, but `MediaConnection` will be inactive until it is activated
    programmatically by the other peer so that `MediaStream` can be transferred, otherwise
    `MediaStream` will not be transferred. So, we can write our own logic to let the
    other user accept or reject `DataConnection` or `MediaConnecton`, that is, as
    soon as `DataConnection` or `MediaConnection` is established, we can cancel it
    by asking the user for their opinion.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个节点想要与另一个节点建立 `DataConnection` 或 `MediaConnection`，那么它只需要知道另一个节点的 ID。PeerJS
    不会给另一个节点提供接受或拒绝 `DataConnection` 的选项。在 `MediaConnection` 的情况下，PeerJS 也不会给另一个节点提供接受或拒绝
    `MediaConnection` 的选项，但 `MediaConnection` 将在另一个节点程序化激活以传输 `MediaStream` 之前保持不活跃，否则
    `MediaStream` 将不会传输。因此，我们可以编写自己的逻辑来让其他用户接受或拒绝 `DataConnection` 或 `MediaConnecton`，也就是说，一旦
    `DataConnection` 或 `MediaConnection` 建立，我们就可以通过询问用户的意见来取消它。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At present, one `MediaConnection` can transfer only one `MediaStream`. In future
    releases of PeerJS, a single `MediaConnection` will support the transfer of multiple
    MediaStreams.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，一个 `MediaConnection` 只能传输一个 `MediaStream`。在 PeerJS 的未来版本中，单个 `MediaConnection`
    将支持传输多个 MediaStreams。
- en: 'Now, we need to create a `<video>` tag where the video will be displayed, a
    button to connect to a peer, and also a text box to send message. Here is the
    HTML code to display all these:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个 `<video>` 标签来显示视频，一个连接到节点的按钮，以及一个用于发送消息的文本框。以下是显示所有这些内容的 HTML 代码：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now as soon as the page loads, we need to connect to `PeerServer` and ICE servers
    so that other peers can talk to us, and also when a user clicks on the connect
    button, we can establish `DataConnection` and `MediaConnection`. The following
    is the code for this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当页面加载时，我们需要连接到 `PeerServer` 和 ICE 服务器，以便其他节点可以与我们交谈，并且当用户点击连接按钮时，我们可以建立 `DataConnection`
    和 `MediaConnection`。以下是这个功能的代码：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is how the code works:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使代码工作的：
- en: First we displayed a prompt box to take the ID as an input so that every peer
    can decide their own ID.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们显示了一个提示框来获取输入 ID，这样每个节点都可以决定自己的 ID。
- en: Then we created an instance of `Peer` with ID and PeerServer cloud key. Here
    we didn't provide signaling and ICE server's URLs, therefore, PeerJS will use
    PeerServer cloud as the signaling server and Google's public STUN server. It will
    not use any TURN server. As soon as a `Peer` instance is created, the instance
    connects to the signaling server and registers the given ID.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们使用 ID 和 PeerServer 云密钥创建了一个 `Peer` 实例。在这里，我们没有提供信令和 ICE 服务器的 URL，因此，PeerJS
    将使用 PeerServer 云作为信令服务器和 Google 的公共 STUN 服务器。它将不会使用任何 TURN 服务器。一旦创建了一个 `Peer`
    实例，该实例就会连接到信令服务器并注册给定的 ID。
- en: Then we attached five event handlers to the `peer` object.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们向 `peer` 对象附加了五个事件处理器。
- en: The `open` event is triggered when the connection to `PeerServer` was successful.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当连接到 `PeerServer` 成功时，会触发 `open` 事件。
- en: The `error` event is triggered for errors on the `peer` object.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `peer` 对象出现错误时，会触发 `error` 事件。
- en: The `disconnected` event is triggered when the connection with the signaling
    server is disconnected. The connection with the signaling server may get disconnected
    due to network problem or if you manually call the `peer.disconnect()` method.
    Once you are disconnected, your ID can be taken by someone else. You can try to
    reconnect with the same ID using the `peer.reconnect()` method. You can check
    whether `peer` is connected to the signaling server using the `peer.disconnect`
    Boolean property.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与信令服务器的连接断开时，会触发 `disconnected` 事件。与信令服务器的连接可能会因为网络问题或手动调用 `peer.disconnect()`
    方法而断开。一旦断开连接，你的 ID 可能会被其他人占用。你可以尝试使用 `peer.reconnect()` 方法使用相同的 ID 重新连接。你可以使用
    `peer.disconnect` 布尔属性检查 `peer` 是否连接到信令服务器。
- en: The `close` event is triggered when `peer` is destroyed, that is, it cannot
    be used anymore, all `MediaConnections` and `DataConnections` are killed, connection
    with the signaling server is killed, the ID is taken away, and so on. You may
    want to manually destroy `peer` when you don't need it anymore. You can destroy
    a peer using the `peer.destroy()` method.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `peer` 被销毁时，即它不能再使用时，所有 `MediaConnections` 和 `DataConnections` 都会被终止，与信令服务器的连接会被终止，ID
    会被移除，等等。当你不再需要它时，你可能想要手动销毁 `peer`。你可以使用 `peer.destroy()` 方法销毁一个节点。
- en: The `connection` event is triggered when some other peer establishes `DataConnection`
    with you. As I said earlier, `DataConnection` is established without further permission,
    but you can close it as soon as it's established if you want. Here we let the
    user decide if they want to continue or close `DataConnection` established by
    another peer. The event handler attached to the event receives an instance of
    `DataConnection` via the parameter that represents the currently established `DataConnection`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其他节点与你建立 `DataConnection` 时，会触发 `connection` 事件。正如我之前所说的，`DataConnection` 是无需进一步许可就建立的，但如果你想的话，你可以在建立后立即关闭它。在这里，我们让用户决定是否想要继续或关闭由其他节点建立的
    `DataConnection`。事件处理程序通过表示当前建立的 `DataConnection` 的参数接收 `DataConnection` 的实例。
- en: The `call` event is triggered when some other peer establishes `MediaConnection`
    with you. Here, we also let the user decide if they want to continue or close
    `MediaConnection` established by another peer. The event handler attached to the
    event receives an instance of `MediaConnection` via the parameter that represents
    the currently established `MediaConnection`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其他节点与你建立 `MediaConnection` 时，会触发 `call` 事件。在这里，我们也让用户决定是否想要继续或关闭由其他节点建立的 `MediaConnection`。事件处理程序通过表示当前建立的
    `MediaConnection` 的参数接收 `MediaConnection` 的实例。
- en: Here, in the `call` and `connection` event handlers, we asynchronously displayed
    the confirm popup boxes to prevent blocking the execution of the event handler
    that causes issues in some browsers, that is, blocking it fails to establish `DataConnection`
    and `MediaConnection`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，在 `call` 和 `connection` 事件处理程序中，我们异步显示确认弹出框，以防止阻塞某些浏览器中导致问题的事件处理程序的执行，即阻塞它将无法建立
    `DataConnection` 和 `MediaConnection`。
- en: 'Now, let''s implement the `acceptDataConnection()` and `acceptMediaConnection()`
    functions so that we can display the text messages and remote `MediaStream` when
    other peer establishes `DataConnection` or `MediaConnection` with us. Here''s
    the code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现 `acceptDataConnection()` 和 `acceptMediaConnection()` 函数，这样我们就可以在与其他节点建立
    `DataConnection` 或 `MediaConnection` 时显示文本消息和远程 `MediaStream`。以下是代码：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is how the preceding code works:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面代码的工作原理：
- en: In the `acceptDataConnection()` function, we attached three event handlers to
    `DataConnection`. The `data` event is triggered when the other peer sends us data.
    The `close` event is triggered when `DataConnection` is closed. Finally, the `error`
    event is triggered when an error occurs on `DataConnection`. We can manually close
    `DataConnection` using the `dataConnection.close()` method.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `acceptDataConnection()` 函数中，我们将三个事件处理程序附加到 `DataConnection` 上。当其他节点向我们发送数据时，会触发
    `data` 事件。当 `DataConnection` 关闭时，会触发 `close` 事件。最后，当 `DataConnection` 上发生错误时，会触发
    `error` 事件。我们可以使用 `dataConnection.close()` 方法手动关闭 `DataConnection`。
- en: In the `acceptMediaConnection()` function, we attached three event handlers
    and transferred our `MediaStream` to the other peer. The `stream` event is triggered
    when other peer sends us `MediaStream`. The `close` event is triggered when `MediaConnection`
    is closed. Finally, we activated `MediaConnection` using the `mediaConnection.answer()`
    method by passing our `MediaStream`. After `MediaConnection` is activated, the
    `stream` event will be triggered.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `acceptMediaConnection()` 函数中，我们附加了三个事件处理程序并将我们的 `MediaStream` 转移到其他节点。当其他节点发送我们
    `MediaStream` 时，会触发 `stream` 事件。当 `MediaConnection` 关闭时，会触发 `close` 事件。最后，我们通过传递我们的
    `MediaStream` 使用 `mediaConnection.answer()` 方法激活 `MediaConnection`。在 `MediaConnection`
    激活后，将触发 `stream` 事件。
- en: 'We finished writing the code to handle `MediaConnection` or `DataConnection`
    established by another peer with us. Now we need to write a code to create `MediaConnection`
    and `DataConnection` that a user clicks on the **connect** button. Here is the
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了处理由其他节点与我们建立的 `MediaConnection` 或 `DataConnection` 的代码。现在我们需要编写一个代码来创建用户点击
    **连接** 按钮时触发的 `MediaConnection` 和 `DataConnection`。以下是代码：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is how the code works:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何实现代码的：
- en: First we asked the user to input another user's ID.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们要求用户输入另一个用户的 ID。
- en: Then we established `DataConnection`. To establish a `DataConnection` with another
    user, we need to invoke the `connect()` method of the `Peer` instance with other
    peer's ID. We also made `DataConnection` reliable and ordered. Then, we attached
    the event handlers. We also saw how `data`, `close`, and `error` events work.
    The `open` event is triggered when `DataConnection` is established.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们建立了 `DataConnection`。要与另一个用户建立 `DataConnection`，我们需要调用 `Peer` 实例的 `connect()`
    方法并传入其他用户的 ID。我们还使 `DataConnection` 可靠且有序。然后，我们附加了事件处理器。我们还了解了 `data`、`close`
    和 `error` 事件的工作方式。当 `DataConnection` 建立时，会触发 `open` 事件。
- en: After establishing the `DataConnection`, we established `MediaConnection`. To
    establish `MediaConnection`, we need to call the `call()` method of the `Peer`
    instance. We need to pass `MediaStream` to the `call()` method. Finally, we attached
    the event handlers. The `stream` event will be triggered when the other user calls
    the `answer()` method of the `MediaConnection` instance, that is, when the MediaConnection
    is activated.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在建立 `DataConnection` 之后，我们建立了 `MediaConnection`。要建立 `MediaConnection`，我们需要调用
    `Peer` 实例的 `call()` 方法。我们需要将 `MediaStream` 传递给 `call()` 方法。最后，我们附加了事件处理器。当其他用户调用
    `MediaConnection` 实例的 `answer()` 方法时，即当 `MediaConnection` 激活时，将触发 `stream` 事件。
- en: 'Now the last thing we need to do is write the code to send the message when
    a user clicks on the send message button. Here is the code for this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们最后需要做的是编写代码，以便当用户点击发送消息按钮时发送消息。以下是相应的代码：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To send data via `MediaConnection`, we need to call the `send()` method of the
    `MediaConnection` instance. Here, we are sending a string, but you can pass any
    type of data including blobs and objects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 `MediaConnection` 发送数据，我们需要调用 `MediaConnection` 实例的 `send()` 方法。在这里，我们发送一个字符串，但您可以传递任何类型的数据，包括
    blob 和对象。
- en: Now, to test the application, open the `index.html` page URL in two different
    browsers, devices, or tabs. I am assuming that you have opened the URL in two
    different devices. In each device, provide a different ID to identify the user.
    Then click on the connect button in any one device and enter the other peer's
    ID. Now accept the request on the other device. Once this is done, both the devices
    will be able to display each other's webcam video and microphone audio. You can
    also send messages between them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试应用程序，请在两个不同的浏览器、设备或标签页中打开 `index.html` 页面的 URL。我假设您已经在两个不同的设备上打开了 URL。在每个设备上，提供不同的
    ID 以识别用户。然后在任何一台设备上点击连接按钮并输入另一个用户的 ID。现在在另一台设备上接受请求。一旦完成，这两台设备将能够显示彼此的摄像头视频和麦克风音频。您还可以在它们之间发送消息。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the official documentation of PeerJS API at [http://peerjs.com/docs/#api](http://peerjs.com/docs/#api).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://peerjs.com/docs/#api](http://peerjs.com/docs/#api) 找到 PeerJS API
    的官方文档。
- en: Miscellaneous
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项
- en: At the time of writing this book, the WebRTC specifications were still not finalized.
    The overall idea of what WebRTC does and how WebRTC works has been finalized.
    It's just that the APIs are still under development.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，WebRTC 规范尚未最终确定。WebRTC 的整体功能和运作方式已经确定，只是 API 仍在开发中。
- en: For example, WebRTC has introduced an alternative to the `navigator.getUserMedia()`
    method, that is, the `navigator.mediaDevices.getUserMedia()` method. At the time
    of writing this book, `navigator.mediaDevices.getUserMedia()` is not supported
    in any browsers. The difference between them is that the `navigator.mediaDevices.getUserMedia()`
    method is based on the promise pattern, whereas `navigator.getUserMedia()` is
    based on the callback pattern. At present, there is no plan to get rid of `navigator.getUserMedia()`
    due to the backward compatibility reason, but in future, `navigator.getUserMedia()`
    may be removed as WebRTC wants to implement all APIs using the promise pattern,
    therefore, it's difficult to maintain multiple APIs that do the same thing. Similarly,
    `navigator.mediaDevices.enumerateDevice()` is an alternative to `MediaStreamTrack.getSources()`,
    that is, `navigator.mediaDevices.enumerateDevice()` is based on the promise pattern.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，WebRTC 引入了对 `navigator.getUserMedia()` 方法的替代方案，即 `navigator.mediaDevices.getUserMedia()`
    方法。在撰写本书时，`navigator.mediaDevices.getUserMedia()` 在任何浏览器中都不受支持。它们之间的区别在于，`navigator.mediaDevices.getUserMedia()`
    方法基于承诺模式，而 `navigator.getUserMedia()` 基于回调模式。目前，由于向后兼容性的原因，没有计划废弃 `navigator.getUserMedia()`，但将来，由于
    WebRTC 希望使用承诺模式实现所有 API，因此维护多个执行相同功能的 API 将变得困难。同样，`navigator.mediaDevices.enumerateDevice()`
    是 `MediaStreamTrack.getSources()` 的替代方案，即 `navigator.mediaDevices.enumerateDevice()`
    基于承诺模式。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the official specification of WebRTC at [http://www.w3.org/TR/#tr_Web_Real_Time_Communication](http://www.w3.org/TR/#tr_Web_Real_Time_Communication).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.w3.org/TR/#tr_Web_Real_Time_Communication](http://www.w3.org/TR/#tr_Web_Real_Time_Communication)找到WebRTC的官方规范。
- en: Due to the fact that there are multiple APIs for the same feature, each with
    a different browser support, WebRTC provides a script called `adapter.js`, which
    is a shim to insulate websites from specification changes and prefix differences.
    You can find the shim at [https://github.com/webrtc/adapter](https://github.com/webrtc/adapter).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同一功能存在多个API，每个API都有不同的浏览器支持，WebRTC提供了一个名为`adapter.js`的脚本，它是一个垫片，用于隔离网站免受规范变化和前缀差异的影响。您可以在[https://github.com/webrtc/adapter](https://github.com/webrtc/adapter)找到这个垫片。
- en: WebRTC has a GitHub repository where it puts a lot of example projects showing
    some of the things that can be built using WebRTC. You can find the repository
    at [https://github.com/webrtc/samples](https://github.com/webrtc/samples). Just
    by looking at the examples and their source code, you can learn a lot more about
    WebRTC.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC有一个GitHub仓库，其中包含许多示例项目，展示了可以使用WebRTC构建的一些东西。您可以在[https://github.com/webrtc/samples](https://github.com/webrtc/samples)找到这个仓库。只需查看示例及其源代码，您就可以了解更多关于WebRTC的知识。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the fundamentals of WebRTC and PeerJS by creating
    a simple app. We discussed the various protocols, techniques, and other technologies
    that WebRTC uses to enable real-time peer-to-peer communication and read streams
    of physical media sources. We also saw an overview of PeerServer. Now you must
    be comfortable with building any type of WebRTC app using PeerServer cloud.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过创建一个简单的应用讨论了WebRTC和PeerJS的基础知识。我们讨论了WebRTC用于实现实时点对点通信和读取物理媒体源流的各种协议、技术和其他技术。我们还概述了PeerServer。现在您应该已经熟悉了使用PeerServer云构建任何类型的WebRTC应用。
- en: In the next chapter, we will build an advanced WebRTC app using a custom PeerServer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用自定义的PeerServer构建一个高级的WebRTC应用。
