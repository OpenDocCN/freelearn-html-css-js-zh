- en: Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: In the previous chapter, we covered the history of WebGL, along with its evolution.
    We discussed the fundamental elements in a 3D application and how to set up a
    WebGL context. In this chapter, we will investigate how geometric entities are
    defined in WebGL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了WebGL的历史及其演变。我们讨论了3D应用中的基本元素以及如何设置WebGL上下文。在本章中，我们将研究WebGL中几何实体的定义。
- en: WebGL renders objects following a "divide and conquer" approach. Complex polygons
    are decomposed into triangles, lines, and point primitives. Then, each geometric
    primitive is processed in parallel by the GPU in order to create the final scene.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL按照“分而治之”的方法渲染对象。复杂的多边形被分解成三角形、线和点原语。然后，每个几何原语由GPU并行处理，以创建最终场景。
- en: 'In this chapter, you will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将：
- en: Understand how WebGL defines and processes geometric information
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解WebGL如何定义和处理几何信息
- en: Discuss the relevant API methods that relate to geometry manipulation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论与几何操作相关的相关API方法
- en: Examine why and how to use **JavaScript Object Notation** (**JSON**) to define,
    store, and load complex geometries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查为什么以及如何使用**JavaScript对象表示法**（**JSON**）来定义、存储和加载复杂几何形状
- en: Continue our analysis of WebGL as a state machine to describe the attributes
    that are relevant to geometry manipulation that can be set and retrieved
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续分析WebGL作为状态机，描述与几何操作相关的可设置和检索的属性
- en: Experiment with creating and loading different geometry models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建和加载不同的几何模型
- en: WebGL Rendering Pipeline
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL渲染管线
- en: Although WebGL is often thought of as a comprehensive 3D API, it is, in reality,
    just a rasterization engine. It draws points, lines, and triangles based on the
    code you supply. Getting WebGL to do anything else requires you to provide code
    to use points, lines, and triangles to accomplish your task.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WebGL通常被认为是一个全面的3D API，但实际上它只是一个光栅化引擎。它根据你提供的代码绘制点、线和三角形。要让WebGL执行其他操作，你需要提供代码来使用点、线和三角形来完成你的任务。
- en: WebGL runs on the GPU on your computer. As such, you need to provide code that
    runs on that GPU. The code should be provided in the form of pairs of functions.
    Those two functions are known as the **vertex shader** and **fragment shader**, and
    they are each written in a very strictly-typed C/C++-like language called GLSL (GL
    Shader Language). Together, they are called a **program**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL在你的计算机的GPU上运行。因此，你需要提供在该GPU上运行的代码。代码应以成对函数的形式提供。这两个函数被称为**顶点着色器**和**片段着色器**，它们各自用一种非常严格类型化的C/C++语言编写，称为GLSL（GL着色语言）。它们一起被称为**程序**。
- en: GLSLGLSL is an acronym for the official OpenGL Shading Language. GLSL is a C/C++-like,
    high-level programming language for several parts of the graphic card. With GLSL,
    you can code short programs, called shaders, which are executed on the GPU. For
    more information, please check out [https://en.wikipedia.org/wiki/OpenGL_Shading_Language](https://en.wikipedia.org/wiki/OpenGL_Shading_Language).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL是OpenGL着色语言的缩写。GLSL是一种类似于C/C++的高级编程语言，用于图形卡的多部分。使用GLSL，你可以编写简短的程序，称为着色器，这些程序在GPU上执行。更多信息，请参阅 [https://en.wikipedia.org/wiki/OpenGL_Shading_Language](https://en.wikipedia.org/wiki/OpenGL_Shading_Language)。
- en: A vertex shader's job is to compute vertex attributes. Based on various positions,
    the function outputs values that can be used to rasterize various kinds of primitives,
    including points, lines, and triangles. When rasterizing these primitives, it
    calls a second user-supplied function known as a fragment shader. A fragment shader's
    job is to compute a color for each pixel of the primitive currently being drawn.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器的工作是计算顶点属性。基于各种位置，该函数输出可用于光栅化各种原语（包括点、线和三角形）的值。在光栅化这些原语时，它调用第二个用户提供的函数，称为片段着色器。片段着色器的工作是为当前正在绘制的原语的每个像素计算颜色。
- en: Nearly all of the WebGL API is about setting up state for these pairs of functions
    to execute. For each thing you want to draw, you need to set up state to run these
    functions by invoking `gl.drawArrays` or `gl.drawElements`, which executes your
    shaders on the GPU.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的WebGL API都是关于为这些成对的函数设置状态以执行。对于你想绘制的每一件事，你需要通过调用`gl.drawArrays`或`gl.drawElements`来设置状态以运行这些函数，这将执行你的着色器在GPU上。
- en: 'Before going any further, let''s examine what WebGL''s rendering pipeline looks
    like. In subsequent chapters, we will discuss the pipeline in more detail. The
    following is a diagram of a simplified version of WebGL''s rendering pipeline:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步讨论之前，让我们看看WebGL的渲染管道是什么样的。在随后的章节中，我们将更详细地讨论管道。以下是一个简化的WebGL渲染管道的图表：
- en: '![](img/0131f45f-813f-4251-898d-2b894c1fb4ec.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0131f45f-813f-4251-898d-2b894c1fb4ec.png)'
- en: Let's take a moment to describe each element.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间来描述每个元素。
- en: Vertex Buffer Objects (VBOs)
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点缓冲区对象 (VBOs)
- en: '**VBOs** contain the data that is used to describe the geometry to be rendered.
    Vertex coordinates, which are points that define the vertices of 3D objects, are
    usually stored and processed in WebGL as VBOs. Additionally, there are several
    data elements, such as vertex normals, colors, and texture coordinates, that can
    be modeled as VBOs.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**VBOs**包含用于描述要渲染的几何形状的数据。定义3D对象顶点的顶点坐标通常以VBO的形式存储和处理。此外，还有一些数据元素，如顶点法线、颜色和纹理坐标，可以建模为VBOs。'
- en: Index Buffer Objects (IBOs)
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引缓冲区对象 (IBOs)
- en: While VBOs contain vertices describing a geometry, **IBOs** contain information
    about the relationship of the vertices as the rendering pipeline constructs the
    drawing type primitives. It uses the index of each vertex in the vertex buffer
    as a value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**VBOs**包含描述几何形状的顶点，但**IBOs**包含关于顶点之间关系的详细信息，当渲染管道构建绘图类型原语时使用。它使用顶点缓冲区中每个顶点的索引作为值。
- en: Vertex Shader
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: The **vertex shader** is called on each vertex. The shader manipulates *per-vertex* data,
    such as vertex coordinates, normals, colors, and texture coordinates. This data
    is represented by attributes inside the vertex shader. Each attribute points to
    a VBO from where it reads vertex data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点着色器**在每一个顶点上被调用。着色器操作**每个顶点**的数据，例如顶点坐标、法线、颜色和纹理坐标。这些数据由顶点着色器内的属性表示。每个属性指向一个VBO，从那里读取顶点数据。'
- en: Fragment Shader
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段着色器
- en: Every set of three vertices defines a triangle. Each element on the surface
    of that triangle needs to be assigned a color. Without this, our surfaces wouldn't
    have a color. Each surface element is called a **fragment**. Since we are dealing
    with surfaces that will be displayed on your screen, these elements are more commonly
    known as **pixels**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每组三个顶点定义一个三角形。该三角形表面的每个元素都需要分配一个颜色。没有这个步骤，我们的表面就不会有颜色。每个表面元素被称为**片段**。由于我们处理的是将在屏幕上显示的表面，这些元素更常见地被称为**像素**。
- en: 'The main goal of the **fragment shader** is to calculate the color of *individual
    pixels*. The following diagram illustrates this idea:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**片段着色器**的主要目标是计算**单个像素**的颜色。以下图表说明了这个概念：'
- en: '![](img/461fa06e-78e2-492d-8f53-937e72435b86.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/461fa06e-78e2-492d-8f53-937e72435b86.png)'
- en: Framebuffer
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧缓冲区
- en: A two-dimensional buffer contains the fragments that have been processed by
    the fragment shader. Once all of the fragments have been processed, a 2D image
    is formed and displayed on screen. The **framebuffer** is the final destination
    of the rendering pipeline.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个二维缓冲区包含由片段着色器处理过的片段。一旦所有片段都被处理，就会形成一个2D图像并在屏幕上显示。**帧缓冲区**是渲染管道的最终目的地。
- en: Attributes
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: '**Attributes** are input variables that are used in the vertex shader. Attributes
    are used to specify how to pull data out of buffers and provide them to the vertex
    shader. For example, you may put positions in a buffer as three 32-bit floats
    per position. You would tell a particular attribute which buffer to pull the positions
    out of, what type of data it should pull out (3-component, 32-bit floating point
    numbers), what offset in the buffer the positions start at, and how many bytes
    to get from one position to the next. Since the vertex shader is called on each
    vertex, the attributes will be different every time the vertex shader is invoked.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**是用于顶点着色器的输入变量。属性用于指定如何从缓冲区中提取数据并将其提供给顶点着色器。例如，您可以将位置存储在缓冲区中，每个位置为三个32位浮点数。您会告诉特定的属性从哪个缓冲区中提取位置，它应该提取什么类型的数据（3分量，32位浮点数），缓冲区中位置开始的偏移量，以及从一个位置到下一个位置的字节数。由于顶点着色器在每一个顶点上被调用，因此每次调用顶点着色器时，属性都会不同。'
- en: Uniforms
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: '**Uniforms** are input variables that are available to both the vertex shader
    and the fragment shader. Unlike attributes, uniforms are constant during a rendering
    cycle. For example, the position of a light is often modeled as a uniform. Uniforms
    are effectively global variables that you set before executing your shader program.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一变量**是可供顶点着色器和片元着色器使用的输入变量。与属性不同，统一变量在渲染周期中是恒定的。例如，光的位置通常被建模为一个统一变量。统一变量实际上是你在执行着色器程序之前设置的全球变量。'
- en: Textures
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理
- en: '**Textures** are arrays of data that can be accessed in your shader program.
    Image data is the most common thing to put in a texture, but textures are simply
    data and can just as easily contain something other than an array of colors describing
    an image.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**纹理**是可以在你的着色器程序中访问的数据数组。图像数据是将图像放入纹理中最常见的事情，但纹理只是数据，也可以很容易地包含除了描述图像的颜色数组之外的其他内容。'
- en: Varyings
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值变量
- en: '**Varyings** are used to *pass data* from the vertex shader to the fragment
    shader. Depending on what is being rendered – points, lines, or triangles – the
    values set on a varying by a vertex shader will be interpolated while executing
    the fragment shader.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**插值变量**用于从顶点着色器传递数据到片元着色器。根据渲染的内容——点、线或三角形——顶点着色器设置的插值变量的值将在执行片元着色器时进行插值。'
- en: Now, let's cover the principles of creating a simple geometric object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨创建简单几何对象的原则。
- en: Rendering in WebGL
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL中的渲染
- en: WebGL handles geometry in a standard way, independent of the complexity and
    number of points that surfaces can have. There are two data types that are fundamental
    to represent the geometry of any 3D object: *vertices* and *indices*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL以标准方式处理几何形状，独立于表面的复杂性和点的数量。有两种数据类型是表示任何3D对象几何形状的基本类型：*顶点*和*索引*。
- en: Vertices
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点
- en: '**Vertices** are the points that define the corners of 3D objects. Each vertex
    is represented by three floating-point numbers that correspond to the `x`, `y`,
    and `z` coordinates of the vertex. Unlike its cousin, OpenGL, WebGL does not provide
    API methods to pass independent vertices to the rendering pipeline; therefore,
    all of our vertices need to be written in a **JavaScript array**, which can then
    be used to construct a WebGL vertex buffer.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点**是定义3D对象角落的点。每个顶点由三个浮点数表示，对应于顶点的`x`、`y`和`z`坐标。与它的表亲OpenGL不同，WebGL不提供API方法将独立的顶点传递到渲染管线；因此，我们所有的顶点都需要写入一个**JavaScript数组**，然后可以使用这个数组来构建WebGL顶点缓冲区。'
- en: Indices
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引
- en: '**Indices** are numeric labels for the vertices in a given 3D scene. Indices
    allow us to tell WebGL how to connect vertices in order to produce a surface.
    As with vertices, indices are stored in a JavaScript array and are then passed
    along to WebGL''s rendering pipeline using a WebGL index buffer.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引**是给定3D场景中顶点的数字标签。索引允许我们告诉WebGL如何连接顶点以产生表面。与顶点一样，索引存储在JavaScript数组中，然后通过WebGL索引缓冲区传递给WebGL的渲染管线。'
- en: VBOs Versus IBOs
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: VBOs与IBOs
- en: There are two kinds of WebGL buffers used to describe and process geometry. Buffers
    that contain vertex data are known as **VBOs**, and buffers that contain index
    data are known as **IBOs**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的WebGL缓冲区用于描述和处理几何形状。包含顶点数据的缓冲区被称为**VBOs**，而包含索引数据的缓冲区被称为**IBOs**。
- en: 'In this section, we will use the following steps to render an object in WebGL:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用以下步骤在WebGL中渲染一个对象：
- en: Define a geometry using JavaScript arrays
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JavaScript数组定义几何形状
- en: Create the respective WebGL buffers
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建相应的WebGL缓冲区
- en: Point a vertex shader attribute to a VBO from the previous step to store vertex
    coordinates
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点着色器属性指向上一步骤中的VBO以存储顶点坐标
- en: Use the IBO to render the geometry
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用IBO渲染几何形状
- en: Defining a Geometry Using JavaScript Arrays
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript数组定义几何形状
- en: 'To practice using the preceding steps, let''s use a trapezoid to see how we
    can define its vertices and indices. We need two JavaScript arrays – one for the
    vertices and one for the indices:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习使用前面的步骤，让我们使用梯形来查看我们如何定义其顶点和索引。我们需要两个JavaScript数组——一个用于顶点，一个用于索引：
- en: '![](img/1ccc3e64-684e-4098-b910-505346c4b396.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ccc3e64-684e-4098-b910-505346c4b396.png)'
- en: As you can see from the preceding illustration, we have placed the coordinates
    sequentially in the vertex array and then indicated how these coordinates are
    used to draw the trapezoid in the index array. So, the first triangle is formed
    with the vertices having the indices `0`, `2`, and `1`; the second, with the vertices
    having the indices `1`, `2`, and `3`; and finally, the third, with the vertices
    having the indices `2`, `4`, and `3`. We will follow the same procedure for all
    possible geometries.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的插图中所见，我们已经按顺序将坐标放置在顶点数组中，然后指出了这些坐标如何在索引数组中用于绘制梯形。因此，第一个三角形是由索引为`0`、`2`和`1`的顶点形成的；第二个是由索引为`1`、`2`和`3`的顶点形成的；最后，第三个是由索引为`2`、`4`和`3`的顶点形成的。我们将对所有可能的几何形状遵循相同的程序。
- en: Index Array Order
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 索引数组顺序
- en: Triangles in the index array are usually, but not necessarily, defined in counter-clockwise
    order. It's important to pick one approach and keep it consistent to help you
    determine the front and back sides of geometry primitives. Consistency is important,
    because programs may use the clockwise/counter-clockwise order to determine whether
    a face is facing forward or backward for **culling** and rendering purposes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 索引数组中的三角形通常（但不一定）按逆时针顺序定义。选择一种方法并保持一致对于帮助您确定几何原语的前后侧面非常重要。一致性很重要，因为程序可能使用顺时针/逆时针顺序来确定面是向前还是向后，以便进行剪切和渲染。
- en: Culling
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 剪切
- en: In computer graphics, back-face culling determines whether a polygon of a graphical
    object is visible. It is a step in the graphical pipeline that tests whether the
    points in the polygon appear in clockwise or counter-clockwise order when projected
    onto the screen. For more information, visit [https://en.wikipedia.org/wiki/Back-face_culling](https://en.wikipedia.org/wiki/Back-face_culling)[.](https://en.wikipedia.org/wiki/Back-face_culling)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，背面剪切（back-face culling）确定一个图形对象的多边形是否可见。它是图形管道中的一个步骤，用于测试多边形中的点在投影到屏幕上时是顺时针还是逆时针顺序。有关更多信息，请访问[https://en.wikipedia.org/wiki/Back-face_culling](https://en.wikipedia.org/wiki/Back-face_culling)[.]。
- en: Creating WebGL Buffers
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建WebGL缓冲区
- en: 'Now that we understand how to define a geometry using vertices and indices,
    let''s render a square. Once we have created the JavaScript arrays that define
    the vertices and indices for our geometry, the next step is to create the respective
    buffers. In this case, we have a simple square on the `x`-`y` plane with the z
    values set as `0`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用顶点和索引定义一个几何形状，让我们渲染一个正方形。一旦我们创建了定义我们几何形状的顶点和索引的JavaScript数组，下一步就是创建相应的缓冲区。在这种情况下，我们在`x`-`y`平面上有一个简单的正方形，z值设置为`0`：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Clipspace Coordinates
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 剪裁空间坐标
- en: These vertices are defined in clipspace coordinates, because WebGL only deals
    with clipspace coordinates. Clipspace coordinates always go from `-1` to `+1`,
    regardless of the size of the `canvas`. In later chapters, we will cover coordinates
    in more detail and learn how to convert between different coordinate systems.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些顶点是在剪裁空间坐标中定义的，因为WebGL只处理剪裁空间坐标。剪裁空间坐标总是从`-1`到`+1`，无论`canvas`的大小如何。在后面的章节中，我们将更详细地介绍坐标，并学习如何在不同坐标系之间进行转换。
- en: 'In [Chapter 1](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml), *Getting Started*,
    you may remember learning that WebGL operates as a state machine. Now, when `positionBuffer` is
    made the currently-bound WebGL buffer, any subsequent buffer operation will be
    executed on this buffer until it is unbound, or another buffer is made the current
    one with a bound call. We can bind a buffer with the following instruction:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml)“入门”中，您可能还记得学习到WebGL作为一个状态机运行。现在，当`positionBuffer`成为当前绑定的WebGL缓冲区时，任何后续的缓冲区操作都将在这个缓冲区上执行，直到它被解绑，或者通过绑定调用将另一个缓冲区设置为当前缓冲区。我们可以使用以下指令绑定缓冲区：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first parameter is the type of buffer we are creating. We have two options
    for this parameter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们正在创建的缓冲区类型。对于这个参数，我们有两种选择：
- en: '`gl.ARRAY_BUFFER`: Vertex data'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.ARRAY_BUFFER`：顶点数据'
- en: '`gl.ELEMENT_ARRAY_BUFFER`: Index data'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.ELEMENT_ARRAY_BUFFER`：索引数据'
- en: In the previous example, we created the buffer for vertex coordinates; therefore,
    we use `ARRAY_BUFFER`. For indices, the `ELEMENT_ARRAY_BUFFER` type is used.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了顶点坐标的缓冲区；因此，我们使用`ARRAY_BUFFER`。对于索引，使用`ELEMENT_ARRAY_BUFFER`类型。
- en: '**Bound Buffer Operations**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**边界缓冲区操作**'
- en: WebGL will always access the currently-bound buffer looking for the data. This
    means that we need to ensure that we always have bound a buffer before calling
    any other operation for geometry processing. If there is no buffer bound, you
    will obtain the `INVALID_OPERATION` error.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 将始终访问当前绑定的缓冲区以查找数据。这意味着在调用任何其他几何处理操作之前，我们需要确保已经绑定了缓冲区。如果没有绑定缓冲区，您将获得 `INVALID_OPERATION`
    错误。
- en: 'Remember that `drawArrays` uses VBOs*.* Once we have bound a buffer, we need
    to pass along its contents. We do this with the `bufferData` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`drawArrays` 使用 VBOs*.* 一旦我们绑定了缓冲区，我们需要传递其内容。我们通过 `bufferData` 函数来完成此操作：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the vertices variable is a normal JavaScript array that contains
    the vertex coordinates. WebGL does not accept JavaScript arrays as a parameter
    for the `bufferData` method. Instead, WebGL requires JavaScript typed array so
    that the buffer data can be processed in its native binary form with the objective
    of speeding up geometry-processing performance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`vertices` 变量是一个包含顶点坐标的正常 JavaScript 数组。WebGL 不接受 JavaScript 数组作为 `bufferData`
    方法的参数。相反，WebGL 需要JavaScript 类型化数组，以便以原生二进制形式处理缓冲区数据，目的是加快几何处理性能。
- en: The typed arrays used by WebGL include `Int8Array`, `Uint8Array`, `Int16Array`, `Uint16Array`, `Int32Array`, `Uint32Array`, `Float32Array`,
    and `Float64Array`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 使用的类型化数组包括 `Int8Array`、`Uint8Array`、`Int16Array`、`Uint16Array`、`Int32Array`、`Uint32Array`、`Float32Array`
    和 `Float64Array`。
- en: It's important to note that vertex coordinates can be float, but indices are *always* integers.
    Therefore, we will use `Float32Array` for VBOs and `Uint16Array` for IBOs in this
    book. These two types represent the largest typed arrays that you can use in WebGL *per
    rendering call*. Other types may or may not be present in your browser, as this
    specification is not yet final at the time of this book's publication.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，顶点坐标可以是浮点数，但索引始终是整数。因此，在这本书中，我们将使用 `Float32Array` 作为 VBOs，使用 `Uint16Array`
    作为 IBOs。这两种类型代表了在 WebGL 中每个渲染调用可以使用的最大类型化数组。其他类型可能存在于你的浏览器中，也可能不存在，因为在这个书籍出版时，这个规范尚未最终确定。
- en: Since the indices support in WebGL is restricted to 16-bit integers, an index
    array can only be `65,535` elements in length. If you have a geometry that requires
    more indices, you will need to use several rendering calls. More about rendering
    calls will be presented later in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 WebGL 对索引的支持限制为 16 位整数，索引数组只能有 `65,535` 个元素长。如果你有一个需要更多索引的几何形状，你需要使用多个渲染调用。关于渲染调用的更多内容将在本章后面介绍。
- en: JavaScript Typed Arrays
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 类型化数组
- en: Specifications for typed arrays can be found at [http://www.khronos.org/registry/typedarray/specs/latest/](http://www.khronos.org/registry/typedarray/specs/latest/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [http://www.khronos.org/registry/typedarray/specs/latest/](http://www.khronos.org/registry/typedarray/specs/latest/)
    找到关于类型化数组的规范。
- en: 'Finally, it is a good practice to unbind the buffer. We can achieve this by
    calling the following instruction:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，解除缓冲区绑定是一个好的实践。我们可以通过调用以下指令来实现：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will repeat the same calls described here for every WebGL buffer (VBO or
    IBO) that we will use.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复此处描述的相同调用，用于我们将要使用的每个 WebGL 缓冲区（VBO 或 IBO）。
- en: 'Let''s review what we have just learned with an example. We are going to look
    at an example from `ch02_01_square.html` to see the definition of VBOs and IBOs
    for a square:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例回顾一下我们刚刚学到的内容。我们将查看 `ch02_01_square.html` 的一个示例，以了解正方形的 VBO 和 IBO 的定义：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you want to see this scene in action, launch the `ch02_01_square.html` file
    in your browser.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到这个场景的实际效果，请在你的浏览器中打开 `ch02_01_square.html` 文件。
- en: 'To summarize, for every buffer, we want to do the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，对于每个缓冲区，我们想要执行以下操作：
- en: Create a new buffer
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的缓冲区
- en: Bind it to make it the current buffer
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定它使其成为当前缓冲区
- en: Pass the buffer data using one of the typed arrays
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型化数组之一传递缓冲区数据
- en: Unbind the buffer
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解除缓冲区绑定
- en: Operations to Manipulate WebGL Buffers
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作 WebGL 缓冲区
- en: 'The operations to manipulate WebGL buffers are summarized in the following
    table:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 操作 WebGL 缓冲区的操作总结如下表所示：
- en: '| **Method** | **Description** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `createBuffer()` | Creates a new buffer. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `createBuffer()` | 创建一个新的缓冲区。|'
- en: '| `deleteBuffer(buffer)` | Deletes the supplied buffer. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `deleteBuffer(buffer)` | 删除提供的缓冲区。|'
- en: '| `bindBuffer(target, buffer)` | Binds a buffer object. The accepted values
    for target are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '| `bindBuffer(target, buffer)` | 绑定一个缓冲区对象。`target` 的有效值如下：'
- en: '`ARRAY_BUFFER` (for vertices)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARRAY_BUFFER`（用于顶点）'
- en: '`ELEMENT_ARRAY_BUFFER` (for indices)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELEMENT_ARRAY_BUFFER`（用于索引）'
- en: '|'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `bufferData(target, data, type)` | Provides the buffer data. The accepted
    values for target are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '| `bufferData(target, data, type)` | 提供缓冲区数据。`target` 的可接受值如下：'
- en: '`ARRAY_BUFFER` (for vertices)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARRAY_BUFFER` （用于顶点）'
- en: '`ELEMENT_ARRAY_BUFFER` (for indices)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELEMENT_ARRAY_BUFFER` （用于索引）'
- en: 'As mentioned earlier, WebGL only accepts JavaScript typed arrays for the data.The
    parameter type is a performance hint for WebGL. The accepted values for type are
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，WebGL 只接受 JavaScript 类型数组作为数据。参数 `type` 是 WebGL 的性能提示。`type` 的可接受值如下：
- en: '`STATIC_DRAW`: Data in the buffer will not be changed (specified once and used
    many times)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATIC_DRAW`：缓冲区中的数据将不会更改（指定一次，使用多次）'
- en: '`DYNAMIC_DRAW`: Data will be changed frequently (specified many times and used
    many times)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DYNAMIC_DRAW`：数据将频繁更改（指定多次，使用多次）'
- en: '`STREAM_DRAW`: Data will change on every rendering cycle (specified once and
    used once)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STREAM_DRAW`：数据将在每个渲染周期中更改（指定一次，使用一次）'
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Associating Attributes to VBOs
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将属性关联到 VBO
- en: 'Once we have created the VBOs, we need to associate these buffers to vertex
    shader attributes. Each vertex shader attribute will refer to *one* an*d* *only
    one *buffer, depending on the correspondence that is established, as shown in
    the following diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了 VBO，我们需要将这些缓冲区关联到顶点着色器属性。每个顶点着色器属性将根据建立的对应关系，仅引用一个 *an*d* *仅一个* 缓冲区，如图所示：
- en: '![](img/ef13dc42-3a59-4167-97e1-a8d76ec9ea02.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef13dc42-3a59-4167-97e1-a8d76ec9ea02.png)'
- en: 'We can achieve this by following these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤实现这一点：
- en: Bind a VBO
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定 VBO
- en: Point an attribute to the currently-bound VBO
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性指向当前绑定的 VBO
- en: Enable the attribute
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用属性
- en: Unbind
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解绑
- en: Let's take a look at the first step.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一步。
- en: Binding a VBO
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定 VBO
- en: 'We already know how to do this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何做到这一点：
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Where `myBuffer` is the buffer we want to map.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `myBuffer` 是我们想要映射的缓冲区。
- en: Pointing an Attribute to the Currently-Bound VBO
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将属性指向当前绑定的 VBO
- en: The majority of the WebGL API is about setting up state to supply data to our
    GLSL programs. In this case, the only input to our GLSL program is `aVertexPosition`,
    which is an attribute. In [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml),
    *Lights*, we will learn how to define and reference vertex and fragment shader
    attributes. For now, let's assume that we have the `aVertexPosition` attribute,
    which describes the vertex coordinates in the shader.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL API 的主要部分是设置状态以向我们的 GLSL 程序提供数据。在这种情况下，我们的 GLSL 程序的唯一输入是 `aVertexPosition`，它是一个属性。在
    [第 3 章](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml)，*灯光*，我们将学习如何定义和引用顶点和片段着色器属性。现在，让我们假设我们有一个
    `aVertexPosition` 属性，它描述了着色器中的顶点坐标。
- en: 'The WebGL function that allows pointing attributes to the currently-bound VBOs
    is `vertexAttribPointer`. The following is its signature:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 允许将属性指向当前绑定的 VBO 的 WebGL 函数是 `vertexAttribPointer`。以下是其签名：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s describe each parameter individually:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个描述每个参数：
- en: '**Index**: An attribute''s index that we are going to map the currently-bound
    buffer to.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引**：我们将要映射到当前绑定缓冲区的属性的索引。'
- en: '**Size**: Indicates the number of values per vertex that are stored in the
    currently-bound buffer.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：表示当前绑定缓冲区中每个顶点存储的值的数量。'
- en: '**Type**: Specifies the data type of the values stored in the current buffer.
    It is one of the following constants: `FIXED`, `BYTE`, `UNSIGNED_BYTE`, `FLOAT`, `SHORT`,
    or `UNSIGNED_SHORT`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：指定当前缓冲区中存储的值的类型。它可以是以下常量之一：`FIXED`、`BYTE`、`UNSIGNED_BYTE`、`FLOAT`、`SHORT`
    或 `UNSIGNED_SHORT`。'
- en: '**Normalize**: This parameter can be set to `true` or `false`. It handles numeric
    conversions that are beyond the scope of this introductory guide. For our purposes,
    we will set this parameter to `false`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**归一化**：此参数可以设置为 `true` 或 `false`。它处理超出本入门指南范围的数值转换。对于我们的目的，我们将此参数设置为 `false`。'
- en: '**Stride**: If stride is `0`, then we are indicating that elements are stored
    sequentially in the buffer.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步长**：如果步长为 `0`，则表示元素在缓冲区中按顺序存储。'
- en: '**Offset**: The position in the buffer from which we will start reading values
    for the corresponding attribute. It is usually set to `0` to indicate that we
    will start reading values from the first element of the buffer.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏移量**：从缓冲区中读取对应属性值的起始位置。通常设置为 `0`，表示将从缓冲区的第一个元素开始读取值。'
- en: '**Buffer Pointer**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓冲指针**'
- en: '`vertexAttribPointer` defines a pointer for reading information *fro**m the
    currently-bound buffer*. Remember that an error will be generated if there is
    no VBO currently bound.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertexAttribPointer`定义了一个从当前绑定的缓冲区中读取信息的指针。记住，如果没有当前绑定的VBO，将会生成一个错误。'
- en: Enabling the Attribute
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用属性
- en: Finally, we need to activate the vertex shader attribute. Following our example,
    we just need to add `gl.enableVertexAttribArray(positionAttributeLocation);`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要激活顶点着色器属性。按照我们的例子，我们只需要添加`gl.enableVertexAttribArray(positionAttributeLocation);`。
- en: 'The following diagram summarizes the mapping procedure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了映射过程：
- en: '![](img/9e019111-cf3c-4756-97c3-2abce4db9f69.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e019111-cf3c-4756-97c3-2abce4db9f69.png)'
- en: Unbinding a VBO
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解除VBO的绑定
- en: 'As a rule of thumb, we should unbind our buffers after we''re done using them.
    We can do so with:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，我们在使用完缓冲区后应该解除它们的绑定。我们可以通过以下方式做到：
- en: '`gl.bindBuffer(gl.ARRAY_BUFFER, null);`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl.bindBuffer(gl.ARRAY_BUFFER, null);`.'
- en: Rendering
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: Once we have defined our VBOs and we have mapped them to the corresponding vertex
    shader attributes, we are ready to render! To do this, we can use one of the two
    API functions: `drawArrays` or `drawElements`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的VBOs并将它们映射到相应的顶点着色器属性，我们就可以准备渲染了！为此，我们可以使用两个API函数之一：`drawArrays`或`drawElements`。
- en: Drawing Functions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图函数
- en: The `drawArrays` and `drawElements` functions are used for writing to the framebuffer. `drawArrays` uses
    vertex data in the order in which it is defined in the buffer to create the geometry.
    In contrast, `drawElements` uses indices to access the vertex data buffers and
    create the geometry. Both `drawArrays` and `drawElements` will only use **enabled
    arrays**. These are the vertex buffer objects that are mapped to active vertex
    shader attributes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawArrays`和`drawElements`函数用于向帧缓冲区写入。`drawArrays`使用缓冲区中定义的顶点数据的顺序来创建几何体。相比之下，`drawElements`使用索引来访问顶点数据缓冲区并创建几何体。`drawArrays`和`drawElements`都将仅使用**已启用的数组**。这些是映射到活动顶点着色器属性的顶点缓冲区对象。'
- en: In our example, the buffer that contains the vertex coordinates is the only
    enabled array. However, in a more general scenario, there may be several enabled
    arrays at our disposal.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，包含顶点坐标的缓冲区是唯一的已启用数组。然而，在更一般的情况下，我们可能会有几个可用的已启用数组。
- en: For instance, we can have arrays with information about vertex colors, vertex
    normals, texture coordinates, and any other per-vertex data required by the application.
    In this case, each one of them would be mapped to an active vertex shader attribute.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以有包含顶点颜色、顶点法线、纹理坐标以及应用程序所需的任何其他每顶点数据的数组。在这种情况下，每个数组都会映射到一个活动的顶点着色器属性。
- en: Using Multiple VBOs
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个VBO
- en: 'In [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml), *Lights*, we will
    learn how to use a vertex normal buffer and vertex coordinates to create a lighting
    model for our geometry. In that scenario, we will have two active arrays: vertex
    coordinates and vertex normals.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml)，*光线*，我们将学习如何使用顶点法线缓冲区和顶点坐标来为我们的几何体创建光照模型。在这种情况下，我们将有两个活动的数组：顶点坐标和顶点法线。
- en: Using drawArrays
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用drawArrays
- en: We will call `drawArrays` when information about indices is not available. In
    most cases, `drawArrays` is used when the geometry is simple enough that defining
    indices is overkill – for instance, when we want to render a triangle or a rectangle.
    In that case, WebGL will create the geometry in the order in which the vertex
    coordinates are defined in the VBO. If you have contiguous triangles (as we did
    in the trapezoid example), you will have to *repeat* these coordinates in the
    VBO.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有索引信息时，我们将调用`drawArrays`。在大多数情况下，当几何体足够简单，定义索引是过度时，`drawArrays`会被使用——例如，当我们想要渲染一个三角形或矩形时。在这种情况下，WebGL将按照在VBO中定义的顶点坐标的顺序创建几何体。如果你有连续的三角形（就像我们在梯形示例中做的那样），你将不得不在VBO中*重复*这些坐标。
- en: 'If you need to repeat many vertices to create the geometry, `drawArrays` is
    not the optimal method, because the more vertex data you duplicate, the more calls
    you will have on the vertex shader. This can reduce the overall performance, since
    the same vertices must go through the pipeline several times, one for each time
    that they are repeated in the respective VBO:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要重复许多顶点来创建几何体，`drawArrays`不是最佳方法，因为顶点数据复制的越多，对顶点着色器的调用就越多。这可能会降低整体性能，因为相同的顶点必须通过管道多次，每次它们在相应的VBO中重复时都要通过一次：
- en: '![](img/f878e9ed-961a-454c-9751-4ecb3b96cbe6.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f878e9ed-961a-454c-9751-4ecb3b96cbe6.png)'
- en: 'The signature for `drawArrays` is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawArrays` 的签名如下：'
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Where:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '`mode`: Represents the type of primitive that we are going to render. The possible
    values for mode are `gl.POINTS`, `gl.LINE_STRIP`, `gl.LINE_LOOP`, `gl.LINES`, `gl.TRIANGLE_STRIP`, `gl.TRIANGLE_FAN`,
    and `gl.TRIANGLES`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：表示我们将要渲染的原始类型。`mode` 的可能值有 `gl.POINTS`、`gl.LINE_STRIP`、`gl.LINE_LOOP`、`gl.LINES`、`gl.TRIANGLE_STRIP`、`gl.TRIANGLE_FAN`
    和 `gl.TRIANGLES`。'
- en: '`first`: Specifies the starting element in the enabled arrays.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`：指定启用的数组中的起始元素。'
- en: '`count`: The number of elements to be rendered.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：指定要渲染的元素数量。'
- en: WebGL drawArrays Specification
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL drawArrays 规范
- en: When `drawArrays` is called, it uses count sequential elements from each enabled
    array to construct a sequence of geometric primitives, beginning with the element *first*. Mode specifies
    what kinds of primitives are constructed and how the array elements construct
    those primitives.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `drawArrays` 时，它使用每个启用的数组中的连续 `count` 个元素来构建一系列几何原始形状，从元素 `first` 开始。`mode`
    指定构建哪些类型的原始形状以及数组元素如何构建这些原始形状。
- en: Using drawElements
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 drawElements
- en: Unlike the previous case where no IBO was defined, `drawElements` allows us
    to use the IBO to tell WebGL how to render the geometry. Remember that `drawArrays` uses
    VBOs, which means that the vertex shader will process the repeated vertices as
    many times as they appear in the VBO. On the other hand, `drawElements` uses indices.
    Therefore, vertices are only processed once, and can be used as many times as
    they are defined in the IBO. This feature reduces both the memory and processing
    required on the GPU.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与未定义 IBO 的前一种情况不同，`drawElements` 允许我们使用 IBO 来告诉 WebGL 如何渲染几何形状。记住，`drawArrays`
    使用 VBOs，这意味着顶点着色器将处理 VBO 中出现的重复顶点多次。另一方面，`drawElements` 使用索引。因此，顶点只处理一次，并且可以在
    IBO 中定义的次数内重复使用。这个特性减少了 GPU 上的内存和处理需求。
- en: 'Let''s revisit the following diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新回顾以下图表：
- en: '![](img/93121f63-2b22-47f1-bccc-337ba09ec6a8.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93121f63-2b22-47f1-bccc-337ba09ec6a8.png)'
- en: 'When we use `drawElements`, we need at least two buffers: a VBO and an IBO.
    As the vertex shader gets executed on each vertex, the rendering pipeline assembles
    the geometry into triangles using the IBO.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `drawElements` 时，我们需要至少两个缓冲区：一个 VBO 和一个 IBO。由于顶点着色器在每个顶点上执行，渲染管线使用 IBO
    将几何形状组装成三角形。
- en: Binding the IBO with `drawElements`
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `drawElements` 绑定 IBO
- en: When using `drawElements`, you need to make sure that the corresponding IBO
    is currently bound.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `drawElements` 时，你需要确保相应的 IBO 当前已绑定。
- en: 'The signature for `drawElements` is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawElements` 的签名如下：'
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Where:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '`mode`: Represents the type of primitive we are going to render. The possible
    values for mode are `POINTS`, `LINE_STRIP`, `LINE_LOOP`, `LINES`, `TRIANGLE_STRIP`,
    `TRIANGLE_FAN`, and `TRIANGLES`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：表示我们将要渲染的原始类型。`mode` 的可能值有 `POINTS`、`LINE_STRIP`、`LINE_LOOP`、`LINES`、`TRIANGLE_STRIP`、`TRIANGLE_FAN`
    和 `TRIANGLES`。'
- en: '`count`: Specifies the number of elements to be rendered.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：指定要渲染的元素数量。'
- en: '`type`: Specifies the type of the values in indices. Must be `UNSIGNED_BYTE`
    or `UNSIGNED_SHORT`, as we are handling indices (integer numbers).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：指定索引中值的类型。必须是 `UNSIGNED_BYTE` 或 `UNSIGNED_SHORT`，因为我们正在处理索引（整数）。'
- en: '`offset`: Indicates which element in the buffer will be the starting point
    for rendering. It is usually the first element (zero value).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`：指示缓冲区中哪个元素将是渲染的起点。通常它是第一个元素（零值）。'
- en: WebGL drawElements Specification
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL drawElements 规范
- en: When `drawElements` is called, it uses count sequential elements from an enabled
    array, starting at the offset to construct a sequence of geometric primitives. Mode specifies
    what kinds of primitives are constructed and how the array elements construct
    these primitives. If more than one array is enabled, each is used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `drawElements` 时，它从启用的数组中从偏移量开始使用连续的 `count` 个元素来构建一系列几何原始形状。`mode` 指定构建哪些类型的原始形状以及数组元素如何构建这些原始形状。如果启用了多个数组，则每个数组都会被使用。
- en: Putting Everything Together
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切整合在一起
- en: Since you've probably been waiting to see how everything works together, let's
    go over a simple WebGL program that renders a square.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可能一直在等待看到所有这些是如何一起工作的，让我们回顾一个简单的 WebGL 程序，该程序渲染一个正方形。
- en: 'Time for Action: Rendering a Square'
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：渲染正方形
- en: 'Follow the given steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Open the `ch02_01_square.html` file in a code editor (ideally one that supports
    syntax highlighting).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码编辑器（最好是支持语法高亮的编辑器）中打开 `ch02_01_square.html` 文件。
- en: 'Examine the structure of this file with the help of the following diagram:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下图表的帮助检查此文件的结构：
- en: '![](img/f6ba7319-03f3-49fb-ad75-89d741e24628.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6ba7319-03f3-49fb-ad75-89d741e24628.png)'
- en: 'The web page contains the following:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网页包含以下内容：
- en: The `<script id="vertex-shader" type="x-shader/x-vertex">` script contains the
    vertex shader code.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<script id="vertex-shader" type="x-shader/x-vertex">`脚本包含了顶点着色器代码。'
- en: The `<script id="fragment-shader" type="x-shader/x-fragment">` script contains
    the fragment shader code. We won't pay attention to these two scripts as they
    will be the main point of study in the next chapter. For now, simply notice that
    we have a fragment shader and a vertex shader.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<script id="fragment-shader" type="x-shader/x-fragment">`脚本包含了片段着色器代码。我们暂时不会关注这两个脚本，因为它们将是下一章的主要学习内容。现在，只需注意我们有一个片段着色器和顶点着色器。'
- en: 'The next script on our web page, `<script type="text/javascript">`, contains
    all the JavaScript WebGL code that we will need. This script is divided into the
    following functions:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们网页上的下一个脚本，`<script type="text/javascript">`，包含了我们需要的所有JavaScript WebGL代码。这个脚本分为以下函数：
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We list a few global variables that we use throughout our application:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们列出了一些我们在整个应用程序中使用的全局变量：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`getShader` extracts the contents of a shader present in the HTML web page
    given its `id`:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getShader`函数从HTML网页中提取具有给定`id`的着色器的内容：'
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`initProgram` obtains a reference for the vertex shader and the fragment shader
    present in the web page (that is, the first two scripts that we discussed) and
    passes them along to the GPU to be compiled. Lastly, we attach the location of
    the `aVertexPosition` attribute to the `program` object so that it can be easily
    referenced later. Looking up `attribute` and `uniform` locations is expensive;
    therefore, such operations should happen once during initialization. We will cover
    these techniques in later chapters:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initProgram`函数获取网页中存在的顶点着色器和片段着色器的引用（即我们之前讨论的前两个脚本），并将它们传递给GPU进行编译。最后，我们将`aVertexPosition`属性的地址附加到`program`对象上，以便以后可以轻松引用。查找`attribute`和`uniform`位置是昂贵的；因此，此类操作应在初始化期间发生一次。我们将在后面的章节中介绍这些技术：'
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`initBuffers` contains the API calls to create and initialize buffers, as we
    discussed earlier in this chapter. In this example, we create a VBO to store coordinates
    for the square and an IBO to store the indices of the square:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initBuffers`函数包含了创建和初始化缓冲区的API调用，正如我们在本章前面讨论的那样。在这个例子中，我们创建一个VBO来存储正方形的坐标，以及一个IBO来存储正方形的索引：'
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`draw` maps the VBO to the respective vertex buffer attribute, `program.aVertexPosition`,
    and enables it by calling `enableVertexAttribArray`. It then binds the IBO and
    calls the `drawElements` function. We will cover this in more detail in later
    chapters:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw`函数将VBO映射到相应的顶点缓冲区属性`program.aVertexPosition`，并通过调用`enableVertexAttribArray`来启用它。然后它绑定IBO并调用`drawElements`函数。我们将在后面的章节中更详细地介绍这些内容：'
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`init` is the entry point for the entire application. When the page has loaded,
    `init` is invoked via `window.onload = init`. It''s important to note that the
    order of functions invoked inside of `init` are important to set up and render
    the geometry. We also set the canvas dimension to take the size of the entire
    window (fullscreen). As mentioned previously, in the `draw` function, we are using `canvas.width`
    and `canvas.height` as the source of truth for our drawing dimensions.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`是整个应用程序的入口点。当页面加载完成后，通过`window.onload = init`调用`init`。需要注意的是，`init`内部函数调用的顺序对于设置和渲染几何形状非常重要。我们还设置了画布的尺寸以适应整个窗口的大小（全屏）。如前所述，在`draw`函数中，我们使用`canvas.width`和`canvas.height`作为绘图尺寸的真相。'
- en: 'Open the `ch02_01_square.html` file in the HTML5 browser of your preference
    (Firefox, Safari, Chrome, or Opera), and you should see the following:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你偏好的HTML5浏览器（Firefox、Safari、Chrome或Opera）中打开`ch02_01_square.html`文件，你应该会看到以下内容：
- en: '![](img/230dfe04-f3bd-4609-b9f3-90cba1c1efce.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/230dfe04-f3bd-4609-b9f3-90cba1c1efce.png)'
- en: 'Open up the code for `ch02_01_square.html` and scroll down to the `initBuffers` function.
    Please pay attention to the diagram that appears as a comment inside of the function.
    This diagram describes how the vertices and indices are organized. You should
    see something like the following:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ch02_01_square.html`的代码，并向下滚动到`initBuffers`函数。请注意函数内部出现的注释中的图示。这个图示描述了顶点和索引的排列方式。你应该会看到以下内容：
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Try to modify the existing buffers to turn the square into a pentagon. How would
    you do this?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试修改现有的缓冲区，将正方形变成五边形。你会怎么做？
- en: Updating the Geometry Definition
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 更新几何定义
- en: Modify the vertex buffer array and index array so that the resulting figure
    is a pentagon instead of a square. To do this, you need to add one vertex to the
    vertex array and define one more triangle in the index array.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 修改顶点缓冲区数组和索引数组，以便生成的图形是五边形而不是正方形。为此，你需要向顶点数组中添加一个顶点，并在索引数组中定义一个额外的三角形。
- en: Save the file with a different name and open it in the HTML5 browser of your
    preference to test it.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件另存为不同的名称，并在你偏好的HTML5浏览器中打开它以进行测试。
- en: '***What just happened?***'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: You have learned about the different code elements that conform to a WebGL app.
    The `initBuffers` function has been examined closely and modified to render a
    different geometry.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了符合WebGL应用程序的不同代码元素。`initBuffers`函数已经被仔细检查并修改，以渲染不同的几何形状。
- en: 'Have a Go: Changing the Square Color'
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下：更改正方形颜色
- en: Go to the fragment shader and change the color of your geometry.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 前往片段着色器并更改你的几何形状的颜色。
- en: Four-Component Color Vector
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 四分量颜色向量
- en: The format is (red, green, blue, alpha). Alpha is always `1.0` (for now), and
    the first three arguments are float numbers in the range of `0.0` to `1.0`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 格式是（红色，绿色，蓝色，alpha）。Alpha现在始终为`1.0`，前三个参数是范围在`0.0`到`1.0`之间的浮点数。
- en: Remember to save the file after making the changes in your text editor before
    opening it in your browser.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在浏览器中打开它之前，在文本编辑器中更改文件后保存文件。
- en: 'Have a Go: Rendering Using drawArrays'
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下：使用drawArrays进行渲染
- en: Our square was defined using `drawElements` via vertices and indices. Go ahead
    and render the same square using `drawArrays`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的正方形是通过`drawElements`通过顶点和索引定义的。现在尝试使用`drawArrays`渲染相同的正方形。
- en: Hint
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Given that you don't use indices with `drawArrays`, you won't need an `IBO`.
    So, you will need to duplicate vertices to construct this geometry.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你不使用索引与`drawArrays`一起使用，因此你不需要IBO。所以，你需要复制顶点来构建这个几何形状。
- en: HintFor reference, you can find the source code for this exercise in `ch02_02_square-arrays.html`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 提示为了参考，你可以在这个练习的`ch02_02_square-arrays.html`中找到源代码。
- en: Vertex Array Objects
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点数组对象
- en: '**Vertex array objects (VAOs)** allow you to store all of the vertex/index
    binding information for a set of buffers in a single, easy to manage object. That
    is, the state of attributes, which buffers to use for each attribute, and how
    to pull data out from those buffers, is collected into a VAO. Although we can
    implement VAOs in WebGL 1 by using extensions, they are available by default in
    WebGL 2.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点数组对象（VAOs）**允许你将一组缓冲区的所有顶点/索引绑定信息存储在单个易于管理的对象中。也就是说，属性的状态、每个属性使用的缓冲区以及如何从这些缓冲区中提取数据都收集到VAO中。尽管我们可以通过使用扩展在WebGL
    1中实现VAOs，但它们在WebGL 2中默认可用。'
- en: This is an important feature that should *always *be used, since it significantly
    reduces rendering times. When not using VAOs, all attributes data is in global
    WebGL state, which means that calling functions such as `gl.vertexAttribPointer`, `gl.enableVertexAttribArray`,
    and `gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer)` manipulates the global state.
    This leads to performance loss, because before any draw call, we would need to
    set up all vertex attributes and set the `ELEMENT_ARRAY_BUFFER` where indexed
    data is being used. On the other hand, with VAOs, we would set up all attributes
    during our application's initialization and simply bind the data at render, yielding
    much better performance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个应该*始终*使用的重要功能，因为它可以显著减少渲染时间。当不使用VAOs时，所有属性数据都在全局WebGL状态中，这意味着调用如`gl.vertexAttribPointer`、`gl.enableVertexAttribArray`和`gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,
    buffer)`等函数会操作全局状态。这会导致性能损失，因为在任何绘制调用之前，我们需要设置所有顶点属性并设置`ELEMENT_ARRAY_BUFFER`，其中使用了索引数据。另一方面，使用VAOs时，我们会在应用程序初始化期间设置所有属性，并在渲染时简单地绑定数据，从而获得更好的性能。
- en: Let's see how we can start using VAOs from here on out!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何从这里开始使用VAOs！
- en: 'Time for Action: Rendering a Square Using a VAO'
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：使用VAO渲染正方形
- en: 'Let''s refactor a previous example using VAOs:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构一个使用VAOs的先前示例：
- en: Open up `ch02_01_square.html` in your editor.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`ch02_01_square.html`。
- en: 'First, we update our global variables:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们更新全局变量：
- en: '[PRE16]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've replaced `squareVertexBuffer` with `squareVAO`, as we no longer need to
    reference the vertex buffer directly.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经将`squareVertexBuffer`替换为`squareVAO`，因为我们不再需要直接引用顶点缓冲区。
- en: 'Next, we update the `initBuffers` functions as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们按照以下方式更新`initBuffers`函数：
- en: '[PRE17]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We create a new VAO instance using `gl.createVertexArray();` and assign it to
    `squareVAO`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`gl.createVertexArray();`创建一个新的VAO实例，并将其分配给`squareVAO`。
- en: Then, we bind `squareVAO` with `gl.bindVertexArray(squareVAO);` so that all
    of our attribute settings will apply to that set of attribute state.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`gl.bindVertexArray(squareVAO);`绑定`squareVAO`，这样所有的属性设置都将应用于那一组属性状态。
- en: After the `squareVertexBuffer` has been configured, we instruct the currently
    bound VAO (i.e. `squareVAO`) on how to extract data given the instructions for
    `aVertexPosition`. These instructions are the same ones that previously sat inside
    of the `draw` function; but now, they happen *once *during initialization.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置了`squareVertexBuffer`之后，我们指导当前绑定的VAO（即`squareVAO`）如何根据`aVertexPosition`的指令提取数据。这些指令与之前位于`draw`函数中的指令相同；但现在，它们在初始化时只发生一次。
- en: 'Lastly, we need to use this VAO in our `draw` function:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的`draw`函数中使用这个VAO：
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The updated `draw` function is far simpler! We simply bind the VAO (i.e. `squareVAO`)
    and allow for it to handle the instructions we provided it inside of `initBuffers`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新的`draw`函数要简单得多！我们只需绑定VAO（即`squareVAO`），并允许它在`initBuffers`中处理我们提供的指令。
- en: Lastly, it's good practice to unbind buffers and VAOs after usage by providing
    `null` values.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用后解除缓冲区和VAO的绑定是一个好习惯，通过提供`null`值来实现。
- en: 'Save the file and open it in your browser. You should see the same square being
    rendered using a VAO:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中打开它。你应该会看到使用VAO渲染的相同正方形：
- en: '![](img/29fb58a7-d500-4205-90eb-6c336690bc22.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29fb58a7-d500-4205-90eb-6c336690bc22.png)'
- en: The source code for this exercise can be found in `ch02_03_square-vao.html`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个练习的源代码可以在`ch02_03_square-vao.html`中找到。
- en: Given that we're currently rendering a single geometry, using a VAO may seem
    unnecessarily complex. That is a reasonable assessment! However, as the complexity
    of our application grows, using VAOs becomes a foundational feature.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前正在渲染单个几何体，使用VAO可能看起来是不必要的复杂。这是一个合理的评估！然而，随着我们应用程序的复杂性增加，使用VAO成为了一个基础特性。
- en: Time for Action: Rendering Modes
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：渲染模式
- en: 'Let''s revisit the signature of the `drawElements` function:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`drawElements`函数的签名：
- en: '[PRE19]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first parameter determines the type of primitives that we are rendering.
    In the following section, we will see the different rendering modes with examples.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数确定我们要渲染的图元类型。在下一节中，我们将通过示例看到不同的渲染模式。
- en: 'Follow the given steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Open the `ch02_04_rendering-modes.html` file in your browser. This example follows
    the same structure as in the previous section.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`ch02_04_rendering-modes.html`文件。这个例子与上一节的结构相同。
- en: 'Open `ch02_04_rendering-modes.html` in your editor and scroll down to the `initBuffers` function:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`ch02_04_rendering-modes.html`文件，并滚动到`initBuffers`函数：
- en: '[PRE20]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, you will see that we are drawing a trapezoid. However, on screen, you
    will see two triangles! Later, we'll see how this happened.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，你会看到我们在绘制一个梯形。然而，在屏幕上，你会看到两个三角形！稍后，我们将看到这是如何发生的。
- en: 'At the top of the page, there is a settings controller that allows you to select
    the different rendering modes that WebGL provides:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面顶部，有一个设置控制器，允许你选择WebGL提供的不同渲染模式：
- en: '![](img/142fa15e-666d-4653-bb3e-353f5aa521f0.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/142fa15e-666d-4653-bb3e-353f5aa521f0.png)'
- en: '[PRE21]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you select any option from the settings, you are changing the value of
    the `renderingMode` variable defined at the top of the code (scroll up if you
    want to see where it is defined). The code that sets up the settings controller
    is inside the `initControls` function. We will cover this functionality later.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你从设置中选择任何选项时，你正在改变代码顶部定义的`renderingMode`变量的值（如果你想看到它的定义位置，请向上滚动）。设置控制器设置的代码位于`initControls`函数中。我们将在稍后介绍这个功能。
- en: 'To see how each option modifies the rendering, scroll to the `draw` function:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看每个选项如何修改渲染，请滚动到`draw`函数：
- en: '[PRE22]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will see that after binding the IBO `trapezoidIndexBuffer` with the following
    instruction:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到在绑定IBO `trapezoidIndexBuffer`的以下指令之后：
- en: '[PRE23]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You also have a switch statement where there is some code that executes, depending
    on the value of the `renderingMode` variable.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还有一个switch语句，其中有一些代码会根据`renderingMode`变量的值执行。
- en: For each mode, we define the contents of the JavaScript array indices. Then,
    we pass this array to the currently-bound buffer, `trapezoidIndexBuffer`, by using
    the `bufferData` function. Finally, we call the `drawElements` function.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每种模式，我们定义JavaScript数组索引的内容。然后，我们通过使用`bufferData`函数将这个数组传递给当前绑定的缓冲区，即`trapezoidIndexBuffer`。最后，我们调用`drawElements`函数。
- en: 'Let''s see what each mode does:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看每种模式的作用：
- en: '| **Mode** | **Description** |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **描述** |'
- en: '| `TRIANGLES` | When you use the `TRIANGLES` mode, WebGL will use the first
    three indices defined in your IBO to construct the first triangle, the next three
    to construct the second triangle, and so on.In this example, we are drawing two
    triangles, which can be verified by examining the JavaScript indices array that
    populates the IBO: `indices = [0, 1, 2, 2, 3, 4];`. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `TRIANGLES` | 当您使用`TRIANGLES`模式时，WebGL将使用您在IBO中定义的前三个索引来构建第一个三角形，接下来三个来构建第二个三角形，依此类推。在这个例子中，我们正在绘制两个三角形，这可以通过检查填充IBO的JavaScript索引数组来验证：`indices
    = [0, 1, 2, 2, 3, 4];`。|'
- en: '| `LINES` | The `LINES` mode will instruct WebGL to take each consecutive pair
    of indices defined in the IBO and draw lines by taking the coordinates of the
    corresponding vertices.For instance, `indices = [1, 3, 0, 4, 1, 2, 2, 3];` will
    draw four lines: from vertex number `1` to vertex number `3`, from vertex number
    `0` to vertex number `4`, from vertex number `1` to vertex number `2`, and from
    vertex number `2` to vertex number `3`. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `LINES` | `LINES`模式将指示WebGL根据IBO中定义的连续索引对绘制线条，通过获取相应顶点的坐标。例如，`indices = [1,
    3, 0, 4, 1, 2, 2, 3];`将绘制四条线：从顶点编号`1`到顶点编号`3`，从顶点编号`0`到顶点编号`4`，从顶点编号`1`到顶点编号`2`，以及从顶点编号`2`到顶点编号`3`。|'
- en: '| `POINTS` | When we use the `POINTS` mode, WebGL will not generate surfaces.
    Instead, it will render the vertices that we had defined using the index array.In
    this example, we will only render vertices number `1`, `2`, and `3` with `indices
    = [1, 2, 3];`. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `POINTS` | 当我们使用`POINTS`模式时，WebGL不会生成表面。相反，它将使用索引数组渲染我们定义的顶点。在这个例子中，我们将只使用`indices
    = [1, 2, 3];`渲染顶点编号`1`、`2`和`3`。|'
- en: '| `LINE_LOOP` | `LINE_LOOP` draws a closed loop connecting the vertices defined
    in the IBO to the next one.In our case, it will be `indices = [2, 3, 4, 1, 0];`.
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `LINE_LOOP` | `LINE_LOOP` 绘制一个闭合循环，将IBO中定义的顶点连接到下一个顶点。在我们的情况下，它将是`indices
    = [2, 3, 4, 1, 0];`。|'
- en: '| `LINE_STRIP` | `LINE_STRIP` is similar to `LINE_LOOP`. The difference is
    that WebGL does not connect the last vertex to the first one (not a closed loop).The indices JavaScript
    array will be `indices = [2, 3, 4, 1, 0];`. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `LINE_STRIP` | `LINE_STRIP` 与`LINE_LOOP`类似。区别在于WebGL不会将最后一个顶点连接到第一个顶点（不是闭合循环）。`indices`JavaScript数组将是`indices
    = [2, 3, 4, 1, 0];`。|'
- en: '| `TRIANGLE_STRIP` | `TRIANGLE_STRIP` draws connected triangles. Every vertex
    is specified after the first three.In our example, vertices number `0`, number
    `1`, and number `2` create a new triangle. If we have `indices = [0, 1, 2, 3,
    4];`, then we will generate the triangles *(0, 1, 2)*, *(1, 2, 3)*, and *(2, 3,
    4)*. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `TRIANGLE_STRIP` | `TRIANGLE_STRIP` 绘制连接的三角形。在第一个三个顶点之后指定每个顶点。在我们的例子中，顶点编号`0`、`1`和`2`创建了一个新的三角形。如果我们有`indices
    = [0, 1, 2, 3, 4];`，那么我们将生成三角形*(0, 1, 2)*、*(1, 2, 3)*和*(2, 3, 4)*。|'
- en: '| `TRIANGLE_FAN` | `TRIANGLE_FAN` creates triangles in a similar way to `TRIANGLE_STRIP`.
    However, the first vertex defined in the IBO is taken as the origin of the fan
    (the only shared vertex among consecutive triangles).In our example, `indices
    = [0, 1, 2, 3, 4];` will create the triangles *(0, 1, 2)* and *(0, 3, 4)*. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `TRIANGLE_FAN` | `TRIANGLE_FAN` 以类似于`TRIANGLE_STRIP`的方式创建三角形。然而，在IBO中定义的第一个顶点被用作扇形的起点（连续三角形之间的唯一共享顶点）。在我们的例子中，`indices
    = [0, 1, 2, 3, 4];`将创建三角形*(0, 1, 2)*和*(0, 3, 4)*。|'
- en: 'The following diagram can be useful in visualizing these various rendering
    modes. That being said, it''s easiest to see these modes in action by changing
    the setting''s drop-down values and seeing the various results:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的图示可以帮助可视化这些不同的渲染模式。但说到底，通过更改设置的下拉值并查看各种结果，最容易看到这些模式的效果：
- en: '![](img/22264ffd-5283-4738-a52a-7ff3b1271121.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22264ffd-5283-4738-a52a-7ff3b1271121.png)'
- en: Let's make some changes by editing `ch02_04_rendering-modes.html` so that when
    you select the `TRIANGLES` option, you render the trapezoid instead of two triangles.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过编辑`ch02_04_rendering-modes.html`来做出一些更改，以便当您选择`TRIANGLES`选项时，渲染梯形而不是两个三角形。
- en: '**Hint**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You need one extra triangle in the indices array.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在`indices`数组中添加一个额外的三角形。
- en: Save the file and test it in your browser.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中测试它。
- en: Edit the web page so that you draw the letter **M** using the `LINES` option.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑网页，以便使用`LINES`选项绘制字母**M**。
- en: Hint
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You need to define four lines in the indices array.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在`indices`数组中定义四条线。
- en: Just like before, save your changes and test them in your browser.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像之前一样，保存您的更改并在浏览器中测试它们。
- en: Using the `LINE_LOOP` mode, draw only the boundary of the trapezoid.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`LINE_LOOP`模式，只绘制梯形的边界。
- en: '***What just happened?***'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: This simple exercise helped us see the different rendering modes supported by
    WebGL. These different modes determine how to interpret vertex and index data
    to render an object.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的练习帮助我们看到了WebGL支持的不同渲染模式。这些不同的模式决定了如何解释顶点和索引数据以渲染对象。
- en: 'WebGL as a State Machine: Buffer Manipulation'
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL作为状态机：缓冲区操作
- en: When dealing with buffers for the `getParameter`, `getBufferParameter`, and `isBuffer` functions,
    new information about the state of the rendering pipeline becomes available to
    us.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理`getParameter`、`getBufferParameter`和`isBuffer`函数的缓冲区时，关于渲染管线状态的新信息对我们变得可用。
- en: 'Similar to [Chapter 1](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml), *Getting
    Started*, we will use `getParameter(parameter)`, where parameter can have the
    following values:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第1章](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml) *入门* 类似，我们将使用`getParameter(parameter)`，其中`parameter`可以有以下值：
- en: '`ARRAY_BUFFER_BINDING`: Retrieves a reference to the currently-bound VBO'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARRAY_BUFFER_BINDING`: 获取当前绑定的VBO的引用'
- en: '`ELEMENT_ARRAY_BUFFER_BINDING`: Retrieves a reference to the currently-bound
    IBO'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELEMENT_ARRAY_BUFFER_BINDING`: 获取当前绑定的IBO的引用'
- en: 'We can also query the size and the usage of the currently-bound VBO and IBO
    using `getBufferParameter(type, parameter)`, where type can have the following
    values:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`getBufferParameter(type, parameter)`查询当前绑定的VBO和IBO的大小和用途，其中`type`可以有以下值：
- en: '`ARRAY_BUFFER`: To refer to the currently-bound VBO'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARRAY_BUFFER`: 用于引用当前绑定的VBO'
- en: '`ELEMENT_ARRAY_BUFFER`: To refer to the currently-bound IBO'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELEMENT_ARRAY_BUFFER`: 用于引用当前绑定的IBO'
- en: 'And parameter can have the following values:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`parameter`可以有以下值：
- en: '`BUFFER_SIZE`: Returns the size of the requested buffer'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUFFER_SIZE`: 返回请求的缓冲区大小'
- en: '`BUFFER_USAGE`: Returns the usage of the requested buffer'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUFFER_USAGE`: 返回请求的缓冲区的使用情况'
- en: '**Binding Buffers**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**绑定缓冲区**'
- en: Your VBO and/or IBO needs to be bound when you inspect the state of the currently-bound
    VBO and/or IBO with `getParameter` and `getBufferParameter`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`getParameter`和`getBufferParameter`检查当前绑定的VBO和/或IBO的状态时，你的VBO和/或IBO需要被绑定。
- en: Finally, `isBuffer(object)` will return `true` if the object is a WebGL buffer,
    or `false` with an error when the buffer is invalid. Unlike `getParameter` and `getBufferParameter`, `isBuffer` does
    not require any VBO or IBO to be bound.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`isBuffer(object)`如果对象是WebGL缓冲区，将返回`true`，如果缓冲区无效，则返回`false`并出现错误。与`getParameter`和`getBufferParameter`不同，`isBuffer`不需要绑定任何VBO或IBO。
- en: 'Time for Action: Querying the State of Buffers'
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：查询缓冲区状态
- en: 'Follow the given steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 按照给定的步骤进行：
- en: 'Open the `ch02_05_state-machine.html` file in your browser. You should see
    the following:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`ch02_05_state-machine.html`文件。你应该看到以下内容：
- en: '![](img/429910d1-7f7c-4a50-a5d9-abdc8e529cc3.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/429910d1-7f7c-4a50-a5d9-abdc8e529cc3.png)'
- en: 'Open `ch02_05_state-machine.html` in your editor and scroll down to the `initBuffers` method:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`ch02_05_state-machine.html`，并滚动到`initBuffers`方法：
- en: '[PRE24]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Pay attention to how we use the methods discussed in this section to retrieve
    and display information about the current state of the buffers.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们如何使用本节中讨论的方法来检索和显示缓冲区当前状态的信息。
- en: The information queried by the `initBuffers` function is shown in the settings
    section of the web page when we use `updateInfo`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用`updateInfo`时，`initBuffers`函数查询的信息显示在网页的设置部分。
- en: 'In the settings section of the web page, you will see the following result:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页的设置部分，你会看到以下结果：
- en: '![](img/43adbdf7-8f9d-48c9-826f-4c328423a54b.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43adbdf7-8f9d-48c9-826f-4c328423a54b.png)'
- en: Copy the following line, `gl.bindBuffer(gl.ARRAY_BUFFER, null);`, and paste
    it right before the following line inside of the `initBuffers` function: `coneIndexBuffer
    = gl.createBuffer();`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制以下行，`gl.bindBuffer(gl.ARRAY_BUFFER, null);`，并将其粘贴到`initBuffers`函数中以下行之前：`coneIndexBuffer
    = gl.createBuffer();`。
- en: What happens when you launch the page in your browser again?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在浏览器中再次打开页面时会发生什么？
- en: Why do you think this behavior occurs?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为这种行为为什么会发生？
- en: '***What just happened?***'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '***究竟发生了什么？***'
- en: You have learned that the currently-bound buffer is a state variable in WebGL.
    The buffer is bound until you unbind it by calling `bindBuffer` again with the
    corresponding type (`ARRAY_BUFFER` or `ELEMENT_ARRAY_BUFFER`) as the first parameter
    and with `null` as the second argument (that is, no buffer to bind). You have
    also learned that you can only query the state of the currently-bound buffer.
    Therefore, if you want to query a different buffer, you need to bind it first.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到，当前绑定的缓冲区是 WebGL 中的一个状态变量。缓冲区绑定直到你通过再次调用 `bindBuffer` 并将相应的类型（`ARRAY_BUFFER`
    或 `ELEMENT_ARRAY_BUFFER`）作为第一个参数，以及 `null` 作为第二个参数（即没有要绑定的缓冲区）来解绑它。你也已经了解到，你只能查询当前绑定的缓冲区的状态。因此，如果你想查询不同的缓冲区，你需要先绑定它。
- en: 'Have a Go: Add One Validation'
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下：添加一个验证
- en: Modify the file so that you can validate and show on screen whether the indices array
    and the `coneIndexBuffer` are WebGL buffers.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 修改文件，以便你可以验证并显示在屏幕上索引数组和 `coneIndexBuffer` 是否是 WebGL 缓冲区。
- en: '**Hint**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: In order to display the values, you will have to modify the table in the HTML
    body and modify the `updateInfo` function accordingly.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示值，你将不得不修改 HTML 体内的表格，并相应地修改 `updateInfo` 函数。
- en: Advanced Geometry-Loading Techniques
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级几何加载技术
- en: So far, we’ve rendered very simple objects. Now, let's investigate how to load
    a geometry (vertices and indices) from a file instead of declaring the vertices
    and indices every time we call `initBuffers`. To do this, we will make asynchronous
    calls to the web server using AJAX. We will retrieve the file with our geometry
    from the web server and then use the built-in JSON parser to convert the context
    of our files into JavaScript objects. In our case, these objects will be the vertices and indices arrays.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们渲染了非常简单的对象。现在，让我们研究如何从文件中加载几何形状（顶点和索引）而不是每次调用 `initBuffers` 时都声明顶点和索引。为此，我们将使用
    AJAX 对网络服务器进行异步调用。我们将从网络服务器检索包含我们几何形状的文件，然后使用内置的 JSON 解析器将文件的上下文转换为 JavaScript
    对象。在我们的例子中，这些对象将是顶点和索引数组。
- en: Introduction to JavaScript Object Notation (JSON)
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 对象表示法（JSON）简介
- en: '**JSON** stands for **JavaScript Object Notation**. It is a lightweight, text-based,
    open format used for data interchange. JSON is commonly used as an alternative
    to XML.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON** 代表 **JavaScript 对象表示法**。它是一种轻量级、基于文本的开放格式，用于数据交换。JSON 通常用作 XML 的替代品。'
- en: The power of JSON is that it's language-agnostic. This means that there are
    parsers in many languages to read and interpret JSON objects. Also, JSON is a
    subset of the object literal notation of JavaScript. Therefore, we can define
    JavaScript objects using JSON.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 的强大之处在于它是语言无关的。这意味着有许多语言的解析器可以读取和解释 JSON 对象。此外，JSON 是 JavaScript 对象字面量表示法的子集。因此，我们可以使用
    JSON 定义 JavaScript 对象。
- en: Defining JSON-Based 3D Models
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义基于 JSON 的 3D 模型
- en: 'Let''s assume, for example, that we have a model object with two arrays: vertices and indices.
    Say that these arrays contain the information described in the cone example (`ch02_06_cone.html`),
    as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个包含两个数组：顶点 `vertices` 和索引 `indices` 的 `model` 对象。假设这些数组包含圆锥示例（`ch02_06_cone.html`）中描述的信息，如下所示：
- en: '[PRE25]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Following the JSON notation, we would represent these two arrays as an object,
    as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 JSON 语法，我们会将这些两个数组表示为一个对象，如下所示：
- en: '[PRE26]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Based on this example, we can infer the following syntax rules:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此示例，我们可以推断出以下语法规则：
- en: The extent of a JSON object is defined by curly brackets (`{}`).
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 对象的范围由大括号 (`{}`) 定义。
- en: Attributes in a JSON object are separated by commas (`,`).
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 对象中的属性由逗号 (`,` ) 分隔。
- en: There is no comma after the last attribute.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个属性后没有逗号。
- en: 'Each attribute of a JSON object has two parts: a **key **and a **value.**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 对象的每个属性由两部分组成：一个 **键** 和一个 **值**。
- en: The name of an attribute is enclosed by quotation marks (`""`).
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的名称用引号 (`""`) 括起来。
- en: Each attribute key is separated from its corresponding value with a colon (`:`).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个属性键与其对应的值之间用冒号 (`:`) 分隔。
- en: Attributes of the array are defined in the same way you would define them in
    JavaScript.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的属性定义方式与你在 JavaScript 中定义它们的方式相同。
- en: 'Time for Action: Encoding and Decoding JSON'
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：编码和解码 JSON
- en: 'Most modern web browsers support native JSON encoding and decoding. Let''s
    examine the methods available inside this object:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代网络浏览器支持原生的 JSON 编码和解码。让我们来看看这个对象内部可用的方法：
- en: '| **Method** | **Description** |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `JSON.stringify(object)` | We use `JSON.stringify` to convert JavaScript
    objects to JSON-formatted text. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `JSON.stringify(object)` | 我们使用 `JSON.stringify` 将 JavaScript 对象转换为 JSON
    格式的文本。|'
- en: '| `JSON.parse(string)` | We use `JSON.parse` to convert text into JavaScript
    objects. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `JSON.parse(string)` | 我们使用 `JSON.parse` 将文本转换为 JavaScript 对象。|'
- en: 'Let''s learn how to encode and decode with the JSON notation by creating a
    simple model—a 3D line. Here, we will be focusing on how we do JSON encoding and
    decoding. Follow the given steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个简单的模型——一个 3D 线——来学习如何使用 JSON 符号进行编码和解码。在这里，我们将关注我们如何进行 JSON 编码和解码。按照以下步骤进行：
- en: 'In your browser, open the interactive JavaScript console. Use the following
    table for assistance:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开交互式 JavaScript 控制台。使用以下表格进行帮助：
- en: '| **Browser** | **Shortcut keys (PC/Mac)** |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| **浏览器** | **快捷键（PC/Mac）** |'
- en: '| Firefox | *Ctrl *+ *Shift *+* K*/*Command *+* Alt *+* K* |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| Firefox | *Ctrl *+ *Shift *+* K*/*Command *+* Alt *+* K* |'
- en: '| Safari | *Ctrl *+* Shift *+* C*/*Command *+* Alt *+* C* |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| Safari | *Ctrl *+* Shift *+* C*/*Command *+* Alt *+* C* |'
- en: '| Chrome | *Ctrl *+* Shift *+* J*/*Command *+* Alt* +* J* |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| Chrome | *Ctrl *+* Shift *+* J*/*Command *+* Alt* +* J* |'
- en: 'Create a JSON object by typing the following:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下内容创建一个 JSON 对象：
- en: '[PRE27]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Verify that the model is an object by writing the following:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写以下内容来验证模型是否为对象：
- en: '[PRE28]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: JavaScript Type-Checking
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 类型检查
- en: Since many things in JavaScript are *objects*, it is recommended that you are
    more rigorous with type-checking. We will just use `typeof`for demonstration purposes.
    Additionally, there are many utility libraries, such as Lodash ([https://lodash.com](https://lodash.com/)), that
    extend JavaScript features to provide these operations and more.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 中的许多东西都是 *对象*，建议你在类型检查上更加严谨。我们在这里仅使用 `typeof` 进行演示。此外，还有许多实用库，如
    Lodash ([https://lodash.com](https://lodash.com/))，它扩展了 JavaScript 功能，提供了这些操作以及更多。
- en: 'Let''s print the model attributes. Write this in the console (press *Enter* at
    the end of each line):'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打印模型属性。在控制台中输入以下内容（每行输入后按 *Enter*）：
- en: '[PRE29]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s create a JSON text:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 JSON 文本：
- en: '[PRE30]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What happens when you type `text.vertices`?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你输入 `text.vertices` 时会发生什么？
- en: As you can see, you get a message saying that `text.vertices` is `undefined`.
    This happens because text is not a JavaScript object, but a `string` with the
    peculiarity of being written according to JSON notation to describe an `object`.
    Everything in it is text, and so it does not have any fields.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，您会收到一条消息，表明 `text.vertices` 是 `undefined`。这是因为文本不是一个 JavaScript 对象，而是一个按照
    JSON 符号编写的 `string`，用来描述一个 `object`。它里面的所有内容都是文本，因此它没有任何字段。
- en: 'Let''s convert the JSON text back into an object. Type the following:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 JSON 文本转换回对象。输入以下内容：
- en: '[PRE31]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***What just happened?***'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We have learned to encode and decode JSON objects. These exercises are relevant
    because we will use the same process to define our geometry to be loaded from
    external files. In the next section, we will see how to download geometric models
    specified with JSON from a web server.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何编码和解码 JSON 对象。这些练习是相关的，因为我们将使用相同的过程来定义从外部文件加载的几何形状。在下一节中，我们将看到如何从网络服务器下载用
    JSON 指定的几何模型。
- en: Asynchronous Loading with AJAX
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AJAX 进行异步加载
- en: 'The following diagram summarizes the asynchronous loading of files by the web
    browser using AJAX:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了网页浏览器使用 AJAX 异步加载文件的过程：
- en: '![](img/8c7a9d35-44e1-4c8e-a678-278d6ceb0978.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c7a9d35-44e1-4c8e-a678-278d6ceb0978.png)'
- en: 'Let''s analyze this more closely:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地分析一下：
- en: '**Request File**: Indicates the path to the file you want to load. Remember
    that this file contains the geometry that we will be loading from the web server
    instead of coding the JavaScript arrays (vertices and indices) directly into the
    web page.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求文件**：指示您想要加载的文件的路径。请记住，这个文件包含我们将从网络服务器加载的几何形状，而不是直接将 JavaScript 数组（顶点和索引）编码到网页中。'
- en: '**AJAX Request**: We need to write a function that will perform the AJAX request.
    Let''s call this function `load`. The code looks like this:'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AJAX 请求**：我们需要编写一个执行 AJAX 请求的函数。让我们称这个函数为 `load`。代码如下：'
- en: '[PRE32]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: AJAX Requests with FetchWe are leveraging `fetch`, an AJAX API provided in modern
    browsers, for fetching resources. It is very convenient with a **Promise**-based
    implementation. To learn more about `fetch`, visit [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fetch 的 AJAX 请求我们正在利用现代浏览器提供的 AJAX API，即 `fetch`，来获取资源。它基于 **Promise** 的实现非常方便。要了解更多关于 `fetch`
    的信息，请访问 [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。
- en: For now, let's say that this function will perform the AJAX request.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们假设这个函数将执行 AJAX 请求。
- en: '**Retrieving the file**: The web server will receive and treat our request
    as a regular HTTP request. In fact, the server does not know that this request
    is *asynchronous *(it is asynchronous for the web browser since it does not wait
    for the answer). The server will look for our file and generate a response, regardless
    of whether it finds the request.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检索文件**：网络服务器将接收并处理我们的请求作为一个常规 HTTP 请求。实际上，服务器并不知道这个请求是**异步的**（对于浏览器来说它是异步的，因为它不会等待答案）。服务器将寻找我们的文件并生成一个响应，无论它是否找到请求。'
- en: '**Asynchronous response**: Once a response is sent to the web browser, the
    `fetch` promise is resolved and the provided callback is invoked. This callback
    corresponds to the `then` request method. If the request is successful, we invoke
    the `then` callback; if it fails, we invoke the `catch` callback.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步响应**：一旦将响应发送到浏览器，`fetch` Promise 就会解决，并调用提供的回调。这个回调对应于`then`请求方法。如果请求成功，我们调用`then`回调；如果失败，我们调用`catch`回调。'
- en: '**Handling the loaded model**: After our data is received and parsed, we attach
    a new callback to process the file retrieved from the server. Please notice that
    in the previous segment of code, we used the promise-based JSON parser to create
    a JavaScript object from the file before passing it to the next function. The
    code for the `load` function looks like this:'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理加载的模型**：在数据接收并解析后，我们为从服务器检索的文件附加一个新的回调来处理。请注意，在前面的代码段中，我们使用了基于 Promise
    的 JSON 解析器在传递给下一个函数之前将文件转换为 JavaScript 对象。`load`函数的代码如下：'
- en: '[PRE33]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you look closely, you’ll realize that this function is very similar to one
    of the functions we saw previously: the `initBuffers` function. This is reasonable,
    given that we cannot initialize the buffers until we retrieve the geometry data
    from the server. Just like `initBuffers`, we configure our VAO, VBO, and IBO and
    pass them the information contained in the JavaScript arrays of our model object.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您会发现这个函数与我们之前看到的一个函数非常相似：`initBuffers`函数。这是合理的，因为我们不能在从服务器检索几何数据之前初始化缓冲区。就像`initBuffers`一样，我们配置我们的VAO、VBO和IBO，并将我们的模型对象中包含的信息传递给它们。
- en: Setting up a Web Server
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置网络服务器
- en: 'Now that we''re fetching assets from a server, we need to serve our application
    by using a server. If you do *not* have a web server, we recommend that you install
    a lightweight web server from the following options:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从服务器获取资源，我们需要通过服务器来提供服务。如果您没有网络服务器，我们建议您从以下选项中安装一个轻量级网络服务器：
- en: '**Serve: **[https://github.com/zeit/serve](https://github.com/zeit/serve)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Serve：**[https://github.com/zeit/serve](https://github.com/zeit/serve)'
- en: '**Lighttpd: **[http://www.lighttpd.net](http://www.lighttpd.net/)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lighttpd：**[http://www.lighttpd.net](http://www.lighttpd.net/)'
- en: '**Python Server: **[https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server)'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 服务器：**[https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server)'
- en: Hosting ExamplesAlthough any web server will be able to serve these examples,
    `serve` provides simplicity and great functionality. That being said, be sure
    to run your server from the root of the examples directory, since the `common` directory
    is a shared dependency across chapters.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 主机示例尽管任何网络服务器都可以提供这些示例，但`serve`提供了简单性和强大的功能。话虽如此，请确保您从示例目录的根目录运行您的服务器，因为`common`目录是跨章节的共享依赖项。
- en: Working Around the Web Server Requirement
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决网络服务器需求的问题
- en: If you have Firefox and do not want to install a web server, you can change
    `strict_origin_policy` to false in `about:config`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Firefox 并且不想安装网络服务器，您可以在`about:config`中将`strict_origin_policy`更改为false。
- en: 'If you are using Chrome and do not want to install a web server, make sure
    that you run it from the command line with the following modifier:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Chrome 并且不想安装网络服务器，请确保您从命令行使用以下修饰符运行它：
- en: '[PRE34]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's use AJAX and JSON to load a cone from our web server.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 AJAX 和 JSON 从我们的网络服务器加载一个圆锥体。
- en: 'Time for Action: Loading a Cone with AJAX'
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间：使用 AJAX 加载圆锥体
- en: 'Follow the given steps:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Make sure that your web server is running and access the `ch02_07_ajax-cone.html` file
    using your web server.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的网络服务器正在运行，并使用您的网络服务器访问`ch02_07_ajax-cone.html`文件。
- en: Web Server Address
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器地址
- en: You know that you are using the web server if the URL in the address bar starts
    with `localhost/` or `127.0.0.1/` instead of `file://`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你正在使用网络服务器，地址栏中的 URL 以 `localhost/` 或 `127.0.0.1/` 开头而不是 `file://`，那么你就知道了。
- en: 'The folder containing the code for this chapter should look like this:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含本章代码的文件夹应该看起来像这样：
- en: '![](img/0eb95e36-93cf-4cc9-be0c-19c312fe1a7f.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0eb95e36-93cf-4cc9-be0c-19c312fe1a7f.png)'
- en: Click on `ch02_07_ajax-cone.html`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `ch02_07_ajax-cone.html`。
- en: 'The example will load in your browser and you will see something similar to
    this:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例将在你的浏览器中加载，你会看到类似这样的：
- en: '![](img/2f7e96fe-8a28-431d-936a-4f8c32cf6620.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f7e96fe-8a28-431d-936a-4f8c32cf6620.png)'
- en: Please review the `load` functions to better understand the use of AJAX and
    JSON in the application.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请审查 `load` 函数以更好地理解 AJAX 和 JSON 在应用程序中的使用。
- en: How is the global `model` variable used? *(Check the source code.)*
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局 `model` 变量是如何使用的？ *(检查源代码。)*
- en: Check what happens when you change the color in the `common/models/geometries/cone.json` file
    and reload the page.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当你更改 `common/models/geometries/cone.json` 文件中的颜色并重新加载页面时会发生什么。
- en: Modify the coordinates of the cone in the `common/models/geometries/cone.json` file
    and reload the page. Here, you can verify that WebGL reads and renders the coordinates
    from the file. If you modify them in the file, the geometry will be updated on
    the screen.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `common/models/geometries/cone.json` 文件中圆锥的坐标并重新加载页面。在这里，你可以验证 WebGL 是否从文件中读取和渲染坐标。如果你在文件中修改它们，屏幕上的几何形状将更新。
- en: '***What just happened?***'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: You learned how to use AJAX and JSON to load geometries from a remote location
    (web server) instead of specifying these geometries (using JavaScript arrays)
    inside the web page.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何使用 AJAX 和 JSON 从远程位置（网络服务器）加载几何形状，而不是在网页内部指定这些几何形状（使用 JavaScript 数组）。
- en: 'Have a Go: Loading a Nissan GTR'
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试加载一辆日产GTR
- en: 'Follow the given steps:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Open the `ch02_08_ajax-car.html` file using your web server.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的网络服务器打开 `ch02_08_ajax-car.html` 文件。
- en: 'You should see something like this:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到类似这样的：
- en: '![](img/ce4fd31d-c4eb-4701-abcd-416ccd53f68e.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce4fd31d-c4eb-4701-abcd-416ccd53f68e.png)'
- en: The reason we selected the `LINES` model instead of the `TRIANGLES` model is
    to easily visualize the structure of the car.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择 `LINES` 模型而不是 `TRIANGLES` 模型的原因是易于可视化汽车的结构。
- en: Find the line where the rendering mode is being selected and make sure that
    you understand what the code does.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到选择渲染模式的行，并确保你理解代码的作用。
- en: Go to the `draw` function.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `draw` 函数。
- en: In the `drawElements` instruction, change the mode from `gl.LINES` to `gl.TRIANGLES`.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `drawElements` 指令中，将模式从 `gl.LINES` 更改为 `gl.TRIANGLES`。
- en: Refresh the page in the web browser.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络浏览器中刷新页面。
- en: What do you see? Can you guess why the visuals are different? What is your rationale?
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你看到了什么？你能猜出为什么视觉效果不同吗？你的推理是什么？
- en: Lights
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光
- en: Illumination helps us visualize complex geometries more clearly. Without lights,
    all of our volumes will look opaque, and it will be difficult to distinguish their
    parts when changing from `LINES` to `TRIANGLES`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 照明帮助我们更清晰地可视化复杂几何形状。没有灯光，我们所有的体积看起来都是不透明的，当从 `LINES` 切换到 `TRIANGLES` 时，很难区分它们的各个部分。
- en: Architecture Updates
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构更新
- en: 'Let''s cover some useful functions that we can refactor for use in later chapters:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一些有用的函数，我们可以重构它们以在后续章节中使用：
- en: Open `common/js/utils.js` in your editor to see the following changes.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开 `common/js/utils.js`，查看以下更改。
- en: 'We have added two additional methods, `autoResizeCanvas` and `getShader`, to `utils.js` that
    look very similar to the code we implemented earlier in this chapter:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `utils.js` 中添加了两个额外的函数，`autoResizeCanvas` 和 `getShader`，它们看起来与我们本章早期实现的代码非常相似：
- en: '[PRE35]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `autoResizeCanvas` method takes a `canvas` element and dynamically resizes
    it to be fullscreen by watching browser-resizing events.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`autoResizeCanvas` 方法接受一个 `canvas` 元素，并通过监听浏览器调整大小事件动态调整其大小以全屏显示。'
- en: The `getShader` function takes a `gl` instance and an `id` script to compile
    and return the shader source. Internally, `getShader` reads the source code of
    the script and stores it in a local variable. Then, it creates a new shader by
    using the WebGL `createShader` function. After that, it will add the source code
    to it using the `shaderSource` function. Finally, it will try to compile the shader
    using the `compileShader` function.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getShader` 函数接受一个 `gl` 实例和一个 `id` 脚本来编译并返回着色器源代码。内部，`getShader` 读取脚本的源代码并将其存储在局部变量中。然后，它通过使用
    WebGL 的 `createShader` 函数创建一个新的着色器。之后，它将源代码添加到其中使用 `shaderSource` 函数。最后，它将尝试使用
    `compileShader` 函数编译着色器。'
- en: Open `ch02_09_ajax-car-final.html` in your editor to see the following changes.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开 `ch02_09_ajax-car-final.html` 以查看以下更改。
- en: 'Scroll to the `init` function where the necessary changes were made to use
    the `utils.autoResizeCanvas` method:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 `init` 函数，那里进行了必要的修改以使用 `utils.autoResizeCanvas` 方法：
- en: '[PRE36]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Scroll to the `initProgram` function inside of `ch02_09_ajax-car-final.html`,
    where the necessary changes were made to use the `utils.getShader` method:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 `ch02_09_ajax-car-final.html` 文件中的 `initProgram` 函数，那里进行了必要的修改以使用 `utils.getShader`
    方法：
- en: '[PRE37]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Open `ch02_09_ajax-car-final.html` in a browser to see these changes in action.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `ch02_09_ajax-car-final.html` 以查看这些更改的效果。
- en: Summary
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let’s summarize what we’ve learned in this chapter:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所学的内容：
- en: The WebGL API itself is just a rasterizer and, conceptually, is fairly simple.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL API 本身只是一个光栅化器，从概念上讲相当简单。
- en: WebGL's rendering pipeline describes how the WebGL buffers are used and passed
    in the form of attributes to be processed by the vertex shader. The vertex shader
    parallelizes vertex processing in the GPU. Vertices define the surface of the
    geometry that is going to be rendered. Every element on this surface is known
    as a fragment. These fragments are processed by the fragment shader.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL 的渲染管线描述了如何使用 WebGL 缓冲区，并将它们以属性的形式传递给顶点着色器进行处理。顶点着色器在 GPU 中并行化顶点处理。顶点定义了将要渲染的几何体的表面。表面上的每个元素都称为片段。这些片段由片段着色器处理。
- en: Fragment processing also occurs in parallel in the GPU. When all fragments have
    been processed, the framebuffer, a two-dimensional array, contains the image that
    is then displayed on your screen.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段处理也在 GPU 中并行进行。当所有片段都处理完毕后，帧缓冲区，一个二维数组，包含随后在屏幕上显示的图像。
- en: WebGL is actually a pretty simple API. Its job is to execute two user-supplied
    functions, a vertex shader and fragment shader, and draw triangles, lines, or
    points. While it can get more complicated to do 3D, that complication is added
    by you, the programmer, in the form of more complex shaders.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL 实际上是一个相当简单的 API。它的任务是执行两个用户提供的函数，一个顶点着色器和片段着色器，并绘制三角形、线条或点。虽然进行 3D 操作可能会更复杂，但这种复杂性是由程序员通过更复杂的着色器添加的。
- en: The fine details of how WebGL renders geometry. Remember that there are two
    kinds of WebGL buffers that deal with geometry rendering: VBOs and IBOs*.*
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL 渲染几何体的详细过程。请记住，有两种 WebGL 缓冲区用于处理几何渲染：VBOs 和 IBOs*.*
- en: WebGL works as a state machine. As such, properties referring to buffers are
    available and their values depend on the currently-bound buffer.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL 作为一个状态机工作。因此，指向缓冲区的属性是可用的，它们的值取决于当前绑定的缓冲区。
- en: JSON and AJAX are two JavaScript technologies that integrate well with WebGL
    by enabling us to load large and complex assets.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 和 AJAX 是两种与 WebGL 集成良好的 JavaScript 技术，使我们能够加载大型和复杂的资源。
- en: In the next chapter, we will learn more about shaders and use them to implement
    light sources in our WebGL scene by passing information back and forth between
    the WebGL JavaScript API and the attributes, uniforms, and varyings.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于着色器的内容，并使用它们通过在 WebGL JavaScript API 和属性、统一变量以及插值变量之间传递信息来实现
    WebGL 场景中的光源。
