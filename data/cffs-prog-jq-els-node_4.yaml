- en: Chapter 4. CoffeeScript and Rails
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。CoffeeScript和Rails
- en: Ruby on Rails is a web framework that came around in 2004\. It was written by
    David Heinemeier Hansson and was extracted as a framework from **Basecamp** ,
    a project management web application he had written in Ruby for his company **37signals**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby on Rails是一个于2004年出现的Web框架。它是由David Heinemeier Hansson编写的，并从**Basecamp**中提取出来，这是他为他的公司**37signals**用Ruby编写的项目管理Web应用程序。
- en: Rails immediately impressed a lot of people by how effortlessly and quickly
    one could go about writing web applications and soon became quite popular.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Rails立即给许多人留下了深刻的印象，因为他们可以轻松快速地编写Web应用程序，并很快变得非常受欢迎。
- en: At the time it was developed, Ruby was an obscure scripting language from Japan
    that no one had really heard of. Ruby was really at the heart of why Rails was
    so successful. It has proved to be a powerful and succinct programming language,
    and many programmers have stated that it makes programming fun again.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发时，Ruby是一个来自日本的鲜为人知的脚本语言。Ruby实际上是Rails如此成功的原因。它已被证明是一种强大而简洁的编程语言，许多程序员表示它让编程再次变得有趣。
- en: What makes Rails special?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rails的特殊之处在哪里？
- en: 'Rails has pushed the envelope on how web developers approach writing applications.
    Its core philosophy consists of the following two important principles:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Rails推动了Web开发人员编写应用程序的方式。其核心理念包括以下两个重要原则：
- en: Convention over configuration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约定优于配置
- en: Don't repeat yourself, or DRY
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重复自己，或者DRY
- en: Convention over configuration
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约定优于配置
- en: Rails is designed to assume that the programmer will follow certain known conventions,
    which if used, provide great benefit and much less need to configure the framework.
    It's often called an opinionated framework. That means that the framework makes
    assumptions on how a typical application should be built and structured and it
    doesn't try to be overly flexible and configurable. This helps you spend less
    time on mundane tasks like configuring and wiring up an application architecture
    and more time on actually building your app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Rails旨在假定程序员将遵循某些已知的约定，如果使用这些约定，将提供巨大的好处，并且几乎不需要配置框架。它通常被称为一种有主见的框架。这意味着框架对典型应用程序的构建和结构有假设，并且不试图过于灵活和可配置。这有助于您花费更少的时间在配置和连接应用程序架构等琐事上，而更多的时间实际构建您的应用程序。
- en: For instance, Rails will model tables in your database with objects corresponding
    to their names, so a record in the `Transactions` database will automatically
    map to a `Transactions` class instance, as will a record in the `people` database
    table automatically map to a `Person` class instance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Rails将使用与其名称对应的对象对数据库中的表进行建模，因此`Transactions`数据库中的记录将自动映射到`Transactions`类实例，`people`数据库表中的记录也将自动映射到`Person`类实例。
- en: Rails will generally use conventions to do smart things for you. Let's say our
    `people` table also has a `datetime` field called `created_at` and `updated_at`.
    Rails will be smart enough to now automatically update the timestamps on these
    two fields when a record gets created or updated.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Rails通常会使用约定来为您做一些聪明的事情。比如说，我们的`people`表还有一个名为`created_at`和`updated_at`的`datetime`字段。Rails将聪明地在记录创建或更新时自动更新这两个字段的时间戳。
- en: The most important thing about Rails' conventions is that you should know about
    them and not fight the framework, or try to diverge too much from the Rails way,
    without good reason. Often, this can cancel out any of the benefits you get from
    these conventions, or even make it harder on yourself to try and find workarounds.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rails约定的最重要的事情是你应该了解它们，不要与框架对抗，或者试图过多地偏离Rails的方式，除非有充分的理由。通常，这可能会抵消您从这些约定中获得的任何好处，甚至使您更难以尝试解决问题。
- en: Don't repeat yourself (DRY)
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重复自己（DRY）
- en: 'This software engineering principle can also be stated as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个软件工程原则也可以表述为：
- en: Every piece of knowledge must have a single, unambiguous, and authoritative
    representation within a system.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 系统中的每个知识都必须具有单一、明确和权威的表示。
- en: This means that Rails strives to remove duplication and boilerplate wherever
    it can.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Rails努力在任何可能的地方消除重复和样板。
- en: For instance, a `Person` class that models records in the `people` table will
    not need to define its fields, since they are already defined as columns in your
    database table. Here, Rails can use the powerful metaprogramming capabilities
    of Ruby to magically add attributes to the `Person` class that correspond to columns
    in your database.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，模拟`people`表中的记录的`Person`类将不需要定义其字段，因为它们已经在数据库表中定义为列。在这里，Rails可以利用Ruby的强大的元编程能力，神奇地向`Person`类添加与数据库中的列对应的属性。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Metaprogramming** is the concept of writing code that acts on other code
    as data structures. In other words, metaprogramming is writing code that writes
    code. It is used heavily in the Ruby community and the Rails source code in particular.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**元编程**是编写对其他代码起作用的代码的概念。换句话说，元编程是编写编写代码的代码。它在Ruby社区和特别是Rails源代码中被广泛使用。'
- en: The Ruby language has very powerful metaprogramming abilities that are tied
    to the concept of open classes and objects, meaning that you can easily "open
    up" an existing class definition and redefine and add members to it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby语言具有非常强大的元编程能力，与开放类和对象的概念相关联，这意味着您可以轻松地“打开”现有的类定义并重新定义和添加成员。
- en: Rails and JavaScript
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rails和JavaScript
- en: For a long time, Rails was shipped with the `Prototype.js` and `Script.aculo.us`
    JavaScript libraries for AJAX, page animation, and effects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间，Rails都使用`Prototype.js`和`Script.aculo.us` JavaScript库进行AJAX、页面动画和特效。
- en: Rails has the concept of view helpers—these are Ruby methods that can be used
    in views to abstract away common HTML constructs. Many of the view helpers that
    deal with client-side code and AJAX were built on top of these two frameworks,
    and thus they were completely baked in the framework without an easy way of using
    alternatives.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Rails有视图助手的概念——这些是可以在视图中使用的Ruby方法，用于抽象出常见的HTML构造。许多处理客户端代码和AJAX的视图助手都是建立在这两个框架之上的，因此它们完全融入了框架，没有使用替代方案的简单方法。
- en: '`Prototype.js` shares many of the same ideas and goals as jQuery, but over
    time, jQuery has grown to be perceived as a more elegant and powerful library
    by many programmers.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prototype.js`与jQuery有许多相同的想法和目标，但随着时间的推移，jQuery被许多程序员认为是一个更加优雅和强大的库。'
- en: As jQuery became more popular, many developers in the Rails community started
    experimenting by using jQuery with Rails instead of the default JavaScript libraries.
    A standard set of libraries or **gems** emerged for replacing the built-in Prototype
    library with jQuery.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着jQuery变得越来越受欢迎，许多Rails社区的开发人员开始尝试使用jQuery代替默认的JavaScript库。一套标准的库或**gems**出现了，用于用jQuery替换内置的Prototype库。
- en: In Rails Version 3.1, it was announced that jQuery will be the default JavaScript
    library. Because jQuery already had most of the animation and page effect features
    of `Script.aculo.us`, this library was also not needed anymore.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rails 3.1版本中，宣布jQuery将成为默认的JavaScript库。因为jQuery已经具有大部分`Script.aculo.us`的动画和页面效果功能，所以这个库也不再需要了。
- en: This move seemed to have been a long time coming and generally had the blessings
    of most of the Rails community.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这一举措似乎已经等了很长时间，并且基本上得到了大多数Rails社区的祝福。
- en: Rails and CoffeeScript
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rails和CoffeeScript
- en: Another big addition to Rails 3.1 was the asset pipeline. Its main goal is to
    make it easy to treat assets such as JavaScript and CSS as first-class citizens
    in your Rails app. Prior to this, JavaScript and CSS were just served as static
    content. It also provides an organizational skeleton that helps you to organize
    your JavaScript and CSS and provides a DSL for accessing them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 3.1的另一个重要新增功能是资产管道。其主要目标是使在Rails应用中处理JavaScript和CSS等资产变得更加容易。在此之前，JavaScript和CSS只是作为静态内容提供。它还提供了一个组织框架，帮助你组织JavaScript和CSS，并提供了一个用于访问它们的DSL。
- en: With the asset pipeline, you can organize and manage dependencies between assets
    using manifest files. Rails will also use the pipeline to minify and concatenate
    JavaScript as well as apply fingerprints for cache busting.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用资产管道，你可以使用清单文件组织和管理资产之间的依赖关系。Rails还将使用管道来缩小和连接JavaScript，并为缓存清除应用指纹。
- en: The asset pipeline also has a pre-processor chain that will allow you to run
    files through a series of input-output processors before they are served. It knows
    which pre-processors to run using file extension names.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 资产管道还有一个预处理器链，可以让你在提供文件之前通过一系列的输入-输出处理器运行文件。它知道使用文件扩展名来运行哪些预处理器。
- en: Before Rails 3.1 was released, it was announced that the CoffeeScript compiler
    would be supported out of the box using the asset pipeline. This was a huge announcement
    since CoffeeScript is still quite a young language and it stoked quite some controversy
    within the Rails community, with some lamenting the fact that they didn't want
    to learn or use this new language.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布Rails 3.1之前，宣布CoffeeScript编译器将通过资产管道进行支持。这是一个巨大的宣布，因为CoffeeScript仍然是一种相当年轻的语言，并且在Rails社区内引起了一些争议，一些人为他们不想学习或使用这种新语言而感到惋惜。
- en: The Rails maintainers have stuck to their guns though, and at present it couldn't
    be easier to use CoffeeScript in Rails. The fact that CoffeeScript is the default
    for writing client-side JavaScript code has been a huge boost for CoffeeScript,
    and a lot of Rails developers have since gotten to know and embraced the language.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Rails的维护者们一直坚持自己的立场，目前在Rails中使用CoffeeScript变得非常容易。CoffeeScript成为编写客户端JavaScript代码的默认语言，这对CoffeeScript来说是一个巨大的推动力，许多Rails开发人员已经开始了解并接受了这种语言。
- en: We've been going on about how wonderful Rails is and how well it works with
    CoffeeScript, so let's get Rails installed so that you can see for yourself what
    all the fuss is about.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在谈论Rails有多么美妙，以及它与CoffeeScript的良好配合，所以让我们安装Rails，这样你就可以亲自看看到底是怎么回事。
- en: Installing Rails
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Rails
- en: There are many different ways of installing Ruby and Rails on your development
    machine depending on your operating system, which version of Ruby you would like
    to use, if you're using version managers, building from source, and dozens of
    other options. In this book, we will only briefly cover the most common ways of
    installing it on Windows, Mac, and Linux. Please note that in this book we'll
    be using a Rails version of at least 3.2 and higher and Ruby 1.9.2 and higher.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的操作系统、你想要使用的Ruby版本、是否使用版本管理器、是否从源代码构建以及其他几十种选项，你可以在开发机器上安装Ruby和Rails的许多不同方式。在本书中，我们只会简要介绍在Windows、Mac和Linux上安装它的最常见方式。请注意，在本书中，我们将使用至少3.2及更高版本的Rails和1.9.2及更高版本的Ruby。
- en: Installing Rails using RailsInstaller
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RailsInstaller安装Rails
- en: On Windows, or optionally on a Mac, I would recommend **RailsInstaller** ([http://railsinstaller.org/](http://railsinstaller.org/)).
    It contains everything you need to start with Rails, including the latest version
    of Ruby itself. After downloading the setup program, installation couldn't be
    much easier; just run it and step through the wizard. After the installation,
    you should be presented with an open console command prompt. Try entering `rails
    -v`. If you see a version number, you should be good to go.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，或者在Mac上，我建议使用**RailsInstaller** ([http://railsinstaller.org/](http://railsinstaller.org/))。它包含了开始使用Rails所需的一切，包括最新版本的Ruby本身。下载安装程序后，安装过程非常简单；只需运行它并按照向导进行操作。安装完成后，你应该会看到一个打开的控制台命令提示符。尝试输入`rails
    -v`。如果你看到一个版本号，那么你就可以开始了。
- en: Installing Rails using RVM
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RVM安装Rails
- en: Installing Ruby and Rails on a Mac and Linux can be really easy using **RVM**,
    or the **Ruby Version Manager**, from [https://rvm.io/](https://rvm.io/).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac和Linux上安装Ruby和Rails可能非常容易，使用**RVM**或**Ruby Version Manager**，从[https://rvm.io/](https://rvm.io/)。
- en: 'The Ruby language has grown to be very popular over the past few years, and
    this has resulted in multiple implementations of the language being written, which
    can run on difference platforms. **Matz''s Ruby Interpreter** (**MRI**), the standard
    implementation of Ruby, has also gone through several versions. RVM is great for
    managing and installing different versions of Ruby. It comes with a one-stop installer
    bash script that will install both the latest Ruby and Rails. Just run the following
    command from the terminal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，Ruby语言已经变得非常流行，这导致编写了多个可以在不同平台上运行的语言实现。**Matz's Ruby Interpreter**（**MRI**），Ruby的标准实现，也经历了几个版本。RVM非常适合管理和安装不同版本的Ruby。它配备了一个一站式安装程序bash脚本，可以安装最新的Ruby和Rails。只需从终端运行以下命令：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This might take quite a while to finish. Once it's done, you should try entering
    `rails -v` in the terminal. If you see a version number of at least 3.2, you should
    be good to go.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要相当长的时间才能完成。完成后，您应该尝试在终端中输入`rails -v`。如果您看到至少3.2的版本号，那么您应该可以继续了。
- en: Got Rails installed?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已安装Rails？
- en: Now that we have Rails installed, let's go ahead and build an application using
    CoffeeScript.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Rails，让我们继续使用CoffeeScript构建一个应用程序。
- en: If you ran into any problem or want more information on installing Rails, the
    best place to start would be on the **Download** section of the Ruby on Rails
    site ([http://rubyonrails.org/download](http://rubyonrails.org/download)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到任何问题或需要更多关于安装Rails的信息，最好的起点是Ruby on Rails网站的**下载**部分（[http://rubyonrails.org/download](http://rubyonrails.org/download)）。
- en: Developing our Rails application
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的Rails应用程序
- en: We'll take parts of our existing to-do list application and extend it with a
    server-side backend using Rails. If you weren't following along in the previous
    chapter, then you should be able to just copy the code for that chapter as needed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用现有的待办事项列表应用程序的部分内容，并使用Rails扩展它，添加一个服务器端后端。如果您没有在上一章中跟随，那么您应该能够根据需要复制该章节的代码。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter isn't meant to be a complete introduction to all of Ruby on Rails
    or Ruby, the language. Here, we would like to focus on building a simple Rails
    app within the context of how you would go about using Rails with CoffeeScript.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不旨在对Ruby on Rails或Ruby语言进行完整介绍。在这里，我们想专注于在使用CoffeeScript的情况下构建简单的Rails应用程序。
- en: We will not go into everything in too much detail, and we'll trust in the fact
    that Ruby is quite a simple and readable language and that Rails code is simple
    to understand. Even if you aren't familiar with the language and the framework,
    it should not be too hard to follow along.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍所有内容，并且我们相信Ruby是一种非常简单和可读的语言，Rails代码也很容易理解。即使您不熟悉该语言和框架，也不应该太难跟上。
- en: 'First, we''ll start out by creating an empty base Rails application using the
    `rails` command. Navigate to a folder where you would like to create your app
    and then run this command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过使用`rails`命令创建一个空的基本Rails应用程序。转到要创建应用程序的文件夹，然后运行此命令：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will create a `todo` folder with a whole bunch of files and folders for
    your web application. In Rails' spirit of following conventions, your web application
    will be organized in a certain manner.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`todo`文件夹，其中包含用于Web应用程序的大量文件和文件夹。遵循惯例，Rails将以一定的方式组织您的Web应用程序。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `rails` command is used for many things besides generating a new application
    and serves as your entry point into many of the common day-to-day Rails tasks.
    We'll be covering a few of them in this book and if you want to see the full list
    of what it can do, you can run `rails -h`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`rails`命令用于许多事情，除了生成新应用程序之外，还作为您进入许多日常Rails任务的入口点。我们将在本书中涵盖其中的一些内容，如果您想查看它可以做什么的完整列表，可以运行`rails
    -h`。'
- en: 'Let''s briefly talk about how Rails organizes our application. Most of your
    application code will probably live in the top-level `app` folder. This folder
    contains the following four important subfolders:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要谈谈Rails如何组织我们的应用程序。您的大部分应用程序代码可能都位于顶级`app`文件夹中。此文件夹包含以下四个重要的子文件夹：
- en: '`assets:` This is the folder from which the asset pipeline operates. This is
    where all your CoffeeScript (or JavaScript) and CSS source code, as well as images
    used by our web app, will be.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`资产：`这是资产管道操作的文件夹。这是您的CoffeeScript（或JavaScript）和CSS源代码，以及我们的Web应用程序使用的图像的位置。'
- en: '`controllers`: This is where your controllers live. These are responsible for
    handling routed requests for the application and they talk to your views and models.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`控制器`：这是您的控制器所在的位置。它们负责处理应用程序的路由请求，并与视图和模型进行交互。'
- en: '`models`: This is where you''ll find the domain models. Models represent domain
    objects in a system and correspond to database tables using the `ActiveRecord`
    base class.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模型`：这是您将找到领域模型的位置。模型代表系统中的领域对象，并使用`ActiveRecord`基类对应数据库表。'
- en: '`views`: This folder contains view templates that are used to render your application''s
    HTML. By default, Rails uses ERB templates, which allow us to include snippets
    of Ruby code within an HTML template that will be evaluated to generate the final
    output HTML.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`视图`：此文件夹包含用于呈现应用程序HTML的视图模板。默认情况下，Rails使用ERB模板，允许我们在HTML模板中包含Ruby代码片段，这些代码将被评估以生成最终输出的HTML。'
- en: MVC
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC
- en: '**MVC**, or **Model-View-Controller**, is a widely used application architecture
    pattern that aims to simplify code and reduce coupling by splitting application
    concerns into three domain object types.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVC**，或**Model-View-Controller**，是一种广泛使用的应用程序架构模式，旨在通过将应用程序关注点分为三种领域对象类型来简化代码并减少耦合。'
- en: Rails follows the MVC pattern very closely, and most Rails applications will
    be structured very heavily in terms of models, controllers, and views.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Rails非常密切地遵循MVC模式，大多数Rails应用程序在模型、控制器和视图方面都会有很强的结构。
- en: Another pattern on top of MVC that has been espoused by many Rails programmers
    over the last few years is fat models, skinny controllers. This concept encourages
    the practice of placing most of your domain logic within models, and that controllers
    should only be concerned about routing and interaction between models and views.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC之上的另一个模式是“fat models, skinny controllers”，这是在过去几年中被许多Rails程序员所推崇的。这个概念鼓励将大部分领域逻辑放在模型中，并且控制器只关注路由和模型与视图之间的交互。
- en: Running our application
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的应用程序
- en: 'At this stage we can already run our Rails application to see if it all worked.
    From the terminal, enter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经可以运行我们的Rails应用程序，看看是否一切正常。从终端输入：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Rails will now start hosting a local web server for our application on port
    **3000**. You can test it by browsing to `http://localhost:3000/`. If all went
    well, then you should see the following friendly welcome message:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Rails现在将在端口**3000**上为我们的应用程序托管一个本地Web服务器。您可以通过浏览`http://localhost:3000/`来测试它。如果一切顺利，您应该会看到以下友好的欢迎消息：
- en: '![Running our application](img/9588_04_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Running our application](img/9588_04_01.jpg)'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to keep this server running in a separate console window as we test
    our application. You can also check the output of this process for any errors
    that might occur while it's running.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在我们测试应用程序时，将此服务器保持在单独的控制台窗口中运行。您还可以检查此过程的输出，以查看运行时可能发生的任何错误。
- en: Our todo_items resource
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的todo_items资源
- en: So, we now have a running application, but it doesn't do much except show us
    a welcome page.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个正在运行的应用程序，但除了显示欢迎页面外，它并没有做太多事情。
- en: To get to our goal of being able to track to-do tasks, we'll generate a resource
    for our to-do items. In Rails parlance, a resource consists of a model, a controller
    with some actions, as well as views for those actions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现跟踪待办任务的目标，我们将为待办事项生成一个资源。在Rails术语中，资源包括一个模型、一个带有一些操作的控制器，以及用于这些操作的视图。
- en: 'At the terminal, run the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端上运行以下命令：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What did this do? This is an example of Rails' generator syntax, which can be
    used to generate boilerplate code. Here, we tell it to create a "resourceful"
    controller named `TodoItemsController` and a model, `TodoItem`, which has a `string`
    field for its title and a `boolean` flag to mark it as completed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做有什么作用？这是Rails生成器语法的一个例子，可以用来生成样板代码。在这里，我们告诉它创建一个名为`TodoItemsController`的“资源”控制器和一个名为`TodoItem`的模型，该模型具有一个`string`字段作为标题和一个`boolean`标志来标记它是否已完成。
- en: As you can see from the command output, it has generated a bunch of files as
    well as modified an existing one, in `config/routes.rb`. Let's start by opening
    this file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令输出中可以看到，它生成了一堆文件，并修改了一个现有文件，在`config/routes.rb`中。让我们首先打开这个文件。
- en: routes.rb
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: routes.rb
- en: 'Here is what you should see at the top of the `routes.rb` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您应该在`routes.rb`文件顶部看到的内容：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Rails, `routes.rb` defines how HTTP calls to URLs map to controller actions
    that can handle them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rails中，`routes.rb`定义了HTTP调用URL与可以处理它们的控制器操作之间的映射关系。
- en: Here, the generator added a line for us, which uses the `resources` method.
    This method creates the routes for the most common actions of a "resourceful"
    controller. This means it exposes a single domain resource in your application
    using the HTTP verbs, GET, POST, PUT, and DELETE.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，生成器为我们添加了一行，使用了`resources`方法。此方法使用HTTP动词GET、POST、PUT和DELETE为应用程序中的“资源”控制器创建路由。这意味着它使用HTTP动词在应用程序中公开单个域资源。
- en: 'Usually, this will create routes for seven different controller actions, `index`,
    `show`, `new`, `create`, `edit`, `update`, and `destroy`. As you will see later
    on, we won''t need to create all these actions for our controller, so we''ll tell
    the `resources` method to filter out only the ones we want. Modify the file to
    look like the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这将为七个不同的控制器操作创建路由，`index`、`show`、`new`、`create`、`edit`、`update`和`destroy`。正如您将在后面看到的，我们不需要为我们的控制器创建所有这些操作，因此我们将告诉`resources`方法仅筛选出我们想要的操作。修改文件，使其看起来像以下代码片段：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The controller
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: In the call to `resources`, Rails uses the `:todo_items` symbol to conventionally
    map the `resources` method to `TodoItemsController`, which was also generated
    for us.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`resources`的调用中，Rails使用`:todo_items`符号来按照惯例将`resources`方法映射到`TodoItemsController`，这也是为我们生成的。
- en: 'Open the `app/controllers/todo_items_controller.rb` file; here is what you''ll
    see:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app/controllers/todo_items_controller.rb`文件；您将看到以下内容：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, there isn't a whole lot in here. A class named `TodoItemController`
    is declared, and it derives from the `ApplicationController` class. The `ApplicationController`
    class was also generated for us when we created the app, and it derives from `ActionController::Base`,
    which gives it a whole lot of functionality and lets it behave like a Rails controller.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里并没有太多内容。声明了一个名为`TodoItemController`的类，并且它派生自`ApplicationController`类。当我们创建应用程序时，还为我们生成了`ApplicationController`类，并且它派生自`ActionController::Base`，这使它具有大量功能，并使其可以像Rails控制器一样运行。
- en: We should now be able to test out our controller by navigating to the `http://localhost:3000/todo_items`
    URL.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够通过导航到`http://localhost:3000/todo_items` URL来测试我们的控制器。
- en: What do you see? You should get the **Unknown action** error page stating that
    the `index` action could not be found for `TodoItemsController`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了什么？您应该会收到**未知操作**错误页面，指出`TodoItemsController`找不到`index`操作。
- en: 'This is because the controller doesn''t yet have an `index` action defined,
    as specified in our `routes.rb` file. Let''s go ahead and add a method to our
    `TodoItemsController` class to handle that action; this is shown in the following
    code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为控制器尚未定义`index`操作，如我们的`routes.rb`文件中所指定的。让我们继续向`TodoItemsController`类添加一个方法来处理该操作；以下是示例代码片段：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we refresh the page, we get a different error message: **Template is missing**.
    This happens because we don''t have a template for the `index` action. By default,
    Rails will always try to return a rendered template that corresponds to the `index`
    action name. Let''s go ahead and add one now.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刷新页面，我们会得到一个不同的错误消息：**模板丢失**。这是因为我们没有 `index` 动作的模板。默认情况下，Rails 总是会尝试返回与
    `index` 动作名称对应的呈现模板。让我们继续添加一个。
- en: The view
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: Rails views are saved in the `app/views` folder. Each controller will have a
    subfolder here containing its views. We already have an `index.html` file from
    the previous chapter, which we'll re-use here. To do this, we'll need to copy
    everything that is inside the `body` tag, excluding the last two `script` tags
    from the old `index.html` file, into a file called `app/views/todo_items/index.html.erb`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 视图保存在 `app/views` 文件夹中。每个控制器都会在这里有一个包含其视图的子文件夹。我们已经有一个来自上一章的 `index.html`
    文件，我们将在这里重用。为了做到这一点，我们需要将旧的 `index.html` 文件中 `body` 标签内的所有内容（不包括最后两个 `script`
    标签）复制到一个名为 `app/views/todo_items/index.html.erb` 的文件中。
- en: 'You should end up with the following markup:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该最终得到以下标记：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Looking at this, you might be wondering where the rest of the HTML such as the
    enclosing `html`, `head`, and `body` tags have gone.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这里，你可能会想知道其他 HTML 的部分，比如封闭的 `html`、`head` 和 `body` 标签去了哪里。
- en: 'Well, Rails has the concept of a layout file, which acts as a wrapper for all
    the other views. This way you can have a consistent skeleton for your site that
    you don''t need to create for each view. Our view will be embedded inside the
    default layout file: `app/views/layouts/application.html.erb`. Let''s have a look
    at that file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，Rails 有一个布局文件的概念，它作为所有其他视图的包装器。这样你就可以为你的站点拥有一个一致的骨架，而不需要为每个视图创建。我们的视图将嵌入到默认布局文件中：`app/views/layouts/application.html.erb`。让我们来看看那个文件：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `stylesheet_link_tag` and `javascript_include_tag` methods will make sure
    that all the files specified in the `assets` folder are included in the HTML.
    The `<%= yield %>` line is where the current view will be rendered, which is `index.html.erb`
    in our case.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`stylesheet_link_tag` 和 `javascript_include_tag` 方法将确保在 HTML 中包含在 `assets`
    文件夹中指定的所有文件。`<%= yield %>` 行是当前视图将被呈现的地方，这在我们的情况下是 `index.html.erb`。'
- en: When we refresh the page now, we'll see the `index` page. Have a look at the
    source code to get an idea of how the final HTML is output.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新页面，我们会看到 `index` 页面。查看源代码，了解最终的 HTML 输出。
- en: As you can see, our page is still unstyled and looks quite dull. Let's see if
    we can make it look pretty again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的页面仍然没有样式，看起来相当沉闷。让我们看看是否可以再次让它看起来漂亮。
- en: The CSS
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS
- en: By default, the asset pipeline will look for CSS files in the `app/assets/stylesheets`
    folder. When we browse to this folder, we'll see a file named `todo_items.css.scss`,
    which was generated for us when we created the controller.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，资产管道将在 `app/assets/stylesheets` 文件夹中查找 CSS 文件。当我们浏览到这个文件夹时，我们会看到一个名为 `todo_items.css.scss`
    的文件，这是在我们创建控制器时为我们生成的。
- en: Copy the contents of the previous chapter's `styles.css` file into this file.
    Our `index` page should now look decent again.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一章的 `styles.css` 文件的内容复制到这个文件中。我们的 `index` 页面现在应该看起来还不错。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This file with the strange `.css.scss` extension is a Saas file ([http://sass-lang.com/](http://sass-lang.com/)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个带有奇怪 `.css.scss` 扩展名的文件是一个 Saas 文件（[http://sass-lang.com/](http://sass-lang.com/)）。
- en: Like CoffeeScript, Sass is an extended version of the normal CSS language, with
    a lot of nice features that make writing CSS easier and less repetitive.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CoffeeScript 一样，Sass 是普通 CSS 语言的扩展版本，具有许多使编写 CSS 更容易和不那么重复的好功能。
- en: As with CoffeeScript, it is the default CSS compiler in the Rails asset pipeline.
    The flavor of Sass that we're using is a superset of CSS, which means we can use
    normal CSS in this file without using any of the Sass features and it will work
    fine.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CoffeeScript 一样，它是 Rails 资产管道中的默认 CSS 编译器。我们使用的 Sass 变体是 CSS 的超集，这意味着我们可以在这个文件中使用普通的
    CSS 而不使用任何 Sass 功能，它也可以正常工作。
- en: Our model
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的模型
- en: 'So now we can see our to-do list, but we don''t have any items showing up.
    This time, instead of storing them locally, we''ll store them in the database.
    Luckily for us, we already have a database model that was generated for us when
    we created the resource and the `TodoItem` model, which is defined in `app/models/todo_item.rb`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们的待办事项列表，但没有任何项目显示出来。这一次，我们不会将它们存储在本地，而是将它们存储在数据库中。幸运的是，当我们创建资源和 `TodoItem`
    模型时，已经为我们生成了一个数据库模型，它在 `app/models/todo_item.rb` 中定义：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, like with controllers, you can see that Rails models get most of their
    functionality by deriving from `ActiveRecord::Base`. The `attr_accessible` line
    tells `ActiveRecord` which fields on this model can be assigned to and from user
    input.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，就像控制器一样，你可以看到 Rails 模型通过从 `ActiveRecord::Base` 派生来获得大部分功能。`attr_accessible`
    行告诉 `ActiveRecord` 这个模型上的哪些字段可以被分配给用户输入和从用户输入中分配。
- en: 'How do we use the model? Add the following highlighted code in `todo_items_controller.rb`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用模型？在 `todo_items_controller.rb` 中添加以下突出显示的代码：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line uses an `all` class method on the `TodoItem` class, which is also
    provided by `ActiveRecord`. This will return a new instance of the `TodoItem`
    class for each record in the database, which we can assign to an instance variable
    called `@todo_items` (in Ruby all instance variables start with an `@` symbol).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行在 `TodoItem` 类上使用了一个 `all` 类方法，这也是由 `ActiveRecord` 提供的。这将为数据库中的每条记录返回一个 `TodoItem`
    类的新实例，我们可以将其分配给一个名为 `@todo_items` 的实例变量（在 Ruby 中，所有实例变量都以 `@` 符号开头）。
- en: When Rails executes a controller action, it will automatically make any of the
    controller instance variables available to the view being rendered, which is why
    we're assigning it here. We'll get to use it in our view soon.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Rails 执行控制器动作时，它会自动使任何控制器实例变量可用于正在呈现的视图，这就是我们在这里分配它的原因。我们很快就会在我们的视图中使用它。
- en: Let's refresh the page again to see if this worked. Yet again, we get a **Could
    not find table 'todo_items'** error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次刷新页面，看看这是否有效。再一次，我们得到了一个**找不到表 'todo_items'**的错误。
- en: You've probably guessed that we're supposed to create a table called `todo_items`
    in a database somewhere. Luckily, Rails has already taken care of the hard work,
    using something called migration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经猜到我们应该在某个地方的数据库中创建一个名为`todo_items`的表。幸运的是，Rails已经通过一种称为迁移的方式处理了这项艰苦的工作。
- en: Migrations
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移
- en: 'When we generated our resource, Rails not only created a model for us, but
    also a database script written in Ruby, or **migration** . We should be able to
    open it in the `db/migrations` folder. The actual file will be prefixed with a
    timestamp and will end with `_create_todo_items.rb`. It should look similar to
    the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们生成资源时，Rails不仅为我们创建了一个模型，还创建了一个用Ruby编写的数据库脚本，或者**迁移**。我们应该能够在`db/migrations`文件夹中打开它。实际文件将以时间戳为前缀，并以`_create_todo_items.rb`结尾。它应该类似于以下代码片段：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This script will create a table named `todo_items` with the fields that we had
    specified when we generated the `todo_item` resource. It also creates two timestamp
    fields named `created_at` and `updated_at` using the `t.timestamps` method. Rails
    will make sure that fields with those names get updated with the appropriate timestamp
    when a record gets created or updated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将创建一个名为`todo_items`的表，其中包含我们在生成`todo_item`资源时指定的字段。它还使用`t.timestamps`方法创建了两个名为`created_at`和`updated_at`的时间戳字段。Rails将确保这些名称的字段在记录创建或更新时得到适当的时间戳更新。
- en: 'Migration scripts are a wonderful way of automating database changes, even
    allowing you to roll back a previous change. You don''t have to rely on migrations
    created by resource or model generators either. Custom migrations can be generated
    by running the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移脚本是自动化数据库更改的一种很好的方式，甚至可以让您回滚以前的更改。您也不必依赖于资源或模型生成器创建的迁移。可以通过运行以下命令生成自定义迁移：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After generating your custom migration, you can just implement the `up` and
    `down` methods, which will be called when your migration gets executed or rolled
    back.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 生成自定义迁移后，您只需实现`up`和`down`方法，当您的迁移被执行或回滚时将调用这些方法。
- en: 'Migrations are executed with the `rake` command. `rake` is a task-management
    tool that allows you to write tasks as Ruby scripts, which are then run using
    the `rake` command-line utility. Rails comes with a whole lot of built-in `rake`
    tasks, and you can see the full list of them by using:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是使用`rake`命令执行的。`rake`是一个任务管理工具，允许您将任务编写为Ruby脚本，然后使用`rake`命令行实用程序运行这些任务。Rails带有大量内置的`rake`任务，您可以使用以下命令查看它们的完整列表：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The task that we''re interested in the moment is called `db:migrate` , let''s
    run it and see what happens:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前感兴趣的任务叫做`db:migrate`，让我们运行它，看看会发生什么：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should see the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '**== CreateTodoItems: migrating ================================================**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**== CreateTodoItems: migrating ================================================**'
- en: '**-- create_table(:todo_items)**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**-- create_table(:todo_items)**'
- en: '**-> 0.0011s**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**-> 0.0011s**'
- en: '**== CreateTodoItems: migrated (0.0013s) =======================================**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**== CreateTodoItems: migrated (0.0013s) =======================================**'
- en: This means Rails has successfully created a `todo_items` table for us in the
    database. When we refresh the application page, we should see that the error is
    gone and we're seeing our blank to-do list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Rails已成功在数据库中为我们创建了一个`todo_items`表。当我们刷新应用程序页面时，应该看到错误已经消失，我们看到了空白的待办事项列表。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Where is the database?**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库在哪里？**'
- en: You might have wondered where our actual database lives at the moment. Rails
    defaults to using an embedded SQLite database. SQLite ([http://www.sqlite.org](http://www.sqlite.org))
    is a self-contained, file-based database that doesn't need a server to be configured
    for it to run. This makes it really nice and easy to get up and running quickly
    when developing an application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道我们的实际数据库目前在哪里。Rails默认使用嵌入式SQLite数据库。SQLite ([http://www.sqlite.org](http://www.sqlite.org))是一个自包含的基于文件的数据库，不需要配置服务器即可运行。这使得在开发应用程序时快速启动变得非常简单和方便。
- en: Once you actually deploy your web app, you would probably want to go with a
    more traditional database server, such as MySQL or PostgreSQL. You can easily
    change your database connection settings in the `config/database.yml` file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您实际部署您的Web应用程序，您可能希望使用更传统的数据库服务器，如MySQL或PostgreSQL。您可以在`config/database.yml`文件中轻松更改数据库连接设置。
- en: We still haven't hooked up our view to actually show the list of to-do items.
    Before we do that, let's manually create a couple of to-do items in the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有将我们的视图连接起来，以实际显示待办事项列表。在这之前，让我们在数据库中手动创建一些待办事项。
- en: The Rails console
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rails控制台
- en: 'Rails has a nifty way of interactively playing with your code by using the
    Rails console. This is an interactive Ruby interpreter, or **irb**, session with
    all the Rails project code loaded. Let''s fire it up by using the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Rails有一种巧妙的方式可以通过使用Rails控制台与您的代码进行交互。这是一个交互式的Ruby解释器，或者**irb**，会话加载了所有Rails项目代码。让我们使用以下命令启动它：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once you''re in the console you can enter any valid Ruby code. You can also
    access all the models in your Rails app. Let''s try it with the `TodoItem.all`
    method that we used earlier; this is shown in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进入控制台，您可以输入任何有效的Ruby代码。您还可以访问Rails应用程序中的所有模型。让我们尝试一下我们之前使用的`TodoItem.all`方法；这在以下截图中显示：
- en: '![The Rails consoleRails consoleabout](img/9588_04_02.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![The Rails consoleRails consoleabout](img/9588_04_02.jpg)'
- en: At the moment it returns an empty array, since our table is still empty. Notice
    that Rails also outputted the SQL query that it has generated to get all the records.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目前它返回一个空数组，因为我们的表还是空的。请注意，Rails还输出了它生成的SQL查询，以获取所有记录。
- en: 'From here we can also create a new to-do item using our model. The following
    code will do that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们还可以使用我们的模型创建一个新的待办事项。以下代码将完成这个任务：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we should have a single to-do item in our table. You can verify this by
    using `TodoItem.first`, which will return the first item in our table.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的表中应该有一个待办事项。您可以使用`TodoItem.first`来验证这一点，它将返回我们表中的第一项。
- en: 'I want to make sure that our model always has a title. `ActiveRecord` has very
    powerful validation features that are built-in, which allows for specifying constraints
    on model attributes in a very declarative manner. Let''s make sure that our model
    always checks for the presence of a title before saving; to do this, add the following
    highlighted code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我想确保我们的模型始终有一个标题。`ActiveRecord`具有非常强大的内置验证功能，允许以非常声明性的方式指定模型属性的约束。让我们确保我们的模型在保存之前始终检查标题是否存在；为此，请添加以下突出显示的代码：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Go ahead and create a couple of other to-do items. Once you have done this,
    try running `TodoItem.all` again. This time it returns an array of `TodoItem`
    instances.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建另外几个待办事项。完成后，尝试再次运行`TodoItem.all`。这次它将返回一个`TodoItem`实例数组。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To exit the rails console, just enter `exit`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出rails控制台，只需输入`exit`。
- en: Displaying the items in our view using ERB
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ERB在视图中显示项目
- en: 'To display our to-do items in our view, we''ll use the `@todo_items` instance
    variable that we created in our controller action. Let''s modify the `app/views/todo_items.html.erb`
    file and mix in some Ruby using ERB; add the code that is highlighted in the following
    code snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的视图中显示待办事项，我们将使用在控制器动作中创建的`@todo_items`实例变量。让我们修改`app/views/todo_items.html.erb`文件，并使用ERB混合一些Ruby；添加以下代码片段中突出显示的代码：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'ERB templates are quite simple to understand. The basic idea is that you write
    your HTML as normal and mix in Ruby using ERB tags. The following three tags are
    important:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ERB模板非常简单易懂。基本思想是你按照正常方式编写HTML，并使用ERB标记混合Ruby。以下三个标记很重要：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In our `index` ERB template, we use Ruby's `each` iterator to loop through all
    the elements in the `@todo_items` array instance variable; `each` takes a Ruby
    block as an argument. A block is a piece of code that can be passed to a method
    as data, similar to how functions can be passed as arguments in CoffeeScript.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`index` ERB模板中，我们使用Ruby的`each`迭代器来循环遍历`@todo_items`数组实例变量中的所有元素；`each`以Ruby块作为参数。块是可以作为数据传递给方法的代码片段，类似于CoffeeScript中可以作为参数传递函数。
- en: This block will be executed for each item in the array, passing it in as the
    item variable. For each item, we create its markup, using the item's `title` and
    `completed` attributes inside of our ERB tags.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块将针对数组中的每个项目执行，将其作为item变量传递进来。对于每个项目，我们使用项目的`title`和`completed`属性在我们的ERB标记内部创建其标记。
- en: 'When we refresh the page, we should now finally see our list of to-do items!
    If you are curious, have a look at the HTML source of the document and compare
    it to the ERB template, this should give you a good idea of how it was generated.
    The output page is shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们刷新页面时，现在应该终于看到我们的待办事项列表了！如果你好奇的话，可以查看文档的HTML源代码，并将其与ERB模板进行比较，这应该让你对它是如何生成的有一个很好的了解。输出页面如下截图所示：
- en: '![Displaying the items in our view using ERB](img/9588_04_03.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用ERB在视图中显示项目](img/9588_04_03.jpg)'
- en: Creating a partial
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个部分
- en: 'At the moment, our view code is starting to get a bit messy, especially the
    to-do items list. We can clean it up a bit by using a **view partial** , which
    allows us to pull out snippets of our view into a separate file. This can then
    be rendered where we need it in the main view. Add the line of code highlighted
    in the following code snippet to your file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的视图代码开始变得有点混乱，特别是待办事项列表。我们可以通过使用**视图部分**来稍微整理一下，这允许我们将视图的片段提取到一个单独的文件中。然后可以在主视图中渲染它。将以下代码片段中突出显示的代码行添加到您的文件中：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll move the to-do item markup to its own partial file. By convention, partial
    filenames start with an underscore, and when rendering a partial, Rails will look
    for a file with the same name as the specified partial, with a leading underscore.
    Go ahead and create a file: `app/views/todo_items/_todo_item.html.erb` with the
    following content:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将待办事项的标记移到自己的部分文件中。按照惯例，部分文件名以下划线开头，当渲染部分时，Rails将查找与指定部分相同名称的文件，以下划线开头。继续创建一个文件：`app/views/todo_items/_todo_item.html.erb`，内容如下：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If all went well, our view should still work as before, and we have cleaned
    up the main view code nicely. Simplifying views with partials are also great for
    reusability, which we'll see later on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们的视图应该像以前一样工作，而且我们已经很好地清理了主视图代码。使用部分简化视图对于可重用性也非常有用，我们稍后会看到。
- en: Our to-do list app still needs some work. At the moment, we can't add new tasks
    and the completed task and delete actions don't work either. This calls for some
    client-side code, which means we can finally start using some CoffeeScript.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的待办事项应用程序仍然需要一些工作。目前，我们无法添加新任务，已完成的任务和删除操作也无法正常工作。这需要一些客户端代码，这意味着我们终于可以开始使用一些CoffeeScript了。
- en: Adding new items
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新项目
- en: 'To add new items to our to-do list, we''ll use some of Rails'' native AJAX
    capabilities. The following code snippet is a modified version of the `todo` input
    on our `index` view:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向待办事项列表中添加新项目，我们将使用Rails的一些原生AJAX功能。以下代码片段是我们`index`视图上`todo`输入的修改版本：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So what has changed here? First, you'll notice that we have included the `form_for`
    method, with another call to `text_field` inside of its block. These are Rails'
    view helpers, which are Ruby methods available inside of views, that provide ways
    of building the HTML output.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这里有什么变化呢？首先，你会注意到我们已经包含了`form_for`方法，并在其块内部再次调用了`text_field`。这些是Rails的视图助手，它们是视图内部可用的Ruby方法，提供了构建HTML输出的方式。
- en: The `form_for` method will output an HTML `form` tag, and the `text_field` method
    will generate an `input` tag inside the form, which will be of type `text`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`form_for`方法将输出一个HTML`form`标签，而`text_field`方法将在表单内生成一个`input`标签，类型为`text`。'
- en: We pass a new instance of `TodoItem` as a parameter to the `form_for` method.
    Rails is smart enough to know from the `TodoItem` instance that the form's URL
    should point to `TodoItemController`, and will use attributes of the `TodoItem`
    model as names of inputs inside the form.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个新的`TodoItem`实例作为参数传递给`form_for`方法。Rails足够聪明，能够从`TodoItem`实例中知道表单的URL应该指向`TodoItemController`，并且将使用`TodoItem`模型的属性作为表单内部输入的名称。
- en: The real magic comes in with the `:remote => true` parameter sent to the `form_for`
    method. This tells Rails that you want this form to be submitted using AJAX. Rails
    will take care of all of this in the background.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的魔力在于发送给`form_for`方法的`remote => true`参数。这告诉Rails你希望使用AJAX提交这个表单。Rails将在后台处理所有这些。
- en: 'So which controller action will my form be submitted to? Since we specified
    its action as `post`, it will map to a `create` action in `TodoItemController`.
    We don''t have one yet, so let''s go and write it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我的表单将提交到哪个控制器动作？由于我们指定了它的动作为`post`，它将映射到`TodoItemController`中的`create`动作。我们还没有这个动作，所以让我们去写它：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we create `TodoItem` using the `:todo_item` key in `params`—`params`,
    which is a Ruby hash that Rails created. It contains a value with the key, `:todo_items`,
    which is a hash containing all the parameter values that were submitted from the
    form. When we pass this hash to the `TodoItem.create` method, Rails will know
    how to map them to attributes on our new model and save it to the database.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`params`中的`:todo_item`键创建`TodoItem`—`params`是Rails创建的Ruby哈希。它包含一个带有键`:todo_items`的值，这是一个包含从表单提交的所有参数值的哈希。当我们将这个哈希传递给`TodoItem.create`方法时，Rails将知道如何将它们映射到我们新模型上的属性并保存到数据库中。
- en: Let's try and add a to-do item
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们尝试添加一个待办事项
- en: Type a title in our input box for a new to-do item and hit *Enter*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的输入框中输入一个新的待办事项标题，然后按*Enter*。
- en: 'However, it seems like nothing happened. We can head over to the output of
    our running Rails server session to see if we can spot any errors. If you scroll
    around a bit, you should see an error similar to the following error message:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，似乎什么都没有发生。我们可以前往正在运行的Rails服务器会话的输出，看看是否能发现任何错误。如果你滚动一下，你应该会看到一个类似以下错误消息的错误：
- en: '**ActionView::MissingTemplate (Missing template todo_items/create, application/create
    with {:locale=>[:en], :formats=>[:js, "application/**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**ActionView::MissingTemplate (Missing template todo_items/create, application/create
    with {:locale=>[:en], :formats=>[:js, "application/**'
- en: '**ecmascript", "application/x-ecmascript", :html, :text, :js, :css, :ics, :csv,
    :png, :jpeg, :gif, :bmp, :tiff, :mpeg, :xml, :rss, :atom,**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**ecmascript", "application/x-ecmascript", :html, :text, :js, :css, :ics, :csv,
    :png, :jpeg, :gif, :bmp, :tiff, :mpeg, :xml, :rss, :atom,**'
- en: '**:yaml, :multipart_form, :url_encoded_form, :json, :pdf, :zip], :handlers=>[:erb,
    :builder, :coffee]}. Searched in:**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**:yaml, :multipart_form, :url_encoded_form, :json, :pdf, :zip], :handlers=>[:erb,
    :builder, :coffee]}. Searched in:**'
- en: '*** "/home/michael/dev/todo/app/views"**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*** "/home/michael/dev/todo/app/views"**'
- en: '**)**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**)**'
- en: Adding a CoffeeScript view
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加CoffeeScript视图
- en: So, it seems we still need to do one more thing. All controller actions will
    try and render a view by default. When we try adding a to-do item now, we would
    get the same **Template is missing** error as earlier. It might not be clear what
    should happen, since the form was posted using AJAX. Should we still render a
    view? And how would it look?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，看起来我们还需要做一件事。所有控制器动作默认都会尝试渲染视图。当我们现在尝试添加待办事项时，我们会得到与之前相同的**模板丢失**错误。可能不清楚应该发生什么，因为表单是使用AJAX提交的。我们是否仍然应该渲染一个视图？它会是什么样子？
- en: Looking at the error message a bit more closely might give us a clue. Since
    our action was invoked using AJAX, Rails will, by default, look for a CoffeeScript
    view to render as JavaScript.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下错误消息可能会给我们一些线索。由于我们的动作是使用AJAX调用的，Rails默认会寻找一个CoffeeScript视图来渲染为JavaScript。
- en: The generated JavaScript will serve as the response to the AJAX call and will
    be executed on completion. This also seems like the perfect place to update our
    to-do items list, after creating it on the server.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的JavaScript将作为对AJAX调用的响应，并在完成时执行。这似乎也是更新我们的待办事项列表的完美地方，之后在服务器上创建它。
- en: We'll create a CoffeeScript view template for our `create` action in `app/views/todo_items/create.js.coffee`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`app/views/todo_items/create.js.coffee`中的`create`动作创建一个CoffeeScript视图模板。
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, in the previous code snippet, we grab the `#new-todo` input and clear
    its value. We then render the same `todo_item` partial that we used before, passing
    in the `@todo_item` instance variable that we created in our controller action.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们获取`#new-todo`输入并清除其值。然后我们渲染与之前相同的`todo_item`部分，传入我们在控制器动作中创建的`@todo_item`实例变量。
- en: We wrap the render call in an `escape_javascript` helper method, which will
    ensure that any special JavaScript character will be escaped in our string. We
    then append the newly rendered partial to our `#todo-list` element.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将渲染调用包装在`escape_javascript`辅助方法中，这将确保我们字符串中的任何特殊JavaScript字符都会被转义。然后我们将新渲染的部分附加到我们的`#todo-list`元素中。
- en: Try it out. We can now finally create to-do list items!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 试一下。我们现在终于可以创建待办事项列表了！
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Where did jQuery come from?**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**jQuery是从哪里来的？**'
- en: Rails already included jQuery for us. The Rails asset pipeline uses a manifest
    file, `app/assets/javascript/application.js` to include required dependencies,
    for instance jQuery.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Rails已经为我们包含了jQuery。Rails资产管道使用一个清单文件`app/assets/javascript/application.js`来包含所需的依赖项，例如jQuery。
- en: CoffeeScript in the asset pipeline
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产管道中的CoffeeScript
- en: Notice how seamless this all was? Rails treats CoffeeScript as a first-class
    citizen in its stack, and will make sure that the `.coffee` files get compiled
    into JavaScript before they are used. The fact that you can also pre-process your
    CoffeeScript using ERB templates on the server makes this even more powerful.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这一切是多么无缝？Rails将CoffeeScript视为其堆栈中的一等公民，并确保在使用之前将`.coffee`文件编译为JavaScript。事实上，你还可以在服务器上使用ERB模板预处理你的CoffeeScript，这使其更加强大。
- en: Completing the to-do items
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成待办事项
- en: Let's hook up this functionality. This time, we will do things a bit differently
    to show you a different style of writing CoffeeScript in Rails. We'll follow the
    more traditional approach of handling the AJAX call ourselves.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接这个功能。这一次，我们将以稍有不同的方式来展示在Rails中编写CoffeeScript的不同风格。我们将遵循更传统的方法来处理AJAX调用。
- en: Rails has already created a file where we can put our client-side code, back
    when we created the controller. Each controller will get its own CoffeeScript
    file, which will be included in the page automatically for any action on that
    controller.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Rails已经创建了一个文件，我们可以在其中放置我们的客户端代码，当我们创建控制器时。每个控制器都将有自己的CoffeeScript文件，它将自动包含在该控制器的任何操作的页面中。
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is also an `application.js.coffee` file, where global client-side code
    can be added.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`application.js.coffee`文件，可以在其中添加全局客户端代码。
- en: 'The file that we''re interested in will be `app/assets/views/javascripts/todo_items.js.coffee`.
    We can replace the contents of it with the following code, which will handle the
    AJAX call when completing a task:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的文件将是`app/assets/views/javascripts/todo_items.js.coffee`。我们可以用以下代码替换它的内容，这将在完成任务时处理AJAX调用：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we define a function called `toggleItem`, which we set up to be called
    when a checkbox value changes. In this function we toggle the parent `li` element's
    `completed` class and get the ID of the to-do item using its `data` attribute.
    We then make an AJAX call to `TodoItemController` to update the item with the
    current checked value of the checkbox.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个名为`toggleItem`的函数，我们设置当复选框值改变时调用它。在这个函数中，我们切换父`li`元素的`completed`类，并使用其`data`属性获取待办事项的ID。然后，我们发起一个AJAX调用到`TodoItemController`，以更新复选框的当前选中值。
- en: 'Before we can run this code, we''ll need to add an `update` action to our controller,
    which is shown in the following code snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以运行这段代码之前，我们需要在我们的控制器中添加一个`update`动作，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`params[:id]` will be the value of the ID in the URL. We use this to find the
    to-do item and then call the `update_attributes` method, which do just that, update
    our model and save it to the database. Note that we explicitly tell Rails not
    to render a view here by calling `render nothing: true`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`params[:id]`将是URL中ID的值。我们使用这个来找到待办事项，然后调用`update_attributes`方法，它就是更新我们的模型并将其保存到数据库。请注意，我们明确告诉Rails在这里不要渲染视图，通过调用`render
    nothing: true`。'
- en: Setting tasks to completed should now work. Notice that when you refresh the
    page, tasks stay completed, since they were saved to the database.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 设置任务为已完成现在应该可以工作了。请注意，当你刷新页面时，任务保持已完成状态，因为它们已保存到数据库中。
- en: Removing tasks
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除任务
- en: For removing tasks, we'll follow a very similar pattern.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移除任务，我们将遵循非常相似的模式。
- en: 'In `todo_items.js.coffee`, add the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`todo_items.js.coffee`中，添加以下代码：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In our controller, add the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制器中，添加以下代码：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That should be all we need to remove list items. Notice that here we only remove
    the element once the AJAX call was successful, by handling the `success` callback.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是我们需要移除列表项的全部内容。请注意，这里只有在AJAX调用成功时才移除元素，通过处理`success`回调。
- en: Now, it's your turn
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在轮到你了
- en: As a final exercise to you, I will ask you to make the **Clear completed** button
    work. As a hint, you should be able to use the existing `destroyItem` method functionality.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对你的最后一项练习，我要求你让“清除已完成”按钮起作用。作为提示，你应该能够使用现有的`destroyItem`方法功能。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter started with a whirlwind tour of Ruby on Rails. You have hopefully
    grown to appreciate some of the magic that Rails offers web developers and how
    much fun it can be developing a Rails app. We have also spent some time discovering
    how easy it is to use CoffeeScript in a Rails app, and the different approaches
    and techniques you would typically use to write client-side code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以Ruby on Rails的风风火火开始。你已经希望能够欣赏到Rails为Web开发人员提供的一些魔力，以及开发Rails应用程序可以有多么有趣。我们还花了一些时间发现在Rails应用程序中使用CoffeeScript是多么容易，以及你通常会使用哪些不同的方法和技术来编写客户端代码。
- en: If you haven't done so already, I encourage you to spend some more time learning
    Rails as well as Ruby, and immersing yourself in the wonderful communities they
    support.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，我鼓励你花一些时间学习Rails以及Ruby，并沉浸在它们支持的美妙社区中。
- en: In the next chapter, we'll explore yet another new exciting server framework
    that was built using JavaScript, and how CoffeeScript relates to it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索另一个使用JavaScript构建的令人兴奋的新服务器框架，以及CoffeeScript与其的关系。
