- en: Chapter 8. Scaling Up – Ensuring Performance in Complex Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。扩展 – 确保复杂应用程序的性能
- en: 'In this chapter, we will look at the most common performance issues in Backbone,
    as well as how to avoid them. In particular, we''ll cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Backbone中最常见的性能问题，以及如何避免它们。特别是，我们将涵盖以下内容：
- en: CPU-based performance issues
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于CPU的性能问题
- en: Bandwidth-based performance issues related to content size
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与内容大小相关的基于带宽的性能问题
- en: Bandwidth-based performance issues related to the number of requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与请求数量相关的基于带宽的性能问题
- en: Memory-based performance issues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于内存的性能问题
- en: Backbone and performance
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone与性能
- en: At its core, Backbone is just a JavaScript library, and as such, it doesn't
    add any new performance challenges that weren't already in JavaScript to begin
    with. In fact, the creators of Backbone have taken great care to make the library
    perform well, and in performance comparisons with rival libraries, Backbone typically
    comes out ahead, if not on top.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone的核心只是一个JavaScript库，因此它不会添加任何JavaScript本身没有的新性能挑战。事实上，Backbone的创建者已经非常注意使库性能良好，并且在与其他库的性能比较中，Backbone通常处于领先地位，如果不是最顶尖的。
- en: However, while Backbone itself doesn't create performance issues, it does enable
    entirely new ways of creating web applications, and because such applications
    can be far more complex than traditional websites, a whole new realm of potential
    performance issues is exposed. In this chapter, we will explore these issues,
    as well as their underlying technical details, and address ways to avoid or mitigate
    them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管Backbone本身不会创建性能问题，但它确实为创建Web应用程序提供了全新的方式，并且由于此类应用程序可能比传统网站复杂得多，因此暴露了全新的潜在性能问题领域。在本章中，我们将探讨这些问题，以及它们的技术细节，并讨论避免或减轻这些问题的方法。
- en: Causes of performance issues
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能问题的原因
- en: Whenever a user experiences performance problems, it is because he has exceeded
    the capacity of one of his system resources, either bandwidth memory or processing
    power. Before debugging any performance issue, it's essential to understand which
    of these factors is responsible, and this can be determined in one of two ways.
    First, a profiling tool (such as the tools included with all major browsers) can
    be used to measure how much of each resource is being used, which should quickly
    make obvious which resource is being used excessively. An explanation of these
    tools falls outside the scope of this book, but I strongly encourage you to familiarize
    yourself with the tools available in your favorite browser.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户遇到性能问题时，是因为他已经超出了他系统资源（带宽、内存或处理能力）之一的容量。在调试任何性能问题之前，了解这些因素中的哪一个负责是至关重要的，这可以通过两种方式之一来确定。首先，可以使用性能分析工具（如所有主要浏览器中包含的工具）来测量每种资源的使用量，这应该会迅速清楚地表明哪种资源被过度使用。这些工具的解释超出了本书的范围，但我强烈建议您熟悉您最喜欢的浏览器中可用的工具。
- en: For most problems, however, a profiling tool won't even be necessary, because
    their source can be determined by how they manifest. Bandwidth problems only occur
    when retrieving or sending data from your server (and in most applications, only
    retrieval operations involve enough bandwidth to be problematic). If they occur
    at load time, then they could be caused by a significant number of large static
    resources, such as images, but if they occur afterwards, they are far more likely
    to be the result of AJAX calls. In Backbone applications, this means *fetch* operations
    (or, rarely, *save* or *destroy* operations) from `Models` or `Collections`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数问题，然而，甚至不需要使用性能分析工具，因为它们的原因可以通过它们的表现来确定。带宽问题仅在从您的服务器检索或发送数据时出现（在大多数应用程序中，只有检索操作涉及足够的带宽以成为问题）。如果它们在加载时出现，那么可能是由大量大型静态资源（如图像）引起的，但如果它们在之后出现，更有可能是由AJAX调用引起的。在Backbone应用程序中，这意味着从`Models`或`Collections`进行的*fetch*操作（或很少见的*save*或*destroy*操作）。
- en: CPU performance issues only occur when the user's computer is forced to think
    hard about something you are making it do. For example, a series of nested `for`
    loops, or the rendering of a complex visualization such as a chart can cause such
    performance issues. This type of performance issue is usually easy to identify
    because it only occurs when the user triggers such computationally intensive code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CPU性能问题仅在用户的计算机被迫对您让它做的事情进行深入思考时才会出现。例如，一系列嵌套的`for`循环，或渲染复杂的可视化（如图表）可能导致此类性能问题。这种性能问题通常很容易识别，因为它仅在用户触发这种计算密集型代码时才会发生。
- en: The final, and by far the most difficult, source of performance issues is the
    memory. Unlike the other two issues, which usually have obvious triggers such
    as the start of an AJAX operation or the rendering of a chart, memory issues can
    occur without any clear or obvious source. In fact, memory issues can begin seconds
    or even minutes before the user actually starts noticing problems, forcing you
    to trace back through all the code they hit to try and find a cause. Because memory
    issues are the most common type, and because they are the hardest to understand
    and resolve, we will be focusing most heavily on them in this chapter. However,
    before we do so, let's examine the other two sources, and some common sense approaches
    to avoiding them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题的最终来源，也是最难解决的，是内存。与通常有明显的触发器（如AJAX操作的开始或图表的渲染）的其他两个问题不同，内存问题可能没有任何明显或明显的来源。事实上，内存问题可能在用户真正开始注意到问题之前几秒甚至几分钟就开始出现，迫使你回溯所有触发的代码以尝试找到原因。由于内存问题是最常见的类型，并且它们是最难理解和解决的，因此我们将重点放在它们上。然而，在我们这样做之前，让我们检查其他两个来源，以及一些避免它们的常识性方法。
- en: CPU-related performance issues
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与CPU相关的性能问题
- en: As mentioned earlier, Backbone itself will not usually be the source of CPU-related
    performance issues, because these issues tend to be caused by specific components
    rather than the overall site architecture. However, there is one way that Backbone
    can contribute to such problems, and that is by making it easy to repeat the same
    work in multiple places. For instance, let's imagine that you are creating a dashboard
    page that will use one main `View` class to show your user various pieces of data,
    and a number of child `Views` to render each of these pieces of data. In addition,
    let's imagine that each of these pieces of data will update periodically. Normally,
    you would tie the updating of that data to an AJAX response or a user event, but
    under certain circumstances, you might instead want to use a `setInterval` statement.
    For instance, `onScroll` events are known to be problematic, so many developers
    avoid them and instead rely on `setInterval` to check for scrolling periodically.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Backbone本身通常不会是CPU相关性能问题的源头，因为这些问题的原因往往是由特定组件引起的，而不是整个网站架构。然而，Backbone可以通过使重复相同工作变得容易而贡献于这类问题。例如，让我们假设你正在创建一个仪表板页面，该页面将使用一个主要的`View`类来展示用户的各种数据，以及多个子`Views`来渲染这些数据中的每一个。此外，让我们假设这些数据将定期更新。通常，你会将数据的更新与AJAX响应或用户事件绑定，但在某些情况下，你可能更愿意使用`setInterval`语句。例如，`onScroll`事件已知存在问题，因此许多开发者避免使用它们，而是依赖于`setInterval`定期检查滚动。
- en: This approach will work fine as long as there is only a single `setInterval`
    event running, but what if you instead decide to create a separate `setInterval`
    event for each child `View`? With only a few child `Views`, this still might work,
    but eventually, too many such intervals will become a drain on the user's CPU,
    causing performance problems. In the worst case scenario, while your development
    machine will be able to handle the page, your user's (less powerful) machine might
    not, causing the user to report bugs that you can't reproduce.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 只要只有一个`setInterval`事件在运行，这种方法就会工作得很好，但如果你决定为每个子`View`创建一个单独的`setInterval`事件会怎样呢？对于只有少数子`Views`的情况，这仍然可能工作，但最终，太多的这种间隔将消耗用户的CPU资源，导致性能问题。在最坏的情况下，虽然你的开发机器可以处理页面，但用户的（较弱的）机器可能无法处理，导致用户报告你无法复制的错误。
- en: 'The solution in such cases is straightforward: Don''t repeat processing-intensive
    tasks unnecessarily. In the preceding example, instead of having each child `View`
    update in response to its own `setInterval` event, you could start only a single
    `setIonterval` process in the main `View` and then, have it trigger updates in
    your child `Views` (possibly by using the pub/sub pattern described in the previous
    chapter).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类情况下，解决方案简单明了：不要不必要地重复执行计算密集型任务。在前面的例子中，你不需要每个子`View`都响应自己的`setInterval`事件来更新，你可以在主`View`中启动一个单独的`setInterval`进程，然后让它触发子`Views`的更新（可能通过使用前一章中描述的pub/sub模式）。
- en: Event delegation
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件委托
- en: One other way developers can easily create unnecessary strain on the user's
    browser is by creating too many event handlers. For instance, let's say you want
    to create a large table (perhaps 20 rows × 20 columns), so you create a parent
    `View` for the table and a large number of child `Views` for each cell. So far
    so good! Now let's say, you add a `click` event handler to each of these child
    `Views`. Without realizing it, you just created 400 event handlers. If you add
    another event handler, such as a `change` handler for `<input>` elements inside
    the cell, you add another 400, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过创建过多的事件处理器，以另一种方式轻易地对用户的浏览器造成不必要的压力。例如，假设你想创建一个大表格（可能是20行×20列），因此你为表格创建了一个父`View`，并为每个单元格创建了大量子`View`。到目前为止，一切顺利！现在假设，你为这些子`View`中的每一个添加了一个`click`事件处理器。没有意识到，你刚刚创建了400个事件处理器。如果你为单元格内的`<input>`元素添加另一个事件处理器，比如一个`change`处理器，你又会增加400个，以此类推。
- en: 'Given enough `Views` and enough event handlers, this can eventually create
    a performance issue, but luckily, JavaScript comes with a built-in mechanism that
    we can use to solve this problem: event bubbling. Whenever an event occurs in
    the DOM, it first triggers event handlers on the relevant DOM element and then
    bubbles up to each successive parent of that element. In other words, if a `click`
    event occurs on a `<td>` element, the browser will resolve any event handlers
    bound to that `<td>` element first, then (unless one of the event handlers returned
    false) it will call the handlers on the `<td>` element''s parent `<tr>` element
    and then that `<tr>` parent''s `<table>`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 给定足够的`Views`和足够的事件处理器，这最终可能会造成性能问题，但幸运的是，JavaScript自带了一个我们可以用来解决这个问题内置机制：事件冒泡。每当在DOM中发生事件时，它首先在相关的DOM元素上触发事件处理器，然后冒泡到该元素的每个后续父元素。换句话说，如果一个`click`事件发生在`<td>`元素上，浏览器将首先解决绑定到该`<td>`元素的任何事件处理器，然后（除非某个事件处理器返回了false），它将调用`<td>`元素父`<tr>`元素上的处理器，然后是那个`<tr>`父元素的`<table>`：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can take advantage of this fact and change our event binding strategy to
    improve performance by binding our events to the parent `table` element's `View`
    rather than to each child `View`. This parent `View` event handler can then trigger
    the appropriate logic on the relevant child `View` by using the event's `target`
    property to determine which child `View` caused the event. While this approach
    requires slightly more work, it allows us to reduce our 400 click event handlers
    down to a single event handler, and on particularly complex pages (such as our
    hypothetical table page), the use of such event delegation can significantly reduce
    the strain on the browser.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个事实，并改变我们的事件绑定策略，通过将事件绑定到父`table`元素的`View`而不是每个子`View`来提高性能。然后，这个父`View`事件处理器可以通过使用事件的`target`属性来确定哪个子`View`引发了事件，从而触发相关子`View`上的适当逻辑。虽然这种方法需要稍微多做一些工作，但它使我们能够将400个点击事件处理器减少到单个事件处理器，并且在特别复杂的页面（例如我们假设的表格页面）上，使用这种事件代理可以显著减少对浏览器的压力。
- en: Bandwidth-related performance issues
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与带宽相关的性能问题
- en: 'While it''s true that the typical user''s bandwidth has grown significantly
    in the recent years, the bandwidth nevertheless remains a constant issue for web
    developers. However, many developers don''t realize that there are actually two
    main sources of bandwidth problems. The first of these is fairly obvious: forcing
    your users to download files that are too large. But, there is also a second,
    less obvious source: forcing your users to download too many files at once.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然确实，近年来典型用户的带宽显著增长，但带宽仍然是网络开发者面临的一个持续问题。然而，许多开发者并没有意识到，实际上存在两个主要的带宽问题来源。第一个问题相当明显：强迫用户下载过大的文件。但是，还有一个不那么明显的问题：强迫用户一次性下载过多的文件。
- en: Downloading excessively large files
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载过大的文件
- en: 'Let''s start with the obvious source first. If the files that your users need
    to download are too large, it doesn''t matter whether they are images, videos,
    or JavaScript code files: Your site is going to load slowly. However, you can
    make a big difference in the size of any file you use by enabling compression
    at the web server level. On an Apache web server, this can be done by using `mod_deflate`,
    and most other web servers have similar options. Doing so will make your server
    compress the files that it sends to your users in such a way that your users''
    browser can easily decompress them … all without the user even knowing that any
    decompression is going on.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从最明显的原因开始。如果用户需要下载的文件太大，无论是图片、视频还是JavaScript代码文件，你的网站都会加载得很慢。然而，你可以在使用任何文件的大小上做出很大的改变，只需在Web服务器级别启用压缩即可。在Apache
    Web服务器上，这可以通过使用`mod_deflate`来实现，而大多数其他Web服务器都有类似选项。这样做会使服务器以用户浏览器可以轻松解压缩的方式压缩发送给用户的文件……而用户甚至不知道有任何解压缩正在进行。
- en: 'However, if turning on compression doesn''t help enough, then your next steps
    depend on the file type. If your issues come from images or videos, then you simply
    have to find a way to use smaller files, for instance, by lowering their resolution.
    However, if JavaScript files are your main concern, there is another option: using
    a minification program.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果开启压缩没有足够帮助，那么你的下一步取决于文件类型。如果你的问题来自图片或视频，那么你只需找到一种方法来使用更小的文件，例如，通过降低它们的分辨率。然而，如果你的主要问题是JavaScript文件，那么还有一个选择：使用压缩程序。
- en: Minification programs parse your code to create a new optimized version of it
    that eliminates comments, removes extra whitespace, and renames variables with
    shorter names. The only downside to using such a program is that it will make
    it harder for you to debug problems on your production servers, which shouldn't
    be an issue as long as you have a matching development environment where you don't
    minify your files. Further, if the minification truly becomes a problem, you can
    always temporarily switch your server back to the unminified files to do your
    debugging.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化程序解析你的代码，创建一个新的优化版本，该版本消除了注释，移除了额外的空白，并使用更短的名字重命名变量。使用此类程序的唯一缺点是，它会使你在生产服务器上调试问题变得更加困难，只要你有一个匹配的开发环境，你不需要对文件进行最小化，这就不应该是一个问题。此外，如果最小化确实成为一个问题，你总是可以暂时将服务器切换回未最小化的文件来进行调试。
- en: Together the two techniques of web server compression and minification can result
    in a major difference in file size. For example, the uncompressed jQuery library
    (version 1.11.0) is 276 KB, while the zipped version is only 82 KB and the zipped
    version of the minified jQuery code is only 33 KB. In other words, just by using
    these two techniques, it's possible to reduce jQuery's footprint by almost a factor
    of ten!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器压缩和最小化这两种技术结合起来，可以在文件大小上产生重大差异。例如，未压缩的jQuery库（版本1.11.0）大小为276 KB，而压缩版本仅为82
    KB，而最小化后的压缩jQuery代码版本仅为33 KB。换句话说，仅仅通过使用这两种技术，就有可能将jQuery的占用空间减少近十倍！
- en: Downloading excessive number of files
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载过多文件
- en: Unfortunately though, even if you reduce the bandwidth of your code files and
    assets, there is also another, more subtle bandwidth issue to worry about that
    has nothing to do with the number of bytes your user downloads. To understand
    this issue, you have to understand how browsers handle requests for data, both
    those that come from the DOM (such as the `<link>` and `<script>` tags) and AJAX
    requests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使你减少了代码文件和资源的带宽，还有一个更微妙但需要关注的带宽问题，这与用户下载的字节数无关。要理解这个问题，你必须了解浏览器如何处理数据请求，无论是来自DOM（如`<link>`和`<script>`标签）的还是AJAX请求。
- en: 'When a browser opens up a connection to a particular remote computer, it keeps
    track of how many other connections have already been opened to that computer''s
    domain, and if too many are already open, it pauses until one of the previous
    requests completes. The exact number of connections that can occur before this
    happens varies by browser: In Internet Explorer 7, it''s only two, but in most
    modern browsers, it''s six or eight. Because of this limit, and because each request,
    no matter how small, has a certain minimum amount of time that it will take (also
    called latency), the actual amount of bandwidth used can be irrelevant. There
    are two main approaches for solving a bandwidth issue.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器打开到特定远程计算机的连接时，它会跟踪已经打开到该计算机域的连接数量，如果已经打开太多，它会暂停，直到之前的某个请求完成。在发生这种情况之前可以发生的连接数因浏览器而异：在Internet
    Explorer 7中，只有两个，但在大多数现代浏览器中，是六或八个。由于这个限制，并且因为每个请求，无论大小，都需要一定的时间（也称为延迟），实际使用的带宽可能无关紧要。解决带宽问题主要有两种方法。
- en: The first is, obviously, to make fewer requests. If your problem is too many
    `Models` being fetched at once, `Collections` can be very helpful in solving it;
    instead of fetching each `Model` class individually, simply create an endpoint
    on your server that can return all of the `Models` at once and then, use a `Collection`
    class to fetch them. Even though you will be downloading the same amount of data,
    this change in API will result in significantly less requests. Similarly, if your
    problem is too many images, you can combine all of the images into a single `sprites`
    file and then, use CSS to only display one image at a time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，显然是要减少请求数量。如果你的问题是同时获取过多的`模型`，`集合`可以非常有助于解决这个问题；而不是单独获取每个`模型`类，只需在你的服务器上创建一个可以一次性返回所有`模型`的端点，然后使用`集合`类来获取它们。尽管你将下载相同数量的数据，但这种API的改变将导致请求量显著减少。同样，如果你的问题是图像过多，你可以将所有图像合并成一个单独的`sprites`文件，然后使用CSS只显示一次图像。
- en: The other option, if your application truly does require a large number of requests,
    is to use subdomains. When a browser counts how many connections it has outstanding,
    it doesn't just look at the source's domain but also at its subdomain. This means
    that you can fetch the maximum number of requests from [http://example.com/](http://example.com/)
    and then, fetch that same number of requests from `foo.example.com`, `bar.example.com`,
    and so on. This trick is often used to serve CSS and images more quickly, but
    it can just as easily be used to make a large number of simultaneous fetches (as
    long as you update your `url` methods appropriately to fetch from the correct
    subdomain).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项，如果你的应用程序确实需要大量的请求，可以使用子域名。当浏览器计算未完成的连接数时，它不仅查看源域名，还查看其子域名。这意味着你可以从[http://example.com/](http://example.com/)获取最大数量的请求，然后，从`foo.example.com`、`bar.example.com`等获取相同数量的请求。这个技巧通常用于更快地提供CSS和图像，但也可以同样容易地用于进行大量的并发获取（只要适当地更新你的`url`方法以从正确的子域名获取）。
- en: Finally, there is one last solution to bandwidth issues, which doesn't really
    solve these issues so much as make them more palatable to the user. If you know
    that you're going to be making a request that will take long enough for the user
    to notice, you can give the user a visual wait indicator, such as adding an animated
    spinner image or changing the cursor's CSS property to wait. If you make these
    changes just before you start a `fetch` operation, you can then use that operation's
    success and failure callbacks (or, if you use the deferred style, a single `complete`
    callback) to undo the changes. While this won't make your data download any faster,
    it will make a difference in your user's experience.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个解决带宽问题的方案，这并不是真正解决了这些问题，而是使它们对用户来说更加容易接受。如果你知道你将发起一个请求，这个请求的时间足够长以至于用户会注意到，你可以给用户一个视觉等待指示器，比如添加一个动画旋转图像或改变光标的CSS属性以等待。如果你在开始`fetch`操作之前进行这些更改，然后你可以使用该操作的成功和失败回调（或者如果你使用延迟样式，一个单一的`complete`回调）来撤销这些更改。虽然这不会使你的数据下载速度更快，但它会在用户体验上有所区别。
- en: Memory-related performance issues
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与内存相关的性能问题
- en: Memory-related issues are the hardest to debug and solve, and unfortunately,
    they are also the most likely to be encountered when you first start using Backbone.
    Again, this is not because Backbone itself has memory issues, but because the
    possibilities that Backbone enables can allow developers to shoot themselves in
    the foot if they're not careful.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与内存相关的问题是最难调试和解决的，而且不幸的是，当你刚开始使用Backbone时，它们也是最有可能遇到的。再次强调，这并不是因为Backbone本身有内存问题，而是因为Backbone提供的可能性如果开发者不小心，可能会自己给自己挖坑。
- en: However, before we proceed, it's important to first explain just how browsers
    manage memory. As you probably already know, the memory in JavaScript is managed
    by the browser, not the developer, using something called **garbage collector**.
    What this means is that you don't have to tell the browser I'm done using this
    variable. Instead, you can simply stop using that variable and the browser will
    figure out that it has become `garbage`, which will usually make it clean that
    variable up automatically.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们继续之前，首先解释一下浏览器是如何管理内存的非常重要。正如你可能已经知道的，JavaScript中的内存是由浏览器而不是开发者管理的，使用的是称为**垃圾回收器**的东西。这意味着你不需要告诉浏览器我已经完成对这个变量的使用。相反，你只需停止使用那个变量，浏览器就会弄清楚它已经变成了`garbage`，这通常会使它自动清理那个变量。
- en: 'The problem is that the garbage collector operates on a very simple interpretation
    of what is or is not garbage. In essence, any variable that is not referenced
    by another variable is considered to be garbage. For instance:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于垃圾回收器对垃圾的简单解释。本质上，任何没有被其他变量引用的变量都被认为是垃圾。例如：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The problem is that developers often don''t realize when they leave behind
    references to a variable, and as such, they force the browser to keep using its
    memory even though the programmer considers it garbage. Let''s look at an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于开发者往往没有意识到他们留下了变量的引用，因此迫使浏览器继续使用其内存，尽管程序员认为它是垃圾。让我们看看一个例子：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, it seems like we eliminated all references to `exampleView`
    when we called `exampleView.remove()` and removed it from the DOM, but in fact,
    there was still one reference left behind, hidden inside `exampleModel`. This
    reference was created when we called the `on` method of `exampleModel` and passed
    it `exampleView.render`. By doing so, we told the `Model` to wait until a change
    happens and then call `exampleView.render`, which required it to store a reference
    to `exampleView.render`. Since we didn't delete `exampleModel`, this reference
    remains and won't be garbage-collected, leaving a so-called zombie `View` in the
    browser's memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们调用`exampleView.remove()`并从DOM中移除`exampleView`时，似乎我们消除了对`exampleView`的所有引用，但实际上，还有一个引用被遗留下来，隐藏在`exampleModel`内部。这个引用是在我们调用`exampleModel`的`on`方法并传递`exampleView.render`时创建的。通过这样做，我们告诉`Model`等待发生变化，然后调用`exampleView.render`，这需要它存储对`exampleView.render`的引用。由于我们没有删除`exampleModel`，这个引用仍然存在，不会被垃圾回收，从而在浏览器内存中留下一个所谓的僵尸`View`。
- en: 'One way to solve this problem would be to remove this reference manually by
    using the `off` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用`off`方法手动删除这个引用：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, having to manage such references can quickly become tedious. Luckily,
    the creators of Backbone added a method to `View` (as well as the other three
    Backbone classes) that helps solve this problem, called `listenTo`. This method
    works very similarly to `on` with two important differences. First, it is called
    on the listening object (in this case, the `View`), rather than on the object
    being listened to (in this case, the `Model`), and second, it does not take a
    context argument. Instead, the context of the callback will always be set to the
    object that `listenTo` was called on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，管理这样的引用很快就会变得繁琐。幸运的是，Backbone的创建者为`View`（以及其他三个Backbone类）添加了一个方法来帮助解决这个问题，称为`listenTo`。这个方法与`on`非常相似，有两个重要的区别。首先，它是在监听对象（在这种情况下，是`View`）上调用，而不是在被监听的对象（在这种情况下，是`Model`）上调用，其次，它不接收上下文参数。相反，回调的上下文将始终设置为`listenTo`被调用的对象。
- en: Just as there is an `off` method for `on`, there is a `stopListening` method
    that removes listeners created by `listenTo`. However, you won't need to call
    `stopListening` yourself very often, because it's called automatically as part
    of the `remove` method of a `View`, which is what makes it so convenient.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如存在`off`方法用于`on`一样，也存在一个`stopListening`方法，它可以移除由`listenTo`创建的监听器。然而，你不需要经常调用`stopListening`，因为它会作为`View`的`remove`方法的一部分自动调用，这使得它非常方便。
- en: 'Let''s retry our last example using `listenTo`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `listenTo` 重新尝试我们的上一个例子：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time, just as before, we have a `View` listening for changes in a `Model`.
    However, because we used `listenTo` instead of `on`, the reference created as
    a side effect will get removed whenever `stopListening` is called. Since we called
    `remove` on `exampleView` and since this method automatically calls `stopListening`
    for us, our `View` gets garbage-collected correctly without us having to do any
    extra work.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，就像之前一样，我们有一个 `View` 正在监听 `Model` 的变化。然而，因为我们使用了 `listenTo` 而不是 `on`，作为副作用创建的引用将在调用
    `stopListening` 时被移除。由于我们在 `exampleView` 上调用了 `remove`，并且这个方法会自动为我们调用 `stopListening`，所以我们的
    `View` 被正确地垃圾回收，而无需我们做任何额外的工作。
- en: Unfortunately, however, `listenTo` can't solve all potential leaky references.
    For one thing, you may still want to use the `on` method from time to time. The
    primary reason for doing so is to listen for events from non-Backbone code, such
    as a jQuery UI widget. You might also be tempted to use `on` because (unlike `listenTo`)
    it takes a context argument, but thanks to Underscore's `bind` method, you don't
    need to do so; you can simply bind your desired context in your callback function
    before passing it to `listenTo`. However, even if you do avoid using `on` entirely,
    you still have to remember to call `remove` on your `View`. If you don't, you
    still need to use `off` or `stopListening` to clear the event binding references.
    Finally, event handlers aren't the only source of references.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不幸的是，`listenTo` 无法解决所有潜在泄漏的引用。一方面，你可能仍然需要不时地使用 `on` 方法。这样做的主要原因是为了监听来自非 Backbone
    代码的事件，例如 jQuery UI 小部件。你也可能因为（与 `listenTo` 不同）它接受一个上下文参数而想使用 `on`，但多亏了 Underscore
    的 `bind` 方法，你不需要这样做；你可以在将回调函数传递给 `listenTo` 之前，简单地在你想要的上下文中绑定回调函数。然而，即使你完全避免使用
    `on`，你仍然需要记得在 `View` 上调用 `remove`。如果你不这样做，你仍然需要使用 `off` 或 `stopListening` 来清除事件绑定引用。最后，事件处理器并不是引用的唯一来源。
- en: For instance, parent `Views` and child `Views` often reference each other, and
    unless you delete the referencing `Views` entirely, the `Views` that it references
    won't actually be garbage-collected. The good news is that there's no need to
    worry too much about such references on a small scale, and in fact, trying to
    optimize performance too heavily on every last bit of code in your application
    can wind up being counterproductive. Any given `Model` or `View` will normally
    take up only a small amount of memory on its own, so even if you do create a leaky
    reference that prevents it from being garbage-collected, the actual effect on
    your application's performance will be minimal. If the user never even notices
    the leak and then reclaims the memory when he closes his browser or hits refresh,
    then clearly there was no need for you to have spent time worrying about it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，父 `View` 和子 `View` 经常相互引用，除非你完全删除引用 `View`，否则它所引用的 `View` 实际上不会被垃圾回收。好消息是，在小规模上，你不需要过于担心这样的引用，实际上，试图过度优化应用程序中每一行代码的性能可能会适得其反。任何给定的
    `Model` 或 `View` 通常只占用很少的内存，所以即使你创建了防止其被垃圾回收的泄漏引用，对应用程序性能的实际影响也将是最小的。如果用户甚至没有注意到泄漏，然后在关闭浏览器或刷新时回收内存，那么显然你不需要花费时间担心它。
- en: Instead, you mainly want to focus on managing your references when dealing with
    large numbers of objects. If you are designing a page `View` that will be used
    throughout your application, or creating a `View` for a large table with many
    separate child `Views`, then you will likely want to be extra careful with each
    reference you create and ensure that all these references get cleaned up when
    you are done with them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当你处理大量对象时，你主要需要关注管理你的引用。如果你正在设计一个将在整个应用程序中使用的页面 `View`，或者为具有许多单独子 `View`
    的大表格创建 `View`，那么你可能希望对每个创建的引用格外小心，并确保在完成使用后清理所有这些引用。
- en: Summary
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how JavaScript code in general, and Backbone code
    in particular, can cause performance problems. We learned the three main causes
    of such problems (namely bandwidth, CPU, and memory), as well as techniques and
    methods that can be used to solve them. In particular, we learned how leaky event
    bindings or other references can prevent garbage collection, and how using `listenTo`
    or manually cleaning up references can enable garbage collection to work as expected.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了JavaScript代码在一般情况下，以及Backbone代码特别情况下，如何导致性能问题。我们了解了这类问题的三个主要原因（即带宽、CPU和内存），以及可以用来解决这些问题的技术和方法。特别是，我们学习了漏斗式事件绑定或其他引用如何阻止垃圾回收，以及如何使用`listenTo`或手动清理引用来使垃圾回收按预期工作。
- en: In the next chapter, we'll examine the benefits of proper code documentation,
    learn how to solve some of the Backbone-specific documentation challenges, and
    consider which of the many quality documentation tools are the best for documenting
    your projects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨良好代码文档化的好处，学习如何解决一些Backbone特定的文档挑战，并考虑众多高质量的文档工具中哪一个是用于记录你的项目的最佳选择。
