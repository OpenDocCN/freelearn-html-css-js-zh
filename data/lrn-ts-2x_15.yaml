- en: Working with the TypeScript Compiler and the Language Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TypeScript 编译器和语言服务
- en: In this chapter, we are going to learn about the internals of the TypeScript
    compiler and the TypeScript language services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 TypeScript 编译器和 TypeScript 语言服务的内部机制。
- en: These topics may seem very advanced and not something that everybody will find
    useful. While it is true that it is a topic for advanced users, the truth is that
    everybody can benefit from understanding the TypeScript language services. Understanding
    the compiler API of the TypeScript compiler can help us to develop many kinds
    of development tools and to automate certain aspects of our development workflow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题可能看起来非常高级，并不是每个人都觉得有用。虽然它确实是高级用户的话题，但事实是，每个人都可以从理解 TypeScript 语言服务中受益。理解
    TypeScript 编译器的编译器 API 可以帮助我们开发许多种类的开发工具，并自动化我们开发工作流程的某些方面。
- en: 'The goal of this chapter is not to make you an expert in the compiler''s internals
    or the development of TypeScript tools, but to gently introduce you to this very
    extensive topic. In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是让你成为编译器内部或 TypeScript 工具开发的专家，而是温和地引导你了解这个非常广泛的主题。在本章中，我们将涵盖以下内容：
- en: The internal architecture of the TypeScript compiler
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 编译器的内部架构
- en: Using the compiler API programmatically
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编译器 API 进行编程
- en: Working with `ts-simple-ast`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ts-simple-ast` 进行操作
- en: Implementing custom code-analysis tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义代码分析工具
- en: The TypeScript compiler's internal architecture
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 编译器的内部架构
- en: In this section, we are going to learn what the main components in the TypeScript
    compiler are. We are going to learn the main responsibility of each of the components,
    as well as what their expected inputs and outputs are.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 TypeScript 编译器中的主要组件。我们将学习每个组件的主要职责，以及它们的预期输入和输出。
- en: 'The following diagram describes the main components of the TypeScript architecture:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了 TypeScript 架构的主要组件：
- en: '![](img/3e3e592e-d2b7-4083-8613-dbd668e1dfd4.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e3e592e-d2b7-4083-8613-dbd668e1dfd4.png)'
- en: Components of the TypeScript architecture
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 架构的组成部分
- en: The core TypeScript API is the foundation of everything, and is composed of
    elements such as the scanner, parser, binder, type checker, and emitter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 核心API是所有事物的基石，由扫描器、解析器、绑定器、类型检查器和发射器等元素组成。
- en: The language services and the standalone compiler (the `tsc` command-line tool)
    sit on top of the core compiler APIs. Finally, the Visual Studio shim and the
    TypeScript standalone server (`tsserver`) are designed to facilitate the integration
    of TypeScript with Visual Studio and other source code editors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 语言服务和独立编译器（`tsc` 命令行工具）位于核心编译器 API 之上。最后，Visual Studio 适配器和 TypeScript 独立服务器（`tsserver`）被设计用来促进
    TypeScript 与 Visual Studio 和其他源代码编辑器的集成。
- en: 'The official TypeScript documentation defines the TypeScript standalone server
    as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的官方文档将 TypeScript 独立服务器定义为以下内容：
- en: '"The TypeScript standalone server (aka tsserver) is a node executable that
    encapsulates the TypeScript compiler and language services and exposes them through
    a JSON protocol. tsserver is well suited for editors and IDE support."'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '"TypeScript 独立服务器（又称 tsserver）是一个封装 TypeScript 编译器和语言服务并通过 JSON 协议暴露它们的 Node
    可执行文件。tsserver 非常适合编辑器和 IDE 支持。"'
- en: Scanner
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描器
- en: The scanner transforms the source code files into streams of tokens. The scanner
    is also known as the **lexer** in other resources about compilers. The scanner
    is used by the parser.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描器将源代码文件转换成标记流。扫描器在其他关于编译器的资源中也被称为**词法分析器**。扫描器被解析器使用。
- en: Lexemes and tokens
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词素和标记
- en: A lexeme is a sequence of characters in the source program that matches the
    pattern for a token. We can say that a token has a pattern and a pattern can be
    matched by many lexemes, in some cases. As a result, in a programming language,
    there are an infinite number of potential lexemes and a limited number of tokens.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 词素是源程序中匹配标记模式的字符序列。我们可以这样说，标记有一个模式，而在某些情况下，模式可以由许多词素匹配。因此，在编程语言中，存在无限多的潜在词素和有限的标记数量。
- en: 'The easiest way to understand the difference between a lexeme and a token is
    to take a look at an example, such as the following code snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 理解词素和标记之间的区别的最简单方法是通过查看以下代码片段的例子：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code snippet will be parsed into the following lexemes and tokens:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将被解析成以下词素和标记：
- en: '| **Lexeme** | **Token** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **词素** | **标记** |'
- en: '| `while` | `WhileKeyword` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `while` | `WhileKeyword` |'
- en: '| `(` | `OpenParenToken` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `(` | `OpenParenToken` |'
- en: '| `y` | `Identifier` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `y` | `Identifier` |'
- en: '| `>=` | `GreaterThanEqualsToken` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | `GreaterThanEqualsToken` |'
- en: '| `t` | `Identifier` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `t` | `Identifier` |'
- en: '| `)` | `CloseParenToken` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `)` | `CloseParenToken` |'
- en: '| `y` | `Identifier` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `y` | `Identifier` |'
- en: '| `=` | `EqualsToken` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `=` | `EqualsToken` |'
- en: '| `y` | `Identifier` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `y` | `Identifier` |'
- en: '| `-` | `MinusToken` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `-` | `MinusToken` |'
- en: '| `3` | `NumericLiteral` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `NumericLiteral` |'
- en: '| `;` | `SemicolonToken` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `;` | `SemicolonToken` |'
- en: '|  | `EndOfFileToken` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  | `EndOfFileToken` |'
- en: 'In TypeScript, the tokens are defined in the `SyntaxKind` enumeration:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，标记在`SyntaxKind`枚举中定义：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `SyntaxtKind` enumeration is defined in the [/src/compiler/types.ts](https://github.com/Microsoft/TypeScript/blob/b31aa4e012fc4c2afc9c2200f18b9e79edac160b/src/compiler/types.ts#L80)
    file in the TypeScript source code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyntaxtKind`枚举在TypeScript源代码的[/src/compiler/types.ts](https://github.com/Microsoft/TypeScript/blob/b31aa4e012fc4c2afc9c2200f18b9e79edac160b/src/compiler/types.ts#L80)文件中定义。'
- en: Refer to the official TypeScript repository on GitHub at [https://github.com/Microsoft/TypeScript](https://github.com/Microsoft/TypeScript)
    if you wish to explore the entire source code of the TypeScript project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想探索TypeScript项目的整个源代码，请参阅GitHub上的官方TypeScript仓库[https://github.com/Microsoft/TypeScript](https://github.com/Microsoft/TypeScript)。
- en: Parser
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析器
- en: The TypeScript parser uses the scanner to traverse our source code files and
    transform them into a stream of tokens.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript解析器使用扫描器遍历我们的源代码文件并将它们转换成标记流。
- en: The TypeScript parser then transforms the stream of tokens into a tree-like
    data structure known as an abstract syntax tree (AST). Each of the elements in
    this tree-like data structure is known as a node. A node is the basic building
    block of the AST.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript解析器然后将标记流转换成一个称为抽象语法树（AST）的树状数据结构。这个树状数据结构中的每个元素都称为节点。节点是AST的基本构建块。
- en: AST
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AST
- en: The **abstract syntax tree** (**AST**) is a tree-like data structure created
    by the parser. This data structure allows the TypeScript compiler to traverse
    our source code to perform many core tasks, such as emitting the output JavaScript
    code. We are going to learn more about the AST later in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象语法树**（**AST**）是由解析器创建的树状数据结构。这种数据结构允许TypeScript编译器遍历我们的源代码以执行许多核心任务，例如生成输出JavaScript代码。我们将在本章后面了解更多关于AST的内容。'
- en: Symbols
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号
- en: 'The TypeScript textbook by Basarat Ali Syed describes symbols as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Basarat Ali Syed编写的TypeScript教科书将符号描述如下：
- en: '"Symbols connect declaration nodes in the AST to other declarations contributing
    to the same entity. Symbols are the basic building block of the Semantic system."'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '"符号将AST中的声明节点与其他贡献同一实体的声明连接起来。符号是语义系统的基本构建块。"'
- en: 'The symbol class is defined in the TypeScript source code as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 符号类在TypeScript源代码中定义如下：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A symbol contains a reference to the declarations of a type and some flags that
    help us to identify some of its characteristics.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个符号包含对类型声明的引用和一些帮助我们识别其某些特性的标志。
- en: Binder
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定器
- en: 'The TypeScript textbook by Basarat Ali Syed describes the binder as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Basarat Ali Syed编写的TypeScript教科书将绑定器描述如下：
- en: '"The binder is used to connect the various parts of the source code into a
    coherent type system that can then be used by the checker. The main responsibility
    of the binder is to create the Symbols."'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '"绑定器用于将源代码的各个部分连接成一个连贯的类型系统，然后该系统可以被检查器使用。绑定器的主要责任是创建符号。"'
- en: 'TypeScript supports a feature known as *declaration merging*, which allows
    us to merge two separate declarations declared with the same name into a single
    definition. For example, the following code snippet declares two interfaces named
    `Person` and a variable named `person`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持一个称为*声明合并*的功能，允许我们将使用相同名称声明的两个单独的声明合并为一个单一的定义。例如，以下代码片段声明了两个名为`Person`的接口和一个名为`person`的变量：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The type of the variable is `Person`, and as we can see, the type contains the
    properties declared in both previously declared interfaces. This is the case because
    the declaration merging mechanism merges both declarations into one unique type.
    This is directly related to the behavior of the binder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的类型是`Person`，正如我们所见，该类型包含在先前声明的接口中声明的属性。这是因为声明合并机制将这两个声明合并为一个唯一的类型。这与绑定器的行为直接相关。
- en: Type checker
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型检查器
- en: The type checker is probably the most important component in the TypeScript
    compiler. The type checker uses the abstract syntax trees (one per file) and the
    symbols as inputs, and it oversees the identification of type errors in our source
    code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器可能是TypeScript编译器中最重要的组件。类型检查器使用抽象语法树（每个文件一个）和符号作为输入，并负责监督源代码中类型错误的识别。
- en: Emitter
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射器
- en: The emitter is the component responsible for the generation of the output code.
    The output is usually JavaScript that adheres to one of the supported specifications
    (ES3, ES5, or ES6), but it can also be type definitions or source map files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器是负责生成输出代码的组件。输出通常是遵循支持的规范之一（ES3、ES5或ES6）的JavaScript，但它也可以是类型定义或源映射文件。
- en: Language service
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言服务
- en: 'The TypeScript compiler includes an additional component that has been specifically
    designed to provide developers with a great developer experience. The following
    paragraph has been extracted from the official TypeScript documentation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器包括一个专门设计来为开发者提供良好开发体验的附加组件。以下段落是从官方TypeScript文档中提取的：
- en: '"The "Language Service" exposes an additional layer around the core compiler
    pipeline that is best suiting editor-like applications. The language service supports
    the common set of a typical editor operations like statement completions, signature
    help, code formatting and outlining, colorization, etc... Basic re-factoring like
    rename, Debugging interface helpers like validating breakpoints as well as TypeScript-specific
    features like support of incremental compilation (--watch equivalent on the command-line).
    The language service is designed to efficiently handle scenarios with files changing
    over time within a long-lived compilation context; in that sense, the language
    service provides a slightly different perspective about working with programs
    and source files from that of the other compiler interfaces."'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: “语言服务”在核心编译器管道周围提供了一个额外的层，非常适合类似编辑器的应用程序。语言服务支持典型的编辑器操作集，如语句完成、签名帮助、代码格式化和大纲、着色等。基本的重构，如重命名，调试接口辅助，如验证断点，以及TypeScript特定的功能，如支持增量编译（命令行上的--watch等效）。语言服务旨在高效地处理在长期编译上下文中随时间变化的文件场景；从这个意义上说，语言服务从其他编译器接口的角度来看，对与程序和源文件的工作提供了略微不同的视角。”
- en: Understanding the abstract syntax tree (AST)
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解抽象语法树（AST）
- en: As we have already learned, an **abstract syntax tree**, or **AST**, is a tree-like
    data structure used to represent the abstract syntactic structure of source code
    written in a programming language. Each node of the AST represents a construct
    that occurs in the source code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经学到的，**抽象语法树**（AST）是一种树形数据结构，用于表示用编程语言编写的源代码的抽象句法结构。AST的每个节点都代表源代码中发生的一个构造。
- en: 'We are now going to look at a small TypeScript code snippet to understand the
    AST in detail. There is nothing very special about the following code snippet—it
    simply declares an interface named `Weapon` and a couple of classes, named `Katana`
    and `Ninja`. It then creates an instance of the `Ninja` class and invokes one
    of its methods:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看一个小型的TypeScript代码片段，以详细了解AST。以下代码片段没有什么特别之处——它只是声明了一个名为`Weapon`的接口和几个类，名为`Katana`和`Ninja`。然后它创建了一个`Ninja`类的实例并调用了它的一种方法：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The AST for the preceding code snippet generated by the TypeScript compiler
    looks as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器生成的先前代码片段的AST如下所示：
- en: '![](img/8adc6f41-2ece-476d-a243-f9c76f3ada99.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8adc6f41-2ece-476d-a243-f9c76f3ada99.png)'
- en: Some of the nodes of the preceding AST have been removed for ease of understanding.
    We can see how the AST starts with a `SourceFile` node and ends with an `EndOfFileToken`
    node. Between these two nodes, we have a node for the interface declaration (`InterfaceDeclaration`),
    two nodes for the class declarations (`ClassDeclaration`), one node for the variable
    declaration (`VariableStatement`), and, finally, a node for the method invocation
    (`ExpressionStatement`).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于理解，已经删除了先前AST的一些节点。我们可以看到AST从`SourceFile`节点开始，以`EndOfFileToken`节点结束。在这两个节点之间，我们有一个接口声明节点（`InterfaceDeclaration`），两个类声明节点（`ClassDeclaration`），一个变量声明节点（`VariableStatement`），以及最终的方法调用节点（`ExpressionStatement`）。
- en: 'We are now going to focus on one of these nodes: the node that represents the
    interface declaration (`InterfaceDeclaration`). As we saw earlier, the interface
    declaration looks as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将关注这些节点中的一个：表示接口声明的节点（`InterfaceDeclaration`）。正如我们之前看到的，接口声明看起来如下：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `InterfaceDeclaration` node in the AST for the preceding code snippet looks
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的 AST 中的 `InterfaceDeclaration` 节点如下所示：
- en: '![](img/9e8467e2-a31c-4eb8-a0b8-c0a7a6629136.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e8467e2-a31c-4eb8-a0b8-c0a7a6629136.png)'
- en: In the preceding representation of the AST, we can see the names of each of
    the nodes that compose the AST of an interface declaration with a unique method
    signature. For example, we can see that the declaration starts with a node that
    represents the `interface` keyword (`InterfaceKeyword`), and that it is followed
    by the name of the interface (`Identifier`). We can also see that the `tryHit`
    method takes a number (`NumberKeyword`) as an argument and returns a boolean (`BooleanKeyword`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面 AST 的表示中，我们可以看到组成接口声明 AST 且具有唯一方法签名的每个节点的名称。例如，我们可以看到声明从表示 `interface` 关键字的节点（`InterfaceKeyword`）开始，并且其后是接口的名称（`Identifier`）。我们还可以看到
    `tryHit` 方法接受一个数字（`NumberKeyword`）作为参数，并返回一个布尔值（`BooleanKeyword`）。
- en: 'The AST nodes have certain properties. For example, the `NumberKeyword` in
    the preceding example has the following properties:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: AST 节点具有某些属性。例如，前面示例中的 `NumberKeyword` 具有以下属性：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These properties allow us to identify the kind of the node (the `kind` property)
    and its position within the source code (the `pos` and `end` properties). The
    `kind` is a reference to a `Token`. The value `133` is the value of the `NumberKeyword`
    property in the `SyntaxKind` enum.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性使我们能够识别节点的类型（`kind` 属性）及其在源代码中的位置（`pos` 和 `end` 属性）。`kind` 是对 `Token` 的引用。值
    `133` 是 `SyntaxKind` 枚举中 `NumberKeyword` 属性的值。
- en: Now we know what the TypeScript AST is and what it looks like. In the following
    section, we are going to learn about a tool that can help us to visualize the
    AST.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了 TypeScript AST 是什么以及它的样子。在接下来的部分，我们将学习一个可以帮助我们可视化 AST 的工具。
- en: TypeScript AST Viewer
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript AST 查看器
- en: 'TypeScript AST Viewer is an open source application that allows us to explore
    the AST for a given TypeScript code snippet. This application is available online
    at [http://ts-ast-viewer.com](http://ts-ast-viewer.com):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript AST 查看器是一个开源应用程序，允许我们探索给定 TypeScript 代码片段的 AST。此应用程序可在 [http://ts-ast-viewer.com](http://ts-ast-viewer.com)
    上在线使用：
- en: '![](img/911252a4-64b9-4ba0-94a6-c81040af7333.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/911252a4-64b9-4ba0-94a6-c81040af7333.png)'
- en: Sample application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例应用程序
- en: The companion source code includes a very small application that we are going
    to use throughout the rest of this chapter. The following subsections describe
    each of the components in the sample application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随源代码包括一个非常小的应用程序，我们将在本章的其余部分使用它。以下小节描述了示例应用程序中的每个组件。
- en: interfaces.ts
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: interfaces.ts
- en: 'The `interfaces.ts` file declares and exports a couple of interfaces:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`interfaces.ts` 文件声明并导出了一些接口：'
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: katana.ts
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: katana.ts
- en: 'The `katana.ts` file declares a base class named `BaseWeapon` and a derived
    class named `Katana`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`katana.ts` 文件声明了一个名为 `BaseWeapon` 的基类和一个名为 `Katana` 的派生类：'
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ninja.ts
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ninja.ts
- en: 'The `ninja.ts` file declares a class named `Ninja`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ninja.ts` 文件声明了一个名为 `Ninja` 的类：'
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: main.ts
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main.ts
- en: 'The `main.ts` file is the application''s entry point. It creates an instance
    of `Katana` and an instance of `Ninja` and then invokes one of the methods of
    the `Ninja` instance:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.ts` 文件是应用程序的入口点。它创建了一个 `Katana` 实例和一个 `Ninja` 实例，然后调用 `Ninja` 实例的一个方法：'
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: broken.ts
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: broken.ts
- en: 'The companion source code also includes a file named `broken.ts`. This file
    contains some compilation errors on purpose because it is used to demonstrate
    how to perform error diagnostics:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随源代码还包括一个名为 `broken.ts` 的文件。此文件故意包含一些编译错误，因为它用于演示如何执行错误诊断：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Traversing the TypeScript AST
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历 TypeScript AST
- en: We have learned how to visualize the TypeScript AST using the TypeScript AST
    viewer online. At this point, it is normal to ask ourselves where all this information
    is coming from. In this section, we are going to demonstrate how to use the TypeScript
    compiler APIs to access the AST.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用在线 TypeScript AST 查看器可视化 TypeScript AST。在这个时候，我们自然会问自己所有这些信息是从哪里来的。在本节中，我们将演示如何使用
    TypeScript 编译器 API 访问 AST。
- en: 'After creating a `package.json` file and installing TypeScript using `npm`,
    the first thing that we need to do is to create a new TypeScript file and import
    TypeScript as a module:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `package.json` 文件并使用 `npm` 安装 TypeScript 之后，我们首先需要做的是创建一个新的 TypeScript 文件并将
    TypeScript 作为模块导入：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we need to declare the configuration of the TypeScript compiler using
    an object literal:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要使用对象字面量声明 TypeScript 编译器的配置：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to create a new program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新的程序：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A program is a collection of source files and a set of compilation options that
    represent a compilation unit. The program is the main entry point to the type
    system and code generation system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是一组源文件和一组表示编译单元的编译选项的集合。程序是类型系统和代码生成系统的主入口点。
- en: 'Then we need to create an instance of the TypeScript type checker:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要创建 TypeScript 类型检查器的实例：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At this point, we can write some code to iterate through the source files in
    the program. The following code snippet traverses the AST of the given source
    files and returns a list of the classes and interfaces declared in each file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以编写一些代码来遍历程序中的源文件。以下代码片段遍历给定源文件的 AST，并返回每个文件中声明的类和接口列表。
- en: It uses the `getSourceFiles` method of the program instance to access the source
    files in the program. The `lib.d.ts` file and the files under the `node_modules`
    directory are ignored.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用程序实例的 `getSourceFiles` 方法来访问程序中的源文件。`lib.d.ts` 文件和 `node_modules` 目录下的文件将被忽略。
- en: 'The code snippet uses a recursive function named `visit` to traverse the nodes
    in the AST. The recursive function compares each of the nodes with the tokens
    that we are looking for (`ClassDeclaration` and `InterfaceDeclaration`) to identify
    the classes and interfaces:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段使用名为 `visit` 的递归函数来遍历 AST 中的节点。递归函数将每个节点与我们要查找的标记（`ClassDeclaration` 和 `InterfaceDeclaration`）进行比较，以识别类和接口：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the token found is a module declaration, we will invoke the recursive function
    `visit` once more. Once we have managed to find all the classes and interfaces
    in our source code, we can display them in the console using a simple `forEach`
    loop:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到的标记是模块声明，我们将再次调用递归函数 `visit`。一旦我们成功找到源代码中的所有类和接口，我们可以使用简单的 `forEach` 循环在控制台中显示它们：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the `chalk` module can be installed via `npm`, and is used to display
    colored text in the console output.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`chalk` 模块可以通过 `npm` 安装，并用于在控制台输出中显示彩色文本。
- en: 'Now we know how we can access and traverse the TypeScript AST. As we can see,
    the process required to create this kind of task is quite tedious. However, there
    is an open source tool that can help us to traverse the TypeScript AST with ease:
    `ts-simple-ast`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何访问和遍历 TypeScript AST。正如我们所见，创建此类任务所需的过程相当繁琐。然而，有一个开源工具可以帮助我们轻松地遍历 TypeScript
    AST：`ts-simple-ast`。
- en: Working with ts-simple-ast
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ts-simple-ast
- en: As we learned in the preceding section, when it comes to working with the TypeScript,
    AST is not very complicated. However, there is an open source npm module named
    `ts-simple-ast` that makes working with the TypeScript AST even easier! In this
    section, we are going to take a look at multiple examples to learn how to use
    `ts-simple-ast`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中学到的，当涉及到与 TypeScript 一起工作时，AST 并不是很复杂。然而，有一个名为 `ts-simple-ast` 的开源
    npm 模块可以使处理 TypeScript AST 更加容易！在本节中，我们将查看多个示例，以了解如何使用 `ts-simple-ast`。
- en: Traversing the AST with ts-simple-ast
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ts-simple-ast 遍历 AST
- en: 'The following code snippet implements an application that is almost identical
    to the application that we implemented in the preceding section. The most notable
    difference is that, instead of using the core TypeScript compiler APIs, we are
    going to use the `ts-simple-ast` helpers:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了一个几乎与上一节中实现的程序完全相同的应用程序。最显著的区别是，我们不是使用核心 TypeScript 编译器 API，而是将使用 `ts-simple-ast`
    辅助工具：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following function is used in many of the examples in this chapter, and
    it is used to get an instance of the TypeScript AST, given certain files and the
    desired compiler settings:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数在本章的许多示例中使用，用于根据某些文件和所需的编译器设置获取 TypeScript AST 的实例：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can use the `getAst` function to access the `ts-simple-ast` AST and then
    the `getSourceFiles` method to access the source files in the program:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `getAst` 函数来访问 `ts-simple-ast` AST，然后使用 `getSourceFiles` 方法来访问程序中的源文件：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At this point, we can use `getFilePath` to get the path of a source file and
    the `getClasses` and `getInterfaces` methods to access the class and interface
    declarations in a source file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以使用 `getFilePath` 来获取源文件的路径，以及使用 `getClasses` 和 `getInterfaces` 方法来访问源文件中的类和接口声明：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see, the `ts-simple-ast` helpers can greatly simplify traversing the
    TypeScript AST or searching for a certain kind of entity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`ts-simple-ast` 辅助工具可以极大地简化遍历TypeScript AST或搜索特定类型的实体。
- en: 'Finally, we can display the name of the classes on the command-line interface:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在命令行界面显示类的名称：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Diagnostics with ts-simple-ast
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ts-simple-ast 进行诊断
- en: 'The following code snippet implements a very small application that uses `ts-simple-ast`
    to find errors in a TypeScript file using the error diagnostic APIs. The application
    uses the `chalk` npm module to display errors using a red font in the command-line
    interface:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了一个非常小的应用程序，该应用程序使用 `ts-simple-ast` 通过错误诊断API在TypeScript文件中查找错误。该应用程序使用
    `chalk` npm模块在命令行界面以红色字体显示错误：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following function is the same `getAst` function that we used in the preceding
    section:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是我们在前面部分使用的相同的 `getAst` 函数：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The AST provided by `ts-simple-ast` includes a method named `getDiagnostics`,
    which allows us to access the detected compilation errors. The `getErrors` function
    showcases how to traverse each of the diagnostics and how to access the underlying
    `DiagnosticMessageChain`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts-simple-ast` 提供的AST包含一个名为 `getDiagnostics` 的方法，它允许我们访问检测到的编译错误。`getErrors`
    函数展示了如何遍历每个诊断以及如何访问底层的 `DiagnosticMessageChain`。'
- en: 'The method `diagnostic.getMessageText` returns a string or a `DiagnosticMessageChain`.
    The `DiagnosticMessageChain` implements the iterator pattern, which explains why
    we use the `DiagnosticMessageChain.getNext` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `diagnostic.getMessageText` 返回一个字符串或一个 `DiagnosticMessageChain`。`DiagnosticMessageChain`
    实现了迭代器模式，这就是为什么我们使用 `DiagnosticMessageChain.getNext` 方法的原因：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Accessing class details with ts-simple-ast
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ts-simple-ast 访问类详情
- en: The following code snippet demonstrates how we can use the `ts-simple-ast` APIs
    to access and manipulate class declarations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了我们可以如何使用 `ts-simple-ast` API来访问和操作类声明。
- en: Note that the preceding example is not meant to be executed. It is a showcase
    of the available methods in the `ts-simple-ast` API, but it is not an executable
    demo.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的示例不是用来执行的。它展示了 `ts-simple-ast` API中可用的方法，但它不是一个可执行的演示。
- en: Just like in the preceding examples, we are going to use the `getAst`, `getSourceFiles`,
    and `getClasses` methods to find all the class declarations in our source code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的示例一样，我们将使用 `getAst`、`getSourceFiles` 和 `getClasses` 方法来找到我们源代码中的所有类声明。
- en: 'We will then use some tools to access the details of the class declaration,
    including methods, derived classes, and properties, among others. We will also
    demonstrate how we can modify the class declaration by performing operations such
    as adding a base class or a new method:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用一些工具来访问类声明的详细信息，包括方法、派生类和属性等。我们还将演示如何通过添加基类或新方法等操作来修改类声明：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Accessing module details with ts-simple-ast
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ts-simple-ast 访问模块详情
- en: The following code snippet demonstrates how we can use the `ts-simple-ast` APIs
    to access and manipulate module `import` and `export` declarations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了我们可以如何使用 `ts-simple-ast` API来访问和操作模块 `import` 和 `export` 声明。
- en: Note that the preceding example is not meant to be executed. It is a showcase
    of the available methods in the `ts-simple-ast` API, but it is not an executable
    demo.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的示例不是用来执行的。它展示了 `ts-simple-ast` API中可用的方法，但它不是一个可执行的演示。
- en: 'Just like in the preceding examples, we are going to use the `getAst` and `getSourceFiles` methods
    to access the source code''s objects:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的示例一样，我们将使用 `getAst` 和 `getSourceFiles` 方法来访问源代码的对象：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will then use some methods to access the details of the module `import`
    and `export` declarations. We also demonstrate how we can add and remove module
    `import` and `export` declarations by performing operations such as adding a default
    `export`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用一些方法来访问模块 `import` 和 `export` 声明的详细信息。我们还演示了如何通过添加默认的 `export` 等操作来添加和删除模块
    `import` 和 `export` 声明：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Accessing the language services API
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问语言服务API
- en: The language services API is built on top of the core compiler APIs, and it
    was designed to provide software engineers with a great developer experience independent
    of their IDE or code editor of choice.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 语言服务API建立在核心编译器API之上，它被设计用来为软件工程师提供独立于他们选择的IDE或代码编辑器的优秀开发体验。
- en: 'We are going to use `ts-simple-ast` to access the language services API. We
    can access the language services API using the `getLanguageService` method in
    an AST instance:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ts-simple-ast`来访问语言服务API。我们可以在AST实例中使用`getLanguageService`方法来访问语言服务API：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The language services API implements methods that allow us to perform a common
    editing task, such as renaming a variable or automatically implementing an interface.
    The following screenshot shows some of the available methods in the language services
    API:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 语言服务API实现了允许我们执行常见编辑任务的方法，例如重命名变量或自动实现接口。以下截图显示了语言服务API中的一些可用方法：
- en: '![](img/7c1f8e17-a5e4-4f43-8214-350fed0df449.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c1f8e17-a5e4-4f43-8214-350fed0df449.png)'
- en: 'We are now going to create a very small application that uses the language
    services API to find interfaces in the sample application included in the companion
    source code. The application will display the name of each of the interfaces and
    the name of each of their implementations:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个非常小的应用程序，该应用程序使用语言服务API在配套源代码中包含的示例应用程序中查找接口。该应用程序将显示每个接口及其实现的名称：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We then need to find the name of each of the interface declarations using the
    `getName` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用`getName`方法找到每个接口声明的名称。
- en: We are also going to try to find each of their implementations using the `getImplementations`
    method, which is part of the language services API. The method expects us to pass
    the node that declares the interface. The node can be accessed using the `interfaceDeclaration.getNameNode`
    method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将尝试使用`getImplementations`方法找到它们的每个实现，这个方法是语言服务API的一部分。该方法期望我们传递声明接口的节点。节点可以通过`interfaceDeclaration.getNameNode`方法访问。
- en: 'Once we have found the implementations, we need to find their names. We do
    this by searching for the name of the nodes of the kind called `Identifier`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了实现，我们需要找到它们的名称。我们通过搜索称为`Identifier`类型的节点的名称来完成此操作：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we display the results in the console:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在控制台中显示结果：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we execute the application, we should be able to see the following displayed
    in our console:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行应用程序，我们应该能够在我们的控制台中看到以下内容显示：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since TypeScript 2.2, it is possible to write language services plugins to extend
    the language services API. Custom language services can help to provide developers
    with a better developing experience. For example, there is a language service
    that provides developers with autocomplete and error diagnostic features while
    working with GraphQL queries. Before this, GraphQL queries were just text, and
    as a result, they were somewhat tedious to implement. Implementing our language
    services plugins is out of the scope of this book, but if you wish to learn more,
    you will be able to do so at [https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin](https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 自从TypeScript 2.2以来，可以编写语言服务插件来扩展语言服务API。自定义语言服务可以帮助开发者获得更好的开发体验。例如，有一个语言服务在开发者处理GraphQL查询时提供自动完成和错误诊断功能。在此之前，GraphQL查询只是文本，因此它们在实现上有些繁琐。实现我们的语言服务插件超出了本书的范围，但如果你希望了解更多，你可以在[https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin](https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin)上学习。
- en: Implementing a yUML compiler
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个yUML编译器
- en: In this section, we are going to put together everything that we have learned
    so far during this chapter to create a custom developer tool. We are going to
    write a tool that takes TypeScript source code as input and generates a **unified
    modeling language** (**UML**) class diagram. A class diagram describes the structure
    of a system by showing the system's classes, their attributes, methods, and the
    relationships among the objects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把在本章中学到的所有内容整合起来，创建一个自定义的开发工具。我们将编写一个工具，它接受TypeScript源代码作为输入，并生成一个**统一建模语言**（**UML**）类图。类图通过显示系统的类、它们的属性、方法和对象之间的关系来描述系统的结构。
- en: 'A class diagram looks as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类图看起来如下：
- en: '![](img/794d7e60-33ed-4437-af11-ae46afdd8b1c.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/794d7e60-33ed-4437-af11-ae46afdd8b1c.png)'
- en: We are going to use the TypeScript compiler API and `ts-simple-ast` to traverse
    the AST generated by the sample application included in the companion source code.
    We will then emit some code in a **domain-specific language** (**DSL**) known
    as yUML. Finally, we will post the yUML DSL to an online service to generate the
    diagram as an image. We are going to translate from TypeScript to yUML, which
    means that we can think about this as creating a yUML compiler.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 TypeScript 编译器 API 和 `ts-simple-ast` 来遍历由配套源代码中包含的示例应用程序生成的 AST。然后，我们将以一个称为
    yUML 的**领域特定语言**（**DSL**）的形式生成一些代码。最后，我们将 yUML DSL 发布到在线服务以生成图像。我们将从 TypeScript
    转换为 yUML，这意味着我们可以将此视为创建一个 yUML 编译器。
- en: 'We are going to start by importing some required modules:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先导入一些必需的模块：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `fs` and `path` modules are native core Node.js modules and don't need to
    be installed. However, we are going to need the type definitions for Node.js (`@types/node`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs` 和 `path` 模块是 Node.js 的原生核心模块，不需要安装。但是，我们需要 Node.js 的类型定义（`@types/node`）。'
- en: Note that the `flatten` function is part of the `lodash` npm module. This function
    allows us to transform a multidimensional array (for example, an array of arrays)
    into an array with only one dimension.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`flatten` 函数是 `lodash` npm 模块的一部分。此函数允许我们将多维数组（例如，数组数组）转换为只有一个维度的数组。
- en: 'We are then going to declare two interfaces that are used to represent the
    relevant details about a class, method, or property. In this example, we are going
    to only use the name of the method or property:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将声明两个接口，用于表示类、方法或属性的详细信息。在这个例子中，我们只将使用方法或属性的名称：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following code snippet declares a constant variable named `templates`.
    Templates are functions that take names and return strings that contain yUML DSL
    snippets:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为 `templates` 的常量变量。模板是接受名称并返回包含 yUML DSL 片段的字符串的函数：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following function is used to get the AST for the given source files:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于获取给定源文件的 AST：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following function emits the yUML DSL for the class declarations. We traverse
    the AST, searching for properties and methods:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数生成类声明的 yUML DSL。我们遍历 AST，寻找属性和方法：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following function emits the yUML DSL for interface declarations. We traverse
    through the AST, searching for properties and methods:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数生成接口声明的 yUML DSL。我们遍历 AST，寻找属性和方法：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following function emits the yUML DSL for heritage clauses. This includes
    relationships defined in our source code by the use of the `extends` and `implements`
    keywords:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数生成继承子句的 yUML DSL。这包括通过使用 `extends` 和 `implements` 关键字在源代码中定义的关系：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The following function renders the UML diagram into a `.png` file using the
    yUML web service. We invoke the web service using the `request` npm module.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数使用 yUML 网络服务将 UML 图表渲染到 `.png` 文件。我们使用 `request` npm 模块调用该网络服务：
- en: 'The `request` module is used to download the rendered image. The image is then
    saved into the current directory using the code''s Node.js FileSystem API:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 模块用于下载渲染后的图像。然后使用 Node.js 文件系统 API 将图像保存到当前目录：'
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following function generates the yUML DSL for the given TypeScript files.
    This function delegates work to the previously defined `getAst`, `emitClass`,
    `emitInterface`, and `emitInheritanceRelationships` functions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数为给定的 TypeScript 文件生成 yUML DSL。此函数将工作委托给先前定义的 `getAst`、`emitClass`、`emitInterface`
    和 `emitInheritanceRelationships` 函数：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At this point, we have implemented the entire application and we can invoke
    the yUML function to generate the yUML DSL for the given files:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了整个应用程序，并且可以调用 yUML 函数来为给定的文件生成 yUML DSL：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we can invoke the `render` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以调用 `render` 函数：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Refer to the official `ts-simple-ast` documentation at [https://dsherret.github.io/ts-simple-ast/](https://dsherret.github.io/ts-simple-ast/)
    to learn more about the available APIs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方 `ts-simple-ast` 文档 [https://dsherret.github.io/ts-simple-ast/](https://dsherret.github.io/ts-simple-ast/)
    了解更多关于可用 API 的信息。
- en: VS Code extensions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VS Code 扩展
- en: Developing Visual Studio extensions is out of the scope of this book. However,
    it is worth mentioning that VS Code extensions can be developed using TypeScript.
    This means that it is possible to transform our custom command-line TypeScript
    tools, such as the UML diagram generator, into VS Code extensions without too
    many complications.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 开发 Visual Studio 扩展超出了本书的范围。然而，值得一提的是，可以使用 TypeScript 开发 VS Code 扩展。这意味着我们可以将我们的自定义命令行
    TypeScript 工具，如 UML 图生成器，转换成 VS Code 扩展，而不会遇到太多复杂的问题。
- en: Refer to the official VS Code documentation about the development of extensions
    at [https://code.visualstudio.com/docs/extensions/overview](https://code.visualstudio.com/docs/extensions/overview)
    to learn more.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考关于在 [https://code.visualstudio.com/docs/extensions/overview](https://code.visualstudio.com/docs/extensions/overview)
    开发扩展的官方 VS Code 文档以获取更多信息。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the internal components of the TypeScript
    compiler. We have also learned how to use the compiler APIs and how we can take
    advantage of these features to develop our TypeScript development tools.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 TypeScript 编译器的内部组件。我们还学习了如何使用编译器 API 以及如何利用这些特性来开发我们的 TypeScript
    开发工具。
- en: I hope that this chapter will foster your curiosity of the TypeScript compiler
    internals and the development of software development tools powered by TypeScript.
    Their potential and growing popularity will take the JavaScript ecosystem to the
    next level.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这一章能够激发你对 TypeScript 编译器内部结构和由 TypeScript 驱动的软件开发工具开发的兴趣。它们的潜力和日益增长的受欢迎程度将把
    JavaScript 生态系统提升到新的水平。
