- en: Chapter 6. User Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章：用户管理
- en: 'In the previous chapters, we developed mechanisms to provide login and logout
    capabilities and client-side session monitoring, and we also implemented a dynamic
    menu based on the user permissions. However, all the users, groups, and permissions
    were added manually to the database until now. We cannot do this every time we
    need to grant access to the application to a new user or change the user permissions.
    For this reason, we will implement a screen where we can create new users and
    grant or change the permissions. So in this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们开发了提供登录和注销功能以及客户端会话监控的机制，我们还实现了一个基于用户权限的动态菜单。然而，直到现在，所有用户、组和权限都是手动添加到数据库中的。我们不能每次需要向新用户授予应用程序访问权限或更改用户权限时都这样做。因此，我们将实现一个屏幕，我们可以在这里创建新用户并授予或更改权限。所以在本章中，我们将涵盖：
- en: Listing all the users from the system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出系统中的所有用户
- en: Creating, editing and deleting users
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、编辑和删除用户
- en: Picture preview of a file upload (user's picture)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件上传的图片预览（用户图片）
- en: Managing users
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户
- en: So the first module we are going to develop is user management. In this module,
    we will be able to see all the users that are registered on the system, add new
    users, edit, and delete current users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将要开发的第一个模块是用户管理。在这个模块中，我们将能够看到系统中注册的所有用户，添加新用户，编辑和删除当前用户。
- en: 'When the user clicks on the **Users** menu option, a new tab will open with
    the list of all users from the system as shown in the following screenshot:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 **用户** 菜单选项时，将打开一个新标签页，显示系统中的所有用户列表，如下截图所示：
- en: '![Managing users](img/0457OT_06_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![管理用户](img/0457OT_06_01.jpg)'
- en: 'When the user clicks on the **Add** or **Edit** button, the system will display
    a window so that the user can create a new user or edit a current user (based
    on the record selected on the GridPanel). The **Edit** window will look like the
    following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 **添加** 或 **编辑** 按钮时，系统将显示一个窗口，以便用户可以创建新用户或编辑当前用户（基于在 GridPanel 上选择的记录）。**编辑**
    窗口将如下截图所示：
- en: '![Managing users](img/0457OT_06_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![管理用户](img/0457OT_06_02.jpg)'
- en: 'Some capabilities of creating or editing a user: we can edit the **User Information**
    such as **Name**, **Username**, and so on and we can also upload a **Photo** representing
    the user. But there is an extra feature; using the HTML5 API, we are going to
    display a preview of the **Photo** right after the user selects the picture from
    the computer and before the user uploads to the server.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或编辑用户的某些功能：我们可以编辑 **用户信息**，如 **姓名**、**用户名** 等，我们还可以上传代表用户的 **照片**。但有一个额外功能；使用
    HTML5 API，我们将在用户从计算机中选择图片并上传到服务器之前立即显示 **照片** 的预览。
- en: Listing all the users using a simple GridPanel
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简单的 GridPanel 列出所有用户
- en: 'We need to implement a screen similar to the first screenshot present in this
    chapter. It is a simple GridPanel. So to implement a simple GridPanel**,** we
    need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个类似于本章第一张截图的屏幕。它是一个简单的 GridPanel。因此，要实现一个简单的 GridPanel，我们需要以下内容：
- en: A Model to represent the information that is stored on the `user` table
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Model 来表示存储在 `user` 表上的信息
- en: A Store to load the information and a Proxy to tell Ext JS to read the information
    from the server
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于加载数据的 Store 和用于告诉 Ext JS 从服务器读取信息的 Proxy
- en: A GridPanel component representing the View
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表视图的 GridPanel 组件
- en: A ViewController to listen to the events, as we are going to develop this module
    using MVVM
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于监听事件的 ViewController，因为我们打算使用 MVVM 模式来开发这个模块
- en: Creating a User Model
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户 Model
- en: 'So the first step is to create a Model to represent the `user` table. We are
    going to create a new file named `User.js` under the `app/model/security` directory.
    This Model is going to represent all the fields from the `user` table, except
    the `password` field, because as the password is something very personal to the
    user, we cannot display the user''s password to any other user, including the
    administrator. So the User Model is going to look like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是创建一个 Model 来表示 `user` 表。我们将在 `app/model/security` 目录下创建一个名为 `User.js`
    的新文件。这个 Model 将表示 `user` 表中的所有字段，除了 `password` 字段，因为密码是用户非常私人的信息，我们不能向任何其他用户显示用户的密码，包括管理员。因此，用户
    Model 将如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And as we mentioned before, all the fields from the `user` table are mapped
    into this Model, except the `password` field.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`user` 表中的所有字段都映射到这个 Model 中，除了 `password` 字段。
- en: In line `#1` we are not extending the default `Ext.data.Model` class. We are
    extending a class that we created. Let's see its declaration next.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 `#1` 中，我们没有扩展默认的 `Ext.data.Model` 类。我们扩展了一个我们创建的类。让我们看看它的声明。
- en: Working with schemas
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与模式一起工作
- en: When we designed the database tables, we also added a foreign key to the `user`
    table. This means the `user` table has a relationship with the `groups` table.
    Ext JS 5 introduced the concept of schemas. A schema (`Ext.data.schema.Schema`)
    is a collection of related entities and their respective associations. We know
    that the `User` and `Group` Model classes are related entities, so we can create
    a schema to represent them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计数据库表时，我们还向 `user` 表添加了一个外键。这意味着 `user` 表与 `groups` 表有关联。Ext JS 5 引入了模式的概念。模式（`Ext.data.schema.Schema`）是一组相关实体及其相应的关联。我们知道
    `User` 和 `Group` 模型类是相关实体，因此我们可以创建一个模式来表示它们。
- en: 'So let''s see what''s inside the `Packt.model.security.Base` class:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Packt.model.security.Base` 类内部的内容：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `security.Base` model will work as a super Model that the `User` and `Group`
    (which will be defined later in this chapter in the section *Declaring the User
    ViewModel*) classes and contains the common code for both models.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`security.Base` 模型将作为一个超级模型工作，该模型包含 `User` 和 `Group` 类（这些类将在本章的 *声明用户视图模型*
    部分中定义），并为这两个模型提供共同的代码。'
- en: The first thing the `User` and `Group` Model classes have in common is the `id`
    field (`#1`). So to reuse this field in both classes, we can declare it here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 和 `Group` 模型类共同拥有的第一个东西是 `id` 字段 (`#1`)。因此，为了在两个类中重用这个字段，我们可以在这里声明它。'
- en: Next, `config` is the `schema`. Inside the `schema`, we can configure some options.
    The first one is `namespace` (`#2`). In some cases, we want to use a short name
    for the Model entities. We will use the short name of the `User` and `Group` classes
    when declaring associations and in the **ViewController** later. The short name
    is also known in Ext JS as `entityName` of the Model (we can declare this `config`
    in the Model as well). By default, `entityName` is the full class name, but this
    is exactly what we are trying to avoid. However, if `namespace` is used (in a
    `schema` declaration), the common portion can be discarded, and we can derive
    a shorter name. For example, the full name of the `User` class is `Packt.model.security.User`,
    and its schema namespace is `Packt.model.security`, so `entityName` will result
    in `User`. Using only `User` instead of `Packt.model.security.User` is much better.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`config` 是 `schema`。在 `schema` 中，我们可以配置一些选项。第一个是 `namespace` (`#2`)。在某些情况下，我们希望为模型实体使用简短的名字。当我们声明关联和稍后在
    **ViewController** 中时，我们将使用 `User` 和 `Group` 类的简短名字。这个简短的名字在 Ext JS 中也被称为模型的 `entityName`（我们也可以在模型中声明这个
    `config`）。默认情况下，`entityName` 是完整的类名，但这正是我们试图避免的。然而，如果使用了 `namespace`（在 `schema`
    声明中），则可以丢弃公共部分，并可以派生出更短的名字。例如，`User` 类的完整名字是 `Packt.model.security.User`，其模式命名空间是
    `Packt.model.security`，因此 `entityName` 将结果是 `User`。仅使用 `User` 而不是 `Packt.model.security.User`
    会更好。
- en: We also have the `urlPrefix` (`#3`), which is the URL prefix used for all requests
    to the server. We are going to use this information when configuring `proxy` (in
    [Chapter 5](ch05.html "Chapter 5. Advanced Dynamic Menu"), *Advanced Dynamic Menu*,
    we used `proxy` inside the Store; now we are going to use it inside the Model).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个 `urlPrefix` (`#3`), 这是用于所有服务器请求的 URL 前缀。当配置 `proxy` 时（在 [第 5 章](ch05.html
    "第 5 章。高级动态菜单")，*高级动态菜单* 中，我们在 Store 中使用了 `proxy`；现在我们将在 Model 中使用它）我们将使用这个信息。
- en: 'Next, we are going to configure `proxy` as follows. As we are using `proxy`
    inside the `schema` declaration, the configuration will be available for all classes
    extending the `Packt.model.security.Base` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按照以下方式配置 `proxy`。由于我们在 `schema` 声明中使用 `proxy`，因此该配置将对所有扩展 `Packt.model.security.Base`
    类的类可用：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we want to specify a different `url` for each of the CRUD operations, instead
    of using the `url` config we use the `api` config. Inside the `api` config, we
    define a `url` config for each CRUD action. When using schemas, we can use a template
    in the `proxy` to configure the URLs. For example, we use `prefix`, which refers
    to `urlPrefix` that we configured before. The `entityName` attribute refers to
    the Model `entityName` (and in this example, we also ask to transform the `entityName`
    to lowercase). In line `#4`, for the `User` Model class, the read `url` will be
    `php/user/list.php`. This is very useful when we want to follow a pattern and
    share (reuse) the `schema` configuration between different models.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要为每个CRUD操作指定不同的`url`时，而不是使用`url`配置，我们使用`api`配置。在`api`配置内部，我们为每个CRUD操作定义一个`url`配置。当使用模式时，我们可以在`proxy`中使用一个模板来配置URL。例如，我们使用`prefix`，它指的是我们之前配置的`urlPrefix`。`entityName`属性指的是模型的`entityName`（在这个例子中，我们还要求将`entityName`转换为小写）。在行`#4`中，对于`User`模型类，读取`url`将是`php/user/list.php`。当我们想要遵循一个模式并在不同的模型之间共享（重用）`schema`配置时，这非常有用。
- en: We learned how to configure `reader` already. We can also specify `writer` (`#5`)
    when we want to send information to the server (create, update, or delete records).
    In this case, we are telling Ext JS we want to send a JSON back to the server.
    The `writeAllFields` configuration specifies whether we want the Model (and all
    its fields) to be sent to the server or only the fields that were modified (plus
    the `id` field). To make our life easier on the server-side code, we set `writeAllFields`
    as true. Just as with `reader`, we are also going to configure `rootProperty`
    to be a wrapper of the records. Then, we have the `encode` configuration set to
    `true` to send record data (all record fields if `writeAllFields` is `true`) as
    a JSON-encoded HTTP parameter named by the `rootProperty` configuration. The encode
    option should only be set to `true` when `rootProperty` is defined, because the
    values will be sent as part of the request parameters as opposed to a raw post.
    And at last, we have `allowSingle` set to `false`. This will force `proxy` to
    get all the modified records (to be created, updated, or deleted) and send them
    in an array (wrapped by `rootProperty` if configured). This will make `proxy`
    send only one request to the server (one request for creating, updating, or deleting
    records) instead of one request for each modification.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何配置`reader`。当我们想要向服务器发送信息（创建、更新或删除记录）时，我们也可以指定`writer`（`#5`）。在这种情况下，我们正在告诉Ext
    JS我们想要将一个JSON发送回服务器。`writeAllFields`配置指定了我们是否希望将模型（及其所有字段）发送到服务器，或者只发送已修改的字段（加上`id`字段）。为了使服务器端代码更简单，我们将`writeAllFields`设置为true。就像`reader`一样，我们还将配置`rootProperty`以作为记录的包装器。然后，我们将`encode`配置设置为`true`，以便将记录数据（如果`writeAllFields`为`true`，则为所有记录字段）作为由`rootProperty`配置命名的JSON编码的HTTP参数发送。当`rootProperty`被定义时，编码选项才应设置为`true`，因为值将作为请求参数的一部分发送，而不是原始的POST。最后，我们将`allowSingle`设置为`false`。这将强制`proxy`获取所有已修改的记录（要创建、更新或删除的记录）并将它们作为一个数组（如果已配置，则由`rootProperty`包装）发送。这将使`proxy`只向服务器发送一个请求（一个用于创建、更新或删除记录的请求），而不是每个修改发送一个请求。
- en: At last, we have the proxy `exception` `listener` (`#6`), which we are already
    familiar with from previous chapters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有代理`exception` `listener`（`#6`），这是我们已经在之前的章节中熟悉的。
- en: Defining store-less grids with Users GridPanel
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Users GridPanel定义无存储网格
- en: The next step is to create the views we are going to use to manage the users
    of our application. But before we get our hands on the code, we need to keep one
    thing in mind; when we implement the **Manage Groups** module and on the **Edit
    Group** screen, we want to display all the users that belong to that group. And
    for that, we will need to use a **Users** grid as well. So that being said, we
    need to create a component that will list the users (in this case all the users
    from the application) that we can reuse later. For this reason, the component
    that we are going to create will only contain the list of users and will not contain
    the **Add**/**Edit**/**Delete** buttons. We will add a toolbar with these buttons
    and also wrap the **Users** grid in another component.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们将用于管理应用程序用户的视图。但在我们动手编写代码之前，我们需要记住一件事；当我们实现 **Manage Groups** 模块并在 **Edit
    Group** 屏幕上时，我们希望显示属于该组的所有用户。为此，我们将需要使用一个 **Users** 网格。所以，我们需要创建一个可以稍后重用的组件来列出用户（在这种情况下是应用程序中的所有用户）。因此，我们将创建的组件将只包含用户列表，而不会包含
    **Add**/**Edit**/**Delete** 按钮。我们将添加一个带有这些按钮的工具栏，并将 **Users** 网格包裹在另一个组件中。
- en: 'So we are going to create a GridPanel. To do so, let''s create a new class
    named `Packt.view.security.UsersGrid`. To create this class, we will create a
    new file named `UsersGrid.js` under the `app/view/security` directory:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个 GridPanel。为了做到这一点，让我们在 `app/view/security` 目录下创建一个名为 `Packt.view.security.UsersGrid`
    的新类。要创建这个类，我们将创建一个名为 `UsersGrid.js` 的新文件：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As usual, we are going to start with `xtype`. An alternative to `xtype` is
    using the `alias` (`#1`). When using `xtype`, we can declare it directly (for
    example `xtype: ''user-grid''`). When using `alias`, we need to specify what type
    of alias we are creating. For components we use "`widget.`" and for plugins, we
    use "`plugin.`", followed by the `xtype`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '如同往常，我们将从 `xtype` 开始。`xtype` 的一个替代方案是使用 `alias` (`#1`)。当使用 `xtype` 时，我们可以直接声明它（例如
    `xtype: ''user-grid''`）。当使用 `alias` 时，我们需要指定我们正在创建的别名类型。对于组件，我们使用 "`widget.`"
    而对于插件，我们使用 "`plugin.`"，然后跟随着 `xtype`。'
- en: Let's go ahead and also create `reference` so that we can refer to this component
    later in the ViewModel (`#2`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建 `reference`，这样我们就可以在 ViewModel (`#2`) 中稍后引用这个组件。
- en: Whenever we declare a grid, there are two mandatory configurations we need to
    specify. The first one is the `columns` (`#3`) configuration, and the second one
    is the `store` configuration.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们声明一个网格时，我们需要指定两个强制性的配置。第一个是 `columns` (`#3`) 配置，第二个是 `store` 配置。
- en: The `columns` (`#3`) configuration is an array of column definition objects
    that define all columns that appear in the grid. Each column definition provides
    the header `text` (`text` configuration) for the column, and a definition of where
    the data for that column comes from ((`dataIndex`) `#4`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`columns` (`#3`) 配置是一个列定义对象的数组，它定义了网格中出现的所有列。每个列定义提供了列的标题 `text` (`text` 配置)，以及该列数据来源的定义（`dataIndex`
    `#4`）。'
- en: As a Grid is going to display a collection of data represented by a Model, each
    column needs to have the `dataIndex` (`#4`) configured matching the Model field
    that it represents.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网格将显示由模型表示的数据集合，每个列都需要配置 `dataIndex` (`#4`) 以匹配它所代表的模型字段。
- en: We can define a `width` for each column. But we do not know the monitor resolution
    the user will be using, and we might end up with some extra space. We can choose
    a column to use all the available space by specifying the `flex` configuration
    (`#5`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个列定义一个 `width`。但我们不知道用户将使用的显示器分辨率，我们可能会剩下一些额外空间。我们可以选择一个列来使用所有可用空间，通过指定
    `flex` 配置（`#5`）。
- en: At last, on line `#6`, we have a column with `dataIndex` `groups_id` (`#6`),
    which will render the `groups_id` foreign key from the `groups` table. When we
    display associated data in a grid, we do not want to display the foreign key,
    but the description or name of the information. For now, we will leave the `groups_id`
    configured, but we will come back here and change this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第 `#6` 行，我们有一个 `dataIndex` 为 `groups_id` 的列，它将渲染来自 `groups` 表的外键 `groups_id`。当我们在一个网格中显示关联数据时，我们不想显示外键，而是显示描述或信息名称。现在，我们将保持
    `groups_id` 配置，但我们会回来并更改这一点。
- en: The `store` configuration is also required when declaring a Grid. But this configuration
    is missing in this class. Ext JS 5 introduced the ViewModel, and because of this
    new architecture and the data-binding concept, we can declare a store-less Grid
    and configure this later.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明网格时，也需要`store`配置。但这个配置在这个类中缺失。Ext JS 5引入了ViewModel，由于这个新的架构和数据绑定概念，我们可以声明无存储的网格，并稍后进行配置。
- en: The Users screen
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户屏幕
- en: Now that we have the **Users** GridPanel ready, we still need to create another
    component that is going to wrap the **User** GridPanel and will also contain the
    toolbar with the **Add**/**Edit**/**Delete** buttons. The simplest component that
    supports Docked Items is the panel.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了**用户**GridPanel，我们仍然需要创建另一个组件，它将包装**用户**GridPanel，并且还将包含带有**添加**/**编辑**/**删除**按钮的工具栏。支持Docked
    Items的最简单组件是面板。
- en: 'We are going to create a new class named `Packt.view.security.User` that is
    going to extend from the `Ext.panel.Panel` class. To do so, we need to create
    a new file named `User.js` under the `app/view/security` directory, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`Packt.view.security.User`的新类，它将扩展`Ext.panel.Panel`类。为此，我们需要在`app/view/security`目录下创建一个名为`User.js`的新文件，如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this class, we will have only one component being rendered in the panel's
    body for now. It is the `users-grid` (`#6`). And as we are using its `xtype` to
    instantiate it, we need to make sure the `UsersGrid` class is already loaded,
    and that is why we need to add the class in the `requires` declaration (`#1`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们现在将在面板的主体中渲染一个组件。它是`users-grid`（`#6`）。由于我们使用其`xtype`来实例化它，我们需要确保`UsersGrid`类已经加载，这就是为什么我们需要在`requires`声明中添加类的理由（`#1`）。
- en: Later, we are going to create a window (popup) with a form that is going to
    allow us to create or edit a user. Because of some ViewModel concepts and limitations,
    we will add the window as an item of this class. For this reason, we are not going
    to use the Fit Layout (renders a single child), but we are going to use the `VBox`
    layout (`#5`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将创建一个带有表单的窗口（弹出窗口），允许我们创建或编辑用户。由于一些ViewModel概念和限制，我们将添加窗口为此类的项。因此，我们不会使用Fit
    Layout（渲染单个子项），而是将使用`VBox`布局（`#5`）。
- en: The `VBox` layout aligns the child items vertically. It divides the available
    vertical space between the child items using the `flex` configuration (`#7`).
    In this example, the window will be displayed as a popup, so the Grid will continue
    being the only child component.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`VBox`布局垂直对齐子项。它使用`flex`配置（`#7`）在子项之间划分可用的垂直空间。在这个例子中，窗口将显示为弹出窗口，因此网格将继续作为唯一的子组件。'
- en: 'When using the `VBox` layout, we can also define the alignment of the items.
    We are going to use `align: ''stretch''`. According to Ext JS documentation, the
    possible options are the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用`VBox`布局时，我们还可以定义项目的对齐方式。我们将使用`align: ''stretch''`。根据Ext JS文档，可能的选项如下：'
- en: '`begin`: Child items are aligned vertically at the top of the container'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin`：子项在容器的顶部垂直对齐'
- en: '`middle`: Child items are vertically centered in the container'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`middle`：子项在容器中垂直居中'
- en: '`end`: Child items are aligned vertically at the bottom of the container'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：子项在容器的底部垂直对齐'
- en: '`stretch`: Child items are stretched vertically to fill the height of the container'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretch`：子项垂直拉伸以填充容器的宽度'
- en: '`stretchmax`: Child items are stretched vertically to the height of the largest
    item'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretchmax`：子项垂直拉伸到最大项的高度'
- en: To add a border around the screen, we are going to set `frame:true` (`#4`).
    We are also specifying a `controller` (`#2`) and a `ViewModel` (`#3`) for this
    `View` that we are going to create later in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕周围添加边框，我们将设置`frame:true`（`#4`）。我们还指定了`controller`（`#2`）和`ViewModel`（`#3`）来为我们将在此章后面创建的`View`。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is also the `border` configuration that we can set for any panel subclass.
    The `border` configuration when specified as `false` (default value) renders the
    panel with zero width borders. The `frame` configuration when specified as `true`
    applies a frame to the panel.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以为任何面板子类设置的`border`配置之外，还有`border`配置，当指定为`false`（默认值）时，将渲染具有零宽度边框的面板。当`frame`配置指定为`true`时，将面板应用框架。
- en: Working with docked items
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 与Docked Items一起工作
- en: 'The next step is to add the toolbar with the **Add**, **Edit**, and **Delete**
    buttons, so we are going to `dock` this toolbar on the `top`, and we are going
    to declare it inside the `dockedItems` declaration of the `Packt.view.security.User`
    class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加带有 **添加**、**编辑** 和 **删除** 按钮的工具栏，因此我们将把这个工具栏 `停靠` 在 `顶部`，并在 `Packt.view.security.User`
    类的 `dockedItems` 声明中声明它：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inside the `dockedItems` configuration, we can add a component or a collection
    of components to be added as docked items to the panel or any of its subclasses.
    The docked items can be docked to either the `top`, `right`, `left`, or `bottom`
    of a panel. We can have as many as needed, and it is usually used to declare toolbar
    inside a panel (or any of its subclasses).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dockedItems` 配置中，我们可以添加一个组件或组件集合，将其作为停靠项添加到面板或其任何子类。停靠项可以停靠到面板的 `顶部`、`右侧`、`左侧`
    或 `底部`。我们可以根据需要添加任意多个，通常用于在面板（或其任何子类）内声明工具栏。
- en: In this example, we are adding a toolbar at the `top` (`#1`) of the panel. The
    toolbar has three buttons. For each button, we are going to configure an icon
    with the help of a `glyph` (`#2`) and also the event listener we are going to
    create inside the ViewController (`#3`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在面板的 `顶部` (`#1`) 添加了一个工具栏。工具栏有三个按钮。对于每个按钮，我们将使用 `glyph` (`#2`) 配置一个图标，并配置我们将在
    ViewController 中创建的事件监听器 (`#3`)。
- en: If we take another look at line `#2`, we can see that we have not implemented
    the `Packt.util.Glyphs` class yet. Let's work on it before we dive into the ViewModel
    and ViewController code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看第 `#2` 行，我们可以看到我们还没有实现 `Packt.util.Glyphs` 类。在我们深入研究 ViewModel 和 ViewController
    代码之前，让我们先着手处理它。
- en: Working with singletons – Ext JS class system
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与单例一起工作——Ext JS 类系统
- en: Let's enjoy the opportunity to create a new utility class for our project and
    dive into some class system concepts of Ext JS.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们享受为我们的项目创建一个新的实用类的机会，并深入了解 Ext JS 的类系统概念。
- en: We already know we can use the Font Awesome CSS in the `iconCls` configuration
    of a button (or any other component that supports it), and we also learned we
    can use the `glyph` configuration as an alternative. The con of using `glyph`
    is declaring code as value (`xf067`), and if we decide to read this code in the
    future or another developer decides to maintain it, it is not very helpful; after
    all, what does `'xf067'` mean?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们可以在按钮的 `iconCls` 配置（或任何支持它的其他组件）中使用 Font Awesome CSS，我们也了解到我们可以使用 `glyph`
    配置作为替代。使用 `glyph` 的缺点是将代码作为值声明（`xf067`），如果我们决定将来读取此代码或另一个开发者决定维护它，这并不很有帮助；毕竟，`'xf067'`
    代表什么？
- en: 'We can take advantage of the Ext JS class system—most specifically the `singleton`
    classes—to create a utility class that will take care of this for us. Let''s take
    a look at the code of the `Packt.util.Glyphs` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 Ext JS 的类系统——特别是单例类——来创建一个将为我们处理这些任务的实用类。让我们看看 `Packt.util.Glyphs` 类的代码：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The idea is to declare the glyph code inside configurations of the class (`#2`)
    and use them as a key to retrieve a `glyph` code. `Packt.util.Glyphs.getIcon('add')`
    is easier to understand than `'xf067'`. We can reuse it throughout the application,
    and if we want to change the code for the **Add** button, we can change the `Glyphs`
    class, and the code is changed for the entire application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是在类的配置（#2）中声明 glyph 代码，并使用它们作为键来检索 `glyph` 代码。`Packt.util.Glyphs.getIcon('add')`
    比 `'xf067'` 更容易理解。我们可以在整个应用程序中重用它，如果我们想更改 **添加** 按钮的代码，我们可以更改 `Glyphs` 类，整个应用程序的代码都会更改。
- en: Let's understand the previous code. We started declaring a class, but in line
    `#1`, we have `singleton:true`. This means the class will be instantiated as a
    singleton, which means only one instance of this class can be created.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解之前的代码。我们开始声明一个类，但在第 `#1` 行，我们有 `singleton:true`。这意味着这个类将以单例的形式实例化，这意味着只能创建这个类的一个实例。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about singletons, please visit [http://en.wikipedia.org/wiki/Singleton_pattern](http://en.wikipedia.org/wiki/Singleton_pattern).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于单例的信息，请访问 [http://en.wikipedia.org/wiki/Singleton_pattern](http://en.wikipedia.org/wiki/Singleton_pattern)。
- en: Next, we have the `config` of the class (`#2`). Inside `config`, we can declare
    the attributes of the class. For each attribute, Ext JS is going to generate a
    getter method and a setter method. For example, the `webFont` attribute can be
    retrieved as `this.getWebFont()` as showed in line `#5`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有类的 `config`（#2）。在 `config` 中，我们可以声明类的属性。对于每个属性，Ext JS 将生成一个 getter 方法和一个
    setter 方法。例如，`webFont` 属性可以通过 `this.getWebFont()` 获取，如第 `#5` 行所示。
- en: The method `getGlyph` (`#4`) will be the responsible for returning a string
    with the `glyph` code + `'@'` + name of the font. If the `glyphFontFamily` is
    set, we do not need to specify the font.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`getGlyph`（`#4`）将负责返回一个包含`glyph`代码 + `'@'` + 字体名称的字符串。如果设置了`glyphFontFamily`，我们就不需要指定字体。
- en: In line `#3`, we have `constructor`. A class constructor is the class method
    that gets invoked immediately when a new instance of that class is created. Inside
    the constructor, we call the `initConfig` method. Calling `initConfig` inside
    the constructor initializes the configuration for the class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在行`#3`中，我们有`constructor`。类构造函数是在创建该类的新实例时立即调用的类方法。在构造函数内部，我们调用`initConfig`方法。在构造函数中调用`initConfig`初始化类的配置。
- en: This class can be modified if we need to work with different font icons.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要使用不同的字体图标，这个类可以被修改。
- en: 'We cannot forget to add the `requires` in the classes where we are going to
    use this class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忘记在将要使用此类的类中添加`requires`：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Panel versus Container versus Component
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 面板与容器与组件
- en: Before we continue, let's take a look back on what we have learned so far. We
    have created a few views. In some of them we used the component class, in others
    we used container, and in others, still we used panel. Can you tell the difference
    between them? When do you use component, container, or panel?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们回顾一下我们已经学到的内容。我们创建了一些视图。在一些视图中我们使用了组件类，在另一些视图中我们使用了容器，在其他视图中，我们使用了面板。你能说出它们之间的区别吗？什么时候使用组件、容器或面板？
- en: The component is the base class for all Ext JS components (widgets). It has
    built-in support for basic hide/show, enable/disable, and size control behavior.
    Visually speaking, there is no style. We can set HTML content and set styles using
    one or more `'cls'` configurations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是所有Ext JS组件（小部件）的基类。它具有内置的基本隐藏/显示、启用/禁用和大小控制行为支持。从视觉上讲，没有样式。我们可以设置HTML内容并使用一个或多个`'cls'`配置来设置样式。
- en: The container is the base class that can contain other components (`items` configuration).
    It is also the base class that uses the layouts we are covering in this book (border,
    fit, VBox, anchor, accordion, and so on).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是能够包含其他组件（`items`配置）的基类。它也是使用我们在本书中介绍布局的基类（边框、fit、VBox、anchor、accordion等）。
- en: The panel class is a container with more capabilities. The panel has a header
    that we can set a title and add tools (useful buttons, such as collapse and expand,
    among others) to and it also support docked items (toolbars).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 面板类是一个具有更多功能的容器。面板有一个标题，我们可以设置标题并添加工具（如折叠和展开等有用的按钮）到其中，它还支持停靠项（工具栏）。
- en: So, whenever you want to create a new Ext JS widget, you need to ask yourself,
    "What do I need to have in this widget?". If it is HTML content, we use a component.
    If we need to have items, or if we need a container to organize the layout of
    the children items, we can use a container. If we need to set a `title` or have
    a toolbar inside it, then we use a panel. Because the panel class has more capabilities,
    it is also a heavier component.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当你想要创建一个新的Ext JS小部件时，你需要问自己，“我需要在这个小部件中有什么？”。如果是HTML内容，我们使用一个组件。如果我们需要项目或需要一个容器来组织子项的布局，我们可以使用一个容器。如果我们需要设置`title`或在其内部有工具栏，那么我们使用面板。因为面板类具有更多功能，它也是一个更重的组件。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using the right widget can also help to boost the application performance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的组件也可以帮助提高应用程序的性能。
- en: In this example, we could `move` the toolbar inside the `UserGrid` class. To
    organize the layout, we could transform the `User` class in a container. If we
    only wanted to display the `UserGrid` class, we would not need the `User` class
    at all. This could avoid a bad practice called over-nesting. Over-nesting is using
    an additional container that does not do anything besides containing another component.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以将工具栏移动到`UserGrid`类内部。为了组织布局，我们可以将`User`类转换为一个容器。如果我们只想显示`UserGrid`类，我们根本不需要`User`类。这可以避免一种称为过度嵌套的坏习惯。过度嵌套是指使用一个额外的容器，它除了包含另一个组件之外不做任何事情。
- en: Declaring the User ViewModel
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明用户视图模型
- en: As we use the MVVM architecture, we declare the Model, and then we declare the
    View. The next step would be declaring the ViewModel. To do so, we are going to
    create the class `Packt.view.security.UserModel`, which is the ViewModel for the
    `Packt.view.security.User` class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用MVVM架构，我们声明模型，然后声明视图。下一步将是声明视图模型。为此，我们将创建类`Packt.view.security.UserModel`，它是`Packt.view.security.User`类的视图模型。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the naming convention we are using. The View name is `User`, so the ViewModel
    will be the name of the View + '`Model`'.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的命名约定。视图的名称是 `User`，因此 ViewModel 的名称将是视图名称 + '`Model`'。
- en: 'Let''s take a look at the `ViewModel` class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `ViewModel` 类：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You learned that we can set the predefined data in the `ViewModel` class in
    [Chapter 3](ch03.html "Chapter 3. The Login Page"), *The Login Page*. Now we are
    configuring ViewModel to load data from a `store` (`#1`) that we are declaring
    and creating (`#2`) at the same time. The Store `users` (this would be the Store
    ID) is a collection of the Model User, and we are also asking the Store to load
    automatically (`#3`) (we do not need to call the method load manually).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到，我们可以在 [第 3 章](ch03.html "第 3 章。登录页面") 的 “登录页面” 中，将预定义的数据设置在 `ViewModel`
    类中。现在我们正在配置 ViewModel 以从我们同时声明和创建的 `store` (`#1`) 加载数据。`users` Store（这将作为 Store
    ID）是用户模型集合，我们还要求 Store 自动加载（`#3`）（我们不需要手动调用 load 方法）。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As the ViewModel will be created when the View is created, the Store will be
    loaded when the View is created as well. It is a different approach than declaring
    the Store as a standalone Store with `autoLoad true`—in this case, the Store will
    be created when the application is loaded and will retrieve the information from
    the server as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ViewModel 将在创建视图时创建，因此 Store 也将与视图一起加载。这与将 Store 声明为具有 `autoLoad true` 的独立
    Store 的方法不同——在这种情况下，Store 将在应用程序加载时创建，并将从服务器检索信息。
- en: Instead of creating the Store inside the ViewModel, we could create the file
    representing the Store inside the store package and make a reference here. This
    Store also does not have a proxy since we declared it inside the Model (specifically
    inside the schema for reuse purposes).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 store 包内创建表示 Store 的文件，并在其中创建引用，而不是在 ViewModel 内创建 Store。这个 Store 也没有代理，因为我们是在模型内部（特别是
    schema 内部，为了重用目的）声明的。
- en: Working with ViewModel data binding
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ViewModel 数据绑定进行工作
- en: Let's go back to the `UsersGrid` class. We have not declared a store, which
    is required. We will do it using data binding and referencing the user's Store
    created in the ViewModel.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `UsersGrid` 类。我们还没有声明一个 Store，这是必需的。我们将使用数据绑定并引用 ViewModel 中创建的用户 Store。
- en: 'Inside the `UsersGrid` class, we are going to add the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UsersGrid` 类内部，我们将添加以下代码：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This means the `UsersGrid` will be bound to the users Store. As the `UsersGrid`
    is a child component of the `User` class that refers the User ViewModel, the `UsersGrid`
    class will also have access to the ViewModel.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `UsersGrid` 将绑定到用户 Store。由于 `UsersGrid` 是 `User` 类的子组件，它引用了用户 ViewModel，因此
    `UsersGrid` 类也将能够访问 ViewModel。
- en: 'Next, we will go back to the `User` view class to add another data binding.
    We will add the following code to the **Edit** and **Delete** buttons:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回到 `User` 视图类以添加另一个数据绑定。我们将向 **编辑** 和 **删除** 按钮添加以下代码：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We want the **Edit** and **Delete** buttons to be enabled only when the user
    selects a row from the Grid. If no row is selected, there is no point in clicking
    on the **Edit** or **Delete** buttons. So we are going to enable or disable the
    button according to this constraint. It is bound with the `usersGrid` (`reference`
    of the `UsersGrid` class) and the attribute selection of the Grid.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 **编辑** 和 **删除** 按钮仅在用户从网格中选择一行时启用。如果没有选择行，点击 **编辑** 或 **删除** 按钮就没有意义。因此，我们将根据这个约束启用或禁用按钮。它与
    `usersGrid` (`UsersGrid` 类的引用) 和网格的属性选择绑定。
- en: 'We also cannot forget to add the ViewModel to the `requires` from the `User`
    class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不能忘记将 ViewModel 添加到 `User` 类的 `requires` 中：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our code is complete so far. Time to listen to some events!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止的代码已经完成了。现在是时候监听一些事件了！
- en: Creating the User ViewController
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户 ViewController
- en: The next step is creating the ViewController for the `User` class, so we are
    going to create the `Packt.view.security.UserController` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建 `User` 类的 ViewController，因此我们将创建 `Packt.view.security.UserController`
    类。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the naming convention we are using. The View name is `User`, so the ViewController
    will be the name of the View + '`Controller`'.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的命名约定。视图的名称是 `User`，因此 ViewController 的名称将是视图名称 + '`Controller`'。
- en: 'Let''s add the following code to the ViewController class. It contains the
    method signature of all events and internal methods we are going to create:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下代码添加到 ViewController 类中。它包含了我们将要创建的所有事件和内部方法的签名：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Before we dive into each method, go back to the `User` View, and add the ViewController
    to the `requires` declaration as well so that we can run and test what we coded
    so far:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究每个方法之前，回到`User`视图，并将ViewController添加到`requires`声明中，以便我们可以运行和测试到目前为止所编写的代码：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To be able to execute the code, we also need to execute `UPDATE` on the database:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够执行代码，我们还需要在数据库上执行`UPDATE`操作：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will update the `className` column from `menu table` to match the `xtype`
    configuration we created for the `User` class, which is the View we want to be
    opened when a user clicks on the **Users** option from the menu.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新`className`列从`menu table`到与为`User`类创建的`xtype`配置相匹配，这是我们希望在用户从菜单中选择**用户**选项时打开的视图。
- en: 'Reloading the project, we will be able to see the list of all users from the
    application:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载项目后，我们将能够看到应用程序中所有用户的列表：
- en: '![Creating the User ViewController](img/0457OT_06_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![创建用户视图控制器](img/0457OT_06_03.jpg)'
- en: Adding and editing a new user
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和编辑新用户
- en: Now that we are capable of listing all the users of the application, we can
    implement the **Add** and **Edit** buttons capability. But before we start adding
    new event listeners to the controller, we need to create the new view that we
    are going to display to the user to edit or add a new user.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够列出应用程序的所有用户，我们可以实现**添加**和**编辑**按钮的功能。但在我们开始向控制器添加新的事件监听器之前，我们需要创建一个新视图，我们将向用户展示以编辑或添加新用户。
- en: Creating the Edit View – form within a window
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建编辑视图 – 窗口内的表单
- en: 'This new view is going to be a window since we want to display it as a popup,
    and inside this window, we will have a form with the user''s information, and
    then, we will have a toolbar at the bottom with two buttons: **Cancel** and **Save**.
    It is very similar to the Login window that we developed in [Chapter 3](ch03.html
    "Chapter 3. The Login Page"), *The Login Page*, but we will add new capabilities
    to this new form, such as file upload and also a preview file using HTML5 features.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的视图将是一个窗口，因为我们想将其显示为弹出窗口，在这个窗口内，我们将有一个包含用户信息的表单，然后，在底部将有一个包含两个按钮的工具栏：**取消**和**保存**。这与我们在[第3章](ch03.html
    "第3章。登录页面")，*登录页面*中开发的登录窗口非常相似，但我们将为此新表单添加新的功能，例如文件上传以及使用HTML5特性预览文件。
- en: 'The view we are going to create looks like the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的视图看起来如下截图所示：
- en: '![Creating the Edit View – form within a window](img/0457OT_06_04.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![创建编辑视图 – 窗口内的表单](img/0457OT_06_04.jpg)'
- en: 'So, let''s get started and create a new class named `Packt.view.security.UserForm`
    that is going to `extend` from the window class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始创建一个名为`Packt.view.security.UserForm`的新类，它将`extend`从窗口类继承：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are three very important things that we need to notice in this class:
    the first one is that we are not using the `autoShow` attribute. And the purpose
    is that we can create the window, and then we display it calling the method `show()`
    manually.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，有三件非常重要的事情需要我们注意：第一点是，我们并没有使用`autoShow`属性。其目的是我们可以创建窗口，然后通过手动调用`show()`方法来显示它。
- en: 'The second one is the data binding in line `#1`. We want to use data binding
    to automatically set the `title` of the window (Add new user or Edit: name of
    user). This is one of the advantages of the MVVM architecture.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是行`#1`中的数据绑定。我们希望使用数据绑定来自动设置窗口的`title`（添加新用户或编辑：用户名称）。这是MVVM架构的优点之一。
- en: 'The third thing is the `layout` that we are using on the form. It is not the
    default `layout` used by the form component (which is the Anchor layout). We are
    going to use the `hbox` layout (`#3`) because we want to organize the form''s
    items horizontally. And we want the items to occupy all the available vertical
    space, so we will use the `align: ''stretch''`—we do not want to set `height`
    for each form `items`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '第三点是我们在表单上使用的`layout`。它不是表单组件默认使用的`layout`（即锚布局）。我们将使用`hbox`布局（`#3`），因为我们想水平组织表单的项目。并且我们希望项目占据所有可用的垂直空间，所以我们将使用`align:
    ''stretch''`——我们不想为每个表单`items`设置`height`。'
- en: And at last, we learned in [Chapter 3](ch03.html "Chapter 3. The Login Page"),
    *The Login Page*, how to validate the form using form validations. In this chapter,
    we will validate the form using `modelvalidations` (`#2`).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在[第3章](ch03.html "第3章。登录页面")，*登录页面*中学习了如何使用表单验证来验证表单。在本章中，我们将使用`modelvalidations`（`#2`）来验证表单。
- en: 'Let''s add the first item to our form. If we take a look at the window screenshot
    at the beginning of this topic, we will notice that we are going to use two fieldsets
    to organize the form `items`. So the first one will be a `fieldset` to organize
    all the "`User Information`", as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将第一个项目添加到我们的表单中。如果我们查看本主题开头窗口的截图，我们会注意到我们将使用两个`fieldset`来组织表单`items`。因此，第一个将是一个`fieldset`来组织所有的"`用户信息`"，如下所示：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As the form is using the `hbox` layout, we need to specify how much space this
    component will occupy (`#4`). When working with the HBox or VBox layouts, the
    space occupied by the child component is calculated based on the proportional
    space configured. If we have five items with `flex: 1` each, then the total sum
    will be five; each item will occupy one-fifth of the available space. Or, we can
    also set `width` (HBox) or `height` (VBox) for some items, and the remaining space
    will be divided among the items with the `flex` configuration. In this example,
    we will use `flex: 1` for this `fieldset`, and for the next one we are going declare,
    we will use a fix width, so this `fieldset` will occupy all the remaining available
    space.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '由于表单使用的是`hbox`布局，我们需要指定这个组件将占用多少空间（`#4`）。当使用HBox或VBox布局时，子组件占用的空间是根据配置的相对空间计算的。如果我们有五个项目，每个项目的`flex`属性为`1`，那么总和将是五；每个项目将占用可用空间的一分之一。或者，我们也可以为某些项目设置`width`（HBox）或`height`（VBox），剩余的空间将分配给具有`flex`配置的项目。在这个例子中，我们将为这个`fieldset`使用`flex:
    1`，而对于我们将要声明的下一个，我们将使用固定宽度，因此这个`fieldset`将占用所有剩余的可用空间。'
- en: The `fieldset` will also use the `anchor` layout (`#5`), which allows you to
    anchor the items relative to the container's dimensions. The `anchor` layout is
    the default layout for forms, but as we are using a fieldset, we need to specify
    the layout as well. For each item, we can specify the `anchor` configuration (`#7`).
    As we want the child items occupying all the available width within the fieldset,
    we set the `anchor` configuration to `100%`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`fieldset`还将使用`anchor`布局（`#5`），这允许您根据容器的尺寸锚定项目。`anchor`布局是表单的默认布局，但因为我们使用的是`fieldset`，所以我们也需要指定布局。对于每个项目，我们可以指定`anchor`配置（`#7`）。由于我们希望子项目占用`fieldset`内的所有可用宽度，我们将`anchor`配置设置为`100%`。'
- en: 'For all required items, we will add a red asterisk (`#6`). Instead of adding
    the HTML for each form we use, we can add this value to our `Util` class and reuse
    it among other forms as well. Inside the `Packt.Util.util` class, add the following
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有必填项，我们将添加一个红色星号（`#6`）。我们不必为每个表单添加HTML，我们可以将此值添加到我们的`Util`类中，并在其他表单中重用它。在`Packt.Util.util`类内部，添加以下代码：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are also telling the fieldset that the default `xtype` of the items will
    be `textfield`. If any of the declared fields does not need these default configurations,
    we will override them with other values. So, let''s declare the fields that will
    be part of the `items` configuration of the "`User Information`" fieldset:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还告诉`fieldset`，项目的默认`xtype`将是`textfield`。如果声明的任何字段不需要这些默认配置，我们将用其他值覆盖它们。所以，让我们声明将成为"`用户信息`"字段集`items`配置部分的字段：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `id` field will be `hidden` because we do not want the user to see it (we
    will use it only internally), and the `userName`, `name`, and `email` are simple
    textfields. Note that for each field, we declared a `name` (`#8`) and the `bind`
    (`#9`) configuration. As we are going to use a file upload capability, we will
    need to send the form information using the Ajax submit, and that is why we need
    to set a `name` configuration for each field. To avoid having to set the values
    of the form manually, we are going to use data binding from the ViewModel. We
    will set a variable named `currentUser` in the ViewModel that will refer to the
    current selected row of the `UsersGrid`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`字段将被隐藏，因为我们不希望用户看到它（我们只会在内部使用它），而`userName`、`name`和`email`是简单的文本字段。请注意，对于每个字段，我们声明了一个`name`（`#8`）和`bind`（`#9`）配置。由于我们打算使用文件上传功能，我们需要使用Ajax提交表单信息，这就是为什么我们需要为每个字段设置`name`配置。为了避免手动设置表单的值，我们将使用从ViewModel的数据绑定。我们将在ViewModel中设置一个名为`currentUser`的变量，它将引用`UsersGrid`中当前选中的行。'
- en: Then, we have a combobox. When working with comboboxes, we need to set a Store
    to feed the information to it. In this case, we will bind (`#16`), the `store`
    of this combobox, with Store `groups` from the ViewModel. We will create the Store
    in a minute. The Store can represent a Model that has different fields. We can
    specify which field from the Model will be used as an internal value (`#11`) and
    which field will be displayed to the user (`#10`).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个组合框。当与组合框一起工作时，我们需要设置一个存储来为其提供信息。在这种情况下，我们将绑定（`#16`），这个组合框的`store`与ViewModel中的`groups`存储。我们将在一分钟内创建存储。存储可以表示具有不同字段的模型。我们可以指定模型中哪个字段将用作内部值（`#11`）以及哪个字段将显示给用户（`#10`）。
- en: We can also specify other options such as forcing the user to select a value
    from the combobox (`#13`) and not allowing the user to write anything on it (`#14`)—as
    writing is autocomplete. As we will have the Store already loaded for this combobox,
    we can set the query mode to be `local` (`#15`). The default behavior is that
    whenever the user clicks on the combobox trigger, the Store is loaded.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定其他选项，例如强制用户从组合框（`#13`）中选择一个值，并阻止用户在其上写入任何内容（`#14`）——因为写入是自动完成的。由于我们已为这个组合框加载了存储，我们可以将查询模式设置为`local`（`#15`）。默认行为是，每当用户点击组合框触发器时，都会加载存储。
- en: Note that the binding for this field is more complex than for the other ones.
    We have three values bound; the store that we already mentioned (`#16`); the value,
    which refers to the `groups_id` foreign key (`#15`) of the `User` Model and the
    `selection` (`#17`), which will refer to the `group` object from the `User` Model
    (referring to the `Group` selected).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个字段的绑定比其他字段更复杂。我们绑定了三个值；我们之前提到的存储（`#16`）；一个值，它指的是`User`模型的外键`groups_id`（`#15`）和`selection`（`#17`），它将引用`User`模型中的`group`对象（引用选中的`Group`）。
- en: Then we have the file upload field. This field will not be mandatory, so we
    do not want it to display that red asterisk (`#18`) by overriding the `defaults`
    configuration. We also want to use a preview capability, so we are also going
    to add a `listener` declaration to this field (`#19`). Whenever the user selects
    a new picture, we will display it in the fieldset we are going to declare next
    (we are going to talk about the preview capability later in this chapter).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有文件上传字段。这个字段不是必填项，所以我们不希望它通过覆盖`defaults`配置来显示那个红色的星号（`#18`）。我们还想使用预览功能，因此我们还将为此字段添加一个`listener`声明（`#19`）。每当用户选择一个新的图片时，我们将在我们即将声明的字段集中显示它（我们将在本章后面讨论预览功能）。
- en: 'This is the first `fieldset` that will be displayed on the left-hand side of
    the form. Next, we need to declare the other `fieldset` that is going to wrap
    the `Photo` and will be displayed on the right-hand side of the form:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将在表单左侧显示的第一个`fieldset`。接下来，我们需要声明另一个`fieldset`，它将包裹`Photo`并在表单右侧显示：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this `fieldset`, we will declare a fixed `width` (`#19`). As the form uses
    the HBox layout, when a component has a fixed `width`, the layout will respect
    and apply the specified `width`. Then, the first `fieldset`, which has the `flex`
    configuration, will occupy all the remaining horizontal space.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`fieldset`中，我们将声明一个固定的`width`（`#19`）。由于表单使用HBox布局，当一个组件具有固定`width`时，布局将尊重并应用指定的`width`。然后，具有`flex`配置的第一个`fieldset`将占据所有剩余的水平空间。
- en: Inside the picture fieldset, we will use an `Ext.Image Component`. The `Ext.Image`
    (`#20`) class helps us to create and render images. It also creates an `<image>`
    tag on the DOM with `src` (`#21`) specified. The `src` attribute is also bound
    to the picture field of the `User` Model. We also declared a reference to work
    with the preview capability later (`#20`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片字段集中，我们将使用`Ext.Image Component`。`Ext.Image`（`#20`）类帮助我们创建和渲染图像。它还在DOM中创建一个带有`src`（`#21`）指定的`<image>`标签。`src`属性也绑定到`User`模型的图片字段。我们还声明了一个引用，以便稍后使用预览功能（`#20`）。
- en: When we load an existing `User` and try to edit the form, we will display the
    user's image on this component (if any). Also, if the user uploads a new image,
    the preview will also be rendered in this component.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载现有的`User`并尝试编辑表单时，我们将在这个组件上显示用户的图像（如果有）。此外，如果用户上传了新的图像，预览也将在这个组件中渲染。
- en: 'And now, the last step is to declare the bottom toolbar with the **Save** and
    **Cancel** buttons, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一步是声明带有**保存**和**取消**按钮的底部工具栏，如下所示：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we want to align the buttons on the right-hand side of the toolbar, we will
    use the `hbox` layout as well and organize (`#22`) the buttons to the right toolbar.
    The Edit/Add window is now ready. However, there are a few other details that
    we still need to take care of before implementing the Add and Edit listeners on
    the Controller.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要将按钮对齐在工具栏的右侧，我们将使用`hbox`布局并组织（`#22`）按钮到右侧工具栏。编辑/添加窗口现在已准备好。然而，在实现控制器上的添加和编辑监听器之前，我们还需要注意一些其他细节。
- en: Creating the Group Model
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建组模型
- en: 'On the `Group` combobox, we declared a `groups` Store used to load all the
    `Groups` from the database. Now, we need to implement this missing Store, and
    the first step to do so is create the Model that is going to represent a Group
    record from the `group` table. So we are going to create a new Model named `Packt.model.security.Group`,
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Group`组合框中，我们声明了一个`groups`存储，用于从数据库中加载所有`Groups`。现在，我们需要实现这个缺失的存储，首先一步是创建一个将代表`group`表中组记录的模型。因此，我们将创建一个名为`Packt.model.security.Group`的新模型，如下所示：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As the `group` table is very simple, it only contains two columns, `id` and
    `name`; our `Group` Model is also simple with only these two fields. As the `Group`
    Model is extending from the `Base` Model we created in the beginning of this chapter,
    the `id` column will come from the `Base`, `schema`, and `proxy` configurations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`group`表非常简单，它只包含两个列，`id`和`name`；我们的`Group`模型也很简单，只包含这两个字段。由于`Group`模型是从本章开头创建的`Base`模型扩展的，`id`列将来自`Base`、`schema`和`proxy`配置。
- en: The Groups Store
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组存储
- en: As we already created the `Group` Model, now we need to create the `groups`
    Store.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了`Group`模型，现在我们需要创建`groups`存储。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Always remember the naming convention: the Model name is the singular name
    of the entity you want to represent and the Store is the plural of the name of
    the Model/entity.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住命名约定：模型名称是你想要表示的实体的单数名称，而存储是模型/实体名称的复数形式。
- en: 'So we will create a new `Store` inside the `UserModel` class, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在`UserModel`类内部创建一个新的`Store`，如下所示：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Following the same pattern as the other stores, the `groups` information will
    be sent by the server within a data attribute in the JSON as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 按照其他存储相同的模式，`groups`信息将通过服务器在JSON中的数据属性发送，如下所示：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now all the views, models, and stores needed for our user management module
    are created. We can focus on the ViewController to handle all the events we are
    interested in listening to and implementing all the magic!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有用于我们用户管理模块的视图、模型和存储都已创建。我们可以专注于ViewController来处理我们感兴趣的所有事件，并实现所有魔法！
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For all the server-side code of this chapter, and the group management code,
    please download the source code bundle of this book or go to [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的所有服务器端代码以及组管理代码，请下载本书的源代码包或访问[https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs)。
- en: Controller – listening to the Add button
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器 – 监听添加按钮
- en: The first event that we will implement for the Edit or Add Window is the Add
    event. When the user clicks on the **Add** button, we want to display the **Edit**
    user window (the `Packt.view.security.UserForm` class).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的第一事件是编辑或添加窗口的添加事件。当用户点击**添加**按钮时，我们希望显示**编辑**用户窗口（`Packt.view.security.UserForm`类）。
- en: 'The button **Add** already has a listener. So all we need to do is add the
    code in the ViewController:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮**添加**已经有一个监听器。所以我们只需要在ViewController中添加代码：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the user clicks on the **Add** button, we want to open a blank popup so
    that user can enter the new record information and save it. If the user clicks
    on the **Edit** button, we want to open the same popup with the data from the
    selected row from the Grid. So, for the **Add** button, we will open the popup
    passing null (no row selected). The `createDialog` method is listed in the following
    code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击**添加**按钮，我们希望打开一个空白弹出窗口，以便用户可以输入新记录信息并保存它。如果用户点击**编辑**按钮，我们希望打开包含从网格中选择的行数据的相同弹出窗口。因此，对于**添加**按钮，我们将传递null（没有选择的行）来打开弹出窗口。`createDialog`方法在以下代码中列出：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We start getting a reference (`#1`) to the `User` View class reference, since
    the ModelView was declared inside it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始引用（`#1`）`User`视图类引用，因为`ModelView`是在其中声明的。
- en: Next, we are going to create the `UserForm` window (`#2`) and assign it to a
    variable dialog that belongs to the ViewModel scope (the method add returns the
    instance of the component created). We are also adding the `UserForm` window to
    the `User` View (you might remember that we used the VBox layout instead of the
    Fit layout; this is the reason). When adding the `UserForm` window as an item
    of the `User` View, this item will also have access to the ViewModel associated
    to its parent. In this case, we want to add more details to the Window's ViewModel
    (as a child ViewModel—(`#3`)). We are going to add a predefined field named `title`
    (that we used to set the window's title—(`#4`)). And we are also going to create
    a `link` (`#5`). Links provide a way to assign a simple name to a more complex
    bind. The primary use for this is to assign names to records in the data model.
    If there is an existing `record` (from `Edit`—(`#6`)), it uses a copy of it, and
    if not, it creates a new phantom record (`#7`).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `UserForm` 窗口（`#2`）并将其分配给属于 ViewModel 范围的变量 `dialog`（方法 `add` 返回创建的组件实例）。我们还将
    `UserForm` 窗口添加到 `User` 视图（你可能记得我们使用了 VBox 布局而不是 Fit 布局；这就是原因）。当将 `UserForm` 窗口作为
    `User` 视图的项目添加时，此项目也将能够访问其父级关联的 ViewModel。在这种情况下，我们想要向窗口的 ViewModel 添加更多详细信息（作为一个子
    ViewModel —(`#3`))。我们将添加一个名为 `title` 的预定义字段（我们曾用它来设置窗口的标题 —(`#4`))。我们还将创建一个 `链接`
    (`#5`)。链接提供了一种将简单名称分配给更复杂绑定的方式。这种用法的主要目的是为数据模型中的记录分配名称。如果存在一个现有的 `record`（来自 `Edit`
    —(`#6`))，它将使用它的副本，如果没有，它将创建一个新的幻影记录（`#7`）。
- en: Controller – listening to the Edit button
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器 – 监听编辑按钮
- en: 'If we want to edit an existing user, the **Edit** button will fire the click
    event, and the ViewController will listen to it through the following method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要编辑现有用户，**编辑**按钮将触发点击事件，ViewController 将通过以下方法监听它：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we are going to get the selected `records` from the Grid (`#1`). If a
    record (`#2`) was selected, we are going to create the window passing the record
    (`#3`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从网格中获取所选的 `records` (`#1`)。如果选择了记录（`#2`)，我们将创建一个窗口并传递记录（`#3`)。
- en: 'The method `getRecordSelected` is listed as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRecordSelected` 方法如下列出：'
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are going to get a reference of the `UsersGrid` (`#4`), and by accessing
    its `getSelection` method, we can get the rows selected (`#5`).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获取 `UsersGrid` 的引用（`#4`），通过访问其 `getSelection` 方法，我们可以获取所选的行（`#5`)。
- en: 'The `getSelection` method returns an array of the selected records. That is
    why we are using `records[0]` to access the selected row. By default, a Grid allows
    you to select only one row at a time. This can be changed by setting the following
    configuration in the Grid:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSelection` 方法返回所选记录的数组。这就是为什么我们使用 `records[0]` 来访问所选行。默认情况下，一个网格允许你一次只选择一行。这可以通过在网格中设置以下配置来更改：'
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By default, a Grid allows you to select only one row at a time; this can be
    changed using the `selType: ''checkboxmodel''` (`Ext.selection.CheckboxModel`).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，一个网格允许你一次只选择一行；这可以通过使用 `selType: ''checkboxmodel''` (`Ext.selection.CheckboxModel`)
    来更改。'
- en: The validation in `#2` is an extra step as we are binding the **Edit** button
    directly to the `selection` configuration of the Grid, but to be careful and avoid
    exceptions in the code is never too much!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`#2` 中的验证是一个额外的步骤，因为我们直接将 **编辑** 按钮绑定到网格的 `selection` 配置，但为了谨慎并避免代码中的异常，永远都不嫌多！'
- en: Controller – listening to the Cancel button
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器 – 监听取消按钮
- en: 'If the user decides not to save the user information, it is possible to click
    on the **Cancel** button that is going to fire the click event to execute the
    following method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户决定不保存用户信息，可以点击 **取消** 按钮，这将触发点击事件以执行以下方法：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What we want to do is very simple: if the user wants to cancel all the changes
    made to an existing user or wants to cancel the creation of a user, the system
    will `destroy` the window. We can use `Ext.destroy` to destroy it or call the
    method `destroy` as well. At the same time, `me.dialog` will lose the reference
    as well.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的事情非常简单：如果用户想要取消对现有用户所做的所有更改，或者想要取消创建用户，系统将`销毁`窗口。我们可以使用 `Ext.destroy`
    来销毁它，或者也可以调用 `destroy` 方法。同时，`me.dialog` 也会失去引用。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about JavaScript memory leaks, go to [http://javascript.info/tutorial/memory-leaks](http://javascript.info/tutorial/memory-leaks).
    To learn more about the importance of the garbage collector (freeing up memory)
    go to [http://goo.gl/qDdwwt](http://goo.gl/qDdwwt).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 JavaScript 内存泄漏的信息，请访问 [http://javascript.info/tutorial/memory-leaks](http://javascript.info/tutorial/memory-leaks)。要了解更多关于垃圾收集器（释放内存）的重要性，请访问
    [http://goo.gl/qDdwwt](http://goo.gl/qDdwwt)。
- en: Controller – saving a user
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器 – 保存用户
- en: Now that the user is able to open the window to create or edit a `User`, we
    need to implement the **Save** button logic. No matter if the user is creating
    a new user or editing an existing user, we will use the same logic to save the
    user. We will let the server side handle this if it needs to use an `UPDATE` or
    `INSERT` query.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户能够打开窗口来创建或编辑一个 `User`，我们需要实现 **保存** 按钮的逻辑。无论用户是创建新用户还是编辑现有用户，我们都会使用相同的逻辑来保存用户。如果服务器端需要使用
    `UPDATE` 或 `INSERT` 查询，我们将让服务器端来处理。
- en: 'The ViewController will execute the following method to save the information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ViewController 将执行以下方法来保存信息：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first step is to get the form reference (`#1`). Then, we will verify that
    the form is valid ((`#2`) the user filled the form with valid values following
    all the rules of the model validations (`#4`) that we are going to implement),
    after which we will submit the form to the given `url` (`#5`).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是获取表单引用（`#1`）。然后，我们将验证表单是否有效（`#2` 用户按照模型验证规则（`#4`）填写了有效的值，这些规则是我们将要实施的），之后我们将表单提交到指定的
    `url`（`#5`）。
- en: We could use the Store features to create and edit the User (as we will see
    later in this book). However, we are using a different approach, which is the
    form submit method to directly send the values to the server, because we are also
    uploading a document to the server. When uploading a document to the server, it
    is not possible to use the Store capabilities.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Store 功能来创建和编辑用户（正如我们将在本书后面看到的那样）。然而，我们正在使用不同的方法，即表单提交方法直接将值发送到服务器，因为我们还正在上传文档到服务器。在上传文档到服务器时，无法使用
    Store 功能。
- en: Before we list the success and failure callbacks, take a look at the code again
    at the line `var me = this`. Whenever we have more than one reference to this
    or we work with callbacks, we do this assignment.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们列出成功和失败回调之前，再次看看代码中的这一行 `var me = this`。每次我们有一个以上的 `this` 引用或者我们在处理回调时，我们都会进行这个赋值。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are two reasons to use `me` instead of `this` (or you can create other
    variable names according to your preference (`that`, `self`)). The first one is
    when "`this`" is used a lot in a method, using "`me`" can save 16 bits each reference.
    After we do the production build, Sencha Cmd will replace `me` with `a`, `b`,
    or any other letter. The keyword `this` cannot be replaced with `a`, `b`, or any
    other value, therefore it will use four characters instead of only one.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `me` 而不是 `this`（或者你也可以根据你的喜好创建其他变量名，比如 `that` 或 `self`）有两个原因。第一个原因是在一个方法中大量使用
    `this` 时，使用 `me` 可以在每个引用上节省 16 位。在我们完成生产构建后，Sencha Cmd 将会替换 `me` 为 `a`、`b` 或其他任何字母。关键字
    `this` 不能被替换为 `a`、`b` 或其他任何值，因此它将使用四个字符而不是一个字符。
- en: The second reason is that we can keep a reference to `this` inside a scope in
    which `this` refers to something else (like a callback function, for example,
    the form `submit`—if we used `this` inside the `submit`, it would make a reference
    to the `submit` method itself and not the ViewController).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是我们可以保持对 `this` 的引用，在 `this` 指向其他内容的作用域内（比如回调函数，例如，表单的 `submit`——如果我们使用
    `this` 在 `submit` 中，它将引用 `submit` 方法本身而不是 ViewController）。
- en: This way a callback function can refer to a function or variable that was declared
    in the outer function (ViewController in this example). This is called closure.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，回调函数可以引用在外部函数（在这个例子中是 ViewController）中声明的函数或变量。这被称为闭包。
- en: 'You can learn about how to handle file upload in PHP by downloading the source
    code from this book. If you are using another language or for some reason a form
    submit is not working, always inspect the request in the *Developer Tools* of
    the browser you are using to see what is being sent to the server. The following
    screenshot exemplifies what is being sent while creating a new user:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从这本书下载源代码来了解如何在 PHP 中处理文件上传。如果你使用的是其他语言，或者由于某种原因表单提交不起作用，请始终检查你使用的浏览器中的
    *开发者工具*，以查看发送到服务器的信息。以下截图展示了创建新用户时发送的内容：
- en: '![Controller – saving a user](img/0457OT_06_05.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![控制器 – 保存用户](img/0457OT_06_05.jpg)'
- en: 'The next steps now are to implement the `success` and `failure` callbacks.
    Let''s implement the `success` callback first:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现`success`和`failure`回调。让我们首先实现`success`回调：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the server returns success as `true`, we will call the method `onCancel`
    that is responsible for closing and destroying the window (`#7`) that we implemented
    in the previous topic. As we are using a form submit to send the information to
    the server, we need to refresh (`#8`) the Store to get the new information from
    the server. And at last, we will display a toast (introduced in Ext JS 5) with
    a success message (`#9`) as shown by the following image:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器返回`success`为`true`，我们将调用负责关闭和销毁窗口（`#7`）的`onCancel`方法，该窗口是在前一个主题中实现的。由于我们使用表单提交将信息发送到服务器，我们需要刷新（`#8`）Store以从服务器获取新信息。最后，我们将显示一个吐司（在
    Ext JS 5 中引入）并显示成功消息（`#9`），如下面的图像所示：
- en: '![Controller – saving a user](img/0457OT_06_06.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![控制器 – 保存用户](img/0457OT_06_06.jpg)'
- en: 'The refresh method is listed as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新方法如下所示：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Inside the `refresh` method, we get the reference to the `users` Store and call
    its method `load` to get the information from the server again.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`refresh`方法内部，我们获取`users` Store的引用并调用其`load`方法，再次从服务器获取信息。
- en: 'The following is the `showToast` static method from the `Packt.util.Util` class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`Packt.util.Util`类中的`showToast`静态方法：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Ext.Toast` class provides lightweight, auto-dismissing pop-up notifications
    called toasts. We can set its content (`html`), a title, a **close** button, the
    alignment (in our example, it will be displayed at the top), how many seconds
    it will be displayed (4 seconds) and its width, among other options that we can
    check in the Ext JS documentation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.Toast` 类提供了轻量级、自动消失的弹出通知，称为吐司。我们可以设置其内容（`html`）、标题、**关闭**按钮、对齐方式（在我们的示例中，它将在顶部显示）、显示时长（4秒）以及其宽度，以及其他我们可以在
    Ext JS 文档中检查的选项。'
- en: 'Next, let''s implement the `failure` callback:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现`failure`回调：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In [Chapter 3](ch03.html "Chapter 3. The Login Page"), *The Login Page*, we
    also handled a form failure callback. The code we are going to use here is exactly
    the same. As we are starting to repeat code, we can create another static function
    in the `Util` class so that we can reuse it:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。登录页面")，“登录页面”，我们也处理了表单失败回调。我们将使用这里的代码完全相同。由于我们开始重复代码，我们可以在`Util`类中创建另一个静态函数，以便我们可以重用它：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The difference is now that this code is inside the `Packt.util.Util` class,
    we can refer to it to call the `showErrorMsg` method (`#1`).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的区别是，这段代码位于`Packt.util.Util`类中，我们可以引用它来调用`showErrorMsg`方法（`#1`）。
- en: We can also go back to `LoginController` and replace the failure callback code
    with the call of the `handleFormFailure` function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以回到`LoginController`，并用`handleFormFailure`函数的调用替换失败回调代码。
- en: Our save code is now ready.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的保存代码已经准备好了。
- en: Using Model validators
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用模型验证器
- en: As we implemented the save method, let's use the opportunity to complete the
    code to validate the form with Model validators.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现了保存方法后，让我们利用这个机会来完成代码，以使用模型验证器验证表单。
- en: 'We are going to add the following code to the `User` Model:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`User`模型添加以下代码：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can have the following types of Model validators:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有以下类型的模型验证器：
- en: '`presence`: This ensures that the field has a value. Zero counts as a valid
    value, but empty strings do not.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`presence`: 这确保了字段有一个值。零被视为有效值，但空字符串不算。'
- en: '`length`: This ensures that a string is between `min` length and `max` length.
    Both constraints are optional.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`: 这确保字符串在`min`长度和`max`长度之间。这两个约束都是可选的。'
- en: '`format`: This ensures that a string matches a regular expression format.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`: 这确保字符串匹配正则表达式格式。'
- en: '`inclusion`: This ensures that a value is within a specific set of values (for
    example, ensuring gender is either male or female).'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inclusion`: 这确保值在特定的值集中（例如，确保性别是男性或女性）。'
- en: '`exclusion`: This ensures that a value is not one of the specific set of values
    (for example, blacklisting usernames like "admin").'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exclusion`: 这确保值不是特定集合中的任何一个值（例如，将用户名如“admin”列入黑名单）。'
- en: '`email`: This ensures that the value is a valid e-mail.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`: 这确保值是有效的电子邮件。'
- en: '`range`: This ensures that the value is between a `min` and a `max`. Both constraints
    are optional.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`: 这确保值在`min`和`max`之间。这两个约束都是可选的。'
- en: Each validator has a default `message` just in case the validation is not met.
    We can also override it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每个验证器都有一个默认的`message`，以防验证未通过。我们也可以覆盖它。
- en: Previewing a file before uploading
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在上传前预览文件
- en: 'One last thing that we will implement related to the window: the file upload
    preview. This is something that is not that hard to implement, and it will bring
    a sparkle to the application user''s eyes!'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件我们将实现与窗口相关的事情：文件上传预览。这是一件不太难实现的事情，会给应用程序用户带来惊喜！
- en: 'So what we want to do when the user selects a new file using the file upload
    component is read the file using the HTML5 FileReader API. Unfortunately, not
    every browser supports the FileReader API; only the following versions do: Chrome
    6+, Firefox 4+, Safari 6+, Opera 12+, Explorer 10+, iOS Safari 6+, Android 3+,
    and Opera Mobile 12+. But do not worry, we will verify that the browser supports
    it first, and if it does not, we will not use it, which means that the file preview
    will not happen.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当用户使用文件上传组件选择新文件时，我们想要做的是使用 HTML5 FileReader API 读取文件。不幸的是，并非所有浏览器都支持 FileReader
    API；只有以下版本支持：Chrome 6+、Firefox 4+、Safari 6+、Opera 12+、Explorer 10+、iOS Safari
    6+、Android 3+ 和 Opera Mobile 12+。但不用担心，我们首先会验证浏览器是否支持它，如果不支持，我们则不会使用它，这意味着文件预览将不会发生。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about the FileReader API, please read its specification at [http://www.w3.org/TR/file-upload/](http://www.w3.org/TR/file-upload/),
    and to learn more about this and other HTML5 features, go to [http://www.html5rocks.com/](http://www.html5rocks.com/).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 FileReader API 的信息，请阅读其规范[http://www.w3.org/TR/file-upload/](http://www.w3.org/TR/file-upload/)，以及更多关于此和其他
    HTML5 功能的信息，请访问[http://www.html5rocks.com/](http://www.html5rocks.com/)。
- en: 'When the user selects a new file using the Ext JS file upload component, the
    change event is fired, so we need to listen to it in our ViewController. The following
    code exemplifies what was discussed in this paragraph:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用 Ext JS 文件上传组件选择新文件时，会触发一个改变事件，因此我们需要在我们的 ViewController 中监听它。以下代码示例说明了本段讨论的内容：
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So first, we need to get the file (`#1`) object that is stored inside the file
    input element of the Ext JS File field component (also passed as a parameter to
    our method). Then, we will get a reference of the `Ext.Image` component that is
    inside our form so that we can update its `source` to the file preview.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们需要获取存储在 Ext JS 文件字段组件文件输入元素中的文件对象（也作为参数传递给我们的方法）。然后，我们将获取我们表单中 `Ext.Image`
    组件的引用，以便我们可以更新其 `source` 为文件预览。
- en: 'We will also test whether the FileReader API is available on the browser and
    also whether the file that the user chose is an image (`#3`). If positive, we
    will instantiate a `FileReader` method (`#4`); we will add a listener to it (`#4`),
    so when the FileReader is done reading the file, we can set its contents to the
    `Ext.Image` source (`#6`). And of course, to fire the `onload` event, the FileReader
    instance needs to read the contents of the file (`#7`). One very important note:
    we are displaying the contents of the file before we upload to the server. If
    the user saves the changes made to the form, the new user information will be
    sent to the server (including the file upload), and the next time we open the
    window, the picture will be displayed.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将测试浏览器上是否可用 FileReader API，以及用户选择的文件是否为图像（`#3`）。如果为正，我们将实例化一个 `FileReader`
    方法（`#4`）；我们将向它添加一个监听器（`#4`），这样当 FileReader 完成读取文件后，我们可以将其内容设置为 `Ext.Image` 的源（`#6`）。当然，为了触发
    `onload` 事件，FileReader 实例需要读取文件的内容（`#7`）。一个非常重要的注意事项：我们在上传到服务器之前显示文件的内容。如果用户保存对表单所做的更改，新的用户信息将包括文件上传发送到服务器，下次我们打开窗口时，图片将显示出来。
- en: Note
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'How do you get the full path of the file that is being uploaded? For example,
    the Ext JS file upload component displays `C:\fakepath\nameOfTheFile.jpg`, and
    we want to get its real path, such as `C:\Program Files\nameOfTheFile.jpg`. The
    answer is: it is not possible to do it with JavaScript (and Ext JS is a JavaScript
    framework).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何获取正在上传的文件的全路径？例如，Ext JS 文件上传组件显示 `C:\fakepath\nameOfTheFile.jpg`，而我们想要获取其实际路径，例如
    `C:\Program Files\nameOfTheFile.jpg`。答案是：无法使用 JavaScript（以及 Ext JS 是一个 JavaScript
    框架）来实现这一点。
- en: This is not a restriction from Ext JS; if we try it with any other JavaScript
    framework or library, such as jQuery, it is not going to be possible because this
    is a browser security restriction. Imagine if it was possible. Someone could develop
    a malicious JavaScript file and run it while you are navigating on the web and
    get all the information that you have on your computer.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是 Ext JS 的限制；如果我们尝试使用任何其他 JavaScript 框架或库，例如 jQuery，这也不可能实现，因为这是一个浏览器安全限制。想象一下如果这是可能的。有人可以开发一个恶意的
    JavaScript 文件，在你上网导航时运行它，并获取你电脑上的所有信息。
- en: 'Another really nice thing: if the file that the user chose is not an image
    (`#8`), we will display a message saying that only images can be uploaded, and
    we will reset the file upload component. Unfortunately, it is not possible to
    filter the file types on the browse window (the one that opens so we can choose
    a file from the computer), and this is a wayaround, so we can do this validation
    on the Ext JS side and not leave it to the server.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件非常不错的事情是：如果用户选择的文件不是图片（`#8`），我们将显示一条消息说明只能上传图片，并且我们将重置文件上传组件。不幸的是，在浏览窗口（打开以便我们从电脑中选择文件的那个窗口）中无法过滤文件类型，这是一个变通方法，因此我们可以在
    Ext JS 端进行此验证，而不是将其留给服务器。
- en: And if the FileReader is not available, nothing is going to happen. The file
    preview is simply not going to work. The user will select the file and that's
    it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 FileReader 不可用，将不会发生任何事情。文件预览将无法正常工作。用户将选择文件，然后就没有然后了。
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The file size limit that you can upload depends on the upload limit that is
    set on the web server that you are going to deploy the Ext JS application in.
    For example, Apache supports a limit of 2GB. IIS has a default value of 4MB, but
    you can increase it to 2GB as well. Likewise for Apache Tomcat and other web servers.
    So the size limit is not on Ext JS; it is on the web server, and you just need
    to configure it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以上传的文件大小限制取决于您将要部署 Ext JS 应用程序的 Web 服务器上设置的文件上传限制。例如，Apache 支持高达 2GB 的限制。IIS
    的默认值为 4MB，但您可以将其增加到 2GB。Apache Tomcat 和其他 Web 服务器也是如此。因此，大小限制不在 Ext JS 中；它在于 Web
    服务器，您只需进行配置即可。
- en: Deleting a user
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'The last CRUD operation that we need to implement is the delete user. So let''s
    add the delete listener to the ViewController, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个 CRUD 操作是删除用户。因此，让我们向 ViewController 添加删除监听器，如下所示：
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The idea of this method is to verify that the user selected any row from the
    grid to be deleted (`record[0]` exists—(`#1`)) and also, we will only delete a
    user if there are more than two users on the application (`#3`). If yes, we will
    delete the user. If not, this means there is only one user in the application
    (`#8`), and we cannot delete the only user that exists.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的想法是验证用户是否已从网格中选择任何要删除的行（`record[0]` 存在——`#1`），并且我们只有在应用程序中有超过两个用户的情况下才会删除用户（`#3`）。如果是这样，我们将删除用户。如果不是，这意味着应用程序中只有一个用户（`#8`），我们无法删除唯一存在的用户。
- en: If it is possible to delete the user, the system will display a question asking
    whether we really want to delete the selected user (`#4`). If the answer is `yes`
    (`#5`), we will get the `store` reference (`#2`) and use its `remove` method (`#6`)
    passing the records to be deleted, and will send this request to the server (`#7`).
    The `proxy` will call the `destroy` URL when the `sync` method is called.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以删除用户，系统将显示一个询问是否真的想要删除所选用户（`#4`）的问题。如果答案是 `yes`（`#5`），我们将获取 `store` 引用（`#2`）并使用其
    `remove` 方法（`#6`）传递要删除的记录，并将此请求发送到服务器（`#7`）。当调用 `sync` 方法时，`proxy` 将调用 `destroy`
    URL。
- en: Note
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just remember that on the server, you can execute a `DELETE` query on the database,
    but in most cases we do a logical deletion, which means we will perform an `UPDATE`
    on a column active (in this case update the user to inactive).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，在服务器上，您可以在数据库上执行一个 `DELETE` 查询，但在大多数情况下我们进行逻辑删除，这意味着我们将对 `active` 列执行 `UPDATE`
    操作（在这种情况下，将用户更新为非活动状态）。
- en: Displaying the group name in the Grid
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在网格中显示组名
- en: There are a few ways we can display associated data in the Grid. We will use
    one approach in this example, and in other chapters, we will use different ones.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以在网格中显示关联数据。在这个例子中，我们将使用一种方法，在其他章节中，我们将使用不同的方法。
- en: 'The approach we are going to use is to add a `hasOne` association to the `User`
    Model as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的方法是向 `User` 模型添加一个 `hasOne` 关联，如下所示：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we are using the same schema in the `User` and `Group` models, we can refer
    to the `Group` Model only by its `entityName` (`#1`). We can also give a name
    of the object that is going to come from the server with the `Group` information
    (`#2`). And at last, Ext JS also needs to know which field contains the foreign
    key to the `Group` Model (`#3`).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `User` 和 `Group` 模型中使用相同的模式，我们可以仅通过其 `entityName`（`#1`）来引用 `Group` 模型。我们还可以为从服务器返回的包含
    `Group` 信息的对象指定一个名称（`#2`）。最后，Ext JS 还需要知道哪个字段包含到 `Group` 模型的外键（`#3`）。
- en: 'Then, we are going to add a new field in the user Model as well, as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在用户模型中添加一个新字段，如下所示：
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This field will be created in runtime when a `User` Model is created. We are
    not going to persist this information, which means that whenever the Store sends
    a create, update, or destroy request to the server, this field will not be included.
    For this field, we are also going to declare a `convert` function, which means
    that the information for this field will be created from another existing field.
    If there is `group` information available, we will return its `name`; otherwise,
    we return the `groups_id` anyway.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个`User`模型时，该字段将在运行时创建。我们不会持久化此信息，这意味着每当存储向服务器发送创建、更新或销毁请求时，此字段将不会被包含。对于此字段，我们还将声明一个`convert`函数，这意味着此字段的信息将从另一个现有字段创建。如果有`group`信息可用，我们将返回其`name`；否则，无论如何都会返回`groups_id`。
- en: 'Then, in the `UsersGrid` class, we will replace the current `dataIndex` of
    the `groups_id` column with the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`UsersGrid`类中，我们将用以下代码替换当前`groups_id`列的`dataIndex`：
- en: '[PRE41]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And the Grid will display the name of the group instead of its ID.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 并且网格将显示组的名称而不是其ID。
- en: We can refresh the application and test all functionalities from this chapter!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以刷新应用程序并测试本章中所有功能！
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to create, update, delete, and list all the
    users from our application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何在我们的应用程序中创建、更新、删除和列出所有用户。
- en: While we developed this module, we covered some important Ext JS concepts and
    some features introduced in Ext JS 5\. We developed this module using MVVM, and
    we covered some other ModelView capabilities, such as data binding. We learned
    how to use a schema in the Model and validate a form using Model validation. We
    also explored a new HTML5 feature for the file upload preview capability, which
    is another example of how we can use other technologies along with Ext JS.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发此模块的过程中，我们涵盖了Ext JS的一些重要概念和在Ext JS 5中引入的一些功能。我们使用MVVM开发了此模块，并介绍了其他ModelView功能，例如数据绑定。我们学习了如何在Model中使用模式并使用Model验证来验证表单。我们还探索了HTML5的一个新特性，用于文件上传预览功能，这也是我们如何结合使用其他技术以及Ext
    JS的另一个示例。
- en: In this next chapter, we will implement the MySQL table management module, which
    means we will implement a screen very similar to the **Edit** table data screen
    that we find in the MySQL Workbench application.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现MySQL表管理模块，这意味着我们将实现一个与MySQL Workbench应用程序中找到的**编辑**表数据屏幕非常相似的屏幕。
