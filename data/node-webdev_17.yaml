- en: Security in Node.js Applications
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js应用程序中的安全性
- en: 'We''re coming to the end of this journey of learning Node.js. But there is
    one important topic left to discuss: **security**. The security of your applications
    is very important. Do you want to get into the news because your application is
    the greatest thing since Twitter, or do you want to be known for a massive cybersecurity
    incident launched through your website?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束学习Node.js的旅程。但还有一个重要的话题需要讨论：**安全**。您的应用程序的安全性非常重要。您想因为您的应用程序是自Twitter以来最伟大的东西而上新闻，还是因为通过您的网站发起的大规模网络安全事件而闻名？
- en: Cybersecurity officials around the world have for years clamored for greater
    security on the internet. Security holes in things as innocent as internet-connected
    security cameras have been weaponized by miscreants into vast botnets and are
    used to bludgeon websites or commit other mayhem. In other cases, rampant identity
    theft from security intrusions are a financial threat to us all. Almost every
    day, the news includes more revelations of cybersecurity problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，全球各地的网络安全官员一直呼吁加强互联网安全。诸如互联网连接的安全摄像头之类的东西中的安全漏洞已被不法分子武器化为庞大的僵尸网络，并用于殴打网站或进行其他破坏。在其他情况下，由于安全入侵而导致的猖獗身份盗窃对我们所有人构成了财务威胁。几乎每天，新闻中都会有更多关于网络安全问题的揭示。
- en: We've mentioned this issue several times in this book. Starting in [Chapter
    10](176ce11c-dd6f-4ebf-ba14-529be6db28da.xhtml),* Deploying Node.js Applications
    on Linux*, we discussed the need to segment the deployment of Notes to present
    internal barriers against invasion, and specifically to keep the user database
    isolated in a protected container. The more layers of security you put around
    critical systems, the less likely it is that attackers can get in. While Notes
    is a toy application, we can use it to learn about implementing web application
    security.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中多次提到了这个问题。从第10章开始，即*在Linux上部署Node.js应用程序*，我们讨论了需要将Notes的部署分段以对抗入侵，并特别是将用户数据库隔离在受保护的容器中。您在关键系统周围放置的安全层越多，攻击者进入的可能性就越小。虽然Notes是一个玩具应用程序，但我们可以用它来学习如何实施Web应用程序安全。
- en: Security shouldn't be an afterthought, just as testing should not be an afterthought.
    Both are incredibly important, if only to keep your company from getting in the
    news for the wrong reasons.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 安全不应该是事后才考虑的，就像测试不应该是事后才考虑的一样。两者都非常重要，即使只是为了避免公司因错误原因而上新闻。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implementing HTTPS/SSL on AWS ECS for an Express application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS ECS上为Express应用程序实施HTTPS/SSL
- en: Using the Helmet library to implement headers for Content Security Policy, DNS
    Prefetch Control, Frame Options, Strict Transport Security, and mitigating XSS
    attacks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helmet库为内容安全策略、DNS预取控制、帧选项、严格传输安全性和减轻XSS攻击实施标头
- en: Preventing cross-site request forgery attacks against forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止跨站点请求伪造攻击表单
- en: SQL injection attacks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL注入攻击
- en: Pre-deployment scanning for packages with known vulnerabilities
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对已知漏洞的软件包进行预部署扫描
- en: Reviewing security facilities available on AWS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查AWS上可用的安全设施
- en: For general advice, the Express team has an excellent security resource page
    at [https://expressjs.com/en/advanced/best-practice-security.html](https://expressjs.com/en/advanced/best-practice-security.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般建议，Express团队在[https://expressjs.com/en/advanced/best-practice-security.html](https://expressjs.com/en/advanced/best-practice-security.html)上有一个出色的安全资源页面。
- en: If you haven't yet done so, duplicate the [Chapter 13](1c1eb7f2-8b1a-4f70-9f0a-94d865c739ef.xhtml),
    *Unit Testing and Functional Testing*, source tree, which you may have called `chap13`,
    to make a* Security* source tree, which you can call `chap14`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请复制[第13章](1c1eb7f2-8b1a-4f70-9f0a-94d865c739ef.xhtml)，*单元测试和功能测试*，源树，您可能已经称为`chap13`，以创建一个*安全*源树，您可以称为`chap14`。
- en: By the end of this chapter, you will have experienced the details of provisioning
    SSL certificates, using them to implement an HTTPS reverse-proxy. Following that,
    you will read about several tools to improve the security of Node.js web applications.
    This should give you a foundation in web application security.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解到提供SSL证书的详细信息，使用它们来实施HTTPS反向代理。之后，您将了解有关改进Node.js Web应用程序安全性的几种工具。这应该为您提供Web应用程序安全的基础。
- en: Let's start with implementing HTTPS support for the deployed Notes application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为部署的Notes应用程序实施HTTPS支持开始。
- en: Implementing HTTPS in Docker for deployed Node.js applications
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在部署的Node.js应用程序中为Docker实施HTTPS
- en: The current best practice is that every website must be accessed with HTTPS.
    Gone are the days when it was okay to transmit unencrypted information over the
    internet. That old model is susceptible to problems such as man-in-the-middle
    attacks, and other threats.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的最佳实践是每个网站都必须使用HTTPS访问。传输未加密信息的时代已经过去。这种旧模式容易受到中间人攻击和其他威胁的影响。
- en: Using SSL and HTTPS means that connections over the internet are authenticated
    and encrypted. The encryption is good enough to keep out all but the most advanced
    of snoops, and the authentication means we are assured the website is what it
    says it is. HTTPS uses the HTTP protocol but is encrypted using **SSL**, or **Secure
    Sockets Layers**. Implementing HTTPS requires getting an SSL certificate and implementing
    HTTPS support in the web server or web application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSL和HTTPS意味着互联网连接经过身份验证和加密。加密足够好，可以阻止除最先进的窥探者之外的所有人，而身份验证意味着我们确信网站就是它所说的那样。HTTPS使用HTTP协议，但使用SSL或安全套接字层进行加密。实施HTTPS需要获取SSL证书并在Web服务器或Web应用程序中实施HTTPS支持。
- en: Given a suitable SSL certificate, Node.js applications can easily implement
    HTTPS because a small amount of code gives us an HTTPS server. But there's another
    route that offers an additional benefit. NGINX is a well-regarded web server,
    and proxy server, that is extremely mature and feature-filled. We can use it to
    implement the HTTPS connection, and at the same time gain another layer of shielding
    between potential miscreants and the Notes application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个合适的SSL证书，Node.js应用程序可以很容易地实现HTTPS，因为只需少量代码就可以给我们一个HTTPS服务器。但还有另一种方法，可以提供额外的好处。NGINX是一个备受推崇的Web服务器和代理服务器，非常成熟和功能丰富。我们可以使用它来实现HTTPS连接，并同时获得另一层保护，防止潜在的不法分子和Notes应用程序之间的攻击。
- en: We have already deployed Notes using Docker swarm on an AWS EC2 cluster. Using
    NGINX is a simple matter of adding another container to the swarm, configured
    with the tools required to provision SSL certificates. For that purpose, we will
    use a Docker container that combines NGINX with a Let's Encrypt client program,
    and scripting to automate certificate renewal. Let's Encrypt is a non-profit operating
    an excellent service for free SSL certificates. Using their command-line tools,
    we can provision and otherwise manage SSL certificates as needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在AWS EC2集群上使用Docker swarm部署了Notes。使用NGINX只是简单地向swarm添加另一个容器，配置所需的工具来提供SSL证书。为此，我们将使用一个将NGINX与Let's
    Encrypt客户端程序结合在一起，并编写脚本来自动更新证书的Docker容器。Let's Encrypt是一个非营利性组织，提供免费SSL证书的优秀服务。使用他们的命令行工具，我们可以根据需要提供和管理SSL证书。
- en: 'In this section, we will do the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将做以下工作：
- en: Configure a domain name to point to our swarm
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置一个域名指向我们的swarm
- en: Incorporate a Docker container containing NGINX, Cron, and Certbot (one of the
    Let's Encrypt client tools)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整合一个包含NGINX、Cron和Certbot（Let's Encrypt客户端工具之一）的Docker容器
- en: Implement automated processes in that container for managing certificate renewal
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该容器中实现自动化流程来管理证书的更新
- en: Configure NGINX to listen on port `443` (HTTPS) alongside port `80` (HTTP)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置NGINX监听端口`443`（HTTPS）以及端口`80`（HTTP）
- en: Configure the Twitter application to support the website on HTTPS
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Twitter应用程序以支持网站的HTTPS
- en: This may seem like a lot of work, but every task is simple. Let's get started.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是很多工作，但每项任务都很简单。让我们开始吧。
- en: Assigning a domain name for an application deployed on AWS EC2
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为部署在AWS EC2上的应用程序分配一个域名
- en: The Notes application is deployed using a Docker swarm built on AWS EC2 instances.
    One of those instances has a public IP address and a domain name assigned by AWS.
    It is best to assign a domain name to the EC2 instance because the name assigned
    by AWS is not only user-unfriendly, but will change the next time you redeploy
    the cluster. Giving the EC2 instance a domain name requires having a registered
    domain name, adding an A record listing its IP address, and updating the A record
    every time the EC2 IP address changes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Notes应用程序是使用在AWS EC2实例上构建的Docker swarm部署的。其中一个实例有一个由AWS分配的公共IP地址和域名。最好给EC2实例分配一个域名，因为AWS分配的名称不仅用户不友好，而且在下次重新部署集群时会更改。给EC2实例分配一个域名需要有一个注册的域名，添加一个列出其IP地址的A记录，并在EC2
    IP地址更改时更新A记录。
- en: What does it mean to add an A record? The **domain name system** (**DNS**) is
    what lets us use a name such as `geekwisdom.net` for a website rather than the
    IP address, `216.239.38.21`. In the DNS protocol, there are several types of *records*
    that can be associated with domain name entries in the system. For this project,
    we need to only concern ourselves with one of those record types, the A record,
    for recording IP addresses for domain names. A web browser that's been told to
    visit any domain looks up the A record for that domain and uses that IP address
    to send HTTP(S) requests for website content.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 添加A记录意味着什么？**域名系统**（**DNS**）是让我们可以使用`geekwisdom.net`这样的名称来访问网站，而不是IP地址`216.239.38.21`。在DNS协议中，有几种类型的*记录*可以与系统中的域名条目相关联。对于这个项目，我们只需要关注其中一种记录类型，即A记录，用于记录域名的IP地址。一个被告知访问任何域的网络浏览器会查找该域的A记录，并使用该IP地址发送网站内容的HTTP(S)请求。
- en: 'The specific method to add an A record to the DNS entries of a domain varies
    considerably from one domain registrar to another. For example, one registrar
    (Pair Domains) has this screen:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将A记录添加到域的DNS条目的具体方法在不同的域注册商之间差异很大。例如，一个注册商（Pair Domains）有这样的屏幕：
- en: '![](img/3537cb6a-f1b4-4f14-aaa7-58a7ad7c0d39.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3537cb6a-f1b4-4f14-aaa7-58a7ad7c0d39.png)'
- en: In the dashboard for a specific domain, there might be a section for adding
    new DNS records. In this registrar, a dropdown lets you choose among the record
    types. Select the A record type, then for your domain name enter the IP address
    in the right-hand box, and in the left-hand box enter the subdomain name. In this
    case, we are creating a subdomain, `notes.geekwisdom.net`, so we can deploy a
    test site without disturbing the main site hosted on that domain. This also lets
    us avoid the expense of registering a new domain for this project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定域的仪表板中，可能有一个用于添加新DNS记录的部分。在这个注册商中，下拉菜单可以让你在记录类型中进行选择。选择A记录类型，然后在你的域名中在右侧框中输入IP地址，在左侧框中输入子域名。在这种情况下，我们正在创建一个子域，`notes.geekwisdom.net`，这样我们就可以部署一个测试站点，而不会影响到托管在该域上的主站点。这也让我们避免了为这个项目注册一个新域名的费用。
- en: As soon as you click the ADD RECORD button, the A record will be published.
    Since it usually takes some time for DNS records to propagate, you might not be
    able to visit the domain name right away. If this takes more than a couple of
    hours, you might have done something wrong.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击“添加记录”按钮，A记录就会被发布。由于DNS记录通常需要一些时间来传播，你可能无法立即访问域名。如果这需要超过几个小时，你可能做错了什么。
- en: Once the A record is successfully deployed, your users will be able to visit
    the Notes application at a nice domain like `notes.geekwisdom.net`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦A记录成功部署，你的用户就可以访问`notes.geekwisdom.net`这样一个漂亮的域名的Notes应用程序。
- en: Note that the IP address will change every time the EC2 instances are redeployed.
    If you redeploy the EC2 instances, you will need to update the A record for the
    new address.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每次重新部署EC2实例时，IP地址都会更改。如果重新部署EC2实例，则需要更新新地址的A记录。
- en: In this section, we have learned about assigning a domain name to the EC2 instance.
    This will make it easier for our users to access Notes, while also letting us
    provision an HTTPS/SSL certificate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经了解了将域名分配给EC2实例。这将使我们的用户更容易访问Notes，同时也让我们可以提供HTTPS/SSL证书。
- en: Adding the domain name means updating the Twitter application configuration
    so that Twitter knows about the domain name.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 添加域名意味着更新Twitter应用程序配置，以便Twitter知道该域名。
- en: Updating the Twitter application
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新Twitter应用程序
- en: Twitter needs to know which URLs are valid for our application. So far, we've
    told Twitter about test URLs on our laptop. We have Notes on a live domain, we
    need to tell Twitter about this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter需要知道哪些URL对我们的应用程序有效。到目前为止，我们已经告诉Twitter我们笔记本上的测试URL。我们在一个真实域上有Notes，我们需要告诉Twitter这一点。
- en: We've already done this several times, so you already know what to do. Head
    to `developers.twitter.com`, logging in with your Twitter account, and go to the
    Apps dashboard. Edit the application related to your Notes instance, and add your
    domain name to the list of URLs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做过这个几次了，所以你已经知道该怎么做了。前往`developers.twitter.com`，使用您的Twitter帐户登录，然后转到应用程序仪表板。编辑与您的Notes实例相关的应用程序，并将您的域名添加到URL列表中。
- en: We will be implementing both HTTP and HTTPS for the Notes application, and therefore
    Notes will have both `http://` and `https://` URLs. This means you must not only
    add the HTTP URLs to the Twitter configuration site, but also the HTTPS URLs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为Notes应用程序实现HTTP和HTTPS，因此Notes将具有`http://`和`https://` URL。这意味着您不仅必须将HTTP
    URL添加到Twitter配置站点，还必须将HTTPS URL添加到其中。
- en: In the `compose-stack/docker-compose.yml` file, the `TWITTER_CALLBACK_HOST`
    environment variable in the `svc-notes` configuration must also be updated with
    the domain.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compose-stack/docker-compose.yml`文件中，`svc-notes`配置中的`TWITTER_CALLBACK_HOST`环境变量也必须使用该域名进行更新。
- en: We now have both a domain name associated with the EC2 cluster, and we've informed
    Twitter of the domain name. We should be able to redeploy Notes to the swarm and
    be able to use it with the domain name. That includes being able to log in using
    Twitter, creating and deleting notes, and so forth. At this point, you cannot
    put an HTTPS URL into `TWITTER_CALLBACK_HOST` because we've not implemented HTTPS
    support.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了与EC2集群关联的域名，并且我们已经通知了Twitter该域名。我们应该能够重新部署Notes到集群，并能够使用该域名。这包括能够使用Twitter登录，创建和删除笔记等。在这一点上，您不能将HTTPS
    URL放入`TWITTER_CALLBACK_HOST`，因为我们还没有实现HTTPS支持。
- en: These steps prepared the way for implementing HTTPS on Notes using Let's Encrypt.
    But first, let's examine how Let's Encrypt works so we can better implement it
    for Notes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤为在Notes上使用Let's Encrypt实现HTTPS做好了准备。但首先，让我们来了解一下Let's Encrypt的工作原理，以便更好地为Notes实现它。
- en: Planning how to use Let's Encrypt
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规划如何使用Let's Encrypt
- en: Like every HTTPS/SSL certificate provider, Let's Encrypt is required to be certain
    that you own the domain for which you're requesting the certificate. Successfully
    using Let's Encrypt requires successful validation before any SSL certificates
    are issued. Once a domain is registered with Let's Encrypt, the registration must
    be renewed at least every 90 days, because that's the expiry time for their SSL
    certificates. Domain registration, and certificate renewal, are therefore the
    two primary tasks we must accomplish.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个HTTPS/SSL证书提供商一样，Let's Encrypt需要确保您拥有您正在请求证书的域。成功使用Let's Encrypt需要在发出任何SSL证书之前进行成功验证。一旦域名注册到Let's
    Encrypt，注册必须至少每90天更新一次，因为这是他们SSL证书的到期时间。域名注册和证书更新因此是我们必须完成的两项主要任务。
- en: In this section, we'll discuss how the registration and renewal features work.
    The goal is gaining an overview of how we'll manage an HTTPS service for any domain
    we plan to use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论注册和更新功能的工作原理。我们的目标是了解我们将如何管理我们计划使用的任何域的HTTPS服务。
- en: Let's Encrypt supports an API and there are several client applications for
    this API. Certbot is the recommended user interface for Let's Encrypt requests.
    It is easily installed on a variety of operating systems. For example, it is available
    through the Debian/Ubuntu package management system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Let's Encrypt支持API，并且有几个客户端应用程序用于此API。Certbot是Let's Encrypt请求的推荐用户界面。它可以轻松安装在各种操作系统上。例如，它可以通过Debian/Ubuntu软件包管理系统获得。
- en: For Let's Encrypt documentation, see [https://letsencrypt.org/docs/](https://letsencrypt.org/docs/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Let's Encrypt文档，请参阅[https://letsencrypt.org/docs/](https://letsencrypt.org/docs/)。
- en: For Certbot documentation, see [https://certbot.eff.org/docs/intro.html](https://certbot.eff.org/docs/intro.html).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Certbot文档，请参阅[https://certbot.eff.org/docs/intro.html](https://certbot.eff.org/docs/intro.html)。
- en: Validated domain ownership is a core feature of HTTPS, making it a core requirement
    for any SSL certificate supplier to be certain it is handing out SSL certificates
    correctly. Let's Encrypt has several validation strategies, and in this project,
    we'll focus on one, the HTTP-01 challenge.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 验证域名所有权是HTTPS的核心特性，这使得它成为任何SSL证书供应商确保正确分发SSL证书的核心要求。Let's Encrypt有几种验证策略，在这个项目中，我们将专注于其中一种，即HTTP-01挑战。
- en: The HTTP-01 challenge involves the Let's Encrypt service making a request to
    a URL such as `http://<YOUR_DOMAIN>/.well-known/acme-challenge/<TOKEN>`. The `<TOKEN>` is
    a coded string supplied by Let's Encrypt, which the Certbot tool will write as
    a file in a directory. Our task is then to somehow allow the Let's Encrypt servers
    to retrieve that file using this URL.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP-01挑战涉及Let's Encrypt服务向URL发出请求，例如`http://<YOUR_DOMAIN>/.well-known/acme-challenge/<TOKEN>`。`<TOKEN>`是Let's
    Encrypt提供的编码字符串，Certbot工具将其写入目录中的文件。我们的任务是以某种方式允许Let's Encrypt服务器使用此URL检索该文件。
- en: Once Certbot successfully registers the domain with Let's Encrypt, it receives
    a pair of PEM files comprising the SSL certificate. Certbot tracks various administrative
    details, and the SSL certificates, in a directory, by default `/etc/letsencrypt`.
    The SSL certificate in turn must be used to implement the HTTPS server for Notes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Certbot成功地将域名注册到Let's Encrypt，它将收到一对PEM文件，包括SSL证书。Certbot跟踪各种管理细节和SSL证书，通常在`/etc/letsencrypt`目录中。然后必须使用SSL证书来实现Notes的HTTPS服务器。
- en: Let's Encrypt SSL certificates expire in 90 days, and we must create an automated
    administrative task to renew the certificates. Certbot is also used for certificate
    renewal, by running `certbot renew`. This command looks at the domains registered
    on this server, and for any that require renewal it reruns the validation process.
    Therefore the directory required for the HTTP-01 challenge must remain enabled.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Let's Encrypt SSL证书在90天后过期，我们必须创建一个自动化的管理任务来更新证书。Certbot也用于证书更新，通过运行`certbot
    renew`。这个命令查看在这台服务器上注册的域名，并对任何需要更新的域名重新运行验证过程。因此，必须保持启用HTTP-01挑战所需的目录。
- en: With SSL certificates in hand, we must configure some an HTTP server instance
    to use those certificates to implement HTTPS. It's very possible to configure
    the `svc-notes` service to handle HTTPS on its own. In the Node.js runtime is
    an HTTPS server object that could handle this requirement. It would be a small
    rewrite in `notes/app.mjs` to accommodate SSL certificates to implement HTTPS,
    as well as the HTTP-01 challenge.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有SSL证书后，我们必须配置一些HTTP服务器实例来使用这些证书来实现HTTPS。非常有可能配置`svc-notes`服务来独立处理HTTPS。在Node.js运行时中有一个HTTPS服务器对象，可以处理这个要求。在`notes/app.mjs`中进行小的重写以适应SSL证书来实现HTTPS，以及HTTP-01挑战。
- en: But there is another possible approach. Web servers such as NGINX are very mature,
    robust, well tested, and, most importantly, support HTTPS. We can use NGINX to
    handle the HTTPS connection, and use what's called a *reverse proxy* to pass along
    the traffic to `svc-notes` as HTTP. That is, NGINX would be configured to accept
    in-bound HTTPS traffic, converting it to HTTP traffic to send to `svc-notes`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有另一种可能的方法。诸如NGINX之类的Web服务器非常成熟、稳健、经过充分测试，最重要的是支持HTTPS。我们可以使用NGINX来处理HTTPS连接，并使用所谓的*反向代理*将流量传递给`svc-notes`作为HTTP。也就是说，NGINX将被配置为接受入站HTTPS流量，将其转换为HTTP流量发送到`svc-notes`。
- en: Beyond the security goal of implementing HTTPS, this has an additional advantage
    of using a well-regarded web server (NGINX) to act as a shield against certain
    kinds of attacks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现HTTPS的安全目标之外，这还有一个额外的优势，即使用一个备受推崇的Web服务器（NGINX）来作为对抗某些类型攻击的屏障。
- en: Having looked over the Let's Encrypt documentation, we have a handle on how
    to proceed. There is a Docker container available that handles everything we need
    to do with NGINX and Let's Encrypt. In the next section, we'll learn how to integrate
    that container with the Notes stack, and implement HTTPS.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了Let's Encrypt文档之后，我们知道了如何继续。有一个可用的Docker容器，可以处理我们需要在NGINX和Let's Encrypt中进行的所有操作。在下一节中，我们将学习如何将该容器与Notes堆栈集成，并实现HTTPS。
- en: Using NGINX and Let's Encrypt in Docker to implement HTTPS for Notes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NGINX和Let's Encrypt在Docker中为Notes实现HTTPS
- en: We just discussed how to implement HTTPS for Notes using Let's Encrypt. The
    approach we'll take is to use a pre-baked Docker container, Cronginx ([https://hub.docker.com/r/robogeek/cronginx](https://hub.docker.com/r/robogeek/cronginx)), which
    includes NGINX, Certbot (a Let's Encrypt client), and a Cron server with a Cron
    job for managing SSL certificate renewal. This will simply require adding another
    container to the Notes stack, a little bit of configuration, and running a command
    to register our domain with Let's Encrypt.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了如何使用Let's Encrypt为Notes实现HTTPS。我们将采取的方法是使用一个预先制作的Docker容器，Cronginx（[https://hub.docker.com/r/robogeek/cronginx](https://hub.docker.com/r/robogeek/cronginx)），其中包括NGINX、Certbot（Let's
    Encrypt客户端）和一个用于管理SSL证书更新的Cron服务器和Cron作业。这只需要向Notes堆栈添加另一个容器，进行一些配置，并运行一个命令来注册我们的域名到Let's
    Encrypt。
- en: Before starting this section, make sure you have set aside a domain name that
    we will use in this project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本节之前，请确保您已经设置了一个域名，我们将在这个项目中使用。
- en: In the Cronginx container, Cron is used for managing a background task to renew
    SSL certificates. Yes, Cron, the server Linux/Unix administrators have used for
    decades for managing background tasks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cronginx容器中，Cron用于管理后台任务以更新SSL证书。是的，Cron，Linux/Unix管理员几十年来一直用来管理后台任务的服务器。
- en: The NGINX configuration will both handle the HTTP-01 challenge and use a reverse
    proxy for the HTTPS connection. A *proxy server* acts as an intermediary; it receives
    requests from clients and uses other services to satisfy those requests. A *reverse
    proxy* is a kind of proxy server that retrieves resources from one or more other
    servers, while making it look like the resource came from the proxy server. In
    this case, we will configure NGINX to access the Notes service at `http://svc-notes:3000`,
    while making the appearance that the Notes service is hosted by the NGINX proxy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX配置将同时处理HTTP-01挑战并为HTTPS连接使用反向代理。*代理服务器*充当中间人；它接收来自客户端的请求，并使用其他服务来满足这些请求。*反向代理*是一种从一个或多个其他服务器检索资源的代理服务器，同时使其看起来像资源来自代理服务器。在这种情况下，我们将配置NGINX以访问`http://svc-notes:3000`上的Notes服务，同时使Notes服务看起来是由NGINX代理托管的。
- en: If you don't know how to configure NGINX, don't worry because we'll show exactly
    what to do, and it's relatively simple.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道如何配置NGINX，不用担心，因为我们将准确地展示该怎么做，而且相对简单。
- en: Adding the Cronginx container to support HTTPS on Notes
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加Cronginx容器以支持Notes上的HTTPS
- en: We've determined that adding HTTPS support requires the addition of another
    container to the Notes stack. This container will handle the HTTPS connection
    and incorporate tools for managing SSL certificates provisioned from Let's Encrypt.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，添加HTTPS支持需要向Notes堆栈添加另一个容器。这个容器将处理HTTPS连接，并集成用于管理从Let's Encrypt获取的SSL证书的工具。
- en: 'In the `compose-stack` directory, edit `docker-compose.yml` like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compose-stack`目录中，编辑`docker-compose.yml`如下：
- en: '[PRE0]js\1'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]js\1'
- en: As we said, the NGINX configuration files are relatively simple. This declares
    a server, in this case listening to port `80` (HTTP). It is easy to turn on IPv6
    support if you wish.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，NGINX配置文件相对简单。这声明了一个服务器，本例中监听端口为`80`（HTTP）。如果需要，可以轻松开启IPv6支持。
- en: The `server_name` field tells NGINX which domain name to handle. The `access_log`
    and `error_log` fields, as the name implies, specify where to send logging output.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`server_name`字段告诉NGINX要处理哪个域名。`access_log`和`error_log`字段，顾名思义，指定了日志输出的位置。'
- en: The `location` blocks describe how to handle sections of the URL space for the
    domain. In the first, it says that HTTP-01 challenges on the `/.well-known` URL
    are handled by reading files from `/webroots/YOUR-DOMAIN`. We've already seen
    that directory referenced in the `docker-compose.yml` file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`location`块描述了如何处理域的URL空间的部分。在第一个块中，它表示`/.well-known` URL上的HTTP-01挑战是通过从`/webroots/YOUR-DOMAIN`读取文件来处理的。我们已经在`docker-compose.yml`文件中看到了该目录的引用。'
- en: The second `location` block describes the reverse proxy configuration. In this
    case, we configure it to run an HTTP proxy to the `svc-notes` container at port `3000`.
    That corresponds to the configuration in the `docker-compose.yml` file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`location`块描述了反向代理配置。在这种情况下，我们配置它以在端口`3000`上对`svc-notes`容器运行HTTP代理。这对应于`docker-compose.yml`文件中的配置。
- en: That's the configuration file, but we need to do a little work before we can
    deploy it to the swarm.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是配置文件，但在部署到swarm之前，我们需要做一些工作。
- en: Adding the required directories on the EC2 host
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在EC2主机上添加所需的目录
- en: We've identified three directories to use with Cronginx. Remember that each
    of the EC2 hosts is configured by a shell script we supply in the `user_data`
    field in the Terraform files. That script installs Docker and performs another
    setup. Therefore, we should use that script to create the three directories.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了三个用于Cronginx的目录。请记住，每个EC2主机都是由我们在Terraform文件的`user_data`字段中提供的shell脚本进行配置的。该脚本安装Docker并执行另一个设置。因此，我们应该使用该脚本来创建这三个目录。
- en: 'In `terraform-swarm`, edit `ec2-public.tf` and make this change:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`terraform-swarm`中，编辑`ec2-public.tf`并进行以下更改：
- en: '[PRE1]js\1'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]js\1'
- en: By now you will have done this several times and know what to do. Wait for it
    to finish deploying, record the IP addresses and other data, then initialize the
    swarm cluster and set up remote control access so you can run Docker commands
    on your laptop.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经做了几次这样的事情，知道该怎么做。等待部署完成，记录IP地址和其他数据，然后初始化swarm集群并设置远程控制访问，这样你就可以在笔记本上运行Docker命令。
- en: A very important task is to take the IP address and go to your DNS registrar
    and update the A record for the domain with the new IP address.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的任务是获取IP地址并转到您的DNS注册商，更新域的A记录为新的IP地址。
- en: 'We need to copy the NGINX configuration file into `/home/ubuntu/nginx-conf-d`,
    so let''s do so as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将NGINX配置文件复制到`/home/ubuntu/nginx-conf-d`，操作如下：
- en: '[PRE2]js\1'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]js\1'
- en: This adds the required secrets to the swarm, and then deploys the Notes stack.
    After a few moments, the services should all show as having launched. Notice that
    Cronginx is one of the services.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向swarm添加所需的秘密，并部署Notes堆栈。几分钟后，所有服务应该都已启动。请注意，Cronginx是其中之一。
- en: Once it's fully launched, you should be able to use Notes as always, but using
    the domain you configured. You should even be able to log in using Twitter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完全启动，您应该能够像以往一样使用Notes，但使用您配置的域名。您甚至可以使用Twitter登录。
- en: Registering a domain with Let's Encrypt
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Let's Encrypt注册域名
- en: We have just deployed the Notes stack on the AWS EC2 infrastructure. A part
    of this new deployment is the Cronginx container with which we'll handle HTTPS
    configuration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在AWS EC2基础设施上部署了Notes堆栈。这次部署的一部分是Cronginx容器，我们将用它来处理HTTPS配置。
- en: We have Notes deployed on the swarm, with the `cronginx` container acting as
    an HTTP proxy. Inside that container came pre-installed the Certbot tool and a
    script (`register.sh`) to assist with registering domains. We must run `register.sh` inside
    the `cronginx` container, and once the domain is registered we will need to upload
    a new NGINX configuration file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在swarm上部署了Notes，`cronginx`容器充当HTTP代理。在该容器内预先安装了Certbot工具和一个脚本（`register.sh`）来帮助注册域名。我们必须在`cronginx`容器内运行`register.sh`，一旦域名注册完成，我们将需要上传一个新的NGINX配置文件。
- en: 'Starting a shell inside the `cronginx` container can be this easy:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cronginx`容器内启动shell可能会很容易：
- en: '[PRE3]js\1'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]js\1'
- en: This script is designed to both create the required directory in `/webroots`,
    and to use Certbot to register the domain and provision the SSL certificates.
    Refer to the configuration file and you'll see how the `/webroots` directory is
    used.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本旨在创建`/webroots`中所需的目录，并使用Certbot注册域名并提供SSL证书。参考配置文件，您将看到`/webroots`目录的使用方式。
- en: The `certbot certonly` command only retrieves SSL certificates and does not
    install them anywhere. What that means is it does not directly integrate with
    any server, but simply stashes the certificates in a directory. That directory
    is within the `/etc/letsencrypt` hierarchy.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`certbot certonly`命令只检索SSL证书，不会在任何地方安装它们。这意味着它不会直接集成到任何服务器中，而只是将证书存储在一个目录中。该目录位于`/etc/letsencrypt`层次结构内。'
- en: The `--webroot` option means that we're running in cooperation with an existing
    web server. It must be configured to serve the `/.well-known/acme-challenge` files
    from the directory specified with the `-w` option, which is the `/webroots/YOUR-DOMAIN`
    directory we just discussed. The `-d` option is the domain name to be registered.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`--webroot`选项意味着我们正在与现有的Web服务器合作。必须配置它以从指定为`-w`选项的目录中提供`/.well-known/acme-challenge`文件，这就是我们刚刚讨论过的`/webroots/YOUR-DOMAIN`目录。`-d`选项是要注册的域名。'
- en: In short, `register.sh` fits with the configuration file we created.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`register.sh`与我们创建的配置文件相匹配。
- en: 'The script is executed like so:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的执行方式如下：
- en: '[PRE4]js\1'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]js\1'
- en: The key data is the pathnames for the two PEM files that make up the SSL certificate.
    It also tells you to run `certbot renew` every so often to renew the certificates.
    We already took care of that by installing the Cron job.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关键数据是构成SSL证书的两个PEM文件的路径名。它还告诉您定期运行`certbot renew`来更新证书。我们已经通过安装Cron作业来处理了这个问题。
- en: As they say, it is important to persist this directory elsewhere. We took the
    first step by storing it outside the container, letting us destroy and recreate
    the container at will. But what about when it's time to destroy and recreate the
    EC2 instances? Place a task on your backlog to set up a backup procedure, and
    then during EC2 cluster initialization install this directory from the backup.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如他们所说，将这个目录持久化存储在其他地方是很重要的。我们已经采取了第一步，将其存储在容器外部，这样我们可以随意销毁和重新创建容器。但是当需要销毁和重新创建EC2实例时怎么办？在您的待办事项中安排一个任务来设置备份程序，然后在EC2集群初始化期间从备份中安装这个目录。
- en: Now that our domain is registered with Let's Encrypt, let's change the NGINX
    configuration to support HTTPS.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的域名已经注册到Let's Encrypt，让我们修改NGINX配置以支持HTTPS。
- en: Implementing an NGINX HTTPS configuration using Let's Encrypt certificates
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Let's Encrypt证书实现NGINX HTTPS配置
- en: Alright, we're getting so close we can taste the encryption. We have deployed
    NGINX plus Let's Encrypt tools into the Notes application stack. We've verified
    that the HTTP-only NGINX configuration works correctly. And we've used Certbot
    to provision SSL certificates for HTTPS from Let's Encrypt. That makes it time
    to rewrite the NGINX configuration to support HTTPS and to deploy that config
    to the Notes stack.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们离加密如此之近，我们可以感受到它的味道。我们已经将NGINX和Let's Encrypt工具部署到了笔记应用程序堆栈中。我们已经验证了仅支持HTTP的NGINX配置是否正确。我们已经使用Certbot为HTTPS从Let's
    Encrypt提供SSL证书。现在是时候重写NGINX配置以支持HTTPS，并将该配置部署到笔记堆栈中。
- en: 'In `compose-stack/cronginx` create a new file, `YOUR-DOMAIN.conf`, for example
    `notes.geekwisdom.net.conf`. The previous file had a prefix, `initial`, because
    it served us for the initial phase of implementing HTTPS. Now that the domain
    is registered with Let''s Encrypt, we need a different configuration file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compose-stack/cronginx`中创建一个新文件，`YOUR-DOMAIN.conf`，例如`notes.geekwisdom.net.conf`。之前的文件有一个前缀`initial`，因为它在实现HTTPS的初始阶段为我们提供了服务。现在域名已经注册到Let's
    Encrypt，我们需要一个不同的配置文件：
- en: '[PRE5]js\1'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]js\1'
- en: This is an HTTPS server implementation in NGINX. There are many similarities
    to the HTTP server declaration, but with a couple of HTTPS – specific items. It
    listens on port `443`, the standard port for HTTPS, and tells NGINX to use SSL.
    It has the same configuration for the server name and logging.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是NGINX中的HTTPS服务器实现。与HTTP服务器声明有许多相似之处，但也有一些特定于HTTPS的项目。它在端口`443`上监听，这是HTTPS的标准端口，并告诉NGINX使用SSL。它具有相同的服务器名称和日志配置。
- en: The next segment tells NGINX the location of the SSL certificates. Simply replace
    this with the pathname that Certbot gave you.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分告诉NGINX SSL证书的位置。只需用Certbot给出的路径名替换它。
- en: The next segment handles the `/.well-known` URL for future validation requests
    with Let's Encrypt. Both the HTTP and HTTPS server definitions have been configured
    to handle this URL from the same directory. We don't know whether Let's Encrypt
    will request validation through the HTTP or HTTPS URL, so we might as well support
    this on both servers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分处理了`/.well-known`的URL，用于将来使用Let's Encrypt进行验证请求。HTTP和HTTPS服务器定义都已配置为从同一目录处理此URL。我们不知道Let's
    Encrypt是否会通过HTTP或HTTPS URL请求验证，因此我们可能会在两个服务器上都支持这一点。
- en: The next segment is a proxy server to handle the `/socket.io` URL. This requires
    specific settings because Socket.IO must negotiate an upgrade from HTTP/1.1 to
    WebSocket. Otherwise, an error is printed in the JavaScript console, and the Socket.IO
    features will not work. For more information, see the URL shown in the code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分是一个代理服务器，用于处理`/socket.io`的URL。这需要特定的设置，因为Socket.IO必须从HTTP/1.1升级到WebSocket。否则，JavaScript控制台会打印错误，并且Socket.IO功能将无法工作。有关更多信息，请参见代码中显示的URL。
- en: The last segment is a reverse proxy set up to proxy HTTPS traffic to an HTTP
    backend server. In this case, the backend server is the Notes application running
    on port `3000`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是设置一个反向代理，将HTTPS流量代理到运行在端口`3000`上的HTTP后端服务器上的笔记应用程序。
- en: 'Having created a new configuration file, we can upload it to the `notes-public` EC2
    instance like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个新的配置文件后，我们可以将其上传到`notes-public` EC2实例中，方法如下：
- en: '[PRE6]js\1'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]js\1'
- en: The `nginx.pid` file contains the process ID of the NGINX process. Many background
    services on Unix/Linux systems store the process ID in such a file. This command
    sends the SIGHUP signal to that process, and NGINX is written to reread its configuration
    upon receiving that signal. SIGHUP is one of the standard Unix/Linux *signals*,
    and is commonly used to cause background processes to reload their configuration
    like this. For more information, see the `signal(2)` man page.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`nginx.pid`文件包含NGINX进程的进程ID。许多Unix/Linux系统上的后台服务都将进程ID存储在这样的文件中。这个命令向该进程发送SIGHUP信号，NGINX在接收到该信号时会重新读取其配置。SIGHUP是标准的Unix/Linux*信号*之一，通常用于导致后台进程重新加载其配置。有关更多信息，请参见`signal(2)`手册页。'
- en: 'However, using Docker commands we can do this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用Docker命令，我们可以这样做：
- en: '[PRE7]js\1'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]js\1'
- en: This says that Docker swarm saw that the container exited, and it was therefore
    unable to restart the service.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示Docker swarm看到容器退出了，因此无法重新启动服务。
- en: 'It is easy to make mistakes in NGINX configuration files. First take a careful
    look at the configuration to see what might be amiss. The next stage of diagnosis
    is to look at the NGINX logs. We can do that with the `docker logs` command, but
    we need to know the container name. Because the container has exited, we must
    run this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在NGINX配置文件中很容易出错。首先仔细查看配置，看看可能出了什么问题。诊断的下一阶段是查看NGINX日志。我们可以使用`docker logs`命令来做到这一点，但我们需要知道容器的名称。因为容器已经退出，我们必须运行这个命令：
- en: '[PRE8]js\1'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]js\1'
- en: And indeed, the issue is a syntax error, and it even helpfully tells you the
    line number.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，问题是语法错误，它甚至会友好地告诉您行号。
- en: Once you have successfully restarted the `cronginx` service, visit the Notes
    service you've deployed and verify that it is in HTTPS mode.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您成功重新启动了`cronginx`服务，请访问您部署的Notes服务并验证它是否处于HTTPS模式。
- en: In this section, we successfully deployed HTTPS support for the Notes application
    stack on our AWS EC2 based Docker swarm. We used the files Docker container created
    in the previous section and deployed the updated Notes Stack to the swarm. We
    then ran Certbot to register our domain with Let's Encrypt. And we rewrote the
    NGINX configuration to support HTTPS.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们成功地为基于AWS EC2的Docker集群部署了Notes应用程序堆栈的HTTPS支持。我们使用了上一节中创建的Docker容器文件，并将更新后的Notes堆栈部署到了集群中。然后我们运行Certbot来注册我们的域名并使用Let's
    Encrypt。然后我们重写了NGINX配置以支持HTTPS。
- en: Our next task is to verify the HTTPS configuration is working correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个任务是验证HTTPS配置是否正常工作。
- en: Testing HTTPS support for the Notes application
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Notes应用程序的HTTPS支持
- en: We have done ad hoc testing, and more formal testing, of Notes all through this
    book. Therefore you know what to do to ensure Notes is working in this new environment.
    But there are a couple of HTTPS-specific things to check.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们对Notes进行了临时测试和更正式的测试。因此，您知道要确保Notes在这个新环境中正常工作需要做什么。但是还有一些特定于HTTPS的事项需要检查。
- en: In your browser, head to the domain name where you've hosted the application.
    If all went well, you will be greeted by the application, and it will have redirected
    to the HTTPS port automatically.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，转到您托管应用程序的域名。如果一切顺利，您将会看到应用程序，并且它将自动重定向到HTTPS端口。
- en: So that we humans know that a website is on HTTPS, most browsers show a *lock* icon
    in the location bar.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们人类知道网站是在HTTPS上，大多数浏览器在地址栏中显示一个*锁*图标。
- en: You should be able to click on that lock icon, and the browser will show a dialog
    giving information about the certificate. The certificate will verify that this
    is indeed the correct domain, and will also show the certificate was issued by
    Let's Encrypt via the **Let's Encrypt Authority X3**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够单击该锁图标，浏览器将显示一个对话框，提供有关证书的信息。证书将验证这确实是正确的域，并且还将显示证书是由Let's Encrypt通过**Let's
    Encrypt Authority X3**颁发的。
- en: You should be able to browse around the entire application and still see the
    lock icon.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够浏览整个应用程序并仍然看到锁图标。
- en: You should be on the lookout for *mixed content* warnings. These will appear
    in the JavaScript console and occur when some content on an HTTPS-loaded page
    is loaded using an HTTP URL. The mixed content scenario is less secure, and therefore
    browsers issue warnings to the user. Messages might appear in the JavaScript console
    inside the browser. If you have followed the instructions in this book correctly
    you will not see this message.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意*mixed content*警告。这些警告将出现在JavaScript控制台中，当HTTPS加载的页面上的某些内容使用HTTP URL加载时会出现。混合内容场景不够安全，因此浏览器会向用户发出警告。消息可能会出现在浏览器内的JavaScript控制台中。如果您正确地按照本书中的说明操作，您将不会看到此消息。
- en: Finally, head to the Qualys SSL Labs test page for SSL implementations. This
    service will examine your website, especially the SSL certificates, and give you
    a score. To examine your score, see [https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，前往Qualys SSL Labs SSL实现测试页面。该服务将检查您的网站，特别是SSL证书，并为您提供一个分数。要检查您的分数，请参阅[https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/)。
- en: 'Having completed this task, you may want to bring down the AWS EC2 cluster.
    Before doing so, it''s good form to de-register the domain from Let''s Encrypt.
    That''s also a simple matter of running Certbot with the right command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这项任务后，您可能希望关闭AWS EC2集群。在这样做之前，最好先从Let's Encrypt中注销域名。这也只需要运行带有正确命令的Certbot：
- en: '[PRE9]js\1'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]js\1'
- en: 'Then add this to `notes/app.mjs`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此添加到`notes/app.mjs`中：
- en: '[PRE10]js\1'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: Click the Save button, and you'll see this code displayed as text. A dangerous
    version of Notes would instead insert the `<script>` tag in the notes view page
    so that the malicious JavaScript would be loaded and cause a problem for our visitors.
    Instead, the `<script>` tag is encoded as safe HTML so it simply shows up as text
    on the screen. We didn't do anything special for that behavior, Handlebars did
    that for us.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 单击保存按钮，您将看到此代码显示为文本。Notes的危险版本将在notes视图页面中插入`<script>`标签，以便加载恶意JavaScript并为访问者造成问题。相反，`<script>`标签被编码为安全的HTML，因此它只会显示为屏幕上的文本。我们并没有为这种行为做任何特殊处理，Handlebars为我们做了这个。
- en: 'Actually, it''s a little more interesting. If we look at the Handlebars documentation, [http://handlebarsjs.com/expressions.html](http://handlebarsjs.com/expressions.html),
    we learn about this distinction:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这更有趣一些。如果我们查看Handlebars文档，[http://handlebarsjs.com/expressions.html](http://handlebarsjs.com/expressions.html)，我们会了解到这个区别：
- en: '[PRE11]js\1'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: We do not recommend doing this except as an experiment to see what happens.
    The effect is, as we just said, to allow our users to enter HTML code and have
    it displayed as is. If Notes were to behave this way, any note could potentially
    hold malicious JavaScript snippets or other malware.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不建议这样做，除非作为一个实验来看看会发生什么。效果是，正如我们刚才说的，允许用户输入HTML代码并将其原样显示。如果Notes以这种方式行事，任何笔记都可能携带恶意JavaScript片段或其他恶意软件。
- en: Let's return to Helmet's support for the Content-Security-Policy header. With
    this header, we instruct the web browser the scope from which it can download
    certain types of content. Specifically, it lets us declare which domains the browser
    can download JavaScript, CSS, or Font files from, and which domains the browser
    is allowed to connect to for services.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到Helmet对Content-Security-Policy头的支持。有了这个头部，我们指示Web浏览器可以从哪个范围下载某些类型的内容。具体来说，它让我们声明浏览器可以从哪些域下载JavaScript、CSS或字体文件，以及浏览器允许连接哪些域进行服务。
- en: This header, therefore, solves the named issue, namely our users entering malicious
    JavaScript code. But it also handles a similar risk of a malicious actor breaking
    in and modifying the templates to include malicious JavaScript code. In both cases,
    telling the browser a specific list of allowed domains means references to JavaScript
    from malicious sites will be blocked. That malicious JavaScript that's loaded
    from `pirates.den` won't run.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个标头解决了所命名的问题，即我们的用户输入恶意JavaScript代码。但它还处理了恶意行为者入侵并修改模板以包含恶意JavaScript代码的类似风险。在这两种情况下，告诉浏览器特定的允许域名列表意味着恶意网站的JavaScript引用将被阻止。从`pirates.den`加载的恶意JavaScript不会运行。
- en: To see the documentation for this Helmet module, see [https://helmetjs.github.io/docs/csp/](https://helmetjs.github.io/docs/csp/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此Helmet模块的文档，请参阅[https://helmetjs.github.io/docs/csp/](https://helmetjs.github.io/docs/csp/)。
- en: 'There is a long list of options. For instance, you can cause the browser to
    report any violations back to your server, in which case you''ll need to implement
    a route handler for `/report-violation`. This snippet is sufficient for Notes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多选项。例如，您可以导致浏览器将任何违规行为报告给您的服务器，这样您就需要为`/report-violation`实现一个路由处理程序。这段代码对Notes来说已经足够了：
- en: '[PRE12]js\1'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: What's happened is that the statically defined constant was no longer compatible
    with the domain where Notes was deployed. You had reconfigured this setting to
    limit connections to a different domain, such as `notes.newdomain.xyz`, but the
    service was still hosted on the existing domain, such as `notes.geekwisdom.net`.
    The browser no longer believed it was safe to connect to `notes.geekwisdom.net` because
    your configuration said to trust only `notes.newdomain.xyz`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，静态定义的常量不再与Notes部署的域兼容。您已重新配置此设置，以限制连接到不同域，例如`notes.newdomain.xyz`，但服务仍托管在现有域，例如`notes.geekwisdom.net`。浏览器不再相信连接到`notes.geekwisdom.net`是安全的，因为您的配置说只信任`notes.newdomain.xyz`。
- en: The best solution is to make this a configurable setting by declaring another
    environment variable that can be set to customize behavior.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的解决方案是通过声明另一个环境变量来使其成为可配置的设置，以便根据需要进行设置以自定义行为。
- en: 'In `app.mjs`, change the `contentSecurityPolicy` section to this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.mjs`中，将`contentSecurityPolicy`部分更改为以下内容：
- en: '[PRE13]js\1'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: We can now set that in the configuration, changing it as needed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在配置中设置它，根据需要进行更改。
- en: After rerunning the `docker stack deploy` command, the error message will go
    away and Socket.IO features will start to work.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行`docker stack deploy`命令后，错误消息将消失，Socket.IO功能将开始工作。
- en: In this section, we learned about the potential for a site to send malicious
    scripts to browsers. Sites that accept user-supplied content, such as Notes, can
    be a vector for malware. By using this header, we are able to notify the web browser
    which domains to trust when visiting this website, which will then block any malicious
    content added by malicious third parties.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了网站向浏览器发送恶意脚本的潜力。接受用户提供内容的网站，如Notes，可能成为恶意软件的传播途径。通过使用这个标头，我们能够通知网络浏览器在访问这个网站时信任哪些域名，从而阻止任何恶意内容被恶意第三方添加。
- en: Next, let's learn about preventing excess DNS queries.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何防止过多的DNS查询。
- en: Using Helmet to set the X-DNS-Prefetch-Control header
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用头盔设置X-DNS-Prefetch-Control标头
- en: DNS Prefetch is a nicety implemented by some browsers where the browser will
    preemptively make DNS requests for domains referred to by a given page. If a page
    has links to other websites, it will make DNS requests for those domains so that
    the local DNS cache is pre-filled. This is nice for users because it improves
    browser performance, but it is also a privacy intrusion and can make it look like
    the person visited websites they did not visit. For documentation, see [https://helmetjs.github.io/docs/dns-prefetch-control](https://helmetjs.github.io/docs/dns-prefetch-control).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: DNS Prefetch是一些浏览器实现的一种便利，其中浏览器将预先为给定页面引用的域名进行DNS请求。如果页面有指向其他网站的链接，它将为这些域名进行DNS请求，以便填充本地DNS缓存。这对用户很好，因为它提高了浏览器的性能，但它也是一种侵犯隐私的行为，并且可能使人看起来好像访问了他们没有访问的网站。有关文档，请参阅[https://helmetjs.github.io/docs/dns-prefetch-control](https://helmetjs.github.io/docs/dns-prefetch-control)。
- en: 'Set the DNS prefetch control with the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容设置DNS预取控制：
- en: '[PRE14]js\1'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: To enable a feature, either set it to `'self'` to allow the website to turn
    on the feature, or a domain name of a third-party website to allow to enable that
    feature. For example, enabling the payment feature might require adding `'paypal.com'`
    or some other payment processor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用一个功能，要么将其设置为`'self'`以允许网站启用该功能，要么将其设置为第三方网站的域名，以允许启用该功能。例如，启用支付功能可能需要添加`'paypal.com'`或其他支付处理器。
- en: In this section, we have learned about allowing the enabling or disabling of
    browser features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了允许启用或禁用浏览器功能。
- en: In the next section, let's learn about preventing clickjacking.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们学习如何防止点击劫持。
- en: Using Helmet to set the X-Frame-Options header
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用头盔设置X-Frame-Options标头
- en: '**Clickjacking** has nothing to do with carjacking but instead is an ingenious
    technique for getting folks to click on something malicious. The attack uses an
    invisible `<iframe>`, containing malicious code, positioned on top of a thing
    that looks enticing to click on. The user would then be enticed into clicking
    on the malicious thing.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**点击劫持**与劫持汽车无关，而是一种巧妙的技术，用于诱使人们点击恶意内容。这种攻击使用一个包含恶意代码的不可见`<iframe>`，放置在看起来诱人点击的东西上。然后用户会被诱使点击恶意内容。'
- en: The `frameguard` module for Helmet will set a header instructing the browser
    on how to treat an `<iframe>`. For documentation, see [https://helmetjs.github.io/docs/frameguard/](https://helmetjs.github.io/docs/frameguard/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Helmet的`frameguard`模块将设置一个标头，指示浏览器如何处理`<iframe>`。有关文档，请参阅[https://helmetjs.github.io/docs/frameguard/](https://helmetjs.github.io/docs/frameguard/)。
- en: '[PRE15]js\1'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: 'Or you can use Helmet to do so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用Helmet来这样做：
- en: '[PRE16]js\1'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: There's nothing like throwing the miscreants off the scent.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比让坏人迷失方向更好的了。
- en: We've learned how to let your Express application go incognito to avoid giving
    miscreants clues about how to break in. Let's next learn about declaring a preference
    for HTTPS.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何让您的Express应用程序隐身，以避免给坏人提供关于如何闯入的线索。接下来让我们学习一下如何声明对HTTPS的偏好。
- en: Improving HTTPS with Strict Transport Security
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过严格传输安全性改进HTTPS
- en: Having implemented HTTPS support, we aren't completely done. As we said earlier,
    it is best for our users to use the HTTPS version of Notes. In our AWS EC2 deployment,
    we forced the user to use HTTPS with a redirect. But in some cases we cannot do
    that, and instead must try to encourage the users to visit the HTTPS site over
    the HTTP site.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了HTTPS支持之后，我们还没有完全完成。正如我们之前所说的，最好让我们的用户使用Notes的HTTPS版本。在我们的AWS EC2部署中，我们强制用户使用HTTPS进行重定向。但在某些情况下，我们无法这样做，而必须试图鼓励用户访问HTTPS站点而不是HTTP站点。
- en: The Strict Transport Security header notifies the browser that it should use
    the HTTPS version of the site. Since that's simply a notification, it's also necessary
    to implement a redirect from the HTTP to HTTPS version of Notes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 严格传输安全性标头通知浏览器应该使用站点的HTTPS版本。由于这只是一个通知，还需要实现从HTTP到HTTPS版本的重定向。
- en: 'We set Strict-Transport-Security like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置严格传输安全性如下：
- en: '[PRE17]js\1'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]js\1'
- en: With this package installed, the users don't have to be encouraged to use HTTPS
    because we're silently forcing them to do so.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这个软件包后，用户不必被鼓励使用HTTPS，因为我们在默默地强制他们这样做。
- en: With our deployment on AWS EC2, using this module will cause problems. Because
    HTTPS is handled in the load balancer, the Notes app does not know the visitor
    is using HTTPS. Instead, Notes sees an HTTP connection, and if `forceSSL` were
    in use it would then force a redirect to the HTTPS site. But because Notes does
    not see the HTTPS session at all, it only sees HTTP requests to which `forceSSL`
    will always respond with a redirect.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在AWS EC2上的部署中，使用这个模块会导致问题。因为HTTPS是在负载均衡器中处理的，Notes应用程序不知道访问者正在使用HTTPS。相反，Notes看到的是一个HTTP连接，如果使用了`forceSSL`，它将强制重定向到HTTPS站点。但是因为Notes根本没有看到HTTPS会话，它只看到HTTP请求，而`forceSSL`将始终以重定向方式响应。
- en: These settings are not useful in all circumstances. Your context may require
    these settings, but for a context like our deployment on AWS EC2 it is simply
    not needed. For the sites where this is useful, we have learned about notifying
    the web browser to use the HTTPS version of our website, and how to force a redirect
    to the HTTPS site.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置并非在所有情况下都有用。您的环境可能需要这些设置，但对于像我们在AWS EC2上部署的环境来说，这根本不需要。对于这些有用的站点，我们已经了解到如何通知Web浏览器使用我们网站的HTTPS版本，以及如何强制重定向到HTTPS站点。
- en: Let's next learn about **cross-site-scripting** (**XSS**) attacks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们学习一下**跨站脚本**（**XSS**）攻击。
- en: Mitigating XSS attacks with Helmet
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Helmet减轻XSS攻击
- en: 'XSS attacks attempt to inject JavaScript code into website output. With malicious
    code injected into another website, the attacker can access information they otherwise
    could not retrieve, or cause other sorts of mischief. The X-XSS-Protection header
    prevents certain XSS attacks, but not all of them, because there are so many types
    of XSS attacks:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: XSS攻击试图将JavaScript代码注入到网站输出中。通过在另一个网站中注入恶意代码，攻击者可以访问他们本来无法检索的信息，或者引起其他类型的麻烦。 X-XSS-Protection标头可以防止某些XSS攻击，但并非所有类型的XSS攻击，因为XSS攻击有很多种类型：
- en: '[PRE18]js\1'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]js\1'
- en: This installs the `csurf` package, recording the dependency in `package.json`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装`csurf`软件包，并在`package.json`中记录依赖关系。
- en: 'Then install the middleware like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像这样安装中间件：
- en: '[PRE19]js\1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]js\1'
- en: This generates the CSRF token, ensuring it is sent along with other data to
    the template. Likewise, do the same for the `/login` route in `routes/users.mjs`.
    Our next task is to ensure the corresponding templates render the token as a hidden
    INPUT.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '这将生成CSRF令牌，确保它与其他数据一起发送到模板。同样，在`routes/users.mjs`中的`/login`路由也要这样做。我们的下一个任务是确保相应的模板将令牌呈现为隐藏的输入。 '
- en: 'In `views/noteedit.hbs` and `views/notedestroy.hbs,` add the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views/noteedit.hbs`和`views/notedestroy.hbs`中，添加以下内容：
- en: '[PRE20]js\1'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]js\1'
- en: 'In `views/noteview.hbs`, there''s a form for submitting comments. Make this
    change:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views/noteview.hbs`中，有一个用于提交评论的表单。做出以下更改：
- en: '[PRE21]js\1'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]js\1'
- en: This uses a parameterized string, and the value for `key` is encoded and inserted
    in the place of the question mark. Most database drivers have a similar feature,
    and they already know how to encode values into query strings. Even if a miscreant
    got some SQL into the value of `key`, because the driver correctly encodes the
    contents of `key` the worst that will result is an SQL error message. That automatically
    renders inert any attempted SQL injection attack.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个参数化字符串，`key`的值被编码并插入到问号的位置。大多数数据库驱动程序都有类似的功能，并且它们已经知道如何将值编码到查询字符串中。即使坏人将一些SQL注入到`key`的值中，因为驱动程序正确地对`key`的内容进行了编码，最坏的结果也只是一个SQL错误消息。这自动使任何尝试的SQL注入攻击无效。
- en: 'Contrast this with an alternative we could have written:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们本可以编写的另一种选择形成对比：
- en: '[PRE22]js\1'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]js\1'
- en: 'This tells us there are eight known vulnerabilities among the packages currently
    installed. Each vulnerability is assigned a criticality on this scale ([https://docs.npmjs.com/about-audit-reports](https://docs.npmjs.com/about-audit-reports)):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，当前安装的软件包中有八个已知的漏洞。每个漏洞在这个规模上被分配了一个严重性等级（[https://docs.npmjs.com/about-audit-reports](https://docs.npmjs.com/about-audit-reports)）：
- en: '*Critical*: Address immediately'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*严重*: 立即处理'
- en: '*High*: Address as quickly as possible'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高*: 尽快处理'
- en: '*Moderate*: Address as time allows'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中等*: 尽可能快地处理'
- en: '*Low*: Address at your discretion'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*低*: 自行处理'
- en: 'In this case, running `npm audit` tells us that every one of the low-priority
    issues is in the `minimist` package. For example, the report includes this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，运行`npm audit`告诉我们，所有低优先级问题都在`minimist`软件包中。例如，报告中包括了这样的内容：
- en: '[PRE23]js\1'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]js\1'
- en: In this case, no recommended fix is available because none of these packages
    have released a new version that depends on the correct version of `minimist`.
    The recommended solution for this case is to file issues with each corresponding
    package team requesting they update their dependencies to the later release of
    the offending package.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有推荐的修复方法，因为这些软件包都没有发布依赖于正确版本的`minimist`的新版本。这种情况的推荐解决方案是向每个相应的软件包团队提交问题，要求他们将其依赖项更新为有问题软件包的后续版本。
- en: 'In the last case, it is our application that directly depends on the vulnerable
    package:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，是我们的应用直接依赖于有漏洞的软件包：
- en: '[PRE24]js\1'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]js\1'
- en: These are additional attributes that look useful. The `secure` attribute requires
    that cookies be sent ONLY over HTTPS connections. This ensures the cookie data
    is encrypted by HTTPS encryption. The `maxAge` attribute sets an amount of time
    that cookies are valid, expressed in milliseconds.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是看起来有用的额外属性。`secure`属性要求Cookie只能通过HTTPS连接发送。这确保了Cookie数据通过HTTPS加密进行加密。`maxAge`属性设置了Cookie有效的时间，以毫秒表示。
- en: Cookies are an extremely useful tool in web browsers, even if there is a lot
    of over-hyped worry about what websites do with cookies. At the same time, it
    is possible to misuse cookies and create security problems. In this section, we
    learned how to mitigate risks with the session cookie.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie在Web浏览器中是一个非常有用的工具，即使有很多对网站如何使用Cookie的过度炒作的担忧。与此同时，滥用Cookie并造成安全问题是可能的。在这一部分，我们学习了如何通过会话Cookie来减轻风险。
- en: In the next section, we'll review the best practices for AWS ECS deployment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾AWS ECS部署的最佳实践。
- en: Hardening the AWS EC2 deployment
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固AWS EC2部署
- en: There is an issue left over from [Chapter 12](8551a26c-6834-4df6-b392-60a15c20f6ff.xhtml), *Deploying
    a Docker Swarm to AWS EC2 with Terraform*, which is the security group configuration
    for the EC2 instances. We configured the EC2 instances with permissive security
    groups, and it is better for them to be strictly defined. We rightly described
    that, at the time, as not the best practice, and promised to fix the issue later.
    This is where we do so.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题留在了[第12章](8551a26c-6834-4df6-b392-60a15c20f6ff.xhtml)中，*使用Terraform在AWS
    EC2上部署Docker Swarm*，即EC2实例的安全组配置。我们配置了具有宽松安全组的EC2实例，最好是严格定义它们。我们当时确实描述了这不是最佳实践，并承诺稍后解决这个问题。这就是我们要做的地方。
- en: In AWS, remember that a security group describes a *firewall* that allows or
    disallows traffic based on the IP port and IP address. This tool exists so we
    can decrease the potential attack surface miscreants have to gain illicit access
    to our systems.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS中，要记住安全组描述了一个*防火墙*，根据IP端口和IP地址允许或禁止流量。这个工具存在是为了减少不法分子获取我们系统非法访问的潜在攻击面。
- en: 'For the `ec2-public-sg` security group, edit `ec2-public.tf` and change it
    to this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ec2-public-sg`安全组，编辑`ec2-public.tf`并将其更改为以下内容：
- en: '[PRE25]js\1'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]js\1'
- en: This is largely the same but for some specific differences. First, because the
    private EC2 instances can have MySQL databases, we have declared a rule for port
    `3306`. Second, all but one of the rules restrict traffic to IP addresses inside
    the VPC.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是相同的，但有一些具体的区别。首先，因为私有EC2实例可以有MySQL数据库，我们声明了端口`3306`的规则。其次，除了一个规则外，所有规则都限制流量到VPC内的IP地址。
- en: Between these two security group definitions, we have strictly limited the attack
    surface of the EC2 instances. This will throw certain barriers in the path of
    any miscreants attempting to intrude on the Notes service.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个安全组定义之间，我们严格限制了EC2实例的攻击面。这将在任何不法分子试图侵入Notes服务时设置一定的障碍。
- en: While we've implemented several security best practices for the Notes service,
    there is always more that can be done. In the next section, we'll discuss where
    to learn more.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经为Notes服务实施了几项安全最佳实践，但总是还有更多可以做的。在下一节中，我们将讨论如何获取更多信息。
- en: AWS EC2 security best practices
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS EC2安全最佳实践
- en: At the outset of designing the Notes application stack deployment, we described
    a security model that should result in a highly secure deployment. Are we the
    kind of security experts that can design a secure deployment infrastructure on
    the back of a napkin? Probably not. But the team at AWS does employ engineers
    with security expertise. When we turned to AWS EC2 for deployment, we learned
    it offered a wide range of security tools we hadn't considered in the original
    plan, and we ended up with a different deployment model.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计Notes应用程序堆栈部署的开始，我们描述了一个应该导致高度安全部署的安全模型。我们是那种可以在餐巾纸背面设计安全部署基础设施的安全专家吗？可能不是。但AWS团队确实雇佣了具有安全专业知识的工程师。当我们转向AWS
    EC2进行部署时，我们了解到它提供了一系列我们在原始计划中没有考虑到的安全工具，最终我们得到了一个不同的部署模型。
- en: In this section, let's review what we did and also review some additional tools
    available on AWS.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，让我们回顾一下我们做了什么，还要回顾一些AWS上可用的其他工具。
- en: 'The AWS **Virtual Private Cloud** (**VPC**) contains many ways to implement
    security features, and we used a few of them:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: AWS **虚拟私有云** (**VPC**) 包含许多实现安全功能的方法，我们使用了其中的一些：
- en: '*Security Groups* act as a firewall with strict controls over the traffic that
    can enter or leave the things protected by a Security Group. Security Groups are
    attached to every infrastructure element we used, and in most cases, we configured
    them to allow only the absolutely necessary traffic.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全组*充当一个严格控制进出受安全组保护的事物流量的防火墙。安全组附加到我们使用的每个基础设施元素上，在大多数情况下，我们配置它们只允许绝对必要的流量。'
- en: We ensured the database instances were created within the VPC, rather than hosted
    on the public internet. This hides the databases from public access.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们确保数据库实例是在VPC内创建的，而不是托管在公共互联网上。这样可以将数据库隐藏起来，避免公共访问。
- en: While we did not implement the originally envisioned segmentation, there are
    enough barriers surrounding Notes that it should be relatively safe.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有实施最初设想的分割，但围绕Notes的屏障足够多，应该相对安全。
- en: In reviewing the AWS VPC security documentation, there are a few other facilities
    that are worth exploring.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查AWS VPC安全文档时，还有一些其他值得探索的设施。
- en: Security in AWS Virtual Private Cloud: [https://docs.aws.amazon.com/vpc/latest/userguide/security.html](https://docs.aws.amazon.com/vpc/latest/userguide/security.html).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: AWS虚拟私有云中的安全性：[https://docs.aws.amazon.com/vpc/latest/userguide/security.html](https://docs.aws.amazon.com/vpc/latest/userguide/security.html)。
- en: In this section, you've had a chance to review the security of the application
    that was deployed to AWS ECS. While we did a fairly good job, there is more that
    can be done to exploit tools offered by AWS to beef up the internal security of
    the application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您有机会审查部署到AWS ECS的应用程序的安全性。虽然我们做得相当不错，但还有更多可以利用AWS提供的工具来加强应用程序的内部安全性。
- en: With that, it's time to close out this chapter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，现在是时候结束本章了。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've covered an extremely important topic, application security.
    Thanks to the hard work of the Node.js and Express communities, we've been able
    to tighten the security simply by adding a few bits of code here and there to
    configure security modules.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了一个非常重要的主题，应用程序安全。由于Node.js和Express社区的辛勤工作，我们能够通过在各处添加一些代码来配置安全模块，从而加强安全性。
- en: We first enabled HTTPS because it is now a best practice, and has positive security
    gains for our users. With HTTPS, the browser session is authenticated to positively
    identify the website. It also protects against man-in-the-middle security attacks,
    and encrypts communications for transmission across the internet, preventing most
    snooping.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先启用了HTTPS，因为这是现在的最佳实践，并且对我们的用户有积极的安全收益。通过HTTPS，浏览器会对网站进行身份验证。它还可以防止中间人安全攻击，并加密用于在互联网上传输的通信，防止大部分窥探。
- en: The `helmet` package provides a suite of tools to set security headers that
    instruct web browsers on how to treat our content. These settings prevent or mitigate
    whole classes of security bugs. With the `csurf` package, we're able to prevent
    **cross-site request forgery** (**CSRF**) attacks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`helmet`包提供了一套工具，用于设置安全头，指示Web浏览器如何处理我们的内容。这些设置可以防止或减轻整类安全漏洞。通过`csurf`包，我们能够防止跨站点请求伪造（CSRF）攻击。'
- en: These few steps are a good start for securing the Notes application. But you
    should not stop here because there is a never-ending set of security issues to
    fix. None of us can neglect the security of the applications we deploy.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些几个步骤是确保Notes应用程序安全的良好开端。但是你不应该就此止步，因为有一系列永无止境的安全问题需要解决。我们任何人都不能忽视我们部署的应用程序的安全性。
- en: Over the course of this book, the journey has been about learning the major
    life cycle steps required to develop and deploy a Node.js web application. This
    started from the basics of using Node.js, proceeded to an application concept
    to develop, and from there we covered every stage of developing, testing, and
    deploying that application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，旅程是关于学习开发和部署Node.js网络应用程序所需的主要生命周期步骤。这始于使用Node.js的基础知识，然后是应用程序概念的开发，然后我们涵盖了开发、测试和部署应用程序的每个阶段。
- en: Throughout the book, we've learned how advanced JavaScript features such as
    async functions and ES6 modules are used in Node.js applications. To store our
    data, we learned how to use several database engines, and a methodology to make
    it easy to switch between engines.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们学习了高级JavaScript功能，如异步函数和ES6模块在Node.js应用程序中的使用。为了存储我们的数据，我们学习了如何使用几种数据库引擎，以及一种使在不同引擎之间轻松切换的方法。
- en: Mobile-first development is extremely important in today's environment, and
    to fulfill that goal, we learned how to use the Bootstrap framework.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的环境中，移动优先开发非常重要，为了实现这一目标，我们学习了如何使用Bootstrap框架。
- en: Real-time communication is expected on a wide variety of websites because advanced
    JavaScript capabilities mean we can now offer more interactive services in our
    web applications. To fulfill that goal, we learned how to use the Socket.IO real-time
    communications framework.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 实时通信在各种网站上都是期望的，因为先进的JavaScript功能意味着我们现在可以在网络应用程序中提供更多的互动服务。为了实现这一目标，我们学习了如何使用Socket.IO实时通信框架。
- en: Deploying application services to cloud hosting is widely used, both for simplifying
    the system setup and to scale services to meet the demands of our user base. To
    fulfill that goal, we learned to use Docker, and then we learned how to deploy
    Docker services to AWS ECS using Terraform. We not only used Docker for production
    deployment but for deploying a test infrastructure, within which we can run unit
    tests and functional tests.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序服务部署到云主机是被广泛使用的，既可以简化系统设置，也可以扩展服务以满足用户需求。为了实现这一目标，我们学会了使用Docker，然后学会了如何使用Terraform将Docker服务部署到AWS
    ECS。我们不仅在生产部署中使用Docker，还用它来部署测试基础设施，其中我们可以运行单元测试和功能测试。
