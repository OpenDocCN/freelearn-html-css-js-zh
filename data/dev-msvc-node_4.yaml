- en: Chapter 4. Writing Your First Microservice in Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。在Node.js中编写您的第一个微服务
- en: We have been learning about how to build robust microservices-oriented software,
    and now it is time to put all the concepts to practice. In this chapter, we are
    going to build a microservices-oriented e-commerce using Seneca and some other
    frameworks that are going to allow us to write a software that will benefit from
    the particularities of the microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在学习如何构建健壮的面向微服务的软件，现在是将所有概念付诸实践的时候了。在本章中，我们将使用Seneca和其他一些框架来构建一个面向微服务的电子商务，这将使我们能够编写一个软件，从微服务的特点中受益。
- en: Micromerce – the big picture
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务 - 大局观
- en: 'It covers the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 它涵盖了以下内容：
- en: Writing microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写微服务
- en: Sizing microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的大小
- en: Creating APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建API
- en: Integrating Seneca with Express
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Seneca与Express集成
- en: Storing data using Seneca
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Seneca存储数据
- en: In this chapter, we are going to write a full (nearly) simplistic e-commerce
    solution based on microservices. Full means full from the conceptual point of
    view, but for obvious reasons, it won't be full (as production ready) as it could
    take us a few books to handle all the possible flows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个基于微服务的完整（几乎）简化的电子商务解决方案。完整意味着从概念上来看是完整的，但出于明显的原因，它不会是完整的（生产就绪），因为要处理所有可能的流程可能需要我们几本书。
- en: We won't go deep in to the UI, as it is not related to the subject of this book.
    What we will do instead is a microservice that will aggregate all the other microservices,
    creating a frontend API to be consumed by a **Single-Page Application** (**SPA**),
    built with any of the modern JavaScript frameworks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入研究UI，因为它与本书的主题无关。相反，我们将做一个微服务，它将聚合所有其他微服务，创建一个前端API，供任何现代JavaScript框架构建的**单页应用程序**（**SPA**）消费。
- en: 'In this chapter, we are going to develop the following four microservices:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发以下四个微服务：
- en: '**Product Manager**: This microservice will be responsible for adding, editing,
    and removing products from our database, as well as serving products to the customers.
    This microservice will be partially public for a potential admin site to add/remove
    products.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品经理**：这个微服务将负责向我们的数据库添加、编辑和删除产品，以及向客户提供产品。这个微服务将部分对外开放，供潜在的管理员站点添加/删除产品。'
- en: '**Order Manager**: This microservice will be responsible for managing the order
    and billing.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单管理器：这个微服务将负责管理订单和结算。
- en: '**Emailer**: This microservice will be responsible for delivering e-mails to
    the customers.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Emailer**：这个微服务将负责向客户发送电子邮件。'
- en: '**UI**: This microservice will expose the feature from the other microservices
    to a potential SPA, but we will only build the JSON interface.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI**：这个微服务将向潜在的SPA公开来自其他微服务的功能，但我们只会构建JSON接口。'
- en: Building the four preceding microservices, we will develop the concepts discussed
    in the previous chapters so that, by the end of this chapter, we will be able
    to identify the most common pitfalls going forward. Keep in mind that the objective
    of this book is not converting you into a microservices or Node.js expert, but
    to give you the tools required to learn by yourself, as well as make you aware
    of the best design principles and the most common pitfalls.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建前面的四个微服务，我们将开发前几章讨论的概念，以便在本章结束时，我们将能够识别前进时最常见的陷阱。请记住，本书的目标不是让您成为微服务或Node.js专家，而是为您提供自学所需的工具，并让您了解最佳设计原则和最常见的陷阱。
- en: 'Let''s take a look at the deployment diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下部署图：
- en: '![Micromerce – the big picture](img/B04889_04_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![微服务 - 大局观](img/B04889_04_01.jpg)'
- en: 'This diagram shows how our company (the yellow square) hides some of our microservices
    from the real world and exposes some others to different networks, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图显示了我们公司（黄色方块）如何将一些微服务隐藏在真实世界中，并向不同网络公开其他一些微服务，如下所示：
- en: '**UI** will be exposed to the Internet. Everybody will be able to hit this
    endpoint.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI**将向互联网公开。每个人都可以访问这个端点。'
- en: '**Product Management** will manage the products in our e-commerce. It will
    have the following two interfaces:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品管理**将管理我们电子商务中的产品。它将有以下两个接口：'
- en: A Seneca endpoint from where the UI will extract data
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Seneca端点，UI将从中提取数据
- en: A JSON API from where the office of our company will be able to create, update,
    and delete products
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个JSON API，我们公司的办公室将能够创建、更新和删除产品
- en: '**Emailer** will be our communication channel with our customers. We will use
    this microservice to explain the good points of Seneca, and we will also give
    an example of the eventual consistency and system degradation when a microservice
    fails.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Emailer**将是我们与客户沟通的渠道。我们将使用这个微服务来解释Seneca的优点，并且我们还将举例说明当微服务失败时的最终一致性和系统退化。'
- en: '**Order Manager**: This microservice will let us handle the orders for our
    customers. With this microservice, we will discuss how to handle the fact that
    the data is local to each microservice, instead of being global to the system.
    You can''t just go to the database to recover the product name or price, it needs
    to be recovered from other microservice.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单管理器**：这个微服务将让我们处理客户的订单。通过这个微服务，我们将讨论如何处理数据仅局限于每个微服务，而不是全局于系统的事实。您不能只是去数据库恢复产品名称或价格，它需要从其他微服务中恢复。'
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As you can see, there is no user or staff management, but with these four microservices,
    we will be able to develop the core concepts of microservices architectures. Seneca
    comes with a very powerful data and transport plugin system that makes it easy
    to use Seneca with different data storages and transport systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，没有用户或员工管理，但通过这四个微服务，我们将能够开发微服务架构的核心概念。Seneca配备了一个非常强大的数据和传输插件系统，使得使用不同的数据存储和传输系统与Seneca很容易。
- en: 'For all our microservices, we are going to use MongoDB as the storage. Seneca
    comes with an out-of-the-box in-memory database plugin that allows you to start
    coding straightaway, but the storage is transient: it does not persist the data
    between calls.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们所有的微服务，我们将使用MongoDB作为存储。Seneca带有一个开箱即用的内存数据库插件，允许您立即开始编码，但存储是瞬态的：它不会在调用之间保留数据。
- en: Product Manager – the two-faced core
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品经理 - 双面核心
- en: 'Product Manager is the core of our system. I know what you are thinking: microservices
    should be small (micro) and distributed (no central point), but you need to set
    the conceptual centre somewhere, otherwise you will end up with a fragmented system
    and traceability problems (we will talk about it later).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 产品经理是我们系统的核心。我知道你在想什么：微服务应该是小的（微小）和分布式的（没有中心点），但你需要在某个地方设定概念中心，否则你最终会得到一个碎片化的系统和可追溯性问题（我们以后会谈论这个）。
- en: Building a dual API with Seneca is fairly easy, as it comes with a quite straightforward
    integration with Express. Express is going to be used to expose some capabilities
    of the UI such as editing products, adding products, deleting products, and so
    on. It is a very convenient framework, easy to learn, and it integrates well with
    Seneca. It is also a de-facto standard on Node.js for web apps, so it makes it
    easy to find information about the possible problems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Seneca构建双重API相当容易，因为它与Express有一个非常直接的集成。Express将用于公开UI的一些功能，如编辑产品，添加产品，删除产品等。这是一个非常方便的框架，易于学习，并且与Seneca集成良好。它也是Node.js
    Web应用程序的事实标准，因此很容易找到关于可能问题的信息。
- en: It is going to also have a private part exposed through Seneca TCP (the default
    plugin in Seneca) so that our internal network of microservices (specifically,
    the UI) will be able to access the list of products in our catalogue.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将通过Seneca TCP（Seneca的默认插件）暴露一个私有部分，以便我们的内部微服务网络（特别是UI）能够访问我们目录中的产品列表。
- en: Product Manager is going to be small and cohesioned (it will only manage products),
    as well as scalable, but it will hold all the knowledge required to deal with
    products in our e-commerce.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 产品经理将会小而紧密（它只会管理产品），以及可扩展，但它将拥有处理我们电子商务中产品所需的所有知识。
- en: 'First thing we need to do is to define our Product Manager microservice, as
    follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是定义我们的产品经理微服务，如下所示：
- en: This is going to have a function to retrieve all the products in the database.
    This is probably a bad idea in a production system (as it probably would require
    pagination), but it works for our example.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将有一个函数来检索数据库中的所有产品。在生产系统中这可能是一个坏主意（因为它可能需要分页），但对于我们的例子来说是有效的。
- en: This should have one function that fetches all the products for a given category.
    It is similar to the previous one, it would need pagination in a production-ready
    system.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这应该有一个函数来获取给定类别的所有产品。它类似于之前的函数，在一个生产就绪的系统中，它需要分页。
- en: This should have a function to retrieve products by identifier (`id`).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这应该有一个按标识符（`id`）检索产品的函数。
- en: 'This should have one function that allows us to add products to the database
    (in this case MongoDB). This function will use the Seneca data abstraction to
    decouple our microservice from the storage: we will be able to (in theory) switch
    Mongo to a different database without too much hassle (in theory again).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这应该有一个函数，允许我们将产品添加到数据库（在这种情况下是MongoDB）。这个函数将使用Seneca数据抽象来解耦我们的微服务与存储：我们将能够（理论上）在不太麻烦的情况下切换Mongo到不同的数据库（再次理论上）。
- en: This should have one function to remove products. Again, using Seneca data abstraction.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这应该有一个函数来删除产品。同样，使用Seneca数据抽象。
- en: This should have one function to edit products.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这应该有一个函数来编辑产品。
- en: 'Our product will be a data structure having four fields: **name**, **category**,
    **description**, and **price**. As you can see, it is a bit simplistic, but it
    will help us to understand the complicated world of microservices.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的产品将是一个具有四个字段的数据结构：**名称**，**类别**，**描述**和**价格**。正如你所看到的，它有点简单，但它将帮助我们理解微服务的复杂世界。
- en: Our Product Management microservice is going to use MongoDB ([https://www.mongodb.org/](https://www.mongodb.org/)).
    Mongo is a document-oriented schema-less database that allows an enormous flexibility
    to store data such as products (that, at the end of the day, are documents). It
    is also a good choice for Node.js as it stores JSON objects, which is a standard,
    created for JavaScript (**JSON** stands for **JavaScript Object Notation**), so
    that looks like the perfect pairing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的产品管理微服务将使用MongoDB（[https://www.mongodb.org/](https://www.mongodb.org/)）。Mongo是一个面向文档的无模式数据库，允许以极大的灵活性存储数据，如产品（最终，这些都是文档）。它也是Node.js的一个很好的选择，因为它存储JSON对象，这是JavaScript的标准，为JavaScript创建（**JSON**代表**JavaScript对象表示**），因此看起来是完美的配对。
- en: There is a lot of useful information on the MongoDB website if you want to learn
    more about it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于它的有用信息，可以在MongoDB网站上找到。
- en: Let's start coding our functions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写我们的函数。
- en: Fetching products
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取产品
- en: To fetch products, we go to the database and dump the full list of products
    straight to the interface. In this case, we won't create any pagination mechanism,
    but in general, paginating data is a good practice to avoid database (or applications,
    but mainly database) performance problems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取产品，我们去数据库并将完整的产品列表直接转储到接口。在这种情况下，我们不会创建任何分页机制，但通常，分页数据是避免数据库（或应用程序，但主要是数据库）性能问题的良好实践。
- en: 'Let''s see the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We already have a pattern in Seneca that returns all the data in our database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Seneca中有一个模式，返回我们数据库中的所有数据。
- en: 'The `products.list$()` function will receive the following two parameters:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`products.list$()`函数将接收以下两个参数：'
- en: The query criteria
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询条件
- en: A function that receives an error and result object (remember the error-first
    callback approach)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接收错误和结果对象的函数（记住错误优先的回调方法）
- en: Seneca uses the `$` symbol to identify the key functions such as `list$`, `save$`,
    and so on. Regarding the naming of the properties of your objects, as long as
    you use alphanumeric identifiers, your naming will be collision free.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca使用`$`符号来标识关键函数，如`list$`、`save$`等。关于对象的属性命名，只要你使用字母数字标识符，你的命名就不会发生冲突。
- en: 'We are passing the `done` function from the `seneca.add()` method to the `list$`
    method. This works as Seneca follows the callback with error-first approach. In
    other words, we are creating a shortcut for the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`seneca.add()`方法中的`done`函数传递给`list$`方法。这是因为Seneca遵循错误优先的回调方式。换句话说，我们正在为以下代码创建一个快捷方式：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Fetching by category
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按类别获取
- en: Fetching by category is very similar to fetching the full list of products.
    The only difference is that now the Seneca action will take a parameter to filter
    the products by category.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按类别获取与获取产品的完整列表非常相似。唯一的区别是现在Seneca操作将接受一个参数来按类别过滤产品。
- en: 'Let''s see the code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One of the first questions that most advanced developers will now have in their
    mind is that *isn't this a perfect scenario for an injection attack?* Well, Seneca
    is smart enough to prevent it, so we don't need to worry about it any more than
    avoid concatenating strings with user input.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级开发人员现在脑海中的第一个问题是*这不是一个完美的注入攻击场景吗？*好吧，Seneca足够聪明，可以防止它，所以我们不需要担心它，只需避免将字符串与用户输入连接起来。
- en: As you can see, the only significant difference is the parameter passed called
    `category`, which gets delegated into Seneca data abstraction layer that will
    generate the appropriate query, depending on the storage we use. This is extremely
    powerful when talking about microservices. If you remember, in the previous chapters,
    we always talked about coupling as if it was the root of all evils, and now we
    can assure it is, and Seneca handles it in a very elegant way. In this case, the
    framework provides a contract that the different storage plugins have to satisfy
    in order to work. In the preceding example, `list$` is part of this contract.
    If you use the Seneca storage wisely, switching your microservice over to a new
    database engine (have you ever been tempted to move a part of your data over MongoDB?)
    is a matter of configuration.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，唯一的显著差异是传递的名为`category`的参数，它被委托到Seneca数据抽象层，该层将根据我们使用的存储生成适当的查询。在谈论微服务时，这是非常强大的。如果你还记得，在前面的章节中，我们总是谈论耦合好像它是一切罪恶的根源，现在我们可以确定它是，而Seneca以非常优雅的方式处理它。在这种情况下，框架提供了不同存储插件必须满足的合同。在前面的示例中，`list$`是这个合同的一部分。如果你明智地使用Seneca存储，将你的微服务切换到新的数据库引擎（你有没有曾经想过将你的一部分数据转移到MongoDB？）只是一个配置问题。
- en: Fetching by ID
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过ID获取
- en: 'Fetching a product by ID is one of the most necessary methods, and it is also
    a tricky one. Not tricky from the coding point of view, as shown in the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过ID获取产品是最必要的方法之一，也是一个棘手的方法。从编码的角度来看并不棘手，如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The tricky part is how `id` is generated. The generation of `id` is one of
    the contact points with the database. Mongo creates a hash to represent a synthetic
    ID; whereas, MySQL usually creates an integer that auto-increments to uniquely
    identify each record. Given that, if we want to switch MongoDB to MySQL in one
    of our apps, the first problem that we need to solve is how to map a hash that
    looks something similar to the following into an ordinal number:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 棘手的部分是`id`是如何生成的。生成`id`是与数据库联系的一个接触点。Mongo创建一个哈希来表示合成ID；而MySQL通常创建一个整数，自动增加以唯一标识每条记录。鉴于此，如果我们想要在我们的应用程序中将MongoDB切换到MySQL，我们需要解决的第一个问题是如何将类似以下内容的哈希映射为序数：
- en: '`e777d434a849760a1303b7f9f989e33a`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`e777d434a849760a1303b7f9f989e33a`'
- en: In 99% of the cases, this is fine, but we need to be careful, especially when
    storing IDs as, if you recall from the previous chapters, the data should be local
    to each microservice, which could imply that changing the data type of the ID
    of one entity, requires changing the referenced ID in all the other databases.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在99%的情况下，这是可以的，但我们需要小心，特别是在存储ID时，如果你还记得前面的章节，数据应该是每个微服务本地的，这可能意味着更改一个实体的ID数据类型，需要在所有其他数据库中更改引用的ID。
- en: Adding a product
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加产品
- en: 'Adding a product is trivial. We just need to create the data and save it in
    the database:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 添加产品是微不足道的。我们只需要创建数据并将其保存在数据库中：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this method, we are using a helper from Seneca, `products.data$(false)`.
    This helper will allow us to retrieve the data of the entity without all the metadata
    about namespace (zone), entity name, and base name that we are not interested
    in when the data is returned to the calling method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们使用了Seneca的一个辅助函数`products.data$(false)`。这个辅助函数允许我们检索实体的数据，而不包括当数据返回给调用方法时我们不感兴趣的有关命名空间（区域）、实体名称和基本名称的所有元数据。
- en: Removing a product
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除产品
- en: 'The removal of a product is usually done by `id`: We target the specific data
    that we want to remove by the primary key and then remove it, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过`id`来删除产品：我们通过主键定位要删除的特定数据，然后将其删除，如下所示：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, we don't return anything aside from an error if something goes
    wrong, so the endpoint that calls this action can assume that a non-errored response
    is a success.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，除了在出现问题时返回错误之外，我们不返回任何东西，因此调用此操作的端点可以假定非错误响应是成功的。
- en: Editing a product
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑产品
- en: 'We need to provide an action to edit products. The code for doing that is as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个操作来编辑产品。做到这一点的代码如下：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here is an interesting scenario. Before editing a product, we need to fetch
    it by ID, and we have already done that. So, what we are doing here is relying
    on the already existing action to retrieve a product by ID, copying the data across,
    and saving it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的场景。在编辑产品之前，我们需要通过ID获取它，我们已经做到了。所以，我们在这里所做的是依赖已经存在的操作来通过ID检索产品，复制数据，并保存它。
- en: This is a nice way for code reuse introduced by Seneca, where you can delegate
    a call from one action to another and work in the wrapper action with the result.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Seneca引入的代码重用的一种好方法，你可以将一个动作的调用委托给另一个动作，并在包装动作中处理结果。
- en: Wiring everything up
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一切连接起来
- en: 'As we agreed earlier, the product manager is going to have two faces: one that
    will be exposed to other microservices using the Seneca transport over TCP and
    a second one exposed through Express (a Node.js library to create web apps) in
    the REST way.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前商定的，产品经理将有两个面孔：一个将通过Seneca传输TCP暴露给其他微服务，另一个将通过Express（一个用于创建Web应用程序的Node.js库）以REST方式暴露。
- en: 'Let''s wire everything together:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把一切都连接起来：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s explain the code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解释一下代码：
- en: We have created a Seneca plugin. This plugin can be reused across different
    microservices. This plugin contains all the definitions of methods needed by our
    microservice that we have previously described.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个Seneca插件。这个插件可以在不同的微服务之间重复使用。这个插件包含了我们之前描述的微服务所需的所有方法的定义。
- en: 'The preceding code describes the following two sections:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码描述了以下两个部分：
- en: The first few lines connect to Mongo. In this case, we are specifying that Mongo
    is a local database. We are doing that through the use of a plugin called mongo-store—[https://github.com/rjrodger/seneca-mongo-store](https://github.com/rjrodger/seneca-mongo-store),
    written by Richard Rodger, the author of Seneca.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前几行连接到Mongo。在这种情况下，我们指定Mongo是一个本地数据库。我们通过一个名为mongo-store的插件来实现这一点- [https://github.com/rjrodger/seneca-mongo-store](https://github.com/rjrodger/seneca-mongo-store)，由Seneca的作者Richard
    Rodger编写。
- en: The second part is new to us. It might sound familiar if you have used JQuery
    before, but basically what the `seneca.ready()` callback is doing is taking care
    of the fact that Seneca might not have connected to Mongo before the calls start
    flowing into its API. The `seneca.ready()` callback is where the code for integrating
    Express with Seneca lives.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分对我们来说是新的。如果你以前使用过JQuery，这可能听起来很熟悉，但基本上`seneca.ready()`回调所做的是处理Seneca在调用开始流入其API之前可能尚未连接到Mongo的事实。`seneca.ready()`回调是整合Express与Seneca的代码所在的地方。
- en: 'The following is the `package.json` configuration of our app:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们应用程序的`package.json`配置：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we control all the libraries needed for our microservice to run, as well
    as the configuration.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们控制了微服务运行所需的所有库，以及配置。
- en: Integrating with Express – how to create a REST API
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Express集成-如何创建REST API
- en: 'Integrating with Express is quite straightforward. Let''s take a look at the
    code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与Express集成非常简单。让我们看一下代码：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code snippet, as we''ve seen in the preceding section, provides the following
    three REST endpoints:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中看到的代码片段提供了以下三个REST端点：
- en: '`/products/fetch`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`/products/fetch`'
- en: '`/products/edit`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`/products/edit`'
- en: '`/products/delete`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`/products/delete`'
- en: Let's explain how.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下。
- en: 'First, what we do is tell Seneca to execute the `role:web` action, indicating
    the configuration. This configuration specifies to use a `/products` prefix for
    all the URLs, and it pins the action with a matching `{area: "product", action:
    "*"}` pattern. This is also new for us, but it is a nice way to specify to Seneca
    that whatever action it executes in the URL, it will have implicit `area: "product"`
    of the handler. This means that `/products/fetch` endpoint will correspond to
    the `{area: ''products'', action: ''fetch''}` pattern. This could be a bit difficult,
    but once you get used to it, it is actually really powerful. It does not force
    `use` to fully couple our actions with our URLs by conventions.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们告诉Seneca执行`role:web`操作，指示配置。此配置指定为所有URL使用`/products`前缀，并将动作与匹配的`{area:
    "product", action: "*"}`模式固定。这对我们来说也是新的，但这是一种很好的方式，可以告诉Seneca无论它在URL中执行什么操作，它都将具有处理程序的隐式`area:
    "product"`。这意味着`/products/fetch`端点将对应于`{area: ''products'', action: ''fetch''}`模式。这可能有点困难，但一旦你习惯了，它实际上非常强大。它不会强迫`use`通过约定将我们的动作与我们的URL完全耦合。'
- en: 'In the configuration, the attribute map specifies the HTTP actions that can
    be executed over an endpoint: fetch will allow `GET`, edit will allow `PUT`, and
    delete will only allow `DELETE`. This way, we can control the semantics of the
    application.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中，属性映射指定了可以在端点上执行的HTTP操作：fetch将允许`GET`，edit将允许`PUT`，delete将只允许`DELETE`。这样，我们可以控制应用程序的语义。
- en: 'Everything else is probably familiar to you. Create an Express app and specify
    using the following two plugins:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切对你来说可能都很熟悉。创建一个Express应用程序，并指定使用以下两个插件：
- en: The JSON body parser
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON body解析器
- en: The Seneca web plugin
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Seneca web插件
- en: This is all. Now, if we add a new action to our Seneca list of actions in order
    to expose it through the API, the only thing that needs to be done is to modify
    the map attribute to allow HTTP methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，如果我们向Seneca的动作列表中添加一个新的动作，以便通过API公开它，唯一需要做的就是修改映射属性以允许HTTP方法。
- en: Although we have built a very simplistic microservice, it captures a big portion
    of the common patterns that you find when creating a **CRUD** (**Create Read Update
    Delete**) application. We have also created a small REST API out of a Seneca application
    with little to no effort. All we need to do now is configure the infrastructure
    (MongoDB) and we are ready to deploy our microservice.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们构建了一个非常简单的微服务，但它捕获了创建**CRUD**（**创建读取更新删除**）应用程序时发现的常见模式的很大一部分。我们还从Seneca应用程序中轻松地创建了一个小型REST
    API。现在我们只需要配置基础设施（MongoDB），我们就可以部署我们的微服务了。
- en: The e-mailer – a common problem
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件发送器-一个常见的问题
- en: E-mailing is something that every company needs to do. We need to communicate
    with our customers in order to send notifications, bills, or registration e-mails.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件是每家公司都需要做的事情。我们需要与客户沟通，以便发送通知、账单或注册电子邮件。
- en: In the companies where I've worked before, e-mailing always presented a problem
    such as e-mails not being delivered, or being delivered twice, with the wrong
    content to the wrong customer, and so on. It looks terrifying that something as
    simple as sending an e-mail could be this complicated to manage.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我之前工作过的公司里，发送电子邮件总是出现问题，比如电子邮件无法投递，或者投递两次，内容错误地发送给错误的客户，等等。看起来像是发送电子邮件这样简单的事情竟然如此复杂。
- en: 'In general, e-mail communication is the first candidate to write a microservice.
    Think about it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，电子邮件通信是编写微服务的第一个候选者。想想看：
- en: E-mail does one thing
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件只做一件事
- en: E-mail does it well
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件做得很好
- en: E-mail keeps its own data
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件保留自己的数据
- en: It is also a good example of how the *Conway's law* kicks into our systems without
    being noticed. We design our systems modeling the existing communication in our
    company as we are constrained by it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是*康威定律*如何在我们的系统中不被注意地发挥作用的一个很好的例子。我们设计我们的系统，模拟公司内部的现有通信，因为我们受到了它的限制。
- en: How to send e-mails
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何发送电子邮件
- en: Back to the basics. How do we send e-mails? I am not talking about which network
    protocol we use for sending the e-mail or what are the minimum acceptable headers?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回到基础。我们如何发送电子邮件？我不是在谈论我们用于发送电子邮件的网络协议或者最低可接受的标头是什么？
- en: 'I am talking about what we need to send an e-mail from the business point of
    view:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我在谈论从业务角度发送电子邮件所需的内容：
- en: A title
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题
- en: The content
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容
- en: A destination address
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的地地址
- en: 'That is everything. We could have gone far, talking about acknowledgements,
    secure e-mail, BCCs, and so on. However, we are following the lean methodology:
    start with the minimum viable product and build up from it until you achieve the
    desired result.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部。我们本可以深入讨论确认、安全电子邮件、密件抄送等等。然而，我们遵循精益方法论：从最小可行产品开始，然后逐步构建，直到达到期望的结果。
- en: I can't remember a project where the e-mail sending wasn't a controversial part.
    The product chosen to deliver e-mails ends up tightly coupled to the system and
    it is really hard to replace it seamlessly. However, microservices are here to
    rescue us.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我记不得有哪个项目中，电子邮件发送不是一个有争议的部分。选择用于发送电子邮件的产品最终会与系统紧密耦合，很难无缝替换。然而，微服务来拯救我们。
- en: Defining the interface
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义接口
- en: 'As I mentioned before, although it sounds easy, sending corporate e-mails could
    end up being a mess. Therefore, the first thing we need to clear is our minimum
    requirements:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，尽管听起来很容易，发送企业电子邮件可能最终会变得一团糟。因此，我们需要澄清的第一件事是我们的最低要求：
- en: How do we render the e-mail?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何渲染电子邮件？
- en: Does rendering the email belongs to the bound context of the email manipulation?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染电子邮件是否属于电子邮件操作的绑定上下文？
- en: Do we create another microservice to render e-mails?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否创建另一个微服务来渲染电子邮件？
- en: Do we use a third party to manage the e-mails?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否使用第三方来管理电子邮件？
- en: Do we store the already sent e-mails for auditing purposes?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否存储已发送的电子邮件以进行审计？
- en: For this microservice, we are going to use Mandrill. Mandrill is a company that
    allows us to send corporate e-mails, track the already sent e-mails, and create
    e-mail templates that can be edited online.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个微服务，我们将使用Mandrill。Mandrill是一家允许我们发送企业电子邮件、跟踪已发送电子邮件并创建可在线编辑的电子邮件模板的公司。
- en: 'Our microservice is going to look as shown in the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的微服务将如下所示： '
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have two patterns: one that makes use of templates and the other that sends
    the content contained in the request.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种模式：一种使用模板，另一种发送请求中包含的内容。
- en: As you can see, everything that we have defined here is information related
    to e-mailing. There is no bleeding from the Mandrill terminology into what the
    other microservices see in our e-mail sending. The only compromise that we are
    making is the templating. We are delegating the template rendering to the e-mail
    sender, but it is not a big deal, as even if we walk away from Mandrill, we will
    need to render the content somehow.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在这里定义的一切都是与电子邮件相关的信息。Mandrill的术语没有渗入到其他微服务在我们发送电子邮件时看到的内容中。我们唯一做出的妥协是模板化。我们将模板渲染委托给了电子邮件发送者，但这并不是什么大问题，因为即使我们离开Mandrill，我们也需要以某种方式渲染内容。
- en: We will come back to the code later.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回到代码。
- en: Setting up Mandrill
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Mandrill
- en: Mandrill is fairly easy to use and shouldn't be a problem to set up. However,
    we are going to use the test mode so that we can assure that the e-mails are not
    going to be delivered and we can access the API for all our needs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Mandrill使用起来相当简单，不应该是一个设置问题。然而，我们将使用测试模式，以确保电子邮件不会被投递，并且我们可以访问API满足我们的所有需求。
- en: 'The first thing we need to do is create an account on Mandrill. Just register
    with your e-mail at [https://mandrillapp.com](https://mandrillapp.com), and you
    should be able to access to it, as shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在Mandrill上创建一个账户。只需使用您的电子邮件在[https://mandrillapp.com](https://mandrillapp.com)注册，然后您应该能够访问它，如下面的截图所示：
- en: '![Setting up Mandrill](img/B04889_04_02.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![设置Mandrill](img/B04889_04_02.jpg)'
- en: Now we have created an account that we need to enter into the test mode. In
    order to do it, just click on your e-mail at the top-right corner and select the
    **Turn on the test mode** option from the menu. The Mandrill menu on the left
    will turn orange now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个账户，我们需要进入测试模式。为了做到这一点，只需点击右上角的电子邮件，然后从菜单中选择**打开测试模式**选项。左侧的Mandrill菜单现在会变成橙色。
- en: 'Next, we need to create an API key. This key is the login information to be
    used by the Mandrill API. Just click on **Settings** and **SMTP & API Info** and
    add a new key (don''t forget the checkbox to mark the key as test key). It should
    look like the following screenshot now:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个API密钥。这个密钥是Mandrill API要使用的登录信息。只需点击**设置**和**SMTP & API信息**，然后添加一个新密钥（不要忘记勾选将密钥标记为测试密钥的复选框）。现在它应该看起来像下面的截图：
- en: '![Setting up Mandrill](img/B04889_04_03.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![设置Mandrill](img/B04889_04_03.jpg)'
- en: 'The key is everything you need for now. Let''s test the API:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是现在你所需要的一切。让我们测试API：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With these few lines, we have managed to test that Mandrill is up and running
    and we have a valid key. The output of this program should be something very similar
    to the following JSON:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这几行，我们已经成功测试了Mandrill是否正常运行，并且我们有一个有效的密钥。此程序的输出应该与以下JSON非常相似：
- en: '![Setting up Mandrill](img/B04889_04_10.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![设置Mandrill](img/B04889_04_10.jpg)'
- en: Hands on – integrating Mandrill in your microservice
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践操作-将Mandrill集成到您的微服务中
- en: 'Everything is ready now. We have a working key and our interface. The only
    thing left is to create the code. We are going to use a small part of the Mandrill
    API, but if you want to make use of other features, you can find a better description
    here: [https://mandrillapp.com/api/docs/](https://mandrillapp.com/api/docs/)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪。我们有一个有效的密钥和我们的接口。唯一剩下的就是创建代码。我们将使用Mandrill API的一小部分，但如果您想使用其他功能，可以在这里找到更好的描述：[https://mandrillapp.com/api/docs/](https://mandrillapp.com/api/docs/)
- en: 'Let''s take a look at the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This first method sends messages without using a template. We just get the HTML
    content (and a few other parameters) from our application and deliver it through
    Mandrill.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第一种方法发送消息而不使用模板。我们只需从我们的应用程序获取HTML内容（和其他一些参数），然后通过Mandrill传递它。
- en: 'As you can see, we only have two contact points with the outer world: the parameters
    passed in and the return of our actions. Both of them have a clear contract that
    has nothing to do with Mandrill, but what about the data?'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只与外部世界有两个接触点：传递的参数和我们操作的返回。它们两者都有一个清晰的合同，与Mandrill无关，但数据呢？
- en: At the error, we are returning `e.name`, assuming that it is a code. At some
    point, someone will end up branching the flow depending on this **error code**.
    Here, we have something called data coupling; our software components don't depend
    on the contract, but they do depend on the content sent across.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误时，我们返回`e.name`，假设它是一个代码。在某个时候，某人最终会根据这个**错误代码**分支流程。在这里，我们有一种称为数据耦合的东西；我们的软件组件不依赖于合同，但它们确实依赖于发送的内容。
- en: 'Now, the question is: how do we fix it? *We can''t*. At least not in an easy
    way. We need to assume that our microservice is not perfect, it has a flaw. If
    we switch provider for e-mailing, we are going to need to revisit the calling
    code to check potential couplings.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是：我们该如何修复它？*我们不能*。至少不是一种简单的方式。我们需要假设我们的微服务不完美，它有一个缺陷。如果我们切换电子邮件提供商，我们将需要重新审视调用代码，以检查潜在的耦合。
- en: 'In the world of software, in every single project that I''ve worked on before,
    there was always a big push trying to make the code as generic as possible, trying
    to guess the future, which usually could be as bad as assuming that your microservice
    won''t be perfect. There is something that always attracted my attention: we put
    a large amount of effort in to perfection, but we pretty much ignore the fact
    that we are going to fail and we do can nothing about it. Software fails often
    and we need to be prepared for that.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件世界中，在我以前参与的每个项目中，总是有一个大力推动的努力，试图使代码尽可能通用，试图猜测未来，通常情况下可能像假设您的微服务不会完美一样糟糕。总是吸引我的注意的是：我们在追求完美上投入了大量的努力，但我们几乎忽略了我们将会失败，而且我们对此无能为力。软件经常失败，我们需要为此做好准备。
- en: 'Later, we will see a pattern to factor human nature into the microservices:
    **the circuit breaker**.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将看到一种将人类因素纳入微服务的模式：**断路器**。
- en: Don't be surprised if Mandrill rejects the e-mails due to the *unsigned* reason.
    This is due to the fact that they couldn't validate the domain from where we are
    sending the e-mail (in this case, a dummy domain that does not exist). If we want
    Mandrill to actually process the e-mails (even though we are in test mode), we
    just need to verify our domain by adding some configuration to it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Mandrill因*未签名*原因拒绝电子邮件，请不要感到惊讶。这是因为他们无法验证我们发送电子邮件的域（在这种情况下，一个不存在的虚拟域）。如果我们希望Mandrill实际处理电子邮件（即使我们处于测试模式），我们只需要通过添加一些配置来验证我们的域。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information can be found in the Mandrill documentation here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在Mandrill文档中找到：
- en: '[https://mandrillapp.com/api/docs/](https://mandrillapp.com/api/docs/)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mandrillapp.com/api/docs/](https://mandrillapp.com/api/docs/)'
- en: 'The second method to send e-mails is send an e-mail from a template. In this
    case, Mandrill provides a flexible API:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件的第二种方法是从模板发送电子邮件。在这种情况下，Mandrill提供了灵活的API：
- en: It provides per-recipient variables in case we send the e-mail to a list of
    customers
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为每个收件人提供变量，以防我们将电子邮件发送给客户列表
- en: It has global variables
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有全局变量
- en: It allows content replacement (we can replace a full section)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许内容替换（我们可以替换整个部分）
- en: For convenience, we are going to just use global variables as we are limited
    on space in this book.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将只使用全局变量，因为在这本书中我们的空间有限。
- en: 'Let''s take a look at the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we can create our templates in Mandrill (and let someone else to manage
    them) and we are able to use them to send e-mails. Again, we are specializing.
    Our system specializes in sending e-mails and you leave the creation of the e-mails
    to someone else (maybe someone from the marketing team who knows how to talk to
    customers).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在Mandrill中创建我们的模板（并让其他人来管理它们），并且我们可以使用它们来发送电子邮件。再次强调，我们正在专门化。我们的系统专门用于发送电子邮件，您可以将电子邮件的创建留给其他人（也许是来自了解如何与客户交流的营销团队的人）。
- en: 'Let''s analyze this microservice:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个微服务：
- en: '**Data is stored locally**: Not really (it is stored in Mandrill), but from
    the design point of view, it is'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储在本地**：实际上并非如此（它存储在Mandrill中），但从设计的角度来看，是这样的'
- en: '**Our microservice is well cohesioned**: It sends only e-mails; it does one
    thing, and does it well'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的微服务具有良好的内聚性**：它只发送电子邮件；它只做一件事，并且做得很好'
- en: '**The size of the microservice is correct**: It can be understood in a few
    minutes, it does not have unnecessary abstractions and can be rewritten fairly
    easily'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务的大小是正确的**：可以在几分钟内理解，没有不必要的抽象，可以相当容易地重写'
- en: When we talked about the SOLID design principles earlier, we always skipped
    L, which stands for **Liskov Substitution**. Basically, this means that the software
    has to be semantically correct. For example, if we write an object-oriented program
    that handles one abstract class, the program has to be able to handle all the
    subclasses.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前谈到SOLID设计原则时，我们总是跳过了L，它代表**Liskov替换**。基本上，这意味着软件必须在语义上是正确的。例如，如果我们编写一个处理一个抽象类的面向对象程序，那么程序必须能够处理所有子类。
- en: Coming back to Node.js, if our service is able to handle sending a plain e-mail,
    it should be easy to extend and add capabilities without modifying the existing
    ones.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Node.js，如果我们的服务能够处理发送普通电子邮件，那么在不修改现有功能的情况下扩展和添加功能应该很容易。
- en: Think about it from the day-to-day production operations point of view; if a
    new feature is added to your system, the last thing you want to do is retest the
    existing functionalities or even worse, deliver the feature to production, introducing
    a bug that no one was aware of.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从日常生产运营的角度来考虑一下；如果系统添加了新功能，你最不想做的就是重新测试现有功能，甚至更糟糕的是将新功能交付到生产环境中，引入了没有人意识到的错误。
- en: Let's create a use case. We want to send the same e-mail to two recipients.
    Although Mandrill API allows the calling code to do it, we haven't factored in
    a potential CC.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用例。我们想将同一封电子邮件发送给两个收件人。虽然Mandrill API允许调用代码这样做，但我们没有考虑到潜在的抄送。
- en: 'Therefore, we are going to add a new action in Seneca that allows us to do
    it, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在Seneca中添加一个新的操作，允许我们这样做，如下所示：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have instructed Seneca to take the calls that include `cc` in the list of
    parameters and send them using a Mandrill CC in the send API. If we want to use
    it, the following signature of the calling code will change:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指示Seneca接受包含`cc`在参数列表中的调用，并使用Mandrill CC发送它们到发送API。如果我们想使用它，调用代码的以下签名将会改变：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The signature will change to the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 签名将更改为以下代码：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you remember correctly, the pattern matching tries to match the most concrete
    input so that if an action matches with more parameters than another one, the
    call will be directed to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得的话，模式匹配会尝试匹配最具体的输入，所以如果一个操作与另一个操作相比具有更多的参数匹配，调用将被定向到它。
- en: 'Here is where Seneca shines: We can call it **polymorphism of actions**, as
    we can define different versions of the same action with different parameters
    that end up doing slightly different things and enabling us to reutilize the code
    if we are 100% sure that this is the right thing to do (remember, microservices
    enforce the share-nothing approach: repeating the code might not be as bad as
    coupling two actions).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Seneca的亮点所在：我们可以称之为**操作的多态性**，因为我们可以定义相同操作的不同版本，使用不同的参数，最终做一些略有不同的事情，并且使我们能够重用代码，如果我们100%确定这样做是正确的（记住，微服务强制执行无共享的方法：重复代码可能不像耦合两个操作那样糟糕）。
- en: 'Here is the `package.json` for the e-mailer microservice:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是电子邮件微服务的`package.json`：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The fallback strategy
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备用策略
- en: When you design a system, usually we think about replaceability of the existing
    components; for example, when using a persistence technology in Java, we tend
    to lean towards standards (**JPA**) so that we can replace the underlying implementation
    without too much effort.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计一个系统时，通常我们会考虑现有组件的可替换性；例如，在Java中使用持久化技术时，我们倾向于倾向于标准（**JPA**），这样我们就可以在不太费力的情况下替换底层实现。
- en: Microservices take the same approach, but they isolate the problem instead of
    working towards an easy replaceability. If you read the preceding code, inside
    the Seneca actions, we have done nothing to hide the fact that we are using Mandrill
    to send the e-mails.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务采用相同的方法，但是它们隔离了问题，而不是朝着易于替换的方向努力。如果你读过前面的代码，在Seneca操作中，我们没有隐藏我们正在使用Mandrill发送电子邮件的事实。
- en: As I mentioned before, e-mailing is something that, although seems simple, always
    ends up giving problems.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，发送电子邮件是一件看似简单，但总是会出现问题的事情。
- en: Imagine that we want to replace Mandrill for a plain SMTP server such as Gmail.
    We don't need to do anything special, we just change the implementation and roll
    out the new version of our microservice.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想要用普通的SMTP服务器（如Gmail）替换Mandrill。我们不需要做任何特殊的事情，我们只需更改实现并发布我们微服务的新版本。
- en: 'The process is as simple as applying the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程就像应用以下代码一样简单：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the outer world, our simplest version of the e-mail sender is now using
    SMTP through Gmail to deliver our e-mails.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对外界来说，我们最简单的电子邮件发送器现在使用Gmail通过SMTP来发送我们的电子邮件。
- en: As we will see later in the book, delivering a new version of the same interface
    in a microservice network is fairly easy; as long as we respect the interface,
    the implementation should be irrelevant.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本书后面看到的那样，在微服务网络中交付同一接口的新版本是相当容易的；只要我们尊重接口，实现就应该是无关紧要的。
- en: We could even roll out one server with this new version and send some traffic
    to it in order to validate our implementation without affecting all the customers
    (in other words, contain the failure).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以发布一个具有这个新版本的服务器，并将一些流量发送到它，以验证我们的实现，而不影响所有客户（换句话说，包含故障）。
- en: We have seen how to write an e-mail sender in this section. We have worked through
    a few examples on how our microservice can be adapted quickly for new requirements
    as soon as the business requires new capabilities or we decide that our vendor
    is not good enough to cope with our technical requirements.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在本节中编写电子邮件发送器。我们已经通过了一些示例，说明了我们的微服务如何可以快速适应新的需求，只要业务需要新的功能，或者我们决定我们的供应商无法满足我们的技术需求。
- en: The order manager
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单管理器
- en: The order manager is a microservice that processes the orders that the customer
    places through the UI. As you probably remember, we are not going to create a
    sophisticated single-page application with a modern visual framework, as it is
    out of the scope of this book, but we are going to provide the JSON interface
    in order to be able to build the front end later.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 订单管理器是一个处理顾客通过UI下订单的微服务。你可能还记得，我们不会创建一个复杂的单页应用程序，使用现代的视觉框架，因为这超出了本书的范围，但我们会提供JSON接口，以便能够稍后构建前端。
- en: 'Order manager introduces an interesting problem: this microservice needs access
    to the information about products, such as name, price, availability, and so on.
    However, it is stored in the product manager microservice, so how do we do that?'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 订单管理器引入了一个有趣的问题：这个微服务需要访问有关产品的信息，比如名称、价格、可用性等。然而，这些信息存储在产品管理器微服务中，那么我们该怎么做呢？
- en: Well, the answer for this question might look simple, but requires a bit of
    thinking.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这个问题的答案看起来很简单，但需要一点思考。
- en: Defining the microservice – how to gather non-local data
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义微服务-如何收集非本地数据
- en: 'Our microservice will need to do the following three things:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微服务需要做以下三件事：
- en: Recover orders
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复订单
- en: Create orders
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建订单
- en: Delete existing orders
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除现有订单
- en: When recovering an order, the option is going to be simple. Recover the order
    by the primary key. We could extend it to recover orders by different criteria,
    such as price, date, and so on, but we are going to keep it simple as we want
    to focus on microservices.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复订单时，选项会很简单。通过主键恢复订单。我们可以将其扩展为通过不同的标准恢复订单，比如价格、日期等，但我们会保持简单，因为我们想专注于微服务。
- en: 'When deleting existing orders, the option is also clear: use the ID to delete
    orders. Again, we could choose a more advanced deletion criteria, but we want
    to keep it simple.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除现有订单时，选项也很明确：使用ID删除订单。同样，我们可以选择更高级的删除标准，但我们想保持简单。
- en: 'The problem arises when we are trying to create orders. Creating an order in
    our small microservice architecture means sending an e-mail to the customer, specifying
    that we are processing their order, along with the details of the order, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图创建订单时问题就出现了。在我们小的微服务架构中创建订单意味着向顾客发送一封电子邮件，说明我们正在处理他们的订单，以及订单的详细信息，如下所示：
- en: Number of products
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品数量
- en: Price per product
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种产品的价格
- en: Total price
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总价
- en: Order ID (in case the customer needs to troubleshoot problems with the order)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单ID（以防顾客需要解决订单问题）
- en: How do we recover the product details?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何恢复产品详情？
- en: 'If you see our diagram shown in the *Micromerce – the big picture* section
    of this chapter, order manager will only be called from the UI, which will be
    responsible to recover the product name, its price, and so on. We could adopt
    the following two strategies here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到我们在本章的“微服务-大局”部分中展示的图表，订单管理器只会从UI调用，UI将负责恢复产品名称、价格等信息。在这里我们可以采取以下两种策略：
- en: Order manager calls product manager and gets the details
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单管理器调用产品管理器并获取详情
- en: UI calls product manager and delegates the data to the order manager
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI调用产品管理器并将数据委托给订单管理器
- en: 'Both options are totally valid, but in this case, we are going for the second:
    UI will gather the information needed to generate an order and it will only call
    the order manager when all the data required is available.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 两个选项都是完全有效的，但在这种情况下，我们选择第二个：UI将收集生成订单所需的信息，只有在所有所需的数据可用时才会调用订单管理器。
- en: 'Now to answer the question: why?'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来回答这个问题：为什么？
- en: 'A simple reason: failure tolerance. Let''s take a look at the following sequence
    diagram of the two options:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的原因：故障容忍。让我们来看看两个选项的以下序列图：
- en: '![Defining the microservice – how to gather non-local data](img/B04889_04_04.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![定义微服务-如何收集非本地数据](img/B04889_04_04.jpg)'
- en: 'The diagram for the second option is shown as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项的图表如下所示：
- en: '![Defining the microservice – how to gather non-local data](img/B04889_04_05.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![定义微服务-如何收集非本地数据](img/B04889_04_05.jpg)'
- en: 'In the first view, there is a big difference: the depth of the call; whereas
    in the first example, we have two levels of depth (UI calls the order manager,
    which calls the product manager). In the second example, we have only one level
    of depth. There are a few immediate effects in our architecture, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个视图中，有一个很大的区别：调用的深度；而在第一个例子中，我们有两层深度（UI调用订单管理器，订单管理器调用产品管理器）。在第二个例子中，我们只有一层深度。在我们的架构中有一些即时的影响，如下所示：
- en: When something goes wrong, if we only have one level of depth, we don't need
    to check in too many places.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当出现问题时，如果我们只有一层深度，我们就不需要在太多地方检查。
- en: We are more resilient. If something goes wrong, it is the UI of the microservice
    that notices it, returning the appropriate HTTP code, in this case, without having
    to translate the errors that occurred a few levels above the client-facing microservice.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更具弹性。如果出现问题，是微服务的UI注意到了它，返回适当的HTTP代码，这样就不需要将发生在客户端微服务几层以上的错误进行转换。
- en: It is easier to deploy and test. Not much easier, but we don't need to juggle
    around, we can see straight away if the product manager is reached from the UI,
    instead of having to go through the order manager.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和测试更容易。并不是非常容易，但我们不需要到处搞，我们可以立即看到产品管理器是否从UI中被调用，而不需要通过订单管理器。
- en: 'The fact that we are using this architecture instead of the two-level depth
    does not mean that it isn''t appropriate for another situation: the network topology
    is something that you need to plan ahead if you are creating a microservices-oriented
    architecture, as it is one of the hardest aspects to change.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这种架构而不是两层深度的架构，并不意味着它不适用于其他情况：网络拓扑是你需要提前规划的东西，如果你正在创建一个面向微服务的架构，因为这是最难改变的方面之一。
- en: In some cases, if we want to be extremely flexible, we can use a messaging queue
    with publisher/subscriber technology where our microservices can subscribe to
    different types of messages and emit others to be consumed by a different service,
    but it could complicate the infrastructure that we need to put in place to avoid
    single point of failures.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果我们想要非常灵活，我们可以使用发布者/订阅者技术的消息队列，其中我们的微服务可以订阅不同类型的消息并发出其他消息供不同的服务消费，但这可能会使我们需要构建的基础设施变得复杂，以避免单点故障。
- en: The order manager – the code
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订单管理器 - 代码
- en: 'Let''s take a look at the code for the order manager:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看订单管理器的代码：
- en: '[PRE19]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, there is nothing complicated about the code. The only interesting
    point is the missing code from the create action.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码并不复杂。唯一有趣的地方是创建操作中缺失的代码。
- en: Calling remote services
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用远程服务
- en: Until now, we have assumed that all our microservices run in the same machine,
    but that is far from ideal. In the real world, microservices are distributed and
    we need to use some sort of transport protocol to carry the message from one service
    to another.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设所有的微服务都在同一台机器上运行，但这远非理想。在现实世界中，微服务是分布式的，我们需要使用某种传输协议来将消息从一个服务传递到另一个服务。
- en: Seneca, as well as nearForm, the company behind Seneca, has sorted this problem
    for us and the open source community around it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca以及Seneca背后的nearForm公司已经为我们解决了这个问题，以及围绕它的开源社区。
- en: As a modular system, Seneca has embedded the concept of plugin. By default,
    Seneca comes with a bundled plugin to use TCP as the protocol, but it is not hard
    to create a new transport plugin.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个模块化系统，Seneca内置了插件的概念。默认情况下，Seneca带有一个捆绑的插件来使用TCP作为协议，但创建一个新的传输插件并不难。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'While writing this book, I created one by myself: [https://github.com/dgonzalez/seneca-nservicebus-transport/](https://github.com/dgonzalez/seneca-nservicebus-transport/)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这本书的时候，我自己创建了一个：[https://github.com/dgonzalez/seneca-nservicebus-transport/](https://github.com/dgonzalez/seneca-nservicebus-transport/)
- en: With this plugin, we could route the Seneca messages through NServiceBus (a
    .NET-based Enterprise Bus), changing the configuration of our client and server.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个插件，我们可以通过NServiceBus（一个基于.NET的企业总线）路由Seneca消息，改变我们的客户端和服务器的配置。
- en: 'Let''s see how to configure Seneca to point to a different machine:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何配置Seneca指向不同的机器：
- en: '[PRE20]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By default, Seneca will use the default plugin for transport, which as we've
    seen in [Chapter 2](ch02.html "Chapter 2. Microservices in Node.js – Seneca and
    PM2 Alternatives"), *Microservices in Node.js – Seneca and PM2 Alternatives*,
    is `tcp`, and we have specified it to point to the `192.168.0.2` host on the `8080`
    port.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Seneca将使用默认的传输插件，正如我们在[第2章](ch02.html "第2章。Node.js中的微服务-Seneca和PM2替代方案")中所看到的，*Node.js中的微服务-Seneca和PM2替代方案*，是`tcp`，我们已经指定它指向`192.168.0.2`主机的`8080`端口。
- en: As simple as that, from now on, when we execute an act command on `senecaEmailer`,
    the transport will send the message across to the e-mailer and receives the response.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单，从现在开始，当我们在`senecaEmailer`上执行一个动作命令时，传输将把消息发送到邮件发送器并接收响应。
- en: 'Let''s see the rest of the code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看剩下的代码：
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we are receiving a list of products with all the data needed
    and passing them to the e-mailer to render the e-mail.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们收到了一个包含所有所需数据的产品列表，并将它们传递给邮件发送器以渲染邮件。
- en: If we change the host where the e-mailer lives, the only change that we need
    to do here is the configuration of the `senecaEmailer` variable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改邮件发送器所在的主机，这里唯一需要做的更改就是`senecaEmailer`变量的配置。
- en: Even if we change the nature of the channel (we could potentially even write
    a plugin to send the data over Twitter, for example), the plugin should look after
    the particularities of it and be transparent for the application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们改变了通道的性质（例如，我们甚至可以编写一个插件将数据发送到Twitter），插件也应该处理它的特殊性并对应用程序透明。
- en: Resilience over perfection
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 韧性胜过完美
- en: 'In the example from the preceding section, we built a microservice that calls
    another microservice in order to resolve the call that it receives. However, the
    following points need to be kept in mind:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节的示例中，我们构建了一个微服务，调用另一个微服务来解决它接收到的调用。然而，需要记住以下几点：
- en: What happens if the e-mailer is down?
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果邮件发送器宕机会发生什么？
- en: What happens if the configuration is wrong and the e-mailer is not working on
    the correct port?
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果配置错误，邮件发送器在正确的端口上无法工作会发生什么？
- en: We could be throwing *what ifs* for few pages.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为几页纸写下“如果”。
- en: Humans are imperfect and so are the things that they build, and software is
    not an exception. Humans are also bad at recognizing the potential problems in
    logical flows, and software tends to be a complex system.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 人类是不完美的，他们建造的东西也是如此，软件也不例外。人类也很难识别逻辑流程中的潜在问题，而软件往往是一个复杂的系统。
- en: 'In other languages, playing with exceptions is almost something normal, but
    in JavaScript, exceptions are a big deal:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，处理异常几乎是很正常的事情，但在JavaScript中，异常是一件大事：
- en: If an exception bubbles out in a web app in Java, it kills the current stack
    of calls and Tomcat (or the container that you use) returns an error to the client
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在Java的Web应用程序中出现异常，它会终止当前的调用堆栈，Tomcat（或您使用的容器）会向客户端返回错误。
- en: If an exception bubbles out in a Node.js app, the application is killed as we
    only have one thread executing the app
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在Node.js应用程序中出现异常，应用程序会被终止，因为我们只有一个线程执行应用程序。
- en: As you can see, pretty much every single callback in Node.js has a first parameter
    that is an error.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Node.js中几乎每个回调都有一个作为错误的第一个参数。
- en: When talking about microservices, this error is especially important. You want
    to be resilient. The fact that an e-mail has failed sending does not mean that
    the order cannot be processed, but the e-mail could be manually sent later by
    someone reprocessing the data. This is what we call eventual consistency; we factor
    into our system the fact that at some point our system is going to crash.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论微服务时，这种错误尤为重要。你希望具有弹性。电子邮件发送失败并不意味着订单无法处理，但可以稍后由某人重新处理数据手动发送电子邮件。这就是我们所说的最终一致性；我们在系统中考虑到了我们的系统在某个时刻会崩溃的事实。
- en: 'In this case, if there is a problem sending the e-mail, but we could store
    the order in the database, the calling code, in this case the UI, should have
    enough information to decide whether the customer gets a fatal message or just
    a warning:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果发送电子邮件出现问题，但我们可以将订单存储在数据库中，调用代码，也就是用户界面，应该有足够的信息来决定客户是收到致命消息还是警告：
- en: '*Your order is ready to be processed, however it might take us two days to
    send you the e-mail with the order details. Thanks for your patience*.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: “您的订单已准备好处理，但我们可能需要两天时间才能向您发送包含订单详情的电子邮件。感谢您的耐心。”
- en: Usually, the fact that our application will keep working even if we cannot complete
    a request, it is usually more business than technical decision. This is an important
    detail, as when building microservices, *Conway's law* is pushing us, the technical
    people, to model the existing business process and partial success maps perfectly
    to the human nature. If you can't complete a task, create a reminder in Evernote
    (or a similar tool) and come back to it once the blocker is resolved.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，即使我们无法完成一个请求，我们的应用程序仍将继续工作，这通常更多是业务而不是技术决策。这是一个重要的细节，因为在构建微服务时，“康威定律”正在推动我们，技术人员，来模拟现有的业务流程，部分成功与人类的本性完美契合。如果你无法完成一个任务，可以在Evernote（或类似工具）中创建一个提醒，并在解决阻碍后再回来处理。
- en: 'This reads much better than the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以下内容要好得多：
- en: '*Something happened about something, but we can''t tell you more* (which is
    what my mind reads sometimes when I get a general failure in some websites).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 关于某件事情发生了，但我们不能告诉你更多（有时当我在一些网站上遇到一般性故障时，我的大脑会读到这样的信息）。
- en: 'We call this way of handling errors system degradation: it might not be 100%
    functional, but it will still work even though its few features are not available,
    instead of a general failure.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种处理错误的方式为系统退化：它可能不是100%功能，但即使其少数功能不可用，它仍将工作，而不是一般性故障。
- en: If you think for a second, how many times a web service call has rolled back
    a full transaction in your big corporate system only because it couldn't reach
    a third-party service that might not even be important?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想一秒钟，想一想在你的大型公司系统中，有多少次网络服务调用因为无法到达甚至可能并不重要的第三方服务而回滚了整个事务？
- en: 'In this section, we built a microservice that uses another microservice to
    resolve a request from a customer: order manager uses e-mailer to complete the
    request. We have also talked about resilience and how important it is in our architecture
    in order to provide the best service.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们构建了一个微服务，它使用另一个微服务来解决客户的请求：订单管理器使用电子邮件发送器来完成请求。我们还谈到了弹性以及在我们的架构中提供最佳服务的重要性。
- en: The UI – API aggregation
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面 - API聚合
- en: 'Until now, we have built independent microservices. They had a specific purpose
    and dealt with one specific part of our system: e-mail sending, product management,
    and order processing, but now we are building a microservice whose only purpose
    is to facilitate the communication between microservices.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了独立的微服务。它们有一个特定的目的，并处理我们系统的一个特定部分：发送电子邮件，产品管理和订单处理，但现在我们正在构建一个唯一目的是促进微服务之间通信的微服务。
- en: Now we are going to build a microservice that interacts with others and is the
    front-facing façade to the customer.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将构建一个与其他服务交互并面向客户的前端微服务。
- en: When I was planning the contents of this chapter, a service like this one wasn't
    in it. However, after thinking about it, this chapter wouldn't have been the same
    without showing a few concepts around API aggregation that are fairly easy to
    show in a frontend microservice.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在计划本章的内容时，这样一个服务并不在其中。然而，经过思考，如果没有展示围绕API聚合的一些概念，这一章就不会是一样的，而这些概念在前端微服务中是相当容易展示的。
- en: Need for frontend microservice
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要前端微服务
- en: 'Think about scalability. When dealing with HTTP traffic, there is a pyramid
    of traffic. There are more hits in the frontend than in the backend. Usually,
    in order to reach the backend, the frontend needs to process the following few
    requests from the frontend:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑可扩展性。在处理HTTP流量时，有一个流量金字塔。前端的点击量比后端多。通常，为了到达后端，前端需要处理以下几个来自前端的请求：
- en: Read a form
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读一个表格
- en: Validate it
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证它
- en: Manage the PRG pattern ([https://en.wikipedia.org/wiki/Post/Redirect/Get](https://en.wikipedia.org/wiki/Post/Redirect/Get))
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理PRG模式（[https://en.wikipedia.org/wiki/Post/Redirect/Get](https://en.wikipedia.org/wiki/Post/Redirect/Get)）
- en: As you can see, there is a lot of logic that needs to be processed by the frontend,
    so that it is not hard to see capacity problems if the software is busy. If we
    are using a microservice, and we are using it in the right way, scaling up or
    down should be an automatic process that can be triggered with a couple of clicks
    (or commands).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，有很多逻辑需要由前端处理，所以如果软件很忙，很容易出现容量问题。如果我们正在使用微服务，并且正在正确使用它，扩展或缩小应该是一个可以通过点击（或命令）触发的自动过程。
- en: The code
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: 'Until now, we have pretty much always tested the code in a single server. This
    is fine for testing, but when we are building microservices, we want them to be
    distributed. Therefore, in order to achieve it, we need to indicate to Seneca
    how to reach the services:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎总是在单个服务器上测试代码。这对于测试来说是可以的，但当我们构建微服务时，我们希望它们是分布式的。因此，为了实现这一点，我们需要告诉Seneca如何到达这些服务：
- en: '[PRE22]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What we have done is create three Seneca instances. They are like communication
    pipes between servers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是创建三个Seneca实例。它们就像服务器之间的通信管道。
- en: 'Let''s explain the code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下代码：
- en: Seneca, by default, uses the transport plugin TCP. It means that Seneca will
    be listening to the `/act` URL on the server. As an example, when we create `senecaEmailer`,
    the URL where Seneca will be pointing to is `http://192.168.0.2:8080/act`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca默认使用传输插件TCP。这意味着Seneca将监听服务器上的`/act` URL。例如，当我们创建`senecaEmailer`时，Seneca将指向的URL是`http://192.168.0.2:8080/act`。
- en: 'We can actually verify it with curl. If we execute the following command line,
    replacing `<valid Seneca pattern>` by a valid Seneca command, we should get a
    response from the server in the JSON format, which would be the second parameter
    in the `done` function for the action:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以用curl来验证它。如果我们执行以下命令行，将`<valid Seneca pattern>`替换为有效的Seneca命令，我们应该会在JSON格式的服务器响应中得到一个响应，这将是`done`函数的第二个参数的值。
- en: '[PRE23]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Seneca's default transport plugin is TCP. If we don't specify any other, Seneca
    will use it to reach other servers and listen to calls.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca的默认传输插件是TCP。如果我们没有指定其他插件，Seneca将使用它来到达其他服务器并监听调用。
- en: 'Let''s see an easy example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: '[PRE24]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we run this program, we can see the following output from the terminal:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，我们可以在终端中看到以下输出：
- en: '![The code](img/B04889_04_17.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![代码](img/B04889_04_17.jpg)'
- en: 'It means that Seneca is listening to the port `3000`. Let''s test it:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Seneca正在监听端口`3000`。让我们来测试一下：
- en: '[PRE25]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should print something very similar to the following code in the terminal:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在终端中打印出与以下代码非常相似的内容：
- en: '![The code](img/B04889_04_11.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![代码](img/B04889_04_11.jpg)'
- en: The preceding code is the TCP/IP dialog between our terminal and Seneca server
    with the result of the response in the last line.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是我们的终端和Seneca服务器之间的TCP/IP对话，最后一行是响应的结果。
- en: So, what we achieved earlier on having three different instances of Seneca is
    configuring our network of microservices; Seneca will transport the messages across
    the network for us.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在Seneca上拥有三个不同的实例，我们配置了我们的微服务网络；Seneca将为我们在网络中传输消息。
- en: 'The following flow diagram describes how a single API can hide multiple Seneca
    servers in the backend with different microservices (different Seneca instances,
    basically):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下流程图描述了单个API如何在后端隐藏多个Seneca服务器，这些服务器具有不同的微服务（基本上是不同的Seneca实例）：
- en: '![The code](img/B04889_04_06.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![代码](img/B04889_04_06.jpg)'
- en: 'Now, let''s take a look at the skeleton of the microservice:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下微服务的骨架：
- en: '[PRE26]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have actually left the functionality that calls other microservices for
    later discussion. Now we are going to focus on how the code is articulated:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上留下了调用其他微服务的功能，以便以后讨论。现在我们将专注于代码的结构：
- en: We are creating a new plugin. The plugin is called `api` (the name of the function
    for wrapping the plugin is `api`).
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在创建一个新的插件。插件名为`api`（包装插件的函数名为`api`）。
- en: 'The plugin has to perform the following three actions:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件必须执行以下三个操作：
- en: List all the products
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有产品
- en: Get a product by ID
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按ID获取产品
- en: Create an order
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建订单
- en: 'These three actions will call to two different microservices: Product Manager
    and Order Manager. We will come back to this topic later.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个操作将调用两个不同的微服务：产品经理和订单经理。我们稍后会回到这个话题。
- en: Tip
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Seneca can be seamlessly integrated with Express in order to provide web capabilities
    to Seneca microservices.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca可以与Express无缝集成，以便为Seneca微服务提供Web功能。
- en: Until here, everything is well known, but what about the initialization function
    of the plugin?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都是众所周知的，但是插件的初始化函数呢？
- en: 'At first look, it looks like dark magic:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，它看起来像黑魔法：
- en: '[PRE27]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s explain it:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下：
- en: 'Seneca will call the `init: <plugin-name>` action in order to initialize the
    plugin.'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Seneca将调用`init: <plugin-name>`动作以初始化插件。'
- en: Through the `prefix` argument, we are listening to URLs under the `/api` path.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`prefix`参数，我们正在监听`/api`路径下的URL。
- en: We are instructing Seneca to map the URLs to action by pinning a base common
    argument. In this case, all our `seneca.add(..)` contains an argument called `area`
    with the `ui` value. We are also asking Seneca to route calls that contain the
    `action` argument (no matter the value, that is why we use the `*`) so that it
    would ignore calls that don't specify the `action` argument.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指示Seneca通过固定一个基本公共参数来将URL映射到动作。在这种情况下，我们所有的`seneca.add(..)`都包含一个名为`area`的参数，其值为`ui`。我们还要求Seneca路由包含`action`参数的调用（无论值如何，这就是为什么我们使用`*`），以便它会忽略未指定`action`参数的调用。
- en: The following argument (`map`) specifies the methods allowed in the matching.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参数（`map`）指定了匹配中允许的方法。
- en: How is the argument matching done?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 参数匹配是如何进行的？
- en: The `area` argument is implicit as we have pinned it with the `ui` value.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`area`参数是隐式的，因为我们已经将其与`ui`值固定。'
- en: The `action` argument needs to be present.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`action`参数需要存在。'
- en: The URL must start with `/api` as we specified a prefix.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: URL必须以`/api`开头，因为我们指定了一个前缀。
- en: 'So, with this information, `/api/products` will correspond to the `{area: "ui",
    action: "products"}` action. In the same way, `/api/createorder` will correspond
    to the `{area: "ui", action:"createorder"}` action.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，根据这些信息，`/api/products`将对应于`{area: "ui", action: "products"}`动作。同样，`/api/createorder`将对应于`{area:
    "ui", action:"createorder"}`动作。'
- en: The `Productbyid` argument is a bit special.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`Productbyid`参数有点特殊。'
- en: Tip
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The Seneca `pin` keyword is used to assume that the calling code has a pair
    of argument-value so that it makes the code easier to understand, but be careful,
    implicit values can have bad effects to the readability.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca的`pin`关键字用于假定调用代码具有一对参数值，以使代码更易于理解，但要小心，隐式值可能会对可读性产生不良影响。
- en: Now, although it is not simple, this looks much easier.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然它并不简单，但看起来容易多了。
- en: 'Let''s go back to the Seneca actions that are going to provide the functionality:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到将提供功能的Seneca操作：
- en: '[PRE28]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Warning! In the services written in this chapter, there is no data validation
    performed in order to make the concepts around the design of microservices clear.
    You should always validate the incoming data from untrusted systems (such as customers
    input).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！在本章编写的服务中，没有进行数据验证，以便清楚地阐明微服务设计的概念。您应该始终验证来自不受信任系统（如客户输入）的传入数据。
- en: We are actually using everything that we've discussed in the previous chapters,
    but we are taking a step forward in the Seneca semantics.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们正在使用我们在前几章中讨论过的一切，但我们正在在Seneca语义上迈出一步。
- en: We have created an API with a very limited set of functionalities, but through
    them, we are aggregating the functionality of different microservices into one.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个具有非常有限功能集的API，但通过它们，我们正在将不同微服务的功能聚合成一个。
- en: A detail to take into account is the amount of nested calls in the create order
    action (the last one). In this case, we are creating orders out of only a product
    to simplify the code, but if we are nesting too many calls for non-blocking actions
    waiting for the response in a callback, we will end up having a pyramid of code
    that makes your program difficult to read.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一个细节是在创建订单操作（最后一个）中嵌套调用的数量。在这种情况下，我们只是根据产品创建订单，以简化代码，但如果我们对非阻塞操作进行太多的嵌套调用，等待回调中的响应，我们最终会得到一堆代码，使您的程序难以阅读。
- en: The solution for it would be to refactor how the data is fetched and/or reorganize
    the anonymous functions, avoiding inlining.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是重构数据获取方式和/或重新组织匿名函数，避免内联。
- en: 'Another solution is the usage of promises libraries such as Q or Bluebird ([http://bluebirdjs.com/](http://bluebirdjs.com/))
    that allow us to chain the flow of the methods through promises:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是使用Promise库，如Q或Bluebird（[http://bluebirdjs.com/](http://bluebirdjs.com/)），它们允许我们通过Promise链来连接方法的流程：
- en: '[PRE29]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this way, instead of building a sea of callbacks, we are nicely chaining
    the calls to the methods and adding error handlers to avoid the exceptions from
    bubbling up.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们不是构建一堆回调，而是很好地链接方法的调用，并添加错误处理程序以避免异常冒泡。
- en: As you can see, we are using the UI as a central point of communication for
    all the microservices, except for the mailer, and we have a really good reason
    for it.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图表中所看到的，我们将UI用作所有微服务的中心通信点，除了邮件发送程序，我们有一个非常好的理由。
- en: Service degradation – when the failure is not a disaster
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务降级-当故障不是灾难时
- en: Microservices are great, and we have demonstrated that by writing a small system
    in a few hundred lines of code that is fairly easy to understand.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务很棒，我们已经通过编写几百行代码的小系统证明了这一点，这个系统相当容易理解。
- en: 'They are also great as they allow us to react in the event of a failure:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也很棒，因为它们允许我们在发生故障时做出反应：
- en: What happens if the e-mailer microservice stops working?
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发送电子邮件的微服务停止工作会发生什么？
- en: What happens if the order processor stops working?
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果订单处理器停止工作会发生什么？
- en: Can we recover from the situation?
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能从这种情况中恢复吗？
- en: What does the customer see?
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户看到什么？
- en: These questions, on a monolithic system, are nonsense. The e-mailer probably
    would be a part of the application. The failure on sending an e-mail implies a
    general error, unless it is specifically handled. Same with the order processor.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体系统上，这些问题是无意义的。发送电子邮件可能是应用程序的一部分。发送电子邮件失败意味着一般错误，除非特别处理。订单处理器也是如此。
- en: However, what about our microservices-oriented architecture?
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们的面向微服务的架构呢？
- en: The fact that the e-mailer has failed to deliver a few e-mails does not prevent
    the orders from being processed, even though the customers aren't getting the
    e-mails. This is what we call performance or service degradation; the system might
    be slower, but some functionalities will still work.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件发送失败并不会阻止订单被处理，尽管客户没有收到电子邮件。这就是我们所说的性能或服务降级；系统可能会变慢，但某些功能仍将正常工作。
- en: Tip
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Service degradation is the ability of a system to lose a feature without suffering
    a general failure.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 服务降级是系统失去功能而不会遭受一般性故障的能力。
- en: What about the order manager? Well...we can still make the products-related
    calls work, but we won't be able to process any order…which might still be a good
    thing.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 订单管理器呢？嗯...我们仍然可以使与产品相关的调用工作，但我们将无法处理任何订单...这可能仍然是一件好事。
- en: The fact that the order manager is responsible for sending the e-mail instead
    of the UI microservice is not coincidental; we only want to send the e-mail with
    the acknowledgement of a sale on the success event, and we don't want to send
    the success e-mail in any other case.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 订单管理器负责发送电子邮件而不是UI微服务并非巧合；我们只想在成功事件上发送销售确认的电子邮件，而不想在任何其他情况下发送成功的电子邮件。
- en: Circuit breakers
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断路器
- en: In the previous section, we talked about system degradation in the event of
    a failure, but everybody who has worked in IT for a number of years knows that
    a system does not fail suddenly in most cases of failures.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们谈到了系统在发生故障时的系统降级，但是在IT行业工作多年的人都知道，在大多数故障情况下，系统并不会突然失败。
- en: The most common event is a timeout; the server is busy for a period of time,
    which makes the request to fail, giving our customers a terrible user experience.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的事件是超时；服务器忙碌一段时间，导致请求失败，给我们的客户带来糟糕的用户体验。
- en: How can we solve this particular problem?
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个特定的问题？
- en: 'We can solve this problem with a circuit breaker, as shown in the following
    image:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过断路器解决这个问题，如下图所示：
- en: '![Circuit breakers](img/B04889_04_07.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![断路器](img/B04889_04_07.jpg)'
- en: A circuit breaker is a mechanism to prevent requests from reaching an unstable
    server that could cause our application to misbehave.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器是一种防止请求到达可能导致应用程序运行不正常的不稳定服务器的机制。
- en: 'As you can see in the preceding schema, the circuit breaker has the following
    three statuses:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，断路器有以下三种状态：
- en: '**Closed**: The circuit is closed; the requests reach their destination.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**：电路关闭；请求到达其目的地。'
- en: '**Open**: The circuit is open; the requests don''t get past the circuit breaker
    and the client gets an error. The system will retry the communication after a
    time period.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打开**：电路打开；请求无法通过断路器，客户端收到错误。系统将在一段时间后重试通信。'
- en: '**HalfOpen**: The circuit tests the service again, and if there is no error
    reaching it, the requests can flow again and the circuit breaker is **Closed**.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半开**：电路再次测试服务，如果到达服务时没有错误，请求可以再次流动，断路器**关闭**。'
- en: With this simple mechanism, we can prevent the errors to cascade through our
    system, avoiding catastrophic failures.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种简单的机制，我们可以防止错误在系统中蔓延，避免灾难性的故障。
- en: Ideally, the circuit breaker should be asynchronous. This means that even if
    there are no requests, every few seconds/milliseconds, the system should be trying
    to re-establish the connection to the faulty service in order to continue the
    normal operation.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，断路器应该是异步的。这意味着即使没有请求，系统也应该每隔几秒/毫秒尝试重新建立与故障服务的连接，以便继续正常运行。
- en: Tip
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Failure is a common denominator in the human nature: better be prepared for
    it.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 失败是人类本性中的共同点：最好为此做好准备。
- en: Circuit breakers are also an ideal place to alert the support engineers. Depending
    on the nature of our system, the fact that a given service cannot be reached could
    mean a serious issue. Can you imagine a bank that is unable to reach the SMS service
    to send two-factor authentication codes? No matter how hard we try, it will always
    happen at some point. So, be prepared for it.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器也是警报支持工程师的理想位置。根据我们系统的性质，某个服务无法到达可能意味着一个严重的问题。你能想象一家银行无法到达短信服务发送双因素认证码吗？无论我们如何努力，它总会在某个时候发生。所以，为此做好准备。
- en: Note
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a very inspiring article from Martin Fowler (one of the big names in
    microservices) about circuit breakers at [http://martinfowler.com/bliki/CircuitBreaker.html](http://martinfowler.com/bliki/CircuitBreaker.html).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler（微服务中的大人物之一）有一篇非常鼓舞人心的文章，讲述了断路器的内容，网址为[http://martinfowler.com/bliki/CircuitBreaker.html](http://martinfowler.com/bliki/CircuitBreaker.html)。
- en: Seneca – a simple puzzle that makes our lives easier
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Seneca - 一个简单的谜题，让我们的生活变得更轻松
- en: '**Seneca** is great. It enables the developers to take a simple and small idea
    and translate it into a piece of code with a connection point that does not make
    any assumption, just facts. An action has a clear input and provides you the interface
    to give an answer for it through a callback.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**Seneca**很棒。它使开发人员能够将一个简单而小的想法转化为一段代码，其中连接点不做任何假设，只是事实。一个操作有清晰的输入，并通过回调为其提供答案的接口。'
- en: How many times have you found your team struggling with the class structure
    of an application just to reuse code in *a nice way*?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你的团队有多少次为了以*一种好的方式*重用代码而在应用程序的类结构中挣扎？
- en: Seneca focuses on **simplicity**. The fact that we are not modeling objects,
    but just parts of systems using small portions of code that are extremely cohesive
    and idempotent to objects makes our life much easier.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca专注于**简单性**。我们不是在建模对象，而只是使用小段代码来构建系统的一部分，这些代码与对象非常紧密和幂等，使我们的生活变得更加轻松。
- en: Another way how Seneca makes our life easy is through the **plugability**.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca让我们的生活变得更轻松的另一种方式是通过**可插拔性**。
- en: If you review the code that we have been writing in this book, the first thing
    that will be spotted is how convenient the plugins are.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下我们在本书中写的代码，首先会注意到插件是多么方便。
- en: They provide the right level of encapsulation for a bunch of actions (Does it
    look similar to a class?) that are somehow related to each other.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 它们为一系列某种程度上相关的操作提供了适当的封装（看起来类似于类吗？）。
- en: I always try not to over-engineer solutions. It is really easy to fall into
    premature abstraction, preparing the code for a future that we don't know whether
    it it is going to happen in the majority of the cases.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是尽量不过度设计解决方案。很容易陷入过早的抽象，为我们不知道在大多数情况下是否会发生的未来准备代码。
- en: We don't realize how long we spend maintaining features that have been overdesigned
    and need to be tested every time someone changes the code around them.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有意识到我们花了多长时间来维护那些被过度设计并且需要每次有人改变它们周围的代码时都需要测试的功能。
- en: Seneca avoids (or at least discourages) this type of designs. Think about Seneca
    actions as a small piece of paper (like a post-it), where you need to write what
    happened last week. You need to be smart about what to fit in there, and possibly,
    split it into another post-it if the content gets to dense.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca避免（或至少不鼓励）这种类型的设计。把Seneca的操作想象成一张小纸条（就像便利贴），你需要在上面写上上周发生的事情。你需要聪明地选择要放进去的内容，并且可能，如果内容太密集，就把它分成另一张便利贴。
- en: Another point where Seneca is good is in configurability. As we have seen before,
    Seneca comes with a number of integrations for data storage and transport.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca在可配置性方面也表现良好。正如我们之前所看到的，Seneca带有许多用于数据存储和传输的集成。
- en: 'An important side of Seneca is the transport protocol. As we know by now, the
    default transport is carried over TCP, but can we use a message queue to do it?
    The structure is shown as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca的一个重要方面是传输协议。正如我们现在所知，默认传输是通过TCP进行的，但我们可以使用消息队列吗？结构如下所示：
- en: '![Seneca – a simple puzzle that makes our lives easier](img/B04889_04_08.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![Seneca - 一个简单的谜题，让我们的生活变得更轻松](img/B04889_04_08.jpg)'
- en: Yes, we can. It is already done and maintained.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以。它已经完成并得到维护。
- en: Note
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following URL is a plugin for Seneca that allows it to send messages over
    RabbitMQ instead of HTTP:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 以下URL是Seneca的一个插件，允许它通过RabbitMQ发送消息而不是HTTP：
- en: '[https://github.com/senecajs/seneca-rabbitmq-transport](https://github.com/senecajs/seneca-rabbitmq-transport)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/senecajs/seneca-rabbitmq-transport](https://github.com/senecajs/seneca-rabbitmq-transport)'
- en: 'If you look into the code of the plugin (it looks really complex, but it is
    not), you can spot where the magic happens in few seconds:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看插件的代码（看起来非常复杂，但实际上并不是），您可以在几秒钟内找到魔术发生的地方：
- en: '[PRE30]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Seneca is using Seneca actions to delegate the transport of the message. Although
    it looks a bit recursive, it is brilliant!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca正在使用Seneca动作来委托消息的传输。虽然看起来有点递归，但它很棒！
- en: Once you understand how Seneca and the transport protocol chosen work, you are
    immediately qualified to write a transport plugin for Seneca.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了Seneca和所选择的传输协议的工作原理，您就立即有资格为Seneca编写传输插件。
- en: Note
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When I started learning about Seneca in order to write this book, I also wrote
    a transport plugin to use NServiceBus ([http://particular.net/](http://particular.net/)).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始学习Seneca以撰写本书时，我还编写了一个传输插件来使用NServiceBus（[http://particular.net/](http://particular.net/)）。
- en: NServiceBus is an interesting idea, it allows you to connect a number of storages
    and AMPQ-compliant systems and use them as clients. For example, we could be writing
    messages in a SQL Server table and consuming them from a queue once they get routed
    through NServiceBus, having immediate auditing capabilities on the history of
    the messages.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: NServiceBus是一个有趣的想法，它允许您连接多个存储和AMPQ兼容系统，并将它们用作客户端。例如，我们可以将消息写入SQL Server表中，并在通过NServiceBus路由后从队列中消费它们，从而具有消息历史的即时审计功能。
- en: With such flexibility, we could potentially write a plugin that uses pretty
    much anything as a transport protocol.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的灵活性，我们可能编写一个使用几乎任何东西作为传输协议的插件。
- en: Seneca and promises
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Seneca和promises
- en: All our code from the previous chapters is relying on callbacks. Callbacks are
    good as far as your code does not nest them on more than three levels.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前章节中的所有代码都依赖于回调。回调在您的代码不嵌套超过三层时是好的。
- en: 'However, there is an even better way of managing the asynchronous nature of
    JavaScript: **promises**.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种更好的方法来管理JavaScript的异步特性：**promises**。
- en: 'Take a look at the following code:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE31]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code is an example of the JQuery fragment using promises.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是使用promises的JQuery片段的一个例子。
- en: 'A promise, by its definition is:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其定义，promise是：
- en: '*A declaration or assurance that one will do something or that a particular
    thing will happen.*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*承诺或保证将做某事或发生某事的声明*'
- en: 'That is exactly it. If you see the preceding code, `$.when`, returns a promise.
    We don''t know how long the effect function will take, but we can guarantee that
    once it is ready, the function inside of `done` will be executed. It looks very
    similar to callbacks, but take a look at the following code:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。如果你看到前面的代码，`$.when`返回一个promise。我们不知道effect函数会花多长时间，但我们可以保证一旦准备好，`done`里面的函数就会被执行。它看起来非常类似于回调，但是看看下面的代码：
- en: '[PRE32]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Don''t try to execute it, it is just a hypothetical example, but what we are
    doing in there is chain promises; and that makes the code vertical instead of
    ending up in a pyramid-shaped program, which is a lot harder to read, as shown
    in the following diagram:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试执行它，这只是一个假设的例子，但我们在那里所做的是链接promises；这使得代码垂直而不是以金字塔形式结束，这样更难阅读，如下图所示：
- en: '![Seneca and promises](img/B04889_04_09.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![Seneca和promises](img/B04889_04_09.jpg)'
- en: 'Seneca, by default, is not a promise-oriented framework, but (there is always
    a but) using Bluebird, one of the most famous promises libraries in JavaScript,
    we can *promisify* Seneca, as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Seneca不是一个面向promise的框架，但（总是有一个但）使用Bluebird，JavaScript中最著名的promise库之一，我们可以*promisify*
    Seneca，如下所示：
- en: '[PRE33]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are two important details in the preceding code:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中有两个重要的细节：
- en: '[PRE34]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This creates a promisified version of the `act` function and its use, as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了`act`函数及其使用的promise版本，如下所示：
- en: '[PRE35]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'An important detail in this last fragment; instead of receiving a callback
    with the following two parameters:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的片段中有一个重要的细节；而不是接收以下两个参数的回调：
- en: An error
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个错误
- en: The results
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果
- en: 'We are chaining the following two methods:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在链接以下两种方法：
- en: '**Then**: This is executed when the promise is resolved'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Then**：当promise被解析时执行'
- en: '**Catch**: This is executed if there is an error while resolving the promise'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Catch**：如果在解析promise时出现错误，则执行此操作'
- en: 'This type of constructions allows us to write the following code:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造方式使我们能够编写以下代码：
- en: '[PRE36]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code is handling something that we have never talked about before: the
    gate executor timeouts. It happens when Seneca cannot reach the destination in
    some situations, and it can be easily handled with a promise as shown earlier.
    The `then` part would never be executed as the function will only be called when
    there is an error.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码处理了我们以前从未谈论过的东西：gate executor超时。当Seneca在某些情况下无法到达目的地时，就会发生这种情况，而且可以像之前展示的那样轻松地处理。`then`部分永远不会被执行，因为只有在出现错误时才会调用该函数。
- en: There are a few well-consolidated options in the market now for promises in
    JavaScript. Nowadays, my preferred choice would be Bluebird ([https://github.com/petkaantonov/bluebird](https://github.com/petkaantonov/bluebird))
    because of its simplicity. Q is another option used by AngularJS (one of the most
    popular **SPA** frameworks), but for day-to-day use, it looks more complicated
    than Bluebird.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在市场上有几种JavaScript中的promise的成熟选择。如今，我的首选是Bluebird（[https://github.com/petkaantonov/bluebird](https://github.com/petkaantonov/bluebird)），因为它简单易用。Q是AngularJS（最流行的SPA框架之一）使用的另一个选项，但在日常使用中，它看起来比Bluebird更复杂。
- en: Debugging
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: Debugging a Node.js application is very similar to debugging any other application.
    IDEs like **WebStorm** or **IntelliJ** provide a traditional debugger where you
    can install breakpoints and stop the execution whenever the application hits the
    given line.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 调试Node.js应用程序与调试任何其他应用程序非常相似。像**WebStorm**或**IntelliJ**这样的IDE提供了一个传统的调试器，您可以在其中设置断点，并在应用程序触及给定行时停止执行。
- en: This is perfect if you buy a license for one of the IDEs, but there is a free
    alternative that will have a very similiar result for the users of Google Chrome,
    **node-inspector**.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您购买了其中一个IDE的许可证，这将是完美的，但是对于Google Chrome的用户来说，有一个免费的替代方案将会产生非常相似的结果，**node-inspector**。
- en: Node-inspector is an npm package that pretty much enables the Chrome debugger
    to debug Node.js applications.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Node-inspector是一个npm包，几乎可以使Chrome调试器调试Node.js应用程序。
- en: 'Let''s see how it works:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: 'First of all, we need to install node-inspector:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装node-inspector：
- en: '[PRE37]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should add a command to our system called `node-inspector`. If we execute
    it, we get the following output:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会向我们的系统添加一个名为`node-inspector`的命令。如果我们执行它，我们会得到以下输出：
- en: '![Debugging](img/B04889_04_12.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![调试](img/B04889_04_12.jpg)'
- en: That means our debug server has started.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的调试服务器已经启动。
- en: Now we need to run a node application with a special flag to indicate that it
    needs to be debugged.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要运行一个带有特殊标志的节点应用程序，以指示需要进行调试。
- en: 'Let''s take a simple Seneca act as an example:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个简单的塞内加行为为例：
- en: '[PRE38]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, in order to run it on the debug mode, execute the following command:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了在调试模式下运行它，执行以下命令：
- en: '[PRE39]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The way to access the debugger is through the URL `http://127.0.0.1:8080/?port=5858`:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 访问调试器的方式是通过URL `http://127.0.0.1:8080/?port=5858`：
- en: '![Debugging](img/B04889_04_13.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![调试](img/B04889_04_13.jpg)'
- en: 'I am sure this image is very familiar to every developer in the world: it is
    the Chrome debugger showing our code. As you can see in the first line, the one
    highlighted in blue, the application stopped in the first instruction so that
    we can place the breakpoints by clicking the line numbers, as shown in the following
    image:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信这张图片对世界上每个开发人员来说都很熟悉：这是Chrome调试器显示我们的代码。正如您在第一行中所看到的，也就是蓝色高亮显示的那一行，应用程序在第一条指令处停止，以便我们可以通过点击行号来设置断点，如下图所示：
- en: '![Debugging](img/B04889_04_14.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![调试](img/B04889_04_14.jpg)'
- en: 'As you can see in the preceding image, we have installed a breakpoint in line
    **9**. Now we can use the control panel to navigate through the code and values
    of our variables:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上图中所看到的，我们在第9行设置了一个断点。现在我们可以使用控制面板来浏览代码和变量的值：
- en: '![Debugging](img/B04889_04_15.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![调试](img/B04889_04_15.jpg)'
- en: 'The controls on the top speak for themselves if you ever debugged an application:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的控件说明了自己，如果您曾经调试过一个应用程序：
- en: The first button is called play and it allows the application to run to the
    next breakpoint
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个按钮称为播放，它允许应用程序运行到下一个断点
- en: Step over executes the next line in the current file
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步执行当前文件中的下一行
- en: Step into goes into the next line, getting deeper in the call stack so that
    we can see the call hierarchy
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步入进入下一行，深入调用堆栈，以便我们可以看到调用层次结构
- en: Step out is the reverse of step into
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳出是步入的反向
- en: Disable breakpoints will prevent the program from stopping at the breakpoints
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用断点将阻止程序在断点处停止。
- en: Pause on exceptions, as its name indicates, will cause the program to stop on
    exceptions (it is very useful when trying to catch errors)
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常暂停，顾名思义，将导致程序在异常处停止（在尝试捕获错误时非常有用）
- en: 'If we click on play, we can see how the script will stop in line **9** in the
    following image:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击播放，我们可以看到脚本将在下图中的第9行停止：
- en: '![Debugging](img/B04889_04_16.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![调试](img/B04889_04_16.jpg)'
- en: As a good debugger, it will let us inspect the value of our variables by hovering
    the cursor over the variable name.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个好的调试器，它将让我们通过将光标悬停在变量名上来检查变量的值。
- en: Summary
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has been pretty intense. We have gone through a lot of content
    that helped us in building a small microservices ecosystem that, when orchestrated
    together, would fairly work well. We have been a bit simplistic some times, but
    the idea of the book is to indicate the power of the microservices-oriented software.
    At this stage, I would recommend the reader to start performing some testing around
    Seneca.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节非常紧凑。我们已经经历了很多内容，这些内容帮助我们构建了一个小型的微服务生态系统，当它们一起编排时，将会相当好地工作。有时我们有点过于简化，但本书的目的是要表明面向微服务的软件的强大之处。在这个阶段，我建议读者开始围绕塞内加进行一些测试。
- en: The documentation on the website is quite helpful, and there are a lot of examples
    to follow.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 网站上的文档非常有帮助，也有很多示例可供参考。
- en: There are a few plugins for storage and transport, as well as other type of
    plugins (such as user authentication), that would allow you to experiment with
    different features of Seneca.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些存储和传输的插件，以及其他类型的插件（如用户认证），可以让您尝试不同的塞内加功能。
- en: We will be talking more about some of them in the following chapters.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更多地讨论其中一些。
