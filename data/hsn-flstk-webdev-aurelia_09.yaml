- en: Running E2E Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行端到端测试
- en: Congratulations! You are just one step away from becoming a full stack application
    developer! For now, we will stop talking about Aurelia; you know the framework
    and have a high level of knowledge of how JavaScript works as a programming language.
    Now, it's time to expand our knowledge about full-stack application development.
    We have our FIFA WC 2018 application running on our localhost and have some unit
    testing implemented. Is it enough to ensure that it will work in a QA or production
    environment? Of course, no.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你只需再迈出一小步，就能成为一名全栈应用开发者！目前，我们将停止讨论Aurelia；你了解这个框架，并且对JavaScript作为编程语言的工作原理有很高的了解。现在，是时候扩展我们对全栈应用开发的了解。我们的FIFA
    WC 2018应用正在本地主机上运行，并且已经实现了一些单元测试。这足以确保它在QA或生产环境中工作吗？当然，不够。
- en: Unit testing is very important, but it only ensures the correct functionality
    of one single service. How can we ensure that all our applications (database,
    backend, frontend, and any other external services) are working correctly as one
    single application? This is what we will learn in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试非常重要，但它只能确保单个服务的正确功能。我们如何确保所有我们的应用程序（数据库、后端、前端以及任何其他外部服务）作为一个单一应用程序正确工作？这就是本章我们将学习的内容。
- en: Testing is one of the highly demanded skills for all developers nowadays. Why?
    It's because programming is no longer just writing code and to ensure that it
    works on your own PC, you need to create code that ensures this functionality
    and also be able to automate the testing process to create a continuous delivery
    pipeline.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是当今所有开发者高度需求的一项技能。为什么？因为编程不再仅仅是编写代码，为了确保它在你的个人电脑上工作，你需要编写确保这种功能的代码，并且能够自动化测试过程以创建持续交付管道。
- en: 'We can divide the testing phase into four different levels, and we will cover
    each one through this chapter. Look at the following image:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将测试阶段分为四个不同的级别，我们将在本章中逐一介绍。看看下面的图片：
- en: '![](img/e592f9b9-20ca-4f76-aa30-cf8321f608a5.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e592f9b9-20ca-4f76-aa30-cf8321f608a5.png)'
- en: 'We can refer to these layers as basic tests. Once we have covered all three
    layers, we can commit and push our code. Is that all? No. We have more advanced
    testing layers that should be performed using tools completely external to our
    application:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些层称为基本测试。一旦我们覆盖了所有三个层，我们就可以提交和推送我们的代码。这样就结束了？不。我们还有更高级的测试层，这些测试应该使用完全独立于我们应用程序的工具来执行：
- en: '**System testing** ensures that all our business use cases are resolved and
    satisfied. It''s like black box testing where we don''t know how each method or
    operation is performed; we just care about the input and output. This kind of
    testing starts in the frontend layer, emulating common user operations and expecting
    some data already processed through the backend APIs and external services. You
    must know that system testing can be automated in your CI cycle.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**确保我们所有的业务用例都得到解决和满足。它就像黑盒测试，我们不知道每个方法或操作是如何执行的；我们只关心输入和输出。这种测试从前端层开始，模拟常见的用户操作，并期望一些已经通过后端API和外部服务处理过的数据。你必须知道系统测试可以在你的持续集成周期中自动化。'
- en: '**Acceptance testing** is performed by real end users. They ensure that your
    system will support all user interactions, evaluating time, performance, and one
    very important aspect—your app''s user experience. Commonly, this test is performed
    by the product owner first in an external environment called **user acceptance
    testing** (**UAT**).'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**由真实最终用户执行。他们确保你的系统将支持所有用户交互，评估时间、性能，以及一个非常重要的方面——你的应用程序的用户体验。通常，这种测试首先由产品所有者在称为**用户验收测试**（UAT）的外部环境中执行。'
- en: 'So, we can resume the testing phase in the following illustration:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以总结测试阶段如下所示：
- en: '![](img/67ec1984-69c6-49fd-88a1-0925b0185df7.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67ec1984-69c6-49fd-88a1-0925b0185df7.png)'
- en: 'We will cover each testing phase through this chapter. We''ve already reviewed
    the unit testing in the last section of Chapter 4, *Creating Components and Templates*,
    which is useful to ensure the functionality of a single component, but how can
    we evaluate the complete interaction between our components and other external
    services? It''s time to go one step ahead and learn about integration testing.
    But even one step ahead is not enough for us, so let''s go deeper and evaluate
    one very important but often ignored aspect of every web application: we can ensure
    our application functionality, but is it simple to use by our final users? UI
    testing will give us the answer. Finally, let''s add some cool documentation to
    each endpoint we are exposing to be consumed by some client, even if it''s web
    or mobile. We will show you how Swagger works and how it can generate a nice readable
    documentation about your API. The topics covered in this chapter are these:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过本章介绍每个测试阶段。我们已经在第四章的最后一节“创建组件和模板”中回顾了单元测试，这对于确保单个组件的功能很有用，但我们如何评估组件与其他外部服务之间的完整交互呢？是时候更进一步，学习集成测试了。但仅仅更进一步对我们来说还不够，所以让我们更深入地评估每个Web应用都非常重要但经常被忽视的一个方面：我们可以确保应用功能，但最终用户使用起来简单吗？UI测试将给我们答案。最后，让我们为每个暴露给客户端消费的端点添加一些酷炫的文档，即使它是Web或移动端。我们将向您展示Swagger是如何工作的，以及它如何生成关于您的API的易于阅读的文档。本章涵盖的主题包括：
- en: Integration testing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: UI testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI测试
- en: API testing – Swagger
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API测试 - Swagger
- en: Do not pass through this chapter; testing is a very important part of the application
    development life cycle. Ready? Go!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不要跳过这一章；测试是应用开发生命周期中非常重要的一个部分。准备好了吗？开始吧！
- en: Integration testing – Multiple services, one application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试 - 多个服务，一个应用
- en: We have all our functionalities already tested. We know that our services work
    correctly but what about our database connection? What about our SSO? Can you
    confirm these services/dependencies work correctly?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经测试了所有功能。我们知道我们的服务运行正确，但我们的数据库连接和SSO呢？你能确认这些服务/依赖项运行正确吗？
- en: 'Integration testing plays an important role in the application development
    cycle by verifying the correct behavior of the system. Let''s explore our current
    application architecture:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通过验证系统的正确行为在应用开发周期中发挥着重要作用。让我们探索我们当前的应用架构：
- en: '![](img/183fbeb4-5cc3-4ee3-a149-6b11ef57fec5.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/183fbeb4-5cc3-4ee3-a149-6b11ef57fec5.png)'
- en: Integration tests ensure the correct interaction across our different application
    layers, in this case, database connection, SSO service, and frontend application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试确保我们不同应用层之间的正确交互，在本例中，包括数据库连接、SSO服务和前端应用。
- en: 'Why should you do integration tests? Well, if it''s not clear yet, there are
    a few reasons to consider:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该做集成测试？好吧，如果还不清楚，这里有几个需要考虑的原因：
- en: Easy integration with daily builds in your **Continuous Integration** (**CI**)
    cycle. Your progress will be testable at any time.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易与**持续集成**（**CI**）周期中的日常构建集成。你的进度可以在任何时间进行测试。
- en: Easy to test in dev/QA/UAT/Production environment. It's easy, just like running
    your application.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发/测试/用户验收测试/生产环境中易于测试。这很简单，就像运行你的应用一样。
- en: Tests run faster as compared to end-to-end tests.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与端到端测试相比，测试运行得更快。
- en: Allows you to detect system-level issues. Communication between services, database
    connection, and so on.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你检测系统级问题。服务之间的通信、数据库连接等。
- en: Now, let's add some integration tests to our existing express application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向现有的Express应用添加一些集成测试。
- en: Configuring applications for integration testing
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用以进行集成测试
- en: 'The only prerequisite you need is the Node runtime environment running correctly.
    In JavaScript, we have some tools to make integration tests, such as the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你唯一需要的前提是Node运行环境正确运行。在JavaScript中，我们有几个工具可以用来进行集成测试，例如以下这些：
- en: '**SuperTest**: The best feature is its strong documentation; easy to understand
    and implement, you just need to write a few lines of code to start testing your
    application.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SuperTest**：其最佳特性是强大的文档；易于理解和实现，你只需写几行代码就可以开始测试你的应用。'
- en: '**Mocha**: A simple JavaScript test framework. It can be executed in the web
    browser or in your Node environment. Since Mocha is based on JavaScript, it can
    execute asynchronous tests and generate very useful reports.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mocha**：一个简单的JavaScript测试框架。它可以在浏览器或Node环境中执行。由于Mocha基于JavaScript，它可以执行异步测试并生成非常有用的报告。'
- en: We will use both tools together for our testing purposes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这两个工具一起进行测试。
- en: 'With SuperTest, you gain advantages such as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SuperTest，你可以获得以下优势：
- en: You can simulate a multiple user interaction, storing different credentials
    (tokens) to switch between users.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以模拟多个用户交互，存储不同的凭证（令牌）以在用户之间切换。
- en: You don't need to worry about delete or add mock data. SuperTest will perform
    the operations to clean or add data to your store.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要担心删除或添加模拟数据。SuperTest 将执行清理或添加数据到你的存储的操作。
- en: The most useful feature—all these tests can be automated and integrated in your
    CI pipeline.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最有用的功能——所有这些测试都可以自动化并集成到你的 CI 流水线中。
- en: SuperTest is a big help for productivity; also, it offers a natural way to write
    and test your code at the same time; it is very intuitive and human readable.
    Let’s go over how to quickly set it up for something like user retrieving data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SuperTest 对于提高生产力非常有帮助；它还提供了一种自然的方式来编写和测试你的代码；它非常直观且易于阅读。让我们来看看如何快速设置它来处理用户检索数据。
- en: Where can you run SuperTest tests? Basically, you can run them in any server
    you want. No matter whether you are deploying on local `dev` servers or cloud
    providers, SuperTests can be executed from any of them, but you must know something—SuperTest
    includes its own express server. This server should not be running all the time,
    but using some external tools like nodemon, you can automatically restart your
    server each time we have a change and need to test it. If you don't want to run
    all the tests, Mocha's only specifier is a nice solution too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以运行 SuperTest 测试？基本上，你可以在任何你想要的服务器上运行它们。无论你是部署在本地 `dev` 服务器还是云提供商，SuperTests
    都可以从它们中的任何一个执行，但你必须知道——SuperTest 包含它自己的 Express 服务器。这个服务器不应该一直运行，但使用一些外部工具如 nodemon，你可以在每次我们有所更改并需要测试时自动重启你的服务器。如果你不想运行所有测试，Mocha
    的唯一指定器也是一个不错的解决方案。
- en: 'First, we need to download our dependencies:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要下载我们的依赖项：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Chai allows us to choose any of the following prefixes: `should`, `expect`,
    or `assert`. Just like other test tools, they are all available here too.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 允许我们选择以下前缀中的任何一个：`should`、`expect` 或 `assert`。就像其他测试工具一样，它们在这里也都可用。
- en: We already have our `server.js` file, so you won't need to add any code there.
    Yes, you don't need to run any server, and this is the most beautiful advantage
    of SuperTest!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了我们的 `server.js` 文件，所以你不需要在那里添加任何代码。是的，你不需要运行任何服务器，这是 SuperTest 最美的优势之一！
- en: 'Remember that our test files should be separated from the application files. Next,
    create your `tests` file with the `touch tests.spec.js` command, and let''s add
    some code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的测试文件应该与应用程序文件分开。接下来，使用 `touch tests.spec.js` 命令创建你的 `tests` 文件，然后让我们添加一些代码：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's explain what the code is doing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下代码在做什么。
- en: We are importing our server, Chai and SuperTest. SuperTest includes its own `.expect()`,
    but we are using Chai’s syntax. The code sets a group of `API Tests` and creates
    one test to check whether the `/teams` endpoint returns 200 (OK) as status code.
    Note that the `done()` function is important to declare our asynchronous tests
    are complete. Of course, this is a very high-level test, and we can add more assertions
    such as evaluating the response's content and more. For example purposes, this
    is very simple to understand and know how SuperTest works.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入我们的服务器、Chai 和 SuperTest。SuperTest 包含它自己的 `.expect()`，但我们正在使用 Chai 的语法。代码设置了一组
    `API 测试` 并创建了一个测试来检查 `/teams` 端点是否返回状态码 200（OK）。请注意，`done()` 函数对于声明我们的异步测试已完成非常重要。当然，这是一个非常高级的测试，我们可以添加更多的断言，例如评估响应的内容等。为了说明目的，这个例子非常简单易懂，可以了解
    SuperTest 的工作方式。
- en: 'Now, let’s see if it works. Run the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它是否工作。运行以下命令：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should get this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到这个：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make sure you have correctly configured the `test` command in the script section
    on `package.json` file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经在 `package.json` 文件的脚本部分正确配置了 `test` 命令。
- en: Mocking external dependencies
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟外部依赖项
- en: Okay, you can write some integration tests. Is it enough? Not yet. Let's think.
    We really need to connect to external services? What if they're down? Of course,
    our test will fail but not for some application error. To avoid this, we will
    use Mocks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你可以编写一些集成测试。这够了吗？还不够。让我们再想想。我们真的需要连接到外部服务吗？如果它们宕机了怎么办？当然，我们的测试会失败，但不是因为某些应用程序错误。为了避免这种情况，我们将使用模拟（Mocks）。
- en: 'Mocking is the technique used to simulate some object/service/component and
    return a predefined response when its called. We''ll not connect with real services,
    so we''ll be using `sinon.mock` to create a mock model for our Teams schema, and
    we''ll test the expected result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是一种技术，用于模拟某些对象/服务/组件，并在被调用时返回预定义的响应。我们不会连接到真实的服务，所以我们将使用 `sinon.mock` 为我们的
    Teams 架构创建一个模拟模型，并测试预期的结果：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All okay at this point. Now, let's evaluate another very important aspect of
    testing, code coverage.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切正常。现在，让我们评估测试的另一个非常重要的方面，代码覆盖率。
- en: Make sure that `sinon` is downloaded in your project and imported in your current
    test file to make the example work, same as any external model you may need. You
    can find more info about `sinon` at [http://sinonjs.org](http://sinonjs.org).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在你的项目中下载了 `sinon` 并将其导入到当前的测试文件中，以便示例工作，就像你可能需要的任何外部模型一样。你可以在 [http://sinonjs.org](http://sinonjs.org)
    找到更多关于 `sinon` 的信息。
- en: Calculating code coverage
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算代码覆盖率
- en: With our integration test already written and running, we have one thing pending
    to do. It would be an awesome thing if we could see how our tests are doing with
    respect to our app in terms of test coverage.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的集成测试已经编写并运行，我们还有一件事要做。如果能看到我们的测试在测试覆盖率方面与我们的应用的关系，那将是一件很棒的事情。
- en: Let’s add code coverage to the app!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给应用添加代码覆盖率！
- en: '**Istanbul** is a very famous JavaScript code coverage tool that computes different
    metrics such as statement quality, lines of code, function use, and branch coverage
    with module loader hooks to analyze all our code and add coverage when running
    tests, giving us real-time information about our application. It supports all
    kinds of JavaScript coverage use cases, from unit tests to functional and browser
    tests. The best part about this is that it is scalable.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**Istanbul** 是一个非常著名的 JavaScript 代码覆盖率工具，它通过模块加载器钩子计算不同的指标，如语句质量、代码行数、函数使用和分支覆盖率，在运行测试时添加覆盖率，为我们提供有关应用程序的实时信息。它支持所有类型的
    JavaScript 覆盖率用例，从单元测试到功能测试和浏览器测试。最好的部分是它具有可扩展性。'
- en: 'Fortunately, we just need to install Istanbul and `nyc` (this last one in the
    command line client for `istanbul`). We just do this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们只需要安装 Istanbul 和 `nyc`（这是 `istanbul` 的命令行客户端）。我们只需这样做：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we modify our `package.json` file. This is to add test with coverage
    to our `script` object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们修改我们的 `package.json` 文件。这是为了向我们的 `script` 对象中添加带有覆盖率的测试：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, run the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should be able to see the coverage summary of your application in the console.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在控制台中看到你应用程序的覆盖率摘要。
- en: Does our app meet our business requirements? UI testing
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的应用是否符合我们的业务需求？UI 测试
- en: Don't be confused, we won't test frontend application functionality. This is
    already tested with our unit test, so what is really UI testing? Well, it is a
    very long discussion. We can have many test suites configured to be executed at
    any time, and this will ensure that our E2E meets the business requirements already
    programmed. What do we mean by this? Unit and integration testing cannot evaluate
    all areas of a complete application, specifically the areas related to workflow
    and usability. Basically, all our automated tests can only verify code that exists.
    They cannot evaluate functionality that is maybe missing or issues related to
    visual elements of our application and how easy our product is to use. This is
    the real value of GUI testing, which is performed from the perspective of a user
    instead of the practical point of view of the developer. By analyzing an application
    from a user’s perspective, GUI testing can provide enough information to the project
    team to decide whether the application is ready to deploy or we need to reorganize
    some features to accomplish the user needs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆，我们不会测试前端应用程序的功能。这已经通过我们的单元测试进行了测试，那么真正的 UI 测试是什么？嗯，这是一个非常长的讨论。我们可以配置多个测试套件，以便在任何时候执行，这将确保我们的端到端测试符合已经编写的业务需求。我们这是什么意思？单元和集成测试不能评估完整应用程序的所有区域，特别是与工作流程和可用性相关的区域。基本上，我们所有的自动化测试只能验证存在的代码。它们不能评估可能缺失的功能或与应用程序视觉元素相关的问题，以及我们的产品使用起来有多容易。这是
    GUI 测试的真实价值，它从用户的角度而不是开发者的实际观点进行操作。通过从用户的角度分析应用程序，GUI 测试可以为项目团队提供足够的信息，以决定应用程序是否可以部署，或者我们需要重新组织一些功能以满足用户需求。
- en: So, that being said, will I always will need a person who should be verifying
    a functionality manually? Yes and no. This theme is really hard to explain, because
    different points of view can be referenced and in some cases, contradicted. For
    these cases, we will focus on some very useful testing techniques in the next
    section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这么说来，我是否总是需要一个手动验证功能的人？是的，也不是。这个主题真的很难以解释，因为可以引用不同的观点，在某些情况下，甚至可能相互矛盾。对于这些情况，我们将在下一节中关注一些非常有用的测试技术。
- en: Scripted testing
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本测试
- en: Just like its name, scripted testing based on prescripts elaborated by software
    testers to detect whether there are some functionalities not covered for the application
    at that moment. For example, a script doing a login, saving some data, and then
    retrieving it from another screen. The script defines the predefined data that
    the tester will use to evaluate each screen and the expected output. Then, the
    tester analyzes the results and reports any found defects to the application development
    team. Scripted testing can be performed manually by humans or can be supported
    by test automation through CI tools.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像它的名字一样，基于软件测试人员编写的预脚本进行脚本测试，以检测应用程序是否在那一刻遗漏了某些功能。例如，一个脚本执行登录、保存一些数据，然后从另一个屏幕检索它。脚本定义了测试人员将用于评估每个屏幕的预定义数据以及预期的输出。然后，测试人员分析结果，并向应用程序开发团队报告发现的任何缺陷。脚本测试可以由人工手动执行，也可以通过CI工具支持测试自动化。
- en: The advantage is that you can divide the work between your most experienced
    developers to write the scripts and the entry-level developers to run the script
    and analyze the data, giving maintenance and learning the business requirements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 优点在于，你可以将工作分配给你的最有经验的开发者来编写脚本，以及初级开发者来运行脚本和分析数据，从而进行维护和学习业务需求。
- en: The disadvantage is that it's hard to maintain if your UI changes frequently.
    This kind of testing is highly coupled with your business code so if it changes,
    the entire test should change too.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点在于，如果你的用户界面频繁更改，维护起来会很困难。这种测试与你的业务代码高度耦合，因此如果业务代码发生变化，整个测试也应该随之改变。
- en: Exploratory testing
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索性测试
- en: In this kind of testing, we won't use any automated script. It enforces the
    tester to use the application as a common user and evaluate aspects such as design,
    how easy our product is for the final users, how is the user experience, alternative
    workflows, and more. The tester may identify any failure regarding these aspects
    and provide valuable feedback to developers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种测试中，我们不会使用任何自动化脚本。这强制测试人员以普通用户的方式使用应用程序，并评估设计、我们的产品对最终用户来说有多容易、用户体验如何、替代工作流程等方面。测试人员可以识别与这些方面相关的任何失败，并向开发人员提供有价值的反馈。
- en: Since explanatory tests do not use scripts, there is still pre-planning. In
    real-life situations, commonly in session-based exploratory testing, the testers
    team sets goals for the planned tests and defines a time frame to perform exploratory
    testing in focused areas. All this information is introduced in a document called
    test-charter. Sessions and results of exploratory testing are documented in a
    report and reviewed in the daily meeting with the entire team.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解释性测试不使用脚本，仍然需要进行预先规划。在现实情况下，通常在基于会话的探索性测试中，测试团队为计划中的测试设定目标，并定义一个时间框架来在重点区域进行探索性测试。所有这些信息都包含在一个称为测试宪章的文档中。探索性测试的会话和结果在报告中记录，并在与整个团队的日常会议中审查。
- en: The advantage is that testers have more time to focus on the actual testing,
    because the time to prepare test cases and look at boring documentation is reduced,
    becoming a constant challenge to find more issues and increase their business
    knowledge.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 优点在于，测试人员有更多的时间专注于实际的测试，因为准备测试用例和查看无聊的文档所需的时间减少了，这成为了一个不断挑战，即寻找更多问题和增加他们的业务知识。
- en: The disadvantage is that this kind of test is not auto-executable and of course,
    cannot be repeated to be used as a regression test. Also, you will need testers
    with a deep understanding of your business requirements that most of the time
    are hard to find. In addition, in real-time scenarios, it may be impractical to
    try to cover an entire application with exploratory testing since we won't find
    enough testers with the required knowledge about the product.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试的另一个缺点是它不是自动可执行的，当然也不能重复执行作为回归测试。此外，你可能需要具有深入理解你的业务需求的测试人员，而这通常很难找到。此外，在实时场景中，尝试通过探索性测试覆盖整个应用程序可能是不切实际的，因为我们不会找到足够了解产品所需知识的测试人员。
- en: UX testing
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户体验测试
- en: In user experience testing, actual end users (or user representatives) evaluate
    an application for its ease of use, visual appearance, and ability to meet their
    needs. The users will explore all the applications in an isolated environment
    called UAT, which can be configured in a local server or some cloud provider.
    You must keep in mind that it does not matter where the product is deployed, it
    should represent the same conditions as your production environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户体验测试中，实际最终用户（或用户代表）评估应用程序的易用性、视觉外观以及满足其需求的能力。用户将在一个称为UAT的隔离环境中探索所有应用程序，该环境可以配置在本地服务器或某些云服务提供商上。您必须记住，产品部署的位置无关紧要，它应该代表与您的生产环境相同的条件。
- en: Don’t confuse user experience testing (UX) with user acceptance testing (UAT).
    UAT is a testing level that verifies that a given application meets demanded requirements
    focusing only on business use cases. For example, in UAT, you can ensure that
    your Retrieve Teams button works correctly and returns the correct data well formatted.
    So, it's not enough? Of course no, because you don't know yet whether your button
    is well placed or whether it's difficult to find from the end user's perspective.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将用户体验测试（UX）与用户验收测试（UAT）混淆。UAT是一个测试级别，它验证给定的应用程序是否满足需求，仅关注业务用例。例如，在UAT中，您可以确保您的检索团队按钮工作正常并返回格式良好的正确数据。所以，这还不够吗？当然不够，因为您还不知道按钮是否放置得当，或者从最终用户的角度来看是否难以找到。
- en: Okay, now that we understand how this kind of testing works, which one should
    we apply? All taken decisions regarding testing should target to maximize the
    value of the product for its final users, even by detecting bugs or unexpected
    features, and by ensuring functionality and usability. To achieve this goal, in
    real-time situations, we will need a combination of all different test techniques
    reviewed at this time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们了解了这种测试是如何工作的，我们应该应用哪一种？关于测试的所有决策都应该旨在最大化产品对最终用户的价值，即使是通过检测错误或意外功能，并确保功能性和可用性。为了实现这一目标，在实时情况下，我们需要结合所有不同类型的测试技术，这些技术在此期间已审查。
- en: Planning our tests – Time for the truth
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划我们的测试——真理的时刻
- en: Planning is a very important phase of any project, and this won't be an exception. It
    is important to have a test plan that identifies the resources available for testing
    and that prioritizes areas of the application to be tested before we start writing
    our cases. With this information, the testing team will be able to create test
    scenarios, test cases, and test scripts for scripted testing, documented in the
    test charter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 规划是任何项目的非常重要的阶段，这也不例外。在开始编写用例之前，拥有一个识别可用于测试的资源并优先考虑要测试的应用程序区域的测试计划非常重要。有了这些信息，测试团队将能够创建测试场景、测试用例和测试脚本，并在测试宪章中记录。
- en: 'This is an example of the structure that our test plan should contain:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们测试计划应包含的结构示例：
- en: Defined dates for each test
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试的明确日期
- en: Required testers
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要的测试人员
- en: Required resources such as servers, environments, tools, and cloud providers
    correctly configured to start testing
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要的资源，如服务器、环境、工具和云服务提供商，必须正确配置以开始测试
- en: Target application environments, such as different screen resolutions, mobile
    devices, and supported browsers
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标应用程序环境，例如不同的屏幕分辨率、移动设备和支持的浏览器
- en: User workflows/navigation to test
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要测试的用户工作流程/导航
- en: Testing techniques to be used, including scripted testing, exploratory testing,
    and user experience testing
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要使用的测试技术，包括脚本测试、探索性测试和用户体验测试
- en: Goals for testing, including the acceptance criteria to determine if a test
    passes or fails
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试目标，包括验收标准以确定测试是否通过或失败
- en: 'Also, we can add some more sections according to our own needs:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以根据我们的需求添加更多部分：
- en: '![](img/534f2510-9baf-4cf3-80e3-0cd8e5ab2b6d.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/534f2510-9baf-4cf3-80e3-0cd8e5ab2b6d.png)'
- en: Test plans can be text documents, excel tables, or a test management tool to
    develop the test plan to support analysis and reporting. There are many tools
    available, some of them to download into your private server and others to be
    used on a cloud provider.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试计划可以是文本文档、Excel表格或测试管理工具，用于开发测试计划以支持分析和报告。有许多工具可供选择，其中一些可以下载到您的私有服务器，而另一些则可在云服务提供商上使用。
- en: Our GUI test plan should not be considered as a full system test plan. You can
    also consider other aspects such as load testing, security, backup, fault tolerance,
    and recovery.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GUI测试计划不应被视为完整的系统测试计划。您还可以考虑其他方面，如负载测试、安全性、备份、容错和恢复。
- en: 'Done, we have our plan! What''s next? Identify our testing priorities. For
    example, first of all, we need to ensure the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了，我们有了我们的计划！接下来是什么？确定我们的测试优先级。例如，首先，我们需要确保以下内容：
- en: Visual design
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉设计
- en: Security
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Usability
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户体验
- en: Compliance
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合规性
- en: Functionality
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性
- en: Performance
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: 'Now, it''s time to represent it in a mental map to be understood by the entire
    team and perform the required tests. Check out this example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将其表示为整个团队都能理解的心智图，并执行所需的测试。查看以下示例：
- en: '![](img/cff9be57-89ea-454f-af08-f9870377c79e.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cff9be57-89ea-454f-af08-f9870377c79e.png)'
- en: 'The most common areas to test when we are navigating on a web application are
    these:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Web应用程序中导航时，最常见的测试区域是这些：
- en: Compatibility with different versions of most used browsers
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与大多数常用浏览器不同版本的兼容性
- en: Behavior when the user clicks on the back or refresh button (in browser)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户点击浏览器中的后退或刷新按钮时的行为
- en: Behavior after a user returns to the page using a bookmark or their browser
    history
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用书签或浏览器历史记录返回页面后的行为
- en: Behavior when the user has multiple browser windows open on the UAT at the same
    time
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户同时在UAT上打开多个浏览器窗口时的行为
- en: Defining common scenarios
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义常见场景
- en: We can define a test scenario as a brief statement describing how an application
    will be used in specific real-life situations, for example, “the user will be
    able to log in with a valid username and password.” Commonly, test scenarios are
    written from development documents such as requirements or user stories, each
    one with the required acceptance criteria to accomplish that. If these documents
    are not created yet, product owners should write them and define the different
    scenarios and acceptance criteria to mark the product as complete.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将测试场景定义为描述应用程序如何在特定实际情况下使用的简要声明，例如，“用户将能够使用有效的用户名和密码登录。”通常，测试场景是从开发文档（如需求或用户故事）中编写的，每个场景都有完成该任务所需的可接受标准。如果这些文档尚未创建，产品负责人应该编写它们，并定义不同的场景和可接受标准，以标记产品已完成。
- en: Scenarios are useful because they can guide exploratory testing, giving a good
    understanding of a GUI event, without restricting the testing team to a specific
    procedure. Since it is much faster to create a test scenario instead of writing
    a full test case, scenarios are most used in agile environments.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 场景是有用的，因为它们可以指导探索性测试，对GUI事件有一个良好的理解，而不限制测试团队遵循特定的程序。由于创建测试场景比编写完整的测试用例要快得多，因此场景在敏捷环境中被广泛使用。
- en: If scenarios are used in scripted testing, they can be used as the base from
    which test cases can be written.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在脚本测试中使用场景，它们可以作为编写测试用例的基础。
- en: 'For example, the *login scenario* mentioned earlier can have test cases for
    GUI events such as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面提到的*登录场景*可以包含以下GUI事件的测试用例：
- en: User enters a valid username and password
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入有效的用户名和密码
- en: User enters invalid username
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入无效的用户名
- en: User enters valid username but invalid password
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入有效的用户名但无效的密码
- en: User tries to reset the password
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户尝试重置密码
- en: User presses the Submit button repeatedly
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户反复点击提交按钮
- en: '![](img/11e36bd5-80ad-4c47-9c89-858d95450e3f.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11e36bd5-80ad-4c47-9c89-858d95450e3f.png)'
- en: Writing test cases
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: Commonly, this document starts with a brief description of a GUI event to be
    tested, we will still use the example about the login attempt. We should specify
    conditions and steps for executing the test. Finally, we need to evaluate the
    expected result of the test and define the acceptance criteria for determining
    whether the test succeeds or fails.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这份文档会从对要测试的GUI事件的简要描述开始，我们仍将使用登录尝试的例子。我们应该指定测试执行的条件和步骤。最后，我们需要评估测试的预期结果，并定义确定测试成功或失败的可接受标准。
- en: 'You must keep in mind some considerations such as the ones listed here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须记住一些考虑因素，例如以下列出的：
- en: How often the user interface changes
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面变化的频率
- en: How much freedom end users will have when navigating through the application
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当最终用户在应用程序中导航时，他们将有多少自由度
- en: If you have testers with less experience, they may need more detailed procedures
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有的测试人员经验较少，他们可能需要更详细的程序
- en: 'What to include? Good question. Similar to our planning template, we need to
    put our acceptance criteria organized in a document where we can check and save
    the evolution of each test case. Here''s a very basic example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 应包含哪些内容？这是个好问题。类似于我们的规划模板，我们需要将我们的可接受标准组织在一个文档中，以便我们可以检查和保存每个测试用例的演变。以下是一个非常基本的例子：
- en: '![](img/73de0547-f09d-4247-b359-afd1fd2c9826.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73de0547-f09d-4247-b359-afd1fd2c9826.png)'
- en: It's important that you have separated your test data for test cases. Most of
    the time, issues are products of validation errors in the project, so the development
    teams must know which parameters caused this error. Always remember that application
    development is a team work, so you must give all the facilities to your colleagues
    to get the best product.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你为测试用例分离了测试数据非常重要。大多数情况下，问题是由项目中的验证错误产生的，因此开发团队必须知道哪些参数导致了这个错误。始终记住，应用程序开发是一个团队工作，所以你必须为你的同事提供所有便利，以获得最佳产品。
- en: Organizing our test – Creating scripts
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织我们的测试 - 创建脚本
- en: This is the most detailed part of our test. Here, we will define the steps and
    procedures to execute our test. Create sufficient test scripts to verify paths
    that users will take through the UAT.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的测试中最详细的部分。在这里，我们将定义执行我们的测试的步骤和程序。创建足够的测试脚本以验证用户将通过 UAT 采取的路径。
- en: Always remember to document the input data and the expected output; it will
    be very important when we have to deal with unexpected events.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得记录输入数据和预期输出；当我们必须处理意外事件时，这将非常重要。
- en: API test with Swagger
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swagger 进行 API 测试
- en: In the last section, we were centered in the E2E testing of our entire application
    starting from the frontend, but what about our API itself? Remember that one API
    can be used to serve many client types such as web or mobile. So, don't you think
    it would be awesome to ensure this functionality independently from the entire
    application life cycle? Sure, we know you agree, and we have in mind a very nice
    solution to accomplish this objective—Swagger.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们专注于从前端开始对整个应用程序的端到端测试，但我们的 API 本身呢？记住，一个 API 可以用于服务许多客户端类型，如网页或移动。所以，你不认为确保这个功能独立于整个应用程序生命周期会很好吗？当然，我们知道你同意，我们心中有一个非常棒的解决方案来实现这个目标——Swagger。
- en: 'Swagger is a specification and a nice group of tools to write RESTful APIs.
    Based on their own web page definition:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 是一个规范和一组编写 RESTful API 的优秀工具。根据他们自己的网页定义：
- en: '"Swagger is the world’s largest framework of API developer tools for the OpenAPI
    Specification (OAS), enabling development across the entire API life cycle, from
    design and documentation, to test and deployment."'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '"Swagger 是 OpenAPI 规范 (OAS) 的世界最大 API 开发者工具框架，它使整个 API 生命周期（从设计、文档到测试和部署）的开发成为可能。"'
- en: 'In the group of tools we have in Swagger, we can find these:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swagger 的工具组中，我们可以找到以下工具：
- en: 'Swagger Editor: This tool will allow us to view the updated document in real
    time.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger Editor：这个工具将允许我们实时查看更新的文档。
- en: 'Swagger Codegen: A template-driven engine to generate interactive documents.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger Codegen：一个模板驱动的引擎，用于生成交互式文档。
- en: 'Swagger UI: Allows to visualize the RESTful API, and check input and responses. So,
    *Swagger UI* takes an existing JSON or YAML document and creates interactive documentation.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger UI：允许可视化 RESTful API，并检查输入和响应。因此，*Swagger UI* 从现有的 JSON 或 YAML 文档中创建交互式文档。
- en: Installing Swagger
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Swagger
- en: Let's start getting our most important dependency, Swagger. Remember that we
    will use NPM to download Swagger, because we will use it on a ExpressJS API. Swagger
    has its own implementation depending on the platform you need to document.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始获取我们最重要的依赖项，Swagger。记住，我们将使用 NPM 下载 Swagger，因为我们将在 ExpressJS API 上使用它。Swagger
    根据您需要记录的平台有自己的实现。
- en: 'There are two very famous swagger implementations to integrate with an ExpressJS
    application:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种非常著名的 Swagger 实现可以与 ExpressJS 应用程序集成：
- en: '`swagger-node-express`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swagger-node-express`'
- en: '`swagger-ui-express`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swagger-ui-express`'
- en: 'The `swagger-node-express` is the official *Swagger* module for *Node*. Some
    of the most interesting (and not so) characteristics of this library are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`swagger-node-express` 是官方的 *Swagger* 模块，用于 *Node*。这个库的一些有趣（和不那么有趣）的特性如下：'
- en: Official distribution of the Swagger API. We are fully supported by an organization
    working actively on the development of the product.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger API 的官方发行版。我们得到了一个积极致力于产品开发的组织的全面支持。
- en: It is open source.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是开源的。
- en: Comes with *Swagger Editor* and Swagger Codegen.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附带 *Swagger Editor* 和 Swagger Codegen。
- en: '*Swagger UI* needs to be inserted inside the code where we are adding documentation.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Swagger UI* 需要插入到我们添加文档的代码中。'
- en: Since documentation is quite poor, you need to read the source code of some
    different libraries to learn and understand each argument used to configure Swagger.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于文档相当匮乏，你需要阅读一些不同库的源代码来学习和理解用于配置 Swagger 的每个参数。
- en: The `swagger-ui-express` is supported by the community, another great open source
    option. How does it work? This library adds a middleware to your Express.jsapplication
    that serves the Swagger UI bound to your Swagger document. It's really easy to
    configure; the only thing you will need to perform is add one route to host Swagger
    UI, without need to copy anything manually. Documentation is really good, and
    we think everything you need should be there.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`swagger-ui-express`由社区支持，另一个优秀的开源选项。它是如何工作的？这个库为你的Express.js应用程序添加了一个中间件，该中间件提供与你的Swagger文档绑定的Swagger
    UI。配置起来非常简单；你需要做的只是添加一个路由来托管Swagger UI，无需手动复制任何内容。文档非常好，我们认为你需要的一切都应该在那里。'
- en: Given the functionality and simplicity of this tool, we've decided to use this
    library instead of any other option to achieve our main goal of documenting our
    application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个工具的功能性和简单性，我们决定使用这个库而不是其他任何选项来实现我们记录应用程序的主要目标。
- en: 'To get started, we need to add the library to our current project:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要将这个库添加到我们的当前项目中：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once the library is added to our project, we need to configure a route to host Swagger
    UI. Also, we need to load the Swagger API definition of our application. In our
    application, the Swagger API definition is a single file containing information
    about our application represented in a JSON object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将库添加到我们的项目中，我们需要配置一个路由来托管Swagger UI。此外，我们还需要加载我们应用程序的Swagger API定义。在我们的应用程序中，Swagger
    API定义是一个包含我们应用程序信息的JSON对象的单一文件。
- en: 'To create the Swagger API definition, we have used Swagger Editor. Remember
    that you are free to use JSON or YAML notation. Let''s look at an example of the
    same definition in different formats:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Swagger API定义，我们使用了Swagger Editor。记住，你可以自由地使用JSON或YAML标记。让我们看看同一定义在不同格式下的示例：
- en: 'In JSON it is done as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON中，操作如下：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In YAML:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在YAML中：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both are very human readable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都非常易于阅读。
- en: Even if our specification file is a text that can be edited with any text editor, nowadays
    we have many specialized tools to achieve this, giving us some useful features
    such as syntax validation, format, autocomplete parameters, and more. The best
    option to write specification file is Swagger Editor (yes, its own tool), a powerful
    set of static files that allows you to write and validate Swagger specification
    in YAML syntax and see how your file will look rendered.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的规范文件是可以用任何文本编辑器编辑的文本，但现在我们有许多专门的工具来实现这一点，给我们提供了一些有用的功能，如语法验证、格式、自动完成参数等。编写规范文件的最佳选项是Swagger
    Editor（是的，它自己的工具），一组强大的静态文件，允许你使用YAML语法编写和验证Swagger规范，并查看你的文件渲染后的样子。
- en: 'The created Swagger API definition will be stored in our application as a JSON
    object inside the `swagger.json` file. At this moment, our setup script should
    look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的Swagger API定义将作为JSON对象存储在我们的应用程序的`swagger.json`文件中。此时，我们的设置脚本应该看起来像这样：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, first middleware is setting up our Swagger server. This middleware
    will return static files that are needed for hosting Swagger UI. Second middleware
    is our setup function that will set up Swagger UI to use our predefined users
    parameters in the `json/yml` file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一个中间件是设置我们的Swagger服务器。这个中间件将返回托管Swagger UI所需的静态文件。第二个中间件是我们的设置函数，它将设置Swagger
    UI以使用我们在`json/yml`文件中预定义的用户参数。
- en: Also, of course, our documentation URL is `http://localhost:3000/api-docs`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的文档URL是 `http://localhost:3000/api-docs`。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You are now just one step away from getting the maximum knowledge about full-stack
    applications and all the stuff it concerns. As we said earlier, one of the most
    important parts, and the one that makes the difference between just a programmer
    and a full-stack application developer, is testing. This chapter was meant to
    be easily understandable and highly applicable in your day-to-day work, giving
    you the most modern concepts and tools used in application testing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在只需一步就能获得关于全栈应用程序及其相关内容的最大知识。正如我们之前所说，最重要的部分之一，也是区分程序员和全栈应用程序开发者的关键，是测试。这一章旨在易于理解，并在你的日常工作中高度适用，为你提供应用测试中最现代的概念和工具。
- en: You need to remember that integration tests are the assurance process of all
    components working well together, such third-party systems, external databases,
    and asynchronous processes. Depending on which platform you use, you will have
    a complete ecosystem to accomplish this and get the best value from your application.
    The best part is that you can automate all the tests at this layer and make your
    deployment process safer. One thing you cannot test using script is the usability
    of the application. You will need real humans to interact with your product and in
    this layer different UI testing techniques come to the rescue. Remember that user
    experience is one differential when you need to offer your products to the market.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住，集成测试是确保所有组件协同工作良好的保证过程，例如第三方系统、外部数据库和异步进程。根据你使用的平台，你将拥有一个完整的生态系统来完成这项任务，并从你的应用程序中获得最佳价值。最好的部分是你可以在这个层面自动化所有测试，使你的部署过程更安全。有一件事你不能使用脚本进行测试，那就是应用程序的可用性。你需要真实的人类来与你的产品互动，在这个层面，不同的UI测试技术会提供帮助。记住，当你需要将产品推向市场时，用户体验是一个重要的差异化因素。
- en: Finally, all the different tests need to be documented to be used by other developers
    to improve more features of your application. Swagger is a very nice and simple
    tool to generate a detailed documentation and share with your team.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有不同的测试都需要被记录下来，以便其他开发者可以使用它们来改进你应用程序的更多功能。Swagger是一个非常棒且简单的工具，可以生成详细的文档并与你的团队共享。
- en: Now we have completely covered the testing phase! You know what time it is...
    Let's deploy! See you in the next chapter!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全覆盖了测试阶段！你知道现在是时候了... 让我们部署吧！下一章见！
