- en: '*Chapter 15*: Adding GraphQL Schema Part I'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：添加GraphQL模式第一部分'
- en: In this chapter, we'll continue building out our application by integrating
    GraphQL. We'll do this on both the client and the server. We'll also finish building
    out our backend Express server and integrating that backend with our React client.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续通过集成GraphQL来构建我们的应用程序。我们将在客户端和服务器上都这样做。我们还将完成构建后端Express服务器并将该后端与我们的React客户端集成。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Creating GraphQL server-side typedefs and resolvers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GraphQL服务器端的typedefs和解析器
- en: Integrating authentication with GraphQL resolvers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将身份验证与GraphQL解析器集成
- en: Creating React client-side Hooks for querying Apollo GraphQL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为查询Apollo GraphQL创建React客户端Hooks
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You should have a basic understanding of GraphQL and a good understanding of
    React, Node.js, Postgres, and Redis. We will once again be using Node and **Visual
    Studio Code** (**VSCode**) to write our code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对GraphQL有基本的了解，并且对React、Node.js、Postgres和Redis有很好的了解。我们将再次使用Node和**Visual
    Studio Code**（**VSCode**）来编写我们的代码。
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in folder `Chap15`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库位于[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node)。使用`Chap15`文件夹中的代码。
- en: 'To set up the [*Chapter 15*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222)
    code folder, do this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置[*第15章*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222)代码文件夹，请执行以下操作：
- en: Go to your `HandsOnTypescript` folder and create a new folder called `Chap15`.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的`HandsOnTypescript`文件夹，并创建一个名为`Chap15`的新文件夹。
- en: Now go to the `Chap14` folder and copy the `super-forum-server` folder into
    the `Chap15` folder. Make certain all files have been copied.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到`Chap14`文件夹，并将`super-forum-server`文件夹复制到`Chap15`文件夹中。确保所有文件都已复制。
- en: 'Within the `super-forum-server` folder delete the `node_modules` folder and
    the `package-lock.json` file. Make sure you''re in the `super-forum-server` folder
    and run this command:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`super-forum-server`文件夹中删除`node_modules`文件夹和`package-lock.json`文件。确保您在`super-forum-server`文件夹中，并运行此命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now make sure your Postgres server and Redis server are running, as shown in
    [*Chapter 13*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208), *Setting Up a
    Session State Using Express and Redis*, and [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216),
    *Setting Up Postgres and Repository Layer with TypeORM*. Then, test your server
    by running this command:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在确保您的Postgres服务器和Redis服务器正在运行，如[*第13章*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208)中所示，*使用Express和Redis设置会话状态*，以及[*第14章*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216)，*使用TypeORM设置Postgres和存储库层*。然后，通过运行此命令来测试您的服务器：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now let's copy our client app. Go to the `Chap13` folder and copy `super-forum-client`
    to the root of `Chap15`. Make sure all files are copied over.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们复制我们的客户端应用。转到`Chap13`文件夹，将`super-forum-client`复制到`Chap15`的根目录。确保所有文件都已复制。
- en: 'Delete the `node_modules` folder and the `package-lock.json` file. Now make
    sure you''re in the `super-forum-client` folder and run this command:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`node_modules`文件夹和`package-lock.json`文件。现在确保您在`super-forum-client`文件夹中，并运行此命令：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Test that it works by running this:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行此命令测试它是否有效：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating GraphQL server-side typedefs and resolvers
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建GraphQL服务器端typedefs和解析器
- en: In this section, we'll add our GraphQL service to our Express server. We'll
    also start transforming our routes into GraphQL queries, which we created in [*Chapter
    14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216), *Setting Up* *Postgres and
    Repository Layer with TypeORM*. We'll also flesh out the rest of the calls that
    we need, as GraphQL queries.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把GraphQL服务添加到我们的Express服务器中。我们还将开始将我们在[*第14章*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216)中创建的路由转换为GraphQL查询。我们还将完善我们需要的其余调用，作为GraphQL查询。
- en: 'Let''s start by first integrating GraphQL into our Express application (we
    covered GraphQL in [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, and [*Chapter 10*](B15508_10_Final_JC_ePub.xhtml#_idTextAnchor147),
    *Setting Up an Express Project with TypeScript and GraphQL Dependencies*):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将GraphQL集成到我们的Express应用程序中（我们在[*第9章*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139)中介绍了GraphQL，*什么是GraphQL*，以及[*第10章*](B15508_10_Final_JC_ePub.xhtml#_idTextAnchor147)，*使用TypeScript和GraphQL依赖项设置Express项目*）：
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There will be a very large amount of code in this chapter and not all of it
    can be shown in text. Please refer to the chapter source code, which is the GitHub
    repository code, frequently. Note also the chapter source code is the final running
    project and will contain only the final working code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将有大量的代码，不是所有代码都可以在文本中显示。请经常参考GitHub存储库代码，这是章节源代码。还要注意，章节源代码是最终运行的项目，只包含最终的工作代码。
- en: 'Let''s begin by installing GraphQL. Run this command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始安装GraphQL。运行这个命令：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let''s create our initial type definitions, `typeDefs`. Create a folder
    called `gql` inside of the `src` folder. Then create the file `typeDefs.ts` inside
    of it. Now add this code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的初始类型定义`typeDefs`。在`src`文件夹内创建一个名为`gql`的文件夹。然后在其中创建文件`typeDefs.ts`。现在添加此代码：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We define a new custom `scalar` type, `Date`, not available by default in GraphQL
    for dates and times:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个新的自定义`scalar`类型，`Date`，在GraphQL中默认不可用于日期和时间：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This `EntityResult` type will be used when errors or messages are returned
    instead of entities from our resolvers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`EntityResult`类型将在我们的解析器返回错误或消息而不是实体时使用：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We created our `User` type here. Notice the relations to `Thread` and `ThreadItem`.
    We''ve also used our `Date` type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了我们的`User`类型。注意到与`Thread`和`ThreadItem`的关系。我们还使用了我们的`Date`类型：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We created our `Thread` type and its relations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了我们的`Thread`类型及其关系：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we are implementing our real application, it's time to use some more
    sophisticated features of GraphQL. The `union` type is the same concept as in
    TypeScript. It will allow us to return any type from a list of possible GraphQL
    types. For example, in this example, this type may represent *either* a Thread
    or an EntityResult, but not both at the same time. I'll show the usage of this
    type soon and it will become clearer how it works.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在实现我们的真实应用程序，是时候使用一些更复杂的GraphQL特性了。`union`类型与TypeScript中的概念相同。它将允许我们从可能的GraphQL类型列表中返回任何类型。例如，在这个例子中，这个类型可以表示*要么*是Thread，要么是EntityResult，但不能同时是两者。我将很快展示这种类型的用法，它将变得更清晰。
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We created our `ThreadItem` type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了我们的`ThreadItem`类型。
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ThreadCategory` type also refers to the `Threads` that it contains.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadCategory`类型还指的是它包含的`Threads`。'
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we have our `Query` with the `getThreadById` function. Notice it returns
    our `union` `ThreadResult`. We'll flesh this out more later.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个带有`getThreadById`函数的`Query`。注意它返回我们的`union` `ThreadResult`。我们稍后会详细介绍这个。
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s create a simple resolvers file to get started with our GraphQL installation.
    Create a file called `resolvers.ts` in the `gql` folder and add this code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个简单的解析器文件，以开始使用我们的GraphQL安装。在`gql`文件夹中创建一个名为`resolvers.ts`的文件，并添加以下代码：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ll be using `EntityResult` as our return type for errors and status messages.
    Also, add our type mapping to the same type in the `typeDefs` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`EntityResult`作为我们的错误和状态消息的返回类型。还要将我们的类型映射添加到`typeDefs`文件中的相同类型：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s another new feature of GraphQL we are using. `ThreadResult` is the
    `union` that represents the two types, `Thread` and `EntityResult`, in GraphQL.
    This resolver notices when a `ThreadResult` is about to be returned and figures
    out which type it is internally. The method you use is entirely up to you to determine
    the type sent back, but here we have used a simple check for the `EntityResult`
    type''s `message` field by checking `obj.message`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们正在使用的GraphQL的另一个新特性。`ThreadResult`是在GraphQL中表示两种类型`Thread`和`EntityResult`的`union`。这个解析器注意到即将返回一个`ThreadResult`，并在内部确定它是哪种类型。您使用的方法完全取决于您确定要发送的类型，但在这里，我们通过检查`obj.message`对`EntityResult`类型的`message`字段进行了简单的检查：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We learned about GraphQL queries in [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, so I won't go over it too deeply here. Just note that in this
    call, I accept the result type from the call to `getThreadById`, `QueryOneResult`,
    and after some processing, I return the actual entity itself or `EntityResult`.
    Again, since our `typeDefs` file has our query as returning a `ThreadResult`,
    it will go to the `ThreadResult` query and figure out which type to return. This
    is a pattern that we'll repeat for most of our repository calls. Repositories
    were covered in [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216),
    *Setting Up Postgres and Repository Layer with TypeORM*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第9章*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139)中学习了GraphQL查询，所以我不会在这里过多地介绍它。只需注意，在这个调用中，我接受来自`getThreadById`调用的结果类型`QueryOneResult`，并在一些处理之后，返回实际的实体本身或`EntityResult`。同样，由于我们的`typeDefs`文件将我们的查询返回为`ThreadResult`，它将转到`ThreadResult`查询并确定要返回的类型。这是我们将重复用于大多数存储库调用的模式。存储库在[*第14章*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216)中有所涵盖，*使用TypeORM设置Postgres和存储库层*。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For this sample application, we are just rethrowing the errors that may occur.
    But in your production app, you should handle the error as appropriate to your
    app, which, in general, means to at least log the issue so it can be looked at
    later.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例应用程序，我们只是重新抛出可能发生的错误。但在您的生产应用程序中，您应该根据您的应用程序适当地处理错误，通常意味着至少记录问题，以便以后查看。
- en: We will populate this code with more queries and mutations later, but for now,
    let's focus on completing our base setup.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后用更多的查询和变异填充这段代码，但现在让我们专注于完成我们的基本设置。
- en: Copy and paste the `GqlContext.ts` file from the `Chap10/gql-server/src` folder
    into the `gql` folder. As shown in [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, this is where our Request and Response objects live inside
    of a GraphQL call.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Chap10/gql-server/src`文件夹中的`GqlContext.ts`文件复制并粘贴到`gql`文件夹中。正如我们在[*第9章*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139)中所展示的，*什么是GraphQL？*，这是我们的请求和响应对象在GraphQL调用中的位置。
- en: 'Now let''s open our `index.ts` file and add GraphQL into it. Update it by adding
    this code just before the call to `listen` and make sure to add the necessary
    imports, which you should be able to do yourself now:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们打开我们的`index.ts`文件，并将GraphQL添加到其中。在调用`listen`之前添加以下代码，并确保添加必要的导入，现在您应该能够自己完成：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is basically similar code to [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, where we instantiate our `ApolloServer` and bring it our `typeDefs`,
    `resolvers`, and Express `app` instance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是与[*第9章*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139)中相似的代码，*什么是GraphQL？*，在那里我们实例化我们的`ApolloServer`并将其带入我们的`typeDefs`、`resolvers`和Express`app`实例。
- en: Let's test this to make sure it's working. Open the URL `http://localhost:5000/graphql`.
    This is the GraphQL playground we reviewed in [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*. Run it as shown:![Figure 15.1 – First query into GraphQL
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试一下，确保它能正常工作。打开URL `http://localhost:5000/graphql`。这是我们在[*第9章*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139)中审查过的GraphQL
    playground，*什么是GraphQL？*。按照所示运行它：![图15.1 – 对GraphQL的第一个查询
- en: '](img/Figure_15.01_B15508.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.01_B15508.jpg)'
- en: Figure 15.1 – First query into GraphQL
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – 对GraphQL的第一个查询
- en: So, as you can see, our call now works. The only difference from some of our
    prior calls into GraphQL is that since our call could return two different types,
    we use the `… on <some type>` syntax to decide which entity and fields we want
    upon return (this feature is called inline fragments). Also, again, please remember
    your local ID numbers will not necessarily be the same as mine, so you need to
    send IDs that definitely exist in your database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可以看到，我们的调用现在可以工作了。与我们之前对GraphQL的一些调用的唯一区别是，由于我们的调用可能返回两种不同的类型，我们使用`… on
    <some type>`语法来决定返回时我们想要哪个实体和字段（这个功能称为内联片段）。同样，请记住你的本地ID号可能不会和我的一样，所以你需要发送在你的数据库中确实存在的ID。
- en: 'OK, let''s do another. This time, we''ll pick one that does not return an entity
    – the `createThread` function. First, add this mutation to the end of your `typeDefs`
    file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们再做一个。这次，我们选择一个不返回实体的函数 - `createThread`函数。首先，在你的`typeDefs`文件末尾添加这个mutation：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice we are not returning a `ThreadResult`. Our `createThread` function only
    returns a string message. So that's all we need.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们没有返回`ThreadResult`。我们的`createThread`函数只返回一个字符串消息。所以这就是我们需要的全部。
- en: 'Now let''s update the `resolvers` file. Add this function as a mutation. Again,
    you''ll need to import anything that is needed yourself:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们更新`resolvers`文件。将此函数作为一个mutation添加进去。同样，你需要自己导入所需的任何内容：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Again, the same parameters list as always, but this time we return only the
    `EntityResult` as there is no need to return the entire entity:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，和往常一样的参数列表，但这次我们只返回`EntityResult`，因为没有必要返回整个实体：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we made our call to the repository's `createThread` and got back our result.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了存储库的`createThread`并得到了结果。
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And now we're returning the list of possible messages to indicate the status
    of the result.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在返回可能的消息列表来指示结果的状态。
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, in production, you should not simply rethrow but log or otherwise deal
    with an error. We rethrow here in order to simplify and focus on the concepts
    at hand, without getting sidetracked.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，你不应该简单地重新抛出异常，而是应该记录或以其他方式处理错误。我们在这里重新抛出异常是为了简化并专注于手头的概念，而不要被岔开。
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, now if we run our code, we should see this:![Figure 15.2 – createThread
    function
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，现在如果我们运行我们的代码，我们应该会看到这个：![图15.2 - createThread函数
- en: '](img/Figure_15.02_B15508.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.02_B15508.jpg)'
- en: Figure 15.2 – createThread function
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 - createThread函数
- en: 'OK, so let''s do one more call for Threads. In the `ThreadRepo` is the call
    `getThreadsByCategoryId`, which returns an array of Threads. This is a problem
    because the GraphQL `union` operator does not support arrays. So we''ll need to
    create another new entity in the `typeDefs` file to represent an array of Threads
    and then we can create our union. Update the `typeDefs` file by adding this under
    the ThreadResult union:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，让我们再为Threads做一个调用。在`ThreadRepo`中有一个调用`getThreadsByCategoryId`，它返回一个Threads数组。这是一个问题，因为GraphQL的`union`运算符不支持数组。所以我们需要在`typeDefs`文件中创建另一个新的实体来表示一个Threads数组，然后我们可以创建我们的union。通过在ThreadResult
    union下面添加以下内容来更新`typeDefs`文件：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So we created an entity that returns an array of Threads first. Then we created
    our `union` that either returns that entity type or the `EntityResult`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们首先创建了一个返回Threads数组的实体。然后我们创建了我们的`union`，它可以返回该实体类型或`EntityResult`。
- en: 'Now add this after the `getThreadById` query:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`getThreadById`查询之后添加这个：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can build our resolver. Update the `resolvers` Query section by adding
    this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以构建我们的解析器。通过添加以下内容更新`resolvers`查询部分：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we return our array of threads.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们返回我们的Threads数组。
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And here we return our messages if there are no threads.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果没有Threads，我们返回我们的消息。
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''re missing just one more item. When we first started using `union`, we
    had to create a query for the `EntityResult` type. So, we need to do the same
    thing for our new `ThreadArrayResult` type. Enter this code just after the `EntityResult`
    definition inside the `resolvers` file:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只缺少一个项目。当我们首次使用`union`时，我们必须为`EntityResult`类型创建一个查询。因此，我们需要为我们的新`ThreadArrayResult`类型做同样的事情。在`resolvers`文件中`EntityResult`定义之后输入以下代码：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It's the same situation as before. If `obj` has a `messages` property, we return
    the type `EntityResult`; if not, then we return the `ThreadArray` type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这和之前的情况一样。如果`obj`有一个`messages`属性，我们返回`EntityResult`类型；如果没有，我们返回`ThreadArray`类型。
- en: 'If we run this Query, we should see something like this (note my results are
    filled with duplicate testing data):'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们运行这个查询，我们应该会看到类似这样的结果（注意我的结果中充满了重复的测试数据）：
- en: '![Figure 15.3 – The getThreadsByCategoryId function'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.3 - getThreadsByCategoryId函数'
- en: '](img/Figure_15.03_B15508.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.03_B15508.jpg)'
- en: Figure 15.3 – The getThreadsByCategoryId function
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 - getThreadsByCategoryId函数
- en: Notice we added an additional field called `__typename`. This field will tell
    us which type is coming back, which as shown is `ThreadArray`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们添加了一个额外的字段叫做`__typename`。这个字段将告诉我们返回的是哪种类型，如所示是`ThreadArray`。
- en: OK, so now we have a working GraphQL server with queries for Threads. Try and
    integrate the non-authentication related calls from [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216),
    *Setting Up Postgres and Repository Layer with TypeORM*, yourself. If you get
    stuck, you can refer to the source code. But it's important you try and do this
    *without* looking as that's how you know for sure you understand the material.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们有一个可以工作的GraphQL服务器，可以查询Threads。尝试并集成[*第14章*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216)中与身份验证无关的调用，*使用TypeORM设置Postgres和存储库层*。如果你遇到困难，可以参考源代码。但重要的是你尝试并且*不要*查看，因为这样你才能确切地知道你是否理解了材料。
- en: ThreadPoint System
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ThreadPoint System
- en: 'Now that we''ve integrated our existing resolver calls, let''s create some
    of the calls that we still need. We created a points system for our Threads and
    ThreadItems. Let''s now implement a way to increment and decrement points. If
    it''s been a while, take a look at the ThreadPoint and ThreadItemPoint entities
    before continuing. You''ll notice a new field called `points`, which I''ll explain
    once we start writing our code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经集成了现有的解析器调用，让我们创建一些我们仍然需要的调用。我们为我们的 Threads 和 ThreadItems 创建了一个点系统。现在让我们实现一种增加和减少点数的方法。如果已经有一段时间了，请在继续之前查看一下
    ThreadPoint 和 ThreadItemPoint 实体。您会注意到一个名为 `points` 的新字段，我将在我们开始编写代码时解释：
- en: 'First, create a file called `ThreadPointRepo.ts` inside of the repo folder
    and add this code into it (again, I assume you know how to add the necessary imports):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 repo 文件夹内创建一个名为 `ThreadPointRepo.ts` 的文件，并将以下代码添加到其中（再次假设您知道如何添加必要的导入）：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice the parameters have an `increment` boolean. This determines whether we
    are trying to add or remove a point.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意参数中有一个 `increment` 布尔值。这决定了我们是要添加还是删除一个点。
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once we create our authentication calls, we'll revisit this comment and fill
    it in with code. Note that adding a `todo` comment is a good way of keeping track
    of the items remaining to be completed. It also notifies team members of this
    fact.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了我们的身份验证调用，我们将重新访问这个注释，并用代码填充它。请注意，添加一个 `todo` 注释是跟踪剩余待完成项目的好方法。它还通知团队成员这一事实。
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, we start by getting the `Thread` for the given `threadId`. Notice we also
    check that the given `User` is not the same `User` who owns the thread. If you
    have only one `User` in your database, you'll need to add another `User`, so that
    the owner of the `Thread` is not the same one trying to increment its point. You
    can add a user by using a SQL insert query or reusing our register route from
    [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216), *Setting Up Postgres
    and Repository Layer with TypeORM*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先获取给定 `threadId` 的 `Thread`。请注意，我们还检查了给定的 `User` 是否不是拥有该线程的相同 `User`。如果您的数据库中只有一个
    `User`，您需要添加另一个 `User`，以便拥有 `Thread` 的所有者不是尝试增加其点数的相同人。您可以通过使用 SQL 插入查询或重用我们在[*第14章*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216)中的注册路由来添加用户，*使用
    TypeORM 设置 Postgres 和存储库层*。
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we've gotten the matching `User` a bit before we actually need to use
    them. We'll see in a bit why we're doing something that may seem inefficient.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在实际需要使用它们之前稍微获取了匹配的 `User`。我们稍后会看到为什么我们正在做一些看起来可能效率低下的事情。
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we are seeing if an existing point entity already exists. We will use
    this object to make decisions on how to add or remove points later:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在查看现有的点实体是否已经存在。我们将使用这个对象来决定如何稍后添加或删除点：
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, we have a bit of new TypeORM code. The `getManager().transaction`
    call is creating a SQL transaction. A transaction is a way of doing multiple SQL
    operations as a single atomic operation. In other words, either every single one
    will complete successfully or all will fail. So then everything running inside
    of this scope is part of the transaction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们有一些新的 TypeORM 代码。`getManager().transaction` 调用正在创建一个 SQL 事务。事务是一种将多个
    SQL 操作作为单个原子操作执行的方式。换句话说，要么每个操作都将成功完成，要么全部失败。因此，此范围内运行的所有内容都是事务的一部分。
- en: Additionally, we noticed previously that we had created a `User` entity in advance
    of using it. This is because it is a best practice to avoid making selection queries
    inside of a transaction. This is not a hard rule. But in general, having selection
    queries inside of transactions makes things slower.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们之前注意到我们提前创建了一个 `User` 实体。这是因为最佳实践是避免在事务内进行选择查询。这不是一个硬性规定。但一般来说，在事务内进行选择查询会使事情变慢。
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this section, we checked if a `ThreadPoint` already exists by checking for
    `existingPoint` (remember a `ThreadPoint` can represent a positive or negative
    point, as indicated by the `isDecrement` field). Once that is determined, we decide
    if we are doing an increment or a decrement. If doing an `increment` and there
    is an existing decrement `ThreadPoint`, we delete that entity and do nothing else.
    If we are doing a decrement and there is an existing `increment` `ThreadPoint`,
    we delete that entity and do nothing else.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过检查 `existingPoint`（记住 `ThreadPoint` 可以表示正点或负点，如 `isDecrement` 字段所示）来检查
    `ThreadPoint` 是否已经存在。一旦确定了这一点，我们决定是在进行增加还是减少。如果进行增加并且存在减少的 `ThreadPoint`，我们将删除该实体并且不做其他操作。如果我们正在进行减少并且存在增加的
    `ThreadPoint`，我们将删除该实体并且不做其他操作。
- en: 'Now, the other thing to notice is that our Thread Entity now has a field called
    points, which we increment or decrement as appropriate. This field will act as
    a sort of shortcut in our UI that will allow us to get the current `Thread''s`
    points total without having to sum all the `ThreadPoints` for that `Thread`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，另一件需要注意的事情是我们的 Thread 实体现在有一个名为 points 的字段，我们根据需要进行增加或减少。这个字段将作为我们的 UI 中的一种快捷方式，它将允许我们获取当前
    `Thread` 的点总数，而无需对该 `Thread` 的所有 `ThreadPoints` 进行求和：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Else if we have no existing points at all, we just create a new one that is
    either an increment or a decrement:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果根本没有现有的点，我们只需创建一个新的点，无论是增加还是减少：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now add `Mutation` to `typeDefs` like this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在像这样向 `typeDefs` 添加 `Mutation`：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, update the `resolver` by adding the `updateThreadPoint` call to the `Mutation`
    section. Since this is just a wrapper around the repository call that does the
    actual work, I won't show the code here. Try and see if you can create the `Mutation`
    yourself without looking at the code.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过将 `updateThreadPoint` 调用添加到 `Mutation` 部分来更新解析器。由于这只是对执行实际工作的存储库调用的包装器，我不会在这里显示代码。尝试看看是否可以在不查看代码的情况下创建
    `Mutation`。
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the resolvers we will use are just wrappers around our Repository calls.
    This keeps our resolver code separate from our database and Repository calls.
    So, most of the time, I will not show the resolver code since it is slight and
    available in the source code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的大多数解析器只是我们的存储库调用的包装器。这使我们的解析器代码与我们的数据库和存储库调用分开。因此，大多数时候，我不会显示解析器代码，因为它很少并且在源代码中可用。
- en: 'Run the `Mutation` as shown and then check your database:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行如上所示的`Mutation`，然后检查您的数据库：
- en: '![Figure 15.4 – Run updateThreadPoint'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.4 - 运行updateThreadPoint'
- en: '](img/Figure_15.04_B15508.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.04_B15508.jpg)'
- en: Figure 15.4 – Run updateThreadPoint
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 - 运行updateThreadPoint
- en: 'Here, we have the result of our mutation in the Postgres database, using pgAdmin:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在Postgres数据库中的mutation结果，使用pgAdmin：
- en: '![Figure 15.5 – Run the updateThreadPoint database result'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.5 - 运行updateThreadPoint数据库结果'
- en: '](img/Figure_15.05_B15508.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.05_B15508.jpg)'
- en: Figure 15.5 – Run the updateThreadPoint database result
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 - 运行updateThreadPoint数据库结果
- en: So, our record is created successfully, as shown.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的记录已成功创建，如图所示。
- en: Now let's discuss a bit more about this points system that we have and how it
    works. A *like* points system can allow for both a positive and a negative point,
    as does our system. However, it must also prevent users from voting more than
    once. In order to do that, we need to associate each point with both the user
    that gave it and the Thread or ThreadItem they put it on. This is why we have
    the ThreadPoint and ThreadPointItem entities.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再多讨论一下我们拥有的积分系统以及它是如何工作的。*喜欢*积分系统可以允许正面和负面积分，就像我们的系统一样。然而，它还必须防止用户投票超过一次。为了做到这一点，我们需要将每个积分与给出它的用户以及他们放在其上的Thread或ThreadItem相关联。这就是为什么我们有ThreadPoint和ThreadPointItem实体。
- en: On a well-trafficked site having many users, adding or removing points at any
    given time can be a significant load on the server. But worse than this is if
    we were to have to sum up all of these ThreadPoints or ThreadItemPoints upon each
    call to get Thread or ThreadItem data. This would be untenable. So for the first
    issue, we must accept it as part of having a "one vote per user" points system.
    However, for the summing of points issue, we could attempt several different things
    in order to improve performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个用户众多的流量大的网站上，随时添加或删除积分可能对服务器造成重大负载。但比这更糟糕的是，如果我们每次调用获取Thread或ThreadItem数据时都必须总结所有这些ThreadPoints或ThreadItemPoints。这是不可行的。因此，对于第一个问题，我们必须将其视为“每个用户一票”的积分系统的一部分。然而，对于积分总和的问题，我们可以尝试几种不同的方法来提高性能。
- en: The most performant would be to add a caching system, using a secondary service
    like Redis. However, building a caching system is no trivial matter and well beyond
    the scope of this book. And we could argue that while our site is just getting
    started, before it achieves glorious success and billions of dollars, we won't
    have that kind of traffic. So, as a start, we could try something a little simpler.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最有效的方法是添加一个缓存系统，使用像Redis这样的辅助服务。然而，构建缓存系统并不是一件微不足道的事情，远远超出了本书的范围。我们可以争论说，在我们的网站刚刚起步之前，要取得辉煌的成功和数十亿美元，我们不会有那种流量。因此，作为一个开始，我们可以尝试一些更简单的东西。
- en: So what we are doing instead is adding the points field to our Thread and ThreadItem
    entities and incrementing the values as calls to add or remove points are made.
    Not the best solution, but it will do for now. Over time, a caching system or
    some other mechanism can be built out that is more sophisticated.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们所做的是将积分字段添加到我们的Thread和ThreadItem实体中，并在进行添加或删除积分的调用时递增值。这不是最好的解决方案，但现在可以。随着时间的推移，可以构建出更复杂的缓存系统或其他机制。
- en: The code for ThreadItemPoint is virtually identical. Go ahead and see if you
    can build the `ThreadItemPointRepo.ts` file yourself. As always, take a look at
    the code in the source if you get stuck.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ThreadItemPoint的代码几乎是相同的。继续尝试看看是否可以自己构建`ThreadItemPointRepo.ts`文件。如果遇到困难，可以随时查看源代码。
- en: In this section, we began integrating our Repository calls with our GraphQL
    layer. We also fleshed out our Thread and ThreadItem points system. In the next
    section, we'll continue building out our GraphQL API by integrating our authentication
    calls.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们开始将我们的存储库调用与我们的GraphQL层集成。我们还完善了我们的Thread和ThreadItem积分系统。在下一节中，我们将继续通过集成我们的身份验证调用来构建我们的GraphQL
    API。 '
- en: Integrating authentication with GraphQL resolvers
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将身份验证与GraphQL解析器集成
- en: Integrating authentication into GraphQL isn't much different from adding any
    other functionality. In this section, we'll learn how to do that.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将身份验证集成到GraphQL中并不比添加任何其他功能有多大区别。在本节中，我们将学习如何做到这一点。
- en: 'Let''s now integrate our authentication-related calls. Let''s start with the
    `register` call:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们集成我们与身份验证相关的调用。让我们从`register`调用开始：
- en: 'You''ll recall we already created our `register` call in [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216),
    *Setting Up Postgres and Repository Layer with TypeORM*. So now, let''s add our
    `typeDefs` and `resolvers`. First, add the `register` call from the source code,
    to the `typeDefs` file in the `Mutation` section:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会记得我们已经在[*第14章*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216)中创建了我们的`register`调用，*使用TypeORM设置Postgres和存储库层*。现在，让我们添加我们的`typeDefs`和`resolvers`。首先，在`Mutation`部分的`typeDefs`文件中添加源代码中的`register`调用：
- en: Now, in our resolvers file, in the `Mutation` section, add the code from our
    GitHub source code.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的解析器文件中，在`Mutation`部分，添加我们的GitHub源代码中的代码。
- en: This is again just a wrapper of our repository call so there's not much to explain,
    but notice we do not return a `User` object; we only return a status message.
    This is because we want to reduce the chance of any unnecessary information being
    spilled out. Before we try running it, let's enable our GraphQL playground to
    accept cookies so we can test it. We need to enable cookies so that our Session
    State can be saved, which is what allows our calls to check if the User has already
    logged in.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们存储库调用的一个包装器，所以没有太多需要解释的，但请注意我们没有返回`User`对象；我们只返回一个状态消息。这是因为我们希望减少泄露不必要信息的机会。在尝试运行之前，让我们启用GraphQL
    playground以接受cookie，以便我们进行测试。我们需要启用cookie，以便我们的会话状态可以被保存，这样我们的调用可以检查用户是否已经登录。
- en: 'In the upper-right corner of the playground, click on the gear icon. Set the
    `request.credentials` field to `include` as shown, then save it and refresh the
    screen. We should see this if we run it now:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放器的右上角，点击齿轮图标。将`request.credentials`字段设置为`include`，然后保存并刷新屏幕。如果现在运行它，我们应该会看到这个：
- en: '![Figure 15.6 – Register'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.6 - 注册'
- en: '](img/Figure_15.06_B15508.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.06_B15508.jpg)'
- en: Figure 15.6 – Register
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 - 注册
- en: Let's continue with the `login` function. Add the login source code to the `Mutation`
    section of your `typeDefs` file.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续`login`函数。将登录源代码添加到您的`typeDefs`文件的`Mutation`部分。
- en: Now add the resolver code for `login` from the source code. Our Repository `login`
    call is checking that the user exists and making sure the password matches. The
    GraphQL call then takes the `user.id` and sets it to the Session object, `ctx.req.session.userId`,
    if a successful login happens. Notice also that our resolver does not return the
    `user` object upon success. We'll create a new function to provide `User` info
    later.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加源代码中的`login`解析器代码。我们的Repository `login`调用正在检查用户是否存在，并确保密码匹配。然后GraphQL调用将`user.id`取出，并将其设置为Session对象`ctx.req.session.userId`，如果登录成功的话。还要注意的是，我们的解析器在成功时不返回`user`对象。我们稍后将创建一个新的函数来提供`User`信息。
- en: Now let's do the `logout` function. First, add the `typeDefs` entry inside of
    the `Mutation` section as shown by the source code.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们做`logout`函数。首先，按照源代码中所示，在`Mutation`部分内添加`typeDefs`条目。
- en: Now update the resolvers `Mutation` with the `logout` resolver code from the
    source. Notice no matter what response comes back from the Repository `logout`
    call, we `destroy` the `session` using `ctx.req.session?.destroy` and this sets
    `ctx.req.session?.userId` to `undefined`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从源代码中更新`Mutation`的解析器`logout`解析器代码。请注意，无论存储库`logout`调用返回什么响应，我们都会使用`ctx.req.session?.destroy`来`destroy`
    `session`，并将`ctx.req.session?.userId`设置为`undefined`。
- en: 'Now we need to add one more new call and a new type to our `typeDefs`. Add
    the function `me` to the `Query` section of the `typeDefs` file, as shown by the
    source code. Next, underneath the `User` type, add this `union`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加一个新的调用和一个新的类型到我们的`typeDefs`中。按照源代码中的代码，在`typeDefs`文件的`Query`部分中添加`me`函数。接下来，在`User`类型下面，添加这个`union`：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Why do we need these? In our calls to `register` and `login`, we eliminated
    the returned `User` object because `User` details may or may not be used after
    these calls and we don't want to unnecessarily expose `User` data. However, there
    are times when once a `User` is logged in, we may want to see their relevant data.
    For example, when they access their UserProfile screen. So, we will use this `me`
    function to handle that.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要这些？在我们调用`register`和`login`时，我们消除了返回的`User`对象，因为在这些调用之后可能会或可能不会使用`User`详细信息，我们不希望不必要地暴露`User`数据。然而，有时一旦`User`登录，我们可能希望查看他们的相关数据。例如，当他们访问他们的UserProfile屏幕时。因此，我们将使用这个`me`函数来处理。
- en: 'Now let''s add our `UserRepo` call for the `me` function. Add this function
    to `UserRepo`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为`me`函数添加我们的`UserRepo`调用。将此函数添加到`UserRepo`中：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'First, notice that the `user` object we find includes any `Threads` and `ThreadItems`
    that belong to the user. We will use these in our UserProfile screen:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意我们找到的`user`对象包括属于用户的任何`Threads`和`ThreadItems`。我们将在我们的UserProfile屏幕中使用这些：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The rest of the function is a lot like the login function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分与登录函数非常相似。
- en: Now let's create our `resolvers` for the `UserResult` and the `me` function.
    At the top of the resolvers `const`, add the UserResult resolver as shown in the
    code. This is the same as the other Result `union` resolvers – there's nothing
    new to explain here.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为`UserResult`和`me`函数创建我们的`resolvers`。在`const`的解析器顶部，按照代码中所示添加UserResult解析器。这与其他Result
    `union`解析器相同-这里没有新的内容需要解释。
- en: In the `Query` section, add the code for the `me` function from the source code.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Query`部分，按照源代码中的代码添加`me`函数的代码。
- en: Notice this resolver takes no parameters, as it gets the `userId` from the session.
    On line 193, it checks the `userId` is in the session. If it is not, it exits
    early. If the `userId` is in the Session, it uses our `UserRepo` `me` function
    to get the currently logged-in `user`. And the rest is basically the same as other
    functions returning an entity.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此解析器不接受任何参数，因为它从会话中获取`userId`。在第193行，它检查会话中是否有`userId`。如果没有，它会提前退出。如果会话中有`userId`，它将使用我们的`UserRepo`
    `me`函数来获取当前登录的`user`。其余部分基本上与返回实体的其他函数相同。
- en: 'Let''s try running our `me` resolver. Make sure you''ve logged in once and
    have followed the instructions in *Step 3* for the GraphQL playground. If you
    run `me` as shown, you should get back relevant data:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试运行我们的`me`解析器。确保您已经登录过一次，并且已经按照GraphQL playground中*Step 3*的说明进行了操作。如果您按照所示运行`me`，您应该会得到相关的数据：
- en: '![Figure 15.7 – Call to the me resolver'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.7 - 调用me解析器'
- en: '](img/Figure_15.07_B15508.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.07_B15508.jpg)'
- en: Figure 15.7 – Call to the me resolver
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 - 调用me解析器
- en: As you can see, we use inline fragments again and are able to get back both
    related Threads and ThreadItems.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们再次使用内联片段，并且能够获取相关的Threads和ThreadItems。
- en: In this section, we tied our Repository layer authentication calls to GraphQL
    and tested their functionality. In the next section, we will finish our application
    by tying our nearly complete backend to our frontend.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将我们的存储库层身份验证调用与GraphQL联系起来，并测试它们的功能。在下一节中，我们将通过将我们几乎完成的后端与我们的前端联系起来，完成我们的应用程序。
- en: Creating React client-side Hooks for querying Apollo GraphQL
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Apollo GraphQL查询创建React客户端端Hooks
- en: In this section, we will finish off our application by connecting our React
    client to our GraphQL backend. We've come a long way and we're almost there.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过将我们的React客户端连接到我们的GraphQL后端来完成我们的应用程序。我们已经走了很长的路，我们快要到达目的地了。
- en: In order to tie the two parts of our app together, we need to add CORS to our
    Express server. **CORS** stands for **Cross-Origin Resource Sharing**. It means
    that our server will be set up to allow a client domain that is not the same as
    its own domain.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们应用程序的两个部分联系起来，我们需要将CORS添加到我们的Express服务器中。**CORS**代表**跨源资源共享**。这意味着我们的服务器将被设置为允许与其自身域不同的客户端域。
- en: In most server configurations of even modest complexity, the server that hosts
    the client-side application and the server that provides the API do not exist
    on the same domain. In general, you will have a proxy of some kind, for example,
    NGINX, that will accept calls coming from the browser. And that proxy will "redirect"
    calls as required. We will explain how reverse proxies work in more detail in
    [*Chapter 17*](B15508_17_Final_JC_ePub.xhtml#_idTextAnchor259), *Deploying an
    Application to AWS*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在即使是相当复杂的大多数服务器配置中，托管客户端应用程序的服务器和提供API的服务器并不位于同一域上。通常，您会有某种代理，例如NGINX，它将接受来自浏览器的调用。该代理将根据需要“重定向”调用。我们将在[*第17章*](B15508_17_Final_JC_ePub.xhtml#_idTextAnchor259)中更详细地解释反向代理的工作原理，*将应用程序部署到AWS*。
- en: Note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A proxy is a stand-in for a service or some services. When a proxy is used,
    if a client makes a call to a service, they end up accessing the proxy first and
    not the service directly. The proxy then determines where the client's request
    should be routed to. A proxy, therefore, provides companies with better control
    of their service access.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是服务或某些服务的替身。当使用代理时，如果客户端调用服务，他们最终首先访问代理而不是直接访问服务。然后代理确定客户端的请求应该路由到哪里。因此，代理为公司提供了更好地控制其服务访问的能力。
- en: 'Enabling CORS is also necessary because the React application runs on its own
    test web server. In our case, it runs on port `3000`, while the server runs on
    port `5000`. Although they both use localhost, having different ports effectively
    means different domains. To update CORS, do this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 启用CORS也是必要的，因为React应用程序在其自己的测试Web服务器上运行。在我们的情况下，它在端口`3000`上运行，而服务器在端口`5000`上运行。尽管它们都使用localhost，但具有不同的端口实际上意味着不同的域。要更新CORS，请执行以下操作：
- en: 'First, we need to update our `.env` file to have the path to the client development
    server:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要更新我们的`.env`文件，以便包含客户端开发服务器的路径：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Open `index.ts` and add this code immediately after `const app = express();`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.ts`并在`const app = express();`之后立即添加以下代码：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `credentials` setting enables the header Access-Control-Allow-Credentials.
    This allows client JavaScript to receive responses from servers after successfully
    providing credentials.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`credentials`设置启用了标题Access-Control-Allow-Credentials。这允许客户端JavaScript在成功提供凭据后从服务器接收响应。'
- en: 'Also update the Apollo Server so that its own `cors` is disabled. Update this
    line just before `listen`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要更新Apollo Server，以便禁用其自己的`cors`。在`listen`之前更新此行：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we''ve installed CORS onto our server. Let''s now open our React project
    in its own VSCode window and install GraphQL to get started integrating with our
    GraphQL server:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将CORS安装到我们的服务器上。现在让我们在自己的VSCode窗口中打开我们的React项目，并安装GraphQL以开始与我们的GraphQL服务器集成：
- en: After opening the `super-forum-client` folder in its own VSCode window, try
    running it first to make sure it's working. If you have not done so already, delete
    the `node_modules` folder and the `package-lock.json` file and run `npm install`
    once.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自己的VSCode窗口中打开`super-forum-client`文件夹后，首先尝试运行它以确保它正常工作。如果您还没有这样做，请删除`node_modules`文件夹和`package-lock.json`文件，然后运行`npm
    install`一次。
- en: 'Now let''s install Apollo GraphQL Client. Open your terminal to the root of
    `super-forum-client` and run this:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们安装Apollo GraphQL客户端。打开终端到`super-forum-client`的根目录，并运行以下命令：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we need to configure our client. Open `index.ts` and add this code above
    `ReactDOM.render`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要配置我们的客户端。打开`index.ts`并在`ReactDOM.render`之前添加以下代码：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As always, add your imports – pretty self-explanatory. We set the URL of the
    server, include any credentials needed, and set the `cache` object. Note this
    means that Apollo caches all our query results.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，添加你的导入 - 这很容易理解。我们设置服务器的URL，包括所需的任何凭据，并设置`cache`对象。请注意，这意味着Apollo会缓存我们所有的查询结果。
- en: 'Next update `ReactDOM.render` and have it include the `ApolloProvider`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来更新`ReactDOM.render`，并让其包括`ApolloProvider`：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now let''s test that its working by getting ThreadCategories. Open the `src/components/areas/LeftMenu.tsx`
    file and update it like this:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过获取ThreadCategories来测试它是否正常工作。打开`src/components/areas/LeftMenu.tsx`文件并进行以下更新：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We''ve imported some items from the Apollo client. `gql` allows us to get syntax
    highlighting and formatting for GraphQL queries. `UseQuery` is our first GraphQL
    related client-side Hook. It allows us to do a GraphQL Query, as opposed to doing
    a Mutation, but it runs immediately. Later, I''ll show a Hook that allows lazy
    loading:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从Apollo客户端导入了一些项目。`gql`允许我们为GraphQL查询获取语法高亮显示和格式化。`UseQuery`是我们的第一个与GraphQL相关的客户端Hook。它允许我们执行GraphQL查询，而不是执行Mutation，但它会立即运行。稍后，我将展示一个允许延迟加载的Hook：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here is our query. Not much to explain here, but note we get both `id` and `name`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的查询。这里没有什么需要解释的，但请注意我们获取了`id`和`name`。
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Our `useQuery` call returns the properties `loading`, `error`, and `data`.
    Each Apollo GraphQL Hook returns a different set of relevant properties. We''ll
    see how these particular properties are used in the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`useQuery`调用返回属性`loading`，`error`和`data`。每个Apollo GraphQL Hook返回一组不同的相关属性。我们将看到这些特定属性如何在以下代码中使用：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the code just shown, we first check if data is still being loaded by using
    the `loading` property and providing placeholder text in that case.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚刚显示的代码中，我们首先检查数据是否仍在加载，方法是使用`loading`属性并在这种情况下提供占位文本。
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this error section, we indicate an error occurred during the query run.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在此错误部分中，我们指示查询运行期间发生了错误。
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, if all went well and we got our data, then we display an unordered
    list of elements representing each ThreadCategory. Notice each `li` element has
    a unique key identifier. It is always important to have keys when providing an
    array of similar elements, as it reduces unnecessary renders. Also, each element
    is a link that shows the user all Threads related to a specific `ThreadCategory`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一切顺利，我们得到了我们的数据，然后我们显示一个无序列表，表示每个ThreadCategory。请注意，每个`li`元素都有一个唯一的键标识符。在提供一组类似元素时，拥有键总是很重要的，因为它减少了不必要的渲染。此外，每个元素都是一个链接，向用户显示与特定`ThreadCategory`相关的所有Threads：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Running the app should show this screen in desktop mode. Notice I''ve clicked
    on one of the ThreadCategory links that have associated Thread data. But of course,
    we are currently still using `dataService` to return hardcoded data:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在桌面模式下运行应用程序应该显示这个屏幕。请注意，我已经点击了一个具有关联Thread数据的ThreadCategory链接。但当然，我们目前仍在使用`dataService`返回硬编码数据：
- en: '![Figure 15.8 – LeftMenu ThreadCategory list'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.8 – 左侧菜单线程类别列表'
- en: '](img/Figure_15.08_B15508.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.08_B15508.jpg)'
- en: Figure 15.8 – LeftMenu ThreadCategory list
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 – 左侧菜单线程类别列表
- en: Awesome – we are now connected to our GraphQL server!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了 - 我们现在连接到了我们的GraphQL服务器！
- en: The Main screen
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主屏幕
- en: 'Congratulations – you''ve come a long way. Now we need to update our Main component
    so that we return real data from our GraphQL service. Let''s create that now:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜 - 你已经走了很长的路。现在我们需要更新我们的Main组件，以便从我们的GraphQL服务返回真实的数据。让我们现在创建它：
- en: Go to our `super-forum-server` project and open the `typeDefs` file and add
    the schema entry for the function `getThreadsLatest` just below the `getThreadsByCategoryId`
    query from the source. Here, we are creating a new resolver, `getThreadsLatest`,
    that gives us the latest Threads when no specific ThreadCategory is given. When
    a ThreadCategory is given, we already have the `getThreadsByCategoryId` resolver.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到我们的`super-forum-server`项目，打开`typeDefs`文件，并在源代码中的`getThreadsByCategoryId`查询下方添加函数`getThreadsLatest`的模式条目。在这里，我们正在创建一个新的解析器`getThreadsLatest`，当没有特定的ThreadCategory给出时，它会给我们最新的Threads。当给出ThreadCategory时，我们已经有了`getThreadsByCategoryId`解析器。
- en: 'Open `ThreadRepo` and add this function:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ThreadRepo`并添加这个函数：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We have a query that includes ThreadCategories and ThreadItems – `leftJoinAndSelect`,
    is ordered by the `createdOn` field, `orderBy`, and takes only up to 10 items
    (`take`):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包括ThreadCategories和ThreadItems的查询 - `leftJoinAndSelect`，按`createdOn`字段排序，`orderBy`，并且只取最多10个项目（`take`）：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The rest is self-explanatory as it's similar to `getThreadsByCategoryId`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分与`getThreadsByCategoryId`类似，不再赘述。
- en: 'Let''s also update our `getThreadsByCategoryId` function to include the ThreadItems
    as well:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更新我们的`getThreadsByCategoryId`函数，包括ThreadItems：
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It's the same as before only with the additional `leftJoinAndSelect` function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 它与以前一样，只是多了一个`leftJoinAndSelect`函数。
- en: Open the `resolvers` file and add the `getThreadsLatest` function from the source
    code at the end of the Query section. This is a wrapper almost identical to the
    `getThreadsByCategoryId` resolver, except it calls `getThreadsLatest` instead.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`resolvers`文件，并在Query部分的末尾添加源代码中的`getThreadsLatest`函数。这是一个几乎与`getThreadsByCategoryId`解析器相同的包装器，只是调用了`getThreadsLatest`。
- en: Now we need to update our `Main` React component so that it uses our GraphQL
    resolvers instead of the fake data from our `dataService`. Open `Main` and update
    the file like this.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要更新我们的`Main`React组件，使其使用我们的GraphQL解析器而不是来自`dataService`的假数据。打开`Main`并像这样更新文件。
- en: 'The `const` `GetThreadsByCategoryId` is our first query. As you can see, it
    uses inline fragments and gets back our Thread data fields:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` `GetThreadsByCategoryId`是我们的第一个查询。正如您所看到的，它使用内联片段并获取我们的Thread数据字段：'
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`GetThreadsLatest` is basically identical to `GetThreadsByCategoryId`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetThreadsLatest`基本上与`GetThreadsByCategoryId`相同：'
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we begin our `Main` component definition with our use of `useLazyQuery`
    Hooks:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始使用`useLazyQuery` Hooks定义我们的`Main`组件：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The two Hooks that were shown are now using our queries. Notice these are lazy
    GraphQL queries. This means they do not run immediately, unlike `useQuery`, and
    only run when the `execGetThreadsByCat` or `execGetThreadsLatest` calls are made.
    The `data` property is what contains our query's returned data. Additionally,
    I have commented out two of the returned properties because we are not using them.
    However, they are available for use should your call run into errors. `Error`
    contains information on failures and `called` indicates whether the Hook was called
    already.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显示的两个Hooks正在使用我们的查询。请注意，这些是延迟的GraphQL查询。这意味着它们不会立即运行，不像`useQuery`，只有在进行`execGetThreadsByCat`或`execGetThreadsLatest`调用时才会运行。`data`属性包含我们查询的返回数据。此外，我已经注释掉了两个返回的属性，因为我们没有使用它们。但是，如果您的调用遇到错误，它们是可用的。`Error`包含有关失败的信息，`called`指示Hook是否已经被调用。
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The previous state objects remain unchanged.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的状态对象保持不变。
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This `useEffect` was updated to now only execute `execGetThreadsByCat` or `execGetThreadsLatest`
    as needed. If the `categoryId` parameter is given, `execGetThreadsByCat` should
    run; if not, the other should run:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`useEffect`现在更新为只在需要时执行`execGetThreadsByCat`或`execGetThreadsLatest`。如果给定了`categoryId`参数，应该运行`execGetThreadsByCat`；如果没有，应该运行另一个：
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In `useEffect`, `threadsByCatData` changes cause us to update `category` and
    `threadCards` with data from the `getThreadsByCategoryId` query.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在`useEffect`中，`threadsByCatData`的变化导致我们使用`getThreadsByCategoryId`查询的数据更新`category`和`threadCards`。
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In `useEffect`, `threadsLatestData` changes cause us to update `category` and
    `threadCards` with data from the `getThreadsLatest` query. Notice when no `categoryId`
    is given, we just use a generic "Latest" name for our ThreadCategory.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在`useEffect`中，`threadsLatestData`的变化导致我们使用`getThreadsLatest`查询的数据更新`category`和`threadCards`。请注意，当没有给出`categoryId`时，我们只是使用一个通用的“最新”名称作为我们的ThreadCategory。
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The rest of the code remains the same as before.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其余代码与以前相同。
- en: 'Now if we run this for a `categoryId`, we should see this:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们为`categoryId`运行这个，我们应该会看到这个：
- en: '![Figure 15.9 – With categoryId'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.9 – 有categoryId'
- en: '](img/Figure_15.09_B15508.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.09_B15508.jpg)'
- en: Figure 15.9 – With categoryId
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 – 有categoryId
- en: 'If we run this without a `categoryId`, we should see this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在没有`categoryId`的情况下运行这个，我们应该会看到这个：
- en: '![Figure 15.10 – Without categoryId'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.10 – 没有categoryId'
- en: '](img/Figure_15.10_B15508.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.10_B15508.jpg)'
- en: Figure 15.10 – Without categoryId
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 – 没有categoryId
- en: 'Good – now we have some actual real data populating on our site screen. Before
    continuing, let''s clean up our styling a bit and get rid of some of these placeholder
    background colors. I''ve made minor changes to the `Nav.css` and `Home.css` files.
    This is what it looks like now:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们的网站屏幕上有一些实际的真实数据了。在继续之前，让我们稍微清理一下我们的样式，并去掉一些占位背景颜色。我对`Nav.css`和`Home.css`文件进行了微小的更改。现在是这个样子的：
- en: '![Figure 15.11 – Home screen style update'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.11 - 主屏幕样式更新'
- en: '](img/Figure_15.11_B15508.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.11_B15508.jpg)'
- en: Figure 15.11 – Home screen style update
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 - 主屏幕样式更新
- en: 'OK, that''s better. Here''s one thing to notice on the mobile version of our
    screen – we have no way for the user to switch to another category, as shown in
    this screenshot:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这样好多了。在我们屏幕的移动版本上有一件事要注意 - 我们没有办法让用户切换到另一个类别，如下图所示：
- en: '![Figure 15.12 – Home screen mobile view'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.12 - 主屏幕移动视图'
- en: '](img/Figure_15.12_B15508.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.12_B15508.jpg)'
- en: Figure 15.12 – Home screen mobile view
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 - 主屏幕移动视图
- en: 'So, let''s add a dropdown that will allow the user to switch categories. This
    dropdown should only appear while in mobile mode. Try and build this control yourself
    before following along. Hint: use React-DropDown to build the dropdown and replace
    the category label with the drop-down control. For example, in *Figure 15.12*
    we see the selected category is `MainHeader` control. So then replace that label
    with the dropdown, but only in mobile mode. Note that we are already using a dropdown
    in our ThreadCategory route so we should create a component out of it so it can
    be reused.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加一个下拉菜单，允许用户切换类别。这个下拉菜单应该只在移动模式下出现。在跟随之前尝试构建这个控件。提示：使用React-DropDown构建下拉菜单，并用下拉控件替换类别标签。例如，在*图15.12*中，我们看到所选的类别是`MainHeader`控件。因此，只在移动模式下用下拉菜单替换该标签。请注意，我们已经在我们的ThreadCategory路由中使用了下拉菜单，因此我们应该将其创建为一个组件，以便它可以被重用。
- en: 'If you''ve given it a try, let''s now start building it together so you can
    compare. Here''s the thing I lied a little bit. This is a fairly complex change
    as it requires two main things. First, we would want to add a new Reducer for
    ThreadCategories since we know that the list of ThreadCategories is being used
    in at least two separate components. We also need to componentize the dropdown
    in the ThreadCategory component so that it can be used in several places. This
    second piece is fairly involved as the new drop-down component has to be complex
    enough to receive props from the outside and also send out the selected category
    whenever it changes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经尝试过了，现在让我们一起开始构建，这样你就可以进行比较。这里有一点我说了谎。这是一个相当复杂的改变，因为它需要两个主要的事情。首先，我们希望为ThreadCategories添加一个新的Reducer，因为我们知道ThreadCategories的列表至少在两个独立的组件中被使用。我们还需要将ThreadCategory组件中的下拉菜单组件化，以便它可以在多个地方使用。第二个部分相当复杂，因为新的下拉组件必须足够复杂，以便从外部接收props，并在每次更改时发送所选的类别：
- en: First, let's create our new Reducer. Create a new folder in the `store` folder
    called `categories`. In that folder, create a file called `Reducer.ts` and add
    the source code to it. This file is a lot like our `User` Reducer, except it returns
    as payload an array of `Category` objects.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的新Reducer。在`store`文件夹中创建一个名为`categories`的新文件夹。在该文件夹中，创建一个名为`Reducer.ts`的文件，并将源代码添加到其中。这个文件很像我们的`User`
    Reducer，只是它返回一个`Category`对象数组作为有效负载。
- en: 'Next, we need to add our new Reducer to our `AppState''s` `rootReducer` like
    this:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将新的Reducer添加到我们的`AppState`的`rootReducer`中，就像这样：
- en: '[PRE67]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Our new `rootReducer` member will be called `Categories`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`rootReducer`成员将被称为`Categories`。
- en: Now update the `App.tsx` component so that upon application load, we immediately
    get our ThreadCategories and add them to the Redux store.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新`App.tsx`组件，以便在应用程序加载时，我们立即获取我们的ThreadCategories并将它们添加到Redux存储中。
- en: 'Here, we are adding the `GetAllCategories` GraphQL query:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`GetAllCategories` GraphQL查询：
- en: '[PRE68]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Most of this code we''ve seen before, but this is where we''ve sent our payload
    of ThreadCategories to the Redux store:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的大部分代码都是一样的，但这是我们将ThreadCategories的有效负载发送到Redux存储的地方：
- en: '[PRE69]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Everything else remains the same. Note you will need to update your imports.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切都保持不变。请注意，您需要更新您的导入。
- en: 'The `LeftMenu` and `ThreadCategory` components will need to have their code
    for getting ThreadCategories and creating the dropdown removed. But first, let''s
    create our shared control that will do all this. Create a file inside of `src/components`
    called `CategoryDropDown.tsx` and add this code. Make sure you add any necessary
    imports:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LeftMenu`和`ThreadCategory`组件将需要删除它们获取ThreadCategories和创建下拉菜单的代码。但首先，让我们创建我们的共享控件来完成所有这些。在`src/components`文件夹中创建一个名为`CategoryDropDown.tsx`的文件，并添加这段代码。确保您添加任何必要的导入：'
- en: '[PRE70]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With `defaultOption`, we've created an initial value for our dropdown.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`defaultOption`，我们为我们的下拉菜单创建了一个初始值。
- en: '[PRE71]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`CategoryDropDownProps` will be our parameter type for our `CategoryDropDown`
    component. `sendOutSelectedCategory` is a function passed by the parent caller
    that will be used to receive the selected drop-down option by the parent. `Navigate`
    is a boolean that determines whether the screen will move to a new URL upon selection
    of a new drop-down option. And `preselectedCategory` allows the parent to force
    the dropdown to have selected the specified ThreadCategory on load:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryDropDownProps`将是我们的`CategoryDropDown`组件的参数类型。`sendOutSelectedCategory`是由父调用者传递的函数，将用于接收父级选择的下拉选项。`Navigate`是一个布尔值，确定在选择新的下拉选项时屏幕是否会移动到新的URL。`preselectedCategory`允许父级在加载时强制下拉菜单选择指定的ThreadCategory：'
- en: '[PRE72]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Based on our previous learning, the usage of these listed Hooks is pretty obvious.
    But do notice that we are getting the list of ThreadCategories from our Redux
    store using `useSelector`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的学习，这些列出的Hooks的使用是非常明显的。但请注意，我们正在使用`useSelector`从Redux存储中获取ThreadCategories的列表。
- en: '[PRE73]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, we build our array of options to feed to our dropdown later.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们构建了一个选项数组，以供稍后给我们的下拉菜单。
- en: '[PRE74]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, in `setCategoryOptions`, we are receiving our list of ThreadCategory option
    elements and setting them so they can be consumed by our dropdown later.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setCategoryOptions`中，我们正在接收我们的ThreadCategory选项元素列表并设置它们，以便稍后可以被我们的下拉菜单使用。
- en: '[PRE75]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, we have set our default drop-down selection.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经设置了我们默认的下拉选择。
- en: '[PRE76]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this drop-down change handler here, we are notifying the parent of a selection
    change.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的下拉更改处理程序中，我们正在通知父级选择发生了变化。
- en: '[PRE77]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We navigate to the next ThreadCategory route if requested by the parent.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父级请求，我们将导航到下一个ThreadCategory路由。
- en: '[PRE78]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: And finally, here's our actual JSX, which is pretty self-explanatory.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们实际的JSX，它非常容易理解。
- en: 'Now we need to update the `MainHeader.tsx` file like this:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要像这样更新`MainHeader.tsx`文件：
- en: '[PRE79]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The only significant change is this `getLabelElement` function, which decides
    whether the screen is mobile and renders `CategoryDropDown` if it is:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一重要的更改是`getLabelElement`函数，它决定屏幕是否为移动设备，并在是的情况下呈现`CategoryDropDown`：
- en: '[PRE80]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: </div>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: );
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '};'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE81]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The rest of the code is the removal of code mostly, so try and do that yourself.
    You can, of course, look at the source code if needed. The affected files are
    `ThreadCategory.tsx`, `LeftMenu.tsx`, and `Thread.css`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码大部分是删除的代码，所以请尝试自己做。当然，如果需要，可以查看源代码。受影响的文件是`ThreadCategory.tsx`，`LeftMenu.tsx`和`Thread.css`。
- en: Authentication-related features
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与身份验证相关的功能
- en: 'Now let''s continue by updating our authentication-related features. Please
    remember that all your `User` accounts must have their `confirmed` field set to
    true *before* they can log in:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续更新与身份验证相关的功能。请记住，所有您的“用户”帐户在能够登录之前必须将其“confirmed”字段设置为true：
- en: The first thing we want to do is have the user be able to log in. In order to
    do this and then be able to update our `User` object in the global Redux store,
    we're going to refactor our Redux User Reducer.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是让用户能够登录。为了做到这一点，然后能够更新我们在全局Redux存储中的`User`对象，我们将重构我们的Redux用户Reducer。
- en: First, in the `models` folder, create a new file called `User.ts` and add the
    source code to it. Notice that our `User` class has a field called threads. This
    will contain not only the Threads belonging to the user but the ThreadItems of
    those Threads.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`models`文件夹中，创建一个名为`User.ts`的新文件并将源代码添加到其中。请注意，我们的`User`类有一个名为threads的字段。这将包含不仅是用户拥有的Threads，还有这些Threads的ThreadItems。
- en: Now let's update our Reducer. Open `store/user/Reducer.ts` and update it by
    removing the `UserProfilePayload` interface and replacing its references with
    the new `User` class we just created. Look at the source code if you need to.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们更新我们的Reducer。打开`store/user/Reducer.ts`并通过删除`UserProfilePayload`接口并用我们刚刚创建的新`User`类替换其引用来更新它。如果需要，查看源代码。
- en: Now we can update our `Login` component like this. Update the imports as needed.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以像这样更新我们的`Login`组件。根据需要更新导入。
- en: 'Notice we have imported the Hook `useRefreshReduxMe`. We''ll define this Hook
    in a moment, but first I want to introduce some features of the `useMutation`
    GraphQL Hook:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经导入了Hook`useRefreshReduxMe`。我们将在一会儿定义这个Hook，但首先我想介绍一些`useMutation` GraphQL
    Hook的特性：
- en: '[PRE82]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here is our login `Mutation`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的登录`Mutation`：
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Let me explain this `useMutation` call. The call takes as parameters the Mutation
    query `LoginMutation` and something called `refetchQueries`. `refetchQueries`
    forces whatever queries are listed therein to rerun and then caches their values.
    If we did not use `refetchQueries` and ran the `Me` query again, we would end
    up getting the last cached version instead of the freshest data. Please note it
    does not auto-refresh any calls that depend on its queries; we still have to make
    those calls to get the new data.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下这个`useMutation`调用。调用以Mutation查询`LoginMutation`和称为`refetchQueries`的东西作为参数。`refetchQueries`强制其中列出的任何查询重新运行，然后缓存它们的值。如果我们不使用`refetchQueries`并再次运行`Me`查询，我们最终会得到最后缓存的版本而不是最新的数据。请注意，它不会自动刷新依赖于其查询的任何调用；我们仍然必须进行这些调用以获取新数据。
- en: The output, `execLogin`, is a function that can be executed later as desired.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 输出`execLogin`是一个可以随后执行的函数。
- en: '[PRE84]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The prior calls are the same as they were previously.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的调用与以前一样。
- en: '[PRE85]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `onClickLogin` handler is now calling our `execLogin` function with appropriate
    parameters. After `execLogin` finishes, it will automatically call our `refetchQueries`
    list of queries. After that, we make a call to the functions from our Hook, `useRefreshReduxMe`,
    `execMe`, and `updateMe`. The `execMe` function will get the latest `User` object
    and `updateMe` will add it into the Redux store. The rest of the code is identical
    so I will not show it here.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClickLogin`处理程序现在正在使用适当的参数调用我们的`execLogin`函数。在`execLogin`完成后，它将自动调用我们的`refetchQueries`查询列表。之后，我们调用来自我们的Hook的函数，`useRefreshReduxMe`，`execMe`和`updateMe`。`execMe`函数将获取最新的`User`对象，`updateMe`将将其添加到Redux存储中。其余的代码是相同的，所以我不会在这里展示它。'
- en: Now let's define our Hook `useRefreshReduxMe`. We want to create this Hook so
    that our code to set or unset our Redux `User` object can be in this single file.
    We will be using this Hook from several components. Create a file called `useRefreshReduxMe.ts`
    in the hooks folder and add the source code.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义我们的Hook`useRefreshReduxMe`。我们想要创建这个Hook，以便我们的设置或取消Redux`User`对象的代码可以在这个单个文件中。我们将从几个组件中使用这个Hook。在hooks文件夹中创建一个名为`useRefreshReduxMe.ts`的文件并添加源代码。
- en: From the top, we can see the `Me` `const` is our query to get user information.
    The `EntityResult` inline fragment is used to get the string of messages if that's
    what is coming back. If we get actual user data, then the fields desired are defined
    by the `User` inline fragment.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部，我们可以看到`Me` `const`是用于获取用户信息的查询。`EntityResult`内联片段用于获取消息的字符串（如果返回的是消息）。如果我们获取实际的用户数据，那么所需的字段由`User`内联片段定义。
- en: Next, the `UseRefreshReduxMeResult` interface is a return type for our Hook.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`UseRefreshReduxMeResult`接口是我们Hook的返回类型。
- en: On line 37, we have defined `useLazyQuery` to allow our Hook users to be able
    to execute the call to the `Me` query at a time of their own choosing.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在第37行，我们已经定义了`useLazyQuery`，以允许我们的Hook用户在自己选择的时间执行对`Me`查询的调用。
- en: Next, we have defined a function, `deleteMe`, to allow users of our Hook to
    destroy the Redux `User` object at any time. For example, when the user logs off.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个函数`deleteMe`，允许我们的Hook的用户随时销毁Redux`User`对象。例如，当用户注销时。
- en: And finally, we have the `updateMe` function to allow the setting of the Redux
    `User` object. And then we return all of these functions so they can be used by
    our Hook callers.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`updateMe`函数，允许设置Redux`User`对象。然后我们返回所有这些函数，以便它们可以被我们的Hook调用者使用。
- en: 'Upon app load, we should immediately check if our `User` is logged in and who
    that is. So, open `App.tsx` and update it like this:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用加载时，我们应立即检查我们的`User`是否已登录以及是谁。因此，打开`App.tsx`并像这样更新它：
- en: '[PRE86]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here, we've initialized our `useRefreshReduxMe` Hook.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化了我们的`useRefreshReduxMe` Hook。
- en: '[PRE87]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here, we call our `execMe` to get the `User` data from GraphQL.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用我们的`execMe`来从GraphQL获取`User`数据。
- en: '[PRE88]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: And here, we call `updateMe` to update our Redux User Reducer with the `User`
    data if any.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`updateMe`来使用`User`数据更新我们的Redux用户Reducer。
- en: '[PRE89]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: I changed our original data field name to `categoriesData` so it would be clearer
    what it's for. The rest of the code remains the same.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我们原始的数据字段名称更改为`categoriesData`，这样它就更清楚它的用途了。其余的代码保持不变。
- en: 'If you log in now, you''ll see that our `SideBar` `userName` updates to the
    logged-in user:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在登录，您会看到我们的`SideBar` `userName`更新为已登录用户：
- en: '![Figure 15.13 – Logged-in user'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.13 - 已登录用户'
- en: '](img/Figure_15.13_B15508.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.13_B15508.jpg)'
- en: Figure 15.13 – Logged-in user
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13 - 已登录用户
- en: So, now we can log in, and then show the `userName` as well.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们可以登录，然后显示`userName`。
- en: 'Awesome, but now let''s fix our `SideBar` so that only the appropriate links
    show at the right time. For example, if the user is logged in, we should not see
    the **login** or **register** links:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，但现在让我们修复我们的`SideBar`，以便在适当的时间只显示适当的链接。例如，如果用户已登录，我们不应该看到**登录**或**注册**链接：
- en: 'To make sure that the right menus show when the user logs in or out, let''s
    first update our `Logout` component. Make sure imports are up to date:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保用户登录或注销时显示正确的菜单，让我们首先更新我们的`Logout`组件。确保导入已经更新：
- en: '[PRE90]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here's our `logout` mutation.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`logout` mutation。
- en: '[PRE91]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here, again, we've forced a refresh of our GraphQL cache for the `Me` query.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次强制刷新我们的GraphQL缓存，以获取`Me`查询的数据。
- en: '[PRE92]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Again, we've taken our `useRefreshReduxMe` Hook, but here we only call the `deleteMe`
    function since we're just logging out. The rest of the code remains the same,
    so I won't show it here.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用了我们的`useRefreshReduxMe` Hook，但这里我们只调用了`deleteMe`函数，因为我们只是在注销。其余的代码保持不变，所以我不会在这里展示。
- en: Now we're going to update the `SideBarMenus` component so that only the appropriate
    menus show at the right time. Open that file and update it as follows.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们要更新`SideBarMenus`组件，以便在适当的时间只显示适当的菜单。打开该文件并按照以下方式更新它。
- en: 'In this case, I''ll only show the returned JSX as that''s the only thing that
    changed (other than imports):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我只会显示返回的JSX，因为除了导入之外，这是唯一改变的事情：
- en: '[PRE93]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: As you can see, we are testing whether the `user` object has a value and then
    showing our same `userName` UI, else we show nothing.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在测试`user`对象是否有值，然后显示相同的`userName` UI，否则我们什么都不显示。
- en: '[PRE94]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this case, we don't want to show our registration UI if the user does exist
    so that's what we are doing.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果用户存在，我们不想显示我们的注册UI，这就是我们正在做的。
- en: '[PRE95]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Again, we don't show the login if the `user` object exists already, because
    that indicates the user had already logged in.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果`user`对象已经存在，我们不会显示登录，因为这表示用户已经登录。
- en: '[PRE96]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Here, we show the logout UI if the `user` object has a value.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果`user`对象有值，我们会显示注销UI。
- en: '[PRE97]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If you run this code now, when not yet logged in, you''ll see this:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在运行此代码，当尚未登录时，您会看到这个：
- en: '![Figure 15.14 – Not logged in SideBarMenus'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.14 - 未登录的SideBarMenus'
- en: '](img/Figure_15.14_B15508.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.14_B15508.jpg)'
- en: Figure 15.14 – Not logged in SideBarMenus
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14 - 未登录的SideBarMenus
- en: 'Now, when logged in, we should see this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当登录时，我们应该看到这个：
- en: '![Figure 15.15 – Logged in SideBarMenus'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.15 - 已登录的SideBarMenus'
- en: '](img/Figure_15.15_B15508.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.15_B15508.jpg)'
- en: Figure 15.15 – Logged in SideBarMenus
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15 - 已登录的SideBarMenus
- en: So our sidebar now displays proper links and text. Let's now work on our UserProfile
    screen.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的侧边栏现在显示正确的链接和文本。现在让我们来处理我们的用户资料屏幕。
- en: The UserProfile screen
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户资料屏幕
- en: 'Now, since we are in the authentication sections, let''s finish our UserProfile
    screen. We will need to make multiple changes to configure this screen:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们在认证部分，让我们完成我们的用户资料屏幕。我们需要进行多个更改来配置这个屏幕：
- en: 'First, let''s update our GraphQL by adding a field to our `User` type. Update
    the `typeDefs` file''s `User` type by adding this just below the threads field:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过向我们的`User`类型添加一个字段来更新我们的GraphQL。通过在`typeDefs`文件的`User`类型下面添加这个字段来更新`User`类型：
- en: '[PRE98]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We also need to update our User Entity by adding one new field. Update the
    `User.ts` file by adding this field in it:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要通过添加一个新字段来更新我们的User Entity。通过在`User.ts`文件中添加这个字段来更新`User` Entity：
- en: '[PRE99]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This allows our `User` entity to have associated entities on the ThreadItems
    entity. Also, make sure you already have the matching field in the `ThreadItem.ts`
    file, like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们的`User`实体在ThreadItems实体上有关联的实体。还要确保您已经在`ThreadItem.ts`文件中有匹配的字段，像这样：
- en: '[PRE100]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now let''s open our UserRepo Repository file and update our `me` function so
    that it includes the user''s ThreadItems. Update the UserRepo `User.findOne` function
    like this:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们打开我们的UserRepo Repository文件，并更新我们的`me`函数，以便它包括用户的ThreadItems。像这样更新UserRepo
    `User.findOne`函数：
- en: '[PRE101]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You''ll notice that the UserProfile screen has a change password feature. So
    let''s build that out now. First, we''ll need to add a new Mutation to our `typeDefs`
    file. Add this Mutation to the Mutation section:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到用户资料屏幕具有更改密码功能。所以现在让我们构建出来。首先，我们需要在我们的`typeDefs`文件中添加一个新的Mutation。将此Mutation添加到Mutation部分：
- en: '[PRE102]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: A pretty self-explanatory Mutation definition.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当自解释的Mutation定义。
- en: Now let's implement this function in our UserRepo. Add the `changePassword`
    function to the end of the UserRepo from the source code.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在我们的UserRepo中实现这个函数。在源代码中的UserRepo末尾添加`changePassword`函数。
- en: Starting at line 125, since the user will be logged in if this call is made,
    we are expecting the user `id` from the resolver code to be passed in. If it does
    not exist, then of course we'll error out.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 125 行开始，因为如果进行了这个调用，用户将会被登录，我们期望从解析器代码中传递用户 `id`。如果不存在，那么当然我们会出错。
- en: Then we try and get the `User` object and then run a few checks to make sure
    the user is valid. And finally, we use `bcrypt` to generate our hashed password.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们尝试获取 `User` 对象，然后运行一些检查以确保用户是有效的。最后，我们使用 `bcrypt` 生成我们的哈希密码。
- en: Now we can create our resolver. Open the `resolvers` file and add the source
    code for the `changePassword` function into the Mutation section.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的解析器。打开 `resolvers` 文件，并将 `changePassword` 函数的源代码添加到 Mutation 部分。
- en: First, on line 389, we check if a valid Session and `userId` in that Session
    exist, because this is what indicates the user is logged in.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在第 389 行，我们检查一个有效的 Session 和在该 Session 中存在的 `userId`，因为这是指示用户已登录的标志。
- en: And lastly, we call our `changePassword` Repository function with the Session
    `userId` and the given new password.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 Session `userId` 和给定的新密码调用我们的 `changePassword` 仓库函数。
- en: 'Let''s now update our `UserProfile` component. Update the code as follows:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们更新我们的 `UserProfile` 组件。更新代码如下：
- en: 'Update the imports as we have imported a couple of new items, `gql` and `useMutation`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 更新导入，因为我们导入了一些新项目，`gql` 和 `useMutation`：
- en: '[PRE103]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here, we have our new Mutation, `ChangePassword`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有我们的新 Mutation，`ChangePassword`。
- en: '[PRE104]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: useEffect(() => {
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: useEffect(() => {
- en: if (user) {
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: if (user) {
- en: dispatch({
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: dispatch({
- en: 'type: "userName",'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 'type: "userName",'
- en: 'payload: user.userName,'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 'payload: user.userName,'
- en: '});'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: getUserThreads(user.id).then((items) => {
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: getUserThreads(user.id).then((items) => {
- en: 'const threadItemsInThreadList: Array<ThreadItem>        = [];'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 'const threadItemsInThreadList: Array<ThreadItem>        = [];'
- en: 'const threadList = items.map((th: Thread) => {'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 'const threadList = items.map((th: Thread) => {'
- en: for (let i = 0; i < th.threadItems.length; i++) {
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: for (let i = 0; i < th.threadItems.length; i++) {
- en: threadItemsInThreadList.push(th.            threadItems[i]);
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: threadItemsInThreadList.push(th.            threadItems[i]);
- en: '}'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return (
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <li key={`user-th-${th.id}`}>
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: <li key={`user-th-${th.id}`}>
- en: <Link to={`/thread/${th.id}`}               className="userprofile-link">
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: <Link to={`/thread/${th.id}`}    className="userprofile-link">
- en: '{th.title}'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '{th.title}'
- en: </Link>
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: </Link>
- en: </li>
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: </li>
- en: );
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '});'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: setThreads(<ul>{threadList}</ul>);
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: setThreads(<ul>{threadList}</ul>);
- en: 'const threadItemList = threadItemsInThreadList.         map((ti: ThreadItem)
    => ('
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 'const threadItemList = threadItemsInThreadList.        map((ti: ThreadItem)
    => ('
- en: <li key={`user-th-${ti.threadId}`}>
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: <li key={`user-th-${ti.threadId}`}>
- en: <Link to={`/thread/${ti.threadId}`}             className="userprofile-link">
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: <Link to={`/thread/${ti.threadId}`}       className="userprofile-link">
- en: '{ti.body}'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '{ti.body}'
- en: </Link>
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: </Link>
- en: </li>
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: </li>
- en: ));
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: setThreadItems(<ul>{threadItemList}</ul>);
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: setThreadItems(<ul>{threadItemList}</ul>);
- en: '});'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}, [user]);'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '}, [user]);'
- en: '[PRE105]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: const onClickChangePassword = async (
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: const onClickChangePassword = async (
- en: 'e: React.MouseEvent<HTMLButtonElement, MouseEvent>'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 'e: React.MouseEvent<HTMLButtonElement, MouseEvent>'
- en: ) => {
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ) => {
- en: e.preventDefault();
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: e.preventDefault();
- en: 'const { data: changePasswordData } = await     execChangePassword({'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 'const { data: changePasswordData } = await       execChangePassword({'
- en: 'variables: {'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 'variables: {'
- en: 'newPassword: password,'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 'newPassword: password,'
- en: '},'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '});'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: dispatch({
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: dispatch({
- en: 'type: "resultMsg",'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 'type: "resultMsg",'
- en: 'payload: changePasswordData ? changePasswordData.      changePassword : "",'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 'payload: changePasswordData ? changePasswordData.      changePassword : "",'
- en: '});'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '};'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return (
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <div className="screen-root-container">
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="screen-root-container">
- en: <div className="thread-nav-container">
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="thread-nav-container">
- en: <Nav />
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: <Nav />
- en: </div>
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <form className="userprofile-content-container">
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: <form className="userprofile-content-container">
- en: <div>
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: <div>
- en: <strong>User Profile</strong>
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: <strong>用户资料</strong>
- en: '<label style={{ marginLeft: ".75em"           }}>{userName}</label>'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '<label style={{ marginLeft: ".75em"     }}>{userName}</label>'
- en: </div>
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div className="userprofile-password">
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="userprofile-password">
- en: <div>
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: <div>
- en: <PasswordComparison
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: <PasswordComparison
- en: dispatch={dispatch}
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: dispatch={dispatch}
- en: password={password}
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: password={password}
- en: passwordConfirm={passwordConfirm}
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: passwordConfirm={passwordConfirm}
- en: />
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: <button
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: <button
- en: className="action-btn"
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: className="action-btn"
- en: disabled={isSubmitDisabled}
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: disabled={isSubmitDisabled}
- en: onClick={onClickChangePassword}
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: onClick={onClickChangePassword}
- en: '>'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '[PRE106]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Change Password
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 修改密码
- en: </button>
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: </button>
- en: </div>
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '<div style={{ marginTop: ".5em" }}>'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '<div style={{ marginTop: ".5em" }}>'
- en: <label>{resultMsg}</label>
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: <label>{resultMsg}</label>
- en: </div>
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div className="userprofile-postings">
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="userprofile-postings">
- en: <hr className="thread-section-divider" />
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: <hr className="thread-section-divider" />
- en: <div className="userprofile-threads">
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="userprofile-threads">
- en: <strong>Threads Posted</strong>
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: <strong>发布的主题</strong>
- en: '{threads}'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '{threads}'
- en: </div>
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div className="userprofile-threadIems">
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="userprofile-threadIems">
- en: <strong>ThreadItems Posted</strong>
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: <strong>发布的主题项</strong>
- en: '{threadItems}'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '{threadItems}'
- en: </div>
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </form>
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: </form>
- en: </div>
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: );
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '};'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: export default UserProfile;
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: export default UserProfile;
- en: '[PRE107]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now let''s show the user''s Threads and ThreadItems:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们展示用户的主题和主题项：
- en: 'First, we need to update our User model. Add this field to the `User.ts` file:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要更新我们的用户模型。在 `User.ts` 文件中添加这个字段：
- en: '[PRE108]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now update the `Me` query inside of the `useRefreshReduxMe` Hook like this:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在像这样更新 `useRefreshReduxMe` Hook 中的 `Me` 查询：
- en: '[PRE109]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, in your `UserProfile` component, update `useEffect` like this:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的 `UserProfile` 组件中，像这样更新 `useEffect`：
- en: '[PRE110]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We are now getting our threads from the `user.threads` array, instead of our
    fake `dataService` call, as shown:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在从 `user.threads` 数组中获取我们的主题，而不是我们的虚假 `dataService` 调用，如下所示：
- en: '[PRE111]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We do the same thing for `threadItems` as well. Notice our `Link to` gets updated
    so that it uses `ti.thread?.id` instead of `ti.threadId`:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也对 `threadItems` 做同样的事情。注意我们的 `Link to` 被更新了，所以它使用 `ti.thread?.id` 而不是 `ti.threadId`：
- en: '[PRE112]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Here, we had added a tiny bit of extra logic to format long text that might
    go horizontally off the screen and wrap. Basically, it just means that if the
    text is longer than 40 characters, we add `"…"` to it.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一点额外的逻辑来格式化可能会横向超出屏幕并换行的长文本。基本上，这意味着如果文本超过 40 个字符，我们会在文本后面添加 `"…"`。
- en: '[PRE113]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The remaining code is identical. If you run this, you should see something
    like the following (again, your data will be different):'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的代码是相同的。如果你运行这个，你应该会看到类似以下的东西（再次说明，你的数据将会不同）：
- en: '![Figure 15.16 – User''s Threads and ThreadItems'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.16 – 用户的主题和主题项'
- en: '](img/Figure_15.16_B15508.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.16_B15508.jpg)'
- en: Figure 15.16 – User's Threads and ThreadItems
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16-用户的Threads和ThreadItems
- en: OK, that's it for our UserProfile. Because this was an enormous amount of material
    to cover, let's continue our work in the next chapter, [*Chapter 16*](B15508_16_Final_JC_ePub.xhtml#_idTextAnchor254),
    *Adding a GraphQL Schema – Part II*.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是我们的UserProfile。因为这是一大堆要涵盖的材料，让我们在下一章继续我们的工作，[*第16章*]，*添加GraphQL模式-第二部分*。
- en: Summary
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have almost completed our application by integrating the
    frontend and the backend with GraphQL. This was a large and complex chapter so
    you should feel good about how far you have come.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过将前端和后端与GraphQL集成，几乎完成了我们的应用。这是一个庞大而复杂的章节，所以你应该为自己已经走过的路感到自豪。
- en: In the next chapter, [*Chapter 16*](B15508_16_Final_JC_ePub.xhtml#_idTextAnchor254),
    *Adding a GraphQL Schema – Part II*, we will finish coding our application by
    working on the Thread screen, so that we can view and post Threads, and work on
    the Points system so that users can see the popularity of individual Threads.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第16章*]，*添加GraphQL模式-第二部分*，我们将通过在Thread屏幕上工作来完成我们应用的编码，这样我们就可以查看和发布Threads，并且通过Points系统来查看用户对单个Threads的受欢迎程度。
