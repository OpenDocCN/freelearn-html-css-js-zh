- en: Creating a Chat System with Electron and React – Enhancement, Testing, and Delivery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Electron和React创建聊天系统-增强、测试和交付
- en: We finished the last chapter with a static prototype. We learned about React,
    composed the components, but didn't provide them with any state. Now, we will
    start binding the state of the application window to the Header component. As
    the state concept clarified, we will move to the chat services. After getting
    a brief introduction to the WebSockets technology, we will implement both the
    server and client. We will bind the service events to the application state. Finally,
    we will have a fully working chat. We won't stop on it, but will take care of
    the technical debt. So, we will set up the Jest testing framework and unit-test
    both the stateless and stateful components. Afterward, we will package the application
    and publish releases though a basic HTTP server. We will extend the application
    to update when new releases are available.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上一章以静态原型结束。我们了解了React，组合了组件，但没有为它们提供任何状态。现在，我们将开始将应用窗口的状态绑定到标题组件。随着状态概念的澄清，我们将转向聊天服务。在简要介绍了WebSockets技术之后，我们将实现服务器和客户端。我们将把服务事件绑定到应用状态。最后，我们将拥有一个完全可用的聊天功能。我们不会停在这里，而是会处理技术债务。因此，我们将设置Jest测试框架，并对无状态和有状态组件进行单元测试。之后，我们将打包应用程序，并通过基本的HTTP服务器发布版本。我们将扩展应用程序以在有新版本可用时进行更新。
- en: Revitalizing the title bar
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重振标题栏
- en: Until now, our title bar was not really useful. Thanks to the Photon framework,
    we can already use it as a handle to drag and drop the window across the viewport,
    yet we are missing windowing actions such as close, maximize, and restore window.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们的标题栏并不是真正有用的。多亏了Photon框架，我们已经可以将其用作拖放窗口的手柄，但我们还缺少窗口操作，比如关闭、最大化和还原窗口。
- en: 'Let''s implement them:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实现它们：
- en: '`./app/js/Components/Header.jsx`'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/js/Components/Header.jsx`'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We do not go with methods, with properties keeping anonymous functions bound
    to the object scope. This trick is possible, thanks to `babel-plugin-transform-class-properties`,
    which we included in the manifest and Webpack configuration in [Chapter 3](e8e11085-df99-4abc-8bf2-974934a69cb8.xhtml),
    *Creating a Chat System with Electron and React – Planning, Design, and Development*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用方法，而是使用将匿名函数绑定到对象范围的属性。这个技巧是可能的，多亏了我们在[第3章](e8e11085-df99-4abc-8bf2-974934a69cb8.xhtml)中包含在清单和Webpack配置中的`babel-plugin-transform-class-properties`。
- en: 'We extended the component with handlers to close the window, to maximize, and
    then to restore to its original size. We already have a `close` button in JSX,
    so we just need to subscribe to the corresponding handler method for the `click`
    event using the `onClick` attribute:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了组件，添加了关闭窗口、最大化和还原到原始大小的处理程序。我们在JSX中已经有了`close`按钮，所以我们只需要订阅相应的处理程序方法来处理`click`事件，使用`onClick`属性：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `maximize` and `restore` buttons, though, are rendered in HTML conditionally,
    depending on the current window state. Since we will utilize the state, let''s
    define it:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`maximize`和`restore`按钮是有条件地在HTML中渲染的，取决于当前窗口状态。因为我们将利用状态，让我们来定义它：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `isMaximized` state property takes in the corresponding flag from the current
    window instance. Now, we can extract this value from the state in JSX:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`isMaximized`状态属性接收当前窗口实例的相应标志。现在，我们可以从JSX中提取这个值的状态：'
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, we render the `restore` button when it is true and `maximize` otherwise.
    We also subscribe the handlers for the `click` events on both the buttons, but
    what about changing the state after the window maximizes or restores?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当`restore`为true时，我们渲染`restore`按钮，否则渲染`maximize`按钮。我们还订阅了两个按钮的`click`事件的处理程序，但是窗口最大化或还原后如何改变状态呢？
- en: 'We can subscribe to the corresponding window events straight before the component
    is rendered to the DOM:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件呈现到DOM之前，我们可以订阅相应的窗口事件：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the window changes its state handler, `updateState` invokes and actualizes
    the component state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口改变其状态处理程序时，`updateState`会调用并更新组件状态。
- en: Utilizing WebSockets
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用WebSockets
- en: We have a static prototype, and now we will make it functional. Any chat requires
    communication between connected clients. Usually, clients do not connect directly
    but through a server. The server registers connections and forwards the messages.
    It's pretty clear how to send a message from the client to server, but can we
    do it in the opposite direction? In the olden days, we had to deal with long-polling
    techniques. That worked, but with the overhead of HTTP, it is not really suitable
    when we mean a low latency application. Luckily for us, Electron supports WebSockets.
    With that API, we can open a full-duplex, bi-directional TCP connection between
    the client and server. WebSockets provides higher speed and efficiency as compared
    to HTTP. The technology brings reduction of upto 500:1 in unnecessary HTTP traffic
    and 3:1 in latency ([http://bit.ly/2ptVzlk](http://bit.ly/2ptVzlk)). You can find
    out more about WebSockets in my book *JavaScript Unlocked* ([https://www.packtpub.com/web-development/javascript-unlocked](https://www.packtpub.com/web-development/javascript-unlocked)).
    Here, we will get acquainted with the technology briefly, with the help of a small
    demo. I suggest examining an echo server and a client. Whenever a client sends
    a text to the server, the server broadcasts it on all the connected clients. So,
    on every page with the client loaded, we receive the message in real time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个静态原型，现在我们将使其功能。任何聊天都需要连接客户端之间的通信。通常，客户端不直接连接，而是通过服务器。服务器注册连接并转发消息。从客户端发送消息到服务器是很清楚的，但我们能否以相反的方式做呢？在过去，我们不得不处理长轮询技术。那样可以工作，但由于HTTP的开销，当我们需要低延迟的应用程序时，它并不是真正合适的。幸运的是，Electron支持WebSockets。通过该API，我们可以在客户端和服务器之间建立全双工、双向的TCP连接。与HTTP相比，WebSockets提供了更高的速度和效率。该技术可以将不必要的HTTP流量减少高达500:1，并将延迟减少3:1（[http://bit.ly/2ptVzlk](http://bit.ly/2ptVzlk)）。您可以在我的书*JavaScript
    Unlocked*中找到更多关于WebSockets的信息（[https://www.packtpub.com/web-development/javascript-unlocked](https://www.packtpub.com/web-development/javascript-unlocked)）。在这里，我们将通过一个小型演示简要了解该技术。我建议检查一个回声服务器和一个客户端。每当客户端向服务器发送文本时，服务器都会将其广播到所有连接的客户端。因此，在加载了客户端的每个页面上，我们都可以实时接收消息。
- en: 'Of course, we won''t write a protocol implementation for the server, but go
    with an existing NPM package--nodejs-websocket ([https://www.npmjs.com/package/nodejs-
    websocket](https://www.npmjs.com/package/nodejs-websocket)):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不会为服务器编写协议实现，而是使用现有的NPM包--nodejs-websocket（[https://www.npmjs.com/package/nodejs-websocket](https://www.npmjs.com/package/nodejs-websocket)）：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using the package API, we can quickly make our code to serve incoming messages
    from the client:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包API，我们可以快速编写代码来处理来自客户端的消息：
- en: '`./server.js`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`./server.js`'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we instantiate an object representing the WebSockets server (`server`).
    Within the callback of the `createServer` factory, we will receive connection
    objects. We subscribe to every connection for the `"text"` and `"error"` events.
    The first one happens when a data frame is sent from the client to the server.
    We simply forward it to every available connection. The second event is fired
    when something goes wrong, so we report the error. Finally, we start the server
    in the given port and host, for example, I set port `8001`. If this port is taken
    in your environment by any other program, just change the value of the `PORT`
    constant.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化一个代表WebSockets服务器（`server`）的对象。在`createServer`工厂的回调中，我们将接收连接对象。我们订阅每个连接的`"text"`和`"error"`事件。第一个事件发生在从客户端发送数据帧到服务器时。我们简单地将其转发到每个可用的连接。第二个事件在发生错误时触发，因此我们报告错误。最后，我们在给定的端口和主机上启动服务器，例如，我设置端口`8001`。如果您的环境中的任何其他程序占用了此端口，只需更改`PORT`常量的值即可。
- en: 'We can compose the client of this simplified chat as a single page application.
    So create the following HTML:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个简化的聊天客户端组成一个单页面应用程序。因此，创建以下HTML：
- en: '`./index.html`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`./index.html`'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the HTML, we placed a form with input control and output container. The intent
    is to send input value on form, submit it to the server, and display the server
    response in the output element.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，我们放置了一个带有输入控件和输出容器的表单。意图是在表单上发送输入值，将其提交到服务器，并在输出元素中显示服务器响应。
- en: In the JavaScript, we store a reference to the acting nodes and create an instance
    of the WebSockets client. We subscribe for the `error`, `open`, and `message`
    client events. The first two basically report on what is happening. The last one
    receives events from the server. In our case, the server sends text messages,
    so we can take them as `e.data`. We also need to handle the input from the client.
    Therefore, we subscribe for `submit` on the form element. We use the `send` method
    of the WebSockets client to dispatch the input value to the server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们存储了对操作节点的引用，并创建了WebSockets客户端的实例。我们订阅了`error`、`open`和`message`客户端事件。前两个基本上报告正在发生的事情。最后一个接收来自服务器的事件。在我们的情况下，服务器发送文本消息，因此我们可以将它们作为`e.data`。我们还需要处理来自客户端的输入。因此，我们订阅了表单元素上的`submit`。我们使用WebSockets客户端的`send`方法将输入值发送到服务器。
- en: 'To run the example, we can use the `http-server` module ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server))
    to launch a static HTTP server for our `index.html`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，我们可以使用`http-server`模块（[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)）为我们的`index.html`启动一个静态HTTP服务器：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can add the following commands to `package.json`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将以下命令添加到`package.json`：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, we can run the server as:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以运行服务器：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'and then the client as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后客户端为：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/b2410346-8edf-4dc5-bb31-5b3cc5f06751.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2410346-8edf-4dc5-bb31-5b3cc5f06751.png)'
- en: Implementing chat services
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现聊天服务
- en: 'I believe that it''s more or less clear how WebSockets works now, and we can
    apply the API for our chat. However, in a real application, we need something
    more than to echo sent texts. Let''s put the intended event scenarios on paper:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信现在大致清楚了WebSockets的工作原理，我们可以将API应用于我们的聊天。然而，在实际应用中，我们需要的不仅仅是回显发送的文本。让我们把预期的事件场景写在纸上：
- en: The `Welcome` component handles user input and sends via the client to the `join`
    server event with the entered user name in the payload
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Welcome` 组件处理用户输入，并通过客户端发送到 `join` 服务器事件，载荷中包含输入的用户名'
- en: The server receives the `join` event, adds a new user to the set, and broadcasts
    the `participants` event with the updated set
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器接收 `join` 事件，将新用户添加到集合中，并广播带有更新集合的 `participants` 事件
- en: The client receives the `participants` event and passes the set to the `Participants`
    component, which updates the participant's list
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端接收 `participants` 事件，并将集合传递给 `Participants` 组件，该组件更新参与者列表
- en: The `Conversation` component handles user input and sends the entered message
    via the client to the server as the `text` event with username, text, and timestamp
    in the payload
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Conversation` 组件处理用户输入，并将输入的消息通过客户端作为 `text` 事件发送到服务器，载荷中包含用户名、文本和时间戳'
- en: The server receives the `text` event and broadcasts it to all the chat participants
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器接收 `text` 事件并将其广播给所有聊天参与者
- en: 'As we deal with event messages, we need a unified format for sending and receiving
    a single source of truth. So, we implement a message wrapper--`./app/js/Service/Message.js`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理事件消息，我们需要一个统一的格式来发送和接收单一的真相来源。因此，我们实现了一个消息包装器--`./app/js/Service/Message.js`：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This module exposes two static methods. One transforms the given event name
    and payload into a JSON string, which can be sent through WebSockets; another
    translates the received string into a message object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块公开了两个静态方法。一个将给定的事件名称和载荷转换为 JSON 字符串，可以通过 WebSockets 发送；另一个将接收到的字符串转换为消息对象。
- en: 'Now we write the server--`./app/js/Service/Server.js`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编写服务器--`./app/js/Service/Server.js`：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The same as the echo server, this one subscribes to connection events to report
    what is going on and exposes the `broadcast` and `connect` methods. To make it
    handle incoming messages, we extend the `createServer` callback:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与回声服务器一样，这个服务器订阅连接事件以报告发生了什么，并公开了 `broadcast` 和 `connect` 方法。为了使其处理传入的消息，我们扩展了
    `createServer` 回调：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, when receiving a message, the server tries to call a handler method matching
    the event name. For example, when it receives `join` event, it calls `onjoin`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当接收到消息时，服务器会尝试调用与事件名称匹配的处理程序方法。例如，当它接收到 `join` 事件时，它会调用 `onjoin`：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The method accepts the event payload (the user name here) as the first parameter
    and the connection reference as the second. It registers the connection in `this.participant`
    map. So, we can now determine the associated user name and registration timestamp
    by a connection. The method then broadcasts the values of the map as an array
    (a set of usernames and timestamps).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受事件载荷（这里是用户名）作为第一个参数，连接引用作为第二个参数。它在 `this.participant` 映射中注册连接。因此，我们现在可以通过连接确定关联的用户名和注册时间戳。然后，该方法将映射的值作为数组广播（一组用户名和时间戳）。
- en: 'However, we shall not forget to define `this.participants` as a map in the
    class constructor:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们不应忘记在类构造函数中将 `this.participants` 定义为映射：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also add a handler method for the `text` event:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为 `text` 事件添加了处理程序方法：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The method extracts the username associated with the given connection from the
    `this.participants`, extends the message payload with it, and broadcasts the derived
    message.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从 `this.participants` 中提取与给定连接相关联的用户名，将消息载荷与之扩展，并广播派生消息。
- en: 'Now, we can write the client--`./app/js/Service/Client.js`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写客户端--`./app/js/Service/Client.js`：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The client implements the same trick with the handler methods as the server,
    but this time, we make the `connect` method return a Promise. Thus, we can adjust
    the execution flow if the client failed to connect the server. We have two handlers:
    `onparticipants` and `ontext`. Both of them simply bypass the received message
    to the application. Since the `Client` class extends `EventEmitter`, we can use
    `this.emit` to fire an event and any subscribed application module will be able
    to catch it. Besides, the client exposes two public methods: `join` and `message`.
    One (`join`) will be consumed by the `Welcome` component to register the provided
    username on the server, and the other (`message`) is called from the `Participants`
    component to communicate the submitted text to the server. Both the methods rely
    on the `send` private method, which actually dispatches messages.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端实现了与服务器相同的处理程序方法，但这次，我们让 `connect` 方法返回一个 Promise。因此，如果客户端无法连接服务器，我们可以调整执行流程。我们有两个处理程序：`onparticipants`
    和 `ontext`。它们都简单地将接收到的消息传递给应用程序。由于 `Client` 类扩展了 `EventEmitter`，我们可以使用 `this.emit`
    来触发事件，任何订阅的应用程序模块都能够捕获它。此外，客户端公开了两个公共方法：`join` 和 `message`。其中一个 (`join`) 将被 `Welcome`
    组件使用，用于在服务器上注册提供的用户名，另一个 (`message`) 则从 `Participants` 组件调用，将提交的文本传递给服务器。这两种方法都依赖于
    `send` 私有方法，它实际上是分发消息。
- en: 'Electron comprises of the Node.js runtime and therefore allows us to run the
    server. So, to make it simpler, we will include the server into the application.
    For that, we modify the server code again:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Electron 包括 Node.js 运行时，因此允许我们运行服务器。因此，为了使其更简单，我们将服务器包含到应用程序中。为此，我们再次修改服务器代码：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now it runs the supplied `client.connect` to establish a connection with our
    WebSockets server. If it's the very first instance of the application running,
    no server is yet available. Therefore, the client fails to connect and execution
    flow jumps into the catch callback. There, we start the server and reconnect the
    client.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它运行提供的 `client.connect` 来与我们的 WebSockets 服务器建立连接。如果这是应用程序运行的第一个实例，服务器尚不可用。因此，客户端无法连接，执行流程跳转到
    catch 回调。在那里，我们启动服务器并重新连接客户端。
- en: Bringing functionality to the components
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为组件带来功能
- en: 'Now when we have the server and client services, we can enable them in the
    application. The most suitable place is the `App` container--`./app/js/Containers/App.jsx`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了服务器和客户端服务，我们可以在应用程序中启用它们。最合适的地方是 `App` 容器--`./app/js/Containers/App.jsx`：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Do you remember that we rendered either the `ChatPane` or `Welcome` component
    conditionally in the static prototype?:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在静态原型中有条件地呈现 `ChatPane` 或 `Welcome` 组件吗？：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Back then, we hardcoded `name`, yet it belongs to the component state. So,
    we can initialize the state in the class constructor like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，我们将`name`硬编码，但它属于组件状态。因此，我们可以在类构造函数中初始化状态，如下所示：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Well, `name` is empty by default and we, therefore, show the `Welcome` component.
    We can type in a new name there. As it''s submitted, we need to somehow change
    the state in the parent component. We achieve it with a technique known as **Lifting
    state up**. We declare a handler for the `name` change event in the `App` container
    and pass it to the `Welcome` component with the props:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，`name`默认为空，因此我们显示`Welcome`组件。我们可以在那里输入一个新的名称。当提交时，我们需要以某种方式改变父组件中的状态。我们使用一种称为**状态提升**的技术来实现它。我们在`App`容器中声明一个处理`name`更改事件的处理程序，并将其与props一起传递给`Welcome`组件：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, we extract `name` from the state and use it in the expression. Initially,
    `name` is empty and therefore the `Welcome` component is rendered. We declare
    the `onNameChange` handler and pass it to the `Welcome` component with the props.
    The handler receives the submitted name, registers the new connection on the server
    (`this.client.join`), and changes the component state. So, the `ChatPane` component
    replaces `Welcome`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从状态中提取`name`并在表达式中使用它。最初，`name`为空，因此渲染`Welcome`组件。我们声明`onNameChange`处理程序，并将其与props一起传递给`Welcome`组件。处理程序接收提交的名称，在服务器上注册新连接（`this.client.join`），并更改组件状态。因此，`ChatPane`组件替换了`Welcome`。
- en: 'Now, we will edit the `Welcome` component--`./app/js/Components/Welcome.jsx`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑`Welcome`组件--`./app/js/Components/Welcome.jsx`：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Whenever a component expects any props, it usually means that we have to apply
    the `defaultProps` and `propTypes` static methods. These belong to the `React.Component`
    API and are automatically called during component initialization. The first one
    sets a default value for the props and the second validates them. In HTML, we
    subscribe to the `onSubmit` handler for the form `submit` event. In the handler,
    we need to access an input value. With the `ref` JSX attribute, we added the instance
    as a reference to the input element. So, from the `onSubmit` handler, we can obtain
    the input value as `this.nameEl.value`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个组件期望任何props时，通常意味着我们必须应用`defaultProps`和`propTypes`静态方法。这些方法属于`React.Component`API，并在组件初始化期间自动调用。第一个方法为props设置默认值，第二个方法验证它们。在HTML中，我们为表单的`submit`事件订阅`onSubmit`处理程序。在处理程序中，我们需要访问输入值。通过`ref`
    JSX属性，我们将实例添加为对输入元素的引用。因此，从`onSubmit`处理程序中，我们可以将输入值获取为`this.nameEl.value`。
- en: 'Well, now the user can register in the chat, and we need to show the chat UI--`./app/js/Components/ChatPane.jsx`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户可以在聊天中注册，我们需要显示聊天UI--`./app/js/Components/ChatPane.jsx`：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This one is a composite component that lays out the `Participants` and `Conversation`
    children components and forwards `client` to them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复合组件，它布局`Participants`和`Conversation`子组件，并将`client`转发给它们。
- en: 'The first one is meant to display the list of participants--`./app/js/Components/Participants.jsx`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个组件用于显示参与者列表--`./app/js/Components/Participants.jsx`：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we need some construction work. First, we define the state, which includes
    the participant list from the props. We also subscribe to the client `participants`
    event and update the state every time the server sends an updated list. When rendering
    the list, we also show participant registration time, such as joined 5 minutes
    ago. For that, we use a third-party component, `TimeAgo`, provided by the `react-timeago`
    NPM package.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要一些构造工作。首先，我们定义状态，其中包括来自props的参与者列表。我们还订阅客户端的`participants`事件，并在服务器发送更新列表时每次更新状态。在渲染列表时，我们还显示参与者注册时间，例如5分钟前加入。为此，我们使用`react-timeago`
    NPM包提供的第三方组件`TimeAgo`。
- en: 'Eventually, we are coming to the `Conversation` component--`./app/js/Components/Conversation.jsx`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到`Conversation`组件--`./app/js/Components/Conversation.jsx`：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: During the construction, we subscribe to the client `text` event and collect
    the received messages in the `this.messages` array. We use these messages to set
    the component state. In the `render` method, we extract the message list from
    the state and traverse it to render every item. The message view includes the
    sender's name, text, and time. The name we output as it is. We split the text
    in lines and wrap them with the paragraph element. To display time, we use the
    `normalizeTime` static method. This method transforms the `Date` object into a
    long string (date and time) when it's older than today, and into a short string
    (date) otherwise.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造过程中，我们订阅客户端的`text`事件，并将接收到的消息收集到`this.messages`数组中。我们使用这些消息来设置组件状态。在`render`方法中，我们从状态中提取消息列表，并遍历它以渲染每个项目。消息视图包括发送者的名称、文本和时间。我们直接输出名称。我们将文本按行拆分，并用段落元素包裹它们。为了显示时间，我们使用`normalizeTime`静态方法。该方法将`Date`对象转换为长字符串（日期和时间），当它比今天更旧时，否则转换为短字符串（日期）。
- en: 'We also need a form for sending messages to the chat. The ideal method would
    be to put the form into a separate component, but for the sake of brevity, we
    will keep it next to the conversation view:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个用于向聊天发送消息的表单。理想的方法是将表单放入一个单独的组件中，但为了简洁起见，我们将其保留在会话视图旁边：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Pretty much as in the `Welcome` component, we make a local reference to the
    text area node and subscribe the `onSubmit` handler for the form `submit` event.
    To make it user-friendly, we set `onKeydown` to listen to a keyboard event on
    the text area. When *Enter* is pressed during typing, we submit the form. So,
    we have to now add new handlers to the component class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Welcome`组件一样，我们在本地引用文本区域节点，并为文本区域的表单`submit`事件订阅`onSubmit`处理程序。为了使其用户友好，我们设置`onKeydown`来监听文本区域上的键盘事件。在输入期间按下*Enter*时，我们提交表单。因此，我们现在必须向组件类添加新的处理程序：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the form is submitted either by pressing the OK button or *Enter*, we pass
    the message to the server via the `message` method of the client and reset the
    form.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单通过按下OK按钮或*Enter*提交时，我们通过客户端的`message`方法将消息传递给服务器，并重置表单。
- en: 'I don''t know about you, but I have the itch to run the application and see
    it in action. We have two options here. We can just start multiple instances from
    the same machine, register each one with a different name, and start chatting:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你们，但我很想运行这个应用程序并看到它的运行情况。我们有两个选择。我们可以从同一台机器上启动多个实例，为每个实例注册不同的名称，并开始聊天：
- en: '![](img/389cf4cd-b808-434f-a669-4649c4fef2f9.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/389cf4cd-b808-434f-a669-4649c4fef2f9.png)'
- en: Alternatively, we set a public IP in the `App` container to make the chat available
    across the network.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们在 `App` 容器中设置一个公共 IP，使聊天在整个网络中可用。
- en: Writing unit-tests
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'In real life, we cover application functionality with unit-tests. When it comes
    to React, the Jest testing framework is the first to pop up in one''s mind. The
    framework is developed by Facebook as well as React. Jest is not aimed at React
    only; you can test any JavaScript. Just to see how it works, we can set up a new
    project:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们使用单元测试来覆盖应用功能。当涉及到 React 时，Jest 测试框架是第一个浮现在人们脑海中的。这个框架是由 Facebook 以及
    React 开发的。Jest 不仅针对 React；你可以测试任何 JavaScript。为了看看它是如何工作的，我们可以设置一个新项目：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Install Jest by running the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装 Jest：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Edit the `scripts` section in `package.json`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `package.json` 中的 `scripts` 部分：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Place the example unit for testing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 放置用于测试的示例单元：
- en: '`./unit.js`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`./unit.js`'
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is a simple pure function that double any given number. What we need to
    do now is to just place a JavaScript file of a name matching the `*.(spec|test).js`
    pattern--`./unit.spec.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的纯函数，它会将给定的数字加倍。现在我们需要做的就是放置一个与 `*.(spec|test).js` 模式匹配的 JavaScript 文件--`./unit.spec.js`：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you are familiar with Mocha or, better, Jasmine, you will have no problem
    reading this test suite. We describe an aspect (`describe()`), declare our expectations
    (`it()`), and assert that the result produced by the unit under test meets the
    requirements (`expect()`). Basically, the syntax doesn't differ from the one we
    used in [Chapter 2](013f4079-2a91-4776-a2bb-82e9ff5eb552.xhtml), *Creating a File
    Explorer with NW.js – Enhancement and Delivery*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Mocha 或者更好的 Jasmine，你将毫无问题地阅读这个测试套件。我们描述一个方面（`describe()`），声明我们的期望（`it()`），并断言被测试单元产生的结果是否满足要求（`expect()`）。基本上，这种语法与我们在[第
    2 章](013f4079-2a91-4776-a2bb-82e9ff5eb552.xhtml)中使用的语法没有区别，*使用 NW.js 创建文件资源管理器-增强和交付*。
- en: 'By running `npm test`, we get the following report:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `npm test`，我们得到以下报告：
- en: '![](img/a6bd66e6-b7d5-4c3e-a007-73158c9efea9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6bd66e6-b7d5-4c3e-a007-73158c9efea9.png)'
- en: 'What makes Jest preferable in our case is that it''s really close to the React
    philosophy and incorporates specific features for testing a React application.
    For example, Jest comprises of the `toMatchSnapshot` assertion method. So, we
    can build a component in the virtual DOM, and make and save the snapshot of the
    element. Then, after refactoring, we run the tests. Jest takes actual snapshots
    of the modified components and compares them to the stored ones. That''s a common
    approach for regression tests. Before putting it into practice, we have to set
    up Jest for our environment. We specified our bundling configuration in `webpack.config.js`.
    Jest won''t consider this file. We have to compile the source for Jest separately,
    and we can do it with `babel-jest`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 在我们的情况下更可取的原因在于它与 React 哲学非常接近，并且包含了用于测试 React 应用的特定功能。例如，Jest 包括 `toMatchSnapshot`
    断言方法。因此，我们可以在虚拟 DOM 中构建一个组件，并保存该元素的快照。然后，在重构后，我们运行测试。Jest 会获取修改后组件的实际快照，并将其与存储的快照进行比较。这是回归测试的常见方法。在实践之前，我们必须为我们的环境设置
    Jest。我们在 `webpack.config.js` 中指定了我们的捆绑配置。Jest 不会考虑这个文件。我们必须单独为 Jest 编译源代码，我们可以使用
    `babel-jest` 来实现：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This plugin takes the code transformation instructions from the Babel runtime
    config--`./.babelrc`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件从 Babel 运行时配置中获取代码转换指令--`./.babelrc`：
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we use preset env ([https://babeljs.io/docs/plugins/preset-env/](https://babeljs.io/docs/plugins/preset-env/)),
    which automatically determines and loads the plugins required by the target environment
    (Node.js 7). Do not forget to install the preset:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用预设的 env ([https://babeljs.io/docs/plugins/preset-env/](https://babeljs.io/docs/plugins/preset-env/))，它会自动确定并加载目标环境（Node.js
    7）所需的插件。不要忘记安装预设：
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We also apply the `transform-class-properties` and `transform-class-properties`
    plugins to get access to rest, spread, and ES Class Fields and Static Properties
    syntax, respectively (we have already used these plugins for Webpack configuration
    in [Chapter 3](e8e11085-df99-4abc-8bf2-974934a69cb8.xhtml), *Creating a Chat System
    with Electron and React – Planning, Design, and Development*).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应用了 `transform-class-properties` 和 `transform-class-properties` 插件，以便分别获得
    rest、spread 和 ES 类字段和静态属性语法的访问权限（我们已经在[第 3 章](e8e11085-df99-4abc-8bf2-974934a69cb8.xhtml)中为
    Webpack 配置使用了这些插件，*使用 Electron 和 React 创建聊天系统-规划、设计和开发*）。
- en: 'As we did in the `normalizeTime` test example, we will modify the manifest--`./package.json`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 `normalizeTime` 测试示例中所做的那样，我们将修改清单--`./package.json`：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This time, we also explicitly point Jest to our source directory, `app/js`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们还明确指定了 Jest 的源目录，`app/js`。
- en: 'As I explained earlier, we will produce snapshots of React components for further
    assertions. That can be achieved with the `react-test-renderer` package:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前解释的，我们将为 React 组件生成快照以进行进一步的断言。这可以通过 `react-test-renderer` 包实现：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we can write our first component regression test--`./app/js/Components/Footer.spec.jsx`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写我们的第一个组件回归测试--`./app/js/Components/Footer.spec.jsx`：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Yeah, it turned out that easy. We create an element with `renderer.create` and
    obtain static data representation by calling the `toJSON` method. When we first
    run the test (`npm test`), it creates the `__snapshots__` directory with the snapshot
    next to the test file. Every subsequent time, Jest compares the stored snapshots
    to the actual ones.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这很容易。我们使用 `renderer.create` 创建一个元素，并通过调用 `toJSON` 方法获得静态数据表示。当我们首次运行测试（`npm
    test`）时，它会创建一个 `__snapshots__` 目录，其中包含与测试文件相邻的快照。每次之后，Jest 会将存储的快照与实际快照进行比较。
- en: If you want to reset snapshots, just run ``npm test -- -u``.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想重置快照，只需运行 ``npm test -- -u``。
- en: 'Testing a stateful component is similar--`./app/js/Components/Participants.spec.jsx`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个有状态的组件类似--`./app/js/Components/Participants.spec.jsx`：
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use the `getInstance` method of the created element to access the component
    instance. Thus, we can call the methods of the instance that set the concrete
    state. Here, we pass the fixture list of participants directly to the `onClientParticipants`
    handler. The component renders the list, and we make a snapshot.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用创建的元素的`getInstance`方法来访问组件实例。 因此，我们可以调用实例的方法来设置具体的状态。 在这里，我们直接将参与者的固定列表传递给`onClientParticipants`处理程序。
    组件呈现列表，我们进行快照。
- en: 'Regression tests are good to check whether the component wasn''t broken during
    refactoring, but they do not guarantee that the component behaved as intended
    in the first place. React provides an API via the `react-dom/test-utils` module
    ([https://facebook.github.io/react/docs/test-utils.html](https://facebook.github.io/react/docs/test-utils.html)),
    which we can use to assert that the component really renders everything we expect
    from it. With third-party package enzyme, we can do even more ([http://airbnb.io/enzyme/docs/api/shallow.html](http://airbnb.io/enzyme/docs/api/shallow.html)).
    To get an idea about it, we add a test in the `Footer` suite--`./app/js/Components/Footer.spec.jsx`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试很好，可以检查组件在重构过程中是否没有损坏，但不能保证组件在最初的行为是否符合预期。 React通过`react-dom/test-utils`模块提供了一个API（[https://facebook.github.io/react/docs/test-utils.html](https://facebook.github.io/react/docs/test-utils.html)），我们可以使用它来断言组件确实呈现了我们期望的一切。
    使用第三方包enzyme，我们甚至可以做得更多（[http://airbnb.io/enzyme/docs/api/shallow.html](http://airbnb.io/enzyme/docs/api/shallow.html)）。
    为了了解它，我们在`Footer`套件中添加了一个测试--`./app/js/Components/Footer.spec.jsx`：
- en: '[PRE42]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, we assume that the component renders an HTML footer element (`tree.find(
    "footer" )`). We also check whether the footer contains the project name from
    the manifest:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们假设该组件呈现HTML页脚元素（`tree.find("footer")`）。 我们还检查页脚是否包含清单中的项目名称：
- en: '![](img/f1e9f94f-9b0f-42e5-8b81-ec9c543ff535.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1e9f94f-9b0f-42e5-8b81-ec9c543ff535.png)'
- en: Packaging and distribution
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和分发
- en: 'When we worked with File Explorer and NW.js, we used the `nwjs-builder` tool
    for packaging our application. The Electron has an even more sophisticated tool--electron-builder
    ([https://github.com/electron-userland/electron-builder](https://github.com/electron-userland/electron-builder)).
    Actually, it builds an application installer. The range of target package formats
    electron-builder supports is impressive. Then, why not try packaging our application?
    First, we install the tool:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用文件资源管理器和NW.js时，我们使用`nwjs-builder`工具打包我们的应用程序。 Electron有一个更复杂的工具--electron-builder
    ([https://github.com/electron-userland/electron-builder](https://github.com/electron-userland/electron-builder))。
    实际上，它构建了一个应用程序安装程序。 electron-builder支持的目标软件包格式范围令人印象深刻。 那么，为什么不尝试打包我们的应用程序呢？ 首先，我们安装该工具：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We add a new script to the manifest--`./package.json`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在清单中添加一个新的脚本--`./package.json`：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We also set an arbitrary ID for the application in field build:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在构建字段中为应用程序设置了一个任意的ID：
- en: '[PRE45]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We definitely want to provide the application with an icon, so we create the
    `build` subdirectory and place their `icon.icns` for macOS, `icon.ico` for Windows
    there. Icons for Linux will be extracted from `icon.icns`. Alternatively, you
    can place icons in `build/icons/` named after their sizes--`64x64.png`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定希望为应用程序提供图标，因此我们创建`build`子目录，并在其中放置`icon.icns`（macOS），`icon.ico`（Windows）的图标。
    Linux的图标将从`icon.icns`中提取。 或者，您可以将图标放在`build/icons/`中，以其大小命名--`64x64.png`。
- en: 'In fact, we have not yet granted our application window with an icon. To fix
    it, we modify our main process script--`./app/main.js`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们还没有为应用程序窗口分配图标。 为了解决这个问题，我们修改我们的主进程脚本--`./app/main.js`：
- en: '[PRE46]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Everything seems ready, so we can run the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一切似乎已经准备就绪，所以我们可以运行以下命令：
- en: '[PRE47]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As the process completes, we can find the generated package in the default
    format in the newly created `dist` folder:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 随着过程的完成，我们可以在新创建的`dist`文件夹中找到默认格式的生成软件包：
- en: 'Ubuntu: `chat-1.0.0-x86_64.AppImage`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ubuntu: `chat-1.0.0-x86_64.AppImage`'
- en: '`*` Windows: `chat Setup 1.0.0.exe`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` Windows: `chat Setup 1.0.0.exe`'
- en: '`*` MacOS: `chat-1.0.0.dmg`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` MacOS: `chat-1.0.0.dmg`'
- en: 'Of course, we can aim for a specific target format:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以针对特定的目标格式进行设置：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that the diverse package format may require additional metadata in the
    manifest ([https://github.com/electron-userland/electron-builder/wiki/Options](https://github.com/electron-userland/electron-builder/wiki/Options)).
    For instance, packaging in `.deb` requires both the `homepage` and `author` fields
    filled in.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不同的软件包格式可能需要在清单中添加额外的元数据（[https://github.com/electron-userland/electron-builder/wiki/Options](https://github.com/electron-userland/electron-builder/wiki/Options)）。
    例如，打包为`.deb`需要填写`homepage`和`author`字段。
- en: Deployment and updates
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和更新
- en: Built-in capacities for auto updates is one of Electron's most prominent advantages
    over NW.js. Electron's `autoUpdater` module ([http://bit.ly/1KKdNQs](http://bit.ly/1KKdNQs))
    utilizes the Squirrel framework ([https://github.com/Squirrel](https://github.com/Squirrel)),
    which makes *silent* possible. It works nicely in conjunction with the existing
    solution for multiplatform release servers; in particular, one can run it with
    Nuts ([https://github.com/GitbookIO/nuts](https://github.com/GitbookIO/nuts))
    using GitHub as a backend. We can also quickly set up a fully-featured node server
    based on `electron-release-server` ([https://github.com/ArekSredzki/electron-release-server](https://github.com/ArekSredzki/electron-release-server)),
    which includes release management UI.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 自动更新的内置功能是Electron相对于NW.js的最显着优势之一。 Electron的`autoUpdater`模块（[http://bit.ly/1KKdNQs](http://bit.ly/1KKdNQs)）利用了Squirrel框架（[https://github.com/Squirrel](https://github.com/Squirrel)），这使得*静默*成为可能。
    它与现有的多平台发布服务器解决方案很好地配合使用；特别是，可以在GitHub上使用Nuts（[https://github.com/GitbookIO/nuts](https://github.com/GitbookIO/nuts)）运行它。
    我们还可以快速设置一个基于`electron-release-server`的全功能节点服务器（[https://github.com/ArekSredzki/electron-release-server](https://github.com/ArekSredzki/electron-release-server)），其中包括发布管理UI。
- en: Electron-updater doesn't support Linux. The project maintainers recommend using
    the distribution's package manager to update the application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Electron-updater 不支持 Linux。 项目维护者建议使用发行版的软件包管理器来更新应用程序。
- en: For the sake of brevity, we will walk through a simplified autoupdate approach
    that doesn't require a real release server, but only requires access to static
    releases via HTTP.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们将介绍一种简化的自动更新方法，它不需要真正的发布服务器，只需要通过HTTP访问静态发布。
- en: 'We start by installing the package:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装包：
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we add to the manifest''s `build` field--publish property:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在清单的`build`字段中添加--publish属性：
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we state that our `dist` folder will be available publicly on `127.0.0.1:8080`,
    and we go on with the `generic` provider. Alternatively, the provider can be set
    to Bintray ([https://bintray.com/](https://bintray.com/)) or GitHub.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明我们的`dist`文件夹将在`127.0.0.1:8080`上公开，然后我们继续使用`generic`提供程序。或者，提供程序可以设置为Bintray（[https://bintray.com/](https://bintray.com/)）或GitHub。
- en: 'We modify our main process script to take advantage of the `electron-updater`
    API--`./app/main.js`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改主进程脚本以利用`electron-updater` API--`./app/main.js`：
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Basically, we subscribe for the `autoUpdater` events and report them to the
    renderer script using the `send` function. When `update-downloaded` is fired,
    we send the `update- downloaded` event to the renderer. The renderer on this event
    supposedly reports to the user about a newly downloaded version and asks whether
    it would be convenient to restart the application. When confirmed, the renderer
    sends the `restart` event. From the main process, we subscribe to it using `ipcMain`
    ([http://bit.ly/2pChUNg](http://bit.ly/2pChUNg)). So, when `reset` is fired, `autoUpdater`
    restarts the application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们订阅`autoUpdater`事件并使用`send`函数将其报告给渲染器脚本。当触发`update-downloaded`时，我们将`update-downloaded`事件发送到渲染器。渲染器在此事件上报告给用户有一个新下载的版本，并询问是否方便重新启动应用程序。确认后，渲染器发送`restart`事件。从主进程中，我们使用`ipcMain`（[http://bit.ly/2pChUNg](http://bit.ly/2pChUNg)）订阅它。因此，当触发`reset`时，`autoUpdater`重新启动应用程序。
- en: 'Note that `electron-debug` won''t be available after packaging, so we have
    to remove it from the main process:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`electron-debug`在打包后将不可用，因此我们必须从主进程中将其删除：
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we make a few changes to the renderer script--`./app/index.html`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对渲染器脚本进行一些更改--`./app/index.html`。
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In HTML, we add the `<i>` element with ID `statusbar`, which will print out
    reports from the main process. In JavaScript, we subscribe for main process events
    using `ipcRenderer` ([http://bit.ly/2p9xuwt](http://bit.ly/2p9xuwt)). On the `info`
    event, we change the content of the `statusbar` element with the event payload
    string. When `update-downloaded` occurs, we call `confirm` for the user opinion
    about a suggested restart. If the result is positive, we send the `restart` event
    to the main process.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，我们添加了ID为`statusbar`的`<i>`元素，它将打印出主进程的报告。在JavaScript中，我们使用`ipcRenderer`（[http://bit.ly/2p9xuwt](http://bit.ly/2p9xuwt)）订阅主进程事件。在`info`事件上，我们使用事件载荷字符串更改`statusbar`元素的内容。当发生`update-downloaded`时，我们调用`confirm`来询问用户关于建议重新启动的意见。如果结果是积极的，我们将`restart`事件发送到主进程。
- en: 'Eventually, we edit CSS to stick our `statusbar` element in the left-bottom
    corner of the viewport--`./app/assets/css/custom.css`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们编辑CSS将我们的`statusbar`元素固定在视口的左下角--`./app/assets/css/custom.css`：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Everything is done; let''s rock it! So, we first rebuild the project and release
    it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都完成了；让我们开始吧！所以，我们首先重新构建项目并发布它：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We make the release available through HTTP using `http-server` ([https://www.npmjs.com/package/http-
    server](https://www.npmjs.com/package/http-server)):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过HTTP使用`http-server`（[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)）提供发布：
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We run the release to install the application. The application starts up as
    usual because no new releases are available yet, so we release a new version:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行发布以安装应用程序。应用程序像往常一样启动，因为尚未有新版本可用，所以我们发布了一个新版本：
- en: '[PRE57]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the footer component, we display the application name and version taken by
    the `require` function from the manifest. Webpack retrieves it at compilation
    time. So, if `package.json` is modified after the application is built, the changes
    do not reflect in the footer; we need to rebuild the project.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在页脚组件中，我们显示了从清单中的`require`函数获取的应用程序名称和版本。Webpack在编译时检索它。因此，如果在构建应用程序后修改了`package.json`，更改不会反映在页脚中；我们需要重新构建项目。
- en: Alternatively, we can take the name and version dynamically from the `app` ([http://bit.ly/2qDmdXj](http://bit.ly/2qDmdXj))
    object of Electron and forward it as an IPC event to the renderer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以动态从Electron的`app`（[http://bit.ly/2qDmdXj](http://bit.ly/2qDmdXj)）对象中获取名称和版本，并将其作为IPC事件转发到渲染器。
- en: 'Now, we will start our previously installed release and this time, we will
    observe the `autoUpdater` reports in `statusbar`. As the new release is downloaded,
    we will get the following confirmation window:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将启动之前安装的发布，这次我们将在`statusbar`中观察`autoUpdater`的报告。随着新版本的下载，我们将得到以下确认窗口：
- en: '![](img/7ce30fe9-45d9-4623-af41-99a6370b9375.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ce30fe9-45d9-4623-af41-99a6370b9375.png)'
- en: 'After pressing OK, the application closes and a new window showing the installation
    process pops up:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“确定”后，应用程序关闭，弹出一个显示安装过程的新窗口：
- en: '![](img/dbe45246-db00-4d92-8ee3-756fbec9299e.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbe45246-db00-4d92-8ee3-756fbec9299e.png)'
- en: 'When it''s done, start the updated application. Note that the footer now contains
    the latest released version:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，启动更新的应用程序。请注意，页脚现在包含了最新发布的版本：
- en: '![](img/72b231a9-33c3-439a-aed8-13eee7da86c7.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72b231a9-33c3-439a-aed8-13eee7da86c7.png)'
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've completed our chat application. We started this chapter by programming
    the actions of the title bar. On the way, we learned how to control application
    window state in Electron. We looked into the WebSockets technology on the example
    of simple echo server and the accompanying client. Going deeper, we designed chat
    services based on WebSockets. We bound client events to the component states.
    We were introduced to the Jest testing framework and examined a generic approach
    to unit-testing React components. Besides, we created regression tests for both
    stateless and stateful components. We packaged our application and built an installer.
    We fiddled with publishing releases and made the application update whenever a
    new release is available.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的聊天应用程序。我们从编程标题栏的操作开始了本章。在这个过程中，我们学会了如何在Electron中控制应用程序窗口状态。我们通过简单的回声服务器和相应的客户端示例来了解了WebSockets技术。更深入地，我们设计了基于WebSockets的聊天服务。我们将客户端事件绑定到组件状态。我们介绍了Jest测试框架，并研究了对React组件进行单元测试的通用方法。此外，我们为无状态和有状态组件创建了回归测试。我们打包了我们的应用程序并构建了安装程序。我们对发布版本进行了调整，并使应用程序在有新版本可用时进行更新。
