- en: MongoDB, Mongoose, and REST APIs – Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB、Mongoose和REST API – 第1部分
- en: In this chapter, you're going to learn how to connect your Node applications
    to the MongoDB database you've been running on your local machine. This means
    that we'll be able to issue database commands right inside of our Node apps to
    do stuff like insert, update, delete, or read data. This is going to be critical
    if we're ever going to make that Todo REST API. When someone hits one of our API
    endpoints, we want to manipulate the database, whether it's reading all of the
    Todos or adding a new one. Before we can do any of that though, we have to learn
    the basics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何将您的Node应用程序连接到您在本地计算机上运行的MongoDB数据库。这意味着我们将能够在我们的Node应用程序内部发出数据库命令，执行诸如插入、更新、删除或读取数据等操作。如果我们要制作Todo
    REST API，这将是至关重要的。当有人访问我们的API端点时，我们希望操作数据库，无论是读取所有的Todos还是添加一个新的。然而，在我们做任何这些之前，我们必须先学习基础知识。
- en: Connecting to MongoDB and writing data
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到MongoDB并写入数据
- en: 'To connect to our MongoDB database from inside of Node.js, we''re going to
    be using an npm module created by the MongoDB team. It''s called node-mongodb-native,
    but it includes all of the features you''ll need to connect to and interact with
    your database. To get to it, we''re going to Google `node-mongodb-native`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Node.js内部连接到我们的MongoDB数据库，我们将使用MongoDB团队创建的一个npm模块。它被称为node-mongodb-native，但它包括了你需要连接和与数据库交互的所有功能。要找到它，我们将谷歌搜索`node-mongodb-native`：
- en: '![](img/d2d25ad4-75ae-45ac-ba0e-26abbda50968.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2d25ad4-75ae-45ac-ba0e-26abbda50968.png)'
- en: 'The GitHub repo, which should be the first link, is the one we want—the node-mongodb-native
    repository—and if we scroll down, we can take a look at a few important links:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库，应该是第一个链接，是我们想要的——node-mongodb-native仓库——如果我们向下滚动，我们可以看一下一些重要的链接：
- en: '![](img/c02996e6-da4d-4ffa-8612-721523ea48e4.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c02996e6-da4d-4ffa-8612-721523ea48e4.png)'
- en: First up we have documentation, and we also have our api-docs; these are going
    to be critical as we start exploring the features that we have inside of this
    library. If we scroll down further on this page, we'll find a ton of examples
    on how to get started. We'll be going through a lot of this stuff in this chapter,
    but I do want to make you aware of where you can find other resources because
    the mongodb-native library has a ton of features. There are entire courses dedicated
    to MongoDB, and they don't even begin to cover everything that's built-in to this
    library.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是文档，还有我们的api-docs；当我们开始探索这个库内部的功能时，这些将是至关重要的。如果我们在这个页面上继续向下滚动，我们会发现大量关于如何入门的示例。我们将在本章中讨论很多这些内容，但我想让你知道你可以在哪里找到其他资源，因为mongodb-native库有很多功能。有整个课程专门致力于MongoDB，甚至都没有涵盖这个库内置的所有功能。
- en: 'We''re going to be focusing on the important and common subset of MongoDB that
    we need for Node.js apps. To get started, let''s go ahead and open up the documentations,
    which are shown in the preceding image. When you go to the docs page, you have
    to pick your version. We''ll be using version 3.0 of the driver, and there''s
    two important links:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于Node.js应用程序所需的MongoDB的重要和常见子集。要开始，让我们打开上图中显示的文档。当你进入文档页面时，你必须选择你的版本。我们将使用3.0版本的驱动程序，有两个重要的链接：
- en: '**The Reference link:** This includes guide-like articles, things to get you
    started, and other various references.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考链接：** 这包括类似指南的文章，入门指南和其他各种参考资料。'
- en: '**The API link:** This includes the details of every single method available
    to you when you''re working with the library. We''ll be exploring some of the
    methods on this link as we start creating our Node Todo API.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API链接：** 这包括您在使用该库时可用的每个单独方法的详细信息。当我们开始创建我们的Node Todo API时，我们将在此链接上探索一些方法。'
- en: For now though, we can get started by creating a new directory for this project,
    and then we're going to go ahead and install the MongoDB library and connect to
    the database we have running. I am going to assume that you have your database
    running for all the sections in this chapter. I have it running in a separate
    tab in my Terminal.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，现在我们可以开始为这个项目创建一个新目录，然后我们将安装MongoDB库并连接到我们正在运行的数据库。我假设您在本章的所有部分中都已经运行了您的数据库。我在我的终端中的一个单独标签页中运行它。
- en: If you're on Windows, refer to the instructions in the Windows installation
    section to start your database if you forget. If you're on a Linux or macOS operating
    system, use the instructions I have already mentioned, and don't forget to also
    include that `dbpath` argument, which is essential for booting up your MongoDB
    server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows，请参考Windows安装部分的说明来启动您的数据库，如果您忘记了。如果您使用的是Linux或macOS操作系统，请使用我已经提到的说明，并且不要忘记也包括`dbpath`参数，这对于启动MongoDB服务器至关重要。
- en: Creating a directory for the project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为项目创建一个目录
- en: 'To kick things off, I''m going to make a new folder on the Desktop for the
    Node API. I''ll use `mkdir` to create a new folder called `node-todo-api`. Then,
    I can go ahead and use `cd` to go into that directory, `cd node-todo-api`. And
    from here, we''re going to run `npm init`, which creates our `package.json` file
    and lets us install our MongoDB library. Once again, we''re going to be using
    enter to skip through all of the options, using the defaults for each:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我要在桌面上为Node API创建一个新文件夹。我将使用`mkdir`创建一个名为`node-todo-api`的新文件夹。然后，我可以使用`cd`进入该目录，`cd
    node-todo-api`。从这里，我们将运行`npm init`，这将创建我们的`package.json`文件，并允许我们安装我们的MongoDB库。再次，我们将使用回车键跳过所有选项，使用每个默认值：
- en: '![](img/08418c55-f4af-4d52-8f3c-239701eb5c9f.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08418c55-f4af-4d52-8f3c-239701eb5c9f.png)'
- en: Once we get to the end we can confirm our selections, and now our `package.json`
    file is created. The next thing we're going to do is open up this directory inside
    of Atom. It's on the Desktop, `node-todo-api`. Next up, inside of the root of
    the project we're going to create a new folder, and I'm going to call this folder
    `playground`. Inside of this folder, we'll store various scripts. They're not
    going to be scripts related to the Todo API; they'll be scripts related to MongoDB,
    so I do want to keep them in the folder, but I don't necessarily want them to
    be part of the app. We'll use the `playground` folder for that, like we have in
    the past.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达结尾，我们可以确认我们的选择，现在我们的`package.json`文件已经创建。接下来我们要做的是在Atom中打开这个目录。它在桌面上，`node-todo-api`。接下来，在项目的根目录中，我们将创建一个新文件夹，我将称这个文件夹为`playground`。在这个文件夹里，我们将存储各种脚本。它们不会是与Todo
    API相关的脚本；它们将是与MongoDB相关的脚本，所以我希望将它们放在文件夹中，但我不一定希望它们成为应用的一部分。我们将像以前一样使用`playground`文件夹。
- en: 'In the `playground` folder, let''s go ahead and make a new file, and we''ll
    call this file `mongodb-connect.js`. Inside of this file, we''re going to get
    started by loading in the library and connecting to the database. Now in order
    to do that, we have to install the library. From the Terminal, we can run `npm
    install` to get that done. The new library name is `mongodb`; all lowercase, no
    hyphens. Then, we''re going to go ahead and specify the version to make sure we''re
    all using the same functionality, `@3.0.2`. This is the most recent version at
    the time of writing. After the version number, I am going to use the `--save`
    flag. This is going to save it as a regular dependency, which it already is:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`playground`文件夹中，让我们继续创建一个新文件，我们将称这个文件为`mongodb-connect.js`。在这个文件中，我们将通过加载库并连接到数据库来开始。现在，为了做到这一点，我们必须安装库。从终端，我们可以运行`npm
    install`来完成这项工作。新的库名称是`mongodb`；全部小写，没有连字符。然后，我们将继续指定版本，以确保我们都使用相同的功能，`@3.0.2`。这是写作时的最新版本。在版本号之后，我将使用`--save`标志。这将把它保存为常规依赖项，它已经是：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We're going to need this to run the Todo API application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个来运行Todo API应用程序。
- en: Connecting the mongodb-connect file to the database
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`mongodb-connect`文件连接到数据库。
- en: 'With MongoDB now installed, we can move it to our `mongodb-connect` file and
    start connecting to the database. The first thing we need to do is pull something
    out of the library that we just installed, which is the `mongodb` library. What
    we''re looking for is something called the `MongoClient` constructor. The `MongoClient`
    constructor lets you connect to a Mongo server and issue commands to manipulate
    the database. Let''s go ahead and kick things off by creating a constant called
    `MongoClient`. We''re going to set that equal to `require`, and we''re going to
    require the library we just installed, `mongodb`. From that library, we''re going
    to pull off `MongoClient`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装了MongoDB，我们可以将其移动到我们的`mongodb-connect`文件并开始连接到数据库。我们需要做的第一件事是从我们刚刚安装的库中提取一些东西，那就是`mongodb`库。我们要找的是一个叫做`MongoClient`的构造函数。`MongoClient`构造函数允许您连接到Mongo服务器并发出命令来操作数据库。让我们继续创建一个名为`MongoClient`的常量。我们将把它设置为`require`，并且我们将要求我们刚刚安装的库`mongodb`。从那个库中，我们将取出`MongoClient`：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the `MongoClient` now in place, we can call `MongoClient.connect` to connect
    to the database. This is a method, and it takes two arguments:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`MongoClient`已经就位，我们可以调用`MongoClient.connect`来连接到数据库。这是一个方法，它接受两个参数：
- en: The first argument is a string, and this is going to be the URL where your database
    lives. Now in a production example, this might be an Amazon Web Services URL or
    a Heroku URL. In our case, it's going to be a localhost URL. We'll talk about
    that later.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个字符串，这将是您的数据库所在的URL。现在在生产示例中，这可能是Amazon Web Services URL或Heroku URL。在我们的情况下，它将是本地主机URL。我们稍后会谈论这个。
- en: The second argument is going to be a callback function. The callback function
    will fire after the connection has either succeeded or failed, and then we can
    go ahead and handle things appropriately. If the connection failed, we'll print
    a message and stop the program. If it succeeded, we can start manipulating the
    database.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数将是一个回调函数。回调函数将在连接成功或失败后触发，然后我们可以适当地处理事情。如果连接失败，我们将打印一条消息并停止程序。如果成功，我们可以开始操作数据库。
- en: Adding a string as the first argument
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串添加为第一个参数
- en: 'For the first argument in our case, we''re going to start off with `mongodb://`.
    When we connect to a MongoDB database, we want to use the mongodb protocol like
    this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个参数，我们将从`mongodb://`开始。当我们连接到MongoDB数据库时，我们要使用像这样的mongodb协议：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next up, it''s going to be at localhost since we''re running it on our local
    machine, and we have the port, which we have already explored: `27017`. After
    the port, we need to use `/` to specify which database we want to connect to.
    Now, in the previous chapter, we used that test database. This is the default
    database that MongoDB gives you, but we could go ahead and create a new one. After
    the `/`, I''m going to call the database `TodoApp`, just like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将在本地主机上，因为我们在本地机器上运行它，并且我们已经探索了端口：`27017`。在端口之后，我们需要使用`/`来指定我们要连接的数据库。现在，在上一章中，我们使用了测试数据库。这是MongoDB给你的默认数据库，但我们可以继续创建一个新的。在`/`之后，我将称数据库为`TodoApp`，就像这样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding the callback function as the second argument
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将回调函数添加为第二个参数
- en: 'Next up, we can go ahead and provide the callback function. I''m going to use
    an ES6 arrow (`=>`) function, and we''re going to get past two arguments. The
    first one is going to be an error argument. This may or may not exist; just like
    we''ve seen in the past, it''ll exist if an error actually happened; otherwise
    it won''t. The second argument is going to be the `client` object. This is what
    we can use to issue commands to read and write data:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以继续提供回调函数。我将使用ES6箭头（`=>`）函数，并且我们将通过两个参数。第一个将是一个错误参数。这可能存在，也可能不存在；就像我们过去看到的那样，如果实际发生了错误，它就会存在；否则就不会存在。第二个参数将是`client`对象。这是我们可以用来发出读写数据命令的对象：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Error handling in mongodb-connect
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mongodb-connect中的错误处理
- en: 'Now, before we write any data, I''m going to go ahead and handle any potential
    errors that come about. I''ll do that using an `if` statement. If there is an
    error, we''re going to print a message to the console, letting whoever is looking
    at the logs know that we were unable to connect to the database server, `console.log`,
    then inside of quotes put something like `Unable to connect to MongoDB server`.
    After the `if` statement, we can go ahead and log out a success message, which
    will be something like `console.log`. Then, inside of quotes, we''ll use `Connected
    to MongoDB server`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在写入任何数据之前，我将继续处理可能出现的任何错误。我将使用一个`if`语句来做到这一点。如果有错误，我们将在控制台上打印一条消息，让查看日志的人知道我们无法连接到数据库服务器，`console.log`，然后在引号内放上类似`Unable
    to connect to MongoDB server`的内容。在`if`语句之后，我们可以继续记录一个成功的消息，类似于`console.log`。然后，在引号内，我们将使用`Connected
    to MongoDB server`：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, when you're handling errors like this, the success code is going to run
    even if the error block runs. What we want to do instead is add a `return` statement
    right before the `console.log('Unable to connect to MongoDB server');` line.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你处理这样的错误时，即使错误块运行，成功代码也会运行。我们要做的是在`console.log('Unable to connect to MongoDB
    server');`行之前添加一个`return`语句。
- en: 'This `return` statement isn''t doing anything fancy. All we''re doing is using
    it to prevent the rest of the function from executing. As soon as you return from
    a function, the program stops, which means if an error does occur, the message
    will get logged, the function will stop, and we''ll never see this `Connected
    to MongoDB server` message:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`return`语句并没有做什么花哨的事情。我们所做的只是使用它来阻止函数的其余部分执行。一旦从函数返回，程序就会停止，这意味着如果发生错误，消息将被记录，函数将停止，我们将永远看不到这条`Connected
    to MongoDB server`消息：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An alternative to using the `return` keyword would be to add an `else` clause
    and put our success code in an `else` clause, but it's unnecessary. We can just
    use the `return` syntax, which I prefer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`return`关键字的替代方法是添加一个`else`子句，并将我们的成功代码放在`else`子句中，但这是不必要的。我们可以只使用我更喜欢的`return`语法。
- en: 'Now, before we run this file, there is one more thing I want to do. At the
    very bottom of our callback function, we''re going to call a method on db. It''s
    called `client.close`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在运行这个文件之前，我还想做一件事。在我们的回调函数的最底部，我们将在db上调用一个方法。它叫做`client.close`：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This closes the connection with the MongoDB server. Now that we have this in
    place, we can actually save the `mongodb-connect` file and run it inside of the
    Terminal. It doesn't do much yet, but it is indeed going to work.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这关闭了与MongoDB服务器的连接。现在我们已经有了这个设置，我们实际上可以保存`mongodb-connect`文件并在终端内运行它。它现在还没有做太多事情，但它确实会工作。
- en: Running the file in the Terminal
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在终端中运行文件
- en: 'Inside the Terminal, we can run the file using `node playground` as the directory,
    with the file itself being `mongodb-connect.js`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们可以使用`node playground`作为目录运行文件，文件本身是`mongodb-connect.js`：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we run this file, we get `Connected to MongoDB server` printing to the
    screen:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个文件时，我们会得到`Connected to MongoDB server`打印到屏幕上：
- en: '![](img/9407d5a3-011f-4cbe-90eb-9c4a31b55d58.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9407d5a3-011f-4cbe-90eb-9c4a31b55d58.png)'
- en: 'If we head over into the tab where we have the MongoDB server, we can see we
    got a new connection: connection accepted. As you can see in the following screenshot,
    that connection was closed down, which is fantastic:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进入我们拥有MongoDB服务器的选项卡，我们可以看到我们有一个新的连接：连接已接受。正如你在下面的截图中所看到的，该连接已关闭，这太棒了：
- en: '![](img/6f1192b4-66da-47e3-bde5-7f094bbc762f.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f1192b4-66da-47e3-bde5-7f094bbc762f.png)'
- en: Using the Mongo library we were able to connect, print a message, and disconnect
    from the server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Mongo库，我们能够连接，打印一条消息，并从服务器断开连接。
- en: Now, you might have noticed that we changed the database name in the `MongoClient.connect`
    line in Atom, and we never actually did anything to create it. In MongoDB, unlike
    other database programs, you don't need to create a database before you start
    using it. If I want to kick up a new database I simply give it a name, something
    like `Users`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能已经注意到我们在Atom中的`MongoClient.connect`行中更改了数据库名称，但我们实际上并没有做任何事情来创建它。在MongoDB中，与其他数据库程序不同，你不需要在开始使用之前创建数据库。如果我想启动一个新的数据库，我只需给它一个名称，比如`Users`。
- en: Now that I have a `Users` database, I can connect to it and I can manipulate
    it. There is no need to create that database first. I'm going to go ahead and
    change the database name back to `TodoApp`. If we head into the Robomongo program
    and connect to our local database, you'll also see that the only database we have
    is `test`. The `TodoApp` database was never even created, even though we connected
    to it. Mongo is not going to create the database until we start adding data into
    it. We can go ahead and do that right now.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有一个`Users`数据库，我可以连接到它并对其进行操作。没有必要先创建该数据库。我将继续将数据库名称更改回`TodoApp`。如果我们进入Robomongo程序并连接到我们的本地数据库，你还会看到我们唯一拥有的数据库是`test`。`TodoApp`数据库甚至从未被创建过，即使我们连接到它。Mongo不会创建数据库，直到我们开始向其中添加数据。我们现在可以继续做到这一点。
- en: Adding data to the database
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向数据库添加数据
- en: 'Inside of Atom, before our call to `db.close`, we''re going to insert a new
    record into a collection. This is going to be the Todo application. We''re going
    to have two collections in this app:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，在我们调用`db.close`之前，我们将向集合中插入一条新记录。这将是Todo应用程序。在这个应用程序中，我们将有两个集合：
- en: a `Todos` collection
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Todos`集合
- en: a `Users` collection
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Users`集合
- en: 'We can go ahead and start adding some data to the `Todos` collection by calling
    `db.collection`. The `db.collection` method takes the string name for the collection
    you want to insert into as its only argument. Now, like the actual database itself,
    you don''t need to create this collection first. You can simply give it a name,
    like `Todos`, and you can start inserting into it. There is no need to run any
    command to create it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续通过调用`db.collection`向`Todos`集合添加一些数据。`db.collection`方法以要插入的集合的字符串名称作为其唯一参数。现在，就像实际数据库本身一样，您不需要首先创建此集合。您只需给它一个名称，比如`Todos`，然后可以开始插入。无需运行任何命令来创建它：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we''re going to use a method available in our collection called `insertOne`.
    The `insertOne` method lets you insert a new document into your collection. It
    takes two arguments:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用集合中可用的一个方法`insertOne`。`insertOne`方法允许您将新文档插入到集合中。它需要两个参数：
- en: The first one is going to be an object. This is going to store the various key-value
    pairs we want to have in our document.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个将是一个对象。这将存储我们希望在文档中拥有的各种键值对。
- en: The second one is going to be a callback function. This callback function will
    get fired when things either fail or go well.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个将是一个回调函数。当事情失败或顺利进行时，将触发此回调函数。
- en: 'You''re going to get an error argument, which may or may not exist, and you''ll
    also get the result argument, which is going to be provided if things went well:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得一个错误参数，可能存在，也可能不存在，您还将获得结果参数，如果一切顺利，将会提供：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside of the error callback function itself, we can add some code to handle
    the error, and then we''ll add some code to print the object to the screen if
    it was added successfully. First up, let''s add an error handler. Much like we
    have done previously, we''re going to check if the error argument exists. If it
    does, then we''ll simply print a message using the `return` keyword to stop the
    function from executing. Next, we can use `console.log` to print `Unable to insert
    todo`. The second argument I''m going to pass to the `console.log` is going to
    be the actual `err` object itself, so if someone''s looking at the logs, they
    can see exactly what went wrong:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误回调函数本身内部，我们可以添加一些代码来处理错误，然后我们将添加一些代码来在成功添加时将对象打印到屏幕上。首先，让我们添加一个错误处理程序。就像我们之前做的那样，我们将检查错误参数是否存在。如果存在，那么我们将简单地使用`return`关键字打印一条消息，以阻止函数继续执行。接下来，我们可以使用`console.log`打印`无法插入todo`。我将传递给`console.log`的第二个参数将是实际的`err`对象本身，这样如果有人查看日志，他们可以看到出了什么问题：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next to our `if` statement, we can add our success code. In this case, all
    we''re going to do is pretty-print something to the `console.log` screen, and
    then I''m going to call `JSON.stringify`, where we''re going to go ahead and pass
    in `result.ops`. The `ops` attribute is going to store all of the docs that were
    inserted. In this case, we used `insertOne`, so it''s just going to be our one
    document. Then, I can add my other two arguments, which are `undefined` for the
    filter function, and `2` for the indentation:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`if`语句旁边，我们可以添加我们的成功代码。在这种情况下，我们要做的只是将一些内容漂亮地打印到`console.log`屏幕上，然后我将调用`JSON.stringify`，我们将继续传入`result.ops`。`ops`属性将存储所有插入的文档。在这种情况下，我们使用了`insertOne`，所以它只会是我们的一个文档。然后，我可以添加另外两个参数，对于筛选函数是`undefined`，对于缩进是`2`：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this in place, we can now go ahead and execute our file and see what happens.
    Inside of the Terminal, I''m going to run the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以继续执行我们的文件，看看会发生什么。在终端中，我将运行以下命令：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When I execute the command, we get our success message: `Connected to MongoDB
    server`. Then, we get an array of documents that were inserted:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我执行命令时，我们会收到成功消息：`已连接到MongoDB服务器`。然后，我们会得到一个插入的文档数组：
- en: '![](img/bc451fb0-aae9-404f-9d73-cb56589083ef.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc451fb0-aae9-404f-9d73-cb56589083ef.png)'
- en: Now as I mentioned, in this case we just inserted one document, and that shows
    up as shown in the preceding screenshot. We have the `text` property, which gets
    created by us; we have the `completed` property, which gets created by us; and
    we have the `_id` property, which gets automatically added by Mongo. The `_id`
    property is going to be the topic of the following section. We're going to talk
    in depth about what it is, why it exists and why it's awesome.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正如我所提到的，在这种情况下，我们只插入了一个文档，如前面的屏幕截图所示。我们有`text`属性，由我们创建；我们有`completed`属性，由我们创建；我们有`_id`属性，由Mongo自动添加。`_id`属性将是接下来部分的主题。我们将深入讨论它是什么，为什么存在以及为什么它很棒。
- en: 'For now, we''re going to go ahead and just note that it''s a unique identifier.
    It''s an ID given to just this document. That is all it takes to insert a document
    into your MongoDB database using Node.js. We can view this document inside of
    Robomongo. I''m going to right-click the connection, and click Refresh:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将继续注意它是一个唯一标识符。这是一个仅分配给此文档的ID。这就是使用Node.js将文档插入到您的MongoDB数据库中所需的全部内容。我们可以在Robomongo中查看此文档。我将右键单击连接，然后单击刷新：
- en: '![](img/3618889d-f9e2-4b28-9548-d34f9e2f0315.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3618889d-f9e2-4b28-9548-d34f9e2f0315.png)'
- en: 'This reveals our brand new `TodoApp` database. If we open that up, we get our
    `Collections` list. We can then go into the `Collections`, view the documents,
    and what do we get? We get our one Todo item. If we expand it, we can see we have
    our _id, we have our text property, and we have our completed Boolean:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们全新的`TodoApp`数据库。如果我们打开它，我们会得到我们的`Collections`列表。然后我们可以进入`Collections`，查看文档，我们得到了什么？我们得到了我们的一个Todo项目。如果我们展开它，我们可以看到我们有我们的_id，我们有我们的文本属性，我们有我们的完成布尔值：
- en: '![](img/952d1c7e-fe2e-40e3-a249-8ac9ca3e4b68.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/952d1c7e-fe2e-40e3-a249-8ac9ca3e4b68.png)'
- en: In this case, the Todo is not completed, so the completed value is false. Now,
    what I want you to do is add a new record into a collection. This is going to
    be your challenge for the section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Todo未完成，因此`completed`值为`false`。现在，我希望您将一个新记录添加到集合中。这将是本节的挑战。
- en: Adding a new record into a collection
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向集合中添加新记录
- en: Inside of Atom, what I'd like you to do is take the code all the way from `db.collection`
    down to the bottom of our callback, and comment it out. Then, we're going to go
    ahead and add something following it. Right previous `db.close()`, you're going
    to type `Insert new doc into the Users collection`. This doc is going to have
    a few properties. I want you to give it a `name` property; set that equal to your
    name. Then, we're going to give it an `age` property, and last but not least we
    can give it a `location` string. I want you to insert that doc using `insertOne`.
    You're going to need to pass in the new collection name into the collection method.
    Then, further down, you're going to add some error-handling code, and you're going
    to print the ops to the screen. Once you rerun the file, you should be able to
    view your record in the Terminal and you should be able to refresh things. Over
    in Robomongo, you should see the new Users collection, and you should see your
    user with the name, age, and location you specified.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，我希望您从`db.collection`一直到回调的底部，将代码注释掉。然后，我们将继续添加一些内容。在`db.close()`之前，您将输入`Insert
    new doc into the Users collection`。这个文档将有一些属性。我希望您给它一个`name`属性；将其设置为您的名字。然后，我们将给它一个`age`属性，最后但并非最不重要的是我们可以给它一个`location`字符串。我希望您使用`insertOne`插入该文档。您需要将新的集合名称传递给集合方法。然后，再往下，您将添加一些错误处理代码，并将操作打印到屏幕上。重新运行文件后，您应该能够在终端中查看您的记录，并且应该能够刷新。在Robomongo中，您应该看到新的Users集合，并且应该看到您指定的用户的名称、年龄和位置。
- en: 'Hopefully, you were able to insert a new document into the Users collection.
    What you needed to do in order to get this done is call `db.collection` so we
    can access the collection we want to insert into, which in this case is `Users`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您能够成功将一个新文档插入到Users集合中。为了完成这个任务，您需要调用`db.collection`，这样我们就可以访问我们想要插入的集合，这种情况下是`Users`：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next up, we have to call a method to manipulate the `Users` collection. We
    want to insert a new document, so we''re going to use `insertOne`, just like we
    did in the previous sub-section. We''re going to pass our two arguments into `insertOne`.
    The first one is the document to insert. We''re going to give it a `name` property;
    I''ll set that equal to `Andrew`. Then, we can go ahead and set the `age` equal
    to something like `25`. Lastly, we''ll set the `location` equal to my current
    location, `Philadelphia`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要调用一个方法来操作`Users`集合。我们想要插入一个新文档，所以我们将使用`insertOne`，就像我们在上一小节中所做的那样。我们将把两个参数传递给`insertOne`。第一个是要插入的文档。我们将给它一个`name`属性；我将把它设置为`Andrew`。然后，我们可以设置`age`等于`25`。最后，我们将`location`设置为我的当前位置，`Philadelphia`：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next argument we want it to pass in is our callback function, which is
    going to get called with the error object as well as the results. Inside of the
    callback function itself, we''re going to first handle the error. If there was
    an error, we''re going to go ahead and log it to the screen. I''m going to return
    `console.log`, and then we can put the message: `Unable to insert user`. Then,
    I''ll add the error argument as the second argument for `console.log`. Next up,
    we can add our success case code. If things go well, all I''m going to do is use
    `console.log` to print `result.ops` to the screen. This is going to show us all
    of the records that were inserted:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要传入的下一个参数是我们的回调函数，它将在错误对象和结果一起被调用。在回调函数内部，我们将首先处理错误。如果有错误，我们将继续将其记录到屏幕上。我将返回`console.log`，然后我们可以放置消息：`Unable
    to insert user`。然后，我将添加错误参数作为`console.log`的第二个参数。接下来，我们可以添加我们的成功案例代码。如果一切顺利，我将使用`console.log`将`result.ops`打印到屏幕上。这将显示我们插入的所有记录：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now go ahead and rerun the file inside of the Terminal using the *up*
    arrow key and the *enter* key:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续使用*向上*箭头键和*回车*键在终端内重新运行文件：
- en: '![](img/1efe9b45-0509-4625-9bcf-cf85ef2e1968.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1efe9b45-0509-4625-9bcf-cf85ef2e1968.png)'
- en: We get our array of inserted documents, and we just have one. The `name`, `age`,
    and `location` properties all come from us, and the `_id` property comes from
    MongoDB.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们插入的文档数组，只有一个。`name`、`age`和`location`属性都来自我们，`_id`属性来自MongoDB。
- en: 'Next up, I want you to verify that it was indeed inserted by viewing it in
    Robomongo. In general, when you add a new collection or a new database, you can
    just right-click the connection itself, click Refresh, and then you should be
    able to see everything that was added:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我希望您验证它是否确实被插入到Robomongo中。通常，当您添加一个新的集合或新的数据库时，您可以右键单击连接本身，单击刷新，然后您应该能够看到添加的所有内容：
- en: '![](img/029bbfea-6826-4ece-ac25-f10f834c5966.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/029bbfea-6826-4ece-ac25-f10f834c5966.png)'
- en: As shown in the preceding screenshot, we have our Users collection. I can view
    the documents for Users. We get our one document with the name set to Andrew,
    age set to 25, and location set to Philadelphia. With this in place, we are now
    done. We've been able to connect to our MongoDB database using Node.js, and we've
    also learned how to insert documents using this mongo-native library. In the next
    section, we're going to take an in-depth look at ObjectIds, exploring exactly
    what they are and why they're useful.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们有我们的Users集合。我可以查看Users的文档。我们得到了一个文档，其中名称设置为Andrew，年龄设置为25，位置设置为Philadelphia。有了这个，我们现在完成了。我们已经能够使用Node.js连接到我们的MongoDB数据库，还学会了如何使用这个mongo-native库插入文档。在下一节中，我们将深入研究ObjectIds，探讨它们究竟是什么，以及它们为什么有用。
- en: The ObjectId
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ObjectId
- en: Now that you have inserted some documents into your MongoDB collections, I want
    to take a moment to talk about the `_id` property in the context of MongoDB because
    it's a little different than the IDs that you're probably used to if you've used
    other database systems, like Postgres or MySQL.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经将一些文档插入到MongoDB集合中，我想花一点时间谈谈MongoDB中的`_id`属性，因为它与您可能已经使用过的其他数据库系统（如Postgres或MySQL）中的ID有些不同。
- en: The _id property in the context of MongoDB
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB中的_id属性
- en: 'To kick off our discussion of the `_id` property, let''s go ahead and rerun
    the `mongodb-connect` file. This is going to insert a new document into the Users
    collection, like we''ve defined in the `db.collection` line. I''m going to go
    ahead and do that by running the file through the node. It''s in the `playground`
    folder, and the file itself is called `mongodb-connect.js`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们对`_id`属性的讨论，让我们继续重新运行`mongodb-connect`文件。这将向Users集合中插入一个新的文档，就像我们在`db.collection`行中定义的那样。我将通过在节点中运行文件来做到这一点。它在`playground`文件夹中，文件本身叫做`mongodb-connect.js`：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I''m going to run the command, and we''re going to print out the document that
    got inserted:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我将运行命令，然后我们将打印出插入的文档：
- en: '![](img/dc75c923-aecb-4897-9cde-e6938420c025.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc75c923-aecb-4897-9cde-e6938420c025.png)'
- en: As we've seen in the past, we get our three attributes as well as the one added
    by Mongo.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们过去所看到的，我们得到了我们的三个属性，以及Mongo添加的一个属性。
- en: The first thing you'll notice about this is that it is not an auto incrementing
    integer, kind of like it is for Postgres or MySQL, where the first record has
    an ID of 1 and the second one has an ID of 2\. Mongo does not use this approach.
    Mongo was designed to scale out really easily. Scaling out means that you can
    add on more database servers to handle that extra load.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个的第一件事是，它不是一个自动递增的整数，就像对于Postgres或MySQL一样，第一条记录的ID是1，第二条记录的ID是2。Mongo不使用这种方法。Mongo被设计为非常容易扩展。扩展意味着你可以添加更多的数据库服务器来处理额外的负载。
- en: Imagine you have a web app that gets about 200 users a day and your current
    servers are ready for that traffic. Then, you get picked up by some news outlet
    and 10,000 people flood your site. With MongoDB, it's really easy to kick up new
    database servers to handle that extra load. When we use a randomly generated ID,
    we don't need to constantly communicate with the other database servers to check
    what the highest incrementing value is. Is it 7? Is it 17? It doesn't really matter;
    we're simply going to generate a new random ObjectId and use that for the document's
    unique identifier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个每天大约有200个用户的Web应用程序，你当前的服务器已经准备好处理这个流量。然后，你被某个新闻媒体选中，有1万人涌入你的网站。使用MongoDB，很容易启动新的数据库服务器来处理额外的负载。当我们使用随机生成的ID时，我们不需要不断地与其他数据库服务器通信，以检查最高递增值是多少。是7吗？是17吗？这并不重要；我们只是简单地生成一个新的随机ObjectId，并将其用于文档的唯一标识符。
- en: Now, the ObjectId itself is made up of a few different things. It's a 12-byte
    value. The first four bytes are a timestamp; we'll talk about that later. That
    means that we have a timestamp built into the data that refers to the moment in
    time the ID was created. This means that in our documents, we don't need to have
    a `createdAt` field; it's already encoded in the ID.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，ObjectId本身由几个不同的部分组成。它是一个12字节的值。前四个字节是时间戳；我们稍后会谈论这个。这意味着我们在数据中有一个内置的时间戳，指的是ID创建时刻的时间。这意味着在我们的文档中，我们不需要有一个`createdAt`字段；它已经编码在ID中了。
- en: The next three bytes are machine identifiers. This means that if two computers
    generate ObjectIds, their machine ID is going to be different, and this is going
    to ensure that the ID is unique. Next up, we have two bytes, the process ID, which
    is just another way to create a unique identifier. Last up, we have a 3-byte counter.
    This is similar to what MySQL would do. This is only 3 bytes of the ID. As we
    have already mentioned, we have a timestamp which is going to be unique; a machine
    identifier; a process ID; and lastly, just a random value. That is what makes
    up an ObjectId.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个字节是机器标识符。这意味着如果两台计算机生成ObjectId，它们的机器ID将是不同的，这将确保ID是唯一的。接下来，我们有两个字节，进程ID，这只是另一种创建唯一标识符的方式。最后，我们有一个3字节的计数器。这类似于MySQL会做的。这只是ID的3个字节。正如我们已经提到的，我们有一个时间戳，它将是唯一的；一个机器标识符；一个进程ID；最后，只是一个随机值。这就是ObjectId的组成部分。
- en: 'The ObjectId is the default value for `_id`. If nothing is provided, you can
    indeed do whatever you like with that property. For example, inside of the `mongodb-connect`
    file, I can specify an `_id` property. I''m going to give it a value, so let''s
    go with `123`; add a comma at the end; and that is perfectly legal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ObjectId是`_id`的默认值。如果没有提供任何内容，你确实可以对该属性做任何你喜欢的事情。例如，在`mongodb-connect`文件中，我可以指定一个`_id`属性。我将给它一个值，所以让我们用`123`；在末尾加上逗号；这是完全合法的：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can save the file, and rerun the script using the *up* arrow key and the
    *enter* key:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保存文件，并使用*上*箭头键和*回车*键重新运行脚本：
- en: '![](img/dfbb1afb-2704-4061-b756-9cdefb890c9e.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfbb1afb-2704-4061-b756-9cdefb890c9e.png)'
- en: 'We get our record, where the `_id` property is `123`. The `ObjectId` is the
    default way MongoDB creates IDs, but you can do anything you like for ID creation.
    Inside of Robomongo, we can give our Users collection a refresh, and we get our
    documents:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们的记录，其中`_id`属性是`123`。`ObjectId`是MongoDB创建ID的默认方式，但你可以为ID创建做任何你喜欢的事情。在Robomongo中，我们可以刷新我们的Users集合，然后得到我们的文档：
- en: '![](img/201195b7-8371-478d-a7a1-988e81213e14.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/201195b7-8371-478d-a7a1-988e81213e14.png)'
- en: 'We have the one we created in the previous section and the two we just made
    now, all with a unique identifier. This is why unique IDs are really important.
    In this example, we have three properties: name, age and location, and they''re
    the same for all the records. This is a reasonable thing to do. Imagine two people
    need to do the same thing, like buy groceries. That string alone is not going
    to be enough to uniquely identify a Todo. ObjectIds, on the other hand, are going
    to be unique, and that is what we''re going to use to associated things like Todos
    with things like `Users`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们在上一节中创建的一个，以及我们刚刚创建的两个，都有一个唯一的标识符。这就是为什么唯一的ID非常重要。在这个例子中，我们有三个属性：名称、年龄和位置，它们对所有记录都是相同的。这是一个合理的做法。想象两个人需要做同样的事情，比如买东西。仅仅那个字符串是不够唯一标识一个Todo的。另一方面，ObjectId是唯一的，这就是我们将用来将诸如Todos之类的事物与诸如`Users`之类的事物关联起来的东西。
- en: Next up, I want to take a look at some things we can do with the ID inside of
    our code. As I mentioned earlier, a timestamp is embedded inside of here, and
    we can actually pull that out. Inside of Atom, what we're going to do is remove
    the `_id` property. The timestamp is only going to be available when you're using
    the `ObjectId`. Then, inside of our callback, we can go ahead and print the timestamp
    to the screen.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我想看一下我们在代码中可以做的一些事情。正如我之前提到的，时间戳被嵌入在这里，我们实际上可以将其提取出来。在Atom中，我们要做的是移除`_id`属性。时间戳只有在使用`ObjectId`时才可用。然后，在我们的回调函数中，我们可以继续将时间戳打印到屏幕上。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you remember, `result.ops` is an array of all the documents that got inserted.
    We''re only inserting one, so I''m going to access the first item in the array,
    and then we''re going to access the `_id` property. This is going to do exactly
    what you might think:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，`result.ops`是一个包含所有插入的文档的数组。我们只插入一个，所以我将访问数组中的第一个项目，然后我们将访问`_id`属性。这将正如你所想的那样：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we save the file and rerun the script over from the Terminal, all we get
    is the `ObjectId` printing to the screen:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存文件并从终端重新运行脚本，我们只会得到`ObjectId`打印到屏幕上：
- en: '![](img/288d7028-2bd9-4e7e-8fc1-fab1a9e60a0c.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/288d7028-2bd9-4e7e-8fc1-fab1a9e60a0c.png)'
- en: Now though, we can call a method on the `_id` property.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`_id`属性上调用一个方法。
- en: Calling the .getTimestamp function
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用`.getTimestamp`函数
- en: 'What we''re going to call is `.getTimestamp`. The `getTimestamp` is a function,
    but it doesn''t take any arguments. It simply returns the timestamp that the ObjectId
    was created at:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要调用的是`.getTimestamp`。`getTimestamp`是一个函数，但它不需要任何参数。它只是返回ObjectId创建的时间戳：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if we go ahead and rerun our program, we get a timestamp:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们继续重新运行我们的程序，我们会得到一个时间戳：
- en: '![](img/7d48f1c5-d083-463a-859e-3c4a91749924.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d48f1c5-d083-463a-859e-3c4a91749924.png)'
- en: In the preceding screenshot, I can see that the ObjectId was created on February
    16th 2016 at 08:41 Z, so this timestamp is indeed correct. This is a fantastic
    way to figure out exactly when a document was created.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我可以看到ObjectId是在2016年2月16日08:41 Z创建的，所以这个时间戳确实是正确的。这是一个绝妙的方法，可以准确地确定文档是何时创建的。
- en: Now, we don't have to rely on MongoDB to create our ObjectIds. Inside of the
    MongoDB library, they actually give us a function we can run to make an ObjectId
    whenever we like. For the moment, let's go ahead and comment out our call to insert
    one.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不必依赖MongoDB来创建我们的ObjectIds。在MongoDB库中，他们实际上给了我们一个可以随时运行的函数来创建一个ObjectId。暂时，让我们继续注释掉我们插入的调用。
- en: At the very top of the file, we're going to change our import statement to load
    in something new off of MongoDB, and we're going to do this using an ES6 feature
    known as object destructuring. Let's take a quick second to talk about that before
    we actually go ahead and use it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的顶部，我们将改变我们的导入语句，加载MongoDB的新内容，并且我们将使用ES6的对象解构来实现这一点。在我们实际使用它之前，让我们花一点时间来谈谈它。
- en: Using object destructuring ES6
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象解构ES6
- en: 'Object destructuring lets you pull out properties from an object in order to
    create variables. This means that if we have an object called `user` and it''s
    set equal to an object with a `name` property set to `andrew` and an age property
    set to `25`, as shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对象解构允许你从对象中提取属性以创建变量。这意味着如果我们有一个名为`user`的对象，并且它等于一个具有`name`属性设置为`andrew`和一个年龄属性设置为`25`的对象，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can easily pull out one of these into a variable. Let''s say, for example,
    we want to grab name and create a `name` variable. To do that using object destructuring
    in ES6, we''re going to make a variable and then we''re going to wrap it inside
    of curly braces. We''re going to provide the name we want to pull out; this is
    also going to be the variable name. Then, we''re going to set it equal to whatever
    object we want to destructure. In this case, that is the `user` object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地将其中一个提取到一个变量中。比如说，我们想要获取名字并创建一个`name`变量。要在ES6中使用对象解构，我们将创建一个变量，然后将其包裹在花括号中。我们将提供我们想要提取的名字；这也将是变量名。然后，我们将把它设置为我们想要解构的对象。在这种情况下，那就是`user`对象：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have successfully destructured the `user` object, pulling off the `name`
    property, creating a new `name` variable, and setting it equal to whatever the
    value is. This means I can use the `console.log` statement to print `name` to
    the screen:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功解构了`user`对象，取出了`name`属性，创建了一个新的`name`变量，并将其设置为任何值。这意味着我可以使用`console.log`语句将`name`打印到屏幕上：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I''m going to rerun the script and we get `andrew`, which is exactly what you''d
    expect because that is the value of the `name` property:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我将重新运行脚本，我们得到`andrew`，这正是你所期望的，因为这是`name`属性的值：
- en: '![](img/724333b0-a6d8-4e53-b09d-2266f7b30fdc.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/724333b0-a6d8-4e53-b09d-2266f7b30fdc.png)'
- en: ES6 destructuring is a fantastic way to make new variables from an object's
    properties. I'm going to go ahead and delete this example, and at the top of the
    code, we're going to change our `require` statement so that it uses destructuring.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ES6解构是从对象的属性中创建新变量的一种绝妙方式。我将继续删除这个例子，并且在代码顶部，我们将改变我们的`require`语句，以便使用解构。
- en: Before we add anything new, let's go ahead and take the MongoClient statement
    and switch it to destructuring; then, we'll worry about grabbing that new thing
    that's going to let us make ObjectIds. I'm going to copy and paste the line and
    comment out the old one so we have it for reference.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何新内容之前，让我们继续并将MongoClient语句切换到解构；然后，我们将担心抓取那个新东西，让我们能够创建ObjectIds。我将复制并粘贴该行，并注释掉旧的，这样我们就可以参考它。
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What we're going to do is remove our `.MongoClient` call after `require`. There's
    no need to pull off that attribute because we're going to be using destructuring
    instead. That means over here we can use destructuring, which requires us to add
    our curly braces, and we can pull off any property from the MongoDB library.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是在`require`之后删除我们的`.MongoClient`调用。没有必要去掉那个属性，因为我们将使用解构代替。这意味着在这里我们可以使用解构，这需要我们添加花括号，并且我们可以从MongoDB库中取出任何属性。
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, the only property we had was `MongoClient`. This creates a variable
    called `MongoClient`, setting it equal to the `MongoClient` property of `require('mongodb')`,
    which is exactly what we did in the previous `require` statement.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们唯一拥有的属性是`MongoClient`。这创建了一个名为`MongoClient`的变量，将其设置为`require('mongodb')`的`MongoClient`属性，这正是我们在之前的`require`语句中所做的。
- en: Creating a new instance of objectID
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建objectID的新实例
- en: Now that we have some destructuring in place, we can easily pull more things
    off of MongoDB. We can add a comma and specify something else we want to pull
    off. In this case, we're going to pull off uppercase, `ObjectID`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一些解构，我们可以很容易地从MongoDB中取出更多的东西。我们可以添加一个逗号并指定我们想要取出的其他东西。在这种情况下，我们将取出大写的`ObjectID`。
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This `ObjectID` constructor function lets us make new ObjectIds on the fly.
    We can do anything we like with them. Even if we''re not using MongoDB as our
    database, there is some value in creating and using ObjectIds to uniquely identify
    things. Next, we can make a new ObjectId by first creating a variable. I''ll call
    it `obj`, and we''ll set it equal to `new ObjectID`, calling it as a function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ObjectID`构造函数让我们可以随时创建新的ObjectIds。我们可以随心所欲地使用它们。即使我们不使用MongoDB作为我们的数据库，创建和使用ObjectIds来唯一标识事物也是有价值的。接下来，我们可以通过首先创建一个变量来创建一个新的ObjectId。我会称它为`obj`，并将其设置为`new
    ObjectID`，将其作为一个函数调用：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using the `new` keyword, we can create a new instance of `ObjectID`. Next up,
    we can go ahead and log that to the screen using `console.log(obj)`. This is a
    regular ObjectId:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new`关键字，我们可以创建`ObjectID`的一个新实例。接下来，我们可以使用`console.log(obj)`将其记录到屏幕上。这是一个普通的ObjectId：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we rerun the file over from the Terminal, we get exactly what you''d expect:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从终端重新运行文件，我们会得到你期望的结果：
- en: '![](img/f429516c-25b3-4fae-8689-052b7c4c1ceb.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f429516c-25b3-4fae-8689-052b7c4c1ceb.png)'
- en: 'We get an ObjectId-looking thing. If I rerun it again, we get a new one; they
    are both unique:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个看起来像ObjectId的东西。如果我再次运行它，我们会得到一个新的；它们都是唯一的：
- en: '![](img/b2b1feb5-0446-44b9-b276-e57ae9a9279e.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2b1feb5-0446-44b9-b276-e57ae9a9279e.png)'
- en: 'Using this technique, we can incorporate ObjectIds anywhere we like. We could
    even generate our own, setting them as the `_id` property for our documents, although
    I find it much easier to let MongoDB handle that heavy lifting for us. I''m going
    to go ahead and remove the following two lines since we won''t actually be using
    this code in the script:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以在任何地方都使用ObjectIds。我们甚至可以生成我们自己的ObjectIds，将它们设置为我们文档的`_id`属性，尽管我发现让MongoDB为我们处理这些繁重的工作要容易得多。我将继续删除以下两行，因为我们实际上不会在脚本中使用这段代码：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have learned a bit about ObjectIds, what they are, and why they're useful.
    In the following sections, we're going to be taking a look at other ways we can
    work with MongoDB. We'll learn how to read, remove, and update our documents.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了一些关于ObjectIds的知识，它们是什么，以及它们为什么有用。在接下来的章节中，我们将看看我们可以如何与MongoDB一起工作的其他方式。我们将学习如何读取、删除和更新我们的文档。
- en: Fetching data
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据
- en: Now that you know how to insert data into your database, let's go ahead and
    talk about how we can fetch data out of it. We're going to be using this technique
    in the Todo API. People are going to want to populate a list of all the Todo items
    they need, and they might want to fetch the details about an individual Todo item.
    All of this is going to require that we can query the MongoDB database.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何向数据库插入数据了，让我们继续讨论如何从中获取数据。我们将在Todo API中使用这种技术。人们会想要填充一个他们需要的所有Todo项目的列表，并且他们可能想要获取有关单个Todo项目的详细信息。所有这些都需要我们能够查询MongoDB数据库。
- en: Fetching todos in Robomongo file
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Robomongo文件中获取todos
- en: 'Now, we''re going to create a new file based off of `mongodb-connect`. In this
    new file, instead of inserting records, we''ll fetch records from the database.
    I''m going to create a duplicate, calling this new file `mongodb-find`, because
    `find` is the method we''re going to use to query that database. Next, we can
    go ahead and remove all of the commented-out code that currently inserts records.
    Let''s get started by trying to fetch all of the Todos out of our Todos collection.
    Now, if I head over to Robomongo and open up the `Todos` collection, we have just
    one record:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将基于`mongodb-connect`创建一个新文件。在这个新文件中，我们将从数据库中获取记录，而不是插入记录。我将创建一个副本，将这个新文件称为`mongodb-find`，因为`find`是我们将用来查询数据库的方法。接下来，我们可以开始删除当前插入记录的所有注释掉的代码。让我们开始尝试从我们的Todos集合中获取所有的Todos。现在，如果我转到Robomongo并打开`Todos`集合，我们只有一条记录：
- en: '![](img/c2f51586-1c3b-4789-bdef-5628eaa6ce3a.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2f51586-1c3b-4789-bdef-5628eaa6ce3a.png)'
- en: 'In order to make this querying a little more interesting, we''re going to go
    ahead and add a second one. Right in the Robomongo window, I can click Insert
    Document. Robomongo can delete, insert, update, and read all of your documents,
    and this makes it a fantastic tool for debugging. We can add a new document on
    the fly, with a `text` property equal to `Walk the dog`, and we can also tack
    on a `completed` value. I''m going to set `completed` equal to `false`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个查询更有趣一些，我们将继续添加第二个。在Robomongo窗口中，我可以点击插入文档。Robomongo可以删除、插入、更新和读取所有的文档，这使它成为一个很棒的调试工具。我们可以随时添加一个新的文档，其中`text`属性等于`Walk
    the dog`，我们还可以附加一个`completed`值。我将`completed`设置为`false`：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now by default, we''re not going to provide an `_id` prop. This is going to
    let MongoDB automatically generate that ObjectId, and right here we have our two
    Todos:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，默认情况下，我们不会提供`_id`属性。这将让MongoDB自动生成那个ObjectId，而在这里我们有我们的两个Todos：
- en: '![](img/98401436-3619-4b3e-ade6-1924c766d1fe.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98401436-3619-4b3e-ade6-1924c766d1fe.png)'
- en: With this in place, let's go ahead and run our first query inside of Atom.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们继续在Atom中运行我们的第一个查询。
- en: The find method
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: find方法
- en: 'In Atom, what we''re going to do is access the collection, just like we did
    inside of the `mongodb-connect` file using `db.collection`, passing in the collection
    name as the string. This collection is going to be the `Todos` collection. Now,
    we''re going to go ahead and use a method available on collections called `find`.
    By default, we can call `find` with no arguments:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，我们要做的是访问集合，就像我们在`mongodb-connect`文件中使用`db.collection`一样，将集合名称作为字符串传递。这个集合将是`Todos`集合。现在，我们将继续使用集合上可用的一个叫做`find`的方法。默认情况下，我们可以不带参数地调用`find`：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This means we''re not providing a query, so we''re not saying we want to fetch
    all `Todos` that are completed or not completed. We''re just saying we want to
    fetch all `Todos`: everything, regardless of its values. Now, calling find is
    only the first step. `find` returns a MongoDB cursor, and this cursor is not the
    actual documents themselves. There could be a couple of thousand, and that would
    be really inefficient. It''s actually a pointer to those documents, and the cursor
    has a ton of methods. We can use those methods to get our documents.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们没有提供查询，所以我们没有说我们想要获取所有已完成或未完成的`Todos`。我们只是说我们想获取所有`Todos`：无论其值如何，一切。现在，调用find只是第一步。`find`返回一个MongoDB游标，而这个游标并不是实际的文档本身。可能有几千个，那将非常低效。它实际上是指向这些文档的指针，并且游标有大量的方法。我们可以使用这些方法来获取我们的文档。
- en: One of the most common cursor methods we're going to be using is `.toArray.`
    It does exactly what you think it does. Instead of having a cursor, we have an
    array of the documents. This means we have an array of objects. They have ID properties,
    text properties, and completed properties. This `toArray` method gets us exactly
    what we want back, which is the documents. `toArray` returns a promise. This means
    we can tack on a `then` call, we can add our callback, and when things go right,
    we can do something like print those documents to the screen.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的最常见的游标方法之一是`.toArray.`它确切地做了你认为它会做的事情。我们不再有游标，而是有一个文档的数组。这意味着我们有一个对象的数组。它们有ID属性，文本属性和完成属性。这个`toArray`方法恰好得到了我们想要的东西，也就是文档。`toArray`返回一个promise。这意味着我们可以添加一个`then`调用，我们可以添加我们的回调，当一切顺利时，我们可以做一些像将这些文档打印到屏幕上的事情。
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''re going to get the documents as the first and only argument here, and
    we can also add an error handler. We''ll get passed an error argument, and we
    can simply print something to the screen like `console.log(Unable to fetch todos)`;
    as the second argument, we''ll pass in the `err` object:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到文档作为第一个和唯一的参数，我们还可以添加一个错误处理程序。我们将传递一个错误参数，我们可以简单地打印一些像`console.log(无法获取todos)`的东西到屏幕上；作为第二个参数，我们将传递`err`对象：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, for the success case, what we're going to do is print the documents to
    the screen. I'm going to go ahead and use `console.log` to print a little message,
    `Todos`, and then I'll call `console.log` again. This time, we'll be using the
    `JSON.stringify` technique. I'll be passing in the documents, `undefined` for
    our filter function and `2` for our spacing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于成功的情况，我们要做的是将文档打印到屏幕上。我将继续使用`console.log`来打印一条小消息，`Todos`，然后我将再次调用`console.log`。这次，我们将使用`JSON.stringify`技术。我将传递文档，`undefined`作为我们的过滤函数和`2`作为我们的间距。
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We now have a script that is capable of fetching the documents, converting
    them into an array, and printing them to the screen. Now, for the time being,
    I''m going to comment out the `db.close` method. Currently, that would interfere
    with our previous bit of code. Our final code would look as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个能够获取文档，将其转换为数组并将其打印到屏幕上的脚本。现在，暂时地，我将注释掉`db.close`方法。目前，那会干扰我们之前的代码。我们的最终代码将如下所示：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Save the file and run it from the Terminal. Inside of the Terminal, I''m going
    to go ahead and run our script. Obviously, since we connected to the database
    with Robomongo, it is running somewhere; it''s running in this other tab. In the
    other tab, I can run the script. We''re going to run it through `node`; it''s
    in the `playground` folder, and the file itself is called `mongodb-find.js`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并从终端运行它。在终端中，我将继续运行我们的脚本。显然，由于我们用Robomongo连接到了数据库，它正在某个地方运行；它正在另一个标签页中运行。在另一个标签页中，我可以运行脚本。我们将通过`node`运行它；它在`playground`文件夹中，文件本身叫做`mongodb-find.js`：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When I execute this file, we''re going to get our results:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我执行这个文件时，我们将得到我们的结果：
- en: '![](img/3c47a41b-466f-4f2a-8554-d765a66781ee.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c47a41b-466f-4f2a-8554-d765a66781ee.png)'
- en: We have our `Todos` array with our two documents. We have our `_id`, our `text`
    properties, and our `completed` Boolean values. We now have a way to query our
    data right inside of Node.js. Now, this is a very basic query. We fetch everything
    in the `Todos` array, regardless of whether or not it has certain values.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的`Todos`数组和我们的两个文档。我们有我们的`_id`，我们的`text`属性和我们的`completed`布尔值。现在，我们有一种在Node.js中查询我们的数据的方法。现在，这是一个非常基本的查询。我们获取`Todos`数组中的所有内容，无论它是否具有某些值。
- en: Writing a query to fetch certain values
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个查询以获取特定值
- en: 'In order to query based on certain values, let''s go ahead and switch up our
    `Todos`. Currently, both of them have a `completed` value equal to `false`. Let''s
    go ahead and change the `Walk the dog` completed value to `true` so we can try
    to just query items that aren''t completed. Over in Robomongo, I''m going to right-click
    the document and click Edit Document, and there we can edit the values. I''m going
    to change the `completed` value from `false` to `true`, and then I can save the
    record:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了基于某些值进行查询，让我们继续切换我们的`Todos`。目前，它们两个的`completed`值都等于`false`。让我们继续将`Walk the
    dog`的完成值更改为`true`，这样我们就可以尝试只查询未完成的项目。在Robomongo中，我将右键单击文档，然后单击编辑文档，然后我们可以编辑值。我将把`completed`值从`false`更改为`true`，然后我可以保存记录：
- en: '![](img/b3502cf4-287e-423b-bd7e-91e512b9dc29.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3502cf4-287e-423b-bd7e-91e512b9dc29.png)'
- en: 'Inside of the Terminal, I can rerun the script to prove that it has changed.
    I''m going to shut down the script by running *control* + *C*, and then I can
    rerun it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端内，我可以重新运行脚本来证明它已经改变。我将通过运行*control* + *C*关闭脚本，然后可以重新运行它：
- en: '![](img/b94e60a9-afce-4a1a-b615-bc1a35291560.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b94e60a9-afce-4a1a-b615-bc1a35291560.png)'
- en: As shown in the preceding screenshot, we have our two `Todos`, one with a `completed`
    value of `false` and one with a `completed` value of `true`. By default, a Todo
    app is probably only going to show you the `Todos` collection you haven't completed.
    The ones you have completed, like `Walk the dog`, will probably be hidden, although
    they could be accessible if you clicked a button like Show all Todos. Let's go
    ahead and write a query that just fetches the `Todos` collection that have a `completed`
    status set to `false`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们有两个`Todos`，一个`completed`值为`false`，另一个`completed`值为`true`。默认情况下，待办事项应用程序可能只会显示您尚未完成的`Todos`集合。您已经完成的待办事项，比如`Walk
    the dog`，可能会被隐藏，尽管如果您点击了一个按钮，比如显示所有待办事项，它们可能是可访问的。让我们继续编写一个查询，只获取`completed`状态设置为`false`的`Todos`集合。
- en: Writing a query to fetch completed todos
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个查询以获取已完成的待办事项
- en: 'To get this done, inside of Atom, we''re going to make a change to how we call
    find. Instead of passing in `0` arguments, we''re going to pass in `1`. This is
    what''s known as our query. We can start specifying how we want to query the `Todos`
    collection. For example, maybe we want to query only `Todos` that have a `completed`
    value equal to `false`. All we have to do to query by value is set up the key-value
    pairs, as shown here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个目标，在Atom中，我们将更改调用find的方式。我们不再传递`0`个参数，而是传递`1`个参数。这就是我们所谓的查询。我们可以开始指定我们想要查询`Todos`集合的方式。例如，也许我们只想查询`completed`值等于`false`的`Todos`。我们只需设置键值对来按值查询，如下所示：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If I rerun our script over in the Terminal after shutting it down, we get just
    our one Todo item:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在终端中关闭脚本后重新运行我们的脚本，我们只会得到我们的一个待办事项：
- en: '![](img/2c632bdf-9012-4b71-acf5-fdccbb9420ad.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c632bdf-9012-4b71-acf5-fdccbb9420ad.png)'
- en: We have our item with the `text` equal to `Something to do`. It has a `completed`
    status of `false`, so it shows up. Our other Todo with a `text` property of `Walk
    the dog` is not showing up because that one has been completed. It doesn't match
    the query, so MongoDB does not return it. This is going to come in handy as we
    start querying our documents based off of completed values, text properties, or
    IDs. Let's take a quick moment to look at how we can query one of our `Todos`
    by ID.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目有一个`text`等于`Something to do`。它的`completed`状态为`false`，所以它显示出来。我们的另一个待办事项，`Walk
    the dog`的`text`属性没有显示出来，因为它已经完成。它不匹配查询，所以MongoDB不会返回它。当我们开始根据已完成的值、文本属性或ID查询我们的文档时，这将会很有用。让我们花点时间来看看我们如何可以通过ID查询我们的`Todos`中的一个。
- en: Qureying todos by id
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按ID查询待办事项
- en: The first thing we need to do is remove everything from our query object; we
    no longer want to query by the `completed` value. Instead, we're going to query
    by the `_id` property.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是从我们的查询对象中删除所有内容；我们不再想要按`completed`值查询。相反，我们将按`_id`属性查询。
- en: 'Now, in order to illustrate this, I''m going to grab the ID of the Todo with
    the `completed` value of `false` from the Terminal. I''m going to copy it using
    *command* + *C*. If you''re on Windows or Linux, you might need to right-click
    after highlighting the ID, and click Copy text. Now that I have the text inside
    of the clipboard, I can head over to the query itself. Now, if we try to add the
    ID like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了说明这一点，我将从终端获取`completed`值为`false`的待办事项的ID。我将使用*command* + *C*进行复制。如果您使用的是Windows或Linux，您可能需要在突出显示ID后右键单击，并单击复制文本。现在我已经将文本放入剪贴板，我可以转到查询本身。现在，如果我们尝试像这样添加ID：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is not going to work as expected because what we have inside of the ID property
    is not a string. It's an ObjectId, which means that we need to use the `ObjectID`
    constructor function that we imported previously in order to create an ObjectId
    for the query.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会按预期工作，因为我们在ID属性中拥有的不是一个字符串。它是一个ObjectId，这意味着我们需要使用之前导入的`ObjectID`构造函数来为查询创建一个ObjectId。
- en: To illustrate how that's going to happen, I'm going to go ahead and indent our
    object. This is going to make it a little easier to read and edit.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这将如何发生，我将继续缩进我们的对象。这将使它更容易阅读和编辑。
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, I''m going to remove the string and call `new ObjectID`. The `new ObjectID`
    constructor does take an argument: the ID, in this case, we have it stored as
    a string. This is going to work as expected.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我要删除字符串并调用`new ObjectID`。`new ObjectID`构造函数确实需要一个参数：ID，在这种情况下，我们将其存储为字符串。这将按预期工作。
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'What we''re doing here is we''re querying the Todos collection, looking for
    any records that have an `_id` property equal to the ID we have. Now, I can go
    ahead and save this file, give things a refresh by running the script again, and
    we''ll get the exact same Todo:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是查询`Todos`集合，寻找任何具有与我们拥有的ID相等的`_id`属性的记录。现在，我可以保存这个文件，通过重新运行脚本来刷新一下，我们将得到完全相同的待办事项：
- en: '![](img/c40589de-95cc-48bc-bcfd-25d7c72ee229.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c40589de-95cc-48bc-bcfd-25d7c72ee229.png)'
- en: I can go ahead and change it for the `Walk the dog` Todo by copying the string
    value, pasting that inside of the ObjectID constructor function, and rerunning
    the script. When I do this, I get the `Walk the dog` Todo returned because that
    was the ObjectId I queried.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以继续将其更改为`Walk the dog`的待办事项，通过复制字符串值，将其粘贴到ObjectID构造函数中，并重新运行脚本。当我这样做时，我得到了`Walk
    the dog`的待办事项，因为那是我查询的ObjectId。
- en: Now, querying in this fashion is one of the ways we'll be using find, but there
    are other methods other than `toArray` that are available on our cursors. We can
    explore other ones by heading over to the docs for the native driver. Inside of
    Chrome, have the MongoDB docs pulled up—these are the docs I showed you how to
    access in the previous chapter—and on the left-hand side, we have the Cursor section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以这种方式查询是我们将使用find的方式之一，但除了`toArray`之外，我们的光标上还有其他方法可用。我们可以通过转到原生驱动程序的文档来探索其他方法。在Chrome中，打开MongoDB文档-这些是我在上一章中向您展示如何访问的文档-在左侧，我们有光标部分。
- en: 'If you click that, we can view a list of all the methods available to us on
    that cursor:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击，我们可以查看光标上可用的所有方法的列表：
- en: '![](img/fd2e42a1-88bf-4fc0-a885-e024cf5e2cc4.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd2e42a1-88bf-4fc0-a885-e024cf5e2cc4.png)'
- en: This is what comes back from find. At the very bottom of the list, we have our
    `toArray` method. The one that we're going to look at right now is called count.
    From previous, you can go ahead and click count; it's going to bring you to the
    documentation; the documentation for the native driver is actually really good.
    There is a complete list of all the arguments that you can provide. Some of them
    are optional, some of them are required, and there is usually a real-world example.
    Next, we can figure out exactly how to use `count`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从find返回的内容。在列表的最底部，我们有我们的`toArray`方法。我们现在要看的是称为count的方法。从以前的内容，您可以继续并点击count；它将带您到文档；原生驱动程序的文档实际上非常好。这里有您可以提供的所有参数的完整列表。其中一些是可选的，一些是必需的，通常有一个真实世界的例子。接下来，我们可以确切地找出如何使用`count`。
- en: Implementing the count method
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现计数方法
- en: Now, we're going to go ahead and implement `count` over inside of Atom. What
    I'm going to do is take the current query, copy it to the clipboard, and then
    comment it out. I'm going to go ahead and replace our call to `toArray` with a
    call to `count`. Let's go ahead and remove the query that we pass in to find.
    What we're going to do here is count up all of the Todos in the `Todos` collection.
    Instead of having a call to `toArray`, we're going to have a call to count instead.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续在Atom中实现`count`。我要做的是将当前查询复制到剪贴板，然后将其注释掉。我将用一个调用`count`替换我们对`toArray`的调用。让我们继续删除我们传递给find的查询。我们要做的是计算`Todos`集合中的所有Todos。我们将不再调用`toArray`，而是调用count。
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you saw inside of the examples for count, they call count like this: calling
    count, passing in a callback function that gets called with an error, or the actual
    count. You can also have a promise as a way to access that data, which is exactly
    what we did with `toArray`. In our case, instead of passing a callback function
    like this, we''re going to use the promise instead. We already have the promise
    set up. All we need to do to fix this is change `docs` to `count`, and then we''re
    going to remove the `console.log` caller where we print the docs to the screen.
    Right after we print Todos, we''re going to print `Todos count`, with a colon
    passing in the value.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在count的示例中看到的那样，他们这样调用count：调用count，传递一个回调函数，该函数在出现错误或实际计数时调用。您还可以将promise作为访问数据的一种方式，这正是我们使用`toArray`的方式。在我们的情况下，我们将使用promise而不是传递回调函数。我们已经设置好了promise。我们需要做的就是将`docs`更改为`count`，然后我们将删除打印docs到屏幕的`console.log`调用者。在我们打印Todos之后，我们将打印`Todos
    count`，并传入值。
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is not a template string, but I am going to go ahead and swap it out with
    one, replacing the quotes with [PRE44]
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个模板字符串，但我将继续并用一个替换它，用[PRE44]替换引号
- en: db.collection('Todos').find({}).count().then((count) => {
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: db.collection('Todos').find({}).count().then((count) => {
- en: 'console.log(`Todos count: ${count}`);'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'console.log(`Todos count: ${count}`);'
- en: '}, (err) => {'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '}, (err) => {'
- en: console.log('Unable to fetch todos', err);
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: console.log('Unable to fetch todos', err);
- en: '});'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'db.collection(''Users'').find({name: ''Andrew''})'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'db.collection(''Users'').find({name: ''Andrew''})'
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'db.collection(''Users'').find({name: ''Andrew''}).toArray().then((docs) =>
    {'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'db.collection(''Users'').find({name: ''Andrew''}).toArray().then((docs) =>
    {'
- en: console.log(JSON.stringify(docs, undefined, 2));
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(JSON.stringify(docs, undefined, 2));
- en: '});'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: node_modules/
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: node_modules/
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: git add .
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: git add .
- en: git commit -m 'Init commit'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: git commit -m 'Init commit'
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: git remote add origin https://github.com/garygreig/node-course-2-todo-api.git
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: git remote add origin https://github.com/garygreig/node-course-2-todo-api.git
- en: git push -u origin master
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: git push -u origin master
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '{'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'text: ''Eat lunch'','
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'text: ''Eat lunch'','
- en: 'completed: false'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'completed: false'
- en: '}'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: //deleteMany
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: //deleteMany
- en: 'db.collection(''Todos'').deleteMany({text: ''Eat lunch''});'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'db.collection(''Todos'').deleteMany({text: ''Eat lunch''});'
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: //deleteMany
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: //deleteMany
- en: 'db.collection(''Todos'').deleteMany({text: ''Eat lunch''}).then((result) =>
    {'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'db.collection(''Todos'').deleteMany({text: ''Eat lunch''}).then((result) =>
    {'
- en: console.log(result);
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(result);
- en: '});'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: node playground/mongodb-delete.js
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: node playground/mongodb-delete.js
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: //deleteOne
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: //deleteOne
- en: 'db.collection(''Todos'').deleteOne({text: ''Eat lunch''}).then((result) =>
    {'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'db.collection(''Todos'').deleteOne({text: ''Eat lunch''}).then((result) =>
    {'
- en: console.log(result);
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(result);
- en: '});'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: //findOneAndDelete
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: //findOneAndDelete
- en: 'db.collection(''Todos'').findOneAndDelete({completed: false}).then((result)
    => {'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'db.collection(''Todos'').findOneAndDelete({completed: false}).then((result)
    => {'
- en: console.log(result);
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(result);
- en: '});'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'db.collection(''Users'').deleteMany({name: ''Andrew''});'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'db.collection(''Users'').deleteMany({name: ''Andrew''});'
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'db.collection(''Users'').deleteMany({name: ''Andrew''});'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'db.collection(''Users'').deleteMany({name: ''Andrew''});'
- en: db.collection('Users').findOneAndDelete({
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: db.collection('Users').findOneAndDelete({
- en: '_id: new ObjectID("5a86978929ed740ca87e5c31")'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '_id: new ObjectID("5a86978929ed740ca87e5c31")'
- en: '})'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '})'
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'db.collection(''Users'').deleteMany({name: ''Andrew''});'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 'db.collection(''Users'').deleteMany({name: ''Andrew''});'
- en: db.collection('Users').findOneAndDelete({
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: db.collection('Users').findOneAndDelete({
- en: '_id: new ObjectID("5a86978929ed740ca87e5c31")'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '_id: new ObjectID("5a86978929ed740ca87e5c31")'
- en: '}).then((results) => {'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '}).then((results) => {'
- en: console.log(JSON.stringify(results, undefined, 2));
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(JSON.stringify(results, undefined, 2));
- en: '});'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: git commit -m 'Add delete script'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: git commit -m 'Add delete script'
- en: '[PRE60]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: db.collection('Todos').findOneAndUpdate({
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: db.collection('Todos').findOneAndUpdate({
- en: '_id: new ObjectID(''5a86c378baa6685dd161da6e'')'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '_id: new ObjectID(''5a86c378baa6685dd161da6e'')'
- en: '}, {'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: '$set: {'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '$set: {'
- en: completed:true
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: completed:true
- en: '}'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}, {'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: 'returnOriginal: false'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'returnOriginal: false'
- en: '}).then((result) => {'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '}).then((result) => {'
- en: console.log(result);
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(result);
- en: '});'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: node playground/mongodb-update.js
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: node playground/mongodb-update.js
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: db.collection('Todos').findOneAndUpdate({
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: db.collection('Todos').findOneAndUpdate({
- en: '_id: new ObjectID(''57bc4b15b3b6a3801d8c47a2'')'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '_id: new ObjectID(''57bc4b15b3b6a3801d8c47a2'')'
- en: '}, {'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: '$set: {'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '$set: {'
- en: completed:true
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: completed:true
- en: '}'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}, {'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: 'returnOriginal: false'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 'returnOriginal: false'
- en: '}).then((result) => {'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '}).then((result) => {'
- en: console.log(result);
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(result);
- en: '});'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: db.collection('Users').findOneAndUpdate({
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: db.collection('Users').findOneAndUpdate({
- en: '_id: new ObjectID(''57abbcf4fd13a094e481cf2c'')'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '_id: new ObjectID(''57abbcf4fd13a094e481cf2c'')'
- en: '}, {'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: '$set: {'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '$set: {'
- en: 'name: ''Andrew'''
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: ''Andrew'''
- en: '},'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '$inc: {'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '$inc: {'
- en: 'age: 1'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'age: 1'
- en: '}'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}, {'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: 'returnOriginal: false'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'returnOriginal: false'
- en: '}).then((result) => {'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '}).then((result) => {'
- en: console.log(result);
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(result);
- en: '});'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: git add .
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: git add .
- en: git commit -m 'Add update script'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: git commit -m 'Add update script'
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: git push
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: git push
- en: '```'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: With updating in place, we now have all of the basic CRUD (Creating, Reading,
    Updating, and Deleting) operations down. Up next, we're going to talk about something
    called Mongoose, which we'll be using for the Todo API.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 更新完成后，我们现在已经掌握了所有基本的CRUD（创建、读取、更新和删除）操作。接下来，我们将讨论一个叫做Mongoose的东西，我们将在Todo API中使用它。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started with connecting to MongoDB and writing data. We
    then went ahead to understand the `id` property in the context of MongoDB. After
    learning more about fetching data, we explored different methods to delete data
    in the documents.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从连接到MongoDB并写入数据开始。然后，我们继续了解了在MongoDB上下文中的`id`属性。在学习更多关于获取数据之后，我们探索了在文档中删除数据的不同方法。
- en: In the next chapter, we will continue to play more with Mongoose, MongoDB, and
    REST APIs.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续与Mongoose、MongoDB和REST API进行更多的操作。
