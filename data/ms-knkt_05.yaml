- en: Chapter 5. Durandal – the Knockout Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. Durandal – Knockout 框架
- en: In the previous chapter, we looked at how to use RequireJS and SammyJS with
    Knockout, to add more standard functionality to our frontend stack with module
    definitions and client-side routing. Both of these concepts have become very common
    in the JavaScript world; you might even consider them as a standard for modern
    web applications. Knockout is a library and not a framework, in that it fills
    a specific role—data-binding—instead of trying to be the entire development framework
    for the frontend. This leaves a lot of decisions to be made if you want to create
    a modern JavaScript client, which can be burdensome, time-consuming, and, if your
    team is divided, contentious. Durandal is a framework that attempts to make many
    of these decisions while still keeping Knockout's MVVM philosophy in mind.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何使用 RequireJS 和 SammyJS 与 Knockout 结合，通过模块定义和客户端路由来为我们的前端堆栈添加更多标准功能。这两个概念在
    JavaScript 世界中已经变得非常普遍；你甚至可以将它们视为现代网络应用的标准。Knockout 是一个库而不是一个框架，因为它填补了特定的角色——数据绑定——而不是试图成为前端开发框架的全部。如果你想要创建一个现代的
    JavaScript 客户端，这会留下很多决策需要做出，可能会变得繁重、耗时，如果你的团队意见分歧，可能会产生争议。Durandal 是一个框架，它试图在保持
    Knockout 的 MVVM 哲学的同时，做出许多这些决策。
- en: 'Durandal was created by Blue Spire, whose principal developer, Rob Eisenberg,
    also created the popular WPF framework Caliburn.Micro, another MVVM framework.
    Over the next two chapters, we will be looking at how Durandal can help us build
    web applications easily while leveraging all of our experience and custom code
    from Knockout. This chapter is going to cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal 是由 Blue Spire 创建的，其主要开发者 Rob Eisenberg 还创建了流行的 WPF 框架 Caliburn.Micro，另一个
    MVVM 框架。在接下来的两章中，我们将探讨 Durandal 如何帮助我们轻松地构建网络应用，同时利用我们从 Knockout 获得的所有经验和自定义代码。本章将涵盖以下内容：
- en: Overview of the Durandal framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Durandal 框架概述
- en: The composition system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合系统
- en: The router
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器
- en: Modal dialogs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模态对话框
- en: The application's life cycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的生命周期
- en: Widgets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件
- en: Once again, we will be using the `Contacts` application with the chapter's examples.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将使用本章的示例使用 `Contacts` 应用程序。
- en: An overview of the Durandal framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Durandal 框架概述
- en: Durandal is built on top of Knockout, jQuery, and RequireJS. Durandal's core
    is a collection of AMD modules, which provide composition, events, and activation
    features, as well as some utility functions. In addition to the core modules,
    Durandal also provides several plugins that can optionally be activated, or added
    to with community or personal plugins. The plugins include the router (a basic
    requirement for every SPA framework), dialogs, and widgets.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal 是建立在 Knockout、jQuery 和 RequireJS 之上的。Durandal 的核心是一组 AMD 模块，它们提供了组合、事件和激活功能，以及一些实用函数。除了核心模块之外，Durandal
    还提供了一些可选激活的插件，或者可以通过社区或个人插件添加。这些插件包括路由器（每个 SPA 框架的基本要求）、对话框和小部件。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The documentation for Durandal can be found at [http://durandaljs.com/docs.html](http://durandaljs.com/docs.html).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal 的文档可以在 [http://durandaljs.com/docs.html](http://durandaljs.com/docs.html)
    找到。
- en: Promises
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promises
- en: To bring all of this together, Durandal's internal and external communication
    is handled through **promises**. If you aren't familiar with JavaScript promises—sometimes
    called *thenables* because they provide a `then` method—you're missing out. To
    explain briefly, promises change the way asynchronous actions are handled by replacing
    a callback with a return object that represents the asynchronous work. It allows
    asynchronous tasks to be chained, and does error handling in a simple, easy-to-debug
    manner. I won't be covering how promises work here, but it is going to be relevant.
    You should read up on them if you haven't already done so.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些内容整合在一起，Durandal 的内部和外部通信是通过 **promises** 来处理的。如果你不熟悉 JavaScript 的 promises（有时被称为
    *thenables*，因为它们提供了一个 `then` 方法），那么你错过了一些东西。简要来说，promises 通过用一个表示异步工作的返回对象替换回调来改变异步操作的处理方式。它允许异步任务以简单、易于调试的方式串联，并进行错误处理。在这里我不会介绍
    promises 的工作原理，但它将会是相关的。如果你还没有阅读过，你应该去了解一下。
- en: 'If you are familiar with promises, you may already know that jQuery''s promise
    implementation does not match the A+ specification ([https://promisesaplus.com](https://promisesaplus.com)),
    which most other promise libraries conform to. To minimize third-party dependencies,
    Durandal uses jQuery''s promises by default, but their documentation provides
    a simple patch to allow the use of another promise implementation. This example,
    which uses Q (a very popular promise library), is taken from the Durandal documentation.
    Use it before the call to `app.start()` (we will learn more about this later):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉承诺，你可能已经知道jQuery的承诺实现并不符合A+规范([https://promisesaplus.com](https://promisesaplus.com))，这是大多数其他承诺库所遵循的。为了最小化第三方依赖，Durandal默认使用jQuery的承诺，但它们的文档提供了一个简单的补丁，允许使用另一个承诺实现。这个例子（使用Q，一个非常流行的承诺库）是从Durandal文档中摘录的。在使用`app.start()`之前使用它（我们稍后会了解更多关于这个）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you prefer another library, simply replace `Q` in the preceding code. I will
    be using Durandal's default promises in this chapter for simplicity, but I encourage
    you to use an A+ compliant implementation in real-world applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢另一个库，只需在前面代码中将`Q`替换即可。为了简单起见，我在本章中将使用Durandal的默认承诺，但我鼓励你在实际应用中使用符合A+规范的实现。
- en: Getting started
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用
- en: 'While Durandal''s only real requirement on your filesystem is that all its
    core modules should be in the same folder and all its plugins should be in their
    own folder, there are some conventions for the way things are organized, as shown
    in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Durandal 对你的文件系统只有一个真正的要求，即所有核心模块都应该在同一个文件夹中，所有插件都应该在自己的文件夹中，但有一些关于组织方式的约定，如下面的截图所示：
- en: '![Getting started](img/00009.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用](img/00009.jpeg)'
- en: 'This should be familiar, as it isn''t too different from what we have been
    using. The `app` directory contains our code, the `lib` directory contains third-party
    code, and the `content` directory contains our CSS and other visual assets. Durandal''s
    entire source, which contains some of its own CSS, its core modules, as well as
    the standard plugins directory, is dropped into `lib`. Our `main.js` configuration
    looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很熟悉，因为它与我们一直在使用的没有太大区别。`app`目录包含我们的代码，`lib`目录包含第三方代码，`content`目录包含我们的CSS和其他视觉资产。Durandal的整个源代码，其中包含一些自己的CSS，核心模块以及标准插件目录，被放入`lib`中。我们的`main.js`配置看起来像这样：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There shouldn''t be anything surprising here, as we covered the configuration
    of RequireJS in the previous chapter. All of the paths, except `bootstrap`, are
    required by Durandal. After configuration, Durandal needs to be initialized; this
    is generally placed in `main.js`, just below `require.config`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不应该有什么令人惊讶的地方，因为我们已经在上一章中介绍了RequireJS的配置。除了`bootstrap`之外的所有路径都是Durandal所必需的。配置完成后，Durandal需要初始化；这通常放在`main.js`中，位于`require.config`下方：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `app` and `system` modules are Durandal objects. The `system.debug` call
    instructs Durandal to log all of the steps it takes to the console, which is useful
    for development. The `app.configurePlugins` call registers the plugins to be installed,
    though they are not run until `app.start` is called. The `app.start` call initializes
    all the Durandal modules and installs the registered plugins. As `app.start` is
    a promise-returning function, a `then` method is attached, which calls `app.setRoot`
    when it is finished. The `setRoot` method composes the specified module into the
    DOM as the root viewmodel of the application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`app`和`system`模块是Durandal对象。`system.debug`调用指示Durandal将所有步骤记录到控制台，这对于开发很有用。`app.configurePlugins`调用注册要安装的插件，尽管它们在调用`app.start`之前不会运行。`app.start`调用初始化所有Durandal模块并安装已注册的插件。由于`app.start`是一个返回承诺的函数，因此附加了一个`then`方法，它在完成时调用`app.setRoot`方法。`setRoot`方法将指定的模块组合到DOM中，作为应用程序的根视图模型。'
- en: 'The root of the application is placed inside a `div` element with the `applicationHost`
    ID, which is expected to be in the DOM already. As Durandal will take care of
    all the HTML rendering, the original DOM is pretty thin. It only requires the
    CSS that will be used, the `applicationHost` ID, and the `script` tag for RequireJS.
    This is the standard `index.html` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的根被放置在一个具有`applicationHost` ID的`div`元素中，它预期已经在DOM中。由于Durandal将负责所有的HTML渲染，原始DOM相当简单。它只需要使用的CSS，`applicationHost`
    ID，以及RequireJS的`script`标签。这是标准的`index.html`文件：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's it! Durandal has been started and everything after this point is going
    to be your application's code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！Durandal已经启动，从这一点开始之后的所有内容都将是你应用程序的代码。
- en: The composition system
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合系统
- en: In the previous chapter, we looked at Knockout's new components feature, which
    lets us construct view/viewmodel pairs by instantiating them from the DOM with
    custom elements (or bindings). Knockout released this feature after Durandal,
    so there is some overlap between the two. Durandal's composition is like a blend
    of the components and the template binding.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了Knockout的新组件功能，它允许我们通过从DOM中使用自定义元素（或绑定）实例化它们来构建视图/ViewModel对。Knockout在Durandal之后发布了这个功能，所以两者之间有一些重叠。Durandal的组合类似于组件和模板绑定的混合。
- en: Composition is primarily invoked in two ways, with `setRoot` to compose the
    `applicationHost` ID, and with the compose binding for data-bound values. Composition
    works by pairing a viewmodel with a view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 组合主要通过两种方式调用，使用`setRoot`来组合`applicationHost` ID，以及使用组合绑定来处理数据绑定值。组合通过将viewmodel与视图配对来工作。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Durandal's documentation refers to viewmodels as modules, which I think is a
    bit confusing. I will be referring to composable modules as viewmodels throughout
    this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal的文档将viewmodels称为模块，我认为这有点令人困惑。在本章中，我将把可组合模块称为viewmodels。
- en: When composition is given a viewmodel, it looks up the view, loads it with the
    RequireJS's text loader, binds it to the view, and finally, attaches it to the
    DOM.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当组合被赋予一个viewmodel时，它会查找视图，使用RequireJS的文本加载器加载它，将其绑定到视图上，最后将其附加到DOM中。
- en: '**Composing the application''s root**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合应用程序的根**'
- en: Let's look at the root composition of our shell viewmodel. Our preceding sample
    was setting the root to `shell/shell`. If our `app` directory has a `shell` folder,
    the `shell.js` module will be loaded by `setRoot` and composed. Composition uses
    Durandal's `viewLocator` module to find an HTML file, by replacing the file extension
    of the module; so for `shell.js`, it will look for `shell.html` and use it as
    the view.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看shell viewmodel的根组合。我们前面的示例是将根设置为`shell/shell`。如果我们的`app`目录中有一个`shell`文件夹，`shell.js`模块将被`setRoot`加载并组合。组合使用Durandal的`viewLocator`模块通过替换模块的文件扩展名来查找HTML文件；因此对于`shell.js`，它会查找`shell.html`并将其用作视图。
- en: 'You can see a very simple example of this in `cp5-shell`. The `shell` module
    is very simple, containing just a `title` property that we will bind to:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cp5-shell`中看到一个非常简单的例子。`shell`模块非常简单，只包含一个`title`属性，我们将将其绑定到：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Durandal expects views to be partial HTML documents. They should not contain
    an `HTML`, `HEAD`, or `BODY` element; they should contain only the HTML that will
    be used as the template for the DOM contents.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal期望视图是部分HTML文档。它们不应包含`HTML`、`HEAD`或`BODY`元素；它们应只包含用于DOM内容的模板的HTML。
- en: If you run the code, you will see that this HTML is rendered into the DOM, and
    the title is bound to the `shell` module's `title` property. The object returned
    by the `shell` module is used as the binding context for the shell's view.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码，你会看到这个HTML被渲染到DOM中，标题被绑定到`shell`模块的`title`属性上。`shell`模块返回的对象被用作shell视图的绑定上下文。
- en: The compose binding
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合绑定
- en: Generally, the root of the application does not change, and instead, serves
    as the layout or shell for the HTML. It displays content that is present on every
    page (such as a navigation bar), and hence it doesn't need to change. Composition
    can also be invoked with the compose binding, which takes a viewmodel as a binding
    value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序的根不会改变，而是作为HTML的布局或外壳。它显示每个页面上都存在的内容（如导航栏），因此它不需要改变。组合也可以通过组合绑定来调用，该绑定接受一个viewmodel作为绑定值。
- en: 'Open the `cp5-composition` branch. Notice that the shell view is back to containing
    our familiar navigation bar, as well as a compose binding, in its main content
    area:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`cp5-composition`分支。注意shell视图又回到了包含我们熟悉的导航栏，以及在其主要内容区域中的组合绑定：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The shell viewmodel has a `currentModel` property, as well as two functions,
    to switch the `currentModel` property between the `edit` and `list` page objects:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: shell viewmodel有一个`currentModel`属性，以及两个函数，用于在`edit`和`list`页面对象之间切换`currentModel`属性：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Try pressing the buttons in the navigation bar to see the body content switch
    between the two pages. The compose binding is taking a module instance, locating
    its view, and binding the view as the content of the DOM. As `currentModel` is
    observable, the composition reruns anytime it changes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试按下导航栏中的按钮，看看主体内容是否在两个页面之间切换。组合绑定正在获取一个模块实例，定位其视图，并将视图绑定为DOM的内容。由于`currentModel`是可观察的，所以每当它改变时，组合都会重新运行。
- en: As the `list` and `edit` objects are constructed once and just swapped, you
    should notice that values entered on the edit page are persistent. This is because,
    while the HTML is discarded and recreated when switching, the new HTML is still
    being bound against the same object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`list`和`edit`对象只构建一次并交换，你应该注意到在编辑页面上输入的值是持久的。这是因为，虽然在切换时HTML被丢弃并重新创建，但新的HTML仍然绑定到同一个对象上。
- en: Hopefully, the brevity of this example doesn't undercut the power of the composition
    system. The fact that they are so small should highlight just how easy composition
    is to work with; just by swapping a bound value, we can toggle between two completely
    different pages!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个示例的简洁性不会削弱组合系统的强大功能。它们如此之小的事实应该突出组合是多么容易处理；只需交换绑定值，我们就可以在两个完全不同的页面之间切换！
- en: You may have noticed that composition is like a mirror of Knockout components.
    Instead of a custom element or binding in the DOM choosing what will be rendered,
    composition renders the value specified by JavaScript. This ends up having a large
    impact on flexibility. A component is the element that the DOM says it is, but
    a single compose binding can hold any module and it can change at any time. They
    may seem like competing features, but I think they are serving different goals.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，组合就像是对Knockout组件的映射。不是DOM中的自定义元素或绑定来选择要渲染的内容，而是组合渲染JavaScript指定的值。这最终对灵活性产生了重大影响。组件是DOM所说的元素，但单个组合绑定可以持有任何模块，并且它可以随时更改。它们可能看起来像是相互竞争的功能，但我认为它们服务于不同的目标。
- en: Components are like advanced binding handlers, allowing the HTML to instantiate
    behavior-driven templates.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 组件就像高级的绑定处理器，允许HTML实例化行为驱动的模板。
- en: Composition uses the relationships created and managed by our viewmodel code
    and reflects them in the presentation layer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 组合使用我们视图模型代码创建和管理的关系，并在表示层中反映它们。
- en: Composition options
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合选项
- en: We looked at two examples of composition—`setRoot` and the compose binding—that
    each took an instance of an object to compose. Of course, Durandal is a thoughtful
    framework, so the composition has several other modes of operation. The value
    taken by the compose binding can be any of the following.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了两种组合示例——`setRoot`和组合绑定——它们各自接受一个要组合的对象实例。当然，Durandal是一个深思熟虑的框架，所以组合还有几种其他的工作模式。组合绑定可以接受以下任何一种值。
- en: Module instance
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块实例
- en: We've already covered this, but for the sake of completion, the compose binding
    can take an instance of a module and use it to locate the view. See the `cp5-composition`
    branch for an example. This is the most common use case for composition with the
    compose binding.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过这个问题，但为了完整性，组合绑定可以接受模块的实例，并使用它来定位视图。请参阅`cp5-composition`分支中的示例。这是使用组合绑定组合的最常见用例。
- en: Constructor
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'In the `cp5-composition2` branch, you can see a modified shell that sets the
    `currentModel` property to the constructor functions directly:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cp5-composition2`分支中，你可以看到一个修改后的外壳，它将`currentModel`属性直接设置为构造函数：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While this isn't a great use case, it is supported. Constructors are most commonly
    used for modules tied to the router, as a fresh viewmodel is generally desirable
    when navigating between pages. Unlike the previous example, which stored a reference
    to a constructed viewmodel for each page, this method will recreate the viewmodel
    each time it navigates.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一个很好的用例，但它得到了支持。构造函数最常用于与路由器绑定的模块，因为导航页面之间通常希望有一个新的视图模型。与上一个示例不同，它为每个页面存储了构造视图模型的引用，而这种方法将在每次导航时重新创建视图模型。
- en: Module ID strings
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块ID字符串
- en: 'There are two ways to use strings for the compose binding value. The first
    is by supplying a module ID. You can see this in the `cp5-composition3` branch:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串作为组合绑定值有两种方式。第一种是通过提供模块ID。你可以在`cp5-composition3`分支中看到这一点：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This results in the module being composed. If the module returns an object,
    it is composed directly; if the module returns a function, it is treated as a
    constructor to create the object. Of course, because it''s a string, this could
    be used in the binding directly:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致模块被组合。如果模块返回一个对象，它将被直接组合；如果模块返回一个函数，它被视为构造函数来创建对象。当然，因为它是一个字符串，所以可以直接在绑定中使用它：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While supported, I personally feel like this violates the separation of concerns.
    It ties the HTML view directly to a viewmodel.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然得到了支持，但我个人认为这违反了关注点的分离原则。它将HTML视图直接绑定到视图模型上。
- en: Viewpath strings
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图路径字符串
- en: 'The second way to use strings in the compose binding is with a viewpath. If
    the string contains an extension that the `viewEngine` module recognizes, it will
    be used to load that view and bind it to the current binding context. The common
    use case here is partial views:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compose`绑定中使用字符串的第二种方式是使用视图路径。如果字符串包含`viewEngine`模块能识别的扩展名，它将被用来加载该视图并将其绑定到当前绑定上下文中。这里的常见用例是部分视图：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, the string could be in the HTML or come from the viewmodel. In this case,
    as a view is referring to another view, I think the string belongs to the HTML.
    Otherwise, the reverse violation of the separation of concerns occurs, where a
    viewmodel has a direct reference to a view.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，字符串可以是HTML或来自viewmodel。在这种情况下，由于视图正在引用另一个视图，我认为字符串属于HTML。否则，将发生关注点分离的逆向违反，其中viewmodel直接引用视图。
- en: This sample can be seen in `cp5-composition4`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例可以在`cp5-composition4`中看到。
- en: Explicit models and views
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式模型和视图
- en: 'The compose binding can also take a settings object that specifies a model,
    a view, or both. There isn''t much to say about these examples, so this section
    is taken directly from the Durandal documentation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 组合绑定还可以接受一个设置对象，该对象指定一个模型、一个视图或两者。关于这些示例没有太多可说的，所以这一节直接来自Durandal文档：
- en: '`data-bind="compose: { model: model }"`: This uses the value of `model` with
    `viewLocator` to obtain a view. They are then bound and the view is injected into
    the DOM node.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-bind="compose: { model: model }"`: 这使用`model`的值与`viewLocator`一起获取一个视图。然后它们被绑定，并将视图注入到DOM节点中。'
- en: '`data-bind="compose: { view: view }"`: This evaluates the value of `view`.
    If it is a string, then `viewLocator` is used to locate the view; otherwise, it
    is assumed to be a view. The resultant view is injected into the DOM node.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-bind="compose: { view: view }"`: 这将评估`view`的值。如果是字符串，则使用`viewLocator`定位视图；否则，假定它是一个视图。结果视图将被注入到DOM节点中。'
- en: '`data-bind="compose: { model: model, view: view }"`: This resolves the value
    of `model`. The value of `view` is resolved and a view is constructed as indicated
    in the previous point. Both `model` and `view` are then bound and injected into
    the DOM node.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-bind="compose: { model: model, view: view }"`: 这将解析`model`的值。`view`的值将被解析，并按照前一点所述构建一个视图。然后，`model`和`view`都将被绑定并注入到DOM节点中。'
- en: '`data-bind="compose: { model: model, view:''myView.html'' }"`: The value of
    `model` is resolved. The `viewLocator` module is then used to obtain the view
    indicated by the `view` property. They are then bound, and the view is injected
    into the DOM node.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-bind="compose: { model: model, view:''myView.html'' }"`: 解析`model`的值。然后使用`viewLocator`模块获取由`view`属性指示的视图。它们随后被绑定，并将视图注入到DOM节点中。'
- en: '`data-bind="compose: { model:''shell'', view: view }"`: RequireJS is used to
    resolve the `shell` module. The value of `view` is resolved and a view is returned,
    as described in the previous point. The view is then bound to the resolved module
    and injected into the DOM node.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-bind="compose: { model:''shell'', view: view }"`: 使用RequireJS解析`shell`模块。`view`的值将被解析，并返回视图，如前所述。然后，视图被绑定到解析的模块，并注入到DOM节点中。'
- en: '`data-bind="compose: { model:''shell'', view:''myView.html'' }"`: RequireJS
    is used to resolve the `shell` module. The `viewLocator` module is then used to
    obtain the view indicated by `view`. The view is then bound to the resolved module
    and injected into the DOM node.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-bind="compose: { model:''shell'', view:''myView.html'' }"`: 使用RequireJS解析`shell`模块。然后使用`viewLocator`模块获取由`view`指示的视图。该视图随后被绑定到解析的模块，并注入到DOM节点中。'
- en: Containerless composition
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无容器组合
- en: 'All of the preceding examples work with Knockout''s containerless comment syntax
    as well, so the following is valid:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述示例都与Knockout的无容器注释语法一起工作，所以以下也是有效的：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The composition system has more features than there are in the scope of this
    chapter, including view caching, transitions, template mode, and custom view location
    strategies. They will be discussed in the next chapter, which covers more advanced
    use cases.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 组合系统具有比本章范围更广泛的功能，包括视图缓存、过渡、模板模式和自定义视图位置策略。它们将在下一章中讨论，该章将涵盖更高级的用例。
- en: View locations
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图位置
- en: 'As mentioned earlier, the default behavior of the `viewLocator` module used
    by composition is to look for a view with the same path as the module, but with
    the `.html` extension. This results in modules grouped by folder:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，组合使用的`viewLocator`模块的默认行为是查找与模块路径相同的视图，但带有`.html`扩展名。这导致按文件夹分组的模块：
- en: '![View locations](img/00010.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![视图位置](img/00010.jpeg)'
- en: In the preceding example, the `shell` directory contains the view and the viewmodel
    for the shell, and the `contacts` directory contains a base model for a contact,
    as well as a view and viewmodel for both `list` and `edit`. I think this organization
    is very easy to understand, and it scales well with large applications, as each
    feature or group of features is kept together.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`shell` 目录包含 shell 的视图和视图模型，而 `contacts` 目录包含一个联系人基模型，以及 `list` 和 `edit`
    的视图和视图模型。我认为这种组织方式非常易于理解，并且在大型应用程序中具有良好的扩展性，因为每个功能或功能组都保持在一起。
- en: 'Durandal offers another strategy though, which it calls the conventional strategy.
    You can activate it by modifying your `main.js` file to call `useConvention` on
    the `viewlocator` module:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Durandal 提供了另一种策略，它称之为传统策略。你可以通过修改 `main.js` 文件来在 `viewlocator` 模块上调用 `useConvention`
    来激活它：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This causes Durandal to look for a module with the `viewmodels/contactList`
    ID at `views/contactList.html`. While you can enter any strings for the viewmodels
    and views, paths, this is actually the default. Calling `viewLocator.useConvention()`
    (with no parameters) will produce the same effect.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致 Durandal 在 `views/contactList.html` 中寻找具有 `viewmodels/contactList` ID 的模块。虽然你可以为视图模型和视图输入任何字符串作为路径，但实际上这是默认的。调用
    `viewLocator.useConvention()`（不带参数）会产生相同的效果。
- en: I don't think this method scales as well, and I personally find it harder to
    work with. I prefer to have the viewmodel and view in the same location in the
    filesystem, so that I don't have to hunt for it. It's all up to you (or your team's)
    preference though.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这种方法扩展性不好，我个人觉得它更难操作。我更喜欢将视图模型和视图放在文件系统中的同一位置，这样我就不必去寻找它。但这完全取决于你（或你的团队）的偏好。
- en: All of the code samples shown here will use the default behavior, not the conventional
    behavior.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的所有代码示例都将使用默认行为，而不是传统行为。
- en: Using the router
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由器
- en: While technically an optional plugin, I don't imagine any real-world SPAs will
    do without the use of the router. While SammyJS ties a URL fragment to a function,
    Durandal's router ties the URL directly to a module ID. The module can return
    either a singleton or a constructor, and will be used to bind the view using the
    standard composition system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上这是一个可选插件，但我无法想象任何实际的 SPA 会不使用路由器。虽然 SammyJS 将 URL 片段绑定到函数，但 Durandal 的路由器将
    URL 直接绑定到模块 ID。该模块可以返回单例或构造函数，并将用于使用标准组合系统绑定视图。
- en: Configuring the router
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置路由器
- en: 'Let''s start configuring the router:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始配置路由器：
- en: 'Route configuration is pretty straightforward. Here is the `shell` module with
    router configuration for the `Contact` application:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由配置相当直接。以下是 `shell` 模块中为 `Contact` 应用程序配置的路由器：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The router plugin is required in the `shell` module and is set up during its
    `activate` method.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由插件在 `shell` 模块中是必需的，并在其 `activate` 方法中设置。
- en: The `map` method takes an array of routes and `buildNavigationModel` sets up
    those routes. The `mapUnknownRoutes` function takes a module ID and a route to
    use as a catch-all for attempts to navigate to routes that have not been registered.
    Without this, navigation will be canceled instead, with no error displayed to
    the user!
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map` 方法接受一个路由数组，而 `buildNavigationModel` 则设置这些路由。`mapUnknownRoutes` 函数接受一个模块
    ID 和一个用作对所有未注册路由导航尝试的通配符的路由。如果没有这个功能，导航将被取消，而不会向用户显示任何错误！'
- en: We will cover `activate` and the other life cycle hooks in detail in a bit.
    For now, just know that `activate` is called during composition. If the return
    value from `activate` is a `promise`, then composition will wait until the promise
    resolves.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在稍后详细介绍 `activate` 和其他生命周期钩子。现在，只需知道 `activate` 在组合期间被调用。如果 `activate` 的返回值是一个
    `promise`，则组合将等待直到 promise 解决。
- en: Finally, `router.activate`, which also returns a `promise`, is returned to the
    shell's `activate` method, which chains the wait from composition until the router
    has finished.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`router.activate`，它也返回一个 `promise`，被返回到 `shell` 的 `activate` 方法，该方法将组合等待与路由器完成。
- en: Route properties
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由属性
- en: 'The route''s configuration objects that are passed to the `map` function take
    the following properties:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `map` 函数的路由配置对象具有以下属性：
- en: '`route`: This is the URL to map to. It can be a string or an array of strings.
    Each string can take one of the following forms:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route`：这是要映射的 URL。它可以是字符串或字符串数组。每个字符串可以采用以下形式之一：'
- en: 'Default route: This is `route: ''''`.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '默认路由：这是 `route: ''''`。'
- en: 'Static route: This is `route: ''contacts''`.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '静态路由：这是 `route: ''contacts''`。'
- en: 'Parameterized route: This is `route: ''contacts/:id''`.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '参数化路由：这是 `route: ''contacts/:id''`。'
- en: 'Optional parameter route: This is `route: ''contacts(/:id)''`.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '可选参数路由：这是 `route: ''contacts(/:id)''`。'
- en: 'Splat route: This is `route: ''contacts*details''`. It is a *wild card*, and
    will match any URL starting with `contacts`.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '通配符路由：这是 `route: ''contacts*details''`。它是一个 *通配符*，将匹配以 `contacts` 开头的任何 URL。'
- en: '`moduleId`: This is the module to bind the route to.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moduleId`：这是绑定路由的模块。'
- en: '`hash`: This is used primarily for data binding `<a>` tags. In most cases,
    the router will generate this automatically, but it can be overridden. It is necessary
    to override this property on routes with optional parameters or splats.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash`：这主要用于数据绑定 `<a>` 标签。在大多数情况下，路由会自动生成这个值，但也可以覆盖。在具有可选参数或通配符的路由上覆盖这个属性是必要的。'
- en: '`title`: The `document.title` property is set to this value. If present, then
    the route is active; if absent, the `document.title` is not changed.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：将 `document.title` 属性设置为这个值。如果存在，则路由是活动的；如果不存在，则不更改 `document.title`。'
- en: '`nav`: If `true`, the route will be included in the router''s `navigationModel`,
    an observable array of routes created when `buildNavigationModel` is called, which
    can be used to easily generate navigation bars. The default value is `false`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nav`：如果为 `true`，则路由将被包含在路由的 `navigationModel` 中，这是一个在调用 `buildNavigationModel`
    时创建的路由的可观察数组，可以用来轻松生成导航栏。默认值是 `false`。'
- en: If a module with an `activate` or `canActivate` function is activated by the
    router, the route's parameters are passed as arguments to it. Again, activation
    and other life cycle hooks will be covered in more detail later in this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个具有 `activate` 或 `canActivate` 函数的模块被路由激活，则路由的参数将作为参数传递给它。再次强调，激活和其他生命周期钩子将在本章的后面更详细地介绍。
- en: Query strings are also passed in as the last parameters to `activate`/`canActivate`
    as objects with a key/value pair query string key.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串也作为对象传递给 `activate`/`canActivate` 的最后一个参数，该对象具有键/值对的查询字符串键。
- en: Binding the router
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定路由
- en: 'The router introduces a special binding, also called **router**, which wraps
    the compose binding with special handling logic. It shares the same properties
    as the compose binding:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 路由引入了一个特殊的绑定，也称为 **router**，它使用特殊的处理逻辑包装了 compose 绑定。它具有与 compose 绑定相同的属性：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `activeItem` object on the router holds the currently active routes'' module.
    If the `model` property on the router binding is omitted, the binding will look
    for a router property on the current binding context and take its `activeItem`
    object. The preceding example is equivalent to this one:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 路由上的 `activeItem` 对象包含当前活动路由的模块。如果省略了路由绑定上的 `model` 属性，绑定将查找当前绑定上下文上的路由属性并取其
    `activeItem` 对象。前面的例子等同于这个例子：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The router also has a `navigationModel` observable array, which is very useful
    in generating navigation bars:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 路由还有一个 `navigationModel` 可观察数组，这在生成导航栏时非常有用：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each route has an `isActive` property, which indicates when the route is active,
    and a `hash` property, which can be used for a tag's `href` property.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由都有一个 `isActive` 属性，它指示路由何时处于活动状态，以及一个 `hash` 属性，它可以用于标签的 `href` 属性。
- en: 'Loading or navigating, are also exposed as observables on the router. This
    makes it easy to bind loading indicators on the page:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 加载或导航，也作为路由上的可观察者暴露。这使得在页面上绑定加载指示器变得很容易：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Okay, time to look at a live example. Open the `cp5-router` branch. Try moving
    around the application by editing contacts or using the navigation bar links.
    Notice that the URL's hash is updated to match the current route. You can even
    use the browsers back and forward buttons to control navigation, as the router
    is hooked into the `window.location` object. Like all true SPAs, the navigation
    occurs inside the app, not by performing browser navigation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候看看一个活生生的例子了。打开 `cp5-router` 分支。尝试通过编辑联系人或使用导航栏链接来移动应用程序。注意，URL 的哈希值会更新以匹配当前路由。你甚至可以使用浏览器的后退和前进按钮来控制导航，因为路由已经连接到
    `window.location` 对象。像所有真正的单页应用（SPA）一样，导航是在应用程序内部发生的，而不是通过执行浏览器导航。
- en: Activating routes
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活路由
- en: When a route is activated, the associated viewmodel module is loaded with RequireJS
    and composed into the DOM. The module loaded by RequireJS must either be an object,
    which will be treated as a singleton and bound to the view, or a function, which
    will be treated as a constructor and used to `new` up an object to bind to the
    view.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个路由被激活时，相关的 viewmodel 模块会通过 RequireJS 加载，并组合到 DOM 中。通过 RequireJS 加载的模块必须是对象，它将被视为单例并绑定到视图，或者是一个函数，它将被视为构造函数并用于
    `new` 一个对象以绑定到视图。
- en: Navigation – hash change versus push state
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航 – 哈希变化与推状态
- en: We just saw how the router handled navigation by changing the URL's hash. This
    is the default behavior, but the router also supports push state navigation. Push
    state navigation is the use of the HTML5 history API to modify the current URL
    and the history stack, without causing browser navigation. This results in prettier
    and normal looking URLs during router navigation. We see `http://localhost:3000/contacts/new`
    instead of `http://localhost:3000/#contacts/new`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了路由器如何通过更改 URL 的哈希来处理导航。这是默认行为，但路由器还支持推状态导航。推状态导航是使用 HTML5 历史API来修改当前
    URL 和历史堆栈，而不引起浏览器导航。这导致在路由器导航期间出现更美观且看起来正常的 URL。我们看到 `http://localhost:3000/contacts/new`
    而不是 `http://localhost:3000/#contacts/new`。
- en: 'This mode of navigation can be activated by passing the `router.activate({
    pushState: true })` calling. Though older browsers don''t support push state,
    Durandal will gracefully degrade to hash change navigation when push state is
    not supported.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '通过传递 `router.activate({ pushState: true })` 调用来激活这种导航模式。尽管较旧的浏览器不支持推状态，但 Durandal
    会在不支持推状态时优雅地降级到哈希变化导航。'
- en: The reason this isn't the default behavior is because it requires support from
    the server to work properly. Currently, our server is only serving our application
    when we navigate to the root URL. If we try to navigate to `/contacts/new`, the
    server will display a `404` error. As Durandal is supposed to be in control of
    routes and navigation, adding this support route-by-route to the server would
    be a lot of duplication. The recommended way to support push state on the server
    is to use a wild card route to send all page requests to the index page. Once
    Durandal loads, it will detect the URL and activate the proper route.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是默认行为的原因是因为它需要服务器支持才能正常工作。目前，我们的服务器只有在导航到根 URL 时才提供服务。如果我们尝试导航到 `/contacts/new`，服务器将显示一个
    `404` 错误。由于 Durandal 应该控制路由和导航，因此将此支持逐个添加到服务器将导致大量重复。在服务器上支持推状态的建议方法是使用通配符路由将所有页面请求发送到索引页面。一旦
    Durandal 加载，它将检测 URL 并激活正确的路由。
- en: 'The implementation of wild card routes will depend entirely on your server
    backend. Our examples are using a Node.js server, which makes it pretty easy:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符路由的实现完全取决于您的服务器后端。我们的示例使用的是 Node.js 服务器，这使得它变得相当简单：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That will take care of the page routing, but there is a much bigger supportability
    issue with push state routing; relative paths in HTML and the RequireJS config.
    Right now, all the links to CSS or the scripts in our code look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将处理页面路由，但推状态路由存在一个更大的可支持性问题；HTML 中的相对路径和 RequireJS 配置。目前，我们代码中所有指向 CSS 或脚本的链接看起来像这样：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a problem if the page tries to load `/contacts/new`, because `content/css`
    is a relative path; it will be treated by the browser as `/contacts/content/css`.
    Obviously this will fail; either the server will display a `404` error, or worse,
    the wild card route will cause the index page to be returned!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页面尝试加载 `/contacts/new`，这将是一个问题，因为 `content/css` 是一个相对路径；它将被浏览器视为 `/contacts/content/css`。显然这将失败；要么服务器将显示一个
    `404` 错误，要么更糟糕的是，通配符路由将导致返回索引页面！
- en: 'To fix this, all the paths need to be absolute paths; they have to start with
    a forward slash (`/`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，所有路径都需要是绝对路径；它们必须以正斜杠（`/`）开头：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This one can be nasty as is it requires manually updating any code with links
    in it, including the RequireJS config. As long as you are aware of the road you
    want to take when you start a project, this isn't much of a headache. If you can,
    I recommend going to the push state route. Having those nice looking URLs makes
    a big difference. It also frees the hash up to do its normal job of indicating
    a location or state on the page.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很棘手，因为它需要手动更新包含链接的任何代码，包括 RequireJS 配置。只要您在开始项目时意识到您想要走的路，这就不会造成太大的麻烦。如果您可以的话，我建议使用推状态路由。那些漂亮的
    URL 会使很大的不同。它还释放了哈希，以便它能够正常地表示页面上的位置或状态。
- en: You can see an example of the push state scenario in `cp5-pushstate`. Note that
    as a special treat, this branch supports IE 8 so that you can see the graceful
    degradation to hash change navigation. The rest of the examples in this chapter
    will use push state navigation, but will return only to supporting ES5-compatible
    browsers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `cp5-pushstate` 中看到一个推状态的示例。请注意，作为一个特别的待遇，这个分支支持 IE 8，这样您可以看到对哈希变化导航的优雅降级。本章中的其余示例将使用推状态导航，但只支持
    ES5 兼容的浏览器。
- en: Controlling the navigation from JavaScript
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 JavaScript 控制导航
- en: 'Navigation can easily be done with the router''s `navigate` function, which
    takes a URL string. The router is a singleton, and can be required into any module,
    using `plugins/router`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用路由器的`navigate`函数轻松进行导航，该函数接受一个URL字符串。路由器是一个单例，可以通过`plugins/router`在任何模块中引入：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Modal dialogs
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态对话框
- en: After the overuse of modal dialogs in Windows, and alert boxes in early browser
    applications, modal dialogs have left a bad taste with some developers. However,
    when used appropriately, they are simple and powerful tools. Durandal's modal
    dialog implementation makes collecting user input from modals very easy, by making
    dialogs return promises that resolve when they close. Modal dialogs in Durandal
    come in two types, namely, message boxes and custom dialogs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中过度使用模态对话框以及在早期浏览器应用中使用警告框之后，模态对话框给一些开发者留下了不好的印象。然而，当适当使用时，它们是简单而强大的工具。Durandal的模态对话框实现通过使对话框返回在关闭时解决的承诺，使得从模态对话框中收集用户输入变得非常容易。Durandal中的模态对话框有两种类型，即消息框和自定义对话框。
- en: Message boxes
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息框
- en: 'For simple cases such as displaying a notification or collecting a single piece
    of user input, Durandal provides a modal dialog on `app.showMessage`, which takes
    the following parameters:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于显示通知或收集单个用户输入的简单情况，Durandal在`app.showMessage`上提供了一个模态对话框，它接受以下参数：
- en: '`Message (string)`: This contains the main contents of the message box.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`消息 (string)`: 这包含消息框的主要内容。'
- en: '`Title (string, optional)`: This contains the title of the message box; the
    default title is `app.title`.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题 (string, optional)`: 这包含消息框的标题；默认标题是`app.title`。'
- en: '`Buttons (array, optional)`: This is an array of buttons to show; the default
    is `[''Ok'']`. The first button in the array will be the default action of the
    dialog. If the array is an array of strings, then the text will be both the button
    text and the return value of clicking that button. To specify the value of a button,
    use an array of objects, that is, `[{ text: "One", value: 1 }, { text: "Two",
    value: 2 }]`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮 (array, optional)`: 这是一个要显示的按钮数组；默认是`[''Ok'']`。数组中的第一个按钮将是对话框的默认操作。如果数组是字符串数组，则文本既是按钮文本也是点击该按钮的返回值。要指定按钮的值，请使用对象数组，即`[{
    text: "One", value: 1 }, { text: "Two", value: 2 }]`。'
- en: '`Autoclose (boolean, optional)`: If `true`, the dialog will be closed if the
    user clicks outside of the dialog window; the default is `false`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Autoclose (boolean, optional)`: 如果为`true`，则当用户点击对话框窗口外部时，对话框将被关闭；默认是`false`。'
- en: '`Settings (object, optional)`: See the upcoming *Message box settings* section.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`设置 (object, optional)`: 请参阅即将到来的*消息框设置*部分。'
- en: 'While a simple call to `app.showMessage(''This is a message!'')` is a good
    way to put something right in front of the user, I think the best use case for
    message boxes is the *Are you sure?* confirmation dialog:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的调用`app.showMessage('This is a message!')`是将某物直接展示给用户的好方法，但我认为消息框的最佳用例是*确认对话框*：
- en: '![Message boxes](img/00011.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![消息框](img/00011.jpeg)'
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we are showing a message box when someone tries to delete a contact. The
    message includes the contact's name (to provide context) and a title. The order
    of the two buttons, **No** then **Yes**, ensures that if the user hits enter immediately,
    **No** will be selected. I think it's good to default to the safer case. Whatever
    the user selects will be given to the promise returned from `showMessage`, which
    we can access in the `then` handler.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人尝试删除联系人时，我们在这里显示一个消息框。消息包括联系人的姓名（以提供上下文）和标题。两个按钮的顺序，**否**然后**是**，确保如果用户立即按回车键，**否**将被选中。我认为默认选择更安全的情况是好的。用户选择的任何内容都将传递给`showMessage`返回的承诺，我们可以在`then`处理程序中访问它。
- en: Depending on how you count those lines, we just double-checked a user action
    with a modal dialog in 2-3 lines of very-readable code. You can see an example
    of this in the `cp5-message` branch.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你如何计算这些行，我们只用2-3行非常易读的代码就通过模态对话框双重检查了用户操作。你可以在`cp5-message`分支中看到这个示例。
- en: Message box settings
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息框设置
- en: 'The last parameter to `showMessage` is an object that controls display options.
    It takes the following parameters:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`showMessage`函数的最后一个参数是一个对象，用于控制显示选项。它接受以下参数：'
- en: '`buttonClass`: This specifies a class for all buttons. The default is `btn`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buttonClass`: 这指定了所有按钮的类。默认是`btn`。'
- en: '`primaryButtonClass`: This specifies an additional class for the first button.
    The default is `btn-primary`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`primaryButtonClass`: 这指定了第一个按钮的附加类。默认是`btn-primary`。'
- en: '`secondaryButtonClass`: It specifies an additional class for buttons other
    than the first. The default is no class.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secondaryButtonClass`: 它指定了除了第一个按钮之外的其他按钮的附加类。默认没有类。'
- en: '`class`: This specifies the class of the outermost `div` element of the message
    box. The default is `"messageBox"`. Note that you must specify this property with
    quotes or it will crash in IE8; for example, `"class"` and `"myClass"`.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`: 这指定了消息框最外层 `div` 元素的类。默认为 `"messageBox"`。请注意，您必须用引号指定此属性，否则在 IE8 中会崩溃；例如，`"class"`
    和 `"myClass"`。'
- en: '`style`: This specifies additional styles for the outermost `div` element of
    the message box. The default is nothing.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style`: 这指定了消息框最外层 `div` 元素的额外样式。默认为无。'
- en: You can also control the default settings by passing the same settings object
    to `dialog.MessageBox.setDefaults`. This function will merge the settings passed
    to it with the defaults; if you leave settings out, they will be left alone, not
    removed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过将相同的设置对象传递给 `dialog.MessageBox.setDefaults` 来控制默认设置。此函数将合并传递给它的设置与默认设置；如果您省略了设置，它们将被保留，而不是被删除。
- en: Custom dialogs
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义对话框
- en: Message boxes are great for single input such as `yes`, `no`, or choosing an
    option from a list. However, when things need to get more complex than a single
    answer, Durandal allows us to create custom dialogs. To show a custom dialog,
    you can require the dialog object with `plugins/dialog` and call `dialog.show`,
    or use the alias `app.showDialog`. Dialogs use composition, so any viewmodel passed
    to `show` will look up and bind against its view using the standard methods.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 消息框非常适合单输入，如 `yes`、`no` 或从列表中选择一个选项。然而，当事情需要比单个答案更复杂时，Durandal 允许我们创建自定义对话框。要显示自定义对话框，您可以使用
    `plugins/dialog` 要求对话框对象并调用 `dialog.show`，或者使用别名 `app.showDialog`。对话框使用组合，因此传递给
    `show` 的任何视图模型都将使用标准方法查找并绑定其视图。
- en: To close itself and pass a result back to the caller, the dialog-hosted viewmodel
    will need to require `plugins/dialog` and call `dialog.close(self, result)`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭自身并将结果返回给调用者，对话框承载的视图模型需要要求 `plugins/dialog` 并调用 `dialog.close(self, result)`。
- en: To see how this works, open the `cp5-dialog` branch. The **Add Contact** button
    on the main list page will open the edit viewmodel in a dialog, which will either
    close with `null` for a canceled entry or a new contact for the saved entry. Just
    to show how flexible it is, the `Add Contact` link in the nav bar will still navigate
    to a new page to create a new contact. Both, the dialog and the page are run by
    the same viewmodel!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这是如何工作的，请打开 `cp5-dialog` 分支。主列表页面上的 **添加联系人** 按钮将在对话框中打开编辑视图模型，该对话框将关闭为取消的条目
    `null` 或为保存的条目创建新联系人。为了展示其灵活性，导航栏中的 **添加联系人** 链接仍然会导航到一个新页面以创建新联系人。两者，对话框和页面都由同一个视图模型运行！
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, almost nothing has changed. Instead of always using the router
    to navigate home when finished, the new close method checks `dialog.getDialog(self))`
    to see whether it is a dialog, and closes itself with the result (null or the
    newly created contact). The `dialog.getDialog(self))` method returns the dialog
    context, or is undefined if none is found.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，几乎没有什么变化。在完成时，不再总是使用路由器导航到主页，新的关闭方法会检查 `dialog.getDialog(self))` 以确定它是否是对话框，并使用结果（null
    或新创建的联系人）关闭自身。`dialog.getDialog(self))` 方法返回对话框上下文，如果没有找到则返回未定义。
- en: 'The list viewmodel has to only make the following change to open the dialog
    and keep the result:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表视图模型只需进行以下更改即可打开对话框并保留结果：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `ContactVM` object is the edit viewmodel, which is being required in with
    `contact/edit`. A new one is constructed and passed to `app.showDialog`. Composition
    renders the viewmodel and returns the promise for the dialog's result. This promise
    will be completed by the `dialog.close` call in the edit viewmodel. The `then`
    handler just checks to make sure it exists and adds it to its list of contacts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactVM` 对象是编辑视图模型，它通过 `contact/edit` 被要求。一个新的实例被构建并传递给 `app.showDialog`。组合渲染视图模型并返回对话框结果的承诺。此承诺将由编辑视图模型中的
    `dialog.close` 调用完成。`then` 处理程序只是确保它存在并将其添加到其联系人列表中。'
- en: 'There are some HTML/CSS considerations with custom dialogs. Unlike message
    boxes, which are styled with Bootstrap''s modal classes by Durandal, custom dialogs
    are rendered into an empty `div` element that is centered with absolute positioning
    and a transparent background. Without some styling, the output looks pretty terrible:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义对话框有一些 HTML/CSS 考虑因素。与 Durandal 使用 Bootstrap 的 modal 类样式的消息框不同，自定义对话框被渲染到一个居中的空
    `div` 元素中，该元素具有绝对定位和透明背景。如果没有一些样式，输出看起来相当糟糕：
- en: '![Custom dialogs](img/00012.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![自定义对话框](img/00012.jpeg)'
- en: 'Thankfully, it doesn''t take much to clean this up. This is the CSS I used:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，清理起来并不需要太多。这是我使用的 CSS：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding CSS produces this much nicer looking result:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上述CSS产生了这个看起来更舒服的结果：
- en: '![Custom dialogs](img/00013.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![自定义对话框](img/00013.jpeg)'
- en: While the need for this might be surprising, I think it's better than the alternative
    where Durandal does apply some default styling to all modals, which has to forcefully
    be overridden when it doesn't match what you want. In the next chapter, we will
    cover adding custom dialog hosts, which provides a much nicer way to control default
    modal appearance for both message boxes and custom dialogs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种需求可能令人惊讶，但我认为它比Durandal对所有模态应用一些默认样式的替代方案更好，这必须被强制覆盖，当它不符合你的需求时。在下一章中，我们将介绍添加自定义对话框宿主，这为控制消息框和自定义对话框的默认模态外观提供了更好的方式。
- en: An alternative method
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一种替代方法
- en: 'To keep the calling viewmodel a little cleaner and less aware of how the dialog
    viewmodel works, I prefer to encapsulate the actual dialog code. This is easy
    to do by adding a `show` method to the edit viewmodel:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使调用视图模型保持一定的简洁性，并且减少对对话框视图模型工作方式的了解，我更倾向于封装实际的对话框代码。通过向编辑视图模型添加一个`show`方法来实现这一点非常简单：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And calling it instead of `app.showDialog`, as seen here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 并且像这里所示的那样调用它，而不是`app.showDialog`：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This hides the specific method from the caller, allowing the edit viewmodel
    to control how it shows itself. The `show` method could even take the parameters
    that allowed configuration before showing the dialog. This is especially useful
    when multiple dialog hosts are available, which we will cover in the next chapter.
    You can see this example in the `cp5-dailog2` branch.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这隐藏了特定方法对调用者的可见性，允许编辑视图模型控制其显示方式。`show`方法甚至可以接受在显示对话框之前允许配置的参数。这在有多个对话框宿主可用时特别有用，我们将在下一章中介绍。你可以在`cp5-dailog2`分支中看到这个示例。
- en: The application's life cycle
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的生命周期
- en: Durandal's composition and activator services allow optional callbacks to control
    or hook into their life cycles. They can be useful when performing setup and teardown,
    or implementing logic to block or redirect page changes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal的合成和激活器服务允许可选的回调来控制或挂钩其生命周期。当执行设置和清理，或实现阻止或重定向页面更改的逻辑时，它们可能很有用。
- en: The activation life cycle
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活生命周期
- en: An activator is a special computed observable, whose `write` function enforces
    the activation life cycle. Unless you are managing composition or routing yourself,
    the only activators you will work with are the ones used by the router and the
    dialog system. Though, if you are interested, you can create your own activator
    by requiring in the `durandal/activator` module and using the `create` function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 激活器是一个特殊的计算可观察对象，其`write`函数强制执行激活生命周期。除非你自己在管理合成或路由，否则你将只与路由器和对话框系统使用的激活器一起工作。尽管如此，如果你感兴趣，可以通过在`durandal/activator`模块中引入并使用`create`函数来创建自己的激活器。
- en: 'The following optional properties are called by the activator when the active
    value tries to change:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动值尝试更改时，激活器会调用以下可选属性：
- en: '`canActivate`: This is called on the new value; it should return either a Boolean
    or a promise that resolves to a Boolean. If the result is `false`, activation
    is cancelled.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canActivate`：在新的值上调用此方法；它应该返回一个布尔值或一个解析为布尔值的承诺。如果结果是`false`，则激活被取消。'
- en: '`activate`: This is called on the new value after `canActivate`; it is used
    to perform any desired setup logic. If activate returns a promise, the new value
    will not become the active value until the promise resolves.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activate`：在`canActivate`之后对新值进行调用；它用于执行任何所需的设置逻辑。如果`activate`返回一个承诺，则新值不会成为活动值，直到承诺解析。'
- en: '`canDeactivate`: This is called on the old value; just like activate, it should
    return either a Boolean or a promise that resolves to a Boolean. If the result
    is false, activation is cancelled.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canDeactivate`：在旧值上调用；就像`activate`一样，它应该返回一个布尔值或一个解析为布尔值的承诺。如果结果是`false`，则激活被取消。'
- en: '`Deactivate`: This is called on the old value after activation succeeds, but
    before the switch is made. It is used to perform any teardown logic.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deactivate`：在激活成功后但在切换之前对旧值进行调用。它用于执行任何必要的清理逻辑。'
- en: Preparing viewmodels with activate
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`activate`准备视图模型
- en: 'You have already seen the use of `activate` in the list and edit viewmodels,
    where it is used to load data:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了在列表和编辑视图模型中使用`activate`的情况，它被用来加载数据：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What probably hasn't been obvious, because the mock data service is using local
    storage, is that if this service call actually took time, the page would render
    before the data got back. This could result in a jarring change when all of the
    contacts suddenly load. The `activate` call isn't waiting for this callback to
    finish, so Durandal is activating the viewmodel before it's really ready.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不明显的是，因为模拟数据服务正在使用本地存储，如果这个服务调用实际上花费了时间，页面会在数据返回之前渲染。这可能导致当所有联系人突然加载时出现令人震惊的变化。`activate`调用并不等待这个回调完成，所以Durandal在视图模型真正准备好之前就激活了视图模型。
- en: To see what this looks like, open the `cp5-timeout` branch. All the mock service
    calls have had a 1 second timeout added before their callbacks are used, which
    will result in a more real-world response time scenario. Loading the home page,
    you can see the list load after the rest of the page. This is especially problematic
    when trying to edit a contact, as the form will show the default values until
    the contact is loaded.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这看起来是什么样子，请打开`cp5-timeout`分支。在它们的回调被使用之前，所有模拟服务调用都添加了1秒的超时，这将导致更接近现实世界的响应时间场景。加载主页时，您可以看到列表在页面其余部分加载之后加载。当尝试编辑联系人时，这是一个特别有问题的情况，因为表单将显示默认值，直到联系人加载。
- en: 'To stop the page loading until the list is retrieved, we can return a promise
    from activate. The `durandal/system` module provides a way to create promises
    if you aren''t using your own library (such as Q) to do so:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止页面加载直到检索到列表，我们可以在激活中返回一个承诺。`durandal/system`模块提供了一种创建承诺的方法，如果您不使用自己的库（如Q）来做这件事：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are returning a promise that will be resolved by the callback to our
    mock data service. The `system.defer` function takes a handler that performs asynchronous
    working, calling it with a deferred object. The deferred object has the resolve
    and reject functions, which can take values for success or failure. You can see
    this in the `cp5-activate` branch, where the same change was made for the edit
    page. As activate is waiting on this promise, activation will not continue until
    it resolves. These pages will not activate until their data is loaded, so the
    user never sees the page before it is ready.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们返回一个承诺，该承诺将由回调函数解析我们的模拟数据服务。`system.defer`函数接受一个执行异步工作的处理程序，使用延迟对象调用它。延迟对象具有解析和拒绝函数，可以接受成功或失败的价值。您可以在`cp5-activate`分支中看到这一点，其中对编辑页面进行了相同的更改。由于激活正在等待这个承诺，因此激活将不会继续，直到它解析。这些页面将在数据加载之前不会激活，所以用户在页面准备好之前永远不会看到它。
- en: 'While this method works, there is a cleaner way to do it. Instead of using
    callbacks in our data service and promises in our viewmodels, which really mixes
    strategies, we can use promises in our data service. If our data service returns
    a promise, the activate method looks much nicer:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法有效，但有一种更干净的方法来做这件事。我们不是在我们的数据服务中使用回调，在我们的视图模型中使用承诺，这实际上混淆了策略，我们可以在我们的数据服务中使用承诺。如果我们的数据服务返回一个承诺，激活方法看起来会更好：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What an improvement! In fact, we can take it even further. As `self.contacts`
    is an observable array, which is just a function, we can cut out the anonymous
    function in the `then` handler with this shorthand:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个多么大的改进！实际上，我们可以更进一步。由于`self.contacts`是一个可观察数组，它只是一个函数，我们可以在`then`处理程序中删除匿名函数，使用这个简写：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This works because `self.contacts` becomes the `then` handler, so when the service
    returns the list of contacts, the promise resolves directly into it. This doesn't
    appeal to everyone, and it might even look confusing. However, if it doesn't impair
    readability for you, the shorter code might be nice.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为`self.contacts`成为`then`处理程序，所以当服务返回联系人列表时，承诺直接解析到它。这可能不会吸引每个人，甚至可能看起来很混乱。然而，如果它不会影响您的可读性，较短的代码可能更好。
- en: 'This method can be seen in the `cp5-activate2` branch, which fully converts
    all the data access code into promises, such as this one:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以在`cp5-activate2`分支中看到，它将所有数据访问代码完全转换为承诺，例如这个：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because Durandal has this understanding of promises integrated into its life
    cycle hooks, it makes using promises for all asynchronous code that much more
    appealing. If you aren't doing this already, I strongly encourage you to consider
    it. All code samples from here on will be using promises.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Durandal已经将这种对承诺的理解集成到其生命周期钩子中，这使得在所有异步代码中使用承诺更具吸引力。如果您还没有这样做，我强烈建议您考虑一下。从现在开始的所有代码示例都将使用承诺。
- en: This asynchronous activation is another advantage of the composition of components.
    Components can only construct and bind synchronously, which can make some components
    very tricky to initialize. Composition allows asynchronous work to be done, making
    it that much more flexible.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异步激活是组件组合的另一个优点。组件只能同步构建和绑定，这可能会使某些组件的初始化变得非常复杂。组合允许进行异步工作，使其更加灵活。
- en: A note on the router's isNavigating property
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于路由器的 isNavigating 属性的说明
- en: In the previous section, *Binding the router*, we looked at the `isNavigating`
    property of the router, which is `true` during navigation. The activation life
    cycle is part of navigation, so `isNavigating` will be `true` during any asynchronous
    activity in the activation life cycle. This allows you to bind visual indicators
    on the page while your pages are loading, making your application feel more responsive.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节 *绑定路由器* 中，我们查看路由器的 `isNavigating` 属性，在导航期间为 `true`。激活生命周期是导航的一部分，因此在激活生命周期中的任何异步活动期间
    `isNavigating` 都将是 `true`。这允许你在页面加载时绑定视觉指示器，使你的应用程序感觉更响应。
- en: Checking navigation with canDeactivate
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 canDeactivate 检查导航
- en: The `canActivate` and `canDeactivat`e methods also support promises. Going off
    to the server with an Ajax request to see whether a view can be deactivated might
    seem weird, but Ajax isn't the only source of promises. Perhaps the best possible
    use case for `canDeactivate` is with the promise from a simple message box—**You
    have unsaved changes, are you sure you want to leave?**
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`canActivate` 和 `canDeactivate` 方法也支持承诺。使用Ajax请求去服务器查看视图是否可以被停用可能看起来很奇怪，但Ajax并不是承诺的唯一来源。`canDeactivate`
    的最佳可能用途之一是与简单消息框的承诺——**你有未保存的更改，你确定要离开吗？**'
- en: Open the `cp5-deactivate` branch and open up a contact to edit. If you hit **Cancel**,
    you will still be taken back to the list, but if you make changes and hit **Cancel**,
    you will be prompted. If you hit **No**, navigation will be cancelled.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `cp5-deactivate` 分支并打开一个联系人进行编辑。如果你点击 **取消**，你仍然会被带回到列表中，但如果你进行了更改并点击 **取消**，你将收到提示。如果你点击
    **否**，导航将被取消。
- en: 'You might think that this is being done from the **Cancel** button, but it
    will also happen if the user clicks on the browser''s back button or the navigation
    link (basically, anything but a hard browser navigation). This is because `canDeactivate`
    is run no matter what source the attempted deactivation comes from:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这是从 **取消** 按钮执行的，但用户点击浏览器的后退按钮或导航链接（基本上，除了硬浏览器导航之外的所有操作）也会发生这种情况。这是因为无论尝试停用的来源是什么，`canDeactivate`
    都会被执行：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The dirty flag in this sample is taken from Ryan Niemeyer's blog *Knock Me Out*
    at [http://www.knockmeout.net/2011/05/creating-smart-dirty-flag-in-knockoutjs.html](http://www.knockmeout.net/2011/05/creating-smart-dirty-flag-in-knockoutjs.html).
    It can be seen in the `common/extensions.js` file in the branch source code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的脏标志来自Ryan Niemeyer的博客 *Knock Me Out*，网址为[http://www.knockmeout.net/2011/05/creating-smart-dirty-flag-in-knockoutjs.html](http://www.knockmeout.net/2011/05/creating-smart-dirty-flag-in-knockoutjs.html)。它可以在分支源代码中的
    `common/extensions.js` 文件中看到。
- en: Here, we are just showing a standard message box and transforming the result
    into a Boolean for `canDeactivate`. The promise for this result is returned, and
    `canDeactivate` will wait until it resolves, to determine whether or not activation
    can continue.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是显示一个标准消息框并将结果转换为布尔值用于 `canDeactivate`。返回这个结果的承诺，`canDeactivate` 将等待它解析，以确定是否可以继续激活。
- en: 'We can actually shorten this, because the activator module will interpret the
    strings'' responses by checking them against a list of affirmations and responses
    that it considers to be true. This is the code Durandal uses to check activation
    results, taken from the activator module:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们可以缩短这个，因为激活器模块将通过检查它们与它认为为真的确认和响应列表来解释字符串的响应。这是Durandal用来检查激活结果的代码，取自激活器模块：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This array of `truthy` strings can be changed by accessing `activator.defaults.affirmations`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个由 `truthy` 字符串组成的数组可以通过访问 `activator.defaults.affirmations` 来更改。
- en: 'With this knowledge, we can just return the promise from the message box directly.
    The activator module will consider `Yes` to be a truthy result, and any other
    string to be `false`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们只需直接返回消息框的承诺。激活器模块将 `Yes` 视为真值结果，并将任何其他字符串视为 `false`：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Doesn't that look nice? You can see this in the `cp5-deactivate2` branch.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错吗？你可以在 `cp5-deactivate2` 分支中看到这一点。
- en: While these examples are short, hopefully, they give you an idea of what the
    activation life cycle is capable of, especially when combined with promises. Because
    promises can be chained, you could block deactivation when you go to the server
    to get some information, then display it to the user in a message box, and pass
    the result to the activator module.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些例子很短，但希望它们能给你一个关于激活生命周期能够做什么的思路，尤其是在与承诺结合使用时。因为承诺可以被链式调用，当你去服务器获取一些信息时，你可以阻止去激活，然后在消息框中向用户显示它，并将结果传递给激活模块。
- en: Composition
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: 'The composition life cycle has another set of events that can be hooked into,
    which allow you to control how the DOM is rendered, or respond to various stages
    of composition. Again, all of these are optional:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 组合生命周期还有另一组事件可以被钩入，这允许你控制DOM的渲染方式，或响应组合的各个阶段。同样，这些都是可选的：
- en: '`getView()`: This is a function that can return a view ID (path to a view file),
    or a DOM element. This overrides any other view location done by composition.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getView()`: 这是一个函数，可以返回一个视图ID（视图文件的路径），或一个DOM元素。这会覆盖由组合所做的任何其他视图位置。'
- en: '`viewUrl`: This is a string property of a view ID, to override view location.
    It will only be used if `getView` is not present.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewUrl`: 这是一个视图ID的字符串属性，用于覆盖视图位置。只有在`getView`不存在时才会使用。'
- en: '`activate()`: Just like activation''s `activate` method, this function will
    be called when composition begins. If the compose binding has an `activationData`
    method specified, it will be given to activate as a parameter. If a promise is
    returned, the composition will not continue until it resolves.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activate()`: 就像激活的`activate`方法一样，这个函数会在组合开始时被调用。如果组合绑定指定了`activationData`方法，它将被作为参数传递给激活。如果返回了一个承诺，则组合将不会继续，直到它解析。'
- en: '`binding(view)`: This is called before binding occurs. The view is passed to
    this function as a parameter. If binding returns `false` or `{ applyBindings:false
    }`, binding will not be done on the view.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding(view)`: 在绑定发生之前会被调用。视图作为参数传递给这个函数。如果绑定返回`false`或`{ applyBindings:false
    }`，则不会在视图中进行绑定。'
- en: '`bindingComplete(view)`: This is called when binding finishes. The view is
    passed as a parameter.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindingComplete(view)`: 当绑定完成时会被调用。视图作为参数传递。'
- en: '`attached(view, parent)`: This is called with the view and its parent DOM element
    after it is added to the DOM.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attached(view, parent)`: 在视图被添加到DOM后，会调用这个方法，传递视图及其父DOM元素。'
- en: '`compositionComplete(view, parent)`: This is called with the view and its parent
    DOM element after all composition, including the composition of child elements,
    has been completed.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compositionComplete(view, parent)`: 在所有组合完成之后，包括子元素的组合，会调用这个方法，传递视图及其父DOM元素。'
- en: '`detached(view, parent)`: This is called after the view has been removed from
    the DOM.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detached(view, parent)`: 在视图从DOM中移除后会被调用。'
- en: In the case of the combined activation and composition life cycles, such as
    the router's navigation, the activation module's `activate` method is the only
    one called.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合激活和组合生命周期的案例中，例如路由的导航，激活模块的`activate`方法是唯一被调用的。
- en: With the exception of binding, which can stop binding from occurring, the composition
    life cycle hooks do not offer the opportunity to control or cancel the process
    like the activation hooks do. Though it is generally discouraged in MVVM for the
    viewmodel to interact directly with the view, the composition life cycle is designed
    to make it easy to do so. Patterns should only be followed as long as they are
    helpful or possible, and if binding just can't get your work done, you may need
    to work with the DOM in your viewmodel.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除了绑定可以阻止绑定发生之外，组合生命周期钩子不提供像激活钩子那样的控制或取消过程的机会。尽管在MVVM中通常不建议viewmodel直接与视图交互，但组合生命周期被设计得使得这样做变得容易。应该只遵循那些有帮助或可能的模式，如果绑定无法完成你的工作，你可能需要在viewmodel中与DOM一起工作。
- en: Widgets
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件
- en: Widgets in Durandal are similar to Knockout components, in that they are viewmodel/view
    pairs that are instantiated from the DOM. Components use a custom element while
    widgets use a custom binding. There is definitely some overlap between them, but
    Durandal's widget system came before Knockout's component system. Widgets also
    have a killer feature over components; their views can have replaceable sections
    that can be overridden. This feature is commonly known as **transclusion**—the
    inclusion of one document inside another.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal中的小部件与Knockout组件类似，因为它们都是从DOM中实例化的viewmodel/view对。组件使用自定义元素，而小部件使用自定义绑定。它们之间肯定有一些重叠，但Durandal的小部件系统是在Knockout的组件系统之前出现的。小部件还有一个比组件更出色的特性；它们的视图可以有可替换的部分，可以被覆盖。这个特性通常被称为**转译**——一个文档嵌入到另一个文档中。
- en: It's difficult to talk about the widget API without using an example. When we
    looked at components, we made a contact list component; so let's see what it would
    look like doing the same thing with a widget. It may not be very reusable, making
    it an odd choice for a widget; but it will cover the whole process.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用示例很难谈论小部件API。当我们查看组件时，我们创建了一个联系人列表组件；那么让我们看看用小部件做同样的事情会是什么样子。它可能不是非常可重用，这使得它成为一个奇怪的小部件选择；但它将涵盖整个过程。
- en: Creating a new widget
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的小部件
- en: 'Durandal expects widgets to be located in a directory named `widgets`, at the
    root of your app, which, in our case, would be under `client/app/widgets`. Each
    widget will store its code in a folder, which will be used as the name of the
    widget. The code for a widget must be a JavaScript file named `viewmodel.js` and
    an HTML file named `view.html`. So to make our contacts list item widget, we will
    use the following structure:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal期望小部件位于一个名为`widgets`的目录中，该目录位于应用的根目录下，在我们的例子中，它位于`client/app/widgets`下。每个小部件将存储其代码在一个文件夹中，该文件夹将用作小部件的名称。小部件的代码必须是一个名为`viewmodel.js`的JavaScript文件和一个名为`view.html`的HTML文件。因此，为了制作我们的联系人列表小部件，我们将使用以下结构：
- en: '![Creating a new widget](img/00014.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个新的小部件](img/00014.jpeg)'
- en: 'For the view, we are just going to pull the whole list section out of the `list.html`
    view:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图，我们只是将从`list.html`视图中提取整个列表部分：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As we are going to be binding against a new viewmodel, I''ve changed the `foreach`
    binding from `displayContacts` to `contacts`. Our viewmodel is going to look very
    similar to our normal page viewmodels. Like pages instantiated by the router,
    our widget''s viewmodel won''t be able to receive construction parameters; data
    passed to the widget through the binding will be given to the `activate` function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要绑定到一个新的viewmodel，我已经将`foreach`绑定从`displayContacts`改为`contacts`。我们的viewmodel将非常类似于我们的正常页面viewmodel。像由路由器实例化的页面一样，我们的小部件viewmodel将无法接收构造参数；通过绑定传递给小部件的数据将传递给`activate`函数：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are passing in the data the view needs here, that is, the `contacts` array,
    and a callback for `edit` and `delete`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里传递了视图所需的数据，即`contacts`数组，以及`edit`和`delete`的回调函数。
- en: Using a widget
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用小部件
- en: 'Durandal provides several ways to use the widget. First, we have to activate
    the widget plugin in our `main.js` file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal提供了几种使用小部件的方法。首先，我们必须在`main.js`文件中激活小部件插件：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can use the widget binding to create the widget:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用小部件绑定来创建小部件：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'I don''t really like this though; it''s a little verbose. There are two ways
    to register the widget, which allow it to be used as if it was a binding itself:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不太喜欢这种方式；它有点冗长。有两种方式可以注册小部件，允许它像绑定一样使用：
- en: '[PRE42]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'I think this looks much nicer. To register a widget, you can either call `widget.registerKind(''contactList'')`,
    or modify the plugin configuration:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这看起来更美观。要注册小部件，你可以调用`widget.registerKind('contactList')`，或者修改插件配置：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: I personally prefer this last method; though if you have a lot of widgets, you
    might prefer one of the other methods. You can see this widget being used in the
    `cp5-widget` branch. The result looks identical to the previous version, but the
    list is now in a separate view.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人更喜欢这个最后的方法；尽管如果你有很多小部件，你可能更喜欢其他方法之一。你可以在`cp5-widget`分支中看到这个小部件的使用。结果看起来与上一个版本相同，但现在列表是在一个单独的视图中。
- en: Modifying widgets with data-part attributes
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据-part属性修改小部件
- en: So far, there isn't much to our widget. It doesn't add anything that a Knockout
    component couldn't have given us, and the components have the nicer looking custom
    element syntax going for them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的这个小部件并没有什么特别之处。它没有添加Knockout组件无法提供的内容，而且组件有更美观的定制元素语法。
- en: 'If you have an element in your widget''s view with a `data-part` attribute,
    then that element can be overridden by the caller. Let''s say, for example, that
    we wanted to be able to change the way the phone number was displayed. The first
    step is to add a `data-part` attribute to the widget:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的小部件视图中有一个带有 `data-part` 属性的元素，那么该元素可以被调用者覆盖。例如，如果我们想改变电话号码的显示方式，第一步是为小部件添加一个
    `data-part` 属性：
- en: '[PRE44]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The next step is to use the same `data-part` attribute in the caller:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在调用者中使用相同的 `data-part` 属性：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The result is the new `span` element that replaces the original small element
    inside the widget. You can see this in the `cp5-datapart` branch.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是新的 `span` 元素，它取代了小部件内部的原始元素。您可以在 `cp5-datapart` 分支中看到这一点。
- en: An important thing to notice here is that the new `span` element has a data
    binding that refers to a contact's `phoneNumber` property. The `data-part` attribute
    is overriding an element whose binding context is in the scope of the `foreach`
    loop of the widget, and this scope is maintained by the new element. The binding
    context of a `data-part` attribute, declared inside of a widget-bound element,
    is the binding context of the element it replaces.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要事项是，新的 `span` 元素有一个数据绑定，它引用了联系人的 `phoneNumber` 属性。`data-part` 属性覆盖了一个绑定上下文在
    widget 的 `foreach` 循环作用域内的元素，并且这个作用域由新元素维护。在 widget-bound 元素内部声明的 `data-part`
    属性的绑定上下文是它所替代元素的绑定上下文。
- en: 'The special `$root` property of a widget''s binding context is set to the declaring
    scope, which is especially handy for overriding `data-part` attributes. If we
    want to refer to properties on the list viewmodel, we can do so:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件绑定上下文的特殊 `$root` 属性设置为声明的作用域，这对于覆盖 `data-part` 属性特别有用。如果我们想引用列表视图模型上的属性，我们可以这样做：
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This assumes that the matching button in the widget view has the `data-part="edit-btn"`
    attribute added to it. This button now directly references the `editContact` function
    on the list viewmodel, instead of the one on the widget. You can see this in action
    in the `cp5-datapart2` branch.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设小部件视图中匹配的按钮添加了 `data-part="edit-btn"` 属性。现在，此按钮直接引用列表视图模型上的 `editContact`
    函数，而不是小部件上的函数。您可以在 `cp5-datapart2` 分支中看到这一操作。
- en: A widget can have any number of `data-part` attributes, and each `data-part`
    attribute can contain other `data-part` attributes. This allows maximum flexibility
    in controlling the appearance and functionality of templated widgets.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件可以有任意数量的 `data-part` 属性，并且每个 `data-part` 属性可以包含其他 `data-part` 属性。这允许在控制模板化小部件的外观和功能方面具有最大的灵活性。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: These are just the basics of using Durandal, but hopefully you can already appreciate
    the power and simplicity the framework provides. It frequently happens online
    that Knockout is compared to more complete frameworks such as Angular, and where
    it lacks components, such as a router, they are taken as points against it. Durandal
    stacks up much more evenly with these frameworks while it still takes advantage
    of all of the things that make Knockout great.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是使用 Durandal 的基础知识，但希望您已经能够欣赏到该框架提供的强大和简单性。在线上，Knockout 经常被与更完整的框架，如 Angular
    进行比较，并且当它缺少组件，如路由器时，这些被视为对其的批评。Durandal 与这些框架的对比更加均衡，同时它仍然利用了使 Knockout 变得出色的所有事物。
- en: In this chapter, you should have learned the composition system, as well as
    how the router brings organization and modularity to your application. We saw
    how promises combine with modal dialogs and the application life cycle to allow
    us to respond to asynchronous events easily and naturally. Finally, we saw how
    widgets can take the concepts behind Knockout components (reusable behavior-driven
    controls that are instantiated from the view markup) and add templated `data-part`
    attributes to achieve transclusion.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您应该已经学习了组合系统，以及路由器如何为您的应用程序带来组织和模块化。我们看到了承诺如何与模态对话框和应用程序生命周期结合，使我们能够轻松自然地响应异步事件。最后，我们看到了小部件如何将
    Knockout 组件背后的概念（可重用、行为驱动的控件，由视图标记实例化）以及添加模板化的 `data-part` 属性来实现转义。
- en: The next chapter will continue to explore how the Durandal framework simplifies
    Knockout application development.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续探讨 Durandal 框架如何简化 Knockout 应用程序开发。
