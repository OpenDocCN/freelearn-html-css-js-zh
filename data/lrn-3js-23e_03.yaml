- en: Chapter 3. Working with the Different Light Sources Available in Three.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 在Three.js中处理可用的不同灯光源
- en: 'In the first chapter, you learned about the basics of Three.js, and in the
    previous chapter, we looked a bit deeper at the most important parts of the scene:
    the geometries, meshes, and cameras. You might have noticed that we skipped lights
    in that chapter even though they make up an important part of every Three.js scene.
    Without lights, we won''t see anything rendered. Since Three.js contains a large
    number of lights, each of which has a specific use, we''ll use this whole chapter
    to explain the various details of the lights and prepare you for the next chapter
    on material usage.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，您学习了Three.js的基础知识，在前一章中，我们深入探讨了场景中最重要的一部分：几何体、网格和相机。您可能已经注意到，在那个章节中我们跳过了灯光，尽管它们是每个Three.js场景的重要组成部分。没有灯光，我们将看不到任何渲染的内容。由于Three.js包含大量具有特定用途的灯光，我们将用整个章节来解释灯光的各个细节，并为下一章关于材质的使用做准备。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebGL itself doesn't have inherent support for lighting. Without Three.js, you
    would have to write specific WebGL shader programs to simulate these kinds of
    lights. A good introduction on simulating lighting in WebGL from scratch can be
    found at [https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL](https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL本身并不支持内置的灯光。没有Three.js，您将不得不编写特定的WebGL着色器程序来模拟这些类型的灯光。有关从头开始模拟WebGL中灯光的详细介绍，请参阅[https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL](https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL)。
- en: 'In this chapter, you''ll learn about the following subjects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下主题：
- en: The light sources that are available in Three.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Three.js中可用的光源
- en: When a specific light source should be used
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该在何时使用特定的光源
- en: How you can tune and configure the behavior of all these light sources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何调整和配置所有这些光源的行为
- en: As a bonus, we'll also quickly look at how you can create lens flares
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为额外内容，我们还将快速查看如何创建镜头光晕
- en: As with all the chapters, we have a lot of examples that you can use to experiment
    with the lights' behavior. The examples shown in this chapter can be found in
    the `chapter-03` folder of the supplied sources.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有章节一样，我们提供了许多示例，您可以使用这些示例来实验灯光的行为。本章中展示的示例可以在提供的源代码的`chapter-03`文件夹中找到。
- en: Different kinds of lighting provided by Three.js
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Three.js提供的不同类型的灯光
- en: 'There are a number of different lights available in Three.js that all have
    specific behavior and usages. In this chapter, we''ll discuss the following set
    of lights:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中提供了多种不同的灯光，它们都具有特定的行为和用法。在本章中，我们将讨论以下一组灯光：
- en: '| Name | Description |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.AmbientLight` | This is a basic light, the color of which is added
    to the current color of the objects in the scene. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.AmbientLight` | 这是一种基本的光源，其颜色被添加到场景中对象的当前颜色上。|'
- en: '| `THREE.PointLight` | This is a single point in space from which light spreads
    in all directions. This light can''t be used to create shadows. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.PointLight` | 这是一个空间中的单一点，光从这个点向所有方向扩散。这种灯光不能用来创建阴影。|'
- en: '| `THREE.SpotLight` | This light source has a cone-like effect like that of
    a desk lamp, a spot in the ceiling, or a torch. This light can cast shadows. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.SpotLight` | 这种光源具有类似台灯、天花板上的点或火炬的锥形效果。这种灯光可以产生阴影。|'
- en: '| `THREE.DirectionalLight` | This is also called infinite light. The light
    rays from this light can be seen as parallel, like, for instance, the light from
    the sun. This light can also be used to create shadows. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.DirectionalLight` | 这也被称为无限光。从这个光源发出的光线看起来是平行的，例如，就像太阳的光线一样。这种灯光也可以用来创建阴影。|'
- en: '| `THREE.HemisphereLight` | This is a special light and can be used to create
    more natural-looking outdoors lighting by simulating a reflective surface and
    a faintly illuminating sky. This light also doesn''t provide any shadow-related
    functionality. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.HemisphereLight` | 这是一种特殊的光源，可以通过模拟反射表面和微弱照亮的蓝天来创建更自然的外观户外照明。这种灯光也不提供任何与阴影相关的功能。|'
- en: '| `THREE.AreaLight` | With this light source, instead of a single point in
    space, you can specify an area from which light emanates. `THREE.AreaLight` doesn''t
    cast any shadows. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.AreaLight` | 使用这种光源，您可以从一个区域指定光发出的位置，而不是空间中的一个单独点。`THREE.AreaLight`不会产生任何阴影。|'
- en: '| `THREE.LensFlare` | This is not a light source, but with `THREE.LensFlare`,
    you can add a lens flare effect to the lights in your scene. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LensFlare` | 这不是一个光源，但使用 `THREE.LensFlare`，您可以为场景中的灯光添加镜头光晕效果。|'
- en: 'This chapter is divided into two main parts. First, we''ll look at the basic
    lights: `THREE.AmbientLight`, `THREE.PointLight`, `THREE.SpotLight`, and `THREE.DirectionalLight`.
    All these lights extend the base `THREE.Light` object, which provides shared functionality.
    The lights mentioned here are simple lights that require little setting up and
    can be used to recreate most of the required lighting scenarios. In the second
    part, we will look at a couple of special-purpose lights and effects: `THREE.HemisphereLight`,
    `THREE.AreaLight`, and `THREE.LensFlare`. You''ll probably only need these lights
    in very specific cases.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个主要部分。首先，我们将查看基本灯光：`THREE.AmbientLight`、`THREE.PointLight`、`THREE.SpotLight`
    和 `THREE.DirectionalLight`。所有这些灯光都扩展了基本的 `THREE.Light` 对象，它提供了共享的功能。这里提到的灯光是简单的灯光，设置起来相对简单，可以用来重现大多数所需的照明场景。在第二部分，我们将查看一些特殊用途的灯光和效果：`THREE.HemisphereLight`、`THREE.AreaLight`
    和 `THREE.LensFlare`。您可能只有在非常特定的情况下才需要这些灯光。
- en: Basic lights
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本灯光
- en: 'We''ll start with the most basic of the lights: `THREE.AmbientLight`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最基本的灯光 `THREE.AmbientLight` 开始。
- en: THREE.AmbientLight
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.AmbientLight
- en: When you create `THREE.AmbientLight`, the color is applied globally. There isn't
    a specific direction this light comes from, and `THREE.AmbientLight` doesn't contribute
    to any shadows. You would normally not use `THREE.AmbientLight` as the single
    source of light in a scene since it colors all the objects in the same color,
    regardless of shape. You use it together with other lighting sources, such as
    `THREE.SpotLight` or `THREE.DirectionalLight` to soften the shadows or add some
    additional color to the scene. The easiest way to understand this is by looking
    at the `01-ambient-light.html` example in the `chapter-03` folder. With this example,
    you get a simple user interface that can be used to modify `THREE.AmbientLight`
    that is available in this scene. Note that in this scene, we also have `THREE.SpotLight`,
    which adds additional lighting and provides shadows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建 `THREE.AmbientLight` 时，颜色是全局应用的。这种光没有特定的方向，`THREE.AmbientLight` 不会产生任何阴影。通常您不会将
    `THREE.AmbientLight` 作为场景中唯一的灯光源，因为它会使所有物体着色为相同的颜色，而不管形状如何。您通常将它与其他灯光源一起使用，例如
    `THREE.SpotLight` 或 `THREE.DirectionalLight`，以柔化阴影或为场景添加一些额外的颜色。理解这一点最简单的方法是查看
    `chapter-03` 文件夹中的 `01-ambient-light.html` 示例。在这个示例中，您会得到一个简单的用户界面，可以用来修改场景中可用的
    `THREE.AmbientLight`。请注意，在这个场景中，我们还有 `THREE.SpotLight`，它提供了额外的照明并产生阴影。
- en: 'In the following screenshot, you can see that we used the scene from the first
    chapter and made the color of `THREE.AmbientLight` configurable. In this example,
    you can also turn off the spotlight to see what the effect of `THREE.AmbientLight`
    is on its own:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到我们使用了第一章的场景，并使 `THREE.AmbientLight` 的颜色可配置。在这个示例中，您还可以关闭聚光灯以查看
    `THREE.AmbientLight` 单独的效果：
- en: '![THREE.AmbientLight](img/2215OS_03_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.AmbientLight](img/2215OS_03_01.jpg)'
- en: The standard color we use in this scene is `#0c0c0c`. This is a hexadecimal
    representation of a color. The first two values specify the red part of the color,
    the next two values specify the green part, and the last two values specify the
    blue part.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们使用的标准颜色是 `#0c0c0c`。这是颜色的十六进制表示。前两个值指定颜色的红色部分，接下来的两个值指定绿色部分，最后的两个值指定蓝色部分。
- en: 'In this example, we use a very dimmed light-gray color that we mainly use to
    smoothen the hard shadows our meshes cast to the ground plane. You can change
    the color to a more prominent yellow/orange color (`#523318`) with the menu in
    the top-right corner, and then the objects will have a sun-like glow over them.
    This is shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用了一种非常暗淡的灰色，我们主要用它来平滑我们的网格投射到地面上的硬阴影。您可以通过右上角的菜单将颜色更改为更鲜明的黄色/橙色（`#523318`），然后物体上就会产生类似太阳的光晕。这在上面的屏幕截图中可以显示：
- en: '![THREE.AmbientLight](img/2215OS_03_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.AmbientLight](img/2215OS_03_02.jpg)'
- en: As the preceding image shows, the yellow/orange color is applied to all the
    objects and casts a green glow over the complete scene. What you should remember
    when working with this light is that you should be very conservative with the
    color you specify. If the color you specify is too bright, you'll quickly get
    a completely oversaturated image.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，黄色/橙色应用于所有对象，并在整个场景上投射出绿色光芒。当你使用这种光源时，你应该记住，你应该非常谨慎地指定颜色。如果你指定的颜色太亮，你很快就会得到一个完全过饱和的图像。
- en: 'Now that we''ve seen what it does, let''s look at how you can create and use
    `THREE.AmbientLight`. The next couple of lines of code show you how to create
    `THREE.AmbientLight` and also show how to connect this to the GUI control menu,
    which we will introduce in [Chapter 11](ch11.html "Chapter 11. Custom Shaders
    and Render Postprocessing"), *Custom Shaders and Render Post Processing*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了它的工作原理，让我们看看如何创建和使用 `THREE.AmbientLight`。接下来的几行代码展示了如何创建 `THREE.AmbientLight`，同时也展示了如何将其连接到
    GUI 控制菜单，我们将在第 11 章（[Chapter 11](ch11.html "Chapter 11. Custom Shaders and Render
    Postprocessing")）*自定义着色器和渲染后处理*中介绍：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Creating `THREE.AmbientLight` is very simple and only takes a couple of steps.
    `THREE.AmbientLight` doesn''t have a position and is applied globally, so we only
    need to specify the color (in hex), `new THREE.AmbientLight(ambiColor)`, and add
    this light to the scene, `scene.add(ambientLight)`. In the example, we bind the
    color of `THREE.AmbientLight` to the control menu. To do this, you can use the
    same kind of configuration we used in the previous two chapters. The only change
    is that instead of using the `gui.add(...)` function, we use the `gui.addColor(...)`
    function. This creates an option in the control menu, with which we can directly
    change the color of the passed-in variable. In the code, you can see that we use
    the `onChange` feature of dat.GUI: `gui.addColor(...).onChange(function(e){...})`.
    With this function, we tell `dat.GUI` to call the passed-in function each time
    the color changes. In this specific case, we set the color of `THREE.AmbientLight`
    to a new value.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `THREE.AmbientLight` 非常简单，只需几个步骤。`THREE.AmbientLight` 没有位置，是全局应用的，所以我们只需要指定颜色（十六进制），`new
    THREE.AmbientLight(ambiColor)`，并将此光源添加到场景中，`scene.add(ambientLight)`。在示例中，我们将
    `THREE.AmbientLight` 的颜色绑定到控制菜单。为此，你可以使用我们在前两章中使用过的相同类型的配置。唯一的变化是，我们不是使用 `gui.add(...)`
    函数，而是使用 `gui.addColor(...)` 函数。这会在控制菜单中创建一个选项，我们可以直接更改传入变量的颜色。在代码中，你可以看到我们使用了
    dat.GUI 的 `onChange` 功能：`gui.addColor(...).onChange(function(e){...})`。使用这个函数，我们告诉
    `dat.GUI` 每次颜色改变时调用传入的函数。在这个特定的情况下，我们将 `THREE.AmbientLight` 的颜色设置为新的值。
- en: Using the THREE.Color object
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 THREE.Color 对象
- en: 'Before we move on to the next light, here''s a quick note on using the `THREE.Color`
    object. In Three.js, when you construct an object, you can (usually) specify the
    color as either a hex string (`"#0c0c0c"`) or a hex value (`0x0c0c0c`), which
    is the preferred way of doing it, or by specifying the individual RGB values (`0.3`,
    `0.5`, `0.6`) on a scale of 0 to 1\. If you want to change the color after construction,
    you''ll have to create a new `THREE.Color` object or modify the internal properties
    of the current `THREE.Color` object. The `THREE.Color` object comes with the following
    functions to set and get information about the current object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到下一个光源之前，这里有一个关于使用 `THREE.Color` 对象的简要说明。在 Three.js 中，当你构建一个对象时，你可以（通常）指定颜色为十六进制字符串（`"#0c0c0c"`）或十六进制值（`0x0c0c0c`），这是首选的方法，或者通过指定
    0 到 1 比例上的单个 RGB 值（`0.3`, `0.5`, `0.6`）。如果你想在构建后更改颜色，你必须创建一个新的 `THREE.Color` 对象或修改当前
    `THREE.Color` 对象的内部属性。`THREE.Color` 对象包含以下函数来设置和获取当前对象的信息：
- en: '| Name | Description |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `set(value)` | Set the value of this color to the supplied hex value. This
    hex value may be a string, a number, or an existing `THREE.Color` instance. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `set(value)` | 将此颜色的值设置为提供的十六进制值。此十六进制值可以是字符串、数字或现有的 `THREE.Color` 实例。|'
- en: '| `setHex(value)` | Set the value of this color to the supplied numeric hex
    value. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `setHex(value)` | 将此颜色的值设置为提供的数值十六进制值。|'
- en: '| `setRGB(r,g,b)` | Set the value of this color based on the supplied RGB values.
    The values range from 0 to 1. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `setRGB(r,g,b)` | 根据提供的 RGB 值设置此颜色的值。值的范围从 0 到 1。|'
- en: '| `setHSL(h,s,l)` | Set the value of this color on the supplied HSL values.
    The values range from 0 to 1\. A good explanation of how HSL works for configuring
    colors can be found at [http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL](http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL).
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `setHSL(h,s,l)` | 根据提供的HSL值设置此颜色的值。值范围从0到1。有关如何使用HSL配置颜色的良好解释，请参阅[http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL](http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL)。
    |'
- en: '| `setStyle(style)` | Set the value of this color based on the CSS way of specifying
    colors. For instance, you could use `"rgb(255,0,0)"`, `"#ff0000"`, `"#f00"`, or
    even `"red"`. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `setStyle(style)` | 根据CSS指定颜色的方式设置此颜色的值。例如，您可以使用`"rgb(255,0,0)"`、`"#ff0000"`、`"#f00"`或甚至是`"red"`。
    |'
- en: '| `copy(color)` | Copy the color values from the `THREE.Color` instance provided
    to this color. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `copy(color)` | 从提供的`THREE.Color`实例复制颜色值到这个颜色。 |'
- en: '| `copyGammaToLinear(color)` | This is mostly used internally.Set the color
    of this object based on the `THREE.Color` instance supplied. The color is first
    converted from the gamma color space to the linear color space. The gamma color
    space also uses RGB values, but uses an exponential scale instead of a linear
    one. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `copyGammaToLinear(color)` | 这主要在内部使用。根据提供的`THREE.Color`实例设置此对象的颜色。颜色首先从伽马颜色空间转换为线性颜色空间。伽马颜色空间也使用RGB值，但使用指数刻度而不是线性刻度。
    |'
- en: '| `copyLinearToGamma(color)` | This is mostly used internally.Set the color
    of this object based on the `THREE.Color` instance supplied. The color is first
    converted from the linear color space to the gamma color space. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `copyLinearToGamma(color)` | 这主要在内部使用。根据提供的`THREE.Color`实例设置此对象的颜色。颜色首先从线性颜色空间转换为伽马颜色空间。
    |'
- en: '| `convertGammaToLinear()` | This converts the current color from the gamma
    color space to the linear color space. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `convertGammaToLinear()` | 这将当前颜色从伽马颜色空间转换为线性颜色空间。 |'
- en: '| `convertLinearToGamma()` | This converts the current color from the linear
    color space to the gamma color space. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `convertLinearToGamma()` | 这将当前颜色从线性颜色空间转换为伽马颜色空间。 |'
- en: '| `getHex()` | Return the value from this color object as a number: `435241`.
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `getHex()` | 返回此颜色对象作为数字: `435241`。 |'
- en: '| `getHexString()` | Return the value from this color object as a hex string:
    `"0c0c0c"`. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `getHexString()` | 返回此颜色对象作为十六进制字符串: `"0c0c0c"`。 |'
- en: '| `getStyle()` | Return the value from this color object as a CSS-based value:
    `"rgb(112,0,0)"`. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `getStyle()` | 返回此颜色对象作为基于CSS的值: `"rgb(112,0,0)"`. |'
- en: '| `getHSL(optionalTarget)` | Return the value from this color object as a HSL
    value. If you provide the `optionalTarget` object, Three.js will set the `h`,
    `s`, and `l` properties on that object. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `getHSL(optionalTarget)` | 返回此颜色对象作为HSL值。如果您提供`optionalTarget`对象，Three.js将设置该对象的`h`、`s`和`l`属性。
    |'
- en: '| `offsetHSL(h, s, l)` | Add the `h`, `s`, and `l` values provided to the `h`,
    `s`, and `l` values of the current color. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `offsetHSL(h, s, l)` | 将提供的`h`、`s`和`l`值添加到当前颜色的`h`、`s`和`l`值。 |'
- en: '| `add(color)` | This adds the `r`, `g`, and `b` values of the color supplied
    to the current color. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `add(color)` | 这将提供的颜色的`r`、`g`和`b`值添加到当前颜色。 |'
- en: '| `addColors(color1, color2)` | This is mostly used internally.Add `color1`
    and `color2`, and set the value of the current color to the result. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `addColors(color1, color2)` | 这主要在内部使用。将`color1`和`color2`相加，并将当前颜色的值设置为结果。
    |'
- en: '| `addScalar(s)` | This is mostly used internally.Add a value to the RGB components
    of the current color. Bear in mind that the internal values use a range from 0
    to 1. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `addScalar(s)` | 这主要在内部使用。向当前颜色的RGB组件添加一个值。请注意，内部值使用从0到1的范围。 |'
- en: '| `multiply(color)` | This is mostly used internally.Multiply the current RGB
    values with the RGB values from `THREE.Color`. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `multiply(color)` | 这主要在内部使用。将当前RGB值与`THREE.Color`的RGB值相乘。 |'
- en: '| `multiplyScalar(s)` | This is mostly used internally.This multiplies the
    current RGB values with the value supplied. Bear in mind that the internal values
    use a range from 0 to 1. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `multiplyScalar(s)` | 这主要在内部使用。这会将当前RGB值与提供的值相乘。请注意，内部值使用从0到1的范围。 |'
- en: '| `lerp(color, alpha)` | This is mostly used internally.This finds the color
    that is between the color of this object and the color supplied. The alpha property
    defines how far between the current color and the supplied color you want the
    result to be. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `lerp(color, alpha)` | 这主要在内部使用。这找到位于此对象颜色和提供的颜色之间的颜色。alpha属性定义了结果颜色在当前颜色和提供的颜色之间的距离。
    |'
- en: '| `equals(color)` | This returns `true` if the RGB values of the `THREE.Color`
    instance supplied match the values of the current color. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `equals(color)` | 如果提供的 `THREE.Color` 实例的 RGB 值与当前颜色的值匹配，则返回 `true`。 |'
- en: '| `fromArray(array)` | This has the same functionality as `setRGB`, but now
    the RGB values can be provided as an array of numbers. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `fromArray(array)` | 这与 `setRGB` 有相同的功能，但现在 RGB 值可以作为数字数组提供。 |'
- en: '| `toArray` | This returns an array with three elements, `[r, g, b]`. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `toArray` | 这返回一个包含三个元素的数组，`[r, g, b]`。 |'
- en: '| `clone()` | This creates an exact copy of this color. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `clone()` | 这将创建这个颜色的精确副本。 |'
- en: In this table, you can see that there are many ways in which you can change
    the current color. A lot of these functions are used internally by Three.js, but
    they also provide a good way to easily change the color of lights and materials.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，你可以看到有很多方法可以改变当前的颜色。许多这些函数都是 Three.js 内部使用的，但它们也提供了一个很好的方法来轻松地改变灯光和材料颜色。
- en: 'Before we move on to the discussion on `THREE.PointLight`, `THREE.SpotLight`,
    and `THREE.DirectionalLight`, let''s first highlight their main difference, that
    is, how they emit light. The following diagram shows how these three light sources
    emit light:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论 `THREE.PointLight`、`THREE.SpotLight` 和 `THREE.DirectionalLight` 之前，让我们首先强调它们的主要区别，即它们如何发射光线。以下图表显示了这三个光源如何发射光线：
- en: '![Using the THREE.Color object](img/2215OS_03_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用THREE.Color对象](img/2215OS_03_03.jpg)'
- en: 'You can see the following from this diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图表中你可以看到以下内容：
- en: '`THREE.PointLight` emits light from a specific point in all directions'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.PointLight` 从一个特定的点向所有方向发射光线'
- en: '`THREE.SpotLight` emits light from a specific point in a cone-like shape'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.SpotLight` 从一个特定的点以锥形形状发射光线'
- en: '`THREE.DirectionalLight` doesn''t emit light from a single point, but emits
    light rays from a 2D plane, where the rays are parallel to each other'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.DirectionalLight` 不从一个单一点发射光线，而是从二维平面发射光线，其中光线是平行的。'
- en: We'll look at these light sources in more detail in the next couple of paragraphs;
    let's start with `THREE.Pointlight`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几段中更详细地查看这些光源；让我们从 `THREE.Pointlight` 开始。
- en: THREE.PointLight
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.PointLight
- en: '`THREE.PointLight` in Three.js is a light source that shines light in all directions
    emanating from a single point. A good example of a point light is a signal flare
    fired in the night sky. Just as with all the lights, we have a specific example
    you can use to play around with `THREE.PointLight`. If you look at `02-point-light.html`
    in the `chapter-03` folder, you can find an example where a `THREE.PointLight`
    light is moving around a simple Three.js scene. The following screenshot shows
    an example of this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 中，`THREE.PointLight` 是一个从单个点向所有方向发射光线的光源。一个点光源的好例子是在夜空中发射的信号弹。就像所有的灯光一样，我们有一个特定的例子你可以用来玩
    `THREE.PointLight`。如果你查看 `chapter-03` 文件夹中的 `02-point-light.html`，你可以找到一个例子，其中
    `THREE.PointLight` 灯光在一个简单的 Three.js 场景中移动。以下截图显示了此示例：
- en: '![THREE.PointLight](img/2215OS_03_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.PointLight](img/2215OS_03_04.jpg)'
- en: In this example, `THREE.PointLight` moves around the scene we already saw in
    [Chapter 1](ch01.html "Chapter 1. Creating Your First 3D Scene with Three.js"),
    *Create Your First 3D Scene with Three.js*. To make it more clear where `THREE.PointLight`
    is, we move a small orange sphere along the same path. As this light moves around,
    you'll see the red cube and blue sphere being illuminated by this light on different
    sides.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`THREE.PointLight` 在我们已经在 [第1章](ch01.html "第1章. 使用Three.js创建您的第一个3D场景")
    中看到的场景中移动，*使用Three.js创建您的第一个3D场景*。为了更清楚地显示 `THREE.PointLight` 的位置，我们沿着相同的路径移动一个小橙色球体。随着这个光移动，你会看到红色立方体和蓝色球体从不同的侧面被这个光照亮。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You might notice that we don't see any shadows in this example. In Three.js,
    `THREE.PointLight` doesn't cast shadows. Since `THREE.PointLight` emits light
    in all directions, calculating shadows is a very heavy process for the GPU.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到在这个例子中我们没有看到任何阴影。在Three.js中，`THREE.PointLight` 不投射阴影。由于 `THREE.PointLight`
    向所有方向发射光线，计算阴影对于GPU来说是一个非常繁重的过程。
- en: 'With the `THREE.AmbientLight` we saw earlier, all you had to do was provide
    `THREE.Color` and add the light to the scene. With `THREE.PointLight`, however,
    we have a couple of additional configuration options:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前看到的 `THREE.AmbientLight`，你只需要提供 `THREE.Color` 并将灯光添加到场景中。然而，对于 `THREE.PointLight`，我们有一些额外的配置选项：
- en: '| Property | Description |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This is the color of the light. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是光的颜色。 |'
- en: '| `distance` | This is the distance for which the light shines. The default
    value is `0`, which means that the light''s intensity doesn''t decrease based
    on distance. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `distance` | 这是灯光照射的距离。默认值是 `0`，这意味着灯光的强度不会根据距离而减弱。 |'
- en: '| `intensity` | This is the intensity the light shines with. This defaults
    to `1`. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `intensity` | 这是灯光的照射强度。默认值为 `1`。 |'
- en: '| `position` | This is the position of the light in `THREE.Scene`. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 这是灯光在 `THREE.Scene` 中的位置。 |'
- en: '| `visible` | If this property is set to `true` (the default), this light is
    turned on, and if set it to `false`, the light is turned off. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `visible` | 如果此属性设置为 `true`（默认值），则此灯光开启；如果设置为 `false`，则灯光关闭。 |'
- en: 'In the next couple of examples and screenshots, we''ll explain these properties.
    First, let''s look at how you can create `THREE.PointLight`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个示例和屏幕截图中，我们将解释这些属性。首先，让我们看看如何创建 `THREE.PointLight`：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We create a light with a specific `color` property (here we use a string value;
    we could have also used a number or `THREE.Color`), set its `position` property,
    and add it to the scene.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个具有特定 `color` 属性的灯光（这里我们使用字符串值；我们也可以使用数字或 `THREE.Color`），设置其 `position`
    属性，并将其添加到场景中。
- en: 'The first property we''ll look at is `intensity`. With this property, you can
    set how brightly the light shines. If you set this to `0`, you won''t see anything;
    set it to `1`, and you''ve got the default brightness; set it to `2`, and you
    get a light that shines twice as bright; and so on. In the following screenshot,
    for instance, we set the intensity of the light to `2.4`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看 `intensity` 属性。使用此属性，你可以设置灯光的亮度。如果你将其设置为 `0`，你将看不到任何东西；设置为 `1`，则获得默认亮度；设置为
    `2`，则获得亮度加倍的光；依此类推。例如，在下面的屏幕截图中，我们将灯光的强度设置为 `2.4`：
- en: '![THREE.PointLight](img/2215OS_03_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.PointLight](img/2215OS_03_05.jpg)'
- en: 'All you have to do to change the intensity of the light is use the intensity
    property of `THREE.PointLight`, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改灯光的强度，你只需使用 `THREE.PointLight` 的强度属性，如下所示：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or you can use the dat.GUI listener, like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 dat.GUI 监听器，如下所示：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `distance` property of `PointLight` is a very interesting one and is best
    explained with an example. In the following screenshot, you see the same scene
    again, but this time with a very high `intensity` property (we have a very bright
    light), but with a small `distance`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`PointLight` 的 `distance` 属性非常有趣，最好通过一个例子来解释。在下面的屏幕截图中，你再次看到了相同的场景，但这次具有非常高的
    `intensity` 属性（我们有一个非常明亮的灯光），但 `distance` 很小：'
- en: '![THREE.PointLight](img/2215OS_03_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.PointLight](img/2215OS_03_06.jpg)'
- en: 'The `distance` property of `SpotLight` determines how far the light travels
    from the source before its intensity property is 0\. You can set this property
    like this: `pointLight.distance = 14`. In the preceding screenshot, the light''s
    brightness slowly decreases to `0` at a distance of `14`. That''s why, in the
    example, you can still see a brightly lit cube, but the light won''t reach the
    blue sphere. The default value for the `distance` property is `0`, which means
    that the light won''t decay over a distance.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpotLight` 的 `distance` 属性决定了灯光从光源出发到其强度属性变为 0 的距离。你可以这样设置此属性：`pointLight.distance
    = 14`。在先前的屏幕截图中，灯光的亮度在距离 `14` 处逐渐减弱到 `0`。这就是为什么在示例中，你仍然可以看到一个明亮的立方体，但灯光不会达到蓝色球体。`distance`
    属性的默认值是 `0`，这意味着灯光不会随距离衰减。'
- en: THREE.SpotLight
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.SpotLight
- en: '`THREE.SpotLight` is one of the lights you''ll use most often (especially if
    you want to use shadows). `THREE.SpotLight` is a light source that has a cone-like
    effect. You can compare this with a flashlight or a lantern. This light has a
    direction and an angle at which it produces light. The following table lists all
    the properties that apply to `THREE.SpotLight`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.SpotLight` 是你将最常使用的灯光之一（尤其是如果你想使用阴影）。`THREE.SpotLight` 是一种具有锥形效果的灯光源。你可以将其与手电筒或灯笼进行比较。这种灯光有一个方向和一个产生光线的角度。以下表格列出了所有适用于
    `THREE.SpotLight` 的属性：'
- en: '| Property | Description |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `angle` | This determines how wide the beam emerging from this light is.
    This is measured in radians and defaults to `Math.PI/3`. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `angle` | 这决定了从该光源发出的光束有多宽。这个值以弧度为单位测量，默认为 `Math.PI/3`。 |'
- en: '| `castShadow` | If set to `true`, this light will cast shadows. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `castShadow` | 如果设置为 `true`，则此灯光将产生阴影。 |'
- en: '| `color` | This is the color of the light. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是灯光的颜色。 |'
- en: '| `distance` | This is the distance up to which the light shines. The default
    value is `0`, which means that the light''s intensity doesn''t decrease based
    on distance. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `distance` | 这是光线照射的距离。默认值为 `0`，这意味着光强度不会根据距离而降低。 |'
- en: '| `exponent` | With `THREE.SpotLight`, the emitted light''s intensity decreases
    the further away you are from the source. The `exponent` property determines how
    quickly this intensity decreases. With a low value, the light emitted from this
    source will reach faraway objects, while with a high value, it will only reach
    objects that are very near to `THREE.SpotLight`. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `exponent` | 在 `THREE.SpotLight` 中，发出的光强度随着你与光源距离的增加而降低。`exponent` 属性决定了这种强度降低的速度。低值时，从这个光源发出的光会照射到远处的物体，而高值时，只会照射到非常靠近
    `THREE.SpotLight` 的物体。 |'
- en: '| `intensity` | This is the intensity the light shines with. This defaults
    to 1. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `intensity` | 这是光线照射的强度。默认值为 1。 |'
- en: '| `onlyShadow` | If this property is set to `true`, this light will only cast
    a shadow and won''t add any light to the scene. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `onlyShadow` | 如果此属性设置为 `true`，则此光线只会投射阴影，而不会向场景添加任何光线。 |'
- en: '| `position` | This is the position of the light in `THREE.Scene`. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 这是光线在 `THREE.Scene` 中的位置。 |'
- en: '| `shadowBias` | The shadow bias moves the cast shadow away or towards the
    object casting the shadow. You can use this to solve some strange effects when
    you work with very thin objects (a good example can be found at [http://www.3dbuzz.com/training/view/unity-fundamentals/lights/8-shadows-bias](http://www.3dbuzz.com/training/view/unity-fundamentals/lights/8-shadows-bias)).
    If you see strange shadow effects, small values (for example, `0.01`) for this
    property can often resolve the issue. The default value for this property is `0`.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `shadowBias` | 阴影偏移将投射阴影的物体移动到远离或靠近物体的位置。你可以使用此功能来解决处理非常薄的对象时的一些奇怪效果（一个很好的例子可以在
    [http://www.3dbuzz.com/training/view/unity-fundamentals/lights/8-shadows-bias](http://www.3dbuzz.com/training/view/unity-fundamentals/lights/8-shadows-bias)
    找到）。如果你看到奇怪的阴影效果，此属性的较小值（例如，`0.01`）通常可以解决这个问题。此属性的默认值为 `0`。 |'
- en: '| `shadowCameraFar` | This determines what distance from the light shadows
    should be created. The default value is `5,000`. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `shadowCameraFar` | 这决定了从光源到创建阴影的距离。默认值为 `5,000`。 |'
- en: '| `shadowCameraFov` | This determines how large the field of view used to create
    shadows is (see the *Different cameras for different uses* section in [Chapter
    2](ch02.html "Chapter 2. Basic Components That Make Up a Three.js Scene"), *Basic
    Components That Make Up a Three.js Scene*). The default value is `50`. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `shadowCameraFov` | 这决定了用于创建阴影的视野大小（请参阅 [第 2 章](ch02.html "第 2 章。构成 Three.js
    场景的基本组件") 中 *不同用途的不同相机* 小节，*构成 Three.js 场景的基本组件*）。默认值为 `50`。 |'
- en: '| `shadowCameraNear` | This determines what distance from the light shadows
    should be created. The default value is `50`. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `shadowCameraNear` | 这决定了从光源到创建阴影的距离。默认值为 `50`。 |'
- en: '| `shadowCameraVisible` | If this is set to `true`, you can see how and where
    this light source casts a shadow (see the example in the next section). The default
    value is `false`. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `shadowCameraVisible` | 如果此设置为 `true`，你可以看到光源如何以及在哪里投射阴影（请参阅下一节中的示例）。默认值为
    `false`。 |'
- en: '| `shadowDarkness` | This defines how dark the shadow is rendered. This can''t
    be changed after the scene is rendered. The default value is `0.5`. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `shadowDarkness` | 这定义了阴影渲染的暗度。渲染场景后，此值不能更改。默认值为 `0.5`。 |'
- en: '| `shadowMapWidth` and `shadowMapHeight` | This determines how many pixels
    are used to create the shadow. Increase this when the shadow has jagged edges
    or doesn''t look smooth. This can''t be changed after the scene is rendered. The
    default value for both is `512`. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `shadowMapWidth` 和 `shadowMapHeight` | 这决定了用于创建阴影的像素数量。当阴影边缘参差不齐或看起来不光滑时，请增加此值。渲染场景后，此值不能更改。两者的默认值均为
    `512`。 |'
- en: '| `target` | With `THREE.SpotLight`, the direction it is pointed in is important.
    With the `target` property, you can point `THREE.SpotLight` to look at a specific
    object or position in the scene. Note that this property requires a `THREE.Object3D`
    object (like `THREE.Mesh`). This is in contrast to the cameras we saw in the previous
    chapter that use `THREE.Vector3` in their `lookAt` function. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `target` | 在 `THREE.SpotLight` 中，其指向的方向很重要。使用 `target` 属性，你可以将 `THREE.SpotLight`
    指向场景中的特定对象或位置。请注意，此属性需要一个 `THREE.Object3D` 对象（如 `THREE.Mesh`）。这与我们在上一章中看到的相机形成对比，这些相机在其
    `lookAt` 函数中使用 `THREE.Vector3`。 |'
- en: '| `visible` | If this is set to `true` (the default), this light is turned
    on, and if this is set to `false`, the light is turned off. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `visible` | 如果设置为 `true`（默认值），则此灯光开启；如果设置为 `false`，则灯光关闭。|'
- en: 'Creating `THREE.SpotLight` is very easy. Just specify the color, set the properties
    you want, and add it to the scene, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `THREE.SpotLight` 非常简单。只需指定颜色，设置你想要的属性，并将其添加到场景中，如下所示：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`THREE.SpotLight` is not very different from `THREE.PointLight`. The only difference
    is that we set the `castShadow` property to `true` because we want shadows, and
    we need to set the `target` property for this `SpotLight`. The `target` property
    determines where the light is aimed at. In this case, we point it at the object
    named `plane`. When you run the example (`03-spot-light.html`), you''ll see a
    scene like the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.SpotLight` 与 `THREE.PointLight` 并没有太大的区别。唯一的区别在于我们将 `castShadow` 属性设置为
    `true`，因为我们想要阴影，并且需要为这个 `SpotLight` 设置 `target` 属性。`target` 属性决定了光线指向的位置。在这种情况下，我们将它指向名为
    `plane` 的对象。当你运行示例（`03-spot-light.html`）时，你会看到一个类似于以下截图的场景：'
- en: '![THREE.SpotLight](img/2215OS_03_07.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.SpotLight](img/2215OS_03_07.jpg)'
- en: 'In this example, you can set a number of properties specific to `THREE.SpotLight`.
    One of them is the `target` property. If we set this property to the blue sphere,
    the light will focus at the center of the sphere even if it moves around the scene.
    When we created the light, we aimed it at the ground plane, and in our example,
    we can also aim it at the other two objects. But what if you don''t want to aim
    the light at a specific object, but rather at an arbitrary point in space? You
    can do that by creating a `THREE.Object3D()` object like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以设置一些特定于 `THREE.SpotLight` 的属性。其中之一是 `target` 属性。如果我们把这个属性设置为蓝色球体，即使它在场景中移动，光线也会聚焦在球体的中心。当我们创建灯光时，我们将其指向地面平面，在我们的例子中，我们也可以将其指向其他两个对象。但如果你不想将灯光指向特定的对象，而是指向空间中的任意一点，你可以通过创建一个
    `THREE.Object3D()` 对象来实现这一点：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, set the target property of `THREE.SpotLight`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置 `THREE.SpotLight` 的目标属性：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the table at the beginning of this section, we showed a couple of properties
    that can be used to control how the light emanates from `THREE.SpotLight`. The
    `distance` and `angle` properties define the shape of the cone of light. The `angle`
    property defines the width of the cone, and with the `distance` property, we set
    the length of the cone. The following figure explains how these two values together
    define the area that will receive light from `THREE.SpotLight`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节开头的表格中，我们展示了一些可以用来控制 `THREE.SpotLight` 发光方式的属性。`distance` 和 `angle` 属性定义了光锥的形状。`angle`
    属性定义了锥体的宽度，而 `distance` 属性则设置了锥体的长度。以下图解说明了这两个值如何共同定义将从 `THREE.SpotLight` 接收光线的区域：
- en: '![THREE.SpotLight](img/2215OS_03_08.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.SpotLight](img/2215OS_03_08.jpg)'
- en: 'Usually, you won''t really need to set these values since they come with reasonable
    defaults, but you can use these properties, for instance, to create a `THREE.SpotLight`
    that has a very narrow beam or quickly decreases in light intensity. The last
    property you can use to change the way `THREE.SpotLight` produces light is the
    `exponent` property. With this property, you set how fast the light intensity
    decreases from the center of the light cone towards the edges of the cone. In
    the following image, you can see the result of the `exponent` property in action.
    We have a very bright light (high `intensity`) that rapidly decreases in intensity
    (high `exponent`) as it moves from the center towards the sides of the cone:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你并不真的需要设置这些值，因为它们有合理的默认值，但你可以使用这些属性，例如，创建一个具有非常窄光束或快速降低光强度的 `THREE.SpotLight`。你可以用来改变
    `THREE.SpotLight` 发光方式的最后一个属性是 `exponent` 属性。使用这个属性，你可以设置从光锥中心到边缘的光强度下降速度。在以下图像中，你可以看到
    `exponent` 属性的作用结果。我们有一个非常明亮的光源（高 `intensity`），随着它从中心向锥体侧面移动，光强度迅速降低（高 `exponent`）：
- en: '![THREE.SpotLight](img/2215OS_03_09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.SpotLight](img/2215OS_03_09.jpg)'
- en: You could use this to highlight a specific object or simulate a small flashlight.
    We could also have created the same focused beam effect using a small `exponent`
    value and `angle`. On a cautionary note on this second approach, remember that
    a very small angle can quickly lead to all kinds of rendering artifacts (an artifact
    is a term used in graphics for unwanted distortions and strangely rendered parts
    of the screen).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这个来突出显示特定的对象或模拟一个小手电筒。我们也可以通过使用小的`exponent`值和`angle`来创建相同的效果。在第二个方法的注意事项上，记住一个非常小的角度可以迅速导致各种渲染伪影（伪影是图形中用于描述不想要的扭曲和屏幕上奇怪渲染部分的术语）。
- en: 'Before moving on to the next light, we''ll quickly look at the shadow-related
    properties available to `THREE.SpotLight`. You''ve already learned that we can
    get shadows by setting the `castShadow` property of `THREE.SpotLight` to `true`
    (and, of course, making sure that we set the `castShadow` property for objects
    that should cast shadows, and that we cast the `receiveShadow` property, for objects
    that should show a shadow, on the `THREE.Mesh` objects in our scene). Three.js
    also allows you very fine-grained control on how the shadow is rendered. This
    is done by a couple of properties we explained in the table at the beginning of
    the section. With `shadowCameraNear`, `shadowCameraFar`, and `shadowCameraFov`,
    you can control how and where this light casts a shadow. This works in the same
    way as the perspective camera''s field of view we explained in the preceding chapter.
    The easiest way to see this in action is by setting `shadowCameraVisible` to `true`;
    you can do this by checking the menu''s debug checkbox. This shows, as you can
    see in the following screenshot, the area that is used to determine the shadows
    for this light:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到下一个光源之前，我们将快速查看`THREE.SpotLight`可用的与阴影相关的属性。你已经了解到，我们可以通过将`THREE.SpotLight`的`castShadow`属性设置为`true`来获取阴影（当然，确保我们为应该投射阴影的对象设置了`castShadow`属性，并且对于应该显示阴影的对象，我们在场景中的`THREE.Mesh`对象上设置了`receiveShadow`属性）。Three.js还允许你对阴影的渲染进行非常精细的控制。这是通过本节开头表格中解释的几个属性来实现的。通过`shadowCameraNear`、`shadowCameraFar`和`shadowCameraFov`，你可以控制光线如何以及在哪里投射阴影。这与我们在前一章中解释的透视相机的视野以相同的方式工作。要看到这个动作的最简单方法是将`shadowCameraVisible`设置为`true`；你可以通过检查菜单的调试复选框来完成此操作。这显示了，正如你在下面的屏幕截图中所看到的，用于确定此光源阴影的区域：
- en: '![THREE.SpotLight](img/2215OS_03_10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.SpotLight](img/2215OS_03_10.jpg)'
- en: 'I''ll end this section with a couple of pointers, just in case you run into
    issues with shadows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以几个提示结束本节，以防你在处理阴影时遇到问题：
- en: Enable the `shadowCameraVisible` property. This shows the area that is affected
    by this light for shadow purposes.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用`shadowCameraVisible`属性。这显示了受此光照影响的区域，用于阴影效果。
- en: If the shadow looks blocky, you can either increase the `shadowMapWidth` and
    `shadowMapHeight` properties or make sure the area that is used to calculate the
    shadow tightly wraps your object. You can use the `shadowCameraNear`, `shadowCameraFar`,
    and `shadowCameraFov` properties to configure this area.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果阴影看起来像块状，你可以增加`shadowMapWidth`和`shadowMapHeight`属性，或者确保用于计算阴影的区域紧密包裹你的对象。你可以使用`shadowCameraNear`、`shadowCameraFar`和`shadowCameraFov`属性来配置这个区域。
- en: Remember that you not only have to tell the light to cast shadows, but also
    have to tell each geometry whether it will receive and/or cast shadows by setting
    the `castShadow` and `receiveShadow` properties.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，你不仅要告诉光线去投射阴影，还要告诉每个几何体是否接收和/或投射阴影，这需要通过设置`castShadow`和`receiveShadow`属性来实现。
- en: If you use thin objects in your scene, you might see strange artifacts when
    you render shadows. You can use the `shadowBias` property to slightly offset the
    shadows, which will often fix these kinds of issues.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你场景中使用了细长的对象，渲染阴影时可能会看到奇怪的伪影。你可以使用`shadowBias`属性来稍微偏移阴影，这通常可以解决这类问题。
- en: You can change the darkness of the shadow cast by setting the `shadowDarkness`
    property. If your shadows are too dark or not dark enough, changing this property
    allows you to fine-tune how the shadows are rendered.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过设置`shadowDarkness`属性来改变投射阴影的暗度。如果你的阴影太暗或不够暗，改变这个属性可以让你精细调整阴影的渲染方式。
- en: If you want to have softer shadows, you can set a different `shadowMapType value`
    on `THREE.WebGLRenderer`. By default, this property is set to `THREE.PCFShadowMap`;
    if you set this property to `PCFSoftShadowMap`, you get softer shadows.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要更柔和的阴影，你可以在`THREE.WebGLRenderer`上设置不同的`shadowMapType`值。默认情况下，此属性设置为`THREE.PCFShadowMap`；如果你将此属性设置为`PCFSoftShadowMap`，你会得到更柔和的阴影。
- en: THREE.DirectionalLight
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.DirectionalLight
- en: The last of the basic lights we will look at is `THREE.DirectionalLight`. This
    type of light can be considered as a light that is very far away. All the light
    rays it sends out are parallel to each other. A good example of this is the sun.
    The sun is so far away that the light rays we receive on earth are (almost) parallel
    to each other. The main difference between `THREE.DirectionalLight` and `THREE.SpotLight`
    (which we saw in the previous section) is that this light won't diminish the farther
    it gets from the target of `THREE.DirectionalLight` as it does with `THREE.SpotLight`
    (you can fine-tune this with the `distance` and `exponent` parameters). The complete
    area that is lit by `THREE.DirectionalLight` receives the same intensity of light.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的最后一种基本光源是 `THREE.DirectionalLight`。这种光源可以被认为是非常远的光源。它发出的所有光束都是相互平行的。一个很好的例子就是太阳。太阳距离我们非常遥远，因此我们地球上接收到的光线几乎是平行的。`THREE.DirectionalLight`
    与 `THREE.SpotLight`（我们在上一节中已经讨论过）的主要区别在于，这种光不会随着距离 `THREE.DirectionalLight` 目标越来越远而减弱，就像
    `THREE.SpotLight` 那样（你可以通过 `distance` 和 `exponent` 参数进行微调）。`THREE.DirectionalLight`
    照亮的整个区域都会接收到相同强度的光线。
- en: 'To see this in action, look at the `04-directional-light` example, which is
    shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个效果，请查看 `04-directional-light` 示例，它在这里展示：
- en: '![THREE.DirectionalLight](img/2215OS_03_11.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.DirectionalLight](img/2215OS_03_11.jpg)'
- en: As you can see in the preceding image, there isn't a cone of light that is applied
    to the scene. Everything receives the same amount of light. Only the direction,
    the color, and the intensity of the light is used to calculate the colors and
    shadows.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，场景中并没有应用光锥。所有物体都接收相同数量的光线。只有光的方向、颜色和强度被用来计算颜色和阴影。
- en: 'Just as with `THREE.SpotLight`, there are a couple of properties you can set
    that control the intensity of the light and the way it casts shadows. `THREE.DirectionalLight`
    has a lot of properties that are the same as those of `THREE.SpotLight`: `position`,
    `target`, `intensity`, `distance`, `castShadow`, `onlyShadow`, `shadowCameraNear`,
    `shadowCameraFar`, `shadowDarkness`, `shadowCameraVisible`, `shadowMapWidth`,
    `shadowMapHeight`, and `shadowBias`. For information on those properties, you
    can look at the preceding section on `THREE.SpotLight`. The few additional properties
    are discussed in the next couple of paragraphs.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 `THREE.SpotLight` 一样，有一些属性你可以设置来控制光线的强度和它投射阴影的方式。`THREE.DirectionalLight`
    有很多属性与 `THREE.SpotLight` 相同：`position`、`target`、`intensity`、`distance`、`castShadow`、`onlyShadow`、`shadowCameraNear`、`shadowCameraFar`、`shadowDarkness`、`shadowCameraVisible`、`shadowMapWidth`、`shadowMapHeight`
    和 `shadowBias`。有关这些属性的更多信息，你可以查看关于 `THREE.SpotLight` 的前述章节。接下来的几段将讨论一些额外的属性。
- en: 'If you look back at the `THREE.SpotLight` examples, you can see that we had
    to define the cone of light where shadows were applied. Since, for `THREE.DirectionalLight`,
    all the rays are parallel to each other, we don''t have a cone of light, instead,
    we have a cuboid area, as you can see in the following screenshot (if you want
    to see this for yourself, move the camera further away from the scene):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下 `THREE.SpotLight` 的示例，你可以看到我们必须定义应用阴影的光锥。由于对于 `THREE.DirectionalLight`，所有光线都是相互平行的，所以我们没有光锥，而是有一个长方体区域，正如你在下面的屏幕截图中所看到的（如果你想亲自查看，请将相机从场景中移远）：
- en: '![THREE.DirectionalLight](img/2215OS_03_12.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.DirectionalLight](img/2215OS_03_12.jpg)'
- en: 'Everything that falls within this cube can cast and receive shadows from the
    light. Just as for `THREE.SpotLight`, the tighter you define this area around
    the objects, the better your shadows will look. Define this cube using the following
    properties:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有落在这个立方体内的物体都可以从光中投射和接收阴影。正如 `THREE.SpotLight` 一样，你定义的围绕物体的这个区域越紧密，你的阴影看起来就越好。使用以下属性来定义这个立方体：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can compare this with the way we configured the orthographic camera in the
    section on cameras in [Chapter 2](ch02.html "Chapter 2. Basic Components That
    Make Up a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这比作我们在 [第2章](ch02.html "第2章. 构成Three.js场景的基本组件") 中关于相机的部分配置正交相机的方式，*构成Three.js场景的基本组件*。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is one property that is available to `THREE.DirectionalLight` that we
    haven''t addressed yet: `shadowCascade`. This property can be used to create better
    shadows when you want to use shadows on a large area with `THREE.DirectionalLight`.
    If you set the property to `true`, Three.js will use an alternative approach to
    generate the shadows. It splits the shadow generation up to the value specified
    by `shadowCascadeCount`. This will result in more detailed shadows close to the
    viewpoint of the camera and less detailed shadows far away. To use this, you''ll
    have to experiment with the settings for `shadowCascadeCount`, `shadowCascadeBias`,
    `shadowCascadeWidth`, `shadowCascadeHeight`, `shadowCascadeNearZ`, and `shadowCascadeFarZ`.
    You can find an example where this setup is used at [http://alteredqualia.com/three/examples/webgl_road.html](http://alteredqualia.com/three/examples/webgl_road.html).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`THREE.DirectionalLight`，有一个我们尚未解决的属性：`shadowCascade`。当您想在大型区域使用`THREE.DirectionalLight`的阴影时，可以使用此属性来创建更好的阴影。如果您将属性设置为`true`，Three.js将使用一种替代方法来生成阴影。它将阴影生成分割到`shadowCascadeCount`指定的值。这将导致靠近相机视点的阴影更详细，而远离的阴影则不那么详细。要使用此功能，您将不得不对`shadowCascadeCount`、`shadowCascadeBias`、`shadowCascadeWidth`、`shadowCascadeHeight`、`shadowCascadeNearZ`和`shadowCascadeFarZ`的设置进行实验。您可以在[http://alteredqualia.com/three/examples/webgl_road.html](http://alteredqualia.com/three/examples/webgl_road.html)找到一个使用此设置的示例。
- en: Special lights
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊灯光
- en: In this section on special lights, we'll discuss two additional lights provided
    by Three.js. First, we'll discuss `THREE.HemisphereLight`, which helps in creating
    more natural lighting for outdoor scenes, then we'll look at `THREE.AreaLight`,
    which emits lights from a large area instead of a single point, and finally, we'll
    show you how you can add a lens flare effect to your scene.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节关于特殊灯光中，我们将讨论Three.js提供的两个附加灯光。首先，我们将讨论`THREE.HemisphereLight`，它有助于为户外场景创建更自然的照明，然后我们将查看`THREE.AreaLight`，它从大面积而不是单一点发射光线，最后，我们将向您展示如何为场景添加镜头光晕效果。
- en: THREE.HemisphereLight
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.HemisphereLight
- en: 'The first special light we''re going to look at is `THREE.HemisphereLight`.
    With `THREE.HemisphereLight`, we can create more natural-looking outdoor lighting.
    Without this light, we could simulate the outdoors by creating `THREE.DirectionalLight`,
    which emulates the sun, and maybe add additional `THREE.AmbientLight` to provide
    some general color to the scene. This, however, won''t look really natural. When
    you''re outdoors, not all the light comes directly from above: much is diffused
    by the atmosphere and reflected by the ground and other objects. `THREE.HemisphereLight`
    in Three.js is created for this scenario. This is an easy way to get more natural-looking
    outdoor lighting. To see an example, look at `05-hemisphere-light.html`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个特殊灯光是`THREE.HemisphereLight`。使用`THREE.HemisphereLight`，我们可以创建看起来更自然的户外照明。如果没有这个灯光，我们可以通过创建`THREE.DirectionalLight`来模拟户外，这可能还会添加额外的`THREE.AmbientLight`来为场景提供一些通用颜色。然而，这看起来并不真的自然。当你在户外时，并非所有的光都直接来自上方：很多光被大气散射，并被地面和其他物体反射。Three.js中的`THREE.HemisphereLight`就是为了这种情况而创建的。这是一种获取更自然户外照明的好方法。要查看示例，请查看`05-hemisphere-light.html`：
- en: '![THREE.HemisphereLight](img/2215OS_03_13.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.HemisphereLight](img/2215OS_03_13.jpg)'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this is the first example that loads additional resources and can't
    run directly from your local filesystem. So if you haven't done so, look at [Chapter
    1](ch01.html "Chapter 1. Creating Your First 3D Scene with Three.js"), *Create
    Your First 3D Scene with Three.js*, to find out how to set up a local web server
    or disable the security settings in your browser to make loading external resources
    work.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是第一个加载额外资源的示例，不能直接从您的本地文件系统运行。所以如果您还没有这样做，请查看[第1章](ch01.html "第1章。使用Three.js创建您的第一个3D场景"),
    *使用Three.js创建您的第一个3D场景*，了解如何设置本地Web服务器或禁用浏览器中的安全设置，以便加载外部资源。
- en: 'In this example, you can turn `THREE.HemisphereLight` on and off and set the
    colors and intensity. Creating a hemisphere light is just as easy as creating
    any of the other lights:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您可以打开和关闭`THREE.HemisphereLight`，并设置颜色和强度。创建半球形灯光就像创建其他任何灯光一样简单：
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You just specify the color that is received from the sky, the color received
    from the ground, and the intensity of these lights. If you want to change these
    values later on, you can access them through the following properties:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需指定从天空接收到的颜色、从地面接收到的颜色以及这些灯光的强度。如果您稍后想更改这些值，您可以通过以下属性访问它们：
- en: '| Property | Description |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `groundColor` | This is the color that is emitted from the ground |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `groundColor` | 这是从地面发出的颜色 |'
- en: '| `color` | This is the color that is emitted from the sky |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是从天空发出的颜色 |'
- en: '| `intensity` | This is the intensity with which the light shines |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `intensity` | 这是光线照射的强度 |'
- en: THREE.AreaLight
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.AreaLight
- en: 'The last real light source we''ll look at is `THREE.AreaLight`. With `THREE.AreaLight`,
    we can define a rectangular area that emits light. `THREE.AreaLight` isn''t included
    in the standard Three.js library, but in its extensions, so we have to take a
    couple of additional steps before we can use this light source. Before we look
    at the details, let''s first look at the result we''re aiming for (`06-area-light.html`
    opens this example); the following screenshot encapsulates the result we want
    to see:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一种真实光源是 `THREE.AreaLight`。使用 `THREE.AreaLight`，我们可以定义一个发射光线的矩形区域。`THREE.AreaLight`
    不包含在标准的 Three.js 库中，而是在其扩展中，因此在使用这个光源之前，我们必须采取一些额外的步骤。在我们查看细节之前，让我们首先看看我们想要达到的结果（`06-area-light.html`
    打开此示例）；以下截图封装了我们想要看到的结果：
- en: '![THREE.AreaLight](img/2215OS_03_14.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.AreaLight](img/2215OS_03_14.jpg)'
- en: What you see in this screenshot is that we've defined three `THREE.AreaLight`
    objects, each with their own color. You can also see how these lights affect the
    whole area.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中所看到的是，我们定义了三个 `THREE.AreaLight` 对象，每个对象都有其自己的颜色。您还可以看到这些光线如何影响整个区域。
- en: When we want to use `THREE.AreaLight`, we can't use `THREE.WebGLRenderer`, which
    we used in our examples until now. The reason is that `THREE.AreaLight` is a very
    complex light source that would cause a very serious performance penalty in the
    normal `THREE.WebGLRenderer` object. It uses a different approach when rendering
    a scene (it breaks it up into multiple steps) and can handle complex lights (or
    a very high number of light sources for that matter) much better than the standard
    `THREE.WebGLRenderer` object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使用 `THREE.AreaLight` 时，我们不能使用我们至今为止使用的 `THREE.WebGLRenderer`。原因是 `THREE.AreaLight`
    是一个非常复杂的光源，它会在正常的 `THREE.WebGLRenderer` 对象中造成非常严重的性能损失。它在渲染场景时采用不同的方法（将其分解成多个步骤），并且比标准的
    `THREE.WebGLRenderer` 对象更好地处理复杂的光源（或者就光源数量而言，非常高的数量）。
- en: 'To use `THREE.WebGLDeferredRenderer`, we have to include a couple of additional
    JavaScript sources provided by Three.js. In the head of your HTML skeleton, make
    sure you have the following set of `<script>` sources defined:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `THREE.WebGLDeferredRenderer`，我们必须包含由 Three.js 提供的一些额外的 JavaScript 源文件。在你的
    HTML 框架头部，确保你已经定义了以下 `<script>` 源代码集：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With these libraries included, we can use `THREE.WebGLDeferredRenderer`. We
    can use this renderer in pretty much the same way as the one we discussed in the
    other examples. It just takes a couple of extra arguments:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了这些库之后，我们可以使用 `THREE.WebGLDeferredRenderer`。我们可以以与我们在其他示例中讨论的相同的方式使用这个渲染器。它只需要额外的几个参数：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Don't worry too much about what all these properties mean at the moment. In
    [Chapter 10](ch10.html "Chapter 10. Loading and Working with Textures"), *Loading
    and Working with Textures*, we'll dive deeper into `THREE.WebGLDeferredRenderer`
    and explain them to you. With the correct JavaScript libraries and a different
    renderer, we can start adding `Three.AreaLight`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于担心这些属性在当前时刻的含义。在 [第 10 章](ch10.html "第 10 章。加载和使用纹理")，*加载和使用纹理* 中，我们将更深入地探讨
    `THREE.WebGLDeferredRenderer` 并为您解释它们。有了正确的 JavaScript 库和不同的渲染器，我们可以开始添加 `Three.AreaLight`。
- en: 'We do this in pretty much the same way as all the other lights:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与其他所有光源几乎相同的方式做这件事：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, we create a new `THREE.AreaLight`. This light has a color
    value of `0xff0000` and an intensity value of `3`. Just like the other lights,
    we can use the `position` attribute to set its location in the scene. When you
    create `THREE.AreaLight`, it will be created as a horizontal plane. In our example,
    we created three `THREE.AreaLight` objects that are positioned vertically, so
    we need to rotate our lights `-Math.PI/2` around their *x* axis. Finally, we set
    the size of `THREE.AreaLight` using the `width` and `height` properties and add
    them to the scene. If you try this yourself for the first time, you might wonder
    why you don''t see anything where you positioned your light. This is because you
    can''t see the light source itself, only the light it emits, which you only see
    when it touches an object. If you want to recreate what I''ve shown in the example,
    you can add `THREE.PlaneGeometry` or `THREE.BoxGeometry` at the same position
    (`areaLight1.position`) to simulate the area emitting light, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个新的`THREE.AreaLight`。这个灯光的颜色值为`0xff0000`，强度值为`3`。就像其他灯光一样，我们可以使用`position`属性来设置它在场景中的位置。当你创建`THREE.AreaLight`时，它将被创建为一个水平平面。在我们的例子中，我们创建了三个垂直定位的`THREE.AreaLight`对象，因此我们需要将灯光绕其*x*轴旋转`-Math.PI/2`。最后，我们使用`width`和`height`属性设置`THREE.AreaLight`的大小，并将其添加到场景中。如果你第一次尝试这样做，你可能会想知道为什么你在灯光位置没有看到任何东西。这是因为你无法看到光源本身，只能看到它发出的光，而你只能在它接触到物体时看到光。如果你想重现我在示例中展示的内容，你可以在相同的位置（`areaLight1.position`）添加`THREE.PlaneGeometry`或`THREE.BoxGeometry`来模拟发光区域，如下所示：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can create really beautiful effects with `THREE.AreaLight`, but you''ll
    probably have to experiment a bit to get the desired effect. If you pull down
    the control panel from the top-right corner, you''ve got some controls you can
    play around with to set the color and intensity of the three lights from this
    scene and immediately see the effect, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`THREE.AreaLight`创建非常漂亮的效果，但你可能需要做一些实验来得到期望的效果。如果你从右上角下拉控制面板，你会得到一些可以调整的控件来设置场景中三个灯光的颜色和强度，并立即看到效果，如下所示：
- en: '![THREE.AreaLight](img/2215OS_03_15.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.AreaLight](img/2215OS_03_15.jpg)'
- en: LensFlare
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜头光晕
- en: The last subject we'll explore in this chapter is **lens flares**. You are probably
    already familiar with lens flares. For instance, they appear when you take a photograph
    directly into the sun or another bright light source. In most cases, you want
    to avoid this, but for games and 3D-generated images, it provides a nice effect
    that makes scenes look a bit more realistic.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的最后一个主题是**镜头光晕**。你可能已经对镜头光晕很熟悉了。例如，当你在阳光下或另一个明亮的光源直接拍照时，它们就会出现。在大多数情况下，你希望避免这种情况，但在游戏和3D生成的图像中，它提供了一个很好的效果，使场景看起来更加逼真。
- en: 'Three.js also has support for lens flares and makes it very easy to add them
    to your scene. In this last section, we''re going to add a lens flare to a scene
    and create the output as you can see in the following screenshot; you can see
    this for yourself by opening `07-lensflares.html`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 也支持镜头光晕，并使其很容易添加到场景中。在本节的最后，我们将向场景添加一个镜头光晕，并创建如下截图所示的输出；你可以通过打开`07-lensflares.html`来亲自查看：
- en: '![LensFlare](img/2215OS_03_16.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![镜头光晕](img/2215OS_03_16.jpg)'
- en: 'We can create a lens flare by instantiating the `THREE.LensFlare` object. The
    first thing we need to do is create this object. `THREE.LensFlare` takes the following
    arguments:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实例化`THREE.LensFlare`对象来创建镜头光晕。首先，我们需要创建这个对象。`THREE.LensFlare`需要以下参数：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These arguments are explained in the following table:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格中解释了这些参数：
- en: '| Argument | Description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `texture` | A texture is an image that determines the shape of the flare.
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `texture` | 纹理是一个图像，它决定了光晕的形状。 |'
- en: '| `size` | We can specify how large the flare should be. This is the size in
    pixels. If you specify `-1`, the size of the texture itself is used. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `size` | 我们可以指定光晕的大小。这是以像素为单位的大小。如果你指定`-1`，则使用纹理本身的大小。 |'
- en: '| `distance` | This is the distance from the light source (`0`) to the camera
    (`1`). Use this to position the lens flare in the right position. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `distance` | 这是光源（`0`）到相机（`1`）的距离。使用此参数来定位镜头光晕的正确位置。 |'
- en: '| `blending` | We can specify multiple textures for the flares. The blending
    mode determines how these are blended together. The default to use with `LensFlare`
    is `THREE.AdditiveBlending`. There''s more on blending in the next chapter. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `blending` | 我们可以为光晕指定多个纹理。混合模式决定了这些纹理是如何混合在一起的。与 `LensFlare` 一起使用的默认混合模式是
    `THREE.AdditiveBlending`。关于混合的更多内容将在下一章中介绍。|'
- en: '| `color` | This is the color of the flare. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是光晕的颜色。|'
- en: 'Let''s look at the code used to create this object (see `07-lensflares.html`):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建此对象所使用的代码（见 `07-lensflares.html`）：
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We first load a texture. For this example, I''ve used the lens flare texture
    provided by the Three.js examples, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先加载一个纹理。在这个例子中，我使用了Three.js示例提供的镜头光晕纹理，如下所示：
- en: '![LensFlare](img/2215OS_03_17.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![LensFlare](img/2215OS_03_17.jpg)'
- en: If you compare this image with the screenshot at the beginning of this section,
    you can see that it defines what the lens flare looks like. Next, we define the
    color of the lens flare using `new THREE.Color( 0xffaacc );`, which gives the
    lens flare a red glow. With these two objects, we can create the `THREE.LensFlare`
    object. For this example, we've set the size of the flare to `350` and the distance
    to `0.0` (directly at the light source).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此图像与本节开头的截图进行比较，你可以看到它定义了镜头光晕的外观。接下来，我们使用 `new THREE.Color( 0xffaacc );`
    定义镜头光晕的颜色，这给光晕带来了红色光芒。有了这两个对象，我们可以创建 `THREE.LensFlare` 对象。在这个例子中，我们将光晕的大小设置为 `350`，距离设置为
    `0.0`（直接在光源处）。
- en: 'After we''ve created the `LensFlare` object, we position it at the location
    of our light and add it to the scene, which can be seen in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了 `LensFlare` 对象之后，我们将它放置在光源的位置，并将其添加到场景中，这可以在下面的截图中看到：
- en: '![LensFlare](img/2215OS_03_18.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![LensFlare](img/2215OS_03_18.jpg)'
- en: 'It already looks nice, but if you compare this with the image from the beginning
    of this chapter you''ll notice that we''re missing the small round artifacts in
    the middle of the page. We create these in pretty much the same way as we did
    the main flare, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来已经很不错了，但如果你将此与本章开头的图像进行比较，你会注意到我们在页面中间缺少了小的圆形碎片。我们以与创建主要光晕相同的方式创建这些碎片，如下所示：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This time, though, we don''t create a new `THREE.LensFlare`, but use the `add`
    function provided by the `LensFlare` we just created. In this method, we need
    to specify the texture, size, distance, and blending mode, and that''s it. Note
    that the `add` function can take two additional parameters. You can also set the
    `color` and the `opacity` properties of the new flare to `add`. The texture we
    use for these new flares is a very light circle, as shown in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次我们并没有创建一个新的 `THREE.LensFlare` 对象，而是使用我们刚刚创建的 `LensFlare` 对象提供的 `add` 函数。在这个方法中，我们需要指定纹理、大小、距离和混合模式，然后就可以了。注意，`add`
    函数可以接受两个额外的参数。你还可以将新光晕的 `color` 和 `opacity` 属性设置为 `add`。我们用于这些新光晕的纹理是一个非常轻的圆形，如下面的截图所示：
- en: '![LensFlare](img/2215OS_03_19.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![LensFlare](img/2215OS_03_19.jpg)'
- en: If you look at the scene again, you'll see the artifacts appearing at the positions
    you've specified with the `distance` argument.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看场景，你会看到碎片出现在你使用 `distance` 参数指定的位置。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of information about the different kinds of
    lights that are available in Three.js. In this chapter, you learned that configuring
    lights, colors, and shadows is not an exact science. To get to the correct result,
    you should experiment with the different settings and use a dat.GUI control to
    fine-tune your configuration. The different lights behave in different manners.
    A `THREE.AmbientLight` color is added to each and every color in the scene and
    is often used to smooth hard colors and shadows. `THREE.PointLight` emits light
    in all directions but can't be used to create shadows. `THREE.SpotLight` is a
    light that resembles a flashlight. It has a conical shape, can be configured to
    fade over distance, and is able to cast shadows. We also looked at `THREE.DirectionalLight`.
    This light can be compared with a faraway light, such as the sun, whose light
    rays travel parallel to each other, the intensity of which doesn't decrease the
    farther away it gets from the configured target. Besides the standard lights,
    we also looked at a couple of more specialized lights. For a more natural outdoor
    effect, you can use `THREE.HemisphereLight`, which takes into account ground and
    sky reflections; `THREE.AreaLight` doesn't shine from a single point, but emits
    light from a large area. We showed you how to add a photographic lens flare with
    the `THREE.LenseFlare object`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了关于Three.js中可用的不同种类灯光的大量信息。在本章中，你了解到配置灯光、颜色和阴影并不是一门精确的科学。为了得到正确的结果，你应该尝试不同的设置，并使用dat.GUI控件来精细调整你的配置。不同的灯光表现方式不同。`THREE.AmbientLight`的颜色被添加到场景中的每一个颜色上，通常用于平滑硬色和阴影。`THREE.PointLight`向所有方向发射光线，但不能用于创建阴影。`THREE.SpotLight`是一种类似手电筒的灯光。它具有锥形形状，可以配置为随距离渐变，并且能够投射阴影。我们还探讨了`THREE.DirectionalLight`。这种灯光可以与远处的光源相比，例如太阳，其光线相互平行，强度不会随着距离配置目标越远而减弱。除了标准灯光外，我们还探讨了几个更专业的灯光。为了获得更自然的户外效果，你可以使用`THREE.HemisphereLight`，它考虑了地面和天空的反射；`THREE.AreaLight`不是从一个点发光，而是从大面积发射光线。我们展示了如何使用`THREE.LenseFlare`对象添加摄影镜头光晕。
- en: In the chapters so far, we already introduced a couple of different materials,
    and in this chapter, you saw that not all materials respond in the same manner
    to the available lights. In the next chapter, we'll give an overview of the materials
    that are available in Three.js.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经介绍了几种不同的材料，在本章中，你看到并不是所有材料对可用的灯光都有相同的反应。在下一章中，我们将概述Three.js中可用的材料。
