- en: '*Chapter 7*: Generating Content with Puppeteer'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第七章*: 使用 Puppeteer 生成内容'
- en: When I launched Puppeteer-Sharp (https://github.com/hardkoded/puppeteer-sharp)
    back in 2019, I was surprised to see that the two main use-case scenarios were
    content generation and web scraping.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在2019年推出 Puppeteer-Sharp (https://github.com/hardkoded/puppeteer-sharp) 时，我惊讶地发现，两个主要的使用场景是内容生成和网页抓取。
- en: Things are not too different in the Node.js world. Lots of developers use Puppeteer
    in Node.js for content generation and web scraping as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 世界中，情况并没有太大不同。许多开发者也在 Node.js 中使用 Puppeteer 进行内容生成和网页抓取。
- en: If you are a QA analyst, you will learn how to use screenshots to create regression
    tests. But, please, don't stop there; the other sections will give you a complete
    picture of everything you can do with Puppeteer on this topic. If you are not
    much into web development, share this chapter with your development team. No,
    don't share it – ask them to buy the book. That will be better.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名质量保证分析师，你将学习如何使用截图来创建回归测试。但请记住，不要止步于此；其他部分将为你展示使用 Puppeteer 在这个主题上可以完成的所有事情。如果你不太关注网页开发，请与你的开发团队分享这一章。不，不要分享——请他们购买这本书。那会更好。
- en: Web developers will love this chapter. We will see how to use Puppeteer as a
    content generator tool for your website.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 网页开发者会喜欢这一章。我们将看到如何将 Puppeteer 作为内容生成工具用于你的网站。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Taking screenshots
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拍摄截图
- en: Using screenshots for regression tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用截图进行回归测试
- en: Generating PDF files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 PDF 文件
- en: Creating HTML content
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 HTML 内容
- en: By the end of this chapter, you will have gotten to a new level. You will have
    learned how to use Puppeteer as a testing tool and as a content generator.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将达到一个新的水平。你将学会如何将 Puppeteer 作为测试工具和内容生成器使用。
- en: Let's get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will find all the code of this chapter in the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter7` directory. Remember to run `npm install` on that directory
    and then go to the `Chapter7/vuejs-firebase-shopping-cart` directory and run `npm
    install` again.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库 ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    的 `Chapter7` 目录下找到本章的所有代码。请记住在那个目录下运行 `npm install`，然后进入 `Chapter7/vuejs-firebase-shopping-cart`
    目录并再次运行 `npm install`。
- en: Taking screenshots
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拍摄截图
- en: Taking screenshots is the first feature I mention when I give talks about Puppeteer
    or Puppeteer-Sharp. Don't ask me why, maybe because I find it fun to use, or perhaps
    because it's hard to explain why we would need to take screenshots.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我谈论 Puppeteer 或 Puppeteer-Sharp 时，我会首先提到截图功能。不要问我为什么，可能是因为我觉得使用它很有趣，或者可能是因为很难解释为什么我们需要截图。
- en: As a web developer, there are many things you can accomplish using screenshots.
    The first popular use-case you'll find is to improve your **Open Graph** information.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名网页开发者，你可以使用截图完成许多事情。你首先会发现的一个流行用例是改进你的 **Open Graph** 信息。
- en: According to their website (https://ogp.me/), "*The Open Graph protocol enables
    any web page to become a rich object in a social graph. For instance, this is
    used on Facebook to allow any web page to have the same functionality as any other
    object on Facebook."*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据他们的网站 (https://ogp.me/)，“*Open Graph 协议使任何网页都能成为社交图中的丰富对象。例如，这被用于 Facebook，允许任何网页具有与
    Facebook 上任何其他对象相同的功能。”*
- en: 'Open Graph is what will make social media posts (on Twitter or Facebook) look
    pretty when people share the URL of your site. We are not going to talk about
    product positioning on social media in this book. But what you need to know is
    that if you are working on a public site with users wanting to share your content
    on social media, someone will ask you to improve the open graph information:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Open Graph 是使社交媒体帖子（在 Twitter 或 Facebook 上）在人们分享你的网站 URL 时看起来很漂亮的东西。我们不会在这本书中讨论社交媒体上的产品定位。但你需要知道的是，如果你正在开发一个公共网站，用户想要在社交媒体上分享你的内容，有人会要求你改进
    Open Graph 信息：
- en: '![A post with no Open Graph information'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![没有 Open Graph 信息的帖子'
- en: '](img/Figure_7.01_B16113.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_7.01_B16113.jpg](img/Figure_7.01_B16113.jpg)'
- en: A post with no Open Graph information
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Open Graph信息的帖子
- en: 'You don''t want your site to look like the preceding screenshot when you share
    your products on social media. You want your links to be like Amazon, with a nice
    description and a big image, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望当你在社交媒体上分享你的产品时，你的网站看起来像前面的截图。你希望你的链接看起来像Amazon，有一个好的描述和一张大图，就像以下截图所示：
- en: '![Amazon posts on social media'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![社交媒体上的Amazon帖子'
- en: '](img/Figure_7.02_B16113.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B16113.jpg)'
- en: Amazon posts on social media
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 社交媒体上的Amazon帖子
- en: 'Adding an image to your posts is as easy as adding a meta property called `og:image`
    in the html head of your product page:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的帖子中添加图片就像在你的产品页面的HTML头部添加一个名为`og:image`的元属性一样简单：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Those few lines will make your post look prettier on social media.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行代码会让你的帖子在社交媒体上看起来更美观。
- en: 'What does this have to do with taking screenshots? Well, sometimes getting
    the image for a post is simple. In a shopping cart, the image would be the product
    image – a piece of cake. But sometimes, getting the image for a URL is not that
    easy. Let''s take, for instance, this post from the great HolyJS conference:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这与截取屏幕截图有什么关系呢？嗯，有时候获取帖子的图片很简单。在购物车中，图片就是产品图片——小菜一碟。但有时候，获取URL的图片并不那么容易。让我们以这个来自伟大的HolyJS会议的帖子为例：
- en: '![HolyJS post'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![HolyJS帖子'
- en: '](img/Figure_7.03_B16113.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.03_B16113.jpg)'
- en: HolyJS post
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: HolyJS帖子
- en: If you go to that post ([https://www.hardkoded.com/ui-testing-with-puppeteer/holyjs-post](https://www.hardkoded.com/ui-testing-with-puppeteer/holyjs-post)),
    you won't find the image used in that tweet. You will see Roman's photo, but you
    won't find the image with the photo, the conference logo, or the talk title. They
    might have created that image manually. You don't need great Photoshop skills
    to do that. But if you created hundreds of tweets for all the talks at the HolyJS
    conference, I bet it would be more productive to code a Puppeteer script in a
    few minutes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问那个帖子([https://www.hardkoded.com/ui-testing-with-puppeteer/holyjs-post](https://www.hardkoded.com/ui-testing-with-puppeteer/holyjs-post))，你不会找到那个推文中使用的图片。你会看到罗马的照片，但不会找到带有照片、会议标志或演讲标题的图片。他们可能已经手动创建了那张图片。你不需要有很棒的Photoshop技能来做这件事。但如果你要为HolyJS会议的所有演讲创建数百条推文，我敢打赌，用几分钟的时间编写一个Puppeteer脚本会更有生产力。
- en: We could have an internal page that we would navigate by passing a talk ID.
    Once loaded, we take a screenshot, and we save that image in some kind of storage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个内部页面，通过传递一个演讲ID来导航。一旦加载，我们截取一个屏幕截图，并将该图像保存在某种存储中。
- en: But before getting into Puppeteer's code, let me show you a new tool. Do you
    know that you can take full-page screenshots using Chromium?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入Puppeteer的代码之前，让我先展示一个新工具。你知道你可以使用Chromium来截取全页屏幕截图吗？
- en: 'If you open up the Developer Tools in *Chrome* and then press *Cmd* + *Shift*
    + *P* in macOS or *Ctrl* + *Shift* + *P*, a **command menu list** will pop up,
    just like in VS Code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开*Chrome*的开发者工具，然后在macOS上按*Cmd* + *Shift* + *P*或在Windows上按*Ctrl* + *Shift*
    + *P*，会弹出一个**命令菜单列表**，就像在VS Code中一样：
- en: '![Taking screenshots using Chromium'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用Chromium截取屏幕截图'
- en: '](img/Figure_7.04_B16113.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.04_B16113.jpg)'
- en: Taking screenshots using Chromium
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chromium截取屏幕截图
- en: You will find tons of commands there. Do you want to have some fun? Open the
    3D Viewer. I'll give you 3 minutes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在那里找到大量的命令。你想找点乐子吗？打开3D查看器。我会给你3分钟。
- en: OK, back to work. If you type `screenshot` in the **command menu list**, you
    will get four options.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，回到工作。如果你在**命令菜单列表**中输入`screenshot`，你会得到四个选项。
- en: The first option is **Capture area screenshot**. This option works like the
    take screenshot area you have in macOS by pressing *Cmd* + *Shift* + *4* or the
    **Rectangular snip** in Windows's snipping tool. When you select that option,
    the cursor turns into a cross. You select the area you want to take a screenshot
    of, then you release the mouse and get an image download.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是**捕获区域截图**。这个选项的工作方式类似于在macOS中按*Cmd* + *Shift* + *4*或在Windows的截图工具中的**矩形截图**。当你选择这个选项时，光标会变成一个十字。你选择你想要截取屏幕截图的区域，然后释放鼠标，就可以下载图片了。
- en: The second option is **Capture a full size screenshot**. This feature is so
    cool that I would put this option in a huge font size, in bold, red, and italics,
    but I don't think my editor would let me. **Capture a full size screenshot** will
    take a screenshot of the entire page, even the parts off the screen. I remember
    other tools trying to accomplish this by taking several screenshots while scrolling
    the page, and the results were terrible. To be honest, I have heard of people
    having issues with this option, but generally speaking, the results are pretty
    good. You can use this tool for marketing purposes or for reporting bugs so that
    you can show the entire page.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是 **捕获全尺寸截图**。这个功能非常酷，我甚至想用大号字体、粗体、红色和斜体来强调这个选项，但我不认为我的编辑器会允许我这样做。**捕获全尺寸截图**
    将捕获整个页面的截图，甚至包括屏幕外的部分。我记得其他工具试图通过在滚动页面时多次截图来完成这个任务，结果很糟糕。说实话，我听说有人对这个选项有问题，但总的来说，结果相当不错。你可以用这个工具进行市场营销或报告错误，以便你可以展示整个页面。
- en: The third option is also fantastic. Now I don't know which one is my favorite.
    **Capture node screenshot** works with the **Elements** tab. You go to the **Elements**
    tab, select an element by clicking on it, then select the **Capture node screenshot**
    option, and you will get a screenshot of that element. This is way better than
    trying to select a section of the page with the capture area option.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项也非常出色。现在我不知道哪一个是我最喜欢的。**捕获节点截图** 与 **元素** 选项卡一起使用。你转到 **元素** 选项卡，通过点击选择一个元素，然后选择
    **捕获节点截图** 选项，你将得到该元素的截图。这比尝试使用捕获区域选项选择页面的一部分要好得多。
- en: The last option is just **Capture screenshot**. It will capture the visible
    part of the page. Yes, I know, it sounds boring compared with the others, but
    it's still useful.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项只是 **捕获截图**。它将捕获页面的可见部分。是的，我知道，与其他选项相比，这听起来很无聊，但它仍然很有用。
- en: I don't think I need to tell you the good news because you already know. We
    can do all these things with Puppeteer using the `screenshot` function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我无需告诉你这个好消息，因为你已经知道了。我们可以使用 Puppeteer 的 `screenshot` 函数完成所有这些操作。
- en: Both the `Page` class and the `ElementHandle` class have this function. If you
    call the `screenshot` function on an `ElementHandle`, you will use the **Capture
    node screenshot** option in Chrome.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Page` 类和 `ElementHandle` 类都具有这个功能。如果你在 `ElementHandle` 上调用 `screenshot` 函数，你将使用
    Chrome 中的 **捕获节点截图** 选项。'
- en: 'The function''s signature is quite simple, just `screenshot([options])`, which
    means that just calling `screenshot()` would be enough. But the `options` object
    has many interesting properties. Let''s take a look at them:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的签名非常简单，只是 `screenshot([options])`，这意味着只需调用 `screenshot()` 就足够了。但 `options`
    对象有许多有趣的属性。让我们来看看它们：
- en: '`path` is one of the most common properties you will use. If you pass a path,
    your screenshot will be saved there. Whether you pass the path or not, the resulting
    image will be returned by the `screenshot` function.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path` 是你将最常使用的属性之一。如果你传递一个路径，你的截图将被保存在那里。无论你是否传递路径，结果图像都将由 `screenshot` 函数返回。'
- en: With the `type` option, you can determine whether you want a `type`, Puppeteer
    will infer the type from the `path`. If you pass neither the `type` nor the `path`,
    it will default to **png**.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `type` 选项，你可以确定你想要的是 `type`，Puppeteer 将从 `path` 推断类型。如果你既没有传递 `type` 也没有传递
    `path`，它将默认为 **png**。
- en: If you set the type (whether using the `type` option or the `path` options)
    to `quality` option. It has to be a value from 0 to 100\. It will determine the
    quality of the **jpeg** image.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将类型（无论是使用 `type` 选项还是 `path` 选项）设置为 `quality` 选项，它必须是一个从 0 到 100 的值。它将确定
    **jpeg** 图像的质量。
- en: Then we have `fullPage`. This option is a boolean option that will help us perform
    the **Capture a full size screenshot** action.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们有 `fullPage`。这个选项是一个布尔选项，它将帮助我们执行 **捕获全尺寸截图** 操作。
- en: The `clip` property is an object that will help us perform the `x` for the x-coordinate,
    `y` for the y-coordinate, and then `width` and `height` to determine the area's
    size.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clip` 属性是一个对象，它将帮助我们执行 x 坐标的 `x`，y 坐标的 `y`，然后使用 `width` 和 `height` 确定区域的大小。'
- en: With the `omitBackground` property, you will be able to change the page's default
    (white) background to transparent.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `omitBackground` 属性，你可以将页面的默认（白色）背景更改为透明。
- en: Important Note
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`omitBackground` changes the default background of the page. If the page has
    a custom background, even a white background using `background-color: white`,
    or an image, this option won''t work.'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`omitBackground`更改页面的默认背景。如果页面有自定义背景，即使是使用`background-color: white`的白色背景或图像，此选项将不起作用。'
- en: The last property available is `encoding`, which will determine the return type
    of the `screenshot` function. If you pass `base64`, it will return a base64 string.
    If you pass `binary` or don't set any value, it will return a Node.js `Buffer`
    object.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个可用的属性是`encoding`，它将确定`screenshot`函数的返回类型。如果你传递`base64`，它将返回一个base64字符串。如果你传递`binary`或未设置任何值，它将返回一个Node.js
    `Buffer`对象。
- en: 'Time to see some code. Let''s create a script and try to replicate the four
    options that Chrome offers. You will also be able to see this code in the `screenshots.js`
    file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看一些代码了。让我们创建一个脚本并尝试复制Chrome提供的四个选项。你还可以在`screenshots.js`文件中看到这段代码：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see the four actions expressed in the code. If we pass only the `path`,
    we `fullPage` to true, we will get `fullPage`, we pass a `clip`, we'll get `ElementHandle`
    we get from `page.$('.tombstone')`, we get **Capture node screenshot**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到代码中表达的四种操作。如果我们只传递`path`，将`fullPage`设置为true，我们将得到`fullPage`，我们传递一个`clip`，我们将得到从`page.$('.tombstone')`获取的`ElementHandle`，我们得到**捕获节点截图**。
- en: Tip
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Finding the right `clip` will be quite tricky. Pages change their layout based
    on the window size, which might break the fixed position you are trying to use.
    I would recommend trying to capture node screenshots instead of using a `clip`.
    If there is no element you can use, I would try to build the `clip` based on other
    elements' positions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 找到正确的`clip`将会相当棘手。页面会根据窗口大小改变布局，这可能会破坏你试图使用的固定位置。我建议尝试捕获节点截图而不是使用`clip`。如果没有可用的元素，我会尝试根据其他元素的定位来构建`clip`。
- en: I bet web developers will find more use cases for the screenshot feature. But
    if you are a QA analyst, we will now learn how to use screenshots to perform UI
    regression tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，网络开发者会发现截图功能的更多用例。但如果你是QA分析师，我们现在将学习如何使用截图来执行UI回归测试。
- en: Using screenshots for regression tests
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用截图进行回归测试
- en: We briefly talked about UI regression tests in [*Chapter 2*](B16113_02_Final_SK_ePub.xhtml#_idTextAnchor038),
    *Automated Testing and Test runners*. Now it's time to get practical. First, let's
    recap the concept of **regression**. Regression is something you hear a lot when
    you see bug reports. If a user says something like "I found a regression in X
    feature," they mean that something that was working before in a certain way has
    now changed. It might be a bug, an error in the app, or an unreported change of
    behavior.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B16113_02_Final_SK_ePub.xhtml#_idTextAnchor038)中简要讨论了UI回归测试，*自动化测试和测试运行器*。现在是我们变得实际的时候了。首先，让我们回顾一下**回归**的概念。当你看到错误报告时，你会经常听到这个词。如果一个用户说“我在X功能中发现了回归”，这意味着之前以某种方式工作的事物现在已经改变了。这可能是一个错误，应用程序中的错误，或者是一个未报告的行为变化。
- en: We can say that a UI regression is when we detect that a page or component has
    changed visually. I want to be emphatic again. It might have changed due to a
    bug or an unreported change of style.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，UI回归是我们检测到页面或组件在视觉上发生了变化。我想再次强调。它可能是因为错误或未报告的样式变化而改变的。
- en: 'To prove a regression, you need evidence. Until now, we were testing behavior,
    and our evidence was the code: "If I input the user, the password, and then I
    click on the login button, I should get logged in."'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明回归，你需要证据。到目前为止，我们一直在测试行为，我们的证据是代码：“如果我输入用户名、密码，然后点击登录按钮，我应该能够登录。”
- en: 'To prove a UI regression, our evidence will be **screenshots**. A UI regression
    test would consist of the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明UI回归，我们的证据将是**截图**。UI回归测试将包括以下步骤：
- en: The first thing we need to do is take a screenshot of the current state.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是截图当前状态。
- en: The first time we run a test, we have nothing to compare our screenshot to.
    We have no history, no evidence. We have nothing to test. But now, we have the
    evidence for the next run.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次运行测试时，我们没有可以比较截图的东西。我们没有历史，没有证据。我们没有可以测试的东西。但现在，我们有下一次运行的证据。
- en: If we have evidence, we will compare our current screenshot with the baseline,
    and we will fail if the images are different.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有证据，我们将比较当前的截图与基线，如果图像不同，我们将失败。
- en: That's it. Simple. But what happens when we have a difference? When we get a
    test fail in end-to-end tests, we would first see if it's an error in our test.
    If our tests are working as expected, that failure will end up in a bug report.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。很简单。但是当我们有差异时会发生什么？当我们进行端到端测试失败时，我们首先会看看这是否是我们测试中的错误。如果我们的测试按预期工作，那么这个失败最终会变成一个错误报告。
- en: But with UI regression tests, that's a little bit different. We would need to
    evaluate the results to check if we found an error or if **the baseline has changed**.
    We get UI changes in pages all the time, so we need to see if they are desired
    changes or not. If a change was desired, we would need to delete our baseline
    and create a new baseline image.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与UI回归测试相比，这有点不同。我们需要评估结果，以检查是否发现了错误，或者**基线是否已改变**。我们总是在页面上得到UI更改，所以我们需要看看这些更改是否是期望的。如果更改是期望的，我们就需要删除我们的基线并创建一个新的基线图像。
- en: 'That''s our cake. Now, what tools do we need to bake that cake? And also, what
    are our requirements for those tools? We need four elements:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们的蛋糕。现在，我们需要哪些工具来烘焙这个蛋糕？还有，我们对这些工具有什么要求？我们需要四个要素：
- en: A **test runner**. We already talked about what we need from a test runner,
    and we saw that Mocha and Jest meet our expectations.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个测试运行器**。我们已经讨论了我们需要从测试运行器中得到什么，并且我们看到Mocha和Jest符合我们的期望。'
- en: A **screenshot taker**. The screenshot taker needs to be stable. By stable,
    I mean that it needs to return the same screenshot under the same circumstances
    all the time. It sounds obvious, but UI regression tests are the king of flaky
    tests. We need a tool that provides the same screenshots consistently. Puppeteer
    is great for this.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个截图工具**。截图工具需要稳定。稳定的意思是，它需要在相同的情况下始终返回相同的截图。这听起来很显然，但UI回归测试是易变测试的王者。我们需要一个工具，它可以持续提供相同的截图。Puppeteer在这方面做得很好。'
- en: A **place to store baselines**. We are not talking about a tool here. But we
    need files to be organized so that it's easy to find and remove baselines and
    find the resulting comparisons.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个存储基线的位置**。这里我们不是在谈论一个工具。但我们需要文件组织得井井有条，这样就可以轻松地找到和删除基线，并找到结果比较。'
- en: A **tool to compare images**. This tool is as important as the screenshot taker.
    We don't want false alarms. We don't need a tool that tells us that everything
    is wrong just because one pixel is not the exact same white as the baseline. This
    tool should allow us to pass some kind of threshold to determine how sensitive
    we want it to be to changes. It should also need to support anti-aliased pixels
    to reduce the difference in the image rendering. *Pixelmatch* ([https://www.hardkoded.com/ui-testing-with-puppeteer/pixelmatch](https://www.hardkoded.com/ui-testing-with-puppeteer/pixelmatch))
    is the most popular image comparison package for Node.js.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个用于比较图像的工具**。这个工具与截图工具一样重要。我们不希望出现误报。我们不需要一个工具告诉我们，仅仅因为一个像素不是与基线完全相同的白色，就认为一切都不对。这个工具应该允许我们通过某种阈值来决定我们希望它对更改有多敏感。它还应该支持抗锯齿像素，以减少图像渲染中的差异。"Pixelmatch"([https://www.hardkoded.com/ui-testing-with-puppeteer/pixelmatch](https://www.hardkoded.com/ui-testing-with-puppeteer/pixelmatch))是Node.js中最受欢迎的图像比较包。'
- en: As you can see, it shouldn't be that hard implementing that. But many tools
    on the market solve all that boilerplate for us. Again, it's not about me telling
    you what's the best tool. You have to look for the right tool for you. I found
    that *Project Awesome* ([http://www.hardkoded.com/ui-testing-with-puppeteer/awesome-regression-testing](http://www.hardkoded.com/ui-testing-with-puppeteer/awesome-regression-testing))
    has a huge list of regression testing tools. On that site, I found *differencify*
    ([https://www.hardkoded.com/ui-testing-with-puppeteer/differencify](https://www.hardkoded.com/ui-testing-with-puppeteer/differencify)).
    I like it because it's simple and covers all the requirements mentioned in the
    preceding list. I don't like much that it's a layer between Puppeteer and us,
    but it does the job; I can live with that.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实现这一点不应该很难。但是市场上许多工具为我们解决了所有这些样板代码。再次强调，这并不是关于我告诉你们哪个是最好的工具。你们必须寻找适合你们自己的工具。我发现*Project
    Awesome*([http://www.hardkoded.com/ui-testing-with-puppeteer/awesome-regression-testing](http://www.hardkoded.com/ui-testing-with-puppeteer/awesome-regression-testing))有一个巨大的回归测试工具列表。在那个网站上，我发现了*differencify*([https://www.hardkoded.com/ui-testing-with-puppeteer/differencify](https://www.hardkoded.com/ui-testing-with-puppeteer/differencify))。我喜欢它，因为它简单，并且涵盖了前面提到的所有要求。我不太喜欢它作为Puppeteer和我们的中间层，但它确实完成了工作；我可以忍受这一点。
- en: 'We can create a test called `"Should visually match"`, and use differencify
    there. You can find this test in the `homepage.tests.js` file. Let''s see how
    to implement it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个名为 `"Should visually match"` 的测试，并在其中使用 differencify。你可以在 `homepage.tests.js`
    文件中找到这个测试。让我们看看如何实现它：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It looks pretty much like a normal Puppeteer test. But there are some differences.
    Let''s take a look at them:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来几乎就像一个正常的Puppeteer测试。但是有一些区别。让我们看看它们：
- en: It begins by declaring a variable named `target` and assigning to it the result
    of `differencify.init`. We won't get into the internals of *differencify*, because
    we don't care about the internals. The only thing important in that `init` call
    is that we are setting the test name there, which, as we will see later, will
    be used to name the images.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它从声明一个名为 `target` 的变量并给它分配 `differencify.init` 的结果开始。我们不会深入探讨 *differencify*
    的内部机制，因为我们不关心这些。在那个 `init` 调用中唯一重要的是我们在那里设置了测试名称，正如我们稍后将会看到的，这个名称将被用来命名图像。
- en: After that, it looks like pure Puppeteer code, except that we call `target.launch();`
    instead of `puppeteer.launch();`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它看起来就像纯Puppeteer代码，除了我们调用 `target.launch();` 而不是 `puppeteer.launch();`。
- en: One important thing we need to do when taking screenshots is setting the **viewport**.
    The viewport will determine the size of the screenshot we will use. Even if you
    take a full-page screenshot, the viewport will determine that image's width.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在截取屏幕截图时，我们需要做的一件重要事情是设置 **视口**。视口将决定我们将使用的屏幕截图的大小。即使你截取了全页面的屏幕截图，视口也会决定那个图像的宽度。
- en: Unless you want to check a page's style after specific actions, UI regression
    tests will just go to a page, wait for the page to be loaded and stable, and take
    a screenshot. By stable, I mean that you don't want to take a screenshot with
    half of the resources, for example, images still loading.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你想要检查页面在特定动作之后的样式，否则UI回归测试将只访问一个页面，等待页面加载并稳定，然后截取屏幕截图。这里的稳定意味着你不想在资源加载一半时截取屏幕截图，例如，图片还在加载。
- en: Once the page is loaded, we take a screenshot using `page.screenshot()` and
    then call `await target.toMatchSnapshot(image)`. This function will be responsible
    for creating a baseline image if it doesn't exist, and if it exists, make the
    image comparison.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后，我们使用 `page.screenshot()` 截取屏幕截图，然后调用 `await target.toMatchSnapshot(image)`。这个函数将负责如果不存在则创建基线图像，如果存在，则进行图像比较。
- en: When we run the test for the very first time, the test will pass because, again,
    there is no baseline. One important thing we will notice is that *differencify*
    created the baseline inside a `differencify_reports` directory. You can see the
    complete directory structure inside the `Chapter7/differencify_reports` directory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次运行测试时，测试将会通过，因为，再次强调，没有基线。我们将会注意到的一个重要事情是，*differencify* 在 `differencify_reports`
    目录内创建了基线。你可以在 `Chapter7/differencify_reports` 目录内看到完整的目录结构。
- en: 'Now we have our baseline. Hopefully, this test will be green unless something
    changes on that page. Let''s try to break it. We will open the `vuejs-firebase-shopping-cart/src/components/Header.vue`
    file and change the `color .navbar-btn` elements to blue:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了基线。希望这个测试将会显示绿色，除非那个页面上有变化。让我们尝试破坏它。我们将打开 `vuejs-firebase-shopping-cart/src/components/Header.vue`
    文件并将 `color .navbar-btn` 元素改为蓝色：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a typical scenario of a UI regression test. Maybe you wanted to change
    the color of a button on the login page, and you didn't realize that the `navbar-btn`
    class was also being used on the home page.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的UI回归测试场景。也许你想要改变登录页面上的按钮颜色，但你没有意识到 `navbar-btn` 类也被用于主页。
- en: 'If we run the test, we will get the following output, telling us that the test
    has failed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行测试，我们会得到以下输出，告诉我们测试已经失败：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That doesn''t say much. It just simply says that the image is not the same.
    But if we go to the `differencify_reports` directory, we will see that *differencify*
    created two new files: `Home 1.current.png` under `differencify_reports/__image_snapshots__/__current_output__`,
    which shows the latest screenshot. The second image is `Home 1.differencified.png`
    under `differencify_reports/__image_snapshots__/__differencified_output__`. You
    can see the differencified image inside the directory mentioned above or following
    the link [https://www.hardkoded.com/ui-testing-with-puppeteer/differencified](https://www.hardkoded.com/ui-testing-with-puppeteer/differencified)
    will show us where the changes were detected. In this case, you will see that
    it highlighted the word "`__current_output__` directory and evaluate what went
    wrong.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有说太多。它只是简单地说明图像并不相同。但如果我们去`differencify_reports`目录，我们会看到*differencify*创建了两个新文件：`Home
    1.current.png`位于`differencify_reports/__image_snapshots__/__current_output__`下，显示了最新的截图。第二个图像是`Home
    1.differencified.png`，位于`differencify_reports/__image_snapshots__/__differencified_output__`下。你可以在上述目录中查看差异化的图像，或者通过链接[https://www.hardkoded.com/ui-testing-with-puppeteer/differencified](https://www.hardkoded.com/ui-testing-with-puppeteer/differencified)查看检测到的更改位置。在这种情况下，你会看到它突出显示了单词"`__current_output__`目录并评估出了什么问题。
- en: To wrap up this section, UI regression tests are not for every project. If you
    use CSS frameworks like **bootstrap** or **tailwindcss** the chances of UI regressions
    are low. There are also projects where the page style is not considered a bug.
    Stakeholders won't care if a box is a few pixels below.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本节，UI回归测试并不是每个项目都需要。如果你使用像**bootstrap**或**tailwindcss**这样的CSS框架，UI回归的可能性很低。还有一些项目，页面样式不被视为错误。如果某个框比预期低几个像素，利益相关者不会在意。
- en: I do think it's an excellent tool for frontend developers working on custom
    CSS. With UI regression tests, a frontend developer can measure the impact of
    their changes. It's like unit tests for CSS.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实认为它是一个为使用自定义CSS的前端开发者提供的优秀工具。有了UI回归测试，前端开发者可以衡量他们更改的影响。这就像是CSS的单元测试。
- en: In the next chapter, we are going to talk about device emulation. With device
    emulation plus UI regression tests, you will be able to check how your site looks
    on mobile devices.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论设备模拟。通过设备模拟加上UI回归测试，你将能够检查你的网站在移动设备上的外观。
- en: Now it's time to learn another way to generate content with Puppeteer. Time
    to generate PDF files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习另一种使用Puppeteer生成内容的方法了。现在是生成PDF文件的时候了。
- en: Generate PDF files
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成PDF文件
- en: We are out of QA land, and we'll go into the development world again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经离开了QA领域，将再次进入开发世界。
- en: 'When I talk about PDF generation, I get the same question I mentioned in the
    screenshot section: "Why would I need to generate PDFs using Puppeteer?"'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我谈到PDF生成时，我遇到了我在截图部分提到过的同样的问题：“我为什么要使用Puppeteer生成PDF？”
- en: 'The first scenario to mention is using PDFs as an output format for your website.
    I don''t know if you''ve lived what I lived once. I had to build an e-commerce
    app. I built the product list, the checkout process, and even the receipt page.
    Then the requirement came out: "We need to send an email with that receipt as
    a PDF." That''s an estimation breaker. There is no easy way to create PDF files
    just from scratch.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要提到的场景是将PDF作为网站输出格式。我不知道你是否经历过我经历过的。我不得不构建一个电子商务应用程序。我构建了产品列表、结账流程，甚至收据页面。然后出现了需求：“我们需要发送一个包含该收据的PDF格式的电子邮件。”这是一个估算破坏者。没有简单的方法从头开始创建PDF文件。
- en: Then you find a library that generates PDFs, and you are happy with it. But
    the stakeholders tell you that it needs to look exactly like the receipt page.
    Your estimation goes to the trash again. There should be an easy way to generate
    PDF files.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你找到一个生成PDF的库，你对它很满意。但利益相关者告诉你，它需要看起来完全像收据页面。你的估计再次被扔进了垃圾桶。应该有一个简单的方法来生成PDF文件。
- en: Maybe it's not a receipt. Haven't you ever got a request to send a daily report
    by email as a PDF? You would end up using some huge, complex, and expensive reporting
    tool, just for that daily email.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 也许它不是一个收据。你有没有收到过要求通过电子邮件发送每日报告作为PDF的请求？你可能会使用一些庞大、复杂且昂贵的报告工具，只是为了那个每日的电子邮件。
- en: The second scenario is PDF files as a product by themselves. Do you sell documents?
    Finance reports? You can autogenerate that content using PDF generation tools.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个场景是PDF文件作为独立的产品。你销售文档吗？财务报告？你可以使用PDF生成工具自动生成这些内容。
- en: 'I bet you already know that you can save any page as a PDF file using Chrome''s
    print tool:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你已经知道你可以使用Chrome的打印工具将任何页面保存为PDF文件：
- en: '![Save as PDF in Chrome'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![在Chrome中另存为PDF'
- en: '](img/Figure_7.05_B16113.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.05_B16113.jpg)'
- en: Save as PDF in Chrome
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 中另存为 PDF
- en: You can go to any page, hit *Cmd* + *P* or *Ctrl* + *P*, and instead of selecting
    a real printer, you choose **Save as PDF**. Then you click **Save**, and you get
    your PDF.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以转到任何页面，按 *Cmd* + *P* 或 *Ctrl* + *P*，然后选择 **另存为 PDF** 而不是选择真正的打印机。然后点击 **保存**，你就能得到你的
    PDF。
- en: I think I don't need to tell you this, but as you might have guessed, Puppeteer
    uses this same utility to generate PDF files.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我不用告诉你这一点，但正如你可能已经猜到的，Puppeteer 使用这个相同的工具来生成 PDF 文件。
- en: 'There is something essential you need to know. If you know this, you will be
    able to answer lots of questions in Stack Overflow. Here goes: **PDF generation
    doesn''t work as a screenshot but as a print action**.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些基本的知识你需要了解。如果你知道了这些，你将能够回答 Stack Overflow 上的许多问题。下面是关键点：**PDF 生成不是作为截图，而是作为打印操作**。
- en: It might sound obvious, now that we've seen that **Print** dialog. But it's
    important for you to know that the viewport (the window size) won't determine
    how the PDF will be generated. The page size will determine that.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 **打印** 对话框，这听起来可能很显然。但重要的是你要知道，视口（窗口大小）不会决定 PDF 的生成方式。页面大小将决定这一点。
- en: Designers and frontend developers can determine how a page should be printed
    using the media query print ([https://www.hardkoded.com/ui-testing-with-puppeteer/mediaqueries](https://www.hardkoded.com/ui-testing-with-puppeteer/mediaqueries)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 设计师和前端开发者可以使用媒体查询打印 ([https://www.hardkoded.com/ui-testing-with-puppeteer/mediaqueries](https://www.hardkoded.com/ui-testing-with-puppeteer/mediaqueries))
    来确定页面应该如何打印。
- en: 'Let''s see how you can change a page style using `@media print`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `@media print` 来更改页面样式：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, if you browse this HTML content (you will find this code as `mediaprint.html`
    in the repository), you will find that "`Hello world`" is rendered in blue with
    a size of 16px. But if you hit `print`, the browser will add all the CSS style
    from the `@media print` section, changing the font size to 32px and the color
    to black. In the next section, we will learn how to add print styles if the page
    has none. For now, what you need to know is that we are printing content.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，如果你浏览这个 HTML 内容（你将在存储库中找到这个代码作为 `mediaprint.html`），你会发现 “Hello world”
    以 16px 的大小渲染为蓝色。但如果你点击 `打印`，浏览器将添加来自 `@media print` 部分的所有 CSS 样式，将字体大小改为 32px
    并将颜色改为黑色。在下一节中，我们将学习如何在页面没有打印样式的情况下添加打印样式。现在，你需要知道的是，我们正在打印内容。
- en: 'If the `@media print` style used in the page doesn''t work for you, there is
    a way to bypass this functionality. You can force the media type `screen` using
    the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页面中使用的 `@media print` 样式对你不起作用，有一种方法可以绕过这个功能。你可以使用以下代码强制使用媒体类型 `screen`：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you call `emulateMediaType` before generating the PDF, `@media print` will
    be ignored by the browser.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在生成 PDF 之前调用 `emulateMediaType`，浏览器将忽略 `@media print`。
- en: I don't think I need to tell you that the function we will use to generate PDF
    files is called `page.pdf`. Unlike `screenshot`, there is no `elementHandle.pdf`
    because you can't print just an element.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我不用告诉你这一点，但我们将要使用的生成 PDF 文件的函数叫做 `page.pdf`。与 `screenshot` 不同，没有 `elementHandle.pdf`，因为你不能只打印一个元素。
- en: The signature is simple, just `page.pdf([options])`, but we have many available
    options. Let's begin with the options that map the settings you would find in
    the print dialog.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 签名很简单，就是 `page.pdf([options])`，但我们有很多可用的选项。让我们从在打印对话框中找到的设置映射的选项开始。
- en: The first option you will see in the print dialog after selecting `landscape`.
    It's a boolean that will tell the browser if you want to generate the PDF with
    a landscape orientation or not.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择 `landscape` 后，打印对话框中你将看到的第一个选项是一个布尔值，它将告诉浏览器你是否想要以横向方向生成 PDF。
- en: The next option is `pageRanges`. It's a string where you can pass things like
    `'1-5, 8, 11-13'`. If you don't set this property, it will work as if you had
    set **Pages** to **All** in the print dialog.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项是 `pageRanges`。这是一个字符串，你可以传递类似 `'1-5, 8, 11-13'` 的内容。如果你不设置这个属性，它将像在打印对话框中设置了
    **所有页面** 一样工作。
- en: 'If you click `format`, which is a string that accepts the following options:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 `格式`，这是一个接受以下选项的字符串：
- en: '`Letter`: 8.5 in x 11 in'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Letter`: 8.5 英寸 x 11 英寸'
- en: '`Legal`: 8.5 in x 14 in'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Legal`: 8.5 英寸 x 14 英寸'
- en: '`Tabloid`: 11 in x 17 in'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabloid`: 11 英寸 x 17 英寸'
- en: '`Ledger`: 17 in x 11 in'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ledger`: 17 英寸 x 11 英寸'
- en: '`A0`: 33.1 in x 46.8 in'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A0`: 33.1 英寸 x 46.8 英寸'
- en: '`A1`: 23.4 in x 33.1 in'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A1`: 23.4 英寸 x 33.1 英寸'
- en: '`A2`: 16.54 in x 23.4 in'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A2`: 16.54 英寸 x 23.4 英寸'
- en: '`A3`: 11.7 in x 16.54 in'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A3`: 11.7 英寸 x 16.54 英寸'
- en: '`A4`: 8.27 in x 11.7 in'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A4`: 8.27 英寸 x 11.7 英寸'
- en: '`A5`: 5.83 in x 8.27 in'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A5`: 5.83 英寸 x 8.27 英寸'
- en: '`A6`: 4.13 in x 5.83 in'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A6`: 4.13 英寸 x 5.83 英寸'
- en: 'Puppeteer also offers two extra options: `width` and `height`. If none of those
    formats suit you, you can set custom dimensions with these two properties. These
    properties accept a number or a string. If you use strings, you can pass values
    in units, such as **px** for pixels, **in** for inches, **cm** for centimeters,
    or **mm** for millimeters.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 还提供了两个额外的选项：`width` 和 `height`。如果你不满足于这些格式，你可以使用这两个属性设置自定义尺寸。这些属性接受一个数字或字符串。如果你使用字符串，你可以传递带有单位的值，例如
    **px** 用于像素，**in** 用于英寸，**cm** 用于厘米，或 **mm** 用于毫米。
- en: Next up is `scale`, and it's the zoom that will be used to print the page. You
    will see it in the print dialog as a percentage from 10% to 200%. Here, it will
    be a decimal value from 0.1 to 2.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `scale`，这是打印页面时使用的缩放比例。你会在打印对话框中看到它是一个从 10% 到 200% 的百分比。在这里，它将是一个从 0.1
    到 2 的十进制值。
- en: After **Scale**, you will find **Pages per sheet**. We don't have that setting
    in Puppeteer.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **缩放** 之后，你会找到 **每页页数**。在 Puppeteer 中我们没有这个设置。
- en: 'The next option in the `margin` option is an object with four properties:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在“页边距”选项中，下一个选项是一个具有四个属性的对象：
- en: '`top`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`'
- en: '`right`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right`'
- en: '`bottom`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`'
- en: '`left`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`'
- en: All these properties accept a number or a string, supporting units as `width`
    and `height` do.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性都接受一个数字或字符串，支持与 `width` 和 `height` 相同的单位。
- en: 'After the margins, the print dialog offers an extra set of options. The first
    one is Headers and footers. This is a really fun feature in Puppeteer. Puppeteer
    not only provides a `displayHeaderFooter` boolean property, but it also provides
    a `headerTemplate` property and a `footerTemplate` property. That means that you
    can set what you want the header and the footer to look like. Puppeteer will even
    populate elements with the following classes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在页边距之后，打印对话框提供了一组额外的选项。第一个是页眉和页脚。这是 Puppeteer 中一个非常有趣的功能。Puppeteer 不仅提供了一个 `displayHeaderFooter`
    布尔属性，还提供了一个 `headerTemplate` 属性和一个 `footerTemplate` 属性。这意味着你可以设置你想要的页眉和页脚的样式。Puppeteer
    甚至会使用以下类填充元素：
- en: '`date`: Formatted print date'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`: 格式化的打印日期'
- en: '`title`: Document title'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 文档标题'
- en: '`url`: Document location'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`: 文档位置'
- en: '`pageNumber`: Current page number'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pageNumber`: 当前页码'
- en: '`totalPages`: Total pages in the document'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`totalPages`: 文档中的总页数'
- en: 'The next option is `printBackground` property. It will tell the browser that
    you want to print background graphics. This is `false` by default because this
    option is intended for printers, and you don''t want to waste your toner on a
    background. But you should consider whether this is something you need to turn
    on. Let''s consider Wikipedia:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项是 `printBackground` 属性。它将告诉浏览器你想要打印背景图形。默认情况下这是 `false`，因为这个选项是为打印机设计的，你不想浪费你的墨粉在背景上。但是你应该考虑是否需要打开这个选项。让我们以维基百科为例：
- en: '![Wikipedia without the background graphics checked'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![Wikipedia without the background graphics checked'
- en: '](img/Figure_7.06_B16113.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.06_B16113.jpg)'
- en: Wikipedia without the background graphics checked
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Wikipedia without the background graphics checked
- en: As you can see, the Wikipedia title is missing if you don't check the `SPAN`
    element. If you don't know about this flag, you might be scratching your head
    for several minutes, trying to see what's wrong with your code. Now you know that
    you have to consider `printBackground`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，如果你没有检查 `SPAN` 元素，维基百科的标题就会缺失。如果你不知道这个标志，你可能需要花几分钟时间挠头，试图找出你的代码哪里出了问题。现在你知道你必须考虑
    `printBackground`。
- en: There is one option that you won't see in the print dialog, and it's `preferCSSPageSize`.
    This property, whose default is false, will tell the browser to honor the `@page
    size` declared on the page over `width`/`height` or page `format`. Developers
    can use `@page size` ([https://www.hardkoded.com/ui-testing-with-puppeteer/pagesize](https://www.hardkoded.com/ui-testing-with-puppeteer/pagesize))
    to set the preferred page size when the page is printed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个选项你不会在打印对话框中看到，那就是 `preferCSSPageSize`。这个属性默认是 `false`，它会告诉浏览器在打印页面时优先考虑页面上的
    `@page size` 声明，而不是 `width`/`height` 或页面 `format`。开发者可以使用 `@page size` ([https://www.hardkoded.com/ui-testing-with-puppeteer/pagesize](https://www.hardkoded.com/ui-testing-with-puppeteer/pagesize))
    来设置打印时首选的页面大小。
- en: The last option is the most important. The function's output works in the same
    way as in the `screenshot` function. If you set the `path` property, a file will
    be generated in that path. Either way, the function's return value will be a Buffer
    (https://nodejs.org/api/buffer.html) with the binary representation of the PDF
    file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是最重要的。函数的输出与 `screenshot` 函数中的方式相同。如果你设置了 `path` 属性，将在该路径下生成一个文件。无论如何，函数的返回值将是一个包含
    PDF 文件二进制表示的 Buffer（https://nodejs.org/api/buffer.html）。
- en: 'Time to take a look at some code. In the following code, which you can see
    in the `pdfdemo.js` file, we are going to print www.wikipedia.org using the options
    we have learned:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看一些代码。在以下代码中，您可以在`pdfdemo.js`文件中看到，我们将使用我们学到的选项打印www.wikipedia.org：
- en: '[PRE7]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first thing to notice in this piece of code is that the `pdf` function
    only works in headless mode. If you call `pdf` while in headful, you will get
    an **Error: Protocol error (Page.printToPDF): PrintToPDF is not implemented**.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，首先要注意的是，`pdf`函数仅在无头模式下工作。如果您在完整模式下调用`pdf`，您将得到一个**错误：协议错误（Page.printToPDF）：PrintToPDF未实现**。
- en: The second thing to notice is that you need to set up a margin if you want to
    use footer and header templates. In my personal experience, I wouldn't use very
    complex templates here. Things can get nasty and hard to debug.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事要注意的是，如果您想使用页脚和页眉模板，您需要设置一个边距。根据我的个人经验，我不会在这里使用非常复杂的模板。事情可能会变得很糟糕，难以调试。
- en: The last thing to mention in the code is the CSS classes used in the template.
    As you can see, I'm leaving empty SPANs like `<span class="title"></span>` so
    the browser can replace them with real data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最后要提到的是模板中使用的CSS类。如您所见，我留空了SPAN，如`<span class="title"></span>`，以便浏览器可以用真实数据替换它们。
- en: 'This code will generate the following `headers.pdf` file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将生成以下`headers.pdf`文件：
- en: '![PDF output'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![PDF输出'
- en: '](img/Figure_7.07_B16113.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.07_B16113.jpg)'
- en: PDF output
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: PDF输出
- en: As you can see, we now have a custom header with a title and URL, a custom footer
    with the date and the pages, and, as we set `printBackground`, we are getting
    the Wikipedia logo.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在有一个带有标题和URL的自定义页眉，一个带有日期和页码的自定义页脚，并且由于我们设置了`printBackground`，我们得到了维基百科的标志。
- en: You might think that's it, but it's not. We have one more way to generate content.
    We will build our own pages on the fly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为这就结束了，但事实并非如此。我们还有另一种生成内容的方法。我们将实时构建我们的页面。
- en: Creating HTML content
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTML内容
- en: In this section, we will see a few simple features but pretty useful ones. You
    will be able to follow the code from this section in the `demohtml.js` file. Most
    of the time, you navigate pages using the HTTP protocol as we did with Wikipedia.
    If you open the `mediaprint.html` file, you navigated to that page using the pseudo
    protocol "file." Although it's not a real protocol, you should know that with
    Puppeteer, you can also navigate local files using a URL such as file:///some/folder/of/my/computer/mediaprint.html.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到一些简单但很有用的功能。您将能够从本节中的`demohtml.js`文件中跟踪代码。大多数时候，您会使用HTTP协议导航页面，就像我们使用维基百科一样。如果您打开`mediaprint.html`文件，您就是使用伪协议“file”导航到该页面的。尽管它不是一个真正的协议，但您应该知道，使用Puppeteer，您也可以使用类似file:///some/folder/of/my/computer/mediaprint.html的URL导航本地文件。
- en: So, if you want to generate a social image, like the HolyJS conference one we
    saw in the first section, you could create a page on your website, navigate to
    that page using Puppeteer, take a screenshot, and use that image in your social
    post.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您想生成一个社交图片，比如我们在第一部分看到的HolyJS会议图片，您可以在您的网站上创建一个页面，使用Puppeteer导航到该页面，截图，并在您的社交帖子中使用该图片。
- en: You could also have that file stored locally and navigate that file using the
    `file://` protocol.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以将此文件存储在本地，并使用`file://`协议导航该文件。
- en: What I want to show you in this section is that you don't necessarily need to
    have a file in your file system to generate that social image. You could have
    the HTML that you need in some external source, for instance, a content database,
    load that HTML in an empty page, and then take a screenshot.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在本节向您展示的是，您不一定需要在您的文件系统中有一个文件来生成那个社交图片。您可以在某些外部源中拥有所需的HTML，例如内容数据库，将HTML加载到一个空页面中，然后截图。
- en: 'We can do that using the `setContent` function. The signature is quite simple:
    `page.setContent(html[, options])`, where `html` is the HTML to load, and the
    `options` object, which supports two options you might already know: `timeout`
    and `waitUntil`. We need a `timeout` and a `waitUntil` property because the HTML
    we are loading might involve network requests, and we would need to wait for them.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`setContent`函数来做这件事。签名相当简单：`page.setContent(html[, options])`，其中`html`是要加载的HTML，`options`对象支持您可能已经知道的两个选项：`timeout`和`waitUntil`。我们需要`timeout`和`waitUntil`属性，因为我们加载的HTML可能涉及网络请求，我们需要等待它们。
- en: 'Let''s say we are assigned the task of creating that social media post. The
    content team tells us that we need to use the content `socialPostTemplate` from
    the `contentdb` component. We could do something like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被分配了创建社交媒体帖子的任务。内容团队告诉我们需要使用来自`contentdb`组件的`socialPostTemplate`内容模板。我们可以这样做：
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We load `contentdb` using the `require` function. Then we call `newPage`, which
    will give us an empty canvas, the `about:blank` page. Once we have the empty canvas,
    we load the HTML using `setContent`, take the screenshot, and close the page.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`require`函数加载`contentdb`。然后我们调用`newPage`，这将给我们一个空白的画布，即`about:blank`页面。一旦我们有了空白的画布，我们使用`setContent`加载HTML，然后截图并关闭页面。
- en: Once you call `setContent`, the page will be fully functional. That means that
    you could even call the `evaluate` function to customize and populate that template's
    values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你调用`setContent`，页面将完全可用。这意味着你甚至可以调用`evaluate`函数来自定义和填充该模板的值。
- en: One thing to consider is that the `setContent` function will override all the
    page content. You won't be able to append content using `setContent`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一点是，`setContent`函数将覆盖所有页面内容。你将无法使用`setContent`来追加内容。
- en: 'Two more functions will come in handy while creating new content. The first
    one is `page.addScriptTag(options)`, which will allow you to inject script tags
    into any page. These are the options available:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新内容时，还有两个函数会很有用。第一个是`page.addScriptTag(options)`，它将允许你将脚本标签注入到任何页面中。这些是可用的选项：
- en: You can pass `url`, to inject a JavaScript file from a URL.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以传递`url`，从URL注入JavaScript文件。
- en: You can also use `path` to inject a JavaScript file from a local file.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以使用`path`来从本地文件注入JavaScript文件。
- en: If you have the script in a memory variable, you can use `content` and set the
    entire script there.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将脚本存储在内存变量中，你可以使用`content`并将整个脚本设置在那里。
- en: Finally, you can pass `type`, which is the script type you can set to a script
    element ([https://www.hardkoded.com/ui-testing-with-puppeteer/scriptelement](https://www.hardkoded.com/ui-testing-with-puppeteer/scriptelement)).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你可以传递`type`，这是你可以设置到脚本元素的脚本类型（[https://www.hardkoded.com/ui-testing-with-puppeteer/scriptelement](https://www.hardkoded.com/ui-testing-with-puppeteer/scriptelement)）。
- en: You can use these two functions when you want to inject new functionality that
    wouldn't be solved with just an `evaluate` function call.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想注入新的功能，而这些功能不能仅通过`evaluate`函数调用解决时，你可以使用这两个函数。
- en: 'We also have `page.addStyleTag(options)`. It''s just like `addScriptTag`, but
    instead of injecting a script, you can inject a CSS file or content. The `addStyleTag`
    function has the same options as `addScriptTag`, except for the `type` option,
    which is not a valid option of the link element used to add CSS files. If we go
    back to PDF generation, you can use the following code to inject CSS content before
    generating a PDF file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`page.addStyleTag(options)`。它与`addScriptTag`类似，但不是注入脚本，而是可以注入CSS文件或内容。`addStyleTag`函数具有与`addScriptTag`相同的选项，除了`type`选项，这不是用于添加CSS文件的链接元素的合法选项。如果我们回到PDF生成，你可以使用以下代码在生成PDF文件之前注入CSS内容：
- en: '[PRE9]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this piece of code, we are hiding the search input before generating the
    PDF. This is a relatively simple change, but imagine all the things you would
    be able to set up in real-life scenarios.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们在生成PDF之前隐藏了搜索输入框。这是一个相对简单的更改，但想象一下在现实场景中你能设置的所有事情。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered many of my favorite features. Creating content is
    an unexpected use for a browser automation tool.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了许多我最喜欢的功能。使用浏览器自动化工具创建内容是一个意外的用途。
- en: We learned how to generate screenshots, use them for UI regression testing,
    and generate content for our websites. We also learned how to generate PDF files
    and all the options available. By the end of the chapter, we learned how to generate
    pages on the fly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何生成截图，用于UI回归测试，并为我们的网站生成内容。我们还学习了如何生成PDF文件以及所有可用的选项。到本章结束时，我们学习了如何动态生成页面。
- en: During this chapter, we also saw many features available in Chrome. I hope you
    learned some new tricks there.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还看到了许多Chrome中可用的功能。我希望你在那里学到了一些新技巧。
- en: In the next chapter, we will take our tests to the next level. We will learn
    how to test our websites by emulating different mobile devices and network conditions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们的测试提升到新的水平。我们将学习如何通过模拟不同的移动设备和网络条件来测试我们的网站。
