- en: Chapter 3. Application Structure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 应用程序结构
- en: We previously discussed how growing an application organically without any sense
    of architecture could result in an unmaintainable mess of spaghetti code. One
    of the great things about imposing structure is that it automatically gives predictability
    (a kind of filing system with in which we immediately know where a particular
    piece of code should live).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了在没有架构感的情况下有机地扩展应用程序可能会导致难以维护的混乱代码。强加结构的一个好处是它自动提供了可预测性（一种文件系统，我们立即知道特定代码片段应该放在哪里）。
- en: 'The same applies to the files that make up your application. Certainly, we
    could put all of our files in the root of the website, mixing CSS, JavaScript,
    configuration and HTML files in a long alphabetical list, but we''d be losing
    out on a number of opportunities to keep our application organized. In this chapter,
    we''ll look at:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于组成您应用程序的文件。当然，我们可以将所有文件放在网站根目录下，将CSS、JavaScript、配置和HTML文件混合在一个长的字母顺序列表中，但我们会失去许多保持应用程序组织的机会。在本章中，我们将探讨：
- en: Ideas to structure your code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码结构思路
- en: The layout of a typical Ext JS application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 典型Ext JS应用程序的布局
- en: Use of singletons, mixins, and inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例、混入和继承的使用
- en: Why global state is a bad thing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么全局状态是一个坏东西
- en: Structuring your application is like keeping your house in order. You'll know
    where to find your car keys, and you'll be prepared for unexpected guests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化您的应用程序就像保持您的房子整洁一样。您将知道在哪里找到您的车钥匙，并且您将准备好应对意外的客人。
- en: Ideas for structure
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化思路
- en: One of the ways in which code is structured in large applications involves namespacing
    (the practice of dividing code up by naming identifiers). One namespace could
    contain everything relating to Ajax, whereas another could contain classes related
    to mathematics. Programming languages (such as C# and Java) even incorporate namespaces
    as a first-class language construct to help with code organization.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序中，代码结构的一种方式涉及命名空间（通过命名标识符划分代码的实践）。一个命名空间可以包含所有与Ajax相关的代码，而另一个命名空间可以包含与数学相关的类。编程语言（如C#和Java）甚至将命名空间作为一等语言结构来帮助代码组织。
- en: 'Separating code from directories based on namespace becomes a sensible extension
    of this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据命名空间将代码与目录分离成为这一点的合理扩展：
- en: '![Ideas for structure](img/5308OT_03_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![结构化思路](img/5308OT_03_01.jpg)'
- en: 'From left: Java''s Platform API, Ext JS 5, and .NET Framework'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右：Java的Platform API、Ext JS 5和.NET Framework
- en: A namespace identifier is made up of one or more name tokens, such as "Java"
    or "Ext", "Ajax" or "Math", separated by a symbol, in most cases a full stop/period.
    The top level name will be an overarching identifier for the whole package (such
    as "Ext") and will become less specific as names are added and you drill down
    into the code base.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间标识符由一个或多个名称标记组成，例如"Java"或"Ext"、"Ajax"或"Math"，通常由一个符号分隔，通常是句号。顶级名称将是整个包的总体标识符（例如"Ext"），随着名称的增加和您深入代码库，它将变得更加具体。
- en: 'The Ext JS source code makes heavy use of this practice to partition UI components,
    utility classes, and all the other parts of the framework, so let''s look at a
    real example. The `GridPanel` component is perhaps one of the most complicated
    in the framework; a large collection of classes that contribute to features (such
    as columns, cell editing, selection, and grouping). These work together to create
    a highly powerful UI widget. Take a look at the following files that make up `GridPanel`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS源代码大量使用这种实践来划分UI组件、实用类以及框架的其他部分，因此让我们看看一个真实示例。`GridPanel`组件可能是框架中最复杂的组件之一；它包含大量贡献于功能（如列、单元格编辑、选择和分组）的类。这些类共同创建了一个功能强大的UI小部件。以下是一些组成`GridPanel`的文件：
- en: '![Ideas for structure](img/5308OT_03_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![结构化思路](img/5308OT_03_02.jpg)'
- en: The Ext JS grid component's directory structure
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS网格组件的目录结构
- en: The `grid` directory reflects the `Ext.grid` namespace. Likewise, the subdirectories
    are child namespaces with the deepest namespace being `Ext.grid.filters.filter`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid`目录反映了`Ext.grid`命名空间。同样，子目录是子命名空间，最深层的命名空间是`Ext.grid.filters.filter`。'
- en: 'The main `Panel` and `View` classes: `Ext.grid.Grid` and `Ext.grid.View` respectively
    are there in the main director. Then, additional pieces of functionality, for
    example, the `Column` class and the various column subclasses are further grouped
    together in their own subdirectories. We can also see a `plugins` directory, which
    contains a number of grid-specific plugins.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 `Panel` 和 `View` 类：分别是 `Ext.grid.Grid` 和 `Ext.grid.View`，它们位于主目录中。然后，其他功能组件，例如
    `Column` 类和各种列子类，被进一步分组到它们自己的子目录中。我们还可以看到一个 `plugins` 目录，其中包含多个针对网格的特定插件。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ext JS actually already has an `Ext.plugins` namespace. It contains classes
    to support the plugin infrastructure as well as plugins that are generic enough
    to apply across the entire framework. In the event of uncertainty regarding the
    best place in the code base for a plugin, we might mistakenly have put it in `Ext.plugins`.
    Instead, Ext JS follows best practice and creates a new, more specific namespace
    underneath `Ext.grid`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 实际上已经有一个 `Ext.plugins` 命名空间。它包含支持插件基础设施的类以及足够通用的插件，可以应用于整个框架。在不确定插件在代码库中最佳位置的情况下，我们可能会错误地将它放在
    `Ext.plugins` 中。相反，Ext JS 遵循最佳实践，在 `Ext.grid` 之下创建一个新的、更具体的命名空间。
- en: Going back to the root of the Ext JS framework, we can see that there are only
    a few files at the top level. In general, these will be classes that are either
    responsible for orchestrating other parts of the framework (such as `EventManager`
    or `StoreManager`) or classes that are widely reused across the framework (such
    as `Action` or `Component`). Any more specific functionality should be namespaced
    in a suitably specific way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Ext JS 框架的根目录，我们可以看到在顶层只有几个文件。一般来说，这些将是负责协调框架其他部分（如 `EventManager` 或 `StoreManager`）的类，或者是在整个框架中被广泛重用的类（如
    `Action` 或 `Component`）。任何更具体的功能都应该以适当具体的方式进行命名空间化。
- en: As a rule of thumb, you can take your inspiration from the organization of the
    Ext JS framework, though as a framework rather than a full-blown application.
    It's lacking some of the structural aspects we'll talk about shortly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，你可以从 Ext JS 框架的组织中获得灵感，尽管它是一个框架而不是一个完整的应用程序。它缺少我们很快将要讨论的一些结构方面。
- en: Getting to know your application
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解你的应用程序
- en: 'When generating an Ext JS application using Sencha Cmd, we end up with a code
    base that adheres to the concept of namespacing in class names and in the directory
    structure, as shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Sencha Cmd 生成 Ext JS 应用程序时，我们最终得到一个代码库，它遵循类名和目录结构中的命名空间概念，如下所示：
- en: '![Getting to know your application](img/5308OT_03_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![了解你的应用程序](img/5308OT_03_03.jpg)'
- en: The structure created with Sencha Cmd's "generate app" feature
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sencha Cmd 的 "generate app" 功能创建的结构
- en: We should be familiar with all of this, as it was already covered when we discussed
    MVVM in Ext JS. Having said that, there are some parts of this that are worth
    examining further to see whether they're being used to the full.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该熟悉所有这些内容，因为当我们讨论 Ext JS 中的 MVVM 时，这些内容已经被涵盖。话虽如此，其中一些部分值得进一步检查，看看它们是否被充分利用。
- en: /overrides
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: /overrides
- en: This is a handy one to help us fall into a positive and predictable pattern.
    There are some cases where you need to override Ext JS functionality on a global
    level. Maybe, you want to change the implementation of a low-level class (such
    as `Ext.data.proxy.Proxy`) to provide custom batching behavior for your application.
    Sometimes, you might even find a bug in Ext JS itself and use an override to hotfix
    until the next point release. The `overrides` directory provides a logical place
    to put these changes (just mirror the directory structure and namespacing of the
    code you're overriding). This also provides us with a helpful rule, that is, subclasses
    go in `/app` and overrides go in `/overrides`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很有用的工具，可以帮助我们进入一个积极且可预测的模式。有些情况下，你可能需要在全局级别覆盖 Ext JS 功能。也许，你想要更改低级类（如 `Ext.data.proxy.Proxy`）的实现，以提供你应用程序的定制批量行为。有时，你甚至可能会在
    Ext JS 本身中发现一个错误，并使用覆盖来热修复，直到下一个点发布。`overrides` 目录提供了一个合理的放置这些更改的地方（只需镜像你正在覆盖的代码的目录结构和命名空间）。这也为我们提供了一个有用的规则，即子类放在
    `/app` 目录，覆盖放在 `/overrides` 目录。
- en: /.sencha
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: /.sencha
- en: This contains configuration information and build files used by Sencha Cmd.
    In general, I'd say try and avoid fiddling around in here too much until you know
    Sencha Cmd inside out because there's a chance you'll end up with nasty conflicts
    if you try and upgrade to a newer version of Sencha Cmd. Fortunately, [Chapter
    4](ch04.html "Chapter 4. Sencha Cmd"), *Sencha Cmd*, is all about Sencha Cmd,
    where we'll dive deep into this folder.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了由 Sencha Cmd 使用的配置信息和构建文件。一般来说，我会建议你在完全了解 Sencha Cmd 之前尽量避免在这里过多地修改，因为如果你尝试升级到
    Sencha Cmd 的新版本，可能会遇到一些讨厌的冲突。幸运的是，[第 4 章](ch04.html "第 4 章。Sencha Cmd")，*Sencha
    Cmd*，全部都是关于 Sencha Cmd 的，我们将深入探讨这个文件夹。
- en: bootstrap.js, bootstrap.json, and bootstrap.css
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bootstrap.js, bootstrap.json, 和 bootstrap.css
- en: The Ext JS class system has powerful dependency management through the `requires`
    feature, which gives us the means to create a build that contains only the code
    that's in use. The bootstrap files contain information about the minimum CSS and
    JavaScript needed to run your application as provided by the dependency system.
    As we'll see in [Chapter 4](ch04.html "Chapter 4. Sencha Cmd"), *Sencha Cmd*,
    you can even create custom bootstrap files depending on your requirements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 类系统通过 `requires` 功能提供了强大的依赖管理，这使我们能够创建只包含使用中代码的构建。引导文件包含有关依赖系统提供的运行应用程序所需的最小
    CSS 和 JavaScript 的信息。正如我们将在 [第 4 章](ch04.html "第 4 章。Sencha Cmd")，*Sencha Cmd*
    中看到的那样，你甚至可以根据需求创建自定义的引导文件。
- en: /packages
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: /packages
- en: In a similar way to how Ruby has RubyGems and Node.js has npm, Sencha Cmd has
    the concept of packages (a bundle which can be pulled into your application from
    a local or remote source).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '与 Ruby 有 RubyGems 和 Node.js 有 npm 类似，Sencha Cmd 有包的概念（一个可以从本地或远程源拖入应用程序的包）。 '
- en: This allows you to reuse and publish bundles of functionality (including CSS,
    images, and other resources) to reduce copy and paste of code, and share your
    work with the Sencha community. This directory is empty until you configure packages
    to be used in your app.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你重用和发布功能包（包括 CSS、图像和其他资源）的集合，以减少代码的复制粘贴，并与 Sencha 社区分享你的工作。这个目录在你配置用于应用程序的包之前是空的。
- en: /resources and SASS
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: /resources 和 SASS
- en: SASS is a technology that aids in the creation of complex CSS by promoting reuse
    and bringing powerful features (such as mixins and functions) to your style sheets.
    Ext JS uses SASS for its theme files and encourages you to use it as well. We'll
    look at this in [Chapter 4](ch04.html "Chapter 4. Sencha Cmd"), *Sencha Cmd*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: SASS 是一种通过促进重用并引入强大的功能（如混合和函数）到样式表中来帮助创建复杂 CSS 的技术。Ext JS 使用 SASS 作为其主题文件，并鼓励你也这样做。我们将在
    [第 4 章](ch04.html "第 4 章。Sencha Cmd")，*Sencha Cmd* 中探讨这一点。
- en: index.html
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: index.html
- en: 'We know that `index.html` is the root HTML page of our application. It can
    be customized as you see fit (although, it''s rare you''ll need to). There''s
    one caveat and it''s written in a comment in the file already:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `index.html` 是我们应用程序的根 HTML 页面。它可以按需进行定制（尽管，你很少需要这样做）。这里有一个需要注意的地方，它已经在文件中的注释里写明了：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We know what `bootstrap.js` refers to (loading up our application and starting
    to fulfill its dependencies according to the current build), so heed the comment
    and leave this script tag well alone!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `bootstrap.js` 是指什么（加载我们的应用程序并开始根据当前构建满足其依赖），所以请注意注释，并让这个脚本标签保持原样！
- en: /build and build.xml
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: /build 和 build.xml
- en: The `/build` directory contains build artifacts (the files created when the
    build process is run). If you run a production build, then you'll get a directory
    inside `/build` called `production` and you should use only these files when deploying.
    The `build.xml` file allows you to avoid tweaking some of the files in `/.sencha`
    when you want to add some extra functionality to a build process. If you want
    to do something before, during, or after the build, this is the place to do it.
    We'll come back to the build process when we look at Sencha Cmd in [Chapter 4](ch04.html
    "Chapter 4. Sencha Cmd"), *Sencha Cmd*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`/build` 目录包含构建工件（在运行构建过程时创建的文件）。如果你运行生产构建，那么你会在 `/build` 目录内得到一个名为 `production`
    的目录，并且你应该在部署时只使用这些文件。`build.xml` 文件允许你在想要向构建过程添加一些额外功能时，避免修改 `/.sencha` 目录中的某些文件。如果你想在构建之前、期间或之后做些什么，这就是你要去的地方。当我们查看
    [第 4 章](ch04.html "第 4 章。Sencha Cmd")，*Sencha Cmd* 时，我们还会回到构建过程。'
- en: app.js
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: app.js
- en: This is the main JavaScript entry point to your application. The comments in
    this file advise avoiding editing it in order to allow Sencha Cmd to upgrade it
    in the future. The `Application.js` file at `/app/Application.js` can be edited
    without fear of conflicts and will enable you to do the majority of things you
    might need to do.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您应用程序的主要 JavaScript 入口点。此文件中的注释建议避免编辑它，以便允许 Sencha Cmd 在未来升级它。位于 `/app/Application.js`
    的 `Application.js` 文件可以放心编辑，而不会引起冲突，并使您能够完成可能需要做的绝大多数事情。
- en: app.json
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: app.json
- en: This contains configuration options related to Sencha Cmd and booting your application.
    We'll cover this more in [Chapter 4](ch04.html "Chapter 4. Sencha Cmd"), *Sencha
    Cmd*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含与 Sencha Cmd 和启动您的应用程序相关的配置选项。我们将在 [第 4 章](ch04.html "第 4 章。Sencha Cmd")
    中更详细地介绍，*Sencha Cmd*。
- en: When we refer to the subject of this book as a JavaScript application, we need
    to remember that it's just a website composed of HTML, CSS, and JavaScript as
    well. However, when dealing with a large application that needs to target different
    environments, it's incredibly useful to augment this simplicity with tools that
    assist in the development process. At first, it may seem that the default application
    template contains a lot of cruft, but they are the key to supporting the tools
    that will help you craft a solid product.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到这本书的主题作为 JavaScript 应用程序时，我们需要记住它只是一个由 HTML、CSS 和 JavaScript 组成的网站。然而，当处理需要针对不同环境的大型应用程序时，使用辅助开发过程工具来增强这种简单性非常有用。起初，可能看起来默认的应用程序模板包含了很多冗余，但它们是支持帮助你打造优质产品的工具的关键。
- en: Cultivating your code
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 培养你的代码
- en: As you build your application, there will come a point at which you create a
    new class and yet it doesn't logically fit into the directory structure Sencha
    Cmd created for you. Let's look at a few examples.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建应用程序时，将会有一个点，您会创建一个新的类，但它逻辑上不适合 Sencha Cmd 为您创建的目录结构。让我们看看一些例子。
- en: I'm a lumberjack – let's go log in
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我是一名伐木工 - 让我们去登录
- en: 'Many applications have a centralized `SessionManager` to take care of the currently
    logged in user, perform authentication operations, and set up persistent storage
    for session credentials. There''s only one `SessionManager` in an application.
    A truncated version might look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序都有一个集中的 `SessionManager` 来处理当前登录用户，执行身份验证操作，并为会话凭证设置持久存储。一个应用程序中只有一个 `SessionManager`。一个简化的版本可能看起来像这样：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We create a singleton class. This class doesn''t have to be instantiated using
    the new keyword. As per its class name, `CultivateCode.SessionManager`, it''s
    a top-level class and so it goes in the top-level directory. In a more complicated
    application, there could be a dedicated `Session` class too and some other ancillary
    code, so we''d create the following structure:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个单例类。这个类不需要使用 new 关键字来实例化。根据其类名 `CultivateCode.SessionManager`，它是一个顶级类，因此它位于顶级目录中。在一个更复杂的应用程序中，可能还有一个专门的
    `Session` 类和一些其他辅助代码，因此我们会创建以下结构：
- en: '![I''m a lumberjack – let''s go log in](img/5308OT_03_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![我是一名伐木工 - 让我们去登录](img/5308OT_03_04.jpg)'
- en: The directory structure for our session namespace
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会话命名空间的目录结构
- en: 'What about user interface elements? There''s an informal practice in the Ext
    JS community that helps here. We want to create an extension that shows the coordinates
    of the currently selected cell (similar to cell references in Excel). In this
    case, we''d create an `ux` directory—user experience or user extensions—and then
    go with the naming conventions of the Ext JS framework:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用户界面元素呢？在 Ext JS 社区中有一个非正式的实践可以帮助这里。我们想要创建一个扩展，显示当前选中单元格的坐标（类似于 Excel 中的单元格引用）。在这种情况下，我们会创建一个
    `ux` 目录——用户体验或用户扩展——然后遵循 Ext JS 框架的命名约定：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It looks a little like this, triggering when you click on a grid cell:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来有点像这样，当您点击网格单元格时触发：
- en: '![I''m a lumberjack – let''s go log in](img/5308OT_03_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![我是一名伐木工 - 让我们去登录](img/5308OT_03_05.jpg)'
- en: 'Also, the corresponding directory structure follows directly from the namespace:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，相应的目录结构直接来自命名空间：
- en: '![I''m a lumberjack – let''s go log in](img/5308OT_03_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![我是一名伐木工 - 让我们去登录](img/5308OT_03_06.jpg)'
- en: You can probably see a pattern emerging already.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到了一个模式的出现。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We've mentioned before that organizing an application is often about setting
    things up to fall into a position of success. A positive pattern like this is
    a good sign that you're doing things right.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，组织一个应用程序通常关于设置事情以成功落位。这种积极的模式是一个好兆头，表明你正在做正确的事情。
- en: We've got a predictable system that should enable us to create new classes without
    having to think too hard about where they're going to sit in our application.
    Let's take a look at one more example of a mathematics helper class (one that
    is a little less obvious).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个可预测的系统，应该能够使我们创建新类而无需过多考虑它们将在我们的应用程序中的位置。让我们再看看一个数学辅助类的例子（一个稍微不那么明显的例子）。
- en: 'Again, we can look at the Ext JS framework itself for inspiration. There''s
    an `Ext.util` namespace containing over 20 general classes that just don''t fit
    anywhere else. So, in this case, let''s create `CultivateCode.util.Mathematics`
    that contains our specialized methods for numerical work:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以看看 Ext JS 框架本身以获得灵感。有一个 `Ext.util` 命名空间，包含超过 20 个通用类，这些类根本无处可放。所以，在这种情况下，让我们创建
    `CultivateCode.util.Mathematics`，它包含我们用于数值工作的专用方法：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is one caveat here and it's an important one. There's a real danger that
    rather than thinking about the namespace for your code and its place in your application,
    a lot of stuff ends up under the `utils` namespace, thereby defeating the whole
    purpose. Take time to carefully check whether there's a more suitable location
    for your code before putting it in the `utils` bucket.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个需要注意的地方，而且非常重要。有一个真正的危险，那就是在考虑你的代码命名空间及其在应用程序中的位置时，很多内容最终都放在了 `utils` 命名空间下，从而违背了整个目的。在将代码放入
    `utils` 桶之前，花时间仔细检查是否有更适合的位置。
- en: 'This is particularly applicable if you''re considering adding lots of code
    to a single class in the `utils` namespace. Looking again at Ext JS, there are
    lots of specialized namespaces (such as `Ext.state` or `Ext.draw`). If you were
    working with an application with lots of mathematics, perhaps you''d be better
    off with the following namespace and directory structure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其适用于你考虑在 `utils` 命名空间中向单个类添加大量代码的情况。再次看看 Ext JS，有许多专门的命名空间（例如 `Ext.state`
    或 `Ext.draw`）。如果你正在处理一个包含大量数学的应用程序，你可能更倾向于以下命名空间和目录结构：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The directory structure for the math namespace is shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了数学命名空间的目录结构：
- en: '![I''m a lumberjack – let''s go log in](img/5308OT_03_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![我是一名伐木工 – 让我们去登录](img/5308OT_03_07.jpg)'
- en: This is another situation where there is no definitive right answer. It will
    come to you with experience and will depend entirely on the application you're
    building. Over time, putting together these high-level applications, building
    blocks will become second nature.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个没有明确正确答案的情况。它将随着经验而来，并且完全取决于你正在构建的应用程序。随着时间的推移，构建这些高级应用程序的构建块将变得习以为常。
- en: Money can't buy class
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金钱买不到类
- en: 'Now that we''re learning where our classes belong, we need to make sure that
    we''re actually using the right type of class. Here''s the standard way of instantiating
    an Ext JS class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在学习我们的课程属于哪里，我们需要确保我们实际上正在使用正确的类类型。以下是实例化 Ext JS 类的标准方式：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, think about your code. Think how rare it's in Ext JS to actually manually
    invoke `Ext.create`. So, how else are the class instances created?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑一下你的代码。想想在 Ext JS 中手动调用 `Ext.create` 是多么罕见。那么，类实例又是如何创建的呢？
- en: Singletons
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单例
- en: A singleton is simply a class that only has one instance across the lifetime
    of your application. There are quite a number of singleton classes in the Ext
    JS framework. While the use of singletons in general is a contentious point in
    software architecture, they tend to be used fairly well in Ext JS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 单例只是一个在应用程序生命周期中只有一个实例的类。在 Ext JS 框架中有很多单例类。虽然单例在软件架构中通常是一个有争议的点，但在 Ext JS 中它们通常被很好地使用。
- en: 'It could be that you prefer to implement the mathematical functions (we discussed
    earlier) as a singleton. For example, the following command could work:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你更喜欢将数学函数（我们之前讨论过）实现为单例。例如，以下命令可能可行：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, most developers would implement a circle class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数开发者会实现一个圆形类：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This keeps the circle-related functionality partitioned off into the circle
    class. It also enables us to pass the circle variable round to other functions
    and classes for additional processing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将圆形相关的功能分区到圆形类中。它还使我们能够将圆形变量传递给其他函数和类进行额外处理。
- en: On the other hand, look at `Ext.Msg`. Each of the methods here are fired and
    forgotten, there's never going to be anything to do further actions on. The same
    is true of `Ext.Ajax`. So, once more we find ourselves with a question that does
    not have a definitive answer. It depends entirely on the context.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，看看`Ext.Msg`。这里的方法都会被触发并遗忘，永远不会有什么进一步的操作。`Ext.Ajax`也是同样的情况。因此，我们再次发现自己面临一个没有明确答案的问题。这完全取决于上下文。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This is going to happen a lot, but it's a good thing! This book isn't going
    to teach you a list of facts and figures; it's going to teach you to think for
    yourself. Read other people's code and learn from experience. This isn't coding
    by numbers!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会发生很多次，但这是好事！这本书不会教你一串事实和数字；它会教你独立思考。阅读他人的代码并从经验中学习。这不是按数字编码！
- en: 'The other place you might find yourself reaching for the power of the singleton
    is when you''re creating an overarching manager class (such as the inbuilt `StoreManager`
    or our previous `SessionManager` example). One of the objections about singletons
    is that they tend to be abused to store lots of global state and break down the
    separation of concerns we''ve set up in our code, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现自己需要使用单例（singleton）的强大功能的地方是在创建一个全局管理类（例如内置的`StoreManager`或我们之前的`SessionManager`示例）。关于单例的一个反对意见是，它们往往会滥用以存储大量的全局状态，并破坏我们在代码中设置的职责分离，如下所示：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'No one wants to see this sort of thing in a code base. It brings behavior and
    state to a high level in the application. In theory, any part of the code base
    could call this manager with unexpected results. Instead, we''d do something like
    this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人想在代码库中看到这类东西。它将行为和状态提升到应用的高层次。理论上，代码库的任何部分都可能调用这个管理器并产生意外的结果。相反，我们会这样做：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We still have the same behavior (a way of collecting together grids), but now,
    it's limited to a more contextually appropriate part of the grid. Also, we're
    working with the MVVM system. We avoid global state and organize our code in a
    more correct manner. A win all round.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有相同的行为（一种收集网格的方式），但现在，它被限制在更符合上下文的部分。此外，我们正在使用MVVM系统。我们避免全局状态，并以更正确的方式组织我们的代码。这是一场全面的胜利。
- en: As a general rule, if you can avoid using a singleton, do so. Otherwise, think
    very carefully to make sure that it's the right choice for your application and
    that a standard class wouldn't better fit your requirements. In the previous example,
    we could have taken the easy way out and used a manager singleton, but it would
    have been a poor choice that would compromise the structure of our code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，如果你可以避免使用单例，就请这样做。否则，要非常仔细地考虑，确保它是你应用程序的正确选择，并且标准类更适合你的需求。在先前的示例中，我们可以选择走捷径并使用管理单例，但这将是一个糟糕的选择，会损害我们代码的结构。
- en: Mixins
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混入
- en: 'We''re used to the concept of inheriting from a subclass in Ext JS—a grid extends
    a panel to take on all of its functionality. Mixins provide a similar opportunity
    to reuse functionality to augment an existing class with a thin slice of behavior.
    In *Code Complete Second Edition*, *Steve McConnell*, *Microsoft Press US*, *Section
    6.3*, McConnell says:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于在Ext JS中从子类继承的概念——一个网格扩展了一个面板以承担其所有功能。混入提供了类似的机会来复用功能，通过添加一小部分行为来增强现有的类。在《代码大全第二版》中，Steve
    McConnell，Microsoft Press US，第6.3节，McConnell说：
- en: '*"Think of containment as a "has a" relationship. A car "has an" engine, a
    person "has a" name, etc."*'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"将封装视为一个“拥有”关系。一辆车“拥有”一个引擎，一个人“拥有”一个名字，等等。”*'
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*"Think of inheritance as an "is a" relationship. A car "is a" vehicle, a person
    "is a" mammal, etc."*'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"将继承视为一个“是”关系。一辆车“是”一个车辆，一个人“是”一个哺乳动物，等等。”*'
- en: An `Ext.Panel` "is an" `Ext.Component`, but it also "has a" pinnable feature
    that provides a pin tool via the `Ext.panel.Pinnable` mixin.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.Panel`“是”一个`Ext.Component`，但它也“拥有”一个可固定的特性，该特性通过`Ext.panel.Pinnable`混入提供了一个固定工具。'
- en: 'In your code, you should be looking at mixins to provide a feature, particularly
    in cases where this feature can be reused. In the next example, we''ll create
    a UI mixin called `shakeable`, which provides a UI component with a shake method
    that draws the user''s attention by rocking it from side to side:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中，你应该查看混入（mixins）以提供功能，尤其是在这个功能可以被复用的场合。在下一个示例中，我们将创建一个名为`shakeable`的UI混入，它提供了一个具有摇动方法的UI组件，通过从一侧摇到另一侧来吸引用户的注意力：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use the `animate` method (which itself is actually mixed in `Ext.Element`)
    to set up some animation keyframes to move the component''s element first left,
    then right, then back to its original position. Here''s a class that implements
    it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`animate`方法（它本身实际上是混合在`Ext.Element`中的）来设置一些动画关键帧，首先移动组件的元素向左，然后向右，最后回到原始位置。下面是一个实现它的类：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also it''s used like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 也像这样使用：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The button has taken on the new shake method provided by the mixin. Now, if
    we'd like a class to have the `shakeable` feature, we can reuse this mixin where
    necessary.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮已经采用了混合提供的新的`shake`方法。现在，如果我们想让一个类具有`shakeable`特性，我们可以在必要时重用这个混合。
- en: In addition, mixins can simply be used to pull out the functionality of a class
    into logical chunks, rather than having a single file of many thousands of lines.
    `Ext.Component` is an example of this. In fact, most of its core functionality
    is found in classes that are mixed in `Ext.Component`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，混合可以简单地用来将类的功能提取到逻辑块中，而不是有一个包含数千行代码的单个文件。`Ext.Component`就是这样一个例子。事实上，其大部分核心功能都存在于混合在`Ext.Component`中的类中。
- en: 'This is also helpful when navigating a code base. Methods that work together
    to build a feature can be grouped and set aside in a tidy little package. Let''s
    take a look at a practical example of how an existing class could be refactored
    using a mixin. Here''s the skeleton of the original:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这在导航代码库时也很有用。共同构建一个特性的方法可以被分组并放在一个整洁的小包中。让我们看看一个使用混合重构现有类的实际例子。以下是原始类的框架：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `MetaPanel` does two things that the normal `FormPanel` does not:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`MetaPanel`做了两件事，这是正常`FormPanel`所不具备的：
- en: It reads the `Ext.data.Fields` from an `Ext.data.Model` and automatically generates
    a form layout based on these fields. It can also generate field sets if the fields
    have the same group configuration value.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从`Ext.data.Model`读取`Ext.data.Fields`，并自动根据这些字段生成表单布局。如果字段具有相同的组配置值，它还可以生成字段集。
- en: When the values of the form change, it persists them to `localStorage` so that
    the user can navigate away and resume completing the form later. This is useful
    for long forms.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当表单的值发生变化时，它会将它们持久化到`localStorage`，这样用户就可以离开并稍后继续完成表单。这对于长表单很有用。
- en: 'In reality, implementing these features would probably require additional methods
    to the ones shown in the previous code skeleton. As the two extra features are
    clearly defined, it''s easy enough to refactor this code to better describe our
    intent:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，实现这些功能可能需要比之前代码框架中显示的更多方法。由于两个额外功能定义得非常明确，重构此代码以更好地描述我们的意图是很容易的：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have a much shorter file and the behavior we're including in this class is
    described a lot more concisely. Rather than seven or more method bodies that may
    span a couple of hundred lines of code, we have two mixin lines and the relevant
    methods extracted to a well-named mixin class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个更短的文件，并且在这个类中包含的行为描述得更加简洁。而不是七个或更多可能跨越几百行代码的方法体，我们只有两行混合代码，并且相关的方法被提取到一个命名良好的混合类中。
- en: The solution to pollution
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 污染的解决方案
- en: In essence, we're striving to make sure that a newcomer to a project is never
    surprised by what they see. Everything should be clearly labeled, decisions should
    have logic behind them, and code should be in a place that makes sense for its
    functionality. We've briefly touched on how a namespace (such as `utils`) can
    become a "bucket" for code that doesn't immediately fit. There are a couple of
    other situations in which we find ourselves creating a dumping ground for functions
    that nobody knows what to do with.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，我们努力确保新加入项目的成员不会对所见到的内容感到惊讶。一切都应该有明确的标签，决策应该有逻辑支撑，代码应该放在对功能有意义的地点。我们简要地讨论了如何将命名空间（如`utils`）变成不适合立即使用的代码的“桶”。还有一些其他情况，我们会发现自己为那些无人知晓如何使用的函数创建了一个垃圾场。
- en: A global solution to a local problem
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对局部问题的全局解决方案
- en: Our hero, the plucky programmer with a lot of heart and a burgeoning talent,
    is writing their latest application when they realize something.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的英雄，一个充满热情且才华横溢的程序员，在编写他们最新的应用程序时意识到一件事。
- en: '*I''m going to need this function a lot; potentially, in most of my UI components.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*我可能需要这个函数很多次；可能在我的大多数UI组件中都需要。*'
- en: Worried, they consider the best way to implement it, then the best place for
    it to fit in the existing code base.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 担忧之下，他们考虑了实现它的最佳方式，以及它在现有代码库中的最佳位置。
- en: I need to call it from anywhere in the application. Also, my application class
    is already available from everywhere in the app; I'll hang it off there. `MyApp.myFunc()`,
    here we come!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要在应用程序的任何地方调用它。此外，我的应用程序类已经在应用程序的任何地方可用；我会在那里挂载它。`MyApp.myFunc()`，我们来了！
- en: And so our hero starts down the road to madness. `MyApp.isUserLoggedIn()`, they
    ask? `MyApp.isProduction()` or `MyApp.isStaging()`, they wonder? Also, for convenient
    access to configuration, we have the `MyApp.validNames` and `MyApp.apiUrl` arrays.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的英雄开始踏上疯狂的道路。他们会问`MyApp.isUserLoggedIn()`吗？他们会想`MyApp.isProduction()`或`MyApp.isStaging()`吗？此外，为了方便访问配置，我们有`MyApp.validNames`和`MyApp.apiUrl`数组。
- en: '*Look on my global state ye mighty, and despair!*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*看看我的全局状态吧，你伟大的存在，绝望吧！*'
- en: 'A little melodrama to get the point across. It''s very easy to use your application
    singleton as an easy catch-all as shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种夸张的戏剧手法，以便传达观点。使用你的应用程序单例作为简单的万能工具非常容易，就像这里展示的那样：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What would be the right thing to do here? Well, `searchCfg` needs to be moved
    to the place it's used, perhaps a search model or view model, maybe on the UI
    component responsible for search.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里应该做什么才是正确的呢？嗯，`searchCfg`需要移动到它被使用的地方，可能是一个搜索模型或视图模型，也许是在负责搜索的UI组件上。
- en: The Ajax overrides and error handling could be moved to the `/overrides` folder
    and positioned within their correct namespaces, making them much more discoverable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax重写和错误处理可以移动到`/overrides`文件夹，并放置在它们正确的命名空间中，这使得它们更容易被发现。
- en: The cookie check, which makes sure users have cookies enabled on their browser,
    could probably be retained in the application class, simply because in this app,
    cookies could be a requirement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 确保用户在浏览器上启用了cookie的cookie检查可能保留在应用程序类中，仅仅因为在这个应用程序中，cookie可能是一个要求。
- en: Things such as `isLoggedIn` would be best taken care of by a `SessionManager`,
    as we previously discussed. Still in a singleton, but a singleton that is in a
    more discoverable and logical place for this functionality.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前的讨论中提到的，像`isLoggedIn`这样的东西最好由`SessionManager`来处理。仍然是一个单例，但这是一个更易于发现和逻辑上更合适的功能位置的单例。
- en: 'In another place, we can take our cue from the Ext JS framework: `setMasked`.
    Rather than having this as a method on the application, Ext JS provides it as
    a method on each `Ext.Container`, meaning you can call it directly on panels and
    grids. This means that the code that masks components will no longer jump up to
    the global application scope and hope that it''s targeting the correct container.
    Instead, you can be certain that you''re affecting the component you''re interested
    in and nothing more, and all without polluting your global application class.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个地方，我们可以从Ext JS框架那里得到启示：`setMasked`。而不是在应用程序上作为方法，Ext JS将其作为每个`Ext.Container`上的方法提供，这意味着你可以直接在面板和网格上调用它。这意味着将组件遮罩的代码将不再跳到全局应用程序范围并希望它指向正确的容器。相反，你可以确信你正在影响你感兴趣的组件，而不会影响其他任何东西，而且这一切都不需要污染你的全局应用程序类。
- en: Summary – mind your own beeswax
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述——管好自己的事
- en: In this chapter, we drove several points home.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们强调了几个要点。
- en: When it comes to structuring your application, make life easy for yourself.
    Go for the principle of least surprise and don't pile all of your classes in a
    single namespace.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构建你的应用程序时，让自己生活得更容易。遵循最小惊讶原则，不要把所有的类堆在一个命名空间中。
- en: Keep your code in manageable blocks using architectural devices such as mixins.
    When you look in a class, you don't want to see thousands of meandering lines,
    but want a concise logical unit.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如mixins这样的架构设备来保持你的代码在可管理的块中。当你查看一个类时，你不想看到数千行蜿蜒的代码，而希望看到一个简洁的逻辑单元。
- en: 'Use the Ext JS framework as structural inspiration. It may not be 100 percent,
    but it does show us something very important, which should inform every aspect
    of your application architecture: having a system is always better than not having
    one and you should be consistent at all times.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将Ext JS框架作为结构上的灵感来源。它可能不是100%，但它确实向我们展示了非常重要的一点，这应该指导你应用程序架构的各个方面：有一个系统总是比没有系统要好，并且你应该始终保持一致性。
- en: In the next chapter, we will look at Sencha Cmd, a tool that goes hand in hand
    with Ext JS to help us generate, develop, and deploy our applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Sencha Cmd，这是一个与Ext JS携手并进的工具，帮助我们生成、开发和部署我们的应用程序。
