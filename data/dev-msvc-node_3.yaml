- en: Chapter 3. From the Monolith to Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 从单体到微服务
- en: 'In my professional life, I have worked in quite a few different companies,
    mainly in financial services, and all of the companies that I have worked for
    follow the same pattern as shown in the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我在许多不同的公司工作过，主要是在金融服务领域，我为所有工作过的公司都遵循了以下相同的模式：
- en: 'A company is set up by a couple of people with good domain knowledge: insurance,
    payments, credit cards, and so on.'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一家公司是由一些具有良好领域知识的人建立的：保险、支付、信用卡等等。
- en: The company grows, demanding new business requirements that need to be satisfied
    quickly (regulation, big customers demanding silly things, and so on), which are
    built in a hurry with little to no planning.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公司增长，需要满足新的业务需求（监管、大客户要求愚蠢的事情等），这些需求匆忙建立，几乎没有规划。
- en: The company experiences another phase of growing, where the business transactions
    are clearly defined and poorly modelled by a hard-to-maintain monolithic software.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公司经历了另一个增长阶段，业务交易明确定义，但被难以维护的单片软件模糊建模。
- en: The company increases the headcount that drives into growing pains and loss
    of efficiency due to restrictions imposed on how the software was built in the
    first instance.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公司增加了员工人数，导致增长痛苦和效率损失，因为软件建立时受到了限制。
- en: This chapter is not only about how to avoid the previous flow (uncontrolled
    organic growth), but it is also about how to model a new system using microservices.
    This chapter is the soul of this book, as I will try to synthetize my experience
    in a few pages, setting up the principles to be followed in [Chapter 4](ch04.html
    "Chapter 4. Writing Your First Microservice in Node.js"), *Writing Your First
    Microservice in Node.js*, where we will be building a full system based on microservices
    using the lessons learned in the previous chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章不仅关于如何避免之前的流程（不受控制的有机增长），还关于如何使用微服务模型一个新系统。这一章是本书的灵魂，我将在几页中尝试综合我的经验，建立在前几章中学到的原则上，[第四章](ch04.html
    "第四章. 用Node.js编写你的第一个微服务")中，我们将基于微服务构建一个完整的系统，使用前几章中学到的经验。
- en: First, there was the monolith
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先是单体
- en: A huge percentage (my estimate is around 90%) of the modern enterprise software
    is built following a monolithic approach.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现代企业软件的巨大比例（我估计约为90%）是按照单体方法构建的。
- en: 'Large software components that run in a single container and have a well-defined
    development life cycle, which goes completely against the agile principles, deliver
    early and deliver often ([https://en.wikipedia.org/wiki/Release_early,_release_often](https://en.wikipedia.org/wiki/Release_early,_release_often)),
    as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大型软件组件在单个容器中运行，并且具有明确定义的开发生命周期，这完全违反了敏捷原则，早交付和经常交付（[https://en.wikipedia.org/wiki/Release_early,_release_often](https://en.wikipedia.org/wiki/Release_early,_release_often)）。
- en: '**Deliver early**: The sooner you fail, the easier it is to recover. If you
    are working for two years on a software component and then it is released, there
    is a huge risk of deviation from the original requirements, which are usually
    wrong and change every few days.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**早交付**：失败得越早，恢复就越容易。如果你在一个软件组件上工作了两年，然后发布，那么与原始要求偏离的风险很大，而原始要求通常是错误的，并且每隔几天就会改变一次。'
- en: '**Deliver often**: Delivering often, the stakeholders are aware of the progress
    and can see the changes reflected quickly in the software. Errors can be fixed
    in a few days and improvements are identified easily.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经常交付**：经常交付，利益相关者可以意识到进展，并可以在软件中快速看到变化。错误可以在几天内修复，改进很容易被识别。'
- en: 'Companies build big software components instead of smaller ones that work together
    as it is the natural thing to do, as shown in the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 公司构建大型软件组件，而不是一起工作的较小组件，这是自然的事情，如下所示：
- en: The developer has a new requirement.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员有了新的要求。
- en: He builds a new method on an existing class on the service layer.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他在服务层的现有类上构建了一个新的方法。
- en: The method is exposed on the API via HTTP, SOAP, or any other protocol.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法通过HTTP、SOAP或任何其他协议在API上公开。
- en: Now, multiply it by the number of developers in your company, and you will obtain
    something called **organic growth**. Organic growth is a type of *uncontrolled
    and unplanned* growth on software systems under business pressure without an adequate
    long-term planning, and it is bad.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将开发人员的数量乘以，你将得到一种称为**有机增长**的东西。有机增长是一种在业务压力下对软件系统进行*不受控制和无计划*的增长，而且是不好的。
- en: How to tackle organic growth?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何解决有机增长？
- en: The first thing required to tackle organic growth is to make sure that the business
    and IT are aligned in the company. Usually, in big companies, IT is not seen as
    a core part of the business.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 解决有机增长的第一件事是确保公司的业务和IT是对齐的。通常，在大公司中，IT并不被视为业务的核心部分。
- en: 'Organizations outsource their IT systems, keeping the price in mind, but not
    the quality so that the partners building these software components are focused
    on one thing: *deliver on time* and according to the specifications even if they
    are incorrect.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 组织外包其IT系统，考虑价格，但不考虑质量，因此构建这些软件组件的合作伙伴专注于一件事：*按时交付*并根据规格进行交付，即使规格是不正确的。
- en: This produces a less-than-ideal ecosystem to respond to the business needs with
    a working solution for an existing problem. IT is lead by people who barely understand
    how the systems are built, and usually overlook the complexity of software development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个不太理想的生态系统，无法以现有问题的工作解决方案来响应业务需求。IT由几乎不了解系统构建方式的人领导，并且通常忽视软件开发的复杂性。
- en: Fortunately, this is a changing tendency as IT systems become the driver of
    99% of the businesses around the world, but we need to get smarter about how we
    build them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，随着IT系统成为全球99%企业的驱动力，这种趋势正在改变，但我们需要更聪明地构建它们。
- en: 'The first measure to tackle organic growth is aligning IT and business stakeholders
    to work together: educating the nontechnical stakeholders is the key to success.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解决有机增长的第一步是使IT和业务利益相关者协同工作：教育非技术利益相关者是成功的关键。
- en: If we go back to the few big releases schema. Can we do it better?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到少量大版本的模式。我们能做得更好吗？
- en: Of course we can. Divide the work into manageable software artifacts that model
    a single, well-defined business activity and give it an entity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然可以。将工作分成可管理的软件构件，模拟一个明确定义的业务活动并赋予其实体。
- en: It does not need to be a microservice at this stage, but keeping the logic inside
    of a separated, well-defined, easily testable, and decoupled module will give
    us a huge advantage for future changes in the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，它不需要成为微服务，但是将逻辑保持在一个分离的、定义良好、易于测试和解耦的模块内，将为我们在应用程序未来变更中带来巨大优势。
- en: 'Let''s consider the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：
- en: '![How to tackle organic growth?](img/B04889_03_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![如何应对有机增长？](img/B04889_03_01.jpg)'
- en: In this insurance system, you can see that someone was in a hurry. SMS and e-mail
    sender, although both are communication channels, they have a very different nature
    and you probably want them to act in different ways.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个保险系统中，你可以看到有人匆忙。短信和电子邮件发送者，尽管两者都是通信渠道，但它们的性质非常不同，你可能希望它们以不同的方式行事。
- en: 'The calling services are grouped into the following two high-level entities:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 调用服务分为以下两个高级实体：
- en: '**New Business**: The new customers that receive an e-mail when they sign up'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新业务**：新客户在注册时收到电子邮件'
- en: '**Renewals**: The existing customers that receive an SMS when the insurance
    policy is ready to be renewed'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**续保**：现有客户在保险政策准备续保时收到短信'
- en: At some point, the system needed to send SMSs and e-mails and someone created
    the communication service entity that handles all the third-party communications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，系统需要发送短信和电子邮件，有人创建了处理所有第三方通信的通信服务实体。
- en: It looks like a good idea in the beginning. SMS or e-mail, at the end of the
    day, is only a channel, the communication mechanism will be 90% same and we can
    reuse plenty of functionality.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始看起来是个好主意。短信或电子邮件，归根结底，只是一个通道，通信机制将90%相同，我们可以重复使用大量功能。
- en: What happens if we suddenly want to integrate a third-party service that handles
    all the physical post?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们突然想要集成一个处理所有实体邮件的第三方服务会发生什么？
- en: What happens if we want to add a newsletter that goes out to the customers once
    a week with information that we consider interesting for our customers?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加一个每周向客户发送我们认为有趣的信息的新闻简报会发生什么？
- en: The service will grow out of control and it will become more difficult to test,
    release, and ensure that the changes in the SMS code won't affect sending the
    e-mail in any form.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将失控，并且测试、发布和确保短信代码的更改不会以任何形式影响发送电子邮件将变得更加困难。
- en: 'This is organic growth and, in this case, it is related to a law called **Conway''s
    Law**, which states the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是有机增长，在这种情况下，它与一条称为**康威定律**的法律有关，该定律陈述如下：
- en: '*Any organization that designs a system (defined more broadly here than just
    information systems) will inevitably produce a design whose structure is a copy
    of the organization''s communication structure.*'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*任何设计系统的组织（此处定义比信息系统更广泛）都将不可避免地产生一个结构与组织通信结构相同的设计。*'
- en: In this case, we are falling into a trap. We are trying to model the communication
    on a single software component that is probably too big and complex to react quickly
    to new business needs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们陷入了一个陷阱。我们试图对一个可能太大和复杂以至于无法迅速应对新业务需求的单个软件组件进行建模通信。
- en: 'Let''s take a look at the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的图表：
- en: '![How to tackle organic growth?](img/B04889_03_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![如何应对有机增长？](img/B04889_03_02.jpg)'
- en: Now, we have encapsulated every communication channel on its own service (which,
    later on, will be deployed as a microservice) and we will do the same for future
    communication channels.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将每个通信渠道封装到自己的服务中（稍后将部署为微服务），并且我们将对未来的通信渠道采取同样的做法。
- en: 'This is the first step to beat organic growth: create fine-grained services
    with well-defined boundaries and a single responsibility—*do something small,
    but do it well*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是击败有机增长的第一步：创建细粒度的服务，具有明确定义的边界和单一责任—*做一些小事，但做得很好*。
- en: How abstract is too abstract?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象到什么程度才算太抽象？
- en: Our brain can't handle complicated mechanisms. The abstraction capacity is one
    of the most recent human intelligence acquisitions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大脑无法处理复杂的机制。抽象能力是人类智力最近的获取之一。
- en: 'In the example from the previous section, I''ve given something for good, which
    will upset half of the programmers in the world: *eradicating the abstraction
    of our system*.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节的示例中，我提出了一些对大部分程序员来说是好事的东西：*消除我们系统的抽象*。
- en: The abstraction capacity is something that we learn along the years and, unlike
    intelligence, it can be trained. Not everyone can reach the same level of abstraction,
    and if we mix the specific and complex domain knowledge required by some industries
    with a high-level of abstraction, we have the perfect recipe for a disaster.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象能力是我们多年来学到的东西，与智力不同，它是可以训练的。并非每个人都能达到相同的抽象水平，如果我们将某些行业所需的特定和复杂领域知识与高水平的抽象混合在一起，就会制造出灾难的完美配方。
- en: When building software, one of the golden rules that I always tried to follow
    (and try is the correct word, as I always find huge opposition to it) is to avoid
    premature abstraction.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建软件时，我总是试图遵循的黄金法则之一（试图是正确的词，因为我总是遇到巨大的反对意见）是避免过早的抽象。
- en: 'How many times did you find yourself in a corner with a simple set of requirements:
    *build a program to solve X*. However, your team goes off and anticipates all
    the possible variations of *X*, without even knowing if they are plausible. Then,
    once the software is in production, one of the stakeholders comes with a variation
    of *X* that you could have never imagined (as the requirements were not even correct)
    and now, getting this variation to work will cost you a few days and a massive
    refactor.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次发现自己在一个简单的需求集合中：*构建一个解决X的程序*。然而，您的团队却提前考虑了*X*的所有可能变化，甚至不知道它们是否可行。然后，一旦软件投入生产，利益相关者之一提出了一个您甚至无法想象的*X*的变化（因为需求甚至不正确），现在，让这个变化工作将花费您几天和大规模的重构。
- en: 'The way to avoid this problem is simple: *avoid abstraction without at least
    three use cases*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这个问题的方法很简单：*避免没有至少三个用例的抽象*。
- en: Do not factor in the possibility of sending the data through different types
    of channels as it might not happen and you are compromising the current feature
    with unnecessary abstractions. Once you have at least one other communication
    channel, it is time to start thinking about how these two software components
    can be designed better, and when the third use case shows up, refactor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不要考虑通过不同类型的渠道发送数据的可能性，因为这可能不会发生，而且您正在通过不必要的抽象来损害当前的功能。一旦您至少有另一个通信渠道，就是时候开始考虑如何更好地设计这两个软件组件了，当第三个用例出现时，进行重构。
- en: 'Remember that when building microservices, they should be small enough to be
    rewritten on a single sprint (around two weeks), so the benefits of having a working
    prototype in such a short period of time is worth the risk of having to rewrite
    it once the requirements are more concrete: something to show to the stakeholders
    is the quickest way to nail down the requirements.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在构建微服务时，它们应该足够小，可以在一个迭代周期内重写（大约两周），因此在这么短的时间内获得一个可工作的原型的好处是值得的，尽管有可能在需求更加具体时需要重写：向利益相关者展示东西是确定需求的最快方式。
- en: '**Seneca** is great in this regard as, through pattern matching, we can extend
    the API of a given microservice without affecting the existing calling code: our
    service is open for extension, but closed for modification (the SOLID principles)
    as we are adding functionality without affecting the existing one. We will see
    more complete examples of this behavior in [Chapter 4](ch04.html "Chapter 4. Writing
    Your First Microservice in Node.js"), *Writing Your First Microservice in Node.js*.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Seneca**在这方面非常出色，通过模式匹配，我们可以扩展给定微服务的API，而不影响现有的调用代码：我们的服务可以进行扩展，但对修改关闭（SOLID原则），因为我们正在添加功能而不影响现有功能。我们将在[第4章](ch04.html
    "第4章。在Node.js中编写您的第一个微服务")中看到更完整的示例，*在Node.js中编写您的第一个微服务*。'
- en: Then the microservices appeared
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 然后微服务出现了。
- en: Microservices are here to stay. Nowadays, the companies give more importance
    to the quality of the software. As stated in the previous section, deliver early
    and deliver often are the key to succeed in software development.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务已经成为一种趋势。如今，公司更加重视软件的质量。正如前一节所述，及早交付和频繁交付是软件开发成功的关键。
- en: Microservices are helping us to satisfy business needs as quickly as possible
    through modularity and specialization. Small pieces of software that can easily
    be versioned and upgraded within a few days and they are easy to test as they
    have a clear and small purpose (specialization) and are written in such a way
    that they are isolated from the rest of the system (modularization).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务正在通过模块化和专业化帮助我们尽快满足业务需求。这些小型软件片段可以很容易地进行版本控制和升级，只需几天就可以进行测试，因为它们具有明确而小的目的（专业化），并且以一种使它们与系统其他部分隔离的方式编写。
- en: Unfortunately, it is not common to find the situation as described previously.
    Usually, big software systems are not built in a way that modularization or specialization
    are easy to identify. The general rule is to build a big software component that
    does everything and the modularization is poor, so we need to start from the very
    basics.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，通常很少会出现如前所述的情况。通常，大型软件系统并不是以易于识别的模块化或专业化的方式构建的。一般规则是构建一个功能齐全的大型软件组件，而模块化很差，因此我们需要从非常基础的地方开始。
- en: 'Let''s start by writing some code, as shown in the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一些代码开始，如下所示：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, this module can be easily called **communications service**
    and it will be fairly easy to guess what it is doing. It manages the e-mail, SMS,
    and post communications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个模块可以很容易地被称为**通信服务**，并且很容易猜到它在做什么。它管理电子邮件、短信和邮件通信。
- en: 'This is probably too much. This service is deemed to grow out of control, as
    people will keep adding methods related to communications. This is the key problem
    of monolithic software: the bounded context spans across different areas, affecting
    the quality of our software from both functional and maintenance point of view.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能太多了。这个服务被认为会失控，因为人们会不断添加与通信相关的方法。这是单片软件的关键问题：边界上下文跨越不同领域，影响我们的软件质量，无论是从功能还是维护的角度来看。
- en: 'If you are a software developer, a red flag will be raised straightaway: the
    cohesion of this module is quite poor.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一名软件开发人员，这个模块的内聚性就会立即引起警觉。
- en: 'Although it could have worked for a while, we are now changing our mindset.
    We are building small, scalable, and autonomous components that can be isolated.
    The cohesion in this case is bad as the module is doing too many different things:
    e-mail, SMS, and post.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它可能已经运行了一段时间，但我们现在正在改变我们的思维方式。我们正在构建小型、可扩展和自治的组件，可以被隔离。在这种情况下，内聚性很差，因为该模块做了太多不同的事情：电子邮件、短信和邮件。
- en: What happens if we add another communication channel such as Twitter and Facebook
    notifications?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加另一个通信渠道，比如Twitter和Facebook通知，会发生什么？
- en: 'The service grows out of control. Instead of having small functional software
    components, you end up with a gigantic module that will be difficult to refactor,
    test, and modify. Let''s take a look at the following SOLID design principles,
    explained in [Chapter 2](ch02.html "Chapter 2. Microservices in Node.js – Seneca
    and PM2 Alternatives"), *Microservices in Node.js – Seneca and PM2 Alternatives*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 服务变得失控。你不再拥有小型的功能软件组件，而是拥有一个庞大的模块，这将很难重构、测试和修改。让我们来看看下面的SOLID设计原则，解释在[第2章](ch02.html
    "第2章 微服务在Node.js中的应用 - Seneca和PM2替代方案")中：*Node.js中的微服务 - Seneca和PM2替代方案*：
- en: '**Single-responsibility principle**: The module does too many things.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一责任原则**：模块做了太多的事情。'
- en: '**Open for extension, closed for modification**: The module will need to be
    modified to add new functionalities and probably change the common code.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放扩展，关闭修改**：模块需要被修改以添加新的功能，可能需要改变公共代码。'
- en: '**Liskov Substitution**: We will skip this one again.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Liskov替换**：我们将再次跳过这个。'
- en: '**Interface segregation**: We don''t have any interface specified in the module,
    just the implementation of an arbitrary set of functions.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离**：模块中没有指定任何接口，只是一组任意函数的实现。'
- en: '**Dependency injection:** There is no dependency injection. The module needs
    to be built by the calling code.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**：没有依赖注入。模块需要由调用代码构建。'
- en: Things get more complicated if we don't have tests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有测试，事情会变得更加复杂。
- en: Therefore, let's split it into various small modules using Seneca.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用Seneca将其拆分为各种小模块。
- en: 'First, the e-mail module (`email.js`) will be as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，电子邮件模块（`email.js`）将如下所示：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The SMS module (`sms.js`) will be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 短信模块（`sms.js`）将如下所示：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, the post module (`post.js`) will be as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，帖子模块（`post.js`）将如下所示：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following diagram shows the new structure of modules:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了模块的新结构：
- en: '![Then the microservices appeared](img/B04889_03_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![然后微服务出现了](img/B04889_03_03.jpg)'
- en: Now, we have three modules. Each one of these modules does one specific thing
    without interfering with each other; we have created high-cohesion modules.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有三个模块。每个模块都做一件特定的事情，互不干扰；我们已经创建了高内聚的模块。
- en: 'Let''s run the preceding code, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行上述代码，如下所示：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As simple as that, we have created a server with the IP `10.0.0.7` bound that
    listens on the `1932` port for incoming requests. As you can see, we haven't referenced
    any file, we just referenced the module by name; Seneca will do the rest.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单，我们创建了一个绑定到IP `10.0.0.7`的服务器，监听`1932`端口以接收请求。正如你所看到的，我们没有引用任何文件，只是按名称引用了模块；Seneca会完成其余工作。
- en: 'Let''s run it and verify that Seneca has loaded the plugins:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它，并验证Seneca是否已加载了插件：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This command will output something similar to the following lines:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将输出类似以下行的内容：
- en: '![Then the microservices appeared](img/B04889_03_05.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![然后微服务出现了](img/B04889_03_05.jpg)'
- en: 'If you remember from [Chapter 2](ch02.html "Chapter 2. Microservices in Node.js
    – Seneca and PM2 Alternatives"), *Microservices in Node.js – Seneca and PM2 Alternatives*,
    Seneca loads a few plugins by default: `basic`, `transport`, `web`, and `mem-store`,
    which allow Seneca to work out of the box without being hassled with the configuration.
    Obviously, as we will see in [Chapter 4](ch04.html "Chapter 4. Writing Your First
    Microservice in Node.js"), *Writing Your First Microservice in Node.js*, that
    the configuration is necessary as, for example, `mem-store` will only store data
    in the memory without persisting it between executions.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[第2章](ch02.html "第2章 微服务在Node.js中的应用 - Seneca和PM2替代方案")中的内容，*Node.js中的微服务
    - Seneca和PM2替代方案*，Seneca默认加载了一些插件：`basic`、`transport`、`web`和`mem-store`，这些插件使得Seneca可以直接使用，而不需要烦恼于配置。显然，正如我们将在[第4章](ch04.html
    "第4章 在Node.js中编写你的第一个微服务")中看到的那样，*在Node.js中编写你的第一个微服务*，配置是必要的，例如，`mem-store`只会在内存中存储数据，不会在执行之间进行持久化。
- en: 'Aside from the standard plugins, we can see that Seneca has loaded three extra
    plugins: `email`, `sms`, and `post`, which are the plugins that we have created.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准插件外，我们还可以看到Seneca加载了三个额外的插件：`email`、`sms`和`post`，这些是我们创建的插件。
- en: 'As you can see, the services written in Seneca are quite easy to understand
    once you know how the framework works. In this case, I have written the code in
    the form of a plugin so that it can be used by different instances of Seneca on
    different machines, as Seneca has a transparent transport mechanism that allows
    us to quickly redeploy and scale parts of our monolithic app as microservices,
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一旦你了解了框架的工作原理，就会发现用Seneca编写的服务非常容易理解。在这种情况下，我已经以插件的形式编写了代码，这样它就可以被不同机器上的不同Seneca实例使用，因为Seneca具有透明的传输机制，允许我们快速重新部署和扩展我们的单体应用的部分作为微服务，如下所示：
- en: The new version can be easily tested, as changes on the e-mail functionality
    will only affect sending the e-mail.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新版本可以很容易地进行测试，因为对电子邮件功能的更改只会影响到发送电子邮件。
- en: It is easy to scale. As we will see in the next chapter, replicating a service
    is as easy as configuring a new server and pointing our Seneca client to it.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很容易扩展。正如我们将在下一章中看到的那样，复制一个服务就像配置一个新的服务器并将我们的Seneca客户端指向它一样容易。
- en: It is also easy to maintain, as the software is easier to understand and modify.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也很容易维护，因为软件更容易理解和修改。
- en: Disadvantages
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: With microservices, we solve the biggest problems in modern enterprise, but
    that does not mean that they are problem free. Microservices often lead to different
    types of problems that are not easy to foresee.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过微服务，我们解决了现代企业中最大的问题，但这并不意味着它们没有问题。微服务经常导致各种类型的问题，这些问题不容易预见。
- en: 'The first and most concerning one is the operational overhead that could chew
    up the benefits obtained from using microservices. When you are designing a system,
    you should always have one question in mind: how to automate this? Automation
    is the key to tackling this problem.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人担忧的是操作开销可能会消耗使用微服务获得的好处。当你设计一个系统时，你应该始终记住一个问题：如何自动化？自动化是解决这个问题的关键。
- en: The second disadvantage with microservices is nonuniformity on the applications.
    A team might consider something a good practice that could be banned in another
    team (especially around exception handling), which adds an extra layer of isolation
    between teams that probably does not do well for the communication of your engineers
    within the team.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的第二个缺点是应用程序的不一致性。一个团队可能认为某种做法是好的，而另一个团队可能会禁止（尤其是在异常处理方面），这给团队内工程师之间的沟通增加了额外的隔离层。
- en: Lastly, but not less important, microservices introduce a bigger communication
    complexity that could lead to security problems. Instead of having to control
    a single application and its communication with the outer world, we are now facing
    a number of servers that communicate with each other.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，微服务引入了更大的通信复杂性，可能会导致安全问题。现在我们不再只需要控制单个应用程序及其与外部世界的通信，而是面对一些相互通信的服务器。
- en: Splitting the monolith
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆分单体
- en: Consider that the marketing department of your company has decided to run an
    aggressive e-mail campaign that is going to require peaks of capacity that could
    harm the normal day-to-day process of sending e-mail. Under stress, the e-mails
    will be delayed and that could cause us problems.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你公司的营销部门已经决定进行一项激进的电子邮件营销活动，这将需要容量的峰值，可能会影响正常的日常发送电子邮件的流程。在压力下，电子邮件将会延迟，这可能会给我们带来问题。
- en: Luckily, we have built our system as explained in the previous section. Small
    Seneca modules in the form of a high-cohesion and low-coupled plugins.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经按照前一节所述的方式构建了我们的系统。以高内聚和低耦合的插件形式的小型Seneca模块。
- en: 'Then, the solution to achieve it is simple: deploy the e-mail service (`email.js`)
    on more than one machine:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，实现这个解决方案很简单：在多台机器上部署电子邮件服务（`email.js`）：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, create a Seneca client pointing to it, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，创建一个指向它的Seneca客户端，如下所示：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From now on, the `senecaEmail` variable will contact the remote service when
    calling `act` and we would have achieved our goal: *scale up our first microservice*.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，`senecaEmail`变量在调用`act`时将联系远程服务，我们将实现我们的目标：*扩展我们的第一个微服务*。
- en: Problems splitting the monolith – it is all about the data
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆分单体的问题 - 这一切都与数据有关
- en: Data storage could be problematic. If your application has grown out of control
    for a number of years, the database would have done the same, and by now, the
    organic growth will make it hard to deal with significant changes in the database.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储可能会有问题。如果你的应用程序多年来已经失控，那么数据库也会如此，到现在为止，有机的增长将使处理数据库中的重大变化变得困难。
- en: 'Microservices should look after their own data. Keeping the data local to the
    service is one of the keys to ensure that the system remains flexible as it evolves,
    but it might not be always possible. As an example, financial services suffer
    especially from one of the main weak points of microservices-oriented architectures:
    *the lack of transactionality*. When a software component deals with money, it
    needs to ensure that the data remains consistent and not eventually consistent
    after every single operation. If a customer deposits money in a financial company,
    the software that holds the account balance needs to be consistent with the money
    held in the bank, otherwise, the reconciliation of the accounts will fail. Not
    only that, if your company is a regulated entity, it could cause serious problems
    for the continuity of the business.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该照顾好自己的数据。将数据保持在服务的本地是确保系统在发展过程中保持灵活性的关键之一，但这可能并非总是可能的。例如，金融服务特别受到微服务导向架构的主要弱点之一的影响：*事务性的缺乏*。当软件组件处理资金时，它需要确保数据在每次操作后保持一致，而不是最终一致。如果客户向金融公司存款，持有账户余额的软件需要与银行持有的资金保持一致，否则账目的对账将失败。不仅如此，如果你的公司是受监管的实体，这可能会给业务的连续性带来严重问题。
- en: 'The general rule of thumb, when working with microservices and financial systems,
    is to keep a not-so-microservice that deals with all the money and creates microservices
    for the auxiliary modules of the system such as e-mailing, SMS, user registration,
    and so on, as shown in the following image:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用微服务和金融系统时的一般经验法则是，保留一个不那么微小的服务来处理所有的资金，并为系统的辅助模块创建微服务，比如电子邮件、短信、用户注册等，如下图所示：
- en: '![Problems splitting the monolith – it is all about the data](img/B04889_03_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![拆分单体的问题 - 这一切都与数据有关](img/B04889_03_04.jpg)'
- en: As you can see in the preceding picture, the fact that payments will be a big
    microservice instead of smaller services, it only has implications in the operational
    side, there is nothing preventing us from modularizing the application as seen
    before. The fact that withdrawing money from an ATM has to be an atomic operation
    (either succeed or fail without intermediate status) should not dictate how we
    organize the code in our application, allowing us to modularize the services,
    but spanning the transaction scope across all of them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的图片所示，支付将成为一个大型微服务而不是较小的服务，这只对操作方面有影响，没有什么能阻止我们像之前看到的那样模块化应用。从ATM取款必须是一个原子操作（要么成功，要么失败，没有中间状态）的事实不应该决定我们如何组织应用中的代码，这使我们能够模块化服务，但跨越所有服务范围的事务范围。
- en: Organizational alignment
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织对齐
- en: In a company where the software is built based on microservices, every single
    stakeholder needs to be involved in decision making.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个以微服务为基础构建软件的公司中，每个利益相关者都需要参与决策。
- en: Microservices are a huge paradigm shift. Usually, large organizations tend to
    build software in a very old fashioned manner. Big releases every few months that
    require days to complete the **quality assurance** (**QA**) phase and few hours
    to deploy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个巨大的范式转变。通常，大型组织倾向于以非常老式的方式构建软件。每隔几个月进行大版本发布，需要数天来完成质量保证（QA）阶段，以及几个小时来部署。
- en: 'When a company chooses to implement a microservices-oriented architecture,
    the methodology changes completely: small teams work on small features that are
    built, tested, and deployed on their own. The teams do one thing (one microservice,
    or more realistic, a few of them) and they do it well (they master the domain
    and technical knowledge required to build the software).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当一家公司选择实施面向微服务的架构时，方法论会完全改变：小团队负责构建、测试和部署自己的小功能。团队只做一件事（一个微服务，或更现实的是几个），并且做得很好（他们掌握了构建软件所需的领域和技术知识）。
- en: These are what usually called cross-functional teams. A unit of work of few
    people that have the required knowledge to build high-quality software components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被称为跨职能团队。一小组人完成所需知识以构建高质量软件组件的工作单元。
- en: It is also important to flag that the team has to master the domain knowledge
    needed to understand the business requirements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还要强调团队必须掌握理解业务需求所需的领域知识。
- en: Here is where the majority of the companies where I have worked in my professional
    life fail (in my opinion). Developers are considered brick stackers that magically
    understand the business flows without being exposed to them before. If one developer
    delivers *X* amount of work in one week, ten developers will deliver *10X*. This
    is wrong.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我在职业生涯中大多数公司失败的地方（在我看来）。开发人员被认为是神奇地理解业务流程而不需要事先接触它们的砖块堆叠者。如果一个开发人员在一周内交付了*X*量的工作，那么十个开发人员将交付*10X*。这是错误的。
- en: People in cross-functional teams that build the microservices have to master
    (not only know) the domain-specific knowledge in order to be efficient and factor
    the Conway's Law and its implications into the system for changing how the business
    processes work.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 构建微服务的跨职能团队必须掌握（不仅仅是了解）领域特定知识，以便高效地考虑康威定律及其对改变业务流程工作方式的影响。
- en: 'When talking about organizational alignment in microservices, autonomy is the
    key. The teams need to be autonomous in order to be agile while building the microservices,
    which implies keeping the technical authority within the team, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论微服务的组织对齐时，自治是关键。团队需要具有自治性，以便在构建微服务时保持敏捷，这意味着在团队内保持技术权威，具体如下：
- en: Languages used
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的语言
- en: Code standards
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码标准
- en: Patterns used to solve problems
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于解决问题的模式
- en: Tools chosen to build, test, debug, and deploy the software
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择用于构建、测试、调试和部署软件的工具
- en: This is an important part, as this is where we need to define how the company
    builds software and where the engineering problems may be introduced.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的部分，因为这是我们需要定义公司如何构建软件以及工程问题可能会引入的地方。
- en: 'As an example, we can look into the coding standards, as shown in the following
    list:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以看一下编码标准，如下列表所示：
- en: Do we want to keep the same coding standards across the teams?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否希望在团队之间保持相同的编码标准？
- en: Do we want each team to have their own coding standards?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否希望每个团队都有自己的编码标准？
- en: 'In general, I am always in favor of the 80% rule: *80% of perfection is more
    than enough for 100% of the use cases*. It means that loosening up the coding
    standards (it can be applied to other areas) and allowing some level of imperfection/personalization,
    helps to reduce the friction between teams and also allows the engineers to quickly
    catch up with the very few important rules to follow such as logging strategies
    or exception handling.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我总是赞成80%的法则：*80%的完美对于100%的使用案例来说已经足够了*。这意味着放宽编码标准（也可以应用到其他领域）并允许一定程度的不完美/个性化，有助于减少团队之间的摩擦，也允许工程师快速掌握一些重要的规则，如日志策略或异常处理。
- en: If your coding standards are too complicated, there will be friction when a
    team tries to push a code into a microservice out of their usual scope (remember,
    teams own the services, but every team can contribute to them).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编码标准太复杂，当一个团队试图将代码推送到他们通常范围之外的微服务时，就会产生摩擦（记住，团队拥有服务，但每个团队都可以为其做出贡献）。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the principles of building monolithic applications
    oriented to be split as microservices, depending on the business needs. As you
    have learned, the **Atomicity**, **Consistency**, **Isolation**, **Durability**
    (**ACID**) design principles are concepts that we need to have in mind in order
    to build high quality software.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了构建面向根据业务需求拆分为微服务的单片应用程序的原则。正如你所学到的，**原子性**、**一致性**、**隔离性**、**持久性**（**ACID**）设计原则是我们需要牢记的概念，以构建高质量软件。
- en: You have also learned that we cannot assume that we are going to be able to
    design a system from scratch, so we need to be smart about how we build the new
    parts of the system and how we refactor the existing ones so that we achieve the
    level of flexibility required to satisfy the business needs and be resilient.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学到了我们不能假设我们能够从头开始设计一个系统，因此我们需要聪明地构建系统的新部分以及重构现有部分，以便达到满足业务需求和具有弹性所需的水平。
- en: We also have given a small introduction about monolithic designed databases
    and how they are the biggest pain points when splitting a monolithic software
    into microservices, as it is usually required to shut down the system for a few
    hours in order to split the data into local databases. This subject could well
    be an entire book as new trends with NoSQL databases are changing the game of
    data storage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要介绍了单片式设计数据库以及在将单片式软件拆分为微服务时它们是最大的痛点，因为通常需要关闭系统几个小时以将数据拆分到本地数据库中。这个主题可能会成为一本完整的书，因为NoSQL数据库的新趋势正在改变数据存储的游戏规则。
- en: Finally, we discussed how to align the teams of engineers in our company in
    order to be efficient while keeping the flexibility and resilience needed to be
    able to be agile, as well as how the Conway's Law impacts the conversion of monolithic
    systems into microservices-oriented architectures.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何调整我们公司的工程团队，以便在保持灵活性和弹性的同时高效运作，并讨论了康威定律如何影响将单片系统转换为面向微服务的架构。
- en: In the next chapter, we will apply all the principles discussed in the first
    three chapters, as well as a big dose of common sense to build a full working
    system based on microservices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将应用前三章讨论的所有原则，以及大量的常读感，构建基于微服务的完整工作系统。
