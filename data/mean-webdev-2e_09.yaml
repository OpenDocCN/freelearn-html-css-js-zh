- en: Chapter 9. Adding Real-time Functionality Using Socket.io
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。使用Socket.io添加实时功能
- en: 'In previous chapters, you learned how to build your MEAN application and how
    to create CRUD modules. These chapters covered the basic functionalities of a
    web application; however, more and more applications require real-time communication
    between the server and the browser. In this chapter, you''ll learn how to connect
    your Express and Angular applications in real time using the `Socket.io` module.
    Socket.io enables Node.js developers to support real-time communication using
    `WebSockets` in modern browsers and legacy fallback protocols in older browsers.
    In this chapter, we''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您学习了如何构建您的MEAN应用程序以及如何创建CRUD模块。这些章节涵盖了Web应用程序的基本功能；然而，越来越多的应用程序需要服务器和浏览器之间的实时通信。在本章中，您将学习如何使用`Socket.io`模块实时连接您的Express和Angular应用程序。Socket.io使Node.js开发人员能够在现代浏览器中支持使用`WebSockets`进行实时通信，并在旧版浏览器中支持回退协议。在本章中，我们将涵盖以下主题：
- en: Setting up the Socket.io module
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Socket.io模块
- en: Configuring the Express application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Express应用程序
- en: Setting up the Socket.io/Passport session
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Socket.io/Passport会话
- en: Wiring Socket.io routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接Socket.io路由
- en: Using the Socket.io client object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Socket.io客户端对象
- en: Building a simple chat room
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个简单的聊天室
- en: Introducing WebSockets
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WebSockets
- en: Modern web applications, such as Facebook, Twitter, and Gmail, are incorporating
    real-time capabilities which enable applications to continuously present the user
    with recently updated information. Unlike traditional applications, in real-time
    applications, the common roles of the browser and the server can be reversed since
    the server needs to update the browser with new data regardless of the browser
    request state. This means that unlike the common HTTP behavior, the server won't
    wait for the browser's requests. Instead, it will send new data to the browser
    whenever this data becomes available.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web应用程序，如Facebook、Twitter和Gmail，正在整合实时功能，使应用程序能够持续向用户呈现最新更新的信息。与传统应用程序不同，在实时应用程序中，浏览器和服务器的常见角色可以颠倒，因为服务器需要更新浏览器的新数据，而不管浏览器请求的状态如何。这意味着与常见的HTTP行为不同，服务器不会等待浏览器的请求。相反，它将在可用新数据时立即将新数据发送到浏览器。
- en: This reverse approach is often called **Comet**, a term coined by a web developer
    named Alex Russel back in 2006 (the term was a word play on the AJAX term; both
    Comet and AJAX are common household cleaners in the US). In the past, there were
    several ways to implement a Comet functionality using the HTTP protocol.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反向方法通常被称为**Comet**，这个术语是由一位名叫Alex Russel的网页开发者在2006年创造的（这个术语是对AJAX术语的一个双关语；Comet和AJAX都是美国常见的家用清洁剂）。过去，有几种方法可以使用HTTP协议实现Comet功能。
- en: 'The first and easiest way is **XMLHttpRequest** (**XHR**) polling. In XHR polling,
    the browser makes periodic requests to the server. The server then returns an
    empty response unless it has new data to send back. Upon a new event, the server
    will return the new event data to the next polling request. While this works quite
    well for most browsers, this method has two problems. The most obvious one is
    that using this method generates a large number of requests that hit the server
    with no particular reason, since a lot of requests return empty. The second problem
    is that the update time depends on the request period. This means that new data
    will only get pushed to the browser on the next request, causing delays in updating
    the client state. To solve these issues, a better approach was introduced: XHR
    long polling.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种最简单的方法是**XMLHttpRequest**（**XHR**）轮询。在XHR轮询中，浏览器定期向服务器发出请求。然后服务器返回一个空响应，除非它有新数据要发送回来。在新事件发生时，服务器将新事件数据返回给下一个轮询请求。虽然这对大多数浏览器来说效果很好，但这种方法有两个问题。最明显的问题是，使用这种方法会产生大量没有特定原因的请求，因为很多请求都是空的。第二个问题是更新时间取决于请求周期。这意味着新数据只会在下一个请求时推送到浏览器，导致更新客户端状态的延迟。为了解决这些问题，引入了更好的方法：XHR长轮询。
- en: In XHR long polling, the browser makes an XHR request to the server, but a response
    is not sent back unless the server has new data. Upon an event, the server responds
    with the event data and the browser makes a new long polling request. This cycle
    enables better management of requests, since there is only a single request per
    session. Furthermore, the server can update the browser immediately with new information
    without having to wait for the browser's next request. Because of its stability
    and usability, XHR long polling has become the standard approach for real-time
    applications and was implemented in various ways, including Forever iFrame, multipart
    XHR, and JSONP long polling using script tags (for cross-domain, real-time support),
    and the common long-living XHR.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在XHR长轮询中，浏览器向服务器发出XHR请求，但除非服务器有新数据，否则不会发送响应。在事件发生时，服务器将以事件数据响应，并且浏览器会发出新的长轮询请求。这个循环可以更好地管理请求，因为每个会话只有一个请求。此外，服务器可以立即使用新信息更新浏览器，而无需等待浏览器的下一个请求。由于其稳定性和可用性，XHR长轮询已成为实时应用程序的标准方法，并以各种方式实现，包括Forever
    iFrame、多部分XHR和使用脚本标签的JSONP长轮询（用于跨域实时支持），以及常见的长期XHR。
- en: 'However, all these approaches were actually hacks using the HTTP and XHR protocols
    in a way they were not meant to be used. With the rapid development of modern
    browsers and the increased adoption of the new HTML5 specifications, a new protocol
    emerged in order to implement real-time communication: the full duplex `WebSockets`
    protocol.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些方法实际上都是使用HTTP和XHR协议的黑客方法，这并不是它们本来的用途。随着现代浏览器的快速发展和新HTML5规范的广泛采用，出现了一种新的协议，用于实现实时通信：全双工`WebSockets`协议。
- en: In browsers that support the `WebSockets` protocol, the initial connection between
    the server and browser is made over HTTP and is called an HTTP handshake. Once
    the initial connection is made, the browser and server open a single ongoing communication
    channel over a TCP socket. Once the socket connection is established, it enables
    bidirectional communication between the browser and the server. This enables both
    parties to send and retrieve messages over a single communication channel. This
    also helps lower the server load, decrease message latency, and unify PUSH communication
    using a standalone connection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持`WebSockets`协议的浏览器中，服务器和浏览器之间的初始连接是通过HTTP进行的，称为HTTP握手。一旦建立了初始连接，浏览器和服务器将在TCP套接字上打开一个持续的通信通道。一旦套接字连接建立，它就可以实现浏览器和服务器之间的双向通信。这使双方能够通过单一通信通道发送和检索消息。这也有助于降低服务器负载，减少消息延迟，并统一使用独立连接进行PUSH通信。
- en: However, `WebSockets` still suffers from two major problems. First and foremost
    is browser compatibility. The `WebSockets` specification is fairly new, so older
    browsers don't support it, and though most modern browsers implement the protocol
    now, a large group of users is still using these older browsers. The second problem
    is HTTP proxies, firewalls, and hosting providers. Since `WebSockets` uses a different
    communication protocol than HTTP, a lot of these intermediaries don't support
    it yet and block any socket communication. As it has always been with the Web,
    developers are left with a fragmentation problem, which can only be solved using
    an abstraction library that optimizes usability by switching between protocols
    according to the available resources. Fortunately, a popular library called Socket.io
    has been developed for this purpose, and it is freely available for the Node.js
    developer community.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`WebSockets`仍然存在两个主要问题。首先是浏览器兼容性。`WebSockets`规范相当新，因此旧版浏览器不支持它，尽管大多数现代浏览器现在实现了该协议，但仍有大量用户在使用这些旧版浏览器。第二个问题是HTTP代理、防火墙和托管提供商。由于`WebSockets`使用与HTTP不同的通信协议，许多中介不支持它，因此阻止任何套接字通信。就像Web一直存在的问题一样，开发人员面临着碎片化问题，只能通过使用抽象库来解决，该库通过根据可用资源切换协议来优化可用性。幸运的是，一个名为Socket.io的流行库已经为此目的开发，并且可以免费提供给Node.js开发人员社区。
- en: Introducing Socket.io
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Socket.io
- en: 'Created in 2010 by the JavaScript developer Guillermo Rauch, Socket.io aimed
    at abstracting Node.js real-time application development. Since then, it has evolved
    dramatically and has been released in nine major versions before being broken
    in its latest version into two different modules: `engine.io` and `socket.io`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.io由JavaScript开发人员Guillermo Rauch于2010年创建，旨在抽象化Node.js实时应用程序开发。从那时起，它已经发展迅速，并在最新版本中分为两个不同的模块：`engine.io`和`socket.io`之前发布了九个主要版本。
- en: Previous versions of Socket.io were criticized for being unstable since they
    first tried to establish the most advanced connection mechanisms and then fall
    back on more primitive protocols. This caused serious issues with using Socket.io
    in production environments and posed a threat to the adoption of Socket.io as
    a real-time library. To solve this, the Socket.io team redesigned it and wrapped
    the core functionality in a base module called Engine.io.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.io的早期版本因首先尝试建立最先进的连接机制，然后回退到更原始的协议而受到批评。这导致在生产环境中使用Socket.io出现严重问题，并对将Socket.io作为实时库的采用构成威胁。为了解决这个问题，Socket.io团队对其进行了重新设计，并将核心功能包装在一个名为Engine.io的基础模块中。
- en: The idea behind Engine.io was to create a more stable real-time module, which
    first opens a long-polling XHR communication and then tries to upgrade the connection
    to a `WebSockets` channel. The new version of Socket.io uses the Engine.io module
    and provides the developer with various features, such as events, rooms, and automatic
    connection recovery, which you would otherwise implement by yourself. In this
    chapter's examples, we will use the new Socket.io 1.0, which is the first version
    to use the Engine.io module.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Engine.io的理念是创建一个更稳定的实时模块，首先打开长轮询XHR通信，然后尝试升级连接到`WebSockets`通道。新版本的Socket.io使用Engine.io模块，并为开发人员提供各种功能，如事件、房间和自动连接恢复，否则您将自行实现。在本章的示例中，我们将使用新的Socket.io
    1.0，这是第一个使用Engine.io模块的版本。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Older versions of Socket.io prior to version 1.x don't use the new Engine.io
    module and, therefore, are much less stable in production environments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.x版本之前的旧版Socket.io不使用新的Engine.io模块，因此在生产环境中不太稳定。
- en: 'When you include the `socket.io` module, it provides you with two objects:
    a socket server object that is responsible for the server functionality and a
    socket client object that handles the browser''s functionality. We''ll begin by
    examining the server object.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您包含`socket.io`模块时，它会为您提供两个对象：一个负责服务器功能的socket服务器对象，以及一个处理浏览器功能的socket客户端对象。我们将从检查服务器对象开始。
- en: The Socket.io server object
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket.io服务器对象
- en: The Socket.io server object is where it all begins. You start by requiring the
    `socket.io` module and then use it to create a new Socket.io server instance that
    will interact with socket clients. The server object supports both a standalone
    implementation and the ability to use it in conjunction with the Express framework.
    The server instance then exposes a set of methods that allow you to manage the
    Socket.io server operations. Once the server object is initialized, it will also
    be responsible for serving the socket client JavaScript file for the browser.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.io服务器对象是一切的开始。您首先需要引入`socket.io`模块，然后使用它创建一个新的Socket.io服务器实例，该实例将与socket客户端进行交互。服务器对象支持独立实现和与Express框架一起使用的能力。然后，服务器实例公开一组方法，允许您管理Socket.io服务器操作。一旦服务器对象被初始化，它还将负责为浏览器提供socket客户端JavaScript文件。
- en: 'A simple implementation of the standalone Socket.io server will look as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 独立Socket.io服务器的简单实现如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will open a Socket.io over the `3000` port and serve the socket client
    file at `http://localhost:3000/socket.io/socket.io.js`. Implementing the Socket.io
    server in conjunction with an Express application will be a bit different as shown
    in the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`3000`端口上打开一个Socket.io，并在`http://localhost:3000/socket.io/socket.io.js`上提供套接字客户端文件。与Express应用程序一起实现Socket.io服务器将会有一些不同，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This time, you first use the `http` module of Node.js to create a server and
    wrap the Express application. The server object is then passed to the `socket.io`
    module and serves both the Express application and the Socket.io server. Once
    the server is running, it will be available for socket clients to connect. A client
    trying to establish a connection with the Socket.io server will start by initiating
    the handshaking process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你首先使用Node.js的`http`模块创建一个服务器并包装Express应用程序。然后将服务器对象传递给`socket.io`模块，同时提供Express应用程序和Socket.io服务器。一旦服务器运行起来，它将可供套接字客户端连接。试图与Socket.io服务器建立连接的客户端将通过启动握手过程开始。
- en: Socket.io handshaking
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socket.io握手
- en: When a client wants to connect the Socket.io server, it will first send a handshake
    HTTP request. The server will then analyze the request to gather the necessary
    information for the ongoing communication. It will then look for the configuration
    middleware that is registered with the server and execute it before firing the
    connection event. When the client is successfully connected to the server, the
    connection event listener is executed, exposing a new socket instance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要连接到Socket.io服务器时，它首先会发送一个握手HTTP请求。服务器将分析请求以收集进行中通信所需的必要信息。然后它会查找在服务器上注册的配置中间件，并在触发连接事件之前执行它。当客户端成功连接到服务器时，连接事件监听器将被执行，暴露一个新的套接字实例。
- en: 'Once the handshaking process is over, the client is connected to the server,
    and all communication with it is handled through the socket instance object. For
    example, handling a client''s disconnection event will be as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦握手过程结束，客户端就连接到服务器了，并且所有与它的通信都通过套接字实例对象处理。例如，处理客户端的断开连接事件将如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note how the `socket.on()` method adds an event handler to the disconnection
    event. Although the disconnection event is a predefined event, this approach works
    the same for custom events as well, as you will see in the following sections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`socket.on()`方法如何向断开连接事件添加事件处理程序。尽管断开连接事件是一个预定义事件，但这种方法对自定义事件也适用，后面你会看到。
- en: While the handshake mechanism is fully automatic, Socket.io provides you with
    a way to intercept the handshake process using a configuration middleware.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然握手机制是完全自动的，Socket.io提供了一种使用配置中间件拦截握手过程的方法。
- en: The Socket.io configuration middleware
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socket.io配置中间件
- en: 'Although the Socket.io configuration middleware existed in previous versions,
    in the new version, it is even simpler and allows you to manipulate socket communication
    before the handshake actually occurs. To create a configuration middleware, you
    will need to use the server''s `use()` method, which is very similar to the Express
    application''s `use()` method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Socket.io配置中间件在以前的版本中存在，但在新版本中，它更简单，允许你在握手实际发生之前操纵套接字通信。要创建一个配置中间件，你需要使用服务器的`use()`方法，这与Express应用程序的`use()`方法非常相似：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, the `io.use()` method callback accepts two arguments: the `socket`
    object and a `next` callback. The `socket` object is the same socket object that
    will be used for the connection, and it holds some connection properties. An important
    property is the `socket.request` property, which represents the handshake HTTP
    request. In the following sections, you will use the handshake request to incorporate
    the Passport session with the Socket.io connection.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`io.use()`方法的回调接受两个参数：`socket`对象和`next`回调。`socket`对象是将用于连接的相同套接字对象，它保存了一些连接属性。一个重要的属性是`socket.request`属性，它代表握手HTTP请求。在接下来的部分，你将使用握手请求来将Passport会话与Socket.io连接结合起来。
- en: 'The `next` argument is a callback method that accepts two arguments: an error
    object and a Boolean value. The `next` callback tells Socket.io whether or not
    to proceed with the handshake process, so if you pass an error object or a false
    value to the `next` method, Socket.io will not initiate the socket connection.
    Now that you have a basic understanding of how handshaking works, it is time to
    discuss the Socket.io client object.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`参数是一个回调方法，接受两个参数：一个错误对象和一个布尔值。`next`回调告诉Socket.io是否继续握手过程，因此如果你向`next`方法传递一个错误对象或false值，Socket.io将不会初始化套接字连接。现在你已经基本了解了握手的工作原理，是时候讨论Socket.io客户端对象了。'
- en: The Socket.io client object
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket.io客户端对象
- en: 'The Socket.io client object is responsible for the implementation of the browser
    socket communication with the Socket.io server. You start by including the Socket.io
    client JavaScript file, which is served by the Socket.io server. The Socket.io
    JavaScript file exposes an `io()` method that connects to the Socket.io server
    and creates the client `socket` object. A simple implementation of the socket
    client will be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.io客户端对象负责实现浏览器与Socket.io服务器的套接字通信。首先要包含由Socket.io服务器提供的Socket.io客户端JavaScript文件。Socket.io
    JavaScript文件公开了一个`io()`方法，用于连接到Socket.io服务器并创建客户端`socket`对象。套接字客户端的简单实现如下：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note the default URL for the Socket.io client object. Although it can be altered,
    you can usually leave it like this and just include the file from the default
    Socket.io path. Another thing you should notice is that the `io()` method will
    automatically try to connect to the default base path when executed with no arguments;
    however, you can also pass a different server URL as an argument.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Socket.io客户端对象的默认URL。虽然它可以被改变，但通常你可以保持默认的Socket.io路径并包含文件。另一件你应该注意的事情是，当没有参数执行`io()`方法时，它将自动尝试连接到默认的基本路径；但是，你也可以传递不同的服务器URL作为参数。
- en: As you can see, the socket client is much easier to implement, so we can move
    on to discussing how Socket.io handles real-time communication using events.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，socket客户端的实现要简单得多，因此我们可以继续讨论Socket.io如何使用事件处理实时通信。
- en: Socket.io events
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket.io事件
- en: 'To handle the communication between the client and the server, Socket.io uses
    a structure that mimics the `WebSockets` protocol and fires event messages across
    the server and client objects. There are two types of events: system events, which
    indicate the socket connection status, and custom events, which you''ll use to
    implement your business logic.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理客户端和服务器之间的通信，Socket.io使用了一种模仿`WebSockets`协议的结构，并在服务器和客户端对象之间触发事件消息。有两种类型的事件：系统事件，指示socket连接状态，和自定义事件，您将使用它们来实现业务逻辑。
- en: 'The system events on the socket server are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: socket服务器上的系统事件如下：
- en: '`io.on(''connection'', ...)`: This is emitted when a new socket is connected'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.on(''connection'', ...)`: 当一个新的socket连接时触发'
- en: '`socket.on(''message'', ...)`: This is emitted when a message is sent using
    the `socket.send()` method'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''message'', ...)`: 当使用`socket.send()`方法发送消息时触发'
- en: '`socket.on(''disconnect'', ...)`: This is emitted when the socket is disconnected'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.on(''disconnect'', ...)`: 当socket断开连接时触发'
- en: 'The system events on the client are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端上的系统事件如下：
- en: '`socket.io.on(''open'', ...)`: This is emitted when the socket client opens
    a connection with the server'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.io.on(''open'', ...)`: 当socket客户端与服务器建立连接时触发'
- en: '`socket.io.on(''connect'', ...)`: This is emitted when the socket client is
    connected to the server'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.io.on(''connect'', ...)`: 当socket客户端连接到服务器时触发'
- en: '`socket.io.on(''connect_timeout'', ...)`: This is emitted when the socket client
    connection with the server is timed out'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.io.on(''connect_timeout'', ...)`: 当socket客户端与服务器的连接超时时触发'
- en: '`socket.io.on(''connect_error'', ...)`: This is emitted when the socket client
    fails to connect with the server'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.io.on(''connect_error'', ...)`: 当socket客户端无法连接到服务器时触发'
- en: '`socket.io.on(''reconnect_attempt'', ...)`: This is emitted when the socket
    client tries to reconnect with the server'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.io.on(''reconnect_attempt'', ...)`: 当socket客户端尝试重新连接到服务器时触发'
- en: '`socket.io.on(''reconnect'', ...)`: This is emitted when the socket client
    is reconnected to the server'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.io.on(''reconnect'', ...)`: 当socket客户端重新连接到服务器时触发'
- en: '`socket.io.on(''reconnect_error'', ...)`: This is emitted when the socket client
    fails to reconnect with the server'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.io.on(''reconnect_error'', ...)`: 当socket客户端无法重新连接到服务器时触发'
- en: '`socket.io.on(''reconnect_failed'', ...)`: This is emitted when the socket
    client fails to reconnect with the server'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.io.on(''reconnect_failed'', ...)`: 当socket客户端无法重新连接到服务器时触发'
- en: '`socket.io.on(''close'', ...)`: This is emitted when the socket client closes
    the connection with the server'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.io.on(''close'', ...)`: 当socket客户端关闭与服务器的连接时触发'
- en: Handling events
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理事件
- en: While system events are helping us with connection management, the real magic
    of Socket.io lies in using custom events. In order to do that, Socket.io exposes
    two methods, both on the client and server objects. The first method is the `on()`
    method, which binds event handlers with events, and the second method is the `emit()`
    method, which is used to fire events between the server and client objects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然系统事件帮助我们进行连接管理，但Socket.io的真正魔力在于使用自定义事件。为了做到这一点，Socket.io在客户端和服务器对象上都公开了两种方法。第一种方法是`on()`方法，它将事件处理程序与事件绑定在一起，第二种方法是`emit()`方法，用于在服务器和客户端对象之间触发事件。
- en: 'An implementation of the `on()` method in the socket server is very simple:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在socket服务器中实现`on()`方法非常简单：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, you bound an event listener to the `customEvent` event.
    The event handler is called when the socket client object emits the `customEvent`
    event. Note how the event handler accepts the `customEventData` argument that
    is passed to the event handler from the socket client object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，您绑定了一个事件监听器到`customEvent`事件。当socket客户端对象发出`customEvent`事件时，事件处理程序被调用。注意事件处理程序如何接受从socket客户端对象传递给事件处理程序的`customEventData`参数。
- en: 'An implementation of the `on()` method in the socket client is also straightforward:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在socket客户端中实现`on()`方法也很简单：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This time, the event handler is called when the socket server emits the `customEvent`
    event that sends `customEventData` to the socket client event handler.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，事件处理程序在socket服务器发出`customEvent`事件并将`customEventData`发送到socket客户端事件处理程序时被调用。
- en: Once you set your event handlers, you can use the `emit()` method to send events
    from the socket server to the socket client and vice versa.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了事件处理程序，您就可以使用`emit()`方法从socket服务器向socket客户端发送事件，反之亦然。
- en: Emitting events
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送事件
- en: 'On the socket server, the `emit()` method is used to send events to a single
    socket client or a group of connected socket clients. The `emit()` method can
    be called from the connected `socket` object, which will send the event to a single
    socket client, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在socket服务器上，`emit()`方法用于向单个socket客户端或一组连接的socket客户端发送事件。`emit()`方法可以从连接的`socket`对象中调用，这将向单个socket客户端发送事件，如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `emit()` method can also be called from the `io` object, which will send
    the event to all connected socket clients, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`emit()`方法也可以从`io`对象中调用，这将向所有连接的socket客户端发送事件，如下所示：'
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another option is to send the event to all connected socket clients except
    from the sender using the `broadcast` property, as shown in the following lines
    of code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用`broadcast`属性将事件发送给除发送方以外的所有连接的socket客户端，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On the socket client, things are much simpler. Since the socket client is only
    connected to the socket server, the `emit()` method will only send the event to
    the socket server:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在socket客户端上，情况要简单得多。由于socket客户端只连接到socket服务器，`emit()`方法只会将事件发送到socket服务器：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Although these methods allow you to switch between personal and global events,
    they still lack the ability to send events to a group of connected socket clients.
    Socket.io offers two options to group sockets together: namespaces and rooms.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些方法允许您在个人和全局事件之间切换，但它们仍然缺乏向一组连接的套接字客户端发送事件的能力。Socket.io提供了两种选项来将套接字分组：命名空间和房间。
- en: Socket.io namespaces
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket.io命名空间
- en: In order to easily control socket management, Socket.io allows developers to
    split socket connections according to their purpose using namespaces. So instead
    of creating different socket servers for different connections, you can just use
    the same server to create different connection endpoints. This means that socket
    communication can be divided into groups, which will then be handled separately.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地控制套接字管理，Socket.io允许开发人员根据其目的将套接字连接分割成不同的命名空间。因此，您可以使用相同的服务器来创建不同的连接端点，而不是为不同的连接创建不同的套接字服务器。这意味着套接字通信可以被分成组，然后分别处理。
- en: Socket.io server namespaces
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socket.io服务器命名空间
- en: 'To create a socket server namespace, you will need to use the socket server
    `of()` method that returns a socket namespace. Once you retain the socket namespace,
    you can just use it the same way you use the socket server object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建套接字服务器命名空间，您需要使用套接字服务器的`of()`方法，该方法返回一个套接字命名空间。一旦保留了套接字命名空间，您可以像使用套接字服务器对象一样使用它：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In fact, when you use the `io` object, Socket.io actually uses a default empty
    namespace, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当您使用`io`对象时，Socket.io实际上使用一个默认的空命名空间，如下所示：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding lines of code are actually equivalent to this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行实际上等同于这个：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Socket.io client namespaces
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socket.io客户端命名空间
- en: 'On the socket client, the implementation is a little different:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字客户端上，实现略有不同：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, you can use multiple namespaces on the same application without
    much effort. However, once sockets are connected to different namespaces, you
    will not be able to send an event to all these namespaces at once. This means
    that namespaces are not very good for a more dynamic grouping logic. For this
    purpose, Socket.io offers a different feature called rooms.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以在同一个应用程序中轻松使用多个命名空间。然而，一旦套接字连接到不同的命名空间，您将无法同时向所有这些命名空间发送事件。这意味着命名空间对于更动态的分组逻辑并不是很好。为此，Socket.io提供了一个称为rooms的不同功能。
- en: Socket.io rooms
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket.io房间
- en: Socket.io rooms allow you to partition connected sockets into different groups
    in a dynamic way. Connected sockets can join and leave rooms, and Socket.io provides
    you with a clean interface to manage rooms and emit events to the subset of sockets
    in a room. The rooms functionality is handled solely on the socket server but
    can easily be exposed to the socket client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.io房间允许您以动态方式将连接的套接字分成不同的组。连接的套接字可以加入和离开房间，Socket.io为您提供了一个清晰的界面来管理房间并向房间中的套接字子集发出事件。房间功能完全由套接字服务器处理，但可以轻松地暴露给套接字客户端。
- en: Joining and leaving rooms
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入和离开房间
- en: 'Joining a room is handled using the socket `join()` method, while leaving a
    room is handled using the `leave()` method. So, a simple subscription mechanism
    can be implemented as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用套接字`join()`方法处理加入房间，而使用`leave()`方法处理离开房间。因此，可以实现一个简单的订阅机制，如下所示：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the `join()` and `leave()` methods both take the room name as the
    first argument.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`join()`和`leave()`方法都将房间名称作为第一个参数。
- en: Emitting events to rooms
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向房间发出事件
- en: 'To emit events to all the sockets in a room, you will need to use the `in()`
    method. So, emitting an event to all socket clients who joined a room is quite
    simple and can be achieved with the help of the following code snippets:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要向房间中的所有套接字发出事件，您需要使用`in()`方法。因此，向已加入房间的所有套接字客户端发送事件非常简单，并且可以通过以下代码片段的帮助实现：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Another option is to send the event to all the connected socket clients in
    a room except the sender using the `broadcast` property and the `to()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用`broadcast`属性和`to()`方法将事件发送到房间中除发送者之外的所有连接的套接字客户端：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This pretty much covers the simple yet powerful room functionality of Socket.io.
    In the next section, you will learn how to implement Socket.io in your MEAN application,
    and more importantly, how to use the Passport session to identify users in the
    Socket.io session. The examples in this chapter will continue directly from those
    in previous chapters, so copy the final example from [Chapter 8](ch08.html "Chapter 8. Creating
    a MEAN CRUD Module"), *Creating a MEAN CRUD Module*, and let's start from there.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上涵盖了Socket.io的简单而强大的room功能。在下一节中，您将学习如何在MEAN应用程序中实现Socket.io，更重要的是，如何使用Passport会话来识别Socket.io会话中的用户。本章中的示例将直接从前几章中的示例继续，因此请从[第8章](ch08.html
    "第8章。创建一个MEAN CRUD模块")中复制最终示例，*创建一个MEAN CRUD模块*，然后从那里开始。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While we covered most of the Socket.io features, you can learn more about Socket.io
    by visiting the official project page at [http://socket.io/](http://socket.io/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经介绍了大部分Socket.io的功能，但您可以通过访问官方项目页面[http://socket.io/](http://socket.io/)来了解更多关于Socket.io的信息。
- en: Installing Socket.io
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Socket.io
- en: 'Before you can use the `socket.io` module, you will need to install it using
    `npm`. To do that, change your `package.json` file as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用`socket.io`模块之前，您需要使用`npm`进行安装。为此，请按照以下更改您的`package.json`文件：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To install the `socket.io` module, go to your application''s root folder and
    issue the following command in your command-line tool:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`socket.io`模块，请转到应用程序的根文件夹，并在命令行工具中发出以下命令：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As usual, this will install the specified version of Socket.io in your `node_modules`
    folder. When the installation process is successfully over, you will need to configure
    your Express application to work in conjunction with the `socket.io` module and
    start your socket server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，这将在您的`node_modules`文件夹中安装指定版本的Socket.io。安装过程成功完成后，您需要配置Express应用程序以与`socket.io`模块配合工作，并启动套接字服务器。
- en: Configuring the Socket.io server
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Socket.io服务器
- en: 'After you''ve installed the `socket.io` module, you will need to start the
    socket server in conjunction with the Express application. For this, you will
    have to make the following changes in your `config/express.js` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了`socket.io`模块之后，你需要启动Socket服务器以及Express应用程序。为此，你需要在你的`config/express.js`文件中进行以下更改：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's go over the changes you made to your Express configuration. After including
    the new dependencies, you used the `http` core module to create a `server` object
    that wraps your Express `app` object. You then used the `socket.io` module and
    its `listen()` method to attach the Socket.io server with your `server` object.
    Finally, you returned the new `server` object instead of the Express application
    object. When the server starts, it will run your Socket.io server along with your
    Express application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看你对Express配置所做的更改。在包含新的依赖项之后，你使用了`http`核心模块来创建一个包装你的Express `app`对象的`server`对象。然后你使用了`socket.io`模块及其`listen()`方法将Socket.io服务器附加到你的`server`对象上。最后，你返回了新的`server`对象而不是Express应用程序对象。当服务器启动时，它将运行你的Socket.io服务器以及Express应用程序。
- en: While you can already start using Socket.io, there is still one major problem
    with this implementation. Since Socket.io is a standalone module, requests that
    are sent to it are detached from the Express application. This means that the
    Express session information is not available in a socket connection. This raises
    a serious obstacle when dealing with your Passport authentication in the socket
    layer of your application. To solve this issue, you will need to configure a persistent
    session storage, which will allow you to share your session information between
    the Express application and Socket.io handshake requests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你已经可以开始使用Socket.io，但是这个实现还存在一个主要问题。由于Socket.io是一个独立的模块，发送到它的请求与Express应用程序分离。这意味着Express会话信息在socket连接中不可用。在应用程序的socket层处理Passport身份验证时，这将带来严重的障碍。为了解决这个问题，你需要配置一个持久的会话存储，这将允许你在Express应用程序和Socket.io握手请求之间共享会话信息。
- en: Configuring the Socket.io session
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Socket.io会话
- en: To configure your Socket.io session to work in conjunction with your Express
    sessions, you have to find a way to share session information between Socket.io
    and Express. Since the Express session information is being stored in the memory
    currently, Socket.io will not be able to access it properly. So, a better solution
    would be to store the session information in your MongoDB. Fortunately, there
    is a node module named `connect-mongo` that allows you to store the session information
    in a MongoDB instance almost seamlessly. To retrieve the Express session information,
    you will need a way to parse the signed session cookie information. For this purpose,
    you'll also need to install the `cookie-parser` module, which is used to parse
    the cookie header and populate the HTTP request object with cookies-related properties.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置你的Socket.io会话与Express会话一起工作，你必须找到一种方法在Socket.io和Express之间共享会话信息。由于Express会话信息目前存储在内存中，Socket.io将无法正确访问它。因此，一个更好的解决方案是将会话信息存储在你的MongoDB中。幸运的是，有一个名为`connect-mongo`的节点模块，它几乎无缝地允许你将会话信息存储在MongoDB实例中。为了检索Express会话信息，你需要一种方法来解析已签名的会话cookie信息。为此，你还需要安装`cookie-parser`模块，它用于解析cookie头并将HTTP请求对象填充为与cookie相关的属性。
- en: Installing the connect-mongo and cookie-parser modules
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装connect-mongo和cookie-parser模块
- en: 'Before you can use the `connect-mongo` and `cookie-parser` modules, you will
    need to install them using `npm`. To do that, change your `package.json` file
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以使用`connect-mongo`和`cookie-parser`模块之前，你需要使用`npm`安装它们。为此，请按照以下方式更改你的`package.json`文件：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To install the new modules, go to your application''s root folder and issue
    the following command in your command-line tool:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装新的模块，进入你的应用程序根目录，并在命令行工具中输入以下命令：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As usual, this will install the specified versions of the `connect-mongo` and
    `cookie-parser` modules in your `node_modules` folder. When the installation process
    is successfully over, your next step will be to configure your Express application
    to use `connect-mongo` as the session storage.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，这将在你的`node_modules`文件夹中安装指定版本的`connect-mongo`和`cookie-parser`模块。当安装过程顺利完成后，你的下一步将是配置你的Express应用程序使用`connect-mongo`作为会话存储。
- en: Configuring the connect-mongo module
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置connect-mongo模块
- en: 'To configure your Express application to store session information using the
    `connect-mongo` module, you will have to make a few changes. First, you will need
    to change your `config/express.js` file, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置你的Express应用程序使用`connect-mongo`模块存储会话信息，你需要做一些更改。首先，你需要更改你的`config/express.js`文件，如下所示：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code snippet, you configured a few things. First, you loaded
    the `connect-mongo` module and then passed the Express session module to it. Then,
    you created a new `connect-mongo` instance and passed your Mongoose connection
    object to it. Finally, you used the Express session store option to let the Express
    session module know where to store the session information.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，你配置了一些东西。首先，你加载了`connect-mongo`模块，然后将Express会话模块传递给它。然后，你创建了一个新的`connect-mongo`实例，并将你的Mongoose连接对象传递给它。最后，你使用了Express会话存储选项，让Express会话模块知道在哪里存储会话信息。
- en: 'As you can see, your Express configuration method requires a `db` argument.
    This argument is the Mongoose connection object, which will be passed to the Express
    configuration method from the `server.js` file when it requires the `express.js`
    file. So, go to your `server.js` file and change it as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你的Express配置方法需要一个`db`参数。这个参数是Mongoose连接对象，它将从`server.js`文件传递给Express配置方法，当它需要`express.js`文件时。因此，去你的`server.js`文件并按照以下方式更改它：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once the Mongoose connection is created, the `server.js` file will call the
    `express.js` module method and pass the Mongoose database property to it. In this
    way, Express will persistently store the session information in your MongoDB database
    so that it will be available for the Socket.io session. Next, you will need to
    configure your Socket.io handshake middleware to use the `connect-mongo` module
    and retrieve the Express session information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Mongoose连接创建完成，`server.js`文件将调用`express.js`模块方法并将Mongoose数据库属性传递给它。这样，Express将会将会话信息持久存储在您的MongoDB数据库中，以便为Socket.io会话提供。接下来，您需要配置您的Socket.io握手中间件以使用`connect-mongo`模块并检索Express会话信息。
- en: Configuring the Socket.io session
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Socket.io会话
- en: 'To configure the Socket.io session, you''ll need to use the Socket.io configuration
    middleware and retrieve your session user. Begin by creating a new file named
    `socketio.js` in your `config` folder to store all your Socket.io-related configurations.
    In your new file, add the following lines of code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Socket.io会话，您需要使用Socket.io配置中间件并检索您的会话用户。首先，在您的`config`文件夹中创建一个名为`socketio.js`的新文件，以存储所有与Socket.io相关的配置。在您的新文件中，添加以下代码行：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's go over the new Socket.io configuration file. First, you required the
    necessary dependencies, and then you used the `io.use()` configuration method
    to intercept the handshake process. In your configuration function, you used the
    Express `cookie-parser` module to parse the handshake request cookie and retrieve
    the Express `sessionId`. Then, you used the `connect-mongo` instance to retrieve
    the session information from the MongoDB storage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下新的Socket.io配置文件。首先，您需要引入必要的依赖项，然后使用`io.use()`配置方法来拦截握手过程。在配置函数中，您使用Express的`cookie-parser`模块来解析握手请求的cookie并检索Express的`sessionId`。然后，您使用`connect-mongo`实例从MongoDB存储中检索会话信息。
- en: Once you retrieved the session object, you used the `passport.initialize()`
    and `passport.session()` middleware to populate the session's `user` object according
    to the session information. If a user is authenticated, the handshake middleware
    will call the `next()` callback and continue with the socket initialization; otherwise,
    it will use the `next()` callback in a way that informs Socket.io that a socket
    connection cannot be opened. This means that only authenticated users can open
    a socket communication with the server and prevent unauthorized connections to
    your Socket.io server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检索到会话对象，您使用`passport.initialize()`和`passport.session()`中间件来根据会话信息填充会话的`user`对象。如果用户经过身份验证，握手中间件将调用`next()`回调并继续进行套接字初始化；否则，它将使用`next()`回调以一种方式通知Socket.io套接字连接无法打开。这意味着只有经过身份验证的用户才能与服务器建立套接字通信，并防止未经授权的连接到您的Socket.io服务器。
- en: 'To complete your Socket.io server configuration, you will need to call the
    Socket.io configuration module from your `express.js` file. Go to your `config/express.js`
    file and change it, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成您的Socket.io服务器配置，您需要从`express.js`文件中调用Socket.io配置模块。转到您的`config/express.js`文件并进行更改，如下所示：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will execute your Socket.io configuration method and will take care of
    setting the Socket.io session. Now that you have everything configured, let's
    see how you can use Socket.io and MEAN to easily build a simple chat.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行您的Socket.io配置方法，并负责设置Socket.io会话。现在您已经配置好了一切，让我们看看如何使用Socket.io和MEAN轻松构建一个简单的聊天。
- en: Building a Socket.io chat
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个Socket.io聊天
- en: To test your Socket.io implementation, build a simple chat application. Your
    chat will be constructed from several server event handlers, but most of the implementation
    will take place in your Angular application. We'll begin with setting the server
    event handlers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试您的Socket.io实现，构建一个简单的聊天应用程序。您的聊天将由几个服务器事件处理程序构成，但大部分实现将在您的Angular应用程序中进行。我们将从设置服务器事件处理程序开始。
- en: Setting the event handlers of the chat server
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置聊天服务器的事件处理程序
- en: 'Before implementing the chat client in your Angular application, you''ll first
    need to create a few server event handlers. You already have a proper application
    structure, so you won''t implement the event handlers directly in your configuration
    file. Instead, it would be better to implement your chat logic by creating a new
    file named `chat.server.controller.js` inside your `app/controllers` folder. In
    your new file, paste the following lines of code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Angular应用程序中实现聊天客户端之前，您首先需要创建一些服务器事件处理程序。您已经有了一个合适的应用程序结构，因此不会直接在配置文件中实现事件处理程序。相反，最好通过在`app/controllers`文件夹中创建一个名为`chat.server.controller.js`的新文件来实现聊天逻辑。在您的新文件中，粘贴以下代码行：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this file, you implemented a couple of things. First, you used the `io.emit()`
    method to inform all the connected socket clients about the newly connected user.
    This was done by emitting the `chatMessage` event and passing a chat message object
    with the user information and the message text, time, and type. Since you took
    care of handling the user authentication in your socket server configuration,
    the user information is available from the `socket.request.user` object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，您实现了一些内容。首先，您使用`io.emit()`方法通知所有连接的套接字客户端有新连接的用户。这是通过发出`chatMessage`事件并传递带有用户信息和消息文本、时间和类型的聊天消息对象来完成的。由于您在套接字服务器配置中处理了用户身份验证，用户信息可以从`socket.request.user`对象中获取。
- en: Next, you implemented the `chatMessage` event handler that will take care of
    messages sent from the socket client. The event handler will add the message type,
    time, and user information, and it will send the modified message object to all
    connected socket clients using the `io.emit()` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您实现了`chatMessage`事件处理程序，负责处理从套接字客户端发送的消息。事件处理程序将添加消息类型、时间和用户信息，并使用`io.emit()`方法将修改后的消息对象发送给所有连接的套接字客户端。
- en: Our last event handler will take care of handling the `disconnect` system event.
    When a certain user is disconnected from the server, the event handler will notify
    all the connected socket clients about this event using the `io.emit()` method.
    This will allow the chat view to present the disconnection information to other
    users.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个事件处理程序将负责处理`disconnect`系统事件。当某个用户从服务器断开连接时，事件处理程序将使用`io.emit()`方法通知所有连接的socket客户端关于这个事件。这将允许聊天视图向其他用户呈现断开连接的信息。
- en: 'You now have your server handlers implemented, but how will you configure the
    socket server to include these handlers? To do that, you will need to go back
    to your `config/socketio.js` file and slightly modify it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经实现了服务器处理程序，但是如何配置socket服务器以包含这些处理程序呢？为此，您需要返回到您的`config/socketio.js`文件并稍微修改它：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note how the socket server `connection` event is used to call the chat controller.
    This will allow you to bind your event handlers directly with the connected socket.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意socket服务器`connection`事件是如何用来调用聊天控制器的。这将允许您直接将事件处理程序与连接的socket绑定。
- en: Congratulations; you've successfully completed your server implementation! Next,
    you'll see how easy it is to implement the Angular chat component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功完成了服务器的实现！接下来，您将看到实现Angular聊天组件是多么容易。
- en: Creating the Chat Angular module
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建聊天Angular模块
- en: In order to finish our chat implementation, we're going to create a new Angular
    chat module. Our module will include our component and template, a routing configuration,
    and a service wrapping the `socket.io` client functionality. Socket.io provides
    us with a client library to handle the socket communication; however, a best practice
    would be to obfuscate it using our own Angular service. We'll begin by configuring
    the Socket.io client library.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的聊天实现，我们将创建一个新的Angular聊天模块。我们的模块将包括我们的组件和模板、路由配置以及包装`socket.io`客户端功能的服务。Socket.io为我们提供了一个客户端库来处理socket通信；然而，最佳实践是使用我们自己的Angular服务来混淆它。我们将从配置Socket.io客户端库开始。
- en: Setting up the Socket.io client library
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Socket.io客户端库
- en: 'To set up the Socket.io client library, we''ll need to include the library
    JavaScript file in our `index.ejs` template. To do that, go to the `app/views/index.ejs`
    file and make the following change:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置Socket.io客户端库，我们需要在我们的`index.ejs`模板中包含库的JavaScript文件。为此，转到`app/views/index.ejs`文件并进行以下更改：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, all that we did here was add the script tag to include Socket.io's
    client file in our main application page. Next, we'll need to create our `Chat`
    module.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这里所做的就是在我们的主应用页面中添加脚本标签以包含Socket.io的客户端文件。接下来，我们需要创建我们的`Chat`模块。
- en: Creating the Chat module
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建聊天模块
- en: 'Once we are finished with the basic declaration setup for our client Socket.io
    implementation, we can continue with our chat implementation. To begin, create
    a folder named `chat` inside your `public/app` folder. Then, create a file inside
    this folder called `chat.module.ts`, which contains the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了客户端Socket.io实现的基本声明设置后，我们可以继续进行聊天实现。首先，在`public/app`文件夹内创建一个名为`chat`的文件夹。然后，在这个文件夹内创建一个名为`chat.module.ts`的文件，其中包含以下代码：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you probably noticed, our module imports a new chat component and routing
    configuration and injects the chat service. Let's continue by creating our chat
    service.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能注意到的，我们的模块导入了一个新的聊天组件和路由配置，并注入了聊天服务。让我们继续创建我们的聊天服务。
- en: Creating the Chat service
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建聊天服务
- en: 'In order to obfuscate our component communication with the Socket.io client
    library, we''ll need to create an Angular service. To do that, create a file named
    `chat.service.ts` inside your `public / app / chat` folder. In your new file,
    paste the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了混淆我们的组件与Socket.io客户端库的通信，我们需要创建一个Angular服务。为此，在`public/app/chat`文件夹内创建一个名为`chat.service.ts`的文件。在新文件中，粘贴以下代码：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's review our new code for a moment. The basic structure should look familiar,
    since it is basically a regular Angular service. After injecting the Authentication
    and Router services in the constructor, you checked whether the user is authenticated
    using the `Authentication` service. If the user was not authenticated, you redirected
    the request back to the home page using the `Router` service. Since Angular services
    are lazily loaded, the Socket service will only load when requested. This will
    prevent unauthenticated users from using the Socket service. If the user is authenticated,
    the service `socket` property is set by calling the `io()` method of Socket.io.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下来审查我们的新代码。基本结构应该看起来很熟悉，因为它基本上是一个常规的Angular服务。在构造函数中注入了Authentication和Router服务后，您使用`Authentication`服务检查用户是否经过身份验证。如果用户未经过身份验证，则使用`Router`服务将请求重定向回主页。由于Angular服务是惰性加载的，Socket服务只有在请求时才会加载。这将阻止未经身份验证的用户使用Socket服务。如果用户经过身份验证，则通过调用Socket.io的`io()`方法设置服务`socket`属性。
- en: Next, you wrapped the socket `emit()`, `on()`, and `removeListener()` methods
    with compatible service methods. In order to keep our example straightforward,
    we called our `ChatService` service. However, as you may notice by its structure,
    this service can easily become a general Socket service used across different
    components of our application. Now that the chat service is ready, all we have
    to do is implement the chat component and template. Let's begin by defining the
    chat component.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您使用兼容的服务方法包装了socket的`emit()`、`on()`和`removeListener()`方法。为了保持我们的示例简单，我们称之为`ChatService`服务。然而，正如您可能通过其结构注意到的那样，这个服务很容易成为我们应用程序不同组件中使用的通用Socket服务。现在聊天服务已经准备好了，我们所要做的就是实现聊天组件和模板。让我们开始定义聊天组件。
- en: Creating the Chat component
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建聊天组件
- en: 'Our chat component will contain the basic client-side chat functionality. To
    implement it, go to your `public / app / chat` folder and create a file named
    `char.component.ts`. In your new file, paste the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天组件将包含基本的客户端聊天功能。要实现它，转到您的`public/app/chat`文件夹，并创建一个名为`char.component.ts`的文件。在新文件中，粘贴以下代码：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In our component, you first created a message array and then used the `ChatService
    on()` method to implement the `chatMessage` event listener that will add retrieved
    messages to this array. Next, you created a `sendMessage()` method that will send
    new messages by emitting the `chatMessage` event to the socket server. Finally,
    you used the in-built `ngOnInit` directive to remove the `chatMessage` event listener
    from the socket client. The `ngOnDestroy` method will be emitted when the controller
    instance is deconstructed. This is important because the event handler will still
    get executed unless you remove it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的组件中，您首先创建了一个消息数组，然后使用`ChatService on()`方法来实现`chatMessage`事件监听器，将检索到的消息添加到此数组中。接下来，您创建了一个`sendMessage()`方法，通过向套接字服务器发出`chatMessage`事件来发送新消息。最后，您使用内置的`ngOnInit`指令来从套接字客户端中删除`chatMessage`事件监听器。当控制器实例被拆除时，`ngOnDestroy`方法将被触发。这很重要，因为除非您将其删除，否则事件处理程序仍将被执行。
- en: Creating the Chat template
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建聊天模板
- en: 'The chat template will be constructed from a simple form and a list of chat
    messages. To implement your chat template, go to your `public/app/chat` folder
    and create a new file named `chat.template.html`, which contains the following
    code snippet:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天模板将由一个简单的表单和一个聊天消息列表构成。要实现您的聊天模板，请转到您的`public/app/chat`文件夹，并创建一个名为`chat.template.html`的新文件，其中包含以下代码片段：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In your template, you used the `ngFor` directive to render the message list
    and the `ngSwitch` directive to distinguish between status messages and regular
    messages. The template ends with a simple form that uses the `ngSubmit` directive
    to invoke the `sendMessage()` method. That is it! All you have to do is finalize
    your implementation by adding the Chat module to our application module.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的模板中，您使用了`ngFor`指令来渲染消息列表，使用了`ngSwitch`指令来区分状态消息和常规消息。模板以一个简单的表单结束，该表单使用`ngSubmit`指令来调用`sendMessage()`方法。就是这样！您只需要通过将聊天模块添加到我们的应用程序模块中来完成您的实现。
- en: Adding the Chat routing configuration
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加聊天路由配置
- en: 'To add your Chat component route, go back to your `public/app/chat` folder
    and create a new file named `chat.routes.ts`, which contains the following code
    snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加聊天组件路由，请返回到您的`public/app/chat`文件夹，并创建一个名为`chat.routes.ts`的新文件，其中包含以下代码片段：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, we created a simple routing for our chat component. All we have
    left to do is include our chat module in our application module.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们为我们的聊天组件创建了一个简单的路由。我们要做的就是在我们的应用程序模块中包含我们的聊天模块。
- en: Using the Chat module
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用聊天模块
- en: 'To finalize our Chat implementation, we''ll need to include our module in the
    application module. To do that, go to your `public/app/app.`module `.ts`, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成我们的聊天实现，我们需要将我们的模块包含在应用程序模块中。为此，请转到您的`public/app/app.module.ts`，如下所示：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, you''ll need to add a link to our chat component in our home component.
    To do that, go to your `public/app/home/home.template.html` file and make the
    following changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要在主页组件中添加一个链接到我们的聊天组件。为此，请转到您的`public/app/home/home.template.html`文件并进行以下更改：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once you are finished with these changes, your new chat component should be
    ready for use! Use your command-line tool and navigate to the MEAN application''s
    root folder. Then, run your application by typing the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些更改后，您的新聊天组件应该已经准备好使用了！使用命令行工具并导航到MEAN应用程序的根文件夹。然后，通过输入以下命令来运行您的应用程序：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once your application is running, open two different browsers and sign up with
    two different users. Then, navigate to `http://localhost:3000/` and click on your
    new Chat link. Try to send chat messages between your two clients, and you'll
    be able to see how chat messages are updated in real time. Your MEAN application
    now supports real-time communication!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的应用程序运行起来，打开两个不同的浏览器并使用两个不同的用户进行注册。然后，导航到`http://localhost:3000/`并点击您的新的聊天链接。尝试在两个客户端之间发送聊天消息，您将能够看到聊天消息是如何实时更新的。您的MEAN应用程序现在支持实时通信！
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how the `socket.io` module works. You went over
    the key features of Socket.io and learned how the server and client communicate.
    You configured your Socket.io server and learned how to integrate it with your
    Express application. You also used the Socket.io handshake configuration to integrate
    the Passport session. Finally, you built a fully functional chat example and learned
    how to wrap the Socket.io client with an Angular service. In the next chapter,
    you'll learn how to write and run tests to cover your application code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了`socket.io`模块的工作原理。您了解了Socket.io的关键特性，并学习了服务器和客户端如何通信。您配置了Socket.io服务器，并学习了如何将其与Express应用程序集成。您还使用了Socket.io握手配置来集成Passport会话。最后，您构建了一个完全功能的聊天示例，并学习了如何使用Angular服务包装Socket.io客户端。在下一章中，您将学习如何编写和运行测试来覆盖您的应用程序代码。
