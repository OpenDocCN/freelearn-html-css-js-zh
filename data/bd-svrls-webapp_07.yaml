- en: Managing a Serverless Database
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理无服务器数据库
- en: 'A serverless database is defined like any other serverless service: it needs
    to have *high availability*,Â *high scalability*, and the pricing model must consider
    its *real usage*. Satisfying those conditions is particularly hard for databases
    since *performance* is a key feature. For a predictable and high performance,
    databases are usually configured in their own dedicated servers, but serverless
    requires a shared model to avoid charging the customer for 100% of the time the
    database is available. In serverless, we want to pay only when a request is done
    and not when the database is in an idle state.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器数据库的定义与任何其他无服务器服务相同：它需要具有*高可用性*、*高可扩展性*，并且定价模型必须考虑其实际使用情况。对于数据库来说，满足这些条件尤其困难，因为*性能*是一个关键特性。为了可预测的高性能，数据库通常配置在自己的专用服务器上，但无服务器需要共享模型以避免向客户收取数据库100%可用时间的费用。在无服务器中，我们只想在请求完成时付费，而不是当数据库处于空闲状态时。
- en: 'Currently, only a few services have managed to bring the serverless model to
    databases. AWS offers just one service: SimpleDB, but it lacks many important
    features and is extremely limited. For other and better options, you can try FaunaDB,
    Google Firebase, or Google Cloud Datastore. To continue to use AWS services in
    this book, we are going to cover DynamoDB, which is an almost serverless database.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只有少数服务成功地将无服务器模型引入数据库。AWS仅提供一项服务：SimpleDB，但它缺少许多重要功能，并且极其有限。对于其他更好的选择，你可以尝试FaunaDB、Google
    Firebase或Google Cloud Datastore。为了继续使用本书中的AWS服务，我们将介绍DynamoDB，它是一种几乎无服务器的数据库。
- en: Furthermore, we'll see how to use Amazon S3 to store media files since, in most
    cases, it's better to save files in a cheap storage system than a database server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将了解如何使用Amazon S3来存储媒体文件，因为在大多数情况下，将文件保存在廉价的存储系统中比数据库服务器更好。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using and managing SimpleDB and DynamoDB databases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和管理SimpleDB和DynamoDB数据库
- en: Using Amazon S3 to store media files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon S3存储媒体文件
- en: When you finish this chapter, you'll have implemented the data access layer
    of the online store and acquired the necessary knowledge to use serverless databases.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成本章后，你将已经实现了在线商店的数据访问层，并获得了使用无服务器数据库的必要知识。
- en: Amazon SimpleDB
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon SimpleDB
- en: SimpleDB is an old service (late 2007), and it is the only one offered by AWS
    that can really be called a serverless database. AWS offers many other managed
    databases, such as DynamoDB or RDS, but all of them require that you set provisions
    and pay for 24 hours a day, even when no one is using your system. You *do* need
    to worry about the servers when you need to constantly check whether the capacity
    is well designed for your traffic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 'SimpleDB是一项旧服务（2007年底），并且是AWS提供的唯一一个真正可以称为无服务器数据库的服务。AWS提供许多其他托管数据库，如DynamoDB或RDS，但所有这些都需要你设置配置并支付24小时的费用，即使没有人使用你的系统。当你需要不断检查容量是否适合你的流量时，你确实需要担心服务器。 '
- en: 'SimpleDB is serverless for the following reasons:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleDB之所以是无服务器的，有以下原因：
- en: '**Totally managed by AWS**: You don''t need to spin-up a machine and install/configure
    a DBMS.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全由AWS管理**：你不需要启动机器并安装/配置数据库管理系统。'
- en: '**Highly available**: AWS manages multiple geographically distributed replicas
    of your database to enable high availability and data durability.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性**：AWS管理多个地理上分布的数据库副本，以实现高可用性和数据持久性。'
- en: '**Scalable**: You can grow in size very fast without worrying about provisioning.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：你可以快速增长，而无需担心配置。'
- en: '**Cost-efficient**: You pay for the amount of data stored, data transferred,
    and the CPU time used to run queries. If no one is using the database, you pay
    only for what is currently stored.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本效益**：你只需为存储的数据量、传输的数据量和运行查询所使用的CPU时间付费。如果没有人使用数据库，你只需为当前存储的内容付费。'
- en: SimpleDB is a NoSQL database, but unfortunately, it is very limited due to the
    absence of important functionalities. For example, the only data type that you
    can use is a string. This makes it harder for you to implement a lot of use cases,
    but we will cover some hacks here to make it feasible. If your application is
    somewhat complex, I would avoid using SimpleDB. Use it only for small applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleDB是一个NoSQL数据库，但遗憾的是，由于缺少重要的功能，它非常有限。例如，你可以使用的唯一数据类型是字符串。这使得你难以实现许多用例，但我们将在这里介绍一些技巧，使其可行。如果你的应用程序相对复杂，我会避免使用SimpleDB。仅用于小型应用程序。
- en: Modeling the database
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计数据库模型
- en: 'First, a little bit of nomenclature: a *domain*, in SimpleDB, is the equivalent
    of a *table* in the relational world and an *item* is the equivalent of a *row*.
    They are pretty equivalent, but you need to know what they mean to understand
    SDK functions. Also, in SimpleDB, each *item* has a list of attribute-value pairs,
    where the *attribute* is like a *column* and the values are always of the string
    data type.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先了解一下一些术语：在SimpleDB中，一个*域*相当于关系型世界中的*表*，而一个*项*相当于*行*。它们非常相似，但你需要了解它们的意思才能理解SDK函数。此外，在SimpleDB中，每个*项*都有一个属性值对的列表，其中*属性*类似于*列*，而值总是字符串数据类型。
- en: For a practical example, we will model the database for the serverless store.
    We are going to use just two domains such as `Products` and `ShoppingCart`. We
    will not create a domain to save user account data (e-mail, password, and others)
    because we are going to use Amazon Cognito in the next chapter and Cognito is
    responsible for saving and managing user data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们将为无服务器商店建模数据库。我们只将使用两个域，例如`Products`和`ShoppingCart`。我们不会创建一个域来保存用户账户数据（电子邮件、密码等），因为在下一章中我们将使用Amazon
    Cognito，而Cognito负责保存和管理用户数据。
- en: 'The following table lists the attributes for the `Products` domain. All of
    them will be created to hold strings due to a SimpleDB restriction, but I''ve
    added what would be the ideal data type. And, in the next sections, we will see
    how to handle this limitation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了`Products`域的属性。所有这些属性都将创建以保存字符串，因为SimpleDB有一个限制，但我已经添加了理想的数据类型。在下一节中，我们将看到如何处理这个限制：
- en: '| **Attribute** | **Desired data type** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **期望的数据类型** |'
- en: '| `ID` | String |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `ID` | 字符串 |'
- en: '| `Name` | String |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `名称` | 字符串 |'
- en: '| `Price` | Decimal |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `价格` | 十进制 |'
- en: '| `Image` | String |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `图片` | 字符串 |'
- en: '| `Comments` | Array of documents |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `评论` | 文档数组 |'
- en: 'Some observations about this model are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此模型的一些观察如下：
- en: '`ID`: The `ID` attribute could be defined as an integer, but I''ve defined
    it as a string since we are using the ID in the URL. Instead of showing the URL
    as `store.com/product/123`, we are using `store.com/product/lonely-bird`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ID`：`ID`属性可以定义为整数，但我将其定义为字符串，因为我们将在URL中使用ID。我们不是将URL显示为`store.com/product/123`，而是使用`store.com/product/lonely-bird`。'
- en: '`Price`: The `Price` attribute will be saved as a string, although we wanted
    to save it as a number.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`价格`：`价格`属性将以字符串形式保存，尽管我们希望将其保存为数字。'
- en: '`Image`: The `Image` attribute will be saved as a string because we will save
    the URL of a S3 object instead of saving the entire object in the database.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图片`：`图片`属性将以字符串形式保存，因为我们将在数据库中保存S3对象的URL，而不是保存整个对象。'
- en: '`Comments`: The `Comments` attribute needs a relation of **one-to-many**, where
    *one* product has *many* comments. Some NoSQL databases, such as MongoDB, have
    an "array of documents" data type, which would be helpful here.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`评论`：`评论`属性需要一个**一对一**的关系，其中*一个*产品有*多个*评论。一些NoSQL数据库，如MongoDB，有一个“文档数组”数据类型，这在这里会有所帮助。'
- en: 'The `Comments` field will be a list of:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`评论`字段将是一个列表：'
- en: '| **Attribute** | **Desired data type** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **期望的数据类型** |'
- en: '| `ID` | Integer |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `ID` | 整数 |'
- en: '| `Username` | String |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `用户名` | 字符串 |'
- en: '| `Date` | DateTime |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `日期` | 日期时间 |'
- en: '| `Text` | String |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `文本` | 字符串 |'
- en: 'This model requires other observations:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型需要其他观察：
- en: The `ID` attribute could be defined as an integer where the `ID` of every new
    comment would be the value of the last saved comment `ID` plus one unit. However,
    SimpleDB doesn't offer any feature for auto-incrementing a field. To avoid needing
    to query the last comment `ID` before saving a new comment, and the conflicts
    it would cause due to the lack of transactions, we can use this attribute to save
    an **Universally Unique Identifier** (**UUID**) as a string value.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ID`属性可以定义为整数，其中每个新评论的`ID`将是最后保存的评论`ID`加一。然而，SimpleDB没有提供任何自动递增字段的特性。为了避免在保存新评论之前查询最后一个评论`ID`，以及由于缺乏事务而可能引起的冲突，我们可以使用这个属性以字符串形式保存一个**全局唯一标识符**（**UUID**）。'
- en: The `Date` attribute will be discussed later.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`日期`属性将在稍后讨论。'
- en: 'The following table lists the attributes for the `ShoppingCart` domain:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了`ShoppingCart`域的属性：
- en: '| **Attribute** | **Desired data type** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **期望的数据类型** |'
- en: '| `UserID` | String |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `UserID` | 字符串 |'
- en: '| `LastUpdate` | DateTime |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `最后更新` | 日期时间 |'
- en: '| `SelectedProducts` | Array of documents |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `SelectedProducts` | 文档数组 |'
- en: As we are going to use Amazon Cognito, the `UserID` was defined as a string.
    The only problem with this model is that we want a field to store a datetime and
    another to store an array of data, where `SelectedProducts` are defined by a list
    of `ProductID` and `Quantity` pairs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用Amazon Cognito，所以`UserID`被定义为字符串类型。这个模型唯一的问题是，我们希望有一个字段来存储日期时间，另一个字段来存储数据数组，其中`SelectedProducts`由`ProductID`和`Quantity`对的列表定义。
- en: Handling one-to-many relations
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理一对一关系
- en: In the previous models, we saw that *one* product has *many* comments and *one*
    cart has *many* selected products. In a relational database, we would model another
    table to list all comments or selected products and we would use the `join` operator
    to retrieve all related data when querying for a specific product or cart. However,
    in NoSQL, we usually don't have a `join` operator so we need to make two separated
    queries to retrieve what we need *or* we can save all related data in just one
    field as an array of documents.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的模型中，我们看到了一个产品有多个评论，一个购物车有多个选定的产品。在一个关系型数据库中，我们会创建另一个表来列出所有评论或选定的产品，并在查询特定产品或购物车时使用`join`操作符来检索所有相关数据。然而，在NoSQL中，我们通常没有`join`操作符，所以我们需要进行两个独立的查询来检索所需的数据，或者我们可以将所有相关数据保存到一个字段中，作为一个文档数组。
- en: 'In SimpleDB, we don''t have an "array of documents" data type, but we have
    two other options:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在SimpleDB中，我们没有“文档数组”数据类型，但有另外两种选择：
- en: Save a stringified array of JSON objects
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存JSON对象的字符串化数组
- en: Multi-valued attributes
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多值属性
- en: The first option is a hacky solution where you can stringify an array of JavaScript
    objects and save it in a single attribute. The problem is that you won't be able
    to query attributes in this field, so forget queries such as "How many distinct
    users have ordered ProductID lonely-bird?".
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方案是一个笨拙的解决方案，你可以将JavaScript对象的数组字符串化并保存到单个属性中。问题是，你将无法查询这个字段中的属性，所以忘记查询“有多少不同的用户订购了ProductID
    lonely-bird？”这样的查询。
- en: 'The second option is the best solution since SimpleDB allows you to have multiple
    attributes with the same name. Take a look at the following dataset for the `ShoppingCart`
    that uses multi-valued attributes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方案是最佳解决方案，因为SimpleDB允许你拥有多个具有相同名称的属性。看看以下`ShoppingCart`数据集，它使用了多值属性：
- en: '| **UserID** | **LastUpdate** | **ProductID** | **QuantityX** | **ProductID**
    | **QuantityY** | **ProductID** | **QuantityZ** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **UserID** | **LastUpdate** | **ProductID** | **QuantityX** | **ProductID**
    | **QuantityY** | **ProductID** | **QuantityZ** |'
- en: '| `A` | `<Date>` | `X` | `2` | `Y` | `2` | `Z` | `4` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `A` | `<Date>` | `X` | `2` | `Y` | `2` | `Z` | `4` |'
- en: '| `B` | `<Date>` | `X` | `3` | ​ | ​ | ​ | ​ |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `B` | `<Date>` | `X` | `3` | ​ | ​ | ​ | ​ |'
- en: '| `C` | `<Date>` | `X` | `1` | `Y` | `5` | ​ | ​ |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `C` | `<Date>` | `X` | `1` | `Y` | `5` | ​ | ​ |'
- en: The `ProductID` attribute repeats with the same name multiple times and this
    is not an issue because SimpleDB allows two attributes with the same name. What
    SimpleDB does not allow is two attributes with the same name *and* value. In the
    first item (`UserID` with value `A`), we have a `ProductID` with value `X` and
    a `ProductID` with value `Y`, which is valid. The problem would be with the `Quantity`
    attributes, since two of them have value `2` in the same item. To fix this problem,
    the `ProductID` value was appended to the attribute name, creating the attributes
    `QuantityX` and `QuantityY`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductID`属性以相同的名称重复多次，这不是问题，因为SimpleDB允许两个具有相同名称的属性。SimpleDB不允许两个具有相同名称和值的属性。在第一个项目（`UserID`值为`A`）中，我们有一个值为`X`的`ProductID`和一个值为`Y`的`ProductID`，这是有效的。问题在于`Quantity`属性，因为两个属性在同一个项目中都有值为`2`。为了解决这个问题，将`ProductID`值附加到属性名称上，创建了`QuantityX`和`QuantityY`属性。'
- en: The SimpleDB domain is schemaless, which means that, when you insert a new item,
    you say what attributes it has and it won't return an error if you add an attribute
    name that doesn't exist yet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleDB域是无模式的，这意味着当你插入一个新项目时，你只需说明它具有哪些属性，如果添加了一个尚不存在的属性名称，它也不会返回错误。
- en: Handling numbers
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数字
- en: The biggest issue with SimpleDB is not about how to store data as a string but
    how to retrieve it using queries. You can save the number `27` as `"27"`, but
    filtering a query with `Quantity > "5"` would not return the desired value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleDB的最大问题不在于如何将数据作为字符串存储，而在于如何使用查询来检索它。你可以将数字`27`保存为`"27"`，但使用`Quantity
    > "5"`进行过滤查询不会返回期望的值。
- en: A solution to handle numerical data as a string is to modify it before saving.
    Instead of saving `"27"`, use a zero-padding function and store it as `"000027"`.
    Now query it with `Quantity > "000005"` and you will get the value that you want.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将数值数据作为字符串处理的一个解决方案是在保存之前对其进行修改。与其保存`"27"`，不如使用零填充函数并将其存储为`"000027"`。现在用`Quantity
    > "000005"`进行查询，你将得到你想要的价值。
- en: How many zeros do you need to add? It depends. Think about the largest number
    that your dataset can reach and zero-pad all the other numbers to have the same
    number of characters.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要添加多少个零？这取决于。考虑一下你的数据集可以达到的最大数字，并将所有其他数字都零填充以具有相同的字符数。
- en: This trick works for integers. If you have a decimal, as in the `Price` attribute,
    you need to multiply it by the number of decimal places. In this case, multiply
    it per 100 before saving the value and divide it by 100 when you retrieve it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧适用于整数。如果你有一个小数，比如`Price`属性，你需要将其乘以小数位数。在这种情况下，在保存值之前乘以100，在检索时除以100。
- en: Another issue is handling negative numbers. In this case, you need to add an
    offset. This offset must be greater than the largest negative number of your entire
    dataset. For example, if your offset is `100,000`, the value `-27` must be added
    to `100,000` (resulting in `99973`) and zero-padded with six places, resulting
    in `"099973"`. If you need to compare whether the number is greater than `5`,
    you will need to add the offset and zero-pad the comparison value, resulting in
    `Quantity > "100005"`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是如何处理负数。在这种情况下，你需要添加一个偏移量。这个偏移量必须大于你整个数据集中最大的负数。例如，如果你的偏移量是`100,000`，则必须将`-27`加到`100,000`（结果为`99973`），并用六个零进行零填充，结果为`"099973"`。如果你需要比较数字是否大于`5`，你需要添加偏移量并零填充比较值，结果为`Quantity
    > "100005"`。
- en: Handling Booleans
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理布尔值
- en: You can store Boolean values as either `true`/`false` or `1`/`0`. You can select
    what you prefer, just define a convention and use the same strategy in all Boolean
    attributes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将布尔值存储为`true`/`false`或`1`/`0`。你可以选择你喜欢的，只需定义一个约定并在所有布尔属性中使用相同的策略。
- en: 'Here''s an example of this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Handling dates
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理日期
- en: When saving a datetime variable, you can use the ISO 8601 standard format, for
    example, `5:15:10 PM December 24th 2016 UTC` becomes `2016-12-24T17:15:10.000Z`.
    This format is queryable using strings. So `Date > "2016-12-24T00:00:00.000Z"`
    will return the value of the previous example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当保存日期时间变量时，你可以使用ISO 8601标准格式，例如，`5:15:10 PM December 24th 2016 UTC`变为`2016-12-24T17:15:10.000Z`。此格式可以用字符串进行查询。因此，`Date
    > "2016-12-24T00:00:00.000Z"`将返回上一个示例的值。
- en: Now consider that you have a `LastAccess` attribute and you want to query all
    the users that accessed your system in the last 5 minutes. In this case, you just
    need to find the current time, subtract it by 5 minutes, and convert it into the
    ISO string before querying.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑你有一个`LastAccess`属性，你想要查询在过去5分钟内访问过你的系统的所有用户。在这种情况下，你只需要找到当前时间，减去5分钟，然后在查询之前将其转换为ISO字符串。
- en: Creating a domain
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建域
- en: Creating a domain is pretty straightforward. You just need to set the domain
    name as the parameter and it will be created with the `createDomain` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建域相当简单。你只需要将域名作为参数设置，它将通过`createDomain`函数创建。
- en: 'Here''s an example of this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Regarding the attributes, you don't need to specify them while creating the
    domain. There is no schema attached. Each item has its own list of attributes
    that are not necessarily the same as the other attributes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于属性，在创建域时你不需要指定它们。没有附加模式。每个项目都有自己的属性列表，这些属性不一定与其他属性相同。
- en: Limits
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制
- en: 'SimpleDB was designed for small workloads, so AWS has enforced some limits
    that may restrict your application. In the following table, I''ve listed the most
    important limits that you should be aware of before using SimpleDB in your system.
    You can find more about this in the official documentation at [http://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/SDBLimits.html](http://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/SDBLimits.html):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleDB是为小型工作负载设计的，因此AWS实施了一些限制，这些限制可能会限制你的应用程序。在下面的表中，我列出了在使用SimpleDB之前你应该注意的最重要限制。你可以在官方文档中找到更多关于此的信息：[http://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/SDBLimits.html](http://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/SDBLimits.html)：
- en: '| **Parameter** | **Restriction** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **限制** |'
- en: '| Domain size | 10 GB per domain |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 域大小 | 每个域10 GB |'
- en: '| Domain size | 1 billion attributes per domain |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 域大小 | 每个域1亿个属性 |'
- en: '| Attribute value length | 1,024 bytes |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 属性值长度 | 1,024 字节 |'
- en: '| Maximum items in the `Select` response | 2,500 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Select` 响应中的最大项目数 | 2,500 |'
- en: '| Maximum query execution time | 5 seconds |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 最大查询执行时间 | 5 秒 |'
- en: '| Maximum response size of `Select` | 1 MB |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `Select` 的最大响应大小 | 1 MB |'
- en: Inserting and querying data
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入和查询数据
- en: 'The following example shows how to insert data into a SimpleDB domain. I''m
    using `batchPutAttributes` because it allows multiple inserts simultaneously,
    but you could call `putAttributes` to insert a single item:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何将数据插入 SimpleDB 域。我使用 `batchPutAttributes` 因为它允许同时进行多个插入，但您也可以调用 `putAttributes`
    来插入单个项：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following example shows how to query the data that was previously inserted.
    Despite being a NoSQL database, SimpleDB uses a SQL-like syntax for queries:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何查询之前插入的数据。尽管 SimpleDB 是一个 NoSQL 数据库，但在查询时它使用类似 SQL 的语法：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code will generate the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成以下输出：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Performance and concurrency
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和并发
- en: AWS will automatically create an index for every attribute that you create,
    but querying data filtering by dates or integers converted into strings can easily
    lead to performance issues. You should always be careful of your performance requirements
    and the size of your domain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 将自动为每个创建的属性创建索引，但通过日期或转换为字符串的整数进行数据过滤查询可能会轻易导致性能问题。您应该始终注意您的性能需求和域的大小。
- en: Also, like most NoSQL databases, SimpleDB doesn't support transactions, so concurrency
    can be a real problem for data consistency. Instead of transactions, SimpleDB
    offers *conditional operations*. For example, if you need to insert some data,
    you can place a condition that will execute the operation only if the attribute
    does not exist yet. Another use case is to implement a counter. You will update
    the value of the counter to `X+1` only if the current value is `X`. If this condition
    is not met, it's because another user have already incremented the value and your
    update will be canceled.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像大多数 NoSQL 数据库一样，SimpleDB 不支持事务，因此并发可能会成为数据一致性的真正问题。而不是事务，SimpleDB 提供了 *条件操作*。例如，如果您需要插入一些数据，您可以放置一个条件，只有当属性尚不存在时才会执行该操作。另一个用例是实现计数器。您将只更新计数器的值为
    `X+1`，如果当前值是 `X`。如果这个条件不满足，那是因为另一个用户已经增加了值，您的更新将被取消。
- en: 'Here''s an example of a conditional operation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个条件操作的示例：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Managing the database
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数据库
- en: You can manage your database using the AWS CLI or SDK, but many people prefer
    to use a tool that provides a user interface. Since AWS doesn't offer a console
    for SimpleDB, we need to rely on third-party tools. In this case, I can recommend
    the Chrome extension SdbNavigator. It's a very simple tool but offers a nice user
    interface with the essential features such as creating domains, inserting items,
    and making queries.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 AWS CLI 或 SDK 来管理您的数据库，但许多人更喜欢使用提供用户界面的工具。由于 AWS 不为 SimpleDB 提供控制台，我们需要依赖第三方工具。在这种情况下，我可以推荐
    Chrome 扩展程序 SdbNavigator。这是一个非常简单的工具，但提供了一个很好的用户界面，具有创建域名、插入项和执行查询等基本功能。
- en: 'Take a look at the following steps for managing the database:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下步骤以管理数据库：
- en: Using Chrome, you can add the extension from [https://chrome.google.com/webstore/detail/sdbnavigator/ddhigekdfabonefhiildaiccafacphgg.](https://chrome.google.com/webstore/detail/sdbnavigator/ddhigekdfabonefhiildaiccafacphgg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Chrome，您可以添加来自[https://chrome.google.com/webstore/detail/sdbnavigator/ddhigekdfabonefhiildaiccafacphgg](https://chrome.google.com/webstore/detail/sdbnavigator/ddhigekdfabonefhiildaiccafacphgg)
    的扩展程序。
- en: 'After installing it, add your AWS keys and select a region to connect. You
    can add a new domain with the Add domain button:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，添加您的 AWS 密钥并选择一个区域进行连接。您可以使用添加域名按钮添加新的域名：
- en: '![](img/bda2ffed-14d2-403c-925c-94f68405f81f.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bda2ffed-14d2-403c-925c-94f68405f81f.png)'
- en: 'This tool has a button to add properties. When you add a new item, these properties
    will become the items'' attributes:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此工具有一个添加属性的按钮。当您添加新项时，这些属性将成为项的属性：
- en: '![](img/c5896d86-4b53-405c-a5da-b876bd6d70f6.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5896d86-4b53-405c-a5da-b876bd6d70f6.png)'
- en: 'The Add record button is used to add your domain items:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加记录按钮用于添加您的域名项：
- en: '![](img/48964ae1-80fc-4fd0-b062-58fdde867303.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48964ae1-80fc-4fd0-b062-58fdde867303.png)'
- en: Backing up and restoring data
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份和恢复数据
- en: Unfortunately, there is no native AWS feature to consistently back up and restore
    SimpleDB domains. The solution is to make queries that will read all of the data
    (backup) and scripts to insert (restore) this saved data when needed. However,
    the main issue is consistency. If your application is running while you are copying
    the data, there is no guarantee that your backup would be consistent. The application
    may have started a delete operation and your backup may still have some part of
    the items that should have been deleted.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，AWS 没有提供原生的功能来一致性地备份和恢复 SimpleDB 域。解决方案是执行查询以读取所有数据（备份），并在需要时使用脚本插入（恢复）这些保存的数据。然而，主要问题是数据一致性。如果在您复制数据时应用程序正在运行，则无法保证您的备份是一致的。应用程序可能已经开始了一个删除操作，而您的备份可能仍然包含一些应该被删除的项目。
- en: Besides this consistency problem, you still have issues with copying/inserting
    data since AWS places many limits on this operation. For example, the maximum
    number of items in `select` is 2,500 items. To solve this second problem, you
    can try one of the many third-party tools available to mitigate this burden.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个一致性问题之外，您在复制/插入数据时仍然会遇到问题，因为 AWS 对此操作设置了众多限制。例如，`select` 中的最大项数是 2,500 项。为了解决第二个问题，您可以尝试许多第三方工具之一来减轻这个负担。
- en: Controlling user access
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制用户访问
- en: SimpleDB relies on the AWS security model. So if you want to manage access,
    you will need to create IAM users and roles. The granularity of this control lies
    in the domains your users can access and the actions they can execute.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleDB 依赖于 AWS 安全模型。因此，如果您想管理访问权限，您将需要创建 IAM 用户和角色。这种控制的粒度在于用户可以访问的域以及他们可以执行的操作。
- en: 'In our Lambda functions, we *must* give permissions *explicitly*. You can''t
    execute a SimpleDB request without setting the restrictions. This configuration
    is done in the `serverless.yml` file under the `iamRoleStatements` function. In
    the following example, I''m giving read (`sdb:Select`) and write (`sdb:PutAttributes`)
    access to the `Products` and `ShoppingCart` domains. If you want to allow full
    access, use the `"sdb:*"` action and set the domain with `domain/*`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Lambda 函数中，我们必须**明确**地赋予权限。如果不设置限制，您无法执行 SimpleDB 请求。此配置在 `serverless.yml`
    文件下的 `iamRoleStatements` 函数中进行。在以下示例中，我正在为 `Products` 和 `ShoppingCart` 领域赋予读取（`sdb:Select`）和写入（`sdb:PutAttributes`）访问权限。如果您想允许完全访问，请使用
    `"sdb:*"` 动作并将域设置为 `domain/*`：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: DynamoDB
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DynamoDB
- en: DynamoDB is a fully managed, NoSQL database with high availability and that
    can be configured to scale automatically. The only reason that it can't be considered
    as a serverless database is due to its pricing model. You must pay for provisioned
    resources even if no one is using your application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 是一个完全托管、高可用性的 NoSQL 数据库，可以配置为自动扩展。它不能被视为无服务器数据库的唯一原因是其定价模型。即使没有人使用您的应用程序，您也必须为预留资源付费。
- en: However, DynamoDB is a great database, with many useful features, and AWS offers
    a generous permanent free tier. It is being extensively used in many serverless
    projects because it is cheap, easy to use and offers predictable performance.
    In this book, we are going to use DynamoDB as our main database. If you browse
    this chapters' code files, you will see the data layer of the serverless store
    implemented with SimpleDB and DynamoDB, but DynamoDB will be the default and the
    database where we will discuss here what features needs to be implemented for
    the serverless store.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，DynamoDB 是一个优秀的数据库，具有许多有用的功能，AWS 提供了慷慨的永久免费层。它被广泛用于许多无服务器项目中，因为它便宜、易于使用，并提供了可预测的性能。在这本书中，我们将使用
    DynamoDB 作为我们的主要数据库。如果您浏览这一章的代码文件，您将看到无服务器存储的数据层是用 SimpleDB 和 DynamoDB 实现的，但 DynamoDB
    将是默认的，也是我们将讨论需要为无服务器存储实现哪些功能的数据库。
- en: Modeling the database
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计数据库模型
- en: In DynamoDB, a *table* is a collection of *items* and each item is a collection
    of key-value pairs called *attributes*. Like most NoSQL databases, DynamoDB is
    *schemaless*. You just need to define the primary key and you can add items with
    different attributes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DynamoDB 中，一个**表**是一组**项**，每个项是一组称为**属性**的键值对集合。像大多数 NoSQL 数据库一样，DynamoDB
    是**无模式的**。您只需定义主键，就可以添加具有不同属性的项。
- en: 'DynamoDB supports the following data types:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 支持以下数据类型：
- en: '**Scalar**: Category of data types that store a single value:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标量**：存储单个值的**数据类型**类别：'
- en: '`String`: UTF-8 strings with a maximum size of 400 KB.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`：最大大小为 400 KB 的 UTF-8 字符串。'
- en: '`Number`: It stores a maximum of 38 digits and accepts negative numbers as
    well.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`：它最多存储 38 位数字，并接受负数。'
- en: '`Boolean`: It stores true or false.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`布尔型`：它存储真或假。'
- en: '`Binary`: It allows binary data to be saved. Due to maximum size of 400 KB,
    it may not be a good choice for many applications. We are going to use S3 to store
    product images and a `String` field in DynamoDB to save the S3 URL.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`二进制`：它允许保存二进制数据。由于最大大小为400 KB，它可能不是许多应用程序的好选择。我们打算使用S3来存储产品图片，并在DynamoDB中保存一个`String`字段以保存S3
    URL。'
- en: '`Null`: It represents an attribute with an unknown or undefined state.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`空值`：它表示一个具有未知或未定义状态的属性。'
- en: '**Document**: It is a category of data types that store multiple values:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：它是一类存储多个值的数据类型：'
- en: '`List`: It stores an *ordered* collection of values. It''s similar to an array
    where you can store elements of any type. Example: `[5, "foo", 2, -4, "bar"]`.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`列表`：它存储一个*有序*的值集合。它类似于可以存储任何类型元素的数组。例如：`[5, "foo", 2, -4, "bar"]`。'
- en: '`Map`: It stores an *unordered* collection of values. It''s similar to JSON
    object. Example: `{ "Name": "foo", "Address": 123 }`.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`：它存储一个*无序*的值集合。它与JSON对象类似。例如：`{ "Name": "foo", "Address": 123 }`。'
- en: '**Set**: It''s a data type where you store data as an array, but all elements
    must be unique and of the same data type. Also, the order is not preserved. Example:
    a set of numbers could be `[1, 7, 2, -4]`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：它是一个数据类型，您可以将数据作为数组存储，但所有元素必须是唯一且相同的数据类型。此外，顺序不被保留。例如：一组数字可以是`[1, 7,
    2, -4]`。'
- en: 'For the serverless store, we need to create two tables such as `Products` and
    `ShoppingCart`. They will be defined as the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无服务器存储，我们需要创建两个表，例如`Products`和`ShoppingCart`。它们将被定义为以下内容：
- en: '`Products`: Take a look at the following table depicting its attributes:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Products`：查看以下表格，描述其属性：'
- en: '| **Attribute** | **Data Type** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **数据类型** |'
- en: '| `ID` | String |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `ID` | 字符串 |'
- en: '| `Name` | String |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `Name` | 字符串 |'
- en: '| `Price` | Number |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `Price` | 数字 |'
- en: '| `Image` | String |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `Image` | 字符串 |'
- en: '| `Comments` | List of Maps |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `Comments` | 地图对象列表 |'
- en: '`Comments`: Take a look at the following table depicting its attributes:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Comments`：查看以下表格，描述其属性：'
- en: '| **Attribute** | **Data Type** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **数据类型** |'
- en: '| `ID` | `String` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `ID` | 字符串 |'
- en: '| `Username` | `String` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `Username` | 字符串 |'
- en: '| `Date` | `String` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `Date` | 字符串 |'
- en: '| `Text` | `String` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `Text` | 字符串 |'
- en: '`ShoppingCart`: Take a look at the following table depicting its attributes:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShoppingCart`：查看以下表格，描述其属性：'
- en: '| **Attribute** | **Data Type** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **数据类型** |'
- en: '| `UserID` | String |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `UserID` | 字符串 |'
- en: '| `LastUpdate` | String |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `LastUpdate` | 字符串 |'
- en: '| `SelectedProducts` | List of Maps |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `SelectedProducts` | 地图对象列表 |'
- en: '`SelectedProducts`: Take a look at the following table depicting its attributes:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectedProducts`：查看以下表格，描述其属性：'
- en: '| **Attribute** | **Data Type** |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **数据类型** |'
- en: '| `ProductID` | `String` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `ProductID` | 字符串 |'
- en: '| `Quantity` | `Number` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `Quantity` | 数字 |'
- en: 'Some observations about this model are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此模型的一些观察如下：
- en: The `Comments` and `SelectedProducts` attributes were defined as a list of map
    objects, which means that we will save an ordered list of JSON objects
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Comments`和`SelectedProducts`属性被定义为地图对象列表，这意味着我们将保存一个有序的JSON对象列表'
- en: Just like SimpleDB, there is no auto-increment field for DynamoDB, so we will
    use UUIDs for the Comment IDs
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像SimpleDB一样，DynamoDB没有自增字段，所以我们将使用UUIDs作为评论ID
- en: DynamoDB doesn't support a datetime data type, so we will need to define the
    `Date` and `LastUpdate` attributes as a string that uses the ISO format
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DynamoDB不支持datetime数据类型，因此我们需要将`Date`和`LastUpdate`属性定义为使用ISO格式的字符串
- en: Creating a table
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表
- en: We are going to create the tables for the serverless store using the AWS SDK.
    As DynamoDB is a schemaless database, we just need to set the primary key and
    the attributes will be defined when the items are inserted.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用AWS SDK创建无服务器存储的表。由于DynamoDB是一个无模式数据库，我们只需要设置主键，属性将在插入项目时定义。
- en: 'Use the following example to create them:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下示例来创建它们：
- en: '[PRE7]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can use the same code to create the `ShoppingCart` table. Just change the
    table name to `ShoppingCart` and the primary key name to `UserID`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的代码创建`ShoppingCart`表。只需将表名更改为`ShoppingCart`，并将主键名称更改为`UserID`。
- en: Limits
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制
- en: 'DynamoDB imposes some limits that you need to consider before building your
    application. They are listed as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB在构建应用程序之前强加了一些需要考虑的限制。它们如下列出：
- en: '| **Parameter** | **Restriction** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **限制** |'
- en: '| Number of tables | 256 per account |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 表的数量 | 每个账户256个 |'
- en: '| Table size | There is no limit in the number of items |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 表大小 | 项的数量没有限制 |'
- en: '| Provisioned throughput | Up to 40,000 read and 40,000 write capacity units
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 配置吞吐量 | 最多40,000个读和40,000个写容量单位 |'
- en: '| Item size | The sum of the size of all attributes of one item must not exceed
    400 KB |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 项目大小 | 一个项目的所有属性的大小之和不得超过400 KB |'
- en: '| Secondary indexes | 5 local and 5 global secondary indexes per table |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 二级索引 | 每个表5个本地和5个全局二级索引 |'
- en: '| `API BatchGetItem()` | Maximum of 100 items or 16 MB retrieved |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `API BatchGetItem()` | 最大100个项目或16 MB检索 |'
- en: '| `API BatchWriteItem()` | Maximum of 25 put or delete requests or 16 MB sent
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `API BatchWriteItem()` | 最大25个插入或删除请求或16 MB发送 |'
- en: '| API Query or Scan | The result set is limited to 1 MB |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| API Query或Scan | 结果集限制为1 MB |'
- en: Inserting and querying data
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入和查询数据
- en: We are going to this discuss in this section how to insert and query data with
    DynamoDB.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中讨论如何使用DynamoDB插入和查询数据。
- en: Inserting data
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入数据
- en: DynamoDB offers two ways to insert data such as `putItem()` and `batchWriteItem()`.
    The difference between them is that `putItem` allows you to create one new item
    or update an existing item, while `batchWriteItem` allows you to create or delete
    multiples items, but doesn't support the update operation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB提供了两种插入数据的方式，例如`putItem()`和`batchWriteItem()`。它们之间的区别在于，`putItem`允许你创建一个新项目或更新现有项目，而`batchWriteItem`允许你创建或删除多个项目，但不支持更新操作。
- en: 'The following is an example of the `putItem` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`putItem`方法的示例：
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Document Client API
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档客户端API
- en: As you can see, the previous example shows how to insert a single item, but
    the syntax is very complicated. To define a string attribute, we need to create
    a JSON object where the key is `"S"` (string) and the value is the desired data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，前面的示例展示了如何插入单个项目，但语法非常复杂。要定义一个字符串属性，我们需要创建一个JSON对象，其中键是`"S"`（字符串），值是所需的数据。
- en: To make this task easier, we can use the Dynamo's Document Client API to abstract
    the attribute values by using native JavaScript types for read and write operations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这项任务更容易，我们可以使用Dynamo的文档客户端API通过使用原生JavaScript类型来抽象属性值，以进行读写操作。
- en: 'The following example shows how to insert the same item using this API. Note
    that we need to retrieve the client using `new AWS.DynamoDB.DocumentClient()`
    and the command is `put` instead of `putItem`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用此API插入相同的项目。请注意，我们需要使用`new AWS.DynamoDB.DocumentClient()`检索客户端，命令是`put`而不是`putItem`：
- en: '[PRE9]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Querying data
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询数据
- en: To query the item that we have just inserted, DynamoDB offers two methods such
    as `scan()` and `query()`. We will see how they work in the next sections. For
    both of them, we are going to use the Document Client.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询我们刚刚插入的项目，DynamoDB提供了两种方法，例如`scan()`和`query()`。我们将在下一节中看到它们是如何工作的。对于这两种方法，我们将使用文档客户端。
- en: The scan method
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描方法
- en: 'The `scan` method is used to retrieve all items of a table without needing
    to filter by a key. Filtering is possible, but is optional. The problem with this
    method is that, for a large table, you need to make multiple requests because
    it will interrupt the operation when it scans more than 1 MB of data. When the
    scan operation is interrupted, the result set will contain a `LastEvaluatedKey`
    parameter that can be used for further requests:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan`方法用于检索表中所有项目，无需按键进行筛选。筛选是可能的，但不是必须的。这种方法的问题在于，对于大型表，你需要进行多次请求，因为当扫描超过1
    MB的数据时，它将中断操作。当扫描操作中断时，结果集将包含一个`LastEvaluatedKey`参数，可用于进一步的请求：'
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The query method
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询方法
- en: The `query` method finds items based on the hash key. It is similar to the `scan`
    method since a query will be interrupted if it reads more than 1 MB of data, returning
    a `LastEvaluatedKey` parameter, but the main difference between `query` and `scan`
    is that `query` will consider the filter conditions before reading the data and
    `scan` will apply the filters after the table is read.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`query`方法基于哈希键查找项目。它与`scan`方法类似，因为如果读取超过1 MB的数据，查询将被中断，返回一个`LastEvaluatedKey`参数，但`query`和`scan`之间的主要区别在于，`query`在读取数据之前会考虑筛选条件，而`scan`会在读取表之后应用筛选。'
- en: 'The following is an example to query only the `Lonely Bird` product:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个仅查询`Lonely Bird`产品的示例：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Performance and concurrency
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和并发
- en: Like most NoSQL databases, there is no support for transactions in DynamoDB.
    Atomic operations can only be done on the item level, which means that you can
    atomically change two attributes of a single item, but you can't update two distinct
    items in a single operation. Like SimpleDB, DynamoDB supports conditional updates
    to implement counters.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 NoSQL 数据库一样，DynamoDB 不支持事务。原子操作只能在项目级别进行，这意味着你可以原子性地更改单个项目的两个属性，但你不能在单个操作中更新两个不同的项目。像
    SimpleDB 一样，DynamoDB 支持条件更新以实现计数器。
- en: Regarding performance, DynamoDB creates indexes for the hash key and one optional
    range key, but if you need to query data filtering by other fields, you need to
    create additional indexes. For example, if you want to find all products that
    cost more than US$ 10, you need to create an index for the `Price` attribute.
    That's something that we don't need in our serverless store model, since we will
    query only by the hash keys for both tables, but we will describe here how to
    add extra indexes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 关于性能，DynamoDB 为哈希键和可选的范围键创建索引，但如果你需要通过其他字段进行查询过滤，你需要创建额外的索引。例如，如果你想找到所有价格超过10美元的产品，你需要为
    `价格` 属性创建一个索引。在我们的无服务器存储模型中，我们不需要这样做，因为我们只会通过两个表的哈希键进行查询，但我们将描述如何添加额外的索引。
- en: 'First, you need to understand that DynamoDB has the following two types of
    index:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要了解 DynamoDB 有以下两种索引类型：
- en: '**Local secondary index**: An index that has the same partition key as the
    base table'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地二级索引**：与基础表具有相同分区键的索引'
- en: '**Global secondary index**: An index that is not restricted to the same partition
    of the base table'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局二级索引**：一个不限于基础表相同分区的索引'
- en: One difference between them is that local indexes uses the same provisioned
    throughput of the hash key and global indexes requires that you pay for an extra
    provisioned throughput for them. The benefit of global indexes is that you don't
    need to include a filter by the hash key, and you can filter directly by the key
    that you have specified. In the previous example, if you want to query all products
    with a price above US$ 10, you need to create a global index for the `Price` attribute.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的一个区别是，本地索引使用与哈希键相同的预配吞吐量，而全局索引则需要你为它们支付额外的预配吞吐量。全局索引的好处是，你不需要包含哈希键的过滤器，可以直接通过你指定的键进行过滤。在之前的例子中，如果你想查询所有价格高于10美元的产品，你需要为
    `价格` 属性创建一个全局索引。
- en: 'Now suppose that you have a table for `Orders` that saves the `OrderID`, `ProductID`,
    `Price`, and other information. The `OrderID` would be the hash key and, for a
    single order, we would have many items. For example, take a look at the following
    table:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你有一个名为 `Orders` 的表，该表保存了 `订单ID`、`产品ID`、`价格` 以及其他信息。`订单ID` 将作为哈希键，对于单个订单，我们会有许多条目。例如，看一下以下表格：
- en: '| **OrderID** | **ProductID** | **Price** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **订单ID** | **产品ID** | **价格** |'
- en: '| `1` | `77` | `15.99` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `77` | `15.99` |'
- en: '| `1` | `88` | `18.99` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `88` | `18.99` |'
- en: '| `1` | `23` | `12.99` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `23` | `12.99` |'
- en: '| `2` | `18` | `15.00` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `18` | `15.00` |'
- en: In this model, if you want to query by the `OrderID` with number `1` and filter
    by `Price` greater than 15, you would create a *local* secondary index for the
    `Price` attribute and not a *global* index.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模型中，如果你想通过 `订单ID` 号码 `1` 进行查询并按 `价格` 大于15进行过滤，你会为 `价格` 属性创建一个 *本地* 二级索引，而不是
    *全局* 索引。
- en: 'The following example shows the syntax to create local and global indexes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了创建本地和全局索引的语法：
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can use `DynamoDB.updateTable()` to add *global secondary indexes* after
    a table is created, but you can only add *local secondary indexes* during the
    creation of a table. It is not possible to update a table to add local indexes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `DynamoDB.updateTable()` 在创建表后添加 *全局二级索引*，但你只能在创建表时添加 *本地二级索引*。无法通过更新表来添加本地索引。
- en: Managing the database
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数据库
- en: 'AWS has a management console for DynamoDB where you can configure the capacity
    of your tables, create indexes, and view CloudWatch metrics. In the following
    steps, I will show how you can see and manipulate your table''s data:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 为 DynamoDB 提供了一个管理控制台，你可以在此配置表的容量、创建索引和查看 CloudWatch 指标。在以下步骤中，我将展示如何查看和操作你的表数据：
- en: Browse the Management Console at this link [https://console.aws.amazon.com/dynamodb.](https://console.aws.amazon.com/dynamodb)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此链接浏览管理控制台 [https://console.aws.amazon.com/dynamodb.](https://console.aws.amazon.com/dynamodb)
- en: 'In the left menu, click on Tables:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，点击“表”：
- en: '![](img/30e54ee9-aef7-421c-a927-6b924c224750.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30e54ee9-aef7-421c-a927-6b924c224750.png)'
- en: 'Now click on your table Name and in the Items tab. In this tab, you can create,
    delete, or update items. A scan query will be executed automatically, but you
    can change the query parameters if you want to see other items. Click on the item
    ID to open the edit modal:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击您的表名称，然后在“项目”选项卡中。在此选项卡中，您可以创建、删除或更新项目。将自动执行扫描查询，但您可以根据需要更改查询参数以查看其他项目。点击项目
    ID 以打开编辑模式：
- en: '![](img/428ee72d-dc8c-4168-a6a7-86d078aba4c6.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/428ee72d-dc8c-4168-a6a7-86d078aba4c6.png)'
- en: 'The Edit item modal allows you to see all properties of an item and update
    the attributes if required:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑项目模式允许您查看项目的所有属性，并在需要时更新属性：
- en: '![](img/0efb45d7-7fc1-44e5-8a3d-4a2d4f78b6a4.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0efb45d7-7fc1-44e5-8a3d-4a2d4f78b6a4.png)'
- en: Provisioned throughput
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置吞吐量
- en: DynamoDB performance is based on provisioned throughput for read and write operations.
    One *read capacity unit* represents one strongly consistent read per second or
    two eventually consistent reads per second for objects with up to 4 KB in size,
    while one *write capacity unit* means that you can write one 1 KB object per second.
    You need to define those values when you create your table, but you can update
    them if you want later. In this chapter's example, the table was created with
    five read units and five write units for each key.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 的性能基于读和写操作的配置吞吐量。一个 *读容量单元* 代表每秒一个强一致性读取或对于大小最多为 4 KB 的对象每秒两个最终一致性读取，而一个
    *写容量单元* 意味着您每秒可以写入一个 1 KB 的对象。您在创建表时需要定义这些值，但您可以在以后更新它们。在本章的示例中，表为每个键创建了五个读单元和五个写单元。
- en: If your system requests more read/write operations than expected by your provisioned
    capacity, AWS will allow the operations to be executed without errors for a short
    period of time. If you continue to exceed the provisioned capacity, some requests
    will fail with the `ProvisionedThroughputExceededException` error. The good news
    is that the AWS SDK has built-in support for retrying throttled requests, so we
    don't need to write the logic for this.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统请求的读/写操作数超过了配置的容量，AWS 将允许在短时间内无错误地执行这些操作。如果您继续超出配置容量，一些请求将因 `ProvisionedThroughputExceededException`
    错误而失败。好消息是，AWS SDK 内置了对延迟请求的重试支持，因此我们不需要编写此逻辑。
- en: Auto scaling
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动扩展
- en: You can configure CloudWatch to send e-mail alerts when your DynamoDB usage
    is higher than your provisioned throughput and manually update the capacity when
    necessary *or* you can configure auto scaling. As we want to avoid worrying about
    servers and scalability, we will configure auto scaling to handle this burden
    for us.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置 CloudWatch 在您的 DynamoDB 使用量高于配置吞吐量时发送电子邮件警报，并在必要时手动更新容量，或者您还可以配置自动扩展。由于我们想要避免担心服务器和可伸缩性，我们将配置自动扩展来为我们处理这个负担。
- en: Auto scaling will actively manage the throughput capacity to scale up and down
    to match your application utilization when your workload increases or decreases.
    What we need to configure is a range (upper and lower limits) for read and write
    capacity units and a target utilization percentage within this range. You can
    access the auto scaling configuration through the Management Console. Click in
    the table where you want to enable this setting and select the Capacity tab.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展将主动管理吞吐量容量，以在您的负载增加或减少时自动扩展和缩减，以匹配您的应用程序利用率。我们需要配置的是读和写容量单元的范围（上限和下限）以及此范围内的目标利用率百分比。您可以通过管理控制台访问自动扩展配置。在您想要启用此设置的表中单击，然后选择“容量”选项卡。
- en: 'The following screenshot shows an example of auto scaling configuration:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了自动扩展配置的示例：
- en: '![](img/7542bd2b-e390-47ba-9539-e96290b0a088.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7542bd2b-e390-47ba-9539-e96290b0a088.png)'
- en: Backing up and restoring data
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份和恢复数据
- en: 'Unfortunately, DynamoDB doesn''t provide a simple feature for backup and restore.
    What AWS proposes is to use other two services for this task such as **AWS Data
    Pipeline** and **Amazon Elastic MapReduce** (**EMR**). Due to the complexity and
    length of this configuration, it won''t be covered in this book. You can follow
    the AWS tutorial to implement a task for this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，DynamoDB 不提供简单的备份和恢复功能。AWS 提出的方案是使用其他两个服务来完成这项任务，例如 **AWS 数据管道** 和 **Amazon
    Elastic MapReduce**（**EMR**）。由于此配置的复杂性和长度，本书不会涉及。您可以遵循 AWS 教程来实现此任务：
- en: '[http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-importexport-ddb.html](http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-importexport-ddb.html)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[AWS 数据管道文档](http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-importexport-ddb.html)'
- en: In short, what you need is to use a AWS Data Pipeline template for DynamoDB
    and schedule a task that will start an EMR with Hive to save/restore a DynamoDB
    table.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你需要使用 AWS Data Pipeline 模板为 DynamoDB 创建任务，并安排一个任务来启动 EMR，使用 Hive 保存/恢复
    DynamoDB 表。
- en: Controlling user access
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制用户访问
- en: 'Just like SimpleDB, we manage DynamoDB user access through IAM roles. We must
    give permissions *explicitly* to the Lambda functions to be able to execute the
    requests. This configuration is done in the `serverless.yml` file under the `iamRoleStatements`
    function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 SimpleDB 一样，我们通过 IAM 角色来管理 DynamoDB 用户访问。我们必须明确地给 Lambda 函数赋予权限，以便它们能够执行请求。这种配置是在
    `serverless.yml` 文件下的 `iamRoleStatements` 函数中完成的：
- en: '[PRE13]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Improving the serverless store
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化无服务器存储
- en: In this book's GitHub repository, you will find a `scripts` folder that you
    can use to create the tables for DynamoDB and SimpleDB, along with sample data
    to be used in our tests. Also, in the root directory, you will find a `backend`
    folder that contains a `repositories` folder with the `dynamodb.js`, `simpledb.js`,
    and `fakedb.js` files. The sample application uses `fakedb` as the default database,
    because it doesn't require any configuration since it provides only hardcoded
    data.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的 GitHub 仓库中，你可以找到一个 `scripts` 文件夹，你可以使用它来创建 DynamoDB 和 SimpleDB 的表，以及用于我们测试的示例数据。此外，在根目录中，你可以找到一个
    `backend` 文件夹，其中包含一个 `repositories` 文件夹，包含 `dynamodb.js`、`simpledb.js` 和 `fakedb.js`
    文件。示例应用程序使用 `fakedb` 作为默认数据库，因为它不需要任何配置，因为它只提供硬编码的数据。
- en: We are going to implement the DynamoDB code now. In the `lib` folder, we are
    going to change the dependencies from `const db = require('../repositories/fakedb')`
    to `const db = require('../repositories/dynamodb')` and in the `dynamodb.js` file,
    we need to develop four methods such as `retrieveAllProducts`, `retrieveCart`,
    `saveCart`, and `processCheckout`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现 DynamoDB 代码。在 `lib` 文件夹中，我们将把依赖项从 `const db = require('../repositories/fakedb')`
    更改为 `const db = require('../repositories/dynamodb')`，并在 `dynamodb.js` 文件中，我们需要开发四个方法，如
    `retrieveAllProducts`、`retrieveCart`、`saveCart` 和 `processCheckout`。
- en: Retrieving all products
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有产品
- en: 'Retrieving all products is a simple function that will execute a `scan` operation.
    As we have just a few items, we don''t need to worry about the 1 MB limit in this
    case:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所有产品是一个简单的函数，它将执行 `scan` 操作。由于我们只有少量项目，我们不需要担心这种情况下的 1 MB 限制：
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Retrieving the user's shopping cart
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户的购物车
- en: 'Retrieving the user''s cart uses a simple query where we will filter by `UserID`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户的购物车使用一个简单的查询，我们将通过 `UserID` 进行过滤：
- en: '[PRE15]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Saving the user's shopping cart
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存用户的购物车
- en: 'The `saveCart` function receives the `userId` and `selectedProducts` as arguments,
    where the `selectedProducts` is a pair of `ProductId-Quantity` elements:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveCart` 函数接收 `userId` 和 `selectedProducts` 作为参数，其中 `selectedProducts` 是
    `ProductId-Quantity` 元素的配对：'
- en: '[PRE16]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Processing the checkout
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理结账
- en: 'Handling payment data is a complex process and is out of scope for this book.
    In this case, we are going to implement a function that will just execute the
    callback passing `null` as the error parameter:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 处理支付数据是一个复杂的过程，超出了本书的范围。在这种情况下，我们将实现一个函数，该函数将仅执行回调，并将 `null` 作为错误参数传递：
- en: '[PRE17]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Amazon S3 (for media files)
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon S3（用于媒体文件）
- en: S3 is not a database, it is only a storage system. It lacks a database engine
    and many storage features, but it can be pretty useful for saving media files
    such as photos, videos, and music.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: S3 不是一个数据库，它只是一个存储系统。它缺少数据库引擎和许多存储功能，但可以用于保存媒体文件，如照片、视频和音乐。
- en: This approach is already very popular. For example, if you develop an application
    that uses a MongoDB database, you could use MongoDB GridFS to store large binary
    data. However, the most efficient solution is to offload this kind of data to
    cloud services because the machines responsible for your database are usually
    the most expensive ones. It means that the cost per gigabyte in a database is
    usually higher than a cloud storage service, such as S3.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法已经非常流行。例如，如果你开发了一个使用 MongoDB 数据库的应用程序，你可以使用 MongoDB GridFS 来存储大型二进制数据。然而，最有效的解决方案是将这类数据卸载到云服务中，因为负责你的数据库的机器通常是成本最高的。这意味着数据库中每千兆字节的成本通常高于云存储服务，如
    S3。
- en: 'In our serverless store, we are storing the product images in SimpleDB/DynamoDB
    as string fields. Instead of saving the full binary data, we save just the URL
    of the image file. Example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的无服务器存储中，我们将产品图片存储在 SimpleDB/DynamoDB 中的字符串字段中。我们不是保存完整的二进制数据，而是只保存图像文件的
    URL。例如：
- en: '[https://s3.amazonaws.com/serverless-store-media/product-images/lonely-bird.jpg](https://s3.amazonaws.com/serverless-store-media/product-images/lonely-bird.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://s3.amazonaws.com/serverless-store-media/product-images/lonely-bird.jpg](https://s3.amazonaws.com/serverless-store-media/product-images/lonely-bird.jpg)'
- en: 'When we receive this information in the frontend, the `<img>` element has the
    `src` attribute referencing this S3 URL:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在前端收到这些信息时，`<img>` 元素具有 `src` 属性，引用这个 S3 URL：
- en: '[PRE18]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Instead of downloading the image from the database, the user will download the
    image from S3, thus relieving the database.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将直接从 S3 下载图片，而不是从数据库中下载，从而减轻数据库的负担。
- en: 'This is one use case for S3\. There are two other common usages:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 S3 的一种用法。还有两种其他常见用法：
- en: '**The user needs to upload his avatar image**: Instead of saving in the database,
    we can generate a temporary permission for the user to upload the file directly
    to S3'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户需要上传他的头像图片**：而不是保存在数据库中，我们可以为用户生成一个临时权限，直接将文件上传到 S3'
- en: '**The user wants to see his private album**: Instead of requesting a Lambda
    function to download the files from S3, we can generate private temporary links
    from where he will be able to download the files'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户想要查看他的私有相册**：而不是请求 Lambda 函数从 S3 下载文件，我们可以生成私有临时链接，用户可以从那里下载文件'
- en: We will discuss in this section how to handle these examples and how to use
    S3 as a database for media files.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何处理这些示例以及如何将 S3 作为媒体文件的数据库使用。
- en: Uploading and downloading files
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传和下载文件
- en: If your bucket stores public files, you can configure it to allow anonymous
    requests to upload and download files. However, if the files are private, you
    need to give pre-signed URLs to the client to ensure privacy and security. Both
    the actions, namely upload and download, must be signed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的存储桶存储的是公共文件，您可以配置它以允许匿名请求上传和下载文件。但是，如果文件是私有的，您需要向客户端提供预签名 URL 以确保隐私和安全。上传和下载这两个操作都必须进行签名。
- en: 'These keys are generated at the backend because you need to use the SDK with
    credential access to the bucket. Let''s take a look at the following steps to
    upload and download files:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些密钥是在后端生成的，因为您需要使用具有对存储桶凭证访问权限的 SDK。让我们看看以下上传和下载文件的步骤：
- en: 'Create a Lambda function and expose an endpoint to allow it to be called by
    the frontend code. Use the `getSignedUrl` function of the S3 object to obtain
    the signed URL:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Lambda 函数并公开一个端点，以便前端代码可以调用它。使用 S3 对象的 `getSignedUrl` 函数获取签名 URL：
- en: '[PRE19]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the operation is to download a private file, render the HTML with an anchor
    tag that uses this pre-signed URL in the `href` attribute and set the attribute
    `target` to `_blank` in order to carry out the download:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果操作是下载私有文件，则使用具有此预签名 URL 的锚点标签渲染 HTML，并将 `target` 属性设置为 `_blank` 以执行下载：
- en: '[PRE20]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the operation is to upload a file, add an `input` element to receive the
    file:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果操作是上传文件，则添加一个 `input` 元素以接收文件：
- en: '[PRE21]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And upload the file with an Ajax request using the pre-signed URL:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并使用预签名 URL 通过 Ajax 请求上传文件：
- en: '[PRE22]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you have generated the pre-signed URL using a Lambda function, you will know
    the filename and where the file will be stored, however, you won't know exactly
    when the file upload will finish if it is really started by the user. One option
    that you have is to add another Lambda function to receive the object created
    event, which will be triggered by the S3 bucket.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于您已使用 Lambda 函数生成了预签名 URL，因此您将知道文件名和文件存储的位置，但如果用户真正启动了文件上传，您将无法确切知道文件上传何时完成。您有一个选项，就是添加另一个
    Lambda 函数来接收由 S3 存储桶触发的对象创建事件。
- en: Enabling CORS
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 CORS
- en: 'The previous code will only work if we enable CORS for the S3 bucket. CORS
    headers are necessary because we are going to make upload and download requests
    from a domain that is different from the S3 domain. This setting can be configured
    using the S3 Console: [https://console.aws.amazon.com/s3](https://console.aws.amazon.com/s3).
    Open your bucket properties and select Permissions, followed by CORS Configuration,
    as shown in the following screenshot:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码只有在为 S3 存储桶启用 CORS 后才能正常工作。CORS 头是必要的，因为我们将从与 S3 域不同的域进行上传和下载请求。此设置可以使用
    S3 控制台进行配置：[https://console.aws.amazon.com/s3](https://console.aws.amazon.com/s3)。打开您的存储桶属性，选择权限，然后选择
    CORS 配置，如下面的截图所示：
- en: '![](img/f26675ef-04cd-40e2-a7ad-49c7c50e4e52.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f26675ef-04cd-40e2-a7ad-49c7c50e4e52.png)'
- en: 'This command will add a CORS configuration for GET requests. Before saving,
    we need to add one line to include authorization for POST requests and change
    the Allowed Header to * (all):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为GET请求添加CORS配置。在保存之前，我们需要添加一行以包括对POST请求的授权，并将允许的头部改为*（所有）：
- en: '[PRE23]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Backing up and restoring data
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份和恢复数据
- en: Amazon S3 was designed to provide up to 99.999999999% of durability, which means
    that AWS makes a huge effort to replicate your data and keep it safe from disk
    failures. Although you can rest assured that your data is safe on S3, you must
    consider that it is not so safe against your own mistakes. For example, if you
    have a feature that deletes specific files from S3, you can make a mistake and
    delete a wrong file or, even worse, delete all of them. So, making backups is
    important to ensure a safer operation for your business.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊S3旨在提供高达99.999999999%的持久性，这意味着AWS会做出巨大努力来复制您的数据并使其免受磁盘故障的影响。尽管您可以在S3上放心，但您必须考虑它对您自己的错误并不那么安全。例如，如果您有一个从S3删除特定文件的功能，您可能会犯错误并删除错误的文件，或者更糟糕的是，删除所有文件。因此，进行备份对于确保业务更安全的操作非常重要。
- en: 'You can back up files locally (downloading) or make copies in other external
    services (such as Azure or Google Cloud), but it is usually not necessary. You
    can save all files of a bucket in another bucket using a command of the AWS CLI:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将文件本地备份（下载）或在其他外部服务（如Azure或Google Cloud）中创建副本，但这通常不是必要的。您可以使用AWS CLI的命令将存储桶中的所有文件保存到另一个存储桶：
- en: '[PRE24]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you want to restore all files that were saved at specific time to the backup
    bucket, you would need to add a `--delete` option to remove files in the target
    bucket that do not exist in the backup bucket:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将特定时间保存的所有文件恢复到备份存储桶，您需要添加`--delete`选项以删除目标存储桶中不存在于备份存储桶中的文件：
- en: '[PRE25]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using S3 versioning
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用S3版本控制
- en: S3 versioning is another way to protect your data. Once enabled, every time
    you modify an object, a new one will be saved, and when you delete an object,
    S3 will just place a delete mark on it. Versioning allows you to recover files
    that were accidentally deleted, but you will pay more to keep those files available.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: S3版本控制是保护数据的另一种方式。一旦启用，每次修改对象时，都会保存一个新的对象，当删除对象时，S3只需在它上面放置一个删除标记。版本控制允许您恢复意外删除的文件，但您需要支付更多费用以保持这些文件可用。
- en: 'To configure S3 versioning, go to the Management Console and select the bucket
    Properties. You will see an option to enable versioning:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置S3版本控制，请转到管理控制台并选择存储桶属性。您将看到一个启用版本控制的选项：
- en: '![](img/8adc7511-86cd-4aaf-aaa2-670c32822493.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8adc7511-86cd-4aaf-aaa2-670c32822493.png)'
- en: 'You can reduce costs by configuring life cycle rules to delete old versioned
    files. This setting can be found under the Management tab:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过配置生命周期规则来删除旧版本文件来降低成本。此设置可以在管理标签页下找到：
- en: '![](img/44059071-563b-4c41-8bc5-53c959992829.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44059071-563b-4c41-8bc5-53c959992829.png)'
- en: 'To finish this section, an observation about security: if your AWS access keys
    get compromised, a malicious user could delete the files in the S3 bucket and
    also remove versioned files. To prevent this, you can add an extra layer of protection
    by enabling MFA Delete. With this setting, you can only permanently delete a file
    if you have access to the AWS account *and* if you are able to provide an access
    code from an authentication device.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本节，关于安全性的一个观察：如果您的AWS访问密钥遭到泄露，恶意用户可能会删除S3存储桶中的文件，并删除已版本化的文件。为了防止这种情况，您可以通过启用MFA删除来添加额外的保护层。使用此设置，只有当您有权访问AWS账户并且能够从认证设备提供访问代码时，才能永久删除文件。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to model, query, and insert data using serverless
    databases. We saw how SimpleDB works, but due to its lack of features, we also
    covered how to use DynamoDB. Plus, you learned more about Amazon S3 and how to
    use it to store media files.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用无服务器数据库建模、查询和插入数据。我们看到了SimpleDB是如何工作的，但由于其功能不足，我们还介绍了如何使用DynamoDB。此外，您还了解了更多关于Amazon
    S3及其如何用于存储媒体文件的信息。
- en: In the next chapter, we are going to learn how to use authentication and authorization
    on AWS and also check out standard security practices to build a serverless project.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在AWS上使用身份验证和授权，并检查构建无服务器项目的标准安全实践。
