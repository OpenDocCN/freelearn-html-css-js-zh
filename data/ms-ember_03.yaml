- en: Chapter 3. Routing and State Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 路由和状态管理
- en: 'In this chapter, we will learn URL-based state management in Ember.js, which
    constitutes **routing**. Routing enables us to translate different states in our
    applications into URLs and vice-versa. It is a key concept in Ember.js that enables
    developers to easily separate application logic. It also enables users to link
    back to content in the application via the usual HTTP URLs. That being said, by
    the end of this chapter, we should be able to accomplish the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习基于URL的状态管理在 Ember.js 中的应用，这构成了**路由**。路由使我们能够将应用程序中的不同状态转换为URL，反之亦然。这是
    Ember.js 中的一个关键概念，使开发者能够轻松地分离应用程序逻辑。它还使用户能够通过通常的HTTP URL链接回应用程序中的内容。话虽如此，到本章结束时，我们应该能够完成以下任务：
- en: Create a router
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个路由器
- en: Define resources and routes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义资源和路由
- en: Define a route's model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义路由的模型
- en: Perform a redirect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行重定向
- en: Accomplish asynchronous routing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现异步路由
- en: Creating the application's router
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序的路由器
- en: We all know that in traditional web development, every request is linked by
    a URL that enables the server make a decision on the incoming request. Typical
    actions include sending back a resource file or JSON payload, redirecting the
    request to a different resource, or sending back an error response such as in
    the case of unauthorized access.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，在传统的Web开发中，每个请求都通过一个URL与服务器相连，这使得服务器能够对传入的请求做出决策。典型的操作包括发送资源文件或JSON有效负载、将请求重定向到不同的资源，或者在未经授权访问的情况下发送错误响应。
- en: 'Ember.js strives to preserve these ideas in the browser environment by enabling
    association between these URLs and state of the application. The main component
    that manages these states is the application router. As mentioned in the introductory
    section, it is responsible for restoring an application to a state matching the
    given URL. It also enables the user to navigate between the application''s history
    as expected. The router is automatically created on application initialization
    and can be referenced as `MyApplicationNamespace.Router`. Before we proceed, we
    will be using the bundled chapter sample to better understand this extremely convenient
    component. The sample is a simple implementation of the Contacts OS X application
    as shown in the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 通过在浏览器环境中实现这些URL与应用程序状态的关联，力求保留这些理念。管理这些状态的主要组件是应用程序路由器。正如引言部分所述，它负责将应用程序恢复到与给定URL匹配的状态。它还允许用户按预期在应用程序的历史记录中导航。路由器在应用程序初始化时自动创建，可以引用为
    `MyApplicationNamespace.Router`。在我们继续之前，我们将使用捆绑的章节示例来更好地理解这个极其方便的组件。该示例是Contacts
    OS X应用程序的简单实现，如下面的截图所示：
- en: '![Creating the application''s router](img/00004.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![创建应用程序的路由器](img/00004.jpeg)'
- en: It enables users to add new contacts as well as edit and delete existing ones.
    For simplicity, we won't support avatars, but that could be an implementation
    exercise for the reader at the end of the chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用户能够添加新的联系人，以及编辑和删除现有的联系人。为了简单起见，我们不会支持头像，但这可以是读者在章节末尾的一个实现练习。
- en: 'We already mentioned some of the states in which this application can transition
    into. These states have to be registered in the same way server-side frameworks
    have URL dispatchers that backend programmers use to map URL patters to views.
    The chapter sample already illustrates how these possible states are defined:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了一些应用程序可以转换到的状态。这些状态必须以与服务器端框架相同的方式进行注册，这些框架有URL分发器，后端程序员使用它将URL模式映射到视图。章节示例已经说明了如何定义这些可能的状态：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that the already instantiated router was referenced as `App.Router`.
    Calling its `map` method gives the application an opportunity to register its
    possible states. In addition, two other methods are used to classify these states
    into *routes* and *resources*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，已经实例化的路由器被引用为 `App.Router`。调用其 `map` 方法给应用程序一个机会来注册其可能的状态。此外，还使用了两种其他方法来将这些状态分类为*路由*和*资源*。
- en: Mapping URLs to routes
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将URL映射到路由
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first argument specifies the name of the resource and coincidentally, the
    path to match the request URL. The next argument is optional and holds configurations
    that we may need to specify, as we shall see later. The last one is a function
    that is used to define the routes of that particular resource. For example, the
    first defined resource in the samples says, let the `contacts` resource handle
    any requests whose URL starts with `/contacts`. It also specifies one route, `new`,
    that is used to handle the creation of new contacts. Routes on the other hand,
    accept the same arguments for the function argument.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数指定了资源的名称，巧合的是，这也是匹配请求URL的路径。下一个参数是可选的，它包含我们可能需要指定的配置，我们将在稍后看到。最后一个是一个函数，用于定义特定资源的路由。例如，在示例中第一个定义的资源表示，让`contacts`资源处理以`/contacts`开头的任何请求。它还指定了一个`new`路由，用于处理新联系人的创建。另一方面，路由接受函数参数的相同参数。
- en: 'You must be asking yourself, "So how are routes different from resources?"
    The two are essentially the same, other than the former offers a way to categorize
    states (routes) that perform actions on a specific entity. We can think of an
    Ember.js application as a tree, composed of a trunk (the router), branches (resources),
    and leaves (routes). For example, the `contact` state (a resource) caters for
    a specific contact. This resource can be displayed in two modes: read and write;
    hence, the `index` and `edit` routes respectively, as shown:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想，“那么路由和资源有什么不同？”这两者本质上是一样的，只是前者提供了一种对在特定实体上执行操作的状态（路由）进行分类的方法。我们可以将 Ember.js
    应用程序想象成一棵树，由树干（路由器）、树枝（资源）和叶子（路由）组成。例如，`contact`状态（一个资源）为特定的联系人提供服务。这个资源可以以两种模式显示：读取和写入；因此，分别有`index`和`edit`路由，如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Because Ember.js encourages convention, there are two components of routes
    and resources that are always autodefined:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ember.js 鼓励约定，路由和资源有两个组件总是自动定义的：
- en: 'A default application resource: This is the master resource into which all
    other resources are defined. We therefore do not need to define it in the router.
    It''s not mandatory to define resources on every state. For example, our `about`
    state is a route because it only needs to display static content to the user.
    It can however be thought to be a route of the already autodefined application
    resource.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认应用程序资源：这是所有其他资源定义的主资源。因此，我们不需要在路由器中定义它。不是每个状态都必须定义资源。例如，我们的`about`状态是一个路由，因为它只需要向用户显示静态内容。然而，它可以被认为是已经自动定义的应用程序资源的一个路由。
- en: 'A default `index` route on every resource: Again, every resource has a default
    index route. It''s autodefined because an application cannot settle on a resource
    state. The application therefore uses this route if no other route within this
    same resource was intended to be used.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个资源都有一个默认的`index`路由：再次强调，每个资源都有一个默认的索引路由。它是自动定义的，因为应用程序无法确定资源的状态。因此，如果在这个资源内部没有其他路由被打算使用，应用程序将使用这个路由。
- en: Nesting resources
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源嵌套
- en: Resources can be nested depending on the architecture of the application. In
    our case, we need to load contacts in the sidebar before displaying any of them
    to the user. Therefore, we need to define the contact resource inside the contacts.
    On the other hand, in an application such as Twitter, it won't make sense to define
    a `tweet` resource embedded inside a `tweets` resource because an extra overhead
    will be incurred when a user just wants to view a single tweet linked from an
    external application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的架构，资源可以被嵌套。在我们的例子中，我们需要在向用户显示任何联系人之前，在侧边栏中加载联系人。因此，我们需要在`contacts`内部定义联系人资源。另一方面，在一个像
    Twitter 这样的应用程序中，在`tweets`资源内部定义一个嵌套的`tweet`资源是没有意义的，因为当用户只想从外部应用程序查看单个推文时，将会产生额外的开销。
- en: Understanding the state transition cycle
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解状态转换周期
- en: A request is handled in the same way water travels from the roots (the application),
    up the trunk, and is eventually lost off leaves. This request we are referring
    to is a change in the browser location that can be triggered in a number of ways,
    as we shall discover more in the next chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的处理方式与水从根部（应用程序）向上流经树干，最终在叶子处流失的方式相同。我们这里所说的请求是指浏览器位置的变化，它可以以多种方式触发，我们将在下一章中了解更多。
- en: 'Before we proceed into finer details about routes, let''s discuss what happened
    when the application was first loaded. On boot, a few things happened as outlined:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨路由的更详细细节之前，让我们讨论一下当应用程序首次加载时发生了什么。在启动时，发生了一些事情，如下所述：
- en: The application first transitioned into the application state, then the index
    state.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序首先转换到应用程序状态，然后是索引状态。
- en: Next, the application index route redirected the request to the contacts resource.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，应用程序索引路由将请求重定向到联系人资源。
- en: Our application uses the browser's local storage to store the contacts and so
    for demoing purposes, the contacts resource populated this store with fixtures
    (located at `fixtures.js`).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序使用浏览器的本地存储来存储联系人，因此为了演示目的，联系人资源使用固定值（位于`fixtures.js`）填充了这个存储。
- en: The application then transitioned into the corresponding contacts resource index
    route, `contacts.index`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序随后转换到相应的联系人资源索引路由，`contacts.index`。
- en: Again, here we made a few decisions based on whether our store contained any
    data. Since we indeed have data, we redirected the application into the contact
    resource, passing the ID of the first contact along.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次，我们根据我们的存储是否包含数据做出了一些决定。由于我们确实有数据，我们将应用程序重定向到联系人资源，并传递了第一个联系人的ID。
- en: Just as in the two preceding resources, the application transitioned from this
    last resource into the corresponding index route, `contact.index`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如在前两个资源中一样，应用程序从最后一个资源转换到相应的索引路由，`contact.index`。
- en: 'The following figure gives a good view of the preceding state change:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下图给出了先前状态变化的好视角：
- en: '![Understanding the state transition cycle](img/00005.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![理解状态转换周期](img/00005.jpeg)'
- en: Configuring the router
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置路由器
- en: 'The router can be customized in the following ways:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器可以通过以下方式自定义：
- en: Logging state transitions
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录状态转换
- en: Specifying the root app URL
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定根应用URL
- en: Changing browser location lookup method
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改浏览器位置查找方法
- en: 'During development, it may be necessary to track the states into which the
    application transitions. Enabling these logs is as simple as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，可能需要跟踪应用程序转换到的状态。启用这些日志非常简单：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As illustrated, we enable the `LOG_TRANSITIONS` flag when creating the application.
    If an application is not served at the root of the website domain, then it may
    be necessary to specify the path name used, as in the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，我们在创建应用程序时启用了`LOG_TRANSITIONS`标志。如果一个应用程序不是在网站域的根目录下提供服务，那么可能需要指定使用的路径名，如下例所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One other modification we may need to make revolves around the techniques Ember.js
    uses to subscribe to the browser''s location changes. This makes it possible for
    the router to do its job of transitioning the app into the matched URL state.
    Two of these methods are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可能需要进行的修改是围绕 Ember.js 用于订阅浏览器位置变化的技术。这使得路由器能够完成其将应用程序转换到匹配的URL状态的任务。以下两种方法如下：
- en: Subscribing to the `hashchange` event
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅`hashchange`事件
- en: Using the `history.pushState` API
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`history.pushState` API
- en: 'The default technique used is provided by the `HashLocation` class documented
    at [http://emberjs.com/api/classes/Ember.HashLocation.html](http://emberjs.com/api/classes/Ember.HashLocation.html).
    This means that URL paths are usually prefixed with the hash symbol, for example,
    `/#/contacts/1/edit`. The other one is provided by the `HistoryLocation` class
    located at [http://emberjs.com/api/classes/Ember.HistoryLocation.html](http://emberjs.com/api/classes/Ember.HistoryLocation.html).
    This does not distinguish URLs from the traditional ones and can be enabled as:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认技术由文档中位于[http://emberjs.com/api/classes/Ember.HashLocation.html](http://emberjs.com/api/classes/Ember.HashLocation.html)的`HashLocation`类提供。这意味着URL路径通常以哈希符号开头，例如，`/#/contacts/1/edit`。另一种由位于[http://emberjs.com/api/classes/Ember.HistoryLocation.html](http://emberjs.com/api/classes/Ember.HistoryLocation.html)的`HistoryLocation`类提供。这并不区分传统URL和URL，并且可以启用如下：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also opt to let Ember.js pick which method is best suited for our app
    with the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以选择让 Ember.js 根据以下代码选择最适合我们应用程序的方法：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we don''t need any of these techniques, we could opt to do so especially
    when performing tests:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要这些技术中的任何一种，我们可以选择这样做，尤其是在进行测试时：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Specifying a route's path
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定路由的路径
- en: 'We now know that when defining a route or resource, the resource name used
    also serves as the path the router uses to match request URLs. Sometimes, it may
    be necessary to specify a different path to use to match states. There are two
    common reasons that may lead us to do this, the first of which is good for delegating
    route handling to another route. Although, we have not yet covered route handlers,
    we already mentioned that our application transitions from the application `index`
    route into the `contacts.index` state. We may however specify that the contacts
    route handler should manage this path as:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，在定义一个路由或资源时，所使用的资源名称也作为路由器用来匹配请求URL的路径。有时，可能需要指定一个不同的路径来匹配状态。有两个常见的原因可能导致我们这样做，第一个原因是有利于将路由处理委托给另一个路由。尽管我们还没有介绍路由处理程序，但我们已经提到，我们的应用程序从`index`路由过渡到`contacts.index`状态。然而，我们可以指定联系人路由处理程序应该管理以下路径：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Therefore, to specify an alternative path for a route, simply pass the desired
    route in a hash as the second argument during resource definition. This also applies
    when defining routes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要指定一个路由的替代路径，只需在资源定义期间将所需的路由作为哈希的第二参数传递。这也适用于定义路由。
- en: 'The second reason would be when a resource contains dynamic segments. For example,
    our contact resource handles contacts who should obviously have different URLs
    linking back to them. Ember.js uses URL pattern matching techniques used by other
    open source projects such as Ruby on Rails, Sinatra, and Express.js. Therefore,
    our contact resource should be defined as:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因可能是当资源包含动态段时。例如，我们的联系人资源处理那些显然应该有不同的URL链接回它们的联系人。Ember.js使用其他开源项目（如Ruby
    on Rails、Sinatra和Express.js）使用的URL模式匹配技术。因此，我们的联系人资源应该定义为：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Defining route and resource handlers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义路由和资源处理程序
- en: 'Now that we have defined all the possible states that our application can transition
    into, we need to define handlers to these states. From this point onwards, we
    will use the terms *route* and *resource handlers* interchangeably. A route handler
    performs the following major functions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了应用程序可以过渡到的所有可能的状态，我们需要定义这些状态的处理程序。从现在开始，我们将交替使用术语*路由*和*资源处理程序*。路由处理程序执行以下主要功能：
- en: Providing data (model) to be used by the current state
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供当前状态使用的（模型）数据
- en: Specifying the view and/or template to use to render the provided data to the
    user
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定用于将提供的数据渲染给用户的视图和/或模板
- en: Redirecting an application away into another state
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序重定向到另一个状态
- en: 'Before we move into discussing these roles, we need to know that a route handler
    is defined from the `Ember.Route` class as:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论这些角色之前，我们需要知道路由处理程序是从`Ember.Route`类定义的：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This class is used to define handlers for both resources and routes and therefore,
    the naming should not be a concern. Just as routes and resources are associated
    with paths and handlers, they are also associated with controllers, views, and
    templates using the Ember.js naming conventions. For example, when the application
    initializes, it enters into the `application` state and therefore, the following
    objects are sought:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类用于定义资源和路由的处理程序，因此命名不应成为问题。正如路由和资源与路径和处理程序相关联一样，它们也与控制器、视图和模板相关联，使用Ember.js的命名约定。例如，当应用程序初始化时，它进入`application`状态，因此，以下对象被寻找：
- en: The application route
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序路由
- en: The application controller
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序控制器
- en: The application view
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序视图
- en: The application template
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序模板
- en: In the spirit of *do more with reduced boilerplate* code, Ember.js autogenerates
    these objects unless explicitly defined in order to override the default implementations.
    As another example, if we examine our application, we notice that the `contact.edit`
    route has a corresponding `App.ContactEditController` controller and `contact/edit`
    template.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在“用更少的样板代码做更多”的精神下，Ember.js自动生成这些对象，除非明确定义以覆盖默认实现。作为另一个例子，如果我们检查我们的应用程序，我们会注意到`contact.edit`路由有一个相应的`App.ContactEditController`控制器和`contact/edit`模板。
- en: 'We do not need to define its route handler or view. Having seen this example,
    when referring to routes, we normally separate the resource name from the route
    name by a period as in the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要定义其路由处理程序或视图。在看到这个示例后，当我们提到路由时，我们通常通过一个点将资源名称与路由名称分开，如下所示：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the case of templates, we may use a period or a forward slash:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的情况下，我们可以使用一个点或一个正斜杠：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The other objects are usually camelized and suffixed by the class name:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其他对象通常采用驼峰式命名并附加类名后缀：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For example, the following table shows all the objects used in our chapter sample.
    As mentioned earlier, some are autogenerated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下表格显示了我们在章节示例中使用的所有对象。如前所述，其中一些是自动生成的。
- en: '| Route Name | Controller | Route Handler | View | Template |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 路由名称 | 控制器 | 路由处理器 | 视图 | 模板 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `applicationApplicationControllerApplicationRoute` | `ApplicationViewapplication`
    |   |   |   |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `applicationApplicationControllerApplicationRoute` | `ApplicationViewapplication`
    |   |   |   |'
- en: '| `indexIndexControllerIndexRoute` | `IndexViewindex` |   |   |   |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `indexIndexControllerIndexRoute` | `IndexViewindex` |   |   |   |'
- en: '| `about` | `AboutController` | `AboutRoute` | `AboutView` | `about` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `about` | `AboutController` | `AboutRoute` | `AboutView` | `about` |'
- en: '| `contactsContactsControllerContactsRoute` | `ContactsView` |   |   |   |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `contactsContactsControllerContactsRoute` | `ContactsView` |   |   |   |'
- en: '| `contacts.indexContactsIndexControllerContactsIndexRoute` | `ContactsIndexViewcontacts/index`
    |   |   |   |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `contacts.indexContactsIndexControllerContactsIndexRoute` | `ContactsIndexViewcontacts/index`
    |   |   |   |'
- en: '| `contacts.newContactsNewController` | `ContactsNewRoute` |   |   |   |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `contacts.newContactsNewController` | `ContactsNewRoute` |   |   |   |'
- en: '| `contact` | `ContactController` | `ContactRoute` | `ContactView` | `contact`
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `contact` | `ContactController` | `ContactRoute` | `ContactView` | `contact`
    |'
- en: '| `contact.index` | `ContactIndexController` | `ContactIndexRoute` | `ContactIndexView`
    | `contact/index` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `contact.index` | `ContactIndexController` | `ContactIndexRoute` | `ContactIndexView`
    | `contact/index` |'
- en: '| `contact.edit` | `ContactEditController` | `ContactEditRoute` | `ContactEditView`
    | `contact/edit` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `contact.edit` | `ContactEditController` | `ContactEditRoute` | `ContactEditView`
    | `contact/edit` |'
- en: One thing to note is that objects associated with the intermediary application
    state do not need to carry the suffix; hence, just `index` or `about`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是，与中间应用程序状态关联的对象不需要携带后缀；因此，只需`index`或`about`。
- en: Specifying a route's model
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定路由的模型
- en: 'In the first chapter, we mentioned that route handlers provide controllers,
    the data needed to be displayed by templates. These handlers have a `model` hook
    that can be used to provide this data in the following format:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们提到路由处理器提供控制器和模板需要显示的数据。这些处理器有一个`model`钩子，可以用来以下格式提供这些数据：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For instance, the route `contacts` handler in the chapter sample loads any
    saved contacts from local storage as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，章节示例中的`contacts`路由处理器从本地存储加载任何已保存的联系人，如下所示：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have abstracted this logic into our `App.Contact` model. Notice how we reopen
    the class in order to define this static method. As a recap of this lesson in
    [Chapter 2](part0019_split_000.html#page "Chapter 2. Understanding Ember.js Objects
    and Mixins"), *Understanding Ember.js Objects and Mixins*, a static method can
    only be called by the class of that method and not its instances:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将此逻辑抽象到我们的`App.Contact`模型中。注意我们如何重新打开类来定义这个静态方法。作为对[第二章](part0019_split_000.html#page
    "第二章. 理解 Ember.js 对象和混入")中本节课的回顾，*理解 Ember.js 对象和混入*，静态方法只能由该方法所属的类调用，而不能由其实例调用：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If no arguments are passed to the method, it goes ahead and calls the `findAll`
    method, which uses the local storage helper to retrieve the contacts:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有向该方法传递任何参数，它将直接调用`findAll`方法，该方法使用本地存储助手来检索联系人：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because we want to deal with contact objects, we iteratively convert the contents
    of the loaded contact list. If we examine the corresponding template, `contacts`,
    we notice that we are able to populate the sidebar as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想处理联系人对象，所以我们迭代地转换已加载联系人列表的内容。如果我们检查相应的模板`contacts`，我们会注意到我们能够像以下代码所示填充侧边栏：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Do not worry about the template syntax at this point if you''re new to Ember.js.
    The important thing to note is that the model was accessed via the `model` variable.
    Of course, before that, we check to see if the model has any content in:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚接触 Ember.js，在这个阶段不必担心模板语法。重要的是要注意，模型是通过`model`变量访问的。当然，在那之前，我们检查模型是否有内容：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we shall see later, if the list was empty, the application would be forced
    to transition into the `contacts.new` state, in order for the user to add the
    first contact as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将要看到的，如果列表为空，应用程序将被迫过渡到`contacts.new`状态，以便用户可以添加第一个联系人，如下面的截图所示：
- en: '![Specifying a route''s model](img/00006.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![指定路由的模型](img/00006.jpeg)'
- en: 'The `contact` handler is a different case. Remember we mentioned that its path
    has a dynamic segment that would be passed to the handler. This information is
    passed to the model hook in an options hash as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`contact`处理器是一个不同的情况。记住我们提到它的路径有一个动态段，这个段会被传递给处理器。这个信息以选项哈希的形式传递给模型钩子：'
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that we are able to access the contact''s ID via the `contact_id` attribute
    of the hash. This time, the `find` method calls the `findOne` static method of
    the contact''s class, which performs a search for the contact matching the provided
    ID, as shown in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们能够通过哈希的`contact_id`属性访问联系人的ID。这次，`find`方法调用联系人类别的`findOne`静态方法，该方法执行与提供的ID匹配的联系人搜索，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Serializing resources
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源序列化
- en: 'We''ve mentioned that Ember.js supports content to be linked back externally.
    Internally, Ember.js simplifies creating these links in templates. In our sample
    application, when the user selects a contact, the application transitions into
    the `contact.index` state, passing his/her ID along. This is possible through
    the use of the `link-to` handlebars expression:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到Ember.js支持将内容链接回外部。内部上，Ember.js简化了在模板中创建这些链接的过程。在我们的示例应用程序中，当用户选择一个联系人时，应用程序会过渡到`contact.index`状态，并传递其ID。这是通过使用`link-to`
    handlebars表达式实现的：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Again, we will revisit this later, in detail, in [Chapter 4](part0044_split_000.html#page
    "Chapter 4. Writing Application Templates"), *Writing Application Templates*,
    but for now, the important thing to note is that this expression enables us to
    construct a link that points to the said resource by passing the resource name
    and the affected model. The destination resource or route handler is responsible
    for yielding this path constituting **serialization**. To serialize a resource,
    we need to override the matching `serialize` hook as in the contact handler case
    shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将在[第4章](part0044_split_000.html#page "第4章。编写应用程序模板")中详细回顾这个问题，*编写应用程序模板*，但现在，重要的是要注意，这个表达式使我们能够通过传递资源名称和受影响的模型来构建指向该资源的链接。目标资源或路由处理器负责生成构成**序列化**的路径。要序列化资源，我们需要像以下代码中的联系人处理器案例一样覆盖匹配的`serialize`钩子：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Serialization means that the hook is supposed to return the values of all the
    specified segments. It receives two arguments, the first of which is the affected
    resource and the second is an array of all the specified segments during the resource
    definition. In our case, we only had one and so we returned the required hash
    that resembled the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化意味着钩子应该返回所有指定段落的值。它接收两个参数，第一个是受影响的资源，第二个是在资源定义期间指定的所有段落的数组。在我们的例子中，我们只有一个，所以我们返回了所需的类似以下代码的哈希：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we, for example, defined a resource with multiple segments like the following
    code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们定义了一个具有多个段落的资源，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The serialization hook would need to return something close to:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化钩子需要返回类似以下内容：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Asynchronous routing
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步路由
- en: 'In actual apps, we would often need to load the model data in an asynchronous
    fashion. There are various approaches that can be used to deliver this kind of
    data. The most robust way to load asynchronous data is through use of **promises**.
    Promises are objects whose unknown value can be set at a later point in time.
    It is very easy to create promises in Ember.js. For example, if our contacts were
    located in a remote resource, we could use jQuery to load them as:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用程序中，我们通常会以异步方式加载数据模型。有各种方法可以用来提供这类数据。加载异步数据最稳健的方式是通过使用**承诺**。承诺是可以在以后某个时间点设置未知值的对象。在Ember.js中创建承诺非常容易。例如，如果我们的联系人位于远程资源中，我们可以使用jQuery来加载它们，如下所示：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'jQuery''s HTTP utilities also return promises that Ember.js can consume. As
    a by-the-way, jQuery can also be referenced as `Ember.$` in an Ember.js application.
    In the preceding snippet, once data is loaded, Ember.js would set it as the model
    of the resource. However, one thing is missing. We require that the loaded data
    be converted to the defined contact model, as shown in the following little modification:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的HTTP工具同样返回Ember.js可以消费的承诺。顺便提一下，在Ember.js应用程序中，jQuery也可以被引用为`Ember.$`。在前面提到的代码片段中，一旦数据加载完成，Ember.js就会将其设置为资源的模型。然而，还有一件事是缺失的。我们需要将加载的数据转换为定义的联系人模型，如下面的简单修改所示：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We first create the promise, kick off the XHR request, and then return the promise
    while the request is still being processed. Ember.js will resume routing once
    this promise is rejected or resolved. The XHR call also creates a promise, so
    we need to attach to it the `then` method which essentially says, *invoke the
    passed resolve or reject function on successful or failed load respectively*.
    The `resolve` function converts the loaded data and resolves the promise; passing
    the data along thereby resumes routing. If the promise was rejected, the transition
    fails with an error. We will see how to handle this error in a moment.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建承诺，启动 XHR 请求，然后在请求仍在处理时返回承诺。Ember.js 将在承诺被拒绝或解决后恢复路由。XHR 调用也创建了一个承诺，因此我们需要将其附加到
    `then` 方法，该方法本质上表示，*在成功或失败加载时分别调用传递的解决或拒绝函数*。`resolve` 函数将加载的数据转换为解决承诺；传递数据从而恢复路由。如果承诺被拒绝，转换将因错误而失败。我们将在稍后看到如何处理此错误。
- en: 'Note that there are two other flavors we can use to create promises in Ember.js,
    as shown in the following examples:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以使用以下示例中所示的其他两种方式在 Ember.js 中创建承诺：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second example is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例如下：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Configuring a route's controller
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置路由的控制器
- en: 'We just learned that routes provide their corresponding controllers, data that
    they proxy to templates and views. This usually happens in the `setupController`
    hook of the route. For example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解到，路由提供它们对应的控制器、它们代理到模板和视图的数据。这通常发生在路由的 `setupController` 钩子中。例如：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Although we''ll rarely need to use it, this hook provides a good opportunity
    to modify other controllers. For example, we could set a property on the `application`
    controller as:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们很少需要使用它，但此钩子提供了修改其他控制器的好机会。例如，我们可以在 `application` 控制器上设置一个属性，如下所示：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Sometimes, we may want to specify a different controller that a handler should
    use. For example, the `contact.edit` route is used to edit the `contact` resource
    model. In this case, we needed to specify that the former depended on the latter
    via the `needs` property. That way, as we''ll learn in [Chapter 5](part0061_split_000.html#page
    "Chapter 5. Controllers"), *Controllers*, the `contact.edit` route''s template
    was able to access the model that was set on the controller as:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望指定一个不同的控制器，处理程序应该使用它。例如，`contact.edit` 路由用于编辑 `contact` 资源模型。在这种情况下，我们需要通过
    `needs` 属性指定前者依赖于后者。这样，正如我们将在第 [5章](part0061_split_000.html#page "第5章。控制器") 中学习到的，*控制器*，`contact.edit`
    路由的模板能够访问控制器上设置的模型，如下所示：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An alternative approach would be to use this controller directly by specifying
    it in the handler as:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过在处理程序中指定它来直接使用此控制器：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The result would be that the `contact.edit` template would be similar to that
    of the `contacts.new` template and, therefore both can be removed as explained
    in the next section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是 `contact.edit` 模板将与 `contacts.new` 模板的类似，因此两者都可以在下一节中解释的情况下被删除。
- en: Rendering the route's template
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染路由的模板
- en: 'Before we discuss more on route handler template rendering, it''s worth discussing
    what happens when the application transitions between states in the context of
    templates. This section will be revisited in detail in the next chapter. In our
    chapter example, the application eventually knows the transition, as outlined
    in order:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论更多关于路由处理程序模板渲染之前，讨论一下在模板的上下文中应用程序在状态之间转换时发生的事情是值得的。这一节将在下一章中详细回顾。在我们的章节示例中，应用程序最终知道转换，按照以下顺序概述：
- en: '`application state`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`应用状态`'
- en: '`contacts state`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`联系人状态`'
- en: '`contact state`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`联系人状态`'
- en: '`contact.index state`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`联系人索引状态`'
- en: 'Therefore, the `application` template is first rendered on the screen. The
    next template, `contacts`, is then rendered into the application template to constitute
    the sidebar. Next, the `contact` template is inserted into the `contacts` template.
    Lastly, the `contact.index` template was inserted into the `contact` template
    to complete the transition. Each template specifies an `outlet` portion into which
    child route handlers can render their templates. For example, note the outlet
    expression in the following application template:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`application` 模板首先在屏幕上渲染。然后，下一个模板 `contacts` 被渲染到 `application` 模板中，以构成侧边栏。接下来，`contact`
    模板被插入到 `contacts` 模板中。最后，`contact.index` 模板被插入到 `contact` 模板中，以完成过渡。每个模板都指定了一个
    `outlet` 部分，子路由处理程序可以将它们的模板渲染到其中。例如，注意以下应用模板中的出口表达式：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A route handler can specify the template to use in the same way as controllers.
    Again, revisiting the `contact.edit` route template, it uses a partial, which
    we shall discuss in the next chapter, and includes the shared `contacts.form`
    template into the host template.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理器可以像控制器一样指定要使用的模板。再次回顾`contact.edit`路由模板，它使用了一个部分，我们将在下一章讨论，并将共享的`contacts.form`模板包含到宿主模板中。
- en: 'The `renderTemplate` hook is the last chance for the handler to specify a custom
    template to use by invoking the `render` method and passing in the template to
    use along, as shown in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderTemplate`钩子是处理器指定要使用的自定义模板的最后机会，通过调用`render`方法并传入要使用的模板来实现，如下所示：'
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this case, we can therefore get rid of the defined controllers and routes
    of the `contacts.new` and `contact.edit` routes. Lastly, templates are not limited
    to a single outlet. This means that you can render different templates with different
    controller contexts in the current state template. For example, in a game application,
    we could define two outlets to host two different templates serving different
    purposes as:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以因此去除`contacts.new`和`contact.edit`路由中定义的控制器和路由。最后，模板并不局限于单个输出。这意味着你可以在当前状态模板中渲染不同的模板，不同的控制器上下文。例如，在一个游戏应用中，我们可以定义两个输出以容纳两个不同的模板，它们服务于不同的目的，如下所示：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And then, render them via the handler as:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过处理器渲染它们，如下所示：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Redirecting state
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向状态
- en: 'A common use of a handler is to redirect the application into another state
    in the same way we may be redirected to a `404` page if the requested resource
    was not found by the underlying server. In our sample app, the index controller
    overrides the route handler''s `redirect` hook in order to redirect the application
    into the `contacts` state using the `transitionTo` method, as shown in the following
    code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的一个常见用途是将应用程序重定向到同一状态中的另一个状态，就像如果请求的资源没有被底层服务器找到，我们可能会被重定向到`404`页面一样。在我们的示例应用中，索引控制器覆盖了路由处理器的`redirect`钩子，以便使用`transitionTo`方法将应用程序重定向到`contacts`状态，如下所示：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There are two cases where we may need to perform this redirection. The first
    is when we don''t need to know the model of the route handler. We used one of
    these hooks, `beforeModel`, to populate the contact list local store with fixtures
    just before the same handler went ahead to load them, as shown in the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要执行此重定向的情况有两种。第一种是我们不需要知道路由处理器的模型。我们使用这些钩子之一，`beforeModel`，在相同的处理器开始加载之前，用固定值填充联系人列表本地存储，如下所示：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'On the other hand, we can either use the `redirect` and `afterModel` hooks
    if we needed to wait for the handler''s model to load. In fact, the latter actually
    just calls the former. For example, we used the `afterModel` hook in the `contacts`
    route handler in the chapter sample to determine whether we needed to force the
    user to add a new contact or redirect them to view the first contact, as shown
    in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们需要等待处理器的模型加载，我们可以使用`redirect`和`afterModel`钩子。实际上，后者实际上只是调用了前者。例如，我们在章节示例中的`contacts`路由处理器中使用了`afterModel`钩子，以确定是否需要强制用户添加新的联系人或将他们重定向到查看第一个联系人，如下所示：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Catching routing errors
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获路由错误
- en: 'If a transition into a route fails, for example, failure to load the model,
    Ember.js emits the error action in that handler. Although we have not covered
    actions, think of them as events that can be delegated to a handler from templates
    or other route handlers and controllers. The following example catches such errors
    by redirecting the application to an appropriate error handling route:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路由转换失败，例如，无法加载模型，Ember.js会在该处理器中发出错误操作。尽管我们还没有涉及操作，但可以将它们视为可以从模板或其他路由处理器和控制器委托给处理器的事件。以下示例通过将应用程序重定向到适当的错误处理路由来捕获此类错误：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter has detailed how states are managed in Ember.js. We have particularly
    discussed how an Ember.js application boots from an application state into other
    nested states. A few concepts were introduced in the chapter sample and will be
    discussed in detail in the next chapter. That being said, in the next chapter,
    we will discuss templates, especially how they render the data proxied by controllers
    and how they delegate user generated actions back to routes. Therefore, you should
    have a solid understanding of the following topics covered in this chapter since
    they''ll be frequently revisited:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了 Ember.js 中状态的管理。我们特别讨论了 Ember.js 应用程序如何从一个应用程序状态启动到其他嵌套状态。本章示例中介绍了一些概念，将在下一章中详细讨论。因此，在下一章中，我们将讨论模板，特别是它们如何渲染由控制器代理的数据以及它们如何将用户生成操作委派回路由。因此，你应该对以下本章涵盖的主题有一个稳固的理解，因为它们将被频繁回顾：
- en: Defining application routes
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序路由
- en: Defining an application route
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序路由
- en: Implementing a route's model
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现路由的模型
- en: Setting up a route's controllers
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置路由的控制器
- en: Specifying a route's template
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定路由的模板
- en: Performing asynchronous routing
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行异步路由
- en: The next chapter will describe how to include templates using script tags or
    compiling and bundling/shipping templates from the server.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将描述如何使用脚本标签包含模板，或者从服务器编译和打包/运输模板。
