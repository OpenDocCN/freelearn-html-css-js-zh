- en: Chapter 1. Making a Web Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。创建Web服务器
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Setting up a router
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置路由
- en: Serving static files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Caching content in memory for immediate delivery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存中缓存内容以立即提供
- en: Optimizing performance with streaming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流优化性能
- en: Securing against filesystem hacking exploits
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止文件系统黑客攻击
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: One of the great qualities of Node is its simplicity. Unlike PHP or ASP there
    is no separation between the web server and code, nor do we have to customize
    large configuration files to get the behavior we want. With Node we can create
    the server, customize it, and deliver content all at the code level. This chapter
    demonstrates how to create a web server with Node and feed content through it,
    all while implementing security and performance enhancements to cater for various
    situations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Node的一个伟大特点是它的简单性。与PHP或ASP不同，它没有将web服务器和代码分开，也不需要定制大型配置文件来获得我们想要的行为。使用Node，我们可以创建服务器，自定义它，并在代码级别提供内容。本章演示了如何使用Node创建web服务器，并通过它提供内容，同时实现安全性和性能增强以满足各种情况。
- en: Setting up a router
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置路由
- en: In order to deliver web content we need to make a URI available. This recipe
    walks us through the creation of an HTTP server that exposes routes to the user.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供web内容，我们需要使URI可用。本教程将指导我们创建一个公开路由的HTTP服务器。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, let's create our server file. If our main purpose is to expose server
    functionality, it's general practice to call the file `server.js`, which we could
    put in a new folder. It's also a good idea to install and use `hotnode:`
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的服务器文件。如果我们的主要目的是公开服务器功能，通常的做法是将文件命名为`server.js`，然后将其放在一个新文件夹中。安装和使用`hotnode`也是一个好主意：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Hotnode` will conveniently auto-restart the server when we save changes.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存更改时，`hotnode`将方便地自动重新启动服务器。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to create the server we need the `http` module, so let''s load it
    and use the `http.createServer` method:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建服务器，我们需要`http`模块，所以让我们加载它并使用`http.createServer`方法：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files emailed directly to you.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.PacktPub.com](http://www.PacktPub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: Now, if we save our file and access `localhost:8080` on a web browser or using
    curl, our browser (or curl) will exclaim:`'Woohoo!'`. However, the same will occur
    at `localhost:8080/foo`. Indeed, any path will render the same behavior, so let's
    build in some routing. We can use the `path` module to extract `basename` of the
    path (the final part of the path), and reverse any URI encoding from the client
    with `decodeURI:`
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们保存我们的文件并在web浏览器上或使用curl访问`localhost:8080`，我们的浏览器（或curl）将会呼喊：`'Woohoo!'`。然而，在`localhost:8080/foo`上也会发生同样的事情。实际上，任何路径都会产生相同的行为，因此让我们构建一些路由。我们可以使用`path`模块提取路径的`basename`（路径的最后一部分），并使用`decodeURI`从客户端反转任何URI编码：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now need a way to define our routes. One option is to use an array of objects:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一种定义路由的方法。一种选择是使用对象数组：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our `pages` array should be placed above the `http.createServer` call.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`pages`数组应该放在`http.createServer`调用之上。
- en: 'Within our server, we need to loop through our array and see if the lookup
    variable matches any of our routes. If it does we can supply the output. We''ll
    also implement some `404` handling:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的服务器内部，我们需要循环遍历我们的数组，并查看查找变量是否与我们的路由中的任何一个匹配。如果匹配，我们可以提供输出。我们还将实现一些`404`处理：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The callback function we provide to `http.createServer` gives us all the functionality
    we need to interact with our server through the `request` and `response` objects.
    We use `request` to obtain the requested URL and then we acquire its `basename`
    with `path`. We also use `decodeURI` which our `another page` route would fail
    without as our code would try to match `another%20page` against our `pages` array
    and return `false`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供给`http.createServer`的回调函数为我们提供了通过`request`和`response`对象与服务器进行交互所需的所有功能。我们使用`request`来获取请求的URL，然后我们使用`path`获取它的`basename`。我们还使用`decodeURI`，如果没有它，我们的`another
    page`路由将失败，因为我们的代码将尝试将`another%20page`与我们的`pages`数组进行匹配并返回`false`。
- en: Once we have our `basename`, we can match it in any way we want. We could send
    it in a database query to retrieve content, use regular expressions to effectuate
    partial matches, or we could match it to a file name and load its contents.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`basename`，我们可以以任何我们想要的方式进行匹配。我们可以将其发送到数据库查询以检索内容，使用正则表达式进行部分匹配，或者将其与文件名匹配并加载其内容。
- en: We could have used a `switch` statement to handle routing but our `pages` array
    has several advantages. It's easier to read and extend, and it can be seamlessly
    converted to JSON. We loop through our `pages` array using `forEach`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用`switch`语句来处理路由，但我们的`pages`数组有几个优点。它更容易阅读和扩展，并且可以无缝转换为JSON。我们使用`forEach`循环遍历我们的`pages`数组。
- en: Node is built on Google's V8 engine, which provides us with a number of ECMAScript
    5 features. These features can't be used in all browsers as they're not yet universally
    implemented, but using them in Node is no problem! `forEach` is an ES5 implementation,
    but the ES3 way is to use the less convenient `for` loop.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Node是建立在谷歌的V8引擎上的，它为我们提供了许多ECMAScript 5功能。这些功能不能在所有浏览器中使用，因为它们尚未普遍实现，但在Node中使用它们没有问题！`forEach`是ES5的实现，但ES3的方法是使用不太方便的`for`循环。
- en: While looping through each object, we check its `route` property. If we get
    a match, we write the `200 OK` status and `content-type` headers. We then end
    the response with the object's output property.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环遍历每个对象时，我们检查它的`route`属性。如果我们找到匹配，我们将写入`200 OK`状态和`content-type`头。然后我们用对象的输出属性结束响应。
- en: '`response.end` allows us to pass a parameter to it, which it writes just before
    finishing the response. In `response.end`, we used a ternary operator (?:) to
    conditionally call `page.output` as a function or simply pass it as a string.
    Notice that the `another page` route contains a function instead of a string.
    The function has access to its parent object through the `this` variable, and
    allows for greater flexibility in assembling the output we want to provide. In
    the event that there is no match in our `forEach` loop, `response.end` would never
    be called. Therefore, the client would continue to wait for a response until it
    times out. To avoid this, we check the `response.finished` property and if it''s
    false, we write a `404` header and end the response.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`response.end`允许我们向其传递参数，在完成响应之前写入。在`response.end`中，我们使用了一个三元运算符（?:）来有条件地调用`page.output`作为函数或简单地将其作为字符串传递。请注意，`another
    page`路由包含一个函数而不是一个字符串。该函数通过`this`变量可以访问其父对象，并允许更灵活地组装我们想要提供的输出。如果在我们的`forEach`循环中没有匹配，`response.end`将永远不会被调用。因此，客户端将继续等待响应，直到超时。为了避免这种情况，我们检查`response.finished`属性，如果为false，我们写入一个`404`头并结束响应。'
- en: '`response.finished` depends on the `forEach` callback, yet it''s not nested
    within the callback. Callback functions are mostly used for asynchronous operations.
    So on the surface this looks like a potential race condition, however `forEach`
    does not operate asynchronously. It continues to block until all loops are complete.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`response.finished`取决于`forEach`回调，但它并不嵌套在回调内部。回调函数主要用于异步操作。因此，表面上看起来像是潜在的竞争条件，但`forEach`并不是异步操作。它会继续阻塞，直到所有循环完成。'
- en: There's more...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many ways to extend and alter this example. There's also some great
    non-core modules available that do the leg work for us.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以扩展和修改这个示例。还有一些非核心模块可供我们使用。
- en: Simple multilevel routing
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单多级路由
- en: So far, our routing only deals with a single-level path. A multilevel path (for
    example, `/about/node)` will simply return a `404`. We can alter our object to
    reflect a subdirectory-like structure, remove `path`, and use `request.url` for
    our routes instead of `path.basename:`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的路由只处理单级路径。多级路径（例如，`/about/node`）将简单地返回`404`。我们可以修改我们的对象以反映子目录结构，删除`path`，并使用`request.url`而不是`path.basename`来作为我们的路由。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When serving static files, `request.url` must be cleaned prior to fetching a
    given file. Check out the *Securing against filesystem hacking exploits* section
    discussed in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供静态文件时，必须在获取给定文件之前清理`request.url`。请查看本章中讨论的*防止文件系统黑客攻击*部分。
- en: Multilevel routing could be taken further, allowing us to build and then traverse
    a more complex object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 多级路由可以进一步进行，允许我们构建然后遍历一个更复杂的对象。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After the third or fourth level, this object would become a leviathan to look
    at. We could instead create a helper function to define our routes that essentially
    pieces our object together for us. Alternatively, we could use one of the excellent
    non-core routing modules provided by the open source Node community. Excellent
    solutions already exist which provide helper methods to handle the increasing
    complexity of scalable multilevel routing (see *Routing modules* discussed in
    this chapter and[Chapter 6](ch06.html "Chapter 6. Accelerating Development with
    Express"), *Accelerating Development with Express*).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三或第四级之后，查看这个对象将变得非常庞大。我们可以创建一个辅助函数来定义我们的路由，从而为我们拼接对象。或者，我们可以使用开源Node社区提供的出色的非核心路由模块之一。已经存在出色的解决方案，提供了帮助方法来处理可扩展多级路由的不断增加的复杂性（请参阅本章和[第6章](ch06.html
    "第6章。使用Express加速开发")中讨论的*路由模块*，*使用Express加速开发*）。
- en: Parsing the querystring
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析查询字符串
- en: Two other useful core modules are `url` and `querystring`. The `url.parse` method
    allows two parameters. First the URL string (in our case, this will be `request.url)`
    and second a Boolean parameter named `parseQueryString`. If set to `true`, it
    lazy loads the `querystring` module, saving us the need to require it, to parse
    the query into an object. This makes it easy for us to interact with the query
    portion of a URL.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个有用的核心模块是`url`和`querystring`。`url.parse`方法允许两个参数。首先是URL字符串（在我们的情况下，这将是`request.url`），第二个是名为`parseQueryString`的布尔参数。如果设置为`true`，它会延迟加载`querystring`模块，省去了我们需要要求它来解析查询为对象。这使我们可以轻松地与URL的查询部分交互。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the added `id` properties we can access our object data by, for instance,
    `localhost:8080?id=2.`
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`id`属性，我们可以通过`localhost:8080?id=2`等方式访问我们的对象数据。
- en: Routing modules
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由模块
- en: There's an up-to-date list of various routing modules for Node at [https://www.github.com/joyent/node/wiki/modules#wiki-web-frameworks-routers](https://www.github.com/joyent/node/wiki/modules#wiki-web-frameworks-routers).
    These community-made routers cater to various scenarios. It's important to research
    the activity and maturity of a module before taking it into a production environment.
    In [Chapter 6](ch06.html "Chapter 6. Accelerating Development with Express"),
    *Accelerating Development with Express*, we will go into greater detail on using
    the built-in Express/Connect router for more comprehensive routing solutions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Node的各种路由模块的最新列表，请访问[https://www.github.com/joyent/node/wiki/modules#wiki-web-frameworks-routers](https://www.github.com/joyent/node/wiki/modules#wiki-web-frameworks-routers)。这些由社区制作的路由器适用于各种场景。在将其引入生产环境之前，重要的是要研究模块的活动和成熟度。在[第6章](ch06.html
    "第6章。使用Express加速开发")中，*使用Express加速开发*，我们将更详细地讨论使用内置的Express/Connect路由器来实现更全面的路由解决方案。
- en: See also
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Serving static files* and *Securing against filesystem hacking exploits* discussed
    in this chapter'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中讨论的*提供静态文件*和*防止文件系统黑客攻击*。
- en: '*Dynamic Routing* discussed In [Chapter 6](ch06.html "Chapter 6. Accelerating
    Development with Express"), *Accelerating Development with Express*.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。使用Express加速开发")中讨论的*动态路由*。
- en: Serving static files
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: If we have information stored on disk that we want to serve as web content,
    we can use the `fs` (filesystem) module to load our content and pass it through
    the `createServer` callback. This is a basic conceptual starting point for serving
    static files. As we will learn in the following recipes there are much more efficient
    solutions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在磁盘上存储了要作为Web内容提供的信息，我们可以使用`fs`（文件系统）模块加载我们的内容并通过`createServer`回调传递。这是提供静态文件的基本概念起点。正如我们将在接下来的示例中学到的，还有更高效的解决方案。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll need some files to serve. Let''s create a directory named `content`,
    containing the following three files:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些要提供的文件。让我们创建一个名为`content`的目录，其中包含以下三个文件：
- en: '`index.html:`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html:`'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`script.js:`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`script.js:`'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`styles.css:`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`styles.css:`'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'As in the previous recipe, we''ll be using the core modules `http` and `path`.
    We''ll also need to access the filesystem, so we''ll require the `fs` module too.
    Let''s create our server:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们将使用核心模块`http`和`path`。我们还需要访问文件系统，因此我们也需要`fs`模块。让我们创建我们的服务器：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we haven''t already, we can initialize our `server.js` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有，我们可以初始化我们的`server.js`文件：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Try loading `localhost:8080/foo` and the console will say `foo doesn''t exist`,
    because it doesn''t. `localhost:8080/script.js` will tell us `script.js is there`,
    because it is. Before we can save a file, we are supposed to let the client know
    the `content-type`, which we can determine from the file extensions. So let''s
    make a quick map using an object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试加载`localhost:8080/foo`，控制台将显示`foo不存在`，因为它确实不存在。`localhost:8080/script.js`将告诉我们`script.js存在`，因为它确实存在。在保存文件之前，我们应该让客户端知道`content-type`，我们可以从文件扩展名中确定。因此，让我们使用对象快速创建一个映射：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We could extend our `mimeTypes` map later to support more types.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以后可以扩展我们的`mimeTypes`映射以支持更多类型。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modern browsers may be able to interpret certain mime types (such as `text/javascript)`
    without the server sending a `content-type` header. However, older browsers or
    less common mime types will rely upon the correct `content-type` header being
    sent from the server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器可能能够解释某些MIME类型（例如`text/javascript`）而无需服务器发送`content-type`头。然而，旧版浏览器或较少使用的MIME类型将依赖服务器发送正确的`content-type`头。
- en: Remember to place `mimeTypes` outside the server callback since we don't want
    to initialize the same object on every client request. If the requested file exists,
    we can convert our file extension into `content-type` by feeding `path.extname`
    into `mimeTypes` and then passing our retrieved `content-type` to `response.writeHead`.
    If the requested file doesn't exist, we'll write out a `404` and end the response.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，将`mimeTypes`放在服务器回调之外，因为我们不希望在每个客户端请求上初始化相同的对象。如果请求的文件存在，我们可以通过将`path.extname`传递给`mimeTypes`，然后将我们检索到的`content-type`传递给`response.writeHead`来将我们的文件扩展名转换为`content-type`。如果请求的文件不存在，我们将写出`404`并结束响应。
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At the moment, there is still no content sent to the client. We have to get
    this content from our file, so we wrap the response handling in an `fs.readFile`
    method callback.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，仍然没有内容发送到客户端。我们必须从我们的文件中获取这些内容，因此我们将响应处理包装在`fs.readFile`方法的回调中。
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Before we finish, let''s apply some error handling to our `fs.readFile` callback
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成之前，让我们对我们的`fs.readFile`回调应用一些错误处理，如下所示：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that `return` stays outside the `fs.readFile` callback. We are returning
    from the `fs.exists` callback to prevent further code execution (for example,
    sending `404)`. Placing a `return` in an `if` statement is similar to using an
    `else` branch. However, the `if return` pattern is generally preferable to using
    `if else` in Node, as it eliminates yet another set of curly braces.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`return`保持在`fs.readFile`回调之外。我们从`fs.exists`回调中返回，以防止进一步的代码执行（例如，发送`404`）。在`if`语句中放置`return`类似于使用`else`分支。然而，在Node中，`if
    return`模式通常比使用`if else`更可取，因为它消除了另一组花括号。
- en: 'So now we can navigate to `localhost:8080` which will serve our `index.html`
    file. The `index.html` file makes calls to our `script.js` and `styles.css` files,
    which our server also delivers with appropriate mime types. The result can be
    seen in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以导航到`localhost:8080`，这将提供我们的`index.html`文件。`index.html`文件调用我们的`script.js`和`styles.css`文件，我们的服务器也以适当的MIME类型提供这些文件。结果可以在以下截图中看到：
- en: '![How to do it...](img/7188_01_image.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/7188_01_image.jpg)'
- en: This recipe serves to illustrate the fundamentals of serving static files. Remember,
    this is not an efficient solution! In a real-world situation, we don't want to
    make an I/O call every time a request hits the server, this is very costly especially
    with larger files. In the following recipes, we'll learn better ways to serve
    static files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例用来说明提供静态文件的基本原理。请记住，这不是一个高效的解决方案！在现实世界的情况下，我们不希望每次请求到达服务器时都进行I/O调用，尤其是对于较大的文件来说，这是非常昂贵的。在接下来的示例中，我们将学习更好的方法来提供静态文件。
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our script creates a server and declares a variable called `lookup`. We assign
    a value to `lookup` using the double pipe (||) *or* operator. This defines a default
    route if `path.basename` is empty. Then we pass `lookup` to a new variable that
    we named `f` in order to prepend our `content` directory to the intended filename.
    Next we run `f` through the `fs.exists` method and check the `exist` parameter
    in our callback to see if the file is there. If the file exists we read it asynchronously
    using `fs.readFile`. If there is a problem accessing the file, we write a `500`
    server error, end the response, and return from the `fs.readFile` callback. We
    can test the error-handling functionality by removing read permissions from `index.html`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本创建了一个服务器并声明了一个名为`lookup`的变量。我们使用双管道（||）*或*运算符为`lookup`赋值。这定义了一个默认路由，如果`path.basename`为空的话。然后我们将`lookup`传递给一个新变量，我们将其命名为`f`，以便将我们的`content`目录前置到预期的文件名。接下来，我们通过`fs.exists`方法运行`f`并检查回调中的`exist`参数，以查看文件是否存在。如果文件存在，我们使用`fs.readFile`进行异步读取。如果访问文件出现问题，我们将写入`500`服务器错误，结束响应，并从`fs.readFile`回调中返回。我们可以通过从`index.html`中删除读取权限来测试错误处理功能。
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Doing so will cause the server to throw the `500` server error status code.
    To set things right again run the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将导致服务器抛出`500`服务器错误状态码。要再次设置正确，请运行以下命令：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As long as we can access the file, we grab `content-type` using our handy `mimeTypes`
    mapping object, write the headers, end the response with data loaded from the
    file, and finally return from the function. If the requested file does not exist,
    we bypass all this logic, write a `404`, and end the response.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们可以访问文件，就可以使用我们方便的`mimeTypes`映射对象来获取`content-type`，编写标头，使用从文件加载的数据结束响应，最后从函数返回。如果请求的文件不存在，我们将绕过所有这些逻辑，写入`404`，并结束响应。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here's something to watch out for...
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是...
- en: The favicon gotcha
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网站图标陷阱
- en: 'When using a browser to test our server, sometimes an unexpected server hit
    can be observed. This is the browser requesting the default `favicon.ico` icon
    file that servers can provide. Apart from the initial confusion of seeing additional
    hits, this is usually not a problem. If the favicon request begins to interfere,
    we can handle it like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用浏览器测试我们的服务器时，有时会观察到意外的服务器请求。这是浏览器请求服务器可以提供的默认`favicon.ico`图标文件。除了看到额外的请求之外，这通常不是问题。如果网站图标请求开始干扰，我们可以这样处理：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we wanted to be more polite to the client, we could also inform it of a `404`
    by using `response.writeHead(404)` before issuing `response.end`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对客户端更有礼貌，还可以在发出`response.end`之前使用`response.writeHead(404)`通知它`404`。
- en: See also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Caching content in memory for immediate delivery* discussed in this chapter'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的将内容缓存在内存中以进行即时传递*'
- en: '*Optimizing performance with streaming* discussed in this chapter'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用流来优化性能*'
- en: '*Securing against filesystem hacking exploits* discussed in this chapter'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的防止文件系统黑客攻击*'
- en: Caching content in memory for immediate delivery
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将内容缓存在内存中以进行即时传递
- en: Directly accessing storage on each client request is not ideal. For this example,
    we will explore how to enhance server efficiency by accessing the disk on only
    the first request, caching the data from file for that first request, and serving
    all further requests out of the process memory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在每个客户端请求上访问存储并不理想。在本例中，我们将探讨如何通过仅在第一次请求时访问磁盘、为第一次请求缓存文件数据以及从进程内存中提供所有后续请求来增强服务器效率。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to improve upon the code from the previous task, so we'll be working
    with `server.js`, and in the `content` directory with `index.html, styles.css`,
    and `script.js`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将改进上一个任务中的代码，因此我们将使用`server.js`，以及`content`目录中的`index.html，styles.css`和`script.js`。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Let's begin by looking at our script from the previous recipe *Serving static
    files:*
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下上一个配方“提供静态文件”的脚本
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We need to modify this code to only read the file once, load its contents into
    memory, and afterwards respond to all requests for that file from memory. To keep
    things simple and preserve maintainability, we''ll extract our cache handling
    and content delivery into a separate function. So above `http.createServer`, and
    below `mimeTypes`, we''ll add the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改这段代码，只读取文件一次，将其内容加载到内存中，然后从内存中响应所有对该文件的请求。为了保持简单和可维护性，我们将缓存处理和内容传递提取到一个单独的函数中。因此，在`http.createServer`上方，并在`mimeTypes`下方，我们将添加以下内容：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A new `cache` object has been added to store our files in memory as well as
    a new function called `cacheAndDeliver`. Our function takes the same parameters
    as `fs.readFile`, so we can replace `fs.readFile` in the `http.createServer` callback
    while leaving the rest of the code intact:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新的`cache`对象，用于将文件存储在内存中，以及一个名为`cacheAndDeliver`的新函数。我们的函数接受与`fs.readFile`相同的参数，因此我们可以在`http.createServer`回调中替换`fs.readFile`，同时保持其余代码不变：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we execute our `server.js` file and access `localhost:8080` twice consecutively,
    the second request causes the console to output the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行`server.js`文件并连续两次访问`localhost:8080`时，第二个请求会导致控制台输出以下内容：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We defined a function called `cacheAndDeliver`, which like `fs.readFile`, takes
    a filename and callback as parameters. This is great because we can pass the exact
    same callback of `fs.readFile` to `cacheAndDeliver`, padding the server out with
    caching logic without adding any extra complexity visually to the inside of the
    `http.createServer` callback. As it stands, the worth of abstracting our caching
    logic into an external function is arguable, but the more we build on the server's
    caching abilities the more feasible and useful this abstraction becomes. Our `cacheAndDeliver`
    function checks to see if the requested content is already cached, if not, we
    call `fs.readFile` and load the data from disk. Once we have this data we may
    as well hold onto it, so it's placed into the `cache` object referenced by its
    file path (the `f` variable). The next time anyone requests the file, `cacheAndDeliver`
    will see that we have the file stored in the `cache` object and will issue an
    alternative callback containing the cached data. Notice that we fill the `cache[f]`
    property with another new object containing a `content` property. This makes it
    easier to extend the caching functionality in the future since we would just need
    to place extra properties into our `cache[f]` object and supply logic that interfaces
    with these properties accordingly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`cacheAndDeliver`的函数，类似于`fs.readFile`，它接受文件名和回调作为参数。这很棒，因为我们可以将完全相同的`fs.readFile`回调传递给`cacheAndDeliver`，在不向`http.createServer`回调内部添加任何额外可视复杂性的情况下，为服务器添加缓存逻辑。目前来看，将我们的缓存逻辑抽象成外部函数的价值是有争议的，但是随着我们不断增强服务器的缓存能力，这种抽象变得越来越可行和有用。我们的`cacheAndDeliver`函数检查所请求的内容是否已经缓存，如果没有，我们调用`fs.readFile`并从磁盘加载数据。一旦我们有了这些数据，我们可能会保留它，因此它被放入由其文件路径引用的`cache`对象中（`f`变量）。下次有人请求文件时，`cacheAndDeliver`将看到我们在`cache`对象中存储了文件，并将发出包含缓存数据的替代回调。请注意，我们使用另一个新对象填充了`cache[f]`属性，其中包含一个`content`属性。这样做可以更容易地扩展将来的缓存功能，因为我们只需要将额外的属性放入我们的`cache[f]`对象中，并提供与这些属性相对应的接口逻辑。
- en: There's more...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we were to modify the files we are serving, any changes wouldn't be reflected
    until we restart the server. We can do something about that.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改正在提供的文件，任何更改都不会反映在我们重新启动服务器之前。我们可以解决这个问题。
- en: Reflecting content changes
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反映内容更改
- en: 'To detect whether a requested file has changed since we last cached it, we
    must know when the file was cached and when it was last modified. To record when
    the file was last cached, let''s extend the `cache[f]` object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测请求的文件自上次缓存以来是否发生了更改，我们必须知道文件何时被缓存以及上次修改时间。为了记录文件上次缓存的时间，让我们扩展`cache[f]`对象：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That was easy. Now we need to find out when the file was updated last. The
    `fs.stat` method returns an object as the second parameter of its callback. This
    object contains the same useful information as the command-line GNU coreutils
    `stat.fs.stat` supplies three time-related properties: last accessed (`atime`),
    last modified (`mtime`), and last changed (`ctime`). The difference between `mtime`
    and `ctime` is that `ctime` will reflect any alterations to the file, whereas
    `mtime` will only reflect alterations to the content of the file. Consequently,
    if we changed the permissions of a file, `ctime` would update but `mtime` would
    stay the same. We want to pay attention to permission changes as they happen,
    so let''s use the `ctime` property:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要找出文件上次更新的时间。`fs.stat`方法在其回调的第二个参数中返回一个对象。该对象包含与命令行GNU coreutils `stat.fs.stat`提供的相同有用信息：上次访问时间（`atime`）、上次修改时间（`mtime`）和上次更改时间（`ctime`）。`mtime`和`ctime`之间的区别在于`ctime`将反映对文件的任何更改，而`mtime`只会反映对文件内容的更改。因此，如果我们更改了文件的权限，`ctime`会更新，但`mtime`会保持不变。我们希望在发生权限更改时注意到，因此让我们使用`ctime`属性：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The contents of `cacheAndDeliver` have been wrapped in an `fs.stat` callback.
    Two variables have been added and the `if(!cache[f])` statement has been modified.
    We parse the `ctime` property of the second parameter, dub `stats` using `Date.parse`
    to convert it to milliseconds since midnight, January 1, 1970 (the Unix epoch),
    and assign it to our `lastChanged` variable. Then we check whether the requested
    file's last changed time is greater than when we cached the file (provided the
    file is indeed cached) and assign the result to our `isUpdated` variable. After
    that, it's merely a case of adding the `isUpdated` Boolean to the conditional
    `if(!cache[f])` statement via the `||` (or) operator. If the file is newer than
    our cached version (or if it isn't yet cached), we load the file from the disk
    into the cache object.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheAndDeliver`的内容已经包装在`fs.stat`回调中。添加了两个变量，并修改了`if(!cache[f])`语句。我们解析了第二个参数`stats`的`ctime`属性，使用`Date.parse`将其转换为自1970年1月1日午夜以来的毫秒数（Unix纪元），并将其分配给我们的`lastChanged`变量。然后我们检查所请求文件的上次更改时间是否大于我们缓存文件的时间（假设文件确实已缓存），并将结果分配给我们的`isUpdated`变量。之后，只需通过`||`（或）运算符将`isUpdated`布尔值添加到条件`if(!cache[f])`语句中。如果文件比我们缓存的版本更新（或者尚未缓存），我们将文件从磁盘加载到缓存对象中。'
- en: See also
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Optimizing performance with streaming* discussed in this chapter'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中讨论了通过流优化性能
- en: '*Browser-server transmission via AJAX discussed in* [Chapter 3](ch03.html "Chapter 3. Working
    with Data Serialization"), *Working with Data Serialization*'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在* [第3章](ch03.html "第3章. 数据序列化处理") *中讨论了通过AJAX进行浏览器-服务器传输*，*数据序列化处理*'
- en: Optimizing performance with streaming
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过流优化性能
- en: Caching content certainly improves upon reading a file from disk for every request.
    However, with `fs.readFile`, we are reading the whole file into memory before
    sending it out in `response`. For better performance, we can stream a file from
    disk and `pipe` it directly to the `response` object, sending data straight to
    the network socket one piece at a time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存内容确实改进了每次请求时从磁盘读取文件。但是，使用`fs.readFile`时，我们是在将整个文件读入内存后再将其发送到`response`中。为了提高性能，我们可以从磁盘流式传输文件，并将其直接传输到`response`对象，一次发送一小部分数据到网络套接字。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are building on our code from the last example, so let's get `server.js,
    index.html, styles.css`, and `script.js` ready.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建上一个示例中的代码，所以让我们准备好`server.js, index.html, styles.css`和`script.js`。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will be using `fs.createReadStream` to initialize a stream, which can be
    piped to the `response` object. In this case, implementing `fs.createReadStream`
    within our `cacheAndDeliver` function isn''t ideal because the event listeners
    of `fs.createReadStream` will need to interface with the `request` and `response`
    objects. For the sake of simplicity, these would preferably be dealt within the
    `http.createServer` callback. For brevity''s sake, we will discard our `cacheAndDeliver`
    function and implement basic caching within the server callback:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`fs.createReadStream`来初始化一个流，可以将其传输到`response`对象。在这种情况下，在我们的`cacheAndDeliver`函数中实现`fs.createReadStream`并不理想，因为`fs.createReadStream`的事件监听器将需要与`request`和`response`对象进行接口。为了简单起见，这些最好在`http.createServer`回调中处理。为了简洁起见，我们将放弃我们的`cacheAndDeliver`函数，并在服务器回调中实现基本的缓存：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Later on, we will fill `cache[f].content` while we're interfacing with the `readStream`
    object. Here's how we use `fs.createReadStream:`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，当我们与`readStream`对象进行接口时，我们将填充`cache[f].content`。以下是我们如何使用`fs.createReadStream：`
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will return a `readStream` object which streams the file that is pointed
    at by the `f` variable. `readStream` emits events that we need to listen to. We
    can listen with `addEventListener` or use the shorthand `on:`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个`readStream`对象，该对象流式传输由`f`变量指向的文件。`readStream`发出我们需要监听的事件。我们可以使用`addEventListener`进行监听，也可以使用简写的`on:`
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since `createReadStream` returns the `readStream` object, we can latch our
    event listener straight onto it using method chaining with the dot notation. Each
    stream is only going to open once, we don''t need to keep on listening to it.
    Therefore, we can use the `once` method instead of `on` to automatically stop
    listening after the first event occurrence:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`createReadStream`返回`readStream`对象，我们可以使用点符号的方法链接将我们的事件监听器直接附加到它上面。每个流只会打开一次，我们不需要继续监听它。因此，我们可以使用`once`方法而不是`on`方法，在第一次事件发生后自动停止监听：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Before we fill out the `open` event callback, let''s implement error handling
    as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们填写`open`事件回调之前，让我们按照以下方式实现错误处理：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The key to this entire endeavor is the `stream.pipe` method. This is what enables
    us to take our file straight from disk and stream it directly to the network socket
    via our `response` object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 整个努力的关键是`stream.pipe`方法。这使我们能够直接从磁盘获取文件并将其直接通过我们的`response`对象流式传输到网络套接字。
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'What about ending the response? Conveniently, `stream.pipe` detects when the
    stream has ended and calls `response.end` for us. For caching purposes, there''s
    one other event we need to listen to. Still within our `fs.exists` callback, underneath
    the `createReadStream` code block, we write the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 结束响应怎么办？方便的是，`stream.pipe`会检测流何时结束，并为我们调用`response.end`。出于缓存目的，我们需要监听另一个事件。在我们的`fs.exists`回调中，在`createReadStream`代码块下面，我们编写以下代码：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We've used the `data` event to capture the buffer as it's being streamed, and
    copied it into a buffer that we supplied to `cache[f].content`, using `fs.stat`
    to obtain the file size for the file's cache buffer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`data`事件来捕获正在流式传输的缓冲区，并将其复制到我们提供给`cache[f].content`的缓冲区中，使用`fs.stat`来获取文件的缓冲区大小。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Instead of the client waiting for the server to load the entire file from the
    disk prior to sending it to the client, we use a stream to load the file in small,
    ordered pieces and promptly send them to the client. With larger files this is
    especially useful, as there is minimal delay between the file being requested
    and the client starting to receive the file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端不需要等待服务器从磁盘加载完整的文件然后再发送给客户端，我们使用流来以小的、有序的片段加载文件，并立即发送给客户端。对于较大的文件，这是特别有用的，因为在文件被请求和客户端开始接收文件之间几乎没有延迟。
- en: We did this by using `fs.createReadStream` to start streaming our file from
    the disk. `fs.createReadStream` creates `readStream`, which inherits from the
    `EventEmitter` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`fs.createReadStream`来开始从磁盘流式传输我们的文件。`fs.createReadStream`创建了`readStream`，它继承自`EventEmitter`类。
- en: 'The `EventEmitter` class accomplishes the *evented* part of Node''s tag line:
    Evented I/O for V8 JavaScript. Due to this, we''ll use listeners instead of callbacks
    to control the flow of stream logic.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`类实现了Node标语中的*evented*部分：Evented I/O for V8 JavaScript。因此，我们将使用监听器而不是回调来控制流逻辑的流程。'
- en: Then we added an `open` event listener using the `once` method since we want
    to stop listening for `open` once it has been triggered. We respond to the `open`
    event by writing the headers and using the `stream.pipe` method to shuffle the
    incoming data straight to the client.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`once`方法添加了一个`open`事件监听器，因为我们希望一旦触发就停止监听`open`。我们通过编写标头并使用`stream.pipe`方法将传入的数据直接传输到客户端来响应`open`事件。
- en: '`stream.pipe` handles the data flow. If the client becomes overwhelmed with
    processing, it sends a signal to the server which should be honored by pausing
    the stream. Under the hood, `stream.pipe` uses `stream.pause` and `stream.resume`
    to manage this interplay.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream.pipe`处理数据流。如果客户端在处理过程中变得不堪重负，它会向服务器发送一个信号，服务器应该通过暂停流来予以尊重。在底层，`stream.pipe`使用`stream.pause`和`stream.resume`来管理这种相互作用。'
- en: While the response is being piped to the client, the content cache is simultaneously
    being filled. To achieve this, we had to create an instance of the `Buffer` class
    for our `cache[f].content` property. A `Buffer` must be supplied with a size (or
    an array or string) which in our case is the size of the file. To get the size,
    we used the asynchronous `fs.stat` and captured the `size` property in the callback.
    The `data` event returns `Buffer` as its only callback parameter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应被传输到客户端时，内容缓存同时被填充。为了实现这一点，我们必须为`cache[f].content`属性创建一个`Buffer`类的实例。`Buffer`必须提供一个大小（或数组或字符串），在我们的情况下是文件的大小。为了获取大小，我们使用了异步的`fs.stat`并在回调中捕获了`size`属性。`data`事件将`Buffer`作为其唯一的回调参数返回。
- en: The default `bufferSize` for a stream is 64 KB. Any file whose size is less
    than the `bufferSize` will only trigger one `data` event because the entire file
    will fit into the first chunk of data. However, for files greater than `bufferSize`,
    we have to fill our `cache[f].content` property one piece at a time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 流的默认`bufferSize`为64 KB。任何大小小于`bufferSize`的文件将只触发一个`data`事件，因为整个文件将适合第一个数据块中。但是，对于大于`bufferSize`的文件，我们必须一次填充我们的`cache[f].content`属性的一部分。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Changing the default `readStream` buffer size:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 更改默认的`readStream`缓冲区大小：
- en: We can change the buffer size of `readStream` by passing an `options` object
    with a `bufferSize` property as the second parameter of `fs.createReadStream`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过传递一个`options`对象并在`fs.createReadStream`的第二个参数中添加一个`bufferSize`属性来更改`readStream`的缓冲区大小。
- en: 'For instance, to double the buffer you could use `fs.createReadStream(f,{bufferSize:
    128 * 1024})`;'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，要将缓冲区加倍，可以使用`fs.createReadStream(f,{bufferSize: 128 * 1024})`；'
- en: We cannot simply concatenate each `chunk` with `cache[f].content` since this
    will coerce binary data into string format which, though no longer in binary format,
    will later be interpreted as binary. Instead, we have to copy all the little binary
    buffer `chunks` into our binary `cache[f].content` buffer.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将每个`chunk`与`cache[f].content`连接起来，因为这样会将二进制数据强制转换为字符串格式，尽管不再是二进制格式，但以后会被解释为二进制格式。相反，我们必须将所有小的二进制缓冲区`chunks`复制到我们的二进制`cache[f].content`缓冲区中。
- en: We created a `bufferOffset` variable to assist us with this. Each time we add
    another `chunk` to our `cache[f].content` buffer, we update our new `bufferOffset`
    by adding the length of the `chunk` buffer to it. When we call the `Buffer.copy`
    method on the `chunk` buffer, we pass `bufferOffset` as the second parameter so
    our `cache[f].content` buffer is filled correctly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`bufferOffset`变量来帮助我们。每次我们向我们的`cache[f].content`缓冲区添加另一个`chunk`时，我们通过将`chunk`缓冲区的长度添加到它来更新我们的新`bufferOffset`。当我们在`chunk`缓冲区上调用`Buffer.copy`方法时，我们将`bufferOffset`作为第二个参数传递，以便我们的`cache[f].content`缓冲区被正确填充。
- en: Moreover, operating with the `Buffer` class renders performance enhancements
    with larger files because it bypasses the V8 garbage collection methods. These
    tend to fragment large amounts of data thus slowing down Node's ability to process
    them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用`Buffer`类进行操作可以提高性能，因为它可以绕过V8的垃圾回收方法。这些方法往往会使大量数据碎片化，从而减慢Node处理它们的能力。
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While streaming has solved a problem of waiting for files to load into memory
    before delivering them, we are nevertheless still loading files into memory via
    our `cache` object. With larger files, or large amounts of files, this could have
    potential ramifications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然流解决了等待文件加载到内存中然后传递它们的问题，但我们仍然通过我们的`cache`对象将文件加载到内存中。对于较大的文件或大量文件，这可能会产生潜在的影响。
- en: Protecting against process memory overruns
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止进程内存溢出
- en: There is a limited amount of process memory. By default, V8's memory is set
    to 1400 MB on 64-bit systems and 700 MB on 32-bit systems. This can be altered
    by running Node with `--max-old-space-size=N` where `N` is the amount of megabytes
    (the actual maximum amount that it can be set to depends upon the OS and of course
    the amount of physical RAM available). If we absolutely needed to be memory intensive,
    we could run our server on a large cloud platform, divide up the logic, and start
    new instances of node using the `child_process` class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 进程内存有限。默认情况下，V8的内存在64位系统上设置为1400 MB，在32位系统上设置为700 MB。可以通过在Node中运行`--max-old-space-size=N`来改变这个值，其中`N`是以兆字节为单位的数量（实际可以设置的最大值取决于操作系统和可用的物理RAM数量）。如果我们绝对需要占用大量内存，我们可以在大型云平台上运行服务器，分割逻辑，并使用`child_process`类启动新的node实例。
- en: 'In this case, high memory usage isn''t necessarily required and we can optimize
    our code to significantly reduce the potential for memory overruns. There is less
    benefit to caching larger files. The slight speed improvement relative to the
    total download time is negligible while the cost of caching them is quite significant
    in ratio to our available process memory. We can also improve cache efficiency
    by implementing an expiration time on cache objects which can then be used to
    clean the cache, consequently removing files in low demand and prioritizing high-demand
    files for faster delivery. Let''s rearrange our `cache` object slightly:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，高内存使用并不一定是必需的，我们可以优化我们的代码，显著减少内存溢出的可能性。对于缓存较大的文件，好处较少。与总下载时间相比，轻微的速度提高是微不足道的，而缓存它们的成本相对于我们可用的进程内存来说是相当显著的。我们还可以通过在缓存对象上实现过期时间来提高缓存效率，然后用它来清理缓存，从而删除低需求的文件，并优先处理高需求的文件以实现更快的传递。让我们稍微重新排列一下我们的`cache`对象：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For a clearer mental model, we''re making a distinction between the cache as
    a functioning entity and the cache as a store (which is a part of the broader
    cache entity). Our first goal is to only cache files under a certain size. We''ve
    defined `cache.maxSize` for this purpose. All we have to do now is insert an `if`
    condition within the `fs.stat` callback:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰的思维模型，我们要区分缓存作为一个功能实体和缓存作为存储（这是更广泛的缓存实体的一部分）。我们的第一个目标是只缓存一定大小的文件。我们为此定义了`cache.maxSize`。现在我们只需要在`fs.stat`回调中插入一个`if`条件：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice we also slipped in a new `timestamp` property into our `cache.store[f]`.
    This is for cleaning the cache, which is our second goal. Let's extend `cache:`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还在我们的`cache.store[f]`中悄悄地添加了一个新的`timestamp`属性。这是为了清理缓存，这是我们的第二个目标。让我们扩展`cache:`。
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So in addition to `maxSize`, we''ve created a `maxAge` property and added a
    `clean` method. We call `cache.clean` at the bottom of the server like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了`maxSize`，我们创建了一个`maxAge`属性并添加了一个`clean`方法。我们在服务器底部调用`cache.clean`，如下所示：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`cache.clean` loops through `cache.store` and checks to see if it has exceeded
    its specified lifetime. If it has, we remove it from `store`. We''ll add one further
    improvement and then we''re done. `cache.clean` is called on each request. This
    means `cache.store` is going to be looped through on every server hit, which is
    neither necessary nor efficient. It would be better if we cleaned the cache, say,
    every two hours or so. We''ll add two more properties to `cache`. The first is
    `cleanAfter` to specify how long between cache cleans. The second is `cleanedAt`
    to determine how long it has been since the cache was last cleaned.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache.clean`循环遍历`cache.store`，并检查它是否已超过指定的生命周期。如果是，我们就从`store`中移除它。我们将再添加一个改进，然后就完成了。`cache.clean`在每个请求上都会被调用。这意味着`cache.store`将在每次服务器命中时被循环遍历，这既不必要也不高效。如果我们每隔两个小时或者更长时间清理一次缓存，效果会更好。我们将向`cache`添加两个属性。第一个是`cleanAfter`，用于指定清理缓存的时间间隔。第二个是`cleanedAt`，用于确定自上次清理缓存以来的时间。'
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We wrap our `cache.clean` method in an `if` statement which will allow a loop
    through `cache.store` only if it has been longer than two hours (or whatever `cleanAfter`
    is set to), since the last clean.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的`cache.clean`方法包裹在一个`if`语句中，只有当它距离上次清理已经超过两个小时（或者`cleanAfter`设置为其他值）时，才允许对`cache.store`进行循环。
- en: See also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Handling file uploads* discussed In [Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"), *Exploring the HTTP Object*'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理文件上传*在[第2章](ch02.html "第2章。探索HTTP对象")中讨论过，*探索HTTP对象*'
- en: '*Securing Against Filesystem Hacking Exploits* discussed in this chapter.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*防止文件系统黑客攻击*在本章中讨论。'
- en: Securing against filesystem hacking exploits
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止文件系统黑客攻击
- en: For a Node app to be insecure, there must be something an attacker can interact
    with for exploitation purposes. Due to Node's minimalist approach, the onus is
    mostly on programmers to ensure their implementation doesn't expose security flaws.
    This recipe will help identify some security risk anti-patterns that could occur
    when working with the filesystem.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Node应用程序不安全，必须有攻击者可以与之交互以进行利用的东西。由于Node的极简主义方法，大部分责任都落在程序员身上，以确保他们的实现不会暴露安全漏洞。这个配方将帮助识别在处理文件系统时可能出现的一些安全风险反模式。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be working with the same `content` directory as in the previous recipes,
    but we'll start a new `insecure_server.js` file (there's a clue in the name!)
    from scratch to demonstrate mistaken techniques.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与以前的配方中相同的`content`目录，但我们将从头开始创建一个新的`insecure_server.js`文件（名字中有提示！）来演示错误的技术。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Our previous static file recipes tend to use `path.basename` to acquire a route,
    but this flat levels all request. If we accessed `localhost:8080/foo/bar/styles.css`,
    our code would take `styles.css` as the `basename` and deliver `content/styles.css`
    to us. Let's make a subdirectory in our `content` folder, call it `subcontent`,
    and move our `script.js` and `styles.css` files into it. We'd need to alter our
    script and link tags in `index.html:`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前的静态文件配方倾向于使用`path.basename`来获取路由，但这会使所有请求都处于平级。如果我们访问`localhost:8080/foo/bar/styles.css`，我们的代码会将`styles.css`作为`basename`，并将`content/styles.css`交付给我们。让我们在`content`文件夹中创建一个子目录，称之为`subcontent`，并将我们的`script.js`和`styles.css`文件移动到其中。我们需要修改`index.html`中的脚本和链接标签：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can use the `url` module to grab the entire `pathname`. So let''s include
    the `url` module in our new `insecure_server.js` file, create our HTTP server,
    and use `pathname` to get the whole requested path:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`url`模块来获取整个`pathname`。所以让我们在我们的新的`insecure_server.js`文件中包含`url`模块，创建我们的HTTP服务器，并使用`pathname`来获取整个请求路径：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we navigate to `localhost:8080`, everything works great. We''ve gone multilevel,
    hooray. For demonstration purposes, a few things have been stripped out from previous
    recipes (such as `fs.exists)`, but even with them, the following code presents
    the same security hazards:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到`localhost:8080`，一切都很顺利。我们已经多级了，万岁。出于演示目的，一些东西已经从以前的配方中剥离出来（比如`fs.exists`），但即使有了它们，以下代码也会呈现相同的安全隐患：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we have our server''s code. An attacker could also access `/etc/passwd`
    with a few attempts at guessing its relative path:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们服务器的代码。攻击者也可以通过几次猜测相对路径来访问`/etc/passwd`：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In order to test these attacks, we have to use curl or another equivalent because
    modern browsers will filter these sorts of requests. As a solution, what if we
    added a unique suffix to each file we wanted to serve and made it mandatory for
    the suffix to exist before the server coughs it up? That way, an attacker could
    request `/etc/passwd` or our `insecure_server.js` because they wouldn''t have
    the unique suffix. To try this, let''s copy the `content` folder and call it `content-pseudosafe`,
    and rename our files to `index.html-serve, script.js-serve`, and `styles.css-serve`.
    Let''s create a new server file and name it `pseudosafe_server.js`. Now all we
    have to do is make the `-serve` suffix mandatory:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些攻击，我们必须使用curl或其他等效工具，因为现代浏览器会过滤这些请求。作为解决方案，如果我们为要提供的每个文件添加一个唯一的后缀，并且要求服务器在提供文件之前必须存在这个后缀，会怎么样？这样，攻击者就可以请求`/etc/passwd`或我们的`insecure_server.js`，因为它们没有唯一的后缀。为了尝试这个方法，让我们复制`content`文件夹，并将其命名为`content-pseudosafe`，并将我们的文件重命名为`index.html-serve`、`script.js-serve`和`styles.css-serve`。让我们创建一个新的服务器文件，并将其命名为`pseudosafe_server.js`。现在我们只需要让`-serve`后缀成为必需的：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For feedback purposes, we'll also include some `404` handling with the help
    of `fs.exists`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 出于反馈目的，我们还将使用`fs.exists`来处理一些`404`。
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So let''s start our `pseudosafe_server.js` file and try out the same exploit:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动我们的`pseudosafe_server.js`文件，并尝试相同的攻击：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We've used the `-i` argument so that curl will output the headers. What's the
    result? A `404`, because the file it is actually looking for is `../insecure_server.js-serve`,
    which doesn't exist. So what's wrong with this method? Well it's inconvenient
    and prone to error. However, more importantly an attacker can still work around
    it!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`-i`参数，以便curl输出头部。结果是什么？一个`404`，因为它实际上正在寻找的文件是`../insecure_server.js-serve`，这个文件不存在。这种方法有什么问题？嗯，它很不方便，容易出错。然而，更重要的是，攻击者仍然可以绕过它！
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And voila! There's our server code again. The solution to our problem is `path.normalize`,
    which cleans up our `pathname` before it gets to `fs.readFile`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后！这是我们的服务器代码。我们问题的解决方案是`path.normalize`，它可以在`fs.readFile`之前清理我们的`pathname`。
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Prior recipes haven't used `path.normalize`, yet they're still relatively safe.
    `path.basename` gives us the last part of the path, so any leading relative directory
    pointers (../) are discarded, thus preventing the directory traversal exploit.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例没有使用`path.normalize`，但它们仍然相对安全。`path.basename`给出了路径的最后部分，因此任何前导的相对目录指针（../）都被丢弃，从而防止了目录遍历的利用。
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here we have two filesystem exploitation techniques: the **relative directory
    traversal** and **poison null byte attacks**. These attacks can take different
    forms, such as in a POST request or from an external file. They can have different
    effects. For example, if we were writing to files instead of reading them, an
    attacker could potentially start making changes to our server. The key to security
    in all cases is to validate and clean any data that comes from the user. In `insecure_server.js`,
    we pass whatever the user requests to our `fs.readFile` method. This is foolish
    because it allows an attacker to take advantage of the relative path functionality
    in our operating system by using `../`, thus gaining access to areas that should
    be off limits. By adding the `-serve` suffix, we didn''t solve the problem. We
    put a plaster on it which can be circumvented by the poison null byte. The key
    to this attack is `%00`, which is a URL hex code for the null byte. In this case,
    the null byte blinds Node to the `../insecure_server.js` portion, but when the
    same null byte is sent through to our `fs.readFile` method, it has to interface
    with the kernel. However, the kernel gets blinded to the `index.html` part. So
    our code sees `index.html` but the read operation sees `../insecure_server.js`.
    This is known as null byte poisoning. To protect ourselves, we could use a `regex`
    statement to remove the `../` parts of the path. We could also check for the null
    byte and spit out a `400 Bad Request` statement. However, we don''t need to, because
    `path.normalize` filters out the null byte and relative parts for us.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两种文件系统利用技术：**相对目录遍历**和**毒空字节攻击**。这些攻击可以采取不同的形式，比如在POST请求中或来自外部文件。它们可能会产生不同的影响。例如，如果我们正在写入文件而不是读取它们，攻击者可能会开始对我们的服务器进行更改。在所有情况下，安全性的关键是验证和清理来自用户的任何数据。在`insecure_server.js`中，我们将用户请求传递给我们的`fs.readFile`方法。这是愚蠢的，因为它允许攻击者利用我们操作系统中相对路径功能，通过使用`../`来访问本应禁止访问的区域。通过添加`-serve`后缀，我们没有解决问题。我们只是贴了一张创可贴，这可以被毒空字节绕过。这种攻击的关键是`%00`，这是空字节的URL十六进制代码。在这种情况下，空字节使Node对`../insecure_server.js`部分变得盲目，但当同样的空字节通过我们的`fs.readFile`方法发送时，它必须与内核进行接口。然而，内核对`index.html`部分变得盲目。所以我们的代码看到的是`index.html`，但读取操作看到的是`../insecure_server.js`。这就是空字节毒害。为了保护自己，我们可以使用`regex`语句来删除路径中的`../`部分。我们还可以检查空字节并输出`400
    Bad Request`语句。但我们不需要，因为`path.normalize`已经为我们过滤了空字节和相对部分。
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's further delve into how we can protect our servers when it comes to serving
    static files.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨在提供静态文件时如何保护我们的服务器。
- en: Whitelisting
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 白名单
- en: 'If security was an extreme priority, we could adopt a strict whitelisting approach.
    In this approach, we would create a manual route for each file we are willing
    to deliver. Anything not on our whitelist would return `404`. We can place a `whitelist`
    array above `http.createServer` as shown in the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全性是一个极端重要的优先事项，我们可以采用严格的白名单方法。在这种方法中，我们将为我们愿意交付的每个文件创建一个手动路由。不在我们的白名单上的任何内容都将返回`404`。我们可以在`http.createServer`上方放置一个`whitelist`数组，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside of our `http.createServer` callback, we''ll put an `if` statement to
    check if the requested path is in the `whitelist` array:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`http.createServer`回调中，我们将放置一个`if`语句来检查请求的路径是否在`whitelist`数组中：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That's it. We can test this by placing a file `non-whitelisted.html` in our
    `content` directory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们可以通过在我们的`content`目录中放置一个文件`non-whitelisted.html`来测试这个。
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding command will return `404` because `non-whitelisted.html` isn't
    on whitelist.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将返回`404`，因为`non-whitelisted.html`不在白名单上。
- en: Node-static
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Node-static
- en: '[https://github.com/joyent/node/wiki/modules#wiki-web-frameworks-static](https://github.com/joyent/node/wiki/modules#wiki-web-frameworks-static)
    has a list of static file server modules available for different purposes. It''s
    a good idea to ensure that a project is mature and active before relying on it
    to serve your content. Node-static is a well developed module with built-in caching.
    It''s also compliant with the RFC2616 HTTP standards specification. This defines
    how files should be delivered over HTTP. Node-static implements all the essentials
    discussed in this chapter and more besides. This piece of code is slightly adapted
    from the node-static Github page at [https://github.com/cloudhead/node-static:](https://github.com/cloudhead/node-static)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/joyent/node/wiki/modules#wiki-web-frameworks-static](https://github.com/joyent/node/wiki/modules#wiki-web-frameworks-static)列出了可用于不同目的的静态文件服务器模块的列表。在依赖它来提供您的内容之前，确保项目是成熟和活跃的是一个好主意。Node-static是一个开发完善的模块，内置缓存。它还符合RFC2616
    HTTP标准规范。这定义了如何通过HTTP传递文件。Node-static实现了本章讨论的所有基本要点，以及更多。这段代码略有改动，来自node-static的Github页面[https://github.com/cloudhead/node-static:](https://github.com/cloudhead/node-static)'
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding code will interface with the `node-static` module to handle server-side
    and client-side caching, use streams to deliver content, and filter out relative
    requests and null bytes, among other things.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将与`node-static`模块进行接口，以处理服务器端和客户端缓存，使用流来传递内容，并过滤相对请求和空字节，等等。
- en: See also
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Preventing cross-site request forgery* discussed In [Chapter 7](ch07.html
    "Chapter 7. Implementing Security, Encryption, and Authentication"), *Implementing
    Security, Encryption, and Authentication*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*防止跨站点请求伪造*在[第7章](ch07.html "第7章。实施安全、加密和身份验证")中讨论，*实施安全、加密和身份验证*'
- en: '*Setting up an HTTPS web server* discussed In [Chapter 7](ch07.html "Chapter 7. Implementing
    Security, Encryption, and Authentication"), *Implementing Security, Encryption,
    and Authentication*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置HTTPS Web服务器 在[第7章](ch07.html "第7章。实施安全、加密和认证") *实施安全、加密和认证*
- en: '*Deploying to a server environment* discussed In [Chapter 10](ch10.html "Chapter 10. Taking
    It Live"), *Taking It Live*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到服务器环境 在[第10章](ch10.html "第10章。上线") *上线*
- en: '*Cryptographic password sashing* discussed In [Chapter 7](ch07.html "Chapter 7. Implementing
    Security, Encryption, and Authentication"), *Implementing Security, Encryption,
    and Authentication*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码哈希加密 在[第7章](ch07.html "第7章。实施安全、加密和认证") *实施安全、加密和认证*
