- en: Modules and Toolkits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和工具包
- en: Now that we have reviewed what Node.js's new features are, and now that we know
    what a microservice is, it's time to see what tools or modules we can we to create
    one. We'll review a couple of options and build a more or less simple microservice
    so that we can point out advantages and disadvantages for each approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了Node.js的新特性，并且我们知道什么是微服务，是时候看看我们可以使用哪些工具或模块来创建一个微服务了。我们将回顾几个选项，并构建一个简单或复杂的微服务，以便我们可以指出每种方法的优缺点。
- en: 'We''ll look at different modules:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看不同的模块：
- en: '**Seneca**: A microservice toolkit based on property matching'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Seneca**：基于属性匹配的微服务工具包'
- en: '**Hydra**: A package that bundles a couple of modules to help you resolve many
    microservices concerns, such as distribution and monitoring'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hydra**：一个打包了几个模块的包，可以帮助你解决许多微服务问题，如分发和监控'
- en: Seneca
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 塞涅卡
- en: 'Let''s look at framework called Seneca which was designed to help you develop
    message-based microservices. It has two distinct characteristics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看名为Seneca的框架，它被设计用来帮助你开发基于消息的微服务。它有两个显著的特点：
- en: '**T****ransport agnostic**: Communication and message transport is separated
    from your service logic and it''s easy to swap transports'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T** **ransport agnostic**：通信和消息传输与你的服务逻辑分离，并且很容易更换传输方式'
- en: '**Pattern matching**: Messages are JSON objects and each function exposes what
    sort of messages they can handle based on object properties'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式匹配**：消息是JSON对象，每个函数都根据对象属性暴露它们可以处理的消息类型'
- en: 'What is really interesting about Seneca is its ability to expose functions
    based on object patterns. Let''s start by installing Seneca:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 塞涅卡真正有趣的是它根据对象模式暴露函数的能力。让我们先安装塞涅卡：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For now, let''s forget the transport and create a producer and consumer in
    the same file. Let''s look at an example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们忘记传输，并在同一文件中创建生成者和消费者。让我们看看一个示例：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We first include the `seneca` module and create a new service. We then expose
    a producer function that matches an object that has `math` equal to `sum`. This
    means that any request object to the service that has the property `math` and
    that is equal to `sum` will be passed to this function. This function accepts
    two arguments. The first, which we called `msg`, is the request object. The second
    argument, `next`, is the callback that the function should invoke when finished
    or in case of an error. In this particular case, we're expecting an object that
    also has a `values` list and we're returning the sum of all values by using the
    `reduce` method that's available in arrays. Finally, we invoke `act`, expecting
    it to consume our producer. We pass an object with the `math` equal to `sum` and
    a list of `values`. Our producer should be invoked and should return the sum.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含`seneca`模块并创建一个新的服务。然后我们暴露一个匹配对象，该对象具有等于`sum`的`math`属性。这意味着任何具有`math`属性且等于`sum`的请求对象都将传递给这个函数。这个函数接受两个参数。第一个，我们称之为`msg`，是请求对象。第二个参数，`next`，是函数完成或发生错误时应该调用的回调。在这种情况下，我们期望一个也具有`values`列表的对象，并且我们通过使用数组中可用的`reduce`方法来返回所有值的总和。最后，我们调用`act`，期望它消费我们的生成者。我们传递一个具有等于`sum`的`math`属性和值列表的对象。我们的生成者应该被调用并返回总和。
- en: 'Assuming you have this code in `app.js`, if you run this in the command line,
    you should see something like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将此代码放在`app.js`中，如果你在命令行中运行它，你应该会看到类似以下内容：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's try and replicate our previous stack example. This time, instead of having
    the consumer and producer in the code, we'll use `curl` as the consumer, just
    like we did previously.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试复制我们之前的堆栈示例。这次，我们不再在代码中使用消费者和生成者，而是使用`curl`作为消费者，就像我们之前做的那样。
- en: 'First, we need to create our `service`. We do that, as we''ve seen before,
    by loading Seneca and creating an instance:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的`service`。正如我们之前所看到的，我们通过加载Seneca并创建一个实例来完成这个任务：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We explicitly tell it that we don''t care about logging for now. Now, let''s
    create a variable to hold our stack:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确表示我们现在不关心日志记录。现在，让我们创建一个变量来保存我们的堆栈：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then create our producers. We''ll create three of them: one for adding an
    element to the stack, called push; one to remove the last element from the stack,
    called pop; and one to see the stack, called get. Both push and pop will return
    the final stack result. The third producer is just a helper function so that we
    can see the stack without performing any operations.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的生产者。我们将创建三个：一个用于向栈中添加元素，称为`push`；一个用于从栈中移除最后一个元素，称为`pop`；一个用于查看栈，称为`get`。`push`和`pop`都将返回最终的栈结果。第三个生产者只是一个辅助函数，这样我们就可以在不执行任何操作的情况下查看栈。
- en: 'To add elements to the stack, we define:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要向栈中添加元素，我们定义：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a few new things to see here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新内容需要查看：
- en: We defined our pattern as a string instead of an object. This action string
    is a shortcut to the extended object definition.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将模式定义为字符串而不是对象。这个动作字符串是扩展对象定义的快捷方式。
- en: We explicitly indicate that we need a value.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们明确指出需要一个值。
- en: We also indicate that we don't care what the value is (remember, this is pattern
    matching).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还表明我们不在乎值是什么（记住，这是模式匹配）。
- en: 'We now define a simpler function to remove the last element of the `stack`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义一个更简单的函数来移除`stack`的最后一个元素：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This one is simpler as we don't need a value, we're just removing the last one.
    We're not addressing the case where the stack is empty already. An empty array
    won't throw an exception, but perhaps, in a real scenario, you would want another
    response.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作比较简单，因为我们不需要一个值，我们只是移除最后一个元素。我们不会处理栈已经为空的情况。一个空数组不会抛出异常，但在实际场景中，你可能希望得到另一个响应。
- en: 'Our third function is even simpler as we just return the `stack`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个函数甚至更简单，我们只是返回`stack`：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we need to tell our `service` to listen for messages. The default
    transport is HTTP and we just indicate port `3000` as we did in our previous examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要告诉我们的`service`监听消息。默认传输是HTTP，我们只需像之前示例中那样指定端口`3000`：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Wrap all this code in a file and try it out. You can use curl or just try it
    in your browser. Seneca won''t differentiate between HTTP verbs in this case.
    Let''s begin by checking our `stack`. The URL describes an action (`/act`) we
    want to perform and the query parameter gets converted to our pattern:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些代码放入一个文件中并尝试运行。你可以使用curl或者直接在浏览器中尝试。在这种情况下，Seneca不会区分HTTP动词。让我们先检查我们的`stack`。URL描述了一个我们想要执行的操作（`/act`），查询参数被转换成我们的模式：
- en: '![](img/5f272cfa-7bc7-445b-b506-7494b9365918.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f272cfa-7bc7-445b-b506-7494b9365918.png)'
- en: 'We can then try adding the value `one` to our `stack` and see the final `stack`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以尝试向我们的`stack`添加值`one`并查看最终的`stack`：
- en: '![](img/2fd2bb60-ddae-48aa-a36f-8150eb30f4f6.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fd2bb60-ddae-48aa-a36f-8150eb30f4f6.png)'
- en: 'We can continue and add the value `two` and see how the `stack` grows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续添加值`two`并查看`stack`的增长情况：
- en: '![](img/9765d76f-b004-469f-9582-fbeebe6a33df.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9765d76f-b004-469f-9582-fbeebe6a33df.png)'
- en: 'If we then try to remove the last element, we''ll see the `stack` shrinking:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试移除最后一个元素，我们会看到`stack`缩小：
- en: '![](img/5d18267f-0b27-4d44-acc9-af7b2ef87ed1.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d18267f-0b27-4d44-acc9-af7b2ef87ed1.png)'
- en: As in Express, Seneca also has middleware that you can install and use. In this
    case, the middleware is called plugins. By default, Seneca includes a number of
    core plugins for transport, and both HTTP and TCP transports are supported. There
    are more transports available, such as **Advanced Message Queuing Protocol** (**AMQP**)
    and Redis.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Express中一样，Seneca也有可以安装和使用的中间件。在这种情况下，中间件被称为插件。默认情况下，Seneca包含了一些核心插件用于传输，包括HTTP和TCP传输都得到了支持。还有更多的传输方式可用，例如**高级消息队列协议**（**AMQP**）和Redis。
- en: 'There are also storage plugins for persistent data and there''s support for
    several database servers, both relational and non-relational. Seneca exposes an
    **o****bject-relational mapping** (**ORM**)-like interface to manage data entities.
    You can manipulate entities and use a simple storage in development and then move
    to production storage later on. Let''s see a more complex example of this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有用于持久数据的存储插件，并且支持多种数据库服务器，包括关系型和非关系型。Seneca提供了一个类似对象关系映射（**ORM**）的接口来管理数据实体。你可以操作实体，并在开发中使用简单的存储，然后稍后迁移到生产存储。让我们看看一个更复杂的例子：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Just run this new code and we''ll see how this code behaves by making some
    requests to test it. First, let''s see how our `stack` is by requesting it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行这段新代码，我们就可以通过发送一些请求来测试它的行为。首先，让我们通过请求来查看我们的`stack`：
- en: '![](img/8562bd7e-ce15-4e5f-ab0e-afd983610ba2.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8562bd7e-ce15-4e5f-ab0e-afd983610ba2.png)'
- en: 'Nothing different. Now, let''s add the value `one` to the `stack`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么不同。现在，让我们向`stack`添加值`one`：
- en: '![](img/5e8c79dc-6ed3-4ccd-a429-7bc3cdcf5621.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e8c79dc-6ed3-4ccd-a429-7bc3cdcf5621.png)'
- en: 'Well, we haven''t received the final `stack`. We could, but instead we changed
    the service to return the exact item that was added. It''s actually a good way
    to confirm what we just did. Let''s add another one:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们还没有收到最终的`堆栈`。我们可以这样做，但相反，我们更改了服务以返回刚刚添加的确切项目。这实际上是一种确认我们刚刚做了什么的不错的方法。让我们再添加一个：
- en: '![](img/d0a0b98b-9518-4224-8496-916a3097902b.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0a0b98b-9518-4224-8496-916a3097902b.png)'
- en: 'Again, it returns the value we just added. Now, let''s see how our stack is:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，它返回了我们刚刚添加的值。现在，让我们看看我们的堆栈：
- en: '![](img/c5189716-9284-48e2-b6bc-a82ebaa670cc.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5189716-9284-48e2-b6bc-a82ebaa670cc.png)'
- en: Our `stack` now has our two values. Now comes one big difference compared with
    the previous code. We're using *entities*, an API exposed by Seneca, which helps
    you store and manipulate data objects using a simple abstraction layer similar
    to an ORM, or to people who are familiar with Ruby, an `ActiveRecord`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`堆栈`现在有了我们的两个值。现在与之前的代码相比有一个很大的不同。我们正在使用 Seneca 提供的 *entities* API，它帮助您使用类似于
    ORM 的简单抽象层或对于熟悉 Ruby 的人来说，类似于`ActiveRecord`来存储和操作数据对象。
- en: 'Our new code, instead of just popping out the last value, removes a value we
    indicate. So, let''s remove the value `one` instead of `two`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新代码，而不是仅仅弹出最后一个值，而是移除我们指定的值。所以，让我们移除值`one`而不是`two`：
- en: '![](img/bf96bdff-3fd7-4ba4-b597-8a39a1e10cf1.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf96bdff-3fd7-4ba4-b597-8a39a1e10cf1.png)'
- en: 'Success! We removed exactly one item. Our code will remove all items from the
    `stack` that match the value (it has no duplication check so you can have repeated
    items). Let''s try to remove the same item again:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们恰好移除了一个项目。我们的代码将移除所有匹配值的`堆栈`中的项目（它没有重复检查，因此您可以有重复的项目）。让我们再次尝试移除相同的项：
- en: '![](img/98a3dabd-f496-4b1a-a365-6e95ee918e80.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98a3dabd-f496-4b1a-a365-6e95ee918e80.png)'
- en: 'No more items match `one`, so it didn''t remove anything. We can now check
    our `stack` and confirm that we still have the value `two`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多项匹配`one`，所以它没有移除任何东西。我们现在可以检查我们的`堆栈`并确认我们仍然有值`two`：
- en: '![](img/8ddfe232-1446-4940-9a93-75ed0c3d7690.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ddfe232-1446-4940-9a93-75ed0c3d7690.png)'
- en: Correct! And, as a bonus, you can stop and restart the code and your stack will
    still have the value `two`. That's because we're using the JSON file store plugin.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正确！而且，作为额外奖励，您可以停止和重新启动代码，而您的堆栈仍然具有值`two`。这是因为我们正在使用 JSON 文件存储插件。
- en: When testing using Chrome or any other browser, be aware that sometimes, browsers
    make requests in advance while you're typing. Because we already tested our first
    code, which had the same URL addresses, the browser might duplicate requests and
    you might get a stack with duplicated values without knowing why. This is why.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Chrome 或任何其他浏览器进行测试时，请注意，有时，当您在输入时，浏览器会提前发出请求。因为我们已经测试了我们的第一个代码，它有相同的 URL
    地址，浏览器可能会重复请求，您可能会得到一个包含重复值的堆栈，而不知道为什么。这就是原因。
- en: Hydra
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hydra
- en: Let's get back to Express. As you've seen before, it's a rock-solid layer on
    top of the `http` module. Although it adds an important base layer in the somewhat
    raw module, it still lacks many features you need to make a good microservice.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 Express。如您之前所见，它是在`http`模块之上的一个坚如磐石的层。尽管它在某种程度上原始的模块中添加了一个重要的基础层，但它仍然缺少您需要制作良好微服务的大多数功能。
- en: As there are lots of plugins out there to extend Express, it can be hard to
    pick a useful list for us to use.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于市面上有大量的插件可以扩展 Express，因此挑选一个对我们有用的插件列表可能会有些困难。
- en: 'After picking the right list, you''ll still need to make other decisions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择正确的列表后，您仍然需要做出其他决定：
- en: How can I distribute my service with multiple instances?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何使用多个实例分发我的服务？
- en: How can the service be discovered?
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务如何被发现？
- en: How can I monitor whether my service is running properly?
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何监控我的服务是否正常运行？
- en: Enter Hydra, a framework that facilitates building distributed microservices.
    Hydra leverages the power of Express and helps you create microservices or communicate
    with microservices.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 Hydra，这是一个促进构建分布式微服务的框架。Hydra 利用 Express 的力量，并帮助您创建微服务或与微服务进行通信。
- en: 'It will, out of the box, enable you to:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它将默认启用您：
- en: Do service registration and service discovery, allowing your microservices to
    discover and be discoverable
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行服务注册和服务发现，使您的微服务能够被发现并可被发现。
- en: Communicate with microservices and load balance communication between multiple
    instances, taking care of failed instances and automatically rerouting requests
    to other running instances
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与微服务进行通信，并在多个实例之间负载均衡通信，处理失败的实例，并自动将请求重定向到其他正在运行的实例。
- en: Monitor instances, checking whether the microservice is available and operating
    normally
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控实例，检查微服务是否可用且正常运行
- en: 'Unlike the other modules we''ve reviewed so far, Hydra has a dependency that
    is not installable directly using the NPM. Hydra uses Redis to accomplish its
    goal. Look for information on the Redis website at [https://redis.io/](https://redis.io/)
    to install it on your operating system before continuing. If you have macOS and
    use Homebrew, type the following to install `redis`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前审查的其他模块不同，Hydra 有一个依赖项不能直接使用 NPM 安装。Hydra 使用 Redis 来实现其目标。在继续之前，请查找 Redis
    网站上的信息 [https://redis.io/](https://redis.io/) 在你的操作系统上安装它。如果你有 macOS 并使用 Homebrew，输入以下命令来安装
    `redis`：
- en: '![](img/dfdb0104-7906-4919-ad18-48f4839b8d5d.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dfdb0104-7906-4919-ad18-48f4839b8d5d.png)'
- en: 'Now, let''s make sure `redis` has successfully started:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保 `redis` 已成功启动：
- en: '![](img/df9525cb-5e2b-44ca-9948-288dff2a4572.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df9525cb-5e2b-44ca-9948-288dff2a4572.png)'
- en: 'After that, we need to install Hydra command-line tools:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要安装 Hydra 命令行工具：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now need to configure the connection to Redis. We do this by creating a
    configuration. Type in the command and follow the instructions. If you installed
    it locally (or used the preceding instructions), you should answer something similar
    to the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要配置与 Redis 的连接。我们通过创建一个配置文件来完成这个操作。输入命令并遵循指示。如果你是在本地安装的（或使用了前面的指示），你应该回答类似于以下截图的内容：
- en: '![](img/130a1c25-01fb-4389-8c74-a56a66fd5fcc.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/130a1c25-01fb-4389-8c74-a56a66fd5fcc.png)'
- en: 'Now, let''s create a very simple microservice, just to see what the workflow
    is like. Hydra has a scaffolding tool using `yeoman`. To create a service, type
    the following command and follow the instructions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个非常简单的微服务，只是为了看看工作流程是什么样的。Hydra 使用 `yeoman` 工具进行脚手架搭建。要创建一个服务，输入以下命令并遵循指示：
- en: '![](img/3d00ff9e-fda1-423a-a9bc-edda341e9ba6.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d00ff9e-fda1-423a-a9bc-edda341e9ba6.png)'
- en: 'On the name of the service, just type hello. Just hit *Enter* to the rest of
    the questions to use the defaults. In the end, enter the folder that was created
    and install the dependencies:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务名称处，只需输入 hello。对于其余问题，按 *Enter* 使用默认值。最后，进入创建的文件夹并安装依赖项：
- en: '![](img/11d89f4f-7424-42a5-8cdd-01f69cc1d427.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11d89f4f-7424-42a5-8cdd-01f69cc1d427.png)'
- en: 'The service is now ready to start. You might have already seen the instructions
    when scaffolding the service. Let''s start the service:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 服务现在已准备好启动。你可能已经在搭建服务时看到了这些指示。让我们启动服务：
- en: '![](img/b745a179-c4e5-461a-abbc-4a6bf684b7f6.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b745a179-c4e5-461a-abbc-4a6bf684b7f6.png)'
- en: 'As we can see from the preceding screenshot, the service has started and has
    been attached to a local IP (192.168.1.108) and port (45394). Open up the folder
    in your code editor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，服务已启动，并附加到本地 IP（192.168.1.108）和端口（45394）。在你的代码编辑器中打开该文件夹：
- en: '![](img/774328d2-8714-43d2-8db1-85995dce6e95.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/774328d2-8714-43d2-8db1-85995dce6e95.png)'
- en: 'You''ll see a file in the base folder called `hello-service.js`, which has
    the service routes inside it. You''ll find the `/v1/hello` route, which points
    to another file in `routes/hello-v1-routes.js`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在基本文件夹中看到一个名为 `hello-service.js` 的文件，其中包含服务路由。你可以找到指向 `routes/hello-v1-routes.js`
    中另一个文件的 `/v1/hello` 路由：
- en: '![](img/ebd2d928-eeac-4e32-a563-343dbc72f82f.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ebd2d928-eeac-4e32-a563-343dbc72f82f.png)'
- en: 'Inside that file, you''ll see the response to that route. Now, let''s jump
    to a web browser and see if it''s up and running:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个文件中，你会看到对该路由的响应。现在，让我们跳转到网页浏览器，看看它是否启动并运行：
- en: '![](img/8b40b263-ed17-48dd-bcab-979f1083384d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b40b263-ed17-48dd-bcab-979f1083384d.png)'
- en: What we saw in the file is inside the result property of the JSON response.
    We just deployed our first Hydra microservice without writing a single line of
    code!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文件中看到的内容位于 JSON 响应的 result 属性中。我们只是部署了第一个 Hydra 微服务，而没有写一行代码！
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've just covered a range of different modules and toolkits to help develop
    microservices. From patterns in Seneca, to the Hydra bundle, many approaches are
    available.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了一系列不同的模块和工具包，以帮助开发微服务。从 Seneca 的模式到 Hydra 包，有许多方法可供选择。
- en: They all target different audiences and fill different needs. I would advise
    you to experiment with some of them to help you make a better choice instead of
    just picking one.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它们针对不同的受众群体，满足不同的需求。我建议你尝试其中的一些，以帮助你做出更好的选择，而不仅仅是选择一个。
- en: Let's dig into some of these tools and start creating a more complete microservice.
    In the next chapter, we'll be making a useful microservice, covering different
    use cases, while we develop a fully functional and distributed microservice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究这些工具，并开始创建一个更完整的微服务。在下一章中，我们将构建一个有用的微服务，涵盖不同的用例，同时开发一个功能齐全且分布式的微服务。
