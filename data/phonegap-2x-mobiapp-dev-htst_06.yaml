- en: Chapter 6. Say Cheese!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 拍照吧！
- en: There was a time, not so long ago, when cameras on mobile phones didn't exist.
    And then there was a time when those cameras were so bad, they were really only
    useful for snapping *reminder shots*, for example, snapping a picture of a store
    item that you wanted to look up more information about later. But now so many
    mobile devices have excellent cameras that can take fantastic pictures. In this
    project, we'll look at how to use these cameras in our own app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，手机上还没有摄像头。然后又有一段时间，那些摄像头非常糟糕，它们实际上只适用于拍一些提醒照片，例如，拍下你想要稍后查找更多信息商店物品的照片。但现在，许多移动设备都配备了优秀的摄像头，可以拍摄出令人惊叹的照片。在这个项目中，我们将探讨如何在我们的应用程序中使用这些摄像头。
- en: What do we build?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要构建什么？
- en: In this Project, we're going to build an app called `Imgn`. It won't be a complete
    app; all it will do is take pictures and let you view them. But there are a lot
    of things you could add on to it, such as sharing functionality or creative filters
    that could change the image after it was taken.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将构建一个名为`Imgn`的应用程序。它不会是一个完整的应用程序；它只会拍照并允许你查看它们。但你可以添加很多其他功能，比如分享功能或创意滤镜，这些功能可以在拍照后改变图像。
- en: What this app will do, however, is show the process for taking a picture via
    the device's camera and also show the process for accessing the user's photo album
    so that images can be imported to the app. Like with our previous apps, we'll
    have full file management, so images can be deleted, copied, and renamed at will.
    We'll accomplish this a little differently though; we'll be implementing something
    seen in a lot of photo apps – the image grid.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个应用程序将展示通过设备摄像头拍照的过程，以及访问用户照片库以导入图像的过程。就像我们之前的应用程序一样，我们将拥有完整的文件管理功能，因此可以随意删除、复制和重命名图像。不过，我们将以不同的方式实现这一点；我们将实现许多照片应用程序中看到的功能——图像网格。
- en: What does it do?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它能做什么？
- en: Ultimately, the app will let you take a picture or import one from your photo
    library, and then view it. While it sounds simple enough, the app has full image
    management, which means we'll go over how to delete, copy, and rename images as
    well. In most photo apps, there is usually the option to delete images in batches
    (say you took several blurry photos and don't want them anymore), and deleting
    images in batches with the `File` API can be a bit tricky.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这个应用程序将允许你拍照或从你的照片库中导入一张照片，然后查看它。虽然听起来很简单，但这个应用程序具有完整的图像管理功能，这意味着我们将介绍如何删除、复制和重命名图像。在大多数照片应用程序中，通常有批量删除图像的选项（比如说你拍了几张模糊的照片，不再需要它们），而使用`File`
    API批量删除图像可能有点棘手。
- en: Most photo apps also use what is called the image grid, which is a grid of small
    image thumbnails that let the user see several images at once on the screen and
    scroll through them all. This grid isn't terribly hard to implement; it's really
    just a series of thumbnails that wrap using good-old HTML. Where this idea falls
    apart is that there's no functionality in PhoneGap to create a thumbnail from
    an image; which means that the images displayed as a thumbnail are really the
    full-sized image, they're just scaled down to a small thumbnail. This scaling
    introduces a lot of performance problems, and as a workaround, we'll be using
    the HTML5 `Canvas` tag to actually get some of that performance back.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数照片应用程序也使用所谓的图像网格，这是一个小图像缩略图的网格，允许用户在屏幕上同时查看多张图像并滚动浏览它们。这个网格并不难实现；它实际上只是一系列使用古老的HTML进行包装的缩略图。这个想法失败的地方在于，PhoneGap中没有创建缩略图的功能；这意味着作为缩略图显示的图像实际上是全尺寸图像，它们只是被缩小到一个小缩略图。这种缩放引入了许多性能问题，作为解决方案，我们将使用HTML5的`Canvas`标签来恢复一些性能。
- en: Why is it great?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它很棒？
- en: We'll be covering a lot of technologies in this project, all of which are critical
    if you're going to make a performant photo app. We'll look at how to take a picture
    and how to import one from the user's photo library – both of which are critically
    important in a large number of apps. Social apps use this kind of functionality
    quite often, but there are other apps that do so as well.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将涵盖许多技术，如果你想要制作一个性能良好的照片应用程序，这些技术都是至关重要的。我们将探讨如何拍照以及如何从用户的照片库中导入照片——这两者在大量应用程序中都是至关重要的。社交应用程序经常使用这种功能，但还有其他应用程序也这样做。
- en: As always, we'll be covering file management, which is never that easy. In this
    project, we'll be introduced to the idea of a wrapper for the `File` API, which
    should make dealing with files just a little bit easier. Ultimately, though, we
    still have to get a bit tricky when dealing with files, so be prepared to twist
    your brain inside out.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将涵盖文件管理，这从来都不是那么容易。在这个项目中，我们将介绍`File` API包装器的概念，这应该会使处理文件变得稍微容易一些。然而，最终我们仍然在处理文件时需要变得有些巧妙，所以请准备好让你的大脑变得错综复杂。
- en: 'We''ll be working with something that''s gaining a lot of traction in the mobile
    web world: the **HTML5 Canvas**. It''s been used to great effect in desktop websites,
    but only now have our mobile devices started to become fast enough to use Canvas
    in interesting ways.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在移动网络世界中越来越受欢迎的东西：**HTML5 Canvas**。它已经在桌面网站上得到了很好的应用，但现在我们的移动设备才开始足够快，能够以有趣的方式使用Canvas。
- en: How are we going to do it?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何实现？
- en: 'As in all our previous tasks, we''re going to approach this using our tried-and-true
    approach:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的所有任务一样，我们将采用我们经过验证的方法来处理这个问题：
- en: Designing the user interface and the look and feel
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用户界面和外观
- en: Designing the data model
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计数据模型
- en: Implementing the documents view
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现文档视图
- en: Implementing the image view
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现图像视图
- en: What do I need to get started?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我需要准备些什么才能开始？
- en: In order to get started, you'll need to create the project as you've done in
    each project so far. You should also take a look at the resources directory in
    the project files for this project. We've got several icon files that you might
    find interesting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，你需要创建项目，就像你之前在每一个项目中做的那样。你还应该查看项目文件中的资源目录。我们有一些图标文件，你可能觉得很有趣。
- en: Designing the user interface and the look and feel
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计用户界面和外观
- en: Conceptually, this is a pretty simple app from a user interface perspective.
    If you've seen a photo app on a phone, chances are you already know where we're
    headed. Even so, let's design a mockup, and then flesh that out a bit to come
    up with the assets we'll need for our look and feel.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户界面角度来看，这个应用程序在概念上非常简单。如果你在手机上看过照片应用程序，你很可能已经知道我们将要走向何方。即便如此，让我们设计一个原型，然后对其进行一些扩展，以确定我们需要的外观和感觉资产。
- en: Getting on with it
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动
- en: 'Let''s examine the mockups for this project:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个项目的原型：
- en: '![Getting on with it](img/9403OS_06_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![开始行动](img/9403OS_06_01.jpg)'
- en: The left-most screen is simply a grid (1) of all the images that the user has
    added to the app. These images might be taken with the camera, or they might have
    been imported in various ways.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最左侧的屏幕只是一个网格（1），显示了用户添加到应用程序中的所有图片。这些图片可能是用相机拍摄的，也可能是以各种方式导入的。
- en: In the navigation bar, we'll have a fancy title – photo apps, for some reason,
    seem to call for something less utilitarian than some of our apps have been lately.
    We'll also be including an **Edit** button that can also change state to a **Done**
    button (2). This button indicates the current state; if a user taps **Edit**,
    the images will become selectable for batch operations such as a *delete* operation.
    In this mode, the button switches to **Done**. If the user taps the button again,
    they will exit selection mode, and the button will indicate **Edit** once again.
    Any selections the user made will be discarded.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航栏中，我们将有一个花哨的标题——不知何故，照片应用程序似乎需要比我们最近的一些应用程序更少的功能性。我们还将包括一个可以改变状态为**完成**按钮（2）的**编辑**按钮。此按钮表示当前状态；如果用户点击**编辑**，图片将变为可选择的，以便进行批量操作，如**删除**操作。在此模式下，按钮切换到**完成**。如果用户再次点击按钮，他们将退出选择模式，按钮将再次指示**编辑**。用户所做的任何选择都将被丢弃。
- en: It's been a little while since we had a toolbar (3), too. We'll show various
    icons here depending upon the current editing state. If we're not in selection
    mode (the navigation bar button shows **Edit**), we'll show a camera and a film
    roll. These two icons will allow interaction with the camera and photo album,
    respectively. If we are in the selection mode (the navigation bar button shows
    **Done**), and have at least one image selected, we'll show a trashcan icon and
    a person icon indicating *delete* and *share*, respectively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们有了工具栏（3）以来已经有一段时间了。我们将根据当前的编辑状态显示各种图标。如果我们不在选择模式（导航栏按钮显示**编辑**），我们将显示一个相机和一个胶卷。这两个图标将允许与相机和相册进行交互。如果我们处于选择模式（导航栏按钮显示**完成**），并且至少选择了一张图片，我们将显示一个垃圾桶图标和一个人物图标，分别表示**删除**和**分享**。
- en: If we aren't in a selection mode, the user can tap an image to see it enlarged.
    At this point, we'll move to the right-most screen seen in the preceding screenshot.
    The navigation bar will have a **Back** button (4). The image will be displayed
    in the content area (5). If the image is larger than the screen, it will be able
    to scroll. In the toolbar (6), we'll provide a way to delete the image, or to
    share it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不在选择模式中，用户可以点击一个图像来查看它放大。此时，我们将移动到前一个截图中最右侧的屏幕。导航栏将有一个**返回**按钮（4）。图像将在内容区域（5）显示。如果图像比屏幕大，它将可以滚动。在工具栏（6）中，我们将提供删除图像或分享图像的方式。
- en: 'Now that we''ve gone over the mockups, let''s flesh things out a bit more.
    Here''s the final result after doing some work in our favorite graphics editor:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了原型，让我们更详细地展开。这是在我们最喜欢的图形编辑器中做一些工作后的最终结果：
- en: '![Getting on with it](img/9403_06_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_06_02.jpg)'
- en: While the basic elements of all our apps are present, it's clear that they've
    been spruced up quite a bit. The navigation bar has been given a fresh coat of
    paint and a playful font for the title of the app. The toolbar has also been given
    a nice upgrade to a darker color.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们所有应用的基本元素都存在，但很明显，它们已经被大大改进了。导航栏被涂上了新的油漆，并为应用的标题使用了俏皮的字体。工具栏也被升级到了更深的颜色。
- en: Each image will be given a simple white border and a drop shadow to help it
    stand out from the background. These effects are easily achieved using CSS, so
    we won't need images for this particular part.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图像都会被赋予一个简单的白色边框和阴影，以帮助它从背景中脱颖而出。这些效果可以通过CSS轻松实现，因此我们不需要为这个特定部分使用图像。
- en: For the rest of the app though, it's a different story. We'll have four icons,
    namely, a camera, a film roll, a trashcan, and a person. These icons will always
    reside in the toolbar and can be tapped to perform an action. The navigation bar
    and toolbar itself will also need to be a graphical asset. These would be quite
    difficult to render using CSS alone (especially since there is some subtle *noise*
    in both to give them some texture). Finally, the title itself needs to be an image
    asset since the font we've used may not be available on the device. About the
    only thing other than the photos themselves on this workup that we can do without
    images is the **Edit** button on the navigation bar. We'll be using the same CSS
    we've been using to accomplish the display of the button.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于应用的其他部分，情况就不同了。我们将有四个图标，分别是相机、胶卷、垃圾桶和人物。这些图标将始终位于工具栏中，并且可以点击执行操作。导航栏和工具栏本身也需要是图形资源。仅使用CSS渲染这些图标将非常困难（特别是由于它们都有一些细微的*噪声*来增加它们的纹理）。最后，标题本身也需要是图像资源，因为我们使用的字体可能不在设备上可用。在这个工作中，除了照片本身之外，我们唯一可以不使用图像完成的事情就是导航栏上的**编辑**按钮。我们将使用我们一直在使用的相同CSS来完成按钮的显示。
- en: The second screen of this app, the image view, isn't mocked up here – all it
    would be is a large image in the middle with the rest of the design unchanged.
    The two icons would be the trashcan and the person in the toolbar, but that's
    about all that's different.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的第二屏，即图像查看器，在这里没有制作原型——它将只是一个中间的大图像，其余的设计保持不变。工具栏中的两个图标将是垃圾桶和人物，但这就是所有不同的地方。
- en: Now that we've determined what needs to be a graphical asset, it's time to splice
    them out of our mockup. You can see the final result in the `www/images` directory
    of our project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了需要成为图形资源的部分，那么就是时候从我们的原型中提取它们了。您可以在我们项目的`www/images`目录中看到最终结果。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We made the title its own image separate from the navigation bar. This is because
    the navigation bar is free to tile and we wouldn't want the title to tile along
    with it!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将标题制作成独立于导航栏的图像。这是因为导航栏可以自由拼接，我们不想让标题与它一起拼接！
- en: What did we do?
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task we've mocked up the user interface and detailed how everything
    works together. We've also fleshed out the mockup so that we were able to generate
    the image assets we'll need for the implementation of the app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们制作了用户界面并详细说明了所有部分是如何协同工作的。我们还完善了原型，以便我们能够生成应用实现所需的图像资源。
- en: Designing the data model
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计数据模型
- en: For the first time, our data model is going to be remarkably simple. There's
    really not a lot to keep track of here. In a way, our data model is exactly replicated
    by what is in persistent storage—the images themselves.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库模型将首次非常简单。这里实际上没有太多需要跟踪的内容。从某种意义上说，我们的数据模型与持久存储中的内容完全相同——即图像本身。
- en: Getting on with it
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: Just like in prior tasks, we do have a document collection model that reads
    all the images in persistent storage and lets our document view interact with
    them. There has been almost no change in this particular model (save for the name),
    so we won't cover it here.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的任务中一样，我们确实有一个文档集合模型，它读取持久存储中的所有图像，并允许我们的文档视图与之交互。这个特定模型几乎没有任何变化（除了名称之外），所以在这里我们不会对其进行介绍。
- en: What we will cover is not quite a data model, but still important. When a user
    taps the **Edit** button, we want them to be able to select multiple pictures
    for a batch operation (such as delete). To do this, we need to keep track of which
    images are selected, and which ones aren't.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的内容并不完全是一个数据模型，但仍然很重要。当用户点击**编辑**按钮时，我们希望他们能够选择多张图片进行批量操作（例如删除）。为了做到这一点，我们需要跟踪哪些图像被选中，哪些没有被选中。
- en: 'The model itself is so simple that it doesn''t actually have its own code file.
    It''s just an array combined with a single property that indicates if we are in
    selection mode or not. This is what it looks like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型本身非常简单，实际上并没有自己的代码文件。它只是一个数组，结合一个表示我们是否处于选择模式的单个属性。它看起来是这样的：
- en: '`inSelectionMode`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inSelectionMode`'
- en: '`selectedItems[]`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectedItems[]`'
- en: That's it. Dreadfully simple, yes, but it is important to understand how this
    works to provide a selection mechanism.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。非常简单，是的，但理解它是如何工作的对于提供选择机制非常重要。
- en: When the app begins, we won't be in the selection mode, so `inSelectionMode`
    will be `false`. If the user taps **Edit**, we change this to `true`, and change
    the color of the borders around all the images to a light yellow color. The color
    itself really doesn't matter; it's done simply to show that the device responded
    to the tap and that all the images are currently not selected (we'll use red to
    indicate selected images). This also means the `selectedItems` array will also
    be blank.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用开始时，我们不会处于选择模式，所以`inSelectionMode`将是`false`。如果用户点击**编辑**，我们将将其改为`true`，并将所有图像周围的边框颜色改为浅黄色。颜色本身并不重要；这样做只是为了表明设备对点击做出了响应，并且所有图像目前都是未选择的（我们将使用红色来表示已选择的图像）。这也意味着`selectedItems`数组也将是空的。
- en: There are two ways we could approach how to keep track of which images are selected.
    We could set up an array that had as many items as images on the screen. This
    would work, but chances are pretty good that most of these images would remain
    unselected throughout the selection operation. Unless the user is intending to
    delete all the images (which, while possible, is something that doesn't happen
    very often), there's really no need to waste all that space.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以跟踪哪些图像被选中。我们可以设置一个数组，其项目数量与屏幕上的图像数量相同。这可以工作，但可能性很大，大多数这些图像在整个选择操作中都将保持未选择状态。除非用户有意删除所有图像（虽然这是可能的，但这种情况并不常见），否则真的没有必要浪费那么多空间。
- en: Instead, we'll keep a track of these selections using a `sparse` array; each
    item in the array will instead point to the image that is selected. That means,
    if we select three images, the array only needs to be three items long. Any image
    not contained within the array can be considered to be unselected, and those that
    are in the array are considered selected.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用一个`稀疏`数组来跟踪这些选择；数组中的每个项目将指向所选的图像。这意味着，如果我们选择了三幅图像，数组只需要三个项目长。任何不在数组中的图像都可以被认为是未选择的，而那些在数组中的被认为是已选择的。
- en: This does present a few difficulties in how to manage this array, though. Thankfully
    it's not too hard to get one's head around.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实在如何管理这个数组方面带来了一些困难。幸运的是，理解这一点并不太难。
- en: Let's imagine that the user taps on image 3 while in selection mode. First we'll
    change the border color to something striking (red, in our example) to indicate
    that we *heard* the user. Then we'll use the `push` method of the array to add
    the image to the selection. At this point our array contains exactly one item
    with the value of `3`. The user goes on to select a few more items, and say we
    finally end up with an array of `3`, `1`, `9`. This means images 1, 3, and 9 are
    selected. (Notice that the order simply doesn't matter.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设用户在选择模式下点击了图像3。首先，我们将边框颜色改为引人注目的颜色（在我们的例子中是红色）以表明我们“听到了”用户。然后，我们将使用数组的`push`方法将图像添加到选择中。此时，我们的数组中恰好有一个值为`3`的项目。用户继续选择一些其他项目，最终我们可能得到一个包含`3`、`1`、`9`的数组。这意味着图像1、3和9被选中。（请注意，顺序并不重要。）
- en: Now, let's imagine that the user taps image 1 again. It's already selected,
    so we should unselect it. To do this, we need to remove the second item of the
    array so that we're left with an array of `3`, `9`. JavaScript makes it really
    easy to do this, though the names of the methods might not be immediately obvious.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设用户再次点击图像1。它已经选中了，所以我们应该取消选中它。为了做到这一点，我们需要从数组中删除第二个元素，这样我们就剩下了一个包含`3`、`9`的数组。虽然这些方法的名称可能不是立即显而易见的，但JavaScript确实使这个过程变得非常简单。
- en: First, we'll use `indexOf` to find where `1` is in the array. Once we've found
    the location, we'll use `splice()` to tell JavaScript to remove that particular
    item. The `splice()` method can be used for really cool array operations, but
    it also does item removal particularly well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`indexOf`来找到`1`在数组中的位置。一旦我们找到了位置，我们将使用`splice()`来告诉JavaScript删除那个特定的项。`splice()`方法可以用于非常酷的数组操作，但它也特别擅长进行项删除。
- en: With these three methods on the array, we can track the selection state of any
    image. If we can't find the image in the array, we know it isn't selected. If
    we do find the image in the array, we know it is selected. And that's really all
    we need to know.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组上有这三种方法后，我们可以跟踪任何图像的选择状态。如果我们无法在数组中找到图像，我们知道它没有被选中。如果我们确实在数组中找到了图像，我们知道它已被选中。而这实际上就是我们需要知道的所有内容。
- en: When the user is done with their selection, they have the option to do something
    with it. This is where things can get a little dicey. Let's say they want to delete
    several images at once. The `File` API is a bit painful, as we've seen from previous
    tasks, and now we have to figure out a way to call it several times in a row.
    In other programming languages with synchronous file operations, we'd use a simple
    `for` loop, but we don't have that luxury with the `File` API provided by PhoneGap,
    since it is an asynchronous API.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户完成他们的选择后，他们可以选择对它们进行一些操作。这里可能会有一些困难。假设他们想一次性删除多张图片。`File` API有点痛苦，正如我们从之前的任务中看到的，现在我们必须想出一种方法来连续多次调用它。在其他具有同步文件操作的语言中，我们会使用简单的`for`循环，但我们在PhoneGap提供的`File`
    API中没有这样的便利，因为它是一个异步API。
- en: The other thing the user can do is end their selection, which they can do by
    tapping on **Done**. When this occurs, we will change all the image borders back
    to white to indicate that we've heard the user, and to also indicate that any
    selected images are now unselected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以做的另一件事是结束他们的选择，他们可以通过点击**完成**来做到这一点。当这种情况发生时，我们将将所有图像边框变回白色，以表明我们已经听到了用户的要求，并且也表明任何已选图像现在已取消选择。
- en: What did we do?
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we've examined a simple data model that keeps track of selections
    in an array. We've discussed how we'll use `push()`, `indexOf()`, and `splice()`
    to maintain this array, and how all this will appear to the user.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们检查了一个简单的数据模型，该模型跟踪数组中的选择。我们讨论了我们将如何使用`push()`、`indexOf()`和`splice()`来维护这个数组，以及所有这些将如何对用户显示。
- en: Since this model is so simple, we've not bothered to give it a separate file;
    we'll make it a part of the document view that we'll implement next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个模型非常简单，我们没有费心给它一个单独的文件；我们将将其作为我们将在下一个实现中实现的文档视图的一部分。
- en: Implementing the document view
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现文档视图
- en: While there are portions of our document view that are the same as or similar
    to the previous projects, there is also quite a bit that is different. The view
    has to handle taking pictures, importing them, and then dealing with the user
    selecting several pictures at once in advance of a batch operation. This means
    there is quite a bit going on, even if the underlying model is pretty simple.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的文档视图中有一些部分与之前的项目相同或类似，但也有相当多的不同。视图必须处理拍照、导入图片，并在批量操作之前处理用户一次性选择多张图片。这意味着即使底层模型相当简单，也有很多事情要做。
- en: 'Here''s how the view will look, first for iOS:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是视图的外观，首先是iOS版本：
- en: '![Implementing the document view](img/9403_06_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![实现文档视图](img/9403_06_03.jpg)'
- en: 'For Android, the view will be as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，视图如下所示：
- en: '![Implementing the document view](img/9403_06_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![实现文档视图](img/9403_06_04.jpg)'
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Our view is located in `www/views/documentsView.html` in the files for this
    project if you want to follow along.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟进，我们的视图位于此项目的文件`www/views/documentsView.html`中。
- en: Getting on with it
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动
- en: 'As always, let''s start with the HTML portion of our view:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，让我们从视图的HTML部分开始：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most of this code is similar to the document views in previous projects. The
    `div` element `documentsView_title` has an in-line style to bring the title image
    down a bit; otherwise, it would align to the top of the navigation bar. The rest
    of the changes rest in the `div` classed `toolBar` where we have four icons defined,
    namely the photo (`photo_64.png`) icon, the film (`film_64.png`) icon, the trash
    (`trash_64.png`) icon, and the person (`man_64.png`) icon. As these icons aren't
    going to change based on localization, it is safe to put them here rather than
    define the content in `initializeView()`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分与之前项目中的文档视图相似。`div` 元素 `documentsView_title` 有一个内联样式，将标题图片向下移动一点；否则，它将与导航栏的顶部对齐。其余的更改都在
    `div` 类名为 `toolBar` 的部分，其中定义了四个图标，分别是照片（`photo_64.png`）图标、电影（`film_64.png`）图标、垃圾箱（`trash_64.png`）图标和人物（`man_64.png`）图标。由于这些图标不会根据本地化而改变，因此在这里放置它们而不是在
    `initializeView()` 中定义内容是安全的。
- en: 'Next, let''s look at our template that we will use for each image:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们将为每张图片使用的模板：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is probably the simplest template we've had in quite some time. All that
    is contained within is a `canvas` tag with a unique `id` value and a `click` handler.
    Don't let the simplicity fool you that we use a `canvas` tag rather than an `img`
    tag means that we have to have code that draws images to the `canvas` tag later
    on. The gains, however, that using `canvas` brings is worth this extra code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我们很长时间以来最简单的模板了。其中只包含一个具有唯一 `id` 值的 `canvas` 标签和一个 `click` 处理器。不要被使用 `canvas`
    标签而不是 `img` 标签的简单性所欺骗，这意味着我们稍后必须编写代码将图像绘制到 `canvas` 标签上。然而，使用 `canvas` 带来的好处是值得这段额外代码的。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We have given the `canvas` tag a specific `width` and `height`; this gives it
    a defined shape until we can later override it with the actual image width and
    height. This is simply to make a smoother transition from an unloaded image to
    a loaded image.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经给 `canvas` 标签指定了特定的 `width` 和 `height`；这给它一个定义的形状，直到我们可以稍后用实际图像的宽度和高度覆盖它。这只是为了使从未加载的图像到已加载的图像的过渡更加平滑。
- en: 'With the HTML out of the way, let''s take a look at the code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 部分处理完毕后，让我们看看代码：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Most of these properties just used are the ones we''re familiar with from previous
    projects. However, there are three that are important to this particular project,
    mentioned as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分这些仅使用的属性都是我们从之前的项目中熟悉的。然而，有三个属性对于这个特定项目非常重要，如下所述：
- en: '`inSelectionMode`: This indicates if the user has placed us into the selection
    mode. In the selection mode, the user can select multiple images for a batch operation
    (such as a delete operation), whereas outside of the selection mode, tapping the
    image results in viewing it larger.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inSelectionMode`：这表示用户是否已将我们置于选择模式。在选择模式下，用户可以选择多张图像进行批量操作（如删除操作），而在选择模式之外，点击图片将导致查看其大图。'
- en: '`selectedItems`: This is an array, as discussed in the previous task, it contains
    the selected images. This is a *sparse* array, as it only contains those images
    actually selected and not those that are unselected.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectedItems`：这是一个数组，如前一个任务中讨论的，它包含选定的图像。这是一个 *稀疏* 数组，因为它只包含实际选定的图像，而不包含未选定的图像。'
- en: '`globalAlert`: This is a placeholder for an alert. We''ll use this when doing
    a batch delete. If the user happens to delete several images at once, it might
    take a few seconds, and so we want to be able to display an alert over the action
    going on underneath.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`globalAlert`：这是一个占位符，用于显示警告。当进行批量删除时，我们将使用它。如果用户一次性删除多张图片，可能需要几秒钟，因此我们希望能够在下面的操作上显示一个警告。'
- en: 'After this, we have the initialization code for the view given as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们有视图的初始化代码，如下所示：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So far, not much is different than in our previous projects. In the preceding
    code, we've added text and code to the **Edit** button – if tapped, we'll call
    `toggleSelection()`, which will switch the selection modes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，与我们的前几个项目没有太大区别。在前面的代码中，我们向 **编辑** 按钮添加了文本和代码——如果被点击，我们将调用 `toggleSelection()`，这将切换选择模式。
- en: 'Next, we''ll define the handlers for each icon on the toolbar using the following
    code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下代码片段定义工具栏上每个图标的处理程序：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We've not attached a touch listener to the **Share** button for now. Refer to
    [Project 2](ch02.html "Chapter 2. Let's Get Social!"), *Let's Get Social!* if
    you want to implement sharing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还没有将触摸监听器附加到 **分享** 按钮上。如果您想实现分享功能，请参考 [项目 2](ch02.html "第二章：让我们社交吧！")，*让我们社交吧！*
- en: Something important to note is that the last two icons are set to a `display`
    of `none`, which means they won't show up on the screen. This is because they
    only apply to selected images and there's no need to display them if they can't
    do anything. When we change selection modes and at least one image is selected,
    we'll re-display them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是，最后两个图标被设置为`display`为`none`，这意味着它们不会显示在屏幕上。这是因为它们仅适用于选中图片，如果它们无法执行任何操作，就没有必要显示它们。当我们更改选择模式并且至少选中了一张图片时，我们将重新显示它们。
- en: 'With the view initialized, let''s look at `toggleSelection()`. This is the
    handler for when the user taps the **Edit** button:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图初始化后，让我们看看`toggleSelection()`。这是当用户点击**编辑**按钮时的处理程序：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first thing we need to do (given the name of the method) is to switch selection
    modes. We''ll take advantage of how Booleans work to simply switch the value:
    if it is `false` coming in, we''ll switch it to `true`, and vice versa.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据方法名称，我们首先需要做的事情是切换选择模式。我们将利用布尔值的工作原理来简单地切换值：如果它进来时是`false`，我们将将其切换为`true`，反之亦然。
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As seen in the preceding code, if we're now in the selection mode, we'll alter
    the **Edit** button to display **Done** so that the user knows how to end the
    selection mode. Next we empty the `selectedItems` array so that any previous selections
    are wiped out. Since we're using the image borders to indicate selection state,
    we need to iterate through each image and set its border to the unselected state
    (light yellow). Finally, we hide all the icons in the toolbar as none of them
    are immediately applicable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，如果我们现在处于选择模式，我们将更改**编辑**按钮以显示**完成**，以便用户知道如何结束选择模式。接下来，我们将清空`selectedItems`数组，以便删除任何之前的选中项。由于我们使用图片边框来指示选择状态，我们需要遍历每个图片并将它的边框设置为未选择状态（浅黄色）。最后，我们将隐藏工具栏中的所有图标，因为它们都不立即适用。
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On the other hand, if we're ending a selection, we need to switch the **Done**
    button back to **Edit** and then turn all the image borders back to white. We
    also have to re-enable the first two icons (camera and import) since they now
    apply to our current state. The last two icons are hidden (since they may have
    been visible just prior to ending the selection).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们正在结束选择，我们需要将**完成**按钮切换回**编辑**，然后将所有图片边框恢复为白色。我们还需要重新启用前两个图标（相机和导入），因为它们现在适用于我们的当前状态。最后两个图标被隐藏（因为它们可能在结束选择之前是可见的）。
- en: 'Switching the selection mode, of course, isn''t sufficient to actually implement
    selection, so let''s look at `documentContainerTapped()`, which is called every
    time an image is tapped:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，切换选择模式本身不足以实际实现选择，让我们看看`documentContainerTapped()`，它每次点击图片时都会被调用：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Tapping on an image means different things based on whether or not we''re in
    the selection mode. If we are in the selection mode, tapping on it should either
    select the image (if not previously selected), unselect the image (if previously
    selected), and then update the toolbar; this is done using the following code
    snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 点击图片的含义取决于我们是否处于选择模式。如果我们处于选择模式，点击它应该选择图片（如果之前未选择），取消选择图片（如果之前已选择），然后更新工具栏；这是通过以下代码片段完成的：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To determine if the image is selected, we use `indexOf()`. If the image is in
    the array, we know the image is currently selected; therefore, tapping on it should
    deselect it and we change the border color to light yellow and remove the image
    from the `selectedItems` array using the `splice()` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定图片是否被选中，我们使用`indexOf()`。如果图片在数组中，我们知道图片当前被选中；因此，点击它应该取消选中，我们将边框颜色更改为浅黄色，并使用`splice()`方法从`selectedItems`数组中删除图片。
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the image isn't found in the `selectedItems` array, we know we need to select
    it, so we change the border color (red) and add it to the array via the `push()`
    method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图片在`selectedItems`数组中找不到，我们知道我们需要选择它，因此我们更改边框颜色（红色）并通过`push()`方法将其添加到数组中。
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Regardless of whether or not we selected or deselected the image, we need to
    handle the toolbar. If we've selected at least one image, we'll display the *delete*
    and *share* icons. If the selection ever becomes empty, we'll hide them again.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是否选中或取消选中了图片，我们都需要处理工具栏。如果我们至少选中了一张图片，我们将显示**删除**和**分享**图标。如果选择变为空，我们将再次隐藏它们。
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we're not in the selection mode, tapping on the image should move to the
    image view so that we can see it at full size. We push the view first, then after
    `500` ms we actually tell the view what image to display. This may seem odd at
    first (normally we'd do this in the opposite order), but it is intended to smooth
    the transition to the new view. Images obtained from the camera can be quite large,
    and loading that image takes some time. If it is loading at the same time as the
    transition, the transition will stutter, making the app feel slower than it really
    is. So instead, we wait until the transition will be over, and then tell the view
    to load the image.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不在选择模式中，点击图片应该将视图移动到图片查看器，以便我们可以看到其全尺寸。我们首先推送视图，然后在 `500` 毫秒后，我们实际上告诉视图要显示的图片。这乍一看可能有些奇怪（我们通常会按相反的顺序这样做），但这是为了平滑过渡到新视图。从相机获取的图片可能相当大，加载这张图片需要一些时间。如果它在过渡的同时加载，过渡将会卡顿，使应用程序感觉比实际运行得慢。因此，我们等待过渡完成，然后告诉视图加载图片。
- en: With selection out of the way, let's look at how we take and import pictures.
    Essentially these actions are the same thing, only the source of the image is
    different. Of course, to the user, they are very different. One involves taking
    a picture (framing the picture, waiting for the right moment, pressing the shutter
    release, and so on) while the other only involves the user searching for an image
    already on their camera. But to the app, they are technically the same thing with
    different image sources. Because of this, we'll have three methods, the first
    two to determine what the image source is, and the final one to do the actual
    work of taking or importing the image.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择完成后，让我们看看如何拍摄和导入图片。本质上，这些操作是相同的事情，只是图片的来源不同。当然，对于用户来说，它们是非常不同的。一个涉及拍照（构图、等待合适的时机、按下快门等），而另一个只涉及用户在相机中搜索已存在的图片。但对于应用程序来说，它们在技术上是一样的，只是图片来源不同。正因为如此，我们将有三个方法，前两个用于确定图片来源，最后一个用于实际拍摄或导入图片。
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First up, taking a picture. We'll call `doPicture()` with the source of `CAMERA`,
    which indicates that the picture is to be obtained from the device camera. The
    user interface will vary based on the platform and device, but we don't need to
    worry about that as PhoneGap provides the interface for us.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是拍照。我们将使用 `doPicture()` 函数，并传入 `CAMERA` 作为源，这表示图片将从设备相机获取。用户界面会根据平台和设备的不同而有所变化，但我们不需要担心这一点，因为
    PhoneGap 已经为我们提供了接口。
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To import a picture, we call `doPicture()` with the source of `PHOTOLIBRARY`.
    This indicates that the image should come from the user's own library of images.
    Again, the user interface will vary based on the platform and device, but our
    app doesn't have to worry about that as PhoneGap will handle all the details for
    us.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入图片，我们使用 `PHOTOLIBRARY` 作为源调用 `doPicture()` 函数。这表示图片应来自用户的图像库。同样，用户界面会根据平台和设备的不同而有所变化，但我们的应用程序不需要担心这一点，因为
    PhoneGap 会为我们处理所有细节。
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are several layers of callbacks going on in this function, each of which
    relies on the previous step being executed correctly. Let's look at the outer
    layer for now.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中存在多层回调，每一层都依赖于前一步的正确执行。现在我们先看看外层回调。
- en: 'To take an image, or import one, we call `navigator.camera.getPicture()` with
    three parameters: the `success` function, the `failure` function, and the options.
    The options in our function are at the very end of the method. Here''s what each
    one means:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要拍摄图片或导入图片，我们调用 `navigator.camera.getPicture()` 函数，并传入三个参数：`success` 函数、`failure`
    函数和选项。我们函数中的选项位于方法的最后。以下是每个选项的含义：
- en: '`quality`: This is the compression used for the image. We use `50` because
    it is a good tradeoff between quality and file size. Furthermore, some devices
    have problems handling images from the camera with a quality higher than 50\.
    (Typically, on devices that exhibit problems with a quality larger than 50, the
    app would crash. Not a good end-user experience.)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quality`：这是图像的压缩方式。我们使用 `50`，因为它在质量和文件大小之间提供了一个良好的平衡。此外，一些设备处理来自相机的质量高于 `50`
    的图片时可能会出现问题。（通常，在质量大于 `50` 的设备上，应用程序可能会崩溃。这不是一个好的用户体验。）'
- en: '`destinationType`: It determines the destination. There are two options here:
    we can either request a base64-encoded string which represents the image data,
    or we can request the file location where the image was saved. We''re requesting
    the file location instead of base64, simply due to ease of handling and memory
    concerns. (Base64 is at least double the file size of the image.)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destinationType`: 它决定了目的地。这里有两种选择：我们可以请求一个表示图像数据的base64编码字符串，或者我们可以请求图像保存的文件位置。我们请求文件位置而不是base64，主要是因为处理方便和内存考虑。（Base64至少是图像文件大小的两倍。）'
- en: '`sourceType`: It determines where the image should come from. If set to `CAMERA`,
    it will get the image from the camera. If `PHOTOLIBRARY`, it will get it from
    the user''s library. Note that we take the incoming parameter here, which is what
    `takePicture()` and `importPicture()` send to us.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sourceType`: 它决定了图像应该来自哪里。如果设置为`CAMERA`，它将从相机获取图像。如果设置为`PHOTOLIBRARY`，它将从用户的库中获取。请注意，我们在这里接收传入的参数，这是`takePicture()`和`importPicture()`发送给我们的。'
- en: '`encodingType`: This is the image format, generally either JPEG or PNG. PNGs
    are great for images with a lot of pixel repetition (such as diagrams), and are
    lossless. For photography, however, PNGs would be too large. Instead, we''ll use
    JPEGs. Though lossy, they won''t be so large as to be unwieldy.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encodingType`: 这是图像格式，通常是JPEG或PNG。PNG非常适合具有大量像素重复的图像（如图表），并且是无损的。然而，对于摄影来说，PNG会太大。因此，我们将使用JPEG。虽然是有损的，但它们不会大到难以处理。'
- en: '`mediaType`: The camera can often be used to take video instead of a still
    image. In this case, all we want is a still image, so we send `PICTURE`. This
    also limits the available formats when importing an image. Without this, a user
    could import a video instead, which we can''t handle.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mediaType`: 相机通常可以用来拍摄视频而不是静态图像。在这种情况下，我们想要的只是一个静态图像，所以我们发送`PICTURE`。这也限制了导入图像时可用格式。如果没有这个，用户可能会导入一个视频，而我们无法处理。'
- en: '`correctOrientation`: This parameter can be used to correct the orientation
    used to take an image. For example, if the phone was rotated and we didn''t correct
    the orientation, the image might appear sideways or upside-down. With this enabled,
    we get the image right-side up.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`correctOrientation`: 这个参数可以用来纠正拍照时使用的方向。例如，如果手机被旋转了，而我们没有纠正方向，图像可能会显示为侧放或颠倒。启用此功能后，我们得到的是正立的图像。'
- en: '`saveToPhotoAlbum`: This can be either `true` or `false`. If `true`, the image
    taken by the camera will be saved to the photo album and our app. If `false`,
    only our app receives the image. While we use `false` here, it is really a matter
    of choice. Does it make sense for the image to be saved to the album as well as
    your app? The answer to that question depends on your app and its target audience.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saveToPhotoAlbum`: 这可以是`true`或`false`。如果为`true`，相机拍摄的图像将被保存到相册和我们的应用中。如果为`false`，只有我们的应用接收图像。虽然我们在这里使用`false`，但这实际上是一个选择问题。将图像保存到相册以及您的应用中是否有意义？对这个问题的答案取决于您的应用及其目标受众。'
- en: 'If we move into the `success` function for `navigator.camera.getPicture()`,
    we see this line:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进入`navigator.camera.getPicture()`的`success`函数，我们会看到这一行：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The file given to us by the camera may be in a temporary spot (especially on
    iOS), so we first move the file to a more permanent location. We're using the
    `PKFILE FILE` API wrapper to do this, which we'll discuss later on in this task.
    Using `doc://` here ensures that the file is written to persistent storage, and
    using the Unix Time (which is milliseconds since 1st January, 1970) ensures a
    nearly unique filename. (It's frankly impossible for the user to take two images
    in quick enough succession to end up on the same millisecond.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 相机给我们的文件可能位于临时位置（尤其是在iOS上），所以我们首先将文件移动到一个更永久的位置。我们使用`PKFILE FILE` API包装器来完成此操作，我们将在本任务的稍后部分讨论。使用`doc://`确保文件被写入持久存储，使用Unix时间（自1970年1月1日起的毫秒数）确保文件名几乎唯一。（用户不可能在足够短的时间内连续拍摄两张图像，以至于它们落在同一个毫秒上。）
- en: When the move is complete, we call another `success` function, which simply
    reloads the available documents, which in our case redisplays the image grid with
    the new image in it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动完成时，我们调用另一个`success`函数，该函数简单地重新加载可用的文档，在我们的例子中，它重新显示包含新图像的图像网格。
- en: Along the way we also have `failure` functions where we have the `alerts`. These
    are important if, for some reason, the camera fails to take the picture, or an
    import goes badly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程中，我们还有`failure`函数，其中包含`alerts`。如果相机由于某种原因无法拍照或导入出现问题，这些是很重要的。
- en: 'Next up, let''s handle deleting multiple pictures at once (deleting a single
    picture is done the same way we''ve deleted documents in past projects):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理一次性删除多张图片的情况（删除单张图片的方式与我们在过去项目中删除文档的方式相同）：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First we ask the user if they really want to delete the selected images as the
    action is unrecoverable. If they do, we call `deleteSelectedPictures()` after
    a short delay. This delay is to give enough time for the first alert to go away
    before `deleteSelectedPictures()` puts up its own alert.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们询问用户是否真的想要删除选定的图片，因为这个操作是不可恢复的。如果他们同意，我们将在短暂的延迟后调用`deleteSelectedPictures()`。这个延迟是为了确保在`deleteSelectedPictures()`显示自己的警告之前，第一个警告已经消失。
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method requires us to switch our brain inside-out a bit, since there's
    something missing we might normally expect—a `for` loop. Because the `FILE` APIs
    are all asynchronous, we can't loop around them, we need to be able to ensure
    all the API requests are finished before we tell the user we're done.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法需要我们稍微转换一下思维方式，因为有一些我们通常期望存在的东西缺失——一个`for`循环。因为`FILE` API都是异步的，我们不能在它们周围循环，我们需要确保在告诉用户我们已完成之前，所有的API请求都已经完成。
- en: So instead, we use something akin to recursion. It's not true recursion, since
    the function calls aren't nested within each other, but it is close enough to
    be a bit painful on our neurons.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用类似递归的方法。这不是真正的递归，因为函数调用不是嵌套的，但它足够接近，以至于对我们的神经元来说有点痛苦。
- en: We start by checking the length of the `selectedItems` array. If it has any
    images in it, we know we need to delete one. If it has nothing in it, we know
    we've finished the job and can clean everything up.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查`selectedItems`数组的长度。如果其中包含图片，我们知道我们需要删除一张。如果数组为空，我们知道我们已经完成了工作，可以清理一切。
- en: If we need to remove an image, we call `PKFILE.removeFile` with the full path
    to the image. We also pass along our current method to the `success` function.
    This means that once the image is successfully deleted, we'll be called again
    to repeat the process until we've deleted all images in the `selectedImages` array.
    The process will only stop when a failure occurs or when the `selectedImages`
    array is empty.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要删除一个图片，我们调用`PKFILE.removeFile`函数，并传入图片的完整路径。同时，我们也将当前方法传递给`success`函数。这意味着一旦图片成功删除，我们会被再次调用以重复此过程，直到`selectedImages`数组中的所有图片都被删除。只有在发生错误或`selectedImages`数组为空时，这个过程才会停止。
- en: When the `selectedImages` array is empty, we need to clean things up. We clear
    the alert we created when starting the deletion process, and we reload all our
    available documents.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当`selectedImages`数组为空时，我们需要清理一些东西。我们清除在开始删除过程时创建的警告，并重新加载所有可用的文档。
- en: 'With all this talk about reloading the document listing, perhaps we should
    go into that a bit:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论重新加载文档列表的过程中，也许我们应该稍微深入一点：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first portion of this function is identical to previous projects, so we''ll
    skip ahead to the interesting bits in the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第一部分与之前的工程相同，所以我们直接跳到下面代码片段中有趣的部分：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Just like in our last project, we have a long press gesture attached to each
    image. When a long press is received, we'll display a menu allowing the user to
    delete, copy, or rename the image.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我们的上一个项目中一样，我们给每个图片附加了一个长按手势。当接收到长按手势时，我们会显示一个菜单，允许用户删除、复制或重命名图片。
- en: 'The more interesting bit is this next part, where we actually render the image''s
    thumbnail onto each `canvas`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的部分是下面的部分，我们在这里实际上将图片的缩略图渲染到每个`canvas`上：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, for each available document, we create a new `Image` object. We assign
    an `index` to a property of the object as well, because we'll need it later when
    the image is finished loading.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对于每个可用的文档，我们创建一个新的`Image`对象。同时，我们也会给对象的属性分配一个`index`，因为当图片加载完成后，我们还需要用到它。
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We then attach a method to the `onload` event of the image. This is where we'll
    render the image to the canvas.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们给图片的`onload`事件附加一个方法。这就是我们将图片渲染到画布上的地方。
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing we do after the image is loaded is to determine the size of
    the thumbnail. Since we want to maintain the aspect ratio, we have to know the
    image's width and height, something we can do by using `this.height` and `this.width`.
    First we assume the image will fit into a width of `84` pixels, and determine
    the height using the ratio of the height to the width. But on some images this
    might result in them being taller than `84` pixels, and so we redo the calculation
    for these images based on a height of `84` pixels.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图像加载后，我们首先确定缩略图的大小。由于我们希望保持宽高比，我们必须知道图像的宽度和高度，这可以通过使用`this.height`和`this.width`来实现。首先我们假设图像将适合`84`像素的宽度，并使用高度与宽度的比例来确定高度。但有些图像可能会比`84`像素高，因此我们基于`84`像素的高度重新计算这些图像的尺寸。
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once the thumbnail's width and height are determined, we can figure out the
    top and left so that the image is nicely centered within its 84 x 84 container.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了缩略图的宽度和高度，我们就可以计算出顶部和左侧的位置，使图像在其84 x 84的容器中居中。
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, we obtain the canvas and set its width and height to the newly calculated
    values. Notice that we set both the CSS and the HTML width and height; this is
    important because the size of the canvas may actually be different on displays
    with different pixel ratios. (On a retina display the canvas is actually twice
    as large, but the CSS compresses it back to the original size visually.)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取画布并将其宽度和高度设置为新的计算值。请注意，我们设置了CSS和HTML的宽度和高度；这是因为不同像素比率的显示上画布的实际大小可能不同。（在视网膜显示屏上，画布实际上大了一倍，但CSS将其压缩回原始大小以供视觉使用。）
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we obtain a context from the canvas. We then scale the canvas to the
    pixel ratio so that we can continue to use point-based pixels on devices where
    each point is more than one pixel. Then we turn off image smoothing; this is to
    help speed up the next line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从画布中获取一个上下文。然后我们将画布缩放到像素比例，这样我们就可以在每一点超过一个像素的设备上继续使用基于点的像素。然后我们关闭图像平滑；这是为了帮助加快下一行：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This line physically draws the image to the canvas at the size we calculated
    earlier. Once done, we will have a nice thumbnail instead of an empty canvas.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行实际上将图像绘制到我们之前计算出的尺寸的画布上。一旦完成，我们就会有一个漂亮的缩略图而不是一个空白的画布。
- en: This operation isn't free, however; it takes time to draw the image to a smaller
    scale, but we only have to do this once (whenever we load the available documents).
    If we had used `IMG` tags for all our thumbnails, this would have had to be done
    every time something changed on the view, which would be so slow as to be unusable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个操作并不是免费的；将图像绘制到更小的比例需要时间，但我们必须只做一次（无论何时加载可用的文档）。如果我们为所有缩略图都使用了`IMG`标签，那么每次视图发生变化时都必须这样做，这将慢到无法使用。
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we set the image's source. This triggers loading of the image, which
    will trigger the image's `onload()` method when finished. This operation isn't
    free either, but again, it only happens whenever we load the list of documents.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置图像的源。这会触发图像的加载，加载完成后会触发图像的`onload()`方法。这个操作也不是免费的，但同样，它只在我们加载文档列表时发生。
- en: The rest of the view's code is very similar, if not identical, to prior projects,
    so we won't go over that code again.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 视图代码的其余部分与以前的项目非常相似，如果不是完全相同，所以我们不会再次介绍那段代码。
- en: What did we do?
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We've touched on quite a bit of stuff in this task. We created code that can
    take and import pictures, we worked with the HTML5 `canvas` tags, and we started
    working with a `FILE` API wrapper that makes working with files just a bit easier.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们已经涉及了很多内容。我们创建了可以获取和导入图片的代码，我们使用了HTML5的`canvas`标签，并且开始使用一个使文件操作变得稍微容易一点的`FILE`
    API包装器。
- en: What else do I need to know?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要知道什么？
- en: We mentioned that we would discuss the `FILE` API wrapper a bit more, and here's
    as good a place as any.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过会更多地讨论`FILE` API包装器，这里就是一个很好的地方。
- en: Think of `PKFILE` as a convenience wrapper that makes working with files somewhat
    easier. It doesn't take away the asynchronous nature, but it does encapsulate
    some of the operations that a file operation typically has to do, getting the
    file system especially. It also gives us the ability to add in some shortcuts
    for referencing persistent and temporary storage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将`PKFILE`视为一个方便的包装器，它使文件操作变得更容易一些。它并没有消除异步性，但它封装了一些文件操作通常必须执行的操作，特别是获取文件系统。它还使我们能够添加一些用于引用持久和临时存储的快捷方式。
- en: 'Let''s cover that last part first. Any filename that contains one of the following
    automatically gets translated to the system-specific value:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来覆盖最后一部分。任何包含以下之一的文件名都会自动转换为系统特定的值：
- en: '`doc://` is translated to `/path/to/app/persistent/storage/`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc://` 转换为 `/path/to/app/persistent/storage/`。'
- en: '`tmp://` is translated to `/path/to/app/temporary/stora`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmp://` 转换为 `/path/to/app/temporary/stora`。'
- en: '`lhost` is replaced with `""`; the `FILE` APIs can''t handle a path starting
    with this.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lhost` 被替换为 `""`；`FILE` API 无法处理以这个开头的路径。'
- en: Because `PKFILE` will translate these values in any path or filename for every
    method, we no longer have to worry about obtaining the file systems for ourselves.
    This cuts out at least one callback chain and simplifies how we refer to files
    within our own app's storage. For example, we can refer to `doc://photo.jpg` instead
    of something like `/var/something/somethingelse/app/Documents/photo.jpg`.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为 `PKFILE` 会将任何路径或文件名中的这些值转换为系统特定的值，所以我们不再需要担心自己获取文件系统。这至少减少了回调链的数量，并简化了我们对自己应用存储中文件的引用方式。例如，我们可以用
    `doc://photo.jpg` 而不是像 `/var/something/somethingelse/app/Documents/photo.jpg`
    这样的路径来引用。
- en: Each method in `PKFILE` takes some combination of filenames, and `success` and
    `failure` parameters. The `failure` functions are always passed an object that
    indicates the reason for failure. The `success` functions aren't passed any parameters.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PKFILE` 中的每个方法都接受一些文件名、`success` 和 `failure` 参数的组合。`failure` 函数总是传递一个对象，表明失败的原因。`success`
    函数不传递任何参数。'
- en: We won't go over the code for the wrapper, mainly because it isn't really anything
    you haven't seen before. If you want to take a look, it is located in `framework/fileutil.js`
    in the files available for this project.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不会详细讲解包装器的代码，主要是因为它并不是你以前没有见过的。如果你想看看，它位于 `framework/fileutil.js` 中，这是本项目提供的文件之一。
- en: Implementing the image view
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现图片视图
- en: 'The image view itself is very simple: all it does is display a single image
    along with two icons in the toolbar (**Delete** and **Share**). Here''s how our
    view will look, first for iOS:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图片视图本身非常简单：它只显示一个图片以及工具栏中的两个图标（**删除**和**分享**）。以下是我们的视图将如何看起来，首先是iOS：
- en: '![Implementing the image view](img/9403_06_05.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![实现图片视图](img/9403_06_05.jpg)'
- en: 'For Android, the view is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，视图如下所示：
- en: '![Implementing the image view](img/9403_06_06.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![实现图片视图](img/9403_06_06.jpg)'
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: If you want to follow along, the code is in `www/views/imageView.js`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟上来，代码在 `www/views/imageView.js`。
- en: Getting on with it
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续进行
- en: 'Typically we''d start with the HTML for the view, but this is very similar
    to the previous project. Instead we''ll start with the template used to display
    the image:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会从视图的HTML开始，但这个与上一个项目非常相似。因此，我们将从用于显示图片的模板开始：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is probably the simplest template we've ever had. It is literally just
    an image with a specified width. The height will be inferred from the aspect ratio
    of the image.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我们见过的最简单的模板。它实际上只是一个指定宽度的图片。高度将根据图片的宽高比推断出来。
- en: 'Like the template, the code is going to very simple as well:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就像模板一样，代码也将非常简单：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We store two items: the path to the image and the index of the image. We also
    provide a method called `setImage` that others can use to tell us which image
    to load. Once called, we replace the content area with the image data.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储两个项目：图片的路径和图片的索引。我们还提供了一个名为 `setImage` 的方法，其他人可以使用它来告诉我们加载哪张图片。一旦调用，我们就用图片数据替换内容区域。
- en: 'Our view also supports deleting the picture being viewed. Here''s how that
    is handled:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观点也支持删除正在查看的图片。以下是处理方式：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We first ask the user if they are sure, and if so, we will remove the file via
    `PKFILE.removeFile()`. Once removed, we pop ourselves off the view stack because
    it doesn't make a lot of sense to be viewing an image that is now deleted. We
    also tell the `documentsView` to reload its documents, seeing as we've modified
    the file system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先询问用户是否确定，如果是的话，我们将通过 `PKFILE.removeFile()` 删除文件。一旦删除，我们就从视图堆栈中移除自己，因为查看现在已被删除的图片没有太多意义。我们还告诉
    `documentsView` 重新加载其文档，因为我们已经修改了文件系统。
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There's one last method to cover, and that's the `viewDidHide()` method seen
    in the preceding code snippet. All we do here is clear out the content area so
    that when the image view is not being displayed, no image is sitting there hidden
    and taking up the memory. It also means the next time the view is displayed, there
    isn't an odd transition where the last loaded image is visible for a couple moments
    before the new one is loaded. (Remember, we wait a few milliseconds before loading
    in a new picture to ensure a smooth transition.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个方法需要介绍，那就是前面代码片段中看到的 `viewDidHide()` 方法。我们在这里所做的只是清除内容区域，这样当图像视图不被显示时，就不会有图像隐藏在那里占用内存。这也意味着下次视图显示时，不会出现一个奇怪的过渡，即最后加载的图像在新图像加载之前可见几秒钟。（记住，我们在加载新图片之前等待几毫秒，以确保平滑过渡。）
- en: What did we do?
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we implemented the image view, handled loading the image, and
    also handled deleting the image.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们实现了图像视图，处理了图像的加载，还处理了图像的删除。
- en: Game Over..... Wrapping it up
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束..... 结束语
- en: Well, that wasn't terribly hard, was it? We have been able to take pictures
    using the in-built camera, and we've also been able to import images directly
    from the user's photo library. We've worked with displaying thumbnails via the
    HTML5 `canvas` tag to improve performance as well. Finally, we have worked a little
    with a `FILE` API wrapper to help make our code simpler to write.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不太难，对吧？我们已经能够使用内置相机拍照，并且我们还能直接从用户的照片库中导入图像。我们还通过使用 HTML5 的 `canvas` 标签来显示缩略图，从而提高了性能。最后，我们与
    `FILE` API 包装器进行了一些工作，以帮助简化我们的代码编写。
- en: Can you take the HEAT? The Hotshot Challenge
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能承受高温吗？热手挑战
- en: There's a lot that could be done to improve the project as it stands now. Why
    don't you try a few?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的项目还有很多可以改进的地方。你为什么不尝试几个呢？
- en: Add sharing capabilities to the app. Be careful to deal with batch sharing multiple
    images, too.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序添加共享功能。同时，也要小心处理批量共享多张图片。
- en: Add filters to the images so that they can be converted to black and white,
    sepia, and more. If you want to save the files, you'll need to write a native
    plugin to save the data returned from the canvas.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为图像添加过滤器，以便可以将它们转换为黑白、棕褐色等。如果你想保存文件，你需要编写一个本地插件来保存从画布返回的数据。
- en: Speed things up a bit by generating a thumbnail from each image if it doesn't
    already have one. You could store the thumbnail in local storage if you wanted,
    it wouldn't be very big, or use the `File` API to store it.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果图像还没有缩略图，可以通过生成缩略图来加快速度。如果你想存储缩略图，可以将其存储在本地存储中，它不会很大，或者使用 `File` API 来存储。
