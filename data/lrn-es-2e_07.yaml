- en: Proxies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: Proxies are used to define the custom behavior of the fundamental operations
    on objects. Proxies are already available in programming languages such as C#,
    C++, and Java, but JavaScript has never had proxies. ES6 introduced the Proxy
    API, which lets us create proxies. In this chapter, we will look at proxies, their
    usage, and proxy traps. Due to the benefits of proxies, developers are using them
    increasingly and, therefore, it's important to learn about proxies in depth, with
    examples, which we will do in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代理用于定义对象基本操作的自定义行为。代理在诸如C#、C++和Java等编程语言中已经可用，但JavaScript从未有过代理。ES6引入了Proxy
    API，允许我们创建代理。在本章中，我们将探讨代理、它们的用法和代理陷阱。由于代理的好处，开发者越来越多地使用它们，因此深入了解代理，并通过示例进行学习变得非常重要，我们将在本章中这样做。
- en: 'In this chapter, we''ll cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating proxies using the Proxy API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Proxy API创建代理
- en: Understanding what proxies are and how to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代理是什么以及如何使用它们
- en: Intercepting various operations on the objects using traps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用陷阱拦截对象上的各种操作
- en: The different kinds of available traps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的不同陷阱类型
- en: Some use cases of proxies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理的一些用例
- en: Proxies in a nutshell
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理概述
- en: A proxy acts like a wrapper for an object and defines the custom behavior for
    the fundamental operations on the object. Some fundamental operations on the objects
    are property lookup, property assignment, constructor invocation, enumeration,
    and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代理就像是一个对象的包装器，并定义了对象基本操作的自定义行为。对象的一些基本操作包括属性查找、属性赋值、构造函数调用、枚举等。
- en: Think of it as a basic way of intercepting the operation you do with an object
    and its associated properties. For example, calling out a property value by writing
    `<objectname>.propertyName` should technically just echo out the property value,
    right?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这是一种拦截你用对象及其相关属性执行的操作的基本方式。例如，通过编写`<objectname>.propertyName`来调用属性值，从技术上讲，应该只是回显属性值，对吧？
- en: What if you want to take a step back and inject your control right before the
    echoing part, but right after the calling part? Here's where proxies come in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在回声部分之前，但在调用部分之后，退一步并注入你的控制，那么代理就派上用场了。
- en: Once an object is wrapped using a proxy, all the operations that are supposed
    to be done on the object should now be done on the proxy object, so that the custom
    behavior can take place.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用代理包装了一个对象，那么应该在代理对象上执行所有应该在对象上执行的操作，以便执行自定义行为。
- en: Terminology for proxies
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理的术语
- en: 'Here are some important terms that are used while studying proxies:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习代理时，以下是一些重要的术语：
- en: '**Target:** This is the object that is wrapped by a proxy.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标对象**：这是被代理包装的对象。'
- en: '**Traps:** These are functions that intercept various operations on the `target`
    object, and define the custom behavior for those operations.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**陷阱**：这些是拦截目标对象上各种操作并定义这些操作自定义行为的函数。'
- en: '**Handler:** This is an object that holds the traps. A handler is attached
    to a proxy object.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**：这是一个包含陷阱的对象。处理器附加到代理对象上。'
- en: Working with the Proxy API
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Proxy API一起工作
- en: 'The ES6 Proxy API provides the proxy constructor to create proxies. The proxy
    constructor takes two arguments, which are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 Proxy API提供了代理构造函数来创建代理。代理构造函数接受两个参数，它们是：
- en: '**Target:** This is the object that will be wrapped by the proxy'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标对象**：这是将被代理包装的对象'
- en: '**Handler:** This is an object that contains the traps for the `target` object'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**：这是一个包含`target`对象陷阱的对象'
- en: 'A trap can be defined for every possible operation on the `target` object.
    If a trap is not defined, then the default action takes place on the target. Here
    is a code example that shows how to create a proxy, and does various operations
    on the `target` object. In this example, we have not defined any traps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为目标对象上的每个可能操作定义陷阱。如果没有定义陷阱，则默认在目标上执行操作。以下是一个代码示例，展示了如何创建代理，并在目标对象上执行各种操作。在这个例子中，我们没有定义任何陷阱：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This outputs the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出以下内容：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we can see that the age property of the `target` object can be accessed
    via the `proxy` object. When we added the name property to the `proxy` object,
    it was actually added to the `target` object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到可以通过`proxy`对象访问`target`对象的`age`属性。当我们向`proxy`对象添加`name`属性时，实际上它是添加到`target`对象上的。
- en: As there was no trap attached to the property assignment, the `proxy.name` assignment
    resulted in the default behavior--that is, simply assigning the value to the property.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有将陷阱附加到属性赋值上，`proxy.name`赋值导致了默认行为——即简单地赋值给属性。
- en: So, we can say that a proxy is just a wrapper for a `target` object, and traps
    can be defined to change the default behavior of operations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以这样说，代理只是一个`target`对象的包装器，并且可以定义陷阱来改变操作的默认行为。
- en: 'Many developers don''t keep a reference variable for the `target` object, so
    use of the proxy is not mandatory for accessing the object. Keep a reference for
    the handler only when you need to reuse it for multiple proxies. Here is how to
    rewrite the previous code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者没有保留`target`对象的引用变量，因此访问对象时使用代理不是强制性的。只有在你需要为多个代理重用处理器时，才保留处理器的引用。以下是重写之前代码的方法：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Proxy traps
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理陷阱
- en: There are different traps for the different operations that can be performed
    on an object. Some of the traps need to return values. There are some rules you
    need to follow when returning values. The returned values are intercepted by the
    proxy to filter and/or check if the returned values obey the rules. If a trap
    doesn't obey rules while returning a value, then the proxy throws the `TypeError`
    exception.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可以在对象上执行的不同操作，有不同的陷阱。一些陷阱需要返回值。在返回值时，你需要遵循一些规则。返回的值被代理拦截以过滤和/或检查返回的值是否遵守规则。如果一个陷阱在返回值时违反了规则，那么代理会抛出`TypeError`异常。
- en: The value of `this` inside a trap is always a reference to the handler.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 陷阱内部的`this`值始终是处理器的引用。
- en: Let's take a look at the various kinds of traps.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看各种陷阱。
- en: The get(target, property, receiver) method
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`get(target, property, receiver)`方法'
- en: The get trap is executed when we retrieve a property value using the dot or
    bracket notation, or the `Reflect.get()` method. It takes three parameters--that
    is, the `target` object, the property name, and the proxy.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用点或方括号表示法检索属性值，或使用`Reflect.get()`方法时，会执行获取陷阱。它接受三个参数——即`target`对象、属性名和代理。
- en: 'It must return a value that represents the property value. Here is a code example,
    which shows how to use the get trap:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须返回一个表示属性值的值。以下是一个代码示例，展示了如何使用获取陷阱：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output, as you might''ve figured out, is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出，正如你可能已经猜到的，如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of the output, you will get the following without proxies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是输出，没有代理时你会得到以下内容：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we can see that the get trap looks for the property in the `target` object
    and, if it finds it, then returns the `property` value. Otherwise, it returns
    a string indicating that it was not found.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到获取陷阱在`target`对象中查找属性，如果找到了，则返回`property`值。否则，它返回一个字符串，表示未找到。
- en: 'The receiver parameter is the reference of the object whose property we intend
    to access. Consider this example to better understand the value of the receiver
    parameter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器参数是我们打算访问其属性的对象的引用。考虑以下示例，以更好地理解接收器参数的值：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that `{age: 13}` here is `ProxyObject`, `{ age: 12 }` is the normal object.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，这里的`{age: 13}`是`ProxyObject`，`{ age: 12 }`是普通对象。'
- en: Here `obj` inherits the `proxy` object. Therefore, when the name property was
    not found in the `obj` object, it was searched for in the `proxy` object. As the
    `proxy` object had a get trap, it provided a value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`obj`继承了`proxy`对象。因此，当名称属性在`obj`对象中未找到时，它会在`proxy`对象中查找。由于`proxy`对象有一个获取陷阱，它提供了一个值。
- en: So, the value of the receiver parameter when we access the name property via
    the `obj.name` expression is `obj`, and when we access the name property via `proxy.name` the
    expression is `proxy`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们通过`obj.name`表达式访问名称属性时，接收器参数的值是`obj`，当我们通过`proxy.name`访问名称属性时，表达式是`proxy`。
- en: The value of the receiver parameter is decided in the same way for all other
    traps also.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他陷阱，接收器参数的值决定方式相同。
- en: Rules for using get trap
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用获取陷阱的规则
- en: 'These rules shouldn''t be violated when using the get trap:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用获取陷阱时，不应违反以下规则：
- en: The value returned for a property must be the same as the value of the `target`
    object property if the `target` object property is a non-writable, non-configurable
    data property.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`target`对象属性是一个不可写、不可配置的数据属性，则返回的属性值必须与`target`对象属性的值相同。
- en: The value returned for a property must be `undefined` if the `target` object
    property is a non-configurable accessor property that has `undefined` as its [[Get]]
    attribute.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `target` 对象的属性是一个不可配置的访问器属性，并且其 `[[Get]]` 属性为 `undefined`，则返回值必须为 `undefined`。
- en: The set(target, property, value, receiver) method
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`set(target, property, value, receiver)` 方法'
- en: The set trap is invoked when we set the value of a property using the assignment
    operator, or the `Reflect.set()` method. It takes four parameter-- that is, the
    `target` object, the property name, the new property value, and the receiver.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用赋值运算符或 `Reflect.set()` 方法设置属性值时，将调用 `set` 陷阱。它接受四个参数--即，`target` 对象、属性名、新的属性值和接收者。
- en: The set trap must return `true` if the assignment was successful. Otherwise,
    it will return `false`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果赋值成功，`set` 陷阱必须返回 `true`。否则，它将返回 `false`。
- en: 'Here is a code example that demonstrates how to use the set trap:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用 `set` 陷阱：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Rules for using set trap
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `set` 陷阱的规则
- en: 'These rules shouldn''t be violated when using the set trap:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `set` 陷阱时，不应违反这些规则：
- en: If the `target` object property is a non-writable, non-configurable data property,
    then it will return as `false`--that is, you cannot change the property value
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `target` 对象的属性是一个不可写、不可配置的数据属性，则它将返回 `false`--也就是说，您不能更改属性值
- en: If the `target` object property is a non-configurable accessor property that
    has `undefined` as its [[Set]] attribute, then it will return as `false`--that
    is, you cannot change the property value
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `target` 对象的属性是一个不可配置的访问器属性，并且其 `[[Set]]` 属性为 `undefined`，则它将返回 `false`--也就是说，您不能更改属性值
- en: The has(target, property) method
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`has(target, property)` 方法'
- en: The has trap is executed when we check if a property exists or not, using the
    `in` operator. It takes two parameters--that is, the `target` object and the property
    name. It must return a Boolean value that indicates whether the property exists
    or not.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `in` 运算符检查属性是否存在时，将执行 `has` 陷阱。它接受两个参数--即，`target` 对象和属性名。它必须返回一个布尔值，指示属性是否存在。
- en: 'Here is a code example that demonstrates how to use the has trap:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用 `has` 陷阱：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Rules for using has trap
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `has` 陷阱的规则
- en: 'These rules shouldn''t be violated when using the has trap:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `has` 陷阱时，不应违反这些规则：
- en: You cannot return `false` if the property exists as a non-configurable and is
    its own property of the `target` object
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为非配置属性存在于 `target` 对象中，并且是其自身属性，则不能返回 `false`
- en: You cannot return `false` if the property exists as an own property of the `target`
    object and the `target` object is not-extensible
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为 `target` 对象的自身属性存在，并且 `target` 对象是不可扩展的，则不能返回 `false`
- en: The isExtensible(target) method
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`isExtensible(target)` 方法'
- en: The `isExtensible` trap is executed when we check if the object is extensible
    or not, using the `Object.isExtensible()` method. It takes only one parameter--that
    is, the `target` object. It must return a Boolean value indicating whether the
    object is extensible or not.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Object.isExtensible()` 方法检查对象是否可扩展时，将执行 `isExtensible` 陷阱。它只接受一个参数--即，`target`
    对象。它必须返回一个布尔值，指示对象是否可扩展。
- en: 'Here is a code example that demonstrates how to use the `isExtensible` trap:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用 `isExtensible` 陷阱：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Rule for using isExtensible trap
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `isExtensible` 陷阱的规则
- en: 'This rule shouldn''t be violated when using the `isExtensible` trap:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `isExtensible` 陷阱时，不应违反此规则：
- en: You cannot return `false` if the target is extensible. Similarly, you cannot
    return `true` if the target is non-extensible
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标对象是可扩展的，则不能返回 `false`。同样，如果目标对象是不可扩展的，则不能返回 `true`
- en: The getPrototypeOf(target) method
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getPrototypeOf(target)` 方法'
- en: The `getPrototypeOf` trap is executed when we retrieve the value of the internal
    [[prototype]] property, using either the `Object.getPrototypeOf()` method or the
    `__proto__` property. It takes only one parameter--that is, the `target` object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Object.getPrototypeOf()` 方法或 `__proto__` 属性检索内部 [[prototype]] 属性的值时，将执行
    `getPrototypeOf` 陷阱。它只接受一个参数--即，`target` 对象。
- en: It must return an object or null value. The null value indicates that the object
    doesn't inherit anything else and is the end of the inheritance chain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须返回一个对象或 `null` 值。`null` 值表示该对象没有继承其他任何内容，并且是继承链的末端。
- en: 'Here is a code example that demonstrates how to use the `getPrototypeOf` trap:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用 `getPrototypeOf` 陷阱：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Rules for using getPrototypeOf trap
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `getPrototypeOf` 陷阱的规则
- en: 'These rules shouldn''t be violated when using the `getPrototypeOf` trap:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `getPrototypeOf` 陷阱时，不应违反这些规则：
- en: It must either return an object or return a null value
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须返回一个对象或返回一个空值
- en: If the target is not-extensible, then this trap must return the actual prototype
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标是不可扩展的，那么这个陷阱必须返回实际的原型
- en: The setPrototypeOf(target, prototype) method
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`setPrototypeOf(target, prototype)` 方法'
- en: The `setPrototypeOf` trap is executed when we set the value of the internal
    [[prototype]] property, using either the `Object.setPrototypeOf()` method or the
    `__proto__` property. It takes two parameters--that is, the `target` object and
    value of the property to be assigned.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Object.setPrototypeOf()` 方法或 `__proto__` 属性设置内部 [[prototype]] 属性的值时，将执行
    `setPrototypeOf` 陷阱。它接受两个参数——即 `target` 对象和要分配的属性的值。
- en: This trap will return a Boolean, indicating whether it has successfully set
    the prototype or not.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陷阱将返回一个布尔值，表示是否成功设置了原型。
- en: 'Here is a code example that demonstrates how to use the `setPrototypeOf` trap:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示了如何使用 `setPrototypeOf` 陷阱：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Rule for using setPrototypeOf trap
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `setPrototypeOf` 陷阱的规则
- en: 'This rule shouldn''t be violated when using the `setPrototypeOf` trap:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `setPrototypeOf` 陷阱时，不应违反以下规则：
- en: You must return `false` if the target is not-extensible
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `target` 不是不可扩展的，你必须返回 `false`
- en: The preventExtensions(target) method
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`preventExtensions(target)` 方法'
- en: The `preventExtensions` trap is executed when we prevent the addition of new
    properties using the `Object.preventExtensions()` method. It takes only one parameter--that
    is, the `target` object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Object.preventExtensions()` 方法防止添加新属性时，将执行 `preventExtensions` 陷阱。它只接受一个参数——即
    `target` 对象。
- en: It must return a Boolean, indicating whether it has successfully prevented the
    extension of the object or not.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须返回一个布尔值，表示是否成功阻止了对象的扩展。
- en: 'Here is a code example that demonstrates how to use the `preventExtensions`
    trap:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示了如何使用 `preventExtensions` 陷阱：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Rule for using preventExtensions trap
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `preventExtensions` 陷阱的规则
- en: 'This rule shouldn''t be violated when using the `preventExtensions` trap:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `preventExtensions` 陷阱时，不应违反以下规则：
- en: This trap can return `true` only if the target is non-extensible or it has made
    the target non-extensible
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当 `target` 是不可扩展的或已使 `target` 不可扩展时，这个陷阱才能返回 `true`
- en: The getOwnPropertyDescriptor(target, property) method
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getOwnPropertyDescriptor(target, property)` 方法'
- en: The `getOwnPropertyDescriptor` trap is executed when we retrieve the descriptor
    of a property by using the `Object.getOwnPropertyDescriptor()` method. It takes
    two parameters--that is, the `target` object and the name of the property.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Object.getOwnPropertyDescriptor()` 方法检索属性的描述符时，将执行 `getOwnPropertyDescriptor`
    陷阱。它接受两个参数——即 `target` 对象和属性的名称。
- en: This trap must return a `descriptor` object or `undefined`. The `undefined`
    value is returned if the property doesn't exist.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陷阱必须返回一个 `descriptor` 对象或 `undefined`。如果属性不存在，则返回 `undefined` 值。
- en: 'Here is a code example that demonstrates how to use the `getOwnPropertyDescriptor`
    trap:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示了如何使用 `getOwnPropertyDescriptor` 陷阱：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Rules for using getOwnPropertyDescriptor trap
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `getOwnPropertyDescriptor` 陷阱的规则
- en: 'These rules shouldn''t be violated when using the `getOwnPropertyDescriptor`
    trap:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `getOwnPropertyDescriptor` 陷阱时，不应违反以下规则：
- en: This trap must either return an object or return an `undefined` property
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个陷阱必须返回一个对象或返回一个 `undefined` 属性
- en: You cannot return the `undefined` value if the property exists as a non-configurable
    own property of the `target` object
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为 `target` 对象的非配置性自有属性存在，则不能返回 `undefined` 值
- en: You cannot return the `undefined` value if the property exists as an own property
    of the `target` object and the `target` object is not-extensible
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为 `target` 对象的自有属性存在，并且 `target` 对象是不可扩展的，则不能返回 `undefined` 值
- en: You will have to return `undefined` if the property does not exist as an own
    property of the `target` object and the `target` object is not-extensible
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性不是 `target` 对象的自有属性，并且 `target` 对象是不可扩展的，那么你必须返回 `undefined`
- en: You cannot make the configurable property of the returned descriptor object
    `false` if the property exists as an own property of the `target` object, or if
    it exists as a configurable own property of the `target` object
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为 `target` 对象的自有属性存在，或者如果它作为 `target` 对象的可配置自有属性存在，则不能将返回的描述符对象的配置性设置为
    `false`
- en: The defineProperty(target, property, descriptor) method
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`defineProperty(target, property, descriptor)` 方法'
- en: The `defineProperty` trap is executed when we define a property using the `Object.defineProperty()`
    method. It takes three parameters--that is, the `target` object, the property
    name, and the `descriptor` object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`Object.defineProperty()`方法定义属性时，会执行`defineProperty`陷阱。它接受三个参数——即`target`对象、属性名和`descriptor`对象。
- en: This trap should return a Boolean indicating whether it has successfully defined
    the property or not.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陷阱应该返回一个布尔值，表示是否成功定义了属性。
- en: 'Here is a code example that demonstrates how to use the `defineProperty` trap:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用`defineProperty`陷阱：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Rule for using defineProperty
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`defineProperty`的规则
- en: 'This rule shouldn''t be violated when using the `defineProperty` trap:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`defineProperty`陷阱时，不应违反此规则：
- en: It must return `false` if the `target` object is not-extensible, and the property
    doesn't yet exist
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`target`对象是不可扩展的，并且属性尚未存在，则必须返回`false`。
- en: The deleteProperty(target, property) method
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`deleteProperty(target, property)`方法'
- en: The `deleteProperty` trap is executed when we delete a property using either
    the delete operator or the `Reflect.deleteProperty()` method. It takes two parameters--that
    is, the `target` object and the property name.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用删除运算符或`Reflect.deleteProperty()`方法删除属性时，会执行`deleteProperty`陷阱。它接受两个参数——即`target`对象和属性名。
- en: 'This trap must return a Boolean, indicating whether the property was deleted
    successfully or not. Here is a code example that demonstrates how to use the `deleteProperty`
    trap:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陷阱必须返回一个布尔值，表示属性是否成功删除。下面是一个代码示例，演示了如何使用`deleteProperty`陷阱：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Rule for deleteProperty trap
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`deleteProperty`陷阱的规则
- en: 'This rule shouldn''t be violated when using the `deleteProperty` trap:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`deleteProperty`陷阱时，不应违反此规则：
- en: This trap must return `false` if the property exists as a non-configurable own
    property of the `target` object
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个陷阱必须返回`false`，如果属性作为`target`对象的非可配置自有属性存在
- en: The ownKeys(target) method
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ownKeys(target)`方法'
- en: The `ownKeys` trap is executed when we retrieve the own property keys using
    the `Reflect.ownKeys()`, `Object.getOwnPropertyNames()`, `Object. getOwnPropertySymbols()` and
    the `Object.keys()` methods. It takes only one parameter--that is, the `target`
    object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`Reflect.ownKeys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`和`Object.keys()`方法检索自有属性键时，会执行`ownKeys`陷阱。它只接受一个参数——即`target`对象。
- en: The `Reflect.ownKeys()` method is similar to the `Object.getOwnPropertyNames()`
    method--that is, they both return the enumerable and non-enumerable property keys
    of an object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.ownKeys()`方法类似于`Object.getOwnPropertyNames()`方法——即它们都返回对象的可枚举和非可枚举属性键。'
- en: They also both ignore the inherited properties. The only difference is that
    the `Reflect. ownKeys()` method returns both the symbol and string keys, whereas
    the `Object. getOwnPropertyNames()` method returns only the string keys.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也都会忽略继承的属性。唯一的区别是`Reflect.ownKeys()`方法返回符号键和字符串键，而`Object.getOwnPropertyNames()`方法只返回字符串键。
- en: The `Object.getOwnPropertySymbols()` method returns the enumerable and non-enumerable
    properties whose keys are symbols. It ignores the inherited properties.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertySymbols()`方法返回具有符号键的可枚举和非可枚举属性。它忽略了继承的属性。'
- en: The `Object.keys()` method is similar to the `Object.getOwnPropertyNames()`
    method, but the only difference is that the `Object.keys()` method returns the
    enumerable properties only.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.keys()`方法类似于`Object.getOwnPropertyNames()`方法，但唯一的区别是`Object.keys()`方法只返回可枚举属性。'
- en: The `ownKeys` trap must return an array, representing the own property keys.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ownKeys`陷阱必须返回一个数组，表示自有属性键。'
- en: 'Here is a code example which demonstrates how to use the `ownKeys` trap:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用`ownKeys`陷阱：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we can see that the values of the array returned by the `ownKeys` trap
    are filtered by the proxy, based on what the caller expected. For example, the
    `Object.getOwnPropertySymbols()` caller expected an array of symbols. Therefore,
    the proxy removed the strings from the returned array.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`ownKeys`陷阱返回的数组值被代理过滤，基于调用者期望的内容。例如，`Object.getOwnPropertySymbols()`调用者期望一个包含符号的数组。因此，代理从返回的数组中移除了字符串。
- en: Rules for using ownKeys trap
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ownKeys`陷阱的规则
- en: 'These rules shouldn''t be violated when using the `ownKeys` trap:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则在使用`ownKeys`陷阱时不应被违反：
- en: The elements of the returned array must either be a string or symbol
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回数组的元素必须是字符串或符号
- en: The returned array must contain the keys of all the non-configurable own properties
    of the `target` object
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的数组必须包含`target`对象的所有非配置自有属性的键
- en: If the `target` object is not-extensible, then the returned array must contain
    all the keys of the own properties and of the `target` object, and no other values
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`target`对象是不可扩展的，则返回的数组必须包含自有属性和`target`对象的所有键，并且不包含其他值
- en: The apply(target, thisValue, arguments) method
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`apply(target, thisValue, arguments)`方法'
- en: If the target is a function, then calling the proxy will execute the `apply`
    trap. The `apply` trap is also executed for the function's `apply()` and `call()`
    methods, and the `Reflect.apply()` method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是函数，则调用代理将执行`apply`陷阱。`apply`陷阱也会为函数的`apply()`和`call()`方法以及`Reflect.apply()`方法执行。
- en: The apply trap takes three parameters. The first parameter is the `target` object
    and the third parameter is an array, representing the arguments of the function
    call.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`陷阱接受三个参数。第一个参数是`target`对象，第三个参数是一个数组，表示函数调用的参数。'
- en: The second parameter is the same as the value of `this` of the `target` function--that
    is, it's the same as the value of `this` of the target function if the target
    function would have been invoked without the proxy.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数与`target`函数的`this`值相同--即，如果目标函数没有使用代理被调用，则与目标函数的`this`值相同。
- en: 'Here is a code example that demonstrates how to use the apply trap:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码示例，演示如何使用apply陷阱：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The construct(target, arguments) method
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`construct(target, arguments)`方法'
- en: If the target is a function, then calling the target as a constructor using
    the `new` operator or the `Reflect.construct()` method will execute the construct
    trap.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是函数，则使用`new`运算符或`Reflect.construct()`方法将目标作为构造函数调用将执行构造陷阱。
- en: The construct trap takes two parameters. The first parameter is the `target`
    object and the second parameter is an array, representing the arguments of the
    constructor call.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`construct`陷阱接受两个参数。第一个参数是`target`对象，第二个参数是一个数组，表示构造函数调用的参数。'
- en: 'The `construct` trap must return an object, representing the newly created
    instance. Here is a code example that demonstrates how to use the `construct`
    trap:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`construct`陷阱必须返回一个对象，表示新创建的实例。以下是一个代码示例，演示如何使用`construct`陷阱：'
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Proxy.revocable(target, handler) method
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Proxy.revocable(target, handler)`方法'
- en: A revocable proxy is a proxy that can be revoked (that is, switched off).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可撤销代理是一种可以被撤销（即，关闭）的代理。
- en: 'To create revocable proxies we have to use the `Proxy.revocable()` method.
    The `Proxy.revocable()` method is not a constructor. This method also takes the
    same arguments as the `Proxy` constructor, but, instead of returning a revocable
    proxy instance directly, it returns an object with two properties, which are the
    following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建可撤销代理，我们必须使用`Proxy.revocable()`方法。`Proxy.revocable()`方法不是一个构造函数。此方法也接受与`Proxy`构造函数相同的参数，但它不是直接返回一个可撤销代理实例，而是返回一个具有两个属性的对象，如下所示：
- en: '`proxy`: This is the revocable `proxy` object'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy`：这是可撤销的`proxy`对象'
- en: '`revoke`: When this function is called, it revokes the proxy'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`revoke`：当此函数被调用时，它将撤销代理'
- en: 'Once a revocable `proxy` is revoked, any attempts to use it will throw a `TypeError`
    exception. Here is an example to demonstrate how to create a revocable `proxy`
    and `revoke` it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦撤销了可撤销的`proxy`，任何尝试使用它的操作都将抛出`TypeError`异常。以下是一个示例，演示如何创建可撤销的`proxy`并撤销它：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Use case of revocable proxy
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可撤销代理的使用场景
- en: You can use the revocable proxies instead of the regular proxies. You can use
    it when you pass a proxy to a function that runs asynchronously or in parallel,
    so that you can revoke it when you don't want the function to be able to use that
    proxy anymore.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用可撤销代理而不是常规代理。当您将代理传递给一个异步或并行运行的功能时，您可以撤销它，这样您就不希望该功能再使用该代理了。
- en: The uses of proxies
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理的使用
- en: 'There are several uses of proxies. Here are some main use cases:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代理有几种用途。以下是主要的使用场景：
- en: Creating virtualized objects, such as remote objects, persistent objects, and
    more
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建虚拟化对象，例如远程对象、持久化对象等
- en: The lazy creation of objects
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的懒加载创建
- en: Transparent logging, tracing, profiling, and more
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明的日志记录、跟踪、分析等
- en: Embedded domain specific languages
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内嵌领域特定语言
- en: Generically interposing abstractions in order to enforce access control
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过强制访问控制来泛化抽象
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned what proxies are and how to use them. We saw the
    various traps available with examples. We also saw different rules that need to
    be followed by different traps. This chapter explained everything about the Proxy
    API in JavaScript in depth. Finally, we saw some use cases of proxies. In the
    next chapter, we will walk through object-oriented programming and the ES6 classes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了什么是代理以及如何使用它们。我们通过例子看到了可用的各种陷阱。我们还看到了不同陷阱需要遵循的不同规则。本章深入解释了JavaScript中Proxy
    API的各个方面。最后，我们看到了一些代理的使用案例。在下一章中，我们将探讨面向对象编程和ES6类。
