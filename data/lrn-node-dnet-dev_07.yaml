- en: Chapter 7. Setting up an Automated Build
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 设置自动化构建
- en: In the previous chapter, we took a major step from a demo application to a maintainable
    codebase by starting to write automated tests. Another important component of
    real-world software projects is build automation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过开始编写自动化测试，从演示应用程序到可维护的代码库迈出了重要的一步。现实世界软件项目的另一个重要组成部分是构建自动化。
- en: Automated builds allow a whole team to work on a project in a consistent manner.
    A standardized way of executing common tasks makes it easier for new developers
    to get started. It also avoids annoying issues with developers getting different
    results for spurious reasons.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化构建允许整个团队以一致的方式在项目上工作。执行常见任务的标准方式使得新开发者更容易开始。它还避免了开发者因各种原因得到不同结果而引起的烦恼问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Configuring an integration server to build and run our tests automatically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置集成服务器以自动构建和运行我们的测试
- en: Setting up an automated task runner to simplify the execution of our tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置自动化任务运行器以简化测试的执行
- en: Automating more tasks to help maintain coding standards and test coverage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化更多任务以帮助维护编码标准和测试覆盖率
- en: Setting up an integration server
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置集成服务器
- en: Build and test automation allow code changes to be verified by an **integration
    server**, an automated server independent of individual developers' machines.
    This helps keep the project stable by catching errors or regressions early on.
    The integration server can automatically alert the developer who introduced the
    problem. They then have a chance to fix the problem before it causes issues for
    the rest of the team or the project as a whole.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和测试自动化允许通过**集成服务器**验证代码更改，这是一个独立于个人开发者机器的自动化服务器。这有助于通过早期捕获错误或回归来保持项目稳定。集成服务器可以自动提醒引入问题的开发者。然后，他们有机会在问题对整个团队或项目造成影响之前修复问题。
- en: Building the codebase and running tests automatically on each commit is called
    **Continuous Integration** (**CI**). There are many CI/build servers available.
    These can be self-hosted or provided as a third-party service. Examples that you
    may have used before include Jenkins (formerly Hudson), Atlassian Bamboo, JetBrains
    TeamCity, and Microsoft's Team Foundation Server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次提交时自动构建代码库和运行测试被称为**持续集成**（**CI**）。有许多CI/构建服务器可用。这些可以是自托管的，也可以作为第三方服务提供。你可能之前使用过的例子包括Jenkins（以前称为Hudson）、Atlassian
    Bamboo、JetBrains TeamCity和微软的Team Foundation Server。
- en: We're going to be using Travis CI ([https://travis-ci.org/](https://travis-ci.org/)),
    which is a hosted service for running automated builds. It is free for use with
    public source code repositories. In order to use Travis CI's free service, we
    need to host our application's code in a public GitHub repository.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Travis CI ([https://travis-ci.org/](https://travis-ci.org/))，这是一个托管服务，用于运行自动化构建。对于公共源代码仓库，它是免费的。为了使用Travis
    CI的免费服务，我们需要将我们的应用程序代码托管在公共GitHub仓库中。
- en: Setting up a public GitHub repository
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置公共GitHub仓库
- en: If you have your own version of the example application code from following
    along with the book so far, and are already familiar with GitHub, you can push
    your code to a new GitHub repository of your own. Otherwise, you can fork one
    of the example chapter repositories.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经根据本书的内容熟悉了示例应用程序代码，并且已经熟悉GitHub，你可以将你的代码推送到你自己的新GitHub仓库。否则，你可以从示例章节仓库中fork一个。
- en: 'Use [https://github.com/NodeJsForDevelopers/chapter06/](https://github.com/NodeJsForDevelopers/chapter06/)
    if you want to follow along with the changes in this chapter. This contains the
    example code from the end of [Chapter 6](part0034.xhtml#aid-10DJ41 "Chapter 6. Testing
    Node.js Applications"), *Testing Node.js Applications*, which we will build on
    in this chapter. You can create your own fork of this repository using the **Fork**
    button on GitHub. This should be visible at the top-right of the screen when visiting
    the URL mentioned earlier:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跟随本章的变化，请使用[https://github.com/NodeJsForDevelopers/chapter06/](https://github.com/NodeJsForDevelopers/chapter06/)。这包含了[第6章](part0034.xhtml#aid-10DJ41
    "第6章. 测试Node.js应用程序")末尾的示例代码，我们将在此基础上构建。你可以使用GitHub上的**Fork**按钮创建这个仓库的自己的fork。当你访问之前提到的URL时，它应该出现在屏幕的右上角：
- en: '![Setting up a public GitHub repository](img/image00219.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![设置公共GitHub仓库](img/image00219.jpeg)'
- en: This will create a new repository under your own GitHub account, using the example
    code as a starting point.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的GitHub账户下创建一个新的仓库，以示例代码作为起点。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is all you need to get started in this chapter. However, if you are not
    already familiar with Git and/or GitHub and would like to know more, you can find
    more information at [https://help.github.com/](https://help.github.com/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章开始所需的所有内容。然而，如果你不熟悉Git和/或GitHub并想了解更多信息，你可以在[https://help.github.com/](https://help.github.com/)找到更多信息。
- en: Building a project on Travis CI
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Travis CI上构建项目
- en: We'll now set up a build for our application on Travis CI. If you created your
    own public repository in the previous section, you can try this out for yourself.
    Visit [https://travis-ci.org](https://travis-ci.org) and sign in with GitHub.
    You should see a profile page listing your repositories. Enable the repository
    you just created.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置在Travis CI上为我们应用程序构建。如果你在上一节中创建了您自己的公共仓库，你可以亲自尝试。访问[https://travis-ci.org](https://travis-ci.org)并使用GitHub登录。你应该会看到一个列出你的仓库的个人资料页面。启用你刚刚创建的仓库。
- en: 'We have to create a simple `config` file to tell Travis CI in what environment(s)
    to build our application. Create a file in the root of the project as follows
    (note the leading dot in the file name `.travis.yml`):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建一个简单的`config`文件来告诉Travis CI在什么环境下构建我们的应用程序。按照以下方式在项目的根目录中创建一个文件（注意文件名中的前导点`.travis.yml`）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This tells TravisCI to build our project with the current stable and long-term
    support versions of Node.js (at the time of writing). If you're familiar with
    Git, you can make this change in a local clone of your repository, commit, and
    push it to master. If you're new to Git, the easiest way to create this file is
    to navigate to your repository on [https://github.com](https://github.com) and
    click on the **New file** button. This will open a web-based editor from which
    you can create and commit the file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示TravisCI使用当前稳定和长期支持版本的Node.js（截至写作时）来构建我们的项目。如果你熟悉Git，你可以在本地仓库的克隆版本中做出这个更改，提交并推送到master。如果你是Git的新手，最简单创建此文件的方法是导航到你的仓库在[https://github.com](https://github.com)上，并点击**新建文件**按钮。这将打开一个基于网页的编辑器，你可以从中创建和提交文件。
- en: 'Once you have added this file to your repository, visit [https://travis-ci.org](https://travis-ci.org)
    again. You should now see a passing build for your repository:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将此文件添加到你的仓库中，再次访问[https://travis-ci.org](https://travis-ci.org)。现在你应该会看到你仓库的通过构建：
- en: '![Building a project on Travis CI](img/image00220.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![在Travis CI上构建项目](img/image00220.jpeg)'
- en: TravisCI built our project twice, once for each version of Node.js that we specified.
    If you click on either build you can see the command-line output. Notice that
    TravisCI automatically ran our tests using the standard `npm test` command.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TravisCI为我们指定的每个Node.js版本构建了我们的项目两次。如果你点击任何一个构建，你可以看到命令行输出。注意TravisCI自动使用标准的`npm
    test`命令运行了我们的测试。
- en: Automating the build process with Gulp
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gulp自动化构建过程
- en: It's great that TravisCI runs our tests automatically. But that's not the only
    task we want to automate. Of course, as JavaScript is an interpreted language,
    we don't have a compile step in our build process. There are other tasks we want
    to carry out though, for example, checking our code style, running integration
    tests, and gathering code coverage. We can make use of a build tool to automate
    these tasks and allow us to run them in a consistent manner. You may have used
    MSBuild for this in .NET before or Java tools such as Maven or Gradle.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，TravisCI自动运行了我们的测试。但这不是我们想要自动化的唯一任务。当然，由于JavaScript是一种解释型语言，我们在构建过程中没有编译步骤。我们还想执行其他任务，例如检查我们的代码风格、运行集成测试和收集代码覆盖率。我们可以使用构建工具来自动化这些任务，并允许我们以一致的方式运行它们。你之前可能在使用.NET时使用过MSBuild，或者使用过Java工具，如Maven或Gradle。
- en: There are several different build tools available for Node.js. The two most
    popular by far are Grunt and Gulp. Both have large communities and an extensive
    range of plugins for performing different operations. Grunt's model has each operation
    reading in files and writing back to the filesystem. Gulp uses Node.js streams
    to pipe processing from one operation to the next.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Node.js，有几种不同的构建工具可用。最受欢迎的两个是Grunt和Gulp。它们都有庞大的社区和广泛的功能插件，用于执行不同的操作。Grunt的模型是每个操作读取文件并将其写回文件系统。Gulp使用Node.js流将处理从一项操作传递到下一项操作。
- en: Grunt's model is slightly simpler and may be easier to get started with, especially
    if you have modest build requirements. Gulp's model is potentially faster for
    some types of task and can reduce the amount of build configuration code you need
    to write. Both are excellent, well-supported build tools. We'll be using Gulp,
    but everything we do in this chapter could be achieved with Grunt as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 的模型稍微简单一些，可能更容易上手，特别是如果你有适度的构建需求。Gulp 的模型对于某些类型的任务来说可能更快，并且可以减少你需要编写的构建配置代码的数量。两者都是优秀的、受良好支持的构建工具。我们将使用
    Gulp，但本章中我们做的所有事情也可以用 Grunt 实现。
- en: Running tests using Gulp
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Gulp 运行测试
- en: 'We first need to install Gulp, both globally (to add it to our path) and into
    the project. Then we add Gulp plugins for controlling Mocha and environment variables:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要安装 Gulp，既要在全局范围内（将其添加到我们的路径中）也要在项目中安装。然后我们添加 Gulp 插件来控制 Mocha 和环境变量：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We now add a configuration file for Gulp to our project. Gulp will look for
    a file with this name by convention as `gulpfile.js`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为 Gulp 添加一个配置文件到我们的项目中。按照惯例，Gulp 会寻找一个名为 `gulpfile.js` 的文件：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This creates a test task and makes an empty default task to run it. The `''default''`
    task name is special and will be invoked when we run `gulp` from the command line.
    We can now remove our test script from `package.json` and update our `.travis.yml`
    file to run Gulp:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个测试任务，并创建了一个空的默认任务来运行它。`'default'` 任务名称是特殊的，当我们在命令行中运行 `gulp` 时将会调用它。我们现在可以从
    `package.json` 中删除我们的测试脚本，并更新我们的 `.travis.yml` 文件以运行 Gulp：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This hasn't gained us much yet. We now just have a slightly shorter command
    to execute our tests. However, the use of a build tool will become more valuable
    as we add more tasks to automate. Let's look at some of the other processes we
    may want to make part of our build.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这还没有给我们带来太多好处。我们现在只是有一个稍微简短的命令来执行我们的测试。然而，随着我们添加更多自动化任务，使用构建工具将变得更加有价值。让我们看看我们可能希望将哪些其他过程纳入我们的构建中。
- en: Checking code style with ESLint
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ESLint 检查代码风格
- en: Although we don't need a compiler, we can still benefit from having the computer
    perform static analysis of our code. Linting tools are common in many languages
    for spotting common programming errors that may lead to subtle bugs or confusing
    code. You may be familiar with CodeRush, StyleCop, and others for .NET, or CheckStyle,
    Findbugs, Sonar, and others for Java.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不需要编译器，但我们仍然可以从计算机对我们代码的静态分析中受益。代码检查工具在许多语言中很常见，用于发现可能导致微妙错误或混乱代码的常见编程错误。你可能熟悉
    .NET 的 CodeRush、StyleCop 以及其他工具，或者 Java 的 CheckStyle、Findbugs、Sonar 以及其他工具。
- en: 'We''ll be using a JavaScript/ECMAScript linting tool called ESLint. Let''s
    first install it globally:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 ESLint 的 JavaScript/ECMAScript 代码检查工具。让我们首先全局安装它：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now create a config file to tell ESLint what rules to use as `.eslintrc.json`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个配置文件来告诉 ESLint 使用哪些规则，作为 `.eslintrc.json`：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we tell ESLint to use its standard recommended rules for the environments
    that we are using in our scripts. We also tell it to check for semicolons at the
    ends of statements and to prefer single quotes. You can run ESLint as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 ESLint 在我们的脚本中使用的环境中使用其标准推荐规则。我们还告诉它检查语句末尾的分号，并优先使用单引号。你可以按照以下方式运行
    ESLint：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'ESLint outputs any errors it finds, including the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 输出它找到的所有错误，包括以下内容：
- en: An unused `favicon` local variable in app.js
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app.js 中的一个未使用的 `favicon` 本地变量
- en: The unused `next` parameter in various middleware functions
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各种中间件函数中未使用的 `next` 参数
- en: The use of `console.log` in our PhantomJS integration test
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 PhantomJS 集成测试中使用 `console.log`
- en: The use of the `phantom` variable in our PhantomJS integration test
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 PhantomJS 集成测试中使用 `phantom` 变量
- en: 'The first of these is trivial to solve: we can just remove the variable declaration
    (this was created for us by the express application template in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Getting Started with Node.js"), *Getting Started with Node.js*). We
    could do the same for the `next` parameters on our middleware functions. However,
    I prefer middleware functions to have a standard and easily identifiable signature.
    Instead of removing this parameter, we can tell ESLint to ignore this particular
    parameter as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题中最简单的一个是：我们可以直接删除变量声明（这是由第 2 章的 express 应用程序模板为我们创建的，[第 2 章](part0018.xhtml#aid-H5A41
    "第 2 章。Node.js 入门")，*Node.js 入门*）。我们也可以对中间件函数上的 `next` 参数做同样处理。然而，我更喜欢中间件函数有一个标准且易于识别的签名。而不是删除这个参数，我们可以告诉
    ESLint 忽略这个特定的参数，如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last two bullet points both relate to our PhantomJS integration test. This
    is quite a special file, so here we''ll change ESLint''s behavior for this file
    specifically, using a comment directive. We can add the following directives at
    the very top of the offending file, `integration-test/game.js`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个项目符号都与我们的 PhantomJS 集成测试相关。这是一个相当特殊的文件，所以我们将特别更改 ESLint 对此文件的行为，使用注释指令。我们可以在有问题的文件
    `integration-test/game.js` 的最顶部添加以下指令：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first of these directives tells ESLint that this script file will run in
    the PhantomJS environment, where the `phantom` variable will be provided for us,
    so ESLint does not need to warn us against referencing it. The second directive
    disable's ESLint's rule against using console logging.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令中的第一个告诉 ESLint，此脚本文件将在 PhantomJS 环境中运行，其中 `phantom` 变量将为我们提供，因此 ESLint 不需要警告我们引用它。第二个指令禁用了
    ESLint 对使用 console logging 的规则。
- en: If you run ESLint again, you should find that the errors listed previously have
    disappeared. Any remaining errors should be smaller issues such as missing semicolons
    or inconsistent use of quotes. These should be quick to fix manually, but in fact,
    ESLint can do this for us, as we'll see in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行 ESLint，你应该会发现之前列出的错误已经消失。任何剩余的错误应该是较小的问题，例如缺少分号或不一致的引号使用。这些问题应该很快就能手动修复，但实际上，ESLint
    可以为我们做这件事，正如我们将在下一节中看到的。
- en: Automatically fixing issues in ESLint
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 ESLint 中自动修复问题
- en: ESLint is able to automatically correct some of the issues it finds. If ESLint
    is not currently reporting any errors, try removing a semicolon from one of the
    project's source files. Run ESLint and you should see an error for this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 能够自动纠正它发现的一些问题。如果 ESLint 目前没有报告任何错误，尝试从项目的一个源文件中移除一个分号。运行 ESLint，你应该会看到一个关于这个的错误。
- en: 'Now run ESLint with the `--fix` option as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下方式运行 ESLint 并使用 `--fix` 选项：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ESLint replaces the semicolon for us. Not all of ESLint's rules can be fixed
    in this way, but many of them can. It depends on whether a rule's errors always
    have a single unambiguous fix. The full list of rules, including which ones are
    fixable, can be found on the ESLint site at [http://eslint.org/docs/rules/](http://eslint.org/docs/rules/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 为我们替换了分号。并不是 ESLint 的所有规则都可以以这种方式修复，但许多规则可以。这取决于规则错误是否总是有一个单一且明确的修复。包括哪些规则可以修复的完整列表可以在
    ESLint 网站上找到，网址为 [http://eslint.org/docs/rules/](http://eslint.org/docs/rules/)。
- en: You should now be able to run ESLint with no errors or warnings. ESLint is now
    ready to pick up errors in any new code that we write.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够运行 ESLint 而没有任何错误或警告。ESLint 现在准备好捕捉我们编写的新代码中的错误。
- en: Running ESLint from Gulp
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Gulp 运行 ESLint
- en: It's slightly messy to specify special exclusions for our Phantom integration
    test. It's also unfortunate that we're enabling the Node.js, Mocha, browser, and
    jQuery environments globally. The Mocha environment is only needed for our test
    code. The browser and jQuery environments are only need for our client-side code,
    where the Node.js environment is not needed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的 Phantom 集成测试指定特殊排除项有些杂乱。不幸的是，我们还全局启用了 Node.js、Mocha、浏览器和 jQuery 环境。Mocha
    环境只需要在我们的测试代码中使用。浏览器和 jQuery 环境只需要在我们的客户端代码中使用，而 Node.js 环境则不需要。
- en: 'This would be easier to manage if we ran ESLint separately on different sets
    of files. This would start to become tedious and error-prone if we did it manually.
    But it''s a great use case for a build tool. We can set up separate ESLint profiles
    for different sets of files using Gulp. First, install the Gulp ESLint plugin:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分别在不同的文件集上运行 ESLint，这将更容易管理。如果我们手动这样做，这会开始变得繁琐且容易出错。但这是一个构建工具的绝佳用例。我们可以使用
    Gulp 为不同的文件集设置单独的 ESLint 配置文件。首先，安装 Gulp ESLint 插件：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we can create Gulp tasks to lint each set of sources. By default, the `gulp-eslint`
    plugin uses rules from our `.eslintrc.json` file. So, we can cut this down to
    just the rules that are relevant to all sources:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建 Gulp 任务来检查每一组源代码。默认情况下，`gulp-eslint` 插件使用我们 `.eslintrc.json` 文件中的规则。因此，我们可以将其缩减为只与所有源代码相关的规则：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can then specify the relevant rules or environments for each set of sources
    in their own Gulp task. This also allows us to remove the special directive comments
    from the top of our integration test script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在各自的 Gulp 任务中指定每一组源代码的相关规则或环境。这也允许我们从集成测试脚本的顶部移除特殊的指令注释：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we wire up the dependencies between our tasks:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将任务之间的依赖关系连接起来：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we make the `test` task depend on `lint-test` and create a new overall
    `lint` task to run all of the others as part of the default build. Try running
    Gulp and observe the output. Note that it kicks off all the lint tasks in parallel,
    but waits for `lint-test` to complete before running tests. By default, Gulp will
    run tasks concurrently if possible. If a task returns a stream (the object obtained
    from `gulp.src`) at the end, Gulp is able to use this to detect when the task
    finishes. Gulp will wait for a task to finish before starting any tasks that depend
    on it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们让 `test` 任务依赖于 `lint-test`，并创建一个新的整体 `lint` 任务来运行所有其他任务作为默认构建的一部分。尝试运行
    Gulp 并观察输出。注意，它并行启动所有 lint 任务，但在运行测试之前等待 `lint-test` 完成。默认情况下，如果可能，Gulp 将并发运行任务。如果一个任务在结束时返回一个流（从
    `gulp.src` 获得的对象），Gulp 能够使用这个流来检测任务何时完成。Gulp 将在开始任何依赖于它的任务之前等待任务完成。
- en: 'To see how ESLint failures affect Gulp, let''s add another ESLint rule to ensure
    the use of JavaScript''s strict mode, as described in [Chapter 3](part0022.xhtml#aid-KVCC1
    "Chapter 3. A JavaScript Primer"), *A JavaScript Primer*. The following code is
    from `.eslintrc.json`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 ESLint 失败如何影响 Gulp，让我们添加另一个 ESLint 规则，以确保使用 JavaScript 的严格模式，如第 3 章[“JavaScript
    入门”](part0022.xhtml#aid-KVCC1 "第 3 章。JavaScript 入门")中所述。以下代码来自 `.eslintrc.json`：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'ESLint is clever enough to make use of the specified environment for each set
    of files to work out how strict mode should be applied: at the top of functions
    for client-side scripts and globally for files that will become Node.js modules.
    It also spots when we unnecessarily specify strict mode multiple times, globally
    or in nested functions.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 足够聪明，能够根据每组文件指定的环境来确定如何应用严格模式：对于客户端脚本在函数顶部，对于将成为 Node.js 模块的文件全局应用。它还会发现我们无必要多次指定严格模式，无论是全局还是嵌套函数中。
- en: When you execute Gulp, notice that failures in the ESLint tasks prevent the
    dependent test tasks from running. If you fix the strict mode errors, then Gulp
    will run successfully again.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行 Gulp 时，注意 ESLint 任务中的失败会阻止依赖的测试任务运行。如果你修复了严格模式错误，那么 Gulp 将再次成功运行。
- en: Gathering code coverage statistics
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集代码覆盖率统计信息
- en: 'Although we have some tests for our application, they are certainly not yet
    comprehensive. It would be useful to be able to see what parts of our code are
    covered by tests. For this, we''ll use Istanbul, a JavaScript code coverage tool.
    First, install the `gulp-instanbul` plugin:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们对我们的应用程序有一些测试，但它们当然还没有全面。能够看到我们的代码哪些部分被测试覆盖将很有用。为此，我们将使用 Istanbul，一个 JavaScript
    代码覆盖率工具。首先，安装 `gulp-instanbul` 插件：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we need to add a Gulp task to instrument our production code for coverage:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个 Gulp 任务来为我们的生产代码进行覆盖率测试：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we need to update our test task to output a coverage report and fail
    the build if we are below our threshold:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的测试任务以输出覆盖率报告，并在低于阈值时失败构建：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, when we run Gulp, three new results occur:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行 Gulp 时，会出现三个新的结果：
- en: A coverage summary appears on the command line
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上出现覆盖率摘要
- en: A set of coverage reports appear under the `coverage` folder
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组覆盖率报告出现在 `coverage` 文件夹下
- en: The build fails because we are below the coverage threshold
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建失败是因为我们的覆盖率低于阈值
- en: The build summary on the command line is very useful. There is even more detail
    in the HTML report that appears at `coverage/lcov-report/index.html` (in the project
    directory).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行上的构建摘要非常有用。在 `coverage/lcov-report/index.html`（项目目录中）出现的 HTML 报告中还有更多详细信息。
- en: 'Although we need to improve our test coverage, we don''t want to leave our
    build failing. For now, we''ll set the coverage target just below our current
    level so it doesn''t drop further. We can do this with the options passed to `istanbul.enforceThresholds`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们需要提高测试覆盖率，但我们不想让构建失败。目前，我们将覆盖率目标设置在当前水平以下，以防止进一步下降。我们可以通过传递给 `istanbul.enforceThresholds`
    的选项来实现这一点：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running integration tests from Gulp
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Gulp 运行集成测试
- en: 'Gulp tasks are just ordinary JavaScript functions, so can contain any functionality
    we like. Let''s look at a more complex use case. We''ll create a task that starts
    up our server, runs integration tests, and then closes the server. For this, we''ll
    need the Gulp Shell plugin:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 任务只是普通的 JavaScript 函数，因此可以包含我们喜欢的任何功能。让我们看看一个更复杂的使用案例。我们将创建一个任务，启动我们的服务器，运行集成测试，然后关闭服务器。为此，我们需要
    Gulp Shell 插件：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, we update our integration test script so that we can pass in the port
    number of the test server. This makes use of the PhantomJS `''system''` module
    as follows (in `integration-test/game.js`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们更新我们的集成测试脚本，以便我们可以传递测试服务器的端口号。这使用了 PhantomJS 的 `'system'` 模块，如下所示（在 `integration-test/game.js`
    中）：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can define a Gulp task to run the server and the integration test:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个 Gulp 任务来运行服务器和集成测试：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This launches the application and then makes use of the `gulp-shell` plugin
    to execute our integration test scripts. Finally, we make sure we close the server
    when done, passing in Gulp's async callback. Like returning a stream, using this
    callback allows Gulp to know when the task has completed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动应用程序，然后利用 `gulp-shell` 插件来执行我们的集成测试脚本。最后，我们确保在完成后关闭服务器，通过传递 Gulp 的异步回调。就像返回一个流一样，使用这个回调允许
    Gulp 知道任务何时完成。
- en: 'We make this task depend on the `test` task so that they don''t interfere with
    one another. We don''t make this part of our default task as it''s a more heavyweight
    operation. We do want it to run on our build server though, so we''ll add it to
    `.travis.yml` along with the default task:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使这个任务依赖于 `test` 任务，这样它们就不会相互干扰。我们不将这部分作为我们的默认任务，因为它是一个更重的操作。但我们确实希望它在我们的构建服务器上运行，所以我们将它添加到
    `.travis.yml` 中，与默认任务一起：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, if we push to the remote master, TravisCI will run static analysis on our
    code, execute all of our unit and integration tests, and check the unit test coverage.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们向远程主分支推送，TravisCI 将对我们的代码执行静态分析，执行所有单元和集成测试，并检查单元测试覆盖率。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have set up an integration build using Travis CI, added
    static analysis of our code using ESLint, automated our tests and other tasks
    using Gulp, and started measuring our test coverage using the Istanbul tool.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Travis CI 设置了一个集成构建，使用 ESLint 添加了代码的静态分析，使用 Gulp 自动化了我们的测试和其他任务，并开始使用
    Istanbul 工具测量测试覆盖率。
- en: Now that we have the infrastructure in place for stable development, we can
    start expanding our project. In the next chapter, we'll introduce persistent data
    stores to the application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了稳定开发的基础设施，我们可以开始扩展我们的项目。在下一章中，我们将向应用程序引入持久化数据存储。
