- en: Chapter 6. Point Clouds and Postprocessing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 点云和后处理
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Creating a point cloud based on a geometry
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于几何形状创建点云
- en: Creating a point cloud from scratch
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头创建点云
- en: Coloring individual points in a point cloud
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在点云中着色单个点
- en: Styling individual points
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式单个点
- en: Moving individual points of a point cloud
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动点云的单个点
- en: Exploding a point cloud
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爆炸点云
- en: Setting up the basic postprocessing pipeline
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置基本后处理管道
- en: Creating custom postprocessing steps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义后处理步骤
- en: Saving WebGL output to disk
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 WebGL 输出保存到磁盘
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Three.js has support for many different types of geometries and objects. In
    this chapter, we'll show you a number of recipes that use the `THREE.PointCloud`
    object. With this object, you can create a point cloud where the individual vertices
    are rendered instead of the complete mesh. You have all kinds of different styling
    options available for the points, and you can even move the individual points
    around to create very interesting-looking (and realistic) animations and simulations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 支持许多不同类型的几何形状和对象。在本章中，我们将向您展示一些使用 `THREE.PointCloud` 对象的食谱。使用此对象，你可以创建一个点云，其中渲染的是单个顶点而不是完整的网格。对于点，你有各种各样的不同样式选项可用，你甚至可以移动单个点来创建非常有趣（并且逼真）的动画和模拟。
- en: Creating a point cloud based on a geometry
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于几何形状创建点云
- en: An interesting feature of Three.js is that it also allows you to create point
    clouds. A point cloud isn't rendered as a solid geometry, but all the individual
    vertices are rendered as single points. In this recipe, we'll show you how to
    create such a point cloud based on an already existing geometry.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 的一个有趣特性是它还允许你创建点云。点云不是作为一个实体几何形状渲染，而是所有单个顶点都作为单独的点渲染。在本食谱中，我们将向您展示如何基于已经存在的几何形状创建这样的点云。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'There are no additional steps required to start with this recipe. For the example
    we use in this recipe, however, we use an external model as the basis for our
    point cloud. We also use a camera control object, `THREE.OrbitControls`, to make
    navigation around the example easier. If you want to use the camera control object
    yourself, you need to add the following JavaScript libraries to the scene (besides
    the standard Three.js one):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开始这个食谱不需要额外的步骤。然而，在本食谱中使用的示例中，我们使用外部模型作为点云的基础。我们还使用了一个相机控制对象，`THREE.OrbitControls`，以便更容易地在示例周围导航。如果你想要自己使用相机控制对象，你需要将以下
    JavaScript 库添加到场景中（除了标准的 Three.js 之外）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The external model we use is also provided with the sources in this book and
    can be found in the `assets/models/cow` folder. To see what the result of this
    recipe can look like, we provided an example that shows you a point cloud that
    was created based on an existing geometry (`06.01-create-point-cloud-from-geometry.html`).You
    will see something similar to the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的这个外部模型也包含在这本书的源代码中，可以在 `assets/models/cow` 文件夹中找到。为了展示这个食谱的结果可能看起来像什么，我们提供了一个示例，展示了基于现有几何形状创建的点云（`06.01-create-point-cloud-from-geometry.html`）。你将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_06_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_06_01.jpg)'
- en: As you can see in this screenshot, we've loaded a cow geometry and created a
    point cloud based on it. You can, of course, use any geometry you want, but especially
    complex models look really great when rendered as a point cloud.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本截图中所见，我们已经加载了一个牛的几何形状，并基于它创建了一个点云。当然，你可以使用任何你想要的几何形状，但特别是复杂模型作为点云渲染时看起来非常棒。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Creating a point cloud isn''t that different from creating a simple `THREE.Mesh`
    object. The following section explains the steps you should take:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建点云与创建简单的 `THREE.Mesh` 对象并没有太大的区别。以下部分解释了你应该采取的步骤：
- en: 'The first thing you need in this approach is `THREE.Geometry`. You can use
    either one of the standard geometries or load an external one. For this recipe,
    we''ll load an external one (the cow we mentioned in the *Getting ready* section
    of this recipe):'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种方法中，你需要的是 `THREE.Geometry`。你可以使用标准几何形状之一，或者加载一个外部几何形状。对于这个食谱，我们将加载一个外部几何形状（本食谱中*准备就绪*部分提到的牛）：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code snippet, we load the external model, so we have geometry on which
    we can base the point cloud.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们加载了外部模型，因此我们有了可以基于它建立点云的几何形状。
- en: 'Before we create the point cloud, we first have to tell Three.js what we want
    the point cloud to look like. For this, we create `THREE.PointCloudMaterial`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建点云之前，我们首先必须告诉 Three.js 我们想要点云看起来像什么。为此，我们创建 `THREE.PointCloudMaterial`：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This material defines what each point will look like. Most of the properties
    are pretty self-explanatory. The interesting one here is the `blending` property.
    By setting the `blending` property to `THREE.AdditiveBlending`, you get the nice
    glow effect you can see in the screenshot at the beginning of this recipe.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种材质定义了每个点的外观。大多数属性都是相当直观的。这里有趣的一个是 `blending` 属性。通过将 `blending` 属性设置为 `THREE.AdditiveBlending`，您可以得到在食谱开头截图中所看到的漂亮的光晕效果。
- en: 'At this point, we have `THREE.Geometry` and `THREE.PointCloudMaterial`; with
    these two objects, we can create the point cloud:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们有 `THREE.Geometry` 和 `THREE.PointCloudMaterial`；使用这两个对象，我们可以创建点云：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we pass in `THREE.Geometry` and `THREE.PointCloudMaterial` to
    create `THREE.PointCloud`. On the created point cloud, we set two additional properties
    to `true`. The `sizeAttenuation` property makes sure that the size of a point
    also depends on the distance from the camera. So, points farther away look smaller.
    The `sortPoints` property makes sure that when you use transparent points, as
    we do in this recipe, they are rendered correctly.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们传递 `THREE.Geometry` 和 `THREE.PointCloudMaterial` 来创建 `THREE.PointCloud`。在创建的点云上，我们设置两个额外的属性为
    `true`。`sizeAttenuation` 属性确保点的尺寸也取决于与摄像机的距离。因此，远离摄像机的点看起来更小。`sortPoints` 属性确保当您使用透明点时，正如我们在本食谱中所做的那样，它们会被正确渲染。
- en: 'The last step to perform is to add the created `THREE.PointCloud` object to
    the scene:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行的最后一步是将创建的 `THREE.PointCloud` 对象添加到场景中：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, Three.js will render the point cloud just like it does any other 3D object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Three.js 将像渲染任何其他 3D 对象一样渲染点云。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you create `THREE.PointCloud`, Three.js creates a point for each vertex
    of the provided `THREE.Geometry` object. No other information in `THREE.Geometry`
    is used. Internally, for `THREE.WebGLRenderer`, it directly uses `GL_POINTS`,
    which is a WebGL primitive, to render the individual points (refer to [https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml](https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml)
    for more information). Then, using a custom fragment shader, it styles these points.
    The result is that when you use `THREE.WebGLRenderer`, you can easily render millions
    of points while maintaining great performance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建 `THREE.PointCloud` 时，Three.js 会为提供的 `THREE.Geometry` 对象的每个顶点创建一个点。`THREE.Geometry`
    中的其他信息不使用。对于 `THREE.WebGLRenderer`，它内部直接使用 `GL_POINTS`，这是一个 WebGL 原语，来渲染单个点（更多信息请参考
    [https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml](https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml)）。然后，使用自定义片段着色器，它为这些点着色。结果是，当您使用
    `THREE.WebGLRenderer` 时，您可以轻松渲染数百万个点，同时保持出色的性能。
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Points are a great way to represent all kinds of different effects. For some
    interesting applications of points, you can look at the following examples:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 点是表示各种不同效果的好方法。对于一些有趣的点应用，您可以查看以下示例：
- en: 'One million points rendered on WebGL: [http://soulwire.github.io/WebGL-GPU-Particles/](http://soulwire.github.io/WebGL-GPU-Particles/)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 WebGL 上渲染一百万个点：[http://soulwire.github.io/WebGL-GPU-Particles/](http://soulwire.github.io/WebGL-GPU-Particles/)
- en: 'Morphing from one geometry to another using a point cloud: [http://oos.moxiecode.com/js_webgl/particles_morph/index.html](http://oos.moxiecode.com/js_webgl/particles_morph/index.html)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点云从一个几何体转换到另一个几何体：[http://oos.moxiecode.com/js_webgl/particles_morph/index.html](http://oos.moxiecode.com/js_webgl/particles_morph/index.html)
- en: See also
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter, we have a number of recipes that deal with points that are
    closely related to this one:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们有许多与这个密切相关的食谱：
- en: In the *Creating a point cloud from scratch* recipe, we create a point cloud
    from a custom-created geometry
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *从头创建点云* 食谱中，我们从一个自定义创建的几何体创建点云
- en: In the *Styling individual points* recipe, we show you how you can style the
    individual points of a point cloud
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *样式单个点* 食谱中，我们向您展示如何样式点云中的单个点
- en: In the *Moving individual points of a point cloud* and *Exploding a point cloud*
    recipes, we show you how you can move the points around
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *移动点云中的单个点* 和 *爆炸点云* 食谱中，我们向您展示如何移动点
- en: Creating a point cloud from scratch
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头创建点云
- en: When you want to create a point cloud, you can pass in an existing geometry
    and base the point cloud on it. In this recipe, we'll show you how you can create
    `THREE.Geometry` from scratch and create a point cloud from it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要创建点云时，您可以传入现有的几何体，并将点云基于它创建。在这个菜谱中，我们将向您展示如何从头创建 `THREE.Geometry` 并从它创建点云。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'For this recipe, we don''t require any additional JavaScript libraries and
    we don''t need to load external models, as we create our geometry from scratch.
    You can look at the geometry we created by opening `06.02-create-point-system-from-scratch.html`
    in your browser. You will see something similar to the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们不需要任何额外的 JavaScript 库，也不需要加载外部模型，因为我们从头创建我们的几何体。您可以通过在浏览器中打开 `06.02-create-point-system-from-scratch.html`
    来查看我们创建的几何体。您将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_06_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_06_02.jpg)'
- en: In the next section, we'll explain how to create this custom geometry and use
    it together with `THREE.PointCloud`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何创建这个自定义几何体并使用它与 `THREE.PointCloud` 一起。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps are pretty much the same as shown in the *Creating a point cloud
    based on a geometry* recipe, except that first, we need to create our own custom
    geometry:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤基本上与 *基于几何体创建点云* 菜谱中所示相同，除了首先我们需要创建我们自己的自定义几何体：
- en: 'Creating a custom geometry is fairly easy:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建自定义几何体相当简单：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see from this code snippet, you first need to instantiate `THREE.Geometry`
    and then create `THREE.Vector3` instances and push them to the vertices property
    of geometry.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如此代码片段所示，您首先需要实例化 `THREE.Geometry`，然后创建 `THREE.Vector3` 实例并将它们推送到几何体的顶点属性中。
- en: 'Now that we''ve got a geometry, we just need `THREE.PointCloudMaterial`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了一个几何体，我们只需要 `THREE.PointCloudMaterial`：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use this material together with the geometry to create `THREE.PointCloud` and
    add it to the scene:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这种材质与几何体一起创建 `THREE.PointCloud` 并将其添加到场景中：
- en: '[PRE7]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you've already looked at the *Creating a point cloud based on a geometry*
    recipe, you'll notice that most of the steps are the same. The only difference
    between these two recipes is how you create the geometry.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经查看过 *基于几何体创建点云* 的菜谱，您会注意到大多数步骤都是相同的。这两个菜谱之间的唯一区别是创建几何体的方式。
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For an explanation on how this works, look at the *How it works…* section from
    the *Creating a point cloud based on a geometry* recipe.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于它是如何工作的解释，请参阅 *基于几何体创建点云* 菜谱中的 *它是如何工作的…* 部分。
- en: There's more…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries and
    Meshes*, we showed how you could render 3D formulas with Three.js. With the setup
    from this recipe, you can also create 3D formulas that are visualized as point
    clouds. For instance, the following screenshot shows you a 3D formula from [Chapter
    2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries and Meshes*, rendered
    as a point cloud:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第2章](ch02.html "第2章。几何体和网格")，*几何体和网格* 中，我们展示了如何使用 Three.js 渲染 3D 公式。使用这个菜谱的设置，您也可以创建以点云形式可视化的
    3D 公式。例如，以下截图显示了 [第2章](ch02.html "第2章。几何体和网格") 中的 3D 公式，渲染为点云：
- en: '![There''s more…](img/1182OS_06_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/1182OS_06_03.jpg)'
- en: As you can see, you can very easily create great-looking point clouds this way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以通过这种方式非常容易地创建看起来很棒的点云。
- en: See also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关阅读
- en: 'There are a couple of recipes in this chapter that are related to this recipe:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有几个与这个菜谱相关的菜谱：
- en: In the *Creating a point cloud based on a geometry* recipe, we use an existing
    geometry to create a point cloud
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *基于几何体创建点云* 菜谱中，我们使用现有的几何体来创建点云
- en: In the *Styling individual points* recipe, we show you how you can style the
    individual points of a point cloud
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *样式单个点* 菜谱中，我们向您展示如何样式化点云中的单个点
- en: In the *Moving individual points of a point cloud* and *Exploding a point cloud*
    recipes, we show you how you can move the points around
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *移动点云中的单个点* 和 *爆炸点云* 的菜谱中，我们向您展示如何移动点
- en: Coloring the individual points in a point cloud
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为点云中的单个点着色
- en: When you create a point cloud, every point has the same color and style, as
    every point uses the same `THREE.PointCloudMaterial` object. There is, however,
    a way to add color to the individual points.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建点云时，每个点都有相同的颜色和样式，因为每个点都使用相同的 `THREE.PointCloudMaterial` 对象。然而，有一种方法可以为单个点添加颜色。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'There is no need for any additional steps to run this recipe. We''ll create
    a custom geometry, just like we did in the *Creating a point cloud from scratch*
    recipe, and this time, we color each individual point. The result of this recipe
    can be seen by opening `06.03-color-individual-points-in-point-system.html` in
    your browser. You will see something similar to the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此配方不需要任何额外的步骤。我们将创建一个自定义几何体，就像我们在 *从头创建点云* 配方中所做的那样，这次我们将为每个单独的点着色。此配方的结果可以通过在您的浏览器中打开
    `06.03-color-individual-points-in-point-system.html` 来查看。您将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_06_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_06_04.jpg)'
- en: As you can see, we've colored the individual points in various shades of red.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经用各种红色的阴影给各个点着色。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To accomplish individual colored points, we need to set one additional property
    when we create `THREE.Geometry`. The following steps show you how to do this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现单个着色点，我们需要在创建 `THREE.Geometry` 时设置一个额外的属性。以下步骤显示了如何做到这一点：
- en: 'We start by creating the geometry. When we create the individual vertices,
    we can also inform Three.js about the color that we want to use for it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建几何体。当我们创建单个顶点时，我们也可以通知 Three.js 我们想要为其使用的颜色：
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code snippet, we create a random color and push it to the `geometry.colors`
    array. At the end of these two loops, we will have 10000 vertices in the `vertices`
    array and 10000 colors in the `colors` array.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们创建一个随机颜色并将其推送到 `geometry.colors` 数组。在这两个循环结束时，我们将有 `vertices` 数组中的
    10000 个顶点和 `colors` 数组中的 10000 个颜色。
- en: 'Now, we can create `THREE.PointCloudMaterial` and use it together with the
    geometry to create `THREE.PointCloud`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建 `THREE.PointCloudMaterial` 并与几何体一起使用来创建 `THREE.PointCloud`：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To use the colors we created in step 1, we need to set the `vertexColors` property
    of `THREE.PointCloudMaterial` to `true`. In this code snippet, we also load a
    texture and assign it to the `map` property. We use individual colors, so there
    is no need to set the `color` property on the material we need to set color on
    `THREE.Geometry`, which we show in the next step.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用我们在步骤 1 中创建的颜色，我们需要将 `THREE.PointCloudMaterial` 的 `vertexColors` 属性设置为 `true`。在这个代码片段中，我们还加载了一个纹理并将其分配给
    `map` 属性。我们使用单个颜色，因此不需要在需要设置颜色的材质上设置 `color` 属性。我们将在下一步中展示这一点。
- en: 'If you''ve already looked at the example shown in the *Getting ready* section
    of this recipe, you''ll notice that the colors of the points change. We can easily
    do this by just changing the color in the `colors` array of the geometry in the
    render loop:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经查看过本配方中 *准备就绪* 部分所示的示例，您会注意到点的颜色发生了变化。我们可以通过只需更改渲染循环中几何体的 `colors` 数组中的颜色来轻松做到这一点：
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you change the colors, you need to set the `colorsNeedUpdate` property
    to `true` so that Three.js knows that the colors of the points need to be updated.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您更改颜色时，需要将 `colorsNeedUpdate` 属性设置为 `true`，这样 Three.js 就知道需要更新点的颜色。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Three.js uses WebGL to render individual points. For this, Three.js uses vertex
    shaders and fragment shaders (see the previous chapter for more recipes on this).
    To color the individual points, Three.js passes the information into the fragment
    shader used to determine the output color. The corresponding piece of shader code
    looks like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 使用 WebGL 来渲染单个点。为此，Three.js 使用顶点着色器和片段着色器（有关此内容的更多配方，请参阅上一章）。为了着色单个点，Three.js
    将信息传递到用于确定输出颜色的片段着色器。相应的着色器代码如下：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `psColor` variable is the one that is passed from the colors array of `THREE.Geometry`
    to the shader used to color the points.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`psColor` 变量是从 `THREE.Geometry` 的颜色数组传递到用于着色点的着色器的。'
- en: See also
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Coloring an individual point in Three.js is very simple and straightforward.
    However, if you want to change more properties of the points, such as the opacity
    or the size, you can't do that with standard Three.js. In the *Styling individual
    points* recipe, we'll show you how you can create a custom shader to also change
    these properties of the points within a point cloud.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Three.js 中着色单个点非常简单直接。然而，如果您想更改点的更多属性，如不透明度或大小，您不能使用标准的 Three.js 来做到这一点。在
    *样式化单个点* 配方中，我们将向您展示您如何创建一个自定义着色器来更改点云中点的这些属性。
- en: If you're interested in adding animation to the points in the point cloud, you
    can look at the *Moving individual points of a point cloud* and *Exploding a point
    cloud* recipes.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您对给点云中的点添加动画感兴趣，可以查看 *移动点云中的单个点* 和 *爆炸点云* 的配方。
- en: Styling individual points
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个点的样式设置
- en: With the standard Three.js functionality, you can't style the individual points
    of a point cloud. You can change their color, as we've shown in the *Coloring
    the individual points in a point cloud* recipe, but it isn't possible to change
    a point's size or opacity. In this recipe, we'll show you how to create a custom
    vertex and fragment shader, which allow you to change the color, opacity, and
    size of the individual points of a point cloud and that you can also easily extend
    to add more properties.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的Three.js功能，你不能为点云中的单个点进行样式设置。你可以改变它们的颜色，就像我们在 *在点云中为单个点着色* 菜单中所展示的那样，但无法改变点的大小或透明度。在这个菜谱中，我们将向你展示如何创建自定义的顶点和片段着色器，这允许你改变点云中单个点的颜色、透明度和大小，并且你可以轻松扩展以添加更多属性。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'There are no external libraries used in this recipe. We''ll just extend the
    basic Three.js functionality by creating our own custom shaders. To see the shaders
    in action, open the `06.04-style-individual-points-in-point-system-with-custom-shader.html`
    example in your browser. You will see something similar to the following recipe:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中没有使用外部库。我们将通过创建我们自己的自定义着色器来扩展基本的Three.js功能。要查看着色器的效果，请在你的浏览器中打开 `06.04-style-individual-points-in-point-system-with-custom-shader.html`
    示例。你将看到以下菜谱类似的内容：
- en: '![Getting ready](img/1182OS_06_05.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_06_05.jpg)'
- en: As you can see in this screenshot, the size, color, and opacity of the individual
    points differ.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如此截图所示，单个点的尺寸、颜色和透明度各不相同。
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'Let''s look at the steps that you need to take to accomplish this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你需要采取的步骤来完成这个任务：
- en: 'Let''s start simple and first create the geometry from which we''ll create
    the point cloud:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从简单开始，首先创建我们将从中创建点云的几何体：
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we create `THREE.Geometry` from scratch and generate 10,000
    vertices. As we want to change the color, size, and opacity of the individual
    vertices, we also generate values for these properties for each of the 10,000
    vertices. The colors are stored in the `geometry.colors` array as this is the
    standard Three.js functionality. We store the size in the `pSize` array and the
    opacity in the `pOpacity` array.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们从头开始创建 `THREE.Geometry` 并生成10,000个顶点。因为我们想改变单个顶点的颜色、大小和透明度，所以我们也为这10,000个顶点生成了这些属性的值。颜色存储在
    `geometry.colors` 数组中，这是Three.js的标准功能。我们将大小存储在 `pSize` 数组中，透明度存储在 `pOpacity` 数组中。
- en: 'Now that we''ve got a geometry and a couple of arrays containing the expected
    size and opacity for the individual vertices, let''s define the material for the
    point cloud:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了一个几何体和包含预期大小和透明度的单个顶点的几个数组，让我们定义点云的材质：
- en: '[PRE13]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Instead of using the standard `THREE.PointCloudMaterial` object, we use `THREE.ShaderMaterial`.
    The `transparent` and `blending` are properties standard material properties and
    behave as you'd expect. We'll explain the other properties in the upcoming steps.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们没有使用标准的 `THREE.PointCloudMaterial` 对象，而是使用了 `THREE.ShaderMaterial`。`transparent`
    和 `blending` 是标准材质属性，表现如你所预期。我们将在接下来的步骤中解释其他属性。
- en: 'In step 2, the material referenced the attributes variable. In this step, we''ll
    configure this variable:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤2中，引用了属性变量。在这个步骤中，我们将配置这个变量：
- en: '[PRE14]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our `attributes` object contains two properties. The first one points to the
    array that contains the sizes of the vertices and the second one points to the
    array that contains the opacity values. The `f` value for type means that it is
    an array of floats. As we reference this attribute from our shader material, we
    can access the individual values in our shaders.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `attributes` 对象包含两个属性。第一个属性指向包含顶点大小的数组，第二个属性指向包含透明度值的数组。类型 `f` 的 `value`
    表示它是一个浮点数数组。因为我们从着色器材质中引用了这个属性，所以我们可以在着色器中访问这些单独的值。
- en: 'In step 2, we also defined some uniforms. The `uniforms` object are also passed
    into the shader but are the same for all vertices:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤2中，我们还定义了一些统一变量。`uniforms` 对象也被传递到着色器中，但对于所有顶点来说都是相同的：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we reuse the standard uniforms Three.js uses in its shaders and use it
    to further configure the shaders.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们重用了Three.js在其着色器中使用的标准统一变量，并使用它来进一步配置着色器。
- en: 'Looking back at step 2, the only two properties we need to define are the actual
    shaders: `document.getElementById(''pointVertexShader'').text` and `document.getElementById(''pointFragmentShader'').text`.
    Let''s start with the vertex shader:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾步骤2，我们只需要定义两个属性：实际的着色器：`document.getElementById('pointVertexShader').text`
    和 `document.getElementById('pointFragmentShader').text`。让我们从顶点着色器开始：
- en: '[PRE16]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A vertex shader is used to determine the position and the size of a vertex.
    In this shader, we set the size of the vertex and the point and use the `pSize`
    attribute in the calculation. This way, we can control the size of the individual
    pixel. We also copy the value of `color` and `pOpacity` to a `varying` value so
    that we can access it from our fragment shader in the next step.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 顶点着色器用于确定顶点的位置和大小。在这个着色器中，我们设置顶点和点的大小，并使用`pSize`属性进行计算。这样，我们可以控制单个像素的大小。我们还把`color`和`pOpacity`的值复制到一个`varying`值中，这样我们就可以在下一步的片段着色器中访问它。
- en: 'So far, the size of the point could be configured directly from Three.js. Now,
    let''s look at the fragment shader and do the same for the color and opacity:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，点的大小可以直接从Three.js中配置。现在，让我们看看片段着色器，并对其进行相同的颜色和透明度设置：
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The fragment shader is only a small program. What we do here is the following:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 片段着色器只是一个小的程序。我们在这里做的事情如下：
- en: We first set the color of the fragment (the point) to the color defined on the
    material (`psColor`), and the opacity is set to the point-specific opacity (`vOpacity`).
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将片段（点）的颜色设置为材质上定义的颜色(`psColor`)，透明度设置为点特定的透明度(`vOpacity`)。
- en: Next, we apply the provided texture (`map`).
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应用提供的纹理(`map`)。
- en: Finally, we multiply the color value(`gl_Fragcolor`) with the point specific
    color(`vcolor`).
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将颜色值(`gl_Fragcolor`)与点特定颜色(`vcolor`)相乘。
- en: 'At this point, we''ve configured the material and created the specific shaders.
    Now, we can just create the point cloud and add it to the scene:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经配置了材质并创建了特定的着色器。现在，我们只需创建点云并将其添加到场景中：
- en: '[PRE18]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this last step, you're done.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这一最后步骤，您就完成了。
- en: As you can see, as this isn't a standard Three.js functionality, we need to
    take some additional steps to accomplish our goals.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这不是一个标准的Three.js功能，我们需要采取一些额外的步骤来实现我们的目标。
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous section, we've already explained a bit how the styling of individual
    points works. The main thing to remember here is that under the hood, Three.js
    creates vertex and fragment shaders for rendering. If there is a functionality
    you want that can't be configured in the standard shaders, you can use `THREE.ShaderMaterial`
    to create your own custom implementations. You can still use Three.js to create
    your geometries and handle all the WebGL initialization stuff but use your own
    shader implementations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经解释了如何对单个点进行样式化的一些内容。这里要记住的主要事情是，在底层，Three.js为渲染创建顶点和片段着色器。如果您想要的功能在标准着色器中无法配置，您可以使用`THREE.ShaderMaterial`来创建自己的自定义实现。您仍然可以使用Three.js来创建您的几何体并处理所有WebGL初始化内容，但使用您自己的着色器实现。
- en: There's more…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: With this setup, you've got a basic skeleton to create your own custom shader
    based on point clouds. You can now easily add more functionalities, other configuration
    options, and more by just adding to this setup.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，您已经有一个基本的框架来创建基于点云的自定义着色器。您现在可以很容易地通过添加更多功能、其他配置选项等来扩展这个设置。
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you just want to color an individual point, you can refer to the *Coloring
    the individual points in a point cloud* recipe, and if you're interested in adding
    animation to the points in the point cloud, you can refer to the *Moving individual
    points of a point cloud* and *Exploding a point cloud* recipes.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您只想着色单个点，可以参考“*在点云中着色单个点*”食谱，如果您对在点云中添加动画感兴趣，可以参考“*移动点云中的单个点*”和“*爆炸点云*”食谱。
- en: There are also a couple of other recipes that use vertex and fragment shaders.
    In this chapter, you can find the *Creating custom postprocessing steps* recipe,
    which uses a shader as a postprocessing effect. In [Chapter 5](ch05.html "Chapter 5. Lights
    and Custom Shaders"), *Light and Custom Shaders*, we have the *Creating a custom
    vertex shader* recipe, which uses a custom vertex shader to alter the shape of
    a geometry, and the *Creating a custom fragment shader* recipe, which colors 3D
    objects using a custom fragment shader implementation.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一些其他使用顶点和片段着色器的食谱。在本章中，您可以找到“*创建自定义后处理步骤*”食谱，它使用着色器作为后处理效果。在[第5章](ch05.html
    "第5章。光和自定义着色器")“*光和自定义着色器*”，我们有“*创建自定义顶点着色器*”食谱，它使用自定义顶点着色器来改变几何形状，以及“*创建自定义片段着色器*”食谱，它使用自定义片段着色器实现来着色3D对象。
- en: Moving individual points of a point cloud
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动点云中的单个点
- en: When you create a point cloud from a geometry, the position of the points is
    based on the vertices from the provided geometry. The result is a point cloud
    where the individual points don't move. In this recipe, we show you how you can
    move the individual points of a point cloud.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从几何体创建点云时，点的位置基于提供的几何体的顶点。结果是点云中各个点不会移动。在这个示例中，我们向您展示如何移动点云中的各个点。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we require a point cloud that contains some points. You can
    create your own one (as we explained in the *Creating a point cloud from scratch*
    and *Creating a point cloud from an existing geometry* recipes). We will use the
    point cloud we created in the *Styling individual points* recipe. As always, we''ve
    provided an example where you can see the final result of this recipe. Open `06.05-move-individual-points.html`
    in your browser, and you''ll see the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要一个包含一些点的点云。您可以创建自己的点云（如我们在*从头开始创建点云*和*从现有几何体创建点云*示例中解释的）。我们将使用在*样式化单个点*示例中创建的点云。像往常一样，我们提供了一个示例，您可以在其中看到此示例的最终结果。在您的浏览器中打开`06.05-move-individual-points.html`，您将看到以下截图：
- en: '![Getting ready](img/1182OS_06_06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_06_06.jpg)'
- en: If you open this in your browser, you'll see all the points being moved around
    the screen. In the following section, we'll explain how you can do that.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开它，您将看到所有点在屏幕周围移动。在下一节中，我们将解释您如何做到这一点。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create moving points, we need to perform the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建移动的点，我们需要执行以下步骤：
- en: Make sure you've got a point cloud with a geometry. Look at the *Creating a
    point cloud from scratch* and *Creating a point cloud based on a geometry* recipes
    to learn how to create such a point cloud. In this recipe, we assume the point
    cloud can be referenced through the `ps` variable.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您有一个包含一些点的点云。查看*从头开始创建点云*和*基于几何体创建点云*示例，了解如何创建此类点云。在这个示例中，我们假设点云可以通过`ps`变量引用。
- en: 'The next step is to update the position of the individual points of the point
    cloud. We do that by updating the `render` loop:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是更新点云中各个点的位置。我们通过更新`render`循环来完成：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `render` loop, we access geometry through the `ps` variable. Next, we
    change the `y` position (`v.y`) of each point based on the value of the step variable.
    By increasing the step value in each render loop, we create the animation you
    can see when you look at the example for this recipe. Finally, we need to tell
    Three.js that the positions of the vertices in the geometry have changed by setting
    `geometry.verticesNeedUpdate` to `true`.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`render`循环中，我们通过`ps`变量访问几何体。接下来，我们根据步进变量的值改变每个点的`y`位置（`v.y`）。通过在每次渲染循环中增加步进值，我们创建了您查看此示例时可以看到的动画。最后，我们需要通过将`geometry.verticesNeedUpdate`设置为`true`来告诉Three.js几何体中顶点的位置已更改。
- en: In this recipe, we also change the colors of each point, so to inform Three.js
    about these changes, we also set `geometry.colorsNeedUpdate` to `true`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们也改变了每个点的颜色，以便通知Three.js这些变化，因此我们也设置`geometry.colorsNeedUpdate`为`true`。
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe works in a very simple way. A point cloud is created based on the
    position of the vertices of `THREE.Geometry` by simply changing the position of
    the vertices around which we can move the points.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例以非常简单的方式工作。通过简单地改变可以移动点的顶点位置，基于`THREE.Geometry`的顶点位置创建点云。
- en: See also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: In this recipe, we changed the position of the vertices in a very simple way.
    We just changed the *y* value of the vertex. In the *Exploding a point cloud*
    recipe, we show you an approach where the position of a vertex is changed based
    on its normal vector.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们以非常简单的方式改变了顶点的位置。我们只是改变了顶点的*y*值。在*爆炸点云*示例中，我们向您展示了一种根据顶点的法向量改变顶点位置的方法。
- en: Exploding a point cloud
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爆炸点云
- en: You can create many interesting effects with point clouds. You can, for instance,
    create water, smoke, and cloud effects. In this recipe, we show you another interesting
    effect you can create with points. We'll show you how you can explode a point
    cloud where each point's path is based on its normal vector.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用点云创建许多有趣的效果。例如，您可以创建水、烟雾和云效果。在这个示例中，我们向您展示另一种使用点可以创建的有趣效果。我们将向您展示如何根据每个点的法向量爆炸点云。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, there aren''t any steps that need to be taken before we start
    looking at the recipe. We''ve provided an example where you can see the resulting
    explosion in action. Open the `06.06-explode-geometry.html` example in your browser
    and you''ll see a screen that looks like the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，在我们开始查看食谱之前，不需要采取任何步骤。我们提供了一个示例，你可以看到结果爆炸的效果。在浏览器中打开 `06.06-explode-geometry.html`
    示例，你会看到一个类似于以下截图的屏幕：
- en: '![Getting ready](img/1182OS_06_07.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_06_07.jpg)'
- en: If you click on the **implode** button, the points will move to the middle of
    the screen; if you click on **explode**, they'll move outwards. With the **speed**
    property, you can set the speed at which the points will move.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 **implode** 按钮，点将移动到屏幕中央；如果你点击 **explode**，它们将向外移动。通过 **speed** 属性，你可以设置点移动的速度。
- en: How to do it…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To accomplish this effect, you only need to perform a couple of small steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个效果，你只需要执行几个小步骤：
- en: 'The first thing we need to do is create the geometry. For the best effect,
    we use a geometry with lots of vertices:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建几何形状。为了达到最佳效果，我们使用具有许多顶点的几何形状：
- en: '[PRE20]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we don't just create the geometry; we also add a `velocity`
    parameter to each of the vertices, which we set to a random value. We do this
    to make sure not all the points explode at the same speed (which would have the
    same effect as just scaling the geometry).
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们不仅创建了几何形状，还向每个顶点添加了一个 `velocity` 参数，并将其设置为随机值。我们这样做是为了确保不是所有点以相同的速度爆炸（这将产生与仅缩放几何形状相同的效果）。
- en: 'Now, we can create the point cloud:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建点云了：
- en: '[PRE21]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is just a standard point cloud based on the geometry we created in step
    1.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只是一个基于我们在步骤 1 中创建的几何形状的标准点云。
- en: 'In the introduction to the recipe, we mentioned that we wanted to explode the
    points based on their normal vector. So, before we start rendering the scene and
    updating the position of the individual points, we first need to calculate the
    normal of each vector:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在食谱的介绍中，我们提到我们想要根据每个点的法向量来爆炸点。因此，在我们开始渲染场景和更新单个点的位置之前，我们首先需要计算每个向量的法线：
- en: '[PRE22]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We won't explain this code snippet in detail, but what we do here is that we
    calculate the normal vector of each vertex based on the normal vectors of the
    faces the particular vector is part of. The final normal vector is stored in the
    `avgVertexNormals` array.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不会详细解释这个代码片段，但在这里我们所做的是根据特定向量所属面的法向量计算每个顶点的法向量。最终的法向量存储在 `avgVertexNormals`
    数组中。
- en: 'Next, we look at a helper function that we''ll call from the `render` loop
    in the next step. This function determines the new position of each vertex based
    on the velocity function we defined in step 1 and the normal vector we calculated
    in step 3:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们看看一个辅助函数，我们将在下一步的 `render` 循环中调用它。这个函数根据我们在步骤 1 中定义的速度函数和步骤 3 中计算的法向量确定每个顶点的新位置：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `control.scale` variable is set through GUI and determines the speed at
    which our geometry expands, and the `dir` property is based on whether we want
    to move the points outwards or inwards. The `verticesNeedUpdate` property is required
    to inform Three.js about these changes.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`control.scale` 变量通过 GUI 设置，并决定了我们的几何形状扩展的速度，而 `dir` 属性则基于我们是要将点向外移动还是向内移动。`verticesNeedUpdate`
    属性是必需的，用于通知 Three.js 这些变化。'
- en: 'Now all that is left to do is call the explode function from the `render` loop:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的唯一事情就是从 `render` 循环中调用 `explode` 函数：
- en: '[PRE24]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's more
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: In this example, we've used a standard geometry; you can, of course, also use
    an externally loaded model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个标准几何形状；当然，你也可以使用外部加载的模型。
- en: '![There''s more](img/1182OS_06_08.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多](img/1182OS_06_08.jpg)'
- en: This screenshot, for instance, shows you an exploding model of a cow.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个截图展示了牛的爆炸模型。
- en: See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Another recipe that deals with animation and moving individual points around
    can be found in the *Moving individual points of a point cloud* recipe.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个处理动画和移动单个点的食谱可以在 *移动点云中的单个点* 食谱中找到。
- en: Setting up the basic postprocessing pipeline
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本后处理管线
- en: Besides rendering a scene in 3D, Three.js also allows you to add postprocessing
    effects to the final output. With postprocessing, you can take the final rendered
    2D image and apply all different kinds of filters to it. You could, for instance,
    add specific blurring effects, sharpen specific colors, and much more. In this
    recipe, we'll show you how to set up a postprocessing pipeline in Three.js, which
    you can use to add effects to the final rendered scene.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在3D中渲染场景外，Three.js还允许您将后处理效果添加到最终输出中。通过后处理，您可以将最终渲染的2D图像应用所有不同类型的过滤器。例如，您可以添加特定的模糊效果，锐化特定的颜色，等等。在这个菜谱中，我们将向您展示如何在Three.js中设置后处理管道，您可以使用它来向最终渲染的场景添加效果。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To work with postprocessing in Three.js, you need to include a number of additional
    JavaScript files from the Three.js distribution. For this recipe, the following
    JavaScript files should be added to your HTML page:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Three.js中使用后处理，您需要包含来自Three.js分发的多个额外的JavaScript文件。对于这个菜谱，以下JavaScript文件应该添加到您的HTML页面中：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To demonstrate how postprocessing works, we''ll apply the dot-screen effect
    to a Three.js scene. For this effect, we require one additional JavaScript file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示后处理是如何工作的，我们将把点屏幕效果应用到Three.js场景中。为了这个效果，我们需要一个额外的JavaScript文件：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''ve also provided an example that shows you the final result of this recipe.
    You can view this by opening `06.07-setup-basic-post-processing-pipeline.html`
    in your browser. You will see something similar to the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一个示例，展示了这个菜谱的最终结果。您可以通过在浏览器中打开`06.07-setup-basic-post-processing-pipeline.html`来查看它。您将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_06_09.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_06_09.jpg)'
- en: In this screenshot, you can see that we've rendered a scene with a large number
    of cubes and applied an effect to render it as a series of dots.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，您可以看到我们已经渲染了一个包含大量立方体的场景，并应用了一个效果将其渲染为一系列点。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Setting up a postprocessing pipeline only takes a couple of small steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 设置后处理管道只需要几个小步骤：
- en: 'To set up a postprocessing pipeline, we need something called a composer. We''ll
    use this composer in the `render` loop to create the final output. The first thing
    we need for that is a new global variable:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置一个后处理管道，我们需要一个叫做作曲家的东西。我们将在`render`循环中使用这个作曲家来创建最终输出。为此，我们首先需要一个新全局变量：
- en: '[PRE27]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we need to instantiate a composer as a new instance of `THREE.EffectComposer`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实例化一个作曲家，作为`THREE.EffectComposer`的新实例：
- en: '[PRE28]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We pass in `THREE.WebGLRenderer`, which we would normally use to render the
    scene.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们传递`THREE.WebGLRenderer`，这是我们通常用来渲染场景的。
- en: 'Now, we need to define the steps that the composer will execute. These steps
    are executed sequentially and we can use them to apply multiple effects to the
    scene. The first step we always need to take is to render the scene. For this,
    we use `THREE.RenderPass`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义作曲家将要执行的步骤。这些步骤是顺序执行的，我们可以使用它们来对场景应用多个效果。我们始终需要采取的第一步是渲染场景。为此，我们使用`THREE.RenderPass`：
- en: '[PRE29]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A render pass renders a scene object using the provided camera and renderer
    we configured in step 2.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 渲染过程使用我们在第二步中配置的相机和渲染器渲染场景对象。
- en: 'Now that we''ve rendered the scene, we can apply a postprocessing effect. For
    this recipe, we use `THREE.DotScreenShader`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经渲染了场景，我们可以应用一个后处理效果。对于这个菜谱，我们使用`THREE.DotScreenShader`：
- en: '[PRE30]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this code snippet, we create a postprocessing step (`THREE.ShaderPass`),
    add it to the composer (`composer.addPass(effect)`), and tell the effect composer
    to render the output of this step to screen by setting `renderToScreen` to `true`.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们创建了一个后处理步骤（`THREE.ShaderPass`），将其添加到作曲家（`composer.addPass(effect)`），并告诉效果作曲家通过将`renderToScreen`设置为`true`将此步骤的输出渲染到屏幕上。
- en: 'The final step we need to take is to alter the render loop:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要采取的最后一步是修改渲染循环：
- en: '[PRE31]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, we now use the `composer` object we created in step 2 to render
    the final output instead of `THREE.WebGLRenderer`.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们现在使用在第二步中创建的`composer`对象来渲染最终输出，而不是`THREE.WebGLRenderer`。
- en: In this recipe, we've only used a single postprocessing step, but you can use
    as many steps as you want. You just have to remember that in the final step, you
    set the `renderToScreen` property to `true`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们只使用了一个后处理步骤，但您可以使用任意多的步骤。您只需记住，在最终步骤中，您需要将`renderToScreen`属性设置为`true`。
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In a couple of recipes, we've already explained that Three.js uses WebGL shaders
    to render the 3D scenes. `THREE.EffectComposer` uses the same approach. Each of
    the steps you add run a simple vertex and fragment shader on the output from the
    previous step. In the *Creating custom postprocessing steps* recipe, we'll dive
    into more detail and create a custom postprocessing step ourselves.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个菜谱中，我们已经解释了 Three.js 使用 WebGL 着色器来渲染 3D 场景。`THREE.EffectComposer` 使用相同的方法。您添加的每个步骤都在前一个步骤的输出上运行一个简单的顶点和片段着色器。在
    *创建自定义后处理步骤* 菜谱中，我们将深入了解并创建一个自定义后处理步骤。
- en: There's more
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: 'Three.js provides a large number of standard shaders and steps you can use
    in `THREE.EffectComposer`. For a complete overview of the possible shaders and
    standard steps, look at the following directories:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了大量标准着色器和步骤，您可以在 `THREE.EffectComposer` 中使用。为了全面了解可能的着色器和标准步骤，请查看以下目录：
- en: '[https://github.com/mrdoob/three.js/tree/master/examples/js/postprocessing](https://github.com/mrdoob/three.js/tree/master/examples/js/postprocessing):
    This directory contains all the standard postprocessing steps you can use with
    `THREE.EffectComposer`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mrdoob/three.js/tree/master/examples/js/postprocessing](https://github.com/mrdoob/three.js/tree/master/examples/js/postprocessing)：此目录包含所有您可以使用
    `THREE.EffectComposer` 的标准后处理步骤。'
- en: '[https://github.com/mrdoob/three.js/tree/master/examples/js/shaders](https://github.com/mrdoob/three.js/tree/master/examples/js/shaders):
    Three.js provides the `THREE.ShaderPass` postprocessing step, which allows you
    to directly use WebGL shaders. On this page, you can find a large number of shaders
    that can be used with the `THREE.ShaderPass` object.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mrdoob/three.js/tree/master/examples/js/shaders](https://github.com/mrdoob/three.js/tree/master/examples/js/shaders)：Three.js
    提供了 `THREE.ShaderPass` 后处理步骤，允许您直接使用 WebGL 着色器。在此页面上，您可以找到大量可用于 `THREE.ShaderPass`
    对象的着色器。'
- en: See also
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Even though Three.js provides a large number of standard shaders and postprocessing
    steps, you can also easily create your own. In the *Creating custom postprocessing
    steps* recipe, we show you how to create a custom vertex and fragment shader that
    works with `THREE`.`EffectComposer`.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管Three.js提供了大量的标准着色器和后处理步骤，但您也可以轻松创建自己的。在 *创建自定义后处理步骤* 菜谱中，我们向您展示了如何创建一个与 `THREE.EffectComposer`
    一起工作的自定义顶点和片段着色器。
- en: Creating custom postprocessing steps
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义后处理步骤
- en: In the *Setting up the basic postprocessing pipeline* recipe, we showed you
    how you can use `THREE.EffectComposer` to add postprocessing effects to a rendered
    Three.js scene. In this recipe, we'll explain how you can create custom processing
    steps that you can use with `THREE.EffectComposer`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *设置基本后处理管道* 菜谱中，我们向您展示了如何使用 `THREE.EffectComposer` 为 Three.js 场景添加后处理效果。在本菜谱中，我们将解释如何创建自定义处理步骤，您可以使用
    `THREE.EffectComposer` 来使用这些步骤。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe uses `THREE.EffectComposer`, so we need to load some additional
    JavaScript files with the correct objects. For this, you need to add the following
    at the top of your HTML page:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱使用 `THREE.EffectComposer`，因此我们需要加载一些包含正确对象的附加 JavaScript 文件。为此，您需要在 HTML
    页面的顶部添加以下内容：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this recipe, we''ll create a postprocessing effect that converts the output
    using a mosaic effect. You can look at the final result by opening `06.08-create-custom-post-processing-step.html`
    in your browser. You will see something similar to the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将创建一个使用马赛克效果转换输出的后处理效果。您可以通过在浏览器中打开 `06.08-create-custom-post-processing-step.html`
    来查看最终结果。您将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_06_10.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_06_10.jpg)'
- en: You might not recognize this, but what you're seeing is a large number of cubes
    that are rotating.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会认出这个，但你看到的是大量正在旋转的立方体。
- en: How to do it…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We create this effect by using a custom fragment shader. The following steps
    explain how to set this up:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用自定义片段着色器来创建此效果。以下步骤解释了如何设置：
- en: 'We first need to create `THREE.EffectComposer` and configure the steps:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要创建 `THREE.EffectComposer` 并配置步骤：
- en: '[PRE33]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So far, we have only added the render step (`THREE.RenderPass`), which renders
    the scene and allows us to add additional postprocessing effects.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们只添加了渲染步骤 (`THREE.RenderPass`)，它渲染场景并允许我们添加额外的后处理效果。
- en: 'To use custom shaders, we''ll need to use the `THREE.ShaderPass` object:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用自定义着色器，我们需要使用 `THREE.ShaderPass` 对象：
- en: '[PRE34]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We pass in `customShader` as an argument to `THREE.ShaderPass`. This `customShader`
    object contains the configuration of our custom shader. The `uniforms` objects
    are the variables we pass into our custom shader, and `vertexShader` and `fragmentShader`
    point to our shader programs.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`customShader`作为参数传递给`THREE.ShaderPass`。这个`customShader`对象包含我们自定义着色器的配置。`uniforms`对象是我们传递给我们的自定义着色器的变量，而`vertexShader`和`fragmentShader`指向我们的着色器程序。
- en: 'Let''s first look at `vertexShader` from step 2:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先看看第2步中的`vertexShader`：
- en: '[PRE35]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is a simple vertex shader that doesn't change anything related to the output.
    The only thing to notice in this shader code is that we pass the coordinate that
    we're working on (`uv`, which is automatically passed in by Three.js) to the fragment
    shader as a `varying` value with the `texCoord` name.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个简单的顶点着色器，它不会改变与输出相关的任何内容。在这个着色器代码中需要注意的唯一一点是我们将正在处理的坐标（`uv`，由Three.js自动传入）作为名为`texCoord`的`varying`值传递给片元着色器。
- en: 'The final step is to look at the fragment shader from step 2:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是查看第2步中的片元着色器：
- en: '[PRE36]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a rather large shader program and explaining the details is a bit out
    of scope for this recipe. In short, what happens is that this shader looks at
    the color of the surrounding pixels and based on that, it determines how to draw
    this pixel. The important item to notice here is `uniform sampler2D tDiffuse`
    at the top of the code. This is the output of the previous render step passed
    into the shader as a 2D texture. Using `tDiffuse` in the calculations, we can
    change the output that is rendered on screen. If we don't want to apply an effect,
    we would just use `vec4 color = texture2D(tDiffuse, texCoord)` to set the output
    color.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个相当大的着色器程序，详细解释超出了这个配方的范围。简而言之，这个着色器查看周围像素的颜色，并根据这个信息确定如何绘制这个像素。这里需要注意的重要项是代码顶部的`uniform
    sampler2D tDiffuse`。这是传递给着色器作为2D纹理的前一个渲染步骤的输出。在计算中使用`tDiffuse`，我们可以改变屏幕上渲染的输出。如果我们不想应用效果，我们只需使用`vec4
    color = texture2D(tDiffuse, texCoord)`来设置输出颜色。
- en: 'The last step is to update the `render` loop to use composer instead of renderer:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将`render`循环更新为使用composer而不是renderer：
- en: '[PRE37]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Writing shaders is difficult work; a setup like this, however, makes it a lot
    easier to create your own custom shaders. Just replace the fragment shader from
    step 4 with your own implementation and you can start experimenting.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 编写着色器是一项困难的工作；然而，这样的设置使得创建你自己的自定义着色器变得容易得多。只需用你的实现替换第4步中的片段着色器，你就可以开始实验了。
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we've used `THREE.EffectComposer` together with `THREE.RenderPass`
    to render the scene. If we add more steps to `THREE.EffectComposer`, we can access
    the current rendering directly from our shader by accessing the `tDiffuse` texture.
    This way, we can easily add all kinds of effects by just writing a shader that
    uses the `tDiffuse` texture as its input.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了`THREE.EffectComposer`和`THREE.RenderPass`来渲染场景。如果我们向`THREE.EffectComposer`添加更多步骤，我们可以通过访问`tDiffuse`纹理直接从我们的着色器中访问当前渲染。这样，我们只需编写一个使用`tDiffuse`纹理作为其输入的着色器，就可以轻松地添加各种效果。
- en: There's more…
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you write shaders, you can pretty much create whatever you want. Getting
    started with shaders, however, can be rather difficult. A good example of some
    shaders that apply a specific effect can be found at [https://github.com/evanw/glfx.js](https://github.com/evanw/glfx.js).
    The shader we used in this recipe was also adopted from the `hexagonpixalte.js`
    shader that you can find in the `src/filters/fun/hexagonalpixelate.js` folder
    in the mentioned GitHub repository.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写着色器时，你可以几乎创建任何你想要的东西。然而，着色器的入门可能相当困难。一些应用特定效果的着色器的良好例子可以在[https://github.com/evanw/glfx.js](https://github.com/evanw/glfx.js)找到。我们在这个配方中使用的着色器也是从`hexagonpixalte.js`着色器中采用的，该着色器可以在提到的GitHub仓库中的`src/filters/fun/hexagonalpixelate.js`文件夹中找到。
- en: You can also look at the sources of the effects that are provided by Three.js.
    You can access them directly from GitHub at [https://github.com/mrdoob/three.js/tree/master/examples/js/shaders](https://github.com/mrdoob/three.js/tree/master/examples/js/shaders).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以查看Three.js提供的效果的源代码。你可以直接从GitHub在[https://github.com/mrdoob/three.js/tree/master/examples/js/shaders](https://github.com/mrdoob/three.js/tree/master/examples/js/shaders)访问它们。
- en: See also
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](ch05.html "Chapter 5. Lights and Custom Shaders"), *Lights and
    Custom Shaders*, we''ve also created two custom shaders:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。灯光和自定义着色器")中，我们也创建了两个自定义着色器：
- en: In the *Creating a custom vertex shader* recipe, we explain the steps you need
    to take to set up a custom vertex shader
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *创建自定义顶点着色器* 菜谱中，我们解释了您需要采取的步骤来设置自定义顶点着色器
- en: In the *Creating a custom fragment shader* recipe, we explain the steps you
    need to take to set up a custom fragment shader
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *创建自定义片段着色器* 菜谱中，我们解释了您需要采取的步骤来设置自定义片段着色器
- en: Saving WebGL output to disk
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 WebGL 输出保存到磁盘
- en: In this book we've created some very beautiful visualizations so far. The trouble
    with this, however, is that it's difficult to save the output of your rendering
    as an image. In this recipe, we'll show you how you can create a normal image
    from a WebGL-rendered scene, which can be saved to the disk.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们迄今为止已经创建了一些非常漂亮的可视化效果。然而，问题在于很难将渲染输出保存为图像。在这个菜谱中，我们将向您展示如何从 WebGL 渲染场景中创建一个普通图像，并将其保存到磁盘上。
- en: Getting ready
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There isn''t much to do in order to get ready for this recipe. We''ll be using
    standard HTML5 features, which you can apply not just to Three.js-based outputs,
    but to any HTML5 canvas element. We''ve prepared a very simple example page, where
    you test the result of this recipe. For this, open the `06.09-save-webgl-output.html`
    example in your browser. You will see something similar to the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个菜谱，没有太多的事情要做。我们将使用标准的 HTML5 功能，这些功能不仅适用于基于 Three.js 的输出，还适用于任何 HTML5 画布元素。我们已经准备了一个非常简单的示例页面，您可以测试这个菜谱的结果。为此，在您的浏览器中打开
    `06.09-save-webgl-output.html` 示例。您将看到类似于以下截图的内容：
- en: '![Getting ready](img/1182OS_06_11.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_06_11.jpg)'
- en: On this page, you'll see a single Three.js scene. If you hit the *p* key, the
    current state will be saved as a new image, which you can then download normally.
    Note that in the preceding screenshot, we've zoomed out of the page.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，您将看到一个单独的 Three.js 场景。如果您按下 *p* 键，当前状态将被保存为新的图像，然后您可以正常下载。请注意，在先前的截图中，我们已经缩小了页面。
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this recipe, we only need to take a couple of simple steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们只需要采取几个简单的步骤：
- en: 'The first thing we do is register an event listener for key presses:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先为按键注册一个事件监听器：
- en: '[PRE38]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Whenever a key is pressed, the `copyCanvas` function will be called.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当按下键时，`copyCanvas` 函数将被调用。
- en: 'Now let''s look at the `copyCanvas` function:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看 `copyCanvas` 函数：
- en: '[PRE39]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first thing we do here is check which key was pressed. If the *p* key was
    pressed, we'll continue. Next, we take the image data from the canvas with the
    `toDataURL()` function. The final step we need to take is to create a new `img`
    element, assign the data (`imgData`), and add it to the document.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里做的第一件事是检查哪个键被按下。如果按下 *p* 键，我们将继续。接下来，我们使用 `toDataURL()` 函数从画布中获取图像数据。我们需要采取的最后一步是创建一个新的
    `img` 元素，分配数据（`imgData`），并将其添加到文档中。
- en: 'This would work for non-WebGL canvas elements. However, if you work with WebGL,
    we need to take one additional step. We need to instantiate `THREE.WebGLRenderer`
    like this:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将适用于非 WebGL 画布元素。然而，如果您使用 WebGL，我们需要采取一个额外的步骤。我们需要像这样实例化 `THREE.WebGLRenderer`：
- en: '[PRE40]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we don't do this, you'll only see a black screen in the output and not the
    actual WebGL output. Note, though, that this does have an adverse impact on performance.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们不这样做，您将只看到输出中的黑色屏幕，而不是实际的 WebGL 输出。不过，请注意，这确实会对性能产生不利影响。
- en: How it works...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In HTML5, it is possible to describe a file or any other resource using a URL
    starting with data. So, instead of fetching resources in multiple HTTP requests,
    these resources could be included directly in the HTML document. The canvas element
    allows you to copy its contents as a URL that complies with this scheme. In this
    recipe, we use this data URL to create a new `img` element, which can be saved
    like a normal image.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML5 中，可以使用以 data 开头的 URL 描述文件或其他资源。因此，而不是通过多个 HTTP 请求获取资源，这些资源可以直接包含在 HTML
    文档中。画布元素允许您将其内容复制为符合此方案的 URL。在这个菜谱中，我们使用这个数据 URL 创建一个新的 `img` 元素，它可以像普通图像一样保存。
- en: If you want to dive into the details of the data URL scheme, you can look at
    the RFC (Request For Comments) that describes this scheme at [http://tools.ietf.org/html/rfc2397](http://tools.ietf.org/html/rfc2397).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解数据 URL 方案的细节，你可以查看描述此方案的 RFC（请求评论）[http://tools.ietf.org/html/rfc2397](http://tools.ietf.org/html/rfc2397)。
- en: There's more
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'In the most recent version of Chrome and Firefox, you can also save the output
    of an HTML canvas element by right-clicking and selecting **Save Image As**. Besides
    using the standard browser functionality, it is also possible to directly start
    the download of the image. If you use the following piece of code instead of creating
    and adding a new image, the browser will automatically download the canvas as
    an image:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新版本的 Chrome 和 Firefox 中，你也可以通过右键点击并选择**另存为图片**来保存 HTML 画布元素的输出。除了使用标准的浏览器功能外，还可以直接开始下载图片。如果你使用以下代码而不是创建和添加新图片，浏览器将自动将画布作为图片下载：
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, If you''ve got an animation that you want to save as a movie, you
    can do that as well. You can find instructions on how to do this at: [http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets](http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你有一个想要保存为电影的动画，你也可以做到这一点。你可以在以下链接找到如何操作的说明：[http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets](http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets)
