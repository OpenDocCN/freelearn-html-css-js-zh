- en: Chapter 3. Synchronizing with Promises
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。使用承诺进行同步
- en: Implementations of promises have existed for many years inside JavaScript libraries.
    It all started with the Promises/A+ specification. Libraries implemented their
    own variations of this specification, and it wasn't until recently (ES6 to be
    exact) that the Promise specification made it into the JavaScript language. They
    do what the chapter title suggests—help us apply the synchronization principle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 库中已经存在了许多年的承诺（promises）实现。这一切始于 Promises/A+ 规范。库们实现了这个规范的自己的变体，直到最近（确切地说，是
    ES6）承诺规范才被纳入 JavaScript 语言。它们做了章节标题所暗示的事情——帮助我们应用同步原则。
- en: In this chapter, we'll start of with a gentle introduction to the various terms
    used in promise-speak so that the remainder of the chapter will be a little easier
    to follow. Then, well go through the various ways that promises are used to resolve
    future values and make our lives easier when we deal with concurrency. Ready?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从对承诺术语的温和介绍开始，这样本章的其余部分就会更容易理解。然后，我们将探讨承诺被用来解决未来值的各种方式，以及我们在处理并发时如何使生活变得更轻松。准备好了吗？
- en: Promise terminology
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺术语
- en: Before we dive right into the code examples, let's take a minute to make sure
    we have a firm grasp on the terminology surrounding promises. There are promise
    instances, but then there are also various states and actions to consider. The
    sections that follow will make much more sense if we can nail down the promise
    lexicon. These explanations are short and sweet, so if you've already used promises,
    you can quickly gloss over these definitions to sanity check your knowledge.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码示例之前，让我们花一分钟时间确保我们对承诺周围的术语有一个牢固的掌握。有承诺实例，但还有各种状态和动作需要考虑。以下各节将更加有意义，如果我们能够确定承诺词汇表。这些解释简短而直接，所以如果你已经使用过承诺，你可以快速浏览这些定义以验证你的知识。
- en: Promise
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺
- en: As the name suggests, a promise is, well, a promise. Think of a promise as a
    proxy for a value that doesn't exist yet. The promise let's us write better concurrent
    code because we know that the value will be there at some point, and we don't
    have to write lots of state-checking boilerplate code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所暗示的，承诺就是承诺。将承诺想象为一个代理，它代表一个尚未存在的值。承诺让我们能够编写更好的并发代码，因为我们知道值最终会存在，我们不必编写大量的状态检查样板代码。
- en: State
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: 'Promises are always in one of three states:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺始终处于三种状态之一：
- en: '**Pending**: This is the first state of a promise after it''s been created.
    It remains in a pending state until it''s fulfilled or rejected.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：这是承诺创建后的第一个状态。它保持在挂起状态，直到它被解决或拒绝。'
- en: '**Fulfilled**: The promise value has been resolved and is available to the
    `then()` callback function.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已解决**：承诺的值已经被解决，并且可以通过 `then()` 回调函数访问。'
- en: '**Rejected**: Something went wrong trying to resolve the promised value. There
    will be no data today.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已拒绝**：在尝试解决承诺的值时出了问题。今天没有数据。'
- en: An interesting property of promise states is that they only transition once.
    They either go from pending to fulfilled or from pending to rejected. And once
    they make this state transition, they're stuck in this state for the rest of their
    existence.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺状态的一个有趣特性是它们只转换一次。它们要么从挂起（pending）状态转换为已解决（fulfilled）状态，要么从挂起状态转换为已拒绝（rejected）状态。一旦它们完成这种状态转换，它们就会在这个状态下持续存在。
- en: Executor
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行者
- en: 'The executor function is responsible for somehow resolving the value that the
    caller is waiting for. This function is called immediately after the promise is
    created. It takes two arguments: a `resolver` function and a `rejector` function.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器函数负责以某种方式解决调用者所等待的值。这个函数在承诺创建后立即被调用。它接受两个参数：一个 `resolver` 函数和一个 `rejector`
    函数。
- en: Resolver
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决者
- en: The resolver is a function that's passed to the executor function as an argument.
    Actually, this is quite handy because we can then pass the resolver function to
    another function, and so on. It doesn't matter where the resolver function is
    called from, but when it's called, the promise moves into a fulfilled state. This
    change in state will trigger any `then()` callbacks—we'll see what these are shortly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 解决者是一个作为参数传递给执行器函数的函数。实际上，这非常方便，因为我们可以将解决者函数传递给另一个函数，依此类推。解决者函数在哪里被调用并不重要，但一旦被调用，承诺就会进入已解决状态。这种状态的变化将触发任何
    `then()` 回调——我们很快就会看到这些是什么。
- en: Rejector
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拒绝者
- en: The rejector is similar to the resolver. It's the second argument passed to
    the `executor` function, which can be called from anywhere. When it's called,
    it changes the state of the promise from pending to rejected. This state change
    will call the `error` callback function, if any, passed to `then()` or `catch()`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝者与解决者类似。它是传递给`executor`函数的第二个参数，可以从任何地方调用。当它被调用时，它会将承诺的状态从挂起更改为拒绝。这种状态变化将调用传递给`then()`或`catch()`的任何`error`回调函数。
- en: Thenable
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Thenable
- en: An object is thenable if it has a `then()` method that accepts a fulfillment
    callback and a rejection callback as arguments. In other words, a promise is thenable.
    But there are cases where we might want to implement specialized resolution semantics.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象是thenable的，如果它有一个接受满足回调和拒绝回调作为参数的`then()`方法。换句话说，一个承诺是thenable的。但有时我们可能想要实现专门的解决语义。
- en: Resolving and rejecting promises
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决和拒绝承诺
- en: If the preceding section just introduced several new terms that sounded confusing,
    then don't worry. We'll see what all these promise terms look like in practice,
    starting with this section. Here, we'll perform some straightforward promise resolving
    and rejecting.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的部分引入了几个听起来令人困惑的新术语，那么请不要担心。我们将从本节开始，看看所有这些承诺术语在实际中的样子。在这里，我们将执行一些直接的承诺解决和拒绝。
- en: Resolving promises
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决承诺
- en: The resolver is a function that, as the name implies, resolves a promise for
    us. It's not the only way to resolve a promise—we'll explore more advanced techniques
    later on in the chapter. But this method is, by far, the most common. It's passed
    into the executor function as the first argument. This means that the executor
    can resolve the promise directly by simply calling the resolver. But this wouldn't
    provide us with much utility, would it?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 解决者是一个函数，正如其名所示，为我们解决承诺。这不是解决承诺的唯一方法——我们将在本章后面探索更高级的技术。但这种方法无疑是最常见的。它作为第一个参数传递给执行者函数。这意味着执行者可以直接通过调用解决函数来解决承诺。但这不会给我们带来很多实用性，对吧？
- en: The common case to a greater extent is for the promise `executor` function to
    set up the asynchronous actions that are about to take place—things such as making
    network calls. Then, in the callback functions for these asynchronous actions,
    we can resolve the promise. It's a little counterintuitive at first, passing a
    resolve function around in our code, but it'll make more sense once we start using
    them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在更普遍的情况下，承诺`executor`函数会设置即将发生的异步操作——比如进行网络调用。然后，在这些异步操作的回调函数中，我们可以解决承诺。一开始，在代码中传递一个解决函数可能有点反直觉，但一旦我们开始使用它们，这就会更有意义。
- en: 'A resolver function is an opaque function that''s bound to a promise. It can
    only resolve a promise once. We can call the resolver as many times as we please,
    but only the first call will change the state of the promise. Here''s a diagram
    that depicts the possible states of a promise; it also shows how they''re changed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 解决函数是一个绑定到承诺的不可见函数。它只能解决一个承诺一次。我们可以多次调用解决函数，但只有第一次调用会改变承诺的状态。以下是一个图解，描述了承诺的可能状态；它还显示了它们是如何改变的：
- en: '![Resolving promises](img/B05133_03_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![解决承诺](img/B05133_03_01.jpg)'
- en: 'Now, let''s take a look at some promise code. Here, we''ll resolve a promise,
    which causes the `then()` fulfillment callback function to be called:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些承诺代码。在这里，我们将解决一个承诺，这将导致`then()`满足回调函数被调用：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, the `fulfilled()` function is called when the resolver function
    is called. The executor doesn't actually call the resolver. Rather, it passes
    the resolver function to another asynchronous function—`setTimeout()`. The executor
    function itself isn't the asynchronous code that we're trying to wrangle. The
    executor can be thought of as a sort of coordinator, orchestrating asynchronous
    actions to determine when to resolve the promise.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当调用解决函数时，会调用`fulfilled()`函数。执行者实际上并没有调用解决函数。相反，它将解决函数传递给另一个异步函数——`setTimeout()`。执行者函数本身并不是我们试图控制的异步代码。执行者可以被视为一种协调者，协调异步操作以确定何时解决承诺。
- en: 'The preceding example didn''t resolve any values. This is a valid use cases
    when the caller of some action needs acknowledgement that it either succeeded
    or failed. Instead, let''s try resolving a value this time, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例没有解决任何值。当某些动作的调用者需要确认它成功或失败时，这是一个有效的用例。相反，这次让我们尝试解决一个值，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that this code is very similar to the preceding example. The difference
    is that our resolver function is actually called within the closure of the callback
    function that's passed to `setTimeout()`. This is because we're resolving a string
    value. There's also an argument that's passed to our `fulfilled()` function, which
    is the resolved value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这段代码与前面的例子非常相似。不同之处在于，我们的解析函数实际上是在传递给`setTimeout()`的回调函数的作用域内被调用的。这是因为我们正在解析一个字符串值。还有传递给我们的`fulfilled()`函数的参数，它就是解析的值。
- en: Rejecting promises
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拒绝承诺
- en: 'The promise `executor` function doesn''t always go as planned, and when this
    happens, we need to reject the promise. This is the other possible state transition
    from pending. Instead of moving into a fulfilled state, the promise moves into
    a rejected state. This causes a different callback to execute, separate from the
    fulfillment callback. Thankfully, the mechanics of rejecting promises is very
    similar to resolving them. Let''s take a look at how this is done:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的`executor`函数并不总是按计划进行，当这种情况发生时，我们需要拒绝承诺。这是从挂起状态到另一个可能的状态转换。承诺不是移动到满足状态，而是移动到拒绝状态。这导致执行不同的回调，而不是满足回调。幸运的是，拒绝承诺的机制与解析它们非常相似。让我们看看这是如何完成的：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code looks very familiar to the resolution code that we looked at in the
    preceding section. We set a timeout, and instead of resolving the function, we
    rejected it. This is done using the `rejector` function and is passed into the
    executor as the second argument.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来与我们在上一节中查看的解析代码非常相似。我们设置了一个超时，而不是解析函数，我们拒绝了解析。这是通过`rejector`函数完成的，并将其作为第二个参数传递给执行器。
- en: We use the `catch()` method instead of the `then()` method to setup our rejection
    callback function. We'll look at how the `then()` method can be used to handle
    both fulfillment and rejection callbacks later on in the chapter. The rejection
    callback in this example simply logs the reason for the failure as an error. It's
    always important to provide this value. When we resolve promises, a value is common,
    although not strictly necessary. With rejections, on the other hand, there isn't
    a viable case for not providing the reason for the rejection even if the callback
    is only logging the error.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`catch()`方法而不是`then()`方法来设置我们的拒绝回调函数。我们将在本章后面部分探讨如何使用`then()`方法来处理满足和拒绝回调。在这个例子中，拒绝回调简单地记录失败原因作为错误。始终提供这个值是很重要的。当我们解析承诺时，一个值是常见的，尽管不是严格必要的。另一方面，对于拒绝，即使回调只是记录错误，不提供拒绝原因的情况也是没有可行性的。
- en: 'Let''s look at another example, one that catches exceptions in the executor,
    and provides the rejected callbacks with a more meaningful interpretation of the
    failure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，这个例子在执行器中捕获异常，并为拒绝回调提供对失败更具有意义的解释：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What's interesting about the first promise in the previous example is that it
    does change state, even though we're not explicitly changing the state of the
    promise using `resolve()` or `reject()`. However, it's important for the promise
    to eventually change state; we'll explore this topic in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，第一个承诺有趣的是，它确实改变了状态，尽管我们并没有明确使用`resolve()`或`reject()`来改变承诺的状态。然而，对于承诺最终改变状态来说，这是很重要的；我们将在下一节探讨这个话题。
- en: Empty promises
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空承诺
- en: 'Despite the fact that the `executor` function passes a `resolver` function
    and a `rejector` function, there''s never any guarantee that the promise will
    change state. In this scenario, the promise simply hangs, and neither the resolved
    callback nor the rejected callback is triggered. This may not seem like a problem,
    and in fact, with simple promises, it''s easy to diagnose and fix these unresponsive
    promises. However, as we get into more elaborate scenarios later in the chapter,
    a promise can be resolved as a result of several other promises resolving. If
    one of these promises doesn''t resolve or reject, then the whole flow falls apart.
    This scenario is very time-consuming to debug; the following diagram is a visualization
    of the problem:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`executor`函数传递了一个`resolver`函数和一个`rejector`函数，但承诺改变状态永远没有保证。在这种情况下，承诺只是挂起，既没有触发解析回调也没有触发拒绝回调。这看起来可能不是问题，实际上，对于简单的承诺来说，诊断和修复这些无响应的承诺很容易。然而，随着我们在本章后面部分遇到更复杂的情况，一个承诺可能因为其他几个承诺解析而解析。如果这些承诺中的一个没有解析或拒绝，那么整个流程就会崩溃。这种情况的调试非常耗时；以下图表是问题的可视化：
- en: '![Empty promises](img/B05133_03_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![空承诺](img/B05133_03_02.jpg)'
- en: 'Visually, we can see which promise causes the dependent promise to hang, but
    sifting through the code to figure this out isn''t ideal. Let''s now look at an
    `executor` function that causes a promise to hang:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，我们可以看到哪个promise导致依赖的promise挂起，但通过遍历代码来找出这一点并不理想。现在让我们看看一个导致promise挂起的`executor`函数：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But what if there was a safer way to deal with this uncertainty? An `executor`
    function with the potential to hang indefinitely without resolving or rejecting
    is hardly something we want in our code. Let''s look at implementing an executor
    wrapper function that acts as a safety net by rejecting promises that take too
    long to resolve. This would take the mystery out of diagnosing complex promise
    scenarios:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果有一种更安全的方式来处理这种不确定性呢？一个`executor`函数如果无限期地挂起而不解析或拒绝，这几乎是我们不希望出现在代码中的。让我们看看实现一个executor包装函数，它通过拒绝解析时间过长的promise来作为安全网。这将使诊断复杂的promise场景变得不再神秘：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Reacting to promises
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对promise做出反应
- en: Now that we have a better understanding of the mechanics of executing promises,
    this section will take a closer look at using promises to solve particular problems.
    Typically, this means reacting with some purpose in mind when the promise is fulfilled
    or rejected.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对执行promise的机制有了更好的理解，这一节将更深入地探讨使用promises来解决特定问题。通常，这意味着当promise被实现或拒绝时，有目的地做出反应。
- en: We'll start off by looking at the job queues inside the JavaScript interpreter,
    and what these mean for our resolution callback functions. We'll then look at
    making use of the promised data, dealing with errors, creating better abstractions
    for reacting to promises, and thenables. Let's get going.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看JavaScript解释器内部的作业队列开始，以及这些对我们解析回调函数的意义。然后我们将查看利用promised数据，处理错误，创建更好的抽象来响应promises和thenables。让我们开始吧。
- en: Resolution job queues
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析工作队列
- en: The concept of the JavaScript job queue was introduced in [Chapter 2](ch02.html
    "Chapter 2. The JavaScript Execution Model"), *The JavaScript Execution Model*.
    Its main responsibility is to initiate new execution context stacks. This is the
    main job queue. However, there's another queue, which is dedicated to the callbacks
    executed by promises. This means that the algorithm responsible for selecting
    the next job to run can select from either of the queues if they're both populated.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript工作队列的概念在[第2章](ch02.html "第2章。JavaScript执行模型")*JavaScript执行模型*中引入。其主要职责是启动新的执行上下文栈。这是主要的工作队列。然而，还有一个队列，专门用于处理由promises执行的回调函数。这意味着负责选择下一个要运行的工作的算法可以从这两个队列中选择任何一个，如果它们都满了的话。
- en: 'Promises have concurrency semantics built into them, and with good reason.
    If a promise is used to ensure that a value is eventually resolved, it makes sense
    to give high priority to the code that reacts to it. Otherwise, when the value
    arrives, the code that processes it might have to wait in a longer line behind
    other jobs. Let''s write some code that demonstrates these concurrency semantics:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Promises内置了并发语义，这是有充分理由的。如果一个promise用于确保一个值最终被解析，那么给响应它的代码以高优先级是有意义的。否则，当值到达时，处理它的代码可能不得不在更长的队列中等待其他工作。让我们编写一些代码来演示这些并发语义：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The same semantics are followed with rejected callbacks too.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝回调也遵循相同的语义。
- en: Using promised data
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用promised数据
- en: 'So far, we''ve seen a few examples in this chapter where a resolver function
    resolves a promise with a value. The value that''s passed to this function is
    the value that''s ultimately passed to the fulfilled callback function. The idea
    is for the executor to set up any asynchronous action, such as `setTimeout()`,
    which would later call the resolver with the value. But in these examples, the
    caller isn''t actually waiting on any values; we merely use `setTImeout()` as
    an example asynchronous action. Let''s look at a case where we don''t actually
    have a value, and an asynchronous network request needs to go get it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在这个章节中看到了几个例子，其中解析函数使用一个值解析promise。传递给这个函数的值是最终传递给实现回调函数的值。执行者的想法是设置任何异步操作，例如`setTimeout()`，稍后它会用这个值调用解析器。但在这些例子中，调用者实际上并没有等待任何值；我们只是用`setTimeout()`作为一个异步操作的例子。让我们看看一个我们实际上没有值的例子，并且需要异步网络请求来获取它：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With functions like `get()`, not only do they consistently return a synchronization
    primitive like a promise, but they also encapsulate some nasty asynchronous details.
    Dealing with `XMLHttpRequest` objects all over the place in our code isn't pleasant.
    We've also simplified various modes with which the response may come back. Instead
    of always having to create handlers for the `load`, `error`, and `abort` events,
    we only have one interface to worry about—the promise. This is what the synchronize
    concurrency principle is all about.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`get()`这样的函数，它们不仅始终返回一个同步原语，如承诺，而且还封装了一些讨厌的异步细节。在我们的代码中到处处理`XMLHttpRequest`对象并不愉快。我们还简化了响应可能返回的各种模式。我们不必总是为`load`、`error`和`abort`事件创建处理程序，我们只有一个接口需要担心——承诺。这就是同步并发原则的全部内容。
- en: Error callbacks
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误回调
- en: There are two ways to react to rejected promises. Put differently, supplying
    error callbacks. The first approach is to use the `catch()` method, which takes
    a single callback function. The alternative is to pass in the rejected callback
    function as the second argument to `then()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式来响应拒绝的承诺。换句话说，提供错误回调。第一种方法是用`catch()`方法，它接受一个回调函数。另一种方法是作为`then()`的第二个参数传入拒绝回调函数。
- en: The `then()` approach that is used to supply rejected callback functions is
    superior in a couple of scenarios, and it should probably be used instead of `catch()`.
    The first scenario is writing our code so that promises and thenable objects are
    interchangeable. The `catch()` method isn't necessarily part of a thenable. The
    second scenario is when we build callback chains, which we will explore later
    on in this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景下，用于提供拒绝回调函数的`then()`方法更优越，可能应该用它来代替`catch()`。第一种场景是我们编写代码，使得承诺和thenable对象可以互换。`catch()`方法不一定属于thenable。第二种场景是我们构建回调链，我们将在本章稍后探讨。
- en: 'Let''s look at some code that compares the two approaches for providing rejected
    callback functions to promises:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些比较两种向承诺提供拒绝回调函数方法的代码：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see here that both approaches are actually very similar. There's no real
    advantage to one over the other in terms of code aesthetics. However, there's
    an advantage to the `then()` approach when it comes to using thenables, which
    we'll see shortly. But, since we're not actually using the promise instance in
    any way, other than to add the callbacks, there's really no need to worry about
    `catch()` versus `then()` for registering error callbacks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这两种方法实际上非常相似。在代码美观方面，两者之间没有真正的优势。然而，当涉及到使用thenables时，`then()`方法在几个场景中更优越，我们将在稍后看到。但是，由于我们实际上并没有以任何方式使用承诺实例，除了添加回调之外，我们实际上没有必要担心`catch()`与`then()`在注册错误回调方面的区别。
- en: Always reacting
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 始终响应
- en: Promises always end up in either a fulfilled state or a rejected state. We generally
    have distinct callback functions for each of these states. However, there's a
    strong possibility that we'll want to perform some of the same actions for both
    states. For example, if a component that uses a promise changes state while the
    promise is pending, we'll want to make sure that the state is cleaned up once
    the promise is resolved or rejected.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺最终会进入满足状态或拒绝状态。我们通常为这两种状态分别有独立的回调函数。然而，有很大可能性我们希望对这两种状态执行一些相同的操作。例如，如果一个使用承诺的组件在承诺挂起时改变状态，我们希望在承诺解决或拒绝后确保状态被清理。
- en: 'We could write our code in such a way that the callbacks for fulfilled and
    rejected states each perform these actions themselves, or that they can each call
    some common function that does the cleanup. Here''s a visualization of the problem:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写代码，使得满足和拒绝状态下的回调各自执行这些操作，或者它们可以各自调用一些公共函数来完成清理。以下是问题的可视化表示：
- en: '![Always reacting](img/B05133_03_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![始终响应](img/B05133_03_03.jpg)'
- en: 'Wouldn''t it make more sense to assign the cleanup responsibility to the promise,
    instead of assigning it to the individual outcomes? This way, the callback function
    that runs when the promise is resolved is focused on what it needs to do with
    the value, and the rejection callback is focused on dealing with the error. Let''s
    see if we can write some code that extends promises with an `always()` method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将清理责任分配给承诺，而不是分配给个别结果，不是更有意义吗？这样，当承诺解决时运行的回调函数将专注于它需要处理的价值，而拒绝回调将专注于处理错误。让我们看看我们能否编写一些代码来扩展承诺的`always()`方法：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the order is important here. If we called `always()` before `then()`,
    then the function would still always run, but it would run before the callbacks
    provided to `then()`. We could actually call `always()` before and after `then()`
    to always run code before the fulfilled or rejected callbacks, and after.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的顺序很重要。如果我们先调用`always()`然后再调用`then()`，那么函数仍然会始终运行，但它会在提供给`then()`的回调之前运行。我们实际上可以在`then()`前后调用`always()`，以便在满足或拒绝回调之前和之后始终运行代码。
- en: Resolving other promises
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决其他承诺
- en: Most of the promises that we've seen so far in this chapter have either been
    resolved directly by the executor function or as the result of calling the resolver
    from an asynchronous action, when the value was ready to resolve. Passing the
    resolver function around like this is actually quite flexible. For example, the
    executor doesn't even have to perform any work except for storing the resolver
    function somewhere for it to be called later on to resolve the promise.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们迄今为止看到的承诺中的大多数要么是由执行器函数直接解析的，要么是在异步操作中调用解析器作为结果，当值准备好解析时。以这种方式传递解析器函数实际上非常灵活。例如，执行器甚至不需要执行任何工作，除了将其解析器函数存储在某个地方，以便稍后可以调用它来解析承诺。
- en: 'This can be especially useful when we find ourselves in more complex synchronization
    scenarios that require multiple values, which have been promised to callers. If
    we have the resolver function, we can resolve the promise. Let''s take a look
    at code that stores the `resolver` function of several promises so that each promise
    can be resolved later on:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们发现自己处于需要多个值（这些值已经承诺给调用者）的更复杂的同步场景时特别有用。如果我们有解析函数，我们可以解析这个承诺。让我们看看存储几个承诺的`解析器`函数的代码，以便稍后可以解析每个承诺：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As this example makes clear, we don't have to resolve anything within the `executor`
    function itself. In fact, we don't even need to explicitly reference promise instances
    after they've been created and set up with executors and fulfillment functions.
    The resolver function has been stored somewhere, and it holds a reference to the
    promise.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所清楚显示的，我们不需要在`executor`函数内部解析任何内容。事实上，我们甚至不需要在创建并设置好执行器和满足函数后显式地引用承诺实例。解析器函数已经被存储在某个地方，并且它持有对承诺的引用。
- en: Promise–like objects
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类似承诺的对象
- en: 'The Promise class is a primitive JavaScript type. However, we don''t always
    need to create new promise instances to implement the same behavior for synchronizing
    actions. There''s a static `Promise.resolve()` method that we can use to resolve
    such objects. Let''s see how this method is used:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`类是一个原始的JavaScript类型。然而，我们并不总是需要创建新的承诺实例来实现同步动作的相同行为。有一个静态的`Promise.resolve()`方法，我们可以用它来解析这样的对象。让我们看看这个方法是如何使用的：'
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We'll revisit the `Promise.resolve()` method in the final section of the chapter
    to take a look at more use cases.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的最后部分重新访问`Promise.resolve()`方法，以查看更多用例。
- en: Building callback chains
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建回调链
- en: Each promise method that we examined so far in this chapter returns promises.
    This allows us to call these methods again on the return value, resulting in a
    chain of `then().then()` calls, and so forth. One challenging aspect of chaining
    promise calls together is that the instances returned by promise methods are new
    instances. That is, there's a degree of immutability to the promises that we'll
    explore in this section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们迄今为止检查的每个承诺方法都返回承诺。这允许我们再次在返回值上调用这些方法，从而产生一系列`then().then()`调用，等等。将承诺调用链在一起的一个挑战性方面是，承诺方法返回的实例是新的实例。也就是说，承诺具有某种不可变性，我们将在本节中探讨这一点。
- en: As our application gets larger, the concurrency challenges grow with it. This
    means that we need to think of better ways to leverage synchronization primitives,
    such as promises. Just as any other primitive value in JavaScript, we can pass
    them around from function to function. We have to treat promises in the same way—passing
    them around, and building upon the chain of callback functions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序变大，并发挑战也随之增长。这意味着我们需要考虑更好的方法来利用同步原语，例如承诺。就像JavaScript中的任何其他原始值一样，我们可以将它们从一个函数传递到另一个函数。我们必须以相同的方式处理承诺——传递它们，并在回调函数链上构建。
- en: Promises only change state once
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺只改变状态一次
- en: Promises are born into a pending state, and they die in either a resolved or
    rejected state. Once a promise has transitioned into one of these states, they're
    stuck in this state. This has two interesting side-effects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺从挂起状态开始，并在解决或拒绝状态中结束。一旦承诺过渡到这些状态之一，它们就会卡在这个状态。这有两个有趣的副作用。
- en: 'First, multiple attempts to resolve or reject a promise are ignored. In other
    words, resolvers and rejectors are idempotent—only the first call has any effect
    on the promise. Let''s see how this looks code-wise:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，多次尝试解决或拒绝承诺会被忽略。换句话说，解析器和拒绝器是幂等的——只有第一次调用对承诺有影响。让我们看看代码是如何体现的：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The other implication of promises changing state only once is that the promise
    could actually resolve before a fulfillment or rejection callback is added. Race
    conditions, such as this one, are the harsh reality of concurrent programming.
    Typically, the callback function is added to the promise at the time of creation.
    Since JavaScript is run-to-completion, the job queue that processes promise resolution
    callbacks isn''t serviced until the callback is added. But, what if the promise
    resolves immediately in the executor? What if the callback is added to the promise
    in another JavaScript execution context? Let''s see if we can better illustrate
    these ideas with some code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺只改变状态一次的另一个含义是，承诺实际上可能在添加履行或拒绝回调之前就解决了。这种类型的竞态条件是并发编程的残酷现实。通常，回调函数是在创建承诺时添加的。由于
    JavaScript 是运行到完成，处理承诺解决回调的工作队列直到回调被添加才会服务。但是，如果承诺在执行器中立即解决怎么办？如果回调在另一个 JavaScript
    执行上下文中添加到承诺怎么办？让我们通过一些代码来看看我们是否可以更好地说明这些想法：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code illustrates a very important property of promises. It doesn't matter
    when our fulfillment callbacks are added to the promise, whether it's in a pending
    state, or a fulfilled state, the code that uses the promise doesn't change. On
    the face of it, this may not seem like a big deal. But this type of race condition
    checking would require more concurrency code for us to maintain ourselves. Instead,
    the Promise primitive handles this for us, and we can start treating asynchronous
    values as primitive types.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码说明了承诺的一个非常重要的特性。无论我们的履行回调是在承诺的挂起状态还是履行状态时添加，都不会影响使用承诺的代码。表面上，这可能看起来不是什么大问题。但这类竞态条件检查需要我们维护更多的并发代码。相反，Promise
    原语为我们处理了这个问题，我们可以开始将异步值视为原始类型。
- en: Immutable promises
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变承诺
- en: Promises aren't truly immutable. They change state, and the `then()` method
    adds callback functions to the promise. However, there are some immutable traits
    of promises that are worth discussing here, as they impact our promise code in
    certain situations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺并不是真正不可变的。它们会改变状态，`then()` 方法向承诺添加回调函数。然而，有一些承诺的不可变特性在这里值得讨论，因为它们在某些情况下会影响我们的承诺代码。
- en: Technically speaking, the `then()` method doesn't actually mutate the promise
    object. It creates what's called a promise capability, which is an internal JavaScript
    record that references the promise, and the functions that we add. So, it's not
    a real reference in the JavaScript sense of the term.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，`then()` 方法实际上并没有修改承诺对象。它创建了一个称为承诺能力的内部 JavaScript 记录，该记录引用了承诺和添加的函数。所以，它不是
    JavaScript 术语中的真正引用。
- en: 'Here''s a visualization that illustrates what happens when we chain two or
    more `then()` calls together:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个可视化，说明了当我们链式调用两个或多个 `then()` 调用时会发生什么：
- en: '![Immutable promises](img/B05133_03_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![不可变承诺](img/B05133_03_04.jpg)'
- en: 'As we can see, the `then()` method does not return the same instance it was
    called with as the context. Instead, `then()` creates a new promise instance and
    returns that. Let''s take a look at some code to examine more closely what happens
    when we chain together promises using `then()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`then()` 方法并不返回与它被调用的上下文相同的实例。相反，`then()` 创建一个新的承诺实例并返回它。让我们看看一些代码，以更仔细地检查当我们使用
    `then()` 链接承诺时会发生什么：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can clearly see that the two promise instances created in this example are
    separate promise objects. Something else that's worth pointing out is that the
    second promise is bound to the first one—it resolves when the first promise resolves.
    However, we can see that the value isn't passed to the second promise. We'll address
    this problem in the following section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，在这个例子中创建的两个承诺实例是独立的承诺对象。另一个值得指出的是，第二个承诺绑定到第一个承诺上——当第一个承诺解决时，它也会解决。然而，我们可以看到值并没有传递给第二个承诺。我们将在下一节解决这个问题。
- en: Many then callbacks, many promises
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许多`then`回调，许多承诺
- en: As we saw in the preceding section, promises created with `then()` are bound
    to their creator. That is, when the first promise is resolved, the promise that's
    bound it it also resolves, and so on. However, we noticed a slight problem as
    well. The resolved value doesn't make it past the first callback function. The
    reason for this is that each callback that's run in response to a promise resolution,
    is that the return value of the first callback is fed into the second callback,
    and so on. The reason our first callback gets the value as an argument is because
    this happens transparently within the promise mechanism.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用`then()`创建的承诺与其创建者绑定。也就是说，当第一个承诺解决时，绑定到它的承诺也会解决，依此类推。然而，我们也注意到了一个轻微的问题。解决后的值并没有通过第一个回调函数。这是因为每个针对承诺解决而运行的回调，其返回值被传递到第二个回调，依此类推。我们的第一个回调之所以得到值作为参数，是因为这发生在承诺机制中是透明的。
- en: 'Let''s take a look at another promise chain example. This time, we''ll explicitly
    return the values from our callback functions:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个承诺链的示例。这次，我们将明确从我们的回调函数中返回值：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This looks promising. Now we can see that the resolved value makes its way through
    the promise chain. There's a catch—the rejection isn't cumulative. Instead, only
    the first promise in the chain is actually rejected. The remaining promises are
    simply resolved, not rejected. This means that the last `catch()` callback will
    never run.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很有希望。现在我们可以看到解决后的值是如何通过承诺链的。但是有一个问题——拒绝不是累积的。相反，链中的第一个承诺实际上是拒绝的。剩余的承诺只是解决，而不是拒绝。这意味着最后一个`catch()`回调永远不会运行。
- en: When we chain together promises in this fashion, our fulfillment callback functions
    need to be able to handle error conditions. For example, the value that's resolved
    could have an error property, which could be checked for specifics.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种方式链式连接承诺时，我们的实现回调函数需要能够处理错误条件。例如，解决后的值可能有一个错误属性，可以对其进行特定检查。
- en: Passing promises around
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递承诺
- en: In this section, we'll extend the idea of treating promises as primitive values.
    Something we often do with primitive values is pass them to functions as arguments,
    and return them from functions. The key difference between a promise and other
    primitives is how we use them. Other values exist now, whereas promised values
    will exist eventually. Therefore, we need to define some course of action via
    a callback function to take place when the value does arrive.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将扩展将承诺视为原始值的概念。我们经常对原始值做的事情是将它们作为参数传递给函数，并从函数中返回它们。承诺与其他原始值之间的关键区别在于我们如何使用它们。其他值现在存在，而承诺值最终将存在。因此，我们需要通过回调函数定义一些行动方案，以便在值到达时执行。
- en: 'What''s nice about promises is that the interface used to supply these callback
    functions is small and consistent. We don''t need to invent synchronization mechanisms
    on the fly when we can couple the value with the code that will act upon it. These
    units can move around our application just like any other value, and the concurrency
    semantics are unobtrusive. Here''s an example of what several functions that pass
    promises around look like:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于承诺（promises）的优点在于，用于提供这些回调函数的接口既小又一致。当我们能够将值与其将要作用其上的代码耦合时，我们不需要临时发明同步机制。这些单元可以像任何其他值一样在我们的应用程序中移动，并且并发语义是无侵入性的。以下是一些传递承诺的函数的示例：
- en: '![Passing promises around](img/B05133_03_05.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![传递承诺](img/B05133_03_05.jpg)'
- en: By the end of this function call stack, we have a promise object that's reflective
    of several promises resolving. The whole resolution chain is kicked off by the
    first promise resolving. What's more important than the mechanics of how the value
    traverses the chain of promises is the idea that all of these functions are free
    to use this promised value without affecting other functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个函数调用栈结束时，我们有一个承诺对象，它反映了多个承诺的解决情况。整个解决链是由第一个承诺的解决触发的。比值如何穿越承诺链的机制更重要的是，所有这些函数都可以自由使用这个承诺值，而不会影响其他函数。
- en: 'There are two concurrency principles at play here. First, we will conserve
    by performing an asynchronous action to get the value only once; each of the callback
    functions are free to use this resolved value. Second, we''re doing a good job
    of abstracting our synchronization mechanisms. In other words, the code doesn''t
    feel like it''s burdened with boilerplate concurrency code. Let''s see what code
    that passes promises around actually looks like:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个并发原则在起作用。首先，我们将通过执行异步操作来获取值只一次；每个回调函数都可以自由使用这个解析值。其次，我们做得很好，抽象了我们的同步机制。换句话说，代码感觉没有负担着样板并发代码。让我们看看传递承诺的代码实际上是什么样子：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The key functions here are our update functions—`updateFirstName()`, `updateLastName()`,
    and `updateAge()`. They're very flexible and accept a promise or value resolved
    by a promise. If any of these functions get a promise as an argument, they return
    a new promise by adding a `then()` callback function. Note that it's adding the
    same function. `updateFirstName()` will add `updateFirstName()` as the callback.
    When the callback fires, it'll be with the plain object that's used to update
    the UI this time. So the promise check fails, and we can proceed to update the
    UI.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的功能是我们的更新函数——`updateFirstName()`、`updateLastName()` 和 `updateAge()`。它们非常灵活，可以接受一个承诺或由承诺解析的值。如果这些函数中的任何一个接收到一个承诺作为参数，它们将通过添加一个
    `then()` 回调函数返回一个新的承诺。请注意，它添加的是同一个函数。`updateFirstName()` 将添加 `updateFirstName()`
    作为回调。当回调触发时，它将带有这次用于更新 UI 的普通对象。因此，承诺检查失败，我们可以继续更新 UI。
- en: The promise checking takes all of three lines per function, which is not not
    exactly obtrusive. The end result is the flexible code that's easy to read. Ordering
    doesn't matter; we could have composed our `update()` function in a different
    order, and the UI components would all be updated in the same way. We can pass
    the plain object directly to `update()` and everything will work the same. Concurrent
    code that doesn't look like concurrent code is our big win here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数的承诺检查只需要三行，这并不算特别显眼。最终结果是灵活且易于阅读的代码。顺序并不重要；我们可以在不同的顺序中组合我们的 `update()` 函数，UI
    组件将以相同的方式更新。我们可以直接将普通对象传递给 `update()`，一切都会正常工作。看起来不像并发代码的并发代码是我们的大胜利。
- en: Synchronizing several promises
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步多个承诺
- en: Until this point in the chapter, we've looked at single promise instances that
    resolve a value, trigger callbacks, and possibly cause other promises to resolve.
    In this section, we'll look at a couple of static Promise methods that help us
    in scenarios where we need to synchronize the resolution of several promise values.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们本章已经探讨了单个承诺实例，这些实例解析一个值，触发回调，并可能引起其他承诺解析。在本节中，我们将探讨几个静态的承诺方法，这些方法有助于我们在需要同步多个承诺值解析的场景中。
- en: First, we'll address the common case where a component that we develop requires
    synchronous access to several asynchronous resources. Then, we'll look at the
    less common scenario where asynchronous actions become irrelevant before they're
    resolved due to events that have taken place in the UI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将解决一个常见的情况，即我们开发的组件需要同步访问多个异步资源。然后，我们将探讨一个不太常见的场景，即由于 UI 中发生的事件，异步操作在解析之前变得无关紧要。
- en: Waiting on promises
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待承诺
- en: In the case where we are waiting for several promises to resolve, perhaps to
    transform multiple data sources into something consumable by a UI component, we
    can use the `Promise.all()` method. It takes a collection of promise instances
    as input, and returns a new promise instance. This new instance is resolved only
    when all of the input promises are resolved.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们等待多个承诺解析的情况下，可能需要将多个数据源转换为 UI 组件可消费的格式，我们可以使用 `Promise.all()` 方法。它接受一组承诺实例作为输入，并返回一个新的承诺实例。这个新实例只有在所有输入承诺都解析后才会解析。
- en: The `then()` callback that we provide to the new promise, created by `Promise.then(),`
    is given an array of resolved values as input. These values correspond to the
    input promises in terms of index position. This is a very powerful synchronization
    mechanism, one that helps us fulfill the synchronize concurrency principle because
    it hides all the bookkeeping.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供给由 `Promise.then()` 创建的新承诺的 `then()` 回调函数，输入的是一个解析值的数组。这些值在索引位置上对应于输入的承诺。这是一个非常强大的同步机制，它帮助我们实现同步并发原则，因为它隐藏了所有的记录。
- en: 'Instead of several callbacks that each need to coordinate the state of the
    promises that they''re bound to, we have one callback, which has all the resolved
    data that we need. Here''s an example that shows how to synchronize multiple promises:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是有多个回调，每个回调都需要协调它们所绑定承诺的状态，而是一个回调，它包含了我们需要的所有已解决数据。以下是一个示例，说明如何同步多个承诺：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Cancelling promises
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消承诺
- en: The XHR requests that we've seen so far in this book have handlers for aborted
    requests. This is because we can manually abort the request and prevent any `load`
    callbacks from running. A typical scenario that requires this functionality is
    for the user to click a cancel button, or navigate to a different part of the
    application, rendering the request redundant.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们迄今为止看到的XHR请求都有处理已取消请求的处理程序。这是因为我们可以手动取消请求，防止任何`load`回调运行。需要这种功能的一个典型场景是用户点击取消按钮，或者导航到应用程序的不同部分，使得请求变得多余。
- en: If we were to move up a level on the abstraction ladder to promises, the same
    principle applies. Something could happen while the concurrent action is executing
    that renders the promise pointless. The difference between promises and XHR requests,
    of course, is that the former has no `abort()` method. The last thing we want
    to do is start introducing unnecessary cancellation logic in our promise callbacks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将抽象层次提升到承诺层面，同样的原则适用。在并发操作执行过程中，可能会发生某些事情，使得承诺变得毫无意义。当然，承诺与XHR请求之间的区别在于，前者没有`abort()`方法。我们最不想做的事情就是在我们的承诺回调中引入不必要的取消逻辑。
- en: 'This is where the `Promise.race()` method can help us. As the name suggests,
    the method returns a new promise that''s resolved by the first of the input promises
    to resolve. This may not sound like much, but implementing the logic of `Promise.race()`
    isn''t easy. It''s the synchronize principle in action, hiding concurrency complexities
    from the application code. Let''s take a look at how this method can help us deal
    with cancelled promises due to user interactions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Promise.race()`方法能帮到我们的地方。正如其名所示，该方法返回一个新承诺，该承诺由第一个解决的输入承诺解决。这可能听起来不多，但实现`Promise.race()`的逻辑并不容易。这是同步原则在起作用，隐藏了并发复杂性，使其从应用程序代码中消失。让我们看看这个方法如何帮助我们处理由于用户交互而取消的承诺：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As an exercise, try to imagine a more complex scenario where `dataPromise` is
    a promise created by `Promise.all()`. Our `cancelResolver()` function would be
    able to seamlessly cancel many complex asynchronous actions at once.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试想象一个更复杂的场景，其中`dataPromise`是由`Promise.all()`创建的承诺。我们的`cancelResolver()`函数将能够无缝取消许多复杂的异步操作。
- en: Promises without executors
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有执行者的承诺
- en: In this final section, we'll look at the `Promise.resolve()` and `Promise.reject()`
    methods. We've already seen how `Promise.resolve()` can resolve thenable objects
    earlier in the chapter. It can also directly resolve values or other promises.
    These methods come in handy when we implement a function that has the potential
    to be both synchronous and asynchronous. This isn't a situation we want to find
    ourselves in using a function with ambiguous concurrency semantics.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将探讨`Promise.resolve()`和`Promise.reject()`方法。我们已经在本章前面看到`Promise.resolve()`如何解决thenable对象。它还可以直接解决值或其他承诺。当我们实现一个可能既同步又异步的函数时，这些方法非常有用。我们不希望在使用具有模糊并发语义的函数时陷入这种境地。
- en: 'For example, here''s a function that''s both, synchronous and asynchronous,
    leading to confusion, and almost certainly to bugs later on:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个既是同步又是异步的函数，导致混淆，并且几乎肯定会导致后续的bug：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can see that the last call returns a cached value, instead of a promise.
    This makes intuitive sense because we''re not promising an eventual value, we
    already have it! The problem is that we''re exposing an inconsistency to any code
    that uses our `getData()` function. That is, the code that calls `getData()` needs
    to handle concurrency semantics. This code is not concurrent. Let''s change this
    by introducing `Promise.resolve()`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到最后一个调用返回了一个缓存值，而不是一个承诺。这从直觉上是有意义的，因为我们不是承诺一个最终值，我们已经有它了！问题是，我们向使用我们的`getData()`函数的任何代码暴露了一个不一致性。也就是说，调用`getData()`的代码需要处理并发语义。这段代码不是并发的。让我们通过引入`Promise.resolve()`来改变这一点：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is better. Using `Promise.resolve()` and `Promise.reject()`, any code that
    uses `getData()` will get concurrency by default, even when the data fetching
    action is synchronous.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好。使用`Promise.resolve()`和`Promise.reject()`，任何使用`getData()`的代码都会默认获得并发性，即使数据获取操作是同步的。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered a lot of details about the `Promise` object introduced
    in ES6 to help JavaScript programmers deal with synchronization issues that have
    plagued the language for years. With asynchronicity comes callbacks—lots of callbacks.
    This creates a callback hell that we want to avoid at all costs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了ES6中引入的`Promise`对象，帮助JavaScript程序员解决多年来困扰该语言的同步问题。随着异步性的出现，带来了回调——大量的回调。这导致了我们想尽一切办法避免的回调地狱。
- en: Promises help us deal with synchronization issues by implementing a simple interface
    that's generic enough to resolve any value. Promises are always in one of three
    states—pending, fulfilled, or rejected, and they only change their state once.
    When these state changes happen, callbacks are triggered. Promises have an executor
    function, whose job is to set up the asynchronous actions that use a promise `resolver`
    or `rejector` function to change the state of the promise.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现一个足够通用的简单接口来解析任何值，Promise帮助我们处理同步问题。Promise始终处于三种状态之一——挂起、已解决或已拒绝，并且它们只改变一次状态。当这些状态变化发生时，会触发回调。Promise有一个执行器函数，其任务是设置使用Promise
    `resolver`或`rejector`函数来改变Promise状态的异步操作。
- en: Much of the value that promises bring to the table is about how they help us
    simplify complex scenarios. Because, if we only had to deal with a single asynchronous
    action that runs a callback with a resolved value, promises would hardly be worthwhile.
    This is not a common case. The common case is several asynchronous actions that
    each resolve values; and these values need to be synchronized and transformed.
    Promises have methods that allow us to do this, and as a result, we're able to
    better apply the synchronization concurrency principle to our code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Promise带来的大部分价值在于它们如何帮助我们简化复杂场景。因为，如果我们只需要处理一个运行带有已解决值的回调的单个异步操作，Promise几乎就没有价值。这不是一个常见的情况。常见的情况是多个异步操作，每个操作都解析值；并且这些值需要同步和转换。Promise有方法允许我们这样做，因此我们能够更好地将同步并发原则应用到我们的代码中。
- en: In the next chapter, we'll look at another newly-introduced language primitive—the
    generator. Similar to promises, generators are mechanisms that help us apply a
    concurrency principle—conserve.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一种新引入的语言原语——生成器。与Promise类似，生成器是帮助我们应用并发原则——节省资源的机制。
