- en: Chapter 3. Working with Data Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用数据序列化
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Converting an object to JSON and back again
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象转换为JSON，然后再转换回来
- en: Converting an object to XML and back again
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象转换为XML，然后再转换回来
- en: Browser-server transmission via AJAX
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过AJAX进行浏览器-服务器传输
- en: 'Working with real data: fetching trending tweets'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用真实数据：获取热门推文
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: If we want to give third parties safe access to raw data, we can use serialization
    to send it in a format that the requester will understand. In this chapter, we'll
    be looking at data serialization in two well-known standards, JSON and XML.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让第三方安全地访问原始数据，我们可以使用序列化将其发送到请求者能够理解的格式中。在本章中，我们将研究两种著名标准中的数据序列化，JSON和XML。
- en: Converting an object to JSON and back again
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象转换为JSON，然后再转换回来
- en: '**JSON (JavaScript Object Notation)** is very closely related to JavaScript
    objects because it''s a subset of JavaScript. This task will demonstrate how to
    use the building blocks of JSON conversion: `JSON.parse` and `JSON.stringify.`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JSON（JavaScript对象表示法）与JavaScript对象非常相关，因为它是JavaScript的子集。这项任务将演示如何使用JSON转换的构建块：`JSON.parse`和`JSON.stringify`。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need to create two new files called `profiles.js` and `json_and_back.js`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建两个名为`profiles.js`和`json_and_back.js`的新文件。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's create the object that we'll later be converting to JSON.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个对象，稍后将其转换为JSON。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This object contains profile information on some of the leading members of the
    Node Community (though it's entirely non-exhaustive and doesn't even contain all
    of the core development team). One thing to note here is the use of `module.exports`.
    We'll be seeing more of this In [Chapter 9](ch09.html "Chapter 9. Writing Your
    Own Node Modules"), *Writing Your Own Module*. We're using `module.exports` to
    modularize our `profiles` object here in a bid to keep our code uncluttered. We
    can load any expression into `module.exports`, save it as a separate file (which
    in our case, we'll call `profiles.js)`, and use `require` in our main file to
    dynamically load it at initialization.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象包含了Node社区一些领先成员的个人资料信息（尽管它并不全面，甚至不包含所有的核心开发团队）。这里需要注意的一点是使用了`module.exports`。我们将在[第9章](ch09.html
    "第9章。编写自己的Node模块")中看到更多关于这个的内容，*编写自己的模块*。我们在这里使用`module.exports`来模块化我们的`profiles`对象，以保持我们的代码整洁。我们可以将任何表达式加载到`module.exports`中，将其保存为一个单独的文件（在我们的情况下，我们将称之为`profiles.js`），并在我们的主文件中使用`require`来动态加载它进行初始化。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nice and tidy. To convert our `profiles` object into a JSON representation,
    we use `JSON.stringify`, which will return a string composed of JSON data. We're
    going to fundamentally alter our object (which is now a string) using `replace`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 整洁而清晰。为了将我们的`profiles`对象转换为JSON表示，我们使用`JSON.stringify`，它将返回由JSON数据组成的字符串。我们将使用`replace`从根本上改变我们的对象（现在是一个字符串）。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we have called `replace`, using a regular expression with the global `g`
    option to change every occurrence of `name` in our JSON string to `fullname`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了`replace`，使用全局`g`选项的正则表达式来将我们的JSON字符串中的每个`name`更改为`fullname`。
- en: 'But wait! There appears to be some kind of mistake. Felix''s last name is missing
    an umlaut! Let''s correct it by converting our JSON data back into an object,
    and correct his name by altering the value of the re-designated `fullname` property:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！似乎出现了某种错误。Felix的姓缺少一个分音符！让我们通过将我们的JSON数据转换回对象，并通过修改重新指定的`fullname`属性的值来纠正他的名字：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we run our application, `console.log` will output the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的应用程序时，`console.log`将输出以下内容：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first key is now `fullname`, and `Geisendörfer` is spelled correctly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个键现在是`fullname`，而`Geisendörfer`的拼写是正确的。
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we have an everyday JavaScript object, which we serialize into a JSON
    representation. We also call the `String.replace` method on our JSON string, changing
    every occurrence of `name` into `fullname`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个日常的JavaScript对象，我们将其序列化为JSON表示。我们还在我们的JSON字符串上调用`String.replace`方法，将每个`name`的出现更改为`fullname`。
- en: Using replace in this way and context isn't an advisable practice since any
    occurrences of `name` are replaced. There could very easily have been other places
    in the string where `name` may have existed, which would be replaced unintentionally.
    We used `replace` here to affirm that profiles have become a JSON string, as we
    couldn't use `replace` on an object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用replace并不是一个明智的做法，因为任何`name`的出现都会被替换。字符串中很容易有其他地方可能存在`name`，这样会意外地被替换。我们在这里使用`replace`来确认配置文件已经成为JSON字符串，因为我们无法在对象上使用`replace`。
- en: Then we convert our modified JSON string back into an object, using `JSON.parse`.
    To test that our keys were indeed transformed from `name` to `fullname`, and to
    affirm that we are again working with an object, we correct the `felix` profile
    via `profiles.felix.fullname`, and then log `profiles.felix` to the console.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`JSON.parse`将修改后的JSON字符串转换回对象。为了测试我们的键确实从`name`转换为`fullname`，并确认我们再次使用对象，我们通过`profiles.felix.fullname`纠正`felix`配置文件，然后将`profiles.felix`记录到控制台。
- en: There's more...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: JSON is a highly versatile and flexible tool for cross-platform communication.
    Let's look at a more advanced application of the standard.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种非常灵活和多功能的跨平台通信工具。让我们看看标准的更高级应用。
- en: Constructing JSONP responses
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建JSONP响应
- en: '**JSONP (JSON with Padding)** is a cross-domain policy workaround that allows
    developers to interface with resources on other domains. It involves defining
    a callback function on the client side that handles JSON via its first parameter,
    then passing the name of this callback as a query argument in the `src` attribute
    of a `script` element, which points to a web service on another domain. The web
    service then returns the JSON data, wrapped in a function named according to the
    query argument set client side. It''s possibly easier to illustrate this in code.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JSONP（带填充的JSON）是一个跨域策略的变通方法，允许开发人员与其他域上的资源进行接口。它涉及在客户端定义一个回调函数，通过它的第一个参数处理JSON，然后将这个回调函数的名称作为查询参数传递给`script`元素的`src`属性，该元素指向另一个域上的web服务。然后，web服务返回JSON数据，包装在一个根据客户端设置的查询参数命名的函数中。可能更容易通过代码来说明这一点。
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We define a function called `cb` which takes an object as its parameter, then
    we output the `name` and `description` properties. Prior to this, we set a variable
    called `who` which will be passed to the server to grab specific data for us.
    We then dynamically inject a new script element, setting `src` to a figurative
    third-party domain (which for easy demonstration is localhost) and adding `callback`
    and `who` query arguments. The value of `callback` matches the name of our function
    `cb` function. Our server uses this parameter to wrap JSON in a function invocation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`cb`的函数，它以一个对象作为参数，然后输出`name`和`description`属性。在此之前，我们设置了一个名为`who`的变量，它将被传递给服务器以为我们获取特定的数据。然后，我们动态注入一个新的脚本元素，将`src`设置为一个象征性的第三方域（为了方便演示，是localhost），并添加`callback`和`who`查询参数。`callback`的值与我们的函数`cb`函数的名称匹配。我们的服务器使用此参数将JSON包装在函数调用中。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We create a server, extract the `callback` and `who` query parameters, and write
    a response containing a function call passing our JSON data in as its parameter.
    This script is loaded by our client, where the `cb` function is called and JSON
    is received into the function as an object (because it looks like one).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个服务器，提取`callback`和`who`查询参数，并写一个包含传递我们的JSON数据作为参数的函数调用的响应。这个脚本由我们的客户端加载，其中调用`cb`函数并将JSON作为对象接收到函数中（因为它看起来像一个对象）。
- en: Security and JSONP
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全和JSONP
- en: Since JSONP uses script injection, any script could be inserted into our page.
    Therefore, it's highly recommended that this method only be used with trusted
    sources. An untrusted source could run evil code on the page.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSONP使用脚本注入，任何脚本都可以插入到我们的页面中。因此，强烈建议只在受信任的来源使用此方法。不受信任的来源可能在页面上运行恶意代码。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Browser-server transmission via AJAX* discussed in this chapter'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的通过AJAX进行浏览器-服务器传输*'
- en: '*Working with real data: fetching trending tweets* discussed in this chapter'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用真实数据：获取热门推文*'
- en: Converting an object to XML and back again
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象转换为XML，然后再转回来
- en: Since JSON is a string-based representation of a JavaScript object, converting
    between the two is straightforward. However, XML is less convenient to work with.
    Nevertheless, there may be times we have to work with it, for instance, if an
    API works only in XML or if we were contracted with a project that specifies XML
    support.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSON是JavaScript对象的基于字符串的表示，因此在两者之间进行转换是简单的。但是，XML不方便处理。尽管如此，可能有时我们不得不使用它，例如，如果API只能使用XML，或者如果我们与要求XML支持的项目签约。
- en: There are various non-core XML parsers available. One such parser is the non-core
    module `xml2js`. The premise of `xml2js` is that working with objects in JavaScript
    is more suitable than working with XML. `xml2js` provides a basis for us to interact
    with XML by converting it to a JavaScript object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种非核心XML解析器可用。其中一个解析器是非核心模块`xml2js`。`xml2js`的前提是，使用JavaScript中的对象比使用XML更合适。`xml2js`为我们提供了一个基础，让我们通过将XML转换为JavaScript对象来与XML交互。
- en: In this task, we're going to write a function that uses our `profiles` object
    featured in the previous recipe to create a valid XML string, which we'll then
    push through `xml2js`, thus converting it back into an object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将编写一个函数，使用前一个配方中的`profiles`对象来创建一个有效的XML字符串，然后将其通过`xml2js`，从而将其转换回对象。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we start, let's create our file `xml_and_back.js`, making sure we have
    our separately modularized `profiles.js` in the same directory. We should also
    install `xml2js`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们创建我们的文件`xml_and_back.js`，确保我们的单独模块化的`profiles.js`也在同一个目录中。我们还应该安装`xml2js`。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To begin with, we'll need to require our `profiles` object along with `xml2js:`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要引入我们的`profiles`对象以及`xml2js`：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that rather than just requiring the `xml2js` module, we've initialized
    a new instance of its `Parser` method and loaded that as our `xml2js` variable.
    This is to do with the way the `xml2js` module works. We have to create a new
    `Parser` instance in order to parse a piece of XML into an object. Since our code
    is relatively simple we may as well do the initialization work while we require
    it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不仅仅需要`xml2js`模块，还初始化了它的`Parser`方法的一个新实例，并将其加载为我们的`xml2js`变量。这与`xml2js`模块的工作方式有关。我们必须创建一个新的`Parser`实例，以便将一段XML解析为一个对象。由于我们的代码相对简单，我们可能会在需要时进行初始化工作。
- en: 'Just as XML has a tree-like structure, objects can have objects nested within
    them. We need a function that can loop through our object and all sub-objects,
    converting all properties into parent XML nodes, and all non-object values into
    text XML nodes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像XML具有树状结构一样，对象可以在其中嵌套对象。我们需要一个函数，可以循环遍历我们的对象和所有子对象，将所有属性转换为父XML节点，将所有非对象值转换为文本XML节点：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`buildXml` takes two parameters, the object and a string to name the first
    root XML node, and returns a string of XML data representing our object.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildXml`接受两个参数，对象和一个字符串来命名第一个根XML节点，并返回表示我们对象的XML数据的字符串。'
- en: Let's replace all occurrences of `name` with `fullname` as in our *Converting
    an object to JSON and back again* recipe.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有`name`的出现替换为`fullname`，就像我们的*将对象转换为JSON，然后再转回来*配方中一样。
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we'll turn `profiles` back into an object, correct Felix Geisendörfer's
    name using the renamed `fullname` property, then log Felix to console to show
    it has worked.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将`profiles`转回为一个对象，使用重命名的`fullname`属性来更正Felix Geisendörfer的名字，然后将Felix记录到控制台上以显示它已经生效。
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`xml2js.parseString` takes the XML (which at this point is held in the `profiles`
    variable) and assembles it into an object which is passed through as the `obj`
    parameter in its callback.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`xml2js.parseString`接受XML（此时保存在`profiles`变量中）并将其组装成一个对象，作为其回调中的`obj`参数传递。'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A JavaScript object is a key value store, whereas XML is a resource-centric
    markup language. In XML, keys and values could be represented in two ways: either
    as a parent node and a child node or as attributes on an XML node. We converted
    our keys and values to parent and child nodes, mainly because a single XML node
    is filled with lots of attributes, while valid XML, seems to violate the spirit
    of XML.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象是一个键值存储，而XML是一种以资源为中心的标记语言。在XML中，键和值可以用两种方式表示：要么作为父节点和子节点，要么作为XML节点上的属性。我们将我们的键和值转换为父节点和子节点，主要是因为单个XML节点充满了大量的属性，而有效的XML似乎违反了XML的精神。
- en: We achieved our conversion with `buildXml`, which is a function wrapping another
    self-calling recursive function named `traverse`. We do this to take advantage
    of the closure principle in JavaScript which allows us to share variables between
    inner and outer function. This enables us to use the outer `xml` variable to assemble
    our serialized XML.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`buildXml`实现了我们的转换，它是一个包装另一个自调用递归函数`traverse`的函数。我们这样做是为了利用JavaScript中的闭包原理，它允许我们在内部和外部函数之间共享变量。这使我们能够使用外部的`xml`变量来组装我们的序列化XML。
- en: 'In our outer function, we begin with the`<?xml?>` declaration setting the required
    `version` attribute and the optional `encoding` attribute to `UTF-8`. We also
    wrap any output that `traverse` renders in an ending and closing tag named after
    our `rootName` parameter. So in our case, `buildXml` puts the following into our
    `xml` variable:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的外部函数中，我们从`<?xml?>`声明开始，设置所需的`version`属性和可选的`encoding`属性为`UTF-8`。我们还将`traverse`渲染的任何输出都包装在一个以我们的`rootName`参数命名的结束和关闭标签中。因此，在我们的情况下，`buildXml`将以下内容放入我们的`xml`变量中：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If `rootName` is missing, we default to`<xml>` as the root node. Our `traverse`
    inner function takes a single parameter, which is the object to be converted to
    XML. We pass in `rootObj` to the calling parentheses:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`rootName`丢失，我们默认为`<xml>`作为根节点。我们的`traverse`内部函数接受一个参数，即要转换为XML的对象。我们将`rootObj`传递给调用括号：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`traverse` uses `forEach` to loop through the keys of this object, accessing
    each key via the first parameter of the `forEach` callback. We use the name of
    each `key` to generate the opening and closing of XML tags, and append the `open`
    tag to our shared `xml` variable. Then we check our `isTxt` variable, which tests
    for a nested object and returns `true` if it''s not an object (assuming it must
    therefore be text). If `isTxt` is `true`, we output the value of our current property
    and return from the `forEach` callback, continuing onto the next property. This
    is how we get our text nodes — the values. Otherwise, we append a line feed to
    `xml` and call `traverse` on the sub-object, going through the exact same process,
    only this time it''s embedded in the parent `traverse` function. Once our nested
    call to `traverse` has returned, we append the `close` tag to `xml` and our `traverse`
    function is complete. Finally, our outer function appends the closing root node
    tag and returns all the generated XML.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`traverse`使用`forEach`循环遍历此对象的键，通过`forEach`回调的第一个参数访问每个键。我们使用每个`key`的名称来生成XML标签的开头和结尾，并将`open`标签附加到我们共享的`xml`变量上。然后我们检查我们的`isTxt`变量，它测试嵌套对象并在不是对象时返回`true`（假设它必须是文本）。如果`isTxt`为`true`，我们输出当前属性的值并从`forEach`回调返回，继续到下一个属性。这就是我们获取文本节点的方式——值。否则，我们在`xml`中附加一个换行符，并在子对象上调用`traverse`，通过完全相同的过程进行，只是这次它嵌入在父`traverse`函数中。一旦我们嵌套调用`traverse`返回，我们就在`xml`中附加`close`标签，我们的`traverse`函数就完成了。最后，我们的外部函数附加了关闭根节点标签，并返回所有生成的XML。'
- en: There's more...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can adapt our code further to better integrate with the `xml2js` library
    by mirroring its interpretations of certain XML features into JavaScript object
    equivalents. We can also extend it to translate more complex JavaScript objects
    into valid XML.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步调整我们的代码，以更好地与`xml2js`库集成，通过将其对某些XML特性的解释反映到JavaScript对象等价物中。我们还可以将其扩展为将更复杂的JavaScript对象转换为有效的XML。
- en: Objects containing arrays and functions
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包含数组和函数的对象
- en: As well as objects and strings, object properties can contain functions and
    arrays. As it stands, our recipe will interpret these as text, outputting a comma-separated
    list of values where arrays are concerned, and returning the contents of functions
    within text nodes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对象和字符串之外，对象属性还可以包含函数和数组。就目前而言，我们的方法将这些解释为文本，对于数组，输出一个逗号分隔的值列表，并在文本节点中返回函数的内容。
- en: 'This isn''t ideal, so we''ll alter our `traverse` function to handle these
    types:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想，所以我们将修改我们的`traverse`函数来处理这些类型：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We'll save our altered code as `xml_with_arrays_and_functions.js`. For semantics'
    sake, we renamed `isTxt` to `nonObj` and added two more tester variables, `isArray`
    and `isFunc`. If the value of the object we are traversing is an array, we create
    a temporary `childNode` object which we pass back into `traverse`. We do the same
    for each value of the array, each time creating a new `childNode` object where
    the key is the same but the value is the next array element. This effectively
    creates multiple child nodes of the same name.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保存我们修改后的代码为`xml_with_arrays_and_functions.js`。为了语义上的完整，我们将`isTxt`重命名为`nonObj`，并添加了两个更多的测试变量，`isArray`和`isFunc`。如果我们遍历的对象的值是一个数组，我们创建一个临时的`childNode`对象，然后将其传回`traverse`。我们对数组的每个值都做同样的操作，每次创建一个新的`childNode`对象，其中键相同但值是下一个数组元素。这有效地创建了多个相同名称的子节点。
- en: 'To test the array support, let''s copy our `profiles.js` file to `profiles_with_arrays_and_functions.js`,
    requiring it instead of `profiles.js`. Ryan Dahl also pushes to another Github
    account: joyent. So let''s update his profile with an array of Github accounts:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试数组支持，让我们将`profiles.js`文件复制到`profiles_with_arrays_and_functions.js`，并要求它而不是`profiles.js`。Ryan
    Dahl还推送到另一个Github帐户：joyent。所以让我们用Github帐户的数组更新他的个人资料：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now if we do the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们这样做：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And take a look at the output, we''ll see that Ryan has two Github XML nodes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下输出，我们会发现Ryan有两个Github XML节点：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our other variable, `isFunc`, is checked within the `nonObj` conditional statement.
    We use it to determine whether we should just add the text of our object property
    to our `xml` variable, or else call the object property to receive its return
    value. Bert''s IRC, Twitter, and Github accounts are all the same, so let''s add
    methods that pull the IRC and Twitter values from his Github value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的另一个变量`isFunc`在`nonObj`条件语句内进行检查。我们用它来确定我们是应该只将对象属性的文本添加到我们的`xml`变量中，还是调用对象属性以获得其返回值。Bert的IRC、Twitter和Github帐户都是一样的，所以让我们添加从他的Github值中提取IRC和Twitter值的方法：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we build our XML from our object and then convert it back to an object using
    `xml2js`, these properties should no longer be functions, but instead be the returned
    values of the functions/methods:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从对象构建XML，然后使用`xml2js`将其转换回对象，这些属性不应再是函数，而应该是函数/方法的返回值：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And the output will be as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Generating XML attributes
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成XML属性
- en: 'In XML, we can either express data relationships with parent, child, and text
    nodes, or by using attributes. If we want to include the ability of our `buildXml`
    function to cater to XML attributes, we need a convention for defining attributes
    within our objects. When converting from XML to objects, `xml2js` interprets attributes
    by adding a property containing an object that has a special `@` property, which
    in turn holds another sub-object containing the attributes. By implementing the
    same convention in `buildXml`, we can make our code work nicely alongside `xml2js`.
    Let''s take the `profiles` object in `profiles_with_arrays_and_functions.js` and
    further update the `location` properties as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML中，我们可以用父节点、子节点和文本节点来表示数据关系，也可以使用属性。如果我们想让我们的`buildXml`函数能够处理XML属性，我们需要一个约定来定义对象中的属性。在从XML转换为对象时，`xml2js`通过添加一个包含特殊`@`属性的对象来解释属性，该对象又包含属性的另一个子对象。通过在`buildXml`中实现相同的约定，我们可以使我们的代码与`xml2js`很好地配合。让我们取`profiles_with_arrays_and_functions.js`中的`profiles`对象，并进一步更新`location`属性如下：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We'll save this as `profiles_with_attributes.js`, and alter the `require` location
    for the `profiles` variable in our `xml_and_back_with_arrays_and_functions.js`
    code, saving as `xml_and_back_with_attributes.js:`
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其保存为`profiles_with_attributes.js`，并在`xml_and_back_with_arrays_and_functions.js`代码中更改`profiles`变量的`require`位置，保存为`xml_and_back_with_attributes.js`：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s write another function that should be placed inside the `buildXml` function
    to handle our attributes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写另一个函数，应该放在`buildXml`函数内部来处理我们的属性：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our new `attributes` function should be placed within our `buildXml` function
    and will be called inside `traverse`, just after we add our key''s `open` tag
    variable to the `xml` variable, and just before we check for `nonObj` nodes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`attributes`函数应该放在我们的`buildXml`函数内，并且将在`traverse`内部调用，就在我们将键的`open`标签变量添加到`xml`变量之后，以及在检查`nonObj`节点之前：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We pass in the object and key currently being handled by our `traverse` function,
    which checks if this particular property of `obj` contains a property named `@`.
    We're also implicitly checking if the value of our current object key is in itself
    an object as only objects have properties.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将当前由我们的`traverse`函数处理的对象和键传递进去，检查`obj`的这个特定属性是否包含一个名为`@`的属性。我们还在隐式地检查我们当前对象键的值是否本身是一个对象，因为只有对象才有属性。
- en: 'The current attribute `@` property corresponds to the current tag. So if an
    `@` property is found, we remove the last character of `xml` (which would be a
    right angle bracket`>)` and loop through the keys of our sub-object (`obj[key][@]`)
    adding each key and its value to the last `open` tag to be appended to `xml`,
    re-appending the right angle bracket when done. If we left the `@` object inside
    our `profiles` object, it would later be passed back into the `traverse` function
    causing the following behavior:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的属性`@`属性对应于当前标签。因此，如果找到一个`@`属性，我们会删除`xml`的最后一个字符（这将是一个右尖括号`>`），并循环遍历我们子对象（`obj[key][@]`）的键，将每个键及其值添加到最后的`open`标签中，以便附加到`xml`，完成后重新添加右尖括号。如果我们将`@`对象留在`profiles`对象中，它将稍后被传回`traverse`函数，导致以下行为：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We don''t want that, so we finish off by removing the `attributes` sub-object
    from our object. Underneath our `buildXml` function we have the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想要那样，所以我们最后删除了对象中的`attributes`子对象。在我们的`buildXml`函数下面，我们有以下代码：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This changes `name` keys to `fullname` and outputs our XML to console, rendering
    `location` tags with attributes like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`name`键更改为`fullname`，并将我们的XML输出到控制台，呈现出带有属性的`location`标签。
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Text values alongside attribute declarations
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本值与属性声明并列
- en: Our attribute solution uncovers another issue. There isn't a way for attributed
    nodes to contain text nodes, since we convert string types to text nodes but use
    an object to declare attributes. `xml2js` answers the antipathy of this problem
    with the `charkey` property. With the following code we become fully compatible
    with `xml2js:`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的属性解决方案揭示了另一个问题。没有办法让带属性的节点包含文本节点，因为我们将字符串类型转换为文本节点，但使用对象来声明属性。`xml2js`通过`charkey`属性解决了这个问题的敌意。通过以下代码，我们可以完全兼容`xml2js`：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now the dilemma is resolved and we can explicitly add attributed nodes which
    contain text nodes, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个困境已经解决，我们可以明确地添加包含文本节点的属性节点，就像这样：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Which renders:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Converting an object to JSON and back again* discussed in this chapter'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的将对象转换为JSON然后再转换回来*'
- en: '*Browser-server transmission via AJAX* discussed in this chapter'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了*通过AJAX进行浏览器-服务器传输*
- en: '*Working with real data: fetching trending tweets* discussed in this chapter'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了*使用真实数据：获取热门推文*
- en: Browser-server transmission via AJAX
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过AJAX进行浏览器-服务器传输
- en: We can enhance the user experience by loading new content directly into the
    page via AJAX, rather than loading a new page for each content request.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过AJAX直接将新内容加载到页面中，而不是为每个内容请求加载新页面，从而增强用户体验。
- en: In this recipe, we're going to transfer our serialized data to the browser as
    the user requests it and then interact with our client-side data. We'll implement
    a profile viewer in the browser, which retrieves a selected profile in either
    JSON or XML, outputting the key-values or parent-child nodes for that profile.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将根据用户请求将序列化数据传输到浏览器，然后与我们的客户端数据进行交互。我们将在浏览器中实现一个配置文件查看器，该查看器以JSON或XML格式检索所选配置文件，并输出该配置文件的键值或父子节点。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''re going to continue to work with our `profiles.js` object module (from
    the first two recipes of this chapter). For XML delivery, we''ll also grab our
    `buildXml` function from the *Converting an object to XML and back again* recipe,
    converting it to a simple module (just like we did with our `profiles` object
    in the previous recipe):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们的`profiles.js`对象模块（来自本章的前两个示例）。对于XML传递，我们还将从*将对象转换为XML并再次转换*示例中获取我们的`buildXml`函数，并将其转换为一个简单的模块（就像我们在上一个示例中对`profiles`对象所做的那样）：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ll save this as `buildXml.js` and place it in a folder with a copy of our
    `profiles.js` file, along with two newly created files: `server.js` and `index.html`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将将此保存为`buildXml.js`并将其放在一个文件夹中，该文件夹中包含我们的`profiles.js`文件的副本，以及两个新创建的文件：`server.js`和`index.html`。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's start with our `index.html` file. We'll quickly implement a rough layout
    for our profile viewer consisting of a `form` with two `select` elements, a `div`
    for outputting formatted object data, and a `textarea` element for presenting
    the raw serialized data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的`index.html`文件开始。我们将快速实现一个粗略的布局，用于我们的个人资料查看器，包括一个带有两个`select`元素的`form`，一个用于输出格式化对象数据的`div`，以及一个用于呈现原始序列化数据的`textarea`元素。
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that we've included jQuery to obtain cross-browser benefits, particularly
    in the area of AJAX requests. We'll be utilizing jQuery in our client-side script
    shortly, but first let's make our server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经包含了jQuery以获得跨浏览器的好处，特别是在AJAX请求的领域。我们将很快在客户端脚本中使用jQuery，但首先让我们制作我们的服务器。
- en: For our modules, we'll need `http, path`, and `fs` along with our custom `profiles`
    and `buildXml` modules. For our code to work, we'll need to have `index.html`
    hosted within our server in order to prevent cross-origin policy errors.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模块，我们将需要`http，path`和`fs`以及我们自定义的`profiles`和`buildXml`模块。为了使我们的代码工作，我们需要在我们的服务器中托管`index.html`，以防止跨域策略错误。
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We've also defined `routes` and `mimes` variables so we can answer requests
    for specific data from the client along with the correct `Content-Type` header.
    We'll create two routes, one will deliver a list of profile names, the other will
    indicate a request for a particular profile.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了`routes`和`mimes`变量，以便我们可以回答来自客户端的特定数据请求，并附上正确的`Content-Type`标头。我们将创建两个路由，一个将提供配置文件名称列表，另一个将指示对特定配置文件的请求。
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our `output` function, which we just referred to in `routes`, should be placed
    above the `routes` object and looks like the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在`routes`中提到的`output`函数应放置在`routes`对象上方，并且看起来像以下代码：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To finish our server, we simply call `http.createServer` and interact with
    our `routes` object inside the callback, outputting `index.html` where no routes
    are found:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成我们的服务器，我们只需调用`http.createServer`并在回调中与我们的`routes`对象进行交互，在找不到路由的情况下输出`index.html`：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we need to write our client-side code to interface with our server
    over AJAX, which is to be placed in script tags just underneath our `#raw` textarea,
    but above the closing`</body>` tag (to ensure the HTML elements have loaded before
    script execution) of our `index.html` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要编写我们的客户端代码，以通过AJAX与我们的服务器进行交互，该代码应放置在我们的`index.html`文件的`#raw`文本区域的下方的脚本标签中，但在`</body>`标签的上方（以确保HTML元素在脚本执行之前已加载）：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's begin with the server. Inside our `http.createServer` callback, we set
    the appropriate header and check to see if the `routes` object has the specified
    directory name. If the directory name exists in `routes`, we call it as a function
    passing in `basename` and `extname` (we use `extname` to determine the desired
    format). In cases where there is no directory name match, we check for an existing
    property matching `basename`. If there is one, we call it and pass in the extension
    (if any). If both tests turn out to be false, we simply output the contents of
    our `index.html` file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从服务器开始。在我们的`http.createServer`回调中，我们设置了适当的标头，并检查`routes`对象是否具有指定的目录名。如果`routes`中存在目录名，我们将其作为函数调用，并传入`basename`和`extname`（我们使用`extname`来确定所需的格式）。在没有目录名匹配的情况下，我们检查是否存在与`basename`匹配的属性。如果有，我们调用它并传入扩展名（如果有）。如果这两个测试都不成立，我们只需输出我们的`index.html`文件的内容。
- en: Our two routes are `profiles` and `/profile`, the latter has a preceding slash
    which corresponds to the way `path.dirname` returns the directory name of a path.
    Our `/profile` route is designed to allow for a sub-path containing the requested
    profile and format. For instance, `http://localhost:8080/profile/ryan.json` will
    return Ryan's profile in JSON format (if no extension is given, we default to
    JSON format).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个路由是`profiles`和`/profile`，后者有一个前导斜杠，对应于`path.dirname`返回路径的目录名的方式。我们的`/profile`路由旨在允许包含所请求的配置文件和格式的子路径。例如，`http://localhost:8080/profile/ryan.json`将以JSON格式返回Ryan的配置文件（如果未给出扩展名，则默认为JSON格式）。
- en: Both the `profiles` and `/profile` methods utilize our custom `output` function
    which, using the `format` parameter (originally `extname` in the `http.createServer`
    callback), generates either JSON (using `JSON.stringify)` or XML (with our very
    own `buildXml` function) from the `content` passed to it. `output` also takes
    a conditional third parameter, which is passed along to `buildXml` to define the
    `rootNode` of the generated XML.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`profiles`和`/profile`方法都利用我们的自定义`output`函数，该函数使用`format`参数（最初在`http.createServer`回调中为`extname`）从传递给它的`content`生成JSON（使用`JSON.stringify`）或XML（使用我们自己的`buildXml`函数）。`output`还接受一个条件性的第三个参数，该参数传递给`buildXml`以定义生成的XML的`rootNode`。'
- en: On the client side, the first thing we do is call the jQuery `$.get` method
    for `http://localhost:8080/profiles`. This causes the server to call the `profiles`
    method on the `route` object. This in turn calls our `output` function with an
    array of top-level properties from our `profiles.js` object. Since we didn't specify
    an extension in `$.get`, the `output` function will default to JSON format and
    deliver the result of `JSON.stringify` into `response.end.`
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们要做的第一件事是调用jQuery的`$.get`方法获取`http://localhost:8080/profiles`。这会导致服务器调用`route`对象上的`profiles`方法。这将调用我们的`output`函数，并传入来自我们的`profiles.js`对象的顶级属性数组。由于我们没有在`$.get`中指定扩展名，`output`函数将默认为JSON格式，并将`JSON.stringify`的结果传递给`response.end`。
- en: Back on the client side, our third argument in the first `$.get` call is`'json'`,
    this ensures `$.get` interprets the incoming data as JSON, converting it to an
    object. The object is passed in as the first parameter of the function callback
    of `$.get` (second parameter of `$.get)`, which we named `profile_names`. We use
    jQuery's `$.each` to loop through the `profile_names`, populating the first `select`
    element (`#profiles`) by applying jQuery's `append` method to the element, and
    adding each profile name inside the`<option>` elements as we loop through `$.each`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 回到客户端，我们在第一个`$.get`调用中的第三个参数是`'json'`，这确保`$.get`将传入的数据解释为JSON，并将其转换为对象。对象作为`$.get`的回调函数的第一个参数（`$.get`的第二个参数）传递给我们命名为`profile_names`的函数。我们使用jQuery的`$.each`循环遍历`profile_names`，通过将jQuery的`append`方法应用于元素，并在循环`$.each`时将每个配置文件名称添加到`<option>`元素中，从而填充第一个`select`元素（`#profiles`）。
- en: Next, we apply a listener to our two `select` elements (`change`) whose callback
    assembles a URL dependent upon the user's selection, passing this URL into another
    AJAX request using `$.get`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的两个`select`元素应用一个监听器（`change`），其回调根据用户的选择组装一个URL，并将此URL传递给另一个使用`$.get`的AJAX请求。
- en: This time on the server side, the `/profile route` method is invoked, passing
    in the corresponding profile from our `profiles` object to `output`. This property
    will contain an object holding the profile information of the requested individual.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这次在服务器端，调用`/profile route`方法，将对应的配置文件从我们的`profiles`对象传递给`output`。此属性将包含所请求个人的配置文件信息的对象。
- en: In our second `$.get` call, we set the third argument to`'text'`. This will
    force jQuery not to automatically interpret incoming data as JSON or XML. This
    gives us more control and makes it easier to output the raw data into `textarea`.
    Inside the `$.get` callback, we use the `jqXHR` parameter to determine the `Content-Type`
    to see if we have JSON or XML. We loop through the returned data according to
    its type (either Object or XMLObject) and append it to our `#output div`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二个`$.get`调用中，我们将第三个参数设置为`'text'`。这将强制jQuery不自动将传入的数据解释为JSON或XML。这给了我们更多的控制，并使得更容易将原始数据输出到`textarea`中。在`$.get`回调中，我们使用`jqXHR`参数来确定`Content-Type`，以查看我们是否有JSON或XML。我们根据其类型（Object或XMLObject）循环返回的数据，并将其附加到我们的`#output
    div`中。
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can also convert our objects to JSON and XML in the browser and send them
    over to our server, where we can interact with them as objects again.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在浏览器中将我们的对象转换为JSON和XML，然后将它们发送到服务器，我们可以再次将它们作为对象进行交互。
- en: Sending serialized data from client to server
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从客户端发送序列化数据到服务器
- en: Let's extend our example to add new profiles to our `profiles` object on the
    server using our browser interface.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的示例，使用我们的浏览器界面将新配置文件添加到服务器上的`profiles`对象中。
- en: 'Starting with `index.html` (which we''ll copy to `add_profile_index.html —
    we''ll` also copy `server.js` to `add_profile_server.js)`, let''s append a form
    called `#add`, and style it. Here''s the form:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从`index.html`开始（我们将其复制到`add_profile_index.html` - 我们还将`server.js`复制到`add_profile_server.js`），让我们添加一个名为`#add`的表单，并对其进行样式设置。这是表单：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And some additional styles:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的样式：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We''re going to be using our `buildXml` function on the client side (we created
    `buildXml` in the *Converting an object to XML and back again* recipe). This function
    is already available on our server, so we''ll make it available to the client
    by converting it to a string on server starts and supplying a route for the client
    to access it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在客户端使用我们的`buildXml`函数（我们在*将对象转换为XML并再次转换回来*中创建了`buildXml`）。这个函数已经在我们的服务器上可用，所以我们将它转换为字符串，并在服务器启动时提供一个路由供客户端访问：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We also updated our `mimes` object ready to deliver `application/javascript
    Content-Type` and altered the index variable to use our new `add_profile_index.html`
    file. Back in our client-side code, we fetch our `buildXml` function by including
    another`<script>` tag in the head section:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更新了我们的`mimes`对象，准备交付`application/javascript Content-Type`，并修改了索引变量以使用我们的新的`add_profile_index.html`文件。回到客户端代码，我们通过在头部部分包含另一个`<script>`标签来获取我们的`buildXml`函数：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll wrap our initial `$.get` call to the server (which fetches all the profile
    names for the `select` element) in a function called `load`. This allows us to
    dynamically reload the profile names once a profile has been added:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们对服务器的初始`$.get`调用（用于获取`select`元素的所有配置文件名称）包装在一个名为`load`的函数中。这使我们能够在添加配置文件后动态重新加载配置文件名称：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we define a handler for the `#add` form:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为`#add`表单定义一个处理程序：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our handler builds an object from the form input serializing it to the specified
    format. It uses `jQuery.ajax` to send serialized data to our server, and afterwards
    reloads the profiles. On our server, we''ll write a function to handle the POST
    request:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理程序从表单输入构建一个对象，将其序列化为指定格式。它使用`jQuery.ajax`将序列化数据发送到我们的服务器，然后重新加载配置文件。在我们的服务器上，我们将编写一个处理POST请求的函数：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For our new `addProfile` function to work, we need to include the `xml2js`
    module which is used to convert the serialized XML back into an object. So alongside
    all our initial variables we add the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的新`addProfile`函数工作，我们需要包含`xml2js`模块，该模块用于将序列化的XML转换回对象。因此，除了我们所有的初始变量，我们还添加了以下内容：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As in the first recipe of[Chapter 2](ch02.html "Chapter 2. Exploring the HTTP
    Object"), *Exploring the HTTP Object*, in handling POST data, `addProfile` compiles
    all the incoming data together. In the `end` event, we convert the serialized
    data to an object using the method appropriate to its type. We take this object
    and add it to our `profiles` object using the `profileName` property as the key
    for our sub-object. Once we've added the object, we `delete` the redundant `profileName`
    property.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。探索HTTP对象")的第一个食谱中，*探索HTTP对象*，在处理POST数据时，`addProfile`将所有传入的数据汇编在一起。在`end`事件中，我们使用适合其类型的方法将序列化数据转换为对象。我们将这个对象添加到我们的`profiles`对象中，使用`profileName`属性作为子对象的键。一旦我们添加了对象，我们就会`delete`冗余的`profileName`属性。
- en: To return data to the client, the `addProfile` function invokes the callback
    (cb) parameter, passing in our custom `output` function which will return serialized
    data according to the specified format (which is determined by using `replace`
    on the `Content-Type` header).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据返回给客户端，`addProfile`函数调用回调（cb）参数，传入我们自定义的`output`函数，该函数将根据指定的格式返回序列化数据（通过在`Content-Type`头上使用`replace`确定）。
- en: 'We include our `addProfile` function in our server like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像这样在我们的服务器中包含我们的`addProfile`函数：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Within our `addProfile` callback function, we simply end the response with the
    data returned from the `output` function, accessing this data via the `output`
    parameter as defined in the `addProfile` callback. The new profiles are only saved
    in operational memory, so they will be lost on server restarts. If we were to
    store this data on disc, we would ideally want to save it in a database, which
    we'll talk about in the next chapter, *Interfacing with Databases*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`addProfile`回调函数中，我们只需使用从`output`函数返回的数据结束响应，通过`output`参数访问这个数据，这个参数在`addProfile`回调中定义。新的配置文件只保存在操作内存中，所以在服务器重新启动时会丢失。如果我们要将这些数据存储在磁盘上，理想情况下我们会希望将其保存在数据库中，这将在下一章*与数据库交互*中讨论。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Setting up a router* discussed In [Chapter 1](ch01.html "Chapter 1. Making
    a Web Server"),Making a Web Server'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置路由*在[第1章](ch01.html "第1章。制作Web服务器")中讨论，制作Web服务器'
- en: '*Processing POST data* discussed In [Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"),Exploring the HTTP Object'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理POST数据*在[第2章](ch02.html "第2章。探索HTTP对象")中讨论，探索HTTP对象'
- en: '*Converting an object to JSON and back again* discussed in this chapter'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将对象转换为JSON然后再转换回来*在本章中讨论'
- en: '*Converting an object to XML and back again* discussed in this chapter'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将对象转换为XML然后再转换回来*在本章中讨论'
- en: 'Working with real data: fetching trending tweets'
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理真实数据：获取热门推文
- en: Many online entities format their response data as JSON and XML in their Application
    Programmer Interfaces (APIs) to expose pertinent information to third-party developers
    who can subsequently integrate this data into their applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 许多在线实体将他们的响应数据格式化为JSON和XML，以在他们的应用程序编程接口（API）中向第三方开发人员公开相关信息，这些开发人员随后可以将这些数据集成到他们的应用程序中。
- en: One such online entity is Twitter. In this recipe, we are going to make a command-line
    application that makes two requests to Twitter's REST service. The first will
    retrieve the most popular current topics on Twitter and the second will return
    the most recent tweets regarding the hottest topic on Twitter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个这样的在线实体是Twitter。在这个食谱中，我们将制作一个命令行应用程序，向Twitter的REST服务发出两个请求。第一个将检索Twitter上当前最受欢迎的话题，第二个将返回关于Twitter上最热门话题的最新推文。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s create our file and name it `twitter_trends.js`. We may also wish to
    install the third-party `colors` module to make our output more beautiful:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个文件，命名为`twitter_trends.js`。我们可能还希望安装第三方`colors`模块，使我们的输出更加美观：
- en: npm install colors
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: npm install colors
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll need the `http` module in order to make requests, and the `colors` module
    to get some color in our console output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`http`模块来进行请求，并且需要`colors`模块来在控制台输出中添加一些颜色：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We're going to be making a GET request inside another GET request. Between these
    requests we'll be processing JSON data to either pass into the subsequent request
    or to output to console. In the spirit of DRY (Don't Repeat Yourself), and to
    demonstrate how to avoid spaghetti code, we'll abstract our GET requests and JSON
    handling into a function called `makeCall`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在另一个GET请求内部进行GET请求。在这些请求之间，我们将处理JSON数据，要么传递到后续请求，要么输出到控制台。为了遵循DRY（不要重复自己）的精神，并演示如何避免意大利面代码，我们将抽象出我们的GET请求和JSON处理到一个名为`makeCall`的函数中。
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice the mysterious appearance of `trendingTopics` and its `jsonHandler method.
    trendingTopics` is an object that is going to provide all the settings and methods
    for our Twitter interactions. `jsonHandler` is a method on the `trendingTopics`
    object for receiving the response stream and converting the JSON to an object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`trendingTopics`及其`jsonHandler`方法的神秘出现。`trendingTopics`是一个将为我们的Twitter交互提供所有设置和方法的对象。`jsonHandler`是`trendingTopics`对象上的一个方法，用于接收响应流并将JSON转换为对象。
- en: 'We need to set up options for our calls to the trends and tweets APIs, along
    with some Twitter interaction-related functionality. So above our `makeCall` function,
    we''ll create the `trendingTopics` object as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们对趋势和推文API的调用设置选项，以及一些与Twitter交互相关的功能。因此，在我们的`makeCall`函数之上，我们将创建`trendingTopics`对象，如下所示：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: While creating the `trendingTopics` variable, we also turn the object into a
    module by simultanouesly loading it into `module.exports`. See how we use this
    in the *There's more..*. section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`trendingTopics`变量时，我们还将对象转换为模块，同时将其加载到`module.exports`中。看看我们如何在*还有更多...*部分中使用它。
- en: 'Within our `trendingTopics` object, we have the `trends` and `tweets` objects
    and two methods: `jsonHandler` and `tweetPath.`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`trendingTopics`对象中，我们有`trends`和`tweets`对象以及两个方法：`jsonHandler`和`tweetPath`。
- en: Finally, we'll invoke our `makeCall` function to request the top global trends
    from the Twitter trends API, converting the returned JSON to an object, AND using
    this object to ascertain the path to request tweets on the highest trending topic
    for using another embedded `makeCall` invocation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将调用我们的`makeCall`函数来请求来自Twitter趋势API的全球热门趋势，将返回的JSON转换为对象，并使用该对象来确定请求关于最热门话题的推文的路径，使用另一个嵌入的`makeCall`调用。
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Let's pick apart the `trendingTopics` object. `trends` and `tweets` provide
    settings relevant to Twitter's API. For `trends` this is simply a URL options
    object to be passed into `http.get` later on. In the `tweets` object, we have
    the URL object along with some other properties pertaining to options we can set
    within our REST call to the Twitter search API.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析一下`trendingTopics`对象。`trends`和`tweets`提供了与Twitter API相关的设置。对于`trends`来说，这只是一个URL选项对象，稍后将传递给`http.get`。在`tweets`对象中，我们有URL对象以及一些其他属性，涉及我们可以在对Twitter搜索API的REST调用中设置的选项。
- en: Twitter API and the User-Agent header
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Twitter API和User-Agent头
- en: Notice we've gone to the trouble of setting a `User-Agent` header. This is due
    to the Twitter API policy, which penalizes a lack of `User-Agent` string by imposing
    a lower rate limit.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经费心设置了`User-Agent`头。这是由于Twitter API政策，对缺少`User-Agent`字符串的惩罚是降低速率限制。
- en: Our `jsonHandler` method on the `trendingTopics` object takes a `reponse` and
    `cb` (callback) parameter. `trendingTopics.jsonHandler` uses the `response` object
    from the `http.get` call to capture the incoming data stream into a variable (`json`).
    When the stream has ended, which is detected using the `end` event listener on
    `response, cb` is invoking converted JSON as the parameter. The callback from
    `trendingTopics.jsonHandler` finds its way up into the `makeCall` callback.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`trendingTopics`对象上的`jsonHandler`方法接受`response`和`cb`（回调）参数。`trendingTopics.jsonHandler`使用`http.get`调用中的`response`对象来捕获传入数据流到一个变量（`json`）中。当流结束时，使用`response`上的`end`事件监听器来检测，`cb`调用转换后的JSON作为参数。`trendingTopics.jsonHandler`的回调找到了它的方式进入`makeCall`的回调。
- en: '`makeCall` abstractly combines the GET request and JSON handling, and provides
    a callback with a single parameter which is the data returned by Twitter as parsed
    JSON (in this case, it is an array of objects).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeCall`抽象地结合了GET请求和JSON处理，并提供了一个带有单个参数的回调函数，该参数是Twitter返回的解析JSON数据（在本例中，它是一个对象数组）。'
- en: 'In the outer `makeCall` invocation we call the parameter `trendsArr`, because
    Twitter returns its JSON data in an array wrapper. We use `trendsArr` to locate
    the query fragment representation of the Twitter''s top trend and pass it to the
    final method of our `trendingTopics` object: `trendingTopics.tweetPath`. This
    method takes a query fragment (`q`) as its single parameter. It then uses this
    parameter along with the options in `trendingTopics.tweets` to build the final
    Search API path. It injects this path into the `urlOpts` object of `trendingTopics.tweets`,
    which is then passed through into the inner `makeCall` invocation.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部的`makeCall`调用中，我们将参数命名为`trendsArr`，因为Twitter将其JSON数据返回在一个数组包装器中。我们使用`trendsArr`来定位Twitter的顶级趋势的查询片段表示，并将其传递给我们的`trendingTopics`对象的最终方法：`trendingTopics.tweetPath`。该方法以查询片段（`q`）作为其单个参数。然后，它使用此参数以及`trendingTopics.tweets`中的选项来构建最终的Search
    API路径。它将此路径注入到`trendingTopics.tweets`的`urlOpts`对象中，然后传递到内部的`makeCall`调用中。
- en: In the inner `makeCall` invocation we name the parameter `tweetsArr`. This is
    an array of objects containing tweet data as returned from the Twitter Search
    API in response to a query searching for the top trend discovered via the former
    (outer) call to the Trend API. We loop through the array using the veritable `forEach`
    (ES5) looping function, handling each element passed through the loop as `tweet`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部的`makeCall`调用中，我们将参数命名为`tweetsArr`。这是一个包含推文数据的对象数组，是对前一个对Trend API的调用中返回的Twitter搜索API的查询的顶级趋势的响应。我们使用可变的`forEach`（ES5）循环函数循环遍历数组，处理通过循环传递的每个元素作为`tweet`。
- en: 'The objects contained in the `tweetsArr` array contain lots of data, such as
    time information, amount of re-tweets, and so forth. However, we''re just interested
    in the content of the tweet, and who tweeted. So we log the `from_user` and `text`
    properties of each `tweet` to the console:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`tweetsArr`数组中包含很多数据，如时间信息，转发次数等。但是，我们只对推文的内容和发推者感兴趣。因此，我们将每个`tweet`的`from_user`和`text`属性记录到控制台上：'
- en: '![Twitter API and the User-Agent header](img/7188-03-01.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![Twitter API和User-Agent头](img/7188-03-01.jpg)'
- en: This is also where the `colors` module comes in handy since, within `console.log`
    we have `tweet.from_user.yellow.bold`. The colors are not properties on the object
    returned by Twitter, but rather some trickery performed by the `colors` module
    to provide an easy interface for styling console text.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是`colors`模块派上用场的地方，因为在`console.log`中我们有`tweet.from_user.yellow.bold`。颜色不是Twitter返回的对象的属性，而是`colors`模块执行的一些技巧，提供了一个易于使用的界面来为控制台文本设置样式。
- en: There's more...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's look into working with an XML-based service.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何使用基于XML的服务。
- en: Cross referencing Google Hot Trends with Twitter tweets
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Google热门趋势与Twitter推文进行交叉引用
- en: It may be noticed that trending tweets tend to have rather fad-like influences
    generated from within the Twitter community. Google Hot Trends is another source
    of trending information. It provides hourly updates of the highest trending searches.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可以注意到，热门推文往往受到Twitter社区内部产生的时尚影响。Google热门趋势是另一个热门信息的来源。它提供最热门搜索的每小时更新。
- en: We can extend our example to access and process Google's Hot Trends XML atom
    feed, and then integrate the top result into our Twitter Search API request. To
    do this, let's create a new file called `google_trends.twitter.js`. It's nice
    to work with XML data as a JavaScript object, so we'll require the non-core `xml2js`
    featured in the *Converting an object to XML and back again* recipe in this chapter,
    along with `http, colors`, and our own `trendingTopics` module.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展我们的示例来访问和处理Google的热门趋势XML原子源，并将顶部结果集成到我们的Twitter搜索API请求中。为此，让我们创建一个名为`google_trends.twitter.js`的新文件。将XML数据作为JavaScript对象处理很好，因此我们将在本章的*将对象转换为XML，然后再次转换为对象*配方中引入非核心的`xml2js`，以及`http，colors`和我们自己的`trendingTopics`模块。
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now we'll extend our `trendingTopics` object by inheriting from it using the
    EcmaScript 5 `Object.create` method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过使用EcmaScript 5的`Object.create`方法从中继承来扩展我们的`trendingTopics`对象。
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We declared a variable called `hotTrends`, and used `Object.create` to initialize
    an instance of `trendingTopics`, re-substantiating the `trends` property via the
    property declarations object (the second parameter of `Object.create)`. This means
    that instead of `trends` being an inherited property, it now belongs to `hotTrends`
    and we haven't overwritten the `trends` property in `trendingTopics` when adding
    it to our new `hotTrends` object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`hotTrends`的变量，并使用`Object.create`来初始化一个`trendingTopics`的实例，通过属性声明对象（`Object.create`的第二个参数）重新实例化了`trends`属性。这意味着`trends`不再是一个继承属性，而是属于`hotTrends`，当将其添加到新的`hotTrends`对象时，我们没有覆盖`trendingTopics`中的`trends`属性。
- en: 'We then add a new method: `hotTrends.xmlHandler`. This combines all the incoming
    chunks into the `hotTrendsfeed` variable. Once the stream has ended, it invokes
    `xml2js.parseString` and passes the XML contained in `hotTrendsfeed` into it.
    In the callback of the first `parseString` method, we invoke `xml2js.parseString`
    again. Why? Because we have to parse two sets of XML, or rather one set of XML
    and one set of adequately formed HTML. (If we head to [http://www.google.com/trends/hottrends/atom/hourly](http://www.google.com/trends/hottrends/atom/hourly)
    it will be rendered as HTML. If we view the source, we''ll then see an XML document
    with embedded HTML content.)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了一个新的方法：`hotTrends.xmlHandler`。这将所有传入的块组合成`hotTrendsfeed`变量。一旦流结束，它会调用`xml2js.parseString`并将`hotTrendsfeed`中包含的XML传递给它。在第一个`parseString`方法的回调中，我们再次调用`xml2js.parseString`。为什么？因为我们必须解析两组XML，或者说一组XML和一组格式良好的HTML。（如果我们前往[http://www.google.com/trends/hottrends/atom/hourly](http://www.google.com/trends/hottrends/atom/hourly)，它将被呈现为HTML。如果我们查看源代码，然后会看到一个包含嵌入式HTML内容的XML文档。）
- en: Google's Hot Trends XML feed delivers the Hot Trends as HTML inside of its `content`
    XML node.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Google的热门趋势XML源以HTML的形式包含在其`content` XML节点中。
- en: The HTML is wrapped within a `CDATA` section, so it isn't parsed by `xml2js`
    the first time round. Ergo, we create a new `Parser` and then parse the HTML via
    `obj.entry.content['#']`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: HTML被包裹在`CDATA`部分中，因此第一次不会被`xml2js`解析。因此，我们创建了一个新的`Parser`，然后通过`obj.entry.content['#']`解析HTML。
- en: Finally, the `hotTrends.xmlHandler` method completes in the second embedded
    `xml2js` callback where it executes its own callback parameter (cb) with a query
    fragment generated from the top list item element in HTML.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`hotTrends.xmlHandler`方法在第二个嵌入的`xml2js`回调中完成，其中执行了它自己的回调参数（cb），生成了从HTML中的顶部列表项元素生成的查询片段。
- en: Now all we have to do is make some adjustments to `makeCall:`
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要对`makeCall`进行一些调整：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As we are now dealing with both JSON and XML, we slipped in another parameter
    to our `makeCall` function declaration: `handler`. The `handler` parameter allows
    us to specify whether to use the inherited `jsonHander` method or our supplemented
    `xmlHandler` method.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在处理JSON和XML，我们在`makeCall`函数声明中添加了另一个参数：`handler`。`handler`参数允许我们指定是使用继承的`jsonHander`方法还是我们补充的`xmlHandler`方法。
- en: When we invoke the outer `makeCall`, we pass in `hotTrends.xmlHandler`, naming
    the parameter `query`. This is done because we are directly passing in the query
    fragment generated by `xmlHandler` instead of the array returned from Twitter.
    This is passed directly into the `tweetPath` method, which consequently updates
    the `path` property of the `hotTrends.tweets.urlOpts` object.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用外部的`makeCall`时，我们传入`hotTrends.xmlHandler`，将参数命名为`query`。这是因为我们直接传入了由`xmlHandler`生成的查询片段，而不是从Twitter返回的数组。这直接传递到`tweetPath`方法中，因此更新了`hotTrends.tweets.urlOpts`对象的`path`属性。
- en: We pass `hotTrends.tweets.urlOpts` into the second `makeCall`, this time setting
    the `handler` parameter to `hotTrends.jsonHandler`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`hotTrends.tweets.urlOpts`传递给第二个`makeCall`，这次将`handler`参数设置为`hotTrends.jsonHandler`。
- en: The second `makeCall` callback behaves exactly the same as in the main recipe.
    It outputs the tweets to the console. This time, however, it outputs tweets based
    on Google Hot Trends.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`makeCall`回调的行为与主要的配方完全相同。它将推文输出到控制台。但是这次，它基于Google热门趋势输出推文。
- en: See also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using Node as an HTTP client* discussed In [Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"),Exploring the HTTP Object'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](ch02.html "第2章。探索HTTP对象")中讨论了使用Node作为HTTP客户端，探索HTTP对象'
- en: '*Converting an object to JSON and back again* discussed in this chapter'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的*将对象转换为JSON，然后再次转换为对象*'
- en: '*Converting an object to XML and back again* discussed in'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的*将对象转换为XML，然后再次转换为对象*'
