- en: Chapter 4. Introduction to MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。MongoDB简介
- en: 'MongoDB is an exciting new breed of database. The leader of the NoSQL movement
    is emerging as one of the most useful database solutions in the world. Designed
    with web applications in mind, Mongo''s high throughput, unique BSON data model,
    and easily scalable architecture provide web developers with better tools to store
    their persistent data. The move from relational databases to NoSQL solutions can
    be an overwhelming task, which can be easily simplified by understanding MongoDB''s
    design goals. In this chapter, we''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一种令人兴奋的新型数据库。作为NoSQL运动的领导者，它正在成为世界上最有用的数据库解决方案之一。Mongo的高吞吐量、独特的BSON数据模型和易于扩展的架构为Web开发人员提供了更好的工具来存储他们的持久数据。从关系型数据库转移到NoSQL解决方案可能是一个令人不知所措的任务，但通过了解MongoDB的设计目标可以轻松简化。在本章中，我们将涵盖以下主题：
- en: Understanding the NoSQL movement and MongoDB design goals
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解NoSQL运动和MongoDB设计目标
- en: MongoDB BSON data structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB BSON数据结构
- en: MongoDB collections and documents
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB集合和文档
- en: MongoDB query language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB查询语言
- en: Working with the MongoDB shell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoDB shell
- en: Introduction to NoSQL
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL简介
- en: In the past couple of years, web application development has usually required
    the usage of relational databases to store persistent data. Most developers are
    already pretty comfortable with using one of the many SQL solutions. So, the approach
    of storing a normalized data model using a mature relational database became the
    standard. Object-relational mappers started to crop up, giving developers proper
    solutions to marshal their data from the different parts of their application.
    But as the Web grew larger, more scaling problems were presented to a larger base
    of developers. To solve this problem, the community created a variety of key-value
    storage solutions that were designed for better availability, simple querying,
    and horizontal scaling. This new kind of data store became more and more robust,
    offering many of the features of the relational databases. During this evolution,
    different storage design patterns emerged, including key-value storage, column
    storage, object storage, and the most popular one, document storage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，Web应用程序开发通常需要使用关系型数据库来存储持久数据。大多数开发人员已经非常习惯使用众多的SQL解决方案之一。因此，使用成熟的关系数据库存储规范化数据模型的方法成为了标准。对象关系映射器开始出现，为开发人员提供了适当的解决方案，以从其应用程序的不同部分整理数据。但随着Web的不断扩大，越来越多的开发人员面临更多的扩展问题。为了解决这个问题，社区创建了各种键值存储解决方案，旨在提供更好的可用性、简单的查询和水平扩展。这种新型数据存储变得越来越健壮，提供了许多关系数据库的功能。在这一演变过程中，出现了不同的存储设计模式，包括键值存储、列存储、对象存储和最流行的文档存储。
- en: In a common relational database, your data is stored in different tables, often
    connected using a primary-to-foreign key relation. Your program will later reconstruct
    the model using various SQL statements to arrange the data in some kind of hierarchical
    object representation. Document-oriented databases handle data differently. Instead
    of using tables, they store hierarchical documents in standard formats, such as
    JSON and XML.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见的关系数据库中，您的数据存储在不同的表中，通常使用主键到外键的关系连接。您的程序将稍后使用各种SQL语句重新构建模型，以将数据排列成某种层次化对象表示。文档型数据库处理数据的方式不同。它们不使用表，而是以标准格式（如JSON和XML）存储分层文档。
- en: 'To understand this better, let''s have a look at an example of a typical blog
    post. To construct this blog post model using a SQL solution, you''ll probably
    have to use at least two tables. The first one would contain post information
    while the second would contain post comments. A sample table structure can be
    seen in the following diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们看一个典型博客文章的例子。要使用SQL解决方案构建此博客文章模型，您可能至少需要使用两个表。第一个表包含帖子信息，而第二个表包含帖子评论。下图显示了一个示例表结构：
- en: '![Introduction to NoSQL](img/B05071_04_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![NoSQL简介](img/B05071_04_01.jpg)'
- en: 'In your application, you''ll use an object-relational mapping library or direct
    SQL statements to select the blog post record and the post comments records to
    create your blog post object. However, in a document-based database, the blog
    post will be stored completely as a single document that can later be queried.
    For instance, in a database that stores documents in a JSON format, your blog
    post document would probably look like the following code snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中，您将使用对象关系映射库或直接SQL语句来选择博客文章记录和帖子评论记录，以创建您的博客文章对象。然而，在基于文档的数据库中，博客文章将完全存储为单个文档，以后可以进行查询。例如，在一个以JSON格式存储文档的数据库中，您的博客文章文档可能看起来像以下代码片段：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This demonstrates the main difference between document-based databases and relational
    databases. So, while working with relational databases, your data is stored in
    different tables, with your application assembling objects using table records.
    Storing your data as holistic documents will allow faster read operations since
    your application won't have to rebuild the objects with every read. Furthermore,
    document-oriented databases have other advantages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明了文档型数据库和关系型数据库之间的主要区别。因此，在使用关系型数据库时，您的数据存储在不同的表中，您的应用程序使用表记录组装对象。将数据存储为整体文档将允许更快的读取操作，因为您的应用程序不必在每次读取时重新构建对象。此外，面向文档的数据库还有其他优势。
- en: 'While developing your application, you often encounter another problem: model
    changes. Let''s assume you want to add a new property to each blog post. So, you
    go ahead and change your posts table and then go to your application data layer
    and add that property to your blog post object. As your application already contains
    several blog posts, all existing blog post objects will have to change as well,
    which means that you''ll have to cover your code with extra validation procedures.
    However, document-based databases are often schema-less, which means you can store
    different objects in a single collection of objects without changing anything
    in your database. Although this may sound like asking for trouble to some experienced
    developers, the freedom of schema-less storage has several advantages.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，您经常会遇到另一个问题：模型更改。假设您想要为每篇博客文章添加一个新属性。因此，您可以更改您的帖子表，然后转到应用程序数据层，并将该属性添加到您的博客文章对象中。由于您的应用程序已经包含了几篇博客文章，所有现有的博客文章对象也将发生变化，这意味着您必须在代码中添加额外的验证过程。然而，基于文档的数据库通常是无模式的，这意味着您可以在单个对象集合中存储不同的对象，而无需更改数据库中的任何内容。尽管这对一些有经验的开发人员来说可能听起来像是在寻求麻烦，但无模式存储的自由具有几个优点。
- en: For example, think about an e-commerce application that sells used furniture.
    In your `products` table, a chair and a closet might have some common features,
    such as the type of wood, but a customer might also be interested in the number
    of doors the closet has. Storing the closet and chair objects in the same table
    means they could be stored in either a table with a large number of empty columns
    or using the more practical entity-attribute-value pattern, where another table
    is used to store key-value attributes. However, using schema-less storage will
    allow you to define different properties for different objects in the same collection,
    while still enabling you to query this collection using common properties, such
    as wood type. This means your application, and not the database, will be in charge
    of enforcing the data structure, which can help you speed up your development
    process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个销售二手家具的电子商务应用程序。在您的“产品”表中，椅子和壁橱可能具有一些共同的特征，比如木材的类型，但客户可能还对壁橱有多少个门感兴趣。将壁橱和椅子对象存储在同一个表中意味着它们可以存储在具有大量空列的表中，或者使用更实用的实体-属性-值模式，其中另一个表用于存储键-值属性。然而，使用无模式存储将允许您在同一集合中为不同的对象定义不同的属性，同时仍然可以使用常见属性查询该集合，比如木材类型。这意味着您的应用程序，而不是数据库，将负责强制执行数据结构，这可以帮助您加快开发过程。
- en: While there are many NoSQL solutions that solve various development issues,
    usually around caching and scale, document-oriented databases are rapidly becoming
    the leaders of the movement. The document-oriented database's ease of use, along
    with its standalone persistent storage offering, even threatens to replace the
    traditional SQL solutions in some use cases. And although there are a few document-oriented
    databases, none are as popular as MongoDB.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多NoSQL解决方案解决各种开发问题，通常围绕缓存和规模，但面向文档的数据库正在迅速成为该运动的领导者。文档导向数据库的易用性，以及其独立的持久存储功能，甚至威胁着在某些用例中取代传统的SQL解决方案。尽管有一些文档导向数据库，但没有一个像MongoDB那样受欢迎。
- en: Introducing MongoDB
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MongoDB
- en: Back in 2007, Dwight Merriman and Eliot Horowitz formed a company named 10gen
    to create a better platform to host web applications. The idea was to create a
    hosting as a service that will allow developers to focus on building their application,
    rather than handle hardware management and infrastructure scaling. Soon, they
    discovered the community wasn't keen on giving up so much of the control over
    their application's infrastructure. As a result, they released the different parts
    of the platform as open source projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回到2007年，Dwight Merriman和Eliot Horowitz成立了一家名为10gen的公司，以创建一个更好的平台来托管Web应用程序。他们的想法是创建一个作为服务的托管平台，让开发人员专注于构建他们的应用程序，而不是处理硬件管理和基础设施扩展。很快，他们发现社区不愿意放弃对他们应用程序基础设施的控制。因此，他们将平台的不同部分作为开源项目发布。
- en: One such project was a document-based database solution called MongoDB. Derived
    from the word humongous, MongoDB was able to support complex data storage, while
    maintaining the high-performance approach of other NoSQL stores. The community
    cheerfully adopted this new paradigm, making MongoDB one of the fastest-growing
    databases in the world. With more than 150 contributors and over 10,000 commits,
    it also became one of the most popular open source projects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个这样的项目是一个名为MongoDB的基于文档的数据库解决方案。MongoDB源自于“巨大”的单词，能够支持复杂的数据存储，同时保持其他NoSQL存储的高性能方法。社区欣然接受了这种新的范式，使MongoDB成为世界上增长最快的数据库之一。拥有150多名贡献者和超过10,000次提交，它也成为最受欢迎的开源项目之一。
- en: MongoDB's main goal was to create a new type of database that combined the robustness
    of a relational database with the fast throughput of distributed key-value data
    stores. With the scalable platform in mind, it had to support simple horizontal
    scaling while sustaining the durability of traditional databases. Another key
    design goal was to support web application development in the form of standard
    JSON outputs. These two design goals turned out to be MongoDB's greatest advantages
    over other solutions as these aligned perfectly with other trends in web development,
    such as the almost ubiquitous use of cloud virtualization hosting or the shift
    towards horizontal, instead of vertical, scaling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的主要目标是创建一种新类型的数据库，将关系数据库的健壮性与分布式键值数据存储的快速吞吐量相结合。考虑到可扩展的平台，它必须支持简单的水平扩展，同时保持传统数据库的耐久性。另一个关键的设计目标是支持Web应用程序开发，以标准JSON输出的形式。这两个设计目标最终成为MongoDB相对于其他解决方案的最大优势，因为这些与Web开发中的其他趋势完美契合，比如几乎无处不在的云虚拟化托管的使用或向水平而不是垂直扩展的转变。
- en: First dismissed as another NoSQL storage layer over the more viable relational
    database, MongoDB evolved way beyond the platform where it was born. Its ecosystem
    grew to support most of the popular programming platforms, with the various community-backed
    drivers. Along with this, many other tools were formed, including different MongoDB
    clients, profiling and optimization tools, administration and maintenance utilities,
    as well as a couple of VC-backed hosting services. Even major companies such as
    eBay and The New York Times began to use MongoDB data storage in their production
    environment. To understand why developers prefer MongoDB, it's time we dive into
    some of its key features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最初被认为是更可行的关系数据库上的另一个NoSQL存储层，MongoDB发展到远远超出了它诞生的平台。它的生态系统发展到支持大多数流行的编程平台，拥有各种社区支持的驱动程序。除此之外，还形成了许多其他工具，包括不同的MongoDB客户端、性能分析和优化工具、管理和维护实用程序，以及一些风险投资支持的托管服务。甚至一些大公司，如eBay和纽约时报，开始在其生产环境中使用MongoDB数据存储。要了解为什么开发人员更喜欢MongoDB，现在是时候深入了解它的一些关键特性了。
- en: Key features of MongoDB
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB的关键特性
- en: MongoDB has some key features that helped it become so popular. As we mentioned
    before, the goal was to create a new breed between traditional database features
    and the high performance of NoSQL stores. As a result, most of its key features
    were created to evolve beyond the limitations of other NoSQL solutions while integrating
    some of the abilities of relational databases. In this section, you'll learn why
    MongoDB can become your preferred database when approaching modern web application
    developments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB有一些关键特性，帮助它变得如此受欢迎。正如我们之前提到的，目标是在传统数据库功能和NoSQL存储的高性能之间创建一种新的品种。因此，它的大多数关键特性都是为了超越其他NoSQL解决方案的限制，同时整合一些关系数据库的能力而创建的。在本节中，您将了解为什么在处理现代Web应用程序开发时，MongoDB可以成为您首选的数据库。
- en: The BSON format
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BSON格式
- en: One of the greatest features of MongoDB is its JSON-like storage format named
    BSON. Standing for **Binary JSON**, the BSON format is a binary-encoded serialization
    of JSON-like documents, and it is designed to be more efficient in size and speed,
    allowing MongoDB's high read/write throughput.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB最伟大的特性之一是其类似JSON的存储格式，名为BSON。BSON代表**二进制JSON**，BSON格式是JSON样式文档的二进制编码序列化，旨在在大小和速度上更高效，从而实现MongoDB的高读/写吞吐量。
- en: Like JSON, BSON documents are a simple data structure representation of objects
    and arrays in a key-value format. A document consists of a list of elements, each
    with a string typed field name and a typed field value. These documents support
    all of the JSON specific data types along with other data types, such as the `Date`
    type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSON一样，BSON文档是对象和数组的简单数据结构表示，采用键值格式。文档由一系列元素组成，每个元素都有一个字符串类型的字段名和一个类型化的字段值。这些文档支持所有JSON特定的数据类型以及其他数据类型，例如`Date`类型。
- en: 'Another big advantage of the BSON format is the use of the `_id` field as the
    primary key. The `_id` field value will usually be a unique identifier type, named
    `ObjectId`, that is either generated by the application driver or by the mongod
    service. In the event the driver fails to provide a `_id` field with a unique
    `ObjectId`, the mongod service will add it automatically using:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: BSON格式的另一个重要优势是使用`_id`字段作为主键。`_id`字段值通常是一个名为`ObjectId`的唯一标识符类型，它可以由应用程序驱动程序或mongod服务生成。如果驱动程序未能提供带有唯一`ObjectId`的`_id`字段，mongod服务将自动添加它，使用以下方式：
- en: A 4-byte value representing the seconds since the Unix epoch
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示自Unix纪元以来的秒数的4字节值
- en: A 3-byte machine identifier
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个3字节的机器标识符
- en: A 2-byte process ID
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个2字节的进程ID
- en: A 3-byte counter, starting with a random value
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个3字节的计数器，从一个随机值开始
- en: 'So, a BSON representation of the blog post object from the previous example
    would look like the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，上一个示例中的博客文章对象的BSON表示将如下代码片段所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The BSON format enables MongoDB to internally index and map document properties
    and even nested documents, allowing it to scan the collection efficiently and,
    more importantly, to match objects to complex query expressions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: BSON格式使MongoDB能够在内部索引和映射文档属性，甚至嵌套文档，从而能够高效地扫描集合，并且更重要的是，能够将对象与复杂的查询表达式匹配。
- en: MongoDB ad hoc queries
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB的特点
- en: One of the other MongoDB design goals was to expand the abilities of ordinary
    key-value stores. The main issue of common key-value stores is their limited query
    capabilities, which usually means your data is only queryable using the key field,
    and more complex queries are mostly predefined. To solve this issue, MongoDB drew
    its inspiration from the relational database dynamic query language.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的另一个设计目标是扩展普通键值存储的能力。常见键值存储的主要问题是其有限的查询能力，这通常意味着您的数据只能使用键字段进行查询，而更复杂的查询大多是预定义的。为了解决这个问题，MongoDB从关系数据库动态查询语言中汲取了灵感。
- en: 'Supporting ad hoc queries means that the database will respond to dynamically
    structured queries out of the box, without the need to predefine each query. It
    is able to do this by indexing BSON documents and using a unique query language.
    Let''s have a look at the following SQL statement example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 支持即席查询意味着数据库将立即响应动态结构化的查询，无需预定义每个查询。它能够通过索引BSON文档并使用独特的查询语言来实现这一点。让我们看一下以下SQL语句示例：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This simple statement is asking the database for all the post records with
    a title containing the word `mongo`. Replicating this query in MongoDB would look
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的语句是在要求数据库返回所有标题中包含单词`mongo`的帖子记录。在MongoDB中复制这个查询将如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running this command in the MongoDB shell will return all the posts whose `title`
    field contains the word `mongo`. You'll learn more about the MongoDB query language
    later in this chapter, but for now it is important to remember that it is almost
    as queryable as your traditional relational database. The MongoDB query language
    is great, but it raises the question of how efficiently these queries run when
    the database gets larger. Like relational databases, MongoDB solves this issue
    using a mechanism called indexing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB shell中运行此命令将返回所有`title`字段包含单词`mongo`的帖子。您将在本章后面学习更多关于MongoDB查询语言的内容，但现在重要的是要记住它几乎与传统的关系型数据库一样可查询。MongoDB查询语言很棒，但它引发了一个问题，即当数据库变得更大时，这些查询运行效率如何。像关系型数据库一样，MongoDB使用称为索引的机制来解决这个问题。
- en: MongoDB indexing
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB索引
- en: Indexes are unique data structures that enable the database engine to efficiently
    resolve queries. When a query is sent to the database, it will have to scan through
    the entire collection of documents to find those that match the query statement.
    This way, the database engine processes a large amount of unnecessary data, resulting
    in poor performance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是一种独特的数据结构，使数据库引擎能够高效解析查询。当查询发送到数据库时，它将不得不扫描整个文档集合，以找到与查询语句匹配的文档。这种方式，数据库引擎处理了大量不必要的数据，导致性能不佳。
- en: 'To speed up the scan, the database engine can use a predefined index, which
    maps document fields and can tell the engine which documents are compatible with
    this query statement. To understand how indexes work, let''s say we want to retrieve
    all the posts that have more than 10 comments. In this instance, our document
    is defined as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快扫描速度，数据库引擎可以使用预定义的索引，它映射文档字段，并告诉引擎哪些文档与此查询语句兼容。为了理解索引的工作原理，我们假设我们想检索所有具有超过10条评论的帖子。在这种情况下，我们的文档定义如下：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, a MongoDB query that requests documents with more than 10 comments would
    be as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个请求超过10条评论的文档的MongoDB查询将如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To execute this query, MongoDB would have to go through all the posts and check
    whether the post has a `commentCount` property larger than `10`. However, if a
    `commentCount` index was defined, then MongoDB would only have to check which
    documents have a `commentCount` property larger than `10`, before retrieving these
    documents. The following diagram illustrates how a `commentCount` index would
    work:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此查询，MongoDB必须遍历所有帖子，并检查帖子是否具有大于`10`的`commentCount`属性。然而，如果定义了`commentCount`索引，那么MongoDB只需检查哪些文档具有大于`10`的`commentCount`属性，然后检索这些文档。以下图表说明了`commentCount`索引的工作原理：
- en: '![MongoDB indexing](img/B05071_04_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![MongoDB索引](img/B05071_04_02.jpg)'
- en: Using the `commentsCount` index to retrieve documents with more than `10` comments
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`commentsCount`索引检索具有超过`10`条评论的文档
- en: MongoDB replica set
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB副本集
- en: 'To provide data redundancy and improved availability, MongoDB uses an architecture
    called a **replica set**. Replication of databases helps to protect your data
    to recover from hardware failure and increase read capacity. A replica set is
    a set of MongoDB services that host the same dataset. One service is used as the
    primary and the other services that are used are called secondaries. All of the
    set instances support read operations, but only the primary instance is in charge
    of write operations. When a write operation occurs, the primary will inform the
    secondaries about the changes and make sure they''ve applied them to their datasets''
    replication. The following diagram illustrates a common replica set:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供数据冗余和改善可用性，MongoDB使用一种称为**副本集**的架构。数据库的复制有助于保护数据，以便从硬件故障中恢复并增加读取容量。副本集是一组承载相同数据集的MongoDB服务。一个服务被用作主服务，其他服务被称为次服务。所有的实例都支持读操作，但只有主实例负责写操作。当发生写操作时，主实例会通知次实例进行更改，并确保它们已将更改应用到其数据集的复制中。以下图表说明了一个常见的副本集：
- en: '![MongoDB replica set](img/B05071_04_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![MongoDB副本集](img/B05071_04_03.jpg)'
- en: The workflow of a replica set with one primary and two secondaries
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一个主和两个次的副本集的工作流程
- en: Another robust feature of the MongoDB replica set is its automatic failover.
    When one of the set members can't reach the primary instance for more than 10
    seconds, the replica set will automatically elect and promote a secondary instance
    as the new primary. When the old primary comes back online, it will rejoin the
    replica set as a secondary instance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB副本集的另一个强大功能是其自动故障转移。当副本集的一个成员无法在10秒内到达主实例时，副本集将自动选举并提升一个次实例为新的主实例。旧的主实例恢复在线后，它将作为次实例重新加入副本集。
- en: 'Another feature of the replica set is the ability to add arbiter nodes. Arbiters
    do not maintain any data; their main purpose is to maintain a quorum in the replica
    set. This means they participate in the process of electing a new primary but
    cannot function as a secondary or be elected to be the primary. In short, arbiters
    help to provide consistency within the replica set with a cheaper resource cost
    than regular data nodes. The following diagram illustrates a common replica set
    with an arbiter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 副本集的另一个特性是能够添加仲裁节点。仲裁者不维护任何数据；它们的主要目的是在副本集中维护法定人数。这意味着它们参与选举新的主要过程，但不能作为次要功能或被选为主要功能。简而言之，仲裁者有助于以比常规数据节点更低的资源成本在副本集中提供一致性。以下图表说明了一个带有仲裁者的常见副本集：
- en: '![MongoDB replica set](img/B05071_04_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![MongoDB副本集](img/B05071_04_04.jpg)'
- en: The workflow of a replica set with a primary, a secondary, and an arbiter
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 具有主、次和仲裁者的副本集的工作流程
- en: Replication is a very robust feature of MongoDB that is derived directly from
    its platform origin and is one of the main features that makes MongoDB production-ready.
    However, it is not the only one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的复制是一个非常强大的功能，直接源自其平台起源，是使MongoDB达到生产就绪状态的主要功能之一。然而，这并不是唯一的功能。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about MongoDB replica sets, visit [http://docs.mongodb.org/manual/replication/](http://docs.mongodb.org/manual/replication/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于MongoDB副本集的信息，请访问[http://docs.mongodb.org/manual/replication/](http://docs.mongodb.org/manual/replication/)。
- en: MongoDB sharding
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB分片
- en: 'Scaling is a common problem with a growing web application. The various approaches
    to solve this issue can be divided into two groups: vertical scaling and horizontal
    scaling. The differences between the two are illustrated in the following diagram:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web应用程序的增长，扩展性是一个常见的问题。解决这个问题的各种方法可以分为两组：垂直扩展和水平扩展。两者之间的区别在下图中有所说明：
- en: '![MongoDB sharding](img/B05071_04_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![MongoDB分片](img/B05071_04_05.jpg)'
- en: Vertical scaling with a single machine versus horizontal scaling with multiple
    machines
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单台机器的垂直扩展与多台机器的水平扩展
- en: 'Vertical scaling is easier and consists of increasing single-machine resources,
    such as RAM and CPU. However, it has two major drawbacks: first, at some level,
    increasing a single machine''s resources becomes disproportionately more expensive
    compared to splitting the load between several smaller machines. Second, the popular
    cloud-hosting providers limit the size of the machine instances you can use. So,
    scaling your application vertically can only be done up to a certain level.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展更容易，包括增加单台机器的资源，如RAM和CPU。然而，它有两个主要缺点：首先，在某个水平上，增加单台机器的资源相对于在几台较小的机器之间分配负载变得更加昂贵。其次，流行的云托管提供商限制了您可以使用的机器实例的大小。因此，垂直扩展应用程序只能在一定水平上进行。
- en: Horizontal scaling is more complicated and is done using several machines. Each
    machine will handle a part of the load, providing a better overall performance.
    The problem with horizontal database scaling is how to properly divide the data
    between different machines and how to manage the read/write operations between
    them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展更加复杂，需要使用多台机器。每台机器将处理一部分负载，提供更好的整体性能。水平数据库扩展的问题在于如何正确地在不同的机器之间分配数据，以及如何管理它们之间的读/写操作。
- en: Luckily, MongoDB supports horizontal scaling, which it refers to as sharding.
    *Sharding is the process of splitting the data between different machines, or
    shards*. Each shard holds a portion of the data and functions as a separate database.
    The collection of several shards together is what forms a single logical database.
    Operations are performed through services called query routers, which ask the
    configuration servers how to delegate each operation to the right shard.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，MongoDB支持水平扩展，它称之为分片。*分片是将数据分割到不同的机器或分片的过程*。每个分片保存一部分数据，并作为一个独立的数据库。几个分片的集合形成了一个单一的逻辑数据库。操作是通过称为查询路由器的服务执行的，它们询问配置服务器如何将每个操作委派给正确的分片。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about MongoDB sharding, visit [http://docs.mongodb.org/manual/sharding/](http://docs.mongodb.org/manual/sharding/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于MongoDB分片的信息，请访问[http://docs.mongodb.org/manual/sharding/](http://docs.mongodb.org/manual/sharding/)。
- en: MongoDB 3.0
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB 3.0
- en: 'At the beginning of 2015, the MongoDB team introduced the third major version
    of the MongoDB database. Above all else, this version marks the transition MongoDB
    is making towards becoming a leading database solution for bigger and more complex
    production environments. Or, as the team describes it, making MongoDB the "default
    database" for every organization. In order to do so, the team presented several
    new features:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年初，MongoDB团队推出了MongoDB数据库的第三个主要版本。最重要的是，这个版本标志着MongoDB正在向成为更大更复杂的生产环境的领先数据库解决方案迈进。或者，正如团队所描述的那样，使MongoDB成为每个组织的“默认数据库”。为了实现这一目标，团队提出了几个新功能：
- en: '**Storage API**: In this version, the storage engine layer is decoupled from
    higher-level operations. This means organizations can now choose which storage
    engines to use according to their application needs, gaining up to 10x better
    performance.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储API**：在这个版本中，存储引擎层与更高级别的操作解耦。这意味着组织现在可以根据其应用程序需求选择使用哪种存储引擎，从而获得高达10倍的性能提升。'
- en: '**Enhanced query engine introspection**: This allows the DBA to better analyze
    key queries, making sure performance is optimized.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的查询引擎内省**：这使得数据库管理员能够更好地分析关键查询，确保性能得到优化。'
- en: '**Better authentication and auditing**: This allows larger organization to
    manage their MongoDB instance more securely.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的身份验证和审计**：这使得大型组织能够更安全地管理他们的MongoDB实例。'
- en: '**Better logging**: More elaborate logging features allow developers to better
    track MongoDB''s operations.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的日志记录**：更复杂的日志记录功能使开发人员能够更好地跟踪MongoDB的操作。'
- en: These features and many others are what make MongoDB so popular. Although there
    are many good alternatives, MongoDB is becoming more and more ubiquitous among
    developers and is on its way to become one of the world's leading database solutions.
    Let's dive a little deeper to find out how you can easily start using MongoDB.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能和许多其他功能使MongoDB如此受欢迎。尽管有许多良好的替代方案，但MongoDB在开发人员中变得越来越普遍，并且正在成为世界领先的数据库解决方案之一。让我们深入了解如何轻松开始使用MongoDB。
- en: MongoDB shell
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB shell
- en: If you followed [Chapter 1](ch01.html "Chapter 1. Introduction to MEAN"), *Introduction
    to MEAN*, you should have a working instance of MongoDB in your local environment.
    To interact with MongoDB, you'll use the MongoDB shell, which you encountered
    in [Chapter 1](ch01.html "Chapter 1. Introduction to MEAN"), *Introduction to
    MEAN*. The MongoDB shell is a command-line tool that enables the execution of
    different operations using a JavaScript syntax query language.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循了[第1章](ch01.html "第1章。MEAN简介"), *MEAN简介*，您应该在本地环境中拥有一个可用的MongoDB实例。要与MongoDB交互，您将使用MongoDB
    shell，这是您在[第1章](ch01.html "第1章。MEAN简介")中遇到的。MongoDB shell是一个命令行工具，它使用JavaScript语法查询语言来执行不同的操作。
- en: 'In order to explore the different parts of MongoDB, let''s start the MongoDB
    shell by running the `mongo` executable, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索MongoDB的不同部分，让我们通过运行`mongo`可执行文件来启动MongoDB shell，如下所示：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If MongoDB has been properly installed, you should see an output similar to
    what is shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果MongoDB已正确安装，您应该看到类似于以下截图所示的输出：
- en: '![MongoDB shell](img/B05071_04_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![MongoDB shell](img/B05071_04_06.jpg)'
- en: Notice how the shell is telling you the current shell version, and that it has
    connected to the default test database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意shell如何告诉您当前的shell版本，并且它已连接到默认的测试数据库。
- en: MongoDB databases
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB数据库
- en: 'Each MongoDB server instance can store several databases. Unless specifically
    defined, the MongoDB shell will automatically connect to the default test database.
    Let''s switch to another database called `mean` by executing the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MongoDB服务器实例可以存储多个数据库。除非特别定义，否则MongoDB shell将自动连接到默认的测试数据库。通过执行以下命令切换到另一个名为mean的数据库：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You''ll see a command-line output telling you that the shell switched to the
    `mean` database. Notice that you didn''t need to create the database before using
    it because in MongoDB, databases and collections are lazily created when you insert
    your first document. This behavior is consistent with MongoDB''s dynamic approach
    to data. Another way to use a specific database is to run the shell executable
    with the database name as an argument, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个命令行输出，告诉您shell已切换到mean数据库。请注意，您无需在使用数据库之前创建数据库，因为在MongoDB中，当您插入第一个文档时，数据库和集合会懒惰地创建。这种行为与MongoDB对数据的动态方法一致。使用特定数据库的另一种方法是以数据库名称作为参数运行shell可执行文件，如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The shell will then automatically connect to the `mean` database. If you want
    to list all the other databases in the current MongoDB server, just execute the
    following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: shell将自动连接到mean数据库。如果您想列出当前MongoDB服务器中的所有其他数据库，只需执行以下命令：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will show you a list of currently available databases that have at least
    one document stored.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示当前可用的至少存储了一个文档的数据库列表。
- en: MongoDB collections
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB集合
- en: A MongoDB collection is a list of MongoDB documents and is the equivalent of
    a relational database table. A collection is created when its first document is
    being inserted. Unlike a table, a collection doesn't enforce any type of schema
    and can host different structured documents.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB集合是MongoDB文档的列表，相当于关系数据库表。当插入其第一个文档时，将创建一个集合。与表不同，集合不强制执行任何类型的模式，并且可以托管不同结构的文档。
- en: 'To perform operations on a MongoDB collection, you''ll need to use the collection
    methods. Let''s create a posts collection and insert the first post. In order
    to do this, execute the following command in the MongoDB shell:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要在MongoDB集合上执行操作，您需要使用集合方法。让我们创建一个名为posts的集合并插入第一篇文章。为了做到这一点，在MongoDB shell中执行以下命令：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After executing the preceding command, it will automatically create the `posts`
    collection and insert the first document. To retrieve the collection documents,
    execute the following command in the MongoDB shell:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令后，它将自动创建posts集合并插入第一个文档。要检索集合文档，请在MongoDB shell中执行以下命令：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see a command-line output similar to what is shown in the following
    screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于以下截图所示的命令行输出：
- en: '![MongoDB collections](img/B05071_04_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![MongoDB集合](img/B05071_04_07.jpg)'
- en: This means that you have successfully created the `posts` collection and inserted
    your first document.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您已成功创建了posts集合并插入了第一个文档。
- en: 'To show all available collections, issue the following command in the MongoDB
    shell:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示所有可用的集合，请在MongoDB shell中发出以下命令：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The MongoDB shell will output the list of available collections, which in your
    case are the `posts` collection and another collection called `system.indexes`,
    which holds the list of your database indexes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB shell将输出可用集合的列表，您的情况下是posts集合和另一个名为system.indexes的集合，它保存了数据库索引的列表。
- en: 'If you''d like to delete the `posts` collection, you will need to execute the
    `drop()` command as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想删除posts集合，您需要执行drop()命令，如下所示：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The shell will inform you that the collection was dropped, by responding with
    a true output.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: shell将通过输出true来通知您该集合已被删除。
- en: MongoDB CRUD operations
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB CRUD操作
- en: '**Create-Read-Update-Delete** (**CRUD**) operations, are the basic interactions
    you perform with a database. To execute CRUD operations over your database entities,
    MongoDB provides various collection methods.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建-读取-更新-删除**（CRUD）操作是您与数据库执行的基本交互。为了对数据库实体执行CRUD操作，MongoDB提供了各种集合方法。'
- en: Creating a new document
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新文档
- en: You're already familiar with the basic method of creating a new document using
    the `insert()` method, as you previously did in earlier examples. Besides the
    `insert()` method, there are two more methods called `update()` and `save()` to
    create new objects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉使用insert()方法创建新文档的基本方法，就像您之前在早期示例中所做的那样。除了insert()方法，还有两种方法叫做update()和save()来创建新对象。
- en: Creating a document using insert()
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用insert()创建文档
- en: 'The most common way to create a new document is to use the `insert()` method.
    The `insert()` method takes a single argument that represents the new document.
    To insert a new post, just issue the following command in the MongoDB shell:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新文档的最常见方法是使用insert()方法。insert()方法接受一个表示新文档的单个参数。要插入新的文章，只需在MongoDB shell中发出以下命令：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating a document using update()
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用update()创建文档
- en: 'The `update()` method is usually used to update an existing document. You can
    also use the `upsert` flag to create a new document, if no document matches the
    query criteria:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: update()方法通常用于更新现有文档。您还可以使用upsert标志来创建新文档，如果没有文档与查询条件匹配：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, MongoDB will look for a post created by `alice` and
    try to update it. Considering the fact that the `posts` collection doesn't have
    a post created by `alice` and the fact you have used the `upsert` flag, MongoDB
    will not find an appropriate document to update and will create a new document
    instead.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，MongoDB将查找由`alice`创建的帖子并尝试更新它。考虑到`posts`集合没有由`alice`创建的帖子，以及您已经使用了`upsert`标志，MongoDB将找不到适当的文档进行更新，而是创建一个新文档。
- en: Creating a document using save()
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用save()创建文档
- en: 'Another way of creating a new document is by calling the `save()` method, passing
    it a document that either doesn''t have an `_id` field or has an `_id` field that
    doesn''t exist in the collection:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新文档的另一种方法是调用`save()`方法，传递一个没有`_id`字段或在集合中不存在的`_id`字段的文档：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will have the same effect as the `update()` method and will create a new
    document instead of updating an existing one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生与`update()`方法相同的效果，并将创建一个新文档而不是更新现有文档。
- en: Reading documents
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读文档
- en: The `find()` method is used to retrieve a list of documents from a MongoDB collection.
    Using the `find()` method, you can either request all the documents in a collection
    or use a query to retrieve specific documents.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()`方法用于从MongoDB集合中检索文档列表。使用`find()`方法，您可以请求集合中的所有文档，或使用查询检索特定文档。'
- en: Finding all the collection documents
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找所有集合文档
- en: 'To retrieve all the documents in the `posts` collection, you should either
    pass an empty query to the `find()` method or not pass any arguments at all. The
    following query will retrieve all the documents in the `posts` collection:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索`posts`集合中的所有文档，应该将空查询传递给`find()`方法，或者根本不传递任何参数。以下查询将检索`posts`集合中的所有文档：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Furthermore, performing the same operation can also be done using the following
    query:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，也可以使用以下查询执行相同的操作：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These two queries are basically the same and will return all the documents in
    the `posts` collection.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个查询基本上是相同的，将返回`posts`集合中的所有文档。
- en: Using an equality statement
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用相等语句
- en: 'To retrieve a specific document, you can use an equality condition query that
    will grab all the documents which comply with that condition. For instance, to
    retrieve all the posts created by `alice`, you will need to issue the following
    command in the shell:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索特定文档，可以使用相等条件查询，该查询将抓取符合该条件的所有文档。例如，要检索由`alice`创建的所有帖子，您需要在shell中发出以下命令：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will retrieve all the documents that have the `user` property equal to
    `alice`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检索具有`user`属性等于`alice`的所有文档。
- en: Using query operators
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用查询操作符
- en: 'Using an equality statement may not be enough. To build more complex queries,
    MongoDB supports a variety of query operators. Using query operators, you can
    look for different sorts of conditions. For example, to retrieve all the posts
    that were created by either `alice` or `bob`, you can use the following `$in`
    operator:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相等语句可能不够。为了构建更复杂的查询，MongoDB支持各种查询操作符。使用查询操作符，您可以查找不同类型的条件。例如，要检索由`alice`或`bob`创建的所有帖子，可以使用以下`$in`操作符：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are plenty of other query operators you can learn about by visiting [http://docs.mongodb.org/manual/reference/operator/query/#query-selectors](http://docs.mongodb.org/manual/reference/operator/query/#query-selectors).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问[http://docs.mongodb.org/manual/reference/operator/query/#query-selectors](http://docs.mongodb.org/manual/reference/operator/query/#query-selectors)了解更多查询操作符。
- en: Building AND/OR queries
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建AND/OR查询
- en: 'When you build a query, you may need to use more than one condition. Like in
    SQL, you can use `AND`/`OR` operators to build multiple condition query statements.
    To perform an `AND` query, you simply add the properties you''d like to check
    to the query object. For instance, take a look at the following query:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 构建查询时，可能需要使用多个条件。就像在SQL中一样，您可以使用`AND`/`OR`运算符来构建多条件查询语句。要执行`AND`查询，只需将要检查的属性添加到查询对象中。例如，看一下以下查询：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It is similar to the `find()` query you''ve previously used, but adds another
    condition that verifies the document''s `commentCount` property and will only
    grab documents that were created by `alice` and have more than `10` comments.
    An `OR` query is a bit more complex because it involves the `$or` operator. To
    understand it better, take a look at another version of the previous example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它类似于您之前使用的`find()`查询，但添加了另一个条件，验证文档的`commentCount`属性，并且只会抓取由`alice`创建且评论数超过`10`的文档。`OR`查询稍微复杂，因为它涉及`$or`运算符。要更好地理解它，请看上一个例子的另一个版本：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Like the query operators example, this query will also grab all the posts created
    by either `bob` or `alice`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与查询操作符示例一样，这个查询也会抓取由`bob`或`alice`创建的所有帖子。
- en: Updating existing documents
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新现有文档
- en: Using MongoDB, you have the option of updating documents using either the `update()`
    or `save()` methods.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB，您可以使用`update()`或`save()`方法更新文档。
- en: Updating documents using update()
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用update()更新文档
- en: 'The `update()` method takes three arguments to update existing documents. The
    first argument is the selection criteria that indicate which documents to update,
    the second argument is the `update` statement, and the last argument is the `options`
    object. For instance, in the following example, the first argument is telling
    MongoDB to look for all the documents created by `alice`, the second argument
    tells it to update the `title` field, and the third is forcing it to execute the
    `update` operation on all the documents it finds:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法需要三个参数来更新现有文档。第一个参数是选择条件，指示要更新哪些文档，第二个参数是`update`语句，最后一个参数是`options`对象。例如，在下面的例子中，第一个参数告诉MongoDB查找所有由`alice`创建的文档，第二个参数告诉它更新`title`字段，第三个参数强制它在找到的所有文档上执行`update`操作：'
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how the `multi` property has been added to the `options` object. The
    `update()` method's default behavior is to update a single document, so by setting
    the `multi` property, you tell the `update()` method to update all the documents
    that comply with the selection criteria.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`multi`属性已添加到`options`对象中。`update()`方法的默认行为是更新单个文档，因此通过设置`multi`属性，您告诉`update()`方法更新符合选择条件的所有文档。
- en: Updating documents using save()
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用save()更新文档
- en: 'Another way of updating an existing document is by calling the `save()` method,
    passing it a document that contains an `_id` field. For instance, the following
    command will update an existing document with an `_id` field that is equal to
    `ObjectId("50691737d386d8fadbd6b01d")`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更新现有文档的另一种方法是调用`save()`方法，将包含`_id`字段的文档传递给它。例如，以下命令将更新具有`_id`字段等于`ObjectId("50691737d386d8fadbd6b01d")`的现有文档：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It's important to remember that if the `save()` method is unable to find an
    appropriate object, it will create a new one instead.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，如果`save()`方法无法找到合适的对象，它将创建一个新对象。
- en: Deleting documents
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除文档
- en: To remove documents, you will need to use the `remove()` method. The `remove()`
    method can accept up to two arguments. The first one is the deletion criteria,
    and the second is a Boolean argument that indicates whether or not to remove multiple
    documents.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除文档，您需要使用`remove()`方法。`remove()`方法最多可以接受两个参数。第一个是删除条件，第二个是一个布尔参数，指示是否删除多个文档。
- en: Deleting all documents
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除所有文档
- en: 'To remove all the documents from a collection, you will need to call the `remove()`
    method with no deletion criteria at all. For example, to remove all the `posts`
    documents, you''ll need to execute the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集合中删除所有文档，您需要调用`remove()`方法，而不需要任何删除条件。例如，要删除所有`posts`文档，您需要执行以下命令：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the `remove()` method is different from the `drop()` method, as
    it will not delete the collection or its indexes. To rebuild your collection with
    different indexes, it is preferred that you use the `drop()` method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`remove()`方法与`drop()`方法不同，因为它不会删除集合或其索引。要使用不同的索引重建集合，最好使用`drop()`方法。
- en: Deleting multiple documents
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除多个文档
- en: 'To remove multiple documents that match a criteria from a collection, you will
    need to call the `remove()` method with a deletion criteria. For example, to remove
    all the posts made by `alice`, you''ll need to execute the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集合中删除符合条件的多个文档，您需要使用带有删除条件的`remove()`方法。例如，要删除`alice`发布的所有帖子，您需要执行以下命令：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that this will remove all the documents created by `alice`, so be careful
    when using the `remove()` method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这将删除`alice`创建的所有文档，因此在使用`remove()`方法时要小心。
- en: Deleting a single document
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除单个文档
- en: 'To remove a single document that matches a criteria from a collection, you
    will need to call the `remove()` method with a deletion criteria and a Boolean
    stating that you only want to delete a single document. For example, to remove
    the first post made by `alice`, you''ll need to execute the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集合中删除与条件匹配的单个文档，您需要使用带有删除条件和布尔值的`remove()`方法，指示您只想删除单个文档。例如，要删除`alice`发布的第一篇帖子，您需要执行以下命令：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will remove the first document that was created by `alice` and leave other
    documents even if they match the deletion criteria.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除由`alice`创建的第一个文档，并且即使它们符合删除条件，也会保留其他文档。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about NoSQL databases and how they can be useful
    for modern web development. You also learned about the emerging leader of the
    NoSQL movement, MongoDB. You took a deeper dive into understanding the various
    features that make MongoDB such a powerful solution, and learned about its basic
    terminology. Finally, you caught a glimpse of MongoDB's powerful query language
    and how to perform all four CRUD operations. In the next chapter, we'll discuss
    how to connect Node.js and MongoDB together using the popular Mongoose module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了NoSQL数据库以及它们在现代Web开发中的用途。您还了解了NoSQL运动的新兴领导者MongoDB。您深入了解了使MongoDB成为强大解决方案的各种功能，并了解了其基本术语。最后，您一窥了MongoDB强大的查询语言以及如何执行所有四个CRUD操作。在下一章中，我们将讨论如何使用流行的Mongoose模块将Node.js和MongoDB连接在一起。
