- en: Your First Express Application
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一个Express应用程序
- en: Now that we've got our feet wet building an Express application for Node.js,
    let's start developing an application that performs a useful function. The application
    we'll build will keep a list of notes and will eventually have users who can send
    messages to each other. Over the course of this book, we will use it to explore
    some aspects of real Express web applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始为Node.js构建Express应用程序，让我们开始开发一个执行有用功能的应用程序。我们将构建的应用程序将保留一个笔记列表，并最终会有用户可以互发消息。在本书的过程中，我们将使用它来探索一些真实Express
    Web应用程序的方面。
- en: In this chapter, we'll start with the basic structure of an application, the
    initial UI, and the data model. We'll also lay the groundwork for adding persistent
    data storage and all the other features that we will cover in later chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从应用程序的基本结构、初始UI和数据模型开始。我们还将为添加持久数据存储和我们将在后续章节中涵盖的所有其他功能奠定基础。
- en: 'The topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Using Promises and async functions in Express router functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Express路由器函数中使用Promises和async函数
- en: JavaScript class definitions and data hiding in JavaScript classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript类定义和JavaScript类中的数据隐藏
- en: The architecture of an Express application using the MVC paradigm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MVC范例的Express应用程序架构
- en: Building an Express application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Express应用程序
- en: Implementing the CRUD paradigm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现CRUD范例
- en: Express application theming and Handlebars templates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express应用程序主题和Handlebars模板
- en: To get started, we will talk about integrating Express router callbacks with
    async functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论如何将Express路由器回调与async函数集成。
- en: Exploring Promises and async functions in Express router functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Express路由器函数中探索Promises和async函数的主题
- en: Before we get into developing our application, we need to take a deeper look
    at using the `Promise` class and async functions with Express because Express
    was invented before these features existed, and so it does not directly integrate
    with them. While we should be using async functions wherever possible, we have
    to be aware of how to properly use them in certain circumstances, such as in an
    Express application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始开发应用程序之前，我们需要深入了解如何在Express中使用`Promise`类和async函数，因为Express是在这些功能存在之前发明的，因此它不直接与它们集成。虽然我们应该尽可能使用async函数，但我们必须了解如何在某些情况下正确使用它们，比如在Express应用程序中。
- en: 'The rules in Express for handling asynchronous execution are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Express处理异步执行的规则如下：
- en: Synchronous errors are caught by Express and cause the application to go to
    the error handler.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步错误由Express捕获，并导致应用程序转到错误处理程序。
- en: Asynchronous errors must be reported by calling `next(err)`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步错误必须通过调用`next(err)`来报告。
- en: A successfully executing middleware function tells Express to invoke the next
    middleware by calling `next()`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功执行的中间件函数告诉Express通过调用`next()`来调用下一个中间件。
- en: A router function that returns a result to the HTTP request does not call `next()`.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回HTTP请求结果的路由器函数不调用`next()`。
- en: In this section, we'll discuss three ways to use Promises and async functions
    in a way that is compatible with these rules.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论三种使用Promises和async函数的方法，以符合这些规则。
- en: 'Both Promises and async functions are used for deferred and asynchronous computation
    and can make intensely nested callback functions a thing of the past:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Promise和async函数都用于延迟和异步计算，并且可以使深度嵌套的回调函数成为过去的事情：
- en: A `Promise` class represents an operation that hasn't completed yet but is expected
    to be completed in the future. We've used Promises already, so we know that the `.then`
    or `.catch` functions are invoked asynchronously when the promised result (or
    error) is available.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise`类表示尚未完成但预计将来完成的操作。我们已经使用过Promises，所以我们知道当承诺的结果（或错误）可用时，`.then`或`.catch`函数会异步调用。'
- en: Inside an async function, the `await` keyword is available to automatically
    wait for a Promise to resolve. It returns the result of a Promise, or else throws
    errors, in the natural location at the next line of code, while also accommodating
    asynchronous execution.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异步函数内部，`await`关键字可用于自动等待Promise解析。它返回Promise的结果，否则在下一行代码的自然位置抛出错误，同时也适应异步执行。
- en: The magic of async functions is that we can write asynchronous code that looks
    like synchronous code. It's still asynchronous code—meaning it works correctly
    with the Node.js event loop—but instead of results and errors landing inside callback
    functions, errors are thrown naturally as exceptions and results naturally land
    on the next line of code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数的魔力在于我们可以编写看起来像同步代码的异步代码。它仍然是异步代码——意味着它与Node.js事件循环正确工作——但是结果和错误不再落在回调函数内部，而是自然地作为异常抛出，结果自然地落在下一行代码上。
- en: 'Because this is a new feature in JavaScript, there are several traditional
    asynchronous coding practices with which we must correctly integrate. You may
    come across some other libraries for managing asynchronous code, including the
    following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是JavaScript中的一个新功能，所以我们必须正确地整合几种传统的异步编码实践。您可能会遇到一些其他用于管理异步代码的库，包括以下内容：
- en: The `async` library is a collection of functions for various asynchronous patterns.
    It was originally completely implemented around the callback function paradigm,
    but the current version can handle async functions and is available as an ES6
    package. Refer to [https://www.npmjs.com/package/async](https://www.npmjs.com/package/async)
    for more information.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`库是一组用于各种异步模式的函数。它最初完全围绕回调函数范式实现，但当前版本可以处理async函数，并且作为ES6包可用。有关更多信息，请参阅[https://www.npmjs.com/package/async](https://www.npmjs.com/package/async)。'
- en: 'Before Promises were standardized, at least two implementations were available:
    Bluebird ([http://bluebirdjs.com/](http://bluebirdjs.com/)) and Q ([https://www.npmjs.com/package/q](https://www.npmjs.com/package/q)).
    Nowadays, we focus on using the standard, built-in `Promise` object, but both
    of these packages offer additional features. What''s more likely is that we will
    come across older code that uses these libraries.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Promise标准化之前，至少有两种实现可用：Bluebird ([http://bluebirdjs.com/](http://bluebirdjs.com/))和Q
    ([https://www.npmjs.com/package/q](https://www.npmjs.com/package/q))。如今，我们专注于使用标准内置的`Promise`对象，但这两个包都提供了额外的功能。更有可能的是，我们会遇到使用这些库的旧代码。
- en: 'These and other tools were developed to make it easier to write asynchronous
    code and to solve the **pyramid of doom** problem. This is named after the shape
    that the code takes after a few layers of nesting. Any multistage process written
    as callbacks can quickly escalate to code that is nested many levels deep. Consider
    the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些和其他工具的开发是为了更容易编写异步代码并解决**末日金字塔**问题。这是根据代码在几层嵌套后采取的形状而命名的。任何以回调函数编写的多阶段过程都可能迅速升级为嵌套多层的代码。考虑以下例子：
- en: '[PRE0]js\1'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]js\1'
- en: 'A function like this creates the `Promise` object, giving it a callback function,
    within which is your asynchronous operation. The `resolve` and `reject` functions
    are passed into that function and are called when the Promise is resolved as either
    a success or failure state. A typical use of `new Promise` is a structure like
    this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数创建了`Promise`对象，给它一个回调函数，在其中是您的异步操作。`resolve`和`reject`函数被传递到该函数中，并在Promise解析为成功或失败状态时调用。`new
    Promise`的典型用法是这样的结构：
- en: '[PRE1]js\1'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]js\1'
- en: The `Promise` object is fluid enough that the function passed in a `.then` handler
    can return something, such as another Promise, and you can chain the `.then` calls
    together. The value returned in a `.then` handler (if any) becomes a new `Promise`
    object, and in this way, you can construct a chain of `.then` and `.catch` calls
    to manage a sequence of asynchronous operations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`对象足够灵活，传递给`.then`处理程序的函数可以返回一些东西，比如另一个Promise，并且可以将`.then`调用链接在一起。在`.then`处理程序中返回的值（如果有的话）将成为一个新的`Promise`对象，通过这种方式，您可以构建一个`.then`和`.catch`调用链来管理一系列异步操作。'
- en: With the `Promise` object, a sequence of asynchronous operations is called a
    **Promise chain**, consisting of chained `.then` handlers, as we will see in the
    next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Promise`对象，一系列异步操作被称为**Promise链**，由链接的`.then`处理程序组成，我们将在下一节中看到。
- en: Promises and error handling in Express router functions
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Express路由函数中的Promise和错误处理
- en: 'It is important that all errors are correctly handled and reported to Express.
    With synchronous code, Express will correctly catch a thrown exception and send
    it to the error handler. Take the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要正确处理所有错误并将其报告给Express。对于同步代码，Express将正确捕获抛出的异常并将其发送到错误处理程序。看下面的例子：
- en: '[PRE2]js\1'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]js\1'
- en: This is an example of the error indicator landing in an inconvenient place in
    the callback function. The exception is thrown in a completely different stack
    frame than the one invoked by Express. Even if we arranged to return a Promise,
    as is the case with an async function, Express doesn't handle the Promise. In
    this example, the error is lost; the caller would never receive a response and
    nobody would know why.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个错误指示器落在回调函数中不方便的地方的例子。异常在一个完全不同的堆栈帧中抛出，而不是由Express调用的堆栈帧。即使我们安排返回一个Promise，就像异步函数的情况一样，Express也不处理Promise。在这个例子中，错误被丢失；调用者永远不会收到响应，也没有人知道为什么。
- en: 'It is important to reliably catch any errors and respond to the caller with
    results or errors. To understand this better, let''s rewrite the pyramid of doom
    example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要可靠地捕获任何错误，并用结果或错误回应调用者。为了更好地理解这一点，让我们重新编写一下“末日金字塔”示例：
- en: '[PRE3]js\1'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]js\1'
- en: The goal here is to avoid blocking the event loop with a long operation. Deferring
    the processing of results or errors using callback functions is an excellent solution
    and is the founding idiom of Node.js. The implementation of callback functions
    led to this pyramid-shaped problem. Promises help flatten the code so that it
    is no longer in a pyramid shape. They also capture errors, ensuring delivery to
    a useful location. In both cases, errors and results are buried inside an anonymous
    function and are not delivered to the next line of code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是避免使用长时间操作阻塞事件循环。使用回调函数推迟处理结果或错误是一个很好的解决方案，也是Node.js的基本习惯用法。回调函数的实现导致了这个金字塔形的问题。Promise帮助扁平化代码，使其不再呈现金字塔形状。它们还捕获错误，确保将其传递到有用的位置。在这两种情况下，错误和结果都被埋在一个匿名函数中，并没有传递到下一行代码。
- en: Generators and the iteration protocol are an intermediary architectural step
    that, when combined with Promises, lead to the async function. We won't use either
    of these in this book, but they are worth learning about.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器和迭代协议是一个中间的架构步骤，当与Promise结合时，会导致异步函数。我们在本书中不会使用这两者，但值得了解。
- en: For the documentation for the iteration protocol, refer to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有关迭代协议的文档，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)。
- en: For the documentation for the generator functions, refer to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有关生成器函数的文档，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator)。
- en: 'We''ve already used async functions and learned about how they let us write
    clean-looking asynchronous code. For example, the `db.query` example as an async
    function looks as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了异步函数，并了解了它们如何让我们编写看起来整洁的异步代码。例如，`db.query`作为异步函数的示例如下：
- en: '[PRE4]js\1'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]js\1'
- en: Other than `try/catch`, this example is very clean compared to its earlier forms,
    both as a callback pyramid and as a Promise chain. All the boilerplate code is
    erased, and the intent of the programmer shines through clearly. Nothing is lost
    inside a callback function. Instead, everything lands on the next line of code
    where it is convenient.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`try/catch`，这个例子与之前的形式相比非常干净，无论是作为回调金字塔还是Promise链。所有样板代码都被抹去，程序员的意图清晰地展现出来。没有东西丢失在回调函数中。相反，一切都方便地落在下一行代码中。
- en: The `await` keyword looks for a Promise. Therefore, `doSomething` and the other
    functions are expected to return a Promise, and `await` manages its resolution.
    Each of these functions could be an async function, and thereby automatically
    returns a Promise, or it could explicitly create a Promise to manage an asynchronous
    function call. A generator function is also involved, but we don't need to know
    how that works. We just need to know that `await` manages the asynchronous execution
    and the resolution of the Promise.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`关键字寻找一个Promise。因此，`doSomething`和其他函数都应该返回一个Promise，而`await`管理其解析。这些函数中的每一个都可以是一个异步函数，因此自动返回一个Promise，或者可以显式创建一个Promise来管理异步函数调用。生成器函数也涉及其中，但我们不需要知道它是如何工作的。我们只需要知道`await`管理异步执行和Promise的解析。'
- en: More importantly, each statement with an `await` keyword executes asynchronously.
    That's a side effect of `await`—managing asynchronous execution to ensure the
    asynchronous result or error is delivered correctly. However, Express cannot catch
    an asynchronous error and requires us to notify it of asynchronous results using
    `next()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，带有`await`关键字的每个语句都是异步执行的。这是`await`的一个副作用——管理异步执行以确保异步结果或错误被正确传递。然而，Express无法捕获异步错误，需要我们使用`next()`通知它异步结果。
- en: The `try/catch` structure is needed for integration with Express. For the reasons
    just given, we must explicitly catch asynchronously delivered errors and notify
    Express with `next(err)`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`try/catch`结构是为了与Express集成而需要的。基于刚才给出的原因，我们必须显式捕获异步传递的错误，并使用`next(err)`通知Express。'
- en: In this section, we discussed three methods for notifying Express about asynchronously
    delivered errors. The next thing to discuss is some architectural choices to structure
    the code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了三种通知Express有关异步传递错误的方法。接下来要讨论的是一些架构选择，以便结构化代码。
- en: Architecting an Express application in the MVC paradigm
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MVC范式中架构Express应用程序
- en: Express doesn't enforce an opinion on how you should structure the **Model,**** View,
    and Controller** (**MVC**) modules of your application, or whether you should
    follow any kind of MVC paradigm at all. The MVC pattern is widely used and involves
    three main architectural pieces. The **controller** accepts inputs or requests
    from the user, converting that into commands sent to the model. The **model**
    contains the data, logic, and rules by which the application operates. The **view**
    is used to present results to the user.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Express不会强制规定你应该如何构建应用程序的**模型**、**视图**和**控制器**（**MVC**）模块的结构，或者是否应该完全遵循任何MVC范式。MVC模式被广泛使用，涉及三个主要的架构组件。**控制器**接受用户的输入或请求，将其转换为发送给模型的命令。**模型**包含应用程序操作的数据、逻辑和规则。**视图**用于向用户呈现结果。
- en: 'As we learned in the previous chapter, the blank application created by the
    Express generator provides two aspects of the MVC model:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，Express生成器创建的空应用程序提供了MVC模型的两个方面：
- en: The `views` directory contains template files, controlling the display portion,
    corresponding to the view.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`目录包含模板文件，控制显示部分，对应于视图。'
- en: The `routes` directory contains code implementing the URLs recognized by the
    application and coordinates the data manipulation required to generate the response
    to each URL. This corresponds to the controller.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`目录包含实现应用程序识别的URL并协调生成每个URL响应所需的数据操作的代码。这对应于控制器。'
- en: Since the router functions also call the function to generate the result using
    a template, we cannot strictly say that the router functions are the controller
    and that the `views` templates are the view. However, it's close enough to the
    MVC model for it to be a useful analogy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由器函数还调用函数来使用模板生成结果，我们不能严格地说路由器函数是控制器，`views`模板是视图。然而，这足够接近MVC模型，使其成为一个有用的类比。
- en: This leaves us with a question of where to put the model code. Since the same
    data manipulation can be used by multiple router functions, clearly the router
    functions should use a standalone module (or modules) containing the model code.
    This will also ensure a clean separation of concerns—for example, to ease the
    unit testing of each.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们面临一个问题，那就是在哪里放置模型代码。由于相同的数据操作可以被多个路由器函数使用，显然路由器函数应该使用一个独立的模块（或模块）来包含模型代码。这也将确保关注点的清晰分离，例如，以便轻松进行每个单元的测试。
- en: The approach we'll use is to create a `models` directory as a sibling of the
    `views` and `routes` directories. The `models` directory will hold modules to
    handle data storage and other code that we might call **business logic**. The
    API of the modules in the `models` directory will provide functions to create,
    read, update, or delete data items—a **C****reate,** **R****ead,** **Update, and D****elete**/**Destroy **(**CRUD**)
    model—and other functions necessary for the view code to do its thing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的方法是创建一个`models`目录，作为`views`和`routes`目录的同级目录。`models`目录将包含处理数据存储和其他我们可能称之为**业务逻辑**的代码的模块。`models`目录中模块的API将提供创建、读取、更新或删除数据项的函数——一个**C****reate,** **R****ead,** **Update,
    and D****elete**/**Destroy **(**CRUD**)模型——以及视图代码执行其任务所需的其他函数。
- en: The CRUD model includes the four basic operations of persistent data storage.
    The `Notes` application is structured as a CRUD application to demonstrate the
    implementation each of these operations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD模型包括持久数据存储的四个基本操作。`Notes`应用程序被构建为一个CRUD应用程序，以演示实现这些操作的过程。
- en: We'll use functions named `create`, `read`, `update`, and `destroy` to implement
    each of the basic operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`create`、`read`、`update`和`destroy`函数来实现每个基本操作。
- en: We're using the `destroy` verb, rather than `delete`, because `delete` is a
    reserved word in JavaScript.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`destroy`动词，而不是`delete`，因为`delete`是JavaScript中的保留字。
- en: With that architectural decision in mind, let's proceed with creating the `Notes`
    application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个架构决定，让我们继续创建`Notes`应用程序。
- en: Creating the Notes application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Notes应用程序
- en: 'Since we''re starting a new application, we can use the Express generator to
    give us a starting point. It is not absolutely necessary to use this tool since
    we can definitely write the code ourselves. The advantage, however, is that it
    gives us a fully fleshed out starting point:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在启动一个新的应用程序，我们可以使用Express生成器给我们一个起点。虽然不一定要使用这个工具，因为我们完全可以自己编写代码。然而，优点在于它给了我们一个完全成熟的起点：
- en: '[PRE5]js\1'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]js\1'
- en: The supplied script uses `bin/www`, but shortly, we'll restructure the generated
    code to put everything into a single ES6 script named `app.mjs`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的脚本使用`bin/www`，但很快，我们将重新构造生成的代码，将所有内容放入一个名为`app.mjs`的单个ES6脚本中。
- en: 'Then, install `cross-env`, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，安装`cross-env`，如下所示：
- en: '[PRE6]js\1'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]js\1'
- en: We'll finish this up later, but what we've done is restructured the code we
    were given. We can import the Express package, and then export the `router` object.
    Adding router functions is, of course, the done in the same way, whether it is
    a CommonJS or an ES6 module. We made the router callback an async function because
    it will be using async code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会完成这个，但我们所做的是重新构造我们得到的代码。我们可以导入Express包，然后导出`router`对象。添加路由函数当然是以相同的方式进行的，无论是CommonJS还是ES6模块。我们将路由回调设置为异步函数，因为它将使用异步代码。
- en: We'll need to follow the same pattern for any other router modules we create.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遵循相同的模式来创建任何其他路由模块。
- en: Having converted this to an ES6 module, the next step is to merge code from `bin/www` and `app.js` into
    an ES6 module named `app.mjs`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为ES6模块后，下一步是将`bin/www`和`app.js`的代码合并到一个名为`app.mjs`的ES6模块中。
- en: Creating the Notes application wiring – app.mjs
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Notes应用程序连接 - app.mjs
- en: Since the `express-generator` tool gives us a slightly messy application structure
    that does not use ES6 modules, let's reformulate the code it gave us appropriately.
    The first, `app.mjs`, contains the *wiring* of the application, meaning it configures
    the objects and functions from which the application is built while not containing
    any functions of its own. The other code, `appsupport.mjs`, contains the callback
    functions that appeared in the generated `app.js` and `bin/www` modules.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`express-generator`工具给了我们一个略显混乱的应用程序结构，没有使用ES6模块，让我们适当地重新构思它给我们的代码。首先，`app.mjs`包含了应用程序的“连接”，意味着它配置了构成应用程序的对象和函数，而不包含任何自己的函数。另一个代码`appsupport.mjs`包含了在生成的`app.js`和`bin/www`模块中出现的回调函数。
- en: 'In `app.mjs`, start with this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.mjs`中，从这里开始：
- en: '[PRE7]js\1'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]js\1'
- en: In the `dirname-fixed.mjs` example in [Chapter 3](516a5cd0-bdae-4e8c-bb0a-d508f85d483a.xhtml), *Exploring
    Node.js Modules*, we imported specific functions from the `path` and `url` core
    modules. We have used that code and then exported the value for `__dirname` as
    `approotdir`. Other parts of the `Notes` application simply need the pathname
    of the root directory of the application in order to calculate the required pathnames.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](516a5cd0-bdae-4e8c-bb0a-d508f85d483a.xhtml)的`dirname-fixed.mjs`示例中，我们从`path`和`url`核心模块中导入了特定的函数。我们使用了那段代码，然后将`__dirname`的值导出为`approotdir`。Notes应用程序的其他部分只需要应用程序的根目录的路径名，以便计算所需的路径名。
- en: Return your attention to `app.mjs` and you'll see that the router modules are
    imported as `indexRouter` and `notesRouter`. For the moment, `notesRouter` is
    commented out, but we'll get to that in a later section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`app.mjs`，你会看到路由模块被导入为`indexRouter`和`notesRouter`。目前，`notesRouter`被注释掉了，但我们将在后面的部分中处理它。
- en: 'Now, let''s initialize the `express` application object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们初始化`express`应用程序对象：
- en: '[PRE8]js\1'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]js\1'
- en: This section of code wraps the Express application in an HTTP server and gets
    it listening to HTTP requests. The `server` object is also exported in case other
    code wants to access it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将Express应用程序包装在HTTP服务器中，并让它监听HTTP请求。`server`对象也被导出，以便其他代码可以访问它。
- en: Compare `app.mjs` with the generated `app.js` and `bin/www` code and you will
    see that we've covered everything in those two modules except for the inline functions.
    These inline functions could be written at the end of `app.mjs`, but we've elected
    instead to create a second module to hold them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将`app.mjs`与生成的`app.js`和`bin/www`代码进行比较，你会发现我们已经覆盖了这两个模块中的所有内容，除了内联函数。这些内联函数可以写在`app.mjs`的末尾，但我们选择创建第二个模块来保存它们。
- en: 'Create `appsupport.mjs` to hold the inline functions, starting with the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`appsupport.mjs`来保存内联函数，从以下开始：
- en: '[PRE9]js\1'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]js\1'
- en: 'The preceding code handles errors from the HTTP server object. Some of these
    errors will simply cause the server to exit:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码处理了来自HTTP服务器对象的错误。其中一些错误将简单地导致服务器退出：
- en: '[PRE10]js\1'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: These were previously inline functions implementing error handling for the Express
    application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些以前是实现Express应用程序的错误处理的内联函数。
- en: The result of these changes is that `app.mjs` is now clean of distracting code,
    and it instead focuses on connecting together the different parts that make up
    the application. Since Express is not opinionated, it does not care that we restructured
    the code like this. We can structure the code in any way that makes sense to us
    and that correctly calls the Express API.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改的结果是`app.mjs`现在没有分散注意力的代码，而是专注于连接构成应用程序的不同部分。由于Express没有固定的意见，它并不在乎我们像这样重构代码。我们可以以任何对我们有意义并且正确调用Express
    API的方式来构建代码结构。
- en: Since this application is about storing data, let's next talk about the data
    storage modules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个应用程序是关于存储数据的，让我们接下来谈谈数据存储模块。
- en: Implementing the Notes data storage model
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Notes数据存储模型
- en: Remember that we decided earlier to put data model and data storage code into
    a directory named `models` to go along with the `views` and `routes` directories.
    Together, these three directories will separately store the three sides of the
    MVC paradigm.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们之前决定将数据模型和数据存储代码放入一个名为`models`的目录中，以配合`views`和`routes`目录。这三个目录将分别存储MVC范例的三个方面。
- en: The idea is to centralize the implementation details of storing data. The data
    storage modules will present an API for storing and manipulating application data,
    and over the course of this book, we'll make several implementations of this API.
    To switch between one storage engine to another, we will just require a configuration
    change. The rest of the application will use the same API methods, regardless
    of the storage engine being used.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是集中存储数据的实现细节。数据存储模块将提供一个API来存储和操作应用程序数据，在本书的过程中，我们将对这个API进行多次实现。要在不同的存储引擎之间切换，只需要进行配置更改。应用程序的其余部分将使用相同的API方法，无论使用的是哪种存储引擎。
- en: 'To start, let''s define a pair of classes to describe the data model. Create
    a file named `models/Notes.mjs` with the following code in it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一对类来描述数据模型。在`models/Notes.mjs`中创建一个名为`models/Notes.mjs`的文件，并在其中包含以下代码：
- en: '[PRE11]js\1'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: Creating a `Symbol` instance is done with `Symbol('symbol-name')`. The resulting
    `Symbol` instance is a unique identifier, and even if you call `Symbol('symbol-name')`
    again, the uniqueness is preserved. Each `Symbol` instance is unique from all
    other `Symbol` instances, even ones that are formed from the same string. In this
    example, the `b` and `b1` variables were both formed by calling `Symbol('b')`,
    but they are not equivalent.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Symbol`实例是通过`Symbol('symbol-name')`完成的。生成的`Symbol`实例是一个唯一标识符，即使再次调用`Symbol('symbol-name')`，唯一性也得到保留。每个`Symbol`实例都是唯一的，即使是由相同的字符串形成的。在这个例子中，`b`和`b1`变量都是通过调用`Symbol('b')`形成的，但它们并不相等。
- en: 'Let''s see how we can use a `Symbol` instance to attach fields to an object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`Symbol`实例来附加字段到一个对象上：
- en: '[PRE12]js\1'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: With the `Note` class defined, we can create a `Note` instance, and then dump
    it and see the resulting fields. The keys to these fields are indeed `Symbol`
    instances. These `Symbol` instances are hidden inside the module. The fields themselves
    are visible to code outside the module. As we can see here, an attempt to subvert
    the instance with `note[Symbol('key')] = 'new key'` does not overwrite the field
    but instead adds a second field.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`Note`类之后，我们可以创建一个`Note`实例，然后转储它并查看结果字段。这些字段的键确实是`Symbol`实例。这些`Symbol`实例被隐藏在模块内部。这些字段本身对模块外部的代码是可见的。正如我们在这里看到的，企图用`note[Symbol('key')]
    = 'new key'`来破坏实例并不会覆盖字段，而是会添加第二个字段。
- en: With our data types defined, let's start implementing the application, beginning
    with a simple in-memory datastore.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的数据类型，让我们从一个简单的内存数据存储开始实现应用程序。
- en: Implementing an in-memory Notes datastore
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现内存中的笔记数据存储
- en: Eventually, we will create a `Notes` data storage module that persists the notes
    to long-term storage. But to get us started, let's implement an in-memory datastore
    so that we can get on with implementing the application. Because we designed an
    abstract base class, we can easily create new implementations of that class for
    various storage services.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将创建一个`Notes`数据存储模块，将笔记持久化到长期存储中。但是为了让我们开始，让我们实现一个内存数据存储，这样我们就可以继续实现应用程序。因为我们设计了一个抽象基类，我们可以很容易地为各种存储服务创建新的实现。
- en: 'Create a file named `notes-memory.mjs` in the `models` directory with the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models`目录中创建一个名为`notes-memory.mjs`的文件，其中包含以下代码：
- en: '[PRE13]js\1'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: This creates an instance of the class and exports it as `NotesStore`. This will
    work so long as we have a single `NotesStore` instance, but in [Chapter 7](ae8529e5-3a08-45cc-89e9-82895eb45641.xhtml), *Data
    Storage and Retrieval*, we will change this around to support dynamically selecting
    a `NotesStore` instance.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个类的实例并将其导出为`NotesStore`。只要我们有一个单一的`NotesStore`实例，这将起作用，但是在[第7章](ae8529e5-3a08-45cc-89e9-82895eb45641.xhtml)中，*数据存储和检索*，我们将改变这一点，以支持动态选择`NotesStore`实例。
- en: We're now ready to start implementing the web pages and associated code for
    the application, starting with the home page.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始实现应用程序的网页和相关代码，从主页开始。
- en: The Notes home page
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笔记主页
- en: We're going to modify the starter application to support creating, editing,
    updating, viewing, and deleting notes. Let's start by changing the home page to
    show a list of notes, and have a top navigation bar linking to an ADD Note page
    so that we can always add a new note.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改起始应用程序以支持创建、编辑、更新、查看和删除笔记。让我们从更改主页开始，显示一个笔记列表，并在顶部导航栏中添加一个链接到添加笔记页面，这样我们就可以随时添加新的笔记。
- en: 'There''s no change required in `app.mjs` because the home page is generated
    in routes controlled in this router module:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.mjs`中不需要更改，因为主页是在这个路由模块中控制的。'
- en: '[PRE14]js\1'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: We showed the outline for this earlier, and having defined the `Notes` data
    storage model, we can fill in this function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前展示了这个概要，并且已经定义了`Notes`数据存储模型，我们可以填写这个函数。
- en: This uses the `AbstractNotesStore` API that we designed earlier. The `keylist`
    method returns a list of the key values for notes currently stored by the application.
    Then, it uses the `read` method to retrieve each note and pass that list to a
    template that renders the home page. This template will render a list of the notes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了我们之前设计的`AbstractNotesStore` API。`keylist`方法返回当前应用程序存储的笔记的键值列表。然后，它使用`read`方法检索每个笔记，并将该列表传递给一个模板，该模板呈现主页。这个模板将呈现一个笔记列表。
- en: 'What''s the best way to retrieve all the notes? We could have written a simple `for` loop,
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如何检索所有的笔记？我们可以编写一个简单的`for`循环，如下所示：
- en: '[PRE15]js\1'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: This is the file generated by `express-generator`, with the addition of a `header`
    partial for the page header.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由`express-generator`生成的文件，还添加了一个用于页面标题的`header`部分。
- en: 'Remember that in the Fibonacci application, we used a *partial* to store the
    HTML snippet for the navigation. Partials are just that—HTML template snippets
    that can be reused in one or more templates. In this case, the `header` partial
    will appear on every page and serve as a common navigation bar across the application.
    Create `partials/header.hbs`, containing the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在斐波那契应用程序中，我们使用了一个*partial*来存储导航的HTML片段。部分是HTML模板片段，可以在一个或多个模板中重用。在这种情况下，`header`部分将出现在每个页面上，并作为应用程序中的通用导航栏。创建`partials/header.hbs`，包含以下内容：
- en: '[PRE16]js\1'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: This simply steps through the array of note data and formats a simple listing.
    Each item links to the `/notes/view` URL with a `key` parameter. We have yet to
    write code to handle that URL, but will obviously display the note. Another thing
    to note is that no HTML for the list is generated if `notelist` is empty.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地遍历笔记数据数组并格式化一个简单的列表。每个项目都链接到`/notes/view` URL，并带有一个`key`参数。我们还没有编写处理该URL的代码，但显然会显示笔记。另一个需要注意的是，如果`notelist`为空，将不会生成列表的HTML。
- en: There is, of course, a whole lot more that could be put into this. For example,
    it's easy to add jQuery support to every page just by adding the appropriate `script`
    tags here.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有很多东西可以放进去。例如，通过在这里添加适当的`script`标签，可以很容易地为每个页面添加jQuery支持。
- en: 'We have now written enough to run the application, so let''s view the home
    page:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经写了足够的内容来运行应用程序，让我们查看主页：
- en: '[PRE17]js\1'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]js\1'
- en: We'll end up with this in `app.mjs`. We import both routers and then add them
    to the application configuration.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终会在`app.mjs`中得到这个。我们导入两个路由，然后将它们添加到应用程序配置中。
- en: 'Create a file named `routes/notes.mjs` to hold `notesRouter`, starting with
    the following content:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`routes/notes.mjs`的文件来保存`notesRouter`，并以以下内容开始：
- en: '[PRE18]js\1'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]js\1'
- en: This template supports both creating new notes and updating existing notes.
    We'll reuse this template to support both scenarios via the `docreate` flag.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板支持创建新笔记和更新现有笔记。我们将通过`docreate`标志重用这个模板来支持这两种情况。
- en: Notice that the `note` and `notekey` objects passed to the template are empty
    in this case. The template detects this condition and ensures that the input areas
    are empty. Additionally, a flag, `docreate`, is passed in so that the form records
    whether it is being used to create or update a note. At this point, we're adding
    a new note, so no `note` objects exist. The template code is written defensively
    to not throw errors.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，传递给模板的`note`和`notekey`对象是空的。模板检测到这种情况，并确保输入区域为空。此外，还传递了一个标志`docreate`，以便表单记录它是用于创建还是更新笔记。在这一点上，我们正在添加一个新的笔记，所以没有`note`对象存在。模板代码被防御性地编写，以避免抛出错误。
- en: 'When creating HTML forms like this, you have to be careful with using whitespace
    in the elements holding the values. Consider a scenario where the `<textarea>`
    element was instead formatted like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建HTML表单时，必须小心使用包含值的元素中的空格。考虑一个情况，`<textarea>`元素被格式化如下：
- en: '[PRE19]js\1'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]js\1'
- en: Because this URL will also be used for both creating and updating notes, we
    check the `docreate` flag to call the appropriate model operation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个URL也将用于创建和更新笔记，所以我们检查`docreate`标志来调用适当的模型操作。
- en: Both `notes.create` and `notes.update` are async functions, meaning we must
    use `await`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`notes.create`和`notes.update`都是异步函数，这意味着我们必须使用`await`。'
- en: This is an HTTP `POST` handler. Because of the `bodyParser` middleware, the
    form data is added to the `req.body` object. The fields attached to `req.body`
    correspond directly to elements in the HTML form.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个HTTP `POST` 处理程序。由于`bodyParser`中间件，表单数据被添加到`req.body`对象中。附加到`req.body`的字段直接对应于HTML表单中的元素。
- en: In this, and most of the other router functions, we use the `try/catch` construct
    that we discussed earlier to ensure errors are caught and forwarded correctly
    to Express. The difference between this and the preceding `/notes/add` router
    function is whether the router uses an async callback function. In this case,
    it is an async function, whereas for `/notes/add`, it is not async. Express knows
    how to handle errors in non-async callbacks, but it does not know how to handle
    errors in async callback functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，以及大多数其他路由函数中，我们使用了我们之前讨论过的`try/catch`结构，以确保错误被捕获并正确转发给Express。这与前面的`/notes/add`路由函数的区别在于路由器是否使用异步回调函数。在这种情况下，它是一个异步函数，而对于`/notes/add`，它不是异步的。Express知道如何处理非异步回调中的错误，但不知道如何处理异步回调函数中的错误。
- en: 'Now, we can run the application again and use the Add a Note form:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次运行应用程序并使用“添加笔记”表单：
- en: '![](img/c949b296-32e0-4690-be97-a94016e40b5e.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c949b296-32e0-4690-be97-a94016e40b5e.png)'
- en: However, upon clicking on the Submit button, we get an error message. This is
    because there isn't anything (yet) to implement the `/notes/view` URL.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，点击提交按钮后，我们收到了一个错误消息。这是因为还没有任何东西来实现`/notes/view` URL。
- en: 'You can modify the URL in the `Location` box to revisit `http://localhost:3000`, and
    you''ll see something similar to the following screenshot on the home page:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以修改`Location`框中的URL以重新访问`http://localhost:3000`，然后在主页上看到类似以下截图的内容：
- en: '![](img/94936122-5cf1-4959-999d-0fc10d3766b3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94936122-5cf1-4959-999d-0fc10d3766b3.png)'
- en: The note is actually there; we just need to implement `/notes/view`. Let's get
    on with that.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记实际上已经存在；我们只需要实现`/notes/view`。让我们继续进行。
- en: Viewing notes – read
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看笔记-读取
- en: Now that we've looked at how to create notes, we need to move on to reading
    them. This means implementing controller logic and view templates for the `/notes/view`
    URL.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何创建笔记，我们需要继续阅读它们。这意味着为`/notes/view` URL实现控制器逻辑和视图模板。
- en: 'Add the following `router` function to `routes/notes.mjs`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`router`函数添加到`routes/notes.mjs`中：
- en: '[PRE20]js\1'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]js\1'
- en: This is straightforward; we are taking data out of the `note` object and displaying
    it using HTML. At the bottom are two links—one to `/notes/destroy` to delete the
    note and the other to `/notes/edit` to edit it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；我们从`note`对象中取出数据，并使用HTML显示它。底部有两个链接——一个是到`/notes/destroy`用于删除笔记，另一个是到`/notes/edit`用于编辑它。
- en: 'Neither of these corresponding codes exists at the moment, but that won''t
    stop us from going ahead and executing the application:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对应的代码目前都不存在，但这并不妨碍我们继续执行应用程序：
- en: '![](img/1f551683-feb4-41c4-86a4-c5fcdabafde8.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f551683-feb4-41c4-86a4-c5fcdabafde8.png)'
- en: As expected, with this code, the application correctly redirects to `/notes/view`,
    and we can see our handiwork. Also, as expected, clicking on either the Delete
    or Edit links will give us an error because the code hasn't yet been implemented.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，使用这段代码，应用程序会正确重定向到`/notes/view`，我们可以看到我们的成果。同样，预期之中，点击删除或编辑链接都会给我们一个错误，因为代码还没有被实现。
- en: We'll next create the code to handle the Edit link and later, one to handle
    the Delete link.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将创建处理编辑链接的代码，稍后再创建处理删除链接的代码。
- en: Editing an existing note – update
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑现有的笔记 - 更新
- en: Now that we've looked at the `create` and `read` operations, let's look at how
    to update or edit a note.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了`create`和`read`操作，让我们看看如何更新或编辑一个笔记。
- en: 'Add the following router function to `routes/notes.mjs`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/notes.mjs`中添加以下路由函数：
- en: '[PRE21]js\1'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]js\1'
- en: Destroying a note is a significant step, if only because there's no trash can
    to retrieve it from if the user makes a mistake. Therefore, we need to ask the
    user whether they're sure that they want to delete the note. In this case, we
    retrieve the note and then render the following page, displaying a question to
    ensure they definitely want to delete the note.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁一个笔记是一个重要的步骤，因为如果用户犯了错误，就没有垃圾桶可以从中恢复。因此，我们需要询问用户是否确定要删除笔记。在这种情况下，我们检索笔记，然后呈现以下页面，显示一个问题以确保他们确定要删除笔记。
- en: 'Add a `notedestroy.hbs` template to the `views` directory:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views`目录中添加一个`notedestroy.hbs`模板：
- en: '[PRE22]js\1'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]js\1'
- en: 'This calls the `notes.destroy` function in the model. If it succeeds, the browser
    is redirected to the home page. If not, an error message is shown to the user.
    Rerunning the application, we can now view it in action:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用模型中的`notes.destroy`函数。如果成功，浏览器将重定向到主页。如果不成功，会向用户显示错误消息。重新运行应用程序，我们现在可以看到它在运行中的样子：
- en: '![](img/bafe62b3-9c7a-4c38-a32a-e0ca175fad05.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bafe62b3-9c7a-4c38-a32a-e0ca175fad05.png)'
- en: Now that everything is working in the application, you can click on any button
    or link and keep all the notes you want.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序中的一切都在运行，您可以点击任何按钮或链接，并保留所有想要的笔记。
- en: We've implemented a bare-bones application for managing notes. Let's now see
    how to change the look, since in the next chapter, we'll implement a mobile-first
    UI.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了一个简单的笔记管理应用程序。现在让我们看看如何改变外观，因为在下一章中，我们将实现一个移动优先的用户界面。
- en: Theming your Express application
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的Express应用程序设置主题
- en: The Express team has done a decent job of making sure Express applications look
    okay out of the gate. Our `Notes` application won't win any design awards, but
    at least it isn't ugly. There's a lot of ways to improve it, now that the basic
    application is running. Let's take a quick look at theming an Express application.
    In Chapter 6, *Implementing the Mobile-First Paradigm*, we'll take a deeper dive
    into this, focusing on that all-important goal of addressing the mobile market.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Express团队在确保Express应用程序一开始看起来不错方面做得相当不错。我们的`Notes`应用程序不会赢得任何设计奖，但至少它不丑陋。现在基本应用程序正在运行，有很多方法可以改进它。让我们快速看看如何为Express应用程序设置主题。在第6章*实现移动优先范式*中，我们将深入探讨这一点，重点关注解决移动市场这一重要目标。
- en: 'If you''re running the `Notes` application using the recommended method, `npm
    start`, a nice log of activity is being printed in your console window. One of
    these is the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用推荐的方法`npm start`运行`Notes`应用程序，控制台窗口中将打印出一条不错的活动日志。其中之一是以下内容：
- en: '[PRE23]js\1'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]js\1'
- en: 'This file was autogenerated for us by the Express generator at the outset and
    was dropped in the `public` directory. The `public` directory is managed by the
    Express static file server, using the following line in `app.mjs`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是由Express生成器在一开始为我们自动生成的，并且被放在`public`目录中。`public`目录由Express静态文件服务器管理，使用`app.mjs`中的以下行：
- en: '[PRE24]js\1'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]js\1'
- en: 'Something that leaps out is that the application content has a lot of whitespace
    at the top and left-hand sides of the screen. The reason for this is that the `body` tags
    have the `padding: 50px` style. Changing it is a quick business.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '一个显眼的问题是应用程序内容在屏幕顶部和左侧有很多空白。原因是`body`标签有`padding: 50px`样式。更改它很快。'
- en: Since there is no caching in the Express static file server, we can simply edit
    the CSS file and reload the page, and the CSS will be reloaded as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Express静态文件服务器中没有缓存，我们可以简单地编辑CSS文件并重新加载页面，CSS也将被重新加载。
- en: 'Let''s make a couple of tweaks:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些调整：
- en: '[PRE25]js\1'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]js\1'
- en: The `server1` script runs on `PORT 3001`, while the `server2` script runs on
    `PORT 3002`. Isn't it nice to have all of this documented in one place?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`server1`脚本在`PORT 3001`上运行，而`server2`脚本在`PORT 3002`上运行。在一个地方记录所有这些是不是很好？'
- en: 'Then, in one command window, run the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在一个命令窗口中，运行以下命令：
- en: '[PRE26]js\1'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]js\1'
- en: 'This gives us two instances of the `Notes` application. Use two browser windows
    to visit `http://localhost:3001` and `http://localhost:3002`. Enter a couple of
    notes, and you might see something like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们两个`Notes`应用程序的实例。使用两个浏览器窗口访问`http://localhost:3001`和`http://localhost:3002`。输入一些笔记，你可能会看到类似这样的东西：
- en: '![](img/2c6d2829-f1c9-4df4-9131-d8163de6210a.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c6d2829-f1c9-4df4-9131-d8163de6210a.png)'
- en: After editing and adding some notes, your two browser windows could look as
    in the preceding screenshot. The two instances do not share the same data pool;
    each is instead running in its own process and memory space. You add a note to
    one and it does not show on the other screen.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑和添加一些笔记后，您的两个浏览器窗口可能看起来像前面的截图。这两个实例不共享相同的数据池；每个实例都在自己的进程和内存空间中运行。您在一个上添加一个笔记，在另一个屏幕上不会显示。
- en: Additionally, because the model code does not persist data anywhere, the notes
    are not saved. You might have written the greatest Node.js programming book of
    all time, but as soon as the application server restarts, it's gone.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于模型代码不会将数据持久化存储在任何地方，笔记也不会被保存。你可能已经写了有史以来最伟大的Node.js编程书，但一旦应用服务器重新启动，它就消失了。
- en: Typically, you run multiple instances of an application to scale performance.
    That's the old *throw more servers at it* trick. For this to work, the data, of
    course, must be shared, and each instance must access the same data source. Typically,
    this involves a database, and when it comes to user identity information, it might
    even entail armed guards.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会运行多个应用实例以提高性能。这就是老生常谈的“增加服务器”的把戏。为了使其生效，数据当然必须共享，并且每个实例必须访问相同的数据源。通常情况下，这涉及到数据库，当涉及到用户身份信息时，甚至可能需要武装警卫。
- en: All that means databases, more data models, unit testing, security implementation,
    a deployment strategy, and much more. Hold on—we'll get to all of that soon!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着数据库、更多的数据模型、单元测试、安全实施、部署策略等等。等一下——我们很快就会涉及到所有这些！
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've come a long way in this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们走了很长的路。
- en: We started by looking at the pyramid of doom and how Promise objects and async
    functions can help us tame asynchronous code. Because we're writing an Express
    application, we looked at how to use async functions in Express. We'll be using
    these techniques throughout this book.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看了一下回调地狱，以及Promise对象和async函数如何帮助我们驯服异步代码。因为我们正在编写一个Express应用，我们看了如何在Express中使用async函数。我们将在本书中始终使用这些技术。
- en: We quickly moved on to writing the foundation of a real application with Express.
    At the moment, our application keeps its data in memory, but it has the basic
    functionality of what will become a note-taking application that supports real-time
    collaborative commenting on notes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迅速转向使用Express编写真实应用的基础。目前，我们的应用程序将数据保存在内存中，但它具有成为支持实时协作评论的笔记应用的基本功能。
- en: In the next chapter, we'll dip our toes into the water of responsive, mobile-friendly
    web design. Due to the growing popularity of mobile computing devices, it's become
    necessary to address mobile devices first before desktop computer users. In order
    to reach those millions of users a day, the `Notes` application users need a good
    user experience when using their smartphones.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将初步涉足响应式、移动友好的网页设计领域。由于移动计算设备的日益普及，有必要先考虑移动设备，而不是桌面电脑用户。为了每天能够触达数百万用户，"Notes"应用用户在使用智能手机时需要良好的用户体验。
- en: In the following chapters, we'll keep growing the capabilities of the `Notes`
    application, starting with database storage models. But first, we have an important
    task in the next chapter—implementing a mobile-first UI using Bootstrap.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将继续扩展"Notes"应用的功能，首先是数据库存储模型。但首先，在下一章中，我们有一个重要的任务——使用Bootstrap实现移动优先的用户界面。
