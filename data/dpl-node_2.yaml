- en: Chapter 2. Installing and Virtualizing Node Servers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。安装和虚拟化Node服务器
- en: Recall the story from [Chapter 1](ch01.html "Chapter 1. Appreciating Node"),
    *Appreciating Node*, about how Walmart ran all of its *Black Friday* mobile traffic
    through Node, which was deployed across *the equivalent of 2 CPUs and 30 gigs
    of RAM*. This demonstrates that Node processes I/O so efficiently that even Walmart-level
    traffic on *Black Friday* can be handled with only a few servers. This means that,
    for many people, running your Node application on a single server is all you'll
    ever need to do.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下来自[第一章](ch01.html "第一章。欣赏Node")的故事，*欣赏Node*，讲述了沃尔玛如何将所有*黑色星期五*的移动流量通过Node处理，Node部署在*相当于2个CPU和30GB
    RAM*的配置上。这证明了Node处理I/O的效率非常高，即使是*黑色星期五*的沃尔玛级流量也可以仅用几个服务器来处理。这意味着，对于许多人来说，在单个服务器上运行Node应用程序就是他们需要做的全部。
- en: Nevertheless, it is often good to have several servers at your disposal, such
    as redundant servers to ensure failover recovery, a distinct database server,
    specialized media servers, one hosting a message queue, and so on. In keeping
    with the idea of separating concerns into many independent processes, Node-based
    applications are often composed of many lightweight servers spread across a data
    center, possibly even spread across several data centers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常最好有多个服务器可供使用，例如冗余服务器以确保故障恢复，一个独立的数据库服务器，专门的媒体服务器，一个托管消息队列的，等等。按照将关注点分离到许多独立进程的想法，基于Node的应用程序通常由许多轻量级服务器组成，这些服务器分布在数据中心，甚至可能分布在几个数据中心。
- en: In this chapter, we will look at the basics of setting up single Node servers
    concretely and virtually. The goal is to explore your options for *mass producing*
    servers in response to scaling needs and to see how you can connect these together.
    You will learn how to set up an HTTP/S server yourself as well as how to do tunneling
    and proxying with Node. We'll then look at a few popular cloud-hosting solutions
    and how to set up Node servers on those. We'll close with a discussion on **Docker**,
    an exciting new technology to create lightweight virtual services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将具体探讨如何设置单个Node服务器，无论是实际还是虚拟的。目标是探索在响应扩展需求时大规模生产服务器的选项，并了解如何将这些服务器连接起来。你将学习如何自己设置HTTP/S服务器，以及如何使用Node进行隧道和代理。然后，我们将探讨一些流行的云托管解决方案以及如何在那些解决方案上设置Node服务器。最后，我们将讨论**Docker**，这是一种创建轻量级虚拟服务的新兴技术。
- en: Getting a basic Node server up and running
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动基本的Node服务器
- en: HTTP is a data transfer protocol built upon a request/response model. Normally,
    a client makes a request to a server, receives a response, makes another request,
    and so on. HTTP is stateless, which simply means that each request or response
    maintains no information on previous requests or responses. Facilitating this
    sort of rapid-pattern network communication is the sort of I/O that Node is designed
    to excel at. While Node represents a much more interesting technology stack overall,
    it does help engineers in creating networked protocol servers. In this section,
    we will move through a general overview of how to set up a basic HTTP server and
    then into a few more specialized uses of the protocol.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是在请求/响应模型上构建的数据传输协议。通常，客户端向服务器发出请求，收到响应，然后再次发出请求，依此类推。HTTP是无状态的，这仅仅意味着每个请求或响应都不会保留有关先前请求或响应的信息。促进这种快速模式网络通信的是Node设计用来擅长的I/O类型。虽然Node代表了一个更有趣的整个技术栈，但它确实帮助工程师创建网络协议服务器。在本节中，我们将概述如何设置基本的HTTP服务器，然后探讨该协议的一些更专业的用途。
- en: Hello world
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello world
- en: 'An HTTP server responds to connection attempts and manages data as it arrives
    and as it is sent along. A Node server is typically created using the `createServer`
    method of the HTTP module:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器响应连接尝试，并管理到达和发送的数据。Node服务器通常使用HTTP模块的`createServer`方法创建：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The object returned by `http.createServer` is an instance of `http.Server`,
    which extends `EventEmitter` and broadcasts network events as they occur, such
    as a client connection or request. Most server implementations using Node use
    this method of instantiation. However, listening for event broadcasts by an `http.Server`
    instance can be a more useful, even natural, way to organize server/client interactions
    within a Node program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.createServer`返回的对象是`http.Server`的一个实例，它扩展了`EventEmitter`，并在事件发生时广播网络事件，例如客户端连接或请求。大多数使用Node的服务器实现都使用这种方法进行实例化。然而，通过`http.Server`实例监听事件广播可以是在Node程序中组织服务器/客户端交互的更有效、甚至更自然的方式。'
- en: 'Here, we create a basic server that simply reports when a connection is made
    and when it is terminated:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个基本的服务器，它简单地报告连接建立和终止的情况：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When building multiuser systems, especially authenticated multiuser systems,
    this point in the server-client transaction is an excellent place for client validation
    and a tracking code. Cookies can be set and read, along with other session variables.
    A client arrival event can be broadcast to other concurrent clients interacting
    within real-time applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建多用户系统，尤其是经过身份验证的多用户系统时，服务器-客户端事务的这个点是一个进行客户端验证和跟踪代码的绝佳位置。可以设置和读取cookies，以及其他会话变量。可以将客户端到达事件广播给其他在实时应用程序中交互的并发客户端。
- en: 'By adding a listener for requests, we arrive at the more common request/response
    pattern, handled as a `Readable` stream. When a client posts data, we can catch
    that data, as shown here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加请求监听器，我们达到了更常见的请求/响应模式，它被处理为一个`Readable`流。当客户端发送数据时，我们可以捕获这些数据，如下所示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Send this server some data using **curl**:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**curl**向这个服务器发送一些数据：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using connection events, we can nicely separate our connection-handling code,
    grouping it into clearly defined functional domains, which are correctly described
    as executing in response to particular events.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连接事件，我们可以很好地将我们的连接处理代码分离，将其分组到清晰定义的功能域中，这些域被正确地描述为响应特定事件而执行。
- en: 'For example, we can set timers on server connections. Here, we can terminate
    client connections that fail to send new data within a roughly 2-second window:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在服务器连接上设置定时器。在这里，我们可以在大约2秒的窗口内未能发送新数据的客户端连接上进行终止：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Making HTTP requests
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送HTTP请求
- en: HTTP servers are often called upon to perform HTTP services for clients making
    requests. Most commonly, this sort of proxying was done on behalf of web applications
    running in browsers with restrictions on cross-domain requests. Node provides
    an easy interface to make external HTTP calls.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器通常被要求为发起请求的客户端执行HTTP服务。最常见的情况是，这种代理服务是在浏览器中运行的受跨域请求限制的Web应用 behalf 上进行的。Node提供了一个简单的接口来执行外部HTTP调用。
- en: 'For example, the following code will fetch the front page of [google.com](http://google.com):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将获取[google.com](http://google.com)的首页：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we simply dump a `Readable` stream to the terminal, but this stream could
    easily be piped to a `Writable` stream, perhaps bound to a file handle. Note that
    you must always signify that you're done with a request using the `request.end`
    method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是简单地将一个`Readable`流输出到终端，但这个流可以很容易地被管道传输到一个`Writable`流，可能是一个文件句柄。请注意，您必须始终使用`request.end`方法来表示您已完成请求。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'A popular Node module to manage HTTP requests is Mikeal Rogers'' **request**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的Node模块来管理HTTP请求是Mikeal Rogers的**request**：
- en: '[https://github.com/mikeal/request](https://github.com/mikeal/request)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/mikeal/request](https://github.com/mikeal/request)'
- en: 'Because it is common to use `HTTP.request` in order to GET external pages,
    Node offers a shortcut:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通常使用`HTTP.request`来获取外部页面，Node提供了一个快捷方式：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's now look at a few more advanced implementations of HTTP servers, where
    we perform general network services for clients.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些更高级的HTTP服务器实现，在这些实现中，我们为客户端执行通用网络服务。
- en: Proxying and tunneling
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理和隧道
- en: Sometimes, it is useful to provide a means for one server to function as a proxy,
    or broker, for other servers. This would allow one server to distribute requests
    to other servers, for example. Another use would be to provide access to a secured
    server to users who are unable to connect to that server directly—this is often
    seen in countries that place restrictions on Internet access. It is also common
    to have one server answering for more than one URL using a proxy; that one server
    can forward requests to the right recipient.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，提供一个让一个服务器作为其他服务器的代理或经纪人的手段是有用的。这将允许一个服务器将请求分发到其他服务器，例如。另一个用途是提供给无法直接连接到该服务器的用户访问受保护服务器的权限——这在限制互联网访问的国家很常见。通常，一个服务器通过代理回答多个URL；那个服务器可以将请求转发给正确的接收者。
- en: 'Because Node has consistent network interfaces implemented as evented streams,
    we can build a simple HTTP proxy in just a few lines of code. For example, the
    following program will set up an HTTP server on port `8080`, which will respond
    to any request by fetching the front page of Google and piping that back to the
    client:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node具有一致的网络接口，这些接口作为事件流实现，我们可以用几行代码就构建一个简单的HTTP代理。例如，以下程序将在端口`8080`上设置一个HTTP服务器，该服务器将对任何请求做出响应，通过获取谷歌的首页并将其管道传输回客户端：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once this server receives the client socket, it is free to push content from
    any readable stream back to the client. Here, the result of the GET of [www.google.com](http://www.google.com)
    is so streamed. One can easily see how an external content server managing a caching
    layer for your application might become a proxy endpoint.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个服务器收到客户端套接字，它就可以自由地将任何可读流的内容推回到客户端。在这里，对 [www.google.com](http://www.google.com)
    的 GET 请求的结果就是这样流式传输的。人们可以很容易地看到，一个管理着应用程序缓存层的远程内容服务器可能成为一个代理端点。
- en: 'Using similar ideas, we can create a tunneling service using Node''s native
    CONNECT support:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的想法，我们可以创建一个使用 Node 的原生 CONNECT 支持的隧道服务：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ve set up a proxy server that responds to clients requesting an HTTP CONNECT
    method [`on("connect")`], which contains the request object, the network socket-binding
    client and server, and the ''head'' (the first packet) of the tunneling stream.
    When a CONNECT request is received from a client, we parse out `request.url`,
    fetch the requested host information, and open the requested network socket. By
    piping remote data to the client and client data to the remote connection, a bidirectional
    data tunnel is established. Now we need only make the CONNECT request to our proxy,
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了一个代理服务器，它会对请求 HTTP CONNECT 方法（`on("connect")`）的客户端做出响应，该方法包含请求对象、网络套接字绑定客户端和服务器以及隧道的
    'head'（第一个数据包）。当从客户端收到 CONNECT 请求时，我们解析出 `request.url`，获取请求的主机信息，并打开请求的网络套接字。通过将远程数据管道到客户端并将客户端数据管道到远程连接，建立了一个双向数据隧道。现在我们只需要向我们的代理发送
    CONNECT 请求，如下所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once a status 200 confirmation of our CONNECT request is received, we can push
    request packets down this tunnel, catching responses and dumping those to `stdout`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到我们 CONNECT 请求的状态 200 确认，我们就可以将请求数据包推送到这个隧道中，捕获响应并将这些内容输出到 `stdout`：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: HTTPS, TLS (SSL), and securing your server
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTPS、TLS（SSL）和保障你的服务器安全
- en: Web applications have grown in size, importance, and complexity. The security
    of web applications has, therefore, become an important topic. For one reason
    or another, early web applications were allowed to venture into the experimental
    world of client-side business logic, unsecured password transmission, and open
    web services while shielded by only a diaphanous curtain. This is becoming harder
    to find among users interested in the security of their information.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序在规模、重要性和复杂性方面都得到了增长。因此，Web 应用程序的安全性已经成为一个重要的话题。由于一个或多个原因，早期的 Web 应用程序被允许进入客户端业务逻辑的实验世界，未加密的密码传输和开放的网络服务，而仅仅是被一层薄薄的帘子所保护。对于关注其信息安全的用户来说，这种情况变得越来越难找到。
- en: As Node is regularly deployed as a web server, it is imperative that the community
    begins to accept responsibility for securing these servers. HTTPS is a secure
    transmission protocol—essentially, encrypted HTTP formed by layering the HTTP
    protocol on top of the SSL/TLS protocol. Let's learn how to secure our Node deployments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node 通常被部署为 Web 服务器，社区开始对这些服务器的安全性负责是至关重要的。HTTPS 是一种安全的传输协议——本质上，是在 SSL/TLS
    协议之上叠加 HTTP 协议的加密 HTTP。让我们学习如何确保我们的 Node 部署的安全性。
- en: Creating a self-signed certificate for development
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为开发创建自签名证书
- en: In order to support SSL connections, a server will need a properly signed certificate.
    While developing, it is much easier to simply create a self-signed certificate,
    allowing us to use Node's HTTPS module.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持 SSL 连接，服务器需要一个正确签名的证书。在开发过程中，简单地创建一个自签名证书会容易得多，这允许我们使用 Node 的 HTTPS 模块。
- en: 'These are the steps needed to create a certificate for development. Remember
    that this process does not create a real certificate, and the generated certificate
    is *not secure*—it simply allows us to develop within an HTTPS environment from
    a terminal:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是创建开发证书所需的步骤。请记住，这个过程不会创建真正的证书，生成的证书 **不安全**——它只是允许我们在终端中从 HTTPS 环境中进行开发：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These keys can now be used to develop HTTPS servers. The contents of these
    files need simply be passed along as options to a Node server running on the (default)
    SSL port `443`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些密钥现在可以用来开发 HTTPS 服务器。这些文件的内容只需作为选项传递给运行在（默认）SSL 端口 `443` 上的 Node 服务器：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Free **low-assurance** SSL certificates are available from [http://www.startssl.com/](http://www.startssl.com/)
    for cases where self-signed certificates are not ideal during development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在开发过程中自签名证书不是理想选择的情况，可以从 [http://www.startssl.com/](http://www.startssl.com/)
    获取免费的 **低保证** SSL 证书。
- en: Installing a real SSL certificate
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装真实 SSL 证书
- en: In order to move a secure application out of a development environment and into
    an Internet-exposed environment, a real certificate will need to be purchased.
    The prices of these certificates have been dropping year by year, and it should
    be easy to find providers of reasonably priced certificates with a high enough
    level of security. Some providers even offer free personal-use certificates.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将安全的应用程序从开发环境迁移到互联网暴露的环境，需要购买真实的证书。这些证书的价格逐年下降，应该很容易找到提供价格合理且安全级别足够的证书的供应商。一些供应商甚至提供免费的个人使用证书。
- en: 'Setting up a professional certificate simply requires changing the HTTPS options
    we introduced previously. Different providers will have different processes and
    filenames. Typically, you will need to download or, otherwise, receive a private
    `#key` file from your provider, your signed domain certificate `#crt` file, and
    a general bundle `#ca` describing certificate chains:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 设置专业证书只需更改我们之前介绍的 HTTPS 选项。不同的供应商会有不同的流程和文件名。通常，您需要从您的供应商那里下载或接收一个私有的 `#key`
    文件，您的签名域名证书 `#crt` 文件，以及一个描述证书链的通用 `#ca` 文件包：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is important to note that the `#ca` parameter must be sent as an *array*
    even if the bundle of certificates has been concatenated into one file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，即使证书包已被连接成一个文件，`#ca` 参数也必须以 *数组* 的形式发送。
- en: 'Here are the key takeaways of this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本节的关键要点：
- en: HTTP sockets are abstracted into evented streams. This is true for all network
    interfaces provided by Node. These streams can easily be connected to one another.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 套接字被抽象为事件流。这对于 Node 提供的所有网络接口都是正确的。这些流可以轻松地相互连接。
- en: Because stream activity is evented, those events can be recorded. Very precise
    logging information on the behavior of a system can be recorded either in event
    handlers or by piping streams through a `PassThrough Stream` parameter that might
    listen for and record events.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于流活动是事件驱动的，因此可以记录这些事件。可以在事件处理器中记录关于系统行为的非常精确的日志信息，或者通过将流通过一个可能监听并记录事件的 `PassThrough
    Stream` 参数进行管道传输来记录。
- en: Node excels as an I/O service. Node servers can act as dispatchers solely interested
    in brokering communication between a client and any number of remote services
    or even specialized processes running on a local OS.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 在 I/O 服务方面表现出色。Node 服务器可以作为调度器，仅关注在客户端与任何数量的远程服务或本地操作系统上运行的专用进程之间进行通信的经纪人。
- en: Now that you know how to set up an HTTP server and work with the protocol within
    Node, go ahead and experiment. Create a small application on your local machine
    that allows users to read a Twitter feed or connect to a public data API. Get
    used to authenticating remote services over the wire and interacting with them
    either through their API or by otherwise acting as a proxy for their data. Get
    used to composing network applications by integrating remote network services
    using Node as a broker.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了如何在 Node 中设置 HTTP 服务器并处理协议，那么就继续实验吧。在您的本地机器上创建一个小应用程序，允许用户读取 Twitter
    流或连接到公共数据 API。习惯通过网络验证远程服务，并通过它们的 API 或作为它们数据的代理与之交互。习惯通过使用 Node 作为经纪人，通过集成远程网络服务来构建网络应用程序。
- en: Running your own servers in production can be expensive and time consuming,
    especially if you aren't familiar with systems administration. For this reason,
    a large number of cloud-hosting companies have sprung up and many are designed
    specifically for the Node developer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行自己的服务器可能既昂贵又耗时，尤其是如果您不熟悉系统管理。因此，许多云托管公司应运而生，其中许多是为 Node 开发者专门设计的。
- en: Let's take a look at a few of them. By way of comparison, the same Node application
    will be deployed on each—an editable JSON document stored in **MongoDB** bound
    to a simple browser-based **User Interface** (**UI**). You are encouraged to try
    these services out in order, which is not necessary though.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看其中的一些。为了比较，相同的 Node 应用程序将部署在每个平台上——一个存储在 **MongoDB** 中的可编辑 JSON 文档，绑定到一个简单的基于浏览器的
    **用户界面**（**UI**）。鼓励您按顺序尝试这些服务，尽管这不是必需的。
- en: Installing applications on Heroku
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Heroku 上安装应用程序
- en: Heroku is a mature PaaS cloud-hosting solution that supports the development
    of Node applications. To get started, visit [http://www.heroku.com](http://www.heroku.com)
    and submit an e-mail address. Heroku is free to start with. After you've confirmed
    your account, you can start deploying apps right away.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是一个成熟的PaaS云托管解决方案，支持Node应用程序的开发。要开始，请访问[http://www.heroku.com](http://www.heroku.com)并提交一个电子邮件地址。Heroku开始使用是免费的。在您确认了账户后，您就可以立即开始部署应用程序了。
- en: Scaling Heroku applications involves increasing the number of *dynos* that you
    are paying for. Each **dyno** is an isolated container running your application
    and you are able to increase or decrease the number of dynos your application
    uses with ease. In this way, there aren't any hosting *packages* to buy—you simply
    scale as needed by asking for more, or fewer, dynos.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展Heroku应用程序涉及增加您支付的费用中的*dynos*数量。每个**dyno**都是一个运行您应用程序的独立容器，您可以轻松地增加或减少应用程序使用的dynos数量。这样，您不需要购买任何托管*套餐*——您只需根据需要请求更多或更少的dynos即可进行扩展。
- en: Heroku allows you to deploy applications on many platforms and languages—it
    is not Node-centric. This is something to keep in mind should you anticipate the
    need to add services to your application not written in Node.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku允许您在许多平台和语言上部署应用程序——它不是以Node为中心的。如果您预计需要将非Node编写的服务添加到您的应用程序中，请记住这一点。
- en: To control Heroku remote instances, you will use a local *utility belt* application.
    Once you've joined Heroku and confirmed your signup, log in and go to the **Apps**
    section of your dashboard. There should be instructions there on installing Heroku
    Toolbelt ([https://toolbelt.heroku.com/](https://toolbelt.heroku.com/)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制Heroku远程实例，您将使用一个本地的*工具包*应用程序。一旦您加入Heroku并确认了您的注册，登录并转到仪表板上的**应用程序**部分。那里应该有关于安装Heroku
    Toolbelt的说明（[https://toolbelt.heroku.com/](https://toolbelt.heroku.com/))。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `heroku` command-line client will be installed in `/usr/local/heroku` and
    `/usr/local/heroku/bin` will be added to your path.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`heroku`命令行客户端将被安装在`/usr/local/heroku`，并且`/usr/local/heroku/bin`将被添加到您的路径中。'
- en: Once you have Toolbelt installed, open a terminal and log in to Heroku with
    `heroku login`. Since this is your first time, you will most likely be asked to
    generate a public key. Once this key is generated and uploaded, you are secure,
    and, going forward, you can administer your Heroku deployments via Toolbelt and
    the command line.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Toolbelt，打开终端并使用`heroku login`登录Heroku。由于这是您第一次登录，您很可能会被要求生成一个公钥。一旦这个密钥生成并上传，您就安全了，并且从现在开始，您可以通过Toolbelt和命令行来管理您的Heroku部署。
- en: 'Heroku recognizes your application as a Node application if it finds a `package.json`
    file in the root directory of your application folder. Our sample app already
    contains one, so there is no need to create another. However, as Heroku is not
    an exclusive Node host, it does not automatically find the start script for our
    -- `server.js` -- application at the `start` attribute of that package file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Heroku在您的应用程序文件夹的根目录中找到一个`package.json`文件，它将识别您的应用程序为Node应用程序。我们的示例应用程序已经包含了一个，因此不需要再创建一个。然而，由于Heroku不是Node的专用主机，它不会自动在包文件的`start`属性中找到我们的--
    `server.js` --应用程序的启动脚本：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Instead, Heroku requires what is called **Procfile**. Create a `Procfile` file
    in the root directory of our sample application and insert the following text
    into it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Heroku需要所谓的**Procfile**。在我们的示例应用程序的根目录中创建一个`Procfile`文件，并将以下文本插入其中：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It's slightly different, but we can see that the effect is ultimately the same.
    Procfile declares that we want a "web" process—the process that will be spun up
    after the command `node server.js` is executed will expect to have HTTP traffic
    routed to it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它略有不同，但我们可以看出最终效果是相同的。Procfile声明我们想要一个"web"进程——在执行`node server.js`命令后启动的进程将期望有HTTP流量路由到它。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you installed Heroku Toolbelt, another application was also installed:
    **Foreman**. Foreman helps you manage Procfile-based applications. Its primary
    importance for us is that it allows you to start Heroku applications locally.
    While you can simply update the `scripts` attribute of your Node package and run
    your application directly through Node, it does save a step. Try `foreman start`
    and visit `localhost:8080`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装Heroku Toolbelt时，还会安装另一个应用程序：**Foreman**。Foreman帮助您管理基于Procfile的应用程序。对我们来说，它最重要的作用是允许您在本地启动Heroku应用程序。虽然您可以直接通过Node更新Node包的`scripts`属性并直接运行应用程序，但这确实节省了一步。尝试`foreman
    start`并访问`localhost:8080`。
- en: In the following sections, we will look at how a repository is installed and
    managed on Heroku, and how to add to our applications on MongoDB, and we'll deploy
    a JSON editing application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将探讨如何在 Heroku 上安装和管理存储库，以及如何将 MongoDB 添加到我们的应用程序中，并且我们将部署一个 JSON 编辑应用程序。
- en: Add-ons
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加组件
- en: On Heroku, databases are understood as one of many add-ons. From logging tools,
    to caching layers, to databases, Heroku offers dozens of add-ons. Since we need
    a MongoDB instance to run our application, let's install one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Heroku 上，数据库被视为许多附加组件之一。从日志工具到缓存层，再到数据库，Heroku 提供了数十种附加组件。由于我们需要一个 MongoDB
    实例来运行我们的应用程序，让我们安装一个。
- en: Note that, while a developer (sandbox) MongoDB instance from MongoLab is free,
    Heroku requires you to verify your account with a credit card. If you don't have
    a credit card, it is still possible to get a free MongoDB cloud account through
    other services and use those credentials for your Heroku application. In the end,
    we simply need a MongoDB endpoint somewhere to connect to.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然来自 MongoLab 的开发者（沙盒）MongoDB 实例是免费的，但 Heroku 需要您使用信用卡验证您的账户。如果您没有信用卡，仍然可以通过其他服务获得免费的
    MongoDB 云账户，并使用这些凭据为您的 Heroku 应用程序提供服务。最后，我们只需要一个可以连接的 MongoDB 端点。
- en: 'To add a MongoDB account, run the `heroku addons:add mongolab` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 MongoDB 账户，请运行 `heroku addons:add mongolab` 命令：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Use `heroku addons:docs mongolab` to view documentation in your browser.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `heroku addons:docs mongolab` 在浏览器中查看文档。
- en: 'You just added a configuration option to your Heroku instance. Not surprisingly,
    you can view this information via `heroku config`, which will return you something
    like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚为您的 Heroku 实例添加了一个配置选项。不出所料，您可以通过 `heroku config` 查看此信息，它将返回类似以下内容：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With our database established, let's now push our application into Heroku and
    get it running.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库建立之后，现在让我们将我们的应用程序推送到 Heroku 并使其运行。
- en: Git
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git
- en: Deploying applications on Heroku involves pushing your local version into the
    remote application repository you just provisioned. There is no `heroku deploy`
    command; what you do is push to **Git**, thus triggering post-receive hooks at
    Heroku's end. These deploy your app.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Heroku 上部署应用程序涉及将您的本地版本推送到您刚刚配置的远程应用程序仓库。没有 `heroku deploy` 命令；您所做的是推送到 **Git**，从而在
    Heroku 端触发 post-receive 钩子。这些钩子会部署您的应用程序。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're unfamiliar with Git, visit [http://git-scm.com/book/en/Getting-Started-Git-Basics](http://git-scm.com/book/en/Getting-Started-Git-Basics).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 Git，请访问 [http://git-scm.com/book/en/Getting-Started-Git-Basics](http://git-scm.com/book/en/Getting-Started-Git-Basics)。
- en: 'Let''s try it out. Within your code bundle, there exists a `json-editor` folder.
    First, enter that folder and update the MongoDB connection and authentication
    code in `server.js` so that we can use the database connection defined earlier:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。在您的代码包中，存在一个 `json-editor` 文件夹。首先，进入该文件夹，并在 `server.js` 中更新 MongoDB 连接和身份验证代码，以便我们可以使用之前定义的数据库连接：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, run the following commands in your terminal:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的终端中运行以下命令：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This initializes our application as a proper Git repository. Now, we need to
    inform Heroku of our new application and our new Git repository. Let's deploy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将初始化我们的应用程序为一个合适的 Git 仓库。现在，我们需要通知 Heroku 我们的新应用程序和新的 Git 仓库。让我们部署。
- en: 'From within the `json-editor` folder of your code bundle, use Heroku Toolbelt
    to create your first Heroku app:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码包的 `json-editor` 文件夹中，使用 Heroku Toolbelt 创建您的第一个 Heroku 应用程序：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If all goes well, you should see something like this in your terminal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该在终端中看到类似以下内容：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you visit that URL immediately, you will receive an error message. We haven''t
    pushed our repository, so there is nothing deployed, which means there is nothing
    to show. To deploy an application to Heroku, push your local Git repo:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你立即访问该 URL，你会收到一个错误消息。因为我们还没有推送我们的存储库，所以没有部署任何内容，这意味着没有可以展示的内容。要将应用程序部署到 Heroku，请推送您的本地
    Git 仓库：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should result in a lot of build output, clearly informing you of what
    is happening:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生大量的构建输出，清楚地告知您正在发生的事情：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Deploying to Heroku, therefore, naturally combines the actual container deployment
    with the application version management via Git. What is more, pushing changes
    on your Git repository to Heroku will automatically update a running application,
    allowing "hot" code refreshes. Being able to continuously deploy your application
    can be of great benefit in some circumstances, as we'll see in later chapters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将应用程序部署到 Heroku 自然地将实际的容器部署与通过 Git 进行应用程序版本管理结合起来。更重要的是，将您的 Git 仓库上的更改推送到
    Heroku 将自动更新运行中的应用程序，允许“热”代码刷新。在某些情况下，能够持续部署您的应用程序可能非常有用，正如我们将在后面的章节中看到的。
- en: Before we begin, take note that the URL of your deployed app has no port number.
    Heroku automatically assigns a port through which the web process communicates
    with your application—this is not in our control. However, it is made available
    to your Node process via `process.env.PORT`. For this reason, you will need to
    change the `}).listen(8081);` line in `server.js` to `}).listen(process.env.PORT
    || 8081);`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请注意，你部署的应用程序的URL没有端口号。Heroku会自动分配一个端口号，通过该端口号Web进程与应用程序通信——这不在我们的控制范围内。然而，它通过`process.env.PORT`提供给Node进程。因此，你需要将`server.js`中的`}).listen(8081);`行更改为`}).listen(process.env.PORT
    || 8081);`。
- en: 'We are now ready to start up our application. Remember that we are deploying
    a Procfile-based application—processes are defined as being of a certain type.
    In our case, that type is "web". We also need to assign dynos to our deployment—we
    need to requisition a process from Heroku to run our app within. The command to
    start up such an application is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以启动我们的应用程序了。记住，我们正在部署一个基于Procfile的应用程序——进程被定义为某种类型。在我们的例子中，这种类型是“web”。我们还需要为我们的部署分配dynos——我们需要从Heroku中请求一个进程来运行我们的应用程序。启动此类应用程序的命令如下：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This tells Heroku to give us one (`1`) dyno (also known as a process) of the
    *web type*. You could also ask for two, or more, depending on your needs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Heroku给我们一个（`1`）个`web`类型的dyno（也称为进程）。你也可以根据需要请求两个或更多。
- en: 'Run that command. You should see something like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行那个命令。你应该会看到以下类似的内容：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This tells us that everything is running fine and we have `1` dyno that is
    `1x` in size handling our application. You can check that your process is running
    with the `heroku ps` command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们一切运行正常，我们有一个`1`个大小为`1x`的dyno正在处理我们的应用程序。你可以使用`heroku ps`命令来检查你的进程是否正在运行：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our application is running! Visit the Heroku URL you were given earlier. You
    should see a JSON editor and our MongoDB document:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序正在运行！访问你之前收到的Heroku URL。你应该会看到一个JSON编辑器和我们的MongoDB文档：
- en: '![Git](img/1403OS_02_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Git](img/1403OS_02_04.jpg)'
- en: 'This is a JSON editor reading the MongoDB document created on our server. It
    doesn''t do much other than letting you change the value of the `for` attribute.
    If you look at the JavaScript code in `index.html`, you''ll see that we''ve structured
    our client to send updates to the server via an `/update` path whenever values
    are changed in this document:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JSON编辑器，正在读取我们服务器上创建的MongoDB文档。它除了让你更改`for`属性的值之外，没有做太多。如果你查看`index.html`中的JavaScript代码，你会看到我们已经将客户端结构化为在文档中的值更改时通过`/update`路径向服务器发送更新：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Try it out. Use the editor to change `Deploying NodeJS` to something else.
    If you open your browser''s console, you should see **POST RESPONSE: OK** on each
    change you make to this value. After you''ve made a change, reload your browser.
    You''ll see the new value—the changes you''ve made are being persisted on MongoDB
    via our Heroku instance.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。使用编辑器将`Deploying NodeJS`更改为其他内容。如果你打开浏览器控制台，你应该会在更改此值时看到**POST响应：OK**。在做出更改后，重新加载浏览器。你会看到新值——你做出的更改正在通过我们的Heroku实例持久化到MongoDB。
- en: Managing configuration variables
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理配置变量
- en: It is normal for certain aspects of an application to be configurable. For example,
    an application deployed for production will most likely be configured differently
    than one being built in a development environment. Also, authentication credentials
    (such as the one we are using for our MongoDB connection) will be included in
    environment variables.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序的某些方面可以进行配置是很正常的。例如，用于生产的部署的应用程序可能配置得与在开发环境中构建的应用程序不同。此外，认证凭证（例如我们用于MongoDB连接的凭证）将包含在环境变量中。
- en: 'As many configuration variables are sensitive, it is a bad idea to include
    them in an application repository or in a public file. How can variables be shared
    across multiple processes in a secure way? One solution is to pass environment
    variables when starting a Node process via the command line. If we wanted to inform
    a Node process that it should execute as a production server, for example, we
    can do something like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多配置变量是敏感的，将它们包含在应用程序仓库或公开文件中是一个坏主意。如何以安全的方式在多个进程之间共享变量？一个解决方案是在通过命令行启动Node进程时传递环境变量。如果我们想通知Node进程它应该作为一个生产服务器执行，例如，我们可以这样做：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Within that script, we can access the value via `process.env`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个脚本中，我们可以通过`process.env`访问值：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While passing configuration variables in this way works very well in terms of
    privacy, it can be tedious to do this repeatedly for every process, especially
    if there are many variables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以这种方式传递配置变量在隐私方面非常有效，但每次为每个进程重复此操作可能会很繁琐，尤其是如果有许多变量。
- en: 'Heroku provides an interface to help with managing environment variables. If
    you log in to your Heroku instance and visit the **Settings** section, you will
    see something like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku提供了一个界面来帮助管理环境变量。如果你登录到你的Heroku实例并访问**设置**部分，你会看到如下内容：
- en: '![Managing configuration variables](img/1403OS_02_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![管理配置变量](img/1403OS_02_05.jpg)'
- en: These environment variables will be passed to your application automatically
    when it is started and/or restarted. Using the **Edit** button, you can add or
    remove additional settings.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些环境变量将在应用程序启动和/或重启时自动传递给应用程序。使用**编辑**按钮，你可以添加或删除额外的设置。
- en: Managing your deployment
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理你的部署
- en: 'If your application crashes for any reason, `heroku ps` will indicate this.
    You also have access to your process logs via `heroku logs`. Just as when you
    are starting your process, stopping your process involves scaling your dynos down
    to zero:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序因任何原因崩溃，`heroku ps`将会显示这一点。你也可以通过`heroku logs`访问你的进程日志。就像当你启动你的进程一样，停止你的进程涉及到将dynos的规模缩小到零：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Heroku allows you to very precisely scale and configure your process, scale
    to many dynos, add various workers, and change the size of the dynos themselves.
    In our example, we use the basic **1x** dyno, which has the smallest memory and
    compute power, and is the cheapest. For more information, visit [https://devcenter.heroku.com/articles/dyno-size](https://devcenter.heroku.com/articles/dyno-size)
    and [https://devcenter.heroku.com/articles/process-model](https://devcenter.heroku.com/articles/process-model).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku允许你非常精确地扩展和配置你的进程，扩展到多个dynos，添加各种工作者，并改变dynos本身的大小。在我们的示例中，我们使用基本的**1x**
    dyno，它具有最小的内存和计算能力，并且是最便宜的。更多信息，请访问[https://devcenter.heroku.com/articles/dyno-size](https://devcenter.heroku.com/articles/dyno-size)和[https://devcenter.heroku.com/articles/process-model](https://devcenter.heroku.com/articles/process-model)。
- en: From time to time, you might commit a change that is incorrect or want to redeploy
    a previous release. Don't worry! Toolbelt allows you to manage your releases.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会提交一个错误的变化或想要重新部署之前的版本。不用担心！Toolbelt允许你管理你的版本。
- en: 'To list releases, use `heroku releases`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出版本，使用`heroku releases`：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can get specific information on a release:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以获取有关特定版本的详细信息：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Rolling back to the immediately previous version is accomplished with a simple
    Heroku rollback. You can also roll back to a specific release:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的Heroku回滚可以回滚到立即之前的版本。你也可以回滚到特定的版本：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Just as when pushing changes, the version rolled back to will automatically
    "go live".
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在推送更改时一样，回滚到的版本将自动“上线”。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can open your application right from the command line with `heroku open`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`heroku open`从命令行直接打开你的应用程序。
- en: Installing applications on OpenShift
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OpenShift上安装应用程序
- en: Red Hat, the enterprise Linux company, operates OpenShift, a cloud-hosting solution.
    OpenShift offers several options for how you want to deploy your apps—via a web-based
    interface, via the command line, or through an online IDE. As we've worked on
    the command line for our other deployment examples, we'll do the same with OpenShift.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 红帽公司，一家企业级Linux公司，运营着OpenShift，这是一个云托管解决方案。OpenShift提供了多种部署应用程序的选项——通过基于Web的界面、通过命令行或通过在线IDE。由于我们在其他部署示例中使用了命令行，我们将以相同的方式使用OpenShift。
- en: 'Once you''ve joined and confirmed your account, you will need to install the
    OpenShift client tools—`rhc`. For the purposes of this section, I''ll use the
    Mac OS X client. Regardless of which package you happen to choose, the command
    set remains the same:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你加入并确认了你的账户，你需要安装OpenShift客户端工具——`rhc`。为了本节的目的，我将使用Mac OS X客户端。无论你选择哪个包，命令集都是相同的：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will install the client and update it to the latest version.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装客户端并将其更新到最新版本。
- en: Once installed, you will need to set up your SSH keys and authenticate with
    the system by running an `rhc` setup. Just enter your authentication information,
    confirm the installation of keys, and confirm the upload of credentials.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你需要设置你的SSH密钥并通过运行一个`rhc`设置来与系统进行认证。只需输入你的认证信息，确认密钥的安装，并确认凭证的上传。
- en: You will then be asked to enter a namespace. This will serve as your identifier
    in the system, among other things forming the subdomain of your deployed instance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将被要求输入一个命名空间。这将在系统中作为您的标识符，其中还包括形成您部署实例的子域等。
- en: OpenShift works on the idea of **Gears** and **Cartridges**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 的工作原理是**齿轮**和**卡式件**。
- en: Gears are, roughly, containers with a certain allocation of compute units, memory,
    disk, bandwidth, and so on, with a given capacity of cartridges. Larger gears
    are more performant and (generally) can support a greater number of cartridges.
    You can think of your installation as a collection of managed runtimes (cartridges),
    fully isolated and deployed to one or more gears. As your application needs to
    grow, you will add gears and cartridges. When you add cartridges, the OpenShift
    system deploys your cartridge to the correct gear within your deployment—certain
    cartridges with access to only their own gear and others with access to all gears.
    Pricing depends on the number of gears used and, depending on the characteristic
    of those gears, the implied number of cartridge slots.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 齿轮大致上是有一定计算单元、内存、磁盘、带宽等分配的容器，具有给定的卡式件容量。更大的齿轮性能更好，并且（通常）可以支持更多的卡式件。您可以将您的安装视为一组管理的运行时（卡式件），完全隔离并部署到一个或多个齿轮中。随着您的应用程序需要增长，您将添加齿轮和卡式件。当您添加卡式件时，OpenShift
    系统将您的卡式件部署到您的部署中的正确齿轮——某些卡式件只能访问它们自己的齿轮，而其他卡式件可以访问所有齿轮。定价取决于使用的齿轮数量，以及这些齿轮的特性，隐含的卡式件插槽数量。
- en: OpenShift supports many types of development environments, open source repositories,
    web frameworks, databases, and so on—a very rich ecosystem of tools, many more
    than are available in the providers we've looked at so far. You can even develop
    your own cartridges or use community cartridges.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 支持许多类型的开发环境、开源仓库、Web 框架、数据库等等——一个非常丰富的工具生态系统，比我们迄今为止查看的提供商提供的工具要多得多。您甚至可以开发自己的卡式件或使用社区卡式件。
- en: The system makes it easy to dynamically scale your deployment in terms of gears,
    or cartridges, or both. The free tier we will use offers three small gears.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 系统使您能够动态地根据齿轮、卡式件或两者同时进行部署扩展。我们将使用的免费层提供三个小型齿轮。
- en: Installing a Node application and MongoDB
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Node 应用程序和 MongoDB
- en: 'In the OpenShift ecosystem, Node is not a special citizen (as it is with NodeJitsu)
    or one of a fixed set of process types (as with Heroku). Because of the modularity
    that this concept of gears and cartridges offers, creating a sample Node application
    with access to a MongoDB instance can be accomplished in one line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenShift 生态系统中，Node 不是一个特殊的公民（就像 NodeJitsu 一样）或一组固定的进程类型之一（就像 Heroku 一样）。由于这种齿轮和卡式件概念提供的模块化，创建一个具有访问
    MongoDB 实例的示例 Node 应用程序只需一行即可完成：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, your deployment is powerfully configured, allowing SSH access
    and HTTP access, and is ready as a Git repo—if you look inside your json-editor
    folder, a new folder, `myapp/`, has been created. Go ahead and visit your URL.
    Full instructions on how to use Git are provided as well as how to access your
    application via other means.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您的部署配置强大，允许 SSH 访问和 HTTP 访问，并且作为一个 Git 仓库已准备就绪——如果您查看您的 json-editor 文件夹，一个名为
    `myapp/` 的新文件夹已被创建。请继续访问您的 URL。同时提供了如何使用 Git 的完整说明以及如何通过其他方式访问您的应用程序。
- en: We want to now replace this sample Node app with our own `json-editor` app.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想用我们自己的 `json-editor` 应用程序替换这个示例 Node 应用程序。
- en: Deploying your app
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署您的应用
- en: 'We, of course, do not want to use the sample app provided by OpenShift. Rather
    than reconfiguring, let''s keep the `.git` remote configuration in `myapp/` and
    copy the following files and folders in our `json-editor/` folder into the `myapp`
    folder:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不希望使用 OpenShift 提供的示例应用程序。而不是重新配置，让我们保持 `myapp/` 中的 `.git` 远程配置，并将以下文件和文件夹复制到我们的
    `json-editor/` 文件夹中的 `myapp` 文件夹：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These will overwrite any similar files that OpenShift created, while preserving
    the others. Make sure you have changed the directory to myapp/ as we'll be working
    from there from now on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将覆盖 OpenShift 创建的任何类似文件，同时保留其他文件。确保您已更改目录到 myapp/，因为我们将从那里开始工作。
- en: 'As we did when installing on Heroku, we will need to consult the `process.env`
    object when starting our Node server. Open `server.js` and go to this line:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Heroku 上安装时做的那样，我们需要在启动 Node 服务器时咨询 `process.env` 对象。打开 `server.js` 并转到此行：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, change the line to the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将行更改为以下内容：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We are now ready to deploy our app. Update Git with all local files, commit
    them, and push to OpenShift:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备部署我们的应用。更新 Git 中的所有本地文件，提交它们，并推送到 OpenShift：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If all goes well, you should see the following at the tail end of the resulting
    output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该在输出结果的末尾看到以下内容：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can see how both Node and MongoDB are cartridges (not special processes or
    add-ons) and how a successful post-receive hook will automatically deploy and
    activate our app (not unlike what we saw when deploying to Heroku).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Node和MongoDB都是卡式（不是特殊进程或附加组件），以及一个成功的post-receive钩子将自动部署和激活我们的应用程序（这与我们在部署到Heroku时看到的情况类似）。
- en: 'Should anything go wrong, we have direct access to our deployment logs. To
    connect to your application (`myapp`) via SSH, use the `rhc` tool:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何问题，我们可以直接访问我们的部署日志。要通过SSH连接到您的应用程序（`myapp`），请使用`rhc`工具：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once connected, jump to your log directory using `cd $OPENSHIFT_LOG_DIR`. You
    should see two logs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后，使用`cd $OPENSHIFT_LOG_DIR`跳转到您的日志目录。您应该看到两个日志：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These are standard Linux log files and you can read or otherwise manipulate
    them, for example, by tailing them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是标准的Linux日志文件，您可以读取或以其他方式操作它们，例如，通过跟踪它们。
- en: 'You can also tail your logs via `rhc`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过`rhc`跟踪日志：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you are remotely logged in to your virtual container, you can jump to the
    root directory of your app via `cd $OPENSHIFT_REPO_DIR`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当您远程登录到您的虚拟容器时，您可以通过`cd $OPENSHIFT_REPO_DIR`跳转到应用程序的根目录。
- en: 'Controlling your application is easily done via `rhc`. Several commands are
    available via `rhc app <command>`. These are a few commonly used commands:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`rhc`轻松控制您的应用程序。`rhc`提供了几个命令，通过`rhc app <command>`可用。以下是一些常用命令：
- en: '**delete**: This deletes an application from the server'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**delete**: 这将从服务器删除应用程序'
- en: '**force-stop**: This stops all application processes'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**force-stop**: 这将停止所有应用程序进程'
- en: '**reload**: This reloads the application''s configuration'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reload**: 这将重新加载应用程序的配置'
- en: '**restart**: This restarts the application'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**restart**: 这将重新启动应用程序'
- en: '**show**: This shows information about an application'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**show**: 这显示了有关应用程序的信息'
- en: '**start**: This starts the application'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**start**: 这将启动应用程序'
- en: '**stop**: This stops the application'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stop**: 这将停止应用程序'
- en: '**tidy**: This cleans out logs and `tmp` directories and tidies up the `git`
    repo on the server'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tidy**: 这将清理日志和`tmp`目录，并整理服务器上的`git`仓库'
- en: OpenShift offers a flexible option for those who want a little more control
    over the application they are deploying—power tools for power users.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift为那些想要对其部署的应用程序有更多控制权的人提供了一个灵活的选项——为高级用户提供的强大工具。
- en: Using Docker to create lightweight virtual containers
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker创建轻量级虚拟容器
- en: 'This image from the Docker website ([http://www.docker.com/](http://www.docker.com/))
    gives information on how and why the Docker team feels their technology fits into
    the future of application development:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Docker网站的此图像（[http://www.docker.com/](http://www.docker.com/））提供了关于Docker团队认为他们的技术如何适应应用程序开发未来的信息和原因：
- en: '![Using Docker to create lightweight virtual containers](img/1403OS_02_01.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![使用Docker创建轻量级虚拟容器](img/1403OS_02_01.jpg)'
- en: The preceding image, concisely describing the generational shift in application
    architecture we are now experiencing, can just as easily be used to describe the
    how and why of Node's design.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图像简要描述了我们现在正在经历的应用程序架构的代际转变，同样可以用来描述Node的设计方式和原因。
- en: 'Docker, according to the website, *…is an open source engine that automates
    the deployment of any application as a lightweight, portable, self-sufficient
    container that will run virtually anywhere*. Once you have created a Docker image
    of your application, a running instance of that image can be spun in milliseconds.
    Yes, that''s right: a few milliseconds. Docker lets you create even hundreds of
    deployments of your application in a few seconds.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 根据网站上的描述，Docker *…是一个开源引擎，它自动化了任何应用程序的部署，作为一个轻量级、便携、自给自足的容器，几乎可以在任何地方运行*。一旦你创建了应用程序的Docker镜像，该镜像的运行实例可以在毫秒内启动。是的，就是几毫秒。Docker让你在几秒钟内创建甚至数百个应用程序部署。
- en: 'The Docker ecosystem has three main components. Here''s some information about
    the components from the documentation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Docker生态系统有三个主要组件。以下是文档中关于组件的一些信息：
- en: '**Docker containers**: Docker containers are like directories. A Docker container
    holds everything that is needed for an application to run. Each container is created
    from a Docker image. Docker containers can be run, started, stopped, moved, and
    deleted. Each container is an isolated and secure application platform. You can
    consider Docker containers to be the `run` portion of the Docker framework.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker容器**：Docker容器就像目录。一个Docker容器包含运行应用程序所需的一切。每个容器都是从一个Docker镜像创建的。Docker容器可以运行、启动、停止、移动和删除。每个容器都是一个隔离且安全的应用程序平台。你可以将Docker容器视为Docker框架的`run`部分。'
- en: '**Docker images**: The Docker image is a template, for example, an Ubuntu operating
    system with Apache and your web application installed. Docker containers are launched
    from images. Docker provides a simple way to build new images or update existing
    images. You can consider Docker images to be the `build` portion of the Docker
    framework.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker镜像**：Docker镜像是一个模板，例如，一个安装了Apache和你的Web应用的Ubuntu操作系统。Docker容器是从镜像启动的。Docker提供了一种简单的方式来构建新的镜像或更新现有的镜像。你可以将Docker镜像视为Docker框架的`build`部分。'
- en: '**Docker registries**: Docker registries hold images. These are public (or
    private) stores that you can upload or download images to and from. These images
    can be images you create yourself, or you can make use of images that others have
    previously created. Docker registries allow you to build simple and powerful development
    and deployment workflows. You can consider Docker registries to be the `share`
    portion of the Docker framework.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker仓库**：Docker仓库存储镜像。这些是公共（或私有）存储库，您可以上传或下载镜像。这些镜像可以是您自己创建的，或者您可以使用其他人之前创建的镜像。Docker仓库允许您构建简单而强大的开发和部署工作流程。你可以将Docker仓库视为Docker框架的`share`部分。'
- en: You can create images of applications to be run in any number of isolated containers,
    sharing those images with others if you'd like. The concept of composing Node
    applications out of many independent processes naturally aligns with the philosophy
    behind Docker. Docker containers are sandboxed, with their own filesystems, and
    so on, and are unable to execute instructions on their host without your knowledge.
    They can expose a port to their host OS, however, and later in this chapter, we'll
    learn how to use Node to link together many independent virtual containers into
    a larger application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建在任何数量的隔离容器中运行的应用程序镜像，如果你愿意，还可以与他人共享这些镜像。将Node应用程序组合成许多独立进程的概念与Docker背后的哲学自然吻合。Docker容器是沙箱化的，拥有自己的文件系统等，并且在没有你知识的情况下无法在其主机上执行指令。然而，它们可以向其宿主操作系统暴露一个端口。在本章的后面部分，我们将学习如何使用Node将许多独立的虚拟容器链接成一个更大的应用程序。
- en: First, some Unix
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首先，一些Unix命令
- en: Docker is a new technology, and at the time of this writing, it is not yet available
    on all flavors of Unix (although the team is working hard to make that a reality
    in the near future). I will install Docker on CentOS. The Docker website ([https://www.docker.io/](https://www.docker.io/))
    is regularly updated with information on how to install on your favorite flavor
    of Unix.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一种新技术，在撰写本文时，它尚未在所有Unix版本上可用（尽管团队正在努力在不久的将来实现这一点）。我将安装CentOS上的Docker。Docker网站([https://www.docker.io/](https://www.docker.io/))定期更新有关如何在您喜欢的Unix版本上安装的信息。
- en: 'Knowing the details of your OS is important. To find out your OS distribution
    name and version, use `cat /etc/*-release`, which should return something like
    this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的操作系统细节很重要。要找出你的操作系统名称和版本，请使用`cat /etc/*-release`，它应该返回类似以下内容：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Or you can try `cat /proc/version`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以尝试`cat /proc/version`：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When you begin to create virtual machines and bind to ports, it will be necessary
    to check the status of your network on occasion. You should definitely install
    a good process viewer, such as **HTOP** ([http://hisham.hm/htop/](http://hisham.hm/htop/)),
    as this will let you quickly scan/search through your open process list.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始创建虚拟机并绑定端口时，有时需要检查你的网络状态。你绝对应该安装一个好的进程查看器，例如**HTOP** ([http://hisham.hm/htop/](http://hisham.hm/htop/))，这样你可以快速扫描/搜索你的打开进程列表。
- en: 'To get a quick list of stats on the network connections for your box, use `netstat`,
    which will return a list somewhat like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于你的盒子网络连接的快速统计列表，请使用`netstat`，它将返回一个类似这样的列表：
- en: '![First, some Unix](img/1403OS_02_02.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![首先，一些Unix](img/1403OS_02_02.jpg)'
- en: 'You can see that port `8080` is bound to the Node process `31878`. You can
    also directly ask for the process ID associated with a port:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到端口 `8080` 绑定到了 Node 进程 `31878`。你也可以直接查询与端口关联的进程 ID：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To get more information on a process, type `ls -l /proc/31878/exe`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关进程的更多信息，请输入 `ls -l /proc/31878/exe`：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To get more information on a port user, try `lsof`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取端口使用者的更多信息，尝试使用 `lsof`：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Keeping on top of who is listening where, and to what, will serve you well as
    you move through this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟谁在听什么，这将有助于你在阅读本书的过程中。
- en: Getting started with Docker
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Docker
- en: First, you will need to install Docker. Installation instructions for all supported
    Linux distributions can be found at [http://docs.docker.io/installation/](http://docs.docker.io/installation/).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装 Docker。所有支持的 Linux 发行版的安装说明可以在 [http://docs.docker.io/installation/](http://docs.docker.io/installation/)
    找到。
- en: 'Once you have the Docker service installed, you will need to start it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Docker 服务，你需要启动它：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, stop the Docker service:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，停止 Docker 服务：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If everything is working, this command should tell you something about your
    Docker installation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，这个命令应该会告诉你有关你的 Docker 安装的一些信息：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A Docker container runs an image of your application. You can create these images
    yourself, of course, but there does exist a large ecosystem of existing images.
    Let's create our own image of a Node server running Express.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器运行着你的应用程序镜像。当然，你也可以自己创建这些镜像，但确实存在一个庞大的现有镜像生态系统。让我们创建一个运行 Express 的
    Node 服务器镜像。
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To search the Docker image repository, visit [https://index.docker.io/](https://index.docker.io/).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索 Docker 镜像仓库，请访问 [https://index.docker.io/](https://index.docker.io/)。
- en: 'First, we''ll need to build an application to run. Create a folder to put your
    application files into. Just as with all Node applications, we''ll need to create
    a `package.json` file for npm to parse:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要构建一个要运行的应用程序。创建一个文件夹来存放你的应用程序文件。就像所有的 Node 应用程序一样，我们需要创建一个 `package.json`
    文件供 npm 解析：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we need a program that will start an Express HTTP server. Create the
    following file and name it `server.js`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个程序来启动 Express HTTP 服务器。创建以下文件，并将其命名为 `server.js`：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, install and start your application:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，安装并启动你的应用程序：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can now point your browser to your host on port `8087` and see **You just
    deployed some Node!** displayed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将你的浏览器指向端口 `8087` 的主机，并看到 **You just deployed some Node!** 的显示。
- en: Now, we will look at how we can build these files into a virtual container using
    Docker.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何使用 Docker 将这些文件构建成一个虚拟容器。
- en: Creating a Dockerfile
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Dockerfile
- en: Our goal is to describe the environment this application executes within such
    that Docker can reproduce that environment in a container. Also, we want to add
    the source files of our application to run in this newly virtualized environment.
    Docker can act as a builder that follows the instructions you provide on how to
    build an image of your application.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是描述应用程序执行的环境，以便 Docker 能够在容器中重现该环境。此外，我们还想将应用程序的源文件添加到这个新虚拟化的环境中。Docker
    可以作为一个构建器，按照你提供的指令构建应用程序的镜像。
- en: To begin with, you should have a folder containing your application files. This
    is your source code repository. Within this repository, create a `./src` folder.
    We will shortly learn why this folder is created. If this folder is the one where
    your test application was built, remove the `node_modules` folder.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该有一个包含应用程序文件的文件夹。这是你的源代码仓库。在这个仓库中，创建一个 `./src` 文件夹。我们很快就会了解到为什么创建这个文件夹。如果这个文件夹是你测试应用程序构建的地方，请删除
    `node_modules` 文件夹。
- en: 'A Dockerfile is a list of instructions to build an application. You can build
    Docker images manually, of course, but it is likely that you will want to repeat
    those actions many times. A Dockerfile describes a build process. What you will
    normally declare in a Dockerfile is the Linux version that the container will
    run and any OS installations you might need to do—such as Node and npm. Additionally,
    you will indicate where the source code for your application resides: within the
    `./src` folder created earlier.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是构建应用程序的一系列指令。当然，你可以手动构建 Docker 镜像，但很可能会多次重复这些操作。Dockerfile 描述了一个构建过程。你通常会在
    Dockerfile 中声明容器将运行的 Linux 版本以及你可能需要安装的任何操作系统——例如 Node 和 npm。此外，你将指出应用程序源代码的位置：位于之前创建的
    `./src` 文件夹中。
- en: 'A Dockerfile is always built upon another Docker image. Normally, you will
    build upon an OS image. We''ll use CentOS 6.4 for this example. My Dockerfile
    starts with a comment about the version of Docker I am building on and the name
    of the image this image will be built from:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile始终基于另一个Docker镜像构建。通常，您会基于操作系统镜像构建。在这个例子中，我们将使用CentOS 6.4。我的Dockerfile以关于我构建的Docker版本和这个镜像将基于哪个镜像构建的注释开始：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We have now established an OS to run in the container. Now we will simply list
    typical Unix commands to set up a build environment. First, we''ll need Node and
    npm:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经建立了一个在容器中运行的操作系统。现在，我们将简单地列出设置构建环境的典型Unix命令。首先，我们需要Node和npm：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Great! Now our container knows how to build Node and npm. Now let''s bundle
    our application into the `./src` directory of our container using the `ADD` directive:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们的容器知道如何构建Node和npm。现在让我们使用 `ADD` 指令将我们的应用程序打包到容器中的 `./src` 目录：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that our application files are bundled into `./src`, let''s enter that
    directory and install the application package:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序文件已打包到 `./src`，让我们进入该目录并安装应用程序包：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Our app is now installed. Note that in `app.js` we are exposing an Express
    server on port `8087`. A container can''t know this, so we have to tell the container
    to set up the port redirection on the host system:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在已安装。注意，在 `app.js` 中，我们正在在端口 `8087` 上公开一个Express服务器。容器无法知道这一点，所以我们必须告诉容器在主机系统上设置端口重定向：
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, the container is told to start the Node application:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，容器被指示启动Node应用程序：
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That's it. Now, create a file named (exactly) `Dockerfile`, containing the preceding
    instructions. We can now use this Dockerfile to build a Docker image.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在，创建一个名为（确切地）`Dockerfile`的文件，包含前面的指令。我们现在可以使用这个Dockerfile来构建一个Docker镜像。
- en: Building and running a Docker image
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行Docker镜像
- en: 'The command to build a Docker image is `docker build`. Docker will look in
    the current folder for a Dockerfile and build an image based on the instructions
    contained therein. Since we will most likely reuse this image, it is a good idea
    to tag it with a special name. To give an image a name, use the `–t` directive,
    followed by the tag of your choice, followed by a path to the Dockerfile (here,
    the current directory):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像的命令是 `docker build`。Docker会在当前目录中查找Dockerfile，并根据其中包含的指令构建一个镜像。由于我们很可能会重用这个镜像，所以给它一个特殊名称是一个好主意。要给镜像命名，请使用
    `–t` 指令，后跟您选择的标签，然后是Dockerfile的路径（在这里，是当前目录）：
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When you run that command, you will see a lot of output to your terminal as
    the requested packages are downloaded and installed. This may take some time.
    Thankfully, Docker caches these installs—the next build using this Dockerfile,
    or others containing identical install instructions, will be much faster.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行该命令时，您将在终端看到大量输出，因为请求的包正在下载和安装。这可能需要一些时间。幸运的是，Docker缓存了这些安装——使用此Dockerfile或包含相同安装指令的其他Dockerfile的下一个构建将会快得多。
- en: 'If the build went well, your image can be listed, with the `docker images`
    command outputting something like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建成功，您可以使用 `docker images` 命令列出镜像，输出可能如下所示：
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To remove an image, use `docker rmi <image id>`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个镜像，请使用 `docker rmi <image id>`。
- en: 'Our application is now containerized. We can run it using the following command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在已容器化。我们可以使用以下命令运行它：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `–d` directive instructs Docker to run this image in detached mode—to run
    it in the background. The `49001:8087` segment is necessary to map the *virtual*
    port that our Express server is listening to *within the container* (`8087`) to
    an actual port on our host machine.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`–d` 指令指示Docker以分离模式运行此镜像——在后台运行。`49001:8087` 这一部分是必要的，因为它将容器内Express服务器监听的
    *虚拟* 端口（`8087`）映射到主机机器上的实际端口。'
- en: Open your browser and point it to the host machine at port `49001`. You should
    see **You just deployed some Node!** displayed. The Node application we created
    earlier is now running in a container.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的浏览器，将其指向主机机的端口 `49001`。您应该会看到 **您刚刚部署了一些Node**！显示。我们之前创建的Node应用程序现在正在容器中运行。
- en: To demonstrate the point of Docker, execute the same `run` instruction given
    earlier, but change the port mapping to something like `49002:8087`. Open a different
    browser window on your application by changing the port accordingly. You now have
    two identical copies of your application running on the same host in isolated
    containers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示Docker的作用，执行之前给出的相同 `run` 指令，但更改端口映射到类似 `49002:8087` 的值。通过更改端口，在另一个浏览器窗口中打开您的应用程序。现在，您有两个相同的应用程序副本在同一主机上以隔离的容器中运行。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More details on run directives can be found at [http://docs.docker.io/reference/run/](http://docs.docker.io/reference/run/).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于运行指令的详细信息可以在 [http://docs.docker.io/reference/run/](http://docs.docker.io/reference/run/)
    找到。
- en: To learn more about port redirection, visit [http://docs.docker.io/use/port_redirection/#port-redirection](http://docs.docker.io/use/port_redirection/#port-redirection).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于端口重定向的信息，请访问 [http://docs.docker.io/use/port_redirection/#port-redirection](http://docs.docker.io/use/port_redirection/#port-redirection)。
- en: 'You will want to be able to check for the running Docker instances. The command
    to do this is `docker ps`, which will display information similar to the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你将想要能够检查正在运行的 Docker 实例。执行此操作的命令是 `docker ps`，它将显示类似以下的信息：
- en: '![Building and running a Docker image](img/1403OS_02_03.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![构建和运行 Docker 镜像](img/1403OS_02_03.jpg)'
- en: Here we see our two running containers, including information about what they
    are running and how they are mapped. To stop a running container, use `docker
    stop <container id>`. You can use `docker start <container id>` to either restart
    a stopped container or, of course, start a new one. This implies that stopping
    a container does not destroy the container. To do that, use `docker rm <container
    id>`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们正在运行的两个容器，包括它们正在运行的信息以及它们的映射方式。要停止一个正在运行的容器，请使用 `docker stop <容器
    ID>`。你可以使用 `docker start <容器 ID>` 来重新启动一个已停止的容器，或者当然，启动一个新的容器。这意味着停止一个容器并不会销毁它。要销毁容器，请使用
    `docker rm <容器 ID>`。
- en: Tip
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For a full list of Docker commands, simply type `docker` in your terminal.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 Docker 命令的完整列表，只需在终端中输入 `docker`。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create Node servers and applications, both
    locally and *in the cloud*. Having deployed a simple document-editing application
    using Node and MongoDB across three different PaaS providers, you have an early
    sense of what is available to the Node developer who is looking to scale their
    application. You were introduced to Docker, which offers a powerful new containerization
    technology, allowing us to make many cheap clones of our applications; wherever
    there is Linux, there exists a deploy target for Docker.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在本地和 *云中* 创建 Node 服务器和应用程序。通过使用 Node 和 MongoDB 在三个不同的 PaaS 提供商上部署了一个简单的文档编辑应用程序，你对寻求扩展其应用程序的
    Node 开发者可用的资源有了初步的了解。你被介绍到了 Docker，它提供了一种强大的新容器化技术，使我们能够制作许多便宜的应用程序副本；只要有 Linux，就有
    Docker 的部署目标。
- en: In the next chapter, we will take these simple ideas about scaling farther and
    deeper by exploring in more detail how Node can be scaled both vertically and
    horizontally—across cores and across many machines.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过更详细地探讨 Node 可以如何垂直和水平扩展——跨核心和跨多台机器，将这些关于扩展的简单想法推向更远和更深。
