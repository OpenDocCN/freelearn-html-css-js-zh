- en: Organizing Your Work into Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将工作组织成模块
- en: '"Complexity must be grown from simple systems that already work."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “复杂性必须从已经工作的简单系统中增长。”
- en: – Kevin Kelly, “Out of Control”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – 凯文·凯利，“失控”
- en: Node’s straightforward module management system encourages the development of
    code bases that grow and remain maintainable. The Node developer is blessed with
    a rich ecosystem of clearly defined packages with consistent interfaces that are
    easy to combine, delivered via npm. When developing solutions, the Node developer
    will find many pieces of the functionality they need ready-made, and can rapidly
    compose those open source modules into larger, but still consistent and predictable,
    systems. Node's simple and scalable module architecture has let the Node ecosystem
    grow rapidly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node的简单模块管理系统鼓励开发可持续增长和可维护的代码库。Node开发人员有幸拥有一个丰富的生态系统，其中包含了清晰定义的具有一致接口的软件包，易于组合，并通过npm交付。在开发解决方案时，Node开发人员会发现许多他们需要的功能片段已经准备就绪，并且可以迅速将这些开源模块组合成更大的、但仍然一致和可预测的系统。Node的简单且可扩展的模块架构使得Node生态系统迅速增长。
- en: In this chapter, we will cover the details of how Node understands modules and
    module paths, how modules are defined, how to use modules in the npm package repository,
    and how to create and share new npm modules. By following some simple rules, you
    will find it easy to shape the structure of your application, and help others
    work with what you’ve created.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Node如何理解模块和模块路径的细节，如何定义模块，如何在npm软件包存储库中使用模块，以及如何创建和共享新的npm模块。通过遵循一些简单的规则，您会发现很容易塑造应用程序的结构，并帮助他人使用您创建的内容。
- en: '*Module* and *package* will be used interchangeably to describe the file or
    collection of files compiled and returned by `require()`.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块*和*软件包*将被互换使用，以描述由`require()`编译和返回的文件或文件集合。'
- en: How to load and use modules
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何加载和使用模块
- en: 'Before we begin, take a look at these three commands:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，看一下这三个命令：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To install Node, you likely navigated your favorite web browser to [https://nodejs.org/en/](https://nodejs.org/en/),
    downloaded the appropriate installer app for your operating system, and clicked
    through some OK buttons. When you did this, you also got npm. However, npm updates
    quite frequently, so even if you've updated Node recently, you may not have the
    latest version of npm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Node，您可能会在您喜欢的网络浏览器中导航到[https://nodejs.org/en/](https://nodejs.org/en/)，下载适合您操作系统的安装程序应用，并点击一些确定按钮。当您这样做时，您也会得到npm。然而，npm经常更新，所以即使您最近更新了Node，您可能没有最新版本的npm。
- en: Additionally, downloading and installing a new Node installer will update Node,
    but doesn't always update npm, so use `npm install npm@latest -g` to ensure that
    you've got the most recent version.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，下载和安装新的Node安装程序将更新Node，但并不总是更新npm，因此使用`npm install npm@latest -g`来确保您拥有最新版本。
- en: 'The Node designers believe that most modules should be developed in userland—by
    developers, for developers. As such, an effort is made to limit the growth of
    the standard library. At the time of writing this, Node’s standard module library
    contains the following short list of modules:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Node的设计者认为，大多数模块应该由开发人员在用户空间开发。因此，他们努力限制标准库的增长。在撰写本文时，Node的标准模块库包含以下简短的模块列表：
- en: '| **Network and I/O** | **Strings and Buffers** | **Utilities** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **网络和I/O** | **字符串和缓冲区** | **实用工具** |'
- en: '| TTY UDP/Datagram'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '| TTY UDP/Datagram'
- en: HTTP
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP
- en: HTTPS
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS
- en: Net
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Net
- en: DNS
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: DNS
- en: TLS/SSL
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TLS/SSL
- en: Readline
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Readline
- en: FileSystem | Path Buffer
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: FileSystem | Path Buffer
- en: Url
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Url
- en: StringDecoder
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: StringDecoder
- en: QueryString | Utilities VM
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: QueryString | Utilities VM
- en: Readline
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Readline
- en: Domain
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Domain
- en: Console
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Console
- en: Assert |
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Assert |
- en: '| **Encryption and Compression** | **Environment** | **Events and Streams**
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **加密和压缩** | **环境** | **事件和流** |'
- en: '| ZLIB Crypto'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '| ZLIB Crypto'
- en: PunyCode | Process OS
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PunyCode | Process OS
- en: Modules | Child Processes Cluster
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 | 子进程集群
- en: Events
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Events
- en: Stream |
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Stream |
- en: Modules are loaded via the global `require` statement, which accepts the module
    name or path as a single argument. As a Node developer, you are encouraged to
    augment the module ecosystem by creating new modules or new combinations of modules
    of your own, and share them with the world.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是通过全局的`require`语句加载的，它接受模块名称或路径作为单个参数。作为Node开发人员，您被鼓励通过创建新模块或自己的模块组合来增强模块生态系统，并与世界分享它们。
- en: The module system itself is implemented in the require (`module`) module.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统本身是在require（`module`）模块中实现的。
- en: The module object
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块对象
- en: 'A Node module is simply a Javascript file. Reference functions (and anything
    else) that might be useful to outside code to exports, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Node模块只是一个Javascript文件。将可能对外部代码有用的函数（以及其他任何东西）引用到exports中，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We now have a module that can be required by another file. Back in our main
    app, let''s use it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以被另一个文件所需的模块。回到我们的主应用程序，让我们使用它：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note how it was not necessary to use the `.js` suffix. We’ll discuss how Node
    resolves paths shortly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不需要使用`.js`后缀。我们将很快讨论Node如何解析路径。
- en: 'Let''s make our library a little bigger, growing it to three functions, as
    shown:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的库变得更大一点，扩展到三个函数，如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Destructuring assignment, brought to JavaScript with ES6, is a great way to
    assign many functions exported by a required module to their local variables in
    a single line.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值，随着ES6引入到JavaScript中，是一种很好的方式，可以在一行代码中将许多由所需模块导出的函数分配给它们的本地变量。
- en: Modules, exports, and module.exports
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块、导出和module.exports
- en: 'As you inspect the code of Node modules you might see that some modules export
    their functionality using `module.exports`, while others simply use `exports`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您检查Node模块的代码时，您可能会看到一些模块使用`module.exports`导出它们的功能，而其他模块则简单地使用`exports`：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Is there a difference? The short answer is no. You can for the most assign properties
    to either when building your code. Both methods given above will "do" the same
    thing -- the property 'foo' of the exported module will resolve to 'bar' in both
    cases.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有区别吗？简短的答案是否定的。在构建代码时，你可以大多数情况下将属性分配给任何一个。上面提到的两种方法都会“做”同样的事情--导出模块的属性'foo'在两种情况下都将解析为'bar'。
- en: 'The longer answer is that there is a subtle difference between them, having
    to do with how JavaScript references work. Consider how modules are wrapped in
    the first place:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 更长的答案是它们之间存在微妙的差异，与JavaScript引用工作方式有关。考虑模块首先是如何包装的：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you create a module it is wrapped using the above code. That is how the
    "globals" of __dirname and of course exports are available to the script (content)
    being imported -- they are injected into your execution scope:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模块时，它将使用上述代码进行包装。这就是如何将__dirname和当然exports的“全局变量”注入到您的执行范围中的脚本（内容）中的方式：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Recall the discussion on `vm` contexts in [Chapter 10](404d3cde-f615-4c63-b789-442e218a1263.xhtml),
    *Testing Your Application*? The `Module` constructor itself demonstrates how `exports`
    is simply an empty object literal on the `Module` object:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第10章](404d3cde-f615-4c63-b789-442e218a1263.xhtml)中关于`vm`上下文的讨论，*测试您的应用程序*？`Module`构造函数本身演示了`exports`只是`Module`对象上的一个空对象文字：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Wrapping up, we see that in the final compilation whatever `module.exports` contains
    is returned to `require`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在最终编译中，`module.exports`包含的内容将被返回给`require`：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To summarize and simplify, when you are creating a module you are essentially
    defining its exports in this context:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，当您创建一个模块时，实质上是在定义其在此上下文中的导出：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So `exports` is just a reference to `module.exports`, which is why setting
    foo on the `exports` object is the same as setting foo on `module.exports`. However,
    *if you set `exports` to something else* `module.exports` will **not** reflect
    that change:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`exports`只是对`module.exports`的引用，这就是为什么在`exports`对象上设置foo与在`module.exports`上设置foo是相同的。但是，*如果您将`exports`设置为其他内容*，`module.exports`将**不会**反映出这种变化：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we saw above it is only `module.exports` that is returned; `exports` is never
    returned. If `exports` overwrites its own reference to `module.exports` that value
    never escapes the compilation context. To be safe, just use `module.exports`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上面看到的，只有`module.exports`被返回；`exports`从未被返回。如果`exports`覆盖了对`module.exports`的引用，那么该值永远不会逃离编译上下文。为了安全起见，只需使用`module.exports`。
- en: Node’s core modules are also defined using the standard `module.exports` pattern.
    You can see an example of this by browsing the source code defining console: [https://github.com/nodejs/node/blob/master/lib/console.js](https://github.com/nodejs/node/blob/master/lib/console.js).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Node的核心模块也是使用标准的`module.exports`模式定义的。您可以通过浏览定义控制台的源代码来查看这一点：[https://github.com/nodejs/node/blob/master/lib/console.js](https://github.com/nodejs/node/blob/master/lib/console.js)。
- en: Modules and caching
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和缓存
- en: Modules, once loaded, are cached. Modules are cached based on their resolved
    filename, resolved relative to the calling module. Subsequent calls to require
    (`./myModule`) will return the same (*cached*) object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载，模块将被缓存。模块是基于其解析后的文件名缓存的，相对于调用模块进行解析。对require（`./myModule`）的后续调用将返回相同的（缓存的）对象。
- en: 'To demonstrate this, imagine that we''ve got three (poorly designed, in this
    case) modules, each of which require the other two:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，假设我们有三个（在这种情况下设计不佳的）模块，每个模块都需要另外两个模块：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Without caching, requiring any of them will cause infinite loops. However,
    because Node doesn''t rerun an already loaded (or currently being loaded) module,
    it all works:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有缓存，需要其中任何一个将导致无限循环。但是，由于Node不会重新运行已加载（或当前正在加载）的模块，所以一切正常：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note, however, that accessing the same module via a different relative path
    (such as `../../myModule`) will return a different object; think of the cache
    being keyed by relative module paths.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，通过不同的相对路径（例如`../../myModule`）访问相同的模块将返回不同的对象；可以将缓存视为由相对模块路径键入。
- en: 'A snapshot of the current cache can be fetched via `require(''module'')._cache`.
    Let''s take a look:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`require('module')._cache`获取当前缓存的快照。让我们来看一下：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The module object itself contains several useful readable properties:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模块对象本身包含几个有用的可读属性：
- en: '`module.filename`: The name of the file defining this module. You can see these
    paths in the preceding code block.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module.filename`：定义此模块的文件名。您可以在前面的代码块中看到这些路径。'
- en: '`module.loaded`: Whether the module is in the process of loading. Boolean true
    if loaded. In the preceding code, library1 has finished loading (true), while
    app is still loading (false).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module.loaded`：模块是否正在加载过程中。如果加载完成，则为布尔值true。在前面的代码中，library1已经加载完成（true），而app仍在加载中（false）。'
- en: '`module.parent`: The module that required this one, if any. You can see how
    library1 knows that app required it.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module.parent`：需要此模块的模块（如果有）。您可以看到library1是如何知道app需要它的。'
- en: '`module.children`: The modules required by this one, if any.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module.children`：此模块所需的模块（如果有）。'
- en: You can determine whether a module is being executed directly via `node module.js`
    or via `require('./module.js')` by checking `require.main === module`, which will
    return true in the former case.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查`require.main === module`来确定模块是直接执行的（通过`node module.js`）还是通过`require('./module.js')`，在前一种情况下将返回true。
- en: How Node handles module paths
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node如何处理模块路径
- en: As modular application composition is The Node Way, you will often see (and
    use) the require statement. You will have noticed that the argument passed to
    require can take many forms, such as the name of a core module or a file path.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块化应用程序组合是Node的方式，您经常会看到（并使用）require语句。您可能已经注意到，传递给require的参数可以采用许多形式，例如核心模块的名称或文件路径。
- en: 'The following pseudocode, taken from the Node documentation, is an ordered
    description of the steps taken when resolving module paths:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码摘自Node文档，按顺序描述了解析模块路径时所采取的步骤：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: File paths may be absolute or relative. Note that local relative paths will
    not be implicitly resolved and must be stated. For example, if you would like
    to require the `myModule.js` file from the current directory, it is necessary
    to at least prepend `./` to the filename; `– require('myModule.js')` will not
    work. Node will assume that you are referring to either a core module or a module
    found in the `./node_modules` folder. If neither exists, a `MODULE_NOT_FOUND`
    error will be thrown.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 文件路径可以是绝对的或相对的。请注意，本地相对路径不会被隐式解析，必须声明。例如，如果你想要从当前目录中要求`myModule.js`文件，至少需要在文件名前加上`./`；`–
    require('myModule.js')`将不起作用。Node将假定你要么引用一个核心模块，要么引用`./node_modules`文件夹中的模块。如果两者都不存在，将抛出一个`MODULE_NOT_FOUND`错误。
- en: 'As seen in the preceding pseudocode, this `node_modules` lookup ascends a directory
    tree beginning from the resolved path of the calling module or file. For example,
    if the file at `/user/home/sandro/project.js` called `require(''library.js'')`,
    Node would seek in this order:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的伪代码所示，这个`node_modules`查找会从调用模块或文件的解析路径开始向上查找目录树。例如，如果位于`/user/home/sandro/project.js`的文件调用了`require('library.js')`，Node将按照以下顺序寻找：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Organizing your files and/or modules into directories is always a good idea.
    Usefully, Node allows modules to be referenced through their containing folder
    in two ways. Given a directory, Node will first try to find a `package.json` file
    in that directory, alternatively seeking for an `index.js` file. We will discuss
    the use of `package.json` files in the next section. Here, we simply need to point
    out that if require is passed the `./myModule` directory, it will look for `./myModule/index.js`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件和/或模块组织到目录中总是一个好主意。有用的是，Node允许通过它们所在的文件夹的两种方式来引用模块。给定一个目录，Node首先会尝试在该目录中找到一个`package.json`文件，或者寻找一个`index.js`文件。我们将在下一节讨论`package.json`文件的使用。在这里，我们只需要指出，如果require传递了`./myModule`目录，它将寻找`./myModule/index.js`。
- en: If you’ve set the `NODE_PATH` environment variable, then Node will use that
    path information to do further searches if a requested module is not found via
    normal channels. For historical reasons, `$HOME/.node_modules`, `$HOME/.node_libraries`,
    and `$PREFIX/lib/node` will also be searched. `$HOME` represents a user’s home
    directory, and `$PREFIX` will normally be the location Node was installed to.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设置了`NODE_PATH`环境变量，那么Node将使用该路径信息来进行进一步搜索，如果通过正常渠道找不到请求的模块。出于历史原因，还将搜索`$HOME/.node_modules`、`$HOME/.node_libraries`和`$PREFIX/lib/node`。`$HOME`代表用户的主目录，`$PREFIX`通常是Node安装的位置。
- en: Creating a package file
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个包文件
- en: As mentioned when discussing how Node does path lookups, modules may be contained
    within a folder. If you are developing a program that will work well as a module
    for someone else to use, you should organize that module within its own folder,
    and create a `package.json` file within that folder.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在讨论Node如何进行路径查找时提到的，模块可能包含在一个文件夹中。如果你正在开发一个适合作为别人使用的模块的程序，你应该将该模块组织在它自己的文件夹中，并在该文件夹中创建一个`package.json`文件。
- en: As we’ve seen throughout the examples in this book, a `package.json` file describes
    a module, usefully documenting the module’s name, version number, dependencies,
    and so forth. It must exist if you would like to publish your package via npm.
    In this section, we will outline only a few key properties of this file, and we
    will also provide more detail on some of the obscure ones.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的示例中所看到的，`package.json`文件描述了一个模块，有用地记录了模块的名称、版本号、依赖关系等。如果你想通过npm发布你的包，它必须存在。在本节中，我们将仅概述该文件的一些关键属性，并对一些不常见的属性提供更多详细信息。
- en: 'Try `$ npm help json` to fetch detailed documentation for all available package.json
    fields, or visit: [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试`$ npm help json`以获取所有可用package.json字段的详细文档，或访问：[https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)。
- en: A `package.json` file must conform to the JSON specification. Properties and
    values must be double-quoted, for example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件必须符合JSON规范。属性和值必须用双引号引起来，例如。'
- en: Easy init
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单初始化
- en: 'You can create a package file by hand, or use the handy `$ npm init` command-line
    tool, which will ask some questions and generate a `package.json` file for you.
    Let’s run through some of these:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动创建一个包文件，或者使用方便的`$ npm init`命令行工具，它会询问一些问题并为你生成一个`package.json`文件。让我们来看看其中的一些：
- en: '**name**: (Required) This string is what will be passed to `require()` in order
    to load your module. Make it short and descriptive, using only alphanumeric characters;
    this name will be used in URLs, command-line arguments, and folder names. Try
    to avoid using `js` or `node` in the name.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：（必需）这个字符串将被传递给`require()`，以加载你的模块。让它简短和描述性，只使用字母数字字符；这个名称将被用在URL、命令行参数和文件夹名称中。尽量避免在名称中使用`js`或`node`。'
- en: '**version**: (Required) npm uses semantic versioning, where these are all valid:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：（必需）npm使用语义化版本，以下都是有效的：'
- en: '>=1.0.2 <2.1.2'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '>=1.0.2 <2.1.2'
- en: 2.1.x
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2.1.x
- en: ~1.2
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ~1.2
- en: 'For more information on version numbers, visit: [https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有关版本号的更多信息，请访问：[https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver)。
- en: '**description**: When people search `npmjs.org` for packages, this is what
    they will read. Make it short and descriptive.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：当人们在`npmjs.org`上搜索包时，他们将会读到这个。让它简短和描述性。'
- en: '**entry** **point** (main): This is the file that should set `module.exports`;
    it defines where the module object definition resides.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入口点**（主要）：这是应该设置`module.exports`的文件；它定义了模块对象定义的位置。'
- en: '**keywords**: A comma-separated list of keywords that will help others find
    your module in the registry.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键字**：一个逗号分隔的关键字列表，将帮助其他人在注册表中找到你的模块。'
- en: '**license**: Node is an open community that likes permissive licenses. *MIT*
    and *BSD* are good ones here.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**许可证**：Node是一个喜欢宽松许可证的开放社区。*MIT*和*BSD*在这里都是不错的选择。'
- en: You might also want to set the `private` field to `true` while you are developing
    your module. This ensures that npm will refuse to publish it, avoiding accidental
    releases of not-yet-good or time-sensitive code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望在开发模块时将`private`字段设置为`true`。这样可以确保npm拒绝发布它，避免意外发布尚未完善或时间敏感的代码。
- en: Adding scripts to package.json
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向package.json添加脚本
- en: 'Another advantage is that npm can also be used as a build tool. The `scripts`
    field in your package file allows you to set various build directives executed
    at some point following certain npm commands. For example, you might want to minify
    Javascript, or execute some other processes that build dependencies that your
    module will need whenever `npm install` is executed. The available directives
    are as listed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优势是npm也可以用作构建工具。包文件中的`scripts`字段允许您设置在某些npm命令后执行的各种构建指令。例如，您可能希望最小化Javascript，或执行一些其他构建依赖项的过程，每当执行`npm
    install`时，您的模块都需要。可用的指令如下：
- en: '`prepublish`, `publish`, `postpublish`: Run by the `npm publish` command as
    well as on local `npm install` without any arguments.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepublish`，`publish`，`postpublish`：通过`npm publish`命令以及在本地`npm install`命令中没有任何参数时运行。'
- en: '`prepublishOnly`: Run before published only on the `npm publish` command.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepublishOnly`：在`npm publish`命令上发布之前运行。'
- en: '`prepare`: Run before the package is published and on `npm install ` without
    any arguments. Run after `prepublish`, but before `prepublishOnly`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepare`：在包发布之前和在`npm install`命令中没有任何参数的情况下运行。在`prepublish`之后但在`prepublishOnly`之前运行。'
- en: '`prepack`: Run before a tarball is packed via `npm pack` or `npm publish`,
    and when installing git dependencies.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepack`：在通过`npm pack`或`npm publish`打包tarball之前运行，并在安装git依赖项时运行。'
- en: '`postpack`: Run after a tarball has been generated and moved to its final location.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postpack`：在tarball生成并移动到其最终位置后运行。'
- en: '`preinstall`, `install`, `postinstall`: Run by the `npm install` command.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preinstall`，`install`，`postinstall`：通过`npm install`命令运行。'
- en: '`preuninstall`, `uninstall`, `postuninstall`: Run by the `npm uninstall` command.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preuninstall`，`uninstall`，`postuninstall`：通过`npm uninstall`命令运行。'
- en: '`preversion`, `version`, `postversion`: Run by the `npm version` command.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preversion`，`version`，`postversion`：通过`npm version`命令运行。'
- en: '`preshrinkwrap`, `shrinkwrap`, `postshrinkwrap`: Run by the `npm shrinkwrap` command.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preshrinkwrap`，`shrinkwrap`，`postshrinkwrap`：通过`npm shrinkwrap`命令运行。'
- en: '`pretest`, `test`, `posttest`: Run by the `npm test` command.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pretest`，`test`，`posttest`：通过`npm test`命令运行。'
- en: '`prestop`, `stop`, `poststop`: Run by the `npm stop` command.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prestop`，`stop`，`poststop`：通过`npm stop`命令运行。'
- en: '`prestart`, `start`, `poststart`: Run by the `npm start` command.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prestart`，`start`，`poststart`：通过`npm start`命令运行。'
- en: '`prerestart`, `restart`, `postrestart`: Run by the `npm restart` command. Note
    that `npm restart` will run the `stop` and `start` scripts if no `restart` script
    is provided.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prerestart`，`restart`，`postrestart`：通过`npm restart`命令运行。请注意，如果没有提供`restart`脚本，`npm
    restart`将运行`stop`和`start`脚本。'
- en: It should be clear that pre- commands will run before, and post- commands will
    run after their primary command (such as `publish`) is executed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 应该清楚的是，pre-命令将在其主要命令（如`publish`）执行之前运行，而post-命令将在其主要命令执行之后运行。
- en: npm as a build system using custom scripts
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm作为一个使用自定义脚本的构建系统
- en: 'You aren''t limited to using only this predefined bag of default script commands.
    Extending the scripts collection in a package file with, for example, build instructions
    is a very common practice. Consider the following script definition:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅限于仅使用此预定义的默认脚本命令包。在包文件中扩展脚本集合，例如构建说明，是一种非常常见的做法。考虑以下脚本定义：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When this command is run via `npm run dev` we start a hypothetical server in
    debug mode (--inspect), and expose the garbage collector so that we can track
    its impact on our application's performance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过`npm run dev`命令运行此命令时，我们以调试模式（--inspect）启动一个假设的服务器，并公开垃圾收集器，以便我们可以跟踪其对我们应用程序性能的影响。
- en: 'This also implies that npm scripts can in many cases completely replace more
    complex build systems like **gulp** or **webpack**. For example you might want
    to use **Browserify** to bundle your application for deployment, and that build
    step is easy to describe in a script:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着npm脚本在许多情况下可以完全替代更复杂的构建系统，如**gulp**或**webpack**。例如，您可能希望使用**Browserify**来捆绑您的应用程序以进行部署，而该构建步骤很容易在脚本中描述：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After executing `npm run build:browserify` Browserify will process the file
    at src/js/index.js, running it through a transformer (-t) that can compile React
    code (**babelify**) and output (-o) the result to build/app.js.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`npm run build:browserify`后，Browserify将处理src/js/index.js文件，通过一个可以编译React代码（**babelify**）的转换器（-t）运行它，并将结果输出（-o）到build/app.js。
- en: 'Additionally, npm scripts are running on the host system in the context of
    npm, so you are able to execute system commands and address locally installed
    modules. Another build step you might implement is JavaScript minification, moving
    compiled files into a target folder:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，npm脚本在npm的主机系统上运行，因此您可以执行系统命令并访问本地安装的模块。您可能要实现的另一个构建步骤是JavaScript文件的最小化，并将编译后的文件移动到目标文件夹：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we use an OS command mkdir to create the target folder for compiled files,
    perform minification against all JavaScript files in a folder with the (locally
    installed) **uglify** module, and redirect the resulting minified script bundle
    to a single build file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用OS命令mkdir创建编译文件的目标文件夹，在一个文件夹中对所有JavaScript文件执行最小化（本地安装的）**uglify**模块，并将结果的最小化脚本捆绑重定向到一个单独的构建文件。
- en: 'Now we can add a general build command to our scripts collection, and simply
    use `npm run build` whenever we need to deploy a new build:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向我们的脚本集合添加一个通用的构建命令，并在需要部署新构建时简单地使用`npm run build`：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Any number of steps can be chained in this manner. You might add tests, run
    a file watcher, and so forth.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以这种方式链接任意数量的步骤。您可以添加测试，运行文件监视器等。
- en: For your next project consider using npm as a build system rather than complicating
    your stack with large and abstract systems that can be very hard to debug when
    they go wrong. The company **Mapbox**, for instance, uses npm scripts to manage
    a complex build/test pipeline: [https://github.com/mapbox/mapbox-gl-js/blob/master/package.json](https://github.com/mapbox/mapbox-gl-js/blob/master/package.json).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的下一个项目，考虑使用npm作为构建系统，而不是用大型和抽象的系统来复杂化您的堆栈，当它们出现问题时很难调试。例如，公司**Mapbox**使用npm脚本来管理复杂的构建/测试流水线：[https://github.com/mapbox/mapbox-gl-js/blob/master/package.json](https://github.com/mapbox/mapbox-gl-js/blob/master/package.json)。
- en: Registering package dependencies
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册包依赖项
- en: 'It is likely that a given module will itself depend on other modules. These
    dependencies are declared within a `package.json` file using four related properties:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能一个给定的模块本身会依赖于其他模块。这些依赖关系在`package.json`文件中使用四个相关属性声明：
- en: '`dependencies`: The core dependencies of your module should reside here.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`：您的模块的核心依赖应该驻留在这里。'
- en: '`devDependencies`: You may depend on some modules, while developing your module,
    that are not necessary to those who will use it. Typically, test suites are included
    here. This will save some space for those using your module.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devDependencies`：在开发模块时，您可能依赖于一些对于将来使用它的人来说并不必要的模块。通常测试套件会包含在这里。这将为使用您的模块的人节省一些空间。'
- en: '`bundledDependencies`: Node is changing rapidly, as are npm packages. You may
    want to *lock* a certain bundle of dependencies into a single bundled file and
    have those published with your package, so that they will not change via the normal
    `npm update` process.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bundledDependencies`：Node正在迅速变化，npm包也在变化。您可能希望将一定的依赖包锁定到一个单独的捆绑文件中，并将其与您的包一起发布，以便它们不会通过正常的`npm
    update`过程发生变化。'
- en: '`optionalDependencies`: Contains modules that are optional. If these modules
    cannot be found or installed, the build process will not stop (as it will with
    other dependency load failures). You can then check for this module’s existence
    in your application code.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optionalDependencies`：包含可选的模块。如果找不到或安装不了这些模块，构建过程不会停止（与其他依赖加载失败时会停止的情况不同）。然后您可以在应用程序代码中检查此模块的存在。'
- en: 'Dependencies are normally defined with a npm package name, followed by versioning
    information:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖通常使用npm包名称定义，后面跟着版本信息：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, they can also point to a tarball:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它们也可以指向一个tarball：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can point to a GitHub repository:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指向一个GitHub存储库：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'They can even point to the shortcut:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它们甚至可以指向快捷方式：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These GitHub paths are also available to `npm install`, for example, `npm install
    sandro-pasquali/herder`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些GitHub路径也可用于`npm install`，例如，`npm install sandro-pasquali/herder`。
- en: 'Additionally, in cases where only those with proper authentication are able
    to install a module, the following format can be used to source secure repositories:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在只有具有适当身份验证的人才能安装模块的情况下，可以使用以下格式来获取安全存储库：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By properly organizing your dependencies by type, and intelligently sourcing
    those dependencies, build requirements should be easy to accommodate using Node’s
    package system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按类型正确组织您的依赖项，并智能地获取这些依赖项，使用Node的包系统应该很容易满足构建需求。
- en: Publishing and managing NPM packages
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布和管理NPM包
- en: When you install Node, npm is installed natively, and it functions as the primary
    package manager for the Node community. Let’s learn how to set up an account on
    the npm repository, publish (and unpublish) modules, and work with GitHub as an
    alternative source target.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装Node时，npm会被自动安装，并且它作为Node社区的主要包管理器。让我们学习如何在npm存储库上设置帐户，发布（和取消发布）模块，并使用GitHub作为替代源目标。
- en: In order to publish to npm, you will need to create a user; `npm adduser` will
    trigger a series of prompts requesting your name, email, and password. You may
    then use this command on multiple machines to authorize the same user account.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发布到npm，您需要创建一个用户；`npm adduser`将触发一系列提示，要求您的姓名、电子邮件和密码。然后您可以在多台机器上使用此命令来授权相同的用户帐户。
- en: 'To reset your npm password, visit: [https://npmjs.org/forgot](https://npmjs.org/forgot).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要重置您的npm密码，请访问：[https://npmjs.org/forgot](https://npmjs.org/forgot)。
- en: Once you have authenticated with npm, you will be able to publish your packages
    using the `npm publish` command. The easiest path is to run this command from
    within your package folder. You may also target another folder for publishing
    (remembering that a `package.json` file must exist in that folder).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您通过npm进行了身份验证，您就可以使用`npm publish`命令发布您的包。最简单的方法是从您的包文件夹内运行此命令。您也可以将另一个文件夹作为发布目标（记住该文件夹中必须存在`package.json`文件）。
- en: You may also publish a gzipped tar archive containing a properly configured
    package folder.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以发布一个包含正确配置的包文件夹的gzipped tar归档文件。
- en: Note that if the `version` field of the current `package.json` file is lower
    or equal to that of the existing, published package, npm will complain and refuse
    to publish. You can override this using the `--force` argument with `publish`,
    but you probably want to update the version and republish.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果当前`package.json`文件的`version`字段低于或等于现有已发布包的版本，npm会抱怨并拒绝发布。您可以使用`--force`参数与`publish`来覆盖此行为，但您可能希望更新版本并重新发布。
- en: To remove a package, use `npm unpublish <name>[@<version>]`. Note that once
    a package is published, other developers may come to depend on it. For this reason,
    you are strongly discouraged from removing packages that others are using. If
    you want to discourage the use of a version, use npm deprecate `<name>[@<version>]
    <message>`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个包，请使用`npm unpublish <name>[@<version>]`。请注意，一旦一个包被发布，其他开发人员可能会依赖于它。因此，强烈建议您不要删除其他人正在使用的包。如果您想要阻止某个版本的使用，请使用npm
    deprecate `<name>[@<version>] <message>`。
- en: 'To further assist collaboration, npm allows multiple owners to be set for a
    package:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步协助协作，npm允许为一个包设置多个所有者：
- en: '`npm owner ls <package name>`: Lists the users with access to a module'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm owner ls <package name>`：列出对模块具有访问权限的用户'
- en: '`npm owner add <user> <package name>`: The added owner will have full access,
    including the ability to modify the package and add other owners'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm owner add <user> <package name>`：添加的所有者将拥有完全访问权限，包括修改包和添加其他所有者的能力'
- en: '`npm owner rm <user> <package name>`: Removes an owner and immediately revokes
    all privileges'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm owner rm <user> <package name>`：删除所有者并立即撤销所有权限'
- en: All owners have equal privileges—special access controls are unavailable, such
    as being able to give write but not delete access.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有所有者都拥有相同的权限—无法使用特殊访问控制，例如能够给予写入但不能删除的权限。
- en: Global installs and binaries
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局安装和二进制文件
- en: Some Node modules are useful as command-line programs. Rather than requiring
    something like `$ node module.js` to run a program, we might want to simply type
    `$ module` on the console and have the program execute. In other words, we might
    want to treat a module as an executable file installed on the system PATH and
    therefore is accessible from anywhere. There are two ways to achieve this using
    npm.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Node模块作为命令行程序非常有用。与其要求像`$ node module.js`这样运行程序，我们可能希望在控制台上简单地键入`$ module`并执行程序。换句话说，我们可能希望将模块视为安装在系统PATH上的可执行文件，并且因此可以从任何地方访问。使用npm可以通过两种方式实现这一点。
- en: 'The first and simplest way is to install a package using the `-g (global)`
    argument is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种最简单的方法是使用`-g（全局）`参数安装包如下：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If a package is intended as a command-line application that should be installed
    globally, it is a good idea to set the `preferGlobal` property of your `package.json`
    file to `true`. The module will still install locally, but users will be warned
    about its global intentions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个包旨在作为应该全局安装的命令行应用程序，将`package.json`文件的`preferGlobal`属性设置为`true`是一个好主意。该模块仍将在本地安装，但用户将收到有关其全局意图的警告。
- en: 'Another way to ensure global access is by setting a package’s `bin` property:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 确保全局访问的另一种方法是设置包的`bin`属性：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When this module is installed, `aModule` will be understood as a global CLI
    command. Any number of such programs may be mapped to `bin`. As a shortcut, a
    single program can be mapped, as shown:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装此模块时，`aModule`将被理解为全局CLI命令。任意数量的此类程序可以映射到`bin`。作为快捷方式，可以映射单个程序，如下所示：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, the name of the package itself (`aModule`) will be understood
    as the active command.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，包本身的名称（`aModule`）将被理解为活动命令。
- en: Other repositories
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他存储库
- en: 'Node modules are often stored in version control systems, allowing several
    developers to manage package code. For this reason, the `repository` field of
    `package.json` can be used to point developers to such a repository, should collaboration
    be desired. Consider the following example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Node模块通常存储在版本控制系统中，允许多个开发人员管理包代码。因此，`package.json`的`repository`字段可用于指向这样的存储库，如果需要合作，可以将开发人员指向这样的存储库。考虑以下示例：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Similarly, you might want to point users to where bug reports should be filed
    using the bugs field:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可能希望使用bugs字段将用户指向应该提交错误报告的位置：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Lockfiles
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定文件
- en: Ultimately, npm install is a command that takes a `package.json` and builds
    a `node_modules` folder from it. However, does it always product the same one?
    The answer is sometimes, and we will cover the details in a bit.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，npm install是一个命令，它从`package.json`构建一个`node_modules`文件夹。但是，它总是生成相同的文件夹吗？答案有时是，我们将在稍后详细介绍。
- en: If you've made a new project, or recently updated npm to version 5, you may
    have noticed a new file alongside the familiar `package.json`—`package-lock.json`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建了一个新项目，或者最近将npm更新到版本5，您可能已经注意到熟悉的`package.json`旁边有一个新文件—`package-lock.json`。
- en: 'Inside, the contents looks like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 里面的内容如下：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Parts will immediately be familiar. Here are the npm packages your project
    depends upon. Dependencies of dependencies are nested appropriately: `align-text`
    doesn''t require anything, while `babel-core` needs `source-map`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 部分内容会立即变得熟悉。这里是您的项目依赖的npm包。依赖项的依赖项会适当地嵌套：`align-text`不需要任何东西，而`babel-core`需要`source-map`。
- en: The real usefulness beyond `package.json` is delivered by the resolved and integrity
    fields. Here, you can see the exact file the npm downloaded and unzipped to create
    the corresponding folder within `npm_modules`, and, even more importantly, the
    cryptographically-secure hash digest of that file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`package.json`之外的真正有用的部分是通过解析和完整性字段提供的。在这里，您可以看到npm下载并解压缩以创建`npm_modules`中相应文件夹的确切文件，更重要的是，该文件的加密安全哈希摘要。
- en: With `package-lock.json`, you can now get an exact and `reproducable node_modules`
    folder. Committed into source control, you can see when a dependant module version
    has changed right in a diff during a code review. Also, with hashes everywhere,
    you can be more certain that the code your application depends upon hasn't been
    tampered with.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`package-lock.json`，您现在可以获得一个确切和可重现的`node_modules`文件夹。提交到源代码控制中，您可以在代码审查期间的差异中看到依赖模块版本何时发生了变化。此外，到处都是哈希值，您可以更加确信您的应用程序依赖的代码没有被篡改。
- en: '`package-lock.json` is here; it''s long, it''s filled with hash values, but
    actually, you can ignore it. The file''s appearance with npm 5 didn''t change
    the behavior of commands such as npm install and npm update that you''re used
    to. To explain how, and why, it''s helpful to expose two common questions (or
    exclamations) that developers commonly have when encountering the file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`package-lock.json`在这里；它很长，充满了哈希值，但实际上，您可以忽略它。npm 5中文件的外观并没有改变您习惯的npm install和npm
    update等命令的行为。要解释为什么有帮助，有两个开发人员在遇到该文件时通常会提出的常见问题（或感叹）：'
- en: So this means my `node_modules` folder will be made from these hashes, right?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着我的`node_modules`文件夹将由这些哈希值组成，对吗？
- en: Why does my `package-lock.json` file keep changing?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我的`package-lock.json`文件一直在变化？
- en: The answers are (1) no, and (2) that's why.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是（1）不是，（2）这就是为什么。
- en: When npm finds a newer version of a package, it'll download it and update your
    `node_modules` folder, just as earlier. With npm 5, it'll also update `package-lock.json`,
    with the new version number and the new hash.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当npm发现一个包的新版本时，它会下载并更新你的`node_modules`文件夹，就像之前一样。使用npm 5，它还会更新`package-lock.json`，包括新的版本号和新的哈希值。
- en: Also, most of the time, this is what you want it to do. If there's a newer version
    of a package the project you're developing depends upon, you probably want npm
    install to give you the most recent one.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数情况下，这就是你希望它做的。如果有一个包的新版本是你正在开发的项目所依赖的，你可能希望npm install给你最新的版本。
- en: 'However, what if you want npm to not do this? What if you want it to get the
    modules with exactly these versions and exactly these hashes? The way to do this
    lies not in `package-lock.json`, but back in `package.json`, and deals with semantic
    version numbers. Take a look at these three:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你不想让npm这样做呢？如果你希望它获取确切的这些版本和确切的这些哈希值的模块呢？要做到这一点，不在`package-lock.json`中，而是回到`package.json`中，并处理语义版本号。看看这三个：
- en: '`1.2.3`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.2.3`'
- en: '`~1.2.3`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~1.2.3`'
- en: '`^1.2.3`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^1.2.3`'
- en: '`1.2.3` means exactly that version, nothing earlier, and nothing later. `~1.2.3`
    matches that version, or anything more recent. The third example with the caret,
    `^1.2.3`, will bring in that version or something more recent, but stay in version
    1\. Caret is the default, and likely already written everywhere in your `package.json`
    files. It makes sense, as a change to the first number indicates a major version
    which might break compatibility with previous versions, in turn potentially breaking
    your preceding code.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.2.3`确切表示那个版本，没有更早的，也没有更晚的。`~1.2.3`匹配该版本或任何更新的版本。第三个例子中的插入符号`^1.2.3`将引入该版本或更晚的版本，但保持在1版本。插入符号是默认的，很可能已经在你的`package.json`文件中写好了。这是有道理的，因为对第一个数字的更改表示一个可能与先前版本不兼容的主要版本，反过来可能会破坏你之前的代码。'
- en: 'Far beyond these three common examples, there''s a whole language of comparators,
    operators, identifiers, tags, and ranges possible with semantic versioning and
    supported by npm. Curious readers can check it out at: [https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver).
    However, remember to keep it simple! Your current collaborators, and future self,
    will thank you.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个常见的例子之外，语义版本和npm支持的比较器、运算符、标识符和范围还有一个完整的语言。好奇的读者可以在[https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver)查看。但是，请记住保持简单！你现在的合作者和未来的自己会感谢你。
- en: 'So, npm is changing your `node_modules` folder, and `package-lock.json`, because
    you told it to, with `^` in `package.json`. You can remove all the carets to get
    npm to stick to the exact versions, but for the instances where you want to do
    that, there''s a better way:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，npm正在改变你的`node_modules`文件夹和`package-lock.json`，因为你告诉它在`package.json`中使用`^`。你可以删除所有的插入符号，让npm坚持使用确切的版本，但在你想要这样做的情况下，有一个更好的方法：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: All npm's `shrinkwrap` command actually does is rename `package-lock.json` to
    `npm-shrinkwrap.json`. The significance comes in how npm uses the files later.
    When publishing to npm, `package-lock.json` stays behind, because it's likely
    changing as newer versions of the dependencies of what you're working on come
    out. On the other hand, `npm-shrinkwrap.json` is meant to get published with your
    module.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: npm的`shrinkwrap`命令实际上只是将`package-lock.json`重命名为`npm-shrinkwrap.json`。其重要性在于npm后续如何使用这些文件。当发布到npm时，`package-lock.json`会留下，因为它可能会随着你正在使用的依赖项的新版本的出现而改变。另一方面，`npm-shrinkwrap.json`旨在与你的模块一起发布。
- en: When npm acts on a project with a `npm-shrinkwrap.json` file, the `shrinkwrap`
    file and its exact versions and hashes, not `package.json` with its version ranges,
    determines how npm builds the `node_modules` folder. Like the cardboard box from
    a software store in a mall in the 1990s, you know that what's inside is unchanged
    from the factory by removing the plastic wrapping.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当npm在一个带有`npm-shrinkwrap.json`文件的项目上操作时，`shrinkwrap`文件及其确切的版本和哈希值，而不是`package.json`及其版本范围，决定了npm如何构建`node_modules`文件夹。就像上世纪90年代商场里软件商店的纸板盒一样，你知道里面的东西是从工厂出来时没有改变的，因为去掉了塑料包装。
