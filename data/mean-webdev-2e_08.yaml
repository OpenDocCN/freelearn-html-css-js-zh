- en: Chapter 8. Creating a MEAN CRUD Module
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。创建一个MEAN CRUD模块
- en: 'In the previous chapters, you learned how to set up each framework and how
    to connect them all together. In this chapter, you''re going to implement the
    basic operational building blocks of a MEAN application, the CRUD module. CRUD
    modules consist of a base entity with the basic functionality of creating, reading,
    updating, and deleting entity instances. In a MEAN application, your CRUD module
    is built from the server-side Express components and an Angular client module.
    In this chapter, we''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您学习了如何设置每个框架以及如何将它们全部连接在一起。在本章中，您将实现MEAN应用程序的基本操作构建模块，即CRUD模块。CRUD模块由一个基本实体和创建、读取、更新和删除实体实例的基本功能组成。在MEAN应用程序中，您的CRUD模块是从服务器端Express组件和一个Angular客户端模块构建的。在本章中，我们将涵盖以下主题：
- en: Setting up the Mongoose model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Mongoose模型
- en: Creating the Express controller
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Express控制器
- en: Wiring the Express routes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接Express路由
- en: Creating and organizing the Angular module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和组织Angular模块
- en: Understanding Angular forms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Angular表单
- en: Introducing the Angular `http` client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Angular`http`客户端
- en: Implementing the Angular module service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Angular模块服务
- en: Implementing the Angular module components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Angular模块组件
- en: Introducing CRUD modules
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍CRUD模块
- en: CRUD modules are the basic building blocks of a MEAN application. Each CRUD
    module consists of two structures supporting the Express and Angular functionalities.
    The Express part is built upon a Mongoose model, an Express controller, and an
    Express routes file. The Angular module is a bit more complex and contains a set
    of templates and a few Angular components, service, and the routing configuration.
    In this chapter, you'll learn how to combine these components in order to build
    an example `Article` CRUD module. The examples in this chapter will continue directly
    from those in previous chapters, so copy the final example from [Chapter 7](ch07.html
    "Chapter 7. Introduction to Angular"), *Introduction to Angular*, and let's start
    from there.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD模块是MEAN应用程序的基本构建模块。每个CRUD模块由支持Express和Angular功能的两个结构组成。Express部分是建立在Mongoose模型、Express控制器和Express路由文件之上的。Angular模块稍微复杂，包含一组模板和一些Angular组件、服务和路由配置。在本章中，您将学习如何将这些组件组合起来，以构建一个示例的“Article”CRUD模块。本章的示例将直接从前几章中的示例继续，因此请从[第7章](ch07.html
    "第7章。Angular简介") *Angular简介*中复制最终示例，然后从那里开始。
- en: Setting up the Express components
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Express组件
- en: Let's begin with the Express part of the module. First, you'll create a Mongoose
    model that will be used to save and validate your articles. Then, you'll move
    on to the Express controller that will deal with the business logic of your module.
    Finally, you'll wire the Express routes to produce a RESTful API for your controller
    methods. We'll begin with the Mongoose model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从模块的Express部分开始。首先，您将创建一个Mongoose模型，用于保存和验证您的文章。然后，您将继续创建处理模块业务逻辑的Express控制器。最后，您将连接Express路由，以生成控制器方法的RESTful
    API。我们将从Mongoose模型开始。
- en: Creating the Mongoose model
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Mongoose模型
- en: 'The Mongoose model will consist of four simple properties that will represent
    our `Article` entity. Let''s begin by creating the Mongoose model file in the
    `app/models` folder; create a new file named `article.server.model.js`, which
    contains the following code snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose模型将由四个简单的属性组成，代表我们的“Article”实体。让我们从在“app/models”文件夹中创建Mongoose模型文件开始；创建一个名为“article.server.model.js”的新文件，其中包含以下代码片段：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should be familiar with this code snippet, so let''s quickly go over this
    model. First, you included your model dependencies and then you used the Mongoose
    `Schema` object to create a new `ArticleSchema`. `ArticleSchema` defines four
    model fields:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该熟悉这段代码片段，所以让我们快速浏览一下这个模型。首先，您包含了您的模型依赖项，然后使用Mongoose的`Schema`对象创建了一个新的`ArticleSchema`。`ArticleSchema`定义了四个模型字段：
- en: '`created`: This is a date field that represents the time at which the article
    was created'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`：这是一个日期字段，表示文章创建的时间'
- en: '`title`: This is a string field that represents the article title; note how
    you used the required validation to make sure all articles have a title'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是一个字符串字段，表示文章标题；请注意如何使用了必需的验证，以确保所有文章都有标题'
- en: '`content`: This is a string field that represents the article content'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`：这是一个字符串字段，表示文章内容'
- en: '`creator`: This is a reference object that represents the user who created
    the article'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`creator`：这是一个表示创建文章的用户的引用对象'
- en: 'In the end, you registered the `Article` Mongoose model to allow you to use
    it in the `Articles` Express controller. Next, you''ll need to make sure your
    application is loading the model file, so go back to the `config/mongoose.js`
    file and change it as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您注册了“Article”Mongoose模型，以便在“Articles”Express控制器中使用它。接下来，您需要确保您的应用程序正在加载模型文件，因此返回到“config/mongoose.js”文件，并进行以下更改：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will load your new model file and make sure your application can use your
    `Article` model. Once you have your model configured, you'll be able to create
    your `Articles` controller.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载您的新模型文件，并确保您的应用程序可以使用您的“Article”模型。一旦配置了模型，您就可以创建您的“Articles”控制器。
- en: Setting up the Express controller
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Express控制器
- en: 'The Express controller is responsible for managing articles-related functionalities
    on the server side. It is built to offer the basic CRUD operations to manipulate
    the MongoDB article documents. To begin writing the Express controller, go to
    your `app/controllers` folder and create a new file named `articles.server.controller.js`.
    In your newly created file, add the following dependencies:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Express控制器负责在服务器端管理与文章相关的功能。它旨在为MongoDB文章文档提供基本的CRUD操作。要开始编写Express控制器，请转到您的“app/controllers”文件夹，并创建一个名为“articles.server.controller.js”的新文件。在您新创建的文件中，添加以下依赖项：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding lines of code, you basically just included your `Article` mongoose
    model. Now, before you begin creating the CRUD methods, it is recommended that
    you create an error handling method for validation and other server errors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，你基本上只包含了你的`Article` mongoose模型。现在，在开始创建CRUD方法之前，建议你为验证和其他服务器错误创建一个错误处理方法。
- en: The error handling method of the Express controller
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express控制器的错误处理方法
- en: 'In order to handle Mongoose errors, it is preferable to write a simple error
    handling method that will take care of extracting a simple error message from
    the Mongoose error object and provide it to your controller methods. Go back to
    your `app/controllers/articles.server.controller.js` file and append the following
    lines of code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理Mongoose错误，最好编写一个简单的错误处理方法，它将负责从Mongoose错误对象中提取简单的错误消息，并将其提供给你的控制器方法。回到你的`app/controllers/articles.server.controller.js`文件，并添加以下代码行：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `getErrorMessage()` method gets the Mongoose error object passed as an argument
    and then iterates over the error collection and extracts the first message. This
    is done because you don't want to overwhelm your users with multiple error messages
    at once. Now that you have error handling set up, it is time to write your first
    controller method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`getErrorMessage()`方法接收Mongoose错误对象作为参数，然后遍历错误集合并提取第一个消息。这样做是因为你不希望一次向用户展示多个错误消息。现在你已经设置好了错误处理，是时候编写你的第一个控制器方法了。'
- en: The create() method of the Express controller
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express控制器的`create()`方法
- en: 'The `create()` method of the Express controller will provide the basic functionality
    to create a new article document. It will use the HTTP request body as the JSON
    base object for the document, and it will use the model `save()` method to save
    it to MongoDB. To implement the `create()` method, append the following lines
    of code to your `app/controllers/articles.server.controller.js` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Express控制器的`create()`方法将提供创建新文章文档的基本功能。它将使用HTTP请求体作为文档的JSON基对象，并使用模型的`save()`方法将其保存到MongoDB。要实现`create()`方法，请将以下代码添加到你的`app/controllers/articles.server.controller.js`文件中：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s go over the `create()` method code. First, you created a new `Article`
    model instance using the HTTP request body. Next, you added the authenticated
    `passport` user as the article `creator`. Finally, you used the Mongoose instance
    `save()` method to save the article document. In the `save()` callback function,
    it is worth noticing how you return either an error response and an appropriate
    HTTP error code or the new `article` object as a JSON response. Once you''re done
    with the `create()` method, you will move on to implementing the read operation.
    The read operation consists of two methods: one that retrieves a list of articles
    and a second method that retrieves a particular article. Let''s begin with the
    method that lists a collection of articles.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`create()`方法的代码。首先，你使用HTTP请求体创建了一个新的`Article`模型实例。接下来，你将经过身份验证的`passport`用户添加为文章的`creator`。最后，你使用Mongoose实例的`save()`方法来保存文章文档。在`save()`回调函数中，值得注意的是你要么返回一个错误响应和适当的HTTP错误代码，要么返回新的`article`对象作为JSON响应。一旦你完成了`create()`方法，你将继续实现读取操作。读取操作包括两个方法：一个是检索文章列表的方法，另一个是检索特定文章的方法。让我们从列出文章集合的方法开始。
- en: The list() method of the Express controller
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express控制器的`list()`方法
- en: 'The `list()` method of the Express controller will provide the basic functionality
    to retrieve a list of the existing articles. It will use the model''s `find()`
    method to retrieve all the documents in the article collection and then output
    a JSON representation of this list. To implement the `list()` method, append the
    following lines of code to your `app/controllers/articles.server.controller.js`
    file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Express控制器的`list()`方法将提供检索现有文章列表的基本功能。它将使用模型的`find()`方法来检索文章集合中的所有文档，然后输出这个列表的JSON表示。要实现`list()`方法，请将以下代码添加到你的`app/controllers/articles.server.controller.js`文件中：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this controller method, note how you used the `find()` function of Mongoose
    to get the collection of article documents, and while we can add a MongoDB query
    of some sort, for now, we'll retrieve all the documents in the collection. Next,
    note how the article collection is sorted using the `created` property. Then,
    you can see how the `populate()` method of Mongoose was used to add some user
    fields to the `creator` property of the `articles` objects. In this case, you
    populated the `firstName`, `lastName`, and `fullName` properties of the `creator`
    user object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制器方法中，注意你如何使用Mongoose的`find()`函数来获取文章文档的集合，虽然我们可以添加一些MongoDB查询，但现在我们将检索集合中的所有文档。接下来，注意文章集合是如何使用`created`属性进行排序的。然后，你可以看到Mongoose的`populate()`方法是如何用来向`articles`对象的`creator`属性添加一些用户字段的。在这种情况下，你填充了`creator`用户对象的`firstName`、`lastName`和`fullName`属性。
- en: The rest of the CRUD operations involve a manipulation of a single existing
    article document. You could, of course, implement the retrieval of the article
    document in each method by itself, basically repeating this logic. However, the
    Express router has a neat feature for the handling of route parameters, so before
    you'll implement the rest of your Express CRUD functionality, you'll first learn
    how to leverage the route parameter middleware to save some time and code redundancy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD操作的其余部分涉及对单个现有文章文档的操作。当然，你可以在每个方法中实现对文章文档的检索，基本上重复这个逻辑。然而，Express路由器有一个很好的特性用于处理路由参数，所以在实现Express
    CRUD功能的其余部分之前，你首先要学习如何利用路由参数中间件来节省一些时间和代码冗余。
- en: The read() middleware of the Express controller
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express控制器的`read()`中间件
- en: The `read()` method of the Express controller will provide the basic functionality
    to read an existing article document from the database. Since you're writing a
    sort of RESTful API, the common usage of this method will be handled by passing
    the article's ID field as a route parameter. This means that your requests to
    the server will contain an `articleId` parameter in their paths.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Express 控制器的 read() 方法将提供从数据库中读取现有文章文档的基本功能。由于您正在编写一种类似 RESTful API 的东西，因此这种方法的常见用法将通过将文章的
    ID 字段作为路由参数来处理。这意味着您发送到服务器的请求将在其路径中包含一个 `articleId` 参数。
- en: 'Fortunately, the Express router provides the `app.param()` method for the handling
    of route parameters. This method allows you to attach a middleware for all the
    requests containing the `articleId` route parameter. The middleware itself will
    then use the `articleId` provided to find the proper MongoDB document and add
    the retrieved `article` object to the request object. This will allow all the
    controller methods that manipulate an existing article to obtain the `article`
    object from the Express request object. To make this clearer, let''s implement
    the route parameter middleware. Go to your `app/controllers/articles.server.controller.js`
    file and append the following lines of code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Express 路由器提供了 `app.param()` 方法来处理路由参数。该方法允许您为包含 `articleId` 路由参数的所有请求附加一个中间件。然后中间件本身将使用提供的
    `articleId` 来查找适当的 MongoDB 文档，并将检索到的 `article` 对象添加到请求对象中。这将允许所有操作现有文章的控制器方法从
    Express 请求对象中获取 `article` 对象。为了更清晰，让我们实现路由参数中间件。转到您的 `app/controllers/articles.server.controller.js`
    文件并追加以下代码行：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the middleware function signature contains all the Express middleware
    arguments and an `id` argument. It then uses the `id` argument to find an article
    and reference it using the `req.article` property. Note how the `populate()` method
    of the Mongoose model was used to add some user fields to the `creator` property
    of the `article` object. In this case, you populated the `firstName`, `lastName`,
    and `fullName` properties of the `creator` user object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，中间件函数签名包含所有 Express 中间件参数和一个 `id` 参数。然后使用 `id` 参数查找文章，并使用 `req.article`
    属性引用它。请注意，Mongoose 模型的 `populate()` 方法用于向 `article` 对象的 `creator` 属性添加一些用户字段。在这种情况下，您填充了
    `creator` 用户对象的 `firstName`、`lastName` 和 `fullName` 属性。
- en: 'When you connect your Express routes, you''ll learn how to add the `articleByID()`
    middleware to different routes, but for now, let''s add the `read()` method of
    the Express controller, which will return an `article` object. To add the `read()`
    method, append the following lines of code to your `app/controllers/articles.server.controller.js`
    file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您连接 Express 路由时，您将学习如何将 `articleByID()` 中间件添加到不同的路由，但现在让我们添加 Express 控制器的 `read()`
    方法，它将返回一个 `article` 对象。要添加 `read()` 方法，请将以下代码行追加到您的 `app/controllers/articles.server.controller.js`
    文件中：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Quite simple, isn't it? That's because you already took care of obtaining the
    `article` object in the `articleByID()` middleware, so now all you have to do
    is just output the `article` object as a JSON representation. We'll connect the
    middleware and routes in the next sections, but before we do that, let's finish
    implementing the Express controller CRUD functionality.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 相当简单，不是吗？那是因为您已经在 `articleByID()` 中间件中处理了获取 `article` 对象的问题，所以现在您所需做的就是以 JSON
    表示形式输出 `article` 对象。我们将在接下来的部分连接中间件和路由，但在此之前，让我们完成实现 Express 控制器的 CRUD 功能。
- en: The update() method of the Express controller
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express 控制器的 update() 方法
- en: 'The `update()` method of the Express controller will provide the basic operations
    to update an existing article document. It will use the existing `article` object
    as the base object and then update the `title` and `content` fields using the
    HTTP request body. It will also use the model `save()` method to save the changes
    to the database. To implement the `update()` method, go to your `app/controllers/articles.server.controller.js`
    file and append the following lines of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Express 控制器的 update() 方法将提供更新现有文章文档的基本操作。它将使用现有的 `article` 对象作为基础对象，然后使用 HTTP
    请求体更新 `title` 和 `content` 字段。它还将使用模型的 `save()` 方法将更改保存到数据库。要实现 `update()` 方法，请转到您的
    `app/controllers/articles.server.controller.js` 文件并追加以下代码行：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the `update()` method also makes the assumption that you already
    obtained the `article` object in the `articleByID()` middleware. So, all you have
    to do is update the `title` and `content` fields, save the article, and then output
    the updated `article` object as a JSON representation. In case of an error, it
    will output the appropriate error message using the `getErrorMessage()` method
    you wrote earlier and an HTTP error code. The last CRUD operation left to implement
    is the `delete()` method; so let's look at how you can add a simple `delete()`
    method to your Express controller.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`update()` 方法还假设您已经在 `articleByID()` 中间件中获取了 `article` 对象。因此，您所需做的就是更新
    `title` 和 `content` 字段，保存文章，然后以 JSON 表示形式输出更新后的 `article` 对象。如果出现错误，它将使用您之前编写的
    `getErrorMessage()` 方法和 HTTP 错误代码输出适当的错误消息。剩下要实现的最后一个 CRUD 操作是 `delete()` 方法；所以让我们看看如何向
    Express 控制器添加一个简单的 `delete()` 方法。
- en: The delete() method of the Express controller
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express 控制器的 delete() 方法
- en: 'The `delete()` method of the Express controller will provide the basic operations
    to delete an existing article document. It will use the model `remove()` method
    to delete the existing article from the database. To implement the `delete()`
    method, go to your `app/controllers/articles.server.controller.js` file and append
    the following lines of code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Express 控制器的 delete() 方法将提供删除现有文章文档的基本操作。它将使用模型的 `remove()` 方法从数据库中删除现有文章。要实现
    `delete()` 方法，请转到您的 `app/controllers/articles.server.controller.js` 文件并追加以下代码行：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, you can see how the `delete()` method also makes use of the already obtained
    `article` object by the `articleByID()` middleware. So, all you have to do is
    invoke the Mongoose model's `remove()` method and then output the deleted `article`
    object as a JSON representation. In case of an error, it will output the appropriate
    error message using the `getErrorMessage()` method you wrote earlier and an HTTP
    error code instead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以看到`delete()`方法也利用了已经获取的`article`对象，通过`articleByID()`中间件。因此，您所需做的就是调用Mongoose模型的`remove()`方法，然后输出已删除的`article`对象作为JSON表示。如果出现错误，它将使用您之前编写的`getErrorMessage()`方法输出适当的错误消息和HTTP错误代码。
- en: Congratulations! You just finished implementing your Express controller's CRUD
    functionality. Before you continue to wire the Express routes that will invoke
    these methods, let's take some time to implement two authorization middleware.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚完成了实现Express控制器的CRUD功能。在继续连接调用这些方法的Express路线之前，让我们花点时间来实现两个授权中间件。
- en: Implementing an authentication middleware
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施身份验证中间件
- en: 'When building your Express controller, you probably noticed that most methods
    require your user to be authenticated. For instance, the `create()` method won''t
    be operational if the `req.user` object is not assigned. While you can check this
    assignment inside your methods, this will enforce you to implement the same validation
    code over and over. Instead, you can just use the Express middleware chaining
    to block unauthorized requests from executing your controller methods. The first
    middleware you should implement will check whether a user is authenticated at
    all. Since this is an authentication-related method, it would be best to implement
    it in the Express `users` controller, so go to the `app/controllers/users.server.controller.js`
    file and append the following lines of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Express控制器时，您可能已经注意到大多数方法要求用户进行身份验证。例如，如果`req.user`对象未分配，`create()`方法将无法操作。虽然您可以在方法内部检查此分配，但这将强制您一遍又一遍地实施相同的验证代码。相反，您可以使用Express中间件链来阻止未经授权的请求执行您的控制器方法。您应该实施的第一个中间件将检查用户是否已经认证。由于这是一个与身份验证相关的方法，最好将其实施在Express`users`控制器中，因此转到`app/controllers/users.server.controller.js`文件，并追加以下代码行：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `requiresLogin()` middleware uses the Passport-initiated `req.isAuthenticated()`
    method to check whether a user is currently authenticated. If it finds out that
    the user is indeed signed in, it will call the next middleware in the chain; otherwise,
    it will respond with an authentication error and an HTTP error code. This middleware
    is great, but if you want to check whether a specific user is authorized to perform
    a certain action, you will need to implement an article-specific authorization
    middleware.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`requiresLogin()`中间件使用Passport启动的`req.isAuthenticated()`方法来检查用户当前是否已经认证。如果发现用户确实已登录，它将调用链中的下一个中间件；否则，它将以身份验证错误和HTTP错误代码进行响应。这个中间件很棒，但如果您想检查特定用户是否被授权执行某个操作，您需要实施一个特定于文章的授权中间件。'
- en: Implementing an authorization middleware
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施授权中间件
- en: 'In your CRUD module, there are two methods that edit an existing article document.
    Usually, the `update()` and `delete()` methods should be restricted so that only
    the user who created the article will be able to use them. This means that you
    need to authorize any request made to these methods to validate whether the current
    article is being edited by its creator. To do this, you will need to add an authorization
    middleware to your `Articles` controller, so go to the `app/controllers/articles.server.controller.js`
    file and append the following lines of code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的CRUD模块中，有两种方法可以编辑现有的文章文档。通常，`update()`和`delete()`方法应该受限，以便只有创建文章的用户才能使用它们。这意味着您需要授权对这些方法的任何请求，以验证当前文章是否正在被其创建者编辑。为此，您需要向`Articles`控制器添加一个授权中间件，因此转到`app/controllers/articles.server.controller.js`文件，并追加以下代码行：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `hasAuthorization()` middleware uses the `req.articl`e and `req.user` objects
    to verify that the current user is the creator of the current article. This middleware
    also assumes that it gets executed only for requests that contain the `articleId`
    route parameter. Now that you have all your methods and middleware in place, it
    is time to wire the routes that enable their execution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasAuthorization()`中间件使用`req.article`和`req.user`对象来验证当前用户是否是当前文章的创建者。该中间件还假定它仅对包含`articleId`路由参数的请求执行。现在，您已经将所有方法和中间件放置好，是时候连接启用它们的路线了。'
- en: Wiring the Express routes
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接Express路线
- en: 'Before we begin wiring the Express routes, let''s do a quick overview of the
    RESTful API architectural design. The RESTful API provides a coherent service
    structure that represents a set of actions that you can perform on an application
    resource. This means that the API uses a predefined route structure along with
    the HTTP method name in order to provide context for HTTP requests. Though the
    RESTful architecture can be applied in different ways, a RESTful API usually complies
    with a few simple rules:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始连接Express路线之前，让我们快速回顾一下RESTful API的架构设计。RESTful API提供了一个连贯的服务结构，代表了您可以在应用程序资源上执行的一组操作。这意味着API使用预定义的路由结构以及HTTP方法名称，以提供HTTP请求的上下文。虽然RESTful架构可以以不同的方式应用，但RESTful
    API通常遵守一些简单的规则：
- en: A base URI per resource, in our case, `http://localhost:3000/articles`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个资源的基本URI，在我们的情况下是`http://localhost:3000/articles`
- en: A data structure, usually JSON, passed in the request body
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据结构，通常是JSON，传递到请求体中
- en: The usage of standard HTTP methods (for example, `GET`, `POST`, `PUT`, and `DELETE`)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准的HTTP方法（例如，`GET`，`POST`，`PUT`和`DELETE`）
- en: 'Using these three rules, you''ll be able to properly route HTTP requests to
    use the right controller method. So, your articles API will consist of five routes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三条规则，您将能够正确地路由HTTP请求以使用正确的控制器方法。因此，您的文章API将包括五条路线：
- en: '`GET http://localhost:3000/articles`: This will return a list of articles'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://localhost:3000/articles`：这将返回一系列文章'
- en: '`POST http://localhost:3000/articles` : This will create and return a new article'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST http://localhost:3000/articles`：这将创建并返回新文章'
- en: '`GET http://localhost:3000/articles/:articleId`: This will return a single
    existing article'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://localhost:3000/articles/:articleId`：这将返回单个现有文章'
- en: '`PUT http://localhost:3000/articles/:articleId`: This will update and return
    a single existing article'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT http://localhost:3000/articles/:articleId`：这将更新并返回单个现有文章'
- en: '`DELETE http://localhost:3000/articles/:articleId`: This will delete and return
    a single article'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE http://localhost:3000/articles/:articleId`：这将删除并返回单篇文章'
- en: 'As you probably noticed, these routes already have corresponding controller
    methods. You even have the `articleId` route parameter middleware already implemented,
    so all that is left to do is implement the Express routes. To do that, go to the
    `app/routes` folder and create a new file named `articles.server.routes.js`. In
    your newly created file, paste the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这些路由已经有了相应的控制器方法。甚至已经实现了`articleId`路由参数中间件，因此剩下的就是实现Express路由。为此，请转到`app/routes`文件夹，并创建一个名为`articles.server.routes.js`的新文件。在您新创建的文件中，粘贴以下代码片段：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code snippet, you did several things. First, you required the
    `users` and `articles` controllers, and then you used the Express `app.route()`
    method to define the base routes for your CRUD operations. You used the Express
    routing methods to wire each controller method to a specific HTTP method. You
    may also notice how the `POST` method uses the `users.requiresLogin()` middleware,
    since a user needs to log in before they can create a new article. In the same
    way, the `PUT` and `DELETE` methods use both `users.requiresLogin()` and `articles.hasAuthorization()`
    middleware, since users can only edit and delete the articles they created. Finally,
    you used the `app.param()` method to make sure that every route that has the `articleId`
    parameter will first call the `articles.articleByID()` middleware. Next, you'll
    need to configure your Express application to load your new `Article` model and
    routes file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，您做了几件事。首先，您需要了`users`和`articles`控制器，然后使用Express的`app.route()`方法来定义CRUD操作的基本路由。您使用Express路由方法将每个控制器方法与特定的HTTP方法进行了连接。您可能还注意到`POST`方法如何使用`users.requiresLogin()`中间件，因为用户需要在创建新文章之前登录。同样，`PUT`和`DELETE`方法使用了`users.requiresLogin()`和`articles.hasAuthorization()`中间件，因为用户只能编辑和删除他们创建的文章。最后，您使用了`app.param()`方法来确保具有`articleId`参数的每个路由将首先调用`articles.articleByID()`中间件。接下来，您需要配置Express应用程序以加载您的新`Article`模型和路由文件。
- en: Configuring the Express application
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Express应用程序
- en: 'In order to use your new Express assets, you have to configure your Express
    application to load your route file. To do that, go back to your `config/express.js`
    file and change it, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用您的新的Express资源，您必须配置Express应用程序以加载您的路由文件。为此，请返回到您的`config/express.js`文件并进行更改，如下所示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is it; your article's RESTful API is ready! Next, you'll learn how simple
    it is to use the `HTTP` client to let your Angular components communicate with
    it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；您的文章的RESTful API已经准备就绪！接下来，您将学习如何简单地使用`HTTP`客户端让您的Angular组件与其通信。
- en: Using the HTTP client
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP客户端
- en: In [Chapter 7](ch07.html "Chapter 7. Introduction to Angular"), *Introduction
    to Angular*, we mentioned the `http` client as a means of communication between
    the Angular 2 application and your backend API. Since the REST architecture is
    well structured, it would be quite easy to implement a service for our Angular
    module, which we'll provide to our components with an API in order to communicate
    with the server. To do that, the Angular http client utilizes the Observable pattern
    to deal with its asynchronous nature, so before we continue, it would be best
    to quickly review this powerful pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。Angular简介")中，*Angular简介*，我们提到`http`客户端作为Angular 2应用程序与后端API之间通信的手段。由于REST架构结构良好，因此很容易为我们的Angular模块实现一个服务，并通过API提供给我们的组件，以便与服务器通信。为此，Angular
    http客户端利用Observable模式来处理其异步性质，因此在继续之前，最好快速回顾一下这个强大的模式。
- en: Reactive programming and Observables
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式编程和Observables
- en: 'In programming, we mostly expect things to run in a serial way, where all of
    our instructions occur in an order. Alas, from its beginning, web application
    development suffered from a lack of synchronicity. This is especially a problem
    when dealing with data and, more specifically in our case, data that is retrieved
    from the server. To solve this issue, various different patterns were created,
    from which now we mostly use the callback and promise patterns. Callbacks were
    the go-to for most of JavaScript''s lifetime, and more recently, Promises started
    gaining some traction. However, Promises suffer from a short, onetime lifespan.
    To be more precise, a Promise can be set up and then can only be differed once,
    but our data can change over time, so we''ll need to create more and more promises.
    For instance, let''s say we want to track all the changes made to a text field
    and implement an ''undo'' functionality; to do that, we can use a callback to
    our text change event and then record all of the changes and do something with
    it. This might seem simple, but what if we have hundreds of objects or what if
    our text field value is changed programmatically? This is a very simplistic example,
    but this scenario repeats itself in various ways across modern application development,
    and to solve it, a new methodology has emerged, a methodology called Reactive
    Programming. You might have heard about reactive programming or you might have
    not, but the easiest way to understand it is to realize that it''s all about tracking
    asynchronous data that is changing over time, and the way it does this is by using
    Observables. Observables are streams of data that can be observed by one or multiple
    observers. An Observable emits values over time and notifies the "subscribed"
    observers with a new value, an error, or a completion event. A visual representation
    of this mechanism can be seen in the following figure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们大多数情况下期望事情按顺序运行，所有指令都按顺序发生。然而，从一开始，Web应用程序开发就遭受了缺乏同步性的问题。当处理数据时，特别是在我们的情况下，从服务器检索到的数据时，这是一个特别大的问题。为了解决这个问题，创建了各种不同的模式，现在我们主要使用回调和Promise模式。回调在大部分JavaScript的生命周期中都是首选，而最近，Promise开始受到一些关注。然而，Promise的寿命很短。更准确地说，Promise可以设置，但只能延迟一次，但我们的数据可能随着时间的推移而改变，所以我们需要创建更多的Promise。举个例子，假设我们想跟踪对文本字段所做的所有更改并实现“撤销”功能；为此，我们可以使用回调来处理文本更改事件，然后记录所有更改并对其进行处理。这可能看起来很简单，但如果我们有数百个对象，或者如果我们的文本字段值是以编程方式更改的呢？这只是一个非常简单的例子，但这种情况在现代应用程序开发中以各种方式重复出现，为了解决这个问题，出现了一种新的方法论，称为响应式编程。您可能听说过响应式编程，也可能没有，但最容易理解它的方法是意识到它主要是跟踪随时间变化的异步数据，它通过使用Observables来实现这一点。Observables是可以被一个或多个观察者观察的数据流。Observable会随着时间发出值，并通过新值、错误或完成事件通知“订阅”的观察者。这种机制的可视化表示可以在下图中看到：
- en: '![Reactive programming and Observables](img/B05071_08_01.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![响应式编程和Observables](img/B05071_08_01.jpg)'
- en: In this diagram, you can see that the Observables keeps emitting value changes,
    an error, another value change, and then a completion event when the Observable
    finishes its life cycle. Reactive programming might seem complicated, but fortunately,
    the ReactiveX library allows us to deal with observables in a very simple way.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，您可以看到Observables不断发出值的变化，一个错误，另一个值的变化，然后在Observable完成其生命周期时发出完成事件。响应式编程可能看起来很复杂，但幸运的是，ReactiveX库允许我们以非常简单的方式处理Observables。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended that you continue reading about reactive programming, since
    it's rapidly becoming a dominant approach to modern web application development.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您继续阅读有关响应式编程的内容，因为它正在迅速成为现代Web应用程序开发的主要方法。
- en: The ReactiveX library
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactiveX库
- en: 'The Rx library is a cross-platform library that uses the observer pattern to
    help developers manage asynchronous data changes over time. Simply put, ReactiveX
    is a library that allows us to create and manipulate Observable objects. In Angular
    2 projects, we use the RxJS library, which is basically a JavaScript version of
    the ReactiveX library. If you look closely at the previous chapter, you''ll be
    able to see that we already set it up and even used it in our authentication service.
    We did that by installing it using `npm`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Rx库是一个跨平台库，它使用观察者模式来帮助开发人员管理随时间发生的异步数据更改。简而言之，ReactiveX是一个允许我们创建和操作Observable对象的库。在Angular
    2项目中，我们使用RxJS库，它基本上是ReactiveX库的JavaScript版本。如果您仔细观察前一章，您将看到我们已经设置了它，甚至在我们的身份验证服务中使用了它。我们通过使用`npm`安装它来实现这一点：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We imported it in our entities as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实体中导入它如下：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We had to do this because the Angular team chose to use Observables quite extensively.
    And one of our first encounters with it was using the http client.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不这样做是因为Angular团队选择广泛使用Observables。我们第一次遇到它是在使用http客户端时。
- en: Using the http client
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用http客户端
- en: 'The `http` module provides us with a standardized way to communicate with our
    RESTful endpoints. To use the `http` client, we''ll have to import and inject
    it into our entities and then use our `http` client instance to perform different
    HTTP requests. A simple example of using the http client to perform a POST request
    was presented in [Chapter 7](ch07.html "Chapter 7. Introduction to Angular"),
    *Introduction to Angular*, where we used it in our signin method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`http`模块为我们提供了与RESTful端点通信的标准化方式。要使用`http`客户端，我们需要将其导入并注入到我们的实体中，然后使用我们的`http`客户端实例执行不同的HTTP请求。在[第7章](ch07.html
    "第7章。Angular简介")中，我们展示了使用http客户端执行POST请求的简单示例，*Angular简介*中我们在登录方法中使用了它：'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we created a JSON string and set the request headers using the
    `RequestOptions` object before we called the `http` client `post()` methods. The
    `http` client method returns an Observable object that tracks an HTTP Response
    object. But since we want our service to provide data, we used the `map()` method
    to extract the response JSON object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们创建了一个JSON字符串，并在调用`http`客户端的`post()`方法之前使用`RequestOptions`对象设置了请求头。`http`客户端方法返回一个Observable对象，跟踪HTTP响应对象。但是由于我们希望我们的服务提供数据，我们使用`map()`方法提取响应的JSON对象。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We need to use the `json()` method since Angular follows the ES2015 specification
    for the HTTP response object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`json()`方法，因为Angular遵循HTTP响应对象的ES2015规范。
- en: 'Note that we also catch any error using our `handleError()` method. So how
    do we use the Observable object returned from this method? If you look back at
    our `signin` component, you''ll be able to see how we used our authentication
    service:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还使用我们的`handleError()`方法捕获任何错误。那么我们如何使用从这个方法返回的Observable对象？如果您回顾一下我们的`signin`组件，您将能够看到我们如何使用我们的认证服务：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this method, we called the authentication service's signin method and then
    subscribed to the returned Observable. We then handled any value event with the
    first arrow function and any error with the second arrow function. That's basically
    the way we work the HTTP client!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们调用了认证服务的登录方法，然后订阅返回的Observable。然后我们用第一个箭头函数处理任何值事件，用第二个箭头函数处理任何错误。这基本上是我们使用HTTP客户端的方式！
- en: 'The HTTP client offers various methods to handle different HTTP requests:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP客户端提供了各种方法来处理不同的HTTP请求：
- en: '`request(url, options)`: This method allows us to perform any HTTP request
    defined by the options object.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request(url, options)`: 这个方法允许我们执行由选项对象定义的任何HTTP请求。'
- en: '`get()`: This method performs a `GET` HTTP request.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 这个方法执行一个`GET` HTTP请求。'
- en: '`post()`: This method performs a `POST` HTTP request.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post()`: 这个方法执行一个`POST` HTTP请求。'
- en: '`put()`: This method performs a `PUT` HTTP request.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put()`: 这个方法执行一个`PUT` HTTP请求。'
- en: '`delete()`: This method performs a `DELETE` HTTP request.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete()`: 这个方法执行一个`DELETE` HTTP请求。'
- en: All these methods return a Response Observable object that can be subscribed
    or manipulated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都返回一个可订阅或可操作的响应Observable对象。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An important thing to notice is that the HTTP client always returns a "cold"
    observable. This means that the request itself will not be sent until someone
    subscribes to the observable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情要注意的是，HTTP客户端总是返回一个“冷”可观察对象。这意味着请求本身直到有人订阅可观察对象才会被发送。
- en: In the next section, you'll learn how to use the `http` client to communicate
    with your Express API.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何使用`http`客户端与您的Express API进行通信。
- en: Implementing the Angular module
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Angular模块
- en: 'The second part of your CRUD module is the Angular module. This module will
    contain an Angular service that will communicate with the Express API using the
    `http` client, an Angular Article component that will contain four subcomponents
    with a set of templates that provide your users with an interface to perform CRUD
    operations. Before you begin creating your Angular entities, let''s first create
    the initial module structure. Go to your application''s `public/app` folder and
    create a new folder named `articles`. In this new folder, create the module file
    named `articles.module.ts` and paste the following lines of code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您的CRUD模块的第二部分是Angular模块。这个模块将包含一个Angular服务，该服务将使用`http`客户端与Express API进行通信，一个包含四个子组件的Angular文章组件，这些子组件具有一组模板，为您的用户提供执行CRUD操作的界面。在开始创建您的Angular实体之前，让我们首先创建初始模块结构。转到您的应用程序的`public/app`文件夹，并创建一个名为`articles`的新文件夹。在这个新文件夹中，创建名为`articles.module.ts`的模块文件，并粘贴以下代码行：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, we simply imported the modules we needed from the Angular packages
    and the components, service, and routes definition of our new module. Next, we
    created a new Angular module that imports the Angular modules and our routing
    configuration as a child router and then declares our new module components. Now,
    we can continue by creating our main component file. To do that, create a file
    named `articles.component.ts` inside your `public/app` folder and paste the following
    lines of code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只是从Angular包中导入了我们需要的模块，以及我们新模块的组件、服务和路由定义。接下来，我们创建了一个新的Angular模块，它作为子路由导入了Angular模块和我们的路由配置，然后声明了我们新模块的组件。现在，我们可以继续创建我们的主组件文件。为此，在您的`public/app`文件夹中创建一个名为`articles.component.ts`的文件，并粘贴以下代码行：
- en: import { Component } from '@angular/core';
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: import { Component } from '@angular/core';
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this file, we imported the basic Angular modules and the articles service
    we''ll shortly create. We then created a new component that uses `router-outlet`
    and injects our service. Next, we''ll need to create a routing configuration for
    our `articles` component. To do that, create a file named `articles.routes.ts`
    and paste the following lines of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们导入了基本的Angular模块和我们即将创建的文章服务。然后我们创建了一个使用`router-outlet`并注入我们的服务的新组件。接下来，我们需要为我们的`articles`组件创建一个路由配置。为此，创建一个名为`articles.routes.ts`的文件，并粘贴以下代码行：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we simply created a routing configuration for our component
    and its subcomponents. The code should be familiar, since it resembles the authentication
    routing we implemented in the previous chapter. Moreover, in our update and view
    paths, we defined a URL parameter in the form of a colon followed by the name
    of our parameter, in this case, the `articleId` parameter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们简单地为我们的组件及其子组件创建了一个路由配置。这段代码应该很熟悉，因为它类似于我们在上一章中实现的认证路由。此外，在我们的更新和查看路径中，我们定义了一个URL参数，形式为冒号后跟我们的参数名称，这种情况下是`articleId`参数。
- en: 'Next, you''ll need to import our articles module in our application module
    configuration. To do that, go back to your `public/app/app.module.ts` file and
    change it as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要在我们的应用程序模块配置中导入我们的文章模块。为此，返回到您的`public/app/app.module.ts`文件，并将其更改如下：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This concludes the configuration of our new module. Now we can move on to creating
    our module entities. We'll begin with our module service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们新模块的配置。现在我们可以继续创建我们的模块实体。我们将从我们的模块服务开始。
- en: Creating the Angular module service
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Angular模块服务
- en: 'In order for your CRUD module to easily communicate with the API endpoints,
    it is recommended that you use a single Angular service that will utilize the
    `http` client methods. To do that, go to your `public/app/articles` folder and
    create a new file named `articles.service.ts` with the following lines of code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的CRUD模块能够轻松与API端点通信，建议您使用一个单一的Angular服务，该服务将利用`http`客户端方法。为此，请转到您的`public/app/articles`文件夹，并创建一个名为`articles.service.ts`的新文件，其中包含以下代码行：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's review this. First, we imported the `Observable` and `rxjs` library module.
    You might notice that we import the entire library, since we'll need to use various
    operators with our Observable object, for instance, the `map()` method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回顾一下。首先，我们从Angular库中导入了`Observable`和`rxjs`库模块。您可能注意到我们导入了整个库，因为我们需要在Observable对象中使用各种操作符，例如`map()`方法。
- en: 'Next, we imported the modules we needed from the Angular library and created
    our injectable service using the `@Injectable` decorator. Our service has one
    property to hold our API base URL and a constructor to inject the HTTP client.
    It contains an error handling method that deals with server errors. Our other
    methods are quite easy to understand:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从Angular库中导入了我们需要的模块，并使用`@Injectable`装饰器创建了我们的可注入服务。我们的服务有一个属性来保存我们的API基本URL，并且有一个构造函数来注入HTTP客户端。它包含一个处理服务器错误的方法。我们的其他方法都很容易理解：
- en: '`create()`: Accepts an article object and sends it to the server using an HTTP
    POST request'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create()`: 接受文章对象并使用HTTP POST请求将其发送到服务器'
- en: '`read()`: Accepts an `article ID` string and asks for an article object from
    the server using an HTTP GET request'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read()`: 接受`文章ID`字符串并使用HTTP GET请求向服务器请求文章对象'
- en: '`update ()`: Accepts an article object and sends it to the server for an update
    using an HTTP PUT request'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`: 接受文章对象并使用HTTP PUT请求将其发送到服务器进行更新'
- en: '`delete()`: Accepts an `article ID` string and tries to delete it using an
    HTTP DELETE request'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete()`: 接受`文章ID`字符串并尝试使用HTTP DELETE请求删除它'
- en: '`list()`: Requests for an array of article objects using an HTTP GET request'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list()`: 使用HTTP GET请求请求文章对象数组'
- en: Note how we map the response object to only send the JSON object and how we
    catch any error to modify the response so that our components will only have to
    deal with the data itself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将响应对象映射为只发送JSON对象，并且如何捕获任何错误以修改响应，以便我们的组件只需处理数据本身。
- en: That's it! Our module infrastructure is ready for our subcomponents. In the
    next sections, you'll be able to see how easy our implementation becomes using
    our previous preparations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们的模块基础设施已经为我们的子组件准备好了。在接下来的章节中，您将能够看到我们如何利用之前的准备来轻松实现我们的实现。
- en: Implementing the Create subcomponent
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现创建子组件
- en: 'Our "Create" subcomponent will be taking care of creating new articles. Begin
    by creating a new folder named `create` inside your `public/app/articles` folder.
    In this folder, create a new file named `create.component.ts` and paste the following
    code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“创建”子组件将负责创建新文章。首先在`public/app/articles`文件夹内创建一个名为`create`的新文件夹。在此文件夹中，创建一个名为`create.component.ts`的新文件，并粘贴以下代码：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's review this. We started by importing the modules we need from the Angular
    library along with our `ArticlesService`. Then, we created our component with
    an empty article and `errorMessage` objects. Note how our Component's constructor
    injects the `Router` and our `ArticlesService` services. Then, we created a `create()`
    method that uses `ArticlesService` to create a new article object. In our observable
    subscription, we use the `Router` service to navigate to our View components along
    with the newly created `article ID`. In case of an error, we set our component's
    `errorMessage` property to the message. To finish up with our subcomponent, we'll
    need to create its template.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回顾一下。我们首先从Angular库中导入了我们需要的模块以及我们的`ArticlesService`。然后，我们创建了一个带有空文章和`errorMessage`对象的组件。注意我们的组件构造函数如何注入了`Router`和我们的`ArticlesService`服务。然后，我们创建了一个`create()`方法，该方法使用`ArticlesService`来创建一个新的文章对象。在我们的可观察订阅中，我们使用`Router`服务导航到我们的视图组件以及新创建的`文章ID`。在出现错误的情况下，我们将组件的`errorMessage`属性设置为该消息。为了完成我们的子组件，我们需要创建其模板。
- en: Adding the template
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加模板
- en: 'The `create` template will provide your user with an interface to create a
    new article. It will contain an HTML form and it will use your component''s `create`
    method to save the new article. To create your template, go to the `public/app/articles/create`
    folder and create a new file named `create.template.html`. In your new file, paste
    the following code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`模板将为您的用户提供一个创建新文章的界面。它将包含一个HTML表单，并且将使用您组件的`create`方法来保存新文章。要创建您的模板，请转到`public/app/articles/create`文件夹，并创建一个名为`create.template.html`的新文件。在您的新文件中，粘贴以下代码片段：'
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `create` template contains a simple form with two text input fields and
    a submit button. The text fields use the `ngModel` directive to bind the user
    input to our component's properties. It is also important to note the `ngSubmit`
    directive you placed in the `form` element. This directive tells Angular to call
    a specific component method when the form is submitted. In this case, the form
    submission will execute your component's `create()` method. The last thing you
    should notice is the error message at the end of the form that will be shown in
    case of any error. Next, we're going to implement the View subcomponent.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`模板包含一个简单的表单，其中包含两个文本输入字段和一个提交按钮。文本字段使用`ngModel`指令将用户输入绑定到我们组件的属性。还要注意在`form`元素中放置的`ngSubmit`指令。该指令告诉Angular在提交表单时调用特定的组件方法。在这种情况下，表单提交将执行您组件的`create()`方法。您应该注意到的最后一件事是表单末尾的错误消息，以防出现任何错误时会显示。接下来，我们将实现视图子组件。'
- en: Implementing the View subcomponent
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现视图子组件
- en: 'Our "View" subcomponent will be taking care of presenting a single article.
    Our component will also contain a set of buttons that are visible only to the
    article creator, which will allow the creator to delete the article or navigate
    to the `edit` route. Begin by creating a new folder named `view` inside your `public/app/articles`
    folder. In this folder, create a new file named `view.component.ts` and paste
    the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“查看”子组件将负责呈现单篇文章。我们的组件还将包含一组按钮，仅对文章创建者可见，这些按钮将允许创建者删除文章或导航到“编辑”路由。首先，在`public/app/articles`文件夹内创建一个名为`view`的新文件夹。在这个文件夹中，创建一个名为`view.component.ts`的新文件，并粘贴以下代码：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We started by importing the modules we need from the Angular library along with
    our `ArticlesService` and `AuthenticationService`. Then, we created our component
    with an article property, a `currentUser` property, a `paramsObserver` property,
    an `allowEdit` flag, and an `errorMessage` property. Note how our component's
    constructor injects `Router`, `RouteParams`, and our `ArticlesService` and `AuthenticationService`
    services. Our constructor also sets the `currentUser` property using the `AuthenticationService`
    instance. In our `ngOnInit` method, which is being invoked when the component
    is initialized, we read the `article ID` parameter from the route parameters,
    and then we use the `ArticlesService` to fetch an existing article. We do this
    using `ActivatedRoute`, which supplies us with a `params` Observable. We unsubscribe
    to this Observable on our component's `ngOnDestroy` method. In our Observable
    subscription, we set the component's `article` property and determine whether
    the current user can edit the article. In case of an error, we use the `Router`
    service to navigate back to our `List` route. Lastly, we implemented a `delete()`
    method that uses `ArticlesService` to delete the viewed article and go back to
    the article list. To finish up with our subcomponent, we'll need to create its
    template.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Angular库中导入我们需要的模块以及我们的`ArticlesService`和`AuthenticationService`。然后，我们创建了一个具有文章属性、`currentUser`属性、`paramsObserver`属性、`allowEdit`标志和`errorMessage`属性的组件。请注意，我们的组件构造函数注入了`Router`、`RouteParams`和我们的`ArticlesService`和`AuthenticationService`服务。我们的构造函数还使用`AuthenticationService`实例设置了`currentUser`属性。在我们的`ngOnInit`方法中，当组件初始化时被调用，我们从路由参数中读取`文章ID`参数，然后使用`ArticlesService`来获取现有的文章。我们使用`ActivatedRoute`来完成这个操作，它为我们提供了一个`params`
    Observable。我们在组件的`ngOnDestroy`方法中取消了对这个Observable的订阅。在我们的Observable订阅中，我们设置了组件的`article`属性，并确定当前用户是否可以编辑文章。在出现错误时，我们使用`Router`服务来导航回到我们的`List`路由。最后，我们实现了一个`delete()`方法，该方法使用`ArticlesService`来删除查看的文章并返回到文章列表。要完成我们的子组件，我们需要创建它的模板。
- en: Adding the template
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加模板
- en: 'The `view` template will provide your user with an interface to `view` an existing
    article. Your template will also contain a set of buttons only visible to the
    article creator, which will allow the creator to delete the article or navigate
    to the `edit` route. To create the template, go to the `public/app/articles/view`
    folder and create a new file named `view.template.html`. In your new file, paste
    the following code snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: “视图”模板将为用户提供一个界面来“查看”现有文章。您的模板还将包含一组按钮，仅对文章创建者可见，这些按钮将允许创建者删除文章或导航到“编辑”路由。要创建模板，请转到`public/app/articles/view`文件夹，并创建一个名为`view.template.html`的新文件。在新文件中，粘贴以下代码片段：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `view` template contains a simple set of HTML elements presenting the article
    information using the `double curly braces` syntax. It is also important to note
    how you used the `ngIf` directive to present the article edit link and delete
    button only to the creator of the article. The edit link will direct the user
    to the `edit` subcomponent, while the delete button will call the `delete()` method
    of your controller. Next, we'll implement our edit component.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`view`模板包含一组简单的HTML元素，使用`双大括号`语法呈现文章信息。还要注意您如何使用`ngIf`指令，仅向文章的创建者呈现文章编辑链接和删除按钮。编辑链接将引导用户到`edit`子组件，而删除按钮将调用您的控制器的`delete()`方法。接下来，我们将实现我们的编辑组件。'
- en: Implementing the Edit subcomponent
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现编辑子组件
- en: 'Our "Edit" subcomponent will be taking care of editing existing articles. Begin
    by creating a new folder named `edit` inside your `public/app/articles` folder.
    In this folder, create a new file named `edit.component.ts` and paste the following
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“编辑”子组件将负责编辑现有文章。首先，在`public/app/articles`文件夹内创建一个名为`edit`的新文件夹。在这个文件夹中，创建一个名为`edit.component.ts`的新文件，并粘贴以下代码：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, we started by importing the modules we need from the Angular library
    along with our `ArticlesService`. Then, we created our component with an article
    property and an `errorMessage` property. In our constructor, we read the `article
    ID` from the route parameters and then we used `ArticlesService` to fetch an existing
    article. In our Observables subscription, we set the component's article property,
    and in case of an error, we use the `Router` service to navigate back to our List
    route. Lastly, we implemented an `update()` method that uses `ArticlesService`
    to update the viewed article and go back to the View route. To finish up with
    our subcomponent, we'll need to create its template.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们从Angular库中导入我们需要的模块以及我们的`ArticlesService`。然后，我们创建了一个具有文章属性和`errorMessage`属性的组件。在我们的构造函数中，我们从路由参数中读取`文章ID`，然后使用`ArticlesService`来获取现有的文章。在我们的Observable订阅中，我们设置了组件的文章属性，并在出现错误时，我们使用`Router`服务来导航回到我们的List路由。最后，我们实现了一个`update()`方法，该方法使用`ArticlesService`来更新查看的文章并返回到View路由。要完成我们的子组件，我们需要创建它的模板。
- en: Adding the template
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加模板
- en: 'The `edit` template will provide your user with an interface to update an existing
    article. It will contain an HTML form and it will use your component''s `update()`
    method to save the updated article. To create this template, go to the `public/app/articles/edit`
    folder and create a new file named `edit.template.html`. In your new file, paste
    the following HTML code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit` 模板将为用户提供一个界面来更新现有文章。它将包含一个 HTML 表单，并使用你的组件的 `update()` 方法来保存更新后的文章。要创建这个模板，转到
    `public/app/articles/edit` 文件夹并创建一个名为 `edit.template.html` 的新文件。在你的新文件中，粘贴以下 HTML
    代码：'
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `edit` template contains a simple form with two text input fields and a
    submit button. The text fields use the `ngModel` directive to bind the user input
    to the component's `article` property. It is also important to note the `ngSubmit`
    directive you placed in the `form` element. This time, the directive tells Angular
    that the form submission should execute your component's `update()` method. The
    last thing you should notice is the error message at the end of the form, which
    will be shown in the case of an editing error. Our final subcomponent is our List
    subcomponent.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit` 模板包含一个简单的表单，其中有两个文本输入字段和一个提交按钮。文本字段使用 `ngModel` 指令将用户输入绑定到组件的 `article`
    属性。还要注意在 `form` 元素中放置的 `ngSubmit` 指令。这次，该指令告诉 Angular 表单提交应执行组件的 `update()` 方法。你应该注意到的最后一件事是表单末尾的错误消息，在编辑错误的情况下会显示出来。我们的最终子组件是我们的
    List 子组件。'
- en: Implementing the List subcomponent
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 List 子组件
- en: 'Our "List" subcomponent will be taking care of presenting a list of articles.
    We''ll begin by creating a new folder named `list` inside our `public/app/articles`
    folder. In this folder, create a new file named `list.component.ts` and paste
    the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 "List" 子组件将负责呈现文章列表。我们将首先在 `public/app/articles` 文件夹内创建一个名为 `list` 的新文件夹。在这个文件夹中，创建一个名为
    `list.component.ts` 的新文件，并粘贴以下代码：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We started by importing the modules we need from the Angular library along with
    our `ArticlesService`. Then, we created our component with an articles property
    and an `errorMessage` property. Note how our component's constructor injects `ArticlesService`
    and uses it to fetch a list of articles. Inside our Observables subscription,
    we set the component's articles property. Now all we have left to do is implement
    the component's template.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 Angular 库中导入我们需要的模块以及我们的 `ArticlesService`。然后，我们创建了一个具有 articles 属性和 errorMessage
    属性的组件。注意我们组件的构造函数如何注入 `ArticlesService` 并使用它来获取文章列表。在我们的 Observables 订阅中，我们设置了组件的
    articles 属性。现在我们只剩下实现组件的模板了。
- en: Adding the template
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加模板
- en: 'The `list` templatewill provide your user with an interface to view the list
    of existing articles. Our template will use the `ngFor` directive to render a
    list of HTML elements, each representing a single article. If there aren''t any
    existing articles, the view will offer the user to navigate to the `create` route.
    To create your view, go to the `public/app/articles/list` folder and create a
    new file named `list.template.html`. In your new file, paste the following code
    snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 模板将为用户提供一个查看现有文章列表的界面。我们的模板将使用 `ngFor` 指令来呈现一系列 HTML 元素，每个元素代表一篇文章。如果没有现有的文章，视图将提供用户导航到
    `create` 路由。要创建你的视图，转到 `public/app/articles/list` 文件夹并创建一个名为 `list.template.html`
    的新文件。在你的新文件中，粘贴以下代码片段：'
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `list` template contains a simple set of repeating HTML elements that represent
    the list of articles. It uses the `ngFor` directive to duplicate the list item
    for every article in the collection and displays each article's information. We
    then used `routerLink` to link to a single article view. It is also important
    to note how we used the `ngIf` directive to ask the user to create a new article
    in case there are no existing articles.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 模板包含一组简单的重复的 HTML 元素，代表文章列表。它使用 `ngFor` 指令为集合中的每篇文章复制列表项并显示每篇文章的信息。然后我们使用
    `routerLink` 链接到单篇文章视图。还要注意我们如何使用 `ngIf` 指令来要求用户在没有现有文章的情况下创建一篇新文章。'
- en: By implementing your Angular subcomponents, you practically finished your first
    CRUD module! All that is left to do is provide the user with links to our new
    routes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现你的 Angular 子组件，你实际上完成了你的第一个 CRUD 模块！现在剩下的就是向用户提供到我们新路由的链接。
- en: Wrapping up
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'To finish our implementation, it would be great to provide the user with links
    to your new CRUD module routes. To do that, go to your `public/app/home/home.template.html`
    file and change it, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成我们的实现，最好是向用户提供到你的新 CRUD 模块路由的链接。为此，转到你的 `public/app/home/home.template.html`
    文件并进行更改，如下所示：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This change will present our users with links to the new `Articles` component
    routes only when they''re logged in and hide it when they''re not. This is it!
    Everything is ready for you to test your new CRUD module. Use your command-line
    tool and navigate to the MEAN application''s root folder. Then, run your application:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变将只在用户登录时向用户显示到新的 `Articles` 组件路由的链接，并在用户未登录时隐藏它。就是这样！一切都准备就绪，可以测试你的新的 CRUD
    模块了。使用命令行工具导航到 MEAN 应用程序的根文件夹，然后运行你的应用程序：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once your application is running, use your browser and navigate to `http://localhost:3000`.
    You will see the sign-up and sign-in links; try to sign in and watch how the home
    view changes. Then, try to navigate to the `http://localhost:3000/articles` URL
    and see how the `list` component suggests that you create a new article. Continue
    to create a new article and try to edit and delete it using the components you
    created previously. Your CRUD module should be fully operational.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序运行时，使用浏览器导航到 `http://localhost:3000`。你会看到注册和登录链接；尝试登录并观察主页视图的变化。然后，尝试导航到
    `http://localhost:3000/articles` URL，并查看 `list` 组件如何建议你创建一个新文章。继续创建一个新文章，并尝试使用之前创建的组件编辑和删除它。你的
    CRUD 模块应该是完全可操作的。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to build your first CRUD module. You started
    by defining the Mongoose model and Express controller and learned how to implement
    each CRUD method. You also authorized your controller methods using Express middleware.
    Then, you defined a RESTful API for your module methods. You learned a bit about
    reactive programming and the observer pattern. You used the HTTP client to communicate
    with your API. Then, you created your Angular components and implemented the Angular
    CRUD functionality. After connecting the four parts of a MEAN application and
    creating your first CRUD module, in the next chapter, you'll use Socket.io in
    order to add real-time connectivity between your server and client applications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何构建您的第一个CRUD模块。您首先定义了Mongoose模型和Express控制器，并学习了如何实现每个CRUD方法。您还使用Express中间件对控制器方法进行了授权。然后，您为模块方法定义了一个RESTful
    API。您还学习了一些关于响应式编程和观察者模式的知识。您使用HTTP客户端与您的API进行通信。然后，您创建了您的Angular组件并实现了Angular
    CRUD功能。在连接MEAN应用程序的四个部分并创建您的第一个CRUD模块之后，在下一章中，您将使用Socket.io来实现服务器和客户端应用程序之间的实时连接。
