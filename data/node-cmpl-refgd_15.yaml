- en: Restful API Design Guidelines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Restful API设计指南
- en: In the previous chapter, we implemented a catalog module that exposed functions
    for data manipulation for the items in the catalog application. These functions
    made use of the `express.js` **request** object to parse the incoming data in
    the body and then to carry out the appropriate database operation. Each function
    populated the **response** object with a relevant status code and response body
    payload, if needed. Finally, we bound each function to a route, accepting HTTP
    requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了一个目录模块，该模块公开了目录应用程序中项目的数据操作功能。这些函数使用`express.js`的**请求**对象解析请求体中的数据，然后执行适当的数据库操作。每个函数根据需要使用相关状态码和响应体有效载荷填充**响应**对象。最后，我们将每个函数绑定到一个路由，接受HTTP请求。
- en: Now, it's time to look closer into the URLs of the routes and into the returned
    HTTP status codes per operation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更深入地研究路由的URL和每个操作返回的HTTP状态码了。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Endpoint URLs and HTTP status codes best practices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点URL和HTTP状态码最佳实践
- en: Extensibility and versioning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性和版本控制
- en: Linked data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接数据
- en: Endpoint URLs and HTTP status codes best practices
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端点URL和HTTP状态码最佳实践
- en: Each RESTful API operation is a combination of an HTTP request against a URL
    and an appropriate HTTP method.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个RESTful API操作都是对URL发起的HTTP请求和适当的HTTP方法的组合。
- en: When executed, each operation will return a status code, indicating whether
    the invocation has been successful or not. Successful invocation is indicated
    by a HTTP 2XX status code, while operations that are not executed correctly indicate
    this with erroneous status code—4XX if the error is at client side, or 5xx when
    the server fails to process a valid request.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行操作时，每个操作将返回一个状态码，指示调用是否成功。成功的调用通过HTTP 2XX状态码表示，而未正确执行的调用则通过错误状态码表示——如果错误在客户端，则为4XX，如果服务器无法处理有效请求，则为5xx。
- en: Having a well-specified API is vital for its adoption. Such specification should
    not only completely enumerate the status codes of each operation, but should also
    specify the expected data format, that is, its supported media types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个明确指定的API对于其采用至关重要。此类规范不仅应完全列出每个操作的状态码，还应指定预期的数据格式，即其支持的媒体类型。
- en: 'The following table defines how the Express.js Router will expose the API operations,
    and it should serve as a reference specification for it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格定义了Express.js Router将如何公开API操作，并应作为其参考规范：
- en: '| Method | URI | Media type | Description | Status Code |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | URI | 媒体类型 | 描述 | 状态码 |'
- en: '| GET | /catalog | application/json | Returns all the items in the catalog.
    | 200 OK500 Internal Server Error |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| GET | /catalog | application/json | 返回目录中的所有项目。 | 200 OK500 内部服务器错误 |'
- en: '| GET | /catalog/{categoryId} | application/json | Returns all items for the
    selected category. If the category does not exist, it returns 404. | 200 OK,404
    NOT FOUND500 Internal Server Error |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| GET | /catalog/{categoryId} | application/json | 返回所选类别的所有项目。如果该类别不存在，则返回404。
    | 200 OK,404 NOT FOUND500 内部服务器错误 |'
- en: '| GET | /item/{itemId} | application/json | Returns a single item for the selected
    itemId. If there is no such item, it returns 404. | 200 OK,404 NOT FOUND500 Internal
    Server Error |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| GET | /item/{itemId} | application/json | 返回所选itemId的单个项目。如果没有这样的项目，则返回404。
    | 200 OK,404 NOT FOUND500 内部服务器错误 |'
- en: '| POST | /item/ | application/json | Creates a new item; if an item with the
    same identifier exists, it will be updated. When an item is created, a **Location**
    header is returned. It provides the URL where the newly created item can be accessed.
    | 201 Created200 OK500 Internal Server Error |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| POST | /item/ | application/json | 创建新项目；如果存在具有相同标识符的项目，则将其更新。当创建项目时，返回一个**Location**头。它提供了可以访问新创建项目的URL。
    | 201 已创建200 OK500 内部服务器错误 |'
- en: '| PUT | /item/{itemId} | application/json | Updates an existing item; if an
    item with the provided identifier does not exist, it creates it. When an item
    is created, a **Location** header is returned. It provides the URL where the newly
    created item can be accessed. | 201 Created200 OK500 Internal Server Error |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| PUT | /item/{itemId} | application/json | 更新现有项目；如果提供的标识符不存在，则创建它。当创建项目时，返回一个**Location**头。它提供了可以访问新创建项目的URL。
    | 201 已创建200 OK500 内部服务器错误 |'
- en: '| DELETE | /item/{itemId} | application/json | Deletes an existing item; if
    an item with the provided identifier does not exist, it returns 404. | 200 OK,404
    NOT FOUND500 Internal Server Error |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | /item/{itemId} | application/json | 删除现有项目；如果提供的标识符的项目不存在，则返回404。
    | 200 OK, 404 NOT FOUND, 500 Internal Server Error |'
- en: 'The catalog application handles two types of entities: items and categories.
    Each item entity contains a collection of categories where it belongs. As you
    can see, the category is just a logical entity in our application; it will exist
    as long as there is at least one item referencing it, and will cease to exist
    when no items refer it. This is why the application exposes routes for exposing
    data manipulation functions only for resources of type items, while the operations
    for categories are more or less read only. Looking more carefully into the URLs
    exposing the data manipulation operations for the items, we can see a clear pattern
    aligning the URL to the REST fundamental principles—a resource is exposed by a
    single URL, and it supports resource manipulation actions that are determined
    by the HTTP method of the request. To sum up, listed here are the generally accepted
    rules that a well-defined API should follow. They are semantically related to
    each resource manipulation operation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目录应用程序处理两种类型的实体：项目和类别。每个项目实体包含一个属于它的类别集合。正如您所看到的，类别在我们的应用程序中只是一个逻辑实体；只要至少有一个项目引用它，它就会存在，当没有项目引用它时，它将不再存在。这就是为什么应用程序只为类型为项目的资源暴露数据操作路由，而类别的操作更多或更少是只读的。更仔细地查看暴露项目数据操作URL，我们可以看到与REST基本原理相一致的一个清晰模式——一个资源通过单个URL暴露，并且它支持由请求的HTTP方法确定的资源操作。总的来说，以下是良好定义的API应遵循的通常接受的规则。它们与每个资源操作在语义上是相关的：
- en: When a **new** resource is created, the service makes use of the **201 Created** status
    code, followed by a location header that specifies the URL where the newly created
    resource can be accessed.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建一个**新**资源时，服务使用**201 已创建**状态码，后跟一个位置头，指定新创建的资源可以访问的URL。
- en: Operation that creates resources may be implemented to gracefully reject creation
    of resources, which unique identifiers already use; in such cases, the operation
    should indicate a non-successful invocation with an appropriate status code **409
    Conflict**, or a more general **400 BAD REQUEST**. However, a general status code
    should always be followed by a meaningful explanation of what has gone wrong.
    In our implementation, we choose a different approach—we update the resource from
    the create operation, if it exists, and notify the caller that the resource was
    updated by returning the **200 OK** status code instead of **201 Created**.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建资源的操作可以实施以优雅地拒绝创建已使用唯一标识符的资源；在这种情况下，操作应使用适当的**409 冲突**状态码或更通用的**400 错误请求**来指示非成功调用。然而，通用状态码始终应后跟一个有意义的错误解释。在我们的实现中，我们选择了一种不同的方法——如果存在，我们从创建操作更新资源，并通过返回**200
    OK**状态码而不是**201 已创建**来通知调用者资源已被更新。
- en: The **Update** operation resembles the create operation; however, it always
    expects a resource identifier as a parameter, if a resource with this identifier
    exists—it gets updated with a new state provided in the body of the HTTP PUT request.
    The **200 OK** status code indicates successful invocation. The implementation
    may decide to reject handling of non-existent resources with the **404 Not Found** status
    code or creating a new resource with the passed identifier. In that case, it would
    return the **201 Created** status code, followed by a location header that specifies
    the URL where the newly created resource can be accessed. Our API makes use of
    the second option.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**操作类似于创建操作；然而，它始终期望一个资源标识符作为参数，如果具有此标识符的资源存在，它将使用HTTP PUT请求正文中提供的新状态更新。**200
    OK**状态码表示成功调用。实现可能决定使用**404 Not Found**状态码拒绝处理不存在的资源，或者使用传递的标识符创建新资源。在这种情况下，它将返回**201
    已创建**状态码，后跟一个位置头，指定新创建的资源可以访问的URL。我们的API使用第二种选项。'
- en: 'While successful **deletion **can be indicated with the **204 No Content** status and
    further payload, most user agents would expect the **2xx** HTTP status to be followed
    by a body. Thus, to stay compatible with most of the agents, our API will indicate
    successful deletion with the **200 OK** status code, followed by a JSON payload:`{''Status'':
    ''Successfully deleted''}`. Status code **404 Not found** will indicate that a
    resource with the provided identifier does not exist.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '虽然**删除**可以通过**204 No Content**状态和进一步的负载来表示，但大多数用户代理会期望**2xx** HTTP状态后面跟着一个体。因此，为了与大多数代理保持兼容，我们的API将使用**200
    OK**状态码来表示成功的删除，后面跟着一个JSON负载：`{''Status'': ''Successfully deleted''}`。状态码**404
    Not found**将表示提供的标识符不存在。'
- en: As a general rule, **5XX** should not indicate application state errors but
    more severe errors, such as application server or database failures.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据一般规则，**5XX**不应表示应用程序状态错误，而应表示更严重的错误，例如应用程序服务器或数据库故障。
- en: It is best practice that `update` and `create` operations should return as a
    payload to the entire state of the resource. For instance, if a resource is created
    with a minimum set of attributes, all non specified attribute will get default
    values; the response body should contain the full state of the object. The same
    is valid for updates; even if an update operation updates the resource restate
    partially, the response should return the complete state. This may save the user-agent
    an additional GET request if they needed to check the new state.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践是`update`和`create`操作应返回资源的整个状态作为有效载荷。例如，如果一个资源使用最小属性集创建，所有未指定的属性将获得默认值；响应体应包含对象的完整状态。对于更新也是如此；即使更新操作只部分更新资源状态，响应也应返回完整状态。这可能会在用户代理需要检查新状态时节省额外的GET请求。
- en: Now that we have defined some general recommendations on how operations should
    behave, it's time to implement them in a new version of the API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一些关于操作应该如何表现的一般性建议，现在是时候在API的新版本中实现它们了。
- en: Discovering and exploring RESTful services
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现和探索RESTful服务
- en: The topic of discovering RESTful services has a long and complicated history.
    The HTTP specification states that a resource should be self-descriptive and that
    it should be identified uniquely by a URI. Dependent resources should be linked
    by the dependency using their own unique URIs. Discovering a RESTful service means
    navigating from one service to another, following the links it provides.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 发现RESTful服务的话题有一个漫长而复杂的历史。HTTP规范指出，资源应该是自描述的，并且应该由URI唯一标识。依赖资源应通过使用它们自己的唯一URI来链接依赖关系。发现RESTful服务意味着从一个服务导航到另一个服务，遵循它提供的链接。
- en: In the year 2009, a specification called **Web Application Discovery Language**
    (**WADL**) was invented. It aims to document every URI exposed from a web application,
    along with the HTTP methods it supports and the parameter it expects. The response
    media type of the URI is also described. This is very useful for documenting purposes,
    and it's all that a WADL file can provide us in terms of RESTful service provisioning.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在2009年，一个名为**Web Application Discovery Language**（WADL）的规范被发明出来。它的目的是记录从Web应用程序暴露的每个URI，以及它支持的HTTP方法和它期望的参数。URI的响应媒体类型也被描述。这对于文档目的非常有用，这就是WADL文件在RESTful服务提供方面能为我们提供的一切。
- en: Unfortunately, there is currently no Node.js module that can automatically generate
    a WADL file for a given express route. We will have to manually create a WADL
    file to demonstrate how it is used by other clients for discovery.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前还没有Node.js模块可以自动为给定的express路由生成WADL文件。我们将不得不手动创建一个WADL文件来演示它是如何被其他客户端用于发现的。
- en: 'The following listing shows a sample WADL file describing the resources available
    at `/catalog, /catalog/v2/{categoryId}`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了一个示例WADL文件，描述了在`/catalog`、`/catalog/v2/{categoryId}`可用的资源：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the WADL format is very straightforward. It basically describes
    the URI of each resource, providing information about the media types it uses
    and the status codes that are expected at that URI. Many third-party RESTful clients
    understand the WADL language and can generate request messages out of a given
    WADL file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，WADL格式非常简单直接。它基本上描述了每个资源的URI，提供了它使用的媒体类型和在该URI上预期的状态码信息。许多第三方RESTful客户端理解WADL语言，并可以从给定的WADL文件中生成请求消息。
- en: 'Let''s import the WADL file in Postman. Click on the Import button and select
    your WADL file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Postman中导入WADL文件。点击导入按钮，并选择您的WADL文件：
- en: '![](img/6d8accb0-6e40-4112-ac97-769cdac28d1d.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d8accb0-6e40-4112-ac97-769cdac28d1d.png)'
- en: Import a WADL in Postman to get a stub of the service. This is a screenshot
    for Postman. The individual settings are not important here. The purpose of the
    image is just to show how the window looks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Postman 中导入 WADL 文件以获取服务的存根。这是 Postman 的屏幕截图。这里的个人设置并不重要。图片的目的只是展示窗口的外观。
- en: As you can see, the result of importing the WADL file is that we have a project
    ready to test each aspect of a REST service in the nick of time. All the routes
    defined in the WADL file are now conveniently available as separate request entities
    on the right menu. That's not all; apart from the WADL standard, currently the
    swagger documentation format is heavily adopted and has become an informal standard
    for describing RESTful services, so we can also use it to ease the adoption and
    discovery of our service. In the next chapter, we will bind these description
    files to our service. This is an important step in the phase of production preparation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，导入 WADL 文件的结果是我们有一个项目可以及时测试 REST 服务的各个方面。WADL 文件中定义的所有路由现在都方便地作为右侧菜单上的单独请求实体可用。不仅如此；除了
    WADL 标准，目前 Swagger 文档格式被广泛采用，并已成为描述 RESTful 服务的非正式标准，因此我们也可以用它来简化服务的采用和发现。在下一章中，我们将将这些描述文件绑定到我们的服务上。这是生产准备阶段的一个重要步骤。
- en: Extensibility and versioning
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性和版本控制
- en: We've already defined a few basic versioning rules in [Chapter 13](8e04f868-a684-41a0-aed1-bbff8b9c5c2e.xhtml),
    *Building a Typical Web API*. Let's apply them to the MongoDB database-aware module
    we implemented in the previous chapter. Our starting point would be to enable
    the current consumers of the API to continue using the same version on a different
    URL. This will keep them backward-compatible until they adopt and successfully
    test the new version.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 13 章](8e04f868-a684-41a0-aed1-bbff8b9c5c2e.xhtml) 中定义了一些基本的版本控制规则，*构建典型的
    Web API*。现在让我们将这些规则应用到我们在上一章中实现的 MongoDB 数据库感知模块中。我们的起点将是使当前 API 的消费者能够继续在新的 URL
    上使用相同的版本。这将保持向后兼容，直到他们成功采用并测试新版本。
- en: 'Keeping a REST API stable is not a question of only moving one endpoint from
    one URI to another. It makes no sense to perform redirection and afterward have
    an API that behaves differently. Thus, we need to ensure that the behavior of
    the moved endpoint stays the same. To ensure that we don''t change the previously
    implemented behavior, let''s move the current behavior from the `catalog.js` module
    to a new module by renaming the file to `catalogV1.js`. Then, make a copy of it
    to the  `catalogV2.js` module, where we will introduce all new functionality;
    but before doing that, we have to reroute Version 1 from `/, /{categoryId}, /{itemId}`
    to `/v1, /v1/{categoryId}, /v1/{itemId}`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 REST API 的稳定性不仅仅是将一个端点从一个 URI 移动到另一个 URI。执行重定向然后有一个行为不同的 API 是没有意义的。因此，我们需要确保移动的端点的行为保持不变。为了确保我们不改变之前实现的行为，让我们将当前的行为从
    `catalog.js` 模块移动到一个新的模块，通过将文件重命名为 `catalogV1.js`。然后，将其复制到 `catalogV2.js` 模块，在那里我们将引入所有新的功能；但在做之前，我们必须将版本
    1 从 `/`, `/{categoryId}`, `/{itemId}` 重定向到 `/v1`, `/v1/{categoryId}`, `/v1/{itemId}`：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since Version 2 of our API is not yet implemented, executing a `GET` request
    against `/` will result in receiving a `301 Moved Permanently` HTTP status, which
    will then redirect to `/v1/`. This will notify our consumers that the API is evolving
    and that they will soon need to decide whether to continue using Version 1 by
    explicitly requesting its new URI or prepare for adopting Version 2.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 API 的版本 2 尚未实现，对 `/` 的 `GET` 请求将导致收到 `301 永久移动` HTTP 状态，然后重定向到 `/v1/`。这将通知我们的消费者
    API 正在演变，他们很快需要决定是否通过显式请求其新 URI 继续使用版本 1，或者为采用版本 2 做准备。
- en: 'Go ahead and give it a try! Start the modified node application and, from Postman,
    make a GET request to `http://localhost:3000/catalog`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下！启动修改后的节点应用程序，并从 Postman 发送一个 GET 请求到 `http://localhost:3000/catalog`：
- en: '![](img/d5c50d84-3651-4d71-a52a-95d01d81602c.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5c50d84-3651-4d71-a52a-95d01d81602c.png)'
- en: You will see that your request is redirected to the newly routed location at `http://localhost:3000/catalog/v1`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到您的请求被重定向到新的路由位置 `http://localhost:3000/catalog/v1`。
- en: Now that we have finalized Version 1 of the catalog, it's time to think of further
    extensions that we can add in Version 2\. Currently, the catalog service supports
    listing of all items in a category and fetching an item by its ID. It's about
    time to take full advantage of MongoDB, being a document-oriented database, and
    implement a function that will enable our API consumer to query for items based
    on any of their attributes. For instance, list all items for a specific category
    with an attribute that matches a query parameter, such as price or color, or search
    by item name. RESTful services usually expose document-oriented data. However,
    their usage is not limited to documents only. In the next chapter, we will extend
    the catalog in a way that it also stores binary data—an image that can be linked
    to each item. For that purpose, we will use a MongoDB binary format called **Binary
    JSON** (**BSON**) in the *Working with arbitrary data* section in [Chapter 16](92c4bc26-7983-4f36-b220-055f81dca007.xhtml),
    *Implementing a Full Fledged RESTful Service*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了目录的版本1，是时候考虑在版本2中添加的进一步扩展了。目前，目录服务支持列出类别中的所有项目以及通过其ID获取项目。现在是时候充分利用文档数据库MongoDB并实现一个函数，使我们的API消费者能够根据其任何属性查询项目。例如，列出具有与查询参数（如价格或颜色）匹配的属性的特定类别的所有项目，或按项目名称搜索。RESTful服务通常公开面向文档的数据。然而，它们的用途不仅限于文档。在下一章中，我们将以这种方式扩展目录，使其也能够存储与每个项目链接的二进制数据——一张图片。为此，我们将在[第16章](92c4bc26-7983-4f36-b220-055f81dca007.xhtml)的*处理任意数据*部分使用MongoDB的二进制格式**Binary
    JSON**（**BSON**）。
- en: 'Getting back to the searching extension, we''ve already used the `Mongoose.js`
    model''s `find()` and `findOne()` functions. So far, we used them to provide the
    name of the document attribute to be searched with, statically, in our JavaScript
    code. However, this filtering parameter of `find()` is just a JSON object where
    the key is the document attribute and the value is the attribute''s value to be
    used in the query. Here is the first new function we will add to Version 2\. It
    queries MongoDB by an arbitrary attribute and its value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 回到搜索扩展，我们已经使用了`Mongoose.js`模型的`find()`和`findOne()`函数。到目前为止，我们使用它们在JavaScript代码中以静态方式提供要搜索的文档属性的名称。然而，`find()`的此过滤参数只是一个JSON对象，其中键是文档属性，值是用于查询的属性值。这是我们将在版本2中添加的第一个新函数。它通过任意属性及其值查询MongoDB：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function calls find on the model with the provided attribute and value
    as parameters. We will bind this function to the router's `/v2/item/` GET handler.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用提供的属性和值作为参数在模型上调用find。我们将此函数绑定到路由器的`/v2/item/` GET处理器。
- en: At the end, our aim is to have `/v2/item/?currency=USD` that returns only records
    for items that are sold in USD currency, as indicated by the value of the passed
    GET parameter. That way, if we modify the model with additional attributes, such
    as color and size, we can query for all items having the same color or any other
    attribute that an item can have.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的目标是实现`/v2/item/?currency=USD`，它只返回以美元货币出售的项目的记录，正如传递的GET参数的值所指示的。这样，如果我们修改模型以添加额外的属性，例如颜色和大小，我们就可以查询具有相同颜色或任何其他属性的所有项目。
- en: 'We will keep the old behavior of returning a list of all available items when
    no parameters are provided within the query string, but we will also parse the
    query string for the first provided `GET` parameter and use it as a filter in
    the `findItemsByAttribute()` function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询字符串中没有提供参数时，我们将保持返回所有可用项目的旧行为，但我们将解析第一个提供的`GET`参数并将其用作`findItemsByAttribute()`函数中的过滤器：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Perhaps the most interesting part in this function is the URL parsing. As you
    can see, we keep using the same old strategy to check whether any `GET` parameters
    are supplied. We parse the URL in order to get the query string, and then we use
    the built-in `Object.keys` function to check whether the parsed key/value list
    contains elements. If it does, we take the first element and extract its value.
    Both the key and the value are passed to the `findByAttribute` function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，最有趣的部分可能是URL解析。如您所见，我们继续使用相同的老策略来检查是否提供了任何`GET`参数。我们解析URL以获取查询字符串，然后使用内置的`Object.keys`函数检查解析后的键/值列表是否包含元素。如果包含，我们取第一个元素并提取其值。键和值都传递给`findByAttribute`函数。
- en: You may want to improve Version 2 further by providing search support by multiple
    arguments that are provided by more than one `GET` parameters. I will leave that
    to you as an exercise.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望通过提供由多个`GET`参数提供的多个参数来进一步改进版本2，以提供搜索支持。我将把这个留给你作为练习。
- en: Linked data
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接数据
- en: 'Every catalog application supports an image or set of images bound to this
    item. For that purpose, in the next chapter, we will see how to work with binary
    objects in MongoDB. However, now is the time to decide how to semantically link
    the binary data to an item document. Extending the model schema in such a way
    that it contains binary base64 representation of binary data in the document is
    anything but a good idea, as mixing literally encoded and binary data in one format
    is never a good idea. It increases the complexity of the application and makes
    it error-prone:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录应用程序都支持与该项目绑定的图片或图片集。为此，在下一章中，我们将看到如何与MongoDB中的二进制对象一起工作。然而，现在是决定如何将二进制数据语义链接到项目文档的时候了。以这种方式扩展模型模式，使其包含文档中二进制数据的base64表示，绝对不是一个好主意，因为将文本编码和二进制数据混合在一个格式中从来都不是一个好主意。这增加了应用程序的复杂性，并使其容易出错：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Imagine how large a result for a non-filtered query can become just for a few
    hundred items, if all of them had an image binary representation as a value of
    a JSON attribute. To avoid that, we will return the image for each item at a URL
    that is logically linked to the resource's URL—`/catalog/v2/item/{itemId}/image`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，对于一个非过滤查询的结果可以有多大，如果只有几百个项目，并且所有这些项目都将图片的二进制表示作为JSON属性的值。为了避免这种情况，我们将为每个项目返回图片，图片的URL逻辑上链接到资源的URL——`/catalog/v2/item/{itemId}/image`。
- en: 'That way, if there is an image assigned to an item, it will be served at a
    known location. This approach, however, does not semantically link the binary
    item to its corresponding resource, as when accessing the item at `/catalog/v2/item/{itemId}`,
    there would be no indication of whether it has an image assigned or not. To solve
    this, let''s use a custom HTTP header in response of the item route:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果某个项目分配了图片，它将在一个已知的位置被提供。然而，这种方法并没有在语义上将二进制项目与其对应的资源链接起来，就像在访问`/catalog/v2/item/{itemId}`时，没有任何指示表明它是否分配了图片。为了解决这个问题，让我们在项目路由的响应中使用一个自定义的HTTP头：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When present in the response, the `Image-Url` header indicates that the item
    has an additional resource bound to it, and the header value provides the address
    where it is available. Using this approach, we linked a binary resource semantically to
    our document.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应中存在时，`Image-Url`头指示该项目绑定了一个额外的资源，并且头部的值提供了它可用的地址。使用这种方法，我们将二进制资源在语义上链接到了我们的文档中。
- en: In the next chapter, we will implement the routes that will handle the manipulation
    of arbitrary items bound to the items in the catalog.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现处理与目录中项目绑定的任意项目操作的路线。
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed in detail how resources should be exposed via
    a RESTful API; we paid close attention to URL best practices and looked into appropriate
    usage of the HTTP status codes indicating each state of our operations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了如何通过RESTful API公开资源；我们密切关注URL最佳实践，并研究了HTTP状态码的适当使用，这些状态码表示我们操作的各种状态。
- en: We covered the topics of versioning and extensibility, where we used the `301
    Moved Permanently` status code to automatically redirect API calls to different
    URLs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了版本控制和可扩展性的主题，其中我们使用了`301 Moved Permanently`状态码来自动将API调用重定向到不同的URL。
- en: Finally, we figured out how to semantically link our resource items to arbitrary
    binary represented data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们找到了如何将我们的资源项目与任意二进制表示的数据进行语义链接的方法。
