- en: Introducing MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MongoDB
- en: The name MongoDB comes from the phrase huMONGOus data, meaning that it can handle
    a lot of data. MongoDB is a document-oriented database architecture. It enables
    us to develop faster and scale better. In relational database designs, we store
    data by creating tables and rows, but with MongoDB, we can model our data as JSON
    documents, which is much simpler compared to those relational databases. If we
    are agile and our requirements keep changing very often, and if we need to do
    continuous deployment, then MongoDB is our choice. Being a document-based data
    model, MongoDB is very flexible as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的名称来源于huMONGOus数据一词，意思是它可以处理大量数据。MongoDB是一种面向文档的数据库架构。它使我们能够更快地开发和扩展。在关系数据库设计中，我们通过创建表和行来存储数据，但是使用MongoDB，我们可以将数据建模为JSON文档，这与关系数据库相比要简单得多。如果我们灵活并且需求经常变化，并且需要进行持续部署，那么MongoDB就是我们的选择。作为基于文档的数据模型，MongoDB也非常灵活。
- en: The biggest advantage of using MongoDB is that the data is unstructured. We
    can customize our data in any format we like. In a **relational database management
    system** (**RDBMS**), we have to define exactly the number of fields a table can
    have, but with MongoDB, each document can have its own number of fields. We can
    add new data without even having to worry about changing the schema, which is
    why Mongo has a **schemaless design model** for the database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB的最大优势是数据是非结构化的。我们可以按任何格式自定义我们的数据。在关系数据库管理系统中，我们必须精确定义表可以拥有的字段数量，但是使用MongoDB，每个文档可以拥有自己的字段数量。我们甚至可以添加新数据，而不必担心更改模式，这就是为什么Mongo对数据库采用了**无模式设计模型**。
- en: If our business is growing fast, we need to scale faster, we need to access
    data in a more flexible way, and if we need to make changes to our data without
    having to worry about updating our application's database schemas, then MongoDB
    is the best choice for us. Adding new columns to tables in RDBMS also creates
    some performance issues. But, since MongoDB is schemaless, adding new fields is
    done in an instant without compromising the performance of our application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的业务增长迅速，我们需要更快地扩展，我们需要以更灵活的方式访问数据，如果我们需要对数据进行更改而不必担心更新应用程序的数据库模式，那么MongoDB是我们的最佳选择。在关系数据库管理系统中添加新列也会导致一些性能问题。但是，由于MongoDB是无模式的，添加新字段可以立即完成，而不会影响我们应用程序的性能。
- en: In a relational database, the terminologies that we use are **database**, **tables**,
    and **rows**, whereas in MongoDB, we use **database**, **collections**, and **documents**,
    respectively.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，我们使用的术语是**数据库**、**表**和**行**，而在MongoDB中，我们分别使用**数据库**、**集合**和**文档**。
- en: 'Here is a brief summary of what we will be covering in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章节将涵盖的内容的简要总结：
- en: Introducing to MongoDB and the benefits of using MongoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍MongoDB以及使用MongoDB的好处
- en: Understanding the MongoDB database, collections, and documents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解MongoDB数据库、集合和文档
- en: Introducing to Mongoose, creating a connection with Mongoose, understanding
    Mongoose, and CRUD operations with Mongoose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Mongoose，创建与Mongoose的连接，理解Mongoose以及使用Mongoose进行CRUD操作
- en: Adding default and custom validations with Mongoose
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mongoose添加默认和自定义验证
- en: Why MongoDB?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择MongoDB？
- en: 'MongoDB provides a lot of advantages, some of which are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB提供了许多优势，其中一些是：
- en: '**Flexible documents**: A MongoDB collection holds several documents. Each
    document under one collection can have variable field names and can have a different
    size as well, which means we don''t have to define the schema.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的文档**：MongoDB集合包含多个文档。每个集合下的文档可以具有可变的字段名称，也可以具有不同的大小，这意味着我们不必定义模式。'
- en: '**No complex relationships**: The documents in MongoDB are stored as JSON documents,
    which means we no longer have to scratch our head learning about the relationships
    between various components of the application.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有复杂的关系**：MongoDB中的文档存储为JSON文档，这意味着我们不再需要费心学习应用程序各个组件之间的关系。'
- en: '**Easy to scale**: MongoDB is easy to scale as it minimizes the database size
    by using a partitioning method called sharding. Sharding is a database partitioning
    method that allows us to segregate a large database into smaller pieces.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于扩展**：MongoDB易于扩展，因为它通过使用一种称为分片的分区方法来最小化数据库大小。分片是一种数据库分区方法，允许我们将大型数据库分隔成较小的部分。'
- en: MongoDB queries
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB查询
- en: We did quickly review what Mongo queries look like in [Chapter 1](d95a8844-6413-49ed-8d4a-9607cb550211.xhtml), *Introduction
    to MEVN*. Here, we will dive deep into these queries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](d95a8844-6413-49ed-8d4a-9607cb550211.xhtml)中快速回顾了Mongo查询的外观。在这里，我们将深入研究这些查询。
- en: 'The first thing we need to do is start the MongoDB server. We can do that with
    this command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是启动MongoDB服务器。我们可以使用以下命令来做到这一点：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's open the mongo shell by typing `mongo` in our Terminal. When we enter
    the mongo shell, to display the list of databases, we type `show dbs`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在终端中输入`mongo`来打开mongo shell。当我们进入mongo shell时，要显示数据库列表，我们输入`show dbs`。
- en: 'If you see the database in the list, type `use {database_name}` to start using
    this database. If we haven''t created our database yet, just using `use {database_name}`
    will create a database for us. It''s as simple as that. For this exercise, let''s
    create a database called `mongo_test_queries`. So for that, we need to use:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在列表中看到数据库，请输入`use {database_name}`来开始使用该数据库。如果我们还没有创建我们的数据库，只需使用`use {database_name}`就会为我们创建一个数据库。就是这么简单。在这个练习中，让我们创建一个名为`mongo_test_queries`的数据库。为此，我们需要使用：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This should output the following in the Terminal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在终端中输出以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, once we enter the database, the first thing that we need is a collection.
    We have a database but there are no collections. The best way to create a collection
    in MongoDB is by inserting a document. This not only initializes a collection
    but also adds the document to that collection. Simple as that. Now, let's move
    on to Mongo queries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们进入数据库，我们需要的第一件事是一个集合。我们有一个数据库，但没有集合。在MongoDB中创建集合的最佳方法是通过插入文档。这不仅初始化了一个集合，还将文档添加到该集合中。就是这么简单。现在，让我们继续进行Mongo查询。
- en: Creating documents
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文档
- en: There are different queries to create a document in MongoDB, such as `insertOne()`,
    `insertMany()`, and `insert()`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中有不同的查询来创建文档，例如`insertOne()`，`insertMany()`和`insert()`。
- en: insertOne()
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: insertOne()
- en: 'The `insertOne()` command adds a single document to our collection. For example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertOne()`命令将单个文档添加到我们的集合中。例如：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command takes only a single parameter, which is an object, and we can
    pass the field names and values we want for our `users` collection. When we run
    the preceding code in our Terminal inside the Mongo shell, we should get the following
    output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令仅接受一个参数，即对象，我们可以传递我们想要的`users`集合的字段名称和值。当我们在Mongo shell中的终端中运行上述代码时，我们应该得到以下输出：
- en: '![](img/91f27147-b1ee-4f8f-9121-a09b3d2a3c84.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91f27147-b1ee-4f8f-9121-a09b3d2a3c84.png)'
- en: It returns the `_id` of the document that just got created. We have successfully
    created a collection and a document in the `users` collection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回刚刚创建的文档的`_id`。我们已成功在`users`集合中创建了一个集合和一个文档。
- en: The `insertOne()` and `insertMany()` commands only work for Mongo version 3.2
    or higher.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertOne()`和`insertMany()`命令仅适用于Mongo版本3.2或更高版本。'
- en: insertMany()
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: insertMany()
- en: 'This command is used for inserting multiple documents into a collection. In
    the preceding example, we saw that the `insertOne()` command takes an argument
    that is an object. The `insertMany()` command takes an array as a parameter so
    that we can pass multiple objects inside it and insert multiple documents in the
    collection. Let''s look at an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于将多个文档插入到集合中。在前面的示例中，我们看到`insertOne()`命令接受一个对象作为参数。`insertMany()`命令接受一个数组作为参数，以便我们可以在其中传递多个对象并在集合中插入多个文档。让我们看一个例子：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This snippet creates three documents in the `users` collection. When we run
    the command, the output should be:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此片段在`users`集合中创建了三个文档。当我们运行命令时，输出应该是：
- en: '![](img/2a0b35a8-6ce9-4aea-a11d-92c82bda78cf.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a0b35a8-6ce9-4aea-a11d-92c82bda78cf.png)'
- en: insert()
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'insert() '
- en: 'This command inserts single as well as multiple documents into a collection.
    It does the job of both the `insertOne()` and the `insertMany()` commands. To
    insert a single document, we can use:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将单个文档以及多个文档插入到集合中。它可以执行`insertOne()`和`insertMany()`命令的工作。要插入单个文档，我们可以使用：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the command is executed successfully, we should see the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令成功执行，我们应该看到以下输出：
- en: '![](img/8a719b2a-0ff8-40a6-aa1a-f68d30c60f64.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a719b2a-0ff8-40a6-aa1a-f68d30c60f64.png)'
- en: 'Now, if we want to insert multiple documents, we can simply use:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们要插入多个文档，我们可以简单地使用：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![](img/e9a066be-5a9a-49cb-b34e-7d57f8edb430.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9a066be-5a9a-49cb-b34e-7d57f8edb430.png)'
- en: Retrieving documents
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索文档
- en: Retrieving documents from collections in MongoDB is done using the `find()`
    command. There are many ways to use this command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中检索集合中的文档是使用`find()`命令完成的。有许多使用此命令的方法。
- en: Finding all documents
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找所有文档
- en: 'To retrieve all documents from a collection, we can use:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集合中检索所有文档，我们可以使用：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下内容：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This outputs the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '![](img/493ba105-c15e-4001-bec1-5c33c473e5e8.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/493ba105-c15e-4001-bec1-5c33c473e5e8.png)'
- en: Finding documents via filters
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过过滤器查找文档
- en: 'We can add filters to the `find()` command as well. Let''s retrieve documents
    with the name  `Mike`. For that, we can use:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以向`find()`命令添加过滤器。让我们检索名称为`Mike`的文档。为此，我们可以使用：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It should return a document with the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回以下文档：
- en: '![](img/48f4dda2-bd2a-4452-9a6c-6900e11ff9f5.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48f4dda2-bd2a-4452-9a6c-6900e11ff9f5.png)'
- en: We can also specify multiple conditions with `AND` or `OR` queries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`AND`或`OR`查询指定多个条件。
- en: 'To find a collection with the name `Mike` and the email `mike@mongo.com`, we
    can simply use:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找名称为“Mike”且电子邮件为“mike@mongo.com”的集合，我们可以简单地使用：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The comma operator means an `AND` operator. We can specify as many conditions
    as we like with comma-separated values. The preceding command should output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符表示`AND`运算符。我们可以使用逗号分隔的值指定尽可能多的条件。前面的命令应该输出：
- en: '![](img/5c263d37-43b8-433c-9a47-ff92862d4fe0.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c263d37-43b8-433c-9a47-ff92862d4fe0.png)'
- en: 'Now, specifying conditions with `AND` or comma operators is simple. If we want
    to use the OR operator, then we should use:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`AND`或逗号运算符指定条件很简单。如果要使用OR运算符，则应使用：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are saying: retrieve those documents for users whose name is Mike,
    and the email can be `josh@mongo.com` as well. The output is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们说：检索那些名称为Mike的用户的文档，电子邮件也可以是`josh@mongo.com`。输出如下：
- en: '![](img/2fae1443-b58a-48ea-af6a-95deda33f5f3.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fae1443-b58a-48ea-af6a-95deda33f5f3.png)'
- en: Updating documents
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新文档
- en: 'Just like `insert()`, there are three methods of using the `update()` command
    in MongoDB: `updateOne()`, `updateMany()`, and `update()`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`insert()`一样，在MongoDB中使用`update()`命令有三种方法：`updateOne()`，`updateMany()`和`update()`。
- en: updateOne()
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: updateOne()
- en: 'This command updates only a single document in the collection. Here, we have
    inserted a couple of user entries with the incorrect emails. For the user with
    the name `Peter`, the email is `jack@mongo.com`. Let''s update this document using
    `updateOne()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令仅在集合中更新单个文档。在这里，我们插入了一对具有不正确电子邮件的用户条目。对于名称为`Peter`的用户，电子邮件是`jack@mongo.com`。让我们使用`updateOne()`更新此文档：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command will update Peter''s email to `peter@mongo.com`. The output is:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将更新Peter的电子邮件为`peter@mongo.com`。输出为：
- en: '![](img/a7c5fd07-4a23-4cad-9dcf-f086003367ba.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7c5fd07-4a23-4cad-9dcf-f086003367ba.png)'
- en: As the output says, the `modifiedCount` is `1` and the `matchedCount` is `1`,
    which means the document with the given condition was found and updated.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如输出所说，“modifiedCount”是“1”，“matchedCount”是“1”，这意味着找到并更新了具有给定条件的文档。
- en: updateMany()
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: updateMany()
- en: 'This command is used to update multiple documents in a collection. The command
    for updating documents with `updateOne()` and `updateMany()` is the same. To update
    the multiple records, we specify the condition and then set the desired values:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于更新集合中的多个文档。使用`updateOne()`和`updateMany()`更新文档的命令相同。要更新多条记录，我们指定条件，然后设置所需的值：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only difference between `updateOne()` and `updateMany()` is that `updateOne()`
    updates only the first document that is matched whereas `updateMany()` updates
    all the documents that are matched.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateOne()`和`updateMany()`之间的唯一区别是，`updateOne()`只更新匹配的第一个文档，而`updateMany()`更新所有匹配的文档。'
- en: update()
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: update()
- en: 'Just like insert, the `update()` command does the job for `updateOne()` and
    `updateMany()`. To remove confusion, we can just use the `update()` command instead
    of `updateOne()` and `updateMany()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像插入一样，`update()`命令可以为`updateOne()`和`updateMany()`执行任务。为了避免混淆，我们可以使用`update()`命令而不是`updateOne()`和`updateMany()`：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/acd38c2b-330c-44af-bfe4-d799032d7288.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acd38c2b-330c-44af-bfe4-d799032d7288.png)'
- en: Deleting documents
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文档
- en: MongoDB provides multiple commands for deleting and removing documents from
    collections.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB提供了多个命令来从集合中删除和移除文档。
- en: deleteOne()
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: deleteOne()
- en: '`deleteOne()` removes only a single document from a collection:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteOne()`只从集合中删除单个文档：'
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This removes the entry of a user whose name is `John`. The output is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除名为`John`的用户的条目。输出如下：
- en: '![](img/4a229e2e-ac94-4654-bb52-3e0fc52b7cf8.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a229e2e-ac94-4654-bb52-3e0fc52b7cf8.png)'
- en: As you can see in the output, the `deletedCount` is `1`, which means the record
    has been deleted.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在输出中所看到的，`deletedCount`是`1`，这意味着记录已被删除。
- en: deleteMany()
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: deleteMany()
- en: 'The command for `deleteMany()` is the same as `deleteOne()`. The only difference
    is that `deleteOne()` removes only a single entry with the matched filter whereas
    `deleteMany()` removes all the documents which match the given criteria:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteMany()`的命令与`deleteOne()`相同。唯一的区别是，`deleteOne()`只删除与匹配过滤器匹配的单个条目，而`deleteMany()`删除所有符合给定条件的文档：'
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/f45587d2-a32a-44c1-88b3-e3a6f6b71bf6.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f45587d2-a32a-44c1-88b3-e3a6f6b71bf6.png)'
- en: remove()
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: remove()
- en: 'The `remove()` command works to remove a single entry, as well as multiple
    entries, from a collection. If we want to remove only a single document that matched
    certain criteria, then we can pass the count of entries that we wish to delete.
    For example, let''s first create an entry:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`命令用于从集合中删除单个条目，以及多个条目。如果我们只想删除符合某些条件的单个文档，那么我们可以传递我们希望删除的条目计数。例如，让我们首先创建一个条目：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this, now we have two entries for `Mike`. Now, if we want to remove just
    one entry using `remove()`, we can do so with:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，现在我们有了两个`Mike`的条目。现在，如果我们想要使用`remove()`来删除一个条目，我们可以这样做：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/9c069d94-4b75-4853-855d-d584cbb13044.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c069d94-4b75-4853-855d-d584cbb13044.png)'
- en: 'As you can see, we had two entries with the name `Mike`, but it only removed
    one. Similarly, if we want to remove all the documents, we can just use:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有两个名为`Mike`的条目，但只删除了一个。同样，如果我们想要删除所有文档，我们可以使用：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All documents will be removed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文档将被删除。
- en: We talked about the basic ideas on how we can query the documents in Mongo.
    To find out more details, visit [https://docs.mongodb.com/v3.2/tutorial/query-documents/](https://docs.mongodb.com/v3.2/tutorial/query-documents/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了如何在Mongo中查询文档的基本思想。要了解更多详细信息，请访问[https://docs.mongodb.com/v3.2/tutorial/query-documents/](https://docs.mongodb.com/v3.2/tutorial/query-documents/)。
- en: Introducing Mongoose
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Mongoose
- en: Mongoose is an elegant MongoDB object modeling library for Node.js. As I mentioned
    earlier, MongoDB is a schemaless database design. While this has its own advantages,
    sometimes we need to add certain validations as well, and this means defining
    the schemas for our documents. Mongoose provides an easy way to add such validations
    and to typecast the fields in a document.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose是一个优雅的MongoDB对象建模库，适用于Node.js。正如我之前提到的，MongoDB是一个无模式的数据库设计。虽然这有其优点，但有时我们也需要添加一些验证，这意味着为我们的文档定义模式。Mongoose提供了一种简单的方法来添加这些验证，并对文档中的字段进行类型转换。
- en: 'For example, to insert data into a MongoDB document, we can use:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将数据插入MongoDB文档，我们可以使用：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if we want to add another document and we want an extra field in that
    document, we can use:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要添加另一个文档，并且我们想在该文档中添加一个额外的字段，我们可以使用：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is possible in MongoDB because no schemas are defined. These types of documents
    are also needed when building an application. MongoDB will silently accept any
    kind of document. However, there are times when we need to have documents look
    similar in order to behave in certain validations or to have a specific data type.
    In such situations, Mongoose comes to the rescue. We can also leverage these features
    with raw MongoDB as well, but writing validations in MongoDB is an extremely painful
    task. That's why Mongoose was created.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这在MongoDB中是可能的，因为没有定义模式。构建应用程序时也需要这些类型的文档。MongoDB将默默接受任何类型的文档。但是，有时我们需要让文档看起来相似，以便在某些验证中表现出特定的数据类型。在这种情况下，Mongoose就派上用场了。我们也可以利用这些功能与原始的MongoDB一起使用，但是在MongoDB中编写验证是一项极其痛苦的任务。这就是为什么创建了Mongoose。
- en: 'Mongoose is a data modeling technique for Mongo written in Node.js. Every document
    inside a Mongoose collection requires a fixed amount of fields. We have to explicitly
    define a `Schema` and adhere to it. An example of a Mongoose schema is:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose是用Node.js编写的Mongo的数据建模技术。Mongoose集合中的每个文档都需要固定数量的字段。我们必须明确定义`Schema`并遵守它。Mongoose模式的一个示例是：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This means that the name and description fields must be a string, whereas the
    extras can take a whole JSON object in which we can store nested values as well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着名称和描述字段必须是字符串，而额外的字段可以接受一个完整的JSON对象，其中我们还可以存储嵌套值。
- en: Installing Mongoose
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Mongoose
- en: 'Like any other package, Mongoose can be installed in our project using NPM.
    Run the following command in our Terminal inside our `express_app` folder which
    we created in the previous chapter to install Mongoose inside that application:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他包一样，Mongoose可以通过NPM在我们的项目中安装。在我们的终端中运行以下命令，进入我们在上一章中创建的`express_app`文件夹，以在该应用程序中安装Mongoose：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this is successfully installed, we should have a line added to our `package.json`
    file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功安装，我们应该在我们的`package.json`文件中添加一行：
- en: '![](img/cd4d9ce0-ceaf-45cf-80ca-181b578da24d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd4d9ce0-ceaf-45cf-80ca-181b578da24d.png)'
- en: Connecting Mongoose to MongoDB
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Mongoose连接到MongoDB
- en: 'Once Mongoose is installed, we have to connect it to the MongoDB in order to
    start working with it. This is pretty straightforward with Mongoose; we just have
    to add a piece of code to `require` Mongoose in our `app.js` file and use the `mongoose.connect`
    method to connect it to the database. Let''s go ahead and do that. In the `app.js`
    file, add the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Mongoose后，我们必须将其连接到MongoDB才能开始使用它。这在Mongoose中非常简单；我们只需在`app.js`文件中添加一行代码来`require`
    Mongoose，并使用`mongoose.connect`方法将其连接到数据库。让我们继续做这件事。在`app.js`文件中，添加以下代码：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will import the Mongoose module into our codebase.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把Mongoose模块导入到我们的代码库中。
- en: 'Now, to connect to the MongoDB database, add the following line of code in
    our `app.js`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到MongoDB数据库，将以下代码添加到我们的`app.js`中：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This creates a connection with our Mongoose database. Now, let''s run the app
    with the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就创建了与我们的Mongoose数据库的连接。现在，让我们用以下命令运行应用程序：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'and displays a message in our Terminal if it succeeded or failed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 并在我们的终端中显示成功或失败的消息：
- en: '![](img/a9f674f8-65fb-4746-9de9-b5347303decc.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9f674f8-65fb-4746-9de9-b5347303decc.png)'
- en: That's it! We have successfully made a connection to our MongoDB database. The
    URL here is the locally hosted database URL.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经成功地连接到了我们的MongoDB数据库。这里的URL是本地托管的数据库URL。
- en: Creating records in Mongoose
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mongoose中创建记录
- en: Let's start by creating a new model in our application's `express_app`. Create
    a folder called `models` in the root of the project and name it `User.js`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在我们应用的`express_app`中创建一个新的模型开始。在项目的根目录下创建一个名为`models`的文件夹，命名为`User.js`。
- en: We are using a capital letter for the starting letter of the file name. Also,
    we are using the single form for `models`. Contrary to this, for `controllers`,
    we use the plural form and lowercase letters, such as `users.js`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文件名的开头字母使用大写字母。此外，我们在`models`中使用单数形式。与此相反，在`controllers`中，我们使用复数形式和小写字母，比如`users.js`。
- en: 'Once we create the file, paste the following code into it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件后，将以下代码粘贴到其中：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first line here just imports the Mongoose module. This Mongoose package
    provides us with several properties, one of which is to define the `Schema`. Now,
    the original `Schema` definition here is this highlighted part:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一行只是导入了Mongoose模块。这个Mongoose包为我们提供了几个属性，其中之一是定义`Schema`。现在，这里的原始`Schema`定义是这个高亮部分：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What this does is it adds a validation to our `User` data model, where it says
    there must be two fields in total. It will not accept either one or more than
    two data fields while creating a document for a Mongoose collection. Also, it
    adds a validation layer to this `Schema` as well, which says that the two fields,
    both `name`, and `email`, should be a valid string. It won''t accept an integer,
    Boolean, or anything other than a string for both of these fields. This is how
    we define the `Schema`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的作用是向我们的`User`数据模型添加验证，其中规定总共必须有两个字段。在创建Mongoose集合的文档时，它不会接受一个或两个以上的数据字段。此外，它还向这个`Schema`添加了一个验证层，规定这两个字段，即`name`和`email`都应该是有效的字符串。它不会接受整数、布尔值或其他任何非字符串类型的数据。这是我们如何定义`Schema`的方式：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The highlighted part of this code represents the way to create a model. The
    first argument of the method is our model name, which maps to the corresponding
    plural version of the collection name. So, when we create a `User` model, this
    automatically maps to the `user` collections in our database.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的高亮部分表示创建模型的方式。方法的第一个参数是我们的模型名称，它映射到集合名称的相应复数版本。因此，当我们创建一个`User`模型时，这自动映射到我们数据库中的`user`集合。
- en: 'Now, to create a user, the first thing to do is to create a resource:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建一个用户，首先要做的是创建一个资源：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, finally, the part that actually creates the `user` is:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最终创建`user`的部分是：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous code uses a Mongoose function called `save`. The save method has
    a callback function that is used for error handling. We can do whatever we want
    when we encounter an error while saving the resource to our database there:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用了一个名为`save`的Mongoose函数。`save`方法有一个回调函数，用于错误处理。当我们在保存资源到数据库时遇到错误时，我们可以在那里做任何我们想做的事情：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `res.send` method allows us to set what we want to send to the client when
    the resource is successfully saved to the database. The first element of the object
    is `success: true`, which denotes if the execution was successful or not. The
    second element is the status code or the response code. A `200` response code
    denotes successful execution. We will discuss this in further chapters as well.The
    last element is the message that is sent to the client; the users see this in
    the frontend.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.send`方法允许我们设置当资源成功保存到数据库时要发送给客户端的内容。对象的第一个元素是`success: true`，表示执行是否成功。第二个元素是状态码或响应码。`200`响应码表示执行成功。我们在后面的章节中也会讨论这个。最后一个元素是发送给客户端的消息；用户在前端看到这个消息。'
- en: That's how we create a resource in Mongoose.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在Mongoose中创建资源的方式。
- en: Fetching records from Mongoose
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Mongoose中获取记录
- en: 'Now that we have successfully created a user, we have a record in the `users`
    collections in the database. There are two ways to fetch this record in our client:
    fetch all the records of users that we have or fetch a specific user.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了一个用户，在数据库的`users`集合中有一条记录。有两种方法可以在我们的客户端中获取这条记录：获取我们拥有的所有用户的记录，或者获取特定的用户。
- en: Fetching all records
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有记录
- en: There are lots of methods that come out of the box with a Mongoose model to
    make our lives easier. Two such methods are `find()` and `findById()`. In MongoDB,
    we saw how we could retrieve a collection's records data via raw MongoDB queries.
    This is similar, the only  difference being that Mongoose has a very easy way
    to do it. I recommend you learn MongoDB first instead of Mongoose because MongoDB
    gives you an overall idea of what a database is and you will learn the fundamentals
    of the database and about its queries. Mongoose just adds a layer on top of MongoDB
    to make it look a little bit easier for faster developments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose模型中有很多方法可以让我们的生活变得更轻松。其中两种方法是`find()`和`findById()`。在MongoDB中，我们看到了如何通过原始的MongoDB查询检索集合的记录数据。这是类似的，唯一的区别是Mongoose有一种非常简单的方法来做到这一点。我建议你先学习MongoDB而不是Mongoose，因为MongoDB可以让你对数据库有一个整体的了解，你将学习数据库的基本知识和查询。Mongoose只是在MongoDB的基础上添加了一层，使其看起来更容易进行快速开发。
- en: 'With that, let''s look into the code snippet here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们看一下这里的代码片段：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The Mongoose model `User` calls a method called `find()`. The first parameter
    is our query string, which is left empty: `{}` in the preceding query. So, if
    we want to retrieve all users who share the same name, say, Peter, then we can
    replace that empty `{}` with `{ name: ''Peter''}`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mongoose模型`User`调用了一个名为`find()`的方法。第一个参数是我们的查询字符串，在前面的查询中为空：`{}`。因此，如果我们想要检索所有与相同姓名的用户，比如Peter，那么我们可以将空的`{}`替换为`{
    name: ''Peter''}`。'
- en: The second parameter denotes which fields we want to retrieve from the database.
    We can leave it blank if we want to retrieve all fields or we can just specify
    it here. For this example, we are just retrieving user names and emails.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数表示我们想要从数据库中检索哪些字段。如果我们想要检索所有字段，可以将其留空，或者在这里指定。在这个例子中，我们只检索用户的姓名和电子邮件。
- en: 'The third parameter has a callback function attached to it. This function takes
    two parameters, unlike the `create` method. The first parameter handles the error.
    If, somehow, the execution is not done successfully, it returns an error and we
    can customize it the way we want. The second parameter is the important one here;
    it returns the response when the execution is successfully done. In this case,
    the `users` parameter is an array of objects that are retrieved from the `users`
    collection. The output of this call would be:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数附加了一个回调函数。这个函数有两个参数，不像`create`方法。第一个参数处理错误。如果一些原因，执行没有成功完成，它会返回一个错误，我们可以按照我们的意愿进行自定义。第二个参数在这里很重要；当执行成功完成时，它返回响应。在这种情况下，`users`参数是从`users`集合中检索到的对象数组。这个调用的输出将是：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now we have all the records from the `users` collection.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`users`集合中的所有记录。
- en: Fetching a specific record
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取特定记录
- en: This is also as simple as fetching all records from a collection. We talked
    about using `find()` in the previous section. To fetch a single record, we have
    to use `findById()` or `findOne()`, or we can also use the `where` query. The
    `where` query is the same as we talked about previously when we had to pass a
    parameter to fetch records that fell under the same category.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这也和从集合中获取所有记录一样简单。我们在上一节讨论了使用`find()`。要获取单个记录，我们必须使用`findById()`或`findOne()`，或者我们也可以使用`where`查询。`where`查询与我们之前讨论的相同，当我们需要传递参数以获取属于同一类别的记录时。
- en: 'Let''s move ahead on using the following query:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用以下查询：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, the syntax for both `find()` and `findById()` are similar.
    Both take the same amount of parameters and behave the same. The only difference
    between these two is that the preceding `find()` method returned an array of records
    as a response, whereas `findById()` returns a single object. So, the response
    to the preceding query would be:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`find()`和`findById()`的语法是相似的。它们都接受相同数量的参数并且行为相同。这两者之间唯一的区别是，前者`find()`方法返回一个记录数组作为响应，而`findById()`返回一个单一对象。因此，前面查询的响应将是：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That's it – simple!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 简单！
- en: Updating records in Mongoose
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mongoose中更新记录
- en: Let's move on to updating a record in a collection. There are multiple ways
    to update the collection records as well, just as in retrieving data from the
    collections. Updating a document in Mongoose is the combination of `read` and
    `create`(save) methods. To update a document, we first need to find that document
    using the read query of Mongoose, alter that document, and then save the changes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续更新集合中的记录。更新集合记录的方法有多种，就像从集合中检索数据一样。在Mongoose中更新文档是`read`和`create`(save)方法的组合。要更新文档，我们首先需要使用Mongoose的读取查询找到该文档，修改该文档，然后保存更改。
- en: findById() and save()
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: findById()和save()
- en: 'Let''s look at an example as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, the first thing we need to do is find the user document, which we are doing
    by `findById()`. This method returns back the user with the given ID. Now that
    we have that user, we can alter whatever we like for this user. In the preceding
    case, we are changing the name and email of that person.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要做的第一件事是找到用户文档，我们通过`findById()`来实现。这个方法返回具有给定ID的用户。现在我们有了这个用户，我们可以随意更改这个用户的任何内容。在前面的例子中，我们正在更改该人的姓名和电子邮件。
- en: 'Now the important part. The job of updating this user''s document is done by
    the `save()` method here. We have already altered the name and email of the user
    by doing:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重要的部分。更新这个用户文档的工作是由`save()`方法完成的。我们已经通过以下方式更改了用户的姓名和电子邮件：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are changing the object that was returned via `findById()` in the first place
    directly. Now, when we use `user.save()`, this method overwrites whatever value
    it was before for this user with this new name and email.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接更改了通过`findById()`返回的对象。现在，当我们使用`user.save()`时，这个方法会用新的姓名和电子邮件覆盖之前的值。
- en: There are other methods we can use to update a document in Mongoose.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用其他方法来更新Mongoose中的文档。
- en: findOneAndUpdate()
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: findOneAndUpdate()
- en: 'This method can be used when we want to update a single entry. For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要更新单个条目时，可以使用这种方法。例如：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, the first parameter defines the criteria describing the record
    we want to update, which, in this case, is the user whose name is Peter. The second
    parameter is the object in which we define what attributes of `user` do we want
    to update, which is defined by `{ $set: { name: "Sara" }`. This sets the `name`
    of `Peter` to `Sara`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你所看到的，第一个参数定义了描述我们想要更新的记录的条件，这种情况下是名字为Peter的用户。第二个参数是我们定义要更新的`user`的属性的对象，由`{
    $set: { name: "Sara" }`定义。这将`Peter`的`name`设置为`Sara`。'
- en: 'Now, let''s make a small alteration to the preceding code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对上述代码进行一些小的修改：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, notice that I have added a second parameter to the callback function called
    `user`.  What this does is that when Mongoose is done updating that document in
    the database, it returns the object. This is very useful when we want to make
    some decisions after we update the record and want to play with the newly updated
    document.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，请注意我向回调函数添加了一个名为`user`的第二个参数。这样做的作用是，当Mongoose完成对数据库中文档的更新时，它会返回该对象。当我们想要在更新记录后做出一些决定并且想要使用新更新的文档时，这非常有用。
- en: findByIdAndUpdate()
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: findByIdAndUpdate()
- en: 'This is somewhat similar to `findOneAndUpdate()`. This method takes an ID as
    a parameter, unlike `findOneAndUpdate()`, where we can add our own criteria, and
    updates that document:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`findOneAndUpdate()`有些相似。这个方法接受一个ID作为参数，不像`findOneAndUpdate()`，在那里我们可以添加自己的条件，并更新该文档：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The only difference here is that the first parameter takes a single integer
    value, which is the ID of the document rather than an object. This method also
    returns the object that is being updated. So we can use:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的区别是第一个参数接受一个单一的整数值，即文档的ID，而不是一个对象。这个方法也返回正在更新的对象。所以我们可以使用：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Deleting records in Mongoose
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mongoose中删除记录
- en: Just as there are many ways to create, fetch and update records in Mongoose,
    it also provides several ways to delete records from collections as well, such
    as `remove()`, `findOneAndRemove()`, and `findByIdAndRemove()`. We can use `remove()`
    to remove one or many documents. We can also find the documents we want to remove
    first and then use the `remove()` command to remove only those documents. If we
    want to find a specific document with some criteria, we can use `findOneAndRemove()`.
    We can use `findByIdAndRemove()` when we know the ID of the document we wish to
    remove.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Mongoose中有许多方法来创建、获取和更新记录一样，它也提供了几种方法来从集合中删除记录，比如`remove()`、`findOneAndRemove()`和`findByIdAndRemove()`。我们可以使用`remove()`来删除一个或多个文档。我们也可以先找到我们想要删除的文档，然后使用`remove()`命令只删除这些文档。如果我们想要根据一些条件找到特定的文档，我们可以使用`findOneAndRemove()`。当我们知道要删除的文档的ID时，我们可以使用`findByIdAndRemove()`。
- en: remove()
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: remove()
- en: 'Let''s look at a sample for using this method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用这种方法的示例：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first argument of the `remove()` method takes the criteria for filtering
    which user we want to remove. It takes an ID as a parameter. It finds the user
    with the given ID and removes the document from the collection. The second parameter
    is the callback function, which we talked about before. If something goes wrong
    with the above operation, it returns an error, which we can use to better handle
    the exceptions or the errors that occur in our application. In the case of success,
    we can define our own logic as to what to return. In the preceding case, we are
    returning `{ success: true }`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`方法的第一个参数是过滤我们想要删除的用户的条件。它接受一个ID作为参数。它找到具有给定ID的用户并从集合中删除文档。第二个参数是我们之前讨论过的回调函数。如果上述操作出现问题，它会返回一个错误，我们可以用来更好地处理应用程序中发生的异常或错误。在成功的情况下，我们可以定义自己的逻辑来返回什么。在上述情况下，我们返回`{
    success: true }`。'
- en: findOneAndRemove
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: findOneAndRemove
- en: '`findOneAndRemove()` behaves the same way as `remove()` does and takes the
    same amount of parameters:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOneAndRemove()`的行为方式与`remove()`相同，并且需要相同数量的参数：'
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We just have to define the criteria for which documents we want to delete.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要定义要删除的文档的条件。
- en: 'Now, we can also modify the preceding code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也可以修改上述代码：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, I have highlighted the added piece of code. We can also pass on a second
    parameter to the callback function which returns the `user` object being deleted. Now,
    this is helpful if we want to display a certain message to the frontend and also
    add some user attributes such as `name` or `email` of the `user`. For example,
    if we want to display a message saying User with name {x} has been deleted. on
    the frontend, then we can pass `user` or other attributes of `user` here; in this
    case, it's the name, to be displayed on the frontend.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我突出显示了添加的代码片段。我们还可以将第二个参数传递给回调函数，该回调函数返回被删除的`user`对象。如果我们想要向前端显示某个消息并添加一些用户属性，比如`user`的`name`或`email`，那么这将非常有用。例如，如果我们想要在前端显示一个消息，说用户{name}已被删除。然后我们可以传递`user`或`user`的其他属性；在这种情况下，它是要在前端显示的名字。
- en: The main difference between `remove()` and `findOneAndRemove()` is that remove
    does not return the documents that were deleted but `findOneAndRemove()` does.
    Now we know when to use these two methods.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`和`findOneAndRemove()`之间的主要区别是`remove()`不返回被删除的文档，但`findOneAndRemove()`会。现在我们知道何时使用这两种方法了。'
- en: findByIdAndRemove()
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: findByIdAndRemove()
- en: 'This is the same as `findOneAndRemove()`, except that this always needs an
    `id` to be passed as a parameter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`findOneAndRemove()`相同，只是这总是需要一个`id`作为参数传递：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Did you find any difference in the code between `findOneAndRemove()` and the
    preceding code for `findByIdAndRemove()`? If we look at the first parameter of
    this method, it only takes a simple integer value, which is the document ID. Now,
    if we look into the preceding `findOneAndRemove()` code, we will notice that we
    have passed an object in the first parameter. That''s because, for `findOneAndRemove()`,
    we can pass different arguments other than ID as well. For example, we can also
    pass `{ name: ''Anita'' }` in that parameter for `findOneAndRemove()`. But, for `findByIdAndRemove()`,
    as is obvious from the method name, we don''t need to pass an object but just
    an integer that denotes the document''s ID.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '你在`findOneAndRemove()`和前面的`findByIdAndRemove()`的代码之间找到了什么不同吗？如果我们看一下这个方法的第一个参数，它只接受一个简单的整数值，即文档ID。现在，如果我们看一下前面的`findOneAndRemove()`代码，我们会注意到我们在第一个参数中传递了一个对象。这是因为对于`findOneAndRemove()`，我们可以传递除ID之外的不同参数。例如，我们还可以在`findOneAndRemove()`的参数中传递`{
    name: ''Anita'' }`。但是对于`findByIdAndRemove()`，从方法名称显而易见，我们不需要传递一个对象，而只需要一个表示文档ID的整数。'
- en: It finds a document with the mentioned ID in the parameter and removes that
    document from the collections. Like `findOneAndRemove()`, this also returns the
    document that is being deleted.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它在参数中查找具有指定ID的文档，并从集合中删除该文档。与`findOneAndRemove()`一样，它也返回被删除的文档。
- en: Adding validation with Mongoose
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mongoose添加验证
- en: Validations in Mongoose are defined at the schema level. Validations can be
    set in both strings and in numbers. Mongoose provides us with built-in validation
    techniques for strings and numbers. Also, we can customize these according to
    our need as well. Since validations are defined in the schemas, they are triggered
    when we hit the `save()` method for any document. If we only want to test these
    validations, we can do that as well by executing the validation method only via
    `{doc}.validate()`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose中的验证是在模式级别定义的。验证可以在字符串和数字中设置。Mongoose为字符串和数字提供了内置的验证技术。此外，我们也可以根据需要自定义这些验证。由于验证是在模式中定义的，因此当我们对任何文档执行`save()`方法时，它们会被触发。如果我们只想测试这些验证，我们也可以通过`{doc}.validate()`方法执行验证方法。
- en: '`validate()` is also middleware, which means it has control when we are executing
    some methods in an asynchronous way.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate()`也是中间件，这意味着当我们以异步方式执行某些方法时，它具有控制权。'
- en: Default validations
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认验证
- en: Let's talk about some of the default validations that Mongoose provides us with.
    These are also called built-in validators.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈Mongoose提供给我们的一些默认验证。这些也被称为内置验证器。
- en: required()
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: required()
- en: 'The `required()` validator checks if the field we added this validation on
    has some value or not. Previously, in the `User` model, we had this code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`required()`验证器检查我们在其上添加了此验证的字段是否有一些值。以前，在`User`模型中，我们有这样的代码：'
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code also has a validation associated with the fields of the user. It requires
    the name and email of a user to be a string and not numbers, or Boolean, or anything
    else. But this code doesn't make sure the name and email fields are set for the
    user.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也与用户的字段相关联了验证。它要求用户的姓名和电子邮件必须是字符串，而不是数字、布尔值或其他任何东西。但是这段代码并不确保用户的姓名和电子邮件字段已设置。
- en: 'So, if we want to add a `required()` validation, the code should be modified
    in this way:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想添加`required()`验证，代码应该修改为这样：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, we have changed the value of the name key to an object instead
    of just a string. Here, we can add as many validations as we want. So, the added
    validation `required: true` checks if there is some value set on the name and
    email of the user before saving that document in the collection. It returns an
    error if the validation is not met.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，我们已将name键的值更改为对象，而不仅仅是一个字符串。在这里，我们可以添加任意多的验证。因此，添加的验证`required: true`在将该文档保存到集合之前检查用户的姓名和电子邮件是否设置了某些值。如果验证未满足，它将返回错误。'
- en: 'We can also pass a message when the validation returns an error. For example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当验证返回错误时，我们还可以传递消息。例如：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This way, we can also customize the messages as per our requirements. Very cool,
    right?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们还可以根据需要自定义消息。很酷，对吧？
- en: Type validation
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型验证
- en: The type validation method defines the types of fields in a document. The different
    variations of type can be `String`, `boolean`, and `number`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 类型验证方法定义了文档中字段的类型。类型的不同变体可以是`String`、`boolean`和`number`。
- en: String
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: The string itself has several validators under it, such as `enum`, `match`,
    `maxlength`, and `minlength`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串本身有几个验证器，如`enum`、`match`、`maxlength`和`minlength`。
- en: '`maxlength` and `minlength` define the length of a string.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxlength`和`minlength`定义了字符串的长度。'
- en: Numbers
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'Numbers have two validators: `min` and `max`. The `min` and `max` values define
    the range of values for a field in a collection.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 数字有两个验证器：`min`和`max`。`min`和`max`的值定义了集合中字段的值范围。
- en: Custom validations
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义验证
- en: 'We can also add custom validations in case the default built-in validations
    are not enough.  We can pass a `validate` function and write our custom code into
    that function. Let''s look at an example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认的内置验证不够用，我们还可以添加自定义验证。我们可以传递一个`validate`函数，并在该函数中编写我们的自定义代码。让我们看一个例子：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we have passed a `validate` method to the `Schema`. It takes a validator
    function where we can add our own code for the validation. The preceding method checks
    if the phone number field of the user is in the correct format or not. If it does
    not pass the validation, then it displays the message `{value} is not a valid
    phone number`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`Schema`传递了一个`validate`方法。它接受一个验证函数，我们可以在其中添加自己的验证代码。前面的方法检查用户的电话号码字段是否符合正确的格式。如果未通过验证，则显示消息`{value}
    is not a valid phone number`。
- en: 'We can also add nested validations in Mongoose: for example, if the name in
    our user collection is saved as `{ name: { first_name: ''Anita'', last_name: ''Sharma''
    } }`, we will need to add validations for both `first_name` and `last_name`. To
    do that, we can use:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以在Mongoose中添加嵌套验证：例如，如果我们的用户集合中的名称保存为`{ name: { first_name: ''Anita'',
    last_name: ''Sharma'' } }`，我们将需要为`first_name`和`last_name`都添加验证。为了做到这一点，我们可以使用：'
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we define the `Schema` for a low-level object, which is `first_name`
    and `last_name`. Then, for the `userSchema`, we pass on the `nameSchema` for the
    name field.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为低级对象定义`Schema`，即`first_name`和`last_name`。然后，对于`userSchema`，我们将`nameSchema`传递给名称字段。
- en: 'Remember, we cannot add nested validations in a single `Schema` like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们不能像这样在单个`Schema`中添加嵌套验证：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can look into Mongoose validations here: [http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里查看Mongoose验证：[http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html)。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered basic information about MongoDB and its benefits,
    how to make CRUD operations and queries in MongoDB, and the basic validations
    with Mongoose.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了关于MongoDB及其优势的基本信息，如何在MongoDB中进行CRUD操作和查询，以及Mongoose中的基本验证。
- en: Going further, in the next chapter, we will talk more about the REST APIs and
    the RESTful architecture design in our application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更多地讨论关于REST API和我们应用程序中的RESTful架构设计。
