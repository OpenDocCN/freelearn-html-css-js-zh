- en: Chapter 2. Getting Started with Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：Node.js 入门
- en: 'The definition of Node.js that is given on the Node.js website ([http://nodejs.org/](http://nodejs.org/)),
    is as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 网站 ([http://nodejs.org/](http://nodejs.org/)) 上给出的 Node.js 定义如下：
- en: Node.js is a platform built on Chrome's JavaScript runtime for easily building
    fast, scalable network applications. Node.js uses an event-driven, non-blocking
    I/O model that makes it lightweight and efficient, perfect for data-intensive
    real-time applications that run across distributed devices.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Node.js 是一个基于 Chrome 的 JavaScript 运行时构建的平台，用于轻松构建快速、可扩展的网络应用程序。Node.js 使用事件驱动的、非阻塞的
    I/O 模型，使其轻量级且高效，非常适合运行在分布式设备上的数据密集型实时应用程序。
- en: What matters to us is, Node.js as a part of the platform, provides a scalable
    and high-performance web application development framework, which allows programming
    in JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说重要的是，作为平台的一部分，Node.js 提供了一个可扩展且高性能的 Web 应用程序开发框架，允许使用 JavaScript 进行编程。
- en: Many of us got introduced to JavaScript while building websites or web applications
    for DOM manipulation, AJAX, and related stuff. But JavaScript is much more than
    that. Just like C, Java, Python, and so on, JavaScript is also a full-fledged
    programming language. In all browsers, JavaScript is executed in a virtual machine
    (VM), in the context of the browser. But it can also be executed in another context—as
    in the case of a Node.js backend—without the browser.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人是在构建网站或 Web 应用程序以进行 DOM 操作、AJAX 和相关内容时接触到 JavaScript 的。但 JavaScript 远不止于此。就像
    C、Java、Python 等一样，JavaScript 也是一个完整的编程语言。在所有浏览器中，JavaScript 都在浏览器的上下文中在虚拟机 (VM)
    中执行。但它也可以在另一个上下文中执行——就像 Node.js 后端的情况一样——而不需要浏览器。
- en: Node.js uses Google Chrome's JavaScript VM to execute JavaScript applications
    outside the browser, on the server. Along with this runtime environment, Node.js
    also provides a library of modules, which provides a framework for building network
    applications. Node.js is not a web server like the Apache HTTP server, or an application
    server like Tomcat; but as part of its modules library, Node.js does provide an
    HTTP Server, which can be used to build web applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 使用 Google Chrome 的 JavaScript VM 在浏览器之外执行 JavaScript 应用程序，在服务器上。除了这个运行时环境之外，Node.js
    还提供了一组模块库，为构建网络应用程序提供了一个框架。Node.js 不是一个像 Apache HTTP 服务器那样的网络服务器，也不是像 Tomcat 那样的应用程序服务器；但作为其模块库的一部分，Node.js
    也提供了一个 HTTP 服务器，可以用来构建 Web 应用程序。
- en: Apart from having JavaScript as the programming language for the applications,
    one thing that sets Node.js (and most of the Node.js modules and applications)
    apart from the traditional servers and applications is the asynchronous event-driven
    development model, which we will see in later sections.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将 JavaScript 作为应用程序的编程语言之外，Node.js（以及大多数 Node.js 模块和应用）与传统服务器和应用程序区分开来的一点是异步事件驱动开发模型，我们将在后面的章节中看到这一点。
- en: The origin of Node.js
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 的起源
- en: This is not the first time that JavaScript has been used for server-side programming.
    Netscape launched Netscape Enterprise Server in 1996, which allowed server-side
    programming in JavaScript. Since then, many servers, such as **RingoJS** ([http://ringojs.org/](http://ringojs.org/)),
    **Persevere** ([http://www.persvr.org/](http://www.persvr.org/)), Mozilla's Rhino-based
    servers, and others have tried to follow suit.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是 JavaScript 首次被用于服务器端编程。Netscape 在 1996 年推出了 Netscape Enterprise Server，允许使用
    JavaScript 进行服务器端编程。从那时起，许多服务器，如 **RingoJS** ([http://ringojs.org/](http://ringojs.org/))、**Persevere**
    ([http://www.persvr.org/](http://www.persvr.org/))、基于 Mozilla Rhino 的服务器以及其他服务器，都尝试效仿。
- en: A major reason for these servers not being taken seriously was the pitiful performance
    of the JavaScript VMs used by them. JavaScript performance in browsers was also
    not very good. That was until Google launched its Chrome web browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务器没有被认真对待的主要原因之一是它们使用的 JavaScript 虚拟机 (VM) 的性能可怜。浏览器中的 JavaScript 性能也不是很好。直到
    Google 推出了其 Chrome 网络浏览器，这种情况才有所改变。
- en: At the time of its launch, Chrome's JavaScript VM, called **V8**, was almost
    10-20 times faster than any other JavaScript VM, and has since then been the fastest.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在其发布时，Chrome 的 JavaScript VM，称为 **V8**，几乎比其他任何 JavaScript VM 快 10-20 倍，并且从那时起一直是最快的。
- en: It was based on this VM that Ryan Dahl developed Node.js in 2008\. He wanted
    to build a server that would enable and empower real-time interactive web applications
    like Gmail. But Node.js was not the first server he built. Ryan built Ebb, a web
    server based on Ruby and C, but realized that it wasn't working as fast as he
    wanted it to. This was followed by several experiments in building a number of
    small web servers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是基于这个虚拟机在 2008 年由 Ryan Dahl 开发的。他想要构建一个能够支持并赋能实时交互式网络应用，如 Gmail 的服务器。但
    Node.js 并不是他第一个构建的服务器。Ryan 构建了基于 Ruby 和 C 的 Ebb 服务器，但意识到它并没有达到他期望的运行速度。随后，他进行了一系列构建多个小型服务器的实验。
- en: Armed with the knowledge gained from his experiments and the study of various
    platforms, he decided to develop an event-driven or asynchronous server. In the
    January of 2008, he came up with the idea of building a small web server based
    on JavaScript. He was inclined towards JavaScript because it was independent of
    the OS and came without any I/O APIs. He quit his job and worked on Node.js for
    6 months. In November 2009, he presented Node.js in JSConf, and has been working
    for Joyent since then. Initially, Node.js worked only on Unix-based systems; later,
    it came with support for Windows OS too.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 借助从实验和各种平台研究中获得的知识，他决定开发一个事件驱动或异步服务器。2008 年 1 月，他提出了基于 JavaScript 构建小型服务器的想法。他倾向于选择
    JavaScript，因为它独立于操作系统，并且没有 I/O API。他辞去了工作，用 6 个月的时间专注于 Node.js。2009 年 11 月，他在
    JSConf 上展示了 Node.js，并从那时起为 Joyent 工作。最初，Node.js 只能在基于 Unix 的系统上运行；后来，它也增加了对 Windows
    操作系统的支持。
- en: Why Node.js
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Node.js
- en: Node.js is a new platform and is still evolving (not even a version 1.0 has
    been released yet), but even in its infancy, it is probably one of the most popular
    platforms on the Web. It is already powering a large number of popular services.
    Let us take a look at what makes Node.js such a tempting and popular proposition.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是一个新兴的平台，仍在不断发展（甚至还没有发布 1.0 版本），但即使在其初期，它可能也是 Web 上最受欢迎的平台之一。它已经为大量流行的服务提供动力。让我们看看是什么让
    Node.js 如此诱人和受欢迎。
- en: JavaScript everywhere
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 到处都是
- en: The first and foremost advantage of Node.js is JavaScript. If you know and code
    in JavaScript regularly, you already know most of Node.js; all that's left to
    learn can be thought of as APIs and best practices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的首要优势是 JavaScript。如果你知道并经常用 JavaScript 编码，你已经了解了 Node.js 的大部分内容；剩下的学习内容可以看作是
    API 和最佳实践。
- en: Node.js—built over Google Chrome's V8 JavaScript engine—allows entire applications
    to be written using JavaScript. We have already been writing frontends in JavaScript;
    with Node.js, we write the backend as well, in the same language that we have
    honed our skills on and grown to love. It saves every frontend developer from
    learning one more language or relying on some other developer to expose the RESTful
    APIs required by their application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Google Chrome 的 V8 JavaScript 引擎构建的 Node.js 允许使用 JavaScript 编写整个应用程序。我们已经在用
    JavaScript 编写前端；有了 Node.js，我们也可以用同样的语言编写后端，这是我们磨练技能并深深喜爱的语言。它让每个前端开发者都无需学习另一种语言或依赖其他开发者来暴露应用程序所需的
    RESTful API。
- en: Event-driven design
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动设计
- en: Node.js was designed around events and callbacks. As a JavaScript developer,
    you would already be familiar with the concept of listening to events and using
    callbacks. Node.js incorporates this philosophy in each and every aspect of the
    platform. Be it in server request handling, I/O, or database interactions, everything
    in Node.js will ideally be handled by a callback attached to an event by a listener.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是围绕事件和回调进行设计的。作为一个 JavaScript 开发者，你早已熟悉监听事件和使用回调的概念。Node.js 将这种理念融入到平台的每一个方面。无论是服务器请求处理、I/O
    还是数据库交互，Node.js 中的所有操作理想上都将由一个事件监听器附加的回调来处理。
- en: This brings us to one of the most important concepts behind Node.js, that is,
    the *event loop*. I like the fast food restaurant analogy by Dan York ([http://code.danyork.com](http://code.danyork.com))
    for explaining event loop-based systems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到了 Node.js 背后最重要的概念之一，那就是 *事件循环*。我喜欢 Dan York ([http://code.danyork.com](http://code.danyork.com))
    用快餐店类比来解释基于事件循环的系统。
- en: Consider a restaurant where you go to the cashier, place your order, and wait
    till your food is ready. In this case, the cashier cannot serve the other customers
    till you have your order, and the queue is blocked. If the restaurant has a large
    inflow of customers and needs to scale up, they will have to invest in hiring
    more number of cashiers, creating more cash counters, and so on. This is similar
    to the traditional multithreading model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一家餐厅，你走到收银台，下单，然后等待你的食物准备好。在这种情况下，收银员在你下单之前不能服务其他顾客，队列被阻塞。如果餐厅有大量的顾客涌入并需要扩展，他们就必须投资雇佣更多的收银员，创建更多的收银台等等。这类似于传统的多线程模型。
- en: In contrast, let us see the model many other restaurants use. In this case,
    you go to the cashier and place your order (which he/she hands over to the kitchen);
    he/she then accepts your payment and gives you a token. You then step aside, and
    the cashier moves on to the next customer. When your order is ready, the kitchen
    server announces this by calling your name or flashing your token number, and
    you walk up and fetch your order. This event-oriented approach optimizes the work
    of the cashier and lets you wait on the side, freeing up the relevant resources
    to service others until your work is done.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，让我们看看许多其他餐厅使用的模型。在这种情况下，你走到收银台并下单（他/她将其交给厨房）；然后他/她接受你的付款并给你一个凭证。然后你走到一边，收银员继续服务下一个顾客。当你的订单准备好时，厨房服务器通过叫你的名字或闪烁你的凭证号码来宣布这一点，然后你走过去取你的订单。这种面向事件的方法优化了收银员的工作，并让你在旁边等待，直到你的工作完成，从而释放相关资源为其他人提供服务。
- en: In Node.js, the server is the cashier, and all the handlers are the kitchen
    crew. The server accepts a request and spins it off to a handler. It then moves
    on to accept other requests. When the request is processed and the results are
    in place, the response is queued on the server and sent back to the client when
    it reaches the front of the queue.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，服务器就是收银台，所有的处理程序都是厨房工作人员。服务器接受一个请求并将其分配给一个处理程序。然后它继续接受其他请求。当请求被处理并且结果就绪时，响应被排队在服务器上，并在到达队列前端时发送回客户端。
- en: As opposed to the traditional approach of launching the threads or processes
    of the server (which is similar to adding more cashiers), this method is more
    efficient, as the workers launched have dedicated responsibilities. This is much
    lighter and cheaper than replicating the entire server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的启动服务器线程或进程的方法（这类似于增加更多的收银员）相比，这种方法更高效，因为启动的工作者有专门的责任。这比复制整个服务器要轻便和便宜得多。
- en: In the sections ahead, we will see that we register the handlers or the workers
    with the server to handle certain requests, and all the server does is delegate
    the requests to these workers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到我们如何将处理程序或工作者注册到服务器上以处理某些请求，而服务器所做的只是将这些请求委派给这些工作者。
- en: The advantage of the event-driven design is that everything we design is non-blocking.
    "You don't wait on me, I call you" is the mantra that relieves us from the pain
    involved in waiting on a request to be fulfilled. It frees up the system resources
    that would have otherwise been spent in waiting on the request, so that they can
    be used for the other tasks in the queue. This allows the Node.js applications
    to give a very high performance and capability of handling a very high load.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动设计的优势在于我们设计的所有内容都是非阻塞的。“你不等待我，我召唤你”这句箴言使我们免受等待请求完成的痛苦。它释放了本应花费在等待请求上的系统资源，以便它们可以被用于队列中的其他任务。这使得Node.js应用程序能够提供非常高的性能和非常高的负载处理能力。
- en: Node.js is a modular framework with a modern module system from the ground up.
    Everything in Node.js is built as modules running in the V8 JavaScript engine.
    Every functionality in the platform is provided by means of modules. This keeps
    the platform lean and brings in only that what is required. Having a native module
    system also helps in keeping our applications modular.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个模块化框架，从底层开始就拥有一个现代的模块系统。Node.js中的所有内容都是构建在V8 JavaScript引擎中运行的模块。平台上的每个功能都是通过模块提供的。这使平台保持精简，只引入所需的内容。拥有本地的模块系统也有助于保持我们的应用程序模块化。
- en: JavaScript has become one of the most widely-used languages in the past few
    years and has a vibrant community. Node.js provides developers with a good platform
    that assists them in developing end-to-end applications in JavaScript. Node.js
    has also brought in many revolutionary concepts, namely, always asynchronous,
    non-blocking I/O, event-oriented servers, and so on. This has resulted in a very
    vibrant, large, and active community. New modules are coming up continuously,
    and the community provides active support and is very helpful. Most of the popular
    modules and frameworks built for Node.js generally come from the community and
    are mostly open source.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，JavaScript已经成为最广泛使用的语言之一，并且拥有一个充满活力的社区。Node.js为开发者提供了一个良好的平台，帮助他们使用JavaScript开发端到端应用程序。Node.js还引入了许多革命性的概念，例如始终异步、非阻塞I/O、面向事件的服务器等。这导致了一个非常活跃、庞大且活跃的社区。新的模块不断涌现，社区提供积极的支持，非常有帮助。为Node.js构建的大多数流行模块和框架通常来自社区，并且大多是开源的。
- en: Corporate backing
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 企业支持
- en: Many companies have invested heavily in Node.js in the past couple of years.
    From Ryan Dahl's employer, Joyent, to the creators of the Mojito framework (Internet
    giant Yahoo!), many companies have built products, platforms, frameworks, and
    services around Node.js. This kind of corporate commitment assures a stable future.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，许多公司都在Node.js上投入了大量资金。从Ryan Dahl的雇主Joyent到Mojito框架的创造者（互联网巨头Yahoo!），许多公司都围绕Node.js构建了产品、平台、框架和服务。这种企业承诺确保了稳定的未来。
- en: How to get Node.js
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何获取Node.js
- en: Due to the popularity of Node.js, it is very easy to get it working on any operating
    system. You can go to [http://nodejs.org/](http://nodejs.org/) and download the
    appropriate distribution for your operating system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node.js的流行，它在任何操作系统上运行都非常容易。你可以访问[http://nodejs.org/](http://nodejs.org/)下载适合你操作系统的适当版本。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Though Node.js works on any OS, as it comes from the *nix background, many modules
    might only work on Linux or other Unix systems; so it is best to use such a system
    if you have one at hand.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Node.js可以在任何操作系统上运行，但由于它来自*nix背景，许多模块可能只能在Linux或其他Unix系统上运行；因此，如果你手头有这样一个系统，最好使用它。
- en: 'If you are using Linux, in most cases, you should be able to install Node.js
    using your distribution''s package manager. As this information keeps changing,
    I''ll just point out the location instead. You''ll find the instructions for installing
    Node.js using package manager here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Linux，在大多数情况下，你应该能够使用你发行版的包管理器安装Node.js。由于这些信息不断变化，我只会指出位置。你可以在以下位置找到使用包管理器安装Node.js的说明：
- en: '[https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)'
- en: If you are using Mac OS or Windows, you should know that Node.js now provides
    an installer for these platforms, which is the recommended installation approach.
    You can also install using the source. Instead of repeating that process here,
    which is again subject to change, I'll suggest that you follow the official installation
    instructions on the Node.js wiki, on GitHub ([https://github.com/joyent/node/wiki/Installation](https://github.com/joyent/node/wiki/Installation)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Mac OS或Windows，你应该知道Node.js现在为这些平台提供了安装程序，这是推荐的安装方法。你也可以使用源代码进行安装。为了避免在这里重复该过程，这个过程也可能再次发生变化，我建议你遵循Node.js维基百科上的官方安装说明，GitHub（[https://github.com/joyent/node/wiki/Installation](https://github.com/joyent/node/wiki/Installation)）。
- en: Node.js package manager (npm)
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js包管理器（npm）
- en: If you installed Node.js using the installer from the Node.js website, you will
    already have npm installed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Node.js网站上的安装程序安装了Node.js，那么你将已经安装了npm。
- en: Also, if you followed the instructions to build from the source, you will probably
    have installed npm. If that is a yes, very good! If no, please do so now. For
    this, I recommend that you follow the instructions mentioned in the npm installation
    documentation ([https://github.com/isaacs/npm/](https://github.com/isaacs/npm/)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你按照说明从源代码构建，你可能会已经安装了npm。如果是这样的话，非常好！如果没有，请现在就安装。为此，我建议你遵循npm安装文档中提到的说明（[https://github.com/isaacs/npm/](https://github.com/isaacs/npm/)）。
- en: 'You can check if you have npm installed by typing the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下命令来检查你是否已安装npm：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should display the version of npm installed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示已安装的npm版本。
- en: For those who are wondering what npm is and why you would need a package manager
    for Node.js, npm is just what its name says; it provides an infrastructure in
    Node.js to distribute and manage packages. As I said earlier, Node.js is very
    modular. Node.js apps are built using many modules and third-party packages because
    npm provides an easy way of adding and managing third-party dependencies for our
    applications. We will see more on its use in a while.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些还在疑惑npm是什么以及为什么你需要为Node.js安装包管理器的人来说，npm正是其名字所描述的那样；它为Node.js提供了一个基础设施，用于分发和管理包。正如我之前所说的，Node.js非常模块化。Node.js应用程序使用许多模块和第三方包来构建，因为npm为我们提供了添加和管理第三方依赖项的简单方法。我们稍后会看到它的更多用途。
- en: Hello World with Node.js
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World with Node.js
- en: 'Here, the obligatory Hell World example uses Node.js. Write the following line
    in a file called `helloworld.js` and save it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，必做的Hello World示例使用了Node.js。在一个名为`helloworld.js`的文件中写下以下行，并保存：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And now to run it, execute the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要运行它，请执行以下命令：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This should print **Hello World** on the console. All the JavaScript developers
    will immediately recognize that these are the steps we follow to print anything
    on the console while developing a web application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在控制台打印出**Hello World**。所有JavaScript开发者都会立即认出，这些是我们开发Web应用程序时在控制台上打印任何内容的步骤。
- en: What happens is that Node.js loads the JavaScript file in the JavaScript VM,
    provides an environment for its execution, and the VM interprets the script. When
    it gets `console.log`, it checks the environment for the console, which in this
    case is `STDOUT`, and writes **Hello World** to it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是，Node.js在JavaScript虚拟机中加载JavaScript文件，为其执行提供环境，虚拟机解释脚本。当它遇到`console.log`时，它会检查环境中的控制台，在这种情况下是`STDOUT`，并将**Hello
    World**写入其中。
- en: But we are here to develop web applications, correct? So let's say hello to
    the Web!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们在这里是为了开发Web应用程序，对吧？所以让我们向Web问好！
- en: Hello Web
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello Web
- en: 'Let us make a very simple web application that greets the user with a hello.
    Write the following code in a file, and name it `helloweb.js`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个非常简单的Web应用程序，它会对用户说“你好”。在文件中写下以下代码，并将其命名为`helloweb.js`：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To run the previous piece of code, execute `helloweb.js` in Node.js:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行前面的代码片段，请在Node.js中执行`helloweb.js`：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And then open `http://localhost:9999/` in your browser. You should see a page
    saying **Hello Web**. There is a lot going on here! So let us walk through the
    code and understand what is going on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在浏览器中打开`http://localhost:9999/`。你应该会看到一个写着**Hello Web**的页面。这里有很多事情在进行中！所以让我们一步步地看代码，了解发生了什么。
- en: The very first line of code introduces us to one of the fundamental building
    blocks of Node.js, the module system. Node.js has a very simple module system
    built on CommonJS. Those familiar with frontend development using RequireJS with
    **Asynchronous Module Definition (AMD)** will immediately relate to this. All
    the functionality in Node.js is built as modules and you need to import it in
    your code using `require`. Node.js has several modules compiled in a binary form,
    called core modules, HTTP being one of them. We can also create and include our
    own custom or third-party modules using `require`. In case of file modules, there
    is one-to-one mapping between a file and a module; so we write every module in
    its own file. We will see more on writing our own modules later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行向我们介绍了Node.js的一个基本构建块，即模块系统。Node.js有一个基于CommonJS的非常简单的模块系统。那些熟悉使用RequireJS进行前端开发并使用**异步模块定义（AMD）**的人会立即联想到这一点。Node.js中的所有功能都作为模块构建，你需要使用`require`在代码中导入它。Node.js有几个以二进制形式编译的模块，称为核心模块，HTTP就是其中之一。我们也可以使用`require`创建和包含我们自己的自定义或第三方模块。在文件模块的情况下，文件和模块之间存在一对一的映射；因此，我们将在自己的文件中编写每个模块。我们稍后会看到更多关于编写我们自己的模块的内容。
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this statement, Node.js will load the core HTTP module, and it will be
    available in a variable called `http`. The next task is to create a server using
    the HTTP module. This is done using the `createServer` method from the module.
    The `createServer` method accepts `requestListener`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个语句，Node.js将加载核心HTTP模块，并且它将在名为`http`的变量中可用。下一个任务是使用HTTP模块创建一个服务器。这是通过模块中的`createServer`方法完成的。`createServer`方法接受`requestListener`。
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `requestListener` is a function that handles the incoming requests. In our
    case, this function is passed *inline*. Just like JavaScript in a browser, Node.js
    also runs a single process and a single thread. This is different from the traditional
    application servers, which create a new thread or process to handle new requests.
    So to scale and handle multiple requests, Node.js uses asynchronous event handling.
    So every request that comes in triggers an event, which is then handled by the
    event handler asynchronously. This is the mechanism of the event loop explained
    in earlier sections.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestListener` 是一个处理传入请求的函数。在我们的例子中，这个函数是直接传递的。就像浏览器中的 JavaScript 一样，Node.js
    也运行在一个单独的进程和线程中。这与传统的应用服务器不同，传统的应用服务器会为新的请求创建一个新的线程或进程。因此，为了扩展和处理多个请求，Node.js
    使用异步事件处理。所以每个传入的请求都会触发一个事件，然后由事件处理器异步处理。这就是前面章节中解释的事件循环机制。'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: The way `createServer` works is similar to any event handler in JavaScript.
    The event in this case is receiving a request to serve. As we can see, `requestListener`
    takes two arguments, `request` and `response`. The `request` object is an instance
    of `http.ServerRequest`, and will have all the information about the request,
    such as URL, method, headers, and data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`createServer` 的工作方式与 JavaScript 中的任何事件处理器类似。在这个例子中，事件是接收一个请求来服务。正如我们所看到的，`requestListener`
    接受两个参数，`request` 和 `response`。`request` 对象是 `http.ServerRequest` 的一个实例，它将包含有关请求的所有信息，例如
    URL、方法、头和数据。'
- en: 'The `response` object is an instance of `ServerResponse`, which implements
    a `WritableStream`. It exposes various methods to write the response to the client;
    the ones we are most interested in, for now, are `writeHead`, `write` and `end`.
    Let us first see `writeHead`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`response` 对象是 `ServerResponse` 的一个实例，它实现了 `WritableStream` 接口。它暴露了各种方法来将响应写入客户端；目前我们最感兴趣的方法是
    `writeHead`、`write` 和 `end`。让我们首先看看 `writeHead`：'
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, `statusCode` is the HTTP response code, `reasonPhrase` is the optional
    human-readable response phrase, and `headers` is the object that has the headers,
    which are to be sent in the response. This function should be called only once,
    before calling `response.end`. If we call `response.write` or `response.end` before
    this, the implicit/mutable headers will be calculated and the following function
    will be called automatically:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`statusCode` 是 HTTP 响应码，`reasonPhrase` 是可选的供人类阅读的响应短语，`headers` 是包含要发送在响应中的头的对象。这个函数应该只调用一次，在调用
    `response.end` 之前。如果我们在这个之前调用 `response.write` 或 `response.end`，隐式/可变的头将被计算，并且下面的函数将自动被调用：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this call, we are setting the status code to `200`, that is, HTTP OK, and
    we are only setting the `Content-Type` header to `text/html`. The next method
    here is `response.write`, it''s used to write the response content to the client.
    The call to this method is done as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次调用中，我们将状态码设置为 `200`，即 HTTP OK，并且我们只设置了 `Content-Type` 头为 `text/html`。这里的方法是
    `response.write`，它用于将响应内容写入客户端。对这个方法的调用如下：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this call, `chunk` is the content to write and `encoding` is the content
    encoding to use. If the chunk is a string and the encoding is not specified, UTF-8
    will be used by default.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次调用中，`chunk` 是要写入的内容，`encoding` 是要使用的编码。如果 `chunk` 是一个字符串并且没有指定编码，默认将使用 UTF-8。
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the above code, the first time `write` is called, Node.js sends the response
    headers and the chunk of the body. But the `write` method can then be called multiple
    times. Node.js will assume that we are streaming data, and will keep sending the
    chunk whenever the calls are made. And the last call on the response is made to
    tell Node.js that we are done. This is just what `response.end` does.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，第一次调用 `write` 时，Node.js 会发送响应头和响应体的一个片段。但 `write` 方法可以被多次调用。Node.js 会假设我们正在流式传输数据，并且会在每次调用时发送数据块。最后对响应的调用是用来告诉
    Node.js 我们已经完成。这正是 `response.end` 所做的。
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`response.end` signals to the server that all the response headers and body
    content have been sent and that the server should consider this message complete.
    We *must* call this method for every message.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`response.end` 向服务器发出信号，表示所有响应头和主体内容都已发送，服务器应认为这条消息已完整。我们*必须*为每条消息调用此方法。'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our case, we call `response.end` without any of the optional arguments. If
    we do pass in the parameters, it is equivalent to calling `response.write` with
    the parameters, followed by `response.end`. I prefer keeping them separate, and
    hence, explicit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们调用 `response.end` 而不带任何可选参数。如果我们确实传递了参数，那么它等同于调用 `response.write`
    并传递参数，然后调用 `response.end`。我更喜欢将它们分开，并且明确地这样做。
- en: Finally, we need to tell the HTTP server which port it should listen on. In
    this case, we tell it to listen on port 9999.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要告诉 HTTP 服务器它应该监听哪个端口。在这种情况下，我们告诉它监听端口 9999。
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Routing the requests
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求路由
- en: Almost any web application serves more than a single resource. So now we know
    how to serve content using an HTTP server; but how do we handle multiple resources?
    Routing is the name of the game. We need to understand the incoming request and
    map it to the appropriate request handler. This is a bit more complicated than
    the previous example, so we will build it step by step, improving it with every
    step.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何 Web 应用程序都服务于多个资源。因此，现在我们知道如何使用 HTTP 服务器提供内容；但我们如何处理多个资源呢？路由就是关键。我们需要理解传入的请求并将其映射到适当的请求处理器。这比之前的例子要复杂一些，所以我们将逐步构建它，每一步都进行改进。
- en: 'To demonstrate the routing of requests, let us build a simple application that
    serves two resources at `/start` and `/finish`, displaying **Hello** and **Goodbye**
    respectively. To simplify the code, we will serve plain text. So before anything
    else, let''s take a look at the code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示请求的路由，让我们构建一个简单的应用程序，该应用程序在 `/start` 和 `/finish` 路径上提供两个资源，分别显示 **Hello**
    和 **Goodbye**。为了简化代码，我们将提供纯文本。因此，在所有其他事情之前，让我们先看看代码：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save the previous code snippet in a file called `routing.js` and execute it
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前的代码片段保存到名为 `routing.js` 的文件中，并按以下方式执行：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, when we access `http://localhost:9999/start`, we will see **Hello** in
    the browser. Similarly, when we access `http://localhost:9999/finish`, we will
    see a message saying **Goodbye**. If we try to access any other path, we will
    get an HTTP 404 or Not Found error. Let us now try and understand the new things
    we are introducing in this example.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们访问 `http://localhost:9999/start` 时，我们将在浏览器中看到 **Hello**。同样，当我们访问 `http://localhost:9999/finish`
    时，我们将看到一个显示 **Goodbye** 的消息。如果我们尝试访问任何其他路径，我们将得到一个 HTTP 404 或未找到错误。现在让我们尝试理解在这个例子中引入的新内容。
- en: The first thing that we need in order to route a request, is to parse the URL;
    for this we will introduce another inbuilt module called `url`. When a URL string
    is parsed using the `url` module, it returns an instance of the URL. In this case,
    we are interested in the pathname.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了路由一个请求，我们首先需要解析 URL；为此，我们将引入另一个内置模块，称为 `url`。当使用 `url` 模块解析 URL 字符串时，它返回一个
    URL 实例。在这种情况下，我们感兴趣的是路径名。
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the previous line of code, we are passing the `url` string from the request,
    and parsing it using the `url` module, to get the `pathname`. The next step is
    to send an appropriate response, based on the path being accessed:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们正在传递请求中的 `url` 字符串，并使用 `url` 模块对其进行解析，以获取 `pathname`。下一步是根据访问的路径发送适当的响应：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we are comparing the pathname with the one we are expected to handle, and
    accordingly an appropriate response is sent out. And what happens to the requests
    we don't handle? That is what the last part of the if-else-if ladder does. It
    sends an HTTP 404 error.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将路径名与我们期望处理的路径名进行比较，并相应地发送适当的响应。那么，对于我们没有处理的请求会发生什么呢？这就是 if-else-if
    阶梯的最后一部分所做的事情。它发送一个 HTTP 404 错误。
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let us think about extending this application. To handle more paths, we
    will have to add more if-else conditions. But that doesn''t look clean, is difficult
    to read, and is very inefficient in execution. Think about the route handled in
    the last step of the if-else ladder; the process still has to go through the entire
    ladder, checking for every condition. Also, adding new routes to this will require
    us to go through and edit this if-else ladder, which will be at the very least,
    confusing, and can also easily result in errors, typos, and a high chance of unintentional
    modification to the existing routes. So let us make it a bit cleaner by putting
    the handlers in an object mapped by their paths, and also provide an API to extend
    it. So let us change our code to look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑扩展这个应用程序。要处理更多的路径，我们必须添加更多的if-else条件。但这看起来并不干净，难以阅读，并且在执行上非常低效。想想if-else层级结构的最后一步处理的路由；这个过程仍然必须通过整个层级结构，检查每个条件。此外，向其中添加新路由将需要我们遍历并编辑这个if-else层级结构，这至少会让人困惑，也可能导致错误、打字错误，以及无意中修改现有路由的高度可能性。因此，让我们通过将处理程序放入按路径映射的对象中，并也提供一个API来扩展它，使其变得更加干净。因此，让我们将我们的代码修改如下：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To run this code snippet, execute the file with Node.js, using the following
    command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此代码片段，请使用以下命令使用Node.js执行文件：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The functionality of the application will be the same as the result of the previous
    example. When we access either `/start` or `/finish`, it will respond with **Hello**
    for the former, and **Goodbye** for the latter. On trying to access any other
    path, we will get an HTTP 404 message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的功能将与上一个示例的结果相同。当我们访问`/start`或`/finish`时，它将分别为前者响应**Hello**，为后者响应**Goodbye**。尝试访问任何其他路径时，我们将收到HTTP
    404消息。
- en: The change we have made here is that we have thrown out the if-else-if ladder
    in favor of a clean and efficient design approach. In this approach, we don't
    need to play around with existing routes and can add new routes by calling the
    `route.for` method from any module. The route has a map of the path to the `handler`
    function and also has a `on` method to add new routes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的改变是，我们放弃了if-else-if的层级结构，转而采用了一种干净且高效的设计方法。在这种方法中，我们不需要与现有的路由打转，可以通过从任何模块中调用`route.for`方法来添加新的路由。路由有一个指向`handler`函数的路径映射，并且还有一个`on`方法来添加新的路由。
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we are adding two new handlers for the paths `/start` and `/finish`. The
    signature for the handlers is similar to the main request handler. We expect the
    handlers to get the request and response, so that the handler has everything it
    needs to process the request and send the response.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为路径`/start`和`/finish`添加了两个新的处理程序。处理程序的签名与主请求处理程序类似。我们期望处理程序能够获取请求和响应，这样处理程序就有处理请求和发送响应所需的一切。
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the if condition, we check whether the route for the pathname is present,
    and whether it is a function. If we find a handler for the requested path, we
    execute the `handler` function, passing the request and response to it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在if条件中，我们检查路径名对应的路由是否存在，以及它是否是一个函数。如果我们找到了请求路径的处理程序，我们将执行`handler`函数，并将请求和响应传递给它。
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If it is not found, we respond with an HTTP 404 error. Now, to add a new path,
    we can call the `route.on` method with the path and its handler to register it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到，我们将以HTTP 404错误响应。现在，要添加新的路径，我们可以通过调用带有路径及其处理程序的`route.on`方法来注册它。
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: HTTP Methods
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP方法
- en: 'HTTP is not only about the path, we also have to think about the HTTP methods.
    In this section, we will enhance our app to handle the different HTTP methods:
    `GET`, `POST`, `PUT`, and `DEL` `TE`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP不仅关乎路径，我们还要考虑HTTP方法。在本节中，我们将增强我们的应用程序以处理不同的HTTP方法：`GET`、`POST`、`PUT`和`DEL`
    `TE`。
- en: 'As the first step towards this, we will add the ability to add different handlers
    for different methods. We will add the methods in the mapping in resources.js,
    which is a minor change. This is shown in the following code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一步骤的第一步，我们将添加为不同的方法添加不同处理程序的能力。我们将在resources.js中的映射中添加方法，这是一个小的改动。这在上面的代码片段中显示：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Save the file and execute with Node.js. The functionality still remains the
    same, but we will be able to handle different methods using different handlers.
    Let us create a new handler to echo the incoming data on `POST`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并使用Node.js执行。功能仍然保持不变，但我们将能够使用不同的处理程序处理不同的方法。让我们创建一个新的处理程序来在`POST`上回显传入的数据。
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here we are adding a new handler for the `POST` request on the `/echo` path.
    We again see the use of the event-driven approach of Node.js, this time in handling
    the data that comes in with `POST`. Since `request` is an event emitter, we attach
    an event handler to it for each task: for handling chunks of incoming data and
    for completing the request processing once all the data is received.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为`/echo`路径上的`POST`请求添加了一个新的处理器。我们再次看到了Node.js事件驱动方法的使用，这次是在处理通过`POST`传入的数据。由于`request`是一个事件发射器，我们为每个任务（处理传入的数据块和完成请求处理）都附加了一个事件处理器。
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the previous piece of code, we add a listener on the request to handle chunks
    of incoming data. In this case, all we do is accumulate the incoming data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们在请求上添加了一个监听器来处理传入的数据块。在这种情况下，我们只是累积传入的数据。
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The event handler on `end` will be invoked once all the data sent in `POST`
    has been received. This is the time at which we finish receiving all the data.
    To build an echo service, we will send back all the accumulated data. We will
    now create a form to post the request to this handler.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`end`事件处理器中，一旦接收到所有通过`POST`发送的数据，它将被调用。这是我们完成接收所有数据的时刻。为了构建一个回显服务，我们将发送回所有累积的数据。现在，我们将创建一个表单来向此处理器提交请求。
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will add an event handler to the same path (`/echo`), but this time, to handle
    a `GET` request. In the handler, we will return an HTML page with a form to post
    to the same path.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在相同的路径（`/echo`）上添加一个事件处理器，但这次是为了处理`GET`请求。在处理器中，我们将返回一个包含表单的HTML页面，该表单将提交到相同的路径。
- en: Add these two handlers to our `route-handlers.js` and execute it with Node.js.
    To open our form, go to `http://localhost:9999/echo`; then, to trigger our handler,
    type in a message in the form's textbox and click on the **echo** button. This
    will post the content of the form, and in response we will see `msg=<your text>`
    in the browser.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个处理器添加到我们的`route-handlers.js`中，并使用Node.js执行它。要打开我们的表单，请访问`http://localhost:9999/echo`；然后，要触发我们的处理器，请在表单的文本框中输入一条消息，并点击**回显**按钮。这将提交表单的内容，浏览器中我们将看到`msg=<your
    text>`。
- en: Creating our own Modules
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的模块
- en: 'Modules are the basic building blocks of Node.js applications. With all our
    changes, our file is becoming a bit clumsy; moreover, we are putting our infrastructure
    (server and router) with the application logic (the handlers) in the same place.
    As mentioned earlier, Node.js builds on the CommonJS module system. In Node.js,
    a module and a file have a one-to-one relation. Let us move the server and router
    to their own modules. Save the following in a file called `server.js`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是Node.js应用程序的基本构建块。随着我们所有的更改，我们的文件正变得有些杂乱；此外，我们将基础设施（服务器和路由器）与应用程序逻辑（处理器）放在了同一个地方。如前所述，Node.js建立在CommonJS模块系统之上。在Node.js中，模块和文件有一对一的关系。让我们将服务器和路由器移动到它们自己的模块中。将以下内容保存到一个名为`server.js`的文件中：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Most of the logical aspects of the code remain the same, but we have made some
    very subtle structural changes. The first one is that we have taken the routes
    out of the `route` object. Any variables declared in the file are available within
    the module and are not accessible from outside the module.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的逻辑方面大部分保持不变，但我们做了一些非常微妙的结构变化。第一个变化是我们将路由从`route`对象中移除。在文件中声明的任何变量都在模块内部可用，且不可从外部访问。
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As the `route` object is gone, we can now directly access the routes within
    the module and not through the `route` object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`route`对象已不存在，我们现在可以直接访问模块内的路由，而不是通过`route`对象。
- en: The other and more obvious change is `exports`. Since nothing from within the
    module is available outside the module, we have to add the methods/objects that
    we want to expose to the implicit `exports` object. Ideally, you should expose
    only those methods relevant to the end user of your module.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更明显的改变是`exports`。由于模块内部没有任何内容可供外部访问，我们必须将想要公开的方法/对象添加到隐式的`exports`对象中。理想情况下，你应该只公开与模块最终用户相关的那些方法。
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We are exposing two methods from our module: the `forRoute` method (originally,
    the `on` method in the `route` object), and the `start` method that wraps the
    code to start the HTTP server. We also move the application logic to its own module
    called `app.js`, which is shown in the following code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从模块中公开了两个方法：`forRoute`方法（原本是`route`对象中的`on`方法），以及包装启动HTTP服务器的`start`方法。我们还把应用程序逻辑移动到名为`app.js`的单独模块中，如下代码片段所示：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Again, the logical aspects remain unchanged; the changes are only in the structure.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，逻辑方面保持不变；变化仅在于结构。
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The previous line, which is also the first line in the previous code snippet,
    shows us how our server module is loaded. This is similar to loading core modules
    like HTTP or URL, but here we are loading the module and passing its filename.
    The object created by this `require` method, the `server` object, will have two
    methods that will be exposed: `forRoute` and `start`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行，也是前一个代码片段中的第一行，展示了我们的服务器模块是如何被加载的。这类似于加载核心模块如HTTP或URL，但在这里我们加载了模块并传递了其文件名。由这个`require`方法创建的对象，即`server`对象，将有两个将被公开的方法：`forRoute`和`start`。
- en: Next, we replace all the calls to `route.on` with the `server.forRoute` method.
    . And finally, we call the `server.start` method to start the HTTP server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将所有对`route.on`的调用替换为`server.forRoute`方法。最后，我们调用`server.start`方法来启动HTTP服务器。
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Serving files
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件服务
- en: 'We can see that it''s not very intuitive or easy to write HTML pages with our
    current infrastructure. Writing the HTML in the JS code as strings is not fun.
    We would like to serve the HTML content from the HTML files. We will begin with
    taking in two modules, which we will need to read from a file (on the disk) in
    our `app` module:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，使用我们当前的基础设施编写HTML页面并不直观或容易。将HTML以字符串形式写入JS代码并不有趣。我们希望从HTML文件中服务HTML内容。我们将从需要从磁盘中的文件读取的`app`模块中的两个模块开始：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first one, `path`, is the module we use to work with paths, and `fs` is
    the module used to interact with the filesystem. The next step is to get the path
    to the application's root.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，`path`，是我们用来处理路径的模块，而`fs`是用于与文件系统交互的模块。下一步是获取应用程序根路径。
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`__dirname` is a variable managed by Node.js and has the absolute path to the
    directory of the Node.js application script. Now, we add the method that will
    be doing the heavy work of reading the file and sending it to the browser. Add
    this method to `app.js`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`__dirname`是由Node.js管理的变量，包含Node.js应用程序脚本的绝对路径。现在，我们添加一个将执行读取文件并发送到浏览器的大量工作的方法。将此方法添加到`app.js`中：'
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `serveStatic` method that we have created accepts two arguments, the HTTP
    response object and the file path to serve.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`serveStatic`方法接受两个参数，即HTTP响应对象和要服务的文件路径。
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We append the file path to our root path to build the absolute path of the file
    to serve. Here we are implicitly assuming that all the files to be served are
    relative to the Node.js application root; this will prevent a file outside the
    application from being served by mistake. Node.js handles I/O as streams. We can
    see that this is similar to the way it handles the incoming `POST` data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件路径追加到我们的根路径，以构建要服务的文件的绝对路径。这里我们隐式地假设所有要服务的文件都是相对于Node.js应用程序根目录的；这将防止错误地由应用程序之外的文件提供服务。Node.js以流的形式处理I/O。我们可以看到这类似于它处理传入的`POST`数据的方式。
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use `createReadStream` from the `fs` module to create a stream that reads
    from the file. This stream again demonstrates the non-blocking, asynchronous,
    and event-driven approach of Node.js.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`fs`模块中的`createReadStream`创建一个从文件读取的流。这个流再次展示了Node.js的非阻塞、异步和事件驱动方法。
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The stream works as an event emitter, triggering the `'data'` event when there
    is new data on the stream. This allows the application to continue with the other
    processing activities, without having to wait for the data to be read. What we
    are doing here is, we are writing the data we receive on every `read` to the `response`
    stream.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 流作为一个事件发射器，当流上有新数据时触发`'data'`事件。这允许应用程序继续进行其他处理活动，而无需等待数据被读取。我们在这里所做的是，将每次`read`接收到的数据写入`response`流。
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once all the data from the file is read and the stream gets an EOF, it will
    trigger the `'end'` event. We will call `end` on our response as well. Finally,
    we will modify the `GET` handler `"/echo"` to serve from a file called `echo.html`,
    and write the content of the HTML to be served to that file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取了文件中的所有数据，并且流接收到EOF（文件结束标志），它将触发`'end'`事件。我们也会在我们的响应上调用`end`。最后，我们将修改`GET`处理器`"/echo"`以从名为`echo.html`的文件中提供服务，并将要服务的HTML内容写入该文件。
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have removed all the code to build the `response` string, replacing it with
    a call to `serveStatic` to serve `echo.html`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经移除了所有构建`response`字符串的代码，用对`serveStatic`的调用替换了它，以服务`echo.html`。
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The content that we were previously building as a string is now written to this
    file. Once we make these changes and run `app.js` with Node.js, you should be
    able to see the form on `http://localhost:9999/echo` retaining its original functionality.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前作为字符串构建的内容现在被写入这个文件。一旦我们做出这些更改并使用Node.js运行`app.js`，你应该能够在`http://localhost:9999/echo`上看到表单并保留其原始功能。
- en: Those familiar with Unix-like operating systems will realize that the functionality
    we just implemented to read from one stream and write to another can also implemented
    by using pipes (`|`). It shouldn't come as a surprise that Node.js provides a
    high-level function to do exactly the same.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉类Unix操作系统的用户会发现，我们刚刚实现的功能，即从一个流读取并写入另一个流，也可以通过使用管道（`|`）来实现。Node.js提供了一个高级函数来完成完全相同的功能，这并不令人惊讶。
- en: 'Using the `pipe` method provided on `stream` in Node, we can modify the `serveStatic`
    method as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node中`stream`提供的`pipe`方法，我们可以按如下方式修改`serveStatic`方法：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we are replacing the data and end event handlers using `stream.pipe(response)`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`stream.pipe(response)`替换了数据和结束事件处理器。
- en: Third party modules and Express JS
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方模块和Express JS
- en: 'Now that we have built a router of our own and understand the basics of Node.js,
    it is time to get introduced to one of the most widely-used frameworks for Node.js,
    Express ([http://expressjs.com](http://expressjs.com)). Node.js provides the infrastructural
    components to build a web application, but there is too much stuff to handle.
    Therein lies the role of the web frameworks. There are quite a few web frameworks
    that provide a higher level of abstraction for building applications on Node.
    You can see a list of most of them here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了自己的路由器并了解了Node.js的基础知识，是时候介绍Node.js最广泛使用的框架之一——Express ([http://expressjs.com](http://expressjs.com))了。Node.js提供了构建Web应用程序的基础组件，但处理的东西太多。这就是Web框架的作用所在。有相当多的Web框架为Node提供了构建应用程序的高级抽象。您可以在以下列表中看到其中大部分：
- en: '[https://github.com/joyent/node/wiki/Modules#wiki-web-frameworks-full](https://github.com/joyent/node/wiki/Modules#wiki-web-frameworks-full)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/joyent/node/wiki/Modules#wiki-web-frameworks-full](https://github.com/joyent/node/wiki/Modules#wiki-web-frameworks-full)'
- en: Express is a web application framework for Node, built over the Connect middleware,
    that provides many more helpers and structural aspects to build our web applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Express是一个基于Connect中间件的Node Web应用程序框架，它提供了许多辅助工具和结构化方面来构建我们的Web应用程序。
- en: To get started with the Express framework, we need to install it using npm,
    the Node.js package manager.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Express框架，我们需要使用npm，Node.js包管理器，来安装它。
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The previous command will install Express as a global (`-g`) module and make
    `express` available as a command. Let us create an Express app:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将Express作为一个全局（`-g`）模块安装，并使`express`作为一个命令可用。让我们创建一个Express应用：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will create a folder called `hello-express` with certain files and folders
    in it. Let us see and understand these files.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`hello-express`的文件夹，其中包含一些文件和文件夹。让我们看看并理解这些文件。
- en: The first file to understand is `package.json`. This is the file that defines
    a Node.js application package. It has the application metadata such as the name,
    description, and version. More importantly, it has the module dependencies listed.
    The dependency list is used by npm to download the required modules.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要理解的是`package.json`文件。这是定义Node.js应用程序包的文件。它包含应用程序元数据，如名称、描述和版本。更重要的是，它列出了模块依赖项。依赖项列表被npm用于下载所需的模块。
- en: '[PRE49]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The most important things in your `package.json` are the `name` and `version`
    fields. These fields are required, and together, they form a unique identifier
    for a particular release of the package. To begin with, let us change the name
    of our package to `hello-express`. The `version` field consists of the following
    (in the same order):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`package.json`中最重要的东西是`name`和`version`字段。这些字段是必需的，并且它们共同构成了包特定版本的唯一标识符。首先，让我们将我们的包名称更改为`hello-express`。`version`字段由以下内容组成（按相同顺序）：
- en: A number (major version)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字（主要版本）
- en: A period
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个点
- en: A number (minor version)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字（次要版本）
- en: A period
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个点
- en: A number (patch version)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字（补丁版本）
- en: 'Optional: a hyphen, followed by a number (build)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：一个连字符，后跟一个数字（构建）
- en: 'Optional: a collection of pretty much any non-whitespace characters (tag)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：一大堆几乎任何非空白字符的集合（标签）
- en: If we set `private` to true, npm will not publish it to a repository. This ensures
    that you don't end up publishing your code to a public repository by mistake.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `private` 设置为 true，npm 将不会将其发布到仓库。这确保了您不会不小心将代码发布到公共仓库。
- en: The `scripts` object has a mapping of commands to those points in the application
    lifecycle at which they should be run. In this package, we are telling Node.js
    that it should run the `node app` command when the application is started with
    npm. There are some predefined lifecycle commands, such as `start`, `stop`, `restart`,
    and `test`, which can be run using `npm <command>` like `npm start`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts` 对象将命令映射到应用程序生命周期中它们应该运行的那些点。在这个包中，我们告诉 Node.js，当使用 npm 启动应用程序时，它应该运行
    `node app` 命令。有一些预定义的生命周期命令，如 `start`、`stop`、`restart` 和 `test`，可以使用 `npm <command>`
    运行，例如 `npm start`。'
- en: You can also run arbitrary commands using `run-script`. For this, you add the
    command to the `scripts` object and then run it as `npm run-script <command>`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `run-script` 运行任意命令。为此，您将命令添加到 `scripts` 对象中，然后运行它作为 `npm run-script
    <command>`。
- en: And finally—the most interesting part of the package that brings in the magic—`dependencies`.
    This object is a mapping of the name and version of your dependency packages and
    will be used by npm to pull in all the required dependencies.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后——包中最有趣的部分，引入了魔法——`dependencies`。此对象是依赖包名称和版本的映射，将由 npm 用于拉取所有必需的依赖项。
- en: 'In our package, `express` has already defined the dependency on Express and
    Jade. To pull in these dependencies, run the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的包中，`express` 已经定义了对 Express 和 Jade 的依赖。要引入这些依赖项，请运行以下命令：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The output will list all the dependencies it downloaded.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将列出它下载的所有依赖项。
- en: '**jade@0.27.2 node_modules/jade**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**jade@0.27.2 node_modules/jade**'
- en: '**├── commander@0.6.1**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**├── commander@0.6.1**'
- en: '**└── mkdirp@0.3.0**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**└── mkdirp@0.3.0**'
- en: '**express@3.0.0rc2 node_modules/express**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**express@3.0.0rc2 node_modules/express**'
- en: '**├── methods@0.0.1**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**├── methods@0.0.1**'
- en: '**├── fresh@0.1.0**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**├── fresh@0.1.0**'
- en: '**├── range-parser@0.0.4**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**├── range-parser@0.0.4**'
- en: '**├── cookie@0.0.4**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**├── cookie@0.0.4**'
- en: '**├── crc@0.2.0**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**├── crc@0.2.0**'
- en: '**├── commander@0.6.1**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**├── commander@0.6.1**'
- en: '**├── debug@0.7.0**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**├── debug@0.7.0**'
- en: '**├── mkdirp@0.3.3**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**├── mkdirp@0.3.3**'
- en: '**├── send@0.0.3 (mime@1.2.6)**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**├── send@0.0.3 (mime@1.2.6)**'
- en: '**└── connect@2.4.2 (pause@0.0.1, bytes@0.1.0, qs@0.4.2, formidable@1.0.11)**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**└── connect@2.4.2 (pause@0.0.1, bytes@0.1.0, qs@0.4.2, formidable@1.0.11)**'
- en: The dependencies will be placed in a folder called `node_modules`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项将被放置在一个名为 `node_modules` 的文件夹中。
- en: 'Next, we will take a look at the application file `app.js`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看应用程序文件 `app.js`：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the first few lines, Node.js loads the modules required for us to work with.
    We are already familiar with `http` and `path`. The `express` module brings in
    the Express framework. And one more module that we are loading in is `./routes`,
    which will load the module defined in the local `routes` folder, defined by `./routes/index.js`.
    The following code snippet focuses on the first few lines of the previous code
    snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几行中，Node.js 加载了我们工作所需的模块。我们已经熟悉 `http` 和 `path`。`express` 模块引入了 Express 框架。我们还在加载一个模块
    `./routes`，它将加载本地 `routes` 文件夹中定义的模块，该文件夹由 `./routes/index.js` 定义。以下代码片段关注前一个代码片段的前几行：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the next line, it instantiates the Express framework as an app:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，它将 Express 框架实例化为一个应用：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then comes the application configuration:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是应用程序配置：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the previous few lines, we are defining a function that will configure the
    app. The signature for `app.configure` is `app.configure([env], callback)`, where
    `env` is the runtime environment variable *or* the production environment variable,
    as is defined by `process.env.NODE_ENV`. When we don't specify `env`, it will
    be set for all environments.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的几行中，我们正在定义一个将配置应用的函数。`app.configure` 的签名是 `app.configure([env], callback)`，其中
    `env` 是运行时环境变量 *或* 生产环境变量，如由 `process.env.NODE_ENV` 定义。当我们不指定 `env` 时，它将为所有环境设置。
- en: 'The following settings have been provided to alter how Express behaves:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下设置已提供，以改变 Express 的行为：
- en: '`env`: Environment mode, defaults to `process.env.NODE_ENV` or "development"'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`: 环境模式，默认为 `process.env.NODE_ENV` 或 "development"'
- en: '`trust proxy`: Enables reverse proxy support, disabled by default'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trust proxy`: 启用反向代理支持，默认禁用'
- en: '`jsonp callback`: Enables JSONP callback support, enabled by default'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonp callback`: 启用 JSONP 回调支持，默认启用'
- en: '`jsonp callback name`: Changes the default callback name of `?callback=`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonp callback name`: 改变默认的回调名称 `?callback=`'
- en: '`json replacer`: JSON replacer callback, `null` by default'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json replacer`: JSON 替换回调，默认为 `null`'
- en: '`json spaces`: JSON response spaces for formatting; defaults to `2` in development,
    `0` in production'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json spaces`: 用于格式化的 JSON 响应空格；开发中默认为 `2`，生产中为 `0`'
- en: '`case sensitive routing`: Enables case sensitivity, disabled by default, treating
    `/Foo` and `/foo` as the same'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case sensitive routing`: 启用大小写敏感的路由，默认禁用，将 `/Foo` 和 `/foo` 视为相同'
- en: '`strict routing`: Enables strict routing, by default `/foo` and `/foo/` are
    treated the same by the router'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strict routing`: 启用严格路由，默认情况下 `/foo` 和 `/foo/` 由路由器视为相同'
- en: '`view cache`: Enables view template compilation caching, enabled in production
    by default'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view cache`: 启用视图模板编译缓存，默认在生产环境中启用'
- en: '`view engine`: The default engine extension to use when omitted'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view engine`: 当省略时使用的默认引擎扩展'
- en: '`views`: The view directory path'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`: 视图目录路径'
- en: 'The following code snippet demonstrates how to assign settings to an application:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何将设置分配给应用程序：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The settings used by the application here are `port`, `views`, and `view engine`,
    specifying that the application should run on port `3000`, the views will be placed
    in the `views` folder, and the engine to be used is Jade. We will see more about
    views later. Certain features can also be specified, as shown in the following
    snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里应用程序使用的设置是 `port`、`views` 和 `view engine`，指定应用程序应在端口 `3000` 上运行，视图将放置在 `views`
    文件夹中，使用的引擎是 Jade。我们将在后面看到更多关于视图的内容。也可以指定某些功能，如下面的代码片段所示：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As Express builds over Connect middleware, it brings in a lot of existing functionality
    from Connect. Connect's `use` method configures the app to utilize the given middleware
    handle for the given route, where the route defaults to `/`. You can see the list
    of middleware provided by Connect at [http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Express 基于 Connect 中间件构建，它带来了许多来自 Connect 的现有功能。Connect 的 `use` 方法配置应用程序以利用给定的中间件处理程序来处理给定的路由，其中路由默认为
    `/`。你可以在 [http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)
    看到Connect提供的中间件列表。
- en: Let us walk through the middleware components being used here. The Favicon middleware
    will serve the favicon for the application. The Logger middleware logs requests
    in a custom format.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遍历这里使用的中间件组件。Favicon 中间件将提供应用程序的 favicon。Logger 中间件以自定义格式记录请求。
- en: The Body parser parses the request bodies supporting different formats; this
    includes `application/json`, `application/x-www-form-urlencoded`, and `multipart/form-data`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Body 解析器解析支持不同格式的请求体；这包括 `application/json`、`application/x-www-form-urlencoded`
    和 `multipart/form-data`。
- en: Method Override enables the faux HTTP method support. This means that if we
    would like to stimulate the `DELETE` and `PUT` method calls to our application,
    we can do it by adding a `_method` parameter to the request.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 方法覆盖启用模拟 HTTP 方法支持。这意味着如果我们想刺激对应用程序的 `DELETE` 和 `PUT` 方法调用，我们可以通过在请求中添加 `_method`
    参数来实现。
- en: '`app.router` provides an enhanced version of Connect''s `router` module. Basically,
    this is the component that determines what to do when we use routing methods like
    `app.get`. The last middleware, Static, provides a static file server and configures
    it, serving files from the `public` directory.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.router` 提供了 Connect 的 `router` 模块的增强版本。基本上，这是当我们使用 `app.get` 等路由方法时确定要做什么的组件。最后一个中间件，静态文件服务器，提供并配置了它，从
    `public` 目录提供文件。'
- en: For the development environment, the following two lines of code show how to
    set up the Error handler middleware so as to provide stack traces and error messages
    in the responses.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发环境，以下两行代码显示了如何设置错误处理中间件，以便在响应中提供堆栈跟踪和错误消息。
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The next line configures the router to route `/` to be handled by the `index`
    method in the `routes` module:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行配置路由器将 `/` 路由处理为由 `routes` 模块中的 `index` 方法处理：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At the end, we start the HTTP server configured to use the app instance that
    we just configured.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动配置为使用我们刚刚配置的应用实例的 HTTP 服务器。
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the configuration of the app, we saw some folders coming into play, namely,
    `routes`, `views`, and `public`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序配置中，我们看到了一些文件夹开始发挥作用，即 `routes`、`views` 和 `public`。
- en: '`routes` is a module that we will be writing all our handlers to. In the case
    of `/`, we have mapped it to serve from the index method, using the `routes.index`
    method. If you open `routes/index.js`, you will see that `index` is a method exposed
    from this module.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes` 是我们将编写所有处理程序的模块。在 `/` 的情况下，我们将其映射到使用 `index` 方法从 `routes.index` 方法提供服务。如果你打开
    `routes/index.js`，你会看到 `index` 是从这个模块公开的方法。'
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This function signature is similar to the handlers we wrote. It is a function
    that takes a request and response as parameters. Here we are using the Express
    method `response.render`, which will render the mentioned view using the second
    parameter as the model or data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数签名与我们编写的处理程序类似。它是一个接受请求和响应作为参数的函数。在这里，我们使用 Express 方法 `response.render`，它将使用第二个参数作为模型或数据来渲染提到的视图。
- en: The views are present in the `views` folder and use the Jade ([http://jade-lang.com/](http://jade-lang.com/))
    view engine. Jade is a high-performance template engine, heavily influencedby
    Haml ([http://haml.info/](http://haml.info/)), and implemented with JavaScript
    for Node.js. Like many modern HTML generation engines, Jade tries to make the
    UI code easier, cleaner, and simpler, getting rid of the inline code and the HTML
    tags noise.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 视图位于 `views` 文件夹中，并使用 Jade ([http://jade-lang.com/](http://jade-lang.com/))
    视图引擎。Jade 是一个高性能的模板引擎，深受 Haml ([http://haml.info/](http://haml.info/)) 的影响，并使用
    JavaScript 为 Node.js 实现。像许多现代 HTML 生成引擎一样，Jade 试图使 UI 代码更简单、更干净、更简单，去除了内联代码和 HTML
    标签的噪音。
- en: 'We will now see the views defined in our Express app. There are two files to
    see here: `layout.jade` and `index.jade`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到在 Express 应用程序中定义的视图。这里有两大文件需要查看：`layout.jade` 和 `index.jade`。
- en: '`layout.jade`, as the name suggests, is the template for the layout that will
    be used by the different pages in our application. It may be used to place the
    common code of the skeleton for the pages in our application, which is shown in
    the following snippet:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`layout.jade` 是我们将由应用程序中的不同页面使用的布局模板。它可以用来放置应用程序页面骨架的公共代码，如下面的代码片段所示：
- en: '[PRE61]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In Jade, we don''t need the `start` and `end` tags because it identifies the
    start and end of the tags by the indented blocks. So when we render this Jade
    file, it will generate the following HTML code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jade 中，我们不需要 `start` 和 `end` 标签，因为它通过缩进的代码块来识别标签的开始和结束。因此，当我们渲染这个 Jade 文件时，它将生成以下
    HTML 代码：
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the previous piece of code, two things are left undefined, `{TITLE}` and
    `{CONTENT}`. In the Jade template, we define the title as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，有两个东西尚未定义，`{TITLE}` 和 `{CONTENT}`。在 Jade 模板中，我们如下定义标题：
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We tell Jade to use the title from the data passed to `render` as `title`. The
    second thing, `{CONTENT}`, is defined as block in Jade.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉 Jade 使用传递给 `render` 的数据中的标题作为 `title`。第二件事，`{CONTENT}`，在 Jade 中定义为块。
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`block content` is a plugin point provided in the layout template, which can
    be described by any template extending from it.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`block content` 是在布局模板中提供的插件点，它可以由任何扩展它的模板描述。'
- en: '`index.jade` inherits from `layout.jade`. In our index handler, we render the
    index view using the data `{title: ''Express''}`. Take a look at the following
    code snippet:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.jade` 继承自 `layout.jade`。在我们的索引处理程序中，我们使用数据 `{title: ''Express''}` 来渲染索引视图。请看以下代码片段：'
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the previous file, we define the content block to have a `h1` and `p` tags.
    So, with the given input and because it extends the layout, the Jade engine will
    generate the following HTML:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个文件中，我们定义了内容块包含 `h1` 和 `p` 标签。因此，根据给定的输入并且因为它扩展了布局，Jade 引擎将生成以下 HTML：
- en: '[PRE66]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We will see more functionality and syntax in Jade as we work on our chat application
    in the next chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过我们的聊天应用程序来工作，届时我们将看到更多 Jade 的功能和语法。
- en: In the HTML code generated, we can see that `/stylesheets/style.css` is being
    referred to; this file is served by the static file server we configured in the
    app. We can find this and the other files in the public folder.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的 HTML 代码中，我们可以看到 `/stylesheets/style.css` 正在被引用；此文件由我们在应用程序中配置的静态文件服务器提供。我们可以在公共文件夹中找到此文件和其他文件。
- en: 'To run this application, we will use npm. Run the following command on the
    console:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此应用程序，我们将使用 npm。在控制台运行以下命令：
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Then go to `http://localhost:3000/`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后转到 `http://localhost:3000/`。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we were introduced to the Node.js and Express web frameworks.
    As mentioned earlier, this is in no way a complete introduction to Node.js or
    Express. To learn more, please refer to the vast documentation available online
    or any of the books written on Node.js web development.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Node.js 和 Express 网络框架。如前所述，这绝对不是对 Node.js 或 Express 的完整介绍。要了解更多信息，请参考在线上可用的广泛文档或任何关于
    Node.js 网络开发的书籍。
