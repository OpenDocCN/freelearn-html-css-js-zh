- en: Chapter 6. Controlling the Game with Virtual Pads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 使用虚拟垫控制游戏
- en: One of the most important things to consider when making a cross-platform game
    is the way the player will control the main character. Most of the devices your
    game will be running on won't have a keyboard or a mouse, and although more and
    more portable devices now support pads, your game must also be playable without
    pads.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作跨平台游戏时，需要考虑的一个重要因素是玩家将如何控制主要角色。你游戏将运行的大多数设备都没有键盘或鼠标，尽管越来越多的便携式设备现在支持垫子，但你的游戏也必须在没有垫子的情况下可玩。
- en: 'In this chapter, I will show you three of the most popular ways to create virtual
    pads on any device. Among other things, you will learn how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您展示在任意设备上创建虚拟垫的三种最流行的方法。除此之外，你还将学习如何：
- en: Scroll big images to give an idea of an endless background
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动大图像以给出无限背景的印象
- en: Schedule events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排事件
- en: Control the frame rate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制帧率
- en: Check collision between sprites
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查精灵之间的碰撞
- en: Create a simple particle system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的粒子系统
- en: Move sprites manually or using actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动移动精灵或使用动作
- en: So, the first thing to do is take a look at how successful games allow players
    to interact with them using virtual pads.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先要做的是看看成功游戏是如何让玩家通过虚拟垫与他们互动的。
- en: Overview of virtual pads
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟垫概述
- en: The oldest, simplest, and highly discouraged way to create virtual pads is placing
    directional buttons on the screen and controlling the character according to the
    button pressed by the player.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟垫最古老、最简单且高度不建议的方式是在屏幕上放置方向按钮，并根据玩家按下的按钮来控制角色。
- en: I also used this kind of virtual pad in the first version of my *Sokoban* game
    before I made the game playable with swipes, as I showed you during the creation
    of *Cocosban* game.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我在制作游戏可滑动操作之前，也在我的 *Sokoban* 游戏的第一个版本中使用了这种虚拟垫，正如我在 *Cocosban* 游戏制作过程中向您展示的那样。
- en: '![Overview of virtual pads](img/0075SOS_06_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟垫概述](img/0075SOS_06_01.jpg)'
- en: The Sokoban game
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sokoban* 游戏'
- en: In this game, you move the character by clicking or tapping exactly on an arrow
    button. It can fit in a slow-paced puzzle game, but becomes unplayable in a fast-paced
    arcade.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，你通过点击或轻触箭头按钮的精确位置来移动角色。它可以适应节奏较慢的解谜游戏，但在节奏较快的街机游戏中则无法玩。
- en: That's why famous platform games such as *Mikey Shorts* use ghost buttons. Ghost
    buttons act like normal buttons, but the sensible area is way bigger than the
    icon itself.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，著名的平台游戏如 *Mikey Shorts* 使用幽灵按钮。幽灵按钮像正常按钮一样工作，但可感区域比图标本身大得多。
- en: '![Overview of virtual pads](img/0075SOS_06_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟垫概述](img/0075SOS_06_02.jpg)'
- en: 'Although the buttons aren''t bigger than the ones used in my *Sokoban* game,
    the sensible area covers the entire screen: the actual red button sensible area
    is the whole column of the screen covering the red button icon, the blue button
    sensible area is the whole column of the screen covering the blue button icon,
    and so on.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然按钮的大小并不比我在 *Sokoban* 游戏中使用的大，但可感区域覆盖了整个屏幕：实际红色按钮的可感区域是覆盖红色按钮图标的整个屏幕列，蓝色按钮的可感区域是覆盖蓝色按钮图标的整个屏幕列，以此类推。
- en: 'Another way to handle virtual pads is by using the virtual analogic pad. Although,
    the way to control *Mikey Shorts* is digital, which means one button can only
    be pressed or released; sometimes, games require more precision in movements like
    the following screenshot of the *Grand Theft Auto* series:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 处理虚拟垫的另一种方式是使用虚拟模拟垫。尽管控制 *Mikey Shorts* 的方式是数字的，这意味着一个按钮只能被按下或释放；有时，游戏需要像以下
    *Grand Theft Auto* 系列截图所示的更精确的动作：
- en: '![Overview of virtual pads](img/0075SOS_06_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟垫概述](img/0075SOS_06_03.jpg)'
- en: On the bottom left-hand side of the screen, you can see a virtual analogic pad.
    The pad is initially activated by touching the screen, then the further you drag
    the pad from its original position, the faster the character will walk or run.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的左下角，你可以看到一个虚拟模拟垫。垫子最初是通过触摸屏幕激活的，然后你将垫子从原始位置拖得越远，角色行走或奔跑的速度就越快。
- en: 'Another way to create virtual pads that I would like to mention is the one
    used in the *VVVVVV* game, which does not show any icon. A screenshot of the *VVVVVV*
    game is shown as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提到的另一种创建虚拟垫的方式是 *VVVVVV* 游戏中使用的，它不显示任何图标。以下是一个 *VVVVVV* 游戏的截图：
- en: '![Overview of virtual pads](img/0075SOS_06_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟垫概述](img/0075SOS_06_04.jpg)'
- en: 'You simply move the character left and right by continuously dragging, or dragging
    and holding your finger on the device, and I have to say it works way better than
    the old virtual pad because you can virtually use any spot on the device to move.
    Above all, there isn''t any *origin* you have to cross to change direction: no
    matter how far you move your finger from the point you start touching, once you
    move the finger in the opposite direction, the character will walk in the other
    direction.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需通过连续拖动，或者拖动并按住设备上的手指来左右移动角色，我必须说这比旧的虚拟摇杆要好得多，因为你可以虚拟地使用设备上的任何位置来移动。最重要的是，没有必须跨越的任何*原点*来改变方向：无论你将手指从开始触摸的点移动多远，一旦你将手指向相反方向移动，角色就会向另一个方向行走。
- en: Now, apart from the first example, which I said is obsolete, you will see how
    to create all these ways to control your character with virtual pads.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除了我说过已经过时的第一个例子之外，你将看到如何使用虚拟摇杆创建所有这些控制角色的方法。
- en: First things first – the game
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先来看看游戏
- en: 'We are making a little game just to test our virtual pads: a landscape game
    with a shopping cart surrounded by falling bombs and strawberries trying to catch
    strawberries while avoiding bombs? Does it sound crazy? It is.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在制作一个小游戏来测试我们的虚拟摇杆：一个横幅游戏，购物车周围有下落的炸弹和草莓，试图抓住草莓同时避开炸弹？这听起来疯狂吗？是的。
- en: 'This is the content of our `assets` folder:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`assets`文件夹的内容：
- en: '![First things first – the game](img/0075SOS_06_05.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![首先，这是游戏](img/0075SOS_06_05.jpg)'
- en: The making of the entire game is very similar to the making of the endless space
    runner, so there's no need to talk about code you should already know.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 整个游戏的制作与无尽太空跑者的制作非常相似，因此没有必要谈论你应该已经知道的代码。
- en: 'This is the content of `main.js`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`main.js`的内容：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Just look at the resolution policy to make the game work in landscape mode.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 只需查看分辨率策略，就可以使游戏在横幅模式下运行。
- en: 'This is the content of `loadassets.js`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`loadassets.js`的内容：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The content of `gamescript.js`, as said, is very similar to the content of the
    endless space runner.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如所说，`gamescript.js`的内容与无尽太空跑者的内容非常相似。
- en: 'First, let''s take a look at the final result:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看最终结果：
- en: '![First things first – the game](img/0075SOS_06_06.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![首先，这是游戏](img/0075SOS_06_06.jpg)'
- en: We have a cart in the bottom center of the stage, and fruit and bombs falling
    every second with a random trajectory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在舞台的底部中央有一个购物车，每秒都有水果和炸弹随机轨迹下落。
- en: 'As I already told you, there''s nothing new! You should know everything you
    need to build this game. This is `gamescript.js`: first, you need two global variables
    to handle the cart itself and the layer that will be filled with fruit and bombs:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经告诉你的，没有什么新东西！你应该知道构建这个游戏所需的一切。这是`gamescript.js`：首先，你需要两个全局变量来处理购物车本身以及将要填充水果和炸弹的层：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `gameScene` is then defined as usual:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按常规定义`gameScene`：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `game` class declaration contains the core of the game itself:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`game`类声明包含了游戏本身的精髓：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This looks like it''s a lot of code, but there''s nothing new: we simply add
    a background gradient, then two layers: one for fruit and bombs and one for the
    cart, and finally, we add the cart itself. To create fruit and bombs, we use the
    `schedule` method, which calls the `addItem` function every second to create a
    new `Item` class instance, while the `removeItem` function will remove fruit and
    bombs once they fly off the screen.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像有很多代码，但没有什么新东西：我们只是添加了一个背景渐变，然后是两层：一层用于水果和炸弹，另一层用于购物车，最后添加了购物车本身。为了创建水果和炸弹，我们使用`schedule`方法，该方法每秒调用一次`addItem`函数来创建一个新的`Item`类实例，而`removeItem`函数将在水果和炸弹飞出屏幕后将其移除。
- en: 'This is really similar to the creation of the space endless runner, and the
    same goes for the creation of fruit and bombs in the `Item` declaration:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这与空间无尽跑者的创建非常相似，同样适用于在`Item`声明中创建水果和炸弹：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again, there''s a lot of code, but most of it is pure JavaScript and has nothing
    to do with Cocos2d-JS. Let''s take a look at it anyway:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，有很多代码，但其中大部分是纯JavaScript，与Cocos2d-JS无关。但让我们看看它：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'How can you decide whether the current item will be a fruit or a bomb? By simply
    drawing a random number, then according to its value, use the bomb or fruit image.
    The `isBomb` custom attribute will tell us whether it''s a bomb (`true`) or a
    fruit (`false`):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何决定当前物品是水果还是炸弹？只需简单地画一个随机数，然后根据其值，使用炸弹或水果图像。`isBomb`自定义属性将告诉我们它是炸弹（`true`）还是水果（`false`）：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When it's time to place it on the stage, we put it in a random horizontal position
    outside the top of the screen and create a tween to move it outside the bottom
    of the screen in a different random horizontal position. Pretty similar to the
    endless runner's asteroid movement.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当它需要放置在舞台上时，我们将其放置在屏幕顶部的随机水平位置，并创建一个tween将其移动到屏幕底部的不同随机水平位置。这与无尽跑酷中的小行星移动非常相似。
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `update` function ,which is called at every frame, checks for three conditions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧都会调用`update`函数，检查三个条件：
- en: If the item is a fruit and it's very close to the cart, then we remove the item
    and output some text to the console to have a debug message, which displays the
    player hit a fruit.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果项目是水果并且它非常接近小车，那么我们移除项目，并向控制台输出一些文本以获取调试信息，显示玩家击中了水果。
- en: If the item is a bomb and it's close (not as close as required by the fruit),
    but close to the cart, then we remove the item and output some text to the console
    to get a debug message, which displays the player hit a bomb. This is a difficult
    game, because being hit by a bomb is easier than collecting a fruit.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果项目是炸弹并且它很近（不像水果那样近），但接近小车，那么我们移除项目，并向控制台输出一些文本以获取调试信息，显示玩家击中了炸弹。这是一个难度很高的游戏，因为被炸弹击中比收集水果更容易。
- en: If the item (no matter which kind of item) is outside the bottom of the stage,
    we need to remove it.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果项目（无论是什么类型的物品）位于舞台底部之外，我们需要将其移除。
- en: That's all for the game. Now, you need to let the player control the cart in
    the three ways mentioned before.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏就到这里。现在，你需要让玩家以前面提到的方式控制小车。
- en: Controlling the cart with ghost buttons
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用幽灵按钮控制小车
- en: To control the cart with ghost buttons, first, you have to place the button
    on the screen, which, as said, will only act as a fake button because the entire
    left and right area of the stage will represent the actual button.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用幽灵按钮控制小车，首先，你必须在屏幕上放置按钮，正如所说的，它将只作为一个假按钮，因为舞台的整个左右区域将代表实际的按钮。
- en: 'You need to add some global variables to the script to handle left and right
    buttons as well as the horizontal speed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在脚本中添加一些全局变量来处理左右按钮以及水平速度：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `xSpeed` variable represents the horizontal speed of the cart, while the
    `left` and `right` variables will be assigned to left and right arrow buttons.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`xSpeed`变量表示小车的水平速度，而`left`和`right`变量将被分配给左右箭头按钮。'
- en: 'Now, the `init` function needs to place the buttons, set the `touch` listener,
    and schedule the update at each frame:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`init`函数需要放置按钮，设置`touch`监听器，并在每一帧安排更新：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I would like you to check whether both left and right arrow buttons are placed
    on the `topLayer` and their opacity is set to half transparent. Also, look at
    the name of the listener variable we are going to create: `touchListener`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能检查左右箭头按钮是否放置在`topLayer`上，并且它们的透明度设置为半透明。同时，看看我们将要创建的监听器变量的名称：`touchListener`。
- en: 'Also, this is the `touchListener` declaration:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这是`touchListener`的声明：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It''s a touch event like the ones we''ve met before. Let''s take a closer look
    at the triggered events:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类似于我们之前遇到过的触摸事件。让我们更仔细地看看触发的事件：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the player touches the screen that deals with ghost buttons, we only need
    to check whether the left or right portion of the screen has been touched, set
    `xSpeed` accordingly as well as turn the speed to on or off, and set it at full
    or half opacity to the respective arrow buttons.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家触摸处理幽灵按钮的屏幕时，我们只需要检查屏幕的左侧或右侧是否被触摸，相应地设置`xSpeed`以及打开或关闭速度，并将相应的箭头按钮设置为全透明或半透明。
- en: 'It''s very important that the function returns `true` if you want Cocos2d-JS
    to be able to check when the player stops touching the screen. To acheive this,
    add the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让Cocos2d-JS能够检查玩家何时停止触摸屏幕，函数必须返回`true`。为了实现这一点，请添加以下代码片段：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the player stops touching the screen, `xSpeed` is set back to zero and
    both buttons are turned off.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家停止触摸屏幕时，将`xSpeed`设置回零，并关闭两个按钮。
- en: 'Now, you only have to move the cart in the `update` function of the `game`
    class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需要在`game`类的`update`函数中移动小车：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's really no need to explain anything as you are only moving the cart by
    `xSpeed` pixels; just take a look at the `setFlippedX` method to flip the cart
    horizontally when it's going right.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上没有必要解释任何事情，因为你只是通过`xSpeed`像素移动小车；只需看看`setFlippedX`方法，当小车向右移动时，它会水平翻转小车。
- en: 'Run the game and you will see what is shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，你将看到以下截图所示的内容：
- en: '![Controlling the cart with ghost buttons](img/0075SOS_06_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![使用幽灵按钮控制购物车](img/0075SOS_06_08.jpg)'
- en: Touch the screen anywhere to move the cart to the left or to the right according
    to the position of the screen you are touching. That's all about ghost buttons.
    Now, let's see how to control the game using the virtual pad.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上的任何位置触摸，根据你触摸的屏幕位置将购物车移动到左边或右边。这就是幽灵按钮的全部内容。现在，让我们看看如何使用虚拟板控制游戏。
- en: Controlling the cart with a virtual pad
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用虚拟板控制购物车
- en: 'The first thing to do in order to control a game with a virtual pad is to have
    a virtual pad. So we need to change some images in our `assets` folder:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要用虚拟板控制游戏，首先需要有一个虚拟板。因此，我们需要更改`assets`文件夹中的某些图像：
- en: '![Controlling the cart with a virtual pad](img/0075SOS_06_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用虚拟板控制购物车](img/0075SOS_06_09.jpg)'
- en: 'The left and right buttons have been removed to be replaced by virtual pad
    images, so `loadassets.js` changes this way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 左右按钮已被移除，并由虚拟板图像替代，因此`loadassets.js`进行了如下更改：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Obviously, most of the game remains the same because you are only changing
    the way you control the cart. You need to change the global variables a bit:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，游戏的大部分内容保持不变，因为你只是改变了控制购物车的方式。你需要稍微更改全局变量：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While game-related variables remain the same, I added two new variables called
    `touchOrigin` and `touchEnd`, which will handle virtual pad touches. Also, the
    variables used before to handle buttons have been removed. A Boolean variable
    called `touching` will tell us whether the player is touching the screen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏相关变量保持不变的情况下，我添加了两个新变量，分别称为`touchOrigin`和`touchEnd`，它们将处理虚拟板的触摸。之前用于处理按钮的变量也已删除。一个名为`touching`的布尔变量将告诉我们玩家是否在触摸屏幕。
- en: 'Now, the `init` function of the `game` class needs some changes too:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`game`类的`init`函数也需要一些更改：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Basically, all lines about the left and right button have been removed, but
    the core of the script is in the `touchListener` declaration:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，所有关于左右按钮的行都已经删除，但脚本的主体在`touchListener`声明中：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first thing I would like you to see is the three events:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先想让你看到的是三个事件：
- en: '`onTouchBegan`: This event places both virtual pad sprites in the touch location
    and sets the `touching` Boolean variable to `true`.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onTouchBegan`：此事件将两个虚拟板精灵放置在触摸位置，并将布尔变量`touching`设置为`true`。'
- en: '`onTouchMoved`: This event updates the `touchEnd` sprite to the current touch
    position. As the name suggests, this event is triggered when the player moves
    their finger around the screen.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onTouchMoved`：此事件将`touchEnd`精灵更新到当前触摸位置。正如其名所示，此事件在玩家在屏幕上移动手指时触发。'
- en: '`onTouchEnded`: This event removes both virtual pad sprites and sets the `touching`
    Boolean variable to `false`.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onTouchEnded`：此事件移除两个虚拟板精灵，并将布尔变量`touching`设置为`false`。'
- en: 'It''s easy to guess how I am moving the cart in the `update` function of the
    `game` class. If the `touching` variable is `true`, the cart speed is the difference
    between the `touchEnd` and `touchOrigin` functions'' *x* coordinates:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易猜到我是如何在`game`类的`update`函数中移动购物车的。如果`touching`变量为`true`，购物车速度就是`touchEnd`和`touchOrigin`函数的*x*坐标之间的差异：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Being an analogic pad, the greater the difference between the `touchEnd` and
    `touchOrigin` functions' *x* coordinates, the faster the cart movement. I divided
    the difference by `50` to keep the game playable; otherwise, the game would move
    too fast.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一款类比板，`touchEnd`和`touchOrigin`函数的*x*坐标之间的差异越大，购物车移动的速度就越快。我将这个差异除以`50`以保持游戏的可玩性；否则，游戏会移动得太快。
- en: Test the game and play.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试游戏并玩。
- en: '![Controlling the cart with a virtual pad](img/0075SOS_06_10.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![使用虚拟板控制购物车](img/0075SOS_06_10.jpg)'
- en: Touch and drag the screen to move the cart at the proper speed. Also, that's
    all for the analogic virtual pad too.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动屏幕以适当的速度移动购物车。对于类比虚拟板来说，这也是全部。
- en: Controlling the cart just with your finger
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅用手指控制购物车
- en: Although you have been controlling the cart with your finger throughout the
    entire chapter, you have always had visual feedback of your movements. The last
    way to move the cart that I am going to show in this chapter does not provide
    any visual feedback, but it works great in games where movements are limited to
    one axis, such as the one you are making now.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你一直在用手指控制购物车，但整个章节中你都有运动的视觉反馈。在本章中我将要展示的最后一种移动购物车的方法不提供任何视觉反馈，但在仅限于一个轴（如你现在所做的那样）的游戏中效果很好。
- en: 'First, you don''t need any graphic assets except the ones directly related
    to the game, so our `loadassets.js` file is smaller than ever:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你不需要任何与游戏直接相关的图形资源，所以我们的`loadassets.js`文件比以往任何时候都要小：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, the changes are even smaller than the ones you made when you created the
    virtual pad from the ghost button: you just need to change the global variables
    a bit:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些更改甚至比你从幽灵按钮创建虚拟键盘时所做的更改还要小：你只需要稍微改变全局变量：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `detectedX` and `savedX` variables will store the current and last saved
    finger or mouse in a horizontal position.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`detectedX`和`savedX`变量将存储当前和最后保存的手指或鼠标在水平位置。'
- en: 'The `touchListener` content is way simpler than before because you don''t have
    to manage images:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`touchListener`的内容比以前简单得多，因为你不需要管理图像：'
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Apart from setting the `touching` Boolean variable to `true` or `false`, as
    seen before, you play with `detectedX` and `savedX` to store the initial and current
    touch horizontal coordinate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像之前那样设置`touching`布尔变量为`true`或`false`之外，你还可以通过`detectedX`和`savedX`来存储初始和当前的触摸水平坐标。
- en: 'The `update` function of the `game` class takes care of the rest:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`game`类的`update`函数负责处理其余部分：'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the player is touching the screen, the difference between current and last
    saved horizontal touch coordinate is made to see whether the cart has to move
    to the left or to the right. Then, the last saved horizontal touch coordinate
    is updated to the current horizontal touch coordinate, which is ready to change
    again if an `onTouchMoved` event is triggered.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家触摸屏幕时，通过比较当前和最后保存的水平触摸坐标之间的差异来判断购物车是否需要向左或向右移动。然后，将最后保存的水平触摸坐标更新为当前的横向触摸坐标，以便在触发`onTouchMoved`事件时再次改变。
- en: Test the game and move your finger back and forth, you will see the cart change
    direction as soon as your finger changes direction.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 测试游戏并来回移动你的手指，你会看到当你的手指改变方向时，购物车会立即改变方向。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! This was a hard and long chapter because it explained three
    different ways to control your games. Now, it's up to you to use the way you think
    it fits better for each of your games, so why don't you write down a list of your
    favourite mobile games and think about what kind of way would you use to control
    the player?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这是一个艰难且漫长的章节，因为它解释了三种不同的控制游戏的方法。现在，取决于你选择哪种方式更适合你的每款游戏，所以为什么不写下你最喜欢的移动游戏列表，并思考你会使用哪种方式来控制玩家呢？
- en: Now, let's move on to the next chapter where you will meet realistic physics.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到下一章，在那里你将遇到真实的物理。
