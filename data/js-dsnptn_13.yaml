- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Asset Loading Strategies and Executing Code off the Main Thread
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产加载策略和主线程之外的代码执行
- en: There are situations in the life cycle of an application where loading more
    JavaScript is inevitable. This chapter details techniques to mitigate the impact
    of such situations. You’ll learn about asset loading optimizations such as a script
    element’s `async`, the `defer` attribute, the impact of `type="module"`, and the
    link element’s `rel` (relationship) attribute’s `preconnect`, `preload`, and `prefetch`
    values. Next, you will further optimize script loading using Next.js’ `Script`
    component and its different options. The chapter wraps up with an exploration
    of reasons to execute JavaScript code off the main thread and an approach to do
    so.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的生命周期中，有些情况下不可避免地需要加载更多 JavaScript。本章详细介绍了减轻此类情况影响的技术。你将了解资产加载优化，如脚本元素的
    `async`、`defer` 属性的影响、`type="module"` 的影响以及链接元素的 `rel`（关系）属性的 `preconnect`、`preload`
    和 `prefetch` 值。接下来，你将使用 Next.js 的 `Script` 组件及其不同选项进一步优化脚本加载。本章最后将探讨执行 JavaScript
    代码离开主线程的原因以及实现此目标的方法。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to control asset loading more granularly with a script’s **async** and **defer**
    attributes, and links with **preconnect**, **preload**, and **prefetch**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过脚本的自定义 `async` 和 `defer` 属性以及 `preconnect`、`preload` 和 `prefetch` 链接来更细致地控制资产加载
- en: Further optimization opportunities in Next.js using the **Script** component
    and its **strategy** prop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Next.js 中使用 **Script** 组件及其 **strategy** 属性的进一步优化机会
- en: When and how to run code off the main thread via Next.js and Partytown
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以及何时通过 Next.js 和 Partytown 在主线程之外运行代码
- en: By the end of this chapter, you’ll have the skills to exert more control over
    asset loading and JavaScript loading and execution in a web context.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备更多控制资产加载和 Web 环境中 JavaScript 加载与执行技能。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码文件，地址为 [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
- en: Asset loading optimization – async, defer, preconnect, preload, and prefetch
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产加载优化 – 异步、延迟、预连接、预加载和预取
- en: When using `script` to load and execute JavaScript, there are HTML attributes
    of `script` we can use to control the loading and execution.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `script` 来加载和执行 JavaScript 时，我们可以使用 `script` 的 HTML 属性来控制加载和执行。
- en: We can rely on the difference between external scripts and inline scripts; we
    can also use the `async`, `defer`, and `type="module"` attributes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以依赖外部脚本和内联脚本之间的差异；我们还可以使用 `async`、`defer` 和 `type="module"` 属性。
- en: We’ll start by defining external and inline scripts, then the `async` and `defer`
    attributes. Finally, we’ll look at `type="module"` attribute.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义外部和内联脚本，然后是 `async` 和 `defer` 属性。最后，我们将探讨 `type="module"` 属性。
- en: 'External scripts use the `src` attribute to point to a separate JavaScript
    file; for example, what follows is an external script that will load and evaluate
    `./script.js` when it’s encountered:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 外部脚本使用 `src` 属性指向一个单独的 JavaScript 文件；例如，以下是一个外部脚本，当遇到时会加载并评估 `./script.js`：
- en: '**<script src="img/script.js"></script>**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**<script src="img/script.js"></script>**'
- en: 'Contrast this with inline scripts, where there is no `src` attribute; instead,
    the JavaScript code is in the `script` tag contents:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与内联脚本进行对比，内联脚本没有 `src` 属性；相反，JavaScript 代码位于 `script` 标签的内容中：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The default load/execution cycle of scripts is what we call `script` tag’s JavaScript
    to complete execution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的默认加载/执行周期就是我们所说的 `script` 标签的 JavaScript 完成执行。
- en: The `async` and `defer` attributes on the `script` HTML tag can change the behavior
    of loading and executing scripts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`script` HTML 标签上的 `async` 和 `defer` 属性可以改变脚本加载和执行的行为。'
- en: Adding `async` to a script will mean it’s fetched while the rest of the HTML
    document is parsed. An `async` script will be evaluated as soon as it’s loaded.
    This is a large change to the default document parsing behavior of `script`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `async` 添加到脚本意味着它在解析其余 HTML 文档的同时被获取。一旦加载，`async` 脚本就会被评估。这是对 `script` 的默认文档解析行为的重大改变。
- en: 'Say we have an `async.js` file that inserts a paragraph with the text `async.js:
    async` `script executed`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们有一个 `async.js` 文件，它插入一个包含文本 `async.js: async script executed` 的段落：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Say we also have a `script.js` file that also inserts a paragraph with `script.js:
    blocking` `script executed`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们还有一个 `script.js` 文件，它也会插入一个包含 `script.js: blocking script executed` 的段落：'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, say we have a document that has inline script snippets that also add
    paragraphs to track their execution before and after two additional `script` tags.
    One script loads `async.js` with an `async` attribute on the script, and the second
    script loads the `script.js` element using the default render-blocking load:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设我们有一个文档，其中包含内联脚本片段，这些片段在两个额外的 `script` 标签之前和之后添加段落以跟踪它们的执行。一个脚本使用具有 `async`
    属性的脚本加载 `async.js`，而第二个脚本使用默认的渲染阻塞加载方式加载 `script.js` 元素：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is displayed as follows in a browser when loaded with an empty cache:
    the inline script 1 executes first, then `script.js`, then inline script 2, and
    finally `async.js`. Note how `async.js` was in the document *before* `script.js`
    but executed after; that’s the effect of the `async` attribute:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当在空缓存中加载时，以下是在浏览器中显示的：内联脚本 1 首先执行，然后是 `script.js`，然后是内联脚本 2，最后是 `async.js`。注意
    `async.js` 在文档中位于 `script.js` 之前，但执行在后；这是 `async` 属性的效果：
- en: '![Figure 10.1: Inline scripts, external script, and external script with async
    execution order](img/B19109_10_1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1：内联脚本、外部脚本和具有 async 执行顺序的外部脚本](img/B19109_10_1.jpg)'
- en: 'Figure 10.1: Inline scripts, external script, and external script with async
    execution order'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：内联脚本、外部脚本和具有 async 执行顺序的外部脚本
- en: Next, we’ll see how `defer` affects the loading of a script.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到 `defer` 如何影响脚本的加载。
- en: '`defer` indicates to the browser that the script should only be loaded *after*
    the document has been parsed. However, the `DOMContentLoaded` event will not fire
    until all scripts with the `defer` attribute are loaded and executed.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer` 告诉浏览器脚本应该在文档解析后才能加载。然而，`DOMContentLoaded` 事件将在所有具有 `defer` 属性的脚本加载并执行后才触发。'
- en: 'Say we add a `defer.js` file that will insert a paragraph with `defer.js: defer
    script executed`, as shown in the following code block:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们添加一个 `defer.js` 文件，该文件将插入一个包含 `defer.js: defer script executed` 的段落，如下面的代码块所示：'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we extend the HTML document from the previous `async` example by adding
    `<script src="img/defer.js" defer></script>` before `<script src="img/async.js"
    async></script>`. This will look as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过在 `<script src="img/defer.js" defer></script>` 之前添加 `<script src="img/async.js"
    async></script>` 来扩展上一个 `async` 示例中的 HTML 文档。这将如下所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When we load this document in a browser, we see the following output where the
    deferred script adds its paragraph after all the other ones despite being *before*
    the `async.js`, `script.js`, and inline script 2 in the parse order of the document.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中加载此文档时，我们看到以下输出，其中延迟执行的脚本在所有其他脚本之后添加其段落，尽管它在文档的解析顺序中位于 `async.js`、`script.js`
    和内联脚本 2 之前。
- en: '![Figure 10.2: Inline scripts, external script, external script with async,
    and external script with the defer execution order](img/B19109_10_2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2：内联脚本、外部脚本、具有 async 的外部脚本和具有 defer 执行顺序的外部脚本](img/B19109_10_2.jpg)'
- en: 'Figure 10.2: Inline scripts, external script, external script with async, and
    external script with the defer execution order'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：内联脚本、外部脚本、具有 async 的外部脚本和具有 defer 执行顺序的外部脚本
- en: Next, we’ll see how “module” and “classic” scripts are affected differently
    by `async` and `defer`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到“模块”脚本和“经典”脚本如何受到 `async` 和 `defer` 的不同影响。
- en: When a script receives the type of attribute with the `module` value, that script
    will get interpreted as a JavaScript module. We’ll call these “module” scripts,
    as opposed to “classic” scripts, which don’t have a type of attribute.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个脚本接收到具有 `module` 值的属性类型时，该脚本将被解释为 JavaScript 模块。我们将这些称为“模块”脚本，与没有类型属性的“经典”脚本相对。
- en: '`type="module"` defers the execution of the script. This means that “module”
    scripts aren’t affected by the `defer` attribute (since that behavior is applied
    to their execution by default).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`type="module"` 延迟脚本的执行。这意味着“模块”脚本不受 `defer` 属性的影响（因为默认情况下该行为应用于它们的执行）。'
- en: The `async` attribute overall has a similar effect on “module” scripts as it
    does on “classic” scripts, in that the script will be loaded in parallel to document
    parsing and executed once loading has been completed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 属性总体上对“模块”脚本和“经典”脚本的影响相似，即脚本将在文档解析的同时并行加载，并在加载完成后执行。'
- en: One additional effect of the `async` attribute on “module” scripts is that since
    JavaScript modules have syntax to denote dependency loading, the module script
    itself, and once loaded, all the dependencies it loads via the `import` syntax,
    will be loaded in parallel to the document parsing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 属性对“模块”脚本的一个额外影响是，由于 JavaScript 模块具有表示依赖项加载的语法，模块脚本本身以及一旦加载，通过 `import`
    语法加载的所有依赖项都将与文档解析并行加载。'
- en: 'Say we have the following `module.js`, which inserts `module.js: type="module"
    executed` when it runs:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们有一个名为 `module.js` 的模块，它在运行时插入 `module.js: type="module" executed`：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Say we also have the following `module-async.js`, which inserts `module-async.js:
    type="module" async executed` when it runs:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们还有一个名为 `module-async.js` 的模块，它在运行时插入 `module-async.js: type="module" async
    executed`：'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We add script tags with `type="module"` with an inline module that inserts
    `inline: type="module" executed`, and module scripts referencing `module.js` and
    `module-async.js`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '我们添加了带有 `type="module"` 的脚本标签，其中包含一个内联模块，该模块在运行时插入 `inline: type="module" executed`，以及引用
    `module.js` 和 `module-async.js` 的模块脚本：'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we load this document in the browser, we see the following. This illustrates
    that the default load/execution of `type="module"` is deferred since even the
    inline module script executes after `async` scripts. One point of interest is
    that `async` on module scripts can make it execute earlier than scripts without
    `async`. This makes sense since `async` means there’s parallel loading and execution
    is “as soon as available,” as opposed to the module script’s default execution
    method, which is `defer`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中加载此文档时，我们会看到以下内容。这表明 `type="module"` 的默认加载/执行是延迟的，因为即使内联模块脚本也在 `async`
    脚本之后执行。一个有趣的观点是，模块脚本的 `async` 可以使其比没有 `async` 的脚本执行得更早。这是有道理的，因为 `async` 表示并行加载，执行是“一旦可用”，而与模块脚本的默认执行方法相反，其默认方法是
    `defer`：
- en: '![Figure 10.3: Inline scripts, external script, external script with async,
    external script with the defer execution order, inline module script, and external
    module scripts with async and without](img/B19109_10_3.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3：内联脚本、外部脚本、带有 async 的外部脚本、带有 defer 执行顺序的外部脚本、内联模块脚本以及带有 async 和不带 async
    的外部模块脚本](img/B19109_10_3.jpg)'
- en: 'Figure 10.3: Inline scripts, external script, external script with async, external
    script with the defer execution order, inline module script, and external module
    scripts with async and without'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：内联脚本、外部脚本、带有 `async` 的外部脚本、带有 `defer` 执行顺序的外部脚本、内联模块脚本以及带有 `async` 和不带
    `async` 的外部模块脚本
- en: 'We’ve now contrasted different characteristics of script load/execution: inline
    versus external, the impact of `async` and `defer` attributes, and classic versus
    module. The following diagram recapitulates the execution order:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经对比了脚本加载/执行的不同特性：内联与外部，`async` 和 `defer` 属性的影响，以及经典与模块。以下图表总结了执行顺序：
- en: '![Figure 10.4: Script load/execute order versus browser document parsing](img/B19109_10_4.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4：脚本加载/执行顺序与浏览器文档解析](img/B19109_10_4.jpg)'
- en: 'Figure 10.4: Script load/execute order versus browser document parsing'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：脚本加载/执行顺序与浏览器文档解析
- en: We’ve now seen how to improve page performance by adapting how JavaScript is
    loaded and executed. Next, we’ll learn how to use resource hints to improve page
    performance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何通过调整 JavaScript 的加载和执行方式来提高页面性能。接下来，我们将学习如何使用资源提示来提高页面性能。
- en: Resource hints, per the HTML specification, allow consumers to preemptively
    complete an operation. They’re used as `rel` values on link elements. The values
    relevant to our use case are `preconnect`, `prefetch`, and `preload`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据HTML规范，资源提示允许消费者预先完成一个操作。它们用作链接元素上的 `rel` 值。与我们用例相关的值是 `preconnect`、`prefetch`
    和 `preload`。
- en: '`preconnect`’s definition per the HTML standard is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 HTML 标准，`preconnect` 的定义如下：
- en: '“`preconnect`: Specifies that the user agent should preemptively connect to
    the target resource’s origin”, HTML standard – 4.6.7 link types: [https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: “`preconnect`：指定用户代理应预先连接到目标资源的源”，HTML 标准 – 4.6.7 链接类型：[https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)
- en: In summary, `preconnect` allows developers to “tell” browsers to create a connection
    to an origin, enabling subsequent requests to the origin to occur faster, especially
    in an HTTP/2 context where more requests can be done in parallel (via multiplexing)
    and connections are efficiently reused.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`preconnect` 允许开发者“告诉”浏览器创建到源的服务器连接，从而使得后续对该源的服务器请求能够更快地发生，尤其是在 HTTP/2
    上下文中，可以并行执行更多请求（通过多路复用）并且连接能够被高效重用。
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, `preload`’s definition per the HTML specification is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据HTML规范，`preload`的定义如下：
- en: '“`preload`: Specifies that the user agent must preemptively fetch and cache
    the target resource for current navigation according to the potential destination
    given by the as attribute (and the priority associated with the corresponding
    destination).” HTML standard – 4.6.7 link types: [https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: “`preload`：指定用户代理必须根据由as属性给出的潜在目的地（以及与相应目的地关联的优先级）预先获取并缓存目标资源，用于当前导航。” HTML标准
    – 4.6.7 链接类型：[https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)
- en: '`preload` can be used to load resources before they’re detected on the page.
    This can be especially useful in single-page applications or other highly dynamic
    JavaScript-driven contexts where resources might not be in the initial returned
    HTML payload, but we know which resources might be necessary.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`preload`可以在检测到页面上的资源之前加载资源。这在单页应用或其他高度动态的JavaScript驱动环境中特别有用，在这些环境中，资源可能不在初始返回的HTML有效负载中，但我们知道哪些资源可能是必需的。'
- en: 'Note that `preload` requires a fully qualified resource path (e.g., [https://example.com/assets/resource-1.js](https://example.com/assets/resource-1.js)),
    as opposed to `preconnect`, which uses the origin only. Also, note that `preload`
    is not designed for use on module scripts; for that, we need `rel="modulepreload"`,
    which is defined as follows in the HTML standard specification:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`preload`需要一个完全限定的资源路径（例如，[https://example.com/assets/resource-1.js](https://example.com/assets/resource-1.js)），这与仅使用源地址的`preconnect`不同。此外，请注意，`preload`不是为模块脚本设计的；为此，我们需要`rel="modulepreload"`，这在HTML标准规范中定义如下：
- en: '“`modulepreload`: Specifies that the user agent must preemptively fetch the
    module script and store it in the document’s module map for later evaluation.
    Optionally, the module’s dependencies can be fetched as well.” HTML standard –
    4.6.7 link types: [https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: “`modulepreload`：指定用户代理必须预先获取模块脚本并将其存储在文档的模块映射中以便稍后评估。可选地，还可以获取模块的依赖项。” HTML标准
    – 4.6.7 链接类型：[https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)
- en: 'In our current example, we could request pre-loading of some of our `async`
    resources ahead of time (before they’re “seen” by the browser in the HTML), where
    our resource loading looks as follows by default. The load order is defined by
    the order of the script tags in the HTML element and the priority for all resources
    is `Normal`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的示例中，我们可以在浏览器在HTML中“看到”它们之前（提前）请求预加载一些`async`资源，我们的资源加载默认如下。加载顺序由HTML元素中脚本标签的顺序和所有资源的优先级定义，所有资源的优先级默认为`Normal`：
- en: '![Figure 10.5: Page load including the Network tab without any preload](img/B19109_10_5.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5：页面加载包括网络标签，没有预加载](img/B19109_10_5.jpg)'
- en: 'Figure 10.5: Page load including the Network tab without any preload'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：页面加载包括网络标签，但没有预加载
- en: 'To illustrate preload, we can add a `preload` link for `async.js` and a `modulepreload`
    link for `module-async.js` inside the HTML `head` element like in the following
    snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`preload`，我们可以在HTML的`head`元素内添加一个针对`async.js`的`preload`链接和一个针对`module-async.js`的`modulepreload`链接，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we reload our example page, we’ll see that `async.js` and `module-async.js`
    are now loaded with `Highest` priority, and before the rest of the scripts on
    the page. Also note that due to the `async` attribute being loaded earlier, the
    scripts are executed earlier.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新加载我们的示例页面，我们会看到`async.js`和`module-async.js`现在以`最高`优先级加载，并且在页面上的其他脚本之前。此外，由于`async`属性加载较早，脚本执行也较早。
- en: '![Figure 10.6: Page load including Network tab with async.js having preload
    and module-async.js having modulepreload](img/B19109_10_6.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6：页面加载包括网络标签，async.js有预加载，module-async.js有modulepreload](img/B19109_10_6.jpg)'
- en: 'Figure 10.6: Page load including Network tab with async.js having preload and
    module-async.js having modulepreload'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：页面加载包括网络标签，async.js有预加载，module-async.js有modulepreload
- en: 'Finally, `prefetch` is defined as follows in the HTML specification:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在HTML规范中，`prefetch`被定义为如下：
- en: '“`prefetch`: Specifies that the user agent should preemptively fetch and cache
    the target resource as it is likely to be required for a follow-up navigation”
    HTML standard – 4.6.7 link types: [https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: “`prefetch`：指定用户代理应预先获取并缓存目标资源，因为它可能对于后续导航是必需的” HTML标准 – 4.6.7 链接类型：[https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)
- en: This means that `prefetch` will not only connect (like `preconnect` does), but
    do a full load and cache cycle. `prefetch` is useful for when resources will be
    necessary on the next load as opposed to for the current page (which is where
    `preload` and `modulepreload` should be used).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `prefetch` 不仅会连接（就像 `preconnect` 所做的那样），还会进行完整的加载和缓存周期。`prefetch` 在资源将在下一次加载时而不是在当前页面上（在这种情况下应使用
    `preload` 和 `modulepreload`）需要时很有用。
- en: We’ve now seen how to optimize asset loading via the `async` and `defer` attributes
    on `script` elements and via `preconnect`, `preload`, and `prefetch` on `link`
    elements. Next, we’ll look at how the Next.js `Script` component’s `strategy`
    can be used to achieve similar results in a Next.js application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过 `script` 元素的 `async` 和 `defer` 属性以及通过 `link` 元素的 `preconnect`、`preload`
    和 `prefetch` 来优化资产加载。接下来，我们将探讨如何使用 Next.js `Script` 组件的 `strategy` 在 Next.js 应用程序中实现类似的结果。
- en: Using Next.js Script’s strategy option to optimize asset loading
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Next.js 脚本策略选项优化资产加载
- en: The Next.js `Script` component gives us more control over script loading behavior,
    allowing us to improve page load performance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 的 `Script` 组件让我们对脚本加载行为有更多的控制，从而可以改善页面加载性能。
- en: The `strategy` prop allows us to control the loading strategy; it defaults to
    `afterInteractive`, which will begin loading after some of the Next.js code has
    run. It can be set to `beforeInteractive`, in which case the script is loaded
    and executed before all Next.js code. `lazyOnLoad` can be used for lower-priority
    scripts to delay loading until there’s browser idle time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`strategy` 属性允许我们控制加载策略；它默认为 `afterInteractive`，这意味着在 Next.js 代码运行之后开始加载。它可以设置为
    `beforeInteractive`，在这种情况下，脚本将在所有 Next.js 代码之前加载和执行。`lazyOnLoad` 可以用于低优先级的脚本，以延迟加载直到浏览器空闲时间。'
- en: The final option is experimental; it’s the `worker` strategy, which will load
    and run the script in a web worker.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是实验性的；它是 `worker` 策略，它将在 Web Worker 中加载和运行脚本。
- en: 'Per the Next.js docs for the `Script#strategy` option, the following list contains
    the loading strategies of the script (see the docs: [https://nextjs.org/docs/pages/api-reference/components/script#strategy](https://nextjs.org/docs/pages/api-reference/components/script#strategy)).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Next.js 文档中关于 `Script#strategy` 选项的说明，以下列表包含了脚本的加载策略（请参阅文档：[https://nextjs.org/docs/pages/api-reference/components/script#strategy](https://nextjs.org/docs/pages/api-reference/components/script#strategy)）。
- en: 'There are four different strategies that can be used:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用四种不同的策略：
- en: '**beforeInteractive**: Load before any Next.js code and before any page hydration
    occurs'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**beforeInteractive**：在任何 Next.js 代码和任何页面激活之前加载'
- en: '**afterInteractive** (default): Load early but after some hydration on the
    page occurs'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**afterInteractive**（默认）：在页面某些激活之后早期加载'
- en: '**lazyOnload**: Load during browser idle time'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lazyOnload**：在浏览器空闲时加载'
- en: '**worker** (experimental): Load in a web worker'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**worker**（实验性）：在 Web Worker 中加载'
- en: 'One of the benefits of the `Script` component over the `script` native element
    is that the loading strategy can be used even on inline scripts. For example,
    say we have a `pages/index.js` page in a Next.js application; we add some `Script`
    components with two approaches to adding inline scripts. We set the latter `Script`
    to use `beforeInteractive`, remembering that the default strategy is `afterInteractive`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Script` 组件相对于原生的 `script` 元素的一个优点是，即使在内联脚本上也可以使用加载策略。例如，假设我们在 Next.js 应用程序中有一个
    `pages/index.js` 页面；我们添加了一些 `Script` 组件，并采用两种方法添加内联脚本。我们将后者 `Script` 设置为使用 `beforeInteractive`，记住默认策略是
    `afterInteractive`：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we run the Next.js server with `npx next dev` or `npx next build && npx
    next start`, we see that `inline script 2` is printed in the console before `inline
    script 1` is; this is the `Script` strategies being applied:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `npx next dev` 或 `npx next build && npx next start` 运行 Next.js 服务器时，我们看到控制台中打印的是
    `inline script 2` 在 `inline script 1` 之前；这是 `Script` 策略正在应用：
- en: '![Figure 10.7: Second inline Script logging to the console before the first
    due to the strategy of each Script](img/B19109_10_7.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7：第二个内联脚本由于每个脚本的策略在第一个脚本之前记录到控制台](img/B19109_10_7.jpg)'
- en: 'Figure 10.7: Second inline Script logging to the console before the first due
    to the strategy of each Script'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：第二个内联脚本由于每个脚本的策略在第一个脚本之前记录到控制台
- en: We’ll now showcase how we can use the loading strategy with external scripts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示如何使用加载策略与外部脚本一起使用。
- en: 'Say we have `public/afterInteractive.js`, which contains the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `public/afterInteractive.js`，其中包含以下内容：
- en: '**console.log(''afterInteractive.js: loaded'');**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**console.log(''afterInteractive.js: loaded'');**'
- en: 'Similarly, `public/beforeInteractive.js` and `public/lazyOnload.js` contain
    a `console.log` function call with the relevant content, `beforeInteractive.js:
    loaded` and `lazyOnload.js:` `loaded` respectively.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，`public/beforeInteractive.js` 和 `public/lazyOnload.js` 包含一个带有相关内容的 `console.log`
    函数调用，分别是 `beforeInteractive.js: loaded` 和 `lazyOnload.js: loaded`。'
- en: 'We can load them using the following changes to `pages/index.js`; note that
    we’ve put them in a rough “reverse” order of loading to showcase the effect of
    `strategy`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下对 `pages/index.js` 的更改来加载它们；请注意，我们将它们按大致的“反向”顺序加载，以展示 `strategy` 的影响：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we run the Next.js server with `npx next dev` or `npx next build && npx
    next start`, we see that `beforeInteractive` is printed on the console before
    `afterInteractive`, which is printed before `lazyOnLoad`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `npx next dev` 或 `npx next build && npx next start` 运行 Next.js 服务器时，我们会看到在控制台打印出
    `beforeInteractive` 之前，会先打印出 `afterInteractive`，而 `lazyOnLoad` 在 `afterInteractive`
    之前打印：
- en: '![Figure 10.8: Script’s logging in order based on strategy](img/B19109_10_8.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8：基于策略的脚本登录顺序](img/B19109_10_8.jpg)'
- en: 'Figure 10.8: Script’s logging in order based on strategy'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：基于策略的脚本登录顺序
- en: We’ve now seen how Next.js `Script` and its `strategy` prop allow us to control
    script asset loading in a Next.js context to achieve additional page load performance.
    Next, we’ll cover how to run scripts in a worker thread.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了 Next.js `Script` 和其 `strategy` 属性如何让我们在 Next.js 环境中控制脚本资产加载，以实现额外的页面加载性能。接下来，我们将介绍如何在工作线程中运行脚本。
- en: Loading and running scripts in a worker thread
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在工作线程中加载和运行脚本
- en: 'One of the Next.js `Script` strategy options is `worker`, which loads and runs
    the script in a web worker. In current Next.js versions, this is achieved via
    a library called **Partytown** ([https://partytown.builder.io/](https://partytown.builder.io/)).
    The following is from the Partytown documentation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js `Script` 策略选项之一是 `worker`，它会在一个 Web Worker 中加载和运行脚本。在当前的 Next.js 版本中，这是通过一个名为
    **Partytown** 的库实现的 ([https://partytown.builder.io/](https://partytown.builder.io/))。以下内容来自
    Partytown 文档：
- en: “Partytown is a lazy-loaded library to help relocate resource-intensive scripts
    into a web worker, and off of the main thread. Its goal is to help speed up sites
    by dedicating the main thread to your code, and offloading third-party scripts
    to a web worker.” Partytown home page – [https://partytown.builder.io/](https://partytown.builder.io/)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: “Partytown 是一个懒加载库，用于将资源密集型脚本重新定位到 Web Worker 中，并从主线程上移除。它的目标是帮助通过将主线程专用于你的代码，并将第三方脚本卸载到
    Web Worker 中来加速网站。” Partytown 主页 – [https://partytown.builder.io/](https://partytown.builder.io/)
- en: To expand on that definition, JavaScript runs in a single-threaded environment
    in the browser. “Single-threaded” means we only have one entity able to execute
    compute operations; non-asynchronous work cannot be done in parallel. The main
    thread in this context is the browser’s JavaScript execution thread. When loading
    and executing compute-heavy scripts, they can starve other scripts of the execution
    environment. By running said compute-heavy scripts in a web worker, it gets a
    different JavaScript environment or execution thread, meaning the main thread
    is freed up to service the rest of the JavaScript execution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展这个定义，JavaScript 在浏览器中运行在一个单线程的环境中。“单线程”意味着我们只有一个实体能够执行计算操作；非异步工作不能并行执行。在这个上下文中，主线程是浏览器的
    JavaScript 执行线程。当加载和执行计算密集型脚本时，它们可能会剥夺其他脚本的执行环境。通过在工作线程中运行这些计算密集型脚本，它获得了一个不同的
    JavaScript 环境或执行线程，这意味着主线程被释放出来以服务其余的 JavaScript 执行。
- en: 'Since `strategy="worker"` for Next.js `Script` is experimental, in order to
    use it, we need to enable it in `next.config.js` like so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Next.js `Script` 的 `strategy="worker"` 是实验性的，为了使用它，我们需要在 `next.config.js`
    中启用它，如下所示：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When running `npx run dev`, you’ll see a warning about the `nextScriptWorkers`
    experimental feature in the terminal in which you’re running the command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 `npx run dev` 时，你会在运行命令的终端中看到一个关于 `nextScriptWorkers` 实验性功能的警告：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To illustrate how we can use `strategy="worker"` powered by Partytown, we can
    write an `analytics.js` script that will log on, load, and make an API call to
    `jsonplaceholder` with some information about the page. We store `analytics.js`
    in `public/analytics.js` to simulate a third-party script being loaded (or more
    generally, a dependency that cannot be bundled, i.e., one we can’t import into
    our application code):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们如何使用由 Partytown 提供的 `strategy="worker"`，我们可以编写一个 `analytics.js` 脚本，该脚本将记录登录、加载，并对
    `jsonplaceholder` 进行一些关于页面的 API 调用。我们将 `analytics.js` 存储在 `public/analytics.js`
    中，以模拟加载第三方脚本（或更普遍地，无法打包的依赖项，即我们无法将其导入到我们的应用程序代码中）：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can then create a new `pages/worker.js` file in our Next.js application,
    which renders a heading and a few Next.js scripts, including `/analytics.js`.
    The other scripts are to illustrate the load order of the `worker` strategy versus
    alternative strategy values:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在Next.js应用程序中创建一个新的`pages/worker.js`文件，该文件渲染一个标题和一些Next.js脚本，包括`/analytics.js`。其他脚本是为了说明`worker`策略与替代策略值的加载顺序：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we load `npx next build && npx next start`, the production server starts,
    and with the `strategy="worker"` loads after all the other strategies. We also
    see that the `fetch()` call to `jsonplaceholder` completed successfully:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载`npx next build && npx next start`时，生产服务器启动，并且使用`strategy="worker"`在所有其他策略之后加载。我们还看到对`jsonplaceholder`的`fetch()`调用成功完成：
- en: '![Figure 10.9: worker strategy loading after other strategies and fetch call
    response logging](img/B19109_10_9.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9：在其它策略和fetch调用响应日志之后加载worker策略](img/B19109_10_9.jpg)'
- en: 'Figure 10.9: worker strategy loading after other strategies and fetch call
    response logging'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：在其它策略和fetch调用响应日志之后加载worker策略
- en: Another aspect of loading via the `worker` strategy is that `analytics.js` is
    not loaded as a script; it’s loaded via `fetch`. This can be seen by inspecting
    the `XMLHttpRequest`, the precursor to `fetch`) and inspecting the `jsonplaceholder`
    request appears here (as two requests, an `OPTIONS` request to ensure we can make
    the cross-origin request followed by the `POST` request).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`worker`策略加载的另一个方面是`analytics.js`不是作为脚本加载的；它是通过`fetch`加载的。这可以通过检查`XMLHttpRequest`（`fetch`的前身）以及检查`jsonplaceholder`请求在这里出现（作为两个请求，一个`OPTIONS`请求以确保我们可以进行跨源请求，随后是`POST`请求）来看到。
- en: '![Figure 10.10: analytics.js is loaded via fetch, as are requests to jsonplaceholder](img/B19109_10_10.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10：analytics.js通过fetch加载，以及jsonplaceholder的请求](img/B19109_10_10.jpg)'
- en: 'Figure 10.10: analytics.js is loaded via fetch, as are requests to jsonplaceholder'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：analytics.js通过fetch加载，以及jsonplaceholder的请求
- en: If we dig into the `analytics.js` request further, we’ll see that the `Referer`
    header value (which helps us keep track of the source of the request) is `_next/static/~partytown/partytown-sandbox-sw.html`,
    which is a Partytown-generated document.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步挖掘`analytics.js`请求，我们会看到`Referer`头部的值（它帮助我们跟踪请求的来源）是`_next/static/~partytown/partytown-sandbox-sw.html`，这是一个Parytown生成的文档。
- en: '![Figure 10.11: analytics.js Referer is the Partytown service worker-generated
    HTML file](img/B19109_10_11.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11：analytics.js的Referer是Parytown服务工作者生成的HTML文件](img/B19109_10_11.jpg)'
- en: 'Figure 10.11: analytics.js Referer is the Partytown service worker-generated
    HTML file'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：analytics.js的Referer是Parytown服务工作者生成的HTML文件
- en: In short, using `strategy="worker"` loads and executes our script in a different
    JavaScript context to the main window, although Partytown is designed so that
    it should have a high level of similarity with the origin window.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用`strategy="worker"`在不同的JavaScript上下文中加载和执行我们的脚本，尽管Parytown被设计成应该与原始窗口有高度的相似性。
- en: We’ve now seen how to use `strategy="worker"` and Partytown to execute scripts
    off the main thread in a web worker context.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`strategy="worker"`和Parytown在web worker环境中执行主线程之外的脚本。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve covered techniques to control asset and JavaScript loading
    more granularly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了控制资产和JavaScript加载的更细粒度技术。
- en: In order to control script loading using browser built-in functionality, we
    can use `async` and `defer` attributes; we covered their effect on module scripts
    versus classic scripts. We also looked at using the `rel` attribute on a `link`
    element for resource hints, and what impact `preconnect`, `preload`, `modulepreload`,
    and `prefetch` have on resource loading.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用浏览器内置功能控制脚本加载，我们可以使用`async`和`defer`属性；我们讨论了它们对模块脚本与经典脚本的影响。我们还探讨了在`link`元素上使用`rel`属性进行资源提示，以及`preconnect`、`preload`、`modulepreload`和`prefetch`对资源加载的影响。
- en: We can leverage the Next.js `Script` component’s `strategy` prop to control
    script loading and execution beyond `async` and `defer` in the context of a Next.js
    application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用Next.js `Script`组件的`strategy`属性来控制Next.js应用程序上下文中的脚本加载和执行，而不仅仅是`async`和`defer`。
- en: Finally, we looked at the possibility of running certain scripts off the main
    JavaScript thread using the Next.js `Script` `worker` strategy, powered by the
    Partytown library.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了使用Next.js `Script` `worker`策略，由Parytown库提供支持，在主JavaScript线程之外运行某些脚本的可能性。
- en: In this final chapter, we covered asset loading strategies and optimizations
    such as executing code off the main thread.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们讨论了资产加载策略和优化，例如在主线程之外执行代码。
- en: This brings us to the end of this book. Hopefully, you’ve achieved a better
    understanding of design patterns in JavaScript and how to implement them. You
    will be able to discuss and contrast implementations and the usefulness of language-agnostic
    patterns that fall into the creational, structural, and behavioral design pattern
    categories. In addition, you should be confident with JavaScript-specific patterns
    that will help you scale your applications, reactive view library patterns, rendering
    strategies, and asynchronous and event-driven programming patterns in JavaScript.
    Furthermore, you are now familiar with performance and architecture patterns relevant
    to JavaScript such as micro frontends, lazy-loading, code-splitting, and further
    asset loading optimizations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了本书的结尾。希望您已经对JavaScript中的设计模式及其实现有了更深入的理解。您将能够讨论和对比实现方式，以及属于创建型、结构型和行为型设计模式类别的语言无关模式的实用性。此外，您应该对有助于您扩展应用的JavaScript特定模式充满信心，例如响应式视图库模式、渲染策略、以及JavaScript中的异步和事件驱动编程模式。此外，您现在对与JavaScript相关的性能和架构模式也应该很熟悉，例如微前端、懒加载、代码拆分以及进一步的资产加载优化。
- en: Of course, all these patterns are meant to be used and you will discover new
    ways to compose them and even notice them in places you didn’t expect. The JavaScript
    and web platform space is ever-evolving, and I hope this book stands you in good
    stead for using more of its great features.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些模式都是为了使用而设计的，您将发现新的组合它们的方法，甚至可能在您意想不到的地方注意到它们。JavaScript和Web平台空间是不断演变的，我希望这本书能帮助您更好地利用其出色的功能。
