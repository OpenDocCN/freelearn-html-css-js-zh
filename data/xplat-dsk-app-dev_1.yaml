- en: Creating a File Explorer with NW.js-Planning, Designing, and Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NW.js创建文件资源管理器-规划、设计和开发
- en: Nowadays, when speaking of HTML5 desktop application development, one implies
    either **NW.js** or **Electron**. The first one has a shorter learning curve,
    which makes it a better choice for the beginning. Our first application will be
    a File Explorer. This sort of software is traditionally considered as a classical
    desktop application. I believe that you will find it exciting to build a File
    Explorer with HTML, CSS, and JavaScript. This chapter requires no skills in JavaScript
    frameworks, as we will use none. All you need is a basic knowledge of HTML, CSS,
    and plain JavaScript (including Node.js).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，当谈到HTML5桌面应用程序开发时，人们通常指的是**NW.js**或**Electron**。第一个学习曲线较短，对于初学者来说是更好的选择。我们的第一个应用程序将是一个文件资源管理器。这种软件传统上被认为是经典的桌面应用程序。我相信你会发现用HTML、CSS和JavaScript构建一个文件资源管理器是令人兴奋的。本章不需要掌握JavaScript框架的技能，因为我们不会使用任何框架。你只需要基本的HTML、CSS和纯JavaScript知识（包括Node.js）。
- en: So, what are we up to? We will plan and sketch the project. We will set up the
    development environment and create a static prototype and run it with NW.js. We
    will implement the basic functionality, making it ready to be enhanced in [Chapter
    2](013f4079-2a91-4776-a2bb-82e9ff5eb552.xhtml), *Creating a File Explorer with
    NW.js Enhancement and Delivery*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们要做什么？我们将规划和勾画项目。我们将设置开发环境并创建静态原型，并在NW.js中运行它。我们将实现基本功能，使其准备好在[第2章](013f4079-2a91-4776-a2bb-82e9ff5eb552.xhtml)中进行增强，*使用NW.js创建文件资源管理器增强和交付*。
- en: The application blueprint
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序蓝图
- en: 'By File Explorer, I mean a small program that allows navigating through the
    filesystem and performs basic operations on the files, which can be expressed
    with the following user stories:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过文件资源管理器，我指的是一个小程序，允许浏览文件系统并对文件执行基本操作，这可以用以下用户故事来表达：
- en: As a user, I can see the content of the current directory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以查看当前目录的内容
- en: As a user, I can navigate through the filesystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以浏览文件系统
- en: As a user, I can open a file in the default associated program
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以用默认关联的程序打开文件
- en: As a user, I can delete a file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以删除文件
- en: As a user, I can copy a file in the clipboard and paste it later in a new location
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以复制文件到剪贴板，然后在新位置粘贴
- en: As a user, I can open the folder containing the file with the system file manager
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以用系统文件管理器打开包含文件的文件夹
- en: As a user, I can close the application window
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以关闭应用程序窗口
- en: As a user, I can minimize the application window
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以最小化应用程序窗口
- en: As a user, I can maximize and restore the application window
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以最大化和恢复应用程序窗口
- en: As a user, I can change the application language
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以更改应用程序语言
- en: 'It would be easier to perceive it in a visual form, wouldn''t it? Wireframes
    come in handy here. Wireframe is a skeletal framework of the application that
    depicts the arrangement of the application''s content, including UI elements and
    navigation system. Wireframe has no real graphics, typography, or even colors.
    It shows schematically, what the application does. As you know, drawing with a
    pencil on a paper is possible, but it is not the best way to create a wireframe;
    what we need is a prototyping tool. Today, there are plenty of solutions on the
    market. Here, I use an impressive, but affordable tool called **WireframeSketcher**
    ([http://wireframesketcher.com/](http://wireframesketcher.com/)). It allows you
    to sketch web, desktop, and mobile applications (just what we need). It also has
    a rich mock-up gallery of stencils, widgets, icons, and templates that makes prototyping
    fast and easy. Besides, the wireframes look nice in a sketchy style:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以视觉形式来理解会更容易，不是吗？线框图在这里很有用。线框图是应用程序的骨架框架，描述了应用程序内容的排列，包括UI元素和导航系统。线框图没有真正的图形、排版甚至颜色。它以图表的方式展示了应用程序的功能。你知道，用铅笔在纸上画是可能的，但不是创建线框图的最佳方式；我们需要的是原型工具。今天市场上有很多解决方案。在这里，我使用了一个令人印象深刻但价格实惠的工具，叫做**WireframeSketcher**（[http://wireframesketcher.com/](http://wireframesketcher.com/)）。它允许你勾画Web、桌面和移动应用程序（正是我们需要的）。它还有丰富的样机库，包括样式、小部件、图标和模板，使得原型设计快速简单。此外，线框图以草图风格呈现得很好：
- en: '![](img/62a85392-9053-4bf9-bf43-2098db164c19.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62a85392-9053-4bf9-bf43-2098db164c19.png)'
- en: What we can see on the wireframe is often called a **Holy Grail Layout**. In
    our case, the header serves as the window title bar. There, we keep our controls
    for window actions such as close, maximize, and minimize. Besides that, in the
    title bar, we display the path to the current directory. In the sidebar, we have
    our filesystem navigation. The main section contains a table that represents files
    of the current directory. It has columns--Name, Size, and Modified. A right-click
    on a file opens a context menu with available file operations. The footer comprises
    the application title and a language selector combo box.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在线框图上我们看到的通常被称为**圣杯布局**。在我们的情况下，标题栏充当窗口标题栏。在那里，我们保留了窗口操作的控件，如关闭、最大化和最小化。除此之外，在标题栏中，我们显示当前目录的路径。在侧边栏中，我们有文件系统导航。主要部分包含一个表示当前目录文件的表格。它有列--名称、大小和修改日期。右键单击文件会打开一个包含可用文件操作的上下文菜单。页脚包括应用程序标题和语言选择器组合框。
- en: Setting up an NW.js project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立一个NW.js项目
- en: NW.js is an open source framework for building HTML, CSS, and JavaScript applications.
    You can also see it as a headless browser (based on Chromium [https://www.chromium.org/](https://www.chromium.org/))
    that includes Node.js runtime and provides desktop environment integration API.
    Actually, the framework is very easy to start with. What we need is just a start
    page HTML file and project manifest file (`package.json`).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: NW.js是一个用于构建HTML、CSS和JavaScript应用程序的开源框架。你也可以把它看作是一个无头浏览器（基于Chromium [https://www.chromium.org/](https://www.chromium.org/)），它包括Node.js运行时，并提供桌面环境集成API。实际上，这个框架非常容易上手。我们只需要一个起始页HTML文件和项目清单文件（`package.json`）。
- en: '![](img/d4582a55-4af3-4b8c-be20-8c116005485b.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4582a55-4af3-4b8c-be20-8c116005485b.png)'
- en: To see it in action, we will create a project folder named `file-explorer` at
    an arbitrary location. The choice of the folder location is up to you, but I personally
    prefer to keep web projects in `/<username>/Sites` on Linux/macOS and `%USERPROFILE%Sites`
    on Windows.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到它的运行情况，我们将在任意位置创建一个名为`file-explorer`的项目文件夹。文件夹位置的选择取决于您，但我个人更喜欢在Linux/macOS上保留Web项目在`/<username>/Sites`，在Windows上保留在`%USERPROFILE%Sites`。
- en: 'As we enter the directory, we create placeholder folders for JavaScript and
    CSS sources (`js` and `assets/css`):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入目录时，我们为JavaScript和CSS源文件创建占位符文件夹（`js`和`assets/css`）：
- en: '![](img/8d4d3068-5cd0-42f3-aed4-28355b90a084.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d4d3068-5cd0-42f3-aed4-28355b90a084.png)'
- en: 'We also place a start page HTML (`index.html`) that consists of just a few
    lines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还放置了一个起始页HTML（`index.html`），其中只包含几行：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can guess, we shall see just this text--File Explorer-- when feeding
    this file to a browser.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所猜测的，当将此文件输入浏览器时，我们将只看到这个文本--文件浏览器。
- en: Now, we need the Node.js manifest file (`package.json`). Node.js, embedded in
    the framework, will use it to resolve dependency package names when called with
    a `require` function or from an npm script. In addition, NW.js takes from it the
    project configuration data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要Node.js清单文件（`package.json`）。嵌入在框架中的Node.js将使用它来解析依赖包名称，当使用`require`函数或从npm脚本调用时。此外，NW.js还从中获取项目配置数据。
- en: Why not create the manifest file and populate it with dependencies using the
    npm tool?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用npm工具创建清单文件并填充它的依赖项？
- en: Node Package Manager
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node包管理器
- en: Nowadays, **Node Package Manager** (**npm**) is one of the most demanded gadgets
    in the web developer tool belt. It's a command-line utility connected with the
    corresponding online repository of packages and is capable of package installation,
    version management, and dependency management. So, when we need a package (library,
    framework, and module), we will check whether it's available in the npm repository
    and run npm to bring it into our project. It not only downloads the package, it
    also resolves its dependencies and does it pretty smartly. Furthermore, npm is
    pretty handy as an automation tool. We can set various command-line tasks to refer
    any of the locally installed packages by name. The npm tool will find the executable
    package among installed packages and run it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，**Node包管理器**（**npm**）是Web开发人员工具中最受欢迎的工具之一。它是一个与相应的在线软件包存储库连接的命令行实用程序，能够进行软件包安装、版本管理和依赖管理。因此，当我们需要一个软件包（库、框架和模块），我们将检查它是否在npm存储库中可用，并运行npm将其引入我们的项目。它不仅下载软件包，还智能地解决其依赖关系。此外，npm作为自动化工具非常方便。我们可以设置各种命令行任务，通过名称引用任何本地安装的软件包。npm工具将在已安装的软件包中找到可执行软件包并运行它。
- en: 'The npm tool is distributed together with Node.js. So, you can find an installer
    for Windows or for macOS on the Node.js download page ([https://nodejs.org/en/download](https://nodejs.org/en/download)).
    It is also available as an APT package, so you can install it for Linux with the
    `apt-get` tools:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: npm工具与Node.js一起分发。因此，您可以在Node.js下载页面（[https://nodejs.org/en/download](https://nodejs.org/en/download)）上找到Windows或macOS的安装程序。它也作为APT软件包提供，因此您可以使用`apt-get`工具在Linux上安装它：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have already installed npm, ensure that it''s up to date:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了npm，请确保它是最新的：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As I have already said, we can install packages with npm-- for example, NW.js.
    If we want to do it globally, we will run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经说过的，我们可以使用npm安装包--例如NW.js。如果我们想要全局安装，我们将运行以下命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, we can run the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以运行以下命令：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will download the latest build of NW.js in `{prefix}/lib/node_modules/`
    and place the executable file in `{prefix}/bin`. It adds the binary to the `PATH`
    environment variable, so one can call `nw` in any location in the shell.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`{prefix}/lib/node_modules/`中下载NW.js的最新版本，并将可执行文件放在`{prefix}/bin`中。它将二进制文件添加到`PATH`环境变量中，因此可以在shell中的任何位置调用`nw`。
- en: '`{prefix}` In order to find out what `{prefix}` is one can run:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`{prefix}`为了找出`{prefix}`是什么，可以运行：'
- en: '`npm config get prefix`. On Linux/macOS it will be `/usr/local`. On Windows
    `%APPDATA%npm`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm config get prefix`。在Linux/macOS上，它将是`/usr/local`。在Windows上是`%APPDATA%npm`'
- en: This way, we will have a single instance of NW.js across the system, but what
    if an application requires a specific version of NW.js? Luckily, with npm, we
    can also install a package locally, and therefore, rely on a particular version
    that addresses our application. In addition, we can manage local dependencies
    in the `package.json` file. With a single command, npm can install/update all
    the dependencies enlisted there at once.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将在系统中拥有一个NW.js的单一实例，但是如果一个应用程序需要特定版本的NW.js怎么办？幸运的是，通过npm，我们也可以在本地安装一个包，因此，依赖于解决我们应用程序的特定版本。此外，我们可以在`package.json`文件中管理本地依赖项。使用一个命令，npm可以一次安装/更新所有在那里列出的依赖项。
- en: 'Let''s take a look at how it works on our project. We go to the project root
    (the `file-explorer` folder) and run the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它在我们的项目上是如何工作的。我们转到项目根目录（`file-explorer`文件夹）并运行以下命令：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It produces a `package.json` file with the following content:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它会生成一个包含以下内容的`package.json`文件：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, in the `name` field, we set our application name. Beware that NW.js will
    use the provided value to name the directory in a system-dependent path for the
    project persistent data (`nw.App.dataPath`). So, it shall be a unique, lowercase
    alpha-numeric, but may include a few special symbols, such as `.`, `_`, and `-`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`name`字段中，我们设置我们的应用程序名称。请注意，NW.js将使用提供的值来命名项目持久数据的系统相关路径中的目录（`nw.App.dataPath`）。因此，它应该是一个唯一的、小写的字母数字组合，但可能包括一些特殊符号，如`.`、`_`和`-`。
- en: Field version expects the application version as a string, conforming to the
    Semantic Versioning standard ([http://semver.org/](http://semver.org/)). What
    it all boils down to is a composite product version out of three numbers separated
    with dots. The first number (MAJOR) increments when we make incompatible API changes,
    the second number (MINOR) increases when we introduce a new functionality, and
    the last one (PATCH) identifies bug fixes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 字段版本期望应用程序版本作为字符串，符合语义化版本标准（[http://semver.org/](http://semver.org/)）。这归结为三个用点分隔的数字组成的复合产品版本。第一个数字（MAJOR）在我们进行不兼容的API更改时递增，第二个数字（MINOR）在引入新功能时增加，最后一个数字（PATCH）标识错误修复。
- en: 'In the `main` field, we let NW.js know where to find our start page HTML. We
    have to edit the manifest to change its value with `index.html`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`字段中，我们让NW.js知道在哪里找到我们的起始页HTML。我们必须编辑清单以更改其值为`index.html`：
- en: '`./package.json`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`./package.json`'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The field `scripts` accepts a key value object with automation scripts for
    the project. By default, it has a placeholder for tests. Now, run the following
    command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts`字段接受一个键值对象，其中包含项目的自动化脚本。默认情况下，它有一个用于测试的占位符。现在，运行以下命令：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The Shell responds with an error message saying no test specified, as we have
    no test yet. However, we will need a script to start the application. So, we edit
    `package.json` again and add to `scripts` field the following lines:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Shell响应错误消息，表示没有指定测试，因为我们还没有测试。但是，我们需要一个脚本来启动应用程序。因此，我们再次编辑`package.json`并在`scripts`字段中添加以下行：
- en: '`package.json`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we can type `npm run start` or `npm start` to run NW.js on the project
    root, but we do not have the framework installed, yet. We are just about to bring
    it in.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以输入`npm run start`或`npm start`来在项目根目录上运行NW.js，但是我们还没有安装框架。我们正要引入它。
- en: Manifest fields--such as description/keywords and author--help other people
    to discover the application as a package. The `license` field tells people how
    they are permitted to use the package. You can find more about these fields and
    other possible options at [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 清单字段-例如描述/关键字和作者-帮助其他人发现应用程序作为一个包。`license`字段告诉人们他们可以如何使用该包。您可以在[https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)找到有关这些字段和其他可能选项的更多信息。
- en: 'Before telling npm to install the framework, we note that the standard version
    of NW.js doesn''t include DevTools, which we definitely will need for development.
    So, we look for a specific version, the so-called SDK flavor. To find out the
    package versions that are available for the NW.JS package (`nw`), we run the following
    command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在告诉npm安装框架之前，我们注意到标准版本的NW.js不包括DevTools，而我们在开发中肯定会需要。因此，我们寻找一个特定版本，即所谓的SDK版本。要找出NW.JS包（`nw`）可用的包版本，我们运行以下命令：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, we can run the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以运行以下命令：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This receives the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将收到以下输出：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From this payload, we can assume that the latest version at the time of writing
    is `0.20.3` and that it is accompanied with `0.20.3-sdk`. So, we can install the
    framework, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个负载中，我们可以假设在撰写时的最新版本是`0.20.3`，并且它伴随着`0.20.3-sdk`。因此，我们可以按照以下方式安装框架：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively,we can install it, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以按照以下方式安装它：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Actually, since we know that the package has a dist-tag called `sdk`, we can
    also do it as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于我们知道该包有一个名为`sdk`的分发标签，我们也可以按照以下方式进行：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just after running any of these commands, we can find a new subdirectory named
    `node_modules`. There, npm installs local dependencies.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行任何这些命令后，我们可以在`node_modules`中找到一个新的子目录。在那里，npm会安装本地依赖项。
- en: 'Have you noticed that we applied the `--save-dev (-D)` option? This way, we
    requested npm to save the package in our development dependency list. Observe
    that `package.json` is changed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到我们应用了`--save-dev (-D)`选项？这样，我们要求npm将包保存在我们的开发依赖列表中。请注意`package.json`已更改：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We installed the package as a development dependency because this SDK version
    is meant only for development. In [Chapter 2](013f4079-2a91-4776-a2bb-82e9ff5eb552.xhtml),
    *Creating a File Explorer with NW.js–Enhancement and Delivery* we will examine
    the distribution and packaging techniques. So, you will see how we can bundle
    the application with a platform-specific NW.js production build.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将该包安装为开发依赖，因为这个SDK版本仅用于开发。在[第2章](013f4079-2a91-4776-a2bb-82e9ff5eb552.xhtml)中，*使用NW.js创建文件资源管理器-增强和交付*，我们将研究分发和打包技术。因此，您将看到我们如何将应用程序与特定于平台的NW.js生产构建捆绑在一起。
- en: 'Since we have reflected our dependency in the manifest file, we can update
    this and any further packages any time by running the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在清单文件中反映了我们的依赖关系，我们可以通过运行以下命令随时更新此包以及任何进一步的包：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we lose `node_modules`(for example after cloning the project from remote
    GIT repository given the dependency folder is usually in the ignore list), we
    can install all the dependencies through the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们丢失了`node_modules`（例如，在从远程GIT存储库克隆项目时，给定依赖文件夹通常在忽略列表中），我们可以通过以下命令安装所有依赖项：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Have you noticed? In the `package.json`, we assigned `nw` package with version
    in, so called, caret range `^0.20.3-sdk`. That means during the install/update
    process, npm will accept new versions with patch and minor updates, but no major
    versions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到？在`package.json`中，我们将`nw`包分配为所谓的插入范围`^0.20.3-sdk`的版本。这意味着在安装/更新过程中，npm将接受具有补丁和次要更新的新版本，但不接受主要版本。
- en: 'The following are some useful npm commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有用的npm命令：
- en: '`npm i pkg-name`: Installs the latest available version of a package'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm i pkg-name`：安装包的最新可用版本'
- en: '`npm i pkg-name@version`: Installs a concrete version of the package'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm i pkg-name@version`：安装包的具体版本'
- en: '`npm i pkg-name -S`: Installs package as a dependency and saves it in `package.json`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm i pkg-name -S`：将包安装为依赖项并保存在`package.json`中'
- en: '`npm i pkg-name -D`: Installs package as a development dependency and save
    in `package.json`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm i pkg-name -D`：将包安装为开发依赖项并保存在`package.json`中'
- en: '`npm i`: Installs all the dependencies (including development ones) enlisted
    in `package.json`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm i`: 安装`package.json`中列出的所有依赖项（包括开发依赖项）'
- en: '`npm i --production`: Installs dependencies but not development ones'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm i --production`: 安装依赖项，但不包括开发依赖项'
- en: '`npm list`: Shows all the installed dependencies'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm list`: 显示所有已安装的依赖项'
- en: '`npm uninstall nw --save`: uninstalls a package and removes it from'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm uninstall nw --save`: 卸载一个包并从中删除'
- en: '`npm un nw -S`: shorter syntax'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm un nw -S`: 更简洁的语法'
- en: '`package.json`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`'
- en: 'At this point, we have the framework instance and `package.json` pointing to
    `index.html`. So, we can run the only script we have defined in the manifest file
    so far:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有了框架实例和`package.json`指向`index.html`。因此，我们可以运行到目前为止在清单文件中定义的唯一脚本：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, run it on NW.JS in Ubuntu:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Ubuntu上在NW.JS上运行它：
- en: '![](img/1dca42a1-2a57-41f1-87ee-4778c664da85.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dca42a1-2a57-41f1-87ee-4778c664da85.png)'
- en: 'Then, run it on NW.JS in windows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在Windows上在NW.JS上运行它：
- en: '![](img/bb55a82c-1398-4579-ae5e-156ba77dae6d.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb55a82c-1398-4579-ae5e-156ba77dae6d.png)'
- en: 'Finally, we run it in macOS:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在macOS上运行它：
- en: '![](img/6478710c-4847-418f-9d91-3b667083b9dc.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6478710c-4847-418f-9d91-3b667083b9dc.png)'
- en: NW.js created a window and rendered `index.html` in it. It took the default
    Window parameters. If we want to customize them, we will need to edit `package.json`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: NW.js创建了一个窗口并在其中呈现了`index.html`。它采用了默认的窗口参数。如果我们想要自定义它们，我们需要编辑`package.json`。
- en: 'First, we will add the `window` field that accepts an object with the following
    properties:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加接受以下属性的对象的`window`字段：
- en: '`window.icon`: This specifies a relative path to the window icon.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.icon`: 这指定了窗口图标的相对路径。'
- en: '`window.show`: This indicates whether the window is visible when the application
    starts or not. For instance, you can set it to false in the manifest and then
    change it programmatically with JavaScript (`nw.Window.get().show( true )`).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.show`: 这指示应用程序启动时窗口是否可见。例如，您可以在清单中将其设置为false，然后使用JavaScript以编程方式更改它（`nw.Window.get().show(
    true )`）。'
- en: '`window.frame`: This makes the window frameless when set to `false`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.frame`: 当设置为`false`时，这将使窗口无框架。'
- en: '`window.width / window.height`: This sets the window default size in pixels.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.width / window.height`: 这将以像素为单位设置窗口的默认大小。'
- en: '`window.min_width / window.min_height`: This sets a minimal acceptable size
    to the window.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.min_width / window.min_height`: 这将设置窗口的最小可接受大小。'
- en: '`window.position`: This specifies where the window shall be placed. The value
    can be `null`, `center`, or `mouse`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.position`: 这指定窗口应放置的位置。该值可以是`null`，`center`或`mouse`。'
- en: '`window.resizable`: When set to `true`, this property makes the window resizable.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.resizable`: 当设置为`true`时，此属性使窗口可以调整大小。'
- en: 'We will also use the `chromium-args` field to specify the command-line arguments
    that we want to pass to chromium. Here, we set it to `--mixed-context` to switch
    NW.js into the corresponding mode. So, we could access the browser and the NW.js
    API directly from Node.js modules. NW.js introduces Node.js context in addition
    to the browser context and keep them separate. After extending it with NWJS meta-data
    the manifest looks as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`chromium-args`字段来指定要传递给chromium的命令行参数。在这里，我们将其设置为`--mixed-context`，以将NW.js切换到相应的模式。因此，我们可以直接从Node.js模块访问浏览器和NW.js
    API。NW.js引入了Node.js上下文，除了浏览器上下文之外，并将它们分开。在使用NWJS元数据扩展后，清单如下所示：
- en: '`./package.json`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`./package.json`'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These are just a few preferences set for our simple application. All the available
    options can be found at [https://github.com/nwjs/nw.js/wiki/manifest-format](https://github.com/nwjs/nw.js/wiki/manifest-format).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是为我们简单应用程序设置的一些首选项。所有可用选项都可以在[https://github.com/nwjs/nw.js/wiki/manifest-format](https://github.com/nwjs/nw.js/wiki/manifest-format)找到。
- en: An HTML prototype
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个HTML原型
- en: We've just reached the point where we can start templating our application.
    Using HTML and CSS, we will achieve the intended look and feel. Later, we will
    bind JavaScript modules to the acting elements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了可以开始为我们的应用程序创建模板的地步。使用HTML和CSS，我们将实现预期的外观和感觉。稍后，我们将把JavaScript模块绑定到操作元素上。
- en: 'We start by replacing the content of `index.html` with the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先用以下代码替换`index.html`的内容：
- en: '`./index.html`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`./index.html`'
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we just defined the page layout with semantically meaningful HTML tags.
    As you can see, we refer to `./assets/css/app.css` that we are about to create.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是用语义上有意义的HTML标签定义了页面布局。正如您所看到的，我们引用了`./assets/css/app.css`，我们将要创建它。
- en: Maintainable CSS
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护的CSS
- en: Before we start styling, I would like to talk briefly about the importance of
    maintainability in CSS. Despite the fact that CSS is a declarative language, it
    requires no less diligence than any other code in general. When browsing a public
    repository, such as GitHub, you can still find plenty of projects where all the
    styles are put in a single file that is full of code smells ([https://csswizardry.com/2012/11/code-smells-in-css/](https://csswizardry.com/2012/11/code-smells-in-css/))
    and has no consistency in class naming.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始样式化之前，我想简要谈一下CSS中可维护性的重要性。尽管CSS是一种声明性语言，但它需要的细心程度并不比一般代码少。当浏览公共存储库（如GitHub）时，您仍然可以找到许多项目，其中所有样式都放在一个充满代码异味的单个文件中，并且类命名没有一致性。
- en: Well, it will not be much of a problem at the beginning, but CSS as any other
    code tends to grow. Eventually, you will end up with thousands of lines of rotting
    code often written by different people.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这一开始可能不是什么大问题，但CSS和其他代码一样，往往会增长。最终，您将以数千行腐烂的代码结束，通常是由不同的人编写的。
- en: Then, you have to fix the UI element appearance, but you realize that dozens
    of existing CSS declarations across the cascade impact this element. You change
    one, and styles break unpredictably on other elements. So, you will likely decide
    to add your own rules overriding existing styles. After that, you may find out
    that some of the existing rules have a higher specificity, and you will have to
    use brute force through the cascade; every time it is going to be worse.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须修复UI元素的外观，但你意识到跨级影响这个元素的现有CSS声明有数十个。你改变一个，样式就会不可预测地在其他元素上破坏。因此，你可能会决定添加自己的规则来覆盖现有的样式。之后，你可能会发现一些现有规则具有更高的特异性，你将不得不通过级联使用蛮力；每次都会变得更糟。
- en: 'To avoid this maintainability problem, we have to break the entire application
    UI into components and design the CSS code so as to keep them reusable, portable,
    and conflict free; the following heuristics may come in handy:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种可维护性问题，我们必须将整个应用程序UI分解为组件，并设计CSS代码，使它们可重用、可移植和无冲突；以下启发法可能会有所帮助：
- en: Split the whole CSS code into modules that represent components, layouts, and
    states
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将整个CSS代码分成代表组件、布局和状态的模块
- en: Always use classes for styling (not IDs or attributes)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用类来进行样式设置（而不是ID或属性）
- en: Avoid qualified selectors (selectors with tags such as `nav`, `ul`, `li`, and
    `h2`)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免有资格的选择器（带有`nav`、`ul`、`li`和`h2`等标签的选择器）
- en: Avoid location dependency (long selectors such as `.foo`, `.bar`, `.baz`, and
    `article`)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免位置依赖（长选择器，如`.foo`、`.bar`、`.baz`和`article`）
- en: Keep selectors short
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持选择器简短
- en: Do not use `!important` reactively
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要反应性地使用`!important`
- en: 'There are different methodologies that help to improve CSS maintainability.
    Probably, the most popular approach is **Blocks** **Elements** **Modifiers** (**BEM**).
    It introduces a surprisingly simple, but powerful concept ([https://en.bem.info/methodology/key-concepts/](https://en.bem.info/methodology/key-concepts/)).
    It describes a pattern for class names that encourages readability and portability.
    I believe that the best way to explain it is by an example. Let''s say we have
    a component representing a blog post:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法论可以帮助改善CSS的可维护性。可能最流行的方法是**块** **元素** **修饰符**（**BEM**）。它引入了一个令人惊讶的简单但强大的概念（[https://en.bem.info/methodology/key-concepts/](https://en.bem.info/methodology/key-concepts/)）。它描述了一种鼓励可读性和可移植性的类名模式。我相信最好的解释方法是通过一个例子来说明。假设我们有一个代表博客文章的组件：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In BEM terminology, this markup represents a block that we can define with a
    class name `post`. The block has two elements--`post__title` and `post_time`.
    Elements are integral parts of a block; you cannot use them out of the parent
    block context.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在BEM术语中，这个标记代表一个块，我们可以用类名`post`来定义。这个块有两个元素-`post__title`和`post_time`。元素是块的组成部分；你不能在父块上下文之外使用它们。
- en: 'Now imagine that we have to highlight one post of the list. So, we add a `post--sponsored`
    modifier to the block''s classes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们必须突出显示列表中的一篇文章。因此，我们向块的类添加了`post--sponsored`修改器：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At first, class names containing double dashes and underscores may make you
    dizzy, but after a while you will get used to it. The BEM naming convention helps
    developers remarkably by showing indention. So when reading your own or somebody
    else's code, you can quickly figure out by its name what the purpose of a class
    is.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，包含双破折号和下划线的类名可能会让你头晕，但过一段时间你会习惯的。BEM命名约定通过显示缩进，极大地帮助开发人员。因此，当阅读自己或别人的代码时，你可以通过类名快速地弄清楚一个类的目的。
- en: In addition to the BEM naming convention, we will use a few ideas from the Pragmatic
    CSS styleguide ([https://github.com/dsheiko/pcss](https://github.com/dsheiko/pcss)).
    We will give names prefixed with `is-` and `has-` to the classes representing
    global states (for example, `is-hidden` and `has-error`); we will prefix layout-related
    classes with `l-` (for example, `l-app`). Finally, we will amalgamate all CSS
    files in two folders (`Component` and `Base`).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了BEM命名约定之外，我们还将从实用CSS样式指南（[https://github.com/dsheiko/pcss](https://github.com/dsheiko/pcss)）中借鉴一些想法。我们将给代表全局状态的类添加以`is-`和`has-`为前缀的名称（例如，`is-hidden`和`has-error`）；我们将用`l-`为前缀来表示与布局相关的类（例如，`l-app`）。最后，我们将把所有CSS文件合并到两个文件夹（`Component`和`Base`）中。
- en: Defining base rules
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义基本规则
- en: 'Firstly, we will create a `Base` directory and place the reset styles in there:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`Base`目录，并将重置样式放在其中：
- en: '`./assets/css/Base/base.css`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Base/base.css`'
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For HTML scope, we will enable font smoothing for better font rendering.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTML范围，我们将启用字体平滑，以获得更好的字体渲染。
- en: Then, we will set box sizing of every element (`*`) in `border-box`. The default
    CSS box model is `content-box`, where width and height set to an element do not
    include padding and border. However, if we are setting, let's say, a sidebar width
    `250px`, I would expect it to cover this length. With `border-box`, the box's
    size is always exactly what we set it, regardless of padding or border, but if
    you ask me, the `border-box` mode feels more natural.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将设置每个元素（`*`）的盒子尺寸为`border-box`。默认的CSS盒模型是`content-box`，其中宽度和高度设置为一个元素不包括填充和边框。但是，如果我们设置，比如说，侧边栏宽度为`250px`，我希望它能覆盖这个长度。使用`border-box`，盒子的大小始终是我们设置的大小，而不受填充或边框的影响，但如果你问我，`border-box`模式感觉更自然。
- en: 'We will reset indents and markers--for an unordered list--that are used for
    navigation (`nav > ul`). We make body element span the height of the entire viewport
    (`min-height: 100vh`), remove the default margin, and define the font family.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将重置用于导航（`nav > ul`）的缩进和标记-无序列表。我们使body元素跨越整个视口的高度（`min-height: 100vh`），移除默认边距，并定义字体系列。'
- en: We will also introduce a global state `is-hidden` that can be applied on any
    element to remove it from the page flow. By the way, that is a good example of
    proactive and, therefore, permissible use of `!important`. By adding an `is-hidden`
    class (with JavaScript), we state that we want the element to hide, with no exceptions.
    Thus, we will never run into a specificity problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将引入一个全局状态`is-hidden`，可以应用于任何元素，将其从页面流中移除。顺便说一句，这是对`!important`的积极和因此可允许的使用的一个很好的例子。通过添加一个`is-hidden`类（使用JavaScript），我们声明我们希望隐藏该元素，没有例外。因此，我们永远不会遇到特异性问题。
- en: Defining layouts
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义布局
- en: 'That''s enough for base styles; now, we will start on the layout. First, we
    will arrange the title bar, main section, and footer:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就够作为基本样式了；现在，我们将开始布局。首先，我们将安排标题栏、主要部分和页脚：
- en: '![](img/7b48b067-df09-4346-8598-7e78060099b9.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b48b067-df09-4346-8598-7e78060099b9.png)'
- en: 'To achieve this design, we should preferably use Flexbox. If you are not familiar
    with this layout mode, I will recommend the article, *Understanding Flexbox: Everything
    you need to know* ([http://bit.ly/2m3zmc1](http://bit.ly/2m3zmc1)). It provides
    probably the most clear and easy-to-catch-up way of explaining what a Flexbox
    is, what options are available, and how to use them efficiently.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种设计，我们应该优先使用Flexbox。如果您对这种布局模式不熟悉，我建议阅读文章《理解Flexbox：你需要知道的一切》（[http://bit.ly/2m3zmc1](http://bit.ly/2m3zmc1)）。它可能是最清晰和易于理解的解释Flexbox是什么，有哪些选项可用，以及如何有效使用它们的方式。
- en: 'So, we can define the application layout like that:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以这样定义应用程序布局：
- en: '`./assets/css/Component/l-app.css`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/l-app.css`'
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We make `.l-app` a flex container that arranges inner items along a cross axis,
    vertically (`flex-flow: column nowrap`). In addition, we request the flex items
    to fill in the full height of the container (`align-items: stretch`). We set the
    title bar and footer to a fixed height always (`flex: 0 0 40px`). However, the
    main section may shrink and grow depending on the viewport size (`flex: 1 1 auto`).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使`.l-app`成为一个伸缩容器，沿着交叉轴垂直地排列内部项目（`flex-flow: column nowrap`）。此外，我们要求伸缩项目填充容器的整个高度（`align-items:
    stretch`）。我们将标题栏和页脚设置为固定高度（`flex: 0 0 40px`）。但是，主要部分可能会根据视口大小而收缩和增长（`flex: 1 1
    auto`）。'
- en: 'Since we have an application layout, let''s define the inner layout for the
    main section:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有了应用程序布局，让我们为主要部分定义内部布局：
- en: '![](img/1e6327d8-6dc1-4d44-bcb1-2ddc77b39764.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e6327d8-6dc1-4d44-bcb1-2ddc77b39764.png)'
- en: 'What we need to do is to make items--`dir-list` and `file-list`--to arrange
    horizontally one after another:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是使`dir-list`和`file-list`项目水平排列：
- en: '`./assets/css/Component/l-main.css`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/l-main.css`'
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, we set the flex items to line up along an main axis
    horizontally using `flex-flow: row nowrap`. The `l-main__dir-list` item has a
    fixed width and its width depends on the viewport.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述代码中，我们使用`flex-flow: row nowrap`将伸缩项目沿着主轴水平排列。`l-main__dir-list`项目具有固定宽度，其宽度取决于视口。'
- en: 'Actually, it''s hard to see any results of our work until we give the components
    some colors:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在给组件添加一些颜色之前，很难看到我们工作的任何结果：
- en: '`./assets/css/Component/titlebar.css`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/titlebar.css`'
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We also colorise the `footer` component:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还给`footer`组件上色：
- en: '`./assets/css/Component/footer.css`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/footer.css`'
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'and the `file-list` component:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 和`file-list`组件：
- en: '`./assets/css/Component/file-list.css`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/file-list.css`'
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'and eventually the `dir-list` component:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是`dir-list`组件：
- en: '`./assets/css/Component/dir-list.css`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/dir-list.css`'
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we only need to include all the modules in the index file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在索引文件中包含所有模块：
- en: '`./assets/css/app.css`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/app.css`：'
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As it''s done, we launch the application using the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动后，我们使用以下命令启动应用程序：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It launches the application and shows the layout:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它启动应用程序并显示布局：
- en: '![](img/29793a5c-e5ee-4901-b083-f3d13c1d5979.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29793a5c-e5ee-4901-b083-f3d13c1d5979.png)'
- en: 'For font sizes and related parameters such as padding, we use relative units
    (em). It means that we set these values relative to the parent font size:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字体大小和相关参数，如填充，我们使用相对单位（em）。这意味着我们将这些值相对于父字体大小设置：
- en: '`.component { font-size: 10px; } .component__part { font-size: 1.6em; /* computed
    font-size is 10*1.6=16px */ }`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`.component { font-size: 10px; } .component__part { font-size: 1.6em; /* 计算后的字体大小为10*1.6=16px
    */ }`'
- en: This trick allows us to efficiently scale components. For example, when using
    the **Responsive Web Design** (**RWD**) approach, we may need to reduce the font
    sizes and spacing proportionally for a smaller viewport width. When using ems,
    we just change font size for a target component, and values of subordinated rules
    will adapt.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧可以让我们有效地扩展组件。例如，当使用**响应式Web设计**（**RWD**）方法时，我们可能需要按比例减小较小视口宽度的字体大小和间距。使用ems时，我们只需为目标组件更改字体大小，从而使从属规则的值适应。
- en: Defining CSS variables
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义CSS变量
- en: NW.js releases quite frequently, basically updating with every new version of
    Chromium. That means we can safely use the latest CSS features. The one I'm most
    excited about is called **Custom Properties** ([https://www.w3.org/TR/css-variables](https://www.w3.org/TR/css-variables)),
    which were formerly known as CSS variables.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: NW.js的发布频率相当高，基本上会随着每个新版本的Chromium更新。这意味着我们可以安全地使用最新的CSS功能。我最感兴趣的是**自定义属性**（[https://www.w3.org/TR/css-variables](https://www.w3.org/TR/css-variables)），它们以前被称为CSS变量。
- en: 'Actually, variables are one of the main reasons CSS preprocessors exist. With
    NW.js, we can set variables natively in CSS, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，变量是CSS预处理器存在的主要原因之一。使用NW.js，我们可以在CSS中本地设置变量，如下所示：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After that, we can use the variable instead of real values across all the modules
    in the document scope:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以在文档范围内的所有模块中使用变量而不是实际值：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So if we decide now to change one of defined colors, we need to do it once,
    and any rules relying on the variable receives the new value. Let's adopt this
    technology for our application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们现在决定更改其中一个定义的颜色，我们只需要做一次，任何依赖于该变量的规则都会接收到新值。让我们为我们的应用程序采用这项技术。
- en: 'First, we need to create definitions for the module:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为模块创建定义：
- en: '`./assets/css/Base/defenitions.css`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Base/defenitions.css`'
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we define variables representing colors and fixed sizes in the root scope.
    This new file gets included to the CSS index file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在根范围内定义了代表颜色和固定尺寸的变量。这个新文件被包含在CSS索引文件中：
- en: '`./assets/css/app.css`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/app.css`：'
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we have to modify our components. First we take care of the top level
    application layout:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要修改我们的组件。首先，我们要处理顶层应用程序布局：
- en: '`./assets/css/Component/l-app.css`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/l-app.css`'
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then we layout the main section that consists of two columns with dir and file
    lists:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们布局由目录和文件列表组成的主要部分的两列：
- en: '`./assets/css/Component/l-main.css`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/l-main.css`'
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We style the header:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们样式化页眉：
- en: '`./assets/css/Component/titlebar.css`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/titlebar.css`'
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And the footer:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 和页脚：
- en: '`./assets/css/Component/footer.css`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/footer.css`'
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We also need to set colors for the child components of the main section. So
    style the file list component:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为主要部分的子组件设置颜色。因此，样式化文件列表组件：
- en: '`./assets/css/Component/file-list.css`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/file-list.css`'
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'and directory list component:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 和目录列表组件：
- en: '`./assets/css/Component/dir-list.css`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/dir-list.css`'
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can run the application to observe that it looks the same. All the colors
    and sizes are successfully extrapolated from the variables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行应用程序来观察它看起来是一样的。所有颜色和大小都成功地从变量中推断出来。
- en: Sticking the title bar and header
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定标题栏和页眉
- en: The layout looks fine without any content, but what happens to the layout if
    it receives content that is too long?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 布局在没有任何内容的情况下看起来很好，但如果接收到太长的内容会发生什么？
- en: '![](img/cf75cef3-8c6b-439f-986f-067ab9c7b1bd.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf75cef3-8c6b-439f-986f-067ab9c7b1bd.png)'
- en: In fact, we will have a header and footer shifting out of the view when scrolling.
    It doesn't look user-friendly. Fortunately, we can change it easily using another
    fresh addition to CSS called **Sticky positioning** ([https://www.w3.org/TR/css-position-3/#sticky-pos](https://www.w3.org/TR/css-position-3/#sticky-pos)).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当滚动时，我们会有一个头部和页脚移出视图。这看起来不够用户友好。幸运的是，我们可以轻松地使用CSS的另一个新功能**Sticky positioning**（[https://www.w3.org/TR/css-position-3/#sticky-pos](https://www.w3.org/TR/css-position-3/#sticky-pos)）来改变它。
- en: 'All we need to do is to modify slightly the title bar component:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是稍微修改标题栏组件：
- en: '`./assets/css/Component/titlebar.css`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/titlebar.css`'
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'and the footer:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 和页脚：
- en: '`./assets/css/Component/footer.css`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/footer.css`'
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding code, we declared that the title bar will stick to the top
    and footer to the bottom. Run the application now, and you will note that both
    boxes are always visible, regardless of scrolling:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明标题栏将固定在顶部，页脚将固定在底部。现在运行应用程序，你会注意到两个框始终可见，无论滚动如何：
- en: '![](img/3e710942-25dd-40f5-b47d-ab66107b65a0.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e710942-25dd-40f5-b47d-ab66107b65a0.png)'
- en: Styling the title bar
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化标题栏
- en: 'Speaking of the view content, we are ready to populate the layout slots. We
    will start with the title bar:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 说到视图内容，我们已经准备好填充布局插槽。我们将从标题栏开始：
- en: '`./index.html`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`./index.html`'
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Basically, we want the current path to be displayed on the left and window
    controls on the right. It can be achieved with Flexbox. It''s a tiny layout that
    won''t be reused, so it won''t hurt if we mix it in the component module:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们希望当前路径显示在左侧，窗口控件显示在右侧。这可以通过Flexbox实现。这是一个不会被重用的小型布局，因此如果我们将其混合到组件模块中，也不会有什么问题：
- en: '`./assets/css/Component/titlebar.css`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/titlebar.css`'
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](img/f6745676-f99a-4c8d-9547-326cb32d1044.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6745676-f99a-4c8d-9547-326cb32d1044.png)'
- en: Styling the directory list
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化目录列表
- en: 'The directory list will be used for navigation through the file system, so
    we will wrap it with the `nav > ul` structure:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 目录列表将用于浏览文件系统，因此我们将其包装在`nav > ul`结构中：
- en: '`./index.html`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`./index.html`'
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To support it with styles, we go with the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持它的样式，我们使用以下代码：
- en: '`./assets/css/Component/dir-list.css`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/dir-list.css`'
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that we''ve just introduced a couple of variables. Let''s add them in
    the definitions module:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只是引入了一些变量。让我们在定义模块中添加它们：
- en: '`./assets/css/Base/definitions.css`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Base/definitions.css`'
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As we ruin the application we can observe the new contents in the directory
    list:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们可以观察到目录列表中的新内容：
- en: '![](img/11a5efa6-e530-4c6d-9712-3a848f5887e1.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11a5efa6-e530-4c6d-9712-3a848f5887e1.png)'
- en: Styling a file list
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化文件列表
- en: 'The file list will be represented as a table, but we will build it out of an
    unordered list. The`./index.html` file contains the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 文件列表将被表示为表格，但我们将使用无序列表构建它。`./index.html`文件包含以下代码：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In fact, here **Grid Layout** ([https://www.w3.org/TR/css3-grid-layout/](https://www.w3.org/TR/css3-grid-layout/))
    would probably suit better; however, at the time of writing, this CSS module was
    not yet available in NW.js. So, we go on again with Flexbox:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里**Grid Layout**（[https://www.w3.org/TR/css3-grid-layout/](https://www.w3.org/TR/css3-grid-layout/)）可能更合适；然而，在撰写本文时，NW.js中尚未提供此CSS模块。因此，我们继续使用Flexbox：
- en: '`./assets/css/Component/file-list.css`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/file-list.css`'
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: I believe that everything is clear with the preceding code, except that you
    might not be familiar with the `pseudo-class :not()`. I want to change the color
    and mouse cursor on hover for all the file list items, except the table header.
    So, I achieve it with a selector that can be read like any `.file-list__li` that
    is not `.file-list__head`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信前面的代码都很清楚，除非你可能不熟悉`伪类:not()`。我想在悬停时改变所有文件列表项的颜色和鼠标指针，但不包括表头。因此，我使用了一个选择器，可以读作任何`.file-list__li`，但不是`.file-list__head`。
- en: 'The following assignment goes to the definitions file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下任务分配给定义文件：
- en: '`./assets/css/Base/definitions.css`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Base/definitions.css`'
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As we run the application we can see the table with the file list:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们可以看到带有文件列表的表格：
- en: '![](img/795a6487-fe3a-4393-9b4b-fcb43fae7a37.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/795a6487-fe3a-4393-9b4b-fcb43fae7a37.png)'
- en: Styling the footer
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化页脚
- en: 'Eventually, we now reached the footer:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在到达了页脚：
- en: '`./index.html`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`./index.html`'
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We arrange the application title to the left and language selector to the right.
    What do we use to lay this out? Obviously, Flexbox:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用程序标题排列到左侧，语言选择器排列到右侧。我们用什么来布局？显然是Flexbox：
- en: '`./assets/css/Component/footer.css`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/footer.css`'
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It''s a special case. We set items to align right in general, but have reset
    it for the `.footer__header` item that snuggles against the left border driven
    by `margin-right: auto`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个特殊情况。通常我们设置项目右对齐，但已经重置了`.footer__header`项目，它紧贴着由`margin-right: auto`驱动的左边框：'
- en: '![](img/da3040e4-fbf6-418e-a825-51513fa803d8.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da3040e4-fbf6-418e-a825-51513fa803d8.png)'
- en: 'While looking at the result, I think it would be nice to emphasize the functional
    meaning of some UI elements with icons. I personally prefer the icon font of **Material
    Design system** ([https://material.io/icons/](https://material.io/icons/)). So,
    as described in the Developer Guide ([http://google.github.io/material-design-icons/](http://google.github.io/material-design-icons/)),
    we include the corresponding Google Web Font to `index.html`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看结果时，我认为强调一些UI元素的功能含义与图标会很好。我个人更喜欢**Material Design系统**的图标字体（[https://material.io/icons/](https://material.io/icons/)）。因此，如开发人员指南中所述（[http://google.github.io/material-design-icons/](http://google.github.io/material-design-icons/)），我们将相应的Google
    Web字体包含到`index.html`中：
- en: '`./index.html`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`./index.html`'
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'I would suggest that you dedicate a component that will represent an icon and
    fill it with the rule set suggested by Material Design:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您专门为代表图标的组件分配一个规则集，并使用Material Design建议的规则集填充它：
- en: '`./assets/css/Component/icon.css`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/icon.css`'
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we can add an icon anywhere in HTML, as simple as that:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在HTML中的任何位置添加一个图标，就是这么简单：
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Why not then make a folder icon accompanying items in the directory list?:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么不在目录列表中的项目旁边加上一个文件夹图标呢？：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'I believe that a globe icon will get along nicely with the language selector.
    So we modify the HTML:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信地球仪图标会与语言选择器很好地配合。所以我们修改HTML：
- en: '`./index.html`'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`./index.html`'
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'and we add a class in the CSS:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在CSS中添加一个类：
- en: '`./assets/css/Component/footer.css`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/footer.css`'
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As we run the application we can see an icon rendered next to the language
    selector control:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们可以看到一个图标呈现在语言选择器控件旁边：
- en: '![](img/b909a6d5-3d0d-46d4-ab5c-19e5cc8e82f2.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b909a6d5-3d0d-46d4-ab5c-19e5cc8e82f2.png)'
- en: 'If something went wrong after running the application, you can always call
    for Developer Tools--just press *F12*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行应用程序后出现问题，您可以随时调用开发者工具--只需按下* F12 *：
- en: '![](img/0aac4d8b-a258-47b0-a736-74be5e385114.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0aac4d8b-a258-47b0-a736-74be5e385114.png)'
- en: Fulfilling the functional requirements
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 满足功能要求
- en: 'We''ve described the semantic structure of our application with HTML. We have
    defined with CSS how our UI elements shall look. Now, we will teach our application
    to retrieve and update the content as well as to respond to user events. Actually,
    we will allocate the following tasks to several modules:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用HTML描述了应用程序的语义结构。我们已经用CSS定义了我们的UI元素应该是什么样子。现在，我们将教会我们的应用程序检索和更新内容，并响应用户事件。实际上，我们将把以下任务分配给几个模块：
- en: '`DirService`: This provides control on directory navigation'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DirService`：这提供了对目录导航的控制'
- en: '`FileService`: This handles file operations'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileService`：这处理文件操作'
- en: '`FileListView`: This updates the file list with the data received from DirService,
    handles user events (open file, delete file, and so on) using FileService'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileListView`：这使用DirService接收到的数据更新文件列表，使用FileService处理用户事件（打开文件，删除文件等）'
- en: '`DirListView`: This updates the directory list with the data received from
    DirService and handles navigation events using DirService'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DirListView`：这使用DirService接收到的数据更新目录列表，并使用DirService处理导航事件'
- en: '`TitleBarPath`: This updates the current location with the path received from
    DirService'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TitleBarPath`：这使用DirService接收到的路径更新当前位置'
- en: '`TitleBarActions`: This handles user iteration with title bar buttons'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TitleBarActions`：这处理用户与标题栏按钮的交互'
- en: '`LangSelector`: This handles user iteration with language selector'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LangSelector`：这处理用户与语言选择器的交互'
- en: However, before we start coding, let's see what we have in our arsenal.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始编码之前，让我们看看我们的工具库中有什么。
- en: NW.js gets distributed together with the latest stable version of Node.js, which
    has a great support for ES2015/ES2016 ([http://node.green](http://node.green)).
    It means that we can use any of the inherent new JavaScript features, but modules
    ([http://bit.ly/2moblwB](http://bit.ly/2moblwB)). Node.js has its own CommonJS-compliant
    module loading system. When we request a module by path, for example, `require(
    "./foo" )`, the runtime searches for a corresponding file (`foo.js`, `foo.json`,
    or `foo.node`) or a directory (`./foo/index.js`). Then, Node.js evaluates the
    module code and returns the exported type.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: NW.js与最新稳定版本的Node.js一起分发，Node.js对ES2015/ES2016有很好的支持（[http://node.green](http://node.green)）。这意味着我们可以使用任何内在的新JavaScript特性，但模块（[http://bit.ly/2moblwB](http://bit.ly/2moblwB)）。Node.js有自己的CommonJS兼容模块加载系统。当我们按路径请求一个模块，例如`require（“./foo”）`，运行时会搜索相应的文件（`foo.js`，`foo.json`或`foo.node`）或目录（`./foo/index.js`）。然后，Node.js评估模块代码并返回导出的类型。
- en: 'For example, we can create a module that exports a string:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个导出字符串的模块：
- en: '`./foo.js`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`./foo.js`'
- en: '[PRE61]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'and another one, which imports from the first module:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个，从第一个模块导入：
- en: '`./bar.js`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`./bar.js`'
- en: '[PRE62]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If we run it, we get the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，我们会得到以下结果：
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: One should note here that regardless of how many times we require a module,
    it gets executed just once, and every time, its exports are taken from the cache.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里应该注意的是，无论我们需要一个模块多少次，它只会执行一次，并且每次都会从缓存中获取其导出。
- en: Starting with ES2015
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从ES2015开始
- en: As I have already mentioned, NW.js provides a complete support of JavaScript
    of ES2015 and ES2016 editions. To understand what it really means, we need a brief
    excursion into the history of the language. The standardized specification for
    JavaScript was first released in 1997 (ECMA-262 1st Edition).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经提到的，NW.js完全支持ES2015和ES2016版本的JavaScript。要理解它的真正含义，我们需要简要回顾一下这种语言的历史。JavaScript的标准规范首次发布于1997年（ECMA-262第1版）。
- en: Since then, the language has not really changed for 10 years. The 4th edition
    proposed in 2007 called for drastic changes. However, the working group (TC39)
    failed to agree on the feature set. Some proposals have been deemed unsound for
    the Web, but some were adopted in a new project code named Harmony. The project
    turned into the 6th edition of the language specification and was released in
    2015 under the official name ES2015\. Now, the committee is releasing a new specification
    every year.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，语言在10年内并没有真正改变。2007年提出的第4版呼吁进行重大改变。然而，工作组（TC39）未能就功能集达成一致意见。一些提案被认为对Web不利，但有些被采纳到了一个名为Harmony的新项目中。该项目成为了语言规范的第6版，并于2015年以ES2015的官方名称发布。现在，委员会每年都会发布一个新的规范。
- en: New JavaScript is backward compatible with an earlier version. So, you can still
    write code with the syntax of the ECMAScript 5th edition or even 3rd one, but
    why should we lose the opportunity to work with the new advanced syntax and feature
    set? I think it would be helpful if we now go through some new language aspects
    that will be used in the application.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 新的JavaScript向后兼容较早的版本。因此，您仍然可以使用ECMAScript第5版甚至第3版的语法编写代码，但为什么我们要放弃使用新的高级语法和功能集的机会呢？我认为如果我们现在了解一些将在应用程序中使用的新语言方面将会很有帮助。
- en: Scoping
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: 'In the old days, we used to always go with the `var` statement for variable
    declarations. ES2015 introduces two new declaration variables--`let` and `const`.
    The `var` statement declares a variable in a function scope:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们总是使用`var`语句进行变量声明。ES2015引入了两个新的声明变量--`let`和`const`。`var`语句在函数作用域中声明变量：
- en: '[PRE64]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A variable declared with `var` (`foo`) spans the entire function scope, meaning
    that every time we reference it by name, we target the same variable. Both `let`
    and `const` operate on block scopes (`if` statement, `for/while` loops, and so
    on) as shown:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`声明的变量（`foo`）跨越整个函数作用域，这意味着每次我们通过名称引用它时，都会指向相同的变量。`let`和`const`都在块作用域（`if`语句，`for/while`循环等）中运行，如下所示：
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see from the preceding example, we can declare a new variable in
    a block and it will exist only within that block. The statement `const` works
    the same, except it defines a constant that cannot be reassigned after it was
    declared.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的例子中可以看出，我们可以在块中声明一个新变量，它只存在于该块中。`const`语句的工作方式相同，只是它定义了一个在声明后不能重新分配的常量。
- en: Classes
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'JavaScript implies a prototype-based, object-oriented programming style. It
    differs from class-based OOP that is used in other popular programming languages,
    such as C++, C#, Objective-C, Java, and PHP. This used to confuse newcomer developers.
    ES2015 offers a syntactic sugar over the prototype, which looks pretty much like
    canonical classes:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript暗示了一种基于原型的面向对象编程风格。它与其他流行的编程语言（如C++、C#、Objective-C、Java和PHP）中使用的基于类的OOP不同。这常常让新手开发人员感到困惑。ES2015为原型提供了一种语法糖，看起来非常像经典类：
- en: '[PRE68]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we declare a `Machine` class that during instantiation assigns a value
    to a prototype property, `name`. A `Robot` class extends `Machine` and, therefore,
    inherits the prototype. In subtype, we can invoke the parent constructor with
    the `super` keyword.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个`Machine`类，在实例化期间为原型属性`name`分配一个值。`Robot`类扩展了`Machine`，因此继承了原型。在子类型中，我们可以使用`super`关键字调用父构造函数。
- en: We also define a prototype method--`move`--and a static method--`normalizeDirection`.
    The `move` method has a so-called **default function parameter**. So, if we omit
    the direction argument while calling move method, the parameter automatically
    sets to `"left"`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个原型方法--`move`--和一个静态方法--`normalizeDirection`。`move`方法具有所谓的**默认函数参数**。因此，如果我们在调用move方法时省略方向参数，参数将自动设置为`"left"`。
- en: 'In ES2015, we can use a short syntax for the methods and do not need to repeat
    function keywords with every declaration. It''s also available for object literals:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015中，我们可以使用一种简短的语法来定义方法，而不需要在每个声明中重复函数关键字。它也适用于对象文字：
- en: '[PRE70]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The template literal
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板文字
- en: 'Another great addition to JavaScript is **template literals**. These are string
    literals that can be multiline and can include interpolated expressions (``${expression}``).
    For example, we can refactor our move method body, as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的另一个重要补充是**模板文字**。这些是可以多行的字符串文字，可以包含插入的表达式（``${expression}``）。例如，我们可以重构我们的move方法体，如下所示：
- en: '[PRE71]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Getters and setters
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: 'Getters and setters were added back in ES5.1\. In ES2015, it was extended for
    computed property names and goes hand in hand with a short method notation:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器和设置器在ES5.1中被添加。在ES2015中，它被扩展为计算属性名称，并与短方法符号一起使用：
- en: '[PRE72]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Arrow functions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'A function declaration also obtained syntactic sugar. We write it now with
    a shorter syntax. It''s remarkable that a function defined this way (fat arrow
    function) automatically picks up the surrounding context:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明也获得了语法糖。我们现在使用更短的语法来编写它。值得注意的是，以这种方式定义的函数（箭头函数）会自动获取周围的上下文：
- en: '[PRE74]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: When using old function syntax, the callback function passed to an array's method,
    `find`, would lose the context of the `Robot` instance. Arrow functions, though,
    do not create their own context and, therefore, outer context (`this`) gets in
    the closure.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用旧的函数语法时，传递给数组方法`find`的回调函数会丢失`Robot`实例的上下文。然而，箭头函数不会创建自己的上下文，因此外部上下文（`this`）会进入闭包。
- en: 'In this particular example, as it often goes with array extras, the callback
    body is extremely short. So, we can use an even shorter syntax:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，就像经常使用数组额外的情况一样，回调体非常简短。因此，我们可以使用更短的语法：
- en: '[PRE75]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Destructuring
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构
- en: 'In new JavaScript, we can extract specific data from arrays and objects. Let''s
    say, we have an array that could be built by an external function, and we want
    its first and second elements. We can extract them as simple as this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的JavaScript中，我们可以从数组和对象中提取特定的数据。假设我们有一个数组，可以由外部函数构建，并且我们想要它的第一个和第二个元素。我们可以这样简单地提取它们：
- en: '[PRE76]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: So here, we declare two new constants--`r2d2` and `c3po`--and assign the first
    and the second array elements to them, respectively.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了两个新的常量--`r2d2`和`c3po`--并分别将第一个和第二个数组元素赋给它们。
- en: 'We can do the same with objects:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对对象做同样的事情：
- en: '[PRE77]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: What did we do? We declared two constants--`occupation` and `homeworld`--that
    receive values from correspondingly named object members.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了什么？我们声明了两个常量--`occupation`和`homeworld`--分别从相应命名的对象成员中接收值。
- en: 'What is more, we can even alias an object member while extracting:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，我们甚至可以在提取时给对象成员取别名：
- en: '[PRE78]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the last example, we delegated the values of object members--`occupation`
    and `homeworld`--to newly created constants--`affair` and `home`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，我们将对象成员`occupation`和`homeworld`的值委托给新创建的常量`affair`和`home`。
- en: Handling windowing actions
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理窗口操作
- en: 'Coming back to the `file-explorer`, we can start with the `TitleBarActions`
    module that listens to user click events on title bar buttons and performs the
    corresponding windowing action. First, we need to mark the action nodes in HTML.
    The `./index.html` file contains the following code:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`file-explorer`，我们可以从`TitleBarActions`模块开始，该模块监听标题栏按钮的用户点击事件并执行相应的窗口操作。首先，我们需要在HTML中标记动作节点。`./index.html`文件包含以下代码：
- en: '[PRE79]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here, we specify our bounding box (`data-bind="titlebar"`) and the close window
    button (`data-bind="close"`). Let''s begin with the only button. The `./js/View/TitleBarActions.js`
    file contains the following code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了我们的边界框（`data-bind="titlebar"`）和关闭窗口按钮（`data-bind="close"`）。让我们从唯一的按钮开始。`./js/View/TitleBarActions.js`文件包含以下代码：
- en: '[PRE80]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we define a `TitleBarActionView` class that accepts an HTML element as
    a parameter. This element represents the view bounding box, meaning that the instance
    of this class will take care only of the passed in element and its descendants.
    During construction, the class will search for the first element in the scope
    of the bounding box that matches `selector [data-bind=close]`--the close window
    button of the title bar. In the `bindUI` method, we subscribe for clicks events
    on the Close button. When the button is clicked, the `onClose` method is called
    in the context of a `TitleBarActionView` instance, as we bound it in `bindUi`
    (`this.onClose.bind( this )`). The `onClose` method closes the window using the
    NW.js Window API ([http://docs.nwjs.io/en/latest/References/Window/](http://docs.nwjs.io/en/latest/References/Window/)),
    namely it requests a current window object `nw.Window.get()` and calls its close
    method.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`TitleBarActionView`类，它接受一个HTML元素作为参数。这个元素表示视图的边界框，这意味着这个类的实例只会处理传入的元素及其后代。在构造过程中，该类将在边界框范围内搜索与`selector
    [data-bind=close]`匹配的第一个元素--标题栏的关闭窗口按钮。在`bindUI`方法中，我们订阅了关闭按钮的点击事件。当按钮被点击时，`onClose`方法将在`TitleBarActionView`实例的上下文中被调用，因为我们在`bindUi`中绑定了它（`this.onClose.bind(
    this )`）。`onClose`方法使用NW.js Window API（[http://docs.nwjs.io/en/latest/References/Window/](http://docs.nwjs.io/en/latest/References/Window/)）关闭窗口，即请求当前窗口对象`nw.Window.get()`并调用其close方法。
- en: NW.js doesn't provide a module for the API, but exposes the `nw` variable in
    the global scope.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: NW.js没有为API提供模块，而是在全局范围内暴露了`nw`变量。
- en: 'So, we have the first view module and can use it the main script:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了第一个视图模块，并可以在主脚本中使用它：
- en: '`./js/app.js`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/app.js`'
- en: '[PRE81]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here, we import the `TileBarActionView` class from the `./js/View/TitleBarActions`
    module and make an instance of it. We pass the first document element matching
    selector `[data-bind=titlebar]` to the class constructor.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`./js/View/TitleBarActions`模块中导入`TileBarActionView`类并创建一个实例。我们将第一个匹配选择器`[data-bind=titlebar]`的文档元素传递给类构造函数。
- en: Have you noticed that we used destructuring while importing from the module?
    Particularly, we extracted the `TitleBarActionsView` class into a respectively
    called constant.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们在从模块中导入时使用了解构吗？特别是，我们将`TitleBarActionsView`类提取到了一个相应命名的常量中。
- en: Now, we can launch the application and observe, as clicking on the close button
    really closes the window.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动应用程序并观察，当点击关闭按钮时，窗口确实关闭了。
- en: 'Going further, we take care of other title bar buttons. So, we adapt our `index.html`
    file to identify the buttons, nodes with `unmaximize`, `maximize`, and `minimize`
    values for the `data-bind` attribute. Then, we collect in the `TileBarActionView`
    constructor references to the corresponding HTML elements:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步，我们要处理其他标题栏按钮。因此，我们调整我们的`index.html`文件以识别按钮，使用`data-bind`属性的`unmaximize`、`maximize`和`minimize`值来标识节点。然后，在`TileBarActionView`构造函数中收集对应的HTML元素的引用：
- en: '[PRE82]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Of course, we have to add new listeners in the `bindUi` module, respectively:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须在`bindUi`模块中添加新的监听器：
- en: '[PRE83]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The handler for minimizing the window button looks pretty much the same as
    the one we have already examined previously. It just uses the corresponding method
    of the NW.js Window API:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化窗口按钮的处理程序看起来与我们之前已经检查过的处理程序非常相似。它只是使用了NW.js Window API的相应方法：
- en: '[PRE84]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'With maximize and minimize (restore) window buttons, we need to take the fact
    that while one button is visible the second one shall be hidden into account.
    This we achieve with the `toggleMaximize` method:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最大化和最小化（还原）窗口按钮，我们需要考虑到一个按钮可见时，另一个按钮应该隐藏的事实。我们可以通过`toggleMaximize`方法实现这一点：
- en: '[PRE85]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Event handler for these buttons calls this method to the toggle buttons view:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮的事件处理程序调用此方法来切换按钮视图：
- en: '[PRE86]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Writing a service to navigate through directories
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个用于浏览目录的服务
- en: 'Other modules, such as `FileListView`, `DirListView`, and `TitleBarPath`, consume
    the data from the filesystem, such as directory list, file list, and the current
    path. So we need to create a service that will provide this data:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模块，如`FileListView`、`DirListView`和`TitleBarPath`，从文件系统中获取数据，如目录列表、文件列表和当前路径。因此，我们需要创建一个服务来提供这些数据：
- en: '`./js/Service/Dir.js`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Service/Dir.js`'
- en: '[PRE87]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: First of all, we import Node.js core module `fs` that provides us access to
    the filesystem. We also extract functions--`join` and `parse`--from the `path`
    module. We will need them for manipulations in the file/directory path.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入Node.js核心模块`fs`，它为我们提供了对文件系统的访问。我们还从`path`模块中提取函数--`join`和`parse`。我们将需要它们来操作文件/目录路径。
- en: Then, we declare the `DirService` class. On construction, it creates a `dir`
    property, which takes either a passed-in value or the current working directory
    (`process.cwd()`). We add a static method--`readDir`--to the class that reads
    the directory content on a given location. The `fs.readdirSync` method retrieves
    the content of a directory, but we extend the payload with file/directory stats
    (`https://nodejs.org/api/fs.html#fs_class_fs_stats`). In case the stats cannot
    be obtained, we replace its array element with `false`. To avoid such gaps in
    the output array, we will run the array `filter` method. Thus, on the exit point,
    we have a clean array of filenames and file stats.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明`DirService`类。在构造时，它创建一个`dir`属性，该属性接受传入的值或当前工作目录（`process.cwd()`）。我们向类添加了一个静态方法--`readDir`--用于读取给定位置的目录内容。`fs.readdirSync`方法检索目录的内容，但我们扩展了文件/目录统计信息（`https://nodejs.org/api/fs.html#fs_class_fs_stats`）。如果无法获取统计信息，我们将其数组元素替换为`false`。为了避免输出数组中的这种间隙，我们将运行数组`filter`方法。因此，在退出点上，我们有一个干净的文件名和文件统计信息数组。
- en: The `getFileList` method requests `readDir` for the current directory content
    and filters the list to leave only files in there.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFileList`方法请求`readDir`获取当前目录内容，并过滤列表，只留下其中的文件。'
- en: The `getDirList` method filters, evidently, the list for directories only. Besides,
    it prepends the list with a `..` directory for upward navigation, but only if
    we are not in the system root.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDirList`方法显然是仅对目录进行过滤。此外，它在列表前面加上一个`..`目录，用于向上导航，但只有在我们不在系统根目录时才这样做。'
- en: 'So, we can get both lists from the modules consuming them. When the location
    changes and new directory and file lists get available, each of these modules
    have to update. To implement it, we will use the observe pattern:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以从使用它们的模块中获取这两个列表。当位置更改并且新的目录和文件列表可用时，这些模块中的每个模块都必须进行更新。为了实现它，我们将使用观察者模式：
- en: '`./js/Service/Dir.js`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Service/Dir.js`'
- en: '[PRE88]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We export from events, core module the `EventEmitter` class (`https://nodejs.org/api/events.html`).
    By extending it with `DirService`, we make the service an event emitter. It gives
    us the possibility to fire service events and to subscribe on them:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从事件、核心模块中导出`EventEmitter`类（`https://nodejs.org/api/events.html`）。通过将其与`DirService`扩展，我们使服务成为事件发射器。这使我们有可能触发服务事件并订阅它们：
- en: '[PRE89]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: So whenever the `setDir` method is called to change the current location, it
    fires an event of type `"update"`. Given the consuming modules are subscribed,
    they respond to the event by updating their views.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当调用`setDir`方法更改当前位置时，它会触发类型为`"update"`的事件。假设消费模块已订阅，它们会通过更新其视图来响应事件。
- en: Unit-testing a service
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试服务
- en: We've written a service and assume that it fulfills the functional requirements,
    but we do not know it for sure, yet. To check it, we will create a unit-test.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一个服务，并假设它满足了功能要求，但我们还不确定。为了检查它，我们将创建一个单元测试。
- en: We do not have any test environment so far. I would suggest going with the **Jasmine**
    test framework ([https://jasmine.github.io/](https://jasmine.github.io/)). We
    will create in our `tests/unit-tests` subfolder a dedicated NW.js project, which
    will be used for the testing. This way, we get the runtime environment for tests,
    identical to what we have in the application.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有任何测试环境。我建议使用**Jasmine**测试框架（[https://jasmine.github.io/](https://jasmine.github.io/)）。我们将在`tests/unit-tests`子文件夹中创建一个专用的NW.js项目，用于测试。这样，我们就可以获得与应用程序中相同的测试运行环境。
- en: 'So we create the test project manifest:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建测试项目清单：
- en: '`./tests/unit-tests/package.json`'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`./tests/unit-tests/package.json`'
- en: '[PRE90]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: It points at the Jasmine test runner page, the one we placed next to `package.json:`
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 它指向Jasmine测试运行器页面，就是我们放在`package.json`旁边的那个：
- en: '`./tests/unit-tests/specs.html`'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`./tests/unit-tests/specs.html`'
- en: '[PRE91]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: What does this runner do? It loads Jasmine, and with help of the `fs-jetpack`
    npm module ([https://www.npmjs.com/package/fs-jetpack](https://www.npmjs.com/package/fs-jetpack)),
    it traverses the source directory recursively for all the files matching `"*.spec.js"`
    pattern. All these files get added to the test suite. Thus, it assumes that we
    keep our test specifications next to the target source modules.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这个跑步者做什么？它加载Jasmine，并借助`fs-jetpack` npm模块（[https://www.npmjs.com/package/fs-jetpack](https://www.npmjs.com/package/fs-jetpack)）递归遍历源目录，查找所有与`"*.spec.js"`模式匹配的文件。所有这些文件都被添加到测试套件中。因此，它假设我们将测试规范保存在目标源模块旁边。
- en: '`fs-jetpack` is an external module, and we need to install the package and
    add it to the development dependencies list:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs-jetpack`是一个外部模块，我们需要安装该包并将其添加到开发依赖列表中：'
- en: '[PRE92]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Jasmine implements a wide-spread, frontend development testing paradigm **Behavior-driven
    Development** (**BDD**) that can be described with the following pattern:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine实现了一个广泛使用的前端开发测试范式**行为驱动开发**（**BDD**），可以用以下模式描述：
- en: '[PRE93]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'As it is generally accepted in unit testing, a suite may have setup and teardown:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 正如单元测试中通常接受的那样，一个套件可能有设置和拆卸：
- en: '[PRE94]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'When testing a service that touches the filesystem or communicates across the
    network or talks to databases, we have to be careful. A good unit test is independent
    from the environment. So, to test our `DirService`, we have to mock the filesystem.
    Let''s test the `getFileList` method of the service class to see it in action:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试涉及到触及文件系统、跨网络通信或与数据库交互的服务时，我们必须小心。一个好的单元测试是独立于环境的。因此，为了测试我们的`DirService`，我们必须模拟文件系统。让我们测试服务类的`getFileList`方法，看看它的作用：
- en: '`./js/Service/Dir.spec.js`'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Service/Dir.spec.js`'
- en: '[PRE95]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Before running a test, we point the `fs` method to a virtual filesystem with
    the folder `/foo/bar/` that contains the `baz` and `qux` files. After every test,
    we restore access to the original filesystem. In the first test, we instantiate
    the service on the `foo/bar` location and read the content with the `getFileList()`
    method. We assert the number of found files as `2` (as we defined in `beforeEach`).
    In the second test, we take the first element of the list and assert that it contains
    the intended filename and stats.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，我们将`fs`方法指向包含`baz`和`qux`文件的`/foo/bar/`虚拟文件系统。每次测试后，我们都会恢复对原始文件系统的访问。在第一个测试中，我们在`foo/bar`位置实例化服务，并使用`getFileList()`方法读取内容。我们断言找到的文件数量为`2`（正如我们在`beforeEach`中定义的）。在第二个测试中，我们取列表的第一个元素，并断言它包含预期的文件名和状态。
- en: 'As we use an external npm package ([https://www.npmjs.com/package/mock-fs](https://www.npmjs.com/package/mock-fs))
    for mocking, we need to install it:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了外部的npm包（[https://www.npmjs.com/package/mock-fs](https://www.npmjs.com/package/mock-fs)）进行模拟，我们需要安装它：
- en: '[PRE96]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'As we came up with the first test suite, we can modify our project manifest
    file for a proper test runner script. The `./package.json` file contains the following
    code:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想出第一个测试套件时，我们可以修改项目清单文件以获得适当的测试运行程序脚本。`./package.json`文件包含以下代码：
- en: '[PRE97]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, we can run the tests:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行测试：
- en: '[PRE98]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'NW.js will load and render the following screen:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: NW.js将加载并呈现以下屏幕：
- en: '![](img/379b57ff-9df5-41cb-ba06-0ee2106eb355.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/379b57ff-9df5-41cb-ba06-0ee2106eb355.png)'
- en: 'Ideally, unit tests cover all the available functions/methods in the context.
    I believe that from the preceding code you will get an idea of how to write the
    tests. However, you may stumble over testing the `EventEmitter` interface; consider
    this example:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，单元测试覆盖上下文中所有可用的函数/方法。我相信从前面的代码中，你会对如何编写测试有所了解。但是，你可能会在测试`EventEmitter`接口时遇到困难；考虑这个例子：
- en: '[PRE99]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '`EventEmitter` works asynchronously. When we have asynchronous calls in the
    test body, we shall explicitly inform Jasmin when the test is ready so that the
    framework could proceed to the next one. That happens when we invoke the callback
    passed to its function. In the preceding sample, we subscribe the `"update"` event
    on the service and call `notify` to make it fire the event. As soon as the event
    is captured, we invoke the `done` callback.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`工作是异步的。当测试体中有异步调用时，我们必须明确告知Jasmin测试何时准备好，以便框架可以继续进行下一个测试。当我们调用传递给其函数的回调时，就会发生这种情况。在前面的示例中，我们订阅了服务上的`"update"`事件，并调用`notify`来触发事件。一旦捕获到事件，我们就调用`done`回调。'
- en: Writing view modules
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写视图模块
- en: 'Well, we have the service, so we can implement the view modules consuming it.
    However, first we have to mark the bounding boxes for the view in the HTML:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们有了服务，所以我们可以实现使用它的视图模块。但是，首先我们必须在HTML中标记视图的边界框：
- en: '`./index.html`'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`./index.html`'
- en: '[PRE100]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The DirList module
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DirList模块
- en: 'What are our requirements for the `DirList` view? It renders the list of directories
    in the current path. When a user selects a directory from the list, it changes
    the current path. Subsequently, it updates the list to match the content of the
    new location:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`DirList`视图，我们的要求是什么？它会呈现当前路径中的目录列表。当用户从列表中选择一个目录时，它会更改当前路径。随后，它会更新列表以匹配新位置的内容：
- en: '`./js/View/DirList.js`'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/DirList.js`'
- en: '[PRE101]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In the class constructor, we subscribe for the `DirService` `"update"` event.
    So, the view gets updated every time the event fired. Method update performs view
    update. It populates the bounding box with list items built of data received from
    `DirService` . As it is done, it calls the `bindUi` method to subscribe the `openDir`
    handler for click events on newly created items. As you may know, `Element.querySelectorAll`
    returns not an array, but a non-live `NodeList` collection. It can be iterated
    in a `for..of` loop, but I prefer the `forEach` array method. That is why I convert
    the `NodeList` collection into an array.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在类构造函数中，我们订阅了`DirService`的`"update"`事件。因此，每次事件触发时视图都会更新。`update`方法执行视图更新。它用从`DirService`接收到的数据构建的列表项填充边界框。完成后，它调用`bindUi`方法来订阅`openDir`处理程序，以便在新创建的项目上进行单击事件。正如你所知，`Element.querySelectorAll`返回的不是数组，而是非实时的`NodeList`集合。它可以在`for..of`循环中迭代，但我更喜欢`forEach`数组方法。这就是为什么我将`NodeList`集合转换为数组的原因。
- en: The `onOpenDir` handler method extracts target directory name from the `data-file`
    attribute and passes it to `DirList` in order to change the current path.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`onOpenDir`处理程序方法从`data-file`属性中提取目标目录名称，并将其传递给`DirList`以更改当前路径。'
- en: 'Now, we have new modules, so we need to initialize them in `app.js`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了新的模块，所以我们需要在`app.js`中初始化它们：
- en: '`./js/app.js`'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/app.js`'
- en: '[PRE102]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Here, we require new acting classes, create an instance of service, and pass
    it to the `DirListView` constructor together with a view bounding box element.
    At the end of the script, we call `dirService.notify()` to make all available
    views update for the current path.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要新的操作类，创建服务的实例，并将其与视图边界框元素一起传递给`DirListView`构造函数。在脚本的末尾，我们调用`dirService.notify()`来使所有可用的视图更新为当前路径。
- en: 'Now, we can run the application and observe as the directory list updates as
    we navigate through the filesystem:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行应用程序，并观察随着我们在文件系统中导航，目录列表如何更新：
- en: '[PRE103]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Unit-testing a view module
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试视图模块
- en: 'Seemingly, we are expected to write unit test, not just for services, but for
    other modules as well. When testing a view we have to check whether it renders
    correctly in response to specified events:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，我们期望编写单元测试，不仅仅是针对服务，还包括其他模块。在测试视图时，我们必须检查它是否对指定的事件做出了正确的响应：
- en: '`./js/View/DirList.spec.js`'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/DirList.spec.js`'
- en: '[PRE104]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If you might remember in the test runner HTML, we had a hidden `div` element
    with `sandbox` for id. Before every test, we populate that element with the HTML
    fragment the view expects. So, we can point the view to the bounding box with
    the sandbox.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得测试运行器HTML中，我们有一个带有`sandbox`id的隐藏`div`元素。在每个测试之前，我们用视图期望的HTML片段填充该元素。因此，我们可以将视图指向带有sandbox的边界框。
- en: After creating a view instance, we can call its methods, supplying them with
    an arbitrary input data (here, a collection to update from). At the end of a test,
    we assert whether the method produced the intended elements within the sandbox.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视图实例后，我们可以调用其方法，并向其提供任意输入数据（这里是要更新的集合）。在测试结束时，我们断言该方法是否在沙盒内生成了预期的元素。
- en: In the preceding test for simplicity's sake, I injected a fixture array straight
    to the update method of the view. In general, it would be better to stub `getDirList`
    of `DirService` using the **Sinon** library ([http://sinonjs.org/](http://sinonjs.org/)).
    So, we could also test the view behavior by calling the notify method of `DirService`--the
    same as it happens in the application.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，为了简单起见，我直接向视图的更新方法注入了一个固定的数组。一般来说，最好使用**Sinon**库（[http://sinonjs.org/](http://sinonjs.org/)）来存根`DirService`的`getDirList`。这样，我们也可以通过调用`DirService`的`notify`方法来测试视图的行为--就像在应用程序中发生的那样。
- en: The FileList module
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件列表模块
- en: 'The module handling the file list works pretty similar to the one we have just
    examined previously:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件列表的模块与我们刚刚审查的模块非常相似：
- en: '`./js/View/FileList.js`'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/FileList.js`'
- en: '[PRE105]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In the preceding code, in the constructor, we again subscribed the `"update"`
    event, and when it was captured, we run the update method on a collection received
    from the `getFileList` method of `DirService`. It renders the file table header
    first and then the rows with file information. The passed-in collection contains
    raw file sizes and modification times. So, we format these in a human-readable
    form. File size gets beautified with an external module--`filesize` ([https://www.npmjs.com/package/filesize](https://www.npmjs.com/package/filesize))--and
    the timestamp we shape up with the `formatTime` static method.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在构造函数中，我们再次订阅了`"update"`事件，当捕获到该事件时，我们会对从`DirService`的`getFileList`方法接收到的集合运行更新方法。它首先渲染文件表头，然后是包含文件信息的行。传入的集合包含原始文件大小和修改时间。因此，我们以人类可读的形式格式化这些内容。文件大小通过外部模块`filesize`（[https://www.npmjs.com/package/filesize](https://www.npmjs.com/package/filesize)）进行美化处理，时间戳则通过`formatTime`静态方法进行整理。
- en: 'Certainly, we shall load and initialize the newly created module in the main
    script:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该在主脚本中加载和初始化新创建的模块：
- en: '`./js/app.js`'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/app.js`'
- en: '[PRE106]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The title bar path module
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题栏路径模块
- en: 'So we have a directory and file lists responding to the navigation event, but
    the current path in the title bar is still not affected. To fix it, we will make
    a small view class:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个对导航事件做出响应的目录和文件列表，但是标题栏中的当前路径仍然没有受到影响。为了解决这个问题，我们将创建一个小的视图类：
- en: '`./js/View/TitleBarPathView.js`'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/TitleBarPathView.js`'
- en: '[PRE107]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: You can note that the class simply subscribes for an update event and modifies
    the current path accordingly to `DirService`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以注意到，该类简单地订阅了更新事件，并根据`DirService`相应地修改了当前路径。
- en: 'To get it live, we will add the following lines to the main script:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其生效，我们将在主脚本中添加以下行：
- en: '`./js/app.js`'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/app.js`'
- en: '[PRE108]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Summary
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So we've made it to the milestone and have now a working version of the File
    Explorer providing basic functionality. What have we achieved so far?
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经实现了一个工作版本的文件资源管理器，提供了基本功能。到目前为止，我们取得了什么成就？
- en: 'We went together though the traditional development routine: we planned, sketched,
    set up, templated, styled, and programmed. On the way, we discussed the best practices
    of writing maintainable and conflict-free CSS. We have discovered that NW.js enables
    the features of the latest CSS and JavaScript specifications. So while refactoring
    our CSS code, we exploited new aspects, such as custom properties and position
    sticky. We also had a tour of the basics of ES2015, which helped us to build our
    JavaScript modules in a cleaner syntax using classes, arrow functions, destructuring,
    and block scope declarations.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一起经历了传统的开发流程：我们规划、草拟、设置、模板化、样式化和编程。在这个过程中，我们讨论了编写可维护和无冲突的CSS的最佳实践。我们发现NW.js可以实现最新CSS和JavaScript规范的功能。因此，在重构我们的CSS代码时，我们利用了新的方面，比如自定义属性和粘性定位。我们还对ES2015的基础知识进行了介绍，这有助于我们使用类、箭头函数、解构和块作用域声明来以更清晰的语法构建我们的JavaScript模块。
- en: What is more, we explored a few of the goodies normally unavailable in the browser,
    such as Node.js core and external modules, and the desktop environment integration
    API. Thus, we were able to access the filesystem and implement windowing actions
    (close, minimize, maximize, and restore). We made a service extending Node.js
    EventEmitter and incorporated the event-based architecture to serve our needs.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们探索了一些在浏览器中通常无法使用的好东西，比如Node.js核心和外部模块，以及桌面环境集成API。因此，我们能够访问文件系统并实现窗口操作（关闭、最小化、最大化和恢复）。我们创建了一个扩展了Node.js
    EventEmitter的服务，并将基于事件的架构整合到我们的需求中。
- en: We didn't forget about unit-testing. We set up Jasmine testing runner and discussed
    the essentials of BDD specifications. While writing the application unit tests,
    we examined an approach to mock the filesystem and one to test **Document Object
    Model** (**DOM**) manipulations.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有忘记单元测试。我们设置了Jasmine测试运行器，并讨论了BDD规范的基本要点。在编写应用程序单元测试时，我们研究了模拟文件系统的方法以及测试**文档对象模型**（**DOM**）操作的方法。
- en: Evidently, there's still much left for the second chapter, where we will augment
    the existing functionality, dive deeper into NW.js API, and go through the preproduction
    steps. Yet, I hope that you have already accrued a grasp on NW.js and HTML5 desktop
    development basics. See? It doesn't differ much from traditional web development
    after all, just unlocks new exciting possibilities.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，第二章还有很多内容，我们将增强现有功能，深入了解NW.js API，并进行预生产步骤。但是，我希望您已经对NW.js和HTML5桌面开发基础有所了解。看到了吗？它毕竟与传统的Web开发并没有太大的区别，只是解锁了新的令人兴奋的可能性。
