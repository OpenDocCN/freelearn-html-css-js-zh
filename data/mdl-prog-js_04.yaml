- en: Chapter 4. Designing Simple Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 设计简单模块
- en: In this chapter, we are going to focus on applying the concepts that we have
    learned in the previous chapters to design some simple modules for our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于将我们在前几章中学到的概念应用到设计一些简单的模块中。
- en: We will start by analyzing our application's functionality as a whole and then
    we will break it down into smaller functional pieces. Once we have decided on
    our application's functional pieces, we will start creating simple modules to
    implement the required functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先分析应用的整体功能，然后将其分解成更小的功能组件。一旦我们决定了应用的功能组件，我们就会开始创建简单的模块来实现所需的功能。
- en: This chapter is meant to demonstrate the possible steps in the beginning of
    our application's life cycle, based on our requirements. The goal is to see how
    using modules can help us design a better architecture and get a feel for the
    practical advantages of a modular design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在展示基于我们需求的应用生命周期初期的可能步骤。目标是了解使用模块如何帮助我们设计更好的架构，并感受模块化设计的实际优势。
- en: The simple modules that we create in this chapter will provide the foundation
    for our final application in this book, which will be a working client-side single
    page application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中创建的简单模块将为本书中最终的应用提供基础，该应用将是一个工作的客户端单页应用。
- en: 'In this chapter we will cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖：
- en: Reflecting the overall application requirements in our design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的设计中反映整体应用需求
- en: Designing the application's main pieces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计应用的主要部分
- en: Creating specialized modules for our application's main pieces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用的主要部分创建专用模块
- en: Collaboration among modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块间的协作
- en: Using object definitions to describe page fragments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象定义来描述页面片段
- en: Dynamically generating pages and page fragments
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态生成页面和页面片段
- en: The big picture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大局观
- en: Before we start any coding at all, we need to have a good understanding of what
    our application is all about, what the requirements are, and what possible functional
    pieces are needed to satisfy our requirements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始任何编码之前，我们需要对应用的整体情况有一个很好的理解，包括需求是什么，以及需要哪些可能的功能组件来满足这些需求。
- en: While in the beginning of an application's design phase, we try to answer as
    many questions as possible regarding our application's requirements, we should
    always try not to get too tied down by the details.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用设计的初期阶段，我们试图尽可能多地回答关于我们应用需求的问题，但我们始终应该努力不要被细节所束缚。
- en: The idea is to get the big picture right, understand what it is that we want
    to deliver, the timelines involved, and the resources available. Based on such
    analyses, we can start creating a scalable, flexible, and extensible architectural
    design for our application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是确保大局正确，理解我们想要交付的内容，涉及的时间表以及可用的资源。基于这样的分析，我们可以开始为我们的应用创建一个可扩展、灵活和可扩展的架构设计。
- en: I'd like to draw your attention to a very important word that I used here, **extensible**.
    The ability of an application to be easily extended is very important in a proper
    design. Keep in mind that no matter how much we try to finalize all of the requirements
    for an application ahead of time, we won't be able to foresee them all in the
    beginning.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提醒大家一个我在这里使用的重要词汇，**可扩展性**。应用能够轻松扩展的能力在适当的设计中非常重要。请记住，无论我们多么努力提前确定应用的所有需求，我们都不可能在开始时就预见所有这些需求。
- en: Requirements change over time, new requirements are added, and old requirements
    get modified or even removed altogether from the final draft of the application.
    The key is to design our application in a way that can accommodate all such changes
    without a big impact on the overall architecture. This is where the advantages
    of a modular architecture shine and help to mitigate the adverse effects that
    such changes might have on the application as a whole.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需求会随时间变化，新的需求会被添加，旧的需求会被修改，甚至可能完全从应用的最终草案中删除。关键是要以能够适应所有这些变化而不对整体架构产生重大影响的方式来设计我们的应用。这正是模块化架构的优势所在，有助于减轻这种变化对整个应用可能产生的负面影响。
- en: As we keep these points in mind, let's talk about the application that we are
    going to build together in this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在牢记这些要点的同时，让我们来谈谈本书中我们将一起构建的应用。
- en: Our application requirements
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的应用需求
- en: Our application is a simple yet fully functional image gallery application.
    The goal is to present the users with a catalog of beautiful images on our site.
    Our site visitors can click each of the images to see a full view of the image
    and add the images to their favorite list of images, if they wish to do so.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序是一个简单但功能齐全的图片库应用程序。目标是向用户展示我们网站上美丽的图片目录。我们的网站访客可以点击每张图片以查看图片的全景，如果他们愿意，还可以将这些图片添加到他们的收藏夹中。
- en: The application will have a header, a navigation bar at the top, a main content
    area in the middle, a footer, and of course a logo.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将有一个页眉，顶部的导航栏，中间的主要内容区域，页脚，当然还有标志。
- en: As you can tell, there are not many complicated pieces at play here, but I assure
    you that under the hood there are many modules that can be easily ported from
    this application to many other more complex applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里没有多少复杂的部分，但我向你保证，在底层有许多模块可以轻松地从本应用程序移植到许多其他更复杂的应用程序中。
- en: Let's start by creating an overall layout (wireframe) of our application and
    see what the big picture looks like.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个应用程序的整体布局（线框图），看看整体情况是什么样的。
- en: '![Our application requirements](img/B04910_04_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![我们的应用程序需求](img/B04910_04_01.jpg)'
- en: I have identified the main pieces of our index page in this mock-up. We are
    going to create modules to build and update this page, its related pieces, and
    the rest of the application for us.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在这个样图中确定了我们的索引页的主要部分。我们将创建模块来构建和更新这个页面，以及与之相关的其他部分和整个应用程序。
- en: Dynamic views
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态视图
- en: I mentioned that our JavaScript modules are going to build this page for us,
    and I need to explain this a little further.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到我们的JavaScript模块将为我们构建这个页面，我需要进一步解释这一点。
- en: While we are going to create modules to take care of the functional pieces of
    the application, we are going to take that a step further. We are also going to
    create modules that will specialize in building our pages (views) dynamically
    on the client side.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建模块来处理应用程序的功能部分时，我们将更进一步。我们还将创建专门在客户端动态构建我们页面（视图）的模块。
- en: In this design, we only receive the skeleton of the page from the server. The
    page will be populated by our view-generating modules based on the object definitions
    for each page section (fragment) that is sent to the client.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，我们只从服务器接收页面的大纲。页面将通过我们的视图生成模块根据发送到客户端的每个页面部分（片段）的对象定义来填充。
- en: The overall architecture of our application is based on **Single Page Application**
    (**SPA**) design concepts. If you are not familiar with this term, the idea is
    that as we navigate through our application pages (views), we won't need to load
    or build the parts of the page that don't change from one view to the next. We
    simply update the changed pieces of the view dynamically on the client while keeping
    the rest of the view untouched.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的整体架构基于**单页应用程序（SPA**）设计概念。如果你对这个术语不熟悉，其想法是，当我们浏览我们的应用程序页面（视图）时，我们不需要加载或构建从一个视图到下一个视图不改变的部分。我们只需在客户端动态更新视图的更改部分，同时保持其余视图不变。
- en: Since we only do targeted changes in our application's view, the rendering of
    our views will be more robust and optimized.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在应用程序的视图中只进行有针对性的更改，因此我们视图的渲染将更加健壮和优化。
- en: This also means that after the application's initial load, the client will only
    be requesting the changed parts of the application from the server. Therefore,
    we will only be transferring the page fragments over the bandwidth as opposed
    to the full page. Generally speaking, this can be a great advantage when we design
    applications that need to operate in limited bandwidth scenarios, such as mobile
    applications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着在应用程序的初始加载之后，客户端将只从服务器请求应用程序更改的部分。因此，我们只会在带宽上传输页面片段，而不是整个页面。一般来说，当我们设计需要在有限带宽场景下运行的应用程序时，例如移动应用程序，这可以是一个很大的优势。
- en: For our application in this book, our page fragments are transferred as object
    definitions to the client side and our view-generating specialized modules will
    render the required views based on such object definitions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的我们的应用程序，我们的页面片段作为对象定义传输到客户端，我们的视图生成专用模块将根据这样的对象定义渲染所需的视图。
- en: You will see how we can achieve this in the near future as we move forward.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到，随着我们继续前进，我们如何在不久的将来实现这一点。
- en: Designing our SPA main pieces
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的SPA主要部分
- en: Usually when designing SPA applications, I create a core application code base
    which is loaded in the browser at the application's initial load phase. This code
    base provides application-level functionality that is independent of the application's
    views. The application core consists of many modules that are loaded together.
    If you are familiar with **Model-View-Controller** (**MVC**) or **Model-View-Wildcard**
    (**MV***) application design patterns, this core is essentially the controller
    of the application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在设计 SPA 应用程序时，我会创建一个核心应用程序代码库，在应用程序的初始加载阶段加载到浏览器中。这个代码库提供了与应用程序视图无关的应用程序级功能。应用程序核心由许多一起加载的模块组成。如果你熟悉
    **模型-视图-控制器**（**MVC**）或 **模型-视图-通配符**（**MV***）应用程序设计模式，这个核心本质上就是应用程序的控制器。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**MVC and MV* design patterns**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVC 和 MV* 设计模式**'
- en: These design patterns create a good degree of specialization and separation
    of concerns in the code. Understanding these patterns is important in creating
    a good application architecture. While I will be referring to these patterns from
    time to time, covering them in depth is beyond the scope of this book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计模式在代码中创造了很好的专业化和关注点的分离。理解这些模式对于创建良好的应用程序架构非常重要。虽然我会在适当的时候提到这些模式，但深入探讨这些模式超出了本书的范围。
- en: 'I recommend the following resources for more information:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐以下资源以获取更多信息：
- en: '[https://www.packtpub.com/application-development/mastering-javascript-design-patterns/](https://www.packtpub.com/application-development/mastering-javascript-design-patterns/)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/mastering-javascript-design-patterns/](https://www.packtpub.com/application-development/mastering-javascript-design-patterns/)'
- en: '[https://addyosmani.com/blog/understanding-mvc-and-mvp-for-javascript-and-backbone-developers/](https://addyosmani.com/blog/understanding-mvc-and-mvp-for-javascript-and-backbone-developers/)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://addyosmani.com/blog/understanding-mvc-and-mvp-for-javascript-and-backbone-developers/](https://addyosmani.com/blog/understanding-mvc-and-mvp-for-javascript-and-backbone-developers/)'
- en: The model and views of the application also have their own specialized modules,
    some of which are loaded at the initial application load time and some as needed,
    dynamically, at a later time. This type of approach enables the application to
    have a small footprint in the browser and load only what it needs, as needed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的模式和视图也有它们自己的专用模块，其中一些在应用程序初始加载时加载，而另一些则在需要时动态加载。这种方法使得应用程序在浏览器中具有较小的占用空间，并且只加载所需的资源。
- en: I also usually try to have every page of my application as a separate module
    (component) both on the server and the client side. This provides the capability
    to create, modify, or remove pages (components) and their related code without
    affecting other pieces of the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常还会尝试让我的应用程序的每一页在服务器端和客户端都是一个独立的模块（组件）。这提供了创建、修改或删除页面（组件）及其相关代码的能力，而不会影响应用程序的其他部分。
- en: Note that I'm using the term "module" here as a general term and it does not
    necessarily mean modules that are built using the module pattern. My intent is
    to convey the idea that each page is a separate piece in the application, within
    which one or many JavaScript modules can be used to do the work related to that
    page and that page only. If you are not sure exactly what this means, rest assured
    it will all become more clear to you shortly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在这里使用“模块”这个词是一个通用术语，并不一定意味着使用模块模式构建的模块。我的意图是传达每个页面是应用程序中一个独立部分的观念，在这个部分中，可以使用一个或多个
    JavaScript 模块来完成与该页面相关的工作。如果你不确定这究竟意味着什么，请放心，这很快就会变得清晰。
- en: 'The following figure depicts the main pieces of our application for this book,
    categorized by their special functionality and design:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了本书中应用程序的主要组件，按其特殊功能和设计进行了分类：
- en: '![Designing our SPA main pieces](img/B04910_04_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们的 SPA 主要组件](img/B04910_04_02.jpg)'
- en: 'As the figure shows, our overall design is based on three main pieces: **Controller**,
    **View**, and **Model**. In the rest of this chapter, we will talk about each
    piece and will start building them based on our modular architecture.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们的整体设计基于三个主要部分：**控制器**、**视图**和**模型**。在本章的剩余部分，我们将讨论每个部分，并基于我们的模块化架构开始构建它们。
- en: Application controller
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序控制器
- en: The controller is the piece that contains the main functionality of the application.
    Essentially, the controller module is the brain of the application. It will consist
    of application-level modules that provide application-level functionality. This
    piece will also be responsible for initializing all the other modules and components
    in the application as well as gluing them together using a loose coupling approach.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是包含应用主要功能的部件。本质上，控制器模块是应用的“大脑”。它将包括提供应用级功能的应用级模块。这个部件还将负责初始化应用中的所有其他模块和组件，并使用松耦合方法将它们粘合在一起。
- en: Application controller modules
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用控制器模块
- en: Considering the role of the controller in our application as mentioned, we are
    going to design this piece based on specialized modules. These modules together
    create what we will be referring to as the **core** module.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，考虑到我们在应用中控制器的作用，我们将基于专用模块来设计这个部件。这些模块共同构成了我们将称之为**核心**模块的内容。
- en: Keep in mind that since we are using specialized modules for our core, each
    module can easily be modified or replaced without affecting the other parts of
    the application, that is, with the exception of the functionality that is related
    to that module and that module only.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于我们正在使用针对核心的专用模块，每个模块都可以轻松修改或替换，而不会影响应用的其他部分，即除了与该模块相关的功能之外，不会影响其他模块。
- en: Of course, we can also add more modules to the core, if we decide that additional
    functionality is needed at some point in the future.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们决定在未来的某个时刻需要额外的功能，我们也可以向核心添加更多模块。
- en: It is the collective functionality of the controller modules that provides the
    core functionality of the application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器模块的集体功能提供了应用的核心功能。
- en: 'Based on our application''s requirements, I anticipate that we will be needing
    the following modules in our application''s controller:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们应用的需求，我预计我们将在应用控制器中需要以下模块：
- en: Page updater module
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面更新模块
- en: Storage handler module
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储处理模块
- en: Communication handler module
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信处理模块
- en: Utilities module
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具模块
- en: Message handler module
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息处理模块
- en: Logging handler module
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录处理模块
- en: Keep in mind that we are making our best guess as to what modules are required.
    The list can change over time as we proceed further in our implementation. The
    idea is to design and implement the modules that we think we will be needing at
    this time, to have a starting baseline. However, the list of the modules, their
    functionality as well as the names that we choose for them can change over time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们正在尽我们最大的努力猜测所需的模块。随着我们进一步实施，这个列表可能会随着时间的推移而变化。我们的想法是设计和实现我们认为我们现在需要的模块，以有一个起始基线。然而，模块列表、它们的函数以及我们为它们选择的名称可能会随着时间的推移而变化。
- en: Let's start by exploring what the functionality of each module in our application's
    core will be.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来探讨一下我们应用核心中每个模块的功能。
- en: Page updater module
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 页面更新模块
- en: This module is responsible for building HTML pieces in our application. It does
    this task by injecting a string passed to it into a container. This string corresponds
    to the HTML elements that need to be rendered into the predefined container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块负责构建应用中的HTML片段。它通过将传递给它的字符串注入到一个容器中来完成这项任务。这个字符串对应于需要渲染到预定义容器中的HTML元素。
- en: We will be building various pieces of our application pages and updating them
    dynamically as required, using this module.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个模块构建我们应用页面的各个部分，并根据需要动态更新它们。
- en: Storage handler module
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储处理模块
- en: This module has the specific responsibility of storing application-related data.
    This data can be either stored in cookies or in other storage facilities provided
    by the browser, such as HTML 5 local storage.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块有特定的责任，即存储与应用相关的数据。这些数据可以存储在cookies中，或者存储在浏览器提供的其他存储设施中，例如HTML 5本地存储。
- en: Communication handler module
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通信处理模块
- en: All application-related communication is done through this module. This module
    is mainly designed to use AJAX calls to communicate with the back-end server.
    However, the method of communication that this module uses might not be limited
    to AJAX calls at some point in the future.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与应用相关的通信都通过这个模块完成。这个模块主要设计用来使用AJAX调用与后端服务器通信。然而，这个模块使用的通信方法可能在未来的某个时刻不会仅限于AJAX调用。
- en: Utilities module
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工具模块
- en: This module is responsible for providing utility type functionality to the application.
    For instance, it can do string manipulation, object cloning, or page resize calculations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块负责为应用程序提供实用类型的功能。例如，它可以进行字符串操作、对象克隆或页面尺寸计算。
- en: Message handler module
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消息处理模块
- en: As events take place in the application, we need a way to communicate such events
    with the users and display messages on the application's pages. This module specializes
    in this task.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序中事件的发生，我们需要一种方式与用户沟通这些事件，并在应用程序的页面上显示消息。此模块专门负责这项任务。
- en: Logging handler module
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 日志处理模块
- en: This module provides all the functionality related to the logging mechanism
    of the application. The logging can take place on the client side, the server
    side, or both.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块提供与应用程序日志机制相关的所有功能。日志可以在客户端、服务器端或两者同时进行。
- en: Creating our first core module
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个核心模块
- en: Now that we have put together the list of possible required modules for the
    core, let's create the first module of our application's controller, the `PageUpdater`
    module. This module should be designed in such a way that it can dynamically update
    a fragment of the page. This fragment can be as small as a text on the page, or
    as large as the entire displayed page itself. The update to the page fragment
    can be as trivial as changing the font size or the background color or as complex
    as completely re-structuring and re-rendering of the page fragment altogether.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理出了核心所需的可能模块列表，让我们创建应用程序控制器的第一个模块，即 `PageUpdater` 模块。此模块应设计为能够动态更新页面的一部分。这部分可以小到页面上的文本，也可以大到整个显示的页面。对页面片段的更新可以是微不足道的，如更改字体大小或背景颜色，也可以是复杂的，如完全重构和重新渲染页面片段。
- en: Structure of our first module
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们第一个模块的结构
- en: 'Consider the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code implements a simple module which enables us to do an update
    on a page fragment. Let's examine the code and see how it is structured.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实现了一个简单的模块，使我们能够对页面片段进行更新。让我们检查一下代码，看看它是如何组织的。
- en: We have defined a JavaScript module, using the module pattern. An IIFE is used
    to execute the code in our anonymous function, which creates a namespace. What
    gets returned from this function is an object that is assigned to our global variable
    `PageUpdater`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模块模式定义了一个 JavaScript 模块。IIFE 用于执行匿名函数中的代码，创建一个命名空间。从这个函数返回的是分配给我们的全局变量 `PageUpdater`
    的对象。
- en: In our IIFE, we have defined `insertHTMLTxt` and `applyElementCSS` method properties,
    using function expressions. These two methods are kept within the internal private
    scope of our main container function, and as such no external code can access
    them. Thus, we are protecting them from accidental and unintended modifications.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的立即执行函数表达式（IIFE）中，我们使用函数表达式定义了 `insertHTMLTxt` 和 `applyElementCSS` 方法属性。这两个方法被保留在我们主要容器函数的内部私有作用域中，因此外部代码无法访问它们。因此，我们保护它们免受意外和不希望的修改。
- en: We do provide controlled and indirect access to these methods through the module's
    interface, which is the anonymous object that is returned when our container function
    is executed. A reference to this returned object (our module's interface) is assigned
    to the `PageUpdater` variable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实通过模块的接口提供了对这些方法的受控和间接访问，该接口是容器函数执行时返回的匿名对象。对这个返回对象的引用（我们的模块接口）被分配给 `PageUpdater`
    变量。
- en: 'So in fact what is really referenced in this variable (`PageUpdater`) is the
    following object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际上这个变量（`PageUpdater`）真正引用的是以下对象：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As this is just a normal JavaScript object, we can call its methods from the
    external code as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个普通的 JavaScript 对象，我们可以从外部代码调用其方法，如下所示：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `updateElement` method of the `PageUpdater` object in turn calls `insertHTMLTxt(elemID,htmlTxt)`,
    which is the method inside our container function that does the real work behind
    the scene.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageUpdater` 对象的 `updateElement` 方法依次调用 `insertHTMLTxt(elemID,htmlTxt)`，这是在我们容器函数内部执行实际幕后工作的方法。'
- en: 'This method receives two parameters: the id of the container element (`containerID`),
    which we intend to update its contents, and a string (`newStructure`), which is
    the string representation of the HTML elements that will be rendered inside this
    container element.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收两个参数：容器元素的 id (`containerID`), 我们打算更新其内容，以及一个字符串 (`newStructure`), 它是将在容器元素内部渲染的
    HTML 元素的字符串表示。
- en: 'If you are wondering how `PageUpdater` object can call the method inside of
    our container function and how the link is established between the two, you need
    to think of one word: closure!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道`PageUpdater`对象如何调用容器函数内部的方法以及两者之间是如何建立链接的，你需要想到一个词：闭包！
- en: We did talk about closures in [Chapter 2](ch02.html "Chapter 2. Review of Important
    JavaScript OOP Concepts"), *Review of Important JavaScript OOP Concepts*. If you
    recall, because the anonymous object returned from our IIFE was defined inside
    the container function, it has access to the internal private scope of our container
    function. This means `PageUpdater` has access to all the private variables and
    methods defined inside of that scope. That is why the methods that are returned
    as part of the interface from the module are called, **privileged methods**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第2章[重要JavaScript OOP概念的回顾](ch02.html "第2章. 重要JavaScript OOP概念的回顾")中讨论了闭包。如果你还记得，由于我们的IIFE返回的匿名对象是在容器函数内部定义的，它能够访问容器函数的内部私有作用域。这意味着`PageUpdater`能够访问在该作用域内部定义的所有私有变量和方法。这就是为什么从模块返回作为接口部分的那些方法被称为，**特权方法**。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Having problems understanding the module pattern?**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**对模块模式理解有困难？**'
- en: I took some time here to explain our first simple module in depth. Moving forward,
    I will not be explaining the pattern used in creating our modules (module pattern)
    in as much detail. It is important for you to have a good understanding of this
    pattern, as our other modules in the application follow a similar structure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里花了一些时间深入解释我们的第一个简单模块。从现在开始，我将不会像之前那样详细解释创建我们模块（模块模式）所使用的模式。了解这个模式非常重要，因为应用中的其他模块都遵循类似的架构。
- en: For a better understanding of the module pattern, I recommend doing two things.
    First, review [Chapter 2](ch02.html "Chapter 2. Review of Important JavaScript
    OOP Concepts"), *Review of Important JavaScript OOP Concepts* and [Chapter 3](ch03.html
    "Chapter 3. Module Design Pattern"), *Module Design Pattern* again. Second, spend
    some time analyzing the previous code and read my explanations a couple more times.
    I'm sure you will get a good grasp of this pattern very soon.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解模块模式，我建议做两件事。首先，复习[第2章](ch02.html "第2章. 重要JavaScript OOP概念的回顾")，*重要JavaScript
    OOP概念的回顾*和[第3章](ch03.html "第3章. 模块设计模式")，*模块设计模式*。其次，花些时间分析之前的代码，并再次阅读我的解释。我相信你很快就能很好地掌握这个模式。
- en: Note that the `PageUpdater` module is currently capable of doing two things.
    It can update the `innerHTML` of a container element as well as being able to
    update the **CSS** class of an element on the page.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`PageUpdater`模块目前能够执行两项功能。它可以更新容器元素的`innerHTML`，同时也能够更新页面中元素的**CSS**类。
- en: Using our first module's functionality
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用我们的第一个模块的功能
- en: 'The following is an example of how we can leverage the module''s functionality
    by making calls to its methods:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们通过调用其方法利用模块功能的一个示例：
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line of the preceding code populates the footer section of our application,
    based on a predefined object definition, which we will talk about a little later
    in this chapter. The second line of code changes the CSS class of the footer container
    to apply a different background color to this page fragment. The code accompanying
    this chapter has the CSS class definition for this operation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的第一行根据预定义的对象定义填充了我们的应用页脚部分，我们将在本章稍后讨论这一点。第二行代码更改了页脚容器的CSS类，以应用不同的背景颜色到这个页面片段。本章的代码中包含了该操作的CSS类定义。
- en: As you can see, we let the module take care of the mechanics of how page fragments
    are updated, and all we have to do is to make simple calls to it through the interface
    that has been provided for this module.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们让模块负责页面片段更新的机制，而我们只需要通过为这个模块提供的接口进行简单的调用。
- en: Mapping our module's methods to its interface
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将我们的模块方法映射到其接口
- en: There is one important point that we need to note regarding our module's interface,
    which can easily be missed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们模块的接口，有一个重要的点需要我们注意，这个点很容易被忽略。
- en: If you recall, in [Chapter 3](ch03.html "Chapter 3. Module Design Pattern"),
    *Module Design Pattern*, I mentioned that a module is free to implement how it
    accomplishes its tasks and this implementation can change over time. However,
    a module should keep its interface consistent to the outside world. Of course,
    this is because the interface of a module is the module's contact and that's how
    the other pieces of the application can interact with it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，在 [第 3 章](ch03.html "第 3 章。模块设计模式") 中提到的 *模块设计模式*，我提到模块可以自由实现其完成任务的方式，并且这种实现可以随时间变化。然而，模块应该保持其对外部世界的接口一致性。当然，这是因为模块的接口是模块的接触点，其他应用程序组件正是通过这个接口与之交互。
- en: 'Notice how we have defined the following interface for our `PageUpdater` module:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们为我们的 `PageUpdater` 模块定义了以下接口：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, to the outside world, when a CSS class needs to be applied to
    an element, the `updateElementClass` method should be called on the module. This
    module in turn calls a method with a different name in the module's definition,
    which is `applyElementCSS`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于外部世界来说，当需要将 CSS 类应用到元素上时，应在模块上调用 `updateElementClass` 方法。这个模块随后会在模块的定义中调用一个不同名称的方法，即
    `applyElementCSS`。
- en: This type of mapping allows us to change the name of the internal method of
    the module without affecting the module's interface for the external code. The
    mapping provides a layer of abstraction between the module's internals and its
    public interface.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射类型允许我们更改模块内部方法的名称，而不会影响外部代码对模块接口的影响。映射在模块的内部和公共接口之间提供了一个抽象层。
- en: Our module is currently a simple module that does relatively simple things for
    our application, but it does not have to be limited to what we have defined here.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的模块是一个简单的模块，为我们的应用程序执行相对简单的事情，但它不必局限于我们在这里定义的内容。
- en: As we move along in this book, we will be augmenting this module (and others)
    to do more things. Nonetheless, we should always keep in mind that this module
    is specialized to only do tasks that are related to updating of our application
    pages and nothing beyond that. After all, one of the main ideas behind modular
    design is that each module only does one type of work and nothing more so we can
    stay true to the concept of separation of responsibilities and concerns.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，我们将增强这个模块（以及其他模块）以执行更多任务。尽管如此，我们应始终牢记，这个模块是专门用于执行与更新我们应用程序页面相关的任务，而不涉及其他任何事情。毕竟，模块化设计背后的一个主要思想是每个模块只做一种类型的工作，这样我们才能坚持职责分离的概念。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Running the accompanying application''s code**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行伴随应用程序的代码**'
- en: You'll be able to run the application's code by loading the `index.html` page
    in the browser using any IDE that has a built in web server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在浏览器中使用任何内置了网络服务器的 IDE 加载 `index.html` 页面来运行应用程序的代码。
- en: Please have a look at the code that accompanies this chapter and use this module
    to update different fragments of the page as you wish. All the modules discussed
    in this chapter can be found in the `js`/`Modules.js` file in the accompanying
    code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看本章的伴随代码中的代码，并使用此模块根据您的意愿更新页面上的不同片段。本章中讨论的所有模块都可以在伴随代码的 `js`/`Modules.js`
    文件中找到。
- en: Application view
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序视图
- en: Another main piece of our application is the **view** piece. As the name implies,
    this piece deals with the view of all the pages and page fragments of the application.
    The view is what the user actually sees in the browser.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的另一个主要部分是 **视图** 部分。正如其名所示，这部分处理应用程序所有页面和页面片段的视图。视图是用户在浏览器中实际看到的。
- en: Since our application is based on a MV* type architecture (in conjunction with
    modular architecture), our views interact with the controller as well as the model
    pieces.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序基于 MV* 类型架构（结合模块化架构），我们的视图与控制器以及模型组件进行交互。
- en: However, the way we will build our application's views is a little different
    than traditional MV* applications. Our application views will be designed as modules
    and because these modules specialize in creating views, we will be calling them
    **components**. This is to make the distinction between modules that have views
    and those that only provide functionality but have no direct relations to our
    application's views.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将构建应用程序视图的方式与传统 MV* 应用程序略有不同。我们的应用程序视图将被设计为模块，因为这些模块专门用于创建视图，我们将称它们为 **组件**。这是为了区分具有视图的模块和那些只提供功能但没有直接关系到我们应用程序视图的模块。
- en: One other thing to keep in mind about components is that they can implement
    their own MV* architecture. This type of implementation might not be very clear
    to you at this time, but I assure you that it will all make more sense in the
    following chapters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于组件，还有一点需要记住的是，它们可以实现自己的MV*架构。这种实现方式可能你现在还不清楚，但我向你保证，在接下来的章节中一切都会更加清晰。
- en: In this section, we will only focus on how `index.html` is built and how it
    is populated using a few object definitions and the controller methods that we
    saw in the previous section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将只关注如何构建`index.html`以及它是如何使用一些对象定义和我们在上一节中看到的控制器方法来填充的。
- en: To create our `index.html` page, we will start by building a skeleton for this
    page and then we will dynamically modify this skeleton to produce its main fragments.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的`index.html`页面，我们首先将构建这个页面的骨架，然后我们将动态修改这个骨架以生成其主要片段。
- en: Creating the index.html page skeleton
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建index.html页面骨架
- en: The page skeleton of our application is designed to be as minimalist as possible
    at this stage.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的页面骨架在这个阶段被设计得尽可能简约。
- en: 'Have a look at the page structure as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下页面结构：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we render this HTML markup in the browser, we will have the following
    skeleton of our `index.html` page displayed:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中渲染这个HTML标记时，我们将在浏览器中看到我们的`index.html`页面的以下骨架：
- en: '![Creating the index.html page skeleton](img/B04910_04_03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![创建index.html页面骨架](img/B04910_04_03.jpg)'
- en: 'Notice that we have created three main containers: `headerContainer` (the top
    section of the page), `mainPageContainer` (the middle section of the page), and
    `footerContainer` (the bottom section of the page), which are the three main fragments
    of the page.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经创建了三个主要容器：`headerContainer`（页面的顶部部分）、`mainPageContainer`（页面的中间部分）和`footerContainer`（页面的底部部分），它们是页面的三个主要片段。
- en: We will be populating each one of these page fragments with the HTML elements
    that we need.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用我们需要的HTML元素填充这些页面片段中的每一个。
- en: Creating an object definition for the header
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为头部创建对象定义
- en: If you recall, I mentioned that we will be using object definitions to define
    our page fragments in the application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我提到我们将使用对象定义来定义我们应用程序中的页面片段。
- en: As these object definitions are very similar to each other, we will only examine
    one of them in this section , which is related to the header fragment of the page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些对象定义彼此非常相似，我们将在本节中只检查其中一个，它与页面的头部片段相关。
- en: 'Here is the object definition for the header section:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是头部部分的对象定义：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have defined an object literal which at this time only contains
    one property, `sectionHTML`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们定义了一个对象字面量，目前它只包含一个属性，`sectionHTML`。
- en: This property holds a string that is the string representation of the HTML elements
    for the header fragment of the page.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性包含一个字符串，它是页面头部片段的HTML元素的字符串表示。
- en: Keep in mind that, as implemented, we currently have a global variable called
    `headerContainerDef` for our object definition. As you know, we should try to
    avoid using global variables in our code. We will be fixing this issue soon, but
    at this time it is done so on purpose.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，按照目前的实现，我们有一个名为`headerContainerDef`的全局变量用于我们的对象定义。正如你所知，我们应该尽量避免在我们的代码中使用全局变量。我们将很快解决这个问题，但到目前为止，这是故意为之的。
- en: Now that we have created our first object definition, it is time to create the
    first view of our application for the Header fragment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了第一个对象定义，是时候为头部片段创建我们应用程序的第一个视图了。
- en: Generating the Header fragment dynamically
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态生成头部片段
- en: As you saw previously, our application's controller has a module that specializes
    in generating page fragments on the page and it is called `PageUpdater`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前看到的，我们应用程序的控制器有一个专门用于在页面上生成页面片段的模块，它被称为`PageUpdater`。
- en: 'Consider the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we have used our application's `PageUpdater` module and have
    passed the id of the Header fragment as the first parameter to its `updateElement`
    method. The second parameter to this method is the object definition for the Header
    fragment. This implementation allows us to leverage the functionality of our application's
    controller to render the Header fragment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了我们应用程序的`PageUpdater`模块，并将头部片段的id作为第一个参数传递给它的`updateElement`方法。这个方法的第二个参数是头部片段的对象定义。这种实现方式允许我们利用我们应用程序控制器的功能来渲染头部片段。
- en: 'Of course, we can use the same approach to create other parts (fragments) of
    our page, such as the footer, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用相同的方法来创建页面的其他部分（片段），例如页脚，如下所示：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following screenshot shows how the `index.html` page for our application
    is displayed when the page fragments have been rendered on the page:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当页面片段在页面上渲染后，我们应用的`index.html`页面是如何显示的：
- en: '![Generating the Header fragment dynamically](img/B04910_04_04.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![动态生成标题片段](img/B04910_04_04.jpg)'
- en: The main content area of the page (colored red in the middle of the page), is
    the area that will be updated as the user navigates through the pages in our application.
    The header and footer of the page will not be re-rendered for any of the application's
    pages, as our application is built on SPA principles.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的主要内容区域（页面中间用红色标出），是用户在我们应用中浏览页面时将更新的区域。页面的页眉和页脚不会为应用中的任何页面重新渲染，因为我们的应用是基于SPA原则构建的。
- en: As you can see, I have used some interesting background colors to depict each
    fragment of the page. I like to call this color-coding of the page fragments.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我使用了一些有趣的背景颜色来描绘页面的每个片段。我喜欢称这种页面片段的颜色编码为。
- en: The reason for this coloring schema is to easily distinguish each specific region
    of the page in our visual design. When we are finished with our application implementation,
    this page will look a lot better, but for now, this is a good starting point.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种着色方案的原因是为了在我们的视觉设计中轻松区分页面的每个特定区域。当我们完成应用实现后，这个页面看起来会好很多，但就目前而言，这是一个很好的起点。
- en: Of course, if you are reading this book in a black and white medium, you only
    see light and dark shades in the preceding image.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你是在黑白介质中阅读这本书，你只能看到前图中明暗的阴影。
- en: Generating client application's view dynamically
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态生成客户端应用的视图
- en: One of the techniques that I use in my applications is what I call **Dynamic
    Page Generation** (**DPG**).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的应用中使用的一种技术，我称之为**动态页面生成**（**DPG**）。
- en: 'The idea is that each main fragment of the page is associated with an object
    definition, and in this object definition the characteristics of the page fragment
    are defined. For instance, in our design for this application, I have considered
    three distinct fragments on the page: the header fragment, the content fragment,
    and the footer fragment.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是每个页面主要片段都与一个对象定义相关联，在这个对象定义中定义了页面片段的特性。例如，在我们这个应用的设计中，我考虑了页面上的三个不同片段：标题片段、内容片段和页脚片段。
- en: Each main fragment, in turn, could further be divided into sub-fragments and
    each sub-fragment may or may not have its own distinct object definition.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主要片段反过来又可以进一步细分为子片段，每个子片段可能或可能没有自己的独立对象定义。
- en: On the other hand, we could have only one object definition for the entire page,
    which would be used to dynamically generate the page as a whole.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可能只需要一个对象定义来覆盖整个页面，这个定义将用于动态生成整个页面。
- en: Generally speaking, the decision on how to associate an object definition to
    a page fragment or a sub-fragment is in the hands of the user interface developer.
    The developer makes these decisions by considering factors such as the frequency
    at which a fragment or sub-fragment needs to be updated, or whether a page fragment
    needs to be updated independently of other fragments of the page. Of course, performance
    also plays a major role in such decisions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，如何将对象定义关联到页面片段或子片段的决定权在用户界面开发者手中。开发者通过考虑诸如片段或子片段需要更新的频率，或者页面片段是否需要独立于页面其他片段进行更新等因素来做出这些决定。当然，性能也在这些决定中扮演着重要角色。
- en: There are also instances when building certain page fragments on the server
    side is more robust than building them on the client.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 也有时候，在服务器端构建某些页面片段比在客户端构建更稳健。
- en: In our application, we are building all the page fragments on the client dynamically.
    This is so we can explore the full functionality of our modules and components
    on the client side.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们正在客户端动态构建所有页面片段。这样做是为了我们可以探索客户端模块和组件的完整功能。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The look and feel of our application**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们应用的外观和感觉**'
- en: Please note that the aim of this application is to help you understand the concepts
    of modular design as it relates to JavaScript applications, and as such the focus
    has not been on the look and feel.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个应用的目标是帮助你理解与JavaScript应用相关的模块化设计概念，因此重点不在于外观和感觉。
- en: While we will improve the appearance of the application as we move forward,
    I'm sure you can improve its appearance quite a bit further on your own. Our application
    is somewhat responsive based on the browser's view-port but can certainly use
    more CSS polishing to make it fully responsive.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在前进的过程中改进应用程序的外观，但我相信你可以在自己的基础上进一步改进。我们的应用程序在一定程度上基于浏览器的视口进行响应，但确实需要更多的
    CSS 精炼来使其完全响应。
- en: However, I do consider this application as a **Minimum Viable Product** (**MVP**)
    for our purposes. Please feel free to download the code from the site that accompanies
    this book and improve it as you desire. Also, I have only tested this application
    in Chrome 46.0, but a production-quality application needs to be tested in a variety
    of different browser types and versions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我确实认为这个应用程序对于我们的目的来说是一个**最小可行产品**（MVP）。请随意从本书配套网站上下载代码，并根据您的需求进行改进。此外，我仅在
    Chrome 46.0 中测试了此应用程序，但一个生产级的应用程序需要在各种不同类型的浏览器和版本中进行测试。
- en: Application model
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序模型
- en: The last main piece of our MV* implantation is the model. The main role of this
    piece is to store application-level data. In a client application, such data can
    be stored in cache, in cookies, or in local or session storage.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 MV* 实现的最后一部分是模型。这个部分的主要作用是存储应用程序级数据。在客户端应用程序中，此类数据可以存储在缓存中、在 cookies 中或在本地或会话存储中。
- en: In the main application for this book, we will be using most of such mechanisms
    to store our application's data. Also, as a general point, depending on the implementation
    of the MV* architecture, changes in the model's data can trigger changes in the
    application's view.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的主应用程序中，我们将使用大多数这样的机制来存储我们的应用程序数据。此外，作为一个一般原则，根据 MV* 架构的实现，模型数据的更改可以触发应用程序视图的更改。
- en: It is very important to shield application-level data from accidental overwrites
    and modifications. In our implementation, we are going to use the module pattern
    once again to create a module which will act as our application's model and will
    provide a good level of protection for the stored data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要保护应用程序级数据免受意外覆盖和修改。在我们的实现中，我们将再次使用模块模式来创建一个模块，该模块将充当我们的应用程序模型，并为存储的数据提供良好的保护级别。
- en: Creating a module for our application's model
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的应用程序模型创建模块
- en: 'Consider the following implementation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下实现：
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we have created a `GlobalData` module to keep our application-level
    data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们创建了一个 `GlobalData` 模块来保存我们的应用程序级数据。
- en: 'I''m sure you are pretty familiar with how the mechanism works by now. We have
    created an IIFE to return an object as an interface to our private namespace(module).
    This object provides two methods: `getHeaderHTMLTxt` and `getFooterHTMLTxt`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你现在一定非常熟悉这个机制是如何工作的了。我们创建了一个立即执行函数表达式（IIFE）来返回一个对象，作为我们私有命名空间（模块）的接口。这个对象提供了两个方法：`getHeaderHTMLTxt`
    和 `getFooterHTMLTxt`。
- en: These methods return the property values of two private variables `headerContainerDef`
    and `footerContainerDef` respectively.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法分别返回两个私有变量 `headerContainerDef` 和 `footerContainerDef` 的属性值。
- en: Note that we have not provided any methods to set the values for these variables,
    and since they are private variables in our module, we have created a degree of
    encapsulation. Thus, shielding our data from outside influence.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有提供任何设置这些变量值的方法，并且由于它们是我们模块中的私有变量，我们已经创建了一定程度的封装。因此，保护我们的数据免受外部影响。
- en: The property value of `headerContainerDef` is a string representation of the
    HTML elements in the header fragment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`headerContainerDef` 的属性值是头部片段中 HTML 元素的字符串表示。'
- en: 'This string is used to populate the Header fragment of our application''s view,
    as shown:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串用于填充我们应用程序视图的头部片段，如下所示：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just the same, the property value of `footerContainerDef` is a string representation
    of the HTML elements in the Footer fragment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`footerContainerDef` 的属性值是 Footer 片段中 HTML 元素的字符串表示。
- en: 'This string is used to populate the footer fragment of our application''s view,
    as shown:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串用于填充我们应用程序视图的页脚片段，如下所示：
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that when we rendered our header and footer fragments previously, we used
    global variables (such as `headerContainerDef`) to get the required strings for
    the page fragments.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们之前渲染头部和页脚片段时，我们使用了全局变量（如 `headerContainerDef`）来获取页面片段所需的字符串。
- en: However, in our new implementation, we access these strings using the `GlobalData`
    interface methods.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的新实现中，我们使用 `GlobalData` 接口方法来访问这些字符串。
- en: An important point to keep in mind here is that we have implemented two independent
    modules (`PageUpdater` and `GlobalData`) that work together to create the building
    blocks of our application. We will leverage the collaboration among our application
    modules further as we advance through the next chapters, and will implement the
    full functionality of our application on such basis.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的一个重要观点是我们已经实现了两个独立的模块（`PageUpdater`和`GlobalData`），它们共同工作以构建我们应用程序的构建块。随着我们进入下一章，我们将进一步利用应用程序模块之间的协作，并在此基础上实现我们应用程序的完整功能。
- en: Also, notice that our `GlobalData` module is only tasked with providing data
    to other pieces of the application, and `PageUpdater` is only responsible for
    updating fragments of the page.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们的`GlobalData`模块仅负责向应用程序的其他部分提供数据，而`PageUpdater`仅负责更新页面片段。
- en: Another subtle point to consider is the fact that we can change the internals
    of both modules as we desire. But as long as the interfaces of the modules don't
    change, they can still continue working together without the internal changes
    of one module having any effect on the functionality of the other.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的微妙之处是，我们可以根据需要更改两个模块的内部结构。但是，只要模块的接口不改变，它们仍然可以继续一起工作，而一个模块的内部更改不会对另一个模块的功能产生影响。
- en: Creating a logging module
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个日志模块
- en: As a further exercise, we are going to create one more module in this chapter.
    This module will look after all the necessary work related to logging messages
    for our application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步练习，我们将在本章中创建另一个模块。此模块将负责我们应用程序与日志消息相关的所有必要工作。
- en: The question is, which main application piece does this module belong to?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，这个模块属于哪个主要应用程序部分？
- en: To answer this question, we need to do a simple analysis. First, since this
    module does not have any views associated with it, we need to consider it as a
    functional module and not a component.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，我们需要进行简单的分析。首先，由于此模块没有与之关联的任何视图，我们需要将其视为功能模块而不是组件。
- en: Second, this module does not store any application data for us. Therefore, this
    module should belong to the controller piece of our application. As mentioned
    before, since we consider the controller piece of our application to be the same
    as the core module, the logging module should belong to the core module.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，此模块不会为我们存储任何应用程序数据。因此，此模块应属于我们应用程序的控制器部分。如前所述，由于我们将应用程序的控制器部分视为与核心模块相同，因此日志模块应属于核心模块。
- en: Remember that the core module consists of many smaller modules (sub-modules)
    that build the core together.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，核心模块由许多较小的模块（子模块）组成，这些模块共同构建核心。
- en: 'Let''s create our simple logger module as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式创建我们的简单日志模块：
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This module definition structure is pretty much the same as other module definitions
    that we have seen so far, but with minor differences.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块定义结构与迄今为止我们所看到的其他模块定义几乎相同，但有一些细微差别。
- en: We have used a different technique here and have returned a named object instead
    of an anonymous object from our IIFE. We have named this object `theInterface`.
    Initially, this object is an empty object but then we augment this empty object
    with two method properties. One of them logs information messages and the other
    logs error messages to the console.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了不同的技术，并从IIFE返回了一个命名对象而不是匿名对象。我们把这个对象命名为`theInterface`。最初，这个对象是一个空对象，但后来我们通过添加两个方法属性来增强这个空对象。其中一个记录信息消息，另一个将错误消息记录到控制台。
- en: In the case that no information message is passed to `theInterface.logInfo`
    method, a default message is logged to greet the user.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有信息消息传递给`theInterface.logInfo`方法，则会记录一个默认消息以问候用户。
- en: 'Here is how we call the methods on the interface of this module:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何调用此模块接口上的方法：
- en: '[PRE13]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the same way that we call interface methods when we return an anonymous
    object from a module.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们从模块返回匿名对象时调用接口方法的方式。
- en: I have used this technique of returning a named object from a module here to
    show you we don't always have to return an anonymous object from an IIFE to create
    a module interface, and that there are different ways of implementing the module
    pattern. We will explore these techniques further in future chapters of the book.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了从模块返回命名对象的技术，以向您展示我们不必总是从IIFE返回匿名对象来创建模块接口，并且有不同方式实现模块模式。我们将在本书的后续章节中进一步探讨这些技术。
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Practical usage of our modules**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们模块的实际用途**'
- en: As I like to present the concepts along with their practical aspects, I recommend
    that you download the accompanying code for this chapter. Have a look at the simple
    modules in action, and play around with the code as much as you can. This will
    help you become more familiar with the concepts and solidify them in your mind.
    My recommendation applies to this chapter as well as all the other chapters of
    the book.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我喜欢将概念与其实际方面结合起来进行展示，我建议您下载本章的配套代码。查看这些简单模块的实际运行情况，尽可能多地与代码互动。这将帮助您更加熟悉这些概念，并在您的脑海中巩固它们。我的建议同样适用于本书的所有其他章节。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we moved from the conceptual design of modules to the practical
    aspects of implementing them. We started by looking at the high-level requirements
    of our intended application, and then considered the kind of modules that we might
    possibly need to fulfill those requirements.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论从模块的概念设计转向其实施的实践方面。我们首先审视了我们预期应用的高层次需求，然后考虑了可能需要的模块类型以满足这些需求。
- en: We briefly discussed the MV* design pattern and structured our application to
    follow this pattern. Then, based on the functionality and the role that our modules
    play in our design, we categorized them to be part of the controller, view or
    model pieces of our application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了MV*设计模式，并结构化我们的应用以遵循此模式。然后，基于我们的模块在设计中扮演的功能和角色，我们将它们分类为控制器、视图或模型组件的一部分。
- en: The view for our application was generated by first creating an `index.html`
    page skeleton and then populating its main fragments based on object definitions,
    using a core module.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的前端视图是通过首先创建一个`index.html`页面骨架，然后基于对象定义填充其主要片段，使用核心模块生成的。
- en: We also created a safe global data repository for our application to act as
    the model piece of our architecture.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为我们的应用创建了一个安全的全局数据存储库，作为我们架构中的模型组件。
- en: An example of how modules can collaborate together to complete tasks and provide
    application level functionality was also presented.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 还展示了模块如何协作以完成任务并提供应用级功能的一个示例。
- en: In the next chapter we will extend our application modules and work further
    on the building blocks of our application in a modular design approach.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展我们的应用模块，并采用模块化设计方法进一步构建我们应用的基础组件。
