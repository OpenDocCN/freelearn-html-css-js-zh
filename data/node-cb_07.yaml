- en: Chapter 7. Implementing Security, Encryption, and Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。实施安全性、加密和身份验证
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Implementing Basic Authentication
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施基本身份验证
- en: Cryptographic password hashing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码加密哈希
- en: Implementing Digest Authentication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施摘要身份验证
- en: Setting up an HTTPS web server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置HTTPS Web服务器
- en: Preventing cross-site request forgery
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止跨站点请求伪造
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: When it comes to production web servers, security is paramount. The importance
    of security correlates with the importance of the data or services we provide.
    But even for the smallest projects, we want to ensure our systems aren't vulnerable
    to attack.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产Web服务器方面，安全性是至关重要的。安全性的重要性与我们提供的数据或服务的重要性相关。但即使对于最小的项目，我们也希望确保我们的系统不容易受到攻击。
- en: Many web development frameworks provide built-in security, which is a two-sided
    coin. On one side, we don't have to overly concern ourselves with the details
    (except for the basics, like cleaning user input before passing it into an SQL
    statement), but on the other we implicitly trust that the vendor has plugged all
    the holes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web开发框架提供了内置的安全性，这是一个双刃剑。一方面，我们不必过分关注细节（除了基本的事情，比如在将用户输入传递到SQL语句之前清理用户输入），但另一方面，我们隐含地相信供应商已经堵住了所有的漏洞。
- en: If a largely used server-side scripting platform, such as PHP, is discovered
    to contain a security vulnerability, this can become public knowledge very quickly
    and every site running the vulnerable version of that framework is open to attack.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现一个广泛使用的服务器端脚本平台，比如PHP，包含安全漏洞，这可能会很快成为公开的知识，运行易受攻击版本的框架的每个站点都会面临攻击。
- en: With Node, server-side security is almost entirely on our shoulders. Therefore,
    all we need to do is educate ourselves on the potential vulnerabilities and harden
    our systems and code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Node来说，服务器端的安全性几乎完全取决于我们自己。因此，我们只需要教育自己关于潜在的漏洞，并加固我们的系统和代码。
- en: 'For the most part, Node is minimalistic: if we don''t specifically outline
    something it doesn''t happen. This leaves little room for exploitation of unknown
    parts of our system or obscure configuration settings because we coded and configured
    our system by hand.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Node是最简约的：如果我们没有明确地概述某些事情，它就不会发生。这使得我们的系统或模糊的配置设置的未知部分很难被利用，因为我们是通过手工编码和配置我们的系统。
- en: 'Attacks take place from two angles: exploiting technical flaws and taking advantage
    of user naiveté. We can protect our systems by educating ourselves and conscientiously
    checking and rechecking our code. We can also protect our users by educating them.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击发生在两个方面：利用技术缺陷和利用用户的天真。我们可以通过教育自己并认真检查和反复检查我们的代码来保护我们的系统。我们也可以通过教育用户来保护我们的用户。
- en: In this chapter, we will learn how to implement various types of user-authenticated
    logins, how to secure these logins, and encrypt any transferred data, along with
    a technique for preventing authenticated users from falling victim to exploits
    of the browser's security model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何实施各种类型的用户身份验证登录，如何保护这些登录，并加密任何传输的数据，以及一种防止经过身份验证的用户成为浏览器安全模型漏洞的受害者的技术。
- en: Implementing Basic Authentication
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施基本身份验证
- en: The Basic Authentication standard has been in place since the 1990s and can
    be the simplest way to provide a user login. When used over HTTP, it is in no
    way secure since a plain text password is sent over the connection from browser
    to server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证标准自上世纪90年代以来一直存在，并且可以是提供用户登录的最简单方式。当在HTTP上使用时，它绝对不安全，因为明文密码会从浏览器发送到服务器的连接中。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For information on Basic Authentication see [http://en.wikipedia.org/wiki/Basic_authentication](http://en.wikipedia.org/wiki/Basic_authentication).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关基本身份验证的信息，请参见[http://en.wikipedia.org/wiki/Basic_authentication](http://en.wikipedia.org/wiki/Basic_authentication)。
- en: However, when coupled with SSL (HTTPS), Basic Authentication can be a useful
    method if we're not concerned about a custom-styled login form.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当与SSL（HTTPS）结合使用时，基本身份验证可以是一种有用的方法，如果我们不关心自定义样式的登录表单。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We discuss SSL/TLS (HTTPS) in the *Setting up an HTTPS web server* recipe of
    this chapter. For extra information see [http://en.wikipedia.org/wiki/SSL/TLS](http://en.wikipedia.org/wiki/SSL/TLS).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的*设置HTTPS Web服务器*配方中讨论SSL/TLS（HTTPS）。有关更多信息，请参见[http://en.wikipedia.org/wiki/SSL/TLS](http://en.wikipedia.org/wiki/SSL/TLS)。
- en: In this recipe, we'll learn how to initiate and process a Basic Access Authentication
    request over plain HTTP. In following recipes, we'll implement an HTTPS server,
    and see an advancement of Basic Authentication (Digest Authentication).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何在纯HTTP上启动和处理基本访问身份验证请求。在接下来的配方中，我们将实施一个HTTPS服务器，并看到基本身份验证（摘要身份验证）的进展。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We just need to create a new `server.js` file in a new a folder.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在一个新的文件夹中创建一个新的`server.js`文件。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Basic Authentication specifies a username, password, and realm, and it works
    over HTTP. So we''ll require the HTTP module, and set up some variables:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证指定用户名、密码和领域，并且它在HTTP上工作。因此，我们将需要HTTP模块，并设置一些变量：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we''ll set up our HTTP server:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设置我们的HTTP服务器：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice we make two calls to a function named `authenticate`. We need to create
    this function, placing it above our `createServer` call:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对名为`authenticate`的函数进行了两次调用。我们需要创建这个函数，并将其放在我们的`createServer`调用之上：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we navigate to `localhost:8080` in our browser we are asked to provide
    a username and password for the `Node Cookbook` realm. If we provide the correct
    details, our passion for soft cheese is revealed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中导航到`localhost:8080`时，我们被要求为`Node Cookbook`领域提供用户名和密码。如果我们提供了正确的详细信息，我们对软奶酪的热情就会显露出来。
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Basic Authentication works via a series of headers sent between server and browser.
    When a browser hits the server, the `WWW-Authenticate` header is sent to the browser
    and the browser responds by opening a dialog for the user to login.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证通过服务器和浏览器之间发送的一系列标头进行工作。当浏览器访问服务器时，`WWW-Authenticate`标头被发送到浏览器，浏览器会打开一个对话框让用户登录。
- en: The browser's login dialog blocks any further content from being loaded in the
    browser until the user either cancels or attempts to log in. If the user presses
    the **Cancel** button, they see the **Authorization required** message sent with
    `res.end` in the `authenticate` function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的登录对话框会阻止加载其他内容，直到用户取消或尝试登录。如果用户按下**取消**按钮，他们会看到`authenticate`函数中使用`res.end`发送的**需要授权**消息。
- en: 'However, if the user attempts to log in, the browser sends another request
    to the server. This time it contains an `Authorization` header in response to
    the `WWW-Authenticate` header. We check for its existence at the top of the `createServer`
    callback with `req.headers.authorization`. If the header exists, we skip the call
    to `authenticate` and go on to verify the user credentials. The `Authorization`
    header looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果用户尝试登录，浏览器会向服务器发送另一个请求。这次响应`WWW-Authenticate`头部包含一个`Authorization`头部。我们在`createServer`回调的顶部检查它是否存在，使用`req.headers.authorization`。如果头部存在，我们跳过对`authenticate`的调用，继续验证用户凭据。`Authorization`头部如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The text following `Basic` is a Base64-encoded string that holds the username
    and password separated by a colon, so the decoded Base64 text is:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Basic`后面的文本是一个Base64编码的字符串，其中包含用冒号分隔的用户名和密码，因此解码后的Base64文本是：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our `createServer` callback, we decode the Base64 header by first stripping
    the `Basic` portion from it, load it into a buffer which converts Base64 to binary,
    then run `toString` on the result converting it to a UTF8 string.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`createServer`回调中，我们首先从中剥离`Basic`部分，然后将其加载到一个将Base64转换为二进制的缓冲区中，然后对结果运行`toString`，将其转换为UTF8字符串。
- en: See [http://en.wikipedia.org/wiki/Base64](http://en.wikipedia.org/wiki/Base64)
    and [http://en.wikipedia.org/wiki/Comparison_of_Unicode_encodings](http://en.wikipedia.org/wiki/Comparison_of_Unicode_encodings)
    for information on Base64 and string encodings like UTF-8.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Base64和UTF-8等字符串编码的信息，请参阅[http://en.wikipedia.org/wiki/Base64](http://en.wikipedia.org/wiki/Base64)和[http://en.wikipedia.org/wiki/Comparison_of_Unicode_encodings](http://en.wikipedia.org/wiki/Comparison_of_Unicode_encodings)。
- en: Finally, we `split` the login details with a colon, and if the provided username
    and password match our stored credentials, the user is granted access to authorized
    content.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用冒号`split`登录详细信息，如果提供的用户名和密码与我们存储的凭据匹配，用户将获得对授权内容的访问权限。
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Basic Authentication comes bundled with the Express framework as middleware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证作为中间件捆绑在Express框架中。
- en: Basic Authentication with Express
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Express进行基本身份验证
- en: 'Express (via Connect) provides the `basicAuth` middleware, which implements
    this pattern for us. To implement the same in Express:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Express（通过Connect）提供了`basicAuth`中间件，它为我们实现了这种模式。要在Express中实现相同的功能：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we now head to `http://localhost:8080`, our Express server will behave in
    the same way as our main recipe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在转到`http://localhost:8080`，我们的Express服务器将与我们的主要示例表现出相同的行为。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: See[Chapter 6](ch06.html "Chapter 6. Accelerating Development with Express"),
    *Accelerating Development with Express*, for information on using Express to develop
    web solutions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用Express开发Web解决方案的信息，请参阅[第6章](ch06.html "第6章。使用Express加速开发")*使用Express加速开发*。
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Setting up a router* discussed In [Chapter 1](ch01.html "Chapter 1. Making
    a Web Server"),Making a Web Server'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第1章](ch01.html "第1章。制作Web服务器")中讨论了*设置路由*，制作Web服务器'
- en: '*Implementing Digest Authentication* discussed in this chapter'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了*实现摘要身份验证*。
- en: '*Setting up an HTTPS web server* discussed in this chapter'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了*设置HTTPS Web服务器*
- en: Cryptographic password hashing
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码加密哈希
- en: Effective encryption is a fundamental part of online security. Node provides
    the `crypto` module which we can use to generate our own MD5 or SHA1 hashes for
    user passwords. Cryptographic hashes, such as MD5 and SHA1 are known as message
    digests. Once the input data has been digested (encrypted), it cannot be put back
    into its original form (of course if we know the original password, we can regenerate
    the hash and compare it to our stored hash).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的加密是在线安全的基本部分。Node提供了`crypto`模块，我们可以使用它来为用户密码生成我们自己的MD5或SHA1哈希。诸如MD5和SHA1之类的加密哈希被称为消息摘要。一旦输入数据被摘要（加密），它就不能被放回其原始形式（当然，如果我们知道原始密码，我们可以重新生成哈希并将其与我们存储的哈希进行比较）。
- en: We can use hashes to encrypt a user's password before we store them. If our
    stored passwords were ever stolen by an attacker, they couldn't be used to log
    in because the attacker would not have the actual plain text passwords. However,
    since a hash algorithm always produces the same result, it could be possible for
    an attacker to crack a hash by matching it against hashes generated from a password
    dictionary (see the *There's more ..*. section for ways to mitigate this).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用哈希来加密用户的密码，然后再存储它们。如果我们存储的密码被攻击者窃取，他们无法用来登录，因为攻击者没有实际的明文密码。然而，由于哈希算法总是产生相同的结果，攻击者可能通过将其与从密码字典生成的哈希进行匹配来破解哈希（有关缓解此问题的方法，请参见*还有更多...*部分）。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See [http://en.wikipedia.org/wiki/Cryptographic_hash_function](http://en.wikipedia.org/wiki/Cryptographic_hash_function)
    for more information on hashes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有关哈希的更多信息，请参阅[http://en.wikipedia.org/wiki/Cryptographic_hash_function](http://en.wikipedia.org/wiki/Cryptographic_hash_function)。
- en: In this example, we will create a simple registration form, and use the `crypto`
    module to generate an MD5 hash of a password gained via user input.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个简单的注册表单，并使用`crypto`模块来生成通过用户输入获得的密码的MD5哈希。
- en: As with Basic Authentication, our registration form should be posted over HTTPS,
    otherwise the password is sent as plain text.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与基本身份验证一样，我们的注册表单应该通过HTTPS发布，否则密码将以明文形式发送。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In a new folder, let's create a new `server.js` file along with an HTML file
    for our registration form. We'll call it `regform.html`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的文件夹中，让我们创建一个新的`server.js`文件，以及一个用于注册表单的HTML文件。我们将称其为`regform.html`。
- en: We'll use the Express framework to provide the peripheral mechanisms (parsing
    POST requests, serving `regform.html`, and so on), so Express should be installed.
    We covered more about Express and how to install it in the previous chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Express框架来提供外围机制（解析POST请求，提供`regform.html`等），因此应该安装Express。我们在上一章中更详细地介绍了Express以及如何安装它。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, let''s put together our registration form (`regform.html`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们组合我们的注册表单（`regform.html`）：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For `server.js`, we''ll require `express` and `crypto`. Then create our server
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`server.js`，我们将需要`express`和`crypto`。然后创建我们的服务器如下：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`bodyParser` gives us POST capabilities and our `userStore` object is for storing
    registered user details. In production we would use a database.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`bodyParser`给了我们POST的能力，我们的`userStore`对象用于存储注册用户的详细信息。在生产中，我们会使用数据库。'
- en: 'Now to set up a GET route as shown in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置一个GET路由，如下所示的代码：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This uses Express' `sendfile` method to stream our `regform.html` file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用Express的`sendfile`方法来流式传输我们的`regform.html`文件。
- en: Finally, our POST route will check for the existence of `user` and `pass` inputs,
    turning a user's specified password into an MD5 hash.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的POST路由将检查`user`和`pass`输入的存在，将用户指定的密码转换为MD5哈希值。
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we use our form to register, the console will output the `userStore` object,
    containing all registered user names and password hashes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用我们的表单进行注册时，控制台将输出`userStore`对象，其中包含所有注册的用户名和密码哈希。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The password hashing portion of this recipe is:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的密码哈希部分是：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've used the dot notation to chain some `crypto` methods together.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用点符号将一些`crypto`方法链接在一起。
- en: First, we create a vanilla MD5 hash with `createHash` (see the *There's more
    ..*. section on how to create unique hashes). We could alternatively create a
    (stronger) SHA1 hash by passing `sha1` as the argument. The same goes for any
    other encryption method supported by Node's bundled `openssl` version (0.9.8r
    as of Node 0.6.17).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`createHash`创建一个普通的MD5哈希（请参阅*还有更多...*部分，了解如何创建唯一的哈希）。我们也可以通过传递`sha1`作为参数来创建（更强大的）SHA1哈希。对于Node捆绑的`openssl`版本（截至Node
    0.6.17为止）支持的任何其他加密方法也是一样的。
- en: For a comparison of different hash functions, see [http://ehash.iaik.tugraz.at/wiki/The_Hash_Function_Zoo](http://ehash.iaik.tugraz.at/wiki/The_Hash_Function_Zoo).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有关不同哈希函数的比较，请参见[http://ehash.iaik.tugraz.at/wiki/The_Hash_Function_Zoo](http://ehash.iaik.tugraz.at/wiki/The_Hash_Function_Zoo)。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This site labels certain hash functions as broken, which means a weakness point
    has been found and published. However, the effort required to exploit such a weakness
    will often far exceed the value of the data we are protecting.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站将某些哈希函数标记为破解，这意味着已经发现并发布了一个弱点。然而，利用这种弱点所需的工作量通常远远超过我们正在保护的数据的价值。
- en: Then we call `update` to feed our user's password to the initial hash.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`update`来将用户的密码传递给初始哈希。
- en: Finally, we call the `digest` method, which returns a completed password hash.
    Without any arguments, digest returns the hash in binary format. We pass `hex`
    (base 16 numerical representation format of binary data, see [http://en.wikipedia.org/wiki/Hexadecimal)](http://en.wikipedia.org/wiki/Hexadecimal))
    to make it more readable on the console.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`digest`方法，它返回一个完成的密码哈希。没有任何参数，`digest`会以二进制格式返回哈希值。我们传递`hex`（二进制数据的十六进制表示格式，参见[http://en.wikipedia.org/wiki/Hexadecimal)](http://en.wikipedia.org/wiki/Hexadecimal)）以使其在控制台上更易读。
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `crypto` module offers some more advanced hashing methods for creating even
    stronger passwords.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`crypto`模块提供了一些更高级的哈希方法，用于创建更强大的密码。'
- en: Uniquifying hashes with HMAC
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用HMAC使哈希值唯一化
- en: '**HMAC** stands for **Hash-based Message Authentication Code**. This is a hash
    with a secret key (authentication code).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**HMAC**代表**基于哈希的消息认证码**。这是一个带有秘密密钥的哈希（认证码）。'
- en: 'To convert our recipe to using HMAC, we change our `crypto` portion to:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的配方转换为使用HMAC，我们将我们的`crypto`部分更改为：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using HMAC protects us from the use of rainbow tables (pre-computed hashes from
    a large list of probable passwords). The secret key mutates our hash, rendering
    a rainbow table impotent (unless an attacker discovers our secret key, for instance,
    by somehow gaining root access to our server's operating system, at which point
    rainbow tables wouldn't be necessary anyway).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HMAC可以保护我们免受彩虹表（从大量可能的密码列表中预先计算的哈希）的影响。秘密密钥会改变我们的哈希值，使得彩虹表无效（除非攻击者发现我们的秘密密钥，例如，通过某种方式获得了对我们服务器操作系统的根访问权限，在这种情况下，彩虹表将不再是必要的）。
- en: Hardened hashing with PBKDF2
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PBKDF2进行加固的哈希值
- en: '**PBKDF2** is the second version of Password-Based Key Derivation Function,
    which is part of the Password-Based Cryptographic standard.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**PBKDF2**是基于密码的密钥派生函数的第二个版本，它是基于密码的加密标准的一部分。'
- en: A powerful quality of PBKDF2 is that it generates hashes of hashes, thousands
    of times over. Iterating over the hash multiple times strengthens the encryption,
    exponentially increasing the amount of possible outcomes resulting from an initial
    value to the extent that the hardware required to generate or store all possible
    hashes becomes infeasible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: PBKDF2的一个强大特性是它生成数千次的哈希值。多次迭代哈希值可以增强加密，指数级增加了可能结果的数量，使得生成或存储所有可能的哈希值所需的硬件变得不可行。
- en: '`pbkdf2` requires four components: the desired password, a salt value, the
    desired amount of iterations, and a specified length of the resulting hash.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`pbkdf2`需要四个组件：所需的密码，盐值，所需的迭代次数和生成哈希值的指定长度。'
- en: A salt is similar in concept to the secret key in our HMAC in that it mixes
    in with our hash to create a different hash. However, the purpose of a salt differs.
    A salt simply adds a uniqueness to the hash and it doesn't need to be protected
    as a secret. A strong approach is to make each salt unique to the hash being generated,
    storing it alongside the hash. If each hash in a database is generated from a
    different salt, an attacker is forced to generate a rainbow table for each hash
    based on its salt rather than the entire database. With PBKDF2, thanks to our
    salt, we have unique hashes of unique hashes which adds even more complexity for
    a potential attacker.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 盐在概念上类似于HMAC中的秘密密钥，因为它与我们的哈希混合在一起，创建了一个不同的哈希。然而，盐的目的不同。盐只是为哈希添加了独特性，并不需要像秘密一样受到保护。一个强大的方法是使每个盐对生成的哈希是唯一的，并将其存储在哈希旁边。如果数据库中的每个哈希都是从不同的盐生成的，攻击者就被迫为每个哈希基于其盐生成一个彩虹表，而不是整个数据库。有了PBKDF2，由于我们的盐，我们有了唯一哈希的唯一哈希，这为潜在攻击者增加了更多的复杂性。
- en: For a strong salt, we'll use the `randomBytes` method of `crypto` to generate
    128 bytes of random data, which we will then pass through the `pbkdf2` method
    with the user-supplied password 7,000 times, finally creating a hash 256 bytes
    in length.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于强盐，我们将使用`crypto`的`randomBytes`方法生成128字节的随机数据，然后通过`pbkdf2`方法将其与用户提供的密码迭代7,000次，最终创建一个256字节长的哈希。
- en: To achieve this, let's modify our POST route from the recipe.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，让我们修改配方中的POST路由。
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`randomBytes` and `pbkdf2` are asynchronous, which is helpful because it allows
    us to perform other tasks or improve the user experience by immediately taking
    them to a new page while their credentials are being encrypted. This is done by
    simply placing `res.send` outside of the callbacks (we haven''t done this here
    but it could be a good idea since encryption of this magnitude could take around
    a second to calculate).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`randomBytes`和`pbkdf2`是异步的，这很有帮助，因为它允许我们执行其他任务，或者通过立即将用户带到新页面来改善用户体验，而他们的凭据正在被加密。这是通过简单地将`res.send`放在回调之外来完成的（我们在这里没有这样做，但这可能是一个好主意，因为这样大量的加密可能需要大约一秒钟来计算）。'
- en: Once we have both our hash and salt values we place them into our `userStore`
    object. To implement a corresponding login we would simply compute the hash in
    the same way using that user's stored salt.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了哈希和盐值，我们将它们放入我们的`userStore`对象中。要实现相应的登录，我们只需以相同的方式使用用户存储的盐来计算哈希。
- en: We chose to iterate 7,000 times. When PBKDF2 was standardized the recommended
    iteration count was 1,000\. However, we need more iterations to account for technology
    advancements and reductions in the cost of equipment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择迭代7,000次。当PBKDF2被标准化时，推荐的迭代次数是1,000。然而，我们需要更多的迭代来考虑技术进步和设备成本的降低。
- en: See also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing Digest Authentication* discussed in this chapter'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中讨论的*实现摘要身份验证*
- en: '*Setting up an HTTPS web server* discussed in this chapter'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置HTTPS Web服务器*在本章中讨论'
- en: '*Generating Express scaffolding* discussed In [Chapter 6](ch06.html "Chapter 6. Accelerating
    Development with Express"),Accelerating Development with Express'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成Express脚手架*在[第6章](ch06.html "第6章。使用Express加速开发")中讨论，使用Express加速开发'
- en: Implementing Digest Authentication
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现摘要身份验证
- en: '**Digest Authentication** combines Basic Authentication with MD5 encryption,
    thus avoiding the transmission of plain text passwords, making for a more secure
    login method over plain HTTP.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要身份验证**将基本身份验证与MD5加密结合在一起，从而避免传输明文密码，在普通HTTP上实现了更安全的登录方法。'
- en: On its own, Digest Authentication is still insecure without an SSL/TLS-secured
    HTTPS connection. Anything over plain HTTP is vulnerable to man in the middle
    attacks, where an adversary can intercept requests and forge responses. An attacker
    could masquerade as the server, replacing the expected Digest response with a
    Basic Authentication response, thus gaining the password in plain text.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用摘要身份验证仍然不安全，没有SSL/TLS安全的HTTPS连接。在普通HTTP上的任何内容都容易受到中间人攻击的威胁，对手可以拦截请求并伪造响应。攻击者可以冒充服务器，用基本身份验证响应替换预期的摘要响应，从而获得明文密码。
- en: Nevertheless, in the absence of SSL/TLS, Digest Authentication at least affords
    us some defense in the area of plain text passwords requiring more advanced circumvention
    techniques.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在没有SSL/TLS的情况下，摘要身份验证至少为我们提供了一些在明文密码方面需要更高级规避技术的防御。
- en: So in this recipe, we will create a Digest Authentication server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个配方中，我们将创建一个摘要身份验证服务器。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To begin with, we simply have to create a new folder with a new `server.js`
    file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只需创建一个新的文件夹和一个新的`server.js`文件。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'As in the Basic Authentication recipe we create an HTTP server, we''ll also
    be using the `crypto` module to handle the MD5 hashing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基本身份验证配方中我们创建了一个HTTP服务器一样，我们还将使用`crypto`模块来处理MD5哈希：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've made an `md5` function as a shorthand interface to the `crypto` hash methods.
    The `opaque` variable is a necessary part of the `Digest` standard. It's simply
    an MD5 hash of `realm` (as also used in Basic Authentication). The client returns
    the opaque value back to the server for an extra means of validating responses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`md5`函数作为`crypto`哈希方法的简写接口。`opaque`变量是`Digest`标准的必要部分。它只是`realm`的MD5哈希（也用于基本身份验证）。客户端将opaque值返回给服务器，以提供额外的响应验证手段。
- en: 'Now we''ll create two extra helper functions, one for authentication and one
    to parse the `Authorization` header as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建两个额外的辅助函数，一个用于身份验证，另一个用于解析`Authorization`头，如下所示：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we implement the server as shown in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按照以下代码实现服务器：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Within the browser, this will look exactly the same as Basic Authentication,
    which is unfortunate as a clear difference between Digest and Basic dialogs could
    alert the user to a potential attack.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，这看起来与基本身份验证完全相同，这是不幸的，因为摘要和基本对话框之间的明显区别可能会提醒用户可能发生攻击。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When the server sends the `WWW-Authenticate` header to the browser, several
    attributes are included, consisting of: `realm, qop, nonce`, and `opaque`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器向浏览器发送`WWW-Authenticate`头时，包括几个属性，包括：`realm, qop, nonce`和`opaque`。
- en: '`realm` is the same as Basic Authentication, and `opaque` is an MD5 hash of
    the `realm`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`realm`与基本身份验证相同，`opaque`是`realm`的MD5哈希。'
- en: '`qop` stands for Quality of Protection and is set to `auth. qop` can also be
    set to `auth-int` or simply be omitted. By setting it to `auth`, we cause the
    browser to compute a more secure final MD5 hash. `auth-int` is stronger still,
    but browser support for it is minimal.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`qop`代表Quality of Protection，设置为`auth. qop`也可以设置为`auth-int`或者简单地省略。通过将其设置为`auth`，我们使浏览器计算出更安全的最终MD5哈希。`auth-int`更加强大，但浏览器对其的支持很少。'
- en: '`nonce` is a similar concept to a salt, it causes the final MD5 hash to be
    less predictable from an attacker''s perspective.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonce`类似于盐的概念，它使最终的MD5哈希在攻击者的视角下更不可预测。'
- en: When the user submits their login details via the browser's authentication dialog,
    an `Authorization` header is returned containing all of the attributes sent from
    the server, plus the `username, uri, nc, cnonce`, and `response` attributes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过浏览器的身份验证对话框提交其登录详细信息时，将返回一个包含服务器发送的所有属性以及`username, uri, nc, cnonce`和`response`属性的`Authorization`头。
- en: '`username` is the user''s specified alias, `uri` is the path being accessed
    (we could use this to secure on a route by route basis), `nc` is a serial counter
    which is incremented on each authentication attempt, `cnonce` is the browser''s
    own generated `nonce` value, and `response` is the final computed hash.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`username`是用户指定的别名，`uri`是正在访问的路径（我们可以使用它来基于路由进行安全保护），`nc`是一个序列计数器，每次认证尝试时都会递增，`cnonce`是浏览器自己生成的`nonce`值，`response`是最终计算出的哈希。'
- en: In order to confirm an authenticated user, our server must match the value of
    `response`. To do so, it removes the `Digest` string (including the proceeding
    space) and then passes what remains of the `Authorization` header to the `parseAuth`
    function. `parseAuth` converts all the attributes into a handy object, and loads
    it back into our `auth` variable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认经过身份验证的用户，我们的服务器必须匹配`response`的值。为此，它删除`Authorization`头中的`Digest`字符串（包括前面的空格），然后将剩下的内容传递给`parseAuth`函数。`parseAuth`将所有属性转换为一个方便的对象，并将其加载回我们的`auth`变量中。
- en: The first thing we do with `auth` is check that the username is correct. If
    we have no match, we ask for authentication again. This could save our server
    from some unnecessary heavy lifting with MD5 hashing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`auth`的第一件事是检查用户名是否正确。如果没有匹配，我们会再次要求进行身份验证。这可以节省我们的服务器一些不必要的MD5哈希运算。
- en: The final computed MD5 hash is made from the combination of two previously encrypted
    MD5 hashes along with the server's `nonce` and `qop` values and the client's `cnonce`
    and `nc` values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最终计算出的MD5哈希是由两个先前加密的MD5哈希以及服务器的`nonce`和`qop`值以及客户端的`cnonce`和`nc`值的组合生成的。
- en: We called the first hash `digest.ha1`. It contains a colon (:) delimited string
    of the `username, realm`, and `password` values. `digest.ha2` is the `request`
    method (GET) and the `uri` attribute, again delimited by a colon.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称第一个哈希为`digest.ha1`。它包含一个以冒号（:）分隔的字符串，其中包括`username, realm`和`password`的值。`digest.ha2`是`request`方法（GET）和`uri`属性，同样用冒号分隔。
- en: The final `digest.response` property has to match `auth.response` which is generated
    by the browser, so the ordering and specific elements must be precise. To create
    our `digest.response` we combine `digest.ha1`, the `nonce, nc`, the `cnonce, qop`,
    and `digest.ha2` each separated by a colon. For easy reading we put these values
    into an array running JavaScript's `join` method on them to generate the final
    string, which is passed to our `md5` function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`digest.response`属性必须与浏览器生成的`auth.response`匹配，因此排序和特定元素必须精确。为了创建我们的`digest.response`，我们将`digest.ha1`、`nonce,
    nc`、`cnonce, qop`和`digest.ha2`分别用冒号分隔，然后将这些值放入数组中，运行JavaScript的`join`方法生成最终字符串，然后传递给我们的`md5`函数。'
- en: If the given username and password are correct, and we've generated `digest.response`
    correctly, it should match the browser's `response` header attribute (`auth.response`).
    If it doesn't, the user will be presented with another authentication dialog.
    If it does, we reach the final `res.end`. We made it!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的用户名和密码正确，并且我们正确生成了`digest.response`，它应该与浏览器的`response`头属性（`auth.response`）匹配。如果不匹配，用户将被要求进行另一次身份验证对话框。如果匹配，我们到达最终的`res.end`。我们成功了！
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's tackle the logout problem.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决注销问题。
- en: Logging out of authenticated areas
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退出经过身份验证的区域
- en: There is little to no support in browsers for any official logging out method
    under Basic or Digest Authentication, except for closing the entire browser.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本或摘要身份验证下，浏览器几乎没有任何官方注销方法的支持，除了关闭整个浏览器。
- en: However, we can force the browser to essentially lose its session by changing
    the `realm` attribute in the `WWW-Authenticate` header.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过更改`WWW-Authenticate`头中的`realm`属性来强制浏览器基本上失去其会话。
- en: In a multiuser situation, if we change our global `realm` variable it will cause
    all users to log out (if there was more than one). So if a user wishes to log
    out, we have to assign them a unique realm that will cause only their session
    to quit.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在多用户情况下，如果我们更改全局`realm`变量，将导致所有用户注销（如果有多个用户）。因此，如果用户希望注销，我们必须为他们分配一个唯一的领域，这将导致只有他们的会话退出。
- en: 'To simulate multiple users, we''ll remove our `username` and `password` variables,
    replacing them with a `users` object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟多个用户，我们将删除我们的`username`和`password`变量，并用一个`users`对象替换它们：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our sub-objects (currently containing `password)` will potentially gain three
    extra properties: `uRealm, uOpaque`, and `forceLogOut`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的子对象（当前包含`password`）可能会获得三个额外的属性：`uRealm, uOpaque`和`forceLogOut`。
- en: 'Next, we''ll modify our `authenticate` function as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改我们的`authenticate`函数如下：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've added an optional `username` parameter to the `authenticate` function.
    If `username` is present, we load the unique `realm` and corresponding `opaque`
    values for that user, sending them in the header.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向“authenticate”函数添加了一个可选的“username”参数。如果“username”存在，我们加载该用户的唯一“realm”和相应的“opaque”值，并将它们发送到标头中。
- en: 'Inside our server callback we replace this code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的服务器回调中，我们替换了这段代码：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We check whether the specified username exists inside our `users` object, saving
    us from further processing if it doesn't. Providing the user is valid, we check
    the route (we'll be supplying a logout link to the user). If the `/logout` route
    has been hit, we set up a `uRealm` property on the logged in user's object and
    a corresponding `uOpaque` property containing an MD5 hash of `uRealm`. We also
    add a `forceLogOut` Boolean property, setting it to `true`. Then we redirect the
    user away from the `/logout` to `/`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查指定的用户名是否存在于我们的“用户”对象中，如果不存在，则无需进行进一步处理。只要用户有效，我们就检查路由（我们将为用户提供注销链接）。如果已命中“/logout”路由，我们会在已登录用户的对象上设置一个“uRealm”属性和一个包含“uRealm”的MD5哈希的相应“uOpaque”属性。我们还添加一个“forceLogOut”布尔属性，并将其设置为“true”。然后我们将用户从“/logout”重定向到“/”。
- en: The redirect triggers another request, upon which the server detects the presence
    of our `forceLogOut` property for the currently authenticated user. `forceLogOut`
    is then removed from the `users` sub-object to prevent it from getting in the
    way later. Lastly, we pass control over to the `authenticate` function with the
    special `username` parameter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向触发另一个请求，服务器检测到当前经过身份验证的用户的“forceLogOut”属性的存在。然后，从“用户”子对象中删除“forceLogOut”，以防止它在以后造成干扰。最后，我们将控制权交给具有特殊“username”参数的“authenticate”函数。
- en: Consequently, `authenticate` includes the user-linked `uRealm` and `uOpaque`
    values in the `WWW-Authenticate` header, breaking the session.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，“authenticate”在“WWW-Authenticate”标头中包含了与用户关联的“uRealm”和“uOpaque”值，从而中断了会话。
- en: To finish off, we make a few more trivial adjustments.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进行了一些微不足道的调整。
- en: '`digest.ha1` requires the `password` and `realm` values, so it''s updated as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`digest.ha1`需要“密码”和“realm”值，因此更新如下：'
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `password` value is fed in via our new `users` object, and the `realm` value
    is chosen based upon whether our logged-in user has unique realm (a `uRealm` property)
    set or not.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的新“用户”对象输入“密码”值，并根据我们已登录的用户是否设置了唯一领域（“uRealm”属性）来选择“realm”值。
- en: 'We change the last segment of our server''s code to the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将服务器代码的最后一部分更改为以下内容：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice the inclusion of a logout link, the final piece.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到包含了注销链接，这是最后一块拼图。
- en: New `uRealm` and `uOpaque` attributes are generated if the hashes don't match.
    This prevents an eternal loop between the browser and server. Without this, when
    we log in as a valid user and then log out, we'd be presented with another login
    dialog. If we enter a non-existent user, the new login attempt is rejected by
    the server as normal. However, the browser attempts to be helpful and falls back
    to the old authentication details with our first logged-in user and original realm.
    But, when the server receives the old login details, it matches the user to their
    unique realm, demanding authentication for `uRealm`, not `realm`. The browser
    sees the `uRealm` value and matches our non-existent user back to it, attempting
    to authenticate again as that user, thus repeating the cycle.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果哈希不匹配，则会生成新的“uRealm”和“uOpaque”属性。这可以防止浏览器和服务器之间的永久循环。如果没有这个，当我们以有效用户身份登录然后注销时，我们将被呈现另一个登录对话框。如果我们输入一个不存在的用户，新的登录尝试将像正常情况下一样被服务器拒绝。然而，浏览器试图提供帮助，并回到我们第一个已登录用户和原始领域的旧身份验证详细信息。但是，当服务器接收到旧的登录详细信息时，它将用户与其唯一领域进行匹配，要求对“uRealm”而不是“realm”进行身份验证。浏览器看到“uRealm”值并将我们的不存在的用户与其匹配，尝试再次作为该用户进行身份验证，从而重复循环。
- en: By setting a new `uRealm`, we break the cycle because an extra realm is introduced
    which the browser has no record of, so it defers to the user by asking for input.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置新的“uRealm”，我们打破了循环，因为引入了一个浏览器没有记录的额外领域，所以它会要求用户输入。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Implementing Basic Authentication* discussed in this chapter'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了*实施基本身份验证*
- en: '*Cryptographic password hashing* discussed in this chapter'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了*密码哈希加密*
- en: '*Setting up an HTTPS web server* discussed in this chapter'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章讨论了*设置HTTPS Web服务器*
- en: Setting up an HTTPS web server
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置HTTPS Web服务器
- en: For the most part, HTTPS is the solution to many of the security vulnerabilities
    such as (network sniffing, and man in the middle) faced over HTTP.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，HTTPS是解决许多安全漏洞（如网络嗅探和中间人攻击）的解决方案。
- en: Thanks to the core `https` module. It's really simple to set up.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢核心的“https”模块。设置起来非常简单。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The greater challenge could be in actually obtaining the necessary SSL/TLS certificate.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的挑战可能在于实际获取必要的SSL/TLS证书。
- en: In order to acquire a certificate, we must generate an encrypted Private Key,
    and from that we generate a Certificate Signing Request. This is then passed onto
    a Certificate Authority (a commercial entity specifically trusted by browser vendors
    — naturally this means we have to pay for it). Alternatively, the CA may generate
    your Private Key and Certificate Signing Request on your behalf.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得证书，我们必须生成加密的私钥，然后从中生成证书签名请求。然后将其传递给证书颁发机构（一个专门受到浏览器供应商信任的商业实体——这自然意味着我们必须为此付费）。或者，CA可以代表您生成您的私钥和证书签名请求。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The company, StartSSL provides free certificates. An article about using StartSSL
    certificates with Node can be found at [https://www.tootallnate.net/setting-up-free-ssl-on-your-node-server](https://www.tootallnate.net/setting-up-free-ssl-on-your-node-server).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: StartSSL公司提供免费证书。关于如何在Node上使用StartSSL证书的文章可以在[https://www.tootallnate.net/setting-up-free-ssl-on-your-node-server](https://www.tootallnate.net/setting-up-free-ssl-on-your-node-server)找到。
- en: After a verification process, the Certificate Authority (CA) will issue a Public
    Certificate enabling us to encrypt our connections.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 经过验证过程后，证书颁发机构（CA）将颁发一个公共证书，使我们能够加密我们的连接。
- en: We can short cut this process and authorize our own certificate (self-sign),
    naming ourselves as the CA. Unfortunately, if the CA isn't known to a browser,
    it will vividly warn the user that our site isn't to be trusted and that they
    may be under attack. This isn't so good for positive brand image. So while we
    may self-sign during development, we would most likely need a trusted CA for production.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简化这个过程并授权我们自己的证书（自签名），将自己命名为CA。不幸的是，如果CA对浏览器不知情，它将明确警告用户我们的网站不值得信任，他们可能受到攻击。这对于积极的品牌形象并不好。因此，虽然在开发过程中我们可以自签名，但在生产中我们很可能需要一个受信任的CA。
- en: 'For development, we can quickly use the `openssl` executable (available by
    default on Linux and Mac OS X, and we can obtain a Windows version from [http://www.openssl.org/related/binaries.html)](http://www.openssl.org/related/binaries.html))
    to generate necessary Private Key and Public Certificate:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发，我们可以快速使用`openssl`可执行文件（在Linux和Mac OS X上默认可用，我们可以从[http://www.openssl.org/related/binaries.html](http://www.openssl.org/related/binaries.html)获取Windows版本）来生成必要的私钥和公共证书：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This executes `openssl` twice on the command line: once to generate basic Private
    Key and Certificate Signing Request, and again to self-sign Private Key, thus
    generating Certificate (`cert.pem`).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这在命令行上执行`openssl`两次：一次用于生成基本的私钥和证书签名请求，再次用于自签名私钥，从而生成证书（`cert.pem`）。
- en: In a real production scenario, our `-subj` flag would hold more details, and
    we would want to acquire our `cert.pem` file from a legitimate CA. But this is
    fine for private, development, and testing purposes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际生产场景中，我们的`-subj`标志将包含更多细节，我们还需要从合法的CA获取我们的`cert.pem`文件。但这对于私人、开发和测试目的来说是可以的。
- en: Now that we have our key and certificate, we simply need to make our server,
    so we'll create a new `server.js` file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了密钥和证书，我们只需要创建一个新的`server.js`文件来启动我们的服务器。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Within `server.js` we write the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中，我们编写以下代码：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And that's it!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `https` module depends upon the `http` and `tls` modules, which in turn
    rely upon the `net` and `crypto` modules. SSL/TLS is transport layer encryption,
    meaning that it works at a level beneath HTTP, at the TCP level. The `tls` and
    `net` modules work together to provide an SSL/TLS-encrypted TCP connection, with
    HTTPS layered on top of this.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`https`模块依赖于`http`和`tls`模块，而这些模块又依赖于`net`和`crypto`模块。SSL/TLS是传输层加密，这意味着它在HTTP的下层，在TCP层起作用。`tls`和`net`模块一起提供SSL/TLS加密的TCP连接，HTTPS则在其之上。'
- en: When a client connects via HTTPS (in our case, at the address `https://localhost:4443)`,
    it attempts a TLS/SSL handshake with our server. The `https` module uses the `tls`
    module to respond to the handshake in a series of fact-finding interchanges between
    the browser and server. (For example, what SSL/TLS version do you support? What
    encryption method do you want to use? Can I have your public key?)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端通过HTTPS连接（在我们的情况下，地址为`https://localhost:4443`）时，它会尝试与我们的服务器进行TLS/SSL握手。`https`模块使用`tls`模块来响应握手，通过一系列的信息交换来确认浏览器和服务器之间的握手。（例如，你支持什么SSL/TLS版本？你想使用什么加密方法？我可以拿到你的公钥吗？）
- en: At the end of this initial interchange, the client and server have an agreed
    shared secret. This secret is used to encrypt and decrypt content sent between
    the two parties. This is where the `crypto` module kicks in, providing all of
    the data encryption and decryption functionality.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始的交换结束时，客户端和服务器有了一个约定的共享密钥。这个密钥用于加密和解密双方之间发送的内容。这就是`crypto`模块发挥作用的地方，提供所有的数据加密和解密功能。
- en: For us, it's as simple as requiring the `https` module, providing our certificates,
    then using it just like we would an `http` server.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，只需引入`https`模块，提供我们的证书，然后像使用`http`服务器一样使用它。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's see a few HTTPS use cases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些HTTPS使用案例。
- en: HTTPS in Express
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Express中使用HTTPS
- en: 'Enabling HTTPS in Express is just as simple:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express中启用HTTPS同样简单：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Securing Basic Authentication with SSL/TLS
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SSL/TLS保护基本身份验证
- en: 'We can build anything into our `https` server that we could into an `http`
    server. To enable HTTPS in our Basic Authentication recipe all we do is alter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的`https`服务器中构建任何东西，就像在`http`服务器中一样。要在我们的基本身份验证配方中启用HTTPS，我们只需修改：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Cryptographic password hashing* discussed in this chapter'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章讨论的密码哈希* '
- en: '*Implementing Basic Authentication* discussed in this chapter'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章讨论的基本身份验证中实施*'
- en: Preventing cross-site request forgery
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止跨站点请求伪造
- en: There's a problem with every browser's security model that, as developers, we
    must be aware of.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器的安全模型都存在问题，作为开发者，我们必须意识到这一点。
- en: When a user has logged in to a site, any requests made via the authenticated
    browser are treated as legitimate — even if the links for these requests come
    from an email, or are performed in another window. Once the browser has a session,
    all windows can access that session.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录到网站后，通过经过身份验证的浏览器发出的任何请求都被视为合法的——即使这些请求的链接来自电子邮件，或者在另一个窗口中执行。一旦浏览器有了会话，所有窗口都可以访问该会话。
- en: This means an attacker can manipulate a user's actions on a site they are logged
    in to with a specifically crafted link, or with automatic AJAX calls requiring
    no user interaction except to be on the page containing the malicious AJAX.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着攻击者可以通过特制的链接或自动的AJAX调用来操纵用户在已登录的网站上的操作，而无需用户交互，只需在包含恶意AJAX的页面上。
- en: For instance, if a banking web app hasn't been properly CSRF secured, an attacker
    could convince the user to visit another website while logged in to their online
    banking. This website could then run a POST request to transfer money from the
    victim's account to the attacker's account without the victim's consent or knowledge.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个银行网站应用程序没有得到适当的CSRF保护，攻击者可以说服用户在登录到在线银行时访问另一个网站。然后，这个网站可以运行一个POST请求，将资金从受害者的账户转移到攻击者的账户，而受害者并不知情也没有同意。
- en: This is known as a **Cross - Site Request Forgery (CSRF)** attack. In this recipe,
    we'll be implementing a secure HTML login system with CSRF protection.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**跨站点请求伪造（CSRF）**攻击。在这个recipe中，我们将实现一个带有CSRF保护的安全HTML登录系统。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be securing our Profiler Web App from the *Making an Express Web App*
    recipe discussed In [Chapter 6](ch06.html "Chapter 6. Accelerating Development
    with Express"), *Accelerating Development with Express*. We'll want to get a hold
    of our `profiler` app, with the `profiler/app.js` and `profiler/login/app.js`
    files open and ready for editing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从[第6章](ch06.html "第6章。使用Express加速开发")中讨论的*制作一个Express Web应用程序*recipe中保护我们的Profiler
    Web应用程序。我们将想要获取我们的`profiler`应用程序，打开`profiler/app.js`和`profiler/login/app.js`文件进行编辑。
- en: Without SSL/TLS encryption, HTML-based logins are subject to at least the same
    vulnerabilities as Basic Authorization. So for basic security, we'll be adding
    HTTPS to our app. So we need our `cert.pem` and `key.pem` files from the previous
    recipe.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 没有SSL/TLS加密，基于HTML的登录至少会受到与基本授权相同的漏洞的影响。因此，为了基本安全，我们将在我们的应用程序中添加HTTPS。因此，我们需要从上一个recipe中获取我们的`cert.pem`和`key.pem`文件。
- en: We'll also need to have MongoDB running with our stored user data from recipes
    In [Chapter 6](ch06.html "Chapter 6. Accelerating Development with Express"),
    *Accelerating Development with Express*, since our `profiler` app relies upon
    it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要让MongoDB运行，并从[第6章](ch06.html "第6章。使用Express加速开发")中的recipes中存储用户数据，因为我们的`profiler`应用程序依赖于它。
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, let''s secure our entire app with SSL, the top of `profiler/app.js`
    should look like the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用SSL保护整个应用程序，`profiler/app.js`的顶部应该如下所示的代码：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `admin` section of `profiler` is where a CSRF attack could take place,
    so let''s open up `profiler/login/app.js` and add the `express.csrf` middleware.
    The top of the `app.configure` callback in `profiler/login/app.js` should look
    like the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`profiler`的`admin`部分是一个CSRF攻击可能发生的地方，所以让我们打开`profiler/login/app.js`并添加`express.csrf`中间件。`profiler/login/app.js`中`app.configure`回调的顶部应该如下所示的代码：'
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 3.x.x**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 3.x.x**'
- en: 'Don''t forget, in Express 3.x.x the secret goes as a string into `cookieParser`
    instead of an object into `session: express.cookieParser(''kooBkooCedoN'')`;.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '不要忘记，在Express 3.x.x中，秘密作为字符串进入`cookieParser`而不是作为对象进入`session: express.cookieParser(''kooBkooCedoN'')`。'
- en: The `csrf` middleware is dependent upon the `bodyParser` and `session` middleware,
    so it must be placed below these.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`csrf`中间件依赖于`bodyParser`和`session`中间件，因此必须放在这些中间件之下。'
- en: Now if we navigate to `https://localhost:3000/admin` and attempt to log in (dave,
    expressrocks), we will receive a `403 Forbidden` response, even though we use
    correct details.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们导航到`https://localhost:3000/admin`并尝试登录（dave, expressrocks），我们将收到一个`403
    Forbidden`的响应，即使我们使用了正确的详细信息。
- en: That's because our login app is now looking for an additional POST parameter
    called `_csrf` in all of our POST forms, which must match the `_csrf` value stored
    in the user's `session` object.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的登录应用程序现在在所有的POST表单中寻找一个名为`_csrf`的额外的POST参数，它必须与用户`session`对象中存储的`_csrf`值匹配。
- en: Our views need to know the value of `_csrf` so it can be placed in our forms
    as a hidden element.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图需要知道`_csrf`的值，这样它就可以被放置在我们的表单中作为一个隐藏元素。
- en: We'll use `dynamicHelper` to supply `req.session._csrf` to all login views.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`dynamicHelper`为所有登录视图提供`req.session._csrf`。
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we''ll create a view called `csrf.jade` in the `login/views` folder as
    follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`login/views`文件夹中创建一个名为`csrf.jade`的视图，如下所示：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we include `csrf.jade` in each of our POST forms.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在每个POST表单中包含`csrf.jade`。
- en: '`login.jade:`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`login.jade:`'
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`addfrm.jade:`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`addfrm.jade:`'
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Updating and maintaining a site with many different POST forms could pose as
    challenging. We would have to manually alter every single form. See how we can
    auto-generate CSRF values for all forms in the *There's More...* section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 更新和维护一个有许多不同POST表单的网站可能会带来挑战。我们将不得不手动修改每一个表单。看看我们如何在*还有更多...*部分为所有表单自动生成CSRF值。
- en: Now we can log in, add profiles, and log out without a `403 Forbidden` response.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以登录，添加配置文件，并且不会收到`403 Forbidden`的响应。
- en: However, our `/del` route is still susceptible to CSRF. The GET requests are
    not typically supposed to trigger any changes on the server. They are intended
    simply to retrieve information. However, like many other apps in the wild, the
    developers (that's us) were lazy when they built this particular functionality
    and decided to coerce a GET request to do their bidding.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的`/del`路由仍然容易受到CSRF的攻击。GET请求通常不应该触发服务器上的任何更改。它们只是用来检索信息。然而，像许多其他应用程序一样，开发人员（也就是我们）在构建这个特定功能时懒惰，并决定强迫GET请求来执行他们的命令。
- en: We could turn this into a POST request and then secure it with CSRF, but what
    about an app that has hundreds of these deviant GETs?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个转换为一个POST请求，然后用CSRF进行保护，但是对于一个有数百个这种异常GET请求的应用程序呢？
- en: 'Let''s find out how to protect our `/del` route. In `login/routes/index.js`
    add the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出如何保护我们的`/del`路由。在`login/routes/index.js`中添加以下代码：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our changes make it so we can't delete profiles until we include `_csrf` in
    the query string, so in `views/admin.jade:`
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的更改使得我们不能删除配置文件，直到我们在查询字符串中包含`_csrf`，所以在`views/admin.jade:`中：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `csrf` middleware generates a unique token which is held in the user's session.
    This token must be included in any actioning requests (logging in, logging out,
    adding or deleting) as an attribute named `_csrf`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`csrf`中间件生成一个唯一的令牌，保存在用户的会话中。这个令牌必须包含在任何操作请求（登录、登出、添加或删除）中，作为名为`_csrf`的属性。'
- en: If the `_csrf` value in the request body (or query string for GET) doesn't match
    the `_csrf` token stored in the `session` object, the server denies access to
    that route and therefore prevents the action from occurring.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求体中（或GET的查询字符串中）的`_csrf`值与`session`对象中存储的`_csrf`令牌不匹配，服务器将拒绝访问该路由，从而阻止操作的发生。
- en: How does this prevent a CSRF attack? In a plain CSRF exploit, the attacker has
    no way of knowing what the `_csrf` value is, so they are unable to forge the necessary
    POST request.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何防止CSRF攻击？在普通的CSRF攻击中，攻击者无法知道`_csrf`值是多少，因此他们无法伪造必要的POST请求。
- en: Our `/del` route protection is less secure. It exposes the `_csrf` value in
    the address, potentially creating a very small, but nonetheless plausible, window
    of opportunity for an attacker to grab the `_csrf` value. This is why it's best
    for us to stick with the POST/DELETE/PUT requests for all action-related endeavors,
    leaving GET requests for simple retrieval.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`/del`路由保护不够安全。它在地址中暴露了`_csrf`值，可能为攻击者抓取`_csrf`值创造了一个非常小但仍然可信的机会。这就是为什么最好是我们坚持使用POST/DELETE/PUT请求来处理所有与操作相关的努力，将GET请求留给简单的检索。
- en: Cross-site scripting (XSS) circumvention
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨站脚本（XSS）规避
- en: This protection is rendered moot in the event of an accompanied XSS exploit,
    whereby an attacker is able to implant their own JavaScript within the site (for
    example, through exploiting an input vulnerability). JavaScript can read any elements
    in the page it resides on, and view non-HttpOnly cookies with `document.cookie`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在伴随的XSS攻击事件中，这种保护变得无效，攻击者能够在网站中植入自己的JavaScript（例如，通过利用输入漏洞）。JavaScript可以读取页面上的任何元素，并查看`document.cookie`中的非HttpOnly
    cookie。
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We'll take a look at a way to automatically generate CSRF tokens for login forms,
    but we should also bear in mind that CSRF protection is only as good as our ability
    to code tightly.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一种自动生成登录表单CSRF令牌的方法，但我们也应该记住CSRF保护只有我们编写严密的能力才能做到。
- en: Auto-securing the POST forms with the CSRF elements
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动保护带有CSRF元素的POST表单
- en: Ensuring that all the POST forms in our app contain a hidden `_csrf` input element
    could be an arduous task on a site of any significant scale.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们应用程序中的所有POST表单都包含一个隐藏的`_csrf`输入元素可能是一个艰巨的任务。
- en: We can interact directly with some Jade internals to automatically include these
    elements.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接与一些Jade内部交互，自动包含这些元素。
- en: 'First, in `login/app.js` we add the following setting to our configuration:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`login/app.js`中，我们向配置中添加了以下设置：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Express allows us to push particular options to whatever view engine we are
    using. One of the Jade options (our view engine) is `compile`, which allows us
    to define our own custom Jade interpreter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Express允许我们将特定选项推送到我们正在使用的视图引擎。Jade选项之一（我们的视图引擎）是`compile`，它允许我们定义我们自己的自定义Jade解释器。
- en: Let's create `customJadeCompiler.js` placing it in the `login` directory.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`customJadeCompiler.js`并将其放在`login`目录中。
- en: 'First, we''ll require some modules and set up our new compiler class as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些模块并设置我们的新编译器类如下：
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next we use `util.inherits` to inherit our new compiler's prototype from the
    Jades compiler.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`util.inherits`从Jades编译器继承我们新编译器的原型。
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then we modify the Jade's internal `visitTag` method (which we've inherited
    from `jade.Compiler):`
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们修改Jade的内部`visitTag`方法（我们从`jade.Compiler`那里继承的）：
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, we load our new compiler into `module.exports` so it's passed via `require`
    to the `compiler` option of the `view options` setting in `app.js:`
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的新编译器加载到`module.exports`中，以便通过`require`传递给`app.js`中`view options`设置的`compiler`选项：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We create a new class-type function, applying the `call` method to `jade.Compiler`.
    When we pass the `this` object to the `call` method, we essentially inherit the
    main functionality of `jade.Compiler` into our own `CompileWithCsrf` class-type
    function. It's a great way to re-use code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的类类型函数，将`call`方法应用于`jade.Compiler`。当我们将`this`对象传递给`call`方法时，我们实质上将`jade.Compiler`的主要功能继承到我们自己的`CompileWithCsrf`类类型函数中。这是重复使用代码的好方法。
- en: However, `jade.Compiler` also has a modified prototype which must be incorporated
    into our `CompileWithCsrf` in order to fully mimic `jade.Compiler`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`jade.Compiler`还有一个修改过的原型，必须合并到我们的`CompileWithCsrf`中，以便完全模仿`jade.Compiler`。
- en: 'We used `util.inherits`, but we could instead have said:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`util.inherits`，但我们也可以这样说：
- en: '[PRE41]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE42]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or even:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以说：
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`Object.create` is the Ecmascript5 way, `new` is the old way and `__proto__`
    is the non-standard way that should probably be avoided. These all inherit the
    additional methods and properties of `jade.Compiler`. However, `util.inherits`
    is preferred because it also adds a special `super` property containing the object
    we originally inherited from.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.create`是Ecmascript5的方法，`new`是旧的方法，`__proto__`是应该避免使用的非标准方法。它们都继承了`jade.Compiler`的附加方法和属性。但是，`util.inherits`是首选的，因为它还添加了一个特殊的`super`属性，其中包含我们最初继承的对象。'
- en: Using `call` and `util.inherits` essentially allows us to clone the `jade.Compiler`
    object as `CompileWithCsrf`, which means we can modify it without touching `jade.Compiler`
    and then allow it to operate in place of `jade.Compiler`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`call`和`util.inherits`本质上允许我们将`jade.Compiler`对象克隆为`CompileWithCsrf`，这意味着我们可以修改它而不影响`jade.Compiler`，然后允许它代替`jade.Compiler`运行。
- en: We modify the `visitTag` method, which processes each tag (for example, `p,
    div`, and so on) in a Jade view. Then we look for the `form` tags with methods
    set to `post`, using a regular expression since the `method` attribute may be
    in upper or lower case, being wrapped in double or single quotes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改`visitTag`方法，该方法处理Jade视图中的每个标签（例如，`p，div`等）。然后，我们使用正则表达式寻找`method`属性设置为`post`的`form`标签，因为`method`属性可能是大写或小写，用双引号或单引号括起来。
- en: If we find a `form` with POST formatting, we use the `jade.Nodes` constructor
    to create a new input `node` (a Jade construct, in this case rolling as an HTML
    element), which we then call `setAttribute` (an internal Jade method) on three
    times to set the `type, name` and `value` fields. Notice `name` is set to`'"_csrf"'`
    but `value` contains`'_csrf'`. The inner double quotes tell Jade we intend a string.
    Without them, it treats the second parameter as a variable, which is exactly what
    we want in the case of `value`. The `value` attribute is therefore rendered according
    to `_csrf dynamicHelper` defined in `app.js` (which is likewise taken from `req.session._csrf`
    as generated by the `express.csrf` middleware).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个使用POST格式的`form`，我们使用`jade.Nodes`构造函数创建一个新的输入`node`（在这种情况下作为HTML元素），然后调用`setAttribute`（一个内部的Jade方法）三次来设置`type,
    name`和`value`字段。注意`name`设置为`'"_csrf"'`但`value`包含`'_csrf'`。内部的双引号告诉Jade我们打算使用一个字符串。没有它们，它会将第二个参数视为一个变量，这正是我们在`value`的情况下想要的。因此，`value`属性根据`app.js`中定义的`_csrf
    dynamicHelper`（同样是从`express.csrf`中间件生成的`req.session._csrf`中获取）进行渲染。
- en: Now that our `_csrf` tokens are automatically included in every POST form, we
    can remove the `csrf.jade` includes from the `login.jade` and `addfrm.jade` views.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`_csrf`令牌已经自动包含在每个POST表单中，我们可以从`login.jade`和`addfrm.jade`视图中删除`csrf.jade`的包含。
- en: Eliminating cross-site scripting (XSS) vulnerabilities
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消除跨站脚本（XSS）漏洞
- en: Cross-site scripting attacks are generally preventable, all we have to do is
    ensure any user input is validated and encoded. The tricky part comes where we
    improperly or insufficiently encode user input.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击通常是可以预防的，我们所要做的就是确保任何用户输入都经过验证和编码。棘手的部分在于我们在不正确或不充分地对用户输入进行编码的地方。
- en: When we take user input, much of the time we'll be outputting it to the browser
    at a later stage, this means we must embed it within our HTML.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接受用户输入时，大部分时间我们会在稍后的阶段将其输出到浏览器中，这意味着我们必须将其嵌入到我们的HTML中。
- en: 'XSS attacks are all about breaking context. For instance, imagine we had some
    Jade that links to a user profile by their username:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: XSS攻击主要是破坏上下文。例如，想象一下，我们有一些Jade代码，通过用户名链接到用户个人资料：
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This code is exploitable in two ways. First, we used `!{username}` instead
    of `#{username}` for the text portion of our anchor link element. In Jade `#{}interpolation`
    escapes any HTML in the given variable. So if an attacker was able to insert:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两种可利用的方式。首先，我们在锚链接元素的文本部分使用了`!{username}`而不是`#{username}`。在Jade中，`#{}插值`会转义给定变量中的任何HTML。因此，如果攻击者能够插入：
- en: '[PRE45]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As their username, `#{username}` would render:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 作为他们的用户名，`#{username}`会渲染为：
- en: '[PRE46]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Whereas, `!{username}` would be unescaped (for example, HTML would not be replaced
    by escape characters like`&lt`; in place of`<)`. The attacking code could be changed
    from an innocent (though jaunty) `alert` message, to successfully initiated Forged
    Requests, and our CSRF protection would be futile since the attack is operating
    from the same page (JavaScript has access to all data on the page, and the attacker
    has gained access to our page's JavaScript via XSS).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 而`!{username}`将不会被转义（例如，HTML不会被转换为转义字符，如`&lt;`代替`<`）。攻击代码可以从一个无辜（尽管活泼）的`alert`消息改变为成功发起的伪造请求，而我们的CSRF保护将是徒劳的，因为攻击是从同一个页面操作的（JavaScript可以访问页面上的所有数据，攻击者通过XSS获得了对我们页面的JavaScript的访问权限）。
- en: Jade HTML-escapes variables by default, which is a good thing. However, proper
    escaping must be context aware, and simply converting HTML syntax into its corresponding
    entity codes is not enough.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Jade默认对HTML进行转义，这是一件好事。然而，适当的转义必须具有上下文意识，简单地将HTML语法转换为相应的实体代码是不够的。
- en: 'The other vulnerable area in our bad Jade code is the `href` attribute. Attributes
    are a different context to simple nested HTML. Unquoted attributes are particularly
    susceptible to attack, for instance, consider the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们糟糕的Jade代码中的另一个易受攻击的区域是`href`属性。属性是一个与简单嵌套HTML不同的上下文。未引用的属性特别容易受到攻击，例如，考虑以下代码：
- en: '[PRE47]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we could set `profile` to `profile onClick=javascript:alert(''gotcha'')`,
    our HTML would read:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`profile`设置为`profile onClick=javascript:alert('gotcha')`，我们的HTML将会显示：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Again, Jade partially protects us in this sense by automatically quoting variables
    inserted to attributes. However, our vulnerable attribute is the `href` attribute,
    which is another sub context of the URL variety. Since it isn''t prefixed with
    anything, an attacker might input their username as `javascript:alert(''oh oh!'')`
    so the output of:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Jade在这方面部分保护了我们，通过自动引用插入到属性中的变量。然而，我们的易受攻击的属性是`href`属性，这是URL类型的另一个子上下文。由于它没有任何前缀，攻击者可能会将他们的用户名输入为`javascript:alert('oh
    oh!')`，因此输出为：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Would be:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将是：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `javascript:` protocol allows us to execute JavaScript at the link level,
    allowing a CSRF attack to be launched when an unsuspecting user clicks a malicious
    link.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`javascript:`协议允许我们在链接级别执行JavaScript，当一个无意中的用户点击一个恶意链接时，可以发起CSRF攻击。'
- en: Note
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'These trivial examples are elementary. XSS attacks can be much more complex
    and sophisticated. However, we can follow the Open Web Application Security Projects
    8 input sanitizing rules that provide extensive protection against XSS:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的例子是基础的。XSS攻击可能会更加复杂和复杂。然而，我们可以遵循Open Web Application Security Projects
    8输入消毒规则，这些规则提供了对XSS的广泛保护：
- en: '[https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)'
- en: Tip
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Validator module**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证器模块**'
- en: 'Once we understand how to clean user input, we could use regular expressions
    to quickly apply specific validation and sanitization methods. However, for a
    simpler life, we could also use the third-party `validator` module which can be
    installed with `npm`. Documentation is available on the Github page: [https://www.github.com/chriso/node-validator](https://www.github.com/chriso/node-validator).'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了如何清理用户输入，我们就可以使用正则表达式快速应用特定的验证和净化方法。然而，为了简化生活，我们也可以使用第三方的`validator`模块，该模块可以通过`npm`安装。文档可在Github页面上找到：[https://www.github.com/chriso/node-validator](https://www.github.com/chriso/node-validator)。
- en: See also
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Setting up an HTTPS web server* discussed in this chapter'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章讨论的设置HTTPS Web服务器*'
- en: '*Initializing and using a session* discussed In [Chapter 6](ch06.html "Chapter 6. Accelerating
    Development with Express"),Accelerating Development with Express'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化和使用会话*在[第6章](ch06.html "第6章。使用Express加速开发")中讨论，使用Express加速开发'
- en: '*Making an Express web app* discussed In [Chapter 6](ch06.html "Chapter 6. Accelerating
    Development with Express"),Accelerating Development with Express'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建Express Web应用程序*在[第6章](ch06.html "第6章。使用Express加速开发")中讨论，使用Express加速开发'
