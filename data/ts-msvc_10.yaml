- en: Hardening Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固您的应用程序
- en: It is very difficult to get security right. There always seems to be some open
    door for intruders to sneak in. Security mistakes are made all the time, such
    as the famous **WannaCry ransomware attack** (causing $5 billion of damage), **Ethereum
    theft** ($32 million heist), and so on. Such attacks always make us take extra
    steps toward security to avoid such disasters. As microservices are dynamic, any
    of the instances can go down leading to business loss.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要做好安全性是非常困难的。总是似乎有一些开放的门让入侵者溜进来。安全错误一直都在发生，比如著名的**WannaCry勒索软件攻击**（造成50亿美元的损失）、**以太坊盗窃**（3,200万美元的抢劫）等等。这些攻击总是让我们采取额外的步骤来加强安全，以避免这样的灾难。由于微服务是动态的，任何实例都可能崩溃导致业务损失。
- en: 'With a focus on handling security and autoscaling, this chapter explores some
    security fundamentals and microservice best practices to make the system more
    secure and robust, and make it easy to handle any amount of traffic. With the
    advent of containers, we will be looking at security at the container level too,
    as well as the application level. This chapter also focuses on autoscaling with
    the aim of making the application available at any time to handle any load, with
    zero downtime during new deployments. This chapter covers the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点关注处理安全性和自动扩展，探讨了一些安全基础知识和微服务最佳实践，以使系统更安全和健壮，并使其能够轻松处理任何数量的流量。随着容器的出现，我们还将关注容器级别的安全性，以及应用程序级别的安全性。本章还着重介绍了自动扩展，旨在使应用程序随时可用以处理任何负载，在新部署期间实现零停机。本章涵盖以下内容：
- en: Questions you should be asking while applying a security mechanism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用安全机制时应该问的问题
- en: Security best practices for individual services/applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个别服务/应用程序的安全最佳实践
- en: Security best practices for containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的安全最佳实践
- en: Scaling your application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展您的应用程序
- en: Questions you should be asking while applying security
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用安全时应该问的问题
- en: In a constantly evolving world, we can't have a predefined set of rules to apply
    in microservice design. Rather, we can have some predefined questions that we
    can ask ourselves to evaluate the overall system and processes. The following
    sections list of all the standard questions at various levels, which we can use
    as an evaluation checklist. Later, we will be upgrading our security as a solution
    to these questions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在不断发展的世界中，我们不能有一套预定义的规则来应用于微服务设计。相反，我们可以提出一些预定义的问题，以评估整个系统和流程。以下各节列出了各个级别的所有标准问题，我们可以将其用作评估检查表。稍后，我们将根据这些问题的解决方案升级我们的安全性。
- en: Core application/core microservice
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心应用程序/核心微服务
- en: 'We will begin at the very core—our microservice. Whenever we write any microservice
    to satisfy any business capability, once it is designed, we need to take care
    of whether the service is exposed to any vulnerabilities or not. The following
    questions can be asked to get a general idea about security at the application
    level:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最核心的地方开始——我们的微服务。每当我们编写任何微服务来满足任何业务能力时，一旦设计完成，我们需要注意服务是否暴露给任何漏洞。以下问题可以用来对应用程序级别的安全性进行一般了解：
- en: Is the system properly secured at all places or just at the boundaries?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统是否在所有地方都得到了适当的安全保障，还是只在边界处？
- en: If an intruder sneaks in, is the system powerful enough to detect that intruder
    and throw him out?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果入侵者溜进来，系统是否足够强大以侦测到并将其驱逐出去？
- en: How easy is it for an intruder to get inside the network by mimicking the usual
    behavior, get access to traffic, or overload traffic?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入侵者有多容易通过模仿正常行为、获取流量访问或过载流量来进入网络？
- en: Does each microservice trust other microservices even if they call them too
    much?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使它们也经常调用它们，每个微服务是否都信任其他微服务？
- en: Does your service contract have authentication or does the network handle authentication?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的服务契约是否有身份验证，还是网络处理身份验证？
- en: Is the identity of the caller passed along to each of the microservices or is
    it just lost at the gateway?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者的身份是否传递给每个微服务，还是仅在网关处丢失？
- en: What are the measures to ensure that SQL injection doesn't occur?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保不发生SQL注入的措施是什么？
- en: Is the system updated enough to store passwords in encrypted form?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统是否更新到足以以加密形式存储密码？
- en: If we need to upgrade any password storage algorithm, can it be done without
    mass disruption to users?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要升级任何密码存储算法，是否可以在不造成大规模中断用户的情况下进行？
- en: How is private and sensitive data handled in the system?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中如何处理私人和敏感数据？
- en: Can your logging solution detect and analyze security breaches?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的日志记录解决方案是否能够检测和分析安全漏洞？
- en: Middleware
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: 'The next level is our **middleware**. It''s the central place or starting point,
    where all services will pass through. We need to make sure that middleware is
    secured and cannot be exposed to any risk, as it has various parameters such as
    messaging middleware, database access configured, and so on:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个级别是我们的**中间件**。这是所有服务都将通过的中心位置或起点。我们需要确保中间件是安全的，不能暴露给任何风险，因为它有各种参数，如消息中间件、数据库访问配置等等：
- en: Do we have the least privilege principle (that is, single database login across
    all services)?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否遵循最小权限原则（即，跨所有服务只有一个数据库登录）？
- en: Does each service have access to only the data that it needs?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务只能访问它需要的数据吗？
- en: If an intruder gets access to service database credentials, how much data access
    will they get?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果入侵者获得了服务数据库凭据，他们将获得多少数据访问权限？
- en: Do we have a single messaging middleware across all services?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否在所有服务中都有一个单一的消息中间件？
- en: Does the messaging middleware or service bus have login credentials?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息中间件或服务总线是否有登录凭据？
- en: Does the legacy system put the microservice system at risk?
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统系统是否将微服务系统置于风险之中？
- en: API Gateway
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关
- en: 'The next level is our API Gateway. A gateway plays an important part in microservices
    as it is the starting point of any request and is used by all microservices as
    a means of communication between them. Hence, it should not be exposed to any
    other security vulnerabilities:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个级别是我们的API网关。网关在微服务中扮演着重要的角色，因为它是任何请求的起点，并且被所有微服务用作它们之间的通信手段。因此，它不应该暴露给任何其他安全漏洞：
- en: Is there a TLS implementation?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有TLS实现？
- en: Does the TLS implementation remove downgrade attacks or weak cipher attacks?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS实现是否消除了降级攻击或弱密码攻击？
- en: How do you make sure that internal websites and admin URLs are abstracted to
    the internet?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您如何确保内部网站和管理员URL被抽象到互联网上？
- en: What information is circulated through the authentication APIs of your gateway
    service?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过您的网关服务的身份验证API传播了哪些信息？
- en: Do the rest of the services trust the gateway too much or can they find out
    when the gateway is breached?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的服务是否过于信任网关，或者他们能否发现网关被攻破了？
- en: Team and operational activities
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队和运营活动
- en: 'The final phase is team and operational activities. Being distributed in nature,
    every team works independently. In this case, it becomes an essential prerequisite
    that each team has enough security training. The following questions help us to
    evaluate security at the operational level:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后阶段是团队和运营活动。由于分布式的性质，每个团队都是独立工作的。在这种情况下，每个团队都有足够的安全培训成为一个必要的先决条件。以下问题有助于我们评估运营层面的安全性：
- en: How are security activities baked in to every development team?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将安全活动融入到每个开发团队中？
- en: How do you ensure that everyone is aware of common security principles?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您如何确保每个人都了解常见的安全原则？
- en: What security training do you give to the team and do you update them regarding
    any vulnerabilities?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您给团队提供了什么安全培训，并且是否会及时更新他们的漏洞信息？
- en: What automation level do you use to ensure security controls are always in place?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用什么自动化级别来确保安全控制始终存在？
- en: In the next section, we will look at how we can harden the application and container,
    and go through various security best practices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何加固应用程序和容器，并了解各种安全最佳实践。
- en: Security best practices for individual services/applications
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个别服务/应用的安全最佳实践
- en: A microservice architecture shifts around complexity. Instead of having a single
    very complicated system, there are a bunch of simple services with complicated
    interactions. Our goal is to make sure that complexity stays in check and within
    boundaries. Security is really hard to get right. There are countless ways to
    break into an application. Node.js is no different. In this section, we are going
    to look at the techniques to prevent security vulnerabilities. This section is
    meant to act as a basic checklist to ensure that our microservice addresses some
    of the biggest security threats. So, let's get started.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构改变了复杂性。与单一的非常复杂的系统不同，有一堆简单的服务和复杂的交互。我们的目标是确保复杂性受到控制并在范围内。安全确实很难做到。有无数种方法可以侵入应用程序。Node.js也不例外。在本节中，我们将看看如何防止安全漏洞。本节旨在作为一个基本的检查表，以确保我们的微服务解决了一些最大的安全威胁。所以，让我们开始吧。
- en: Checking for known security vulnerabilities
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查已知的安全漏洞
- en: 'Due to a wealth of modules available in `npm`, we can directly work on the
    application and rely on the ecosystem for ready-made solutions. However, due to
    the huge modules, larger security vulnerabilities can occur at any time even for
    mature popular frameworks. In this section, we will look at some valuable tools
    that ensure no vulnerabilities are present in the packages that the application
    relies on, or even while updating:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`npm`中有大量的模块可用，我们可以直接在应用程序上工作，并依赖生态系统提供现成的解决方案。然而，由于庞大的模块，即使对于成熟的流行框架，也可能随时出现较大的安全漏洞。在本节中，我们将看看一些有价值的工具，以确保应用程序依赖的软件包中没有漏洞，甚至在更新时也没有漏洞：
- en: Auditjs
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Auditjs
- en: A simple utility that audits an `npm` project using the OSS index v2 REST API
    to identify known vulnerabilities and outdated package versions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的实用程序，使用OSS index v2 REST API对`npm`项目进行审计，以识别已知的漏洞和过时的软件包版本。
- en: 'Using this is very simple:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它非常简单：
- en: Install it as a `dev` dependency `npm install auditjs --save-dev`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其作为`dev`依赖项安装`npm install auditjs --save-dev`。
- en: 'Add audit scripts in the `npm` scripts:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`npm`脚本中添加审计脚本：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the `npm run audit` command. The full example can be seen in the extracted
    folder under the `chapter 10/auditjs` folder.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm run audit`命令。完整的示例可以在`chapter 10/auditjs`文件夹下的提取文件夹中看到。
- en: For more information you can visit the link [https://www.npmjs.com/package/auditjs](https://www.npmjs.com/package/auditjs) .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以访问链接[https://www.npmjs.com/package/auditjs](https://www.npmjs.com/package/auditjs)。
- en: Snyk.io
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Snyk.io
- en: 'This is another module that we can use to vet any modules against the vulnerability
    database maintained by `synk.io`. The major advantage of this module is that we
    do not need to install this for auditing. This module can be used as a pre-check
    before using any third-party module:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个模块，我们可以用来对抗`synk.io`维护的漏洞数据库中的任何模块进行审查。这个模块的主要优势是我们不需要安装它进行审计。这个模块可以在使用任何第三方模块之前作为预检查使用：
- en: Install it globally—`npm install snyk -g`
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局安装——`npm install snyk -g`
- en: Once installed, you will need to authenticate it by hitting `snyk auth`
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，您需要通过点击`snyk auth`来进行身份验证
- en: Once `snyk` is set up, you can now vet any module using `synk test <module_name>`
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设置好`snyk`，现在可以使用`synk test <module_name>`来审查任何模块
- en: For more information you can visit the link [https://www.npmjs.com/package/snyk](https://www.npmjs.com/package/snyk).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以访问链接[https://www.npmjs.com/package/snyk](https://www.npmjs.com/package/snyk)。
- en: 'The following are some useful commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有用的命令：
- en: '| `snyk wizard` | Finds and fixes known vulnerabilities in a project |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `snyk wizard` | 查找并修复项目中已知的漏洞 |'
- en: '| `snyk protect` | Applies patches and suppresses vulnerabilities |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `snyk protect` | 应用补丁并抑制漏洞 |'
- en: '| `snyk monitor` | Records the state of dependencies, so that whenever new
    vulnerabilities or patches are launched, we can be alerted |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `snyk monitor` | 记录依赖项的状态，因此每当推出新的漏洞或补丁时，我们都可以收到警报 |'
- en: 'Here is some further reading:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步阅读材料：
- en: There are lots of other modules available (we saw Node security earlier)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有许多其他可用的模块（我们之前看到了Node安全性）
- en: '`retire.js` ([https://retirejs.github.io/retire.js/](https://retirejs.github.io/retire.js/))
    is yet another module that does similar vulnerabilities checking, and it can even
    be used as a command-line scanner, `grunt`/`gulp` plugin, Chrome or Firefox extension,
    and so on'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retire.js`（[https://retirejs.github.io/retire.js/](https://retirejs.github.io/retire.js/)）是另一个执行类似漏洞检查的模块，甚至可以用作命令行扫描器、`grunt`/`gulp`插件、Chrome或Firefox扩展程序等。'
- en: Preventing brute force attacks or flooding by adding rate limiters
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过添加速率限制器来防止暴力攻击或洪水攻击
- en: Brute force attacks are common and often serve as a last resort for the hacker.
    They systematically enumerate all possible candidates for a solution and check
    whether each candidate satisfies the problems statement or not. To protect against
    this kind of attack, we have to implement some kind of rate limiting algorithm,
    which will effectively block an IP address from making an outrageous amount of
    requests, thus blocking the possibility of accidentally crashing the application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力攻击是常见的，通常作为黑客的最后手段。他们系统地枚举所有可能的解决方案，并检查每个候选解决方案是否满足问题陈述。为了防止这种攻击，我们必须实施某种速率限制算法，这将有效地阻止IP地址发出大量请求，从而阻止意外崩溃应用程序的可能性。
- en: You can find the rate-limiting implementation under the `Chapter 10/rate-limiter`
    folder, where we used the rate limiting algorithm with the Redis database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Chapter 10/rate-limiter`文件夹下找到速率限制的实现，我们在其中使用了与Redis数据库一起使用的速率限制算法。
- en: 'Now, let''s follow these steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤进行：
- en: 'Install `express-limiter` and `redis`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`express-limiter`和`redis`：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the redis client and set express-limiter:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建redis客户端并设置express-limiter：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, run the program. It will limit requests to `100` requests per hour, after
    which it will start to throw `429: Too Many Requests`.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在运行程序。它将限制每小时的请求次数为`100`次，之后将开始抛出`429: Too Many Requests`。'
- en: Protecting against evil regular expressions
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止恶意正则表达式
- en: 'One of the most commonly occurring vulnerabilities is a poorly formed regular
    expression. A regex, if it takes exponential time when applied to non-matching
    inputs, is termed an evil regex and should be prevented. An evil regex contains
    groupings with repetitions, alterations with overlappings, and words inside the
    repeated group. Let''s look at an example, `Regex : (b+)+, ([a-zA-Z]+)*,(a|aa)+`,
    and so on.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '最常见的漏洞之一是格式不正确的正则表达式。如果正则表达式在应用于非匹配输入时花费指数时间，则被称为恶意正则表达式，应该予以防止。恶意正则表达式包含具有重复的分组、具有重叠的替换和重复组内的单词。让我们看一个例子，`Regex
    : (b+)+, ([a-zA-Z]+)*,(a|aa)+`，等等。'
- en: All these regexes are exposed to input `bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb!`.
    These repetitions can be a hindrance as it may take seconds or even minutes to
    complete. Due to the event loop of Node.js, the execution won't go ahead, which
    will effectively result in the server freezing as the application is completely
    stopped from running. To prevent such disasters, we should use the safe-regex
    tool ([https://www.npmjs.com/package/safe-regex](https://www.npmjs.com/package/safe-regex)).
    It detects potentially catastrophic exponential time regular expressions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些正则表达式都暴露给输入`bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb!`。这些重复可能会成为障碍，因为可能需要几秒甚至几分钟才能完成。由于Node.js的事件循环，执行不会继续进行，这将有效地导致服务器冻结，因为应用程序完全停止运行。为了防止这样的灾难，我们应该使用safe-regex工具（[https://www.npmjs.com/package/safe-regex](https://www.npmjs.com/package/safe-regex)）。它可以检测潜在的灾难性指数时间正则表达式。
- en: You can check the source code in the `safe-regex` folder. You can check the
    regex by just typing `node safe.js '<whatever-my-regex>'`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`safe-regex`文件夹中查看源代码。您可以通过输入`node safe.js '<whatever-my-regex>'`来检查正则表达式。
- en: Blocking cross-site request forgeries
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻止跨站点请求伪造
- en: A common way to intrude in an application is by putting data into the application
    via unsafe sites through a common phishing technique known as cross-site request
    forgery. An intruder making a phishing attempt can initiate a request via a form
    or other input that creates a request for an application through inputs exposed
    by the application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 入侵应用程序的常见方法是通过不安全的站点将数据输入应用程序，通过一种称为跨站点请求伪造的常见网络钓鱼技术。试图进行网络钓鱼的入侵者可以通过表单或其他输入发起请求，通过应用程序暴露的输入创建应用程序的请求。
- en: To harden the application against this kind of attack, we can use CSRF token
    implementation. Every time a user makes a request, a new CSRF token is generated
    and added to the user's cookie. This token should be added as a value to the inputs
    in an applications template and this will be validated against the token the CSRF
    library generates when the user sends information. NPM provides the `csurf` module
    ([https://www.npmjs.com/package/csurf](https://www.npmjs.com/package/csurf)),
    which can be used in express middleware directly and we can play accordingly with
    the `csurf` token.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强应用程序对这种攻击的防范，我们可以使用CSRF令牌实现。每当用户发出请求时，都会生成一个新的CSRF令牌并添加到用户的cookie中。此令牌应添加为应用程序模板中输入的值，并将根据用户发送信息时CSRF库生成的令牌进行验证。NPM提供了`csurf`模块（[https://www.npmjs.com/package/csurf](https://www.npmjs.com/package/csurf)），可以直接在express中间件中使用，并且我们可以根据`csurf`令牌进行相应操作。
- en: Tightening session cookies and effective session management
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加强会话cookie和有效的会话管理
- en: 'The focus of the secure use of cookies cannot be understated in an application.
    This especially applies to stateful services that need to maintain a state across
    a stateless protocol such as HTTP. Express has a default cookie setting that can
    be configured or manually tightened to enhance security. There are various options:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，安全使用cookie的重要性不容忽视。这尤其适用于需要在无状态协议（如HTTP）中保持状态的有状态服务。Express具有默认的cookie设置，可以进行配置或手动加强以增强安全性。有各种选项：
- en: '`secret`: A secret string with which the cookie has to be salted.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secret`：cookie必须用其盐化的秘密字符串。'
- en: '`name`: Name of the cookie.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：cookie的名称。'
- en: '`httpOnly`: This basically flags cookies, so that they can be accessible by
    issuing a web server in order to prevent session hijacking.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpOnly`：基本上标记cookie，以便它们可以被发出web服务器访问，以防止会话劫持。'
- en: '`secure`: This requires TLS/SSL to allow a cookie to be used only in HTTPS
    requests.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secure`：这要求TLS/SSL，以便cookie仅在HTTPS请求中使用。'
- en: '`domain`: This indicates specific domains only, from which the cookie can be
    accessed.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`：这表示只能从中访问cookie的特定域。'
- en: '`path`: The path cookie is accepted from an application''s domain.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：从应用程序域接受cookie的路径。'
- en: '`expires`: The expiration date of the cookie that is being set. If a timely
    expiration is not available, the resource consumption will be very high and resources
    will never be freed.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expires`：正在设置的cookie的到期日期。如果没有及时的到期日期，资源消耗将非常高，资源将永远不会被释放。'
- en: 'In the following example, we will securely set cookies using express-session
    and thus have effective session management. You can follow along with the example
    under `typescript-express-session`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将使用express-session安全地设置cookie，从而实现有效的会话管理。您可以在`typescript-express-session`下跟着例子进行：
- en: Clone `first-microservice` from [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing
    up for the Journey*, and install `express-session` and `@types/express-session`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)克隆`first-microservice`，并安装`express-session`和`@types/express-session`。
- en: 'In `express.ts`, add the following code, which will make our application use
    cookies with the following secured parameters:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`express.ts`中添加以下代码，这将使我们的应用程序使用具有以下安全参数的cookie：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This module effectively helps us to handle stateful sessions by providing various
    options, such as cookie flags, cookie scopes, and so on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块有效地帮助我们通过提供各种选项（如cookie标志、cookie范围等）来处理有状态的会话。
- en: Adding helmet to configure security headers
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加helmet以配置安全标头
- en: 'The `helmet` module ([https://www.npmjs.com/package/helmet](https://www.npmjs.com/package/helmet))
    is a collection of 11 security modules that prevents a varying number of attacks
    against an express microservice. It''s easy to use, as we just have to add two
    lines of code. Adding some basic configurations can help to protect the application
    against possible security mishaps. You can use helmet by simply adding:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`helmet`模块（[https://www.npmjs.com/package/helmet](https://www.npmjs.com/package/helmet)）是一个包含11个安全模块的集合，可以防止针对express微服务的各种攻击。它很容易使用，我们只需添加两行代码。添加一些基本配置可以帮助保护应用程序免受可能的安全意外。您可以通过简单添加helmet来使用：'
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The source code for this can be found in `chapter-10/typescript-express-session`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可以在`chapter-10/typescript-express-session`中找到。
- en: The `helmet` module has a whopping 12 packages that act as some middleware to
    block malicious parties from breaking or using an application. These headers include
    headers for `helmet-csp` (headers for content security policy HTTP header), `dns-prefetch`
    protocols, `frameguards`, `hide-powered-by`, `hpkp`, `hsts`, `ienoopen`, `nocache`,
    `dont-sniff-mimetype`, `referrer-policy`, `x-xss protections`, `frameguard` to
    prevent `clickjackings`, and so on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`helmet`模块有12个包，作为一些中间件来阻止恶意方破坏或使用应用程序。这些标头包括`helmet-csp`（内容安全策略HTTP标头的标头）、`dns-prefetch`协议、`frameguards`、`hide-powered-by`、`hpkp`、`hsts`、`ienoopen`、`nocache`、`dont-sniff-mimetype`、`referrer-policy`、`x-xss
    protections`、`frameguard`以防止`clickjackings`等。'
- en: Another option for securing headers is `lusca` ([https://www.npmjs.com/package/lusca](https://www.npmjs.com/package/lusca)),
    which can be used in combination with express-session. An example can be found
    in the `chapter-10 /express-lusca` directory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 保护标头的另一个选项是`lusca`（[https://www.npmjs.com/package/lusca](https://www.npmjs.com/package/lusca)），可以与express-session结合使用。示例可以在`chapter-10/express-lusca`目录中找到。
- en: Avoiding parameter pollution
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免参数污染
- en: In Node.js, if there are no defined standards for handling multiple parameters
    of the same name, the de facto standard is to treat those values as an array.
    This is extremely useful because for a single name when the expected outcome is
    a string, it types changes to an array if multiple parameters with the same name
    are passed. If this isn't accounted for in query handling, the application will
    crash and bring the whole thing down, making this a possible DoS vector. For example,
    check this link: `http://whatever-url:8080/my-end-point?name=parth&name=ghiya`.
    [](http://whatever-url:8080/my-end-point?name=parth&name=ghiya)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，如果没有为处理相同名称的多个参数定义标准，那么事实上的标准是将这些值视为数组。这非常有用，因为对于单个名称，如果预期结果是字符串，那么如果传递了具有相同名称的多个参数，则类型将更改为数组。如果在查询处理中没有考虑到这一点，应用程序将崩溃并使整个系统崩溃，从而成为可能的DoS向量。例如，检查此链接：`http://whatever-url:8080/my-end-point?name=parth&name=ghiya`。[](http://whatever-url:8080/my-end-point?name=parth&name=ghiya)
- en: 'Here, when we try to read `req.query.name`, we expect it to be a string, but
    instead we get an array, `[''parth'',''ghiya'']`, which will bring down the application
    if not handled with care. To ensure that the application won''t fail you, we can
    do the following things:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当我们尝试读取`req.query.name`时，我们期望它是一个字符串，但实际上我们得到的是一个数组，`['parth'，'ghiya']`，如果不小心处理，这将使应用程序崩溃。为了确保应用程序不会失败，我们可以做以下事情：
- en: Various policies implement polluting mechanisms differently; for example, some
    may take the first occurrence, some may take the last occurrence
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种策略以不同的方式实现污染机制；例如，有些可能采用第一次出现，有些可能采用最后一次出现
- en: Use TypeScript types to validate the request. If the types fail, stop the request
    by giving parameters errors
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TypeScript类型来验证请求。如果类型失败，通过提供参数错误来停止请求
- en: Ensure that parameters in HTTP GET, PUT, or POST are encoded.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保对HTTP GET、PUT或POST中的参数进行编码。
- en: Strict Regexp must be followed in URL rewriting.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL重写必须遵循严格的正则表达式。
- en: You can check the complete list and how it is handled at [https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004)](https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004)](https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004))上查看完整列表以及如何处理。
- en: Securing transmission
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输安全
- en: 'If an application has any moving parts (HTTP methods such as POST, PUT, and
    DELETE) that include anything right from logging or sending a tweet which mutates
    the information from the client, using HTTPs is a vital implementation to make
    sure that the information isn''t modified in mid-transit. Cost can be an easy
    excuse for not investing in an SSL certificate. But now there are new, completely
    free, SSL certificate resources, such as **Let''s Encrypt** ([https://letsencrypt.org/](https://letsencrypt.org/)).
    Also, a Node.js application should not be directly exposed to the internet and
    SSL termination should be handled prior to the request coming to Node.js. Using
    NGINX to do this is a highly recommended option, as it is specially designed to
    terminate SSL more efficiently than Node.js. To effectively set an express application
    behind a proxy, refer to this: [http://expressjs.com/en/4x/api.html#trust.proxy.options.table](http://expressjs.com/en/4x/api.html#trust.proxy.options.table).
    Once the HTTP is set up, we can use `nmap`, `sslyze`, or `OpenSSL` to test HTTP
    certificate transmission.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序有任何移动部分（如POST、PUT和DELETE等HTTP方法），包括从客户端记录或发送推文等会改变信息的操作，使用HTTPs是确保信息在传输过程中不被修改的重要实施。成本可能是不投资SSL证书的一个简单借口。但现在有新的、完全免费的SSL证书资源，比如**Let's
    Encrypt**（[https://letsencrypt.org/](https://letsencrypt.org/)）。此外，Node.js应用程序不应直接暴露在互联网上，SSL终止应在请求到达Node.js之前处理。使用NGINX来做这个是一个非常推荐的选择，因为它专门设计用于比Node.js更有效地终止SSL。要有效地将express应用程序设置在代理后面，请参考此链接：[http://expressjs.com/en/4x/api.html#trust.proxy.options.table](http://expressjs.com/en/4x/api.html#trust.proxy.options.table)。一旦HTTP设置好了，我们可以使用`nmap`、`sslyze`或`OpenSSL`来测试HTTP证书传输。
- en: Preventing command injection/SQL injection
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止命令注入/SQL注入
- en: 'An injection attack can occur when an intruder sends text-based attacks that
    exploit the syntax of an interpreter. SQL injection consists of the injection
    of a partial or complete SQL query through user input, which can expose sensitive
    information and can be destructive as well. Similarly, command injection is a
    technique that can be used by an attacker to run OS commands on a remote web server.
    Through this approach, even passwords can be exposed. To filter against these
    kinds of attack, we should always filter and sanitize user inputs. Using JavaScript
    statements such as eval is also another way to opens up a door to injection attacks.
    To prevent these attacks, we can use `node-postgres` if you are using `postgres`
    ([https://www.npmjs.com/package/pg](https://www.npmjs.com/package/pg)), which
    provides positional query parameters. Common techniques to defend against injection
    include the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击可能发生在入侵者发送利用解释器语法的基于文本的攻击时。SQL注入包括通过用户输入注入部分或完整的SQL查询，这可能会暴露敏感信息，也可能具有破坏性。同样，命令注入是攻击者在远程Web服务器上运行OS命令的一种技术。通过这种方法，甚至密码也可能会被暴露。为了防范这些攻击，我们应该始终过滤和清理用户输入。使用`eval`等JavaScript语句也是注入攻击的另一种方式。为了防止这些攻击，如果你使用`postgres`，可以使用`node-postgres`（[https://www.npmjs.com/package/pg](https://www.npmjs.com/package/pg)），它提供了位置查询参数。防御注入的常见技术包括以下内容：
- en: To escape SQL injection, one of the techniques that can be used is escaping
    user input. Many libraries provide this out of the box.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免SQL注入，可以使用一种技术来转义用户输入。许多库都提供了这个功能。
- en: Parameterizing SQL queries is another way to avoid SQL injection, where you
    create a using positional query parameters and fill in the positional query parameters
    with values.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化SQL查询是避免SQL注入的另一种方法，其中你使用位置查询参数创建一个查询，并用值填充位置查询参数。
- en: '`eval()` with user input is one of the ways to inject commands and should not
    be used at all (in the next section, we will write a `linter`, which will avoid
    this).'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eval()`与用户输入是注入命令的一种方式，根本不应该使用（在下一节中，我们将编写一个`linter`，它将避免这种情况）。'
- en: Similarly, the express application is vulnerable to MongoDB attacks. Not explicitly
    setting the query selector will result in our data being vulnerable to a simple
    query.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，express应用程序容易受到MongoDB攻击。如果不明确设置查询选择器，我们的数据将容易受到简单查询的攻击。
- en: 'We have `db.users.find({user: user, pass: pass})`, where `user` and `pass`
    are coming from a POST request body. Now being type-less, we can simply pass query
    parameters inside this query, such as `{"user": {"$gt": ""},"pass": {"$gt": ""}}`,
    which will return all users along with their passwords. To resolve this, we need
    to explicitly pass the query selector, which will make our query `db.users.find({user:
    { $in: [user] }, pass: { $in: [pass] }})`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '我们有`db.users.find({user: user, pass: pass})`，其中`user`和`pass`来自POST请求体。现在，由于没有类型，我们可以简单地在这个查询中传递查询参数，比如`{"user":
    {"$gt": ""},"pass": {"$gt": ""}}`，这将返回所有用户及其密码。为了解决这个问题，我们需要明确传递查询选择器，这将使我们的查询变为`db.users.find({user:
    { $in: [user] }, pass: { $in: [pass] }})`。'
- en: TSLint/static code analyzers
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSLint/静态代码分析器
- en: 'In this section, we will look at one of the ways to analyze all the written
    code and check it against a list of security vulnerabilities. We will include
    this as one of the stages of our deployment plan. We will write a `linter`, have
    a `.tslint` file where all the rules to be checked against are mentioned, and
    then we will run the lint. So, let''s get started. **TsLint** is one way to check
    and validate the source code. It is a static analysis code tool that runs on Node.js
    in order to keep your source code clean, find possible bugs, uncover security
    issues, and enforce a consistent style across all your teams:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一种分析所有编写的代码并根据安全漏洞列表进行检查的方法之一。我们将把这作为我们部署计划的一个阶段。我们将编写一个`linter`，有一个`.tslint`文件，其中提到了要检查的所有规则，然后我们将运行lint。所以，让我们开始吧。**TsLint**是一种检查和验证源代码的方法。它是一个静态分析代码工具，运行在Node.js上，以保持您的源代码清洁，找到可能的错误，发现安全问题，并强制执行所有团队的一致风格：
- en: 'Clone our `first-typescript-microservices` from [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing
    up for the Journey* and inside it, add the following commands:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)中克隆我们的`first-typescript-microservices`，*为旅程做准备*，并在其中添加以下命令：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we will write `tslint.json` with the basic rules that we want to evaluate
    it against. Copy the rules from [https://github.com/Microsoft/tslint-microsoft-contrib/blob/master/recommended_ruleset.js](https://github.com/Microsoft/tslint-microsoft-contrib/blob/master/recommended_ruleset.js).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`tslint.json`，其中包含我们要根据的基本规则。从[https://github.com/Microsoft/tslint-microsoft-contrib/blob/master/recommended_ruleset.js](https://github.com/Microsoft/tslint-microsoft-contrib/blob/master/recommended_ruleset.js)复制规则。
- en: 'Next, we will write an initialization script:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个初始化脚本：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can now leverage this script anywhere because when we run this, it will throw
    an output of all the errors found while evaluating against that rule set.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在任何地方利用这个脚本，因为当我们运行它时，它将输出所有根据该规则集评估时发现的错误。
- en: We can add a `--fix` flag in the preceding script, which will automatically
    take the necessary measures in most cases.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在前面的脚本中添加一个`--fix`标志，这将在大多数情况下自动采取必要的措施。
- en: You can find the source code under the `chapter 10/tslinter` folder. In this
    section, we looked at some of the things that need to be done when hardening our
    application against all sorts of possible attacks. In the next section, we will
    have a look at some of the container-level securities that can be applied.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`第10章/tslinter`文件夹下找到源代码。在本节中，我们看了一些在加固我们的应用程序针对各种可能的攻击时需要做的事情。在下一节中，我们将看一些可以应用的容器级安全性。
- en: Security best practices for containers
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的安全最佳实践
- en: With the advent of containers, cloud-native applications and infrastructure
    need quite a different approach to security. Let's have a look at the best practices.
    This is the age of the **cloud-native** approach. The cloud-native approach refers
    to a process that packages software in standard units called containers and arranges
    these units in microservices that communicate with each other to form applications.
    It ensures that running applications are fully automated for the greater good—standard
    speed, agility, and scalability. Let's look at the security considerations that
    need to be addressed to have a comprehensive security program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随着容器的出现，云原生应用程序和基础设施需要一种完全不同的安全方法。让我们看看最佳实践。这是**云原生**方法的时代。云原生方法是指将软件打包成称为容器的标准单元，并将这些单元排列成相互通信的微服务，以形成应用程序的过程。它确保运行的应用程序完全自动化，以实现更大的好处-标准速度、灵活性和可伸缩性。让我们看看需要解决的安全考虑，以建立一个全面的安全计划。
- en: Securing container builds and standardizing deployments
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护容器构建和标准化部署
- en: 'This phase focuses on applying control to developer workflows and continuous
    integration and deployment pipelines to mitigate the security issues that may occur
    after containers have been launched. Here is the standard set of practices:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段侧重于对开发人员工作流程和持续集成和部署流水线应用控制，以减轻容器启动后可能发生的安全问题。以下是标准的实践方法：
- en: Apply a single responsibility rule even at the container level. A container
    image should only have the essential software and application code needed to minimize
    the attack surface of every container launched from the image.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在容器级别，也要应用单一责任规则。容器图像应该只包含启动每个容器所需的基本软件和应用程序代码，以最小化攻击面。
- en: Images should be scanned for known vulnerabilities and exposures. There is a
    common vulnerabilities and exposure database (just like the application level)
    on which we can validate the image ([https://github.com/arminc/clair-scanner](https://github.com/arminc/clair-scanner)).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应扫描已知漏洞和曝光的图像。我们可以在其中验证图像的公共漏洞和曝光数据库（就像应用程序级别一样）。
- en: Once images are built, they should be digitally signed. **Signing images** ([https://docs.docker.com/datacenter/dtr/2.4/guides/user/manage-images/sign-images/#initialize-the-trust-metadata](https://docs.docker.com/datacenter/dtr/2.4/guides/user/manage-images/sign-images/#initialize-the-trust-metadata))
    with private keys provides assurances that each image used to launch a container
    was created by a trusted party.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建图像后，应进行数字签名。使用私钥对图像进行签名提供了确保每个用于启动容器的图像都是由受信任方创建的保证。
- en: As containers running on a host share the same OS, it is of utmost importance
    that they start with a restricted set of capabilities. Use modules such as SELinux.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在主机上运行的容器共享相同的操作系统，因此它们以受限的能力集开始是非常重要的。使用诸如SELinux之类的模块。
- en: Use secret management techniques (a technique through which secrets such as
    sensitive data are only distributed to the containers that use them when they
    need them).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用秘密管理技术（一种通过该技术只在需要时将秘密（如敏感数据）分发给使用它们的容器的技术）。
- en: Securing containers at runtime
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时保护容器
- en: 'For runtime phase security, we need to check the following things—visibility,
    detection, response, prevention, stopping containers that violate policies, and
    so on. Here are some of the important factors that need to be taken care of:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行时阶段的安全性，我们需要检查以下事项——可见性、检测、响应、预防、停止违反政策的容器等。以下是需要注意的一些重要因素：
- en: Analyze microservice and containers behavior
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析微服务和容器的行为
- en: Relate distributed threat indicators, and ascertain whether a single container
    is contaminated or it is spread across many containers
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联分布式威胁指标，并确定单个容器是否被污染，或者它是否传播到许多容器中
- en: Intercept to block unauthorized container engine commands
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拦截以阻止未经授权的容器引擎命令
- en: Automate actions for responses
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化响应操作
- en: These are some of the essentials we need to do to ensure that our containers
    are safe against any vulnerabilities. In the next section, we will see a general
    checklist that can be used during our overall microservice development phase.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要做的一些基本工作，以确保我们的容器不受任何漏洞的影响。在下一节中，我们将看到一个可以在整个微服务开发阶段使用的一般清单。
- en: Security checklist
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全清单
- en: Microservices development is a platform of standard tools combined with lots
    of supporting tools and everything is on the move. In this section, we will look
    at an overall checklist, which we can use to validate our development, or which
    can give us a general idea of our microservice development.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务开发是一组标准工具和大量支持工具的平台，一切都在不断变化。在这一部分，我们将看一下一个总体清单，我们可以用它来验证我们的开发，或者它可以给我们一个关于我们微服务开发的一般想法。
- en: Service necessities
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务必需品
- en: 'The first and primary level of development is individual microservice development,
    satisfying some business capability. The following a checklist can be used while
    developing microservices:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 开发的第一和主要级别是个体微服务开发，满足一些业务能力。在开发微服务时可以使用以下清单：
- en: Services should be developed and deployed independently
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务应该独立开发和部署
- en: Services should not have shared data; they should have their own private data
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务不应该有共享数据；它们应该有自己的私有数据
- en: Services should be small enough that they are focused and can add big value
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务应该足够小，以便专注并能够提供巨大价值
- en: Data should be stored in databases and service instances should not be stored
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据应该存储在数据库中，服务实例不应该被存储
- en: Work should be offloaded to asynchronous workers whenever possible
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能将工作卸载到异步工作者
- en: Load balancers should be introduced to distribute work
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该引入负载均衡器来分发工作
- en: Security should be layered and we don't need to reinvent the wheel; for example,
    OAuth can be used to maintain user identity and access control
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全应该是分层的，我们不需要重新发明轮子；例如，OAuth可以用来维护用户身份和访问控制
- en: Security updates should be automated
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全更新应该是自动化的
- en: A distributed firewall with centralized control should be used (such as Project
    Calico)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用具有集中控制的分布式防火墙（如Project Calico）
- en: Monitoring tools, such as Prometheus, should be used
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用监控工具，比如Prometheus
- en: Security scanners should be used for containers
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该为容器使用安全扫描器
- en: Service interactions
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务交互
- en: 'The next level is communication among microservices. When microservices communicate
    among themselves, a checklist should be followed. This checklist helps to ensure
    that if any service fails, then the failure is contained and it doesn''t spread
    through the entire system:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个级别是微服务之间的通信。当微服务相互通信时，应该遵循一个清单。这个清单有助于确保如果任何服务失败，那么失败是被包含的，不会传播到整个系统：
- en: Data should be transported in a serialized format, such as JSON or protobuf
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据应该以序列化格式传输，比如JSON或protobuf
- en: Error codes should be used carefully and actions should be taken accordingly
    on them.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该谨慎使用错误代码，并相应地采取行动。
- en: APIs should be simple, effective, and the contract should be clear
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API应该简单、有效，并且合同应该清晰
- en: A service discovery mechanism should be implemented to find other services easily
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该实施服务发现机制以便轻松找到其他服务
- en: Decentralized interactions over centralized orchestrators should be preferred
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分散的交互优于集中的编排器
- en: APIs should be versioned
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API应该有版本
- en: Circuit breakers help to stop the error propagating throughout the entire system
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器有助于阻止错误在整个系统中传播
- en: Service interactions should only be through exposed endpoints
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务交互应该只通过公开的端点
- en: Authenticating all APIs and passing them through middleware gives a clearer
    picture of usage patterns
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对所有API进行身份验证并通过中间件传递，可以更清晰地了解使用模式
- en: Connection pools can reduce downstream impacts instead of sudden request spikes
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接池可以减少突然请求激增的下游影响
- en: Development phase
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发阶段
- en: 'The next phase to take care of is during development. This checklist adheres
    to the 12 factor standards. The following checklist is of development standards,
    which help in a smoother development process:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要注意的是开发过程。这个清单遵循12个因素的标准。以下是开发标准的清单，有助于更顺畅的开发过程：
- en: A common source code control platform should be used
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用一个共同的源代码控制平台
- en: There should be separate prod environment
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有单独的生产环境
- en: A release less, release it faster principle should be followed
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该遵循无发布，快速发布的原则
- en: Shared libraries are painful to maintain
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享库很难维护
- en: Simple services are easy to replace
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的服务易于替换
- en: Deployment
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'The deployment checklist focuses on the deployment era. It indicates how containers
    and images help in quicker deployments. It advises on key values and property
    configurations to manage deployments in different environments:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 部署清单侧重于部署时代。它指示容器和图像如何帮助更快地部署。它建议关键值和属性配置来管理不同环境中的部署：
- en: Images and containers should be used
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用图像和容器
- en: Configure a mechanism to deploy any version of any service on any environment
    (CI/CD plus proper Git branches and tags)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一个机制，可以在任何环境中部署任何服务的任何版本（CI/CD加适当的Git分支和标签）
- en: Configuration should be managed outside the deployment package, such as environment
    variables, key-value stores, external URL links, and so on
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置应该在部署包之外进行管理，例如环境变量、键值存储、外部URL链接等。
- en: Operations
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: 'The operational checklist contains a list of best practices to be done at an
    operational level to make the after-release life of a system easy. It advises
    using centralized logs, monitoring software, and more. It shows how automation
    can make life easier:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运营清单包含在运营级别执行的最佳实践清单，以使系统在发布后的生活更加轻松。它建议使用集中日志、监控软件等。它展示了自动化如何可以使生活更轻松：
- en: All logs should be in one place (ELK stack)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有日志应该放在一个地方（ELK堆栈）。
- en: A common monitoring platform for all services
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有服务的常见监控平台
- en: Stateless services can easily be autoscaled, as we don't have to replicate the
    session everywhere
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态服务可以轻松进行自动扩展，因为我们不必在所有地方复制会话。
- en: Automation is the key to quick development
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化是快速开发的关键。
- en: That's pretty much it! In the next section, we will cover scalability and look
    at some of the scalability tools available before concluding the book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上就是这样！在下一节中，我们将介绍可伸缩性，并查看一些可用的可伸缩性工具，然后结束本书。
- en: Scalability
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Today, in the world of competitive marketing, an organization's key point is
    to have their system up and running. Any failure or downtime directly impacts
    business and revenue; hence, high availability is a factor that cannot be overlooked.
    Day by day, the mountain of information is growing thanks to the in-depth use
    of technology and the numerous ways we use it. Because of this, load average goes
    beyond the roof. Day by day, data is growing exponentially.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，在竞争激烈的营销世界中，一个组织的关键点是让他们的系统正常运行。任何故障或停机直接影响业务和收入；因此，高可用性是一个不容忽视的因素。由于技术的深度使用和我们使用技术的多种方式，每天信息量不断增加。因此，负载平均值超过了预期。每天，数据呈指数增长。
- en: In some cases, it is unpredictable that data cannot exceed up to some limit
    or a variety of users won't depart out of bounds. Scalability is a preferable
    solution to handle and meet unexpected demands at any point in time. Scalability
    can scale horizontally (we scale by adding more machines to a pool of resources)
    and vertically (we scale by adding more CPU/RAM to an existing machine). In terms
    of data, spanning database and loads of application queries over multiple servers.
    We can add instances in order to handle load, descale after period of time, and
    so on. It is easy to add horsepower to the cluster to handle the load. Cluster
    servers instantly handle failures and manage the failover part to keep your system
    available almost all the time. If one server goes down, it will redirect the user's
    request to another node and perform the requested operation. In this section,
    we will look at two of the most famous tools—Kubernetes and the AWS Load Balancer.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，数据不能超过某个限制或者各种用户不会超出边界是不可预测的。可伸缩性是处理和满足任何时间点的意外需求的首选解决方案。可伸缩性可以水平扩展（通过向资源池添加更多机器来扩展）和垂直扩展（通过向现有机器添加更多CPU/RAM来扩展）。在数据方面，跨数据库和多台服务器上的应用程序查询。我们可以添加实例来处理负载，在一段时间后进行缩减等。向集群添加计算能力以处理负载是很容易的。集群服务器可以立即处理故障并管理故障转移部分，以使系统几乎始终可用。如果一个服务器宕机，它将重定向用户的请求到另一个节点并执行请求的操作。在本节中，我们将介绍两个最著名的工具——Kubernetes和AWS负载均衡器。
- en: AWS Load Balancer
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS负载均衡器
- en: 'For load balancing, we should understand **Amazon Web Services Elastic Load
    Balancer** (**ELB**), which can help us to leverage load balancing. We should
    understand AWS ELB specifically; however, most of the concepts remain the same
    for the rest of the load balancing alternatives available. There are various alternatives
    available to achieve load balancing. A few of them are HAProxy, Apache Web Server,
    NGINX Http server, Pound, Google Cloud Load balancing, F5 Load Balancer, Barracuda
    Load Balancer, and many more. In general, the following is the architecture that
    depicts the flow of load balancing:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于负载平衡，我们应该了解**亚马逊网络服务弹性负载均衡器**（**ELB**），它可以帮助我们实现负载均衡。我们应该特别了解AWS ELB；然而，对于其他可用的负载平衡替代方案，大部分概念仍然是相同的。有各种可用的替代方案来实现负载平衡。其中一些是HAProxy、Apache
    Web服务器、NGINX Http服务器、Pound、Google Cloud负载均衡、F5负载均衡器、Barracuda负载均衡器等。一般来说，以下是描述负载平衡流程的架构：
- en: '![](img/6894138b-b329-4769-9f88-717f6ab46e70.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6894138b-b329-4769-9f88-717f6ab46e70.png)'
- en: Load balancer
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器。
- en: An ELB is one of the many available AWS services, which works to distribute
    incoming network traffic or application traffic to EC2 instances available in
    the network automatically. ELB also keeps an eye on the health of EC2 instances
    to provide high availability for the application by automatically adding or removing
    EC2 instances. It sends traffic only to instances that are available and in a
    healthy state. You can also configure ELB for internal load balancing or public-facing
    load balancing. ELB it becomes the face of the EC2 instances running behind wherever
    your application resides. Depending on the status or availability of the instances,
    a health check would mark it as either `InService`—if it's in a healthy state,
    or `OutOfService`—if it's in an unhealthy state. The load balancer would route
    traffic only to instances that are healthy. With the help of this health check,
    a load balancer provides us with a fault tolerant proof application and ensures
    the application's high availability 24/7, based on our configured parameters (high
    traffic, high resource utilization, and so on).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ELB是AWS提供的众多服务之一，它可以自动将传入的网络流量或应用程序流量分发到网络中可用的EC2实例。ELB还会监视EC2实例的健康状况，通过自动添加或删除EC2实例来为应用程序提供高可用性。它只会将流量发送到可用且健康的实例。您还可以配置ELB进行内部负载均衡或面向公众的负载均衡。ELB成为了应用程序所在的地方后面运行的EC2实例的面孔。根据实例的状态或可用性，健康检查会将其标记为“InService”——如果它处于健康状态，或“OutOfService”——如果它处于不健康状态。负载均衡器只会将流量路由到健康的实例。借助这种健康检查，负载均衡器为我们提供了一个容错的应用程序，并根据我们配置的参数（高流量、高资源利用率等）确保应用程序全天候的高可用性。
- en: Benefits of using a load balancer
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用负载均衡器的好处
- en: A load balancer helps us to provide a fault tolerant application, much better
    high availability, flexibility to the application, and security too, as we wouldn't
    be exposing backend systems directly to the user. Let's have a quick glance at
    some of the benefits of having a load balancer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器帮助我们提供一个容错的应用程序，更好的高可用性，应用程序的灵活性，以及安全性，因为我们不会直接将后端系统暴露给用户。让我们快速浏览一下拥有负载均衡器的一些好处。
- en: Fault tolerance
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容错性
- en: A load balancer helps to monitor the health of the backend instances. If one
    of the instances is unavailable, it would be marked as unavailable. Similarly,
    if the instances are healthy, it would be available to serve the requests. Traffic
    would be routed only to available healthy instances. This provides a fault tolerant
    application so the traffic reaching the application is not affected when we have
    unavailable instances in the backend. However, if none of your systems are unavailable
    in the backend to serve requests, the load balancer marks all the instances as
    unhealthy and users will be affected by an unavailable application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器有助于监视后端实例的健康状况。如果其中一个实例不可用，它将被标记为不可用。同样，如果实例健康，它将可用于处理请求。流量只会路由到可用的健康实例。这提供了一个容错的应用程序，因此当后端有不可用的实例时，到达应用程序的流量不会受到影响。然而，如果后端没有系统不可用来处理请求，负载均衡器会将所有实例标记为不健康，用户将受到不可用应用程序的影响。
- en: High availability
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高可用性
- en: What if we have an application running without a load balancer? If the number
    of requests to the application increases, our instances might not be able to handle
    the load of the requests and the performance of the application would deteriorate.
    Not only this, it might also affect the availability of the application. If we
    have a load balancer, it can route the traffic based on a round-robin method to
    all the instances and can easily distribute the load across the instances. This
    helps to overcome a situation of high availability and not restricting limited
    instances to be flooded with unexpected spikes, which might impact the business.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有负载均衡器运行的应用程序呢？如果对应用程序的请求数量增加，我们的实例可能无法处理请求的负载，应用程序的性能会下降。不仅如此，这也可能影响应用程序的可用性。如果我们有一个负载均衡器，它可以根据轮询方法将流量路由到所有实例，并可以轻松地分配负载到各个实例。这有助于克服高可用性的情况，不限制有限的实例被意外的高峰所淹没，这可能会影响业务。
- en: Flexibility
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活性
- en: Although we discussed fault tolerance and high availability with presumed instances,
    our requests might go beyond the expected limit of the application. In fact, they
    can be below the limit as well. Either of these may lead to a business loss in
    terms of the additional cost of running instances or degraded application performance.
    To manage either of these scenarios, many load balancers, especially in public
    clouds such as AWS ELB, Google Cloud Load Balancing, and a few more, provide the
    flexibility to have the auto-scaling of instances based on certain criteria, such
    as memory or CPU utilization, which can, add or remove a number of instances in
    the load balancer when it scales up or down. Load balancing with such features
    helps to ensure that we manage unexpected spikes of either high or low efficiency.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们讨论了容错性和高可用性，但我们的请求可能超出了应用程序的预期限制。事实上，它们也可能低于限制。其中任何一种情况都可能导致业务损失，无论是额外运行实例的成本还是降低的应用程序性能。为了管理这些情况，许多负载均衡器，特别是在AWS
    ELB、Google Cloud Load Balancing等公共云中，提供了根据特定标准（如内存或CPU利用率）自动扩展实例的灵活性，当它扩展或缩减时，可以增加或删除负载均衡器中的实例数量。具有这些功能的负载均衡有助于确保我们管理意外的高效或低效的高峰。
- en: Security
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Load balancers can also be configured to be not only public-facing instances;
    they can be configured to be private-facing instances as well. This can help in
    cases when there is a secured network or site-to-site VPN tunnel. This helps to
    guard our instances against public interfaces and limit them only to a private
    network. With the help of a private-facing load balancer, we can also configure
    for internal routing of backend systems without exposing them to the internet.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器还可以配置为不仅是面向公共的实例；它们也可以配置为面向私有的实例。这在存在安全网络或站点到站点VPN隧道的情况下会有所帮助。这有助于保护我们的实例免受公共接口的影响，并将它们限制在私有网络中。借助面向私有的负载均衡器，我们还可以配置后端系统的内部路由，而不将其暴露给互联网。
- en: A load balancer has various features, such as configuring protocols, sticky
    sessions, connection draining, idle connection timeout, metrics, access logs,
    host-based routing, path-based routing, load balancing to multiple ports on the
    same instance, and HTTP/2 support.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器具有各种功能，例如配置协议、粘性会话、连接排空、空闲连接超时、指标、访问日志、基于主机的路由、基于路径的路由、将负载均衡到同一实例上的多个端口以及HTTP/2支持。
- en: We looked at many features of load balancers, but we have one more important
    feature to look at. Yes, you are right; it's the health check. Health checks work
    as heartbeats for the load balancer and our application. Let's have look at health
    checks in a bit more detail to understand why they are heartbeats for the load
    balancer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看了很多负载均衡器的功能，但还有一个重要的功能要看。是的，你说对了；它就是健康检查。健康检查作为负载均衡器和我们的应用的心跳。让我们更详细地了解一下健康检查，以了解它们为什么是负载均衡器的心跳。
- en: Health check parameters
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查参数
- en: To discover and maintain the availability of EC2 instances, a load balancer
    periodically sends pings (attempted connections) or sends test requests to test
    EC2 instances. These checks are called health check parameters. The following
    is a list of all health check parameters. Health checks help us to determine if
    an instance is healthy or unhealthy. Let us look at a few of the common configuration
    options available in health checks for most load balancers. The configuration
    options naming convention will vary from one load balancer to another; however,
    conceptually the following configuration parameters are available.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现和维护EC2实例的可用性，负载均衡器定期发送ping（尝试连接）或发送测试请求来测试EC2实例。这些检查称为健康检查参数。以下是所有健康检查参数的列表。健康检查帮助我们确定实例是否健康或不健康。让我们看看大多数负载均衡器中可用的健康检查的一些常见配置选项。
- en: Unhealthy threshold
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不健康阈值
- en: In unhealthy attempts, it is expected to validate by the number of times the
    load balancer doesn't get a positive response from the backend. For instance,
    if we have configured a value of five unhealthy attempts, the load balancer would
    mark the instance unhealthy only if it doesn't get five healthy responses from
    the instance.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在不健康的尝试中，预计通过负载均衡器从后端未收到积极响应的次数来验证。例如，如果我们配置了五次不健康的尝试，只有在负载均衡器从实例未收到五次健康响应时，负载均衡器才会将实例标记为不健康。
- en: Healthy threshold
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康阈值
- en: This is exactly opposite to unhealthy attempts; it is expected to validate by
    the number of times the load balancer gets a positive response from the backend.
    For instance, if we have configured a value of two healthy attempts, the load
    balancer would mark the instance available only if it gets two healthy responses
    from the instance.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这与不健康的尝试完全相反；预计通过负载均衡器从后端收到积极响应的次数来验证。例如，如果我们配置了两次健康的尝试，只有在负载均衡器从实例收到两次健康响应时，负载均衡器才会将实例标记为可用。
- en: Timeout
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时
- en: A health check may be configured to check a URI. Let's say `/login.html` is
    supposed to be checked by a load balancer for a healthy response but doesn't respond
    within the time specified in the timeout. It would be considered an unhealthy
    response. This configuration would help us if there is an instance that may be
    affected due to limited system resource availability and not responding as per
    the expected time which we would have expected. Ideally, it is suggested to configure
    the timeout near to the actual response time from the instance for effective use.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查可以配置为检查URI。比如说，负载均衡器应该检查`/login.html`以获取健康响应，但在超时指定的时间内没有响应。这将被视为不健康的响应。如果有一个实例由于受限的系统资源可用性而受影响，并且未按预期时间响应，这种配置将对我们有所帮助。理想情况下，建议将超时配置为接近实例实际响应时间，以实现有效使用。
- en: Health check protocol
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查协议
- en: We can configure the health protocol type in diverse ways. We can have a health
    check based on a HTTP response, HTTPS response, TCP response, or HTTP/HTTPS body
    response. These are the most commonly available health check types, available
    in most load balancers.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式配置健康协议类型。我们可以基于HTTP响应、HTTPS响应、TCP响应或HTTP/HTTPS主体响应进行健康检查。这些是大多数负载均衡器中最常见的健康检查类型。
- en: Health check port
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查端口
- en: We can also configure health check ports. We can configure health checks based
    on various protocols, as we have just discussed, but if we have custom ports for
    the application, the load balancer can be configured accordingly. For instance,
    if we have an HTTP server in our backend instance running on port `81` instead
    of the default port `80`, we can configure HTTP as the health check protocol with
    the custom port `81` defined in the health check port.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以配置健康检查端口。我们可以根据刚刚讨论的各种协议来配置健康检查，但如果我们的应用有自定义端口，负载均衡器可以相应地进行配置。例如，如果我们的后端实例上运行的HTTP服务器在端口`81`上而不是默认端口`80`上，我们可以在健康检查端口中定义自定义端口`81`，并将HTTP配置为健康检查协议。
- en: Interval
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间隔
- en: This configuration parameter determines after how much time a health check should
    count heart beats for our backend instances. In general, it is configured in seconds,
    so if we configure an interval of 10 seconds, the load balancer will keep on repeating
    its check every 10 seconds.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置参数确定健康检查应在多长时间后计算我们的后端实例的心跳。一般来说，它以秒为单位配置，因此，如果我们配置为10秒的间隔，负载均衡器将每10秒重复一次检查。
- en: Configuring a load balancer
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置负载均衡器
- en: 'Now that we know about our health check parameters, let''s configure a load
    balancer. You will need to create an account on AWS and launch one instance:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的健康检查参数，让我们配置一个负载均衡器。您需要在AWS上创建一个帐户并启动一个实例：
- en: Open up your instance and then go to the Load Balancing | Load balancers tab.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的实例，然后转到负载平衡|负载均衡器选项卡。
- en: 'Create a load balancer. You will be able to choose from an application load
    balancer, network load balancer, or classic load balancer. The uses of these are
    shown in the following screenshot:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个负载均衡器。您可以选择应用负载均衡器、网络负载均衡器或经典负载均衡器。这些的用途在以下截图中显示：
- en: '![](img/10681f34-fa79-4852-a499-a2adcac13b9c.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10681f34-fa79-4852-a499-a2adcac13b9c.jpeg)'
- en: Types of load balancer
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器的类型
- en: 'The next step is to configure the load balancer and add health checks as per
    your requirements. All the steps can be seen in the following screenshot:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是配置负载均衡器，并根据您的要求添加健康检查。所有步骤都可以在以下截图中看到：
- en: '![](img/3a06ce28-6a7f-481a-8fcb-c52d5a45f2aa.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a06ce28-6a7f-481a-8fcb-c52d5a45f2aa.png)'
- en: Configuring the ELB Load Balancer
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 配置ELB负载均衡器
- en: You can specify the health parameters as per the theory discussed. Health checks
    ensure that request traffic is shifted away from failed instances.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以根据讨论的理论指定健康参数。健康检查确保请求流量从失败的实例中转移。
- en: Autoscaling – practical hands on with AWS
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动扩展-与AWS一起实际操作
- en: 'Now, we will do **autoscaling** using *AWS autoscaling groups*, a load balancer,
    and configuration properties. So, let''s get started. Here is the overall process
    that we are going to follow:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用*AWS自动扩展组*、负载均衡器和配置属性进行**自动扩展**。所以，让我们开始吧。以下是我们将要遵循的整个过程：
- en: Create a launch configuration that will run our `first-typescript microservice`
    from [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing up for
    the Journey*, to start the HTTP server
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个启动配置，从[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)运行我们的`first-typescript
    microservice`，*为旅程做准备*，启动HTTP服务器
- en: Create an autoscaling group
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自动扩展组
- en: Create an autoscaling policy to increase instances by two when the CPU load
    is greater than 20% for a minute
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自动扩展策略，当CPU负载大于20%一分钟时，增加两个实例
- en: Add the criteria for removing the autoscaling group.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加删除自动扩展组的标准。
- en: Auto-terminate the instances
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动终止实例
- en: So, let's get our hands dirty.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们动手吧。
- en: Creating the launch configuration
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建启动配置
- en: 'Log in to the AWS console and navigate to the EC2 dashboard. Select the launch
    configuration to start the wizard. Create the launch configuration accordingly
    to the wizard:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到AWS控制台，转到EC2仪表板。选择启动配置以启动向导。根据向导创建启动配置：
- en: '![](img/d2a680c1-5e05-4da3-a9ea-4b87ef43ff72.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2a680c1-5e05-4da3-a9ea-4b87ef43ff72.png)'
- en: Launch configuration
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 启动配置
- en: We should have EC2 instances ready to host our `first-typescript-microservices`
    application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该准备好EC2实例来托管我们的`first-typescript-microservices`应用程序。
- en: Creating an autoscaling group and configuring it with autoscaling policies
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自动扩展组并配置自动扩展策略
- en: 'Now we have a blueprint ready, we need the building base that is our autoscaling
    group. Create an autoscaling group and the following instance will appear. Enter
    appropriate values:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个准备好的蓝图，我们需要的是我们的自动扩展组。创建一个自动扩展组，然后会出现以下实例。输入适当的值：
- en: '![](img/bdcfca7f-f0d2-41b7-90d1-315dcfc26b02.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdcfca7f-f0d2-41b7-90d1-315dcfc26b02.png)'
- en: Creating an autoscaling group
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个自动扩展组
- en: 'This is how the wizard will look for configuring scale-up and scale-down strategies:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是配置扩大和缩小策略的向导外观：
- en: '![](img/b4e12a4b-4fe9-4d43-9b13-2ce2f887bfd4.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4e12a4b-4fe9-4d43-9b13-2ce2f887bfd4.png)'
- en: Autoscaling and auto terminating policies
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展和自动终止策略
- en: After reviewing, click OK and your AWS scaling group is now ready.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 审核后，点击“确定”，您的AWS扩展组现在已准备就绪。
- en: Creating an application load balancer and adding a target group
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个应用负载均衡器并添加目标组
- en: 'The next step is to create an application load balancer and attach a target
    group to it. So, create a new ELB (we can use the one we created earlier for health
    check configurations). Add a name for the target group and in Step 5 of the figure
    (Configuring ELB Load Balancer), register the instances that were launched by
    the autoscaling group:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个应用负载均衡器并将目标组附加到它。因此，创建一个新的ELB（我们可以使用之前为健康检查配置创建的ELB）。为目标组添加名称，并在图5的第5步（配置ELB负载均衡器）中，注册由自动扩展组启动的实例：
- en: '![](img/d86a585a-dcbc-4c78-bc76-3b2cc4297c19.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d86a585a-dcbc-4c78-bc76-3b2cc4297c19.jpg)'
- en: Attaching instances to load balancers
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将实例附加到负载均衡器
- en: The next step is to associate this target group with our autoscaling group.
    To do this, edit your autoscaling group and add the target group by name (there
    should be an autocomplete dropdown). We are all done with configuring AWS.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将此目标组与我们的自动扩展组关联。要做到这一点，编辑您的自动扩展组，并按名称添加目标组（应该有一个自动完成下拉菜单）。我们已经完成了AWS的配置。
- en: Time to test
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试时间
- en: To do load testing, I would prefer a simple load test module ([https://www.npmjs.com/package/loadtest](https://www.npmjs.com/package/loadtest))
    rather than setting up the entirety of Jmeter. Install the module by simply installing `npm
    install loadtest -g`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行负载测试，我更喜欢使用一个简单的负载测试模块（[https://www.npmjs.com/package/loadtest](https://www.npmjs.com/package/loadtest)），而不是设置完整的Jmeter。只需通过`npm
    install loadtest -g`安装该模块。
- en: 'Next, just to run the stress test, we can hit the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，只需运行压力测试，我们可以使用以下命令：
- en: '[PRE7]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `-c` means concurrent requests and `--rps` means requests per second for
    each client. This will trigger an alarm to increase the CPU count by 2\. Go to
    the AWS console after the alert time/wait period has elapsed to check your newly
    created instances. You will be able to see instances when the load has increased
    and after the load has decreased, it will automatically start to drain and terminate.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-c`表示并发请求，`--rps`表示每个客户端的每秒请求。这将触发一个警报，增加2个CPU计数。在警报时间/等待期过去后，转到AWS控制台检查您新创建的实例。当负载增加时，您将能够看到实例，负载减少后，它将自动开始排水和终止。
- en: We successfully autoscaled our instances up and down based on policies.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地根据策略自动扩展了我们的实例。
- en: AWS has an interesting terminology—spot instances. These enables us to reuse
    unused EC2 instances, which can lower our EC2 instances significantly. Since the
    span of autoscaled instance is not that large, using a spot instance while scaling
    up is highly advantageous, and beneficial from a monetary perspective too.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: AWS有一个有趣的术语——spot实例。这使我们能够重用未使用的EC2实例，这可以显著降低我们的EC2实例。由于自动缩放实例的跨度不是很大，在扩展时使用spot实例是非常有利的，从货币角度来看也是有利的。
- en: Scaling with Kubernetes
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行扩展
- en: Kubernetes is an open source system for automating deployments, scaling, and
    managing containerized applications. At the time of writing this book, the Kubernetes
    Version was **1.9.2**. In this section, we will look at some of the basic features
    provided by Kubernetes and the terms used in it. So, let's get started.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是用于自动化部署、扩展和管理容器化应用程序的开源系统。在撰写本书时，Kubernetes版本为**1.9.2**。在本节中，我们将看一些Kubernetes提供的基本功能和其中使用的术语。所以，让我们开始吧。
- en: What problem does Kubernetes solve?
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes解决了什么问题？
- en: With Docker, we have commands such as `docker run`, `docker build`, or `docker
    stop`. Unlike these commands, which perform operations on a single container,
    there is no command like docker deploy to push new images to a group of hosts.
    To solve this problem, Kubernetes is one of the most promising tools. Kubernetes
    provides powerful abstractions that completely decouple application-wise operations,
    such as deployment and scaling. Kubernetes sees the underlying infrastructure
    as a sea of computers in which we can put containers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，我们有诸如`docker run`、`docker build`或`docker stop`之类的命令。与这些命令不同，这些命令在单个容器上执行操作，没有像docker
    deploy这样的命令来将新镜像推送到一组主机。为了解决这个问题，Kubernetes是最有前途的工具之一。Kubernetes提供了强大的抽象，完全解耦了应用程序操作，如部署和扩展。Kubernetes将底层基础设施视为一组计算机，我们可以在其中放置容器。
- en: Kubernetes concepts
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes概念
- en: 'Kubernetes has a client-server architecture, where the Kubernetes server runs
    on the cluster on which we deploy our application. We interact with the Kubernetes
    server using the *kubectl CLI*:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes具有客户端-服务器架构，Kubernetes服务器在我们部署应用程序的集群上运行。我们使用*kubectl CLI*与Kubernetes服务器进行交互。
- en: '**Pods:** Our running containerized application with environment variables
    such as disks. Pods are born and die quickly, such as at deployment times.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pods：**我们正在运行的容器化应用程序，具有磁盘等环境变量。Pods在部署时会迅速产生和死亡。'
- en: '**Node:** A node is a physical or virtual machine running Kubernetes, on which
    pods can be scheduled.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点：**节点是运行Kubernetes的物理或虚拟机，可以在其中调度Pod。'
- en: '**Secret:** We separate out our credentials from environment variables.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秘密：**我们将凭据与环境变量分开。'
- en: '**Service:** This exposes our running pods by labeling them to other applications
    or to the outside world on the desired IP and port.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务：**通过将其标记为其他应用程序或所需IP和端口的外部世界，这将暴露我们正在运行的Pod。'
- en: Kubernetes process
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes流程
- en: For development purposes, we can use *minikube* and *kubectl*. At the production
    level, the ideal way is to use **GCP's** (**Google Cloud Platform's**) inbuilt
    Kubernetes. Trying to run `minikube` and `kubectl` inside VMBox wont be possible
    as it would become nested virtualization. You can download Kubernetes on NativeOS
    as per instructions found here [https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发目的，我们可以使用*minikube*和*kubectl*。在生产级别上，理想的方式是使用**GCP**（Google Cloud Platform）内置的Kubernetes。在VMBox中尝试运行`minikube`和`kubectl`是不可能的，因为它将成为嵌套虚拟化。您可以根据此处找到的说明下载Kubernetes在NativeOS上运行[https://kubernetes.io/docs/setup/](https://kubernetes.io/docs/setup/)。
- en: 'In this section, we will get our application running with Kubernetes before
    winding up. You will need a Google Cloud Platform account for this exercise. Google
    provides a $300 credit free tier. So, let''s get started:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在结束之前使用Kubernetes运行我们的应用程序。您需要一个Google Cloud Platform帐户来进行此练习。Google提供了300美元的免费信用额度。所以，让我们开始吧：
- en: Kubectl is a CLI tool for running commands against Kubernetes and we need the
    Google Cloud SDK. Install the Google Cloud SDK and Kubectl, and initialize your
    SDK with the `gcloud init` command.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubectl是针对Kubernetes运行命令的CLI工具，我们需要Google Cloud SDK。安装Google Cloud SDK和Kubectl，并使用`gcloud
    init`命令初始化您的SDK。
- en: 'The next step is to set up a project, so create one project in the web UI and
    set the default project ID while working with the CLI by running:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置一个项目，在Web UI中创建一个项目，并在使用CLI时设置默认项目ID，方法是运行：
- en: '[PRE8]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Revisit [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing up
    for the Journey*, to gather the `docker build` and `docker run` commands locally:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新查看[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)，*为旅程做准备*，以获取本地的`docker
    build`和`docker run`命令：
- en: '[PRE9]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we will create a cluster with three instances where we will deploy our
    application:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个包含三个实例的集群，我们将在其中部署我们的应用程序：
- en: '[PRE10]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, the `gcloud container clusters create hello-world-cluster --zone
    us-east1-b --machine-type f1-micro`. `F1-mico` is the smallest available unit.
    We can connect the `kubectl` client Kubernetes server with:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`gcloud container clusters create hello-world-cluster --zone us-east1-b --machine-type
    f1-micro`。`F1-mico`是最小的可用单位。我们可以使用以下命令将`kubectl`客户端连接到Kubernetes服务器：
- en: '[PRE11]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We now have a Docker image and server cluster, in which we want to to deploy
    the image and start the containers. So, build and then upload the image using
    the following code:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了一个Docker镜像和服务器集群，我们希望部署该镜像并启动容器。因此，请使用以下代码构建并上传镜像：
- en: '[PRE12]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To deploy, create the following `deployment.yml` file from following `gist`
    ([https://gist.github.com/insanityrules/ef1d556721173b7815e09c24bd9355b1](https://gist.github.com/insanityrules/ef1d556721173b7815e09c24bd9355b1)),
    which will create two pods. To apply this, run the following command:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要部署，请从以下 `gist` ([https://gist.github.com/insanityrules/ef1d556721173b7815e09c24bd9355b1](https://gist.github.com/insanityrules/ef1d556721173b7815e09c24bd9355b1))
    创建以下 `deployment.yml` 文件，这将创建两个pod。要应用此文件，请运行以下命令：
- en: '[PRE13]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, when you do `kubectl get pods`, you will get three pods. To check the logs
    of the system, we can hit `kubectl logs {pod-name}`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您执行 `kubectl get pods` 命令时，您将获得三个pod。要检查系统日志，我们可以使用 `kubectl logs {pod-name}`
    命令。
- en: 'To expose it to the internet and to add scalability to the load balancer, hit
    the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其暴露到互联网并为负载均衡器添加可伸缩性，请执行以下命令：
- en: '[PRE14]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this section, we deployed our application on Kubernetes with three replicas
    on which we can autoscale or close down unwanted instances, just like AWS.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在Kubernetes上部署了我们的应用程序，有三个副本，我们可以自动扩展或关闭不需要的实例，就像AWS一样。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through our hardening layer. We looked at all the vulnerabilities
    our service is exposed to, and we learned about how to address them. We looked
    at some fundamentals, such as rate limiting, session handling, how to prevent
    parameter pollution, and more. We got acquainted with security at the container
    level and went through all the best practices for handling microservice security
    before moving on to scalability. We looked at Kubernetes and the Amazon load balancer,
    and got hands-on with both.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了我们的加固层。我们查看了我们的服务面临的所有漏洞，并学习了如何解决它们。我们了解了一些基本原理，比如速率限制、会话处理、如何防止参数污染等等。我们熟悉了容器级别的安全性，并学习了在处理微服务安全性之前的所有最佳实践，然后转向可伸缩性。我们研究了Kubernetes和亚马逊负载均衡器，并且对两者都有了实际操作。
- en: So far, you have learned how to build microservices using TpeScript on the Node.js
    platform and learned about all the aspects of microservice development, right
    from developing, the API Gateway, service registry, discovery, inter-service communication,
    Swagger, deployment, and testing. The objective of the book was to give you a
    practical hands-on guide to the microservice development and an understanding
    of the basic aspects to get you up and running. I really hope this book covers
    the empty space that is missing in the Node.js community, when compared to the
    Spring Cloud and Java community.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学会了如何在Node.js平台上使用TpeScript构建微服务，并了解了微服务开发的各个方面，从开发、API网关、服务注册表、发现、服务间通信、Swagger、部署和测试等。本书的目标是为您提供一个实用的微服务开发指南，以及对基本方面的理解，让您可以立即上手。我真的希望这本书填补了Node.js社区与Spring
    Cloud和Java社区相比所缺少的空白。
