- en: Persisting Data with MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB持久化数据
- en: With almost any application written for the web nowadays, a highly interactive
    application is of limited value if the interaction between its users isn't permanently
    saved. You have to integrate your application with a proper database to solve
    this issue. Imagine a case where all of the data for your application (registered
    users, order transactions, and social interactions) was stored within the temporary
    memory of the server the application is running on. The moment that server was
    turned off or rebooted, all of your application data would be lost. Relying on
    a database to store this data permanently is crucial to any dynamic application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎现在为Web编写的任何应用程序，如果其用户之间的交互不是永久保存的话，那么高度交互式的应用程序的价值就会受到限制。您必须将您的应用程序与适当的数据库集成以解决这个问题。想象一种情况，您的应用程序的所有数据（注册用户、订单交易和社交互动）都存储在服务器的临时内存中。一旦服务器关闭或重新启动，您的应用程序数据将全部丢失。依赖数据库永久存储这些数据对于任何动态应用程序都至关重要。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: Connecting to MongoDB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到MongoDB
- en: An introduction to Mongoose
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mongoose简介
- en: Schemas and models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和模型
- en: Adding CRUD to our controllers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的控制器中添加CRUD
- en: In the previous chapter, we wrote and accounted for the actual logic of our
    application. The next step in building our application is to connect it to a database
    so that our users' interactions and data can be permanently saved and retrieved.
    Technically, we can get around this by storing data in the memory, but the moment
    our web server restarts or crashes, all of that data will be lost. Without connecting
    our application to a database server to persist data, every input interacted by
    a visitor will be obsolete. Without some kind of database server to store our
    data, most of the websites we interact with on a daily basis wouldn't even exist.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写并考虑了我们应用程序的实际逻辑。构建我们应用程序的下一步是将其连接到数据库，以便我们用户的交互和数据可以被永久保存和检索。从技术上讲，我们可以通过将数据存储在内存中来解决这个问题，但是一旦我们的Web服务器重新启动或崩溃，所有这些数据都将丢失。如果没有将我们的应用程序连接到数据库服务器以持久保存数据，访问者交互的每个输入都将过时。如果没有某种数据库服务器来存储我们的数据，我们每天与之交互的大多数网站甚至都不会存在。
- en: 'Here is a general breakdown of how our data is going to be persisted for every
    visitor interaction in our app:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的数据将如何在我们的应用程序中为每个访问者交互持久化的一般分解：
- en: '![](img/845592b3-7634-4f2f-a19c-6cb969bd0649.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/845592b3-7634-4f2f-a19c-6cb969bd0649.png)'
- en: 'Consider the preceding diagram, which reflects the typical life cycle of a
    web application request:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面的图表，它反映了Web应用程序请求的典型生命周期：
- en: A visitor submits a request to view a page on our application via their web
    browser.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个访问者通过他们的网络浏览器提交请求来查看我们应用程序上的页面。
- en: The Node.js server receives this request and queries a MongoDB server for any
    data.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js服务器接收到这个请求并查询MongoDB服务器是否有任何数据。
- en: The MongoDB server returns the queried data back to our Node.js server.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MongoDB服务器将查询到的数据返回给我们的Node.js服务器。
- en: The Node.js server takes that data, builds it into the view model, and then
    sends the rendered HTML page back to the browser.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js服务器获取数据，将其构建成视图模型，然后将渲染后的HTML页面发送回浏览器。
- en: The web browser receives the response from our Node.js server and renders the
    HTML.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络浏览器接收到来自我们Node.js服务器的响应并渲染HTML。
- en: This cycle typically repeats for every interaction by every visitor.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个循环通常会为每个访问者的每次交互重复。
- en: 'For the purposes of this book, we are using MongoDB as our primary data store,
    but the reality is that we can use any of the following to store data: MySQL,
    PostgreSQL, MS SQL, the filesystem, and so on.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我们使用MongoDB作为我们的主要数据存储，但现实情况是我们可以使用以下任何一种来存储数据：MySQL，PostgreSQL，MS SQL，文件系统等等。
- en: Using MongoDB with Node.js
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js与MongoDB
- en: Before we officially implement MongoDB into our actual application, let's first
    take a look at some basic examples of connecting to a MongoDB server from within
    Node.js.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正式将MongoDB实现到我们的实际应用程序之前，让我们先看一些从Node.js内部连接到MongoDB服务器的基本示例。
- en: Create a new project folder to store some sample code to experiment with. I'll
    call my folder `mongotest`. Inside this folder, create a new file called `test.js`.
    In this file, we will play around with some code to test how to connect to MongoDB
    and how to insert and retrieve some data. The first thing we need to do in order
    to connect to a MongoDB server from Node.js is to require a `mongodb` module.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目文件夹来存储一些样本代码进行实验。我会把我的文件夹称为`mongotest`。在这个文件夹里，创建一个名为`test.js`的新文件。在这个文件中，我们将玩一些代码来测试如何连接到MongoDB，以及如何插入和检索一些数据。从Node.js连接到MongoDB服务器的第一件事是要求一个`mongodb`模块。
- en: 'To get started, change directories into the new `mongotest` folder and install
    the `mongodb` module using `npm`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，切换到新的`mongotest`文件夹并使用`npm`安装`mongodb`模块：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don't be confused by the module's name. The `mongodb` npm module isn't MongoDB
    itself, but rather a third-party npm module that facilitates communicating to
    a MongoDB server from within Node.js. Also, because this is just a sample project
    to experiment with, we don't require the `--save` flag with `npm install`, since
    we aren't maintaining a `package.json` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被模块的名称所困惑。`mongodb` npm模块并不是MongoDB本身，而是一个第三方npm模块，可以方便地从Node.js内部与MongoDB服务器通信。此外，因为这只是一个用于实验的示例项目，所以我们不需要在`npm
    install`中使用`--save`标志，因为我们不维护`package.json`文件。
- en: Connecting to MongoDB
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到MongoDB
- en: 'Now that the `mongodb` module is installed, we can use it in our experimentation
    file. Boot up your editor and create a file named `test.js`. Insert the following
    block of code into it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`mongodb`模块已经安装，我们可以在我们的实验文件中使用它。启动你的编辑器，创建一个名为`test.js`的文件。将以下代码块插入其中：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Executing the preceding code should log Connected to MongoDB! to your screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码应该在你的屏幕上记录“Connected to MongoDB!”。
- en: The first thing you'll notice is that we require the `mongodb` module, but we
    specifically use the `MongoClient` component of the module. This component is
    the actual interface we use to actively open a connection to a MongoDB server.
    Using `MongoClient`, we pass the `mongodb://localhost:27017/mongotest` string
    URL to our local server as the first parameter. Notice that the path in the URL
    points to the server and then the name of the database itself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先注意到的是我们需要“mongodb”模块，但我们特别使用模块的“MongoClient”组件。该组件是我们实际用于主动打开与MongoDB服务器的连接的接口。使用“MongoClient”，我们将“mongodb://localhost:27017/mongotest”字符串URL作为第一个参数传递给我们的本地服务器。请注意，URL中的路径指向服务器，然后是数据库本身的名称。
- en: Remember to make sure you have your local MongoDB server instance running in
    another terminal for the duration of this chapter. To do so, open a command-line
    terminal window and execute `$ mongod`. Your server should launch and log information
    to the screen, ending with `[initandlisten] waiting for connections on port 27017`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在本章节的持续时间内在另一个终端中运行本地的MongoDB服务器实例。为此，打开一个命令行终端窗口并执行`$ mongod`。您的服务器应该启动并在屏幕上记录信息，最后显示“[initandlisten]
    waiting for connections on port 27017”。
- en: 'You might find that when you run your application, you receive a stack trace
    error with something like the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现当运行应用程序时，您会收到类似以下代码的堆栈跟踪错误：
- en: '`events.js:72`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`events.js:72`'
- en: '`thrower; // Unhandled ''error'' event`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`thrower; // Unhandled ''error'' event`'
- en: '`^Error: failed to connect to [localhost:27017]`If this happens, you should
    realize that it failed to connect to the `localhost` on port `27017`, which is
    the port that our local `mongod` server runs under.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：无法连接到[localhost:27017]。如果发生这种情况，您应该意识到它无法连接到端口27017上的“localhost”，这是我们本地“mongod”服务器运行的端口。
- en: Once we have an active connection to our database server, it's as if we are
    running the Mongo shell command. The MongoClient callback function returns a database
    connection object (that we named `db` in our code, but could have named anything),
    which is exactly the same object we work with in the Mongo shell when we execute
    `use <databasename>`. Knowing this, at this point, we can use the `db` object
    to do anything we can do via the Mongo shell. The syntax is slightly different,
    but the idea is generally the same.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们与数据库服务器建立了活动连接，就好像我们在运行Mongo shell命令一样。MongoClient回调函数返回一个数据库连接对象（我们在代码中命名为“db”，但可以命名为任何东西），这与我们在Mongo
    shell中使用的对象完全相同，当我们执行`use <databasename>`时。知道这一点，此时我们可以使用“db”对象做任何我们可以通过Mongo
    shell做的事情。语法略有不同，但思想基本相同。
- en: Inserting a document
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入文档
- en: 'Let''s test out our new `db` object by inserting a record into a collection:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向集合插入记录来测试我们的新“db”对象：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we establish a connection to the database and execute
    a `callback` once the connection is complete. That `callback` receives two parameters,
    the second of which is the `db` object itself. Using the `db` object, we can get
    a collection we want to work with. In this case, we save that collection as a
    variable so that we can work with it throughout the rest of our code more easily.
    Using the `collection` variable, we execute a simple `insert` command and pass
    the JSON object we want to insert into the database as the first parameter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们建立了与数据库的连接，并在连接完成后执行了一个“回调”。该“回调”接收两个参数，第二个参数是“db”对象本身。使用“db”对象，我们可以获取我们想要使用的集合。在这种情况下，我们将该集合保存为一个变量，以便在代码的其余部分更容易地使用它。使用“collection”变量，我们执行一个简单的“insert”命令，并将要插入到数据库中的JSON对象作为第一个参数传递。
- en: The `callback` function executes after `insert` accepts two parameters, the
    second of which is an array of documents affected by the command; in this case,
    it is an array of documents that we inserted. Once `insert` is complete and we
    are inside the `callback` function, we log some data. You can see that the length
    of the `docs.ops` array is `1`, as we only inserted a single document. Furthermore,
    you can see that the single document in the array is the document we inserted,
    although now it has an extra `_id` field since MongoDB handles that automatically.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: “回调”函数在“insert”接受两个参数后执行，第二个参数是受命令影响的文档数组；在这种情况下，它是我们插入的文档数组。一旦“insert”完成并且我们在“回调”函数内部，我们记录一些数据。您可以看到“docs.ops”数组的长度为1，因为我们只插入了一个文档。此外，您可以看到数组中的单个文档是我们插入的文档，尽管现在它有一个额外的“_id”字段，因为MongoDB会自动处理。
- en: Retrieving a document
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索文档
- en: 'Let''s prove our code a little bit more by adding the `findOne` function call
    to look up the document we just inserted. Change the code in `test.js` to match
    the following example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将“findOne”函数调用添加到刚刚插入的文档中，让我们稍微证明一下我们的代码。将“test.js”中的代码更改为以下示例：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code, we insert a record in exactly the same way as before; only this
    time,
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们以与之前完全相同的方式插入记录；只是这一次，
- en: we perform `findOne` on `title`. The `findOne` function accepts a `JSON` object
    to match against (this can be as precise or loose as you want) as its first parameter.
    The `callback` function that executes after `findOne` will contain the single
    document that was found as its second parameter. If we executed a `find` operation,
    we would have received an array of matching documents based on the search criteria.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对“title”执行“findOne”。“findOne”函数接受一个要匹配的JSON对象（这可以是您想要的精确或宽松）作为其第一个参数。在“findOne”之后执行的“回调”函数将包含找到的单个文档作为其第二个参数。如果我们执行了“find”操作，我们将根据搜索条件收到一组匹配的文档。
- en: 'The output of the last mentioned code should be:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出应该是：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In your output, you might notice that the `_id` parameter being reported on
    `insert` doesn't match the one from `findOne`. This is likely the result of running
    the code multiple times, which results in multiple records with the same title
    being inserted. The `findOne` function will return the first document found in
    no particular order, so chances are the document returned might not be the last
    one inserted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的输出中，你可能会注意到`insert`报告的`_id`参数与`findOne`中的不匹配。这很可能是多次运行代码的结果，导致插入了多个具有相同标题的记录。`findOne`函数将返回第一个找到的文档，没有特定的顺序，所以返回的文档可能不是最后一个插入的。
- en: Now that you have a basic understanding of how to easily connect and communicate
    with a MongoDB server from Node.js, let's take a look at how we can work with
    MongoDB in a way that's a little less raw.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经基本了解了如何轻松地从Node.js连接和与MongoDB服务器通信，让我们来看看如何以一种不那么原始的方式来使用MongoDB。
- en: Introducing Mongoose
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Mongoose
- en: While working directly with the `mongodb` module is great, it's also a bit raw
    and lacks any sense of the developer friendliness that we've come to expect when
    working with frameworks such as Express in Node.js. **Mongoose** is a great third-party
    framework that makes working with MongoDB a breeze. It is an elegant `mongodb`
    object modeling for Node.js.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接使用`mongodb`模块很好，但它也有点原始，并且缺乏我们在使用Express等框架时所期望的开发者友好性。**Mongoose**是一个很棒的第三方框架，使得与MongoDB的工作变得轻而易举。它是Node.js的优雅的`mongodb`对象建模。
- en: What that basically means is that Mongoose gives us the power to organize our
    database using schemas (also known as model definitions) and provides powerful
    features to our models, such as validation, virtual properties, and more. Mongoose
    is a great tool, as it makes working with collections and documents in MongoDB
    feel much more elegant. The original `mongodb` module is a dependency of Mongoose,
    so you can think of Mongoose as being a wrapper on top of `mongodb`, much like
    Express is a wrapper on top of Node.js--both abstract away a lot of the raw feeling
    and give you easier tools to work with directly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这意味着Mongoose赋予我们组织数据库的能力，使用模式（也称为模型定义），并为我们的模型提供强大的功能，如验证、虚拟属性等。Mongoose是一个很棒的工具，因为它使得在MongoDB中处理集合和文档变得更加优雅。Mongoose的原始`mongodb`模块是Mongoose的一个依赖，因此你可以将Mongoose看作是`mongodb`的一个包装器，就像Express是Node.js的一个包装器一样——两者都抽象了很多原始的感觉，并为你提供了更容易直接使用的工具。
- en: It's important to note that Mongoose is still MongoDB, so everything you're
    familiar with and used to will work pretty much the same way; only the syntax
    will change slightly. This means that the queries, inserts, and updates that we
    know and love from MongoDB work perfectly fine with Mongoose.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Mongoose仍然是MongoDB，所以你熟悉和习惯的一切都基本上是一样的；只是语法会稍微改变。这意味着我们从MongoDB中熟悉和喜爱的查询、插入和更新在Mongoose中也可以完美地工作。
- en: 'The first thing we need to do is install Mongoose so that it''s available to
    use within our `mongotest` project:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装Mongoose，以便在我们的`mongotest`项目中使用：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After installation, let's take a look at some of the features that Mongoose
    has to offer and that we'll take advantage of to make our lives easier when developing
    apps that rely heavily on a MongoDB database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，让我们来看一下Mongoose提供的一些功能，我们将利用这些功能来简化开发依赖于MongoDB数据库的应用程序时的工作。
- en: Schemas
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: In Mongoose, schemas are what we use to define our models. Visualize the schemas
    as the blueprints which are used to create the models. Using schemas, you can
    define much more than the simple blueprint of a MongoDB model. You can also take
    advantage of the built-in validation that Mongoose provides by default, adding
    static methods, virtual properties, and more.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mongoose中，模式是我们用来定义模型的。将模式想象成用于创建模型的蓝图。使用模式，你可以定义比MongoDB模型的简单蓝图更多的内容。你还可以利用Mongoose默认提供的内置验证，添加静态方法、虚拟属性等。
- en: 'The first thing we do while defining a schema for a model is build a list of
    every field we think we will need for a particular document. The fields are defined
    by type, and the standard data types you would expect are available, as well as
    a few others:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在为模型定义模式时，我们首先要做的是构建我们认为对于特定文档我们将需要的每个字段的列表。字段由类型定义，并且你所期望的标准数据类型都是可用的，还有一些其他的：
- en: '*String*: This type stores a string value.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*String*：这种类型存储字符串值。'
- en: '*Number*: This type stores a number value, with restrictions.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Number*：这种类型存储一个数字值，并带有限制。'
- en: '*Date*: This type holds a `date` and `time` object.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Date*：这种类型保存了一个`date`和`time`对象。'
- en: '*Buffer*: This type provides the storage for binary data. For instance, it
    can include images or any other files.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Buffer*：这种类型提供了二进制数据的存储。例如，它可以包括图像或任何其他文件。'
- en: '*Boolean*: This type is used to store a Boolean (true/ false) value.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Boolean*：这种类型用于存储布尔（true/false）值。'
- en: '*Mixed*: This is basically an unstructured object that can contain anything.
    Consider this when storing JSON type data or data that is arbitrary and'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mixed*：这基本上是一个可以包含任何内容的非结构化对象。在存储JSON类型数据或任意数据时要考虑这一点。'
- en: can literally be any JSON representation. It doesn't need to be predefined.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以是任何JSON表示。它不需要预定义。
- en: '*ObjectID*: This is typically used when you want to store the ObjectID of another
    document in a field, for example, when defining a relationship.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ObjectID*：当你想要在字段中存储另一个文档的ObjectID时，通常会使用这个。例如，在定义关系时。'
- en: '*Array*: This is a collection of other schemas (models).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Array*：这是其他模式（模型）的集合。'
- en: 'Here is an example of a basic Mongoose schema definition:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的Mongoose模式定义的例子：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we define our schema for an `Account` collection. The first thing we do
    is `require` Mongoose and then define a `Schema` object using `mongoose.Schema`
    in our module. We define a schema by creating a new `Schema` instance with a constructor
    object that defines the schema. Each field in the definition is a basic JavaScript
    object with its type and then an optional default value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 `Account` 集合定义了模式。我们首先 `require` Mongoose，然后在我们的模块中使用 `mongoose.Schema`
    定义了一个 `Schema` 对象。我们通过创建一个新的 `Schema` 实例来定义模式，构造函数对象定义了模式。定义中的每个字段都是一个基本的 JavaScript
    对象，具有其类型，然后是一个可选的默认值。
- en: Models
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: A model in Mongoose is a class that can be instantiated (defined by a schema).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mongoose 中，模型是可以实例化的类（由模式定义）。
- en: Using schemas, we define `models` and then use them as regular JavaScript objects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式，我们定义 `models`，然后将它们用作常规 JavaScript 对象。
- en: 'The benefit is that the `model` object has the added bonus of being backed
    by Mongoose, so it also includes features such as saving, finding, creating, and
    removing. Let''s take a look at defining a model using a schema and then instantiating
    a model and working with it. Add another file called `test2.js` to your experimentation
    folder, `mongotest/test2.js`, and include the following block in it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好处是 `model` 对象有额外的优势，即由 Mongoose 支持，因此还包括保存、查找、创建和删除等功能。让我们来看看如何使用模式定义模型，然后实例化模型并使用它。在您的实验文件夹
    `mongotest/test2.js` 中添加另一个文件 `test2.js`，并在其中包含以下代码块：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the preceding code should result in something similar to the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码应该会得到类似以下的结果：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Creating a new model is great when you''re working with new documents and you
    want a way to create a new instance, populate its values, and then save it to
    the database:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用新文档并且想要创建一个新实例、填充其值，然后将其保存到数据库时，创建新模型是很好的：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Calling `.save` on a `mongoose` model will trigger a command to MongoDB that
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mongoose` 模型上调用 `.save` 将触发对 MongoDB 的命令
- en: 'will perform the necessary `insert` or `update` statements to update the server.
    When you switch over to your mongo shell, you can see that the new user was indeed
    saved to the database:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行必要的 `insert` 或 `update` 语句来更新服务器。当您切换到 mongo shell 时，您会看到新用户确实已保存到数据库中：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Without calling `.save()` on the model, the changes to the model won't actually
    be persisted to the database. Working with Mongoose models in your Node code is
    just that--code. You have to execute MongoDB functions on a model for any actual
    communication to occur with the database server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型上不调用 `.save()`，模型的更改实际上不会持久保存到数据库中。在您的 Node 代码中使用 Mongoose 模型就是这样——代码。您必须在模型上执行
    MongoDB 函数，才能与数据库服务器进行任何实际的通信。
- en: 'You can use `AccountModel` to perform a `find` operation and return an array
    of `AccountModel` objects, based on some search criteria that retrieves results
    from the MongoDB database:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `AccountModel` 执行 `find` 操作，并根据一些检索条件返回一组 `AccountModel` 对象，这些条件从 MongoDB
    数据库中检索结果。
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we use the standard MongoDB commands `$gt` and `$lt` for the value of
    age when passing in our query parameter to find documents (that is, find any document
    where the age is above 18 and below 30). The callback function that executes after
    `find` references an `accounts` array, which is a collection of `AccountModel`
    objects returned from the query to MongoDB. As a general means of good housekeeping,
    we close the connection to the MongoDB server after we are finished.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用标准的 MongoDB 命令 `$gt` 和 `$lt` 来传递查询参数以查找文档（也就是查找年龄在 18 到 30 之间的文档）。`find`
    执行后的回调函数引用了一个 `accounts` 数组，这是从 MongoDB 查询返回的 `AccountModel` 对象的集合。作为良好的管理方式，我们在完成后关闭了与
    MongoDB 服务器的连接。
- en: Built-in validation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置验证
- en: One of the core concepts of Mongoose is that it enforces a schema on top of
    a
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 的核心概念之一是它在顶部强制执行模式
- en: 'schema-less design, such as MongoDB. In doing so, we gain a number of new features,
    including built-in validation. By default, every schema type has a built-in required
    validator available. Furthermore, numbers have both `min` and `max` validators,
    and strings have enumeration and matching validators. Custom validators can also
    be defined via your schemas. Let''s take a brief look at some validation added
    to our example schema from earlier:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 无模式设计，例如 MongoDB。这样做，我们获得了许多新功能，包括内置验证。默认情况下，每个模式类型都有一个内置的必需验证器。此外，数字有 `min`
    和 `max` 验证器，字符串有枚举和匹配验证器。还可以通过模式定义自定义验证器。让我们简要看一下我们之前示例中添加的一些验证：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The validation we added to our schema is that the `username` parameter is now
    required, and we included a new field called `age`, which is a number that must
    be between `13` and `120` (years). If either value doesn't match the validation
    requirements (that is, the `username` is blank or the `age` is less than `13`
    or greater than `120`), an error will be thrown.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模式中添加的验证是 `username` 参数现在是必需的，并且我们包含了一个名为 `age` 的新字段，它是一个必须在 `13` 到 `120`（年）之间的数字。如果任一值不符合验证要求（即
    `username` 为空或 `age` 小于 `13` 或大于 `120`），则会抛出错误。
- en: 'Validation will fire automatically whenever a model''s `.save()` function is
    called; however, you can also manually validate by calling a model''s `.validate()`
    function with a `callback` to handle the response. Building on the example, add
    the following code, which will create a new `mongoose` model from the schema defined:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用模型的 `.save()` 函数时，验证将自动触发；但是，您还可以通过调用模型的 `.validate()` 函数并使用 `callback`
    手动验证来处理响应。在上面的示例基础上，添加以下代码，将从定义的模式创建一个新的 `mongoose` 模型：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running the preceding code should log the following error to the screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码应该会将以下错误记录到屏幕上：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that the `error` object that is returned from `validate` is pretty
    useful and provides a lot of information that can help when validating your model
    and returning error messages back to the user.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到从 `validate` 返回的 `error` 对象非常有用，并提供了大量信息，可以在验证模型并将错误消息返回给用户时提供帮助。
- en: Validation is a very good example of why it's so important to always accept
    an `error` object as the first parameter to any `callback` function in Node. It's
    equally important that you check the `error` object and handle it appropriately.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 验证是为什么在Node中始终接受`error`对象作为任何`callback`函数的第一个参数是非常重要的一个很好的例子。同样重要的是，您检查`error`对象并适当处理它。
- en: Static methods
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: '`Schema`s are flexible enough so that you can easily add your own custom static
    methods to them, which will then become available to all of your models that are
    defined by that `Schema`. Static methods are great for adding helper utilities
    and functions that you know you''re going to want to use with most of your models.
    Let''s take our simple age query from earlier and refactor it so that it''s a
    static method and a little more flexible:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schema`足够灵活，以便您可以轻松地向其添加自定义的静态方法，然后这些方法将对由该`Schema`定义的所有模型可用。静态方法非常适合添加您知道您将要在大多数模型中使用的辅助工具和函数。让我们从之前的简单年龄查询中重构它，使其成为一个静态方法并且更加灵活：'
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Static methods are pretty easy to implement and will make your models much more
    powerful once you start taking full advantage of them!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法非常容易实现，一旦您开始充分利用它们，它们将使您的模型更加强大！
- en: Virtual properties
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟属性
- en: 'Virtual properties are exactly what they sound like--fake properties that don''t
    actually exist in your MongoDB documents, but that you can fake by combining other,
    real properties. The most obvious example of a `virtual` property would be a field
    for `fullname`, when only `firstname` and `lastname` are actual fields in the
    MongoDB collection. For `fullname`, you simply want to say, return the model''s
    first and last name combined as a single string and label it as `fullname`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟属性就是它们听起来的样子——虚假的属性，实际上并不存在于您的MongoDB文档中，但您可以通过组合其他真实属性来伪造它们。最明显的虚拟属性的例子是`fullname`字段，当只有`firstname`和`lastname`是MongoDB集合中的实际字段时。对于`fullname`，您只需返回模型的名字和姓氏组合成一个字符串，并将其标记为`fullname`：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We call the `.get()` and `.set()` functions. It's not required to provide both,
    although it's fairly common.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`.get()`和`.set()`函数。虽然不需要同时提供两者，但这是相当常见的。
- en: In this example, our `get()` function simply performs basic string concatenation
    and returns a new value. Our `.set()` function performs the reverse splitting
    of a string on a space and then assigning the model's `firstname` and `lastname`
    field values with each result. You can see that the `.set()` implementation is
    a little flaky if someone attempts to set a model's `fullname` with a value of,
    say, Dr. Kenneth Noisewater.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的`get()`函数只是执行基本的字符串连接并返回一个新值。我们的`.set()`函数执行相反的操作，将字符串在空格上拆分，然后将模型的`firstname`和`lastname`字段值分别赋值给每个结果。您可以看到，如果有人尝试使用Dr.
    Kenneth Noisewater这样的值来设置模型的`fullname`，那么`.set()`的实现就有点不稳定。
- en: It's important to note that virtual properties are not persisted to MongoDB,
    since they are not real fields in the document or collection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，虚拟属性不会持久保存到MongoDB，因为它们不是文档或集合中的真实字段。
- en: 'There''s a lot more you can do with Mongoose, and we only just barely scratched
    the surface. Fortunately, it has a fairly in-depth guide that you can refer to
    at the following link: [http://mongoosejs.com/docs/guide.html](http://mongoosejs.com/docs/guide.html).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose还有很多功能可以使用，我们只是刚刚触及了表面。幸运的是，它有一个相当深入的指南，您可以在以下链接中参考：[http://mongoosejs.com/docs/guide.html](http://mongoosejs.com/docs/guide.html)。
- en: Definitely spend some time reviewing the Mongoose documentation so that you
    are familiar with all of the powerful tools and options available.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要花时间审查Mongoose文档，以便您熟悉所有可用的强大工具和选项。
- en: That concludes our introduction to Mongoose's models, schemas, and validation.
    Next up, let's dive back into our main application and write the schemas and models
    that we will be using to replace our existing sample `ViewModels` and for connecting
    with Mongoose.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Mongoose模型、模式和验证的介绍。接下来，让我们重新回到我们的主要应用程序，并编写我们将用来替换现有样本`ViewModels`并与Mongoose连接的模式和模型。
- en: Context of method (this)
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法的上下文（this）
- en: 'Before getting started with our next sections, the readers may have noticed
    that we have not used a fat arrow function as a replacement for the `callbacks`
    in all cases. This is because we will be using the context of a function `(this)`
    widely. There is a difference in implementation between flat arrow functions and
    regular functions when it comes to context. The differential statement is that
    the context of function `(this)` doesn''t depend on where it is declared, but
    from where it is called. To understand this, let''s consider the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始下一节之前，读者可能已经注意到我们并没有在所有情况下使用箭头函数作为`callbacks`的替代品。这是因为我们将广泛使用函数的上下文`(this)`。在实现上，箭头函数和常规函数在上下文方面有所不同。不同的是，函数的上下文`(this)`不取决于它在哪里声明，而是取决于它从哪里调用。为了理解这一点，让我们考虑以下例子：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On running the preceding snippet, we will get the output `'world'`; this is
    because the foo function is called in a global scope, hence the context is global
    and we receive the value of the global variable. To restrict this behavior, we
    can use the `bind` method or es6 arrow functions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的片段，我们将得到输出`'world'`；这是因为foo函数在全局范围内调用，因此上下文是全局的，我们接收到全局变量的值。为了限制这种行为，我们可以使用`bind`方法或es6箭头函数。
- en: 'Now, we convert the preceding `get virtual` method as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将前面的`get virtual`方法转换如下：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The context inside the preceding `arrow` function won''t refer to the `Account`
    schema, and will thus get undefined. To avoid this behavior, we will continue
    with regular functions. Get to know more about the lexical scoping mechanism of
    the `arrow` function in the following link: [https://goo.gl/bXvFRM](https://goo.gl/bXvFRM).
    More details on how to handle this issue with different methods are posted in
    the following link: [https://github.com/Automattic/mongoose/issues/5057](https://github.com/Automattic/mongoose/issues/5057).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`箭头`函数中的上下文不会引用`Account`模式，因此将得到未定义。为了避免这种行为，我们将继续使用常规函数。了解有关`箭头`函数的词法作用域机制的更多信息，请访问以下链接：[https://goo.gl/bXvFRM](https://goo.gl/bXvFRM)。有关如何使用不同方法处理此问题的更多详细信息，请访问以下链接：[https://github.com/Automattic/mongoose/issues/5057](https://github.com/Automattic/mongoose/issues/5057)。
- en: Connecting with Mongoose
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接Mongoose
- en: The act of connecting to a MongoDB server with Mongoose is almost identical
    to the method we used earlier when we used the `mongodb` module.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Mongoose连接到MongoDB服务器的行为几乎与我们之前使用`mongodb`模块时使用的方法相同。
- en: 'First, we need to ensure that Mongoose is installed. At this point, we are
    going to be using Mongoose in our main app, so we want to install it in the main
    project directory and also update the `package.json` file. Using your command-line
    terminal program, change locations to your `projects` folder, and install Mongoose
    via `npm`, making sure to use the `--save` flag so that the `package.json` file
    is updated:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保安装了Mongoose。在这一点上，我们将在我们的主应用程序中使用Mongoose，因此我们希望在主项目目录中安装它，并更新`package.json`文件。使用您的命令行终端程序，更改位置到您的`projects`文件夹，并通过`npm`安装Mongoose，确保使用`--save`标志以更新`package.json`文件：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With Mongoose installed and the `package.json` file updated for the project,
    we're ready to open a connection to our MongoDB server. For our app, we are going
    to open a connection to the MongoDB server once the app itself boots up and maintains
    an open connection to the database server for the duration of the app's lifetime.
    Let's edit the `server.js` file to include the connection code we need.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Mongoose并更新了项目的`package.json`文件后，我们准备打开与MongoDB服务器的连接。对于我们的应用程序，我们将在应用程序启动时打开与MongoDB服务器的连接，并在应用程序的整个生命周期内保持与数据库服务器的开放连接。让我们编辑`server.js`文件，包括我们需要的连接代码。
- en: 'First, include Mongoose in the app by requiring it at the very top of the file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在文件的顶部包含Mongoose：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, insert the following code right after the `app = config(app);` line:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`app = config(app);`行后面插入以下代码：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That's it! Those few simple lines of code are all it takes to open a connection
    to a MongoDB server, and our app is ready to start communicating with the database.
    The parameter we pass to the `connect` function of Mongoose is a URL string to
    our locally running MongoDB server with a path to the collection we want to use.
    The ``useMongoClient`` is used to opt the new connection method as the default
    method but will be deprecated once we start using Mongo version 4.11.0 and above.
    Further, we add an event listener to the `open` event of the `mongoose.connection`
    object, and when that fires, we simply log an output message that the database
    server has connected.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！这几行简单的代码就可以打开与MongoDB服务器的连接，我们的应用程序已经准备好开始与数据库通信。我们传递给Mongoose的`connect`函数的参数是一个URL字符串，指向我们本地运行的MongoDB服务器，并带有我们要使用的集合的路径。``useMongoClient``用于选择新的连接方法作为默认方法，但一旦我们开始使用Mongo版本4.11.0及以上版本，它将被弃用。此外，我们为`mongoose.connection`对象的`open`事件添加了一个事件侦听器，当它触发时，我们只需记录一个输出消息，即数据库服务器已连接。
- en: Defining the schemas and models
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模式和模型
- en: 'For the purposes of the application we are building, we''re going to have only
    two different, unique schemas and associated models: an `Image` model and a `Comment`
    model. If we were to take this application to production and really build it out
    with all of the necessary features, we would expect to have many more models as
    well.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们正在构建的应用程序，我们将只有两种不同的唯一模式和相关模型：`Image`模型和`Comment`模型。如果我们将这个应用程序投入生产并真正构建它，具有所有必要功能，我们还希望有更多的模型。
- en: 'First, create a new directory labeled `models` in your project, and we will
    store the Node.js modules for each of our models here. Create three files named
    `image.js`, `comment.js`, and `index.js` in this directory. Let''s take a look
    at the `Image` model first. Copy the following block of code into the `models/image.js`
    file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在项目中创建一个名为`models`的新目录，我们将在这里存储每个模型的Node.js模块。在此目录中创建三个文件，命名为`image.js`，`comment.js`和`index.js`。让我们首先看一下`Image`模型。将以下代码块复制到`models/image.js`文件中：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'First, we define our `ImageSchema` with the various fields that we are going
    to store in MongoDB for each of the images. We created a `virtual` property of
    `uniqueId`, which is just the filename with the file extension removed. As we
    want our `Image` model to be available throughout the rest of our app, we export
    it using `module.exports`. Note that we are exporting the model, not the schema
    (as the schema itself is fairly useless to us). Let''s set up a similar model
    for comments. Copy the following block of code into the `models/comment.js` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用各种字段定义了我们的`ImageSchema`，这些字段将存储在MongoDB中的每个图像。我们创建了一个`uniqueId`的`virtual`属性，它只是去掉文件扩展名的文件名。由于我们希望我们的`Image`模型在应用程序的其余部分中可用，我们使用`module.exports`导出它。请注意，我们正在导出模型，而不是模式（因为模式本身对我们来说相当无用）。让我们为评论设置一个类似的模型。将以下代码块复制到`models/comment.js`文件中：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are a few important things to take note of with this model. First, we
    have
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件重要的事情需要注意这个模型。首先，我们有
- en: a field labeled `image_id`, which has an `ObjectId` type. We're going to use
    this
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`image_id`的字段，其类型为`ObjectId`。我们将使用这个
- en: field to store the relationship between the `comment` and `image` that it was
    posted to.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储`comment`和`image`之间关系的字段。
- en: The `ObjectId` that gets stored in this field is the `_id` of the related image
    document from MongoDB.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在此字段中的`ObjectId`是来自MongoDB的相关图像文档的`_id`。
- en: We also define `virtual` on the `comment` schema labeled `image`, which we provide
    a getter and setter for. The `image` virtual property will be how we attach the
    related image when we retrieve comments later in our controllers. For every comment,
    we are going to iterate through and look up its associated image and attach that
    `image` object as a property of the comment.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`comment`模式上定义了`virtual`，标记为`image`，我们为其提供了getter和setter。当我们在控制器中稍后检索评论时，`image`虚拟属性将是我们附加相关图像的方式。对于每条评论，我们将遍历并查找其关联的图像，并将该`image`对象作为评论的属性附加上去。
- en: Handling the name of collections
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 处理集合的名称
- en: You name your models using singular terms, and Mongoose will recognize this
    and create your collections using pluralized model names. So, a model defined
    as `Image` will have a collection in MongoDB named `images`. Mongoose tries to
    be smart about this; however, a model defined as `Person` will have a corresponding
    collection named `people`, and so on. (And yes, octopus will result in octopi!)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用单数形式命名您的模型，Mongoose会识别这一点，并使用复数形式的模型名称创建您的集合。因此，在MongoDB中定义为`Image`的模型将具有名为`images`的集合。Mongoose会尝试智能处理这一点；但是，在MongoDB中定义为`Person`的模型将具有名为`people`的对应集合，依此类推。（是的，octopus会导致octopi！）
- en: The models index file
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型索引文件
- en: There's one last file in the `models` folder that we haven't yet touched on
    in our project. The `index.js` file within any folder in Node.js acts as an `index`
    file for the modules within it. This is by convention, so you don't have to adhere
    to this if you don't want to.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，还有一个我们尚未涉及的`models`文件夹中的最后一个文件。“index.js”文件在Node.js中的任何文件夹中都充当其中模块的“index”文件。这是按照惯例的，所以如果您不想遵循这个规则，也是可以的。
- en: 'Since our `models` folder will contain a number of different files, each a
    unique module for one of our models, it would be nice if we could just include
    all of our models in a single `require` statement. Using the `index.js` file,
    we can do so pretty easily too. Copy the following block of code into the `models/index.js`
    file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的“models”文件夹将包含许多不同的文件，每个文件都是我们模型中的一个独特模块，如果我们可以在单个`require`语句中包含所有模型，那将是很好的。使用“index.js”文件，我们也可以很容易地做到这一点。将以下代码块复制到“models/index.js”文件中：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `index.js` file inside the `models` directory simply defines a JavaScript
    object that consists of a name-value pair for each module in our directory. We
    manually maintain this object, but this is the simplest implementation of the
    concept. Now, thanks to this basic file, we can perform `require('./models')`
    anywhere in our application and know that we have a dictionary of each of our
    models via that module. To reference a specific model in that module, we simply
    refer to the specific model as a property of the module. If we only wanted to
    require a specific model somewhere in our app instead, we could perform `require('./models/image')`
    just as easily! You will see more of this a little later, and it will become much
    clearer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: “models”目录中的“index.js”文件只是定义了一个JavaScript对象，其中包含我们目录中每个模块的名称-值对。我们手动维护这个对象，但这是概念的最简单实现。现在，由于这个基本文件，我们可以在应用程序的任何地方执行“require('./models')”，并知道我们通过该模块拥有每个模型的字典。要引用该模块中的特定模型，我们只需将特定模型作为模块的属性引用。如果我们只想在应用程序的某个地方要求特定的模型，我们也可以轻松地执行“require('./models/image')”！稍后您将看到更多内容，这将变得更加清晰。
- en: Because our two models are so closely related, we are typically always going
    to require the `models` dictionary using `require('./models')` throughout our
    application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的两个模型是如此密切相关，所以我们通常会在整个应用程序中始终使用`require('./models')`来要求“models”字典。
- en: Adding CRUD to the controllers
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向控制器添加CRUD
- en: '**CRUD** stands for Create, Read, Update, and Delete. Now that our schemas
    are defined and our models are ready, we need to start using them throughout our
    application by updating our controllers with various CRUD methods where necessary.
    Up until this point, our controllers have consisted of only fixture, or fake,
    data, so we can prove that our controllers are working and our view models were
    wired up to our templates. The next logical step in our development is to populate
    our View models with data directly from MongoDB. It would be even better if we
    could just pass our Mongoose models right to our templates as `viewModel` itself.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**CRUD**代表创建、读取、更新和删除。现在我们的模式已经定义好，我们的模型也准备就绪，我们需要通过在必要时更新我们的控制器，使用各种CRUD方法在整个应用程序中开始使用它们。直到这一点，我们的控制器只包含了占位符或假数据，因此我们可以证明我们的控制器正在工作，并且我们的视图模型已经连接到我们的模板。我们开发的下一个逻辑步骤是直接从MongoDB中填充我们的视图模型。如果我们可以直接将我们的Mongoose模型传递给我们的模板作为`viewModel`本身，那将更好。'
- en: The home controller
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主控制器
- en: 'If you recall from the *Updating the home controller* section of [Chapter 6](f6aebdd0-b566-4ea8-ac24-9d73cb7ee761.xhtml),
    *Controllers and View Models*, we originally created `viewModel`, which consisted
    of an array of JavaScript objects that were just placeholder fixture data in our
    home controller:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回忆一下[第6章](f6aebdd0-b566-4ea8-ac24-9d73cb7ee761.xhtml)“更新主控制器”部分，*控制器和视图模型*，我们最初创建了`viewModel`，其中包含了主控制器中的一组JavaScript对象，这些对象只是占位符数据：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We are going to replace that `viewModel` with a very stripped-down version
    that we will then populate with real data from our Mongoose models:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个非常简化的版本替换`viewModel`，然后从我们的Mongoose模型中填充它们的真实数据：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before we can populate that `viewModel` with real data, we need to first make
    sure our home controller can use our models. To do so, we must require the `models`
    module. Include this at the very top of the `controllers/home.js` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以用真实数据填充`viewModel`之前，我们首先需要确保我们的主控制器可以使用我们的模型。为此，我们必须要求“models”模块。将其包含在“controllers/home.js”文件的顶部：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We could have required the full `models` module and had access to both the
    `Comment` model and the `Image` model; however, for the home page, we really only
    need to use the `Image` model. Now, our `mongoose` model for `Image` is available
    to our home controller, and we can perform a `find` operation to retrieve a list
    of the newest images to display on the home page. Replace the existing `sidebar()`
    call in your home controller with this updated version of the code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以要求完整的`models`模块，并且可以访问`Comment`模型和`Image`模型；然而，对于主页，我们实际上只需要使用`Image`模型。现在，我们的`mongoose`模型对于主页控制器是可用的，我们可以执行`find`操作来检索最新图片的列表，以便在主页上显示。用这段代码更新你的主页控制器中现有的`sidebar()`调用：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using `ImageModel`, we execute a MongoDB `find` query, but we provide no specifics
    for the actual query (a blank JavaScript object), which means it will return every
    document. The second parameter is also a blank JavaScript object, which means
    we aren't specifying how to map the results, so the full schema will be returned.
    The third parameter is an `options` object, where we can specify things such as
    the `sort` field and order. In this particular query, we are retrieving every
    single image in the images collection sorted by `timestamp` in descending order
    (ascending order would have a value of `1` instead of `-1`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ImageModel`，我们执行了一个MongoDB的`find`查询，但是我们没有为实际查询提供任何具体信息（一个空的JavaScript对象），这意味着它将返回每个文档。第二个参数也是一个空的JavaScript对象，这意味着我们没有指定如何映射结果，因此将返回完整的模式。第三个参数是一个`options`对象，我们可以在其中指定诸如`sort`字段和顺序之类的东西。在这个特定的查询中，我们按照时间戳的降序检索了图像集合中的每个图像（升序的顺序将具有`1`而不是`-1`的值）。
- en: The `callback` function that executes after a successful `find` query to the
    MongoDB database server will return both an `error` object and an `images` array
    of matching models; in our case, it is with every image in the database. Using
    the array that's returned from the query, we simply attach it to our `viewModel`
    via its `images` property. Then, we call our `sidebar` function exactly as we
    did previously.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行对MongoDB数据库服务器的`find`查询后执行的`callback`函数将返回一个`error`对象和一个匹配模型的`images`数组；在我们的情况下，它是数据库中的每个图像。使用从查询返回的数组，我们简单地通过其`images`属性将其附加到我们的`viewModel`上。然后，我们调用我们的`sidebar`函数，就像我们之前做的那样。
- en: 'At this point, we are no longer populating `viewModel` with fixture data, but
    are instead populating it with exactly what is returned from the database when
    we perform a basic `find` query using our Mongoose `Image` model. The home page
    for the application is officially data driven. Here is a recap of the entire `controllers/home.js`
    file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们不再用固定数据填充`viewModel`，而是用我们的Mongoose`Image`模型执行基本的`find`查询时返回的数据来填充它。应用程序的主页现在正式是数据驱动的。以下是整个`controllers/home.js`文件的概述：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you were to run the app and open it in a browser, you wouldn't actually see
    anything on the home page. That's because we haven't actually inserted any data
    yet. That's coming up next. However, note that the page itself still works and
    you don't get any errors. This is because MongoDB is simply returning an empty
    array from the `find` on `ImageModel`, which the Handlebars home page template
    is handling fine because it's performing an `each` operation against an empty
    array, so it's displaying zero images on the home page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序并在浏览器中打开它，你实际上在主页上看不到任何东西。这是因为我们实际上还没有插入任何数据。接下来就要来了。但是，请注意页面本身仍然可以工作，你不会收到任何错误。这是因为MongoDB只是从`ImageModel`的`find`中返回一个空数组，Handlebars主页模板可以很好地处理，因为它对空数组执行了`each`操作，所以在主页上显示零张图片。
- en: The image controller
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像控制器
- en: The `image` controller is by far the biggest component of our application. It
    contains most, if not all, of the logic that's powering our app. This includes
    displaying all of the details for an image, handling the uploading of images,
    and handling likes and comments. There's a lot to cover in this controller, so
    let's break it down by each section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`image`控制器是我们应用程序中最大的组件。它包含了大部分，如果不是全部，支撑我们应用程序的逻辑。这包括显示图像的所有细节，处理图像的上传，以及处理喜欢和评论。在这个控制器中有很多内容要涵盖，所以让我们按每个部分来分解。'
- en: Index - retrieving an image model
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引 - 检索图像模型
- en: The primary responsibility of the `index` function in our `image` controller
    is to retrieve the details for a single, specific image, and display that via
    its `viewModel`. In addition to the details for the actual image, the comments
    for an image are also displayed on the page in the form of a list. Whenever an
    image is viewed, we also need to update the view count for the image and increment
    it by one.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`image`控制器中`index`函数的主要责任是检索单个特定图像的详细信息，并通过其`viewModel`显示出来。除了实际图像的详细信息之外，图像的评论也以列表的形式显示在页面上。每当查看图像时，我们还需要更新图像的查看次数，并将其增加一次。
- en: 'Begin by editing the `controllers/image.js` file and updating the list of required
    modules at the top, to include our `models` module:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编辑`controllers/image.js`文件，并在顶部更新所需模块的列表，包括我们的`models`模块：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also want to strip `viewModel` down to its most basic form, exactly as we
    did in the home controller. Replace the existing `viewModel` object variable with
    this new, lighter version:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望将`viewModel`简化到最基本的形式，就像我们在主页控制器中所做的那样。用这个新的、更轻的版本替换现有的`viewModel`对象变量：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After defining a blank `viewModel`, let''s include a `find` call on the `Image`
    model so that we can look up an image specifically by its `filename`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义一个空的`viewModel`之后，让我们在`Image`模型上包含一个`find`调用，以便我们可以通过其`filename`查找特定的图像：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we are using the `Models` module's `Image` model and
    performing `findOne`, which is identical to `find`, except it will only ever return
    a single document (matching or not), instead of an array like `find` returns.
    By convention, we use a singular variable name in our callback's second parameter
    versus a plural one, just so we, as developers, can easily tell whether we are
    working with a single object or an array/collection of objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`Models`模块的`Image`模型并执行`findOne`，它与`find`相同，只会返回单个文档（匹配或不匹配），而不是`find`返回的数组。按照惯例，我们在回调的第二个参数中使用单数变量名，而不是复数变量名，这样我们作为开发人员就可以轻松地知道我们是在处理单个对象还是一组对象/集合。
- en: The `query` object we provide as the first parameter matches the `filename`
    field of an image document using MongoDB's `regex` filter and compares this to
    `req.params.image_id`, which is the value of the parameter in the URL as defined
    in our `routes` file. The URL for an image page will always be `http://localhost:3300/images/abcdefg`,
    where `abcdefg` will be the value of `req.params.image_id`. If you recall, we
    are randomly generating this value in the `create` function when an image is uploaded.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的`query`对象作为第一个参数匹配了MongoDB的`regex`过滤器中的图像文档的`filename`字段，并将其与`req.params.image_id`进行比较，这是URL中参数的值，如我们的`routes`文件中定义的那样。图像页面的URL将始终是`http://localhost:3300/images/abcdefg`，其中`abcdefg`将是`req.params.image_id`的值。如果您还记得，我们在上传图像时在`create`函数中随机生成这个值。
- en: After checking to make sure our `err` object isn't null, we then check to make
    sure our `image` object is also not null. If it's not null, that means a model
    was returned from MongoDB; so, we found our image, and we're good to go. If an
    `image` model wasn't returned, because we tried searching for an image by a filename
    that doesn't exist, we simply redirect the user back to the home page.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保我们的`err`对象不为空的情况下，我们然后检查我们的`image`对象也不为空。如果它不为空，这意味着从MongoDB返回了一个模型；因此，我们找到了我们的图像，一切正常。如果没有返回`image`模型，因为我们尝试搜索不存在的文件名的图像，我们只需将用户重定向回主页。
- en: 'Let''s now populate our `viewModel` by inserting the following lines into the
    area where we have the `// to do...` placeholder comment:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过在`// to do...`占位符注释的区域插入以下行来填充我们的`viewModel`：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We attach the `image` model that was returned from `findOne` to our `viewModel.image`
    property, but not before incrementing the `views` property of that model by `1`
    (so that we represent our actual plus one view as we load the page). Since we
    modified the model (by incrementing its view count), we need to ensure that it's
    saved back to MongoDB, so we call the model's `save` function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`findOne`返回的`image`模型附加到我们的`viewModel.image`属性上，但在此之前，我们需要将该模型的`views`属性增加`1`（以便在加载页面时表示实际的加一次查看）。由于我们修改了模型（通过增加其视图计数），我们需要确保将其保存回MongoDB，因此我们调用模型的`save`函数。
- en: Now that `viewModel` has been updated with the `image` model and the view
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`viewModel`已经使用`image`模型和视图更新了
- en: 'count has been incremented and saved, we need to retrieve a list of comments
    associated with the image. Let''s include a little bit more code to query the
    `Comment` model and find any comments that belong to the image. Insert the following
    block of code immediately after `image.save();` from earlier:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 计数已经增加并保存，我们需要检索与图像关联的评论列表。让我们在之前的`image.save();`之后立即插入一些代码块：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using `find` on our `Comment` model, we can pass in an object that contains
    our query as the first parameter; in this case, we are specifying that we want
    all comments where the `image_id` field is equal to the `_id` property of the
    main `image` model
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`Comment`模型上的`find`，我们可以将包含我们查询的对象作为第一个参数传递；在这种情况下，我们指定要获取所有`image_id`字段等于主`image`模型的`_id`属性的所有评论
- en: we attached to our `viewModel` earlier.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前附加到`viewModel`上的。
- en: That code might look a little odd, so let's elaborate. Remember that the `image`
    object that is returned from the original `Models.Image.findOne()` call is available
    throughout the entire scope of that `callback` function. No matter how deep we
    get nesting `callback` functions, we will always have access to that original
    `image` model. Therefore, we can access it and its properties inside the `callback`
    function that fires when our `Model.Comment.find()` has executed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能看起来有点奇怪，所以让我们详细解释一下。请记住，从原始的`Models.Image.findOne()`调用返回的`image`对象在整个`callback`函数的范围内都是可用的。无论我们嵌套多深的`callback`函数，我们始终可以访问原始的`image`模型。因此，我们可以在`Model.Comment.find()`执行时触发的`callback`函数内访问它及其属性。
- en: Once inside the `find` callback of `Comment`, we attach the `comments` array
    that was returned to our `viewModel` and then call our `sidebar` function exactly
    as we did when we first opened the controller and started editing this `index`
    function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入`Comment`的`find`回调，我们将返回的`comments`数组附加到我们的`viewModel`，然后像我们第一次打开控制器并开始编辑这个`index`函数时一样调用我们的`sidebar`函数。
- en: 'As a review, here is the entire `index` function inside the `controllers/image.js`
    file after it''s been completely updated:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，在`controllers/image.js`文件中完全更新后，整个`index`函数如下：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s quickly recall all of the `index` controller''s responsibilities and
    tasks:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下`index`控制器的责任和任务：
- en: Create a new empty `viewModel` object.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空`viewModel`对象。
- en: Create the `findOne imagefindOneimage` model, where the filename is a regex
    match to the URL `image_id` parameter.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`findOne imagefindOneimage`模型，其中文件名是与URL`image_id`参数匹配的正则表达式。
- en: Increment the found views of the `image` by one.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将找到的`image`的视图增加一次。
- en: Attach the found `image` model to `viewModel`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将找到的`image`模型附加到`viewModel`。
- en: Save the `image` model since its `view`s have been updated.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`image`模型，因为它的`view`已经更新。
- en: Find all comments with the `image_id` property equal to the `_id` of
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找所有`image_id`属性等于`_id`的评论
- en: the original `image` model.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`image`模型。
- en: Attach the array of found `comments` to `viewModel`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将找到的`comments`数组附加到`viewModel`。
- en: Render the page using `sidebar`, passing in the `viewModel`, and the
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sidebar`渲染页面，传入`viewModel`和
- en: '`callback` function.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback`函数。'
- en: Create - inserting an image model
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 - 插入图像模型
- en: We already have the functionality in place in our `create` function to handle
    randomly naming and uploading an image file. Now, we need to save that information
    to MongoDB for the uploaded image.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的`create`函数中放置了处理随机命名和上传图像文件的功能。现在，我们需要将该信息保存到MongoDB中以供上传的图像使用。
- en: Let's update the original `saveImage` function inside `controllers/images.js:create`
    and include the functionality to tie it into the database.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`controllers/images.js:create`中原始的`saveImage`函数，并包括将其与数据库联系起来的功能。
- en: Our goal with the `saveImage` function is twofold. First, we want to make sure
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`saveImage`函数的目标是双重的。首先，我们要确保
- en: that we never save an image with the same randomly generated filename as an
    already existing image to the database. Second, we want to ensure that we only
    insert the image into the database after it has been successfully uploaded, renamed,
    and saved to the filesystem. We are going to make two modifications to the existing
    code to achieve this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远不会将具有与数据库中已存在的图像相同的随机生成文件名的图像保存到数据库中。其次，我们希望确保只有在成功上传、重命名和保存到文件系统后才将图像插入到数据库中。我们将对现有代码进行两处修改以实现这一点。
- en: 'The first modification is to wrap the bulk of the logic with `find` against
    the randomly generated filename, and if any documents are returned as a match
    from MongoDB, to start the process over and repeat this as many times as necessary
    until we achieve a truly unique filename. The code to perform the search is as
    follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个修改是用`find`对随机生成的文件名进行大部分逻辑包装，如果从MongoDB返回任何文档作为匹配项，就重新开始这个过程，并重复这个过程直到实现真正的唯一文件名。执行搜索的代码如下：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If an `images` array that is returned from `find` has a length greater than
    zero, it means at least one image was found to have the same filename as was generated
    with our random `for` loop. If that's the case, we want to call `saveImage` again,
    which will repeat the whole process (randomly generate a new name and perform
    a `find` on the database for that new name). We do this by previously defining
    the `saveImage` function as a variable, so that within the `saveImage` function
    itself, we can execute it again by calling the original variable as the function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从`find`返回的`images`数组的长度大于零，则意味着至少找到一个具有与我们的随机`for`循环生成的相同文件名的图像。如果是这种情况，我们希望再次调用`saveImage`，这将重复整个过程（随机生成一个新名称并在数据库中执行`find`）。我们通过先定义`saveImage`函数作为变量来实现这一点，这样在`saveImage`函数本身内部，我们可以通过调用原始变量作为函数来再次执行它。
- en: A function that calls itself is called a **recursive** function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 调用自身的函数称为**递归**函数。
- en: 'Originally, the last step of the `create` function was to redirect the visitor
    to the image''s page within the `callback` that fired when the filesystem rename
    was finished. This is where we''re going to want to create a new Mongoose `image`
    model. We should redirect only when the database server has finished saving the
    image (again relying on a `callback` function). Consider the following line in
    the original function: assuming no images were returned from `find`, it means
    we have generated a truly unique filename for our image and we are safe to rename
    the file and upload it to the server, as well as save a record to the database:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`create`函数的最后一步是在文件系统重命名完成时触发的`callback`中将访问者重定向到图像的页面。这是我们希望创建一个新的Mongoose`image`模型的地方。我们应该只在数据库服务器完成保存图像时才重定向（再次依赖于`callback`函数）。考虑原始函数中的以下行：假设从`find`中没有返回图像，这意味着我们已经为我们的图像生成了一个真正独特的文件名，并且我们可以安全地重命名文件并将其上传到服务器，以及在数据库中保存记录：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Replace this with this new block of code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个新的代码块替换这个：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we create a brand new `Image` model and pass in the default values via
    its constructor. The `title` and `description` fields get set right from the values
    passed in via the HTML form using `req.body` and the form field names (`.title`
    and `.description`). The `filename` parameter is built the same way as when we
    originally we set its destination for renaming it, except we don't include the
    path and directory names, just the randomly generated filename and the image's
    original extension.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个全新的`Image`模型，并通过其构造函数传入默认值。`title`和`description`字段直接从通过`req.body`和表单字段名称（`.title`和`.description`）传入的值设置。`filename`参数的构建方式与我们最初设置其重命名目的地的方式相同，只是我们不包括路径和目录名称，只包括随机生成的文件名和图像的原始扩展名。
- en: We call the model's `.save()` function (just as we did earlier, when we updated
    the image's `views` property in the `index controller` function). The `save` function
    accepts a second parameter in its `callback`, which will be the updated version
    of itself. Once the `save` is completed and the image has been inserted into the
    MongoDB database, we then redirect to the image's page. The reason the `callback`
    returns the updated version of itself is because MongoDB automatically includes
    additional information, such as `_id`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用模型的`.save()`函数（就像我们之前在`index controller`函数中更新图像的`views`属性时所做的那样）。`save`函数在其`callback`中接受第二个参数，这将是其更新版本。一旦`save`完成并且图像已插入到MongoDB数据库中，我们就会重定向到图像的页面。`callback`返回其更新版本的原因是因为MongoDB自动包含其他信息，如`_id`。
- en: 'As a review and sanity check, here is the complete code for the `saveImage`
    function in `controllers/image.js:create`, with the new lines of code clearly
    highlighted:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为审查和合理检查，这是`controllers/image.js:create`中`saveImage`函数的完整代码，新添加的代码已经清晰地标出：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Don't forget to initially execute `saveImage()` right after the function is
    defined; otherwise, nothing will happen!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在函数定义后立即执行`saveImage()`；否则，什么也不会发生！
- en: Testing everything out so far
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迄今为止测试一切
- en: 'At this point, we have most of the key functionalities wrapped with MongoDB
    integration, and our app should really feel like it''s coming together. Let''s
    give it a test run and make sure all of our endpoints are working so far. Launch
    the app and open it in a browser:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将大部分关键功能与MongoDB集成起来，我们的应用程序应该真的感觉像是在一起了。让我们进行一次测试运行，确保到目前为止我们的所有端点都在工作。启动应用程序并在浏览器中打开它：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Open up a browser, point it to `http://localhost:3300`, and you should see
    your application up and running, as shown in the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，将其指向`http://localhost:3300`，你应该看到你的应用程序正在运行，如下面的截图所示：
- en: '![](img/0795cd31-1061-425e-88db-ba6224ae6075.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0795cd31-1061-425e-88db-ba6224ae6075.png)'
- en: 'Go ahead and use the form on the home page to search for an image file on your
    computer and select it. Provide an input for Title and Description and click on
    the Upload Image button. You should be taken directly to the image page, with
    the details for your uploaded image displayed:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用首页上的表单，在你的电脑上搜索一张图片文件并选择它。提供标题和描述的输入，然后点击“上传图片”按钮。你应该直接进入图片页面，显示你上传的图片的详细信息：
- en: '![](img/fd3e15ab-44ab-4fe7-991c-ecfb302073f4.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd3e15ab-44ab-4fe7-991c-ecfb302073f4.png)'
- en: 'Go back to the home page, and you should now see your new image displayed under
    the Newest Images section:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 返回首页，你现在应该在“最新图片”部分看到你的新图片显示出来了：
- en: '![](img/1dbedcae-ec77-47d3-838f-74f191d7b6a5.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dbedcae-ec77-47d3-838f-74f191d7b6a5.png)'
- en: The like button and updating an image model
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点赞按钮和更新图片模型
- en: Next, let's add support for the Like button. Remember that our Like button works
    a little differently. It uses AJAX with jQuery so that data can be sent and received
    in real time without reloading the entire page. The experience for the user is
    seamless and enjoyable, as they don't lose their scroll place on the page or experience
    any other jarring UI-related issues.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为“喜欢”按钮添加支持。记住我们的“喜欢”按钮的工作方式有点不同。它使用了带有jQuery的AJAX，这样数据可以实时发送和接收，而不用重新加载整个页面。用户的体验是无缝和愉快的，因为他们不会失去页面上的滚动位置，也不会遇到其他令人不快的与UI相关的问题。
- en: The endpoint that the Like button hits is `/images/:image_id/like`, so we are
    going to use the value in the URL for `image_id` to find and retrieve the image
    in MongoDB, increment its `likes` value by `1`, and then return the new total
    number of `likes` for the image (so that the UI can update with the new value).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: “喜欢”按钮点击的端点是`/images/:image_id/like`，所以我们将使用URL中的`image_id`的值来在MongoDB中找到并检索图片，将其`likes`值增加`1`，然后返回图片的新总点赞数（以便UI可以更新为新值）。
- en: 'Currently, the `like` function in `controllers/image.js` only does a simple
    JSON response with a hardcoded value of `1`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`controllers/image.js`中的`like`函数只是简单地用一个硬编码值`1`做JSON响应：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s replace that original code with new code that will use the Mongoose
    `Image` model to find an image with a filename that matches the `image_id` passed
    in via the URL:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用新的代码替换原始代码，这段代码将使用Mongoose的`Image`模型来查找一个文件名与通过URL传递的`image_id`匹配的图片：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Assuming the `callback` function receives a valid `image` model response from
    the query, we'll then increment its `likes` property, and since the model is then
    modified, we need to execute its `save` function. Inside the `save` function's
    `callback`, we send a JSON response with the real current value of the image's
    likes back to the browser.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`callback`函数从查询中接收到一个有效的`image`模型响应，我们将增加它的`likes`属性，然后由于模型被修改，我们需要执行它的`save`函数。在`save`函数的`callback`中，我们发送一个JSON响应，其中包含图片点赞的实际当前值，返回给浏览器。
- en: 'Sometimes, we will use shorthand in JavaScript and write something similar
    to the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会在JavaScript中使用简写，写出类似以下的内容：
- en: '`if (!err && image)`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (!err && image)`'
- en: In the `if` statement in the preceding example, we are saying, if the `err`
    object is `false` (that is `null`) and the `image` object is `true` (that is not
    `null`), then we're good to go!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中的`if`语句中，我们在说，如果`err`对象是`false`（即`null`），并且`image`对象是`true`（即不是`null`），那么我们就可以继续了！
- en: With this code in place, you can run the app again and test out the Like button
    by viewing the image that you uploaded earlier and simply clicking on Like. If
    it worked, the counter next to the button should increase by one. Refresh the
    page, and the likes count should remain as the new value.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，你可以再次运行应用程序，通过查看你之前上传的图片并点击“喜欢”按钮来测试。如果成功，按钮旁边的计数器应该增加一。刷新页面，点赞数应该保持为新值。
- en: Comment - inserting a comment model
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评论 - 插入评论模型
- en: 'Inserting comments will work almost exactly the same way as the likes for an
    image. The only difference is that we are creating a new `comment` model, instead
    of updating an `image` model. The original code we had in our `comment` function
    was:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 插入评论的工作方式几乎与给图片点赞的方式完全相同。唯一的区别是我们创建了一个新的`comment`模型，而不是更新一个`image`模型。我们在`comment`函数中原来的代码是：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s replace this with some code that will find the image by `image_id` in
    the URL again, but this time, instead of updating its likes, we are going to create
    a new comment and assign the comment''s `image_id` value with the `_id` of the
    image we are currently viewing (this is to attach a relationship to the comment
    so that it actually belongs to an image). Replace the entire `comment` function
    in `controllers/image.js` with the following block of code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些代码来替换这段文字，代码将再次通过`image_id`在URL中找到图片，但这一次，我们不是更新它的点赞，而是创建一个新的评论，并将评论的`image_id`值赋予我们当前查看的图片的`_id`（这是为了将评论与图片关联起来，使其实际上属于一张图片）。用以下代码块替换`controllers/image.js`中的整个`comment`函数：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, you can see that we are using the same code from the `like` function to
    query MongoDB and find the image with the matching `filename` from the URL.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们正在使用与`like`函数相同的代码来查询MongoDB，并从URL中找到与`filename`匹配的图片。
- en: 'Assuming a valid image is returned as a match, we create a new `comment` object
    called `newComment` and actually pass the entire HTML form body into the constructor.
    This is a bit of a cheat, as it''s a coincidence that our HTML form uses `form`
    fields that have the same name and structure as that of a `comment` model. If
    you were to perform the `console.log` operation on the `req.body` object, you
    would see something like the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个有效的图片作为匹配返回，我们创建一个名为`newComment`的新的`comment`对象，并将整个HTML表单主体传递给构造函数。这有点作弊，因为我们的HTML表单恰好使用了与`comment`模型相同的名称和结构的`form`字段。如果你对`req.body`对象执行`console.log`操作，你会看到类似以下的内容：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: That's identical to what we would have built manually anyway, so we just take
    a shortcut and pass the whole thing in as it is! After that, we update a few more
    properties on the `newComment` model. First, we manually set a `gravatar` property,
    which is where we will store the MD5 hash value of the commenter's email address
    so that we can retrieve their Gravatar profile picture. Gravatar is a universal
    avatar service that stores profile pictures based on a user's email address. However,
    the unique ID they use for each profile is an MD5 hash value, which is why we
    have to store that value.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们手动构建的内容完全相同，所以我们只是采取了一种捷径，将整个内容传递进去！之后，我们更新了`newComment`模型的一些属性。首先，我们手动设置了一个`gravatar`属性，这是我们将存储评论者的电子邮件地址的MD5哈希值，以便我们可以检索他们的Gravatar个人资料图片。Gravatar是一个根据用户的电子邮件地址存储个人资料图片的通用头像服务。然而，他们用于每个个人资料的唯一ID是一个MD5哈希值，这就是为什么我们必须存储该值。
- en: 'As we are relying on the third-party MD5 module, we need to ensure that it''s
    installed in our project and saved to our `package.json` file as a dependency.
    From your project''s root folder, execute the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们依赖第三方的MD5模块，我们需要确保它已经安装在我们的项目中，并且作为一个依赖保存在我们的`package.json`文件中。从你的项目根文件夹中，执行以下命令：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In addition, we need to require the module in the `controllers/image.js` file
    at
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要在`controllers/image.js`文件中要求该模块
- en: 'the very top, along with the other modules we are requiring:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，以及我们需要的其他模块一起：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finally, we set the `image_id` property of `newComment` to the `_id` property
    of the image we found at the beginning of the function. Then, we call the `comment`
    model's `.save()` function and redirect the user back to the image page. For convenience,
    we append a bookmark to the new comment's `_id` to the URL so that when the page
    loads it will automatically scroll down to the users' comments that have just
    been posted.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`newComment`的`image_id`属性设置为函数开始时找到的图片的`_id`属性。然后，我们调用`comment`模型的`.save()`函数，并将用户重定向回图片页面。为了方便起见，我们将新评论的`_id`附加到URL中，这样当页面加载时，它将自动滚动到刚刚发布的用户评论处。
- en: 'With that functionality in place, go ahead and fire up the app and open it
    in your browser. Visit the image page for any images you''ve uploaded, and post
    a comment. Once the comment posts and the page reloads, you should see something
    like the following screenshot under an image:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个功能，继续启动应用程序并在浏览器中打开它。访问你上传的任何图片的图片页面，并发表评论。一旦评论发布并页面重新加载，你应该在图片下看到类似以下截图的东西：
- en: '![](img/5b816d54-4b12-487e-bc74-9de5ccae1af6.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b816d54-4b12-487e-bc74-9de5ccae1af6.png)'
- en: We could have chosen to handle comments using jQuery and AJAX, the same way
    we handled the Like button. However, this introduces a bit more complexity, because
    if we were to do that, we would have needed a slightly more sophisticated way
    to display that inserted comment to the screen. This would have involved relying
    heavily on jQuery to do some advanced DOM manipulation to display the comment
    after it was posted using AJAX.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以选择使用jQuery和AJAX来处理评论，就像我们处理“喜欢”按钮一样。然而，这会引入更多的复杂性，因为如果我们这样做，我们将需要一种稍微复杂的方式来显示插入的评论到屏幕上。这将涉及大量依赖jQuery来进行一些高级的DOM操作，以便在使用AJAX发布评论后显示评论。
- en: In a later chapter, when we review Single Page Applications, we will take a
    brief look at some JavaScript frameworks that perform this kind of functionality
    and a lot of other advanced features that concludes the code and functionality
    for the `image` controller.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，当我们回顾单页应用程序时，我们将简要介绍一些执行这种功能以及其他高级功能的JavaScript框架，这些功能包括`image`控制器的代码和功能。
- en: Wrapping it up
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Let''s do a quick recap of all of the changes we''ve made to this controller:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们对这个控制器所做的所有更改：
- en: We updated the `index` function to retrieve an image from MongoDB and populate
    `viewModel` with the details of the `image` model. We also found
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更新了`index`函数，从MongoDB中检索图片，并用`image`模型的细节填充`viewModel`。我们还发现
- en: all the comments related to that image and attached an array of those to `viewModel`
    as well.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与该图片相关的评论都已经插入，并将这些评论的数组附加到`viewModel`中。
- en: We tweaked the `create` function to insert a new `image` model into the database
    once it has been successfully renamed and saved to the filesystem.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调整了`create`函数，一旦成功重命名并保存到文件系统中，就会将新的`image`模型插入到数据库中。
- en: The `like` function was updated to actually increment the value of an image's
    `likes` property and save that value to the database, as well as to return the
    new value via a JSON response.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`like`函数已经更新，实际上增加了图片的`likes`属性的值，并将该值保存到数据库中，同时通过JSON响应返回新的值。'
- en: Comments are now inserted for a particular image via the `comment` function.
    Not only is a `comment` model inserted into the database, but its corresponding
    image is also found and the `image` model's `_id` value is attached to the comment
    to solidify a relationship.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在通过`comment`函数为特定的图片插入评论。不仅插入了一个`comment`模型到数据库中，而且还找到了对应的图片，并将`image`模型的`_id`值附加到评论中，以巩固关系。
- en: Helpers
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助函数
- en: The last piece of the puzzle, and the last area we need to tie into MongoDB
    is the sidebar. To do this, we are going to need to update each of the helpers
    we created previously . Most of the helpers that we write code for will be using
    the concepts and functionality that we've already covered in this chapter. However,
    there is the addition of one new concept that I want to focus on before we take
    a look at the code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图的最后一块，也是我们需要与 MongoDB 连接的最后一个领域是侧边栏。为此，我们需要更新之前创建的每个助手。我们为大多数编写代码的助手将使用本章中已经涵盖的概念和功能。但是，在我们查看代码之前，我想专注于一个新概念的补充。
- en: Introducing the async module
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 async 模块
- en: As JavaScript is asynchronous by its very nature, there will undoubtedly come
    a time when we will need a way to handle executing a number of different asynchronous
    functions at the same time. The big issue here is that if we try to perform three
    different queries on a MongoDB server, for example, how will we know when all
    three are finished before we move on and do work with the results? Up until this
    point, we've simply been relying on a single `callback` function, which works
    great for a single call. How can we assign a single `callback` function to multiple
    asynchronous calls?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 本质上是异步的，毫无疑问，总会有这样的时候，我们需要一种处理同时执行多个不同异步函数的方法。这里的一个大问题是，如果我们尝试在 MongoDB
    服务器上执行三个不同的查询，我们如何知道这三个在移动并处理结果之前何时完成？到目前为止，我们一直在依赖一个单一的 `callback` 函数，这对于单个调用非常有效。我们如何将单一的
    `callback` 函数分配给多个异步调用呢？
- en: The answer is, we can not directly anyway. You can use a lot of nested `callbacks`
    to achieve this, but that is generally considered bad practice and will significantly
    reduce the readability of your code. You can use a third-party module, however,
    that was designed very specifically for this exact need. `async` is a powerful
    node module that can be downloaded and installed via `npm` and which provides
    a number of extremely useful utility functions, all designed to help when working
    with a series of asynchronous functions. Two functions that we are going to work
    with in this chapter are `series` and `parallel`. The `series` function allows
    us to execute asynchronous functions sequentially, each waiting until the previous
    function finishes before executing a single `callback` function at the end. The
    `parallel` function allows us to do the opposite--execute a number of asynchronous
    functions simultaneously, waiting until they are all complete, then executing
    a single `callback` function when the last function is finished.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，我们无法直接做到。您可以使用许多嵌套的 `callbacks` 来实现这一点，但这通常被认为是不良实践，并且会显著降低代码的可读性。但是，您可以使用一个专门为此需求设计的第三方模块。`async`
    是一个强大的 Node 模块，可以通过 `npm` 下载和安装，提供了许多非常有用的实用程序函数，都旨在在处理一系列异步函数时提供帮助。我们将在本章中使用的两个函数是
    `series` 和 `parallel`。`series` 函数允许我们按顺序执行异步函数，每个函数等待前一个函数完成，然后在最后执行一个单一的 `callback`
    函数。`parallel` 函数允许我们执行相反的操作——同时执行多个异步函数，等待它们全部完成，然后在最后一个函数完成时执行一个单一的 `callback`
    函数。
- en: 'How does a single `callback` function handle the responses of a number of different
    asynchronous functions, you ask? The answer is:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单一的 `callback` 函数如何处理多个不同异步函数的响应？答案是：
- en: by accepting an array of the responses of each function as a parameter!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接受每个函数的响应数组作为参数！
- en: 'Since we are going to use `async` for our project, let''s install it via `npm`
    and make sure our `package.json` file is updated as well. Within the root of your
    `project` folder, execute the following from the command line:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在项目中使用 `async`，让我们通过 `npm` 安装它，并确保我们的 `package.json` 文件也得到更新。在您的 `project`
    文件夹的根目录中，从命令行执行以下操作：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The comments helper
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评论助手
- en: Let's take a look at the first use of `async` in one of our helpers, the `comments`
    helper. Originally, `helpers/comments.js` was a module that had a `newest` function
    that returned an array of fixture data with some sample comments.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的助手之一 `comments` 助手中 `async` 的第一个用法。最初，`helpers/comments.js` 是一个模块，其中有一个
    `newest` 函数，返回一个包含一些示例评论的固定数据数组。
- en: 'We are going to completely remove this code and instead query MongoDB for the
    `newest` comments and return those as an array. Start by clearing the `comment`
    helper module and starting from scratch (note that we included a new `callback`
    parameter to the `newest` function):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完全删除此代码，而是查询 MongoDB 的 `newest` 评论并将其作为数组返回。首先清除 `comment` 助手模块，并从头开始（请注意，我们向
    `newest` 函数添加了一个新的 `callback` 参数）：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Notice that we added the additional `require` statements at the top of the
    file for our `models` and `async`. Within the `newest` function, let''s replace
    the `// to do...` comment with code to query MongoDB and find the five most recent
    comments:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在文件顶部添加了额外的 `require` 语句，用于我们的 `models` 和 `async`。在 `newest` 函数中，让我们用代码替换
    `// to do...` 注释，查询 MongoDB 并找到最近的五条评论：
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that the first parameter in the `find` query is an empty JavaScript object,
    meaning we will retrieve every comment in the database. For the third parameter,
    however, we're using `limit` and `sort` so that we limit the number of records
    returned to five, and we sort the query by `timestamp` in descending order.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`find` 查询中的第一个参数是一个空的 JavaScript 对象，这意味着我们将检索数据库中的每条评论。然而，对于第三个参数，我们使用 `limit`
    和 `sort`，以便将返回的记录数量限制为五条，并按照 `timestamp` 降序排序查询。
- en: Now that we have an array of comments, we'd ideally like for the image that
    each comment belongs to to be returned as well. Typically, this would be accomplished
    by using an `aggregate` query in MongoDB to join different collections together
    (such as a `JOIN` in SQL). We will see `aggregate` in more detail in the next
    chapter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个评论数组，我们理想情况下希望返回每条评论所属的图片。通常，这可以通过在 MongoDB 中使用 `aggregate` 查询来连接不同的集合（例如
    SQL 中的 `JOIN`）来实现。我们将在下一章中更详细地了解 `aggregate`。
- en: For the purposes of our code, we're going to instead query MongoDB separately
    for each comment and retrieve the image associated with the comment's `image_id`
    value.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们代码的目的，我们将分别查询MongoDB以获取每个评论并检索与评论的`image_id`值相关联的图像。
- en: 'First, let''s define a function that will query MongoDB and retrieve and attach
    an `image` model to a `comment` model:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个函数，该函数将查询MongoDB并检索并附加`image`模型到`comment`模型：
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This function will accept a `comment` model as the first parameter and a `callback`
    function (named `next`) as the second parameter . Having the `next` callback as
    the second parameter is important, because it's the key to how `async` is able
    to function. Imagine that the next `callback` acts as a chain link. Since the
    same function is going to be called for every item in a collection, there needs
    to be a way to daisy-chain the calls together. This is performed via the `callback`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将接受一个`comment`模型作为第一个参数，并接受一个名为`next`的`callback`函数作为第二个参数。将`next`回调作为第二个参数是很重要的，因为这是`async`能够运行的关键。想象一下，下一个`callback`就像一个链环。由于同一个函数将被调用用于集合中的每个项目，因此需要一种方法来将这些调用链接在一起。这是通过`callback`来执行的。
- en: Basically, every time the `callback` is called for an item in the array, it
    performs its work and then executes the same `callback` with the next item in
    the array, and so on and so forth, which is why we named the callback function
    parameter `next`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，每次对数组中的项目调用`callback`时，它都会执行其工作，然后执行相同的`callback`以处理数组中的下一个项目，依此类推，这就是为什么我们将回调函数参数命名为`next`的原因。
- en: Another important element to point out with this function is that when we attach
    the `image` model to the comment's `image` property, we are using the `virtual`
    property we set up earlier in the main comment's schema. If you recall, when we
    set the `image` property, we were actually setting the private `_image` property.
    Likewise, when we get the `image` property, we are actually retrieving the private
    `_image` property.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的另一个重要元素是，当我们将`image`模型附加到评论的`image`属性时，我们使用了之前在主评论模式中设置的`virtual`属性。如果你还记得，当我们设置`image`属性时，实际上是在设置私有的`_image`属性。同样，当我们获取`image`属性时，实际上是在检索私有的`_image`属性。
- en: 'After we define the `attachImage` function, we need to use the `each` function
    of `async` to apply that function to every item in the `comments` collection:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了`attachImage`函数之后，我们需要使用`async`的`each`函数将该函数应用于`comments`集合中的每个项目：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `each` function of `async` will loop through every item in the collection
    in the first parameter, and send each item as a parameter to a `callback` function
    in the second parameter. The third parameter is the `final callback` function
    that is executed once the entire series is finished with the collection. In this
    case, every comment in the comment''s array will be passed individually to the
    `attachImage` function. When the entire collection has been iterated through,
    the `final callback` will execute, which basically fires the very first `callback`
    function that was passed into the `newest` function as its only parameter. Boy,
    that was a mouthful! Let''s try to break this down a little further, so it makes
    a bit more sense:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`的`each`函数将循环遍历第一个参数中集合中的每个项目，并将每个项目作为第二个参数中的`callback`函数的参数发送。第三个参数是`final
    callback`函数，一旦整个系列与集合完成，就会执行。在这种情况下，评论数组中的每个评论将单独传递给`attachImage`函数。当整个集合被迭代完毕时，将执行`final
    callback`，这基本上触发了作为其唯一参数传递给`newest`函数的第一个`callback`函数。哇，这真是一大堆！让我们试着再详细解释一下，这样就会更有意义一些：'
- en: The `newest` function of the `comment` helper module accepts a single parameter
    named `callback`- -this is the function that will be called
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comment`助手模块的`newest`函数接受一个名为`callback`的参数- -这是将被调用的函数'
- en: once all of the work in this entire function is finished.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦整个函数中的所有工作都完成了。
- en: The first thing the `newest` function does is find the latest five comments
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newest`函数的第一件事是找到最新的五条评论。'
- en: and return them as an array to an anonymously defined inline function.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 并将它们作为数组返回给一个匿名定义的内联函数。
- en: First, we define a function and store it in a variable named `attachImage`.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数并将其存储在名为`attachImage`的变量中。
- en: 'The `attachImage` function accepts two parameters: an individual comment model,
    and a callback function that we named `next`.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attachImage`函数接受两个参数：一个单独的评论模型和一个我们命名为`next`的回调函数。'
- en: The `attachImage` function will query MongoDB to find an image with
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attachImage`函数将查询MongoDB以找到与'
- en: an `_id` value that is the same as the `image_id` property of the `comment`
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 与`comment`的`image_id`属性相同的`_id`值
- en: that was passed into it as the first parameter.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递给它的作为第一个参数。
- en: Once that image is found, it is attached to the comment via its `image` property
    and then the next `callback` function is executed.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦找到该图像，它将通过其`image`属性附加到评论中，然后执行下一个`callback`函数。
- en: We use `async.each` to loop through every comment in the `comments` array that
    was passed as the first parameter to `each`.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`async.each`循环遍历作为`each`的第一个参数传递的`comments`数组中的每个评论。
- en: Pass the `attachImage` function as the second parameter, which is the function
    that will be called for every comment in the comment's array.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`attachImage`函数作为第二个参数传递，这是将为评论数组中的每个评论调用的函数。
- en: Finally, define an inline anonymous function that will be executed once the
    last item in the comments collection has been iterated on. This inline function
    itself only accepts an `error` object as its parameter. Assuming every iteration
    of the `comments` collection was successful, this function will be executed with
    no error. Inside this function, we execute the original function named `callback`
    that was the only parameter to the `newest` function, and `callback` is called
    with the newly updated comment's array as its second parameter.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，定义一个内联匿名函数，该函数将在对评论集合中的最后一项进行迭代后执行。这个内联函数本身只接受一个`error`对象作为参数。假设`comments`集合的每次迭代都成功，这个函数将在没有错误的情况下执行。在这个函数内部，我们执行了原始函数`callback`，这个函数是`newest`函数的唯一参数，并且`callback`被调用时，新更新的评论数组作为它的第二个参数。
- en: 'Okay, the hardest part is over! You survived a crash course on the `async`
    module and came out, hopefully unscathed! Just to be safe, here is the code for
    the `helpers/comments.js` module file in its entirety:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，最困难的部分已经过去了！你已经完成了关于`async`模块的速成课程，并且希望你毫发无损地度过了！为了安全起见，这里是`helpers/comments.js`模块文件的完整代码：
- en: '[PRE53]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Callbacks, callbacks, callbacks everywhere!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 到处都是回调函数！
- en: At this point, it's probably getting a little confusing with the number of `callbacks`
    we've been dealing with. A part of the problem is the terminology we've been using.
    Any function that is passed as a parameter and only executed after certain conditions
    are met, typically as the end result of the original function, is referred to
    as a `callback`. The popular convention with JavaScript is to label a `callback`
    function in a parameter literally with the variable name `callback`, so that it's
    obvious. This works great when you are reading code, but not so much when you
    are explaining code and referring to a function named `callback` that's also known
    as the `callback`!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，可能会因为我们处理的`callbacks`数量而感到有些困惑。问题的一部分是我们一直在使用的术语。任何作为参数传递并且只在满足特定条件后执行的函数，通常作为原始函数的最终结果，被称为`callback`。JavaScript的常规约定是在参数中直接使用变量名`callback`来标记`callback`函数，以便清晰明了。当你阅读代码时，这样做非常好，但当你解释代码并引用一个名为`callback`的函数时，这样做就不太好了！
- en: The sidebar helper
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边栏助手
- en: Okay! So of course, there's a catch, right!? Well, kind of. Since we introduced
    `async` in our `Comments` helper module, we now need to introduce it in our `sidebar`
    helper. This is because of the simple fact that our `Comments` helper is now really
    asynchronous, so anything that uses our `Comments` module needs to deal with that.
    As our `sidebar` module currently stands, it's just expecting the `comments` helper
    module to return an array instantly; so, it's not expecting to have to wait around
    for the actual data. Because of this, if we ran our code as is, our `comments`
    sidebar would remain blank (because the sidebar would have rendered the page before
    the MongoDB calls were even finished thinking within the `comments` module). Let's
    fix this by updating our `sidebar` helper module to use `async` as well.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！当然，肯定有一个陷阱，对吧！？嗯，有点。因为我们在`Comments`助手模块中引入了`async`，所以现在我们需要在`sidebar`助手中也引入它。这是因为我们的`Comments`助手现在真的是异步的，所以任何使用我们的`Comments`模块的东西都需要处理这一点。就我们目前的`sidebar`模块而言，它只是期望`comments`助手模块立即返回一个数组；因此，它并不期望必须等待实际数据。因此，如果我们按照现在的代码运行，我们的`comments`侧边栏将保持空白（因为侧边栏在`comments`模块内的MongoDB调用甚至完成之前就已经渲染了页面）。让我们通过更新我们的`sidebar`助手模块来解决这个问题，以便也使用`async`。
- en: 'First, let''s edit the `helpers/sidebar.js` file and replace its entire contents
    with this slightly modified version that uses `async.parallel`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编辑`helpers/sidebar.js`文件，并用稍微修改过的版本替换其整个内容，该版本使用了`async.parallel`：
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The first thing we did was make sure `async` was included as a required module
    at the top of the file. Inside the primary `exports` function, we basically wrapped
    our existing code and integrated it into `async.parallel` so that we could easily
    tweak it a little later as we updated each section of the `sidebar` helpers. Since
    we've only completed the `comments` helper module so far, that's the only one
    that's actually been changed. The other `Stats` and `Images.popular` calls are
    being forcibly used with `async.parallel`, even though it doesn't quite make sense
    to do that right now. It will once those two sections become more asynchronous
    in the next sections.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是确保在文件顶部包含`async`作为必需的模块。在主要的`exports`函数内部，我们基本上包装了现有的代码，并将其集成到`async.parallel`中，以便稍后可以轻松地对其进行调整，因为我们更新了`sidebar`助手的每个部分。由于我们目前只完成了`comments`助手模块，所以只有这个模块实际上已经被更改了。其他的`Stats`和`Images.popular`调用被强制使用`async.parallel`，即使现在这样做并不太合理。一旦这两个部分在下一节变得更加异步，这样做就会有意义。
- en: The `parallel` function of `async` works in a similar way to its `each` function
    that we used earlier. The main difference is that `parallel` isn't performing
    the same function in a loop through a collection, but is instead performing a
    series of unique functions all at the same time. If you look closely, you can
    see that the first parameter to `parallel` is actually an array, and each item
    in the array is a unique function. Every function in the array accepts a `next`
    callback parameter function, which is executed at the conclusion of each of the
    functions. The second parameter in the `next` callback is the result of the work
    that was performed within the function itself. In the case of `Stats` and `Images.popular`,
    those two functions simply return values instantly, with no asynchronous calls
    to anything else, so we just expect the results to be returned by executing them
    directly.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`的`parallel`函数的工作方式与我们之前使用的`each`函数类似。主要区别在于`parallel`不是通过集合循环执行相同的函数，而是同时执行一系列独特的函数。如果仔细观察，可以看到`parallel`的第一个参数实际上是一个数组，数组中的每个项都是一个独特的函数。数组中的每个函数都接受一个`next`回调参数函数，在每个函数结束时执行。`next`回调的第二个参数是函数本身内部执行的工作结果。在`Stats`和`Images.popular`的情况下，这两个函数只是立即返回值，没有异步调用其他任何东西，因此我们只是期望通过直接执行它们来返回结果。'
- en: However, as you can see with the `Comments.newest` section, we are passing in
    the `next` callback function as a parameter because we want its execution to be
    deferred until the last second (until `Comments.newest` has completed all of its
    work). Once that `next` callback function is called, it is passed the results
    of all of its work.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如您在`Comments.newest`部分中所看到的，我们将`next`回调函数作为参数传递，因为我们希望其执行被推迟到最后一秒（直到`Comments.newest`完成所有工作）。一旦调用了`next`回调函数，它就会传递所有工作的结果。
- en: 'The last parameter to the `parallel` function is an inline function that accepts
    a results array as its second parameter. This array is a collection of the results
    that were returned from each of the functions in the array in the first parameter.
    You can see that when we build `viewModel` now, we are referring to indexes in
    the `results` array. The index order is the order that the functions were defined
    in the original array. We know that the first function was to retrieve `Stats`,
    the second function was to retrieve `Images.popular`, and the third function was
    to retrieve `Comments.newest`. So, we can reliably assign `results[0]` to `viewModel.Stats`,
    and so on. As a reference, here is what the `viewModel` definition originally
    looked like in the `sidebar` module:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel`函数的最后一个参数是一个内联函数，它接受一个结果数组作为其第二个参数。这个数组是从第一个参数中的每个函数返回的结果的集合。您可以看到，当我们现在构建`viewModel`时，我们是在`results`数组中引用索引。索引顺序是原始数组中定义的函数的顺序。我们知道第一个函数是检索`Stats`，第二个函数是检索`Images.popular`，第三个函数是检索`Comments.newest`。因此，我们可以可靠地将`results[0]`分配给`viewModel.Stats`，依此类推。作为参考，这是`sidebar`模块中`viewModel`定义的原始样子：'
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can compare this with the updated version that uses `async`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其与使用`async`的更新版本进行比较：
- en: '[PRE56]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that the sidebar is set up to properly handle the helper modules that are
    (and eventually will be) asynchronous, we can run the application and test it
    to ensure that our sidebar is properly displaying the top five most recent comments
    on the website. Run the application and launch it in a browser. If you haven't
    already posted any comments to an image, do so now, so that you can see those
    comments appearing in the sidebar along with a thumbnail of the image they belong
    to.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在侧边栏已经设置好，可以正确处理辅助模块（以及最终将是）异步的，我们可以运行应用程序并测试它，以确保我们的侧边栏正确显示网站上最近五条评论。运行应用程序并在浏览器中启动它。如果您还没有对图像发布任何评论，请立即这样做，以便您可以在侧边栏中看到这些评论以及它们所属的图像的缩略图。
- en: Troubleshooting
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'At this point, we''ve covered and implemented a large number of changes to
    our application. It''s understandable that something might be broken for you,
    so let''s run through a quick checklist to make sure we haven''t missed any trouble
    spots that might be preventing your app from running properly:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖并实施了大量对我们应用程序的更改。可以理解，您可能会遇到一些问题，因此让我们快速检查一下，确保我们没有漏掉任何可能阻止您的应用程序正常运行的问题：
- en: Make sure you've installed all of the required modules for this chapter and
    that they are saved to your `package.json` file. This includes `mongoose`, `async`,
    and `md5`.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您已安装本章所需的所有模块，并将它们保存到您的`package.json`文件中。这包括`mongoose`，`async`和`md5`。
- en: Make sure the appropriate dependency modules are being required at the top of
    each of the module files they are used in.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个模块文件的顶部都要求适当的依赖模块。
- en: Make sure you remember to launch `mongod` in another terminal instance whenever
    you run the application.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每当运行应用程序时，在另一个终端实例中启动`mongod`。
- en: When in doubt, pay attention to the stack trace output that Node is giving you
    in your terminal when it fails, as it is typically pretty obvious what's wrong.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有疑问，当Node在终端中失败时，注意堆栈跟踪输出，通常很明显出了什么问题。
- en: It will also give you the filename and line number of the offending module.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会给出错误模块的文件名和行号。
- en: When all else fails, execute `console.log` everywhere!
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一切都失败时，到处执行`console.log`！
- en: Next up, let's update the `stats` helper module to use it parallel as well,
    so we can get some real stats for the application.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们也更新`stats`辅助模块，以便使用它并行，这样我们就可以为应用程序获取一些真实的统计数据。
- en: The stats helper
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计助手
- en: The primary responsibility of the `stats` helper module is to gather some totals
    for our application. These `stats` are for things such as the total number of
    images uploaded, the total number of comments, the total views for all the images
    combined, and the total likes for all the images combined. Your first inclination
    might be to assume that we are going to query MongoDB for all the images and loop
    through every image to track all of the views and totals. That's one way to do
    it, but it's pretty inefficient. Fortunately, MongoDB has some built-in functionalities
    which make generating these kinds of values a snap.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats`辅助模块的主要责任是为我们的应用程序收集一些总数。这些`stats`是关于上传的图片总数、评论总数、所有图片的总浏览量和所有图片的总点赞数等。你可能首先会认为我们将查询MongoDB以获取所有图片，并循环遍历每张图片以跟踪所有的浏览量和总数。这是一种方法，但效率很低。幸运的是，MongoDB有一些内置功能，可以轻松生成这些类型的值。'
- en: As we are going to be making a number of calls to MongoDB, we are going to rely
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要对MongoDB进行多次调用，我们将依赖
- en: 'on the `async.parallel` function again, much like we did in the `sidebar` module.
    The original `helpers/stats.js` file was very bare bones, so let''s completely
    replace that file with this new version, which uses `parallel`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在`async.parallel`函数中，就像我们在`sidebar`模块中所做的那样。原始的`helpers/stats.js`文件非常简单，所以让我们完全用这个使用`parallel`的新版本替换该文件：
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This code does exactly what the module originally did, only it''s a little
    more verbose! I''m pretty sure we don''t want to just return `0` for all of our
    stats forever, though, as that''d be pretty useless and unimpressive, to say the
    least! Let''s update the `each` function to properly query MongoDB and get some
    stats. Looking at the object returned in the callback in the last function, we
    can see that we already defined the order of the functions that are being executed
    in parallel. Let''s start with images. Replace the `next(null, 0);` line in the
    first function with the following code snippet:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码完全做了模块最初的事情，只是多了一点冗长！我很确定我们不想永远只返回`0`作为我们所有统计数据，因为那将是相当无用和令人印象深刻的，至少可以这么说！让我们更新`each`函数，正确地查询MongoDB并获取一些统计数据。查看最后一个函数中回调中返回的对象，我们可以看到我们已经定义了并行执行的函数的顺序。让我们从图片开始。将第一个函数中的`next(null,
    0);`行替换为以下代码片段：
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Easy! Just use MongoDB''s `count` method to find the total number of documents
    in the images collection matching any criteria (the first parameter). Then, we
    just pass the `next` function as the `callback`, because coincidentally enough,
    the parameter signatures match. If we didn''t want to use shorthand here, we could
    write this the long way, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！只需使用MongoDB的`count`方法找到与任何条件匹配的图片集合中文档的总数（第一个参数）。然后，我们只需将`next`函数作为`callback`传递，因为巧合的是，参数签名是匹配的。如果我们不想在这里使用简写，我们可以以长方式编写，如下所示：
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'However, who feels like typing all that when you don''t have to! Let''s do
    the same thing for the second function in the parallel array for total comments.
    Replace the `next(null, 0);` line in the second function with the following line
    of code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你不必要的时候，谁会想要输入所有这些！让我们对并行数组中的第二个函数做同样的事情，用于总评论。将第二个函数中的`next(null, 0);`行替换为以下代码行：
- en: '[PRE60]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Again, this was a piece of cake!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这真是小菜一碟！
- en: Now, the next two functions are going to be a little different, but they are
    almost identical to each other. What we want to do with `next` is get the total
    `views` and `likes` for every image. We can't use MongoDB's `count` method, because
    that only counts individual documents in a collection. We need to use MongoDB's
    `aggregate` functionality instead.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，接下来的两个函数将有些不同，但它们几乎是相同的。我们想要用`next`获取每张图片的总`views`和`likes`。我们不能使用MongoDB的`count`方法，因为它只计算集合中的单个文档。我们需要使用MongoDB的`aggregate`功能。
- en: 'Using `aggregate`, we can perform a mathematical operation, such as `$sum`,
    to tally results for us. Replace the `next(null, 0);` line in the third function
    with the following code snippet:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`aggregate`，我们可以执行数学运算，比如`$sum`，来为我们计算结果。将第三个函数中的`next(null, 0);`行替换为以下代码片段：
- en: '[PRE61]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Using MongoDB's `aggregate` function, we are telling MongoDB to group every
    document together and sum up all of their views into a single new field called
    `viewsTotal`. The resulting collection that is returned to the `callback` function
    is an array of documents with the `_id` and `viewsTotal` fields. In this case,
    the results array will only contain a single document with the grand total, because
    we weren't that tricky with our `aggregate` functionality. If there aren't any
    images in the collection at all, we need to handle that and check accordingly.
    Finally, the `next` callback function is called with the actual value for `viewsTotal`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB的`aggregate`函数，我们告诉MongoDB将每个文档分组在一起，并将它们的所有视图总和到一个名为`viewsTotal`的新字段中。返回给`callback`函数的结果集合是一个具有`_id`和`viewsTotal`字段的文档数组。在这种情况下，结果数组将只包含一个具有总数的文档，因为我们在`aggregate`功能中并不那么巧妙。如果集合中根本没有图片，我们需要处理并相应地进行检查。最后，使用实际的`viewsTotal`值调用`next`回调函数。
- en: 'Let''s use the same exact functionality to total up the `likes` for all images.
    Replace the `next(null, 0)`; line of code in the fourth and final function in
    parallel with the following code snippet:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用完全相同的功能来统计所有图片的`likes`。将并行中的第四个和最后一个函数中的`next(null, 0)`行代码替换为以下代码片段：
- en: '[PRE62]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that the `sidebar` helper module has been updated and is complete with
    the `async.parallel` functionality, let''s make a minor tweak to our `sidebar`
    module to ensure we are calling the `Stats` module correctly so that it''s properly
    asynchronous. The original line in `helpers/sidebar.js` was:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`sidebar`辅助模块已经更新，并且完全具有`async.parallel`功能，让我们对`sidebar`模块进行微小调整，以确保我们正确调用`Stats`模块，以便它正确地异步执行。`helpers/sidebar.js`中的原始代码行是：
- en: '[PRE63]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Replace that line of code with this slightly different version:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个稍微不同的版本替换那行代码：
- en: '[PRE64]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Last but not least, let's take care of the most popular helper module for the
    images sidebar.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，让我们来处理图像侧边栏的最受欢迎的辅助模块。
- en: The popular images helper
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受欢迎的图像助手
- en: 'Again, the original `helpers/images.js` file was mostly filled with fixture
    data and placeholder code that''s fairly useless. Let''s replace the entire file
    with this new version that''s actually pretty tame in comparison to all of the
    other helper modules:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，原始的`helpers/images.js`文件大部分都是填充了固定数据和相当无用的占位符代码。让我们用这个实际上相当温和的新版本替换整个文件，与所有其他辅助模块相比。
- en: '[PRE65]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: At this point, this code should be pretty familiar to you. We just query MongoDB
    and find the top nine most liked images by sorting the images by total, such as
    by count in descending order, and then limiting the results to nine documents.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这段代码对你来说应该很熟悉。我们只是查询MongoDB，并通过按总数对图像进行排序，例如按降序计数，然后将结果限制为九个文档，找到了最受欢迎的九张图像。
- en: 'Let''s edit the `helpers/sidebar.js` file again to include the updated call
    to the `Images.popular` function. Consider the original code:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次编辑`helpers/sidebar.js`文件，以包括对`Images.popular`函数的更新调用。考虑原始代码：
- en: '[PRE66]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Replace this with the following slightly newer version:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下稍微更新的版本替换这个：
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now the sidebar is completely finished and completely dynamic. With no more
    fixture data or placeholder variables anywhere. Running the application should
    yield a fully functional website with all of the features we set out to implement
    working perfectly! Give it a spin and make sure it's working correctly.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在侧边栏已经完全完成并且完全动态。没有任何固定数据或占位符变量。运行应用程序应该产生一个功能齐全的网站，所有我们要实现的功能都完美地运行！试一试，确保它正常工作。
- en: Iterating by adding an image removal capability
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过添加图像删除功能进行迭代
- en: At this point, I think our application is pretty awesome, but there's something
    missing that's nagging me. During testing, I've been creating all kinds of new
    images and uploading them to the application, but it's starting to get a bit cluttered
    and messy.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我认为我们的应用程序非常棒，但有一些东西让我感到不满。在测试期间，我一直在创建各种新图像并将它们上传到应用程序，但现在开始变得有点混乱和凌乱。
- en: It dawned on me that the most obvious thing that's missing is the ability to
    delete an image!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到最明显的缺失是删除图像的能力！
- en: 'In reality, I left out this feature on purpose so that we could use this opportunity
    to incorporate a completely new functionality that touches almost every area of
    the application. This seemingly simple addition is actually going to require the
    following changes:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我故意省略了这个功能，这样我们就可以利用这个机会来整合一个完全新的功能，几乎触及应用程序的每个领域。这个看似简单的添加实际上需要以下更改：
- en: Update `routes.js` to include a new route to handle `Delete` requests
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`routes.js`以包括处理`Delete`请求的新路由
- en: Update `controllers/image.js` to include a new function for the route
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`controllers/image.js`以包括路由的新功能
- en: This should not only remove the image from the database, but also delete the
    file and all related comments
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不仅应该从数据库中删除图像，还应该删除文件和所有相关评论
- en: Update the `image.handlebars` HTML template to include a Remove button
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`image.handlebars` HTML模板以包括一个删除按钮
- en: Update the `public/js/scripts.js` file with an AJAX handler for the Remove button
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AJAX处理程序更新`public/js/scripts.js`文件以处理删除按钮
- en: Adding a route
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路由
- en: 'The first thing we need to update in order to add this new functionality is
    the main `routes` list. Here, we will add a new endpoint that handles the `delete`
    function and points to a function within the `image` controller. Edit the `server/routes.js`
    file and insert the following new line of code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加这个新功能，我们需要更新的第一件事是主`routes`列表。在这里，我们将添加一个处理`delete`功能并指向`image`控制器内的函数的新端点。编辑`server/routes.js`文件并插入以下新代码行：
- en: '[PRE68]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Adding a controller handler
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加控制器处理程序
- en: 'Now that we have added a new route, we need to create the controller function
    that it''s using as its `callback` (`image.remove`). Edit `controllers/image.js`
    and add the following new function code after the existing `comment: function(req,
    res){}` operation (don''t forget to add a trailing comma after the `comment` function,
    since you are adding a new function):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经添加了一个新的路由，我们需要创建它使用的控制器函数作为它的`callback`(`image.remove`)。编辑`controllers/image.js`并在现有的`comment:
    function(req, res){}`操作之后添加以下新的函数代码（不要忘记在`comment`函数之后添加一个逗号，因为你正在添加一个新的函数）：'
- en: '[PRE69]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This function performs four primary functions (and as such, nests four layers
    deep with `callbacks`--we could have used the async's `series` method here to
    prevent the crazy amount of nesting). The first task is to find the image that
    we are attempting to remove. Once that image is found, the file associated with
    the image should be deleted. Next, find the comments associated with the image
    and remove them. Once they have been removed, the last step is to remove the image
    itself. Assuming all of that was a success, simply send a `true` Boolean JSON
    response back to the browser.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数执行四个主要功能（因此，使用`callbacks`嵌套了四层深--我们可以在这里使用async的`series`方法来防止疯狂的嵌套）。第一项任务是找到我们要删除的图像。一旦找到该图像，应删除与图像关联的文件。接下来，找到与图像关联的评论并删除它们。一旦它们被删除，最后一步是删除图像本身。假设所有这些都成功了，只需向浏览器发送一个`true`布尔JSON响应。
- en: Updating the Handlebars image page template
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Handlebars图像页面模板
- en: 'Now that we have a `route` and `controller` function to support deleting an
    image, we need a way for the UI to send the request. The most obvious solution
    is to add a Delete button somewhere on the page. Edit the `views/image.handlebars`
    file and, after the existing HTML, where we had the Like button, add new HTML
    for a Delete button:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了支持删除图像的`route`和`controller`函数，我们需要一种方法让UI发送请求。最明显的解决方案是在页面的某个地方添加一个删除按钮。编辑`views/image.handlebars`文件，在现有的HTML之后，我们有了Like按钮，添加一个新的HTML用于删除按钮：
- en: '[PRE70]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we just include a new `div` that's set to four right aligned columns using
    Bootstrap. The UI here is that the Like button and the stats are the leftmost
    portion of the row, and the Delete button (an X icon from Font Awesome) is all
    the way to the right of the same row (and red since we use Bootstrap's danger
    color class).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只包括一个新的`div`，它使用Bootstrap设置为四个右对齐的列。这里的UI是，喜欢按钮和统计数据是行的最左边部分，删除按钮（来自Font
    Awesome的X图标）位于同一行的最右边（由于我们使用Bootstrap的危险颜色类，所以是红色的）。
- en: Updating jQuery
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新jQuery
- en: Finally, we are going to tie it all together by implementing code similar to
    the Like button, where we send an AJAX `delete` method with the URL and the image
    ID to the server when the button is clicked on. To be safe, we display a standard
    JavaScript confirmation dialog to ensure the button wasn't clicked on by accident.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过实现类似于“喜欢”按钮的代码来将所有内容联系在一起，在按钮被点击时向服务器发送带有URL和图像ID的AJAX“删除”方法。为了安全起见，我们显示一个标准的JavaScript确认对话框，以确保按钮不是意外点击的。
- en: 'Assuming the server responds with a `true` value, we will turn the button green
    and change the icon to a checkmark with the word Deleted! in place. Edit `public/js/scripts.js`
    and insert the following block of code after the existing code (be sure to insert
    the new code inside the `$(function(){ ... })` jQuery function):'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 假设服务器响应一个`true`值，我们将把按钮变成绿色，并将图标更改为一个带有“已删除！”字样的复选标记。编辑`public/js/scripts.js`并在现有代码之后插入以下代码块（确保将新代码插入到`$(function(){
    ... })`jQuery函数内）：
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Let's test this brand new functionality by launching the application, loading
    it up in a browser, finding an image we no longer want, and viewing its image
    page.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过启动应用程序、在浏览器中加载它、找到一个我们不再需要的图像并查看它的图像页面来测试这个全新的功能。
- en: The Delete button should now show up in place.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 删除按钮现在应该显示出来了。
- en: Refactoring and improvements
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构和改进
- en: 'At this point, the application that we''ve been building is pretty much complete!
    Before we iterate anymore on the project and continue to build it out and make
    it ready for production, we should probably consider some refactoring and/or general
    improvements. Some areas that I would personally take a look at to refactor and/or
    rewrite to improve the application''s performance and overall sanity are as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们一直在构建的应用程序几乎完成了！在我们对项目进行任何迭代并继续构建它并使其准备投入生产之前，我们可能应该考虑一些重构和/或一般改进。我个人会看一下需要重构和/或重写以改进应用程序性能和整体健康状况的一些领域如下：
- en: I might rethink working directly with models within the controllers so much,
    and instead create a utility that I can wrap a lot of that noise in, and rely
    on more basic CRUD calls to my models and provide only a `callback` to each. This
    is most visible in the `image` controller, with `like`, `comment`, and `remove`.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可能会重新考虑在控制器中直接与模型一起工作这么多，而是创建一个实用程序，我可以在其中包装大部分噪音，并依赖于更基本的CRUD调用我的模型，并仅提供一个`callback`。这在`image`控制器中最为明显，包括`like`、`comment`和`remove`。
- en: There is literally no validation in the project that we wrote, and that's mostly
    for brevity. In reality, we should have included validation on any input fields
    a user interfaces with. Validation should be provided on both the frontend via
    jQuery or plain old vanilla JavaScript and on the backend with Node. The validation
    should protect users from submitting invalid and/or malicious code (that is, XSS
    or Cross-Site Scripting).
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们编写的项目中实际上没有验证，这主要是为了简洁。实际上，我们应该在用户界面上的任何输入字段上包含验证。验证应该在前端通过jQuery或普通的原始JavaScript以及在后端通过Node上提供。验证应该保护用户免受提交无效和/或恶意代码（即XSS或跨站点脚本）的影响。
- en: Right now, our application is open to the general public, which means any visitor
    that comes along can upload images as well as delete them! It would be fairly
    simple to include a user authentication process within our application. Passport.js
    is a great third-party module to integrate user authentication into Node.js applications.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序对一般公众开放，这意味着任何访问者都可以上传图像以及删除它们！在我们的应用程序中包含用户身份验证过程将是相当简单的。Passport.js是一个很好的第三方模块，可以将用户身份验证集成到Node.js应用程序中。
- en: Instead of attaching images to comments for the purposes of the sidebar (the
    `newest` comments), we should consider creating a more robust aggregate query
    using MongoDB to retrieve a hybrid collection of comments that includes the image
    provided directly from MongoDB.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要附加图像到评论的目的边栏（`newest`评论），我们应该考虑使用MongoDB创建更强大的聚合查询，以从MongoDB直接检索包含图像的评论的混合集合。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was a monster, but was also the last piece of the puzzle to complete
    our app and have a fully dynamic, database-driven Node.js app that uses MongoDB.
    Congratulations on making it this far and sticking with it! You're well on your
    way to being a true full-stack JavaScript developer.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是一个庞然大物，但也是完成我们的应用程序并拥有一个完全动态、数据库驱动的Node.js应用程序的最后一块拼图。祝贺你走到了这一步并坚持下来！你正在成为一个真正的全栈JavaScript开发人员。
- en: In the next chapter, we'll step away from our application for a bit as we take
    a look at working with REST APIs using Node.js.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时离开我们的应用程序，看看如何使用Node.js处理REST API。
