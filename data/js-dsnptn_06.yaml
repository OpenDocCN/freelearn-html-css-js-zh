- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Exploring Reactive View Library Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索响应式视图库模式
- en: Reactive view library patterns give us tools to build applications in a scalable
    and maintainable manner when we could benefit from breaking out of the component
    primitive. Using the React view library, we’ll cover different techniques for
    going beyond component-based composition to inject functionality into our components
    – the render prop, a higher-order component, hooks, and provider patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式视图库模式为我们提供了在需要跳出组件原语时以可扩展和可维护的方式构建应用程序的工具。使用React视图库，我们将介绍超越基于组件的组合以向我们的组件注入功能的不同技术——渲染属性、高阶组件、hooks和提供者模式。
- en: 'We’ll cover the following main topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要主题：
- en: An introduction to reactive view library patterns and where we can benefit the
    most by using them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍响应式视图库模式及其使用它们可以带来最大益处的领域
- en: Examples and implementation approaches for the render prop pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染属性模式的示例和实现方法
- en: Implementing and using the higher-order component pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和使用高阶组件模式
- en: Using hooks to build React function components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用hooks构建React函数组件
- en: Multiple ways to implement the provider pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现提供者模式的多种方式
- en: By the end of this chapter, you’ll be able to discern when and how to use Reactive
    view library patterns to build React applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够辨别何时以及如何使用响应式视图库模式来构建React应用程序。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along in this chapter, you’ll need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章，您需要以下内容：
- en: '**Node.js** **20+**: [https://nodejs.org/en](https://nodejs.org/en)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** **20+**：[https://nodejs.org/en](https://nodejs.org/en)'
- en: '**Npm 8+**: Comes with most Node.js installations'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Npm 8+**：大多数Node.js安装都包含'
- en: '[https://parceljs.org/](https://parceljs.org/) is used in some examples and
    has similar platform support to Node.js'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些示例中使用了[https://parceljs.org/](https://parceljs.org/)，它具有与Node.js类似的平台支持
- en: '**React**: React DOM and Formik are installed via npm; an understanding of
    [https://react.dev/](https://react.dev/) basics in a web context is required'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React**：通过npm安装React DOM和Formik；在Web环境中需要了解[https://react.dev/](https://react.dev/)的基础知识'
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
- en: What are reactive view library patterns?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是响应式视图库模式？
- en: Reactive view libraries are extensively used for JavaScript and web frontend
    development. A few very popular options are **React**, **Angular**, and **Vue**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式视图库在JavaScript和Web前端开发中被广泛使用。一些非常流行的选项包括**React**、**Angular**和**Vue**。
- en: Reactive view libraries provide a way to write applications in a more scalable
    fashion by allowing the user interface (usually the browser) to react to changes
    in the data. Application development is, therefore, simplified, since the view
    library or framework takes care of all the direct manipulation necessary to maintain
    synchronization between the underlying data and the browser.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式视图库提供了一种以更可扩展的方式编写应用程序的方法，允许用户界面（通常是浏览器）对数据的变化做出反应。因此，应用程序开发得到了简化，因为视图库或框架负责处理所有必要的直接操作，以保持底层数据和浏览器之间的同步。
- en: One of the key common denominators between these libraries and frameworks is
    the concept of a **component**, which contains business logic and/or rendering
    logic. The component is a key building block of an application. It can be reused
    or not, but it usually encapsulates a set of responsibilities and enforces interfaces
    around it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库和框架之间一个关键的共同点概念是**组件**，它包含业务逻辑和/或渲染逻辑。组件是应用程序的关键构建块。它可以被重用或不被重用，但它通常封装了一组责任，并在其周围强制执行接口。
- en: A trait of components is that a developer should be able to use them as building
    blocks, and without component internals changing significantly, an application’s
    behavior can be changed significantly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的一个特性是开发者应该能够将它们用作构建块，并且在不显著改变组件内部的情况下，可以显著改变应用程序的行为。
- en: Reactive view library patterns, therefore, help us build components in a reusable
    fashion, but they also cover techniques to work around situations where the component
    abstraction has shortcomings.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，响应式视图库模式帮助我们以可重用的方式构建组件，但它们也涵盖了处理组件抽象存在不足的情况的技术。
- en: In the following sections, we’ll cover the render props, higher-order component,
    hooks, and the provider pattern in React. We’ll be focusing on React, but the
    patterns have equivalents in Vue.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍React中的渲染属性、高阶组件、钩子和提供者模式。我们将重点关注React，但这些模式在Vue中也有等效的模式。
- en: The render prop pattern
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染属性模式
- en: The render prop pattern is apparent when a component allows its consumer to
    define how a part of that component is rendered, via a function prop. These can
    be children as a function or another prop, which is a function that takes some
    parameters and returns JSX.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件允许其消费者通过一个函数属性定义该组件的一部分如何渲染时，就会出现渲染属性模式。这些可以是作为函数的子元素或另一个属性，该属性是一个接受一些参数并返回JSX的函数。
- en: Render props allow for a level of inversion of control. Although a component
    could completely encapsulate rendering and business logic, it instead yields control
    of some parts of the rendering logic to its consumer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染属性允许一定程度上的控制反转。尽管一个组件可以完全封装渲染和业务逻辑，但它反而将渲染逻辑的一些部分的控制权交给了其消费者。
- en: Such inversion of control is useful to share logic without sharing the visuals
    or actually rendering the UI. Therefore, this pattern is widespread among libraries.
    A prime example is **Formik**, which gives consumers flexibility on how to render
    a form while providing an abstraction over the form’s state management logic.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种控制反转对于在不共享视觉或实际渲染UI的情况下共享逻辑非常有用。因此，这种模式在库中很常见。一个典型的例子是**Formik**，它为消费者提供了如何渲染表单的灵活性，同时提供了一个对表单状态管理逻辑的抽象。
- en: Use cases
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: Let’s start with a scenario where we build a `CoupledSelect` component, which
    is a wrapper for the `select` native element. We’ll build this component in a
    way that the data and the rendering are closely coupled, providing a simple example
    of when render props can be useful.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个`CoupledSelect`组件的场景开始，这是一个`select`原生元素的包装器。我们将以数据与渲染紧密耦合的方式构建此组件，这是一个渲染属性何时有用的简单示例。
- en: A consumer’s expectation from `CoupledSelect` is that it would behave mostly
    like the `select` native element, with some caveats.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者对`CoupledSelect`的期望是它主要像`select`原生元素那样表现，但有几点需要注意。
- en: 'Our `CoupledSelect` component takes the following props:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CoupledSelect`组件接受以下属性：
- en: '**selectedOption**: This sets the selected option; it is akin to the selected
    prop on the **option** native element'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**selectedOption**：这设置了选定的选项；它类似于**option**原生元素上的`selected`属性'
- en: '**options**: This is an array of strings that are rendered as **option** elements'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options**：这是一个字符串数组，它们被渲染为**option**元素'
- en: '**onChange**: This is an optional callback for the component rendering **CoupledSelect**
    to react to option selections'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onChange**：这是一个可选的回调，用于使渲染**CoupledSelect**的组件对选项选择做出反应'
- en: 'We can implement it as follows. `CoupledSelect` will wrap around `onChange`,
    since it’s optional:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下实现它。`CoupledSelect`将围绕`onChange`，因为它是不必要的：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s move on to the rendering logic. We’ll return a select element with `onChange={onChangeHandler}`
    and `value={selectedOption}` so that select will be in sync with `selectedOption`
    and propagate changes back:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论渲染逻辑。我们将返回一个具有`onChange={onChangeHandler}`和`value={selectedOption}`的`select`元素，这样选择将同步于`selectedOption`并传播更改：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we’ll render the `props.options` using .map, which will return an
    <`option`> element, with the value and key properties set to option and whose
    content will be the `option` value also:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`.map`渲染`props.options`，这将返回一个`<option>`元素，其值和键属性设置为`option`，其内容将是`option`值：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using our `CoupledSelect` might look something as follows.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`CoupledSelect`可能看起来像以下这样。
- en: 'We define an array of options. Here, we structure them as a list of objects
    with a `value` key that’s a string:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个选项数组。在这里，我们将它们结构化为一个具有`value`键的对象列表，该键是一个字符串：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can then use `CoupledSelect` by ensuring that `props.options` is an array
    of strings:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过确保`props.options`是一个字符串数组来使用`CoupledSelect`：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we can save `selectedOption` by using the `useState` hook. We will name
    this particular piece of state `selectedOption` and its update function `setSelectedOption`.
    This will allow us to make `CoupledSelect` interactive:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`useState`钩子来保存`selectedOption`。我们将这个特定的状态命名为`selectedOption`，其更新函数为`setSelectedOption`。这将使我们能够使`CoupledSelect`具有交互性：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we will set an initial value for `selectedOption` to show that this
    functionality of the `CoupledSelect` component works:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为`selectedOption`设置一个初始值，以展示`CoupledSelect`组件的功能是如何工作的：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Starting with the initial `selectedOption` functionality, we can see that the
    item at index 3 of the options array, `{ value: ''grape'' }`, is the initially
    selected option, as shown in *Figure 4**.1*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '从初始的 `selectedOption` 功能开始，我们可以看到选项数组索引 3 的项 `{ value: ''grape'' }` 是初始选中的选项，如图
    *图 4**.1* 所示：'
- en: '![Figure 4.1: The CoupledSelect initial state, with grape selected](img/B19109_04_1.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：CoupledSelect 初始状态，选中葡萄](img/B19109_04_1.jpg)'
- en: 'Figure 4.1: The CoupledSelect initial state, with grape selected'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：CoupledSelect 初始状态，选中葡萄
- en: When opening `select`, the `select` is in the correct state.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开 `select` 时，`select` 处于正确的状态。
- en: '![Figure 4.2: The CoupledSelect select open state, hovering on the orange option](img/B19109_04_2.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：CoupledSelect 选择打开状态，悬停在橙子选项上](img/B19109_04_2.jpg)'
- en: 'Figure 4.2: The CoupledSelect select open state, hovering on the orange option'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：CoupledSelect 选择打开状态，悬停在橙子选项上
- en: Finally, when we select a different option, `onChange` handler also works as
    expected.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们选择不同的选项时，`onChange` 处理器也按预期工作。
- en: '![Figure 4.3: In the CoupledSelect post-selection state, orange is now selected](img/B19109_04_3.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：在 CoupledSelect 选择后的状态中，现在选中了橙子](img/B19109_04_3.jpg)'
- en: 'Figure 4.3: In the CoupledSelect post-selection state, orange is now selected'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：在 CoupledSelect 选择后的状态中，现在选中了橙子
- en: The `CoupledSelect` component has limited flexibility due to the `options.map()`
    call in the render function. Since we’re using the option variable as the option
    element’s value, it must be a string or number. The value is also equal to the
    rendered text content of the option element, but there are often situations where
    we want to display something different from the value that we’re storing. It’s
    a presentation versus persistence concern here. For example, we can’t change the
    values rendered without changing what’s being stored in `onChange`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于渲染函数中的 `options.map()` 调用，`CoupledSelect` 组件的灵活性有限。由于我们使用选项变量作为选项元素的值，它必须是字符串或数字。该值也等于选项元素的渲染文本内容，但通常情况下，我们希望显示与存储的值不同的内容。这是一个展示与持久性关注的问题。例如，我们无法在不更改
    `onChange` 中存储的内容的情况下更改渲染的值。
- en: 'If we want to add a `Fruit`: prefix to `select`, a naive approach is to implement
    it as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 `select` 中添加一个 `Fruit:` 前缀，一个简单的方法是实现如下：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unfortunately, this doesn’t work as expected, as the initial selection doesn’t
    work anymore:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并没有按预期工作，因为初始选择不再起作用：
- en: '![Figure 4.4: The CoupledSelect initial state, where the initial selection
    does not work correctly](img/B19109_04_4.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4：CoupledSelect 初始状态，初始选择不正确](img/B19109_04_4.jpg)'
- en: 'Figure 4.4: The CoupledSelect initial state, where the initial selection does
    not work correctly'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：CoupledSelect 初始状态，初始选择不正确
- en: When opening the `select,` things seem to work OK; we can see the **Fruit:**
    prefix for all the options, as shown in *Figure 4**.5*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开 `select` 时，似乎一切正常；我们可以看到所有选项的 **Fruit:** 前缀，如图 *图 4**.5* 所示。
- en: '![Figure 4.5: The CoupledSelect open state, with the Fruit: prefix](img/B19109_04_5.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5：CoupledSelect 打开状态，带有 Fruit: 前缀](img/B19109_04_5.jpg)'
- en: 'Figure 4.5: The CoupledSelect open state, with the Fruit: prefix'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.5：CoupledSelect 打开状态，带有 Fruit: 前缀'
- en: 'On selection of a new option, we can see that what’s being stored in the `selectedOption`
    is **Fruit: pear** instead of **pear**.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '在选择新选项时，我们可以看到存储在 `selectedOption` 中的是 **Fruit: pear** 而不是 **pear**。'
- en: '![Figure 4.6: The CoupledSelect post-selection state – note that the selected
    option Fruit: pear includes the prefix Fruit:](img/B19109_04_6.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6：CoupledSelect 选择后的状态 – 注意到选中的选项 Fruit: pear 包含前缀 Fruit:](img/B19109_04_6.jpg)'
- en: 'Figure 4.6: The CoupledSelect post-selection state – note that the selected
    option Fruit: pear includes the prefix Fruit:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.6：CoupledSelect 选择后的状态 – 注意到选中的选项 Fruit: pear 包含前缀 Fruit:'
- en: Therefore, the `CoupledSelect` component can’t be used flexibly, due to the
    coupling of the render logic and the data logic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于渲染逻辑和数据逻辑的耦合，`CoupledSelect` 组件不能灵活使用。
- en: We’ll now see how render props could have alleviated this issue by decoupling
    data and rendering logic.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何通过解耦数据和渲染逻辑来缓解这个问题。
- en: Implementation/example
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现/示例
- en: In our `CoupledSelect` example, we saw how the stored data and what is displayed
    to the user are tightly coupled. We’ll now see how to break that coupling using
    render props.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `CoupledSelect` 示例中，我们看到了存储的数据和显示给用户的内容是如何紧密耦合的。现在我们将看到如何使用渲染属性来打破这种耦合。
- en: Decoupling presentation from data logic by using render props
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过使用渲染属性解耦数据逻辑和展示逻辑
- en: 'An alternative way to have written the `CoupledSelect` component with render
    props is as follows. The key additional prop we’re passing is `renderOption`,
    a render prop. Most of the remaining components are similar but are included for
    completeness:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用渲染属性编写 `CoupledSelect` 组件的另一种方法是以下所示。我们传递的附加属性是 `renderOption`，这是一个渲染属性。其余的大部分组件与之前相似，但包括为了完整性：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Usage of the `SelectRenderProps` component is very similar to that of `CoupledSelect`.
    The only additional prop we need to provide an implementation for is the `renderOption`
    prop, which we implement with a function that returns an `option` element:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectRenderProps` 组件的使用与 `CoupledSelect` 非常相似。我们需要的唯一附加属性是实现 `renderOption`
    属性，我们通过一个返回 `option` 元素的函数来实现它：'
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, the implementation is very similar to `CoupledSelect`, apart from the
    fact that the parent of `SelectRenderProps` now decides how to render an option.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，实现与 `CoupledSelect` 非常相似，除了 `SelectRenderProps` 的父组件现在决定如何渲染一个选项。
- en: 'Given the same requirement to prefix the options with `Fruit:`, we can now
    implement it as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 给定相同的将选项前缀为 `Fruit:` 的要求，我们现在可以按以下方式实现：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that counter to what we did with `CoupledSelect`, we’re not even touching
    the options prop. Our only change is to the `renderOption` prop. We’ll now test
    this example and show that decoupling the rendering logic (with a render prop)
    from the data logic works much better for extensibility.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与我们在 `CoupledSelect` 中所做的方法相反，我们甚至没有触及选项属性。我们唯一的更改是 `renderOption` 属性。我们现在将测试这个示例，并展示将渲染逻辑（使用渲染属性）与数据逻辑解耦对于扩展性来说效果更好。
- en: 'The `SelectRenderProps` initial state renders correctly, with `select` and
    **grape** in the parent component:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectRenderProps` 初始状态渲染正确，父组件中包含 `select` 和 **grape**：'
- en: '![Figure 4.7: The SelectRenderProps initial state – the options and initial
    selection are displayed correctly](img/B19109_04_7.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7：SelectRenderProps 初始状态 – 选项和初始选择正确显示](img/B19109_04_7.jpg)'
- en: 'Figure 4.7: The SelectRenderProps initial state – the options and initial selection
    are displayed correctly'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：SelectRenderProps 初始状态 – 选项和初始选择正确显示
- en: When we open `select`, we can see that the **Fruit:** prefix is rendered.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开 `select` 时，我们可以看到 **Fruit:** 前缀被渲染。
- en: '![Figure 4.8: The SelectRenderProps open state – the options include the Fruit:
    prefix](img/B19109_04_8.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8：SelectRenderProps 打开状态 – 选项包括 Fruit: 前缀](img/B19109_04_8.jpg)'
- en: 'Figure 4.8: The SelectRenderProps open state – the options include the Fruit:
    prefix'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.8：SelectRenderProps 打开状态 – 选项包括 Fruit: 前缀'
- en: 'Finally, upon selection of an option, the state is updated correctly, the parent
    stores `select` has **Fruit:** **banana** selected:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在选项被选择后，状态更新正确，父组件存储的 `select` 已选择 **Fruit:** **banana**：
- en: '![Figure 4.9: The SelectRenderProps post-selection state – the selected option
    does not include the Fruit: prefix](img/B19109_04_9.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9：SelectRenderProps 选择后的状态 – 选择的项目不包括 Fruit: 前缀](img/B19109_04_9.jpg)'
- en: 'Figure 4.9: The SelectRenderProps post-selection state – the selected option
    does not include the Fruit: prefix'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.9：SelectRenderProps 选择后的状态 – 选择的项目不包括 Fruit: 前缀'
- en: We’ve now seen how render props can allow the rendering logic and data logic
    to be edited separately when making a rendering change.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了渲染属性如何允许在制作渲染更改时分别编辑渲染逻辑和数据逻辑。
- en: Now that we’ve implemented a basic example of the render prop pattern, we’ll
    see how libraries leverage it to provide flexibility to consumers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一个基本的渲染属性模式示例，我们将看到库如何利用它为消费者提供灵活性。
- en: Additional render prop patterns when providing components with flexible presentation
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供具有灵活呈现的组件时的附加渲染属性模式
- en: The React form management library Formik uses a render prop to provide form
    state back to consumers. The render prop is the children prop of the Formik component.
    In other words, what’s between the opening `<Formik>` tag and the closing `</Formik>`
    tag is a function, which provides props such as values, `isSubmitting`, and `handleChange`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: React 表单管理库 Formik 使用渲染属性将表单状态返回给消费者。渲染属性是 Formik 组件的子属性。换句话说，在 `<Formik>` 标签打开和
    `</Formik>` 标签关闭之间是一个函数，它提供了如值、`isSubmitting` 和 `handleChange` 等属性。
- en: See the following example, which is a single-input form that takes a name, validates
    that it’s at least two characters long, and allows the form to be submitted.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例，这是一个单输入表单，它接受一个名称，验证它至少有两个字符长，并允许表单提交。
- en: 'To begin, we’ll render the form and input that will store the `fields` value
    in `Formik`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将渲染表单和输入，这些表单将在 `Formik` 中存储 `fields` 值：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we can add submission handling and an inline validation error display:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加提交处理和内联验证错误显示：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the initial state, we see the form with a single input and a submit button:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始状态中，我们看到一个包含单个输入和一个提交按钮的表单：
- en: '![Figure 4.10: The Formik single field and Submit button in its initial state,
    which includes the Name (Required) label](img/B19109_04_10.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10：Formik 单个字段和提交按钮在其初始状态，包括名称（必填）标签](img/B19109_04_10.jpg)'
- en: 'Figure 4.10: The Formik single field and Submit button in its initial state,
    which includes the Name (Required) label'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：Formik 单个字段和提交按钮在其初始状态，包括名称（必填）标签
- en: When we click (or otherwise focus) on the name input and then un-focus (the
    *blur* web event), the validation triggers, letting us know that the field is
    required.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击（或以其他方式聚焦）名称输入然后失焦（*blur* 网络事件）时，验证会触发，让我们知道该字段是必填的。
- en: '![Figure 4.11: Name input blur validation - Error: Required validation error](img/B19109_04_11.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11：名称输入失焦验证 - 错误：必填验证错误](img/B19109_04_11.jpg)'
- en: 'Figure 4.11: Name input blur validation - Error: Required validation error'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：名称输入失焦验证 - 错误：必填验证错误
- en: If we input only one character and blur, we get a validation error, **Name**
    **too short**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只输入一个字符并失焦，我们会得到一个验证错误，**名称****太短**。
- en: '![Figure 4.12: H in the name input triggers the validation error Name too short](img/B19109_04_12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12：在名称输入中输入 H 触发验证错误 - 错误：名称太短](img/B19109_04_12.jpg)'
- en: 'Figure 4.12: H in the name input triggers the validation error Name too short'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：在名称输入中输入 H 触发验证错误 - 错误：名称太短
- en: When a name that meets the validation criteria is met, the validation errors
    are cleared.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入满足验证标准的名称时，验证错误会被清除。
- en: '![Figure 4.13: A valid Formik field clears the validation errors](img/B19109_04_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13：有效的 Formik 字段清除验证错误](img/B19109_04_13.jpg)'
- en: 'Figure 4.13: A valid Formik field clears the validation errors'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13：有效的 Formik 字段清除验证错误
- en: 'Finally, when we click **Submit**, we get a browser alert with **{ “name”:
    “****Hugo” }**.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，当我们点击**提交**时，我们会收到一个浏览器警报，显示**{ “name”: “****Hugo” }**。'
- en: '![Figure 4.14: An alert on submission with { “name”: “Hugo” }](img/B19109_04_14.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14：提交时的警报，显示 { “name”: “Hugo” }](img/B19109_04_14.jpg)'
- en: 'Figure 4.14: An alert on submission with { “name”: “Hugo” }'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.14：提交时的警报，显示 { “name”: “Hugo” }'
- en: Now, let’s take a look at some limitations of the render prop pattern.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看渲染属性模式的一些限制。
- en: Limitations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制
- en: One key limitation of the render prop pattern is that it provides units of reuse
    and integration that are functions and not components. It’s possible for a lot
    of the logic to end up in the render prop function itself that could have been
    better served by creating a new component.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染属性模式的一个关键限制是它提供的是函数而不是组件的复用和集成单元。很多逻辑最终可能都集中在渲染属性函数本身，而这些逻辑本可以通过创建一个新的组件来更好地服务。
- en: Render props can make code harder to test when using a shallow renderer such
    as Enzyme’s `shallow`, which won’t render the full component tree. Components
    making heavy use of render props should probably use a full “mount” rendering
    approach so that all the children of the component (including the render props)
    are rendered.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用浅渲染器（如 Enzyme 的 `shallow`）时，渲染属性可能会使代码更难测试，因为浅渲染器不会渲染完整的组件树。大量使用渲染属性的组件可能应该使用完整的“挂载”渲染方法，以便渲染组件的所有子组件（包括渲染属性）。
- en: In this section, we introduced you to the render prop pattern and described
    its use cases, examples, and limitations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向您介绍了渲染属性模式，并描述了其用例、示例和限制。
- en: In the next section, we’ll learn about another reactive view library pattern
    – higher-order components.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解另一个响应式视图库模式——高阶组件。
- en: The higher-order component pattern
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶组件模式
- en: A higher-order component is a function that takes a component and returns a
    component. The definition of higher-order components is similar to higher-order
    functions, which JavaScript supports. Higher-order functions are functions that
    receive a function as a parameter or return a function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件是一个函数，它接受一个组件并返回一个组件。高阶组件的定义与高阶函数类似，JavaScript 支持。高阶函数是接收函数作为参数或返回函数的函数。
- en: The higher-order component pattern allows us to pass additional props to a component.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件模式允许我们向组件传递额外的属性。
- en: Implementation/example
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现/示例
- en: 'The following is a simple render prop, `withLocation`, which injects `window.location.href`
    and `window.location.origin` into a component as props:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的渲染属性，`withLocation`，它将`window.location.href`和`window.location.origin`作为属性注入到组件中：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The pattern that’s used when using higher-order components is to export default
    the higher-order component called with the local component – in this case, `withLocation(Location)`.
    The `Location` component is a simple component that takes location as provided
    by `withLocation` and renders it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高阶组件时使用的模式是将带有本地组件的高阶组件作为默认导出——在本例中，`withLocation(Location)`。`Location`组件是一个简单的组件，它接受由`withLocation`提供的位置并渲染它：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the consumer of `Location`, what we import as `Location` is the default
    export – that is, `withLocation(Location)`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Location`的消费者中，我们导入的`Location`是默认导出——即`withLocation(Location)`：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Location` component renders `location.href` and `location.origin`, based
    on what’s provided by `withLocation`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Location`组件根据`withLocation`提供的内容渲染`location.href`和`location.origin`。'
- en: '![](img/B19109_04_15.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19109_04_15.jpg)'
- en: 'Figure 4.15: The Location component rendering the href and origin, based on
    what’s provided by withlocation'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：`Location`组件根据`withlocation`提供的内容渲染href和origin
- en: We’ve now seen a simple example of a key benefit of higher-order components,
    which is that the component doing the rendering doesn’t need to be directly aware
    of where to receive information; it can read props instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到了高阶组件的一个简单示例，即其关键好处之一，即执行渲染的组件不需要直接知道信息来源；它可以读取属性。
- en: Use cases
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: The `withLocation` example already showed a simple reason why we could use higher-order
    components – to maintain separation of concerns.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`withLocation`示例已经展示了我们可以使用高阶组件的一个简单原因——为了保持关注点的分离。'
- en: In our Location component example, it’s completely possible for Location to
    access `window.location` directly. What that would mean, however, is that the
    Location component is aware of global objects, which could be undesirable. For
    example, it might make unit-testing of `Location` more difficult, since it’s accessing
    something beyond its props.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Location`组件示例中，`Location`直接访问`window.location`是完全可能的。然而，这意味着`Location`组件会意识到全局对象，这可能是不可取的。例如，它可能会使`Location`的单元测试更加困难，因为它正在访问超出其属性的内容。
- en: Limitations
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局限性
- en: As with all abstractions, higher-order components are a layer of indirection.
    This means that tracing where a prop comes from can be more difficult than when
    props are passed explicitly from the parent component.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有抽象一样，高阶组件是一层间接层。这意味着追踪一个属性从哪里来可能比从父组件显式传递属性更困难。
- en: Tracing the props becomes even more difficult when the higher-order component
    comes from a third-party library (and thus is harder to inspect).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当高阶组件来自第三方库（因此更难检查）时，追踪属性变得更加困难。
- en: Higher-order components can have a cost in terms of rendering in the browser,
    since we wrap our component in another component if we stack too many higher-order
    components on top of each other.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件在浏览器渲染方面可能会有成本，因为我们如果在多个高阶组件上堆叠我们的组件，就会将我们的组件包裹在另一个组件中。
- en: 'For example, the following `ConnectedComponent` uses three higher-level components:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下`ConnectedComponent`使用了三个高级组件：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As a consumer of `ConnectedComponent`, we’ll likely render four components –
    the ones provided by `withRouter`, `withHttpClient`, `withAnotherDependency`,
    and `ComponentWithDependencies`. If we had another way to inject the router, HTTP
    client and another dependency, we could reduce the number of components to one,
    only needing `ComponentWithDependencies`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`ConnectedComponent`的消费者，我们可能会渲染四个组件——`withRouter`、`withHttpClient`、`withAnotherDependency`和`ComponentWithDependencies`提供的组件。如果我们有另一种方法注入路由器、HTTP客户端和另一个依赖项，我们可以将组件数量减少到只有一个，只需要`ComponentWithDependencies`。
- en: This drawback leads us to the next topic in this chapter – hooks. Hooks provide
    us a way to access data and logic in similar scenarios as higher-order components,
    without additional components being rendered. Hooks are a great replacement for
    logic-heavy higher-order components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缺点使我们转向本章的下一个主题——钩子。钩子为我们提供了一种在类似高阶组件的场景中访问数据和逻辑的方法，而不需要渲染额外的组件。钩子是逻辑密集型高阶组件的绝佳替代品。
- en: The hooks pattern
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩子模式
- en: We’ve now covered what might be considered *legacy* patterns in React – render
    props and higher-order components.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了在React中可能被认为是*遗留*模式的主题——渲染属性和高阶组件。
- en: 'You’ll note that the React documentation page about higher-order components
    has the following disclaimer: “Higher-order components are not commonly used in
    modern React code.”'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到关于高阶组件的 React 文档页面有如下免责声明：“高阶组件在现代 React 代码中不常用。”
- en: Additional reading
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读
- en: 'The React documentation for **useState** and **useEffect** hooks:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**useState** 和 **useEffect** hooks 的 React 文档：'
- en: '**useState**: [https://react.dev/reference/react/useState](https://react.dev/reference/react/useState)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**useState**：[https://react.dev/reference/react/useState](https://react.dev/reference/react/useState)'
- en: '**useEffect**: [https://react.dev/reference/react/useEffect](https://react.dev/reference/react/useEffect)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**useEffect**：[https://react.dev/reference/react/useEffect](https://react.dev/reference/react/useEffect)'
- en: So, what we know so far is that hooks allow us to do what we did with render
    props and that higher-order components are not recommended any more. This is because
    hooks provide a way to access all the React primitives, including state and the
    component life cycle.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，我们知道 hooks 允许我们做我们用 render props 做过的事情，而且不再推荐使用高阶组件。这是因为 hooks 提供了一种访问所有
    React 原语的方法，包括状态和组件生命周期。
- en: React provides built-in hooks. The two we’ll focus on are `useState` and `useEffect`.
    One key feature of hooks is that we can write custom hooks that build on top of
    React built-in hooks and other custom hooks, which means we have a new way to
    share logic in React.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了内置的 hooks。我们将关注其中的两个：`useState` 和 `useEffect`。hooks 的一个关键特性是我们可以编写自定义
    hooks，这些 hooks 是建立在 React 内置 hooks 和其他自定义 hooks 之上的，这意味着我们在 React 中有了分享逻辑的新方法。
- en: An implementation/example
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现/示例
- en: We’ll implement simple data fetching using the class React components, and then
    hooks. This will showcase how state and life cycle events are handled in both
    cases.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类 React 组件实现简单的数据获取，然后使用 hooks。这将展示在这两种情况下如何处理状态和生命周期事件。
- en: We’ll start with the class components. The regular way to implement data fetching
    is by using life cycle hooks; the initial one tends to be `componentDidMount`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从类组件开始。实现数据获取的常规方式是使用生命周期 hooks；最初的一个通常是 `componentDidMount`。
- en: Our `BasketItemsClassical` component takes `httpClient` and `basketId`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `BasketItemsClassical` 组件接受 `httpClient` 和 `basketId`。
- en: 'The component’s constructor initializes a `state.basketSession` variable to
    an empty object, `{}`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的构造函数将一个 `state.basketSession` 变量初始化为一个空对象，`{}`：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we’ll add a `setBasketSession` method, which will call `this.setState`
    to set `basketSession` as the passed parameter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个 `setBasketSession` 方法，该方法将调用 `this.setState` 来设置 `basketSession`
    为传递的参数。
- en: 'We’ll also add `componentDidMount`, which calls `httpClient.get()` with the
    fakestoreapi.com URL to load carts, using the `basketId` prop:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加 `componentDidMount`，它使用 `httpClient.get()` 和 fakestoreapi.com URL 来加载购物车，使用
    `basketId` prop：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What this now means is that we should be able to render out the contents of
    `this.state.basketSession` in the component’s `render()` method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在意味着我们应该能够在组件的 `render()` 方法中渲染出 `this.state.basketSession` 的内容：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our `BasketItemsClassical` can be used as follows by passing `httpClient` and
    `basketId` as props:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `BasketItemsClassical` 可以通过传递 `httpClient` 和 `basketId` 作为 props 来使用：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`BasketClassical` can then be used in our `App`, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `App` 中使用 `BasketClassical`，如下所示：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the browser, this displays as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，它显示如下：
- en: '![Figure 4.16: The Basket class component loading JSON data](img/B19109_04_16.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16：加载 JSON 数据的 Basket 类组件](img/B19109_04_16.jpg)'
- en: 'Figure 4.16: The Basket class component loading JSON data'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：加载 JSON 数据的 Basket 类组件
- en: 'Here’s the same example with hooks; instead of using `componentDidMount`, we
    can use the `useEffect` hook, and instead of `this.state` in the constructor and
    `this.setState`, we use the `useState` hook. In order to use hooks, we use a React
    function component (React class components don’t support hooks):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 hooks 的相同示例；我们不是使用 `componentDidMount`，而是使用 `useEffect` hook，并且不是在构造函数中使用
    `this.state` 和 `this.setState`，而是使用 `useState` hook。为了使用 hooks，我们使用一个 React 函数组件（React
    类组件不支持 hooks）：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our `BasketItemsHooks` can be used in the same way as `BasketItemsClassical`,
    by passing `httpClient` and `basketId` as props:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `BasketItemsHooks` 可以像 `BasketItemsClassical` 一样使用，通过传递 `httpClient` 和 `basketId`
    作为 props：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We’ll also need to modify `App` to render `BasketHooks` in addition to `BasketClassical`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改 `App` 以渲染 `BasketHooks` 以及 `BasketClassical`：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Both `BasketHooks` (*Figure 4**.17*) and `BasketClassical` (*Figure 4**.16*)
    yield the same JSON output after the HTTP requests are completed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 请求完成后，`BasketHooks`（*图 4**.17*）和 `BasketClassical`（*图 4**.16*）都产生了相同的
    JSON 输出。
- en: '![Figure 4.17: The Hooks basket loading JSON data](img/B19109_04_17.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图4.17：钩子篮子加载JSON数据](img/B19109_04_17.jpg)'
- en: 'Figure 4.17: The Hooks basket loading JSON data'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：钩子篮子加载JSON数据
- en: 'The hooks approach is slightly more compact; each part of the functionality
    does feel a bit more self-contained. For example, the initial state is handled
    in the same place that defines what the state update function will be in the hooks
    version. In the class example, the `initialisation` state is in the constructor,
    and the state update function is a method. In the `BasketClassical` example, there
    was the option to simplify the component by removing the state update method and
    using a direct `this.setState({ bookingSession: session })` call.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '钩子方法稍微紧凑一些；每个功能部分都感觉更独立。例如，初始状态在定义钩子版本中状态更新函数的地方处理。在类示例中，`initialisation`状态在构造函数中，状态更新函数是一个方法。在`BasketClassical`示例中，有简化组件的选项，通过移除状态更新方法并使用直接的`this.setState({
    bookingSession: session })`调用。'
- en: Use cases
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: 'A simple way to think about hooks and class or function components is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 关于钩子和类或函数组件的简单思考方式如下：
- en: Hooks for shared logic
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享逻辑的钩子
- en: Components for logic that is related to rendering
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与渲染相关的逻辑组件
- en: The higher-order component and render prop patterns, which are used to separate
    presentation and business logic, are unlikely to be needed any more and can be
    replaced by custom hooks.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件和渲染属性模式，这些模式用于分离表现层和业务逻辑，可能不再需要，可以用自定义钩子来替代。
- en: React hooks and function components are the recommended way to develop modern
    React applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: React钩子和函数组件是开发现代React应用的推荐方式。
- en: Limitations
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局限性
- en: 'Hooks can’t be used in React class components, as detailed in the React documentation:
    [https://react.dev/reference/react/Component#defining-a-class-component](https://react.dev/reference/react/Component#defining-a-class-component).
    Note that function components are the recommended way to build React components.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如React文档中详细说明：[https://react.dev/reference/react/Component#defining-a-class-component](https://react.dev/reference/react/Component#defining-a-class-component)。请注意，函数组件是构建React组件的推荐方式。
- en: In code bases with heavy usage of class components, higher-order components
    should remain in use instead of migrating components to functions in order to
    use hooks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量使用类组件的代码库中，应该继续使用高阶组件，而不是将组件迁移到函数中以使用钩子。
- en: The last piece of the puzzle with React components is how to bypass the prop
    drilling problem and pass data without changing each component in a React component
    tree. The pattern we use for this is the provider pattern, which we’ll cover in
    the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的最后一部分是如何绕过属性钻取问题，并在不改变React组件树中每个组件的情况下传递数据。我们用于此的模式是提供者模式，我们将在下一节中介绍。
- en: The provider pattern
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供者模式
- en: The provider pattern in React is where one component in the tree makes data
    accessible to all its descendants. This is usually accomplished using the React
    **Context** primitive.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: React中的提供者模式是指树中的某个组件使其数据对所有后代组件可用。这通常是通过使用React **上下文**原语来实现的。
- en: Use case – the prop drilling problem
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例 - 属性钻取问题
- en: The key use case for the provider pattern is to avoid the **prop** **drilling**
    problem.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者模式的关键用途是避免**属性****钻取**问题。
- en: A large majority of the time, a component’s main input is the prop it receives
    from its parent component. A state management pattern to share state between components
    in React is to *lift state up*. Lifting state up means to store relevant state
    in a common ancestor of the components that require the shared state.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，组件的主要输入是从其父组件接收的属性。在React中，要在组件之间共享状态，可以使用提升状态的模式。提升状态意味着将相关状态存储在需要共享状态的组件的共同祖先中。
- en: As stated in the React.js docs ([https://react.dev/learn/sharing-state-between-components](https://react.dev/learn/sharing-state-between-components))
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如React.js文档所述([https://react.dev/learn/sharing-state-between-components](https://react.dev/learn/sharing-state-between-components))
- en: When you want to coordinate two components, move their state to their common
    parent. Then pass the information down through props from their common parent
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想协调两个组件时，将它们的状态移动到它们的共同父组件中。然后通过它们的共同父组件从上往下传递信息
- en: This can lead to **prop drilling** when the common parent has multiple components
    between it and the components requiring the props. This means all the intermediate
    components will receive the props, but they will only use them to forward them
    on to the next layer of components.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致**正钻**，当普通父组件与需要支撑的组件之间有多个组件时。这意味着所有中间组件都将接收支撑，但他们只会使用它们将它们传递给下一层组件。
- en: As stated in the React.js docs (https://react.dev/learn/passing-data-deeply-with-context#the-problem-with-passing-props)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如React.js文档（https://react.dev/learn/passing-data-deeply-with-context#the-problem-with-passing-props）所述
- en: Passing props is a great way to explicitly pipe data through your UI tree to
    the components that use it. But passing props can become verbose and inconvenient
    when you need to pass some prop deeply through the tree, or if many components
    need the same prop. The nearest common ancestor could be far removed from the
    components that need data, and lifting state up that high can lead to a situation
    called “prop drilling
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 传递属性是明确将数据通过UI树传递到使用它的组件的绝佳方式。但是，当您需要将某些属性深度传递到树中，或者许多组件需要相同的属性时，传递属性可能会变得冗长且不方便。最近的共同祖先可能离需要数据的组件很远，将状态提升到那么高的位置可能导致称为“属性钻取”的情况。
- en: The provider pattern is a solution to the prop drilling problem, since every
    descendent of the provider component will have access to the data it provides.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者模式是解决属性钻取问题的解决方案，因为提供者组件的每个后代都将有权访问它提供的数据。
- en: An implementation/example
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个实现/示例
- en: Let’s look back to the examples from *The hooks pattern* section, where we had
    the App rendering `BasketClassical` and `BasketHooks`, which render `BasketItemsClassical`
    and `BasketItemsHooks`, respectively.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下*钩子模式*部分中的示例，其中App渲染`BasketClassical`和`BasketHooks`，分别渲染`BasketItemsClassical`和`BasketItemsHooks`。
- en: '![Figure 4.18: A React app tree with BasketClassical, BasketHooks, and their
    descendants](img/B19109_04_18.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图4.18：包含BasketClassical、BasketHooks及其后代的React应用树](img/B19109_04_18.jpg)'
- en: 'Figure 4.18: A React app tree with BasketClassical, BasketHooks, and their
    descendants'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：包含BasketClassical、BasketHooks及其后代的React应用树
- en: This illustrates the prop drilling problem, since `BasketClassical` and `BasketHooks`
    don’t use `basketId` or `httpClient` beyond passing it to `BasketItemsClassical`
    and `BasketItemsHooks`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了属性钻取问题，因为`BasketClassical`和`BasketHooks`在将`basketId`或`httpClient`传递给`BasketItemsClassical`和`BasketItemsHooks`之外没有使用它们。
- en: 'There are multiple ways to consume a context in React, but it all begins by
    creating a context:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，有多种方式来消费上下文，但一切始于创建一个上下文：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`HttpClientContext` is a context that’s initialized with the null value. `HttpClientProvider`
    is a component that takes a `httpClient` value, setting it as the value that `HttpClientContext.Provider`
    will pass to its descendants in the component tree.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClientContext`是一个初始化为null值的上下文。`HttpClientProvider`是一个组件，它接受一个`httpClient`值，将其设置为`HttpClientContext.Provider`将传递给组件树中后代的值。'
- en: 'In order to use `HttpClientContext`, we can use `HttpClientContext.Consumer`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`HttpClientContext`，我们可以使用`HttpClientContext.Consumer`：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`HttpClientContext.Consumer` has a children render-prop (function) that takes
    the value of the context (in this case, `httpClient`) and returns some JSX to
    render:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClientContext.Consumer`有一个子渲染属性（函数），它接受上下文的值（在这种情况下，`httpClient`）并返回一些JSX进行渲染：'
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This yields the following output in the browser:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这在浏览器中产生以下输出：
- en: '![Figure 4.19: The JSON contents of basketId=5 from fakestoreapi.com](img/B19109_04_19.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19：来自fakestoreapi.com的basketId=5的JSON内容](img/B19109_04_19.jpg)'
- en: 'Figure 4.19: The JSON contents of basketId=5 from fakestoreapi.com'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：来自fakestoreapi.com的basketId=5的JSON内容
- en: 'The approach using `HttpClientContext.Consumer` directly is a bit unwieldy.
    Instead, we could wrap it in a higher-order component, `withHttpClient`, which
    consumes `HttpClientConsumer`. The benefit here is that we only have one place
    that uses `HttpClientConsumer`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HttpClientContext.Consumer`直接的方法有点难以操作。相反，我们可以将其包裹在一个高阶组件`withHttpClient`中，该组件消费`HttpClientConsumer`。这里的优点是我们只有一个使用`HttpClientConsumer`的地方：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With a slight difference from our example of a higher-order component, we’ll
    export const `Connected``     BasketItemsClassical` with the value `withHttpClient(BasketItemsClassical)`. The
    *connected* nomenclature is a call back to the large React Redux code bases where
    the components are often split among *presentation* and *container* components.
    The Redux higher-order component is called `connect`, and all the containers are
    connected:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '与我们示例中的高阶组件略有不同，我们将导出 const `Connected`     `BasketItemsClassical`，其值为 `withHttpClient(BasketItemsClassical)`。*连接* 命名法是对大型
    React Redux 代码库的回溯，其中组件通常分为 *展示* 和 *容器* 组件。Redux 高阶组件称为 `connect`，所有容器都是连接的：'
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can then use `ConnectedBasketItemsClassical` as follows. Note that we don’t
    pass an `httpClient` prop:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以如下使用 `ConnectedBasketItemsClassical`。请注意，我们没有传递一个 `httpClient` 属性：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The higher-order component version using `withHttpClient` outputs the same value
    as the direct `HttpClientConsumer` implementation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `withHttpClient` 的高阶组件版本输出的值与直接的 `HttpClientConsumer` 实现相同。
- en: '![Figure 4.20: The JSON contents of basketId=5 from fakestoreapi.com](img/B19109_04_20.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20：来自 fakestoreapi.com 的 basketId=5 的 JSON 内容](img/B19109_04_20.jpg)'
- en: 'Figure 4.20: The JSON contents of basketId=5 from fakestoreapi.com'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20：来自 fakestoreapi.com 的 basketId=5 的 JSON 内容
- en: The final approach to using context and the provider pattern is to leverage
    the React `useContext` hook. Similar to how `HttpClientContext.Consumer` allows
    us to access the context provider’s value, the hook fulfills that same role. So,
    the output of `useContext(context)` is the current value, based on where the hook
    renders in the component tree.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文和提供者模式的最终方法是利用 React 的 `useContext` 钩子。类似于 `HttpClientContext.Consumer`
    允许我们访问上下文提供者的值，这个钩子也扮演着同样的角色。因此，`useContext(context)` 的输出是基于钩子在组件树中渲染的位置的当前值。
- en: 'It’s customary to wrap the `useContext` hook in a more descriptive name (as
    we did for `HttpClientContext.Consumer`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会将 `useContext` 钩子包裹在一个更具描述性的名称中（就像我们对 `HttpClientContext.Consumer` 所做的那样）：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This time, using `httpClient` from the `HttpClientContext` requires component-level
    changes. So, we’ll write the following implementation of `BasketItemsHooksUseContext`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，使用 `HttpClientContext` 中的 `httpClient` 需要组件级别的更改。因此，我们将编写以下 `BasketItemsHooksUseContext`
    的实现：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`BasketItemsHooksUseContext` can be used as follows. Note that we’re not passing
    `BasketItemsHooksUseContext`, a `httpClient` prop:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasketItemsHooksUseContext` 可以如下使用。请注意，我们并没有传递 `BasketItemsHooksUseContext`，一个
    `httpClient` 属性：'
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This implementation is yet again equivalent to the previous implementations
    we did with `HttpClientConsumer` and `HttpClient`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现再次等同于我们之前使用 `HttpClientConsumer` 和 `HttpClient` 所做的实现。
- en: '![Figure 4.21: The JSON contents of basketId=5 from fakestoreapi.com](img/B19109_04_21.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21：来自 fakestoreapi.com 的 basketId=5 的 JSON 内容](img/B19109_04_21.jpg)'
- en: 'Figure 4.21: The JSON contents of basketId=5 from fakestoreapi.com'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21：来自 fakestoreapi.com 的 basketId=5 的 JSON 内容
- en: We saw how to use the provider pattern to solve the prop drilling problem in
    React apps. Let’s now look at some limitations of this pattern in the next section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用提供者模式来解决 React 应用中的属性钻探问题。现在，让我们在下一节中看看这种模式的局限性。
- en: Limitations
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局限性
- en: The provider pattern is a layer of indirection. It might not always be obvious
    where a context’s value is coming from, or it might sometimes be necessary to
    change the provider/context shape to make some changes at the component level.
    For example, when using context with hooks, the hook shows a direct link between
    consuming component and the context, but it doesn’t necessarily show the provider
    or how the value inside the context is defined.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者模式是一种间接层。有时可能并不明显知道上下文值来自何处，或者有时可能需要更改提供者/上下文形状以在组件级别进行一些更改。例如，当使用钩子与上下文一起时，钩子显示了消费组件和上下文之间的直接链接，但它并不一定显示提供者或上下文内部值的定义方式。
- en: 'It’s also sometimes possible to solve the prop drilling problem by making liberal
    use of children and composing the components in a single large JSX return, such
    as the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通过大量使用子组件并在单个大的 JSX 返回中组合组件，也可以解决属性钻探问题，如下所示：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In `MyComponent`, we pass the props directly to `OtherComponent` and `FinalComponent`
    from `MyComponent`. If we had `ContainerComponent` encapsulating `OtherComponent`
    and `FinalComponent`, the props would be drilled via `ContainerComponent` (it
    doesn’t use the props but receives them, in order to pass them to its descendants).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MyComponent`中，我们直接将props从`MyComponent`传递给`OtherComponent`和`FinalComponent`。如果我们有一个封装`OtherComponent`和`FinalComponent`的`ContainerComponent`，props将通过`ContainerComponent`传递（它不使用props，但接收它们，以便将其传递给其子组件）。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how reactive view library patterns enable us to
    build React applications more effectively when the component paradigm starts to
    break down.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何通过响应式视图库模式，在组件范式开始崩溃时，更有效地构建React应用程序。
- en: The render prop pattern allows us to decouple data logic and rendering logic
    by yielding rendering control back to the consumer of a component.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染属性模式允许我们通过将渲染控制权交还给组件的消费者来解耦数据逻辑和渲染逻辑。
- en: The higher-order component pattern allows components to implement logic (data
    or rendering) against their props, without having to concern themselves with where
    the information comes from.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶组件模式允许组件在其props上实现逻辑（数据或渲染），而无需关心信息来源。
- en: The hooks pattern means that React primitives that were only available in class
    components are now available as self-contained logic chunks to function components.
    Hooks can be composed separately of components, which makes hooks a powerful primitive
    and can partly replace the render prop and higher-order component patterns.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子模式意味着以前仅在类组件中可用的React原语现在可以作为自包含的逻辑块提供给函数组件。钩子可以独立于组件组合，这使得钩子成为一个强大的原语，并且可以部分替代渲染属性和高级组件模式。
- en: The provider pattern allows React components to pass data not only to their
    children but also to any descendent component.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者模式允许React组件不仅将数据传递给其子组件，还可以传递给任何子组件。
- en: Now that we’re familiar with reactive view library patterns, in the next chapter,
    we will look at rendering and page hydration strategies to improve web applications’
    performance.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了响应式视图库模式，在下一章中，我们将探讨渲染和页面激活策略，以改善Web应用程序的性能。
