- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building Web Apps with Bundlers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用打包器构建Web应用
- en: In the previous chapter, we covered an important set of auxiliary tooling –
    linters and formatters. While code quality is important, the undoubtedly most
    important aspect of every project is what is shipped and used by the customer.
    This is the area where a special kind of tooling – called bundlers – shines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了一组重要的辅助工具——代码检查器和格式化工具。虽然代码质量很重要，但每个项目无疑最重要的方面是客户所交付和使用的内容。这正是需要一种特殊工具的地方——称为打包器——的地方。
- en: A bundler is a tool that understands and processes source code to produce files
    that can be placed on a web server and are ready to be consumed by web browsers.
    It takes HTML, CSS, JavaScript, and related files into consideration to make them
    more efficient and readable. In this process, a bundler would merge, split, minify,
    and even translate code from one standard such as ES2020 into another standard
    such as ES5.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 打包器是一种理解并处理源代码的工具，以生成可以放置在Web服务器上并由Web浏览器消费的文件。它考虑HTML、CSS、JavaScript和相关文件，使它们更高效和可读。在这个过程中，打包器会合并、拆分、压缩，甚至将代码从一种标准（如ES2020）转换为另一种标准（如ES5）。
- en: Today, bundlers are no longer nice to have, but necessarily used for most projects
    directly or indirectly. Pretty much every web framework offers tooling that is
    built upon a bundler. Often, the challenge is to configure a bundler so that it
    understands our code base and does exactly what we’d expect it to do. Since web
    code bases are quite different, bundlers need to be flexible in many directions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打包器不再是可选的，而是大多数项目直接或间接必需的。几乎每个Web框架都提供基于打包器的工具。通常，挑战在于配置打包器，使其理解我们的代码库并执行我们期望它执行的操作。由于Web代码库相当不同，打包器需要在多个方向上保持灵活性。
- en: In this chapter, you’ll build up an understanding of what bundlers do and how
    you can control their inner processes. We’ll also introduce the most important
    bundlers as of today, and see how they can be used and configured to work efficiently
    for us. This will help you get your web project from raw source code to production-ready
    artifacts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将建立起对打包器做什么以及如何控制其内部过程的理解。我们还将介绍目前最重要的打包器，并了解它们如何被使用和配置以高效地为我们工作。这将帮助你将你的Web项目从原始源代码转换为生产就绪的工件。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Understanding bundlers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解打包器
- en: Comparing the available bundlers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较可用的打包器
- en: Using Webpack
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Webpack
- en: Using esbuild
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用esbuild
- en: Using Parcel
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Parcel
- en: Using Vite
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vite
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter06](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter06).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可在[https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter06](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter06)找到。
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3G0NiMX](https://bit.ly/3G0NiMX).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可通过[https://bit.ly/3G0NiMX](https://bit.ly/3G0NiMX)访问。
- en: Understanding bundlers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解打包器
- en: 'Writing a modern web application is quite difficult. One of the reasons for
    the level of difficulty is the large variety of different technologies that need
    to be involved in the process. Let’s just mention a few:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编写现代Web应用相当困难。导致这种难度水平的一个原因是需要涉及过程中的各种不同技术。让我们简单提一下：
- en: HTML for writing documents
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编写文档的HTML
- en: CSS for styling those documents
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS来设计这些文档
- en: JavaScript with the DOM API to bring some interactivity
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DOM API的JavaScript以增加一些交互性
- en: A JavaScript UI framework to create interactive components
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于创建交互式组件的JavaScript UI框架
- en: A CSS preprocessor to use variables, nesting, and more features for CSS
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于CSS的预处理器，以使用变量、嵌套等更多功能
- en: Potentially TypeScript or some other typed system to improve reliability in
    certain source code areas
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能使用TypeScript或其他一些类型系统来提高某些源代码区域的可靠性
- en: Service and web workers need to be mastered
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要掌握服务和Web工作者
- en: All static files should be easy to cache
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有静态文件都应该易于缓存
- en: Before the introduction of a new class of tooling that was capable of building
    up module graphs, dedicated task runners such as **Grunt** or **Gulp** were used.
    These runners were inspired by more generic approaches such as **Makefiles**.
    The problem, however, was that two aspects – the build process and the source
    code – needed to be kept in sync. Just adding one file to the source code was
    not sufficient; the build process had to be informed about this new file. With
    bundlers, this all changed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入能够构建模块图的新工具类别之前，人们使用专门的作业运行器，如**Grunt**或**Gulp**。这些运行器受到了更通用方法（如**Makefiles**）的启发。然而，问题在于需要保持两个方面的同步——构建过程和源代码。仅仅添加一个文件到源代码是不够的；构建过程必须被告知这个新文件。有了打包器，这一切都改变了。
- en: At its core, a bundler is a tool that leverages other tools. The most important
    addition is that a bundler understands the module graph – that is, the relationships
    (imports and exports) of code modules such as the CommonJS or ESM modules we discussed
    in the previous chapters. It can build up a module graph and use that to let other
    tools such as Babel work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心上，打包器是一个利用其他工具的工具。最重要的补充是打包器理解模块图——即代码模块（如我们在前几章讨论的CommonJS或ESM模块）之间的关系（导入和导出）。它可以构建模块图，并使用它让其他工具（如Babel）工作。
- en: To get started, a bundler requires so-called entry points – quite often, these
    are referred to as entries. These are files that are used as roots in the module
    graph. These files may depend on other files, in which case the bundler will continue
    in these files to build up the module graph.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，打包器需要所谓的入口点——通常这些被称为入口。这些文件用作模块图的根。这些文件可能依赖于其他文件，在这种情况下，打包器将继续在这些文件中构建模块图。
- en: '*Figure 6**.1* shows an example module graph constructed from two entry points.
    The interesting property of this graph is that the content of **Entry 2** is fully
    contained in **Entry 1**, too. In many situations, there won’t be any significant
    overlap between the module graphs of multiple entry points:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1* 展示了一个由两个入口点构建的示例模块图。这个图的一个有趣特性是**入口2**的内容也完全包含在**入口1**中。在许多情况下，多个入口点的模块图之间不会存在任何显著的重叠：'
- en: '![Figure 6.1 – Example module graph constructed from two entry points ](img/Figure_6.1_B18989.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 由两个入口点构建的示例模块图](img/Figure_6.1_B18989.jpg)'
- en: Figure 6.1 – Example module graph constructed from two entry points
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 由两个入口点构建的示例模块图
- en: 'Most bundlers work in phases. While each bundler uses slightly different terminology,
    they almost always come with the following high-level phases:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数打包器都按阶段工作。虽然每个打包器使用的术语略有不同，但它们几乎总是包含以下高级阶段：
- en: Module resolution
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块解析
- en: Module transformation
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块转换
- en: Chunk and asset generation
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块和资源生成
- en: Applying optimizations
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用优化
- en: The module transformation is often necessary. On the one hand, the bundler needs
    to understand the module to find imported modules to build up the module graph;
    on the other hand, the chunk generation must rely on normalized input modules.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模块转换通常是必要的。一方面，打包器需要理解模块以找到导入的模块来构建模块图；另一方面，块生成必须依赖于规范化的输入模块。
- en: While the transformation phase needs to work hand-in-hand with a resolver to
    continuously build up the module graph, all other phases are pretty much independent.
    Quite often, the optimization phase is either reduced or fully disabled during
    development. This reduction helps speed up the bundling process by a fair margin.
    Additionally, further instructions that are quite helpful during debugging will
    be kept.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换阶段需要与解析器协同工作，以持续构建模块图，而所有其他阶段基本上是独立的。通常，在开发过程中，优化阶段会被减少或完全禁用。这种减少可以显著加快打包过程。此外，一些在调试过程中非常有帮助的额外指令将被保留。
- en: Minification
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩
- en: One of the most common optimizations is minification. The goal of minification
    is to make the files as small as possible without using active compression. While
    minification on the surface is rather easy and efficient in a language such as
    JavaScript, other languages such as CSS or HTML are a bit more problematic. Especially
    minification of HTML has been proven to be a hard problem without as many gains
    compared to the minification of JavaScript. After minification, files are usually
    not as readable as they were previously. One reason is the removal of unnecessary
    whitespace, which was introduced to give the original code readability and structure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的优化之一是压缩。压缩的目标是在不使用主动压缩的情况下使文件尽可能小。虽然表面上看压缩在JavaScript这样的语言中相对简单且高效，但其他语言如CSS或HTML则有点问题。特别是HTML的压缩已被证明是一个难题，与JavaScript的压缩相比，收益较少。压缩后，文件通常不如之前易读。一个原因是移除了不必要的空白，这些空白是为了给原始代码提供可读性和结构而引入的。
- en: 'The whole bundling process can be sketched in a diagram. *Figure 6**.2* shows
    how the different entries enter the different phases:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 整个打包过程可以用图表来概述。*图6.2*展示了不同入口如何进入不同的阶段：
- en: '![Figure 6.2 – High-level phases of a modern web bundler ](img/Figure_6.2_B18989.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 现代网络打包器的高级阶段](img/Figure_6.2_B18989.jpg)'
- en: Figure 6.2 – High-level phases of a modern web bundler
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 现代网络打包器的高级阶段
- en: Another thing to consider is that the chunk generation will mostly also introduce
    some kind of JavaScript runtime. This can be as lightweight as teaching the resulting
    code how to load additional bundles that have been created as script files, but
    it can also include full support for loading shared dependencies from foreign
    code and more. The introduced code is fully bundler-specific.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的是，块生成通常会引入某种JavaScript运行时。这可以轻量到仅仅教会生成的代码如何加载作为脚本文件创建的额外包，但它也可以包括从外部代码加载共享依赖项的完整支持等。引入的代码完全符合打包器的特定要求。
- en: With that in mind, let’s see what kind of bundlers are out there and how they
    compare.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们看看目前有哪些打包器以及它们是如何进行比较的。
- en: Comparing available bundlers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较可用的打包器
- en: There are multiple generations of bundlers. The first generation was centered
    around the belief that Node.js applications are the only kind of applications
    that should be written. Therefore, changing these applications into JavaScript
    files that work in the browser has been the primary concern of the bundlers from
    that generation. The most popular one in that category is **Browserify**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 打包器有多个代。第一代打包器围绕着一个信念，即Node.js应用程序是唯一应该编写的应用程序类型。因此，将这些应用程序转换为在浏览器中工作的JavaScript文件一直是那一代打包器的首要关注点。那个类别中最受欢迎的是**Browserify**。
- en: The second generation went on to extend the idea from the first generation to
    pretty much all JavaScript code. Here, even HTML and CSS assets could be understood.
    For instance, using `@import` rules in CSS would extend the module graph to another
    CSS module. Importantly, while the *CommonJS* (or later on, *ESM*) syntax was
    still used to derive the JavaScript module graph, these second-generation bundlers
    did not care about Node.js. They always assumed that the code was written for
    the browser. Quite often, however, you could change the target and also bundle
    code for Node.js with them. The most popular one in this category is **Webpack**,
    even though Webpack always tried to go with the times and adapt.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二代打包器继续将第一代的思想扩展到几乎所有JavaScript代码。在这里，甚至HTML和CSS资源也可以被理解。例如，使用CSS中的`@import`规则将模块图扩展到另一个CSS模块。重要的是，尽管仍然使用*CommonJS*（或后来，*ESM*）语法来推导JavaScript模块图，但这些第二代打包器并不关心Node.js。它们始终假设代码是为浏览器编写的。然而，相当常见的是，你可以更改目标，并且也可以使用它们打包Node.js代码。这个类别中最受欢迎的是**Webpack**，尽管Webpack总是试图与时俱进并适应。
- en: Third-generation bundlers introduced a much-improved user experience. They tried
    to find a native or obvious way of handling things and often did not even require
    any configuration. The most popular tool in this category is the original *Parcel*
    bundler.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第三代打包器引入了改进的用户体验。它们试图找到处理事情的原生或明显的方式，并且通常甚至不需要任何配置。这个类别中最受欢迎的工具是原始的*Parcel*打包器。
- en: The current fourth-generation bundlers are all about performance. They either
    come with a dedicated runtime or sit on top of natively written tooling, which
    usually outperforms their older JavaScript-written counterparts. Here, we see
    tools such as **esbuild** or experimental runtimes such as **Bun**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的第四代打包器都关注性能。它们要么带有专门的运行时，要么位于原生编写的工具之上，这通常优于它们较老的JavaScript编写的对应工具。在这里，我们看到像**esbuild**这样的工具或像**Bun**这样的实验性运行时。
- en: 'The big question is: When should you use what? With half a dozen popular bundlers
    and more available, the question is not easy to answer. Surely, if a team is already
    really familiar with one of the options, then going with it for a project is very
    often the right choice. Otherwise, look for similar projects and try to understand
    what bundler they picked – and why. In any other case, you could use the following
    catalog of questions to identify which bundler might be the best option:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的问题是：何时使用什么？在六七个流行的打包器和更多可用的情况下，这个问题并不容易回答。当然，如果一个团队已经非常熟悉某个选项，那么在项目中选择它通常是正确的选择。否则，寻找类似的项目，并尝试了解他们选择了哪个打包器——以及原因。在任何其他情况下，你可以使用以下问题目录来识别哪个打包器可能是最佳选择：
- en: What kind of assets are involved? If only JavaScript is involved, then Webpack
    might be good. If you have multiple HTML pages that all need to be processed,
    then **Vite** might be a great option.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及到哪些类型的资产？如果只涉及JavaScript，那么Webpack可能是个不错的选择。如果你有多个需要处理的HTML页面，那么**Vite**可能是个很好的选择。
- en: How many dependencies are you using? Especially when you use older libraries
    from npm, a bundler with a broad range of support – such as Webpack – may be the
    best choice. Otherwise, look for faster options, such as esbuild.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用了多少依赖项？尤其是在你使用npm中的较老库时，一个支持范围广泛的打包器——例如Webpack——可能是最佳选择。否则，寻找更快的选项，如esbuild。
- en: How familiar is the team with bundlers and their options? If the team is not
    familiar with bundling at all, then Parcel could be a great way to get started.
    Otherwise, Webpack potentially has the most documentation out there. A community
    that is rather new and very active and helpful can be found with Vite.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队对打包器和它们的选项熟悉到什么程度？如果团队对打包一无所知，那么Parcel可能是一个很好的入门方式。否则，Webpack可能拥有最多的文档。在Vite中可以找到一个相对较新但非常活跃且乐于助人的社区。
- en: Are you building an application or just want to optimize the assets of a library?
    Especially for a library, something smaller, such as esbuild, might be useful.
    On the other hand, Parcel has a lot to offer here, too. In general, Vite should
    be avoided for libraries. Support is there, but it just does not feel to be ready
    yet for building libraries more efficiently than Rollup.js and esbuild.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是在构建一个应用程序还是只想优化库的资产？特别是对于库，一些更小的工具，如esbuild，可能很有用。另一方面，Parcel在这里也有很多可提供的东西。总的来说，对于库，应避免使用Vite。虽然支持存在，但它似乎还没有准备好比Rollup.js和esbuild更有效地构建库。
- en: Do you need support for advanced scenarios such as offline mode or web workers?
    In these cases, the ecosystem of Webpack is very often hard to beat. Parcel also
    does a good job of offering helpers in this area. esbuild should be avoided for
    such scenarios.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否需要支持高级场景，如离线模式或web workers？在这些情况下，Webpack的生态系统通常很难被超越。Parcel在这方面也做得很好，提供了许多辅助工具。对于此类场景，应避免使用esbuild。
- en: How important is performance? If you have a larger code base (above 1,000 modules
    or 100,000 lines of code), then Webpack is known to be a performance killer, taking
    easily 30 seconds to minutes. Picking something such as Vite or – if possible
    – esbuild will certainly help speed up the process. While the former is more developer
    friendly, it also comes with a lot of hidden complexity. The latter is more direct
    but lacks standard features such as **hot-module** **reloading** (**HMR**).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能有多重要？如果你有一个较大的代码库（超过1,000个模块或10万行代码），那么Webpack已知是一个性能杀手，可能需要30秒到几分钟。选择像Vite或如果可能的话esbuild将肯定有助于加快过程。虽然前者对开发者更友好，但它也带来了很多隐藏的复杂性。后者更直接，但缺乏标准功能，如**热模块****重新加载**（**HMR**）。
- en: How much maintenance is acceptable? Bundlers that rely on a lot of plugins are
    traditionally much harder to maintain. Upgrading Webpack to the next major version
    has been notoriously difficult. From missing plugins to breaking changes in the
    plugin’s API – everything that can happen will also happen in such cases. Prefer
    bundlers such as Parcel or Vite that try to come with everything necessary out
    of the box.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多少维护是可以接受的？依赖于大量插件的打包器传统上维护起来要困难得多。升级 Webpack 到下一个主要版本一直是出了名的困难。从缺少插件到插件 API
    的破坏性更改——所有可能发生的情况在这种情况下都会发生。更倾向于使用如 Parcel 或 Vite 这样的打包器，这些打包器试图提供所有必要的功能。
- en: How important are additional development features such as bundle insights? If
    these are supercritical, then nothing is better than Webpack. As the Webpack ecosystem
    is super large, you’ll find additional tools, libraries, and guides easily. On
    the other hand, choosing something with a growing community such as Vite might
    also work fine. If something is missing, the community should be capable of picking
    it up quickly, too.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的开发功能（如打包洞察）有多重要？如果这些是至关重要的，那么没有什么比 Webpack 更好的了。由于 Webpack 生态系统非常大，你可以轻松找到额外的工具、库和指南。另一方面，选择一个拥有成长社区的选项，如
    Vite，也可能工作得很好。如果缺少某些功能，社区也应该能够快速拾起它们。
- en: In the following sections, we’ll go over an example project to see how some
    of the most popular bundlers can be used to build it. We’ll use a project with
    a small, but non-trivial code base. For this example, we’ll use **React** – but
    don’t worry, you don’t need to know React to follow this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过一个示例项目来了解如何使用一些最受欢迎的打包器来构建它。我们将使用一个代码库较小但非平凡的示例项目。对于这个例子，我们将使用
    **React**——但请放心，您不需要了解 React 就能跟随这一章节。
- en: React
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: React
- en: React is arguably the most popular UI library for web frontend development.
    It allows developers to build UIs quickly in JavaScript by leveraging a language
    extension known as `Button` or `Carousel`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，React 是用于网络前端开发的最受欢迎的 UI 库。它允许开发者通过利用名为 `Button` 或 `Carousel` 的语言扩展，在 JavaScript
    中快速构建 UI。
- en: 'The code base for the example we’ll cover consists of the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要覆盖的示例项目的代码库包括以下内容：
- en: The source code of a **single-page** **application** (**SPA**)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单页应用**（SPA）的源代码（**SPA**）'
- en: An `index.html`) of the SPA
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPA 的 `index.html`
- en: Several asset files (videos, images in different formats, audio)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个资产文件（视频、不同格式的图片、音频）
- en: Several non-trivial dependencies
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个非平凡依赖项
- en: Some files that use TypeScript instead of JavaScript
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些使用 TypeScript 而不是 JavaScript 的文件
- en: A special **CSS** preprocessor called **SASS**
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 **SASS** 的特殊 **CSS** 预处理器
- en: A web framework (React with React Router) is being used
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在使用一个网络框架（React 与 React Router）
- en: Different virtual routes should lead to different pieces of the page that have
    to be lazy loaded
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的虚拟路由应引导到需要懒加载的不同页面部分
- en: All in all, this example should produce a small demo application that contains
    a video and audio player that uses third-party dependencies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个示例应该生成一个包含视频和音频播放器的小型演示应用程序，该播放器使用第三方依赖项。
- en: Lazy loading
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载
- en: Lazy loading describes a technique where not all parts required by an application
    are loaded immediately. For a SPA, this makes sense – after all, not every component
    or part of the SPA will be required for the current user interaction. And even
    if it isn’t required, it could be at some later point in time. Lazy loading usually
    involves loading additional script (or other) files when some action such as a
    user clicking on a button or following some internal link is performed. The implementation
    of lazy loading needs to be supported by the respective UI framework (for example,
    React has a function called `lazy`) but is done by the bundler.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载描述了一种技术，其中并非所有应用程序所需的部分都会立即加载。对于一个 SPA 来说，这很有意义——毕竟，并非每个组件或 SPA 的部分都会在当前用户交互中需要。即使它不是必需的，它也可能在某个未来的时间点需要。懒加载通常涉及在执行某些操作（例如用户点击按钮或跟随某些内部链接）时加载额外的脚本（或其他）文件。懒加载的实现需要得到相应的
    UI 框架的支持（例如，React 有一个名为 `lazy` 的函数），但由打包器完成。
- en: 'The boilerplate for this example can be created by initializing a new Node.js
    project:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过初始化一个新的 Node.js 项目来创建这个示例的模板：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we’ll add all the runtime dependencies – that is, the packages that will
    be required when our application runs in the browser:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加所有运行时依赖项——也就是说，当我们的应用程序在浏览器中运行时所需的包：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At the end of the day, it will be the job of the bundler to add the preceding
    dependencies to scripts that can be run in the browser. However, for us, it makes
    sense to do this to get a clear view of which packages are just required for the
    tooling, and which dependencies are needed for the code to run.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将添加前面的依赖项到可以在浏览器中运行的脚本中将是打包器的任务。然而，对我们来说，这样做以清楚地了解哪些包只是用于工具的，哪些依赖项是代码运行所需的，是有意义的。
- en: 'The basic `devDependencies` – that is, the ones that are required for the tooling
    – are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的`devDependencies`——即那些用于工具的依赖项——如下所示：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Additional tooling dependencies are required, too, but will be bundler-specific.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要额外的工具依赖项，但这些将取决于打包器。
- en: 'The example application contains the following source files:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序包含以下源文件：
- en: '`index.html`: Template for the SPA website'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`：SPA网站的模板'
- en: '`script.tsx`: Starts to run the application'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script.tsx`：开始运行应用程序'
- en: '`App.tsx`: The application root'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.tsx`：应用程序根'
- en: '`Layout.tsx`: The layout of the application'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Layout.tsx`：应用程序的布局'
- en: '`Home.tsx`: The home page containing links to all pages'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Home.tsx`：包含指向所有页面的主页'
- en: '`Video.tsx`: The page containing the video player'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Video.tsx`：包含视频播放器的页面'
- en: '`Audio.tsx`: The page containing the audio player'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Audio.tsx`：包含音频播放器的页面'
- en: '`Player.jsx`: The React component for the video and audio player'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player.jsx`：视频和音频播放器的React组件'
- en: '`earth.mp4`: Video file to play'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`earth.mp4`：要播放的视频文件'
- en: '`river.webp`: Preview image (`.webp` format) for the video file'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`river.webp`：视频文件的预览图片（`.webp`格式）'
- en: '`snow.jpg`: Preview image (`.jpg` format) for the sound file'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snow.jpg`：音频文件的预览图片（`.jpg`格式）'
- en: '`sound.mp3`: Audio file to play'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sound.mp3`：要播放的音频文件'
- en: 'The process of showing a UI is usually called rendering. When React first renders
    the application, it needs to mount its component tree on the DOM tree. This is
    done in the `script.tsx` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 显示UI的过程通常被称为渲染。当React首次渲染应用程序时，它需要在DOM树中挂载其组件树。这是在`script.tsx`文件中完成的：
- en: script.tsx
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: script.tsx
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The usage of angle brackets for initiating `App` is referred to as JSX. Under
    the hood, the additional `x` in the file extension (`tsx`) enables such expressions
    to be processed, where `<App />` will be transformed into `React.createElement(App)`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尖括号来启动`App`的过程被称为JSX。在底层，文件扩展名中的额外`x`（`tsx`）使得这些表达式可以被处理，其中`<App />`将被转换为`React.createElement(App)`。
- en: 'The `App` component itself is defined as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件本身定义如下：'
- en: App.tsx
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: App.tsx
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This kind of structure is typical for a SPA. All the different routes come together
    in a router or root component to be displayed when a certain path is found. For
    instance, in our application, the `/video` path would show the `Video` component,
    while the `/audio` path would show the `Audio` component. All these components
    will be embedded in a `Layout` component, which is responsible for the general
    layout, such as showing the header and the footer, of the application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构对于SPA来说是典型的。所有不同的路由都会在路由器或根组件中汇集，以便在找到特定路径时显示。例如，在我们的应用程序中，`/video`路径将显示`Video`组件，而`/audio`路径将显示`Audio`组件。所有这些组件都将嵌入到`Layout`组件中，该组件负责应用程序的一般布局，例如显示页眉和页脚。
- en: In the `App.tsx` file, lazy loading is initiated by using the ESM `import` function.
    Bundlers should be capable of transforming that into loading another script and
    returning a `Promise` at that location.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.tsx`文件中，通过使用ESM `import`函数启动懒加载。打包器应该能够将其转换为加载另一个脚本并在该位置返回一个`Promise`。
- en: Promises
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Promises
- en: The specification describes an `import` function to return a `Promise`. A `Promise`
    is an object that can be used to determine when an asynchronous operation is finished.
    The object exposes functions, which are called with the result of the asynchronous
    operation or with an error that was thrown during the operation. The most important
    functions are `then` and `catch`. The former can be used to define what to do
    when something is successfully returned, while the latter can be used to handle
    errors.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 规范描述了一个返回`Promise`的`import`函数。`Promise`是一个可以用来确定异步操作何时完成的对象。该对象公开了函数，这些函数可以用来处理异步操作的结果或操作过程中抛出的错误。最重要的函数是`then`和`catch`。前者可以用来定义当成功返回时应该做什么，而后者可以用来处理错误。
- en: 'In a SPA, it makes sense to put every page in a router into lazy loading. *Figure
    6**.3* shows a high-level overview of the example application’s modules. The dashed
    boxes indicate bundling areas – that is, source files that can be grouped into
    combined output files. This bundling is one of the most crucial aspects of any
    bundler:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页应用（SPA）中，将每个页面放入路由器中进行懒加载是有意义的。*图 6**.3* 展示了示例应用程序模块的高级概述。虚线框表示捆绑区域——即可以组合成输出文件的源文件。这种捆绑是任何打包器最重要的方面之一：
- en: '![Figure 6.3 – The example application’s modules ](img/Figure_6.3_B18989.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 示例应用程序的模块](img/Figure_6.3_B18989.jpg)'
- en: Figure 6.3 – The example application’s modules
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 示例应用程序的模块
- en: While some of the given aspects should be rather simple to implement in a bundler,
    other properties of the example application might be challenging. For instance,
    what is the behavior of a bundler when duplicate modules are found? Some bundlers
    may duplicate the generated code while others may create a shared bundle that
    is a loading prerequisite for the generated side bundles.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些给定的方面在打包器中实现起来可能相当简单，但示例应用程序的一些其他属性可能具有挑战性。例如，当找到重复模块时，打包器的行为是什么？一些打包器可能会重复生成的代码，而其他打包器可能会创建一个共享捆绑包，它是生成侧捆绑包的加载前提。
- en: In the case of this example, we can see that `Player.jsx` appears twice. We’ll
    use this to answer the question for each bundler. Furthermore, pretty much every
    module requires `react`; however, since it is already required in the initial
    script module (`script.tsx`), it should not be duplicated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们可以看到 `Player.jsx` 出现了两次。我们将利用这一点来回答每个打包器的问题。此外，几乎每个模块都需要 `react`；然而，由于它已经在初始脚本模块（`script.tsx`）中要求，因此不应重复。
- en: Without further ado, let’s see how this example application can be bundled using
    Webpack.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们看看这个示例应用程序如何使用 Webpack 进行捆绑。
- en: Using Webpack
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Webpack
- en: Webpack is presumably the most popular option among the available bundlers.
    It is also among the oldest bundlers – dating back to a time when Node.js was
    still young and the whole idea of bundling was rather new. At this time, task
    runners were still dominantly used. However, the increasing complexity of frontend
    development opened the door for much more elaborate tooling.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 可能是所有打包器中最受欢迎的选项之一。它也是最早的打包器之一——追溯到 Node.js 仍很年轻，捆绑整个想法相当新颖的时代。当时，任务运行器仍然占主导地位。然而，前端开发的日益复杂为更复杂的工具打开了大门。
- en: One thing that makes Webpack stand out is its ecosystem. From the very beginning,
    Webpack decided to develop only a very shallow core focusing on module resolution.
    In some sense, Webpack is just the wrapper holding all these plugins together
    with a fixed plan of execution. It pretty much combines the configuration that
    was thrown in by the user, with the power of all the selected plugins.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使 Webpack 突出的是其生态系统。从一开始，Webpack 决定只开发一个非常浅的核心，专注于模块解析。在某种程度上，Webpack 只是一个将所有这些插件组合在一起并具有固定执行计划的包装器。它基本上将用户抛入的配置与所有选定的插件的力量结合起来。
- en: Today, Webpack can also work without plugins or a configuration. At least in
    theory. In practice, every project that goes beyond some simple examples will
    require a bit of configuration. Also, interesting features such as support for
    other languages such as TypeScript will require a plugin.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Webpack 也可以在没有插件或配置的情况下工作。至少在理论上是这样。在实践中，任何超出一些简单示例的项目都需要一些配置。此外，支持 TypeScript
    等其他语言等有趣的功能将需要插件。
- en: 'To get started with Webpack, we need to install the `webpack` and `webpack-cli`
    packages using npm:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Webpack，我们需要使用 npm 安装 `webpack` 和 `webpack-cli` 包：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we only wanted to use Webpack programmatically, such as from a Node.js script,
    then we could also spare the `webpack-cli` package installation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想以编程方式使用 Webpack，例如从一个 Node.js 脚本中，那么我们也可以省去 `webpack-cli` 包的安装。
- en: 'To run Webpack from the command line, you can use `npx` together with the `webpack`
    executable:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行运行 Webpack，你可以使用 `npx` 与 `webpack` 可执行文件一起：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Just running Webpack like this will not be successful:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这样直接运行 Webpack 不会成功：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Fixing the warning about `mode` is rather simple – all we need to do is to provide
    a CLI flag such as `--mode production`. The more problematic issue is that Webpack
    does not find any entry point.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 修复关于 `mode` 的警告相当简单——我们只需要提供一个 CLI 标志，例如 `--mode production`。更成问题的是，Webpack
    找不到任何入口点。
- en: As mentioned already, there is a chance that Webpack may just work, but usually,
    we’ll be forced to create a configuration file. Webpack uses real Node.js modules
    to provide the configuration, which gives us the full power of the Node.js ecosystem.
    A Webpack configuration is called `webpack.config.js` and should be placed next
    to the `package.json` file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Webpack 可能会直接工作，但通常我们被迫创建一个配置文件。Webpack 使用真实的 Node.js 模块来提供配置，这为我们提供了 Node.js
    生态系统的全部功能。Webpack 配置称为 `webpack.config.js`，应放置在 `package.json` 文件旁边。
- en: 'Let’s create a rather lightweight one. The highlighted property is one of Webpack’s
    fundamental configuration sections, telling the bundler what entry points to use:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个相当轻量级的配置。突出显示的属性是 Webpack 基本配置部分之一，告诉打包器使用哪些入口点：
- en: webpack.config.js
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: webpack.config.js
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can try running Webpack again:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次尝试运行 Webpack：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is better, but we’re still not there yet. Webpack requires a plugin to
    understand special files such as TypeScript or SASS sources. Therefore, we need
    to install these development dependencies, too. In this case, we require quite
    a list of plugins to make everything work:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好，但我们还没有达到目标。Webpack 需要一个插件来理解特殊文件，例如 TypeScript 或 SASS 源文件。因此，我们还需要安装这些开发依赖项。在这种情况下，我们需要相当多的插件来使一切正常工作：
- en: '`ts-loader` is a plugin for handling TypeScript files by transforming them
    into JavaScript'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts-loader` 是一个插件，用于通过将其转换为 JavaScript 来处理 TypeScript 文件'
- en: '`sass-loader` is a plugin for handling SASS files by transforming them into
    CSS'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sass-loader` 是一个插件，用于通过将其转换为 CSS 来处理 SASS 文件'
- en: '`css-loader` is a plugin for handling CSS by transforming it into a text module'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css-loader` 是一个插件，用于通过将其转换为文本模块来处理 CSS'
- en: '`style-loader` is a plugin for handling CSS by transforming it into a JavaScript
    module'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style-loader` 是一个插件，用于通过将其转换为 JavaScript 模块来处理 CSS'
- en: '`babel-loader` is a plugin for using Babel to transform JavaScript files with
    additional syntax (such as JSX) into plain JS'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babel-loader` 是一个插件，用于使用 Babel 将具有附加语法（如 JSX）的 JavaScript 文件转换为纯 JS'
- en: '`html-webpack-plugin` is a plugin for loading an HTML file as a template for
    the output HTML file'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html-webpack-plugin` 是一个插件，用于将 HTML 文件作为输出 HTML 文件的模板加载'
- en: The big disadvantage of Webpack is that everything must be a JavaScript module
    in the end. Quite often, plugins perform some tricks to end up with empty modules,
    but they still emit the result (such as a separate image or CSS file) to the filesystem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 的一个重大缺点是最终一切都必须是 JavaScript 模块。相当常见的是，插件会玩一些技巧来最终得到空模块，但它们仍然会将结果（如单独的图像或
    CSS 文件）输出到文件系统。
- en: 'You can install the remaining dependencies can be done from the command line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从命令行安装剩余的依赖项：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'One thing we also need to supply is a proper `tsconfig.json`. Without this
    file, TypeScript won’t be configured correctly. The `ts-loader` plugin of Webpack
    works quite closely together with TypeScripts, so it requires this file to know
    what files to consider and which files to drop. It also uses this to properly
    transform the file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供适当的 `tsconfig.json` 文件。没有这个文件，TypeScript 将无法正确配置。Webpack 的 `ts-loader`
    插件与 TypeScript 工作得相当紧密，因此它需要这个文件来知道要考虑哪些文件以及要丢弃哪些文件。它还使用这个文件来正确转换文件：
- en: tsconfig.json
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: tsconfig.json
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this configuration, TypeScript has been set up to process JSX in the default
    React way (that is, transforming JSX into `React.createElement` calls). The configuration
    will also output ESM module syntax (the highlighted option), which is important
    for Webpack to correctly identify imports and exports. Without this, bundle splitting
    won’t work if triggered from TypeScript files. Finally, we include all the files
    in the `src` folder and exclude the `node_modules` folder. The latter is a common
    practice to save a substantial amount of processing time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，TypeScript 已经设置为以默认的 React 方式（即，将 JSX 转换为 `React.createElement` 调用）处理
    JSX。配置还将输出 ESM 模块语法（突出显示的选项），这对于 Webpack 正确识别导入和导出非常重要。如果没有这个，从 TypeScript 文件触发时，捆绑拆分将无法工作。最后，我们将
    `src` 文件夹中的所有文件包含在内，并排除 `node_modules` 文件夹。后者是一种常见的做法，可以节省大量的处理时间。
- en: Now, to get all these things working together, we need to extend the Webpack
    configuration quite a bit. First, we need to import (that is, `require`) all the
    plugins that we’d like to use. In this case, we only want to use `html-webpack-plugin`.
    Next, we need to set up the rules for all the loaders we need to include. This
    is done via the `module.rules` array. Finally, we need to define what to do with
    the remaining assets.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使所有这些功能协同工作，我们需要相当扩展 Webpack 配置。首先，我们需要导入（即 `require`）我们希望使用的所有插件。在这种情况下，我们只想使用
    `html-webpack-plugin`。接下来，我们需要设置所有需要包含的加载器的规则。这是通过 `module.rules` 数组完成的。最后，我们需要定义对剩余资源的处理方式。
- en: 'Let’s see how the Webpack configuration could be written to successfully bundle
    our example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写 Webpack 配置以成功打包我们的示例：
- en: webpack.config.js
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: webpack.config.js
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code is quite lengthy. One of the often-heard criticisms of Webpack
    is that its configuration tends to become quite complex quickly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码相当长。Webpack 经常被听到的一个批评是，其配置很快就会变得相当复杂。
- en: An important part of a Webpack configuration is the use of regular expressions.
    The `test` and `exclude` parts of a rule work best with a regular expression.
    Therefore, instead of having a string with some magic behavior or a very explicit
    and repetitive function, a regular expression is supplied that will check if the
    current module should be processed by this rule or not.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 配置的一个重要部分是使用正则表达式。规则中的 `test` 和 `exclude` 部分与正则表达式配合使用效果最佳。因此，而不是使用具有一些魔法行为或非常明确且重复的函数的字符串，我们提供了一个正则表达式，该表达式将检查当前模块是否应该由此规则处理。
- en: The options for each loader or plugin are determined by the respective loader
    or plugin. Therefore, knowing Webpack is not sufficient to successfully write
    a Webpack configuration. You’ll always need to look up the documentation of the
    different parts that are used in the configuration. In the preceding configuration,
    this has been the case with the `ts-loader` and `babel-loader` configurations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加载器或插件的选项由相应的加载器或插件确定。因此，仅了解 Webpack 并不足以成功编写 Webpack 配置。你总是需要查阅配置中使用的不同部分的文档。在前面的配置中，`ts-loader`
    和 `babel-loader` 配置就是这样处理的。
- en: Loaders are evaluated from right to left. For instance, in the case of `*.scss`
    files, the content is first transformed by `sass-loader`, which then hands over
    to `css-loader`. In the end, all the content is packaged up as a `style` tag by
    `style-loader`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器是从右到左进行评估的。例如，在处理 `*.scss` 文件的情况下，内容首先由 `sass-loader` 转换，然后传递给 `css-loader`。最后，所有内容都通过
    `style-loader` 打包成一个 `style` 标签。
- en: We don’t always need to use a dedicated package for loaders. Using the `type`
    property highlighted in the previous code, we can use some premade loaders from
    Webpack, such as the resource loader (`asset/resource`) to return the paths to
    referenced files. Other options include data URIs (`asset/inline`) and accessing
    a file’s raw content (`asset/source`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不总是需要为加载器使用专门的包。使用前面代码中突出显示的 `type` 属性，我们可以使用 Webpack 的一些预制加载器，例如资源加载器 (`asset/resource`)
    来返回引用文件的路径。其他选项包括数据 URI (`asset/inline`) 和访问文件的原始内容 (`asset/source`)。
- en: Another way to use Webpack is to start a small server during development. Whenever
    we make updates to the code, the bundler can reprocess the changed parts and automatically
    update any active browsing sessions. All in all, this is a very convenient and
    quite productive way of writing a frontend application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用 Webpack 的方法是，在开发过程中启动一个小型服务器。每当我们对代码进行更新时，打包器可以重新处理更改的部分，并自动更新任何活跃的浏览会话。总的来说，这是一种非常方便且相当高效的方式来编写前端应用程序。
- en: 'For Webpack’s live server to work, we’ll need to install yet another tooling
    dependency:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Webpack 的实时服务器工作，我们还需要安装另一个工具依赖项：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This allows us to run the `serve` command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们运行 `serve` 命令：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The live server will keep on running until it is forcefully shut down. On the
    command line, this can be done by pressing *Ctrl* + *C*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实时服务器将持续运行，直到被强制关闭。在命令行中，可以通过按 *Ctrl* + *C* 来完成。
- en: 'One thing to add to `webpack.config.js` would be the history API fallback for
    the development server (the `devServer` section in a Webpack configuration). This
    will improve the development experience of a SPA by a fair margin:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webpack.config.js` 中需要添加的一项是开发服务器（Webpack 配置中的 `devServer` 部分）的历史 API 回退。这将显著提高单页应用程序（SPA）的开发体验：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This setting will respond to all 404 URLs with `index.html` of the root directory
    – just like a SPA should be configured in production mode. This way, refreshing
    when being on a page with a different path than `/` will still work. Without the
    shown configuration, the 404 error will be shown in the browser – no SPA will
    load and handle the route.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置将响应所有404 URL，使用根目录的`index.html` – 就像生产模式中应该配置的单页应用（SPA）一样。这样，在非`/`路径的页面上刷新时仍然可以工作。如果没有显示的配置，浏览器将显示404错误
    – 没有SPA将加载和处理路由。
- en: Now that we know how bundling the example application works in Webpack, it’s
    time to look at a more lightweight alternative named esbuild.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了在Webpack中捆绑示例应用程序的工作方式，是时候看看一个更轻量级的替代品esbuild了。
- en: Using esbuild
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用esbuild
- en: esbuild is quite a new tool that focuses on performance. The key to esbuild’s
    enhanced performance is that it was written from the ground up in the Go programming
    language. The result is a native binary that has certain advantages over pure
    JavaScript solutions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: esbuild是一个相当新的工具，专注于性能。esbuild增强性能的关键在于它从头到尾是用Go编程语言编写的。结果是具有某些优势的原生二进制文件，这些优势超过了纯JavaScript解决方案。
- en: If esbuild stopped at providing a native solution, it would potentially not
    be qualified to make this list. After all, flexibility and the option to extend
    the original functionality are key for any kind of bundler. Luckily, the creator
    of esbuild has thought about this and come up with an elegant solution. While
    the core of esbuild remains native – that is, written in Go and provided as a
    binary – plugins can be written using JavaScript. This way, we get the best of
    both worlds.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果esbuild只提供原生解决方案，它可能不足以进入这个列表。毕竟，灵活性和扩展原始功能的选择对于任何类型的捆绑器都是关键。幸运的是，esbuild的创造者已经考虑了这一点，并提出了一种优雅的解决方案。虽然esbuild的核心仍然是原生的
    – 即，用Go编写并提供为二进制文件 – 插件可以用JavaScript编写。这样，我们就得到了两者的最佳结合。
- en: 'To get started with esbuild, we need to install the `esbuild` package using
    npm:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用esbuild，我们需要使用npm安装`esbuild`包：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this one installation, you can use esbuild programmatically, as well as
    directly from the command line.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次安装，你可以以编程方式使用esbuild，也可以直接从命令行使用。
- en: 'To run esbuild from the command line, you can use `npx` together with the `esbuild`
    executable:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行运行esbuild，你可以使用`npx`与`esbuild`可执行文件一起使用：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will show all the CLI options. To do something, at least one entry point
    needs to be supplied:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所有CLI选项。要执行某些操作，至少需要提供一个入口点：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As expected, we miss a few configuration steps. As with Webpack, the best way
    to teach esbuild about these extra bits is by creating a configuration. Unlike
    Webpack, we do not have a predefined configuration file – instead, the way to
    configure esbuild is by using it programmatically.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们缺少一些配置步骤。与Webpack一样，最好的方法是通过创建配置来教esbuild关于这些额外信息。与Webpack不同，我们没有预定义的配置文件
    – 相反，配置esbuild的方式是通过编程方式使用它。
- en: To do that, we must create a new file called `build.js` and import the `esbuild`
    package. We can use the `build` and `buildSync` functions to trigger the bundling
    process via esbuild.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须创建一个名为`build.js`的新文件，并导入`esbuild`包。我们可以使用`build`和`buildSync`函数通过esbuild触发捆绑过程。
- en: 'The previous CLI command can be written programmatically like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的CLI命令可以像这样以编程方式编写：
- en: build.js
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: build.js
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Of course, the given script will essentially give us the same error as using
    the CLI directly. Therefore, let’s add a few things:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，给定的脚本本质上会给我们带来与直接使用CLI相同的错误。因此，让我们添加一些东西：
- en: '`esbuild-sass-plugin` integrates the transformation of SASS into CSS files'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`esbuild-sass-plugin`将SASS转换为CSS文件'
- en: '`@craftamap/esbuild-plugin-html` allows us to use template HTML files'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@craftamap/esbuild-plugin-html`允许我们使用模板HTML文件'
- en: 'Before we can use these two plugins, we need to install them:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用这两个插件之前，我们需要安装它们：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the plugins are installed, we can extend the `build.js` file so that it
    includes these two plugins:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了插件，我们就可以扩展`build.js`文件，使其包含这两个插件：
- en: build.js
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: build.js
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Along the way, we taught esbuild about our preference for the given file extensions.
    With the `loader` section, we map extensions to specific file loaders. The `file`
    type refers to a loader that will produce an external file. The import of that
    file will result in a reference to the file’s relative output path.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们教esbuild关于我们对于给定文件扩展名的偏好。通过`loader`部分，我们将扩展名映射到特定的文件加载器。`file`类型指的是将生成外部文件的加载器。该文件的导入将导致对文件相对输出路径的引用。
- en: To enable bundle splitting, the `splitting` option needs to be set. This also
    makes the use of the `esm` format necessary. It’s the only format where esbuild
    knows how to produce scripts that can lazy load something. Additionally, `htmlPlugin`
    requires esbuild to produce a metafile to reflect the build artifacts. Therefore,
    the `metafile` option needs to be set to `true`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用包分割，需要设置`splitting`选项。这也使得使用`esm`格式成为必要。这是esbuild知道如何生成可以懒加载内容的脚本的唯一格式。此外，`htmlPlugin`需要esbuild生成一个元文件来反映构建工件。因此，需要将`metafile`选项设置为`true`。
- en: Like Webpack, the ecosystem of esbuild is what makes this tool so flexible,
    yet hard to master. The options for the different plugins need to be collected
    from the different plugin documentation. Like the Webpack ecosystem beforehand,
    the quality of these plugins, as well as their maturity and the community behind
    them, varies a lot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与Webpack一样，esbuild的生态系统使得这个工具如此灵活，但难以掌握。不同插件的选择需要从不同的插件文档中收集。就像之前的Webpack生态系统一样，这些插件的质量、成熟度以及背后的社区差异很大。
- en: If you want to have a development server – just like the one we added to Webpack
    in the previous section – you can use the `serve` function, which can be imported
    from `esbuild`. The first argument describes server-specific settings such as
    the port where the service should be listening. The second argument comprises
    the build options – that is, the options we are supplying right now – as the only
    argument to the `build` function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个开发服务器——就像我们在上一节中添加到Webpack中的那样——你可以使用`serve`函数，该函数可以从`esbuild`导入。第一个参数描述了服务器特定的设置，例如服务应监听的端口。第二个参数包含构建选项——即我们现在提供的选项——作为`build`函数的唯一参数。
- en: 'Let’s write another script called `serve.js` to illustrate this usage:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个名为`serve.js`的脚本来说明这种用法：
- en: serve.js
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: serve.js
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: One thing that esbuild does not do at the moment is HMR. Consequently, the developer’s
    experience of just using esbuild may be a little bit underwhelming in that area
    when compared to similar tools.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 目前esbuild不做的一件事是HMR。因此，与类似工具相比，仅使用esbuild的开发者体验可能在这方面略感不足。
- en: With this in mind, let’s explore yet another option that is widely used for
    bundling – let’s have a look at the configuration-less Parcel bundler.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们再探索一个广泛用于打包的选项——让我们来看看无需配置的Parcel打包器。
- en: Using Parcel
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parcel
- en: 'When Parcel arrived in the community, the hype around it was massive. The reason
    for this was to be found in one new feature: configuration-free bundling. Parcel
    tried to leverage information that was already given in `package.json` – or configuration
    files written for specific tools such as Babel. Using this mechanism, the creators
    of Parcel thought to remove the complexity of configuring a bundler.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当包裹到达社区时，围绕它的炒作非常巨大。这其中的原因在于一个新特性：无需配置的打包。Parcel试图利用`package.json`中已经提供的信息——或者为特定工具（如Babel）编写的配置文件。通过这种机制，Parcel的创造者认为可以消除配置打包器的复杂性。
- en: Ultimately, however, the whole aspect backfired in some sense. As mentioned
    previously, a bundler requires some flexibility. To achieve this kind of flexibility,
    a sound configuration system is necessary. While the configuration system of Webpack
    is a bit too verbose and complex, the one provided with esbuild might be a bit
    too low-level.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终，整个方面在某些意义上适得其反。如前所述，打包器需要一些灵活性。为了实现这种灵活性，需要一个健全的配置系统。虽然Webpack的配置系统有点过于冗长和复杂，但esbuild提供的可能又有点过于底层。
- en: The successor of the original Parcel now also offers an optional configuration
    system, which tries to be right between the verbosity of Webpack and the low-level
    one of esbuild. This makes Parcel no longer configuration-free, but rather a configuration-less
    bundler.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 原始Parcel的继任者现在也提供了一种可选的配置系统，它试图在Webpack的冗长和复杂性与esbuild的低级之间取得平衡。这使得Parcel不再是无需配置的，而是一个无需配置的打包器。
- en: 'To get started with Parcel, we need to install the `parcel` package using npm:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Parcel，我们需要使用npm安装`parcel`包：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this installation, you can use Parcel programmatically, as well as directly
    from the command line.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次安装，你可以以编程方式使用Parcel，也可以直接从命令行使用。
- en: 'To run Parcel from the command line, you can use `npx` together with the `parcel`
    executable. For Parcel, the entry point can be the HTML file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行运行Parcel，你可以使用`npx`与`parcel`可执行文件一起。对于Parcel，入口点可以是HTML文件：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our case, we still need to modify the HTML so that it also points to the
    other source files to continue building up the module graph. A version of the
    `index.html` file that fits much better with Parcel would look as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们仍然需要修改 HTML，使其也指向其他源文件以继续构建模块图。一个与 Parcel 更为契合的 `index.html` 文件版本如下所示：
- en: index.html
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: index.html
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Importantly, we’ve added the stylesheet and script entry points. These will
    be detected by Parcel and properly bundled. In the end, the HTML file will be
    used as a template – with the entry points being replaced by the bundled stylesheet
    and script file references.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们添加了样式表和脚本入口点。这些将被 Parcel 检测并正确打包。最终，HTML 文件将被用作模板——入口点将被打包的样式表和脚本文件引用所替换。
- en: 'Starting Parcel right now will already partially work, but at this time, Parcel
    still has some problems with our audio and video files. While Parcel knows most
    image files (such as `*.webp` or `*.png`) already, some other assets need to be
    configured first. In Parcel, this means creating a `.parcelrc` file and adding
    a section about the transformers to use:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 立即启动 Parcel 将部分工作，但在此阶段，Parcel 仍然与我们的音频和视频文件存在一些问题。虽然 Parcel 已经知道大多数图像文件（如 `*.webp`
    或 `*.png`），但一些其他资产需要先进行配置。在 Parcel 中，这意味着创建一个 `.parcelrc` 文件并添加一个关于要使用的转换器的部分：
- en: .parcelrc
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: .parcelrc
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The configuration instructs Parcel to still rely on the very well-chosen defaults.
    However, we also added the definitions for the two file types in question to the
    section that handles the transformation logic. Like Webpack or esbuild, Parcel
    also has an in-built type to handle such imports by returning a filename that
    can be used within the code. In the case of Parcel, this type is called `@parcel/transformer-raw`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 配置指示 Parcel 仍然依赖于非常精心选择的默认设置。然而，我们也在处理转换逻辑的部分添加了有关两种文件类型的定义。与 Webpack 或 esbuild
    一样，Parcel 也内置了一个类型来处理此类导入，通过返回可以在代码中使用的文件名。在 Parcel 的情况下，这个类型被称为 `@parcel/transformer-raw`。
- en: 'Now, let’s see if Parcel is already running:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Parcel 是否已经启动：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By default, Parcel will start a development server. This already contains everything
    that is needed for developing an application. Quite convenient. If we want to
    build the files – for example, to place the output artifacts on a server – we
    can use the `build` subcommand:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Parcel 将启动一个开发服务器。这已经包含了开发应用程序所需的一切。非常方便。如果我们想构建文件——例如，将输出工件放置在服务器上——我们可以使用
    `build` 子命令：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are CLI flags and options to set almost everything, such as the output
    directory. Nevertheless, by default, the quite common `dist` folder is chosen.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有 CLI 标志和选项可以设置几乎一切，例如输出目录。然而，默认情况下，相当常见的 `dist` 文件夹被选中。
- en: Last, but not least, let’s have a look at the quite trendy Vite bundler, which
    tries to combine the advantages of all previous approaches into a single tool.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，让我们来看看相当流行的 Vite 打包器，它试图将所有先前方法的优点结合成一个单一的工具。
- en: Using Vite
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vite
- en: The latest addition to the set of popular bundlers is Vite. It combines a few
    existing tools – such as Rollup.js and esbuild – together with a unified plugin
    system to allow rapid development. Vite’s approach is to give you the power of
    Webpack at the speed of esbuild.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在流行的打包器集中，最新加入的是 Vite。它结合了几种现有的工具——例如 Rollup.js 和 esbuild——以及一个统一的插件系统，以允许快速开发。Vite
    的方法是在 esbuild 的速度下提供 Webpack 的功能。
- en: Originally, Vite was built by the creator of the frontend framework Vue. However,
    as time went on, Vite’s plugin system became a lot more powerful. With its increased
    API surface, other frontend frameworks such as React or Svelte could be supported.
    Now, Vite has evolved from a single-purpose tool to a real Swiss Army knife –
    thanks to a well-thought-out plugin mechanism with an active community.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Vite 是由前端框架 Vue 的创建者构建的。然而，随着时间的推移，Vite 的插件系统变得更为强大。随着其 API 表面的增加，其他前端框架如
    React 或 Svelte 也可以得到支持。现在，Vite 已经从单一用途的工具发展成为一个真正的瑞士军刀——这要归功于一个精心设计的插件机制和活跃的社区。
- en: 'To get started with Vite, we need to install the `vite` package using npm:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Vite，我们需要使用 npm 安装 `vite` 包：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this installation, you can use Vite programmatically, as well as directly
    from the command line.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次安装，你可以以编程方式使用 Vite，也可以直接从命令行使用。
- en: One thing to know about Vite is that it embraces having an `index.html` file
    as an entry point even more than Parcel. For Vite to work as intended, we need
    to move the `index.html` file from the `src` folder to the parent directory –
    that is, the project’s root folder.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Vite，有一件事需要知道的是，它比 Parcel 更加强调使用 `index.html` 文件作为入口点。为了使 Vite 正常工作，我们需要将
    `index.html` 文件从 `src` 文件夹移动到父目录——即项目的根目录。
- en: 'As we did previously, we should set the references properly:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，我们应该正确设置引用：
- en: index.html
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: index.html
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To run Vite from the command line, you can use `npx` together with the `vite`
    executable:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行运行 Vite，你可以使用 `npx` 与 `vite` 可执行文件一起：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This starts quickly as nothing has been bundled or transformed yet. Only when
    we hit the server will Vite start to transform things – and only the things that
    we are currently looking at. If you are interested in a more realistic picture,
    then the `preview` subcommand can be handy. It does a production build but exposes
    the outcome via the development server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切开始得很快，因为目前还没有进行任何打包或转换。只有当我们访问服务器时，Vite 才会开始转换事物——而且仅仅是当前我们正在查看的事物。如果你对更真实的情况感兴趣，那么
    `preview` 子命令可能很有用。它执行生产构建，但通过开发服务器暴露结果。
- en: 'Of course, like with Parcel, we can still produce files that can be placed
    on a server. Very similar to Parcel, we can do this with the `build` subcommand:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，就像 Parcel 一样，我们仍然可以生成可以放置在服务器上的文件。与 Parcel 非常相似，我们可以使用 `build` 子命令来完成这项工作：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For this example, Vite is the only bundler that just works – at least once all
    the prerequisites have been fulfilled. If you require a custom configuration,
    such as for adding some plugins, then you can follow Webpack’s approach and create
    a `vite.config.js` file in the project’s root folder.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，Vite 是唯一一个只需满足所有先决条件就能正常工作的打包器——至少一开始是这样的。如果你需要自定义配置，例如添加一些插件，那么你可以遵循
    Webpack 的方法，在项目的根目录中创建一个 `vite.config.js` 文件。
- en: Now, let’s recap what you’ve learned in this chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下你在本章中学到的内容。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what a bundler is, why you need it, what bundlers
    exist, and how you can configure and use them. You are now able to take your web
    projects from their raw source code to build production-ready assets.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了什么是打包器，为什么你需要它，有哪些打包器，以及如何配置和使用它们。你现在能够将你的网络项目从原始源代码构建成生产就绪的资产。
- en: Equipped with detailed knowledge about bundlers, you can create very reliable
    code bases that are tailored toward efficiency. Not only will unnecessary code
    be removed upon bundling, but also all referenced files will be processed and
    taken into consideration. Therefore, you’ll never have to worry about missing
    a file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你具备关于打包器的详细知识，你可以创建非常可靠的代码库，这些代码库针对效率进行了定制。不仅打包时会移除不必要的代码，而且所有引用的文件都将被处理并考虑在内。因此，你永远不必担心遗漏文件。
- en: The large variety of existing bundlers can be intimidating at first. While there
    are some obvious choices, such as the very popular Webpack bundler, other options
    may be even better due to less complexity or better performance, depending on
    the project you have at hand. If in doubt, you can refer to the *Comparing available
    bundlers* section of this chapter to ascertain which bundler might be the best
    fit for you.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的打包器种类繁多，一开始可能会让人感到畏惧。虽然有一些明显的选择，比如非常流行的 Webpack 打包器，但根据你手头的项目，其他选项可能由于更少的复杂性或更好的性能而更好。如果有疑问，你可以参考本章的
    *比较可用的打包器* 部分以确定哪个打包器可能最适合你。
- en: In the next chapter, we will take closer look at another category of crucial
    development tools. We’ll see how testing tools give us confidence that our code
    works as it should, both today and in the future.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨另一类至关重要的开发工具。我们将看到测试工具如何让我们对我们的代码在现在和未来都能按预期工作充满信心。
