- en: Chapter 2. Working with Resource Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 与资源文件一起工作
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Displaying a custom offline page
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示自定义离线页面
- en: Loading images offline
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线加载图片
- en: Loading CSS offline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线加载CSS
- en: Loading fonts offline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线加载字体
- en: Implementing multiple fetch handlers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现多个fetch处理器
- en: Fetching remote resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取远程资源
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'You might have encountered, from time to time, having broken images appear
    on certain websites. This could be because of a number of reasons: the image might
    not have existed, it might not have been named properly, or the file path in the
    code might have been incorrect. Whatever the reason it might be, it could impact
    your website, and could lead the user to think that your website is broken.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能时不时地遇到过某些网站上出现损坏的图片。这可能是因为多种原因：图片可能不存在，可能没有正确命名，或者代码中的文件路径可能不正确。无论原因如何，它都可能影响你的网站，并可能导致用户认为你的网站已损坏。
- en: Images are not the only resources that are essential to your website. **Cascading
    style sheets** (**CSS**), JavaScript files, and font files are also necessary
    to make your website appear functional. In this chapter, we are going to look
    at how to load these resources offline.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图片并不是你网站中唯一必要的资源。**层叠样式表**（**CSS**）、JavaScript文件和字体文件也是使你的网站看起来功能齐全所必需的。在本章中，我们将探讨如何离线加载这些资源。
- en: Before we start working on loading resources offline, let's find out how we
    can notify the user that the network is unavailable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理离线加载资源之前，让我们了解一下如何通知用户网络不可用。
- en: Displaying a custom offline page
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示自定义离线页面
- en: 'Let''s revisit the scenario from the first chapter where you are on a train,
    traveling home from work, and you are reading an important news article on the
    web using your mobile device. At the same moment that you click on a link to view
    more details, the train suddenly disappears into a tunnel. You''ve just lost connectivity,
    and are presented with the **Unable to connect to the Internet** message. Well,
    you will not doubt be less annoyed if you can still play the dinosaur game by
    hitting the spacebar on your desktop/laptop, or by tapping on your phone, but
    this can be an area where you can significantly enhance a client''s user experience
    by using a service worker. One of the great features of service workers is that
    they allow you to intercept network requests and decide how you want to respond:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下第一章中的场景，当时你正在火车上，从工作中回家，你正在使用你的移动设备阅读一篇重要的新闻文章。就在你点击链接查看更多详情的同时，火车突然消失在隧道中。你刚刚失去了连接，并显示**无法连接到互联网**的消息。好吧，如果你仍然可以通过在桌面/笔记本电脑上按空格键或在手机上轻触来玩恐龙游戏，你将不会那么烦恼。但是，这可以通过使用服务工作者在用户体验方面进行显著改进。服务工作者的一项伟大功能是它们允许你拦截网络请求并决定你想要如何响应：
- en: '![Displaying a custom offline page](img/B05381_02_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![显示自定义离线页面](img/B05381_02_01.jpg)'
- en: In this recipe, we are going to use a service worker to check whether a user
    has connectivity, and respond with a really simple offline page if they aren't
    connected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用服务工作者来检查用户是否有连接性，如果他们没有连接，则显示一个非常简单的离线页面。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用服务工作者，你需要在浏览器设置中开启服务工作者实验功能。如果你还没有这样做，请参考[第1章](ch01.html "第1章. 学习服务工作者基础")的*设置服务工作者*食谱，*学习服务工作者基础*。服务工作者仅在HTTPS上运行。要了解如何设置开发环境以支持此功能，请参考以下[第1章](ch01.html
    "第1章. 学习服务工作者基础")的食谱：*设置GitHub页面以支持SSL*，*在Windows上设置SSL*，和*在Mac上设置SSL*。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these instructions to set up your file structure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明设置你的文件结构：
- en: 'First, we must create an `index.html` file as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个`index.html`文件，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a JavaScript file called `service-worker.js` in the same folder as the
    `index.html` file, with the following code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`service-worker.js`的JavaScript文件，并包含以下代码：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a second HTML file called `offline.html` file as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个HTML文件，命名为`offline.html`，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open up a browser and go to `index.html`. You will see the **Registration status:
    successful** message:![How to do it...](img/B05381_02_02.jpg)'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个浏览器并转到`index.html`。您将看到**注册状态：成功**的消息：![如何操作...](img/B05381_02_02.jpg)
- en: Now open up DevTools (*Cmd* + *Alt* + *I* or *F12*), go to the **Network** tab,
    click on the dropdown displaying **No throttling**, and select **Offline**:![How
    to do it...](img/B05381_02_03.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开开发者工具（*Cmd* + *Alt* + *I* 或 *F12*），转到**网络**标签，点击显示**无限制**的下拉菜单，并选择**离线**：![如何操作...](img/B05381_02_03.jpg)
- en: Now refresh your browser, and you will see the offline message and the following
    image:![How to do it...](img/B05381_02_04.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在刷新您的浏览器，您将看到离线消息和以下图像：![如何操作...](img/B05381_02_04.jpg)
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When the registration is successful, we are instructing the service worker
    to intercept a request and provide resources from the cached content using the
    fetch event, as illustrated in the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册成功时，我们指示服务工作者使用fetch事件拦截请求，并从缓存内容中提供资源，如下面的图示所示：
- en: '![How it works...](img/B05381_02_05.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B05381_02_05.jpg)'
- en: 'Inside the `index.html` file, when the registration is successful, we inspect
    the state of the registration and print it to the browser. Otherwise, we are printing
    the error message returned by the service worker:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件内部，当注册成功时，我们检查注册状态并将其打印到浏览器中。否则，我们打印由服务工作者返回的错误信息：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The service worker script file will intercept network requests, check for connectivity,
    and provide the content to the user.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者脚本文件将拦截网络请求，检查连接性，并向用户提供内容。
- en: 'We start off by adding our offline page to the cache when we install the service
    worker. In the first few lines, we are specifying the cache version and the URL
    for the offline page. If we had different versions of our cache, you would simply
    update this version number, so a new version of the file will take effect. We
    call this **cache busting**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在安装服务工作者时将离线页面添加到缓存中。在前几行中，我们指定了缓存版本和离线页面的URL。如果我们有不同的缓存版本，您只需更新这个版本号，这样文件的新版本就会生效。我们称之为**缓存破坏**：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We add an event listener to the install event and inside the callback, we make
    a request for this offline page and its resources; when we have a successful response,
    it gets added to the cache:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向install事件添加事件监听器，并在回调函数中请求这个离线页面及其资源；当我们收到成功的响应时，它会被添加到缓存中：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that the offline page is stored in the cache, we can retrieve it whenever
    we need to. In the same service worker, we need to add the logic to return the
    offline page if we have no connectivity:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在离线页面已存储在缓存中，我们可以在需要时检索它。在同一个服务工作者中，我们需要添加逻辑以在没有连接性时返回离线页面：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding listing, we are listening out for the fetch event, and if we
    detect that the user is trying to navigate to another page, and there is an error
    while doing so, we simply return the offline page from the cache. And there you
    go, we have our offline page working.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们正在监听fetch事件，如果我们检测到用户正在尝试导航到另一个页面，并且在这个过程中出现错误，我们只需从缓存中返回离线页面。就这样，我们的离线页面开始工作。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `waitUntil` event extends the lifetime of the install event, until all the
    caches are populated. In other words, it delays treating the installing worker
    as installed, until all the resources we specify are cached and the passed promise
    resolves successfully.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitUntil`事件延长了install事件的寿命，直到所有缓存都已填充。换句话说，它延迟将安装中的工作者视为已安装，直到我们指定的所有资源都已缓存并且传递的promise成功解析。'
- en: 'We saw an HTML and an image file get cached, and then being retrieved when
    our website is offline. We can cache other resources as well, including CSS and
    JavaScript files:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了一个HTML文件和一个图像文件被缓存，然后在我们网站离线时被检索。我们还可以缓存其他资源，包括CSS和JavaScript文件：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Registering a service worker in detail* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。学习服务工作者基础")的*详细注册服务工作者*配方，*学习服务工作者基础*'
- en: The *Creating mock responses* recipe of [Chapter 1](ch01.html "Chapter 1. Learning
    Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 学习Service Worker基础知识")的*创建模拟响应*配方，*学习Service Worker基础知识*'
- en: Loading images offline
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线加载图片
- en: Images are a resource that almost all websites in the world today use. Just
    like your HTML, CSS, and JavaScript, you can cache images to be viewed offline
    with service workers. In this chapter, we are going to look at how to load images
    offline, as well as handling responsive images.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图片是当今世界上几乎所有网站都使用的资源。就像你的HTML、CSS和JavaScript一样，你可以使用服务工作者缓存图片以便离线查看。在本章中，我们将探讨如何离线加载图片以及处理响应式图片。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用服务工作者，你需要在浏览器设置中开启服务工作者实验功能。如果你还没有这样做，请参考[第1章](ch01.html "第1章. 学习Service
    Worker基础知识")的*设置服务工作者*配方，*学习Service Worker基础知识*。服务工作者仅在HTTPS上运行。要了解如何设置支持此功能的发展环境，请参考以下[第1章](ch01.html
    "第1章. 学习Service Worker基础知识")的配方：*设置GitHub页面以支持SSL*、*为Windows设置SSL*和*为Mac设置SSL*。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these instructions to set up your file structure:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明设置你的文件结构：
- en: 'First, we must create an `index.html` file as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个`index.html`文件，如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we have to create a JavaScript file `service-worker.js`, in the same folder
    as the `index.html` file, with the following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须创建一个名为`service-worker.js`的JavaScript文件，并将其保存在与`index.html`文件相同的文件夹中，代码如下：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a JavaScript file called `index.js`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`index.js`的JavaScript文件，代码如下：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Download an image file and save it in the same folder as the `index.html` file.
    In this example, I am calling it `packt-logo.png`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载一个图片文件并将其保存在与`index.html`文件相同的文件夹中。在这个例子中，我将其命名为`packt-logo.png`。
- en: Open up a browser and go to the `index.html` file:![How to do it...](img/B05381_02_06.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并转到`index.html`文件：![如何操作...](img/B05381_02_06.jpg)
- en: Open up Chrome Developer Tools (*Cmd* + *Alt* + *I* or *F12*), select the **Network**
    tab, and click **Offline**:![How to do it...](img/B05381_02_07.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Chrome开发者工具(*Cmd* + *Alt* + *I* 或 *F12*)，选择**网络**选项卡，并点击**离线**：![如何操作...](img/B05381_02_07.jpg)
- en: Refresh the page by pressing *Cmd* + *R* or *F5*, and you will see the image
    looks the same as it did online.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Cmd* + *R* 或 *F5*刷新页面，你会看到图片看起来和在线时一样。
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the `index.html` file, we are linking the image we have downloaded inside
    an `img` tag:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，我们通过`img`标签链接我们下载的图片：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the service worker script file, we add our offline page to the cache when
    we install the service worker. In the first few lines, we specify the cache version
    and the URL for the offline page:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务工作者脚本文件中，我们在安装服务工作者时将离线页面添加到缓存中。在前几行中，我们指定缓存版本和离线页面的URL：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The event listener for the install event calls the `waitUntil` function, where
    we cache `index.html` and the font file, in our case, `webfont-serif.woff`. The
    `cache.addAll` function takes an array of files to be cached:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 安装事件的监听器调用`waitUntil`函数，在那里我们缓存`index.html`和字体文件，在我们的例子中，是`webfont-serif.woff`。`cache.addAll`函数接受一个要缓存的文件数组：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we reload the page, after it is set to go offline, the fetch event gets
    fired, retrieves those two files from the cache, and sends them along with the
    response:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新加载页面，在设置为离线后，fetch事件被触发，从缓存中检索这两个文件，并将它们随响应发送：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, the page will be displayed as it was online.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，页面将以在线时的样子显示。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If we were to develop our website following a mobile-first strategy, having
    responsive images would greatly benefit it. Let's look at how we can achieve this.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照移动优先策略开发我们的网站，拥有响应式图片将极大地受益。让我们看看我们如何实现这一点。
- en: Handling responsive images
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理响应式图片
- en: There are a number of ways to enable the responsive behavior for images. One
    of the older methods (not recommended) is by simply scripting, but this leads
    to a couple of problems. First, if a script determines which image to download,
    but the script itself is loaded after the images specified in the HTML have been
    downloaded, you may potentially end up with two downloaded images. Second, if
    you don't specify any image in HTML, and want to load only the image defined by
    the script, you'll end up with no image at all for browsers that have scripting
    disabled.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以启用图片的响应式行为。其中一种较老的方法（不推荐）是通过简单的脚本实现，但这会导致一些问题。首先，如果脚本确定要下载的图片，但脚本本身在指定的
    HTML 图片下载之后才加载，你可能会最终下载两张图片。其次，如果你在 HTML 中没有指定任何图片，只想通过脚本加载定义的图片，那么对于禁用脚本的浏览器，你将没有任何图片。
- en: 'Hence, we need a better way to deal with responsive images. And thankfully,
    there is one! The recommended way is to use:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一种更好的方式来处理响应式图片。幸运的是，确实存在一种！推荐的方式是使用：
- en: '`srcset`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcset`'
- en: '`sizes`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizes`'
- en: '`picture`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`picture`'
- en: The srcset attribute
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`srcset` 属性'
- en: Before we explore how `srcset` is actually used, let's understand a few terms.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨 `srcset` 实际使用方法之前，让我们先了解一些术语。
- en: Device-pixel ratio
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设备像素比
- en: 'The device-pixel ratio is the number of device pixels per CSS pixel. Two key
    conditions contribute to the device-pixel ratio:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设备像素比是每 CSS 像素中的设备像素数量。有两个关键条件会影响设备像素比：
- en: '**Pixel density of the device (number of physical pixels per inch)**: A high
    resolution device will have a higher pixel density and hence, for the same zoom
    level, it will have a high device-pixel ratio compared to a lower resolution device.
    For example: a high-end Lumia 950 phone will have a higher resolution than a budget
    Lumia 630 phone, and therefore it will have a higher device-pixel ratio for the
    same zoom level.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备的像素密度（每英寸物理像素的数量）**：高分辨率设备将具有更高的像素密度，因此，对于相同的缩放级别，与低分辨率设备相比，它将具有更高的设备像素比。例如：高端的
    Lumia 950 手机比预算型的 Lumia 630 手机具有更高的分辨率，因此，在相同的缩放级别下，它将具有更高的设备像素比。'
- en: '**Zoom level of the browser**: For the same device, a higher zoom level means
    a higher number of device pixels per CSS pixel, and hence a higher device-pixel
    ratio. For example, consider this figure:![Device-pixel ratio](img/B05381_02_08.jpg)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器的缩放级别**：对于同一设备，更高的缩放级别意味着每 CSS 像素拥有更多的设备像素，因此设备像素比更高。例如，考虑这个图：![设备像素比](img/B05381_02_08.jpg)'
- en: When you zoom in on your browser (*Ctrl* + *+*), the number of CSS pixels for
    your `div` remains the same, but the number of device pixels it occupies increases.
    So, you have a higher number of device pixels per CSS pixel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中放大（*Ctrl* + *+*）时，你的 `div` 的 CSS 像素数量保持不变，但占用的设备像素数量增加。因此，你每 CSS 像素拥有更多的设备像素。
- en: 'When you want to display separate images (or usually, a separate asset of the
    same image) based on the device-pixel ratio, you''d go with a basic `srcset` implementation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望根据设备像素比显示不同的图片（或通常，同一图片的不同资产）时，你可以选择基本的 `srcset` 实现：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `x` descriptor in the `srcset` attribute is used to define the device-pixel
    ratio:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`srcset` 属性中的 `x` 描述符用于定义设备像素比：'
- en: For a device-pixel ratio of 1, the `image-src.png` image will be used.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于设备像素比为 1 的情况，将使用 `image-src.png` 图片。
- en: For a device-pixel ratio of 2, the `image-2x.png` image will be used.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于设备像素比为 2 的情况，将使用 `image-2x.png` 图片。
- en: The `src` attribute is used as a fallback for browsers that do not yet support
    `srcset` implementation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 属性用于作为不支持 `srcset` 实现的浏览器的后备选项。'
- en: This works well. Using the `x` descriptor, you'll always get the same image
    on devices with a similar device-pixel ratio—even if this means that you get the
    same image on a 13.5-inch laptop, and a 5-inch mobile phone, which both have the
    same device-pixel ratio.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这效果很好。使用 `x` 描述符，你将在具有相似设备像素比的设备上始终获得相同的图片——即使这意味着你会在 13.5 英寸的笔记本电脑和 5 英寸的手机上获得相同的图片，这两者的设备像素比相同。
- en: The sizes attribute
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`sizes` 属性'
- en: The actual implementation where you'd want a different-sized image (different
    height and width) on different screen sizes is accomplished by using the `sizes`
    attribute along with the `w` descriptor of the `srcset` attribute.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望在不同的屏幕尺寸上使用不同大小的图片（不同的高度和宽度）时，可以通过使用 `sizes` 属性以及 `srcset` 属性的 `w` 描述符来实现。
- en: 'Say you want the image to be viewed in half of the viewport width. You''ll
    type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望图片的显示宽度为视口宽度的一半。你将输入：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The picture element
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`picture` 元素'
- en: 'As we saw in the previous section, the `picture` element is used when you want
    to show a different image depending on the rendered size of the image. The `picture`
    element is a container, which contains other elements that control the image to
    be downloaded:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，当您想要根据图片的渲染大小显示不同的图片时，会使用`picture`元素。`picture`元素是一个容器，它包含其他控制要下载的图片的元素：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At runtime, the `srcset` attribute or the `<picture>` element selects the most
    appropriate image asset and performs a network request.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，`srcset`属性或`<picture>`元素会选择最合适的图片资源，并执行网络请求。
- en: 'If you want to cache an image during the install step for the service worker,
    you have a few options:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在安装服务工作者步骤中缓存图片，您有几个选择：
- en: Installing a single low-resolution version of the image
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装单个低分辨率版本的图片
- en: Installing a single high-resolution version of the image
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装单个高分辨率版本的图片
- en: It is ideal to limit the amount to two or three images in order to preserve
    memory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留内存，最好将图片数量限制在两到三张。
- en: To improve the load time, you may decide to go for the low resolution version
    at the time of installation, and you would try to retrieve higher resolution images
    from the network when the page is loaded; however, in the case that the high-resolution
    images fail, you would think you can easily fall back to the low resolution version,
    but there is one issue.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高加载时间，您可能决定在安装时选择低分辨率版本，并在页面加载时尝试从网络检索更高分辨率的图片；然而，在高清图片失败的情况下，您可能会认为可以轻松地回退到低分辨率版本，但有一个问题。
- en: 'Let''s assume we have two images:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个图片：
- en: '| Display density | Width | Height |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 显示密度 | 宽度 | 高度 |'
- en: '| --- | --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `1x` | `400` | `400` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `1x` | `400` | `400` |'
- en: '| `2x` | `800` | `800` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `2x` | `800` | `800` |'
- en: 'Here is the markup for an `srcset` image:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`srcset`图片的标记：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On a screen with a `2x` display, the browser could opt to download `image-2x.png`,
    if we are offline, then we could catch this request and return the `image-src.png`
    image instead if the image is cached, the browser may expect an image that considers
    the extra pixels on a `2x` screen, therefore the image will appear as 200 x 200
    pixels instead of 400 x 400 pixels. The only fix is to set a fixed width and height
    on the image:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`2x`显示的屏幕上，浏览器可以选择下载`image-2x.png`，如果我们离线，那么我们可以捕获这个请求，如果图片已缓存，则返回`image-src.png`图片代替。如果图片已缓存，浏览器可能期望一个考虑`2x`屏幕额外像素的图片，因此图片将显示为200
    x 200像素，而不是400 x 400像素。唯一的解决办法是在图片上设置固定的宽度和高度：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can take the same approach to `srcset`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取相同的方法来处理`srcset`。
- en: 'No width or height set:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 未设置宽度和高度：
- en: '![The picture element](img/B05381_02_09.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片元素](img/B05381_02_09.jpg)'
- en: 'Height and width set:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 设置高度和宽度：
- en: '![The picture element](img/B05381_02_10.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片元素](img/B05381_02_10.jpg)'
- en: 'If you want to unregister the service worker, you can head to the Developer
    Toolbar in Chrome, and click the **Unregister** button in the **Service Workers**
    section, as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想注销服务工作者，您可以前往Chrome的开发者工具栏，并在**服务工作者**部分点击**注销**按钮，如下面的截图所示：
- en: '![The picture element](img/B05381_02_11.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片元素](img/B05381_02_11.jpg)'
- en: 'If you want to find out the resources stored in the caches, you can do so by
    opening Developer Tools and looking at the **Resources** tab:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想找出存储在缓存中的资源，您可以通过打开开发者工具并查看**资源**选项卡来做到：
- en: '![The picture element](img/B05381_02_12.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片元素](img/B05381_02_12.jpg)'
- en: 'If you are using Firefox Nightly, you can view the caches by opening up Developer
    Tools and looking at the Storage Inspector:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Firefox Nightly，您可以通过打开开发者工具并查看存储检查器来查看缓存：
- en: '![The picture element](img/B05381_02_13.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片元素](img/B05381_02_13.jpg)'
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Registering a service worker in detail* recipe in [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 学习服务工作者基础")的*详细注册服务工作者*食谱，*学习服务工作者基础*
- en: The *Creating mock responses* recipe in [Chapter 1](ch01.html "Chapter 1. Learning
    Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 学习服务工作者基础")的*创建模拟响应*食谱中，*学习服务工作者基础*
- en: Loading CSS offline
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线加载CSS
- en: CSS is essential in structuring your website and making it look functional.
    Because of this, if your website goes offline and the CSS is not available in
    the cache, your website will look broken. In order to achieve this, we cache CSS
    with service workers, and deliver those CSS files as external resources. In this
    recipe, we are going to look at how to load CSS offline.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: CSS对于构建你的网站和使其看起来功能齐全至关重要。正因为如此，如果你的网站离线且CSS不在缓存中，你的网站将看起来损坏。为了实现这一点，我们使用服务工作者缓存CSS，并将这些CSS文件作为外部资源提供。在本教程中，我们将探讨如何离线加载CSS。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用服务工作者，你需要在浏览器设置中开启服务工作者实验功能。如果你还没有这样做，请参考[第1章](ch01.html "第1章. 学习服务工作者基础")的*设置服务工作者*教程，*学习服务工作者基础*。服务工作者仅在HTTPS上运行。要了解如何设置支持此功能的开发生态，请参考[第1章](ch01.html
    "第1章. 学习服务工作者基础")的以下教程：*设置GitHub页面以支持SSL*，*在Windows上设置SSL*，和*在Mac上设置SSL*。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these instructions to set up your file structure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明设置你的文件结构：
- en: 'First, we must create an `index.html` file as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个`index.html`文件，如下所示：
- en: '[PRE20]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a JavaScript file called `service-worker.js`, in the same folder as
    the `index.html` file, with the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`service-worker.js`的JavaScript文件，内容如下：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a CSS file called `style-1.css`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`style-1.css`的CSS文件，内容如下：
- en: '[PRE22]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create another CSS file called `style-2.css`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建另一个名为`style-2.css`的CSS文件，内容如下：
- en: '[PRE23]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open up a browser and go to the `index.html` file. You will see that the background
    color is green:![How to do it...](img/B05381_02_14.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并访问`index.html`文件。你会看到背景颜色是绿色：![如何操作...](img/B05381_02_14.jpg)
- en: Now open up the Developer Tools (*Cmd* + *Shift* + *I* or *F12*) and change
    the **Network** tab to **Offline** as shown in the following screenshot:![How
    to do it...](img/B05381_02_15.jpg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开开发者工具（*Cmd* + *Shift* + *I* 或 *F12*）并将**网络**标签页切换到**离线**，如图所示：![如何操作...](img/B05381_02_15.jpg)
- en: The color of the background is now red.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 背景颜色现在是红色。
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the header section of the `index.html` file, we are linking two CSS files:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件的头部部分，我们链接了两个CSS文件：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In our styles sheets, we are referencing the same CSS property of body.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的样式表中，我们引用了body的相同CSS属性。
- en: 'Because of the order we are calling the CSS files, the last selector takes
    effect on the online page, in our case, this is the `body` selector of `style-1.css`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们调用CSS文件的顺序，最后一个选择器在在线页面上生效，在我们的例子中，这是`style-1.css`的`body`选择器：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `service-worker.js` file, we add `index.html` and the `style-2.css`
    file to the cache when we install the service worker. In the first few lines,
    we specify the cache version and the URL for the offline page:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service-worker.js`文件中，我们在安装服务工作者时将`index.html`和`style-2.css`文件添加到缓存中。在前几行中，我们指定缓存版本和离线页面的URL：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The event listener for the install event calls the `waitUntil` function, where
    we cache `index.html`, and the CSS file. The `cache.addAll` function takes an
    array of files to be cached:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 安装事件的监听器调用`waitUntil`函数，其中我们缓存`index.html`和CSS文件。`cache.addAll`函数接受一个要缓存的文件数组：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we reload the page, after it is set to go offline, the fetch event gets
    fired, retrieves those two files from the cache, and sends them along with the
    response:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新加载页面，在设置为离线后，fetch事件被触发，从缓存中检索这两个文件，并将它们随响应一起发送：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, when we refresh the page, the background will change to red, as the CSS
    file we saved in the cache will be applied to the page this time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们刷新页面时，背景将变为红色，因为我们保存在缓存中的CSS文件这次将被应用到页面上。
- en: Loading fonts offline
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线加载字体
- en: If your website uses external fonts, such as open source web fonts, you could
    cache them to be viewed offline with service workers. In this chapter, we are
    going to look at how to load fonts offline.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的网站使用外部字体，例如开源网络字体，您可以使用服务工作者将其缓存以便离线查看。在本章中，我们将探讨如何离线加载字体。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用服务工作者，您需要在浏览器设置中开启服务工作者实验功能。如果您还没有这样做，请参考[第1章](ch01.html "第1章. 学习服务工作者基础")中的*设置服务工作者*配方，*学习服务工作者基础*。服务工作者仅在HTTPS上运行。要了解如何设置支持此功能的发展环境，请参考以下[第1章](ch01.html
    "第1章. 学习服务工作者基础")中的配方：*设置GitHub页面以支持SSL*，*在Windows上设置SSL*，和*在Mac上设置SSL*。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these instructions to set up your file structure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明设置您的文件结构：
- en: 'First, we must create an `index.html` file as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个如下所示的 `index.html` 文件：
- en: '[PRE29]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a JavaScript file called `service-worker.js`, in the same folder as
    the `index.html` file, with the following code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与 `index.html` 文件相同的文件夹中创建一个名为 `service-worker.js` 的JavaScript文件，并包含以下代码：
- en: '[PRE30]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Download a web font from [https://www.google.com/fonts](https://www.google.com/fonts)
    and save it in the same folder as the `index.html` file. If you are not quite
    sure how to do this, please look at the following *There's more...* section.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://www.google.com/fonts](https://www.google.com/fonts) 下载网络字体并将其保存在与
    `index.html` 文件相同的文件夹中。如果您不确定如何操作，请参阅以下 *更多内容...* 部分。
- en: Open up the browser and go to the `index.html` file:![How to do it...](img/B05381_02_16.jpg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并转到 `index.html` 文件：![如何操作...](img/B05381_02_16.jpg)
- en: Open up Chrome Developer Tools (*Cmd* + *Alt* + *I* or Fb12), select the **Network**
    tab, and click **Offline**:![How to do it...](img/B05381_02_17.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Chrome开发者工具(*Cmd* + *Alt* + *I* 或 Fb12)，选择**网络**选项卡，并点击**离线**：![如何操作...](img/B05381_02_17.jpg)
- en: Refresh the page by pressing *Cmd* + *R* or *F5*, and you will see the font
    looks the same as it did online.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 *Cmd* + *R* 或 *F5* 刷新页面，您将看到字体看起来与在线时相同。
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the header section of the `index.html` file, we link the font file we have
    downloaded inside a `style` tag:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.html` 文件的头部部分，我们在 `style` 标签内链接我们下载的字体文件：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `@font-face` declaration will specify a font named `myWebFont` and specify
    the URL where it can be found. In our case, it is in the same directory as the
    `index.html` file. Then we reference the font inside the paragraph declaration
    as the `font-family` attribute:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`@font-face` 声明将指定一个名为 `myWebFont` 的字体，并指定可以找到该字体的URL。在我们的例子中，它位于 `index.html`
    文件相同的目录中。然后我们在段落声明中引用该字体作为 `font-family` 属性：'
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the service worker script file, we add our offline page to the cache when
    we install the service worker. In the first few lines, we specify the cache version
    and the URL for the offline page:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务工作者脚本文件中，我们在安装服务工作者时将我们的离线页面添加到缓存中。在前几行中，我们指定缓存版本和离线页面的URL：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The event listener for the install event calls the `waitUntil` function, where
    we cache the `index.html` file and the font file; in our case `webfont-serif.woff`.
    The `cache.addAll` function takes an array of files to be cached:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 安装事件的监听器调用 `waitUntil` 函数，在那里我们缓存 `index.html` 文件和字体文件；在我们的例子中是 `webfont-serif.woff`。`cache.addAll`
    函数接受要缓存的文件数组：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we reload the page, after it is set to go offline, the fetch event gets
    fired, retrieves those two files from the cache, and sends them along with the
    response:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新加载页面，在设置为离线后，fetch事件被触发，从缓存中检索这两个文件，并将它们随响应发送：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, the page will be displayed as it was online.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，页面将以在线时的样子显示。
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In order to find a free font family from Google and download it, please perform
    the following instructions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Google找到免费字体并下载它，请执行以下步骤：
- en: Please navigate to [https://www.google.com/fonts](https://www.google.com/fonts),
    and search, or browse, the desired font, then add the one you like to your collection
    by clicking on the blue **Add to Collection** button on the right side of the
    font:![There's more...](img/B05381_02_18.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请导航到[https://www.google.com/fonts](https://www.google.com/fonts)，搜索或浏览所需的字体，然后通过点击字体右侧的蓝色**添加到收藏**按钮将你喜欢的字体添加到你的收藏中：![更多内容...](img/B05381_02_18.jpg)
- en: Your collection will show at the bottom of your screen. Once it has, select
    the **Use this style** checkbox, towards the top-left side of the screen:![There's
    more...](img/B05381_02_19.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的收藏将显示在屏幕底部。一旦有了，选择屏幕右上角的**使用此样式**复选框：![更多内容...](img/B05381_02_19.jpg)
- en: Now, when you click the arrow on the top right-hand side of the page, it will
    prompt you with a dialog. You can choose the first option, which downloads the
    file as a ZIP file:![There's more...](img/B05381_02_20.jpg)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你点击页面右上角的箭头时，它会弹出一个对话框。你可以选择第一个选项，它将文件作为ZIP文件下载：![更多内容...](img/B05381_02_20.jpg)
- en: Once you unzip the file, you will find the font you need inside the folder.
    If you want to unregister a service worker, you can go to `chrome://service-worker-internals`
    and click the **Unregister** button:![There's more...](img/B05381_02_21.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦解压文件，你将在文件夹内找到所需的字体。如果你想注销一个service worker，你可以转到`chrome://service-worker-internals`并点击**注销**按钮：![如何操作...](img/B05381_02_21.jpg)
- en: In Firefox Nightly, you can go to `about:serviceworkers` and click on the **Unregister**
    button:![There's more...](img/B05381_02_22.jpg)
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Firefox Nightly中，你可以转到`about:serviceworkers`并点击**注销**按钮：![更多内容...](img/B05381_02_22.jpg)
- en: See also
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Registering a service worker in detail* recipe in [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 学习Service Worker基础知识")的*详细注册Service Worker*配方中，*学习Service
    Worker基础知识*
- en: The *Creating mock responses* recipe in [Chapter 1](ch01.html "Chapter 1. Learning
    Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 学习Service Worker基础知识")的*创建模拟响应*配方中，*学习Service Worker基础知识*
- en: Implementing multiple fetch handlers
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多个fetch处理器
- en: Service workers can handle multiple fetch handlers, each of which intercepts
    a different type of request. This recipe explains, in detail, how different types
    of request can be handled by implementing separate fetch handlers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Service workers可以处理多个fetch处理器，每个处理器拦截不同类型的请求。这个配方详细解释了如何通过实现单独的fetch处理器来处理不同类型的请求。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用service workers，你需要在浏览器设置中开启service worker实验功能。如果你还没有这样做，请参考[第1章](ch01.html
    "第1章. 学习Service Worker基础知识")的*设置Service Workers*配方，*学习Service Worker基础知识*。Service
    workers仅在HTTPS上运行。要了解如何设置一个支持此功能的发展环境，请参考[第1章](ch01.html "第1章. 学习Service Worker基础知识")的以下配方：*设置GitHub
    pages for SSL*，*设置Windows的SSL*，和*设置Mac的SSL*。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these instructions to set up your file structure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明设置你的文件结构：
- en: 'First, we need to create an `index.html` file as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个`index.html`文件，如下所示：
- en: '[PRE36]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a JavaScript file called `service-worker.js` in the same folder as the
    `index.html` file with the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`service-worker.js`的JavaScript文件，并包含以下代码：
- en: '[PRE37]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Open up a browser and go to the `index.html` file. You will see the **Registration
    status: successful** message:![How to do it...](img/B05381_02_23.jpg)'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并转到`index.html`文件。你会看到**注册状态：成功**的消息：![如何操作...](img/B05381_02_23.jpg)
- en: Change the URL by adding `/cook/` in front as follows:![How to do it...](img/B05381_02_24.jpg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在前面添加`/cook/`来更改URL，如下所示：![如何操作...](img/B05381_02_24.jpg)
- en: Change the URL again by adding `/book` in front as follows:![How to do it...](img/B05381_02_25.jpg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在前面添加`/book`来更改URL，如下所示：![如何操作...](img/B05381_02_25.jpg)
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When the registration is successful, we inspect the state of the registration,
    and print it to the browser. Now it''s time to trigger the responses by the service
    worker. In the `service-worker.js` file, there are two registered fetch handlers,
    `cookFetchHandler` and `cookBookFetchHandler`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册成功时，我们检查注册状态，并将其打印到浏览器中。现在，是时候通过服务工作者触发响应了。在 `service-worker.js` 文件中，有两个注册的获取处理程序，`cookFetchHandler`
    和 `cookBookFetchHandler`：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first handler, `cookFetchHandler`, intercepts requests ending with `/cook`
    anywhere in the URL, and returns a new response with the wording, `Fetch handler
    for /cook`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个处理程序，`cookFetchHandler`，拦截 URL 中任何位置的以 `/cook` 结尾的请求，并返回一个包含文字 `Fetch handler
    for /cook` 的新响应。
- en: The second handler, `cookBookFetchHandler`, intercepts requests ending with
    `/cook/book` anywhere in the URL, and returns a new response with the wording,
    `Fetch handler for /cook/book`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个处理程序，`cookBookFetchHandler`，拦截 URL 中任何位置的以 `/cook/book` 结尾的请求，并返回一个包含文字 `Fetch
    handler for /cook/book` 的新响应。
- en: Since `cookBookFetchHandler` is registered first, when it intercepts `/cook/book`
    requests, it will always first have the chance to return a response via `event.respondWith()`.The
    second handler gets its chance to handle `event.respondWith()` only if the first
    handler does not call it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `cookBookFetchHandler` 是首先注册的，当它拦截 `/cook/book` 请求时，它将首先有机会通过 `event.respondWith()`
    返回响应。只有当第一个处理程序没有调用它时，第二个处理程序才会得到处理 `event.respondWith()` 的机会。
- en: 'When the fetch event occurs, they are invoked one at a time, in the order they
    are registered. Any time a handler calls `event.respondWith()`, none of the other
    registered handlers will be run:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生获取事件时，它们将按注册顺序逐个调用。每当处理程序调用 `event.respondWith()` 时，其他注册的处理程序将不会运行：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If none of the registered fetch handlers call `event.respondWith()`, the browser
    takes control and makes a normal HTTP request. This is the normal procedure, when
    no service workers are involved.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册的任何获取处理程序都没有调用 `event.respondWith()`，浏览器将接管并执行一个正常的 HTTP 请求。这是没有服务工作者参与时的正常流程。
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Within each fetch handler, we have to make sure that the logic that determines
    whether or not to call `event.respondWith()`, is executed synchronously. Simple
    `if()` statements that check `event.request.url` are fine. Anything asynchronous,
    such as performing `caches.match()` and then deciding whether or not to call `event.respondWith()`
    based on the response, will trigger a race condition, and you're likely to see
    an `event already responded to` error in the console.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个获取处理程序内部，我们必须确保确定是否调用 `event.respondWith()` 的逻辑是同步执行的。简单的 `if()` 语句检查 `event.request.url`
    是可以的。任何异步操作，例如执行 `caches.match()` 然后根据响应决定是否调用 `event.respondWith()`，都会触发竞争条件，你很可能会在控制台看到
    `event already responded to` 错误。
- en: 'If you want to unregister the service worker, you can head to the Developer
    Toolbar in Chrome and click the **Unregister** button in the **Service Workers**
    section, as shown in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想注销服务工作者，你可以转到 Chrome 的开发者工具栏，并在 **服务工作者** 部分点击 **注销** 按钮，如图所示：
- en: '![There''s more...](img/B05381_02_26.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/B05381_02_26.jpg)'
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Registering a service worker in detail* recipe in [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 1 章 *学习服务工作者基础* 的 *详细注册服务工作者* 菜谱中，*学习服务工作者基础*
- en: The *Creating mock responses* recipe in [Chapter 1](ch01.html "Chapter 1. Learning
    Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 1 章 *学习服务工作者基础* 的 *创建模拟响应* 菜谱中，*学习服务工作者基础*
- en: Fetching remote resources
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取远程资源
- en: Fetching remote resources can be done in a few different ways. In this recipe,
    we are going to look at two standard ways of fetching remote resources, as well
    as finding out how to use a service worker to act like a proxy middleware.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 获取远程资源可以通过几种不同的方式完成。在这个菜谱中，我们将探讨两种获取远程资源的标准方式，以及了解如何使用服务工作者充当代理中间件。
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the *Setting up service workers* recipe of [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the *Setting up GitHub pages for
    SSL* recipe of [Chapter 1](ch01.html "Chapter 1. Learning Service Worker Basics"),
    *Learning Service Worker Basics*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用服务工作者，您需要在浏览器设置中开启服务工作者实验功能。如果您还没有这样做，请参阅第 1 章 *设置服务工作者* 的配方，*学习服务工作者基础知识*。服务工作者仅在
    HTTPS 上运行。要了解如何设置支持此功能的发展环境，请参阅第 1 章 *为 SSL 设置 GitHub 页面* 的配方，*学习服务工作者基础知识*。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these instructions to set up your file structure:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明设置你的文件结构：
- en: 'First, we need to create an `index.html` file as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个 `index.html` 文件，如下所示：
- en: '[PRE40]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a JavaScript file called `index.js`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与 `index.html` 文件相同的文件夹中创建一个名为 `index.js` 的 JavaScript 文件，其中包含以下代码：
- en: '[PRE41]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a JavaScript file called `service-worker.js`, in the same folder as
    the `index.html` file, with the following code:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与 `index.html` 文件相同的文件夹中创建一个名为 `service-worker.js` 的 JavaScript 文件，其中包含以下代码：
- en: '[PRE42]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Open up a browser and go to the `index.html` file:![How to do it...](img/B05381_02_27.jpg)
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并转到 `index.html` 文件：![如何操作...](img/B05381_02_27.jpg)
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'At the beginning of the `index.js` file, we are testing three different protocols
    for loading resources:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.js` 文件的开始处，我们正在测试三种不同的协议来加载资源：
- en: '`https`: HTTP with **Secure Socket Layer** (**SSL**) protocol'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https`：带有 **Secure Socket Layer**（**SSL**）协议的 HTTP'
- en: '`https-acao`: SSL protocol with the **Access-Control-Origin=*** header'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https-acao`：带有 **Access-Control-Origin=*** 标头的 SSL 协议'
- en: '`http`: HTTP without SSL'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http`：没有 SSL 的 HTTP'
- en: 'We will use three different URLs, which will be loaded multiple times:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用三个不同的 URL，这些 URL 将被多次加载：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We also use two different methods for fetching resources, with or without `cors`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用两种不同的方法来获取资源，带有或没有 `cors`：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we check to see whether the service worker is registered:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查服务工作者是否已注册：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If that is not the case, then we register it and reload the page to make sure
    the client is under the service worker''s control:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果情况不是这样，那么我们将注册它并重新加载页面以确保客户端处于服务工作者的控制之下：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `for` loops go through the provided `protocols` array, make requests for
    each protocol, build a DOM image element with each URL, and go through each mode
    of the `fetchModes` array.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环遍历提供的 `protocols` 数组，为每个协议发出请求，使用每个 URL 构建一个 DOM 图像元素，并遍历 `fetchModes`
    数组中的每个模式。'
- en: 'The `init` object contains any custom settings that you want to apply to the
    request:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 对象包含您想要应用于请求的任何自定义设置：'
- en: '`method`: The request method, for example, `GET` and `POST`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：请求方法，例如，`GET` 和 `POST`'
- en: '`mode`: The mode you want to use for the request, for example, `cors`, `no-cors`,
    or `same-origin`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：您想要用于请求的模式，例如，`cors`、`no-cors` 或 `same-origin`'
- en: '`cache`: The cache mode you want to use for the request: `default`, `no-store`,
    `reload`, `no-cache`, `force-cache`, or `only-if-cached`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache`：您想要用于请求的缓存模式：`default`、`no-store`、`reload`、`no-cache`、`force-cache`
    或 `only-if-cached`'
- en: 'The `buildImage` function takes two arguments: `protocol` and `url`. It creates
    an image element on the fly and attaches the URL as the source of that image.
    Then it goes on to add that image to the DOM tree, where the ID is one of `https-acao-image`,
    `https-image`, or `http–image`. JavaScript has no control over the URL handling
    at this point; the browser handles the URLs:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildImage` 函数接受两个参数：`protocol` 和 `url`。它会动态创建一个图像元素，并将 URL 作为该图像的源。然后它继续将该图像添加到
    DOM 树中，其中 ID 为 `https-acao-image`、`https-image` 或 `http–image` 之一。在此阶段，JavaScript
    对 URL 的处理没有控制权；浏览器处理这些 URL：'
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Images will be rendered for HTTPS requests only, as service workers only support
    connections over SSL:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 HTTPS 请求的图像将被渲染，因为服务工作者仅支持 SSL 连接：
- en: '![How it works...](img/B05381_02_28.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B05381_02_28.jpg)'
- en: The broken image is the one requested over standard HTTP, which fails to respond
    with the requested image.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 破损的图像是通过标准 HTTP 请求的，未能响应请求的图像。
- en: 'Other requests over HTTP also fail to deliver, resulting in errors:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 其他通过 HTTP 发出的请求也未能成功交付，导致错误：
- en: '![How it works...](img/B05381_02_29.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B05381_02_29.jpg)'
- en: 'The requests over SSL, with the **Access-Control-Origin=*** header (**Access
    Control Allow Origin**), will return results successfully:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSL进行的请求，带有`**Access-Control-Origin=***`头（**访问控制允许源**），将成功返回结果：
- en: '![How it works...](img/B05381_02_30.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B05381_02_30.jpg)'
- en: 'By default, fetching a resource from a third-party URL will fail if it doesn''t
    support CORS. You can add a non-CORS option to the request to overcome this, although
    this will cause an *opaque* response, which means you won''t be able to tell whether
    the response was successful or not:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果第三方URL不支持CORS，则从该URL获取资源会失败。你可以向请求添加非CORS选项来克服这个问题，尽管这会导致一个*不透明的*响应，这意味着你无法判断响应是否成功：
- en: '![How it works...](img/B05381_02_31.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B05381_02_31.jpg)'
- en: 'The `fireRequest` function takes three arguments, `fetchMode`, `protocol`,
    and `init`. This function, in turn returns another function, which we can call
    a composition. We start with fetching the given resource directly from the remote
    resource:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`fireRequest`函数接受三个参数，`fetchMode`、`protocol`和`init`。这个函数反过来返回另一个函数，我们可以将其称为组合。我们首先从远程资源直接获取给定的资源：'
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If the fetch was successful, we print it to the console, as well as log it on
    the webpage. We do the same if the request fails, only we print `error`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获取成功，我们将它打印到控制台，并在网页上记录。如果请求失败，我们也会这样做，只是打印`error`。
- en: 'We also attempt to fetch the resource with the service worker''s proxy, which
    the client recognizes as a local resource:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还尝试使用服务工人的代理来获取资源，客户端将其识别为本地资源：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `printSuccess` and `printError` functions log responses to the console,
    as well as the DOM of the web page:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`printSuccess`和`printError`函数将响应记录到控制台，以及网页的DOM：'
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The helper function log finds the DOM element by the ID, and adds a paragraph
    element, as well as a class attribute, to depict the type of the message:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数log通过ID查找DOM元素，并添加一个段落元素以及一个类属性，以描述消息的类型：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `index.html` file, we have style declarations in the `head` section:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，我们在`head`部分有样式声明：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In our `log()` function, we set the undefined type to success, so that it will
    display the color green when we add it to `classList`. The error type will display
    red as declared in the previous styles.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`log()`函数中，我们将未定义的类型设置为成功，这样当我们将其添加到`classList`时，它将显示绿色。错误类型将显示为之前声明的红色。
- en: 'Let''s move over to our `service-worker.js` file. There we have the `onfetch`
    event handler, which gets fired whenever a fetch event occurs. Here, we check
    to see whether the request has a `proxy/` parameter in it. If it does, then it
    responds with the remaining part of the URL:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到我们的`service-worker.js`文件。在那里我们有`onfetch`事件处理程序，它在每次发生fetch事件时被触发。在这里，我们检查请求中是否有`proxy/`参数。如果有，则响应剩余的URL部分：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Otherwise, the response will perform the request with the full URL:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，响应将使用完整的URL执行请求：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There's more...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's examine the defaults of the `fetch()` function in more detail.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查`fetch()`函数的默认值。
- en: No credentials by default
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认不包含凭据
- en: 'When you use fetch, by default, requests won''t contain credentials such as
    cookies. If you want credentials, you can call this instead:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用fetch时，默认情况下，请求不会包含凭据，例如cookies。如果你想包含凭据，你可以调用这个代替：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This behavior is intentional, and is arguably better than XHR's more complex
    default behavior of sending credentials if the URL has the same origin, but omitting
    them otherwise.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是有意为之，并且可以说是比XHR更复杂的默认行为（如果URL具有相同的源，则发送凭据，否则不发送）更好的选择。
- en: Fetch's behavior is more like other CORS requests, such as `<img crossorigin>`,
    which never sends cookies unless you opt in with `<img crossorigin="use-credentials">`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch的行为更类似于其他CORS请求，例如`<img crossorigin>`，除非你通过`<img crossorigin="use-credentials">`选择加入，否则它永远不会发送cookies。
- en: Non-CORS fail by default
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认情况下，非CORS请求会失败
- en: 'By default, fetching a resource from a third-party URL will fail if it doesn''t
    support CORS. You can add a non-CORS option to the **Request** function to overcome
    this, although this will cause an *opaque* response, which means you won''t be
    able to tell whether the response was successful or not:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果第三方URL不支持CORS，则从该URL获取资源会失败。你可以向`Request`函数添加非CORS选项来克服这个问题，尽管这会导致一个*不透明的*响应，这意味着你无法判断响应是否成功：
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you want to unregister the service worker, you can head over to the `chrome://service-worker-internals`
    page in Chrome and click the **Unregister** button of the relevant service worker,
    as shown in the following screenshot:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要注销服务工作者，你可以前往 Chrome 中的 `chrome://service-worker-internals` 页面，并点击相关服务工作者的**注销**按钮，如下面的截图所示：
- en: '![Non-CORS fail by default](img/B05381_02_32.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![默认情况下非 CORS 失败](img/B05381_02_32.jpg)'
- en: See also
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Registering a service worker in detail* recipe in [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。学习服务工作者基础"), *详细注册服务工作者*配方，*学习服务工作者基础*'
- en: The *Creating mock responses* recipe in [Chapter 1](ch01.html "Chapter 1. Learning
    Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。学习服务工作者基础"), *创建模拟响应*配方，*学习服务工作者基础*'
