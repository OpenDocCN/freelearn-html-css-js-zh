- en: 7 Sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 集合
- en: '**Before you begin: Join our book community on Discord**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**开始之前：加入我们的 Discord 书籍社区**'
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“学习 JavaScript 数据结构与算法”第四版下的“EARLY
    ACCESS SUBSCRIPTION”中找到“learning-javascript-dsa-4e”频道）。
- en: '![](img/file0.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file0.png)'
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
- en: 'Building on your knowledge of sequential data structures, this chapter introduces
    you to the unique world of **sets**, a collection that stores only distinct values.
    We will cover the fundamentals of creating sets, adding or removing elements,
    and efficiently checking for membership. We will then discover how to leverage
    the power of sets with mathematical operations like union, intersection, and difference.
    To make things even easier, we will explore JavaScript''s built-in `Set` class,
    providing you with a convenient tool for working with sets directly. So, in this
    chapter, we will cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在您对顺序数据结构的了解之上，本章将带您进入独特的集合世界，这是一个只存储唯一值的集合。我们将介绍创建集合、添加或删除元素以及高效检查成员资格的基本原理。然后我们将发现如何利用集合的并集、交集和差集等数学运算的强大功能。为了使事情更加简单，我们将探索
    JavaScript 的内置 `Set` 类，为您提供直接处理集合的便捷工具。因此，在本章中，我们将涵盖：
- en: Creating a Set class from scratch
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始创建 Set 类
- en: Performing mathematical operations with a set
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合执行数学运算
- en: JavaScript native Set class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 原生 Set 类
- en: Exercises
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习
- en: The set data structure
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合数据结构
- en: A **set** is a fundamental concept in mathematics and computer science. It is
    an unordered collection of distinct items (elements). Think of it as a bag where
    you can put things in, but the order you put them in does not matter, and you
    cannot have duplicates.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**是数学和计算机科学中的基本概念。它是一个无序的不同项（元素）的集合。把它想象成一个袋子，你可以往里放东西，但你放东西的顺序不重要，而且你不能有重复。'
- en: Sets are a fundamental concept in mathematics and computer science, with numerous
    real-world applications across various fields.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是数学和计算机科学中的基本概念，在各个领域的实际应用中有着众多的应用。
- en: Let's take a look at the mathematical concept of sets before we dive into the
    computer science implementation of it. In mathematics, a set is a collection of
    distinct objects. For example, we have a set of natural numbers, which consists
    of integer numbers greater than or equal to 0 - that is, N = {0, 1, 2, 3, 4, 5,
    6, ...}. The list of the objects within the set is surrounded by {} (curly braces).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入计算机科学实现之前，先看看集合的数学概念。在数学中，集合是一组不同的对象。例如，我们有一个自然数集合，它由大于或等于 0 的整数组成——即 N
    = {0, 1, 2, 3, 4, 5, 6, ...}。集合中对象的列表被大括号 `{}` 包围。
- en: There is also the null set concept. A set with no element is called a **null
    set** or an **empty set**. An example would be a set of prime numbers between
    24 and 29\. Since there is no prime number (a natural number greater than 1 that
    has no positive divisors other than 1 and itself) between 24 and 29, the set will
    be empty. We will represent an empty set with { }.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还有空集的概念。没有元素的集合称为**空集**或**空集**。例如，24 和 29 之间的质数集合。由于在 24 和 29 之间没有质数（一个大于 1
    的自然数，除了 1 和它本身没有其他正除数），该集合将是空的。我们将用 `{}` 来表示空集。
- en: In mathematics, a set also has some basic operations such as union, intersection,
    and difference. We will also cover these operations in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，集合也有一些基本操作，如并集、交集和差集。我们也将在这章中介绍这些操作。
- en: In computer science for example, sets are used to model relationships between
    data and to perform operations like filtering, sorting, and searching. Sets are
    also extremely useful to remove duplicate elements from other collections such
    as lists.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，例如，集合用于模拟数据之间的关系，并执行过滤、排序和搜索等操作。集合还可以从列表等其他集合中删除重复元素，非常有用。
- en: You can also imagine a set as an array with no repeated elements and no concept
    of order.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以想象集合为一个没有重复元素且没有顺序概念的数组。
- en: Creating the MySet class
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 MySet 类
- en: ECMAScript 2015 (ES6) introduced the native Set class to JavaScript, providing
    a built-in and efficient way to work with sets. However, understanding the underlying
    implementation of a set is crucial for grasping data structures and algorithms.
    We will delve into creating our own custom `MySet` class that mirrors the functionality
    of the native Set, but with additional features like union, intersection, and
    difference operations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2015 (ES6) 将原生的 `Set` 类引入 JavaScript，提供了一种内置且高效的方式来处理集合。然而，理解集合的底层实现对于掌握数据结构和算法至关重要。我们将深入了解创建我们自己的自定义
    `MySet` 类，该类模仿原生 `Set` 的功能，但具有额外的功能，如并集、交集和差集操作。
- en: 'Our implementation will reside in the `src/07-set/set.js` file. We will start
    by defining the `MySet` class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现将位于 `src/07-set/set.js` 文件中。我们首先定义 `MySet` 类：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We chose the name `MySet` to avoid conflicts with the native `Set` class. We
    utilize an object (`{}`) instead of an array to store elements within the `#items`
    private property. The keys of this object represent the set's unique values, while
    the corresponding values can be anything (we will use true as a simple placeholder).
    This choice leverages the fact that JavaScript objects cannot have duplicate keys,
    naturally enforcing the uniqueness of set elements. Arrays could also be used,
    but they require additional logic to prevent duplicates and might have slightly
    slower lookups in some cases. In other languages, this data structure (using a
    hash table-like approach) is often referred to as a **hash set**. We will also
    keep track of the number of elements in the set with the property `size`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择名称 `MySet` 以避免与原生的 `Set` 类冲突。我们利用对象 (`{}`) 而不是数组来存储 `#items` 私有属性中的元素。该对象的键代表集合的唯一值，而相应的值可以是任何东西（我们将使用
    true 作为简单的占位符）。这种选择利用了 JavaScript 对象不能有重复键的事实，自然地强制集合元素的唯一性。虽然也可以使用数组，但它们需要额外的逻辑来防止重复，并且在某些情况下可能会稍微慢一些。在其他语言中，这种数据结构（使用类似哈希表的方法）通常被称为
    **哈希集**。我们还将使用 `size` 属性跟踪集合中的元素数量。
- en: 'Next, we need to declare the methods available for a set:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要声明集合可用的方法：
- en: 'The `MySet` class will provide the following methods:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`MySet` 类将提供以下方法：'
- en: '`add(value)`: adds a unique value to the set.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(value)`: 向集合添加一个唯一的值。'
- en: '`delete(value)`: removes the value from the set if it exists.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete(value)`: 如果存在，则从集合中移除该值。'
- en: '`has(value)`: returns true if the element exists in the set and false otherwise.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has(value)`: 如果元素存在于集合中，则返回 true，否则返回 false。'
- en: '`clear()`: removes all the values from the set.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 从集合中移除所有值。'
- en: '`size()`: returns how many values the set contains.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 返回集合包含的值的数量。'
- en: '`values()`: returns an array of all the values of the set.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`: 返回集合中所有值的数组。'
- en: '`union(otherSet)`: combines two sets.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`union(otherSet)`: 合并两个集合。'
- en: '`intersection(otherSet)`: finds common elements between the two sets.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intersection(otherSet)`: 查找两个集合之间的公共元素。'
- en: '`difference(otherSet)`: finds elements unique to one set.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difference(otherSet)`: 查找仅存在于一个集合中的元素。'
- en: We will implement each of these methods in detail in the following sections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中详细实现这些方法。
- en: Finding a value in the set
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在集合中查找值
- en: 'The first method we implement in our custom `MySet` class is `has(value)`.
    This method plays a crucial role as a building block for other operations like
    adding and removing elements. It allows us to efficiently determine if a given
    value already exists within the set. Here is the implementation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在自定义 `MySet` 类中首先实现的方法是 `has(value)`。这个方法在添加和移除元素等其他操作中扮演着至关重要的基础角色。它允许我们有效地确定给定值是否已经存在于集合中。以下是实现方法：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The method directly utilizes JavaScript's built-in `hasOwnProperty` function
    on the internal `#items` object. This is a highly optimized way to check if a
    specific key (representing the value) exists in the object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法直接利用 JavaScript 内置的 `hasOwnProperty` 函数在内部 `#items` 对象上。这是一种高度优化的方式来检查特定键（表示值）是否存在于对象中。
- en: The `hasOwnProperty` method provides constant time complexity (*O(1)*) on average,
    making it an extremely fast way to check for existence within the set. This efficiency
    is a key reason we often prefer using objects over arrays for set implementations
    in JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasOwnProperty` 方法在平均情况下提供常数时间复杂度 (*O(1)*)，这使得它成为检查集合中存在性的极快方式。这种效率是我们经常在
    JavaScript 中使用对象而不是数组来实现集合的关键原因。'
- en: And now that we have this method, we can proceed with the implementation of
    the methods for adding and removing values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个方法，我们可以继续实现添加和移除值的方法的实现。
- en: Adding values to the set
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向集合添加值
- en: 'Next, we will implement the add method in our custom `MySet` class. This method
    is responsible for inserting a new element into the set, but only if it''s not
    already present (maintaining the set''s uniqueness property) as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在自定义的`MySet`类中实现`add`方法。这个方法负责将新元素插入到集合中，但只有当它尚未存在时（保持集合的唯一性属性）如下所示：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We start by efficiently checking if the value already exists within the set
    using the `has(value)` method we implemented earlier. If the value is not already
    present, we insert it into the `#items` object. We use the `value` itself as the
    key and assign a value of `true` to it. This serves as a simple flag indicating
    that the value is part of the set. After a successful insertion, we increment
    the `#size` property to accurately reflect the new number of elements in the set.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用我们之前实现的`has(value)`方法高效地检查值是否已经存在于集合中。如果值不存在，我们将其插入到`#items`对象中。我们使用`value`本身作为键，并给它分配一个值为`true`的值。这作为一个简单的标志，表示该值是集合的一部分。插入成功后，我们将`#size`属性增加以准确反映集合中新的元素数量。
- en: We return `true` to signal that the value was successfully added (it was not
    already in the set). Otherwise, we return `false` to indicate that the value was
    not added because it was a duplicate.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回`true`以表示值已成功添加（它不在集合中）。否则，我们返回`false`以指示值没有被添加，因为它是一个重复项。
- en: Removing and clearing all values
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除和清除所有值
- en: 'Next, we will implement the `delete` method as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`delete`方法，如下所示：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We start by checking if the specified value exists within the set using the
    previously implemented `has(value)` method. This ensures we only try to delete
    elements that are present. If the value is found, we use the `delete` operator
    to remove the corresponding key-value pair from the `#items` object. This directly
    eliminates the element from the set's internal storage. After a successful deletion,
    we decrease the `#size` property to maintain an accurate count of elements in
    the set.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用之前实现的`has(value)`方法检查指定的值是否存在于集合中。这确保我们只尝试删除存在的元素。如果找到值，我们使用`delete`运算符从`#items`对象中删除相应的键值对。这直接从集合的内部存储中删除了元素。删除成功后，我们将`#size`属性减少以保持集合中元素数量的准确计数。
- en: We return `true` to signal that the value was successfully deleted from the
    set, and `false` to indicate that the value was not found in the set and therefore
    could not be deleted.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回`true`以表示值已成功从集合中删除，并返回`false`以表示值未在集合中找到，因此无法删除。
- en: 'And if we want to remove all the elements from the set, we can use the `clear`
    method, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从集合中移除所有元素，可以使用`clear`方法，如下所示：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We achieve a complete clearing of the set by directly reassigning the `#items`
    object to a new, empty object `{}`. This effectively discards all previous key-value
    pairs (representing the set's elements) and creates a fresh, empty container for
    future additions. And we also reset the `#size` property back to 0 to accurately
    reflect that the set now contains no elements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过直接将`#items`对象重新分配给一个新的空对象`{}`来实现集合的完全清除。这有效地丢弃了所有之前的关键值对（代表集合的元素），并为未来的添加创建了一个全新的空容器。我们还把`#size`属性重置为0，以准确反映集合现在不包含任何元素。
- en: This implementation is extremely efficient, as reassigning the `#items` object
    is a constant time operation (*O(1)*). The alternative of iterating and deleting
    each element individually would be much slower, especially for large sets. This
    is generally not recommended unless we have a specific reason to track which elements
    are being removed during the clear operation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方式非常高效，因为重新分配`#items`对象是一个常数时间操作（*O(1)*）。逐个迭代并删除每个元素的方法会慢得多，尤其是对于大型集合。除非我们有特定的原因需要在清除操作期间跟踪被移除的元素，否则通常不推荐这样做。
- en: Retrieving the size and checking if it is empty
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取大小并检查是否为空
- en: 'The next method we will implement is the size method (technically a getter
    method) as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要实现的方法是大小方法（技术上是一个获取器方法），如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method simply returns the size property we are using to keep count.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法简单地返回我们用来计数的`size`属性。
- en: 'If we weren''t tracking the `#size` property, we could determine the size of
    the set by:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有跟踪`#size`属性，我们可以通过以下方式确定集合的大小：
- en: Iterating over the keys (elements) of the `#items` object.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历`#items`对象的键（元素）。
- en: Incrementing a counter for each key encountered.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为遇到的每个键增加计数器。
- en: 'Here is the code for this alternative approach:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个替代方法的代码：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code uses a `for...in` loop to iterate over the keys (which are the values
    of the set) in the `#items` object. Inside the loop, `hasOwnProperty` is used
    to ensure we are only counting properties that belong directly to the object (not
    inherited properties from the prototype chain).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `for...in` 循环遍历 `#items` 对象中的键（即集合的值）。在循环内部，使用 `hasOwnProperty` 确保我们只计算属于对象本身的属性（而不是从原型链继承的属性）。
- en: This approach would be less efficient, especially for large sets, as it would
    involve iterating over all elements, resulting in a time complexity of *O(n)*,
    where *n* is the number of elements in the set
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于大型集合来说效率较低，因为它需要遍历所有元素，导致时间复杂度为 *O(n)*，其中 *n* 是集合中元素的数量。
- en: 'And to determine if the `MySet` is empty, we implement the `isEmpty()` method,
    following a pattern consistent with other data structures we have covered in this
    book:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定 `MySet` 是否为空，我们实现了 `isEmpty()` 方法，遵循与其他数据结构一致的模板：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method directly compares the private `#size` property to 0\. The property
    `#size` is meticulously maintained to always reflect the number of elements in
    the set.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法直接比较私有 `#size` 属性与 0。属性 `#size` 被精心维护，始终反映集合中的元素数量。
- en: Retrieving all the values
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索所有值
- en: 'To retrieve an array containing all the elements (values) within our `MySet`,
    we can implement the `values` method as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索包含 `MySet` 中所有元素（值）的数组，我们可以如下实现 `values` 方法：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can leverage the built-in `Object.keys()` method for a concise implementation.
    This built-in JavaScript method takes an object (in our case, `this.#items`) and
    returns an array containing all its enumerable property keys as strings. Remember,
    in our `MySet` implementation, we use the keys of the `#items` object to store
    the actual values that are added to the set.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用内置的 `Object.keys()` 方法来实现简洁的代码。这个内置的 JavaScript 方法接受一个对象（在我们的例子中，是 `this.#items`），并返回一个包含所有可枚举属性键的字符串数组。记住，在我们的
    `MySet` 实现中，我们使用 `#items` 对象的键来存储实际添加到集合中的值。
- en: Now that we have completed the implementation of our custom `MySet` data structure,
    let's explore how to put it into action!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了自定义 `MySet` 数据结构的实现，让我们来看看如何将其付诸实践！
- en: Using the MySet class
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 MySet 类
- en: We will dive into practical examples that showcase the utility and flexibility
    of `MySet`, demonstrating how it can be used to efficiently manage collections
    of unique elements. Imagine we are building a blog or content management system
    where users can add tags (keywords) to their articles or posts. We want to ensure
    that each post has a list of unique tags, with no duplicates.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨一些实际例子，展示 `MySet` 的实用性和灵活性，演示它如何高效地管理唯一元素集合。想象一下，我们正在构建一个博客或内容管理系统，用户可以为他们的文章或帖子添加标签（关键词）。我们希望确保每篇文章都有一个唯一标签列表，没有重复。
- en: 'The source code for this example can be found in the file src/07-set/01-using-myset-class.js.
    Let''s start by defining the article:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的源代码可以在文件 src/07-set/01-using-myset-class.js 中找到。让我们首先定义文章：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s add some tags to our article:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的文章添加一些标签：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that the first and last tags are duplicates. We can confirm if we have
    three tags in the set, meaning there are no duplicates:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个和最后一个标签是重复的。我们可以确认集合中有三个标签，这意味着没有重复：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also use the `has` method to double check which tags are part of the
    article:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `has` 方法来再次确认哪些标签是文章的一部分：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also use the values method to retrieve all the tags:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `values` 方法来检索所有标签：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s say we want to remove the tag programming and add the tag JavaScript
    instead:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要移除标签编程并添加标签 JavaScript：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, now we have a remarkably similar implementation of the Set class, as in
    ECMAScript 2015\. But we can also enhance our implementation by adding some basic
    operations such as union, intersection, and difference.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有一个与 ECMAScript 2015 中的 Set 类非常相似的实现。但我们可以通过添加一些基本操作来增强我们的实现，例如并集、交集和差集。
- en: Performing mathematical operations with a set
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集合执行数学运算
- en: Sets are a fundamental concept in mathematics with far-reaching applications
    in computer science, particularly within the realm of **databases**. Databases
    serve as the backbone of countless applications, and sets play a crucial role
    in their design and operation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是数学中的一个基本概念，在计算机科学中有着广泛的应用，尤其是在数据库领域。数据库是无数应用程序的骨架，集合在它们的设计和运行中起着至关重要的作用。
- en: When we construct a query to retrieve data from a relational database (such
    as Oracle, Microsoft SQL Server, MySQL, etc.), we are essentially using set notation
    to define the desired result. The database, in turn, returns a set of data that
    matches our criteria.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建查询以从关系型数据库（如Oracle、Microsoft SQL Server、MySQL等）检索数据时，我们实际上是在使用集合符号来定义所需的结果。数据库反过来返回一组符合我们标准的数据。
- en: 'SQL queries allow us to specify the scope of the data we want to retrieve.
    We can select all records from a table, or we can narrow down the search to a
    specific subset based on certain conditions. Furthermore, SQL leverages set operations
    to perform various types of data manipulation. The concept of *joins* in SQL is
    fundamentally based on set operations. Here are some common examples:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SQL查询允许我们指定我们想要检索的数据范围。我们可以选择表中的所有记录，或者我们可以根据某些条件缩小搜索范围到特定的子集。此外，SQL利用集合操作来执行各种类型的数据操作。SQL中的*连接*概念在本质上基于集合操作。以下是一些常见的例子：
- en: '**Union**: combining data from two or more tables to create a new set containing
    all unique rows.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并集**：将两个或多个表中的数据合并，创建一个包含所有唯一行的新的集合。'
- en: '**Intersection**: identifying rows that are common to multiple tables, resulting
    in a set containing only the shared data.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交集**：识别多个表中共同存在的行，结果是一个只包含共享数据的集合。'
- en: '**Difference** (Except/Minus): finding rows that exist in one table but not
    in another, creating a set of unique rows from the first table.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差异**（除法/减法）：找出存在于一个表中但不存在于另一个表中的行，从第一个表中创建一个包含唯一行的集合。'
- en: 'And beyond the operations used in SQL, there are other essential set operations
    such as:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了SQL中使用的操作之外，还有其他重要的集合操作，例如：
- en: '**Subset**: determining if one set is entirely contained within another set.
    This helps establish relationships between sets and can be useful for various
    logical and analytical tasks.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子集**：确定一个集合是否完全包含在另一个集合中。这有助于建立集合之间的关系，并且对于各种逻辑和分析任务可能很有用。'
- en: Understanding sets and their operations is essential for working with databases
    and other data-intensive applications. The ability to manipulate sets effectively
    allows us to efficiently extract, filter, and analyze information from complex
    datasets. Let's see how we can simulate these operations using our `MySet` class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 理解集合及其操作对于处理数据库和其他数据密集型应用至关重要。有效地操作集合的能力使我们能够有效地从复杂的数据集中提取、过滤和分析信息。让我们看看我们如何使用我们的`MySet`类来模拟这些操作。
- en: 'Union: combining two sets'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并集：合并两个集合
- en: The union of two sets, A and B, is a new set that contains all the unique elements
    from both sets. It is like combining the contents of two bags into one larger
    bag, making sure not to put in any duplicates.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合A和B的并集是一个新集合，它包含来自两个集合的所有唯一元素。这就像将两个包的内容合并到一个更大的包中，确保不放入任何重复的元素。
- en: 'For example, consider we have two sets: A and B as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有两个集合：A和B如下所示：
- en: Set A = {1, 2, 3}
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合A = {1, 2, 3}
- en: Set B = {3, 4, 5}
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合B = {3, 4, 5}
- en: A ∪ B = {1, 2, 3, 4, 5}
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A ∪ B = {1, 2, 3, 4, 5}
- en: In this example, the value 3 appears in both sets, but it is only included once
    in the resulting union set because sets cannot contain duplicates.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，值3同时出现在两个集合中，但在结果的并集集合中只包含一次，因为集合不能包含重复的元素。
- en: 'The union of sets A and B is denoted by the symbol ∪. So, the union of A and
    B is written as A ∪ B in the mathematical notation. The following diagram exemplifies
    the union operation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 集合A和B的并集用符号∪表示。因此，A和B的并集在数学表示法中写作A ∪ B。以下图表展示了并集操作：
- en: '![The union operation of two sets, highlighting all the area of both sets](img/file54.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![两个集合的并集操作，突出显示两个集合的所有区域](img/file54.png)'
- en: The union operation of two sets, highlighting all the area of both sets
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的并集操作，突出显示两个集合的所有区域
- en: 'Now, let''s implement the union method in our `MySet` class with the following
    code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码在我们的`MySet`类中实现并集方法：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need three steps to perform the union of two sets:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行两个集合的并集，我们需要三个步骤：
- en: 'Create a new empty set: this will be the set to hold the results of the union.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空集合：这将是一个用于存储并集结果的集合。
- en: 'Iterate over the first set: add each element from the first set to the new
    set.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历第一个集合：将第一个集合中的每个元素添加到新集合中。
- en: 'Iterate over the second set: add each element from the second set to the new
    set.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历第二个集合：将第二个集合中的每个元素添加到新集合中。
- en: When performing the add operation, it will evaluate if the value is duplicate
    or not, resulting in a new set containing all the unique elements from the original
    sets.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行添加操作时，它将评估值是否重复，从而得到一个包含原始集合中所有唯一元素的新集合。
- en: It is important to note that the union, intersection, and difference methods
    we are implementing in this chapter do not modify the current instance of the
    `MySet` class nor the `otherSet` that is being passed as a parameter. Methods
    or functions that do not have collateral effects are called **pure functions**.
    A pure function does not modify the current instance nor the parameters; it only
    produces a new result.
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们在本章中实现的并集、交集和差集方法不会修改当前的 `MySet` 类实例，也不会修改作为参数传递的 `otherSet`。没有副作用的方法或函数被称为**纯函数**。纯函数不会修改当前实例或参数；它只产生一个新的结果。
- en: 'Let''s see this in action. Suppose an online advertising platform wants to
    target users based on their interests, which are collected from various sources
    (for example: websites visited and social media activity). To be able to launch
    a campaign, we need:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个方法是如何工作的。假设一个在线广告平台想要根据用户的兴趣进行定位，这些兴趣来自各种来源（例如：访问的网站和社交媒体活动）。为了能够发起活动，我们需要：
- en: Collect sets of keywords representing interests from different sources.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集来自不同来源的兴趣关键词集合。
- en: Calculate the union of these sets to get a comprehensive list of user interests.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算这些集合的并集，以获得一个全面的用户兴趣列表。
- en: Use this combined set to match users with relevant advertisements.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个组合集合来匹配相关广告的用户。
- en: 'The following would be the code that would represent this logic. Let''s first
    collect the interest from websites:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将代表这个逻辑。让我们首先收集来自网站的兴趣：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s collect the interested from social media:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们收集来自社交媒体的兴趣：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With both sources, we can calculate the union to have a list of all interests:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个来源，我们可以计算它们的并集，得到一个包含所有兴趣的列表：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we can try to launch a successful campaign!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试发起一个成功的活动！
- en: 'To facilitate our examples, we can also create a new method what will take
    an array of values as the input:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便我们的示例，我们还可以创建一个新的方法，它将接受一个值数组作为输入：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method will add each element individually so we can save some time during
    the next examples.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将逐个添加每个元素，这样我们可以在下一个示例中节省一些时间。
- en: 'Intersection: identifying common values in two sets'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交集：识别两个集合中的共同值
- en: The intersection of two sets, A and B, is a new set that contains only the elements
    that are common to both sets. Think of it as finding the overlap between the contents
    of two bags.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合 A 和 B 的交集是一个新集合，它只包含两个集合共有的元素。将其视为寻找两个袋子内容的重叠部分。
- en: 'For example, consider we have two sets: A and B as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们有两个集合：A 和 B，如下所示：
- en: Set A = {1, 2, 3, 4}
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 A = {1, 2, 3, 4}
- en: Set B = {3, 4, 5, 6}
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 B = {3, 4, 5, 6}
- en: A ∩ B = {3, 4}
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A ∩ B = {3, 4}
- en: In this example, the values 3 and 4 are present in both sets, so they are included
    in the resulting intersection set.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，值 3 和 4 同时存在于两个集合中，因此它们被包含在结果交集集合中。
- en: 'The intersection of sets A and B is denoted by the symbol ∩. So, the intersection
    of A and B is written as A ∩ B. The following diagram exemplifies the intersection
    operation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 A 和 B 的交集用符号 ∩ 表示。因此，A 和 B 的交集写作 A ∩ B。以下图表展示了交集操作：
- en: '![The intersection operation of two sets, highlighting only the middle, which
    is the shared area of both sets](img/file55.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![两个集合的交集操作，仅突出显示中间部分，这是两个集合的共享区域](img/file55.png)'
- en: The intersection operation of two sets, highlighting only the middle, which
    is the shared area of both sets
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的交集操作，仅突出显示中间部分，这是两个集合的共享区域
- en: 'Now, let''s implement the intersection method in our `MySet` class with the
    following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码在 `MySet` 类中实现交集方法：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We need three steps to perform the intersection of two sets:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行两个集合的交集，我们需要三个步骤：
- en: 'Create a new empty set: this will be the set to hold the results of the intersection.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空集合：这将是一个用于存储交集结果的集合。
- en: 'Iterate over the first set: for each element in the first set, check if it
    also exists in the second set.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历第一个集合：对于第一个集合中的每个元素，检查它是否也存在于第二个集合中。
- en: 'Conditional addition: If the element is found in both sets, add it to the new
    set.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件添加：如果元素在两个集合中都找到，则将其添加到新集合中。
- en: 'Let''s see this in action. Suppose a job platform wants to match candidates
    with job postings based on their skills. For this implementation we would need
    the following logic:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个方法在实际中的应用。假设一个招聘平台想要根据求职者的技能来匹配职位发布。为了这个实现，我们需要以下逻辑：
- en: Represent a candidate's skills and a job's required skills as sets.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将求职者的技能和职位所需的技能表示为集合。
- en: Find the intersection of these sets to determine the skills that the candidate
    possesses, and the job requires.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出这些集合的交集，以确定求职者拥有的技能和职位所需的技能。
- en: Rank job postings based on the size of the intersection to show the most relevant
    jobs to the candidate.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据交集的大小对职位发布进行排名，以显示对求职者最相关的职位。
- en: 'The following would be the code that would represent this logic. First, we
    will define the job postings available:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将代表此逻辑的代码。首先，我们将定义可用的职位发布：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `jobPostings` variable is an array of job objects, each with a `title` and
    a `MySet` named skills containing the required skills for that job.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`jobPostings` 变量是一个包含职位对象的数组，每个对象都有一个 `title` 和一个名为 `skills` 的 `MySet`，其中包含该职位的所需技能。'
- en: 'Next, we will define the candidate with the name and their skills:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义具有名字和技能的求职者：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `candidate` is an object representing a job seeker with a name and a `MySet`
    named skills containing their skills.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`candidate` 是一个对象，代表一个求职者，包含一个名字和一个名为 `skills` 的 `MySet`，其中包含他们的技能。'
- en: 'Then, we can create a function that will calculate the best potential matches
    between the candidate and the job postings available:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个函数，该函数将计算求职者和可用的职位发布之间的最佳潜在匹配：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is an explanation of the `matchCandidateWithJobs` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `matchCandidateWithJobs` 函数的解释：
- en: Takes the `candidate` and the `jobPostings` as input.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `candidate` 和 `jobPostings` 作为输入。
- en: Initializes an empty array `matches` to store the matching jobs.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个空数组 `matches` 来存储匹配的职位。
- en: Iterates through each job in the `jobPostings` array.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历 `jobPostings` 数组中的每个职位。
- en: For each job, it calculates the intersection of the candidate's skills and the
    job's required skills.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个职位，它计算求职者技能和职位所需技能的交集。
- en: If the intersection set is not empty (meaning there are matching skills), the
    job title and the matching skills (as an array) are added to the `matches` array.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果交集集合不为空（意味着存在匹配的技能），则将职位标题和匹配的技能（作为一个数组）添加到 `matches` 数组中。
- en: Finally, we return the matches array containing the job titles and their matching
    skills with the candidate.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们返回包含职位标题及其与求职者匹配的技能的 `matches` 数组。
- en: 'Putting all together:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We get the output that the best job posting for this candidate would be the
    Software Engineer job because the candidate also has JavaScript and Angular skills.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果是，对于这个求职者来说，最佳职位发布将是软件工程师职位，因为求职者还拥有 JavaScript 和 Angular 技能。
- en: The intersection logic we created works perfectly, however, there is an improvement
    we can make.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的交集逻辑工作得很好，然而，我们可以进行一些改进。
- en: Improving the intersection logic
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 改进交集逻辑
- en: 'Consider the following scenario:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：
- en: 'Set A contains values: {1, 2, 3, 4, 5, 6, 7}'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 A 包含以下值：{1, 2, 3, 4, 5, 6, 7}
- en: 'Set B contains values: {4, 6}'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 B 包含以下值：{4, 6}
- en: In our initial intersection method, we would iterate through all seven elements
    of Set A and check for their presence in Set B. However, a more efficient approach
    exists.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最初的交集方法中，我们会遍历集合 A 的所有七个元素，并检查它们是否存在于集合 B 中。然而，存在一种更有效的方法。
- en: 'We can optimize the intersection method by iterating over the *smaller* of
    the two sets. This significantly reduces the number of iterations and comparisons
    needed when one set is considerably smaller than the other. The optimized code
    is presented as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过遍历两个集合中较小的一个来优化交集方法。当其中一个集合明显小于另一个集合时，这显著减少了所需的迭代和比较次数。优化后的代码如下所示：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We use a concise ternary expression to determine which set has fewer elements:
    `this.size <= otherSet.size ? [this, otherSet] : [otherSet, this]`. This assigns
    the smaller set to `smallerSet` and the larger set to `largerSet`. Then, we iterate
    over the `values()` of the `smallerSet`. This immediately reduces the number of
    loop iterations to the size of the smaller set.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用简洁的三元表达式来确定哪个集合元素较少：`this.size <= otherSet.size ? [this, otherSet] : [otherSet,
    this]`。这会将较小的集合分配给 `smallerSet`，较大的集合分配给 `largerSet`。然后，我们遍历 `smallerSet` 的 `values()`。这立即将循环迭代次数减少到较小集合的大小。'
- en: In cases where one set is much smaller than the other, this optimization significantly
    reduces the number of iterations and comparisons, leading to faster execution
    time. And the overall performance of the intersection operation is enhanced, especially
    for scenarios with large set size disparities.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个集合远小于另一个集合的情况下，这种优化显著减少了迭代和比较的次数，从而提高了执行时间。特别是对于集合大小差异大的场景，交集操作的整体性能得到了提升。
- en: Difference between two sets
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个集合之间的差集
- en: The difference between two sets, A and B (denoted as A - B or A \ B), is a new
    set that contains all the elements of A that are not present in B. In other words,
    it is the set of elements that are unique to set A.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合 A 和 B 之间的差集（表示为 A - B 或 A \ B），是一个包含 A 中所有不在 B 中的元素的新集合。换句话说，它是集合 A 中独特的元素集合。
- en: 'For example, consider we have two sets: A and B as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们有两个集合：A 和 B，如下所示：
- en: Set A = {1, 2, 3, 4}
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 A = {1, 2, 3, 4}
- en: Set B = {3, 4, 5, 6}
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 B = {3, 4, 5, 6}
- en: A - B = {1, 2}
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A - B = {1, 2}
- en: B - A = {5, 6}
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B - A = {5, 6}
- en: In this example, A - B results in the set {1, 2} because these elements are
    in A but not in B. Similarly, B - A results in {5, 6}.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，A - B 的结果是集合 {1, 2}，因为这些元素在 A 中但不在 B 中。同样，B - A 的结果是 {5, 6}。
- en: 'The difference of sets A and B is written as:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 A 和 B 的差集表示为：
- en: A - B (sometimes read as *A minus B*)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A - B（有时读作 *A 减去 B*）
- en: A \ B
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A \ B
- en: 'The following diagram exemplifies the difference operation of A - B:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 A - B 的差集操作：
- en: '![The difference operation of two sets A - B, highlighting only the area of
    A not common to B](img/file56.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![两个集合 A - B 的差集操作，突出显示 A 中不与 B 共同的部分](img/file56.png)'
- en: The difference operation of two sets A - B, highlighting only the area of A
    not common to B
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合 A - B 的差集操作，突出显示 A 中不与 B 共同的部分
- en: 'Now, let''s implement the difference method in our `MySet` class with the following
    code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码在我们的 `MySet` 类中实现差集方法：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We need three steps to perform the difference of two sets:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行两个集合的差集，我们需要三个步骤：
- en: 'Create a new empty set: this will hold the result of the difference.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空集合：这将保存差集的结果。
- en: 'Iterate over the first set: for each element in the first set, check if it
    exists in the second set.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历第一个集合：对于第一个集合中的每个元素，检查它是否存在于第二个集合中。
- en: 'Conditional addition: if the element is *not* found in the second set, add
    it to the new set.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件添加：如果元素在第二个集合中未找到，则将其添加到新集合中。
- en: Let's see this in action. Suppose we are running an online store with a list
    of subscribers who receive promotional emails. We have segmented the subscribers
    based on their interests (books, fashion, technology). We want to send a targeted
    email campaign about books, but we want to exclude subscribers who have already
    shown interest in these books.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作。假设我们正在运行一个在线商店，有一份接收促销电子邮件的订阅者列表。我们已经根据他们的兴趣（书籍、时尚、技术）对订阅者进行了细分。我们想要发送关于书籍的目标电子邮件活动，但我们希望排除已经对这些书籍表示过兴趣的订阅者。
- en: 'So, let''s start by declaring all the sets we need for this scenario:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先声明我们在这个场景中需要的所有集合：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have three sets:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个集合：
- en: '`allSubscribers`: a set of all email subscribers.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allSubscribers`：所有电子邮件订阅者的集合。'
- en: '`booksInterested`: a set of subscribers who have expressed interest in the
    books.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`booksInterested`：一组表示对书籍感兴趣的用户。'
- en: '`alreadyPurchasedBooks`: a set of subscribers who have already purchased books.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alreadyPurchasedBooks`：一组已经购买书籍的用户。'
- en: 'Next, we will find the subscribers interested in books, but have not purchased
    yet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将找到对书籍感兴趣但尚未购买的订阅者：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use `booksInterested.difference(alreadyPurchasedBooks)` to find the subscribers
    who are interested in books but have not yet made a purchase in that category.
    This gives us the `targetSubscribers` set.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `booksInterested.difference(alreadyPurchasedBooks)` 来找到对书籍感兴趣但尚未在该类别中购买的订阅者。这给我们带来了
    `targetSubscribers` 集合。
- en: 'And finally, we will send the email to the target subscribers:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将向目标订阅者发送电子邮件：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And the output we will get is:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到的输出是：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We only have one last operation to cover: subsets'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只剩下一个最后操作要覆盖：子集
- en: 'Subset: checking if a set contains all the values'
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子集：检查一个集合是否包含所有值
- en: A set A is a subset of another set B if every element of A is also an element
    of B. In simpler terms, A is completely contained within B.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合 A 的每个元素也是集合 B 的元素，则集合 A 是集合 B 的子集。用更简单的话说，A 完全包含在 B 内。
- en: 'For example, consider we have two sets: A and B as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们有两个集合：A 和 B，如下所示：
- en: Set A = {1, 2}
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 A = {1, 2}
- en: Set B = {1, 2, 3, 4}
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 B = {1, 2, 3, 4}
- en: A ⊆ B
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A ⊆ B
- en: In this example, A is a subset of B because every element in A is also in B.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，A是B的子集，因为A中的每个元素也在B中。
- en: 'The subset relationship is denoted by the symbol ⊆. So, if A is a subset of
    B, we write: A ⊆ B. The following diagram exemplifies the subset relationship:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 子集关系用符号⊆表示。所以，如果A是B的子集，我们写成：A ⊆ B。以下图表展示了子集关系：
- en: '![A is a subset of B because element in A is also in B](img/file57.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![A是B的子集，因为A中的元素也在B中](img/file57.png)'
- en: A is a subset of B because element in A is also in B
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: A是B的子集，因为A中的元素也在B中
- en: 'Now, let''s implement the `isSubsetOf` method in our `MySet` class with the
    following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码在`MySet`类中实现`isSubsetOf`方法：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We start by checking if the size of the current set (`this.size`) is greater
    than the size of the `otherSet`. If it is, we know immediately that the current
    set cannot be a subset of `otherSet` because a subset cannot have more elements
    than the set it is a part of. In this case, the method returns `false` early,
    saving unnecessary further checks.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查当前集合的大小（`this.size`）是否大于`otherSet`的大小。如果是这样，我们立即知道当前集合不能是`otherSet`的子集，因为子集不能比它所组成的集合有更多的元素。在这种情况下，方法提前返回`false`，节省了不必要的进一步检查。
- en: If the size check passes, we call `this.values()` to get an array of all the
    values in the current set. Then, we use the `every()` method on this array to
    check if the other set has the value from the current set. If every value in the
    current set is also found in `otherSet`, then the `every()` method returns `true`
    (meaning the current set is a subset). If even a single value in the current set
    is not found in `otherSet`, `every()` returns `false` (meaning it's not a subset).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大小检查通过，我们调用`this.values()`来获取当前集合中所有值的数组。然后，我们在这个数组上使用`every()`方法来检查另一个集合是否有当前集合中的值。如果当前集合中的每个值都在`otherSet`中找到，那么`every()`方法返回`true`（意味着当前集合是一个子集）。如果当前集合中的任何一个值在`otherSet`中没有找到，`every()`返回`false`（意味着它不是子集）。
- en: Let's see this in action. Imagine we are developing a recipe app with a large
    database of recipes. Each recipe has a set of ingredients. Users can filter the
    recipes based on the ingredients they have available.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个操作的实际效果。想象一下，我们正在开发一个拥有大量食谱数据库的食谱应用。每个食谱都有一组食材。用户可以根据他们拥有的食材来筛选食谱。
- en: 'We will start by declaring the sets that store the ingredients of our recipes:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明存储我们食谱食材的集合：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will declare the recipes along with the ingredients:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将声明食谱及其食材：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `recipes` variable is an array of recipe objects, each with a name and a
    `MySet` named ingredients representing the ingredients required for that recipe.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`recipes`变量是一个食谱对象的数组，每个对象都有一个名称和一个名为`ingredients`的`MySet`，表示该食谱所需的食材。'
- en: 'Then, we also need a set with the list of ingredients we have available:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还需要一个包含我们有可用食材的列表的集合：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next step would be the logic to check if we have a recipe that matches
    our ingredients:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是检查我们是否有匹配我们食材的食谱的逻辑：
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is an explanation of the `filterRecipes` function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`filterRecipes`函数的解释：
- en: Takes the `recipes` and `userIngredients` as input.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收`recipes`和`userIngredients`作为输入。
- en: Initializes an empty array `filteredRecipes` to store the matching recipe names.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个空的数组`filteredRecipes`来存储匹配的食谱名称。
- en: Iterates over each recipe in the recipes array.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历`recipes`数组中的每个食谱。
- en: For each recipe, it checks if `recipe.ingredients.isSubsetOf(userIngredients)`.
    If `true` (meaning all the recipe's ingredients are present in the user's ingredients),
    the recipe's name is added to `filteredRecipes`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个食谱，它检查`recipe.ingredients.isSubsetOf(userIngredients)`。如果为`true`（意味着食谱的所有食材都在用户的食材中），则将食谱的名称添加到`filteredRecipes`。
- en: Returns the `filteredRecipes` array.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`filteredRecipes`数组。
- en: 'And finally, putting all together:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将所有这些放在一起：
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will get the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can also implement the isSupersetOf method, which would check if the current
    set A is a superset of another set B if every element of B is also an element
    of A. In simpler terms, B is completely contained within A. Try it, and you can
    find the source code within the `MySet` class when you download the source code
    of this book.
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们还可以实现`isSupersetOf`方法，该方法将检查当前集合A是否是另一个集合B的超集，如果B中的每个元素也是A的元素。用更简单的术语来说，B完全包含在A中。尝试一下，你可以在下载本书源代码时在`MySet`类中找到源代码。
- en: Now that we have added some additional logic to the `MySet` class, let's check
    how the native JavaScript Set class works.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经向`MySet`类添加了一些额外的逻辑，让我们来看看原生的JavaScript Set类是如何工作的。
- en: The JavaScript Set class
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript Set类
- en: Let's dive into the native Set class introduced in ECMAScript 2015 (ES6) and
    explore how to use it effectively.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解 ECMAScript 2015（ES6）中引入的原生 Set 类，并探讨如何有效地使用它。
- en: The Set class provides a built-in, efficient way to work with sets in JavaScript.
    It offers all the fundamental set operations and is optimized for performance.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Set 类提供了在 JavaScript 中处理集合的内置、高效方式。它提供了所有基本集合操作，并针对性能进行了优化。
- en: 'Now, let''s look at the methods and features available in the native Set class:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看原生 Set 类中可用的方法和功能：
- en: 'Two constructors:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个构造函数：
- en: '`new Set()`: creates an empty Set.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Set()`: 创建一个空的 Set。'
- en: '`new Set(iterable)`: creates a Set from an iterable object (for example, an
    array).'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Set(iterable)`: 从可迭代对象（例如，数组）创建一个 Set。'
- en: '`add(value)`: adds a value to the set (if it is not already present). Returns
    the Set object itself for chaining.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(value)`: 向集合中添加一个值（如果它尚未存在）。返回 Set 对象本身以实现链式调用。'
- en: '`delete(value)`: removes the specified value from the set. Returns `true` if
    the value was present and removed, otherwise `false`.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete(value)`: 从集合中删除指定的值。如果值存在并已删除，则返回 `true`，否则返回 `false`。'
- en: '`clear()`: removes all elements from the set.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 从集合中删除所有元素。'
- en: '`has(value)`: returns `true` if the value exists in the set, otherwise `false`.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has(value)`: 如果值存在于集合中，则返回 `true`，否则返回 `false`。'
- en: 'Different methods for iterating the set:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历集合的不同方法：
- en: '`forEach(callbackFn)`: executes the provided `callbackFn` for each value in
    the set.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach(callbackFn)`: 对集合中的每个值执行提供的 `callbackFn`。'
- en: '`values()`: returns an iterator over the values of the set.'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`: 返回集合值的迭代器。'
- en: '`keys()`: alias for `values()`.'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys()`: `values()` 的别名。'
- en: '`entries()`: Returns an iterator over `[value, value]` pairs (since keys and
    values are the same in a Set).'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entries()`: 返回一个遍历 `[value, value]` 对的迭代器（因为在 Set 中键和值是相同的）。'
- en: '`size`: property that returns the number of elements in the set.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`: 返回集合中元素数量的属性。'
- en: 'If we would like to rewrite our example of the article and its tags, can we
    simply replace `MySet` with `Set` and the code would still work as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要重写文章及其标签的示例，我们可以简单地用 `Set` 替换 `MySet`，代码仍然可以按以下方式工作：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Given the Set class also has a constructor that accepts an array, we could
    simplify the previous code and pass the tags directly to the constructor:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Set 类还有一个接受数组的构造函数，我们可以简化之前的代码，并将标签直接传递给构造函数：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The other methods, such as delete, check the size, has and values would also
    work as expected.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法，如删除、检查大小、存在和值，也会按预期工作。
- en: Building our custom `MySet` class served as a valuable learning exercise, providing
    insights into the internal workings and mechanics of set data structures. While
    in everyday JavaScript development, we would likely use the efficient and convenient
    built-in Set class, the knowledge gained from implementing our own set empowers
    us to understand the underlying principles, make informed choices between built-in
    and custom solutions, and troubleshoot set-related issues more effectively.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 构建我们的自定义 `MySet` 类是一个有价值的练习，它让我们深入了解集合数据结构的内部工作和机制。虽然在日常 JavaScript 开发中，我们可能会使用高效且方便的内建
    Set 类，但通过实现自己的集合所获得的知识使我们能够理解底层原理，在内置和自定义解决方案之间做出明智的选择，并更有效地解决与集合相关的问题。
- en: Reviewing the efficiency of sets
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查集合的效率
- en: 'Let''s review the efficiency of each method by reviewing the Big O notation
    in terms of time of execution:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看每个方法的 Big O 符号来回顾其执行时间效率：
- en: '| **Method** | **MySet** | **Set** | **Explanation** |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **MySet** | **Set** | **说明** |'
- en: '| `add(value)` | *O(1)* | *O(1)* | Constant time insertion into the object
    or underlying data structure. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `add(value)` | *O(1)* | *O(1)* | 将值插入到对象或底层数据结构中具有恒定时间的操作。|'
- en: '| `addAll(values)` | *O(n)* | *O(n)* | Calls `add(value)` for each value in
    the input array, where *n* is the size of the array. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `addAll(values)` | *O(n)* | *O(n)* | 对输入数组中的每个值调用 `add(value)`，其中 *n* 是数组的大小。|'
- en: '| `delete(value)` | *O(1)* | *O(1)* | Constant time deletion from the object
    or underlying data structure. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `delete(value)` | *O(1)* | *O(1)* | 从对象或底层数据结构中删除具有恒定时间的操作。|'
- en: '| `has(value)` | *O(1)* | *O(1)* | Object lookup in both cases has constant
    time |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `has(value)` | *O(1)* | *O(1)* | 在两种情况下，对象查找都具有恒定时间 |'
- en: '| `values()` | *O(n)* | *O(n)* | In `MySet` , it iterates over the object''s
    keys. In `Set` , it creates an iterator that yields each value in linear time.
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `values()` | *O(n)* | *O(n)* | 在 `MySet` 中，它遍历对象的键。在 `Set` 中，它创建一个迭代器，以线性时间产生每个值。|'
- en: '| `size (getter)` | *O(1)* | *O(1)* | Returns the value of the `#size` property
    or equivalent in the native Set. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `size (getter)` | *O(1)* | *O(1)* | 返回 `#size` 属性或原生的 Set 中的等效值。 |'
- en: '| `isEmpty()` | *O(1)* | *O(1)* | Checks if `#size` is 0. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `isEmpty()` | *O(1)* | *O(1)* | 检查 `#size` 是否为 0。 |'
- en: '| `values()` | *O(n)* | *O(n)* | In `MySet` , it iterates over the object''s
    keys. In `Set` , it creates an iterator that yields each value in linear time.
    |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `values()` | *O(n)* | *O(n)* | 在 `MySet` 中，它遍历对象的键。在 `Set` 中，它创建一个迭代器，以线性时间产生每个值。
    |'
- en: '| `clear()` | *O(1)* | *O(1)* | Reassigns the `#items` object to an empty object
    and resets `#size` . |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | *O(1)* | *O(1)* | 将 `#items` 对象重新赋值为空对象，并重置 `#size`。 |'
- en: The overall space complexity of sets is considered O(n), where n is the number
    of unique elements stored in the set. This means that the memory used by a set
    data structure increases linearly with the number of elements it contains.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的整体空间复杂度被认为是 O(n)，其中 n 是集合中存储的唯一元素的数量。这意味着集合数据结构使用的内存与其包含的元素数量成线性增长。
- en: 'Reviewing the time complexity, adding, removing values, and checking if a value
    exists in a set have constant time. One might ask why not always use sets instead
    of arrays or lists? While sets excel at specific tasks, there are a few reasons
    why we would not always choose them over arrays or lists:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾时间复杂度，向集合中添加、删除值以及检查值是否存在都具有常数时间。有人可能会问，为什么我们总是使用集合而不是数组或列表？虽然集合在特定任务上表现出色，但也有一些原因说明为什么我们不会总是选择它们而不是数组或列表：
- en: If the order of the elements is crucial, arrays are the way to go. Sets do not
    guarantee any specific order of elements.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果元素的顺序至关重要，数组是最佳选择。集合不保证元素的任何特定顺序。
- en: If we frequently need to access elements by their position (for example, getting
    the third item in a list), arrays are much faster due to their direct indexing.
    Sets require iteration to find a specific element.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们经常需要通过位置访问元素（例如，获取列表中的第三个元素），数组由于直接索引而要快得多。集合需要迭代来查找特定元素。
- en: If the data naturally contains duplicates, and those duplicates are meaningful,
    then an array is the more appropriate choice.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据自然包含重复项，并且这些重复项是有意义的，那么数组是更合适的选择。
- en: Let's put our knowledge into practice with some exercises.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的知识运用到一些练习中。
- en: Exercises
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: We will resolve one exercise from **LeetCode** using the set data structure
    to remove duplicate values from an array.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用集合数据结构解决来自 **LeetCode** 的一个练习，以从数组中删除重复值。
- en: Remove duplicates from sorted array
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从排序数组中删除重复项
- en: The exercise we will resolve the is the *26\. Remove Duplicates from Sorted
    Array* problem available at [https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解决的练习是位于 [https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)
    的 *26\. 删除排序数组中的重复项* 问题。
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function `function removeDuplicates(nums: number[]):
    number`, which receives an array of numbers and expects the number of unique elements
    within the array as a return. For our solution to be accepted, we also have to
    remove the duplicates from the `nums` array in-place, meaning we cannot simply
    assign a new reference to it.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用 JavaScript 或 TypeScript 解决问题时，我们需要在 `function removeDuplicates(nums: number[]):
    number` 函数内部添加我们的逻辑，该函数接收一个数字数组并期望返回数组中的唯一元素数量。为了使我们的解决方案被接受，我们还需要在原地从 `nums`
    数组中删除重复项，这意味着我们不能简单地为其分配一个新的引用。'
- en: 'Let''s write the `removeDuplicates` function using a set data structure to
    easily remove the duplicates from the array:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用集合数据结构来编写 `removeDuplicates` 函数，以便轻松地从数组中删除重复项：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is an explanation of the solution:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解决方案的解释：
- en: We start by creating a new JavaScript Set object, initializing it with the values
    from the input array `nums`. Sets automatically store only unique values, so any
    duplicates in `nums` are eliminated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的 JavaScript Set 对象，并用输入数组 `nums` 的值初始化它。集合自动存储唯一值，因此 `nums` 中的任何重复项都会被消除。
- en: Next, we convert the set back into a regular array `arr`. This new array contains
    only the unique elements from the original `nums` array, in sorted order. This
    step is required because we cannot access each set value directly, like an `array[i]`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将集合转换回一个常规数组 `arr`。这个新数组只包含从原始 `nums` 数组中提取的唯一元素，并按顺序排列。这一步是必要的，因为我们不能直接访问集合中的每个值，就像访问
    `array[i]` 一样。
- en: The for loop iterates through the `arr` (unique elements) array and copies each
    element back into the original `nums` array, overwriting any duplicate values
    that were present. Since `arr` is guaranteed to be shorter or equal in length
    to `nums`, we only need to iterate up to the length of arr. This step is a requirement
    as the problem judge will also check if the `nums` array was modified in-place.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: for循环遍历`arr`（唯一元素）数组，并将每个元素复制回原始的`nums`数组，覆盖任何现有的重复值。由于`arr`的长度保证不会超过`nums`，我们只需要遍历到`arr`的长度。这一步是必需的，因为问题评判者也会检查`nums`数组是否被就地修改。
- en: Finally, the method returns arr.length, which is the number of unique elements
    in the original array. This is the expected output for the LeetCode problem.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该方法返回`arr.length`，即原始数组中的唯一元素个数。这是LeetCode问题的预期输出。
- en: The time complexity of this function is *O(n)*, where *n* is the number of values
    we have in the array `nums`. We are creating the set, adding all the elements
    (*O(n)*), we convert the set into an array (*O(n)*), and we also have a loop to
    overwrite the original array (*O(k)*, where *k* is the number of unique elements).
    Therefore, the overall time complexity is *O(n)*, as it is dominated by the linear-time
    operations of creating the set and converting it to an array.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的时间复杂度是*O(n)*，其中*n*是数组`nums`中的值数。我们创建集合，添加所有元素（*O(n)*），然后将集合转换为数组（*O(n)*），还有一个循环来覆盖原始数组（*O(k)*，其中*k*是唯一元素的个数）。因此，整体时间复杂度是*O(n)*，因为它受创建集合并将其转换为数组的线性时间操作的支配。
- en: The space complexity is *O(k)* because we are creating a set to store the unique
    elements. In the worst-case scenario where all elements are unique, it will store
    all *n* elements. However, in most cases, *k* (the number of unique elements)
    will be smaller than *n*. We also have the array `arr`, which stores only the
    unique elements, so its size is *k*. Therefore, the overall space complexity is
    *O(k)*, where *k* is the number of unique elements in the input array.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度是*O(k)*，因为我们创建了一个集合来存储唯一元素。在最坏的情况下，即所有元素都是唯一的，它将存储所有*n*个元素。然而，在大多数情况下，*k*（唯一元素的个数）将小于*n*。我们还有一个只存储唯一元素的数组`arr`，所以其大小是*k*。因此，整体空间复杂度是*O(k)*，其中*k*是输入数组中唯一元素的个数。
- en: While the algorithm is correct and solves the problem, it is not the most *space-efficient*
    solution. We will resolve this same problem later in this book using a different
    technique. In the meantime, give it a try and try to solve this problem using
    *O(1)* space complexity.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然算法是正确的并且解决了问题，但它并不是最*空间高效*的解决方案。我们将在本书的后面部分使用不同的技术解决相同的问题。在此期间，请尝试使用*O(1)*空间复杂度解决这个问题。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the inner workings of set data structures by
    implementing a custom `MySet` class. This hands-on approach mirrors the core functionality
    of the Set class introduced in ECMAScript 2015, giving you a deeper understanding
    of how sets operate under the hood. We also extended our exploration beyond the
    standard JavaScript Set by implementing additional methods like union, intersection,
    difference, and subset, enriching your toolkit for working with sets.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过实现自定义的`MySet`类深入探讨了集合数据结构的内部工作原理。这种动手方法反映了ECMAScript 2015中引入的Set类的核心功能，使你对集合在底层如何操作有了更深入的理解。我们还扩展了我们的探索，通过实现并集、交集、差集和子集等额外方法，丰富了你在处理集合时的工具箱。
- en: To put our newfound knowledge into practice, we tackled a real-world LeetCode
    problem, demonstrating the power of sets in solving algorithmic challenges.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们新获得的知识付诸实践，我们解决了一个真实的LeetCode问题，展示了集合在解决算法挑战中的力量。
- en: In the next chapter, we will shift our focus to non-sequential data structures,
    specifically hashes and dictionaries. Get ready to discover how these versatile
    structures enable efficient data storage and retrieval based on key-value pairs!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把重点转向非顺序数据结构，特别是哈希和字典。准备好发现这些多才多艺的结构如何通过键值对实现高效的数据存储和检索！
