- en: Chapter 2. Getting Started with DOM-based Game Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：使用基于 DOM 的游戏开发入门
- en: '*We''ve got an idea about what we are going to learn in the whole book in [Chapter
    1](ch01.html "Chapter 1. Introducing HTML5 Games"), *Introducing HTML5 Games*.
    From this chapter onwards, we will go through a lot of learning-by-doing sections,
    and we will focus on one topic in each section. Before digging deeply into the
    cutting-edge CSS3 animations and HTML5 Canvas game, let''s start with traditional
    DOM-based game development. We will warm up with some basic techniques in this
    chapter.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在 [第 1 章](ch01.html "第 1 章。介绍 HTML5 游戏") *介绍 HTML5 游戏* 中对整本书将要学习的内容有一个大致的了解。从这一章开始，我们将进入许多通过实践学习的内容，并且每个部分将专注于一个主题。在深入探讨
    CSS3 动画和 HTML5 Canvas 游戏之前，让我们从传统的基于 DOM 的游戏开发开始。我们将在这个章节中通过一些基本技术来热身。'
- en: 'In this chapter, we will be:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将做以下事情：
- en: Setting up our first game—Ping Pong
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的第一个游戏——乒乓球
- en: Learning basic positioning with the jQuery JavaScript library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 jQuery JavaScript 库学习基本定位
- en: Getting mouse inputs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取鼠标输入
- en: Creating the Ping Pong game that displays the scores
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建显示分数的乒乓球游戏
- en: Learning to separate data and view rendering logic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何分离数据和视图渲染逻辑
- en: We will create a Ping Pong game that a player plays against the computer via
    mouse input. You can try the game at [http://makzan.net/html5-games/pingpong/](http://makzan.net/html5-games/pingpong/).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个乒乓球游戏，玩家可以通过鼠标输入与电脑对战。你可以在 [http://makzan.net/html5-games/pingpong/](http://makzan.net/html5-games/pingpong/)
    尝试这个游戏。
- en: 'The following screenshot shows the look of the game at the end of this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了本章结束时游戏的外观：
- en: '![Getting Started with DOM-based Game Development](img/B04290_02_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![使用基于 DOM 的游戏开发入门](img/B04290_02_01.jpg)'
- en: So, let's get on with making our Ping Pong game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始制作我们的乒乓球游戏。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing the book, the jQuery version is 2.1.3\. The jQuery functions
    that we used in the examples are basic functions that should work in future versions
    too.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，jQuery 版本是 2.1.3。我们在示例中使用的 jQuery 函数是基本函数，应该在未来版本中也能正常工作。
- en: Preparing the HTML documents for a DOM-based game
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备基于 DOM 的游戏的 HTML 文档
- en: Every website, web page, and HTML5 game starts with a default HTML document.
    Moreover, the document starts with a basic HTML code. We will start our HTML5
    game development journey with `index.html`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网站、网页和 HTML5 游戏都是从默认的 HTML 文档开始的。此外，文档从基本的 HTML 代码开始。我们将从 `index.html` 开始我们的
    HTML5 游戏开发之旅。
- en: Time for action – installing the jQuery library
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——安装 jQuery 库
- en: 'We will create our HTML5 Ping Pong game from scratch. It may sound as if we
    are going to be preparing all the things ourselves. Luckily, we can use a JavaScript
    library to help us. **jQuery** is the **JavaScript library** that is designed
    to navigate the DOM elements easily, manipulate them, handle events, and create
    an asynchronous remote call. We will be using this library in the book to manipulate
    DOM elements. It will help us to simplify our JavaScript logic:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从零开始创建我们的 HTML5 乒乓球游戏。这听起来好像我们即将准备所有的事情。幸运的是，我们可以使用一个 JavaScript 库来帮助我们。**jQuery**
    是一个专为轻松导航 DOM 元素、操作它们、处理事件和创建异步远程调用而设计的 **JavaScript 库**。我们将在本书中使用这个库来操作 DOM 元素。它将帮助我们简化我们的
    JavaScript 逻辑：
- en: Create a new folder named `pingpong` as our project directory.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pingpong` 的新文件夹作为我们的项目目录。
- en: 'Inside the `pingpong` folder, we will create the following file structure,
    with three folders—`js`, `css`, and `images`—and an `index.html` file:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `pingpong` 文件夹内，我们将创建以下文件结构，包括三个文件夹——`js`、`css` 和 `images`——以及一个 `index.html`
    文件：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, it's time to download the jQuery library. Go to [http://jquery.com/](http://jquery.com/).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候下载 jQuery 库了。访问 [http://jquery.com/](http://jquery.com/)。
- en: Select **Download jQuery** and click on **Download the compressed, production
    jQuery 2.1.3**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **下载 jQuery** 并点击 **下载压缩的、用于生产的 jQuery 2.1.3**。
- en: Save `jquery-2.1.3.min.js` within the `js` folder that we created in step 2.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `jquery-2.1.3.min.js` 保存到我们在步骤 2 中创建的 `js` 文件夹中。
- en: 'Open `index.html` in text editor and insert an empty HTML template:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 `index.html` 并插入一个空的 HTML 模板：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we have to ensure that jQuery is loaded successfully. To do this,
    place the following code into the `js/pingpong.js` file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须确保 jQuery 已成功加载。为此，将以下代码放入 `js/pingpong.js` 文件中：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the `index.html` file and open it in the browser. You should see the following
    alert window showing our text. This means that our jQuery is correctly set up:![Time
    for action – installing the jQuery library](img/B04290_02_02.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`index.html`文件并在浏览器中打开它。你应该会看到一个显示我们文本的警告窗口。这意味着我们的jQuery已经正确设置：![Time for
    action – installing the jQuery library](img/B04290_02_02.jpg)
- en: '*What just happened?*'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just created a basic HTML5 page with jQuery and ensured that the jQuery is
    loaded correctly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用jQuery创建了一个基本的HTML5页面，并确保jQuery被正确加载。
- en: New HTML5 doctype
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的HTML5 doctype
- en: The `DOCTYPE` and `meta` tags are simplified in HTML5.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5中，`DOCTYPE`和`meta`标签被简化了。
- en: 'In HTML 4.01, we declare doctype using the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML 4.01中，我们使用以下代码声明doctype：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is a long line of code, right? While in HTML5, the doctype declaration
    couldn''t have been more simpler:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一行很长的代码，对吧？在HTML5中，文档类型声明（doctype）已经不能再简单了：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We do not even have the HTML version in the declaration. This is because HTML5
    is now a living standard without a version number.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至没有在声明中包含HTML版本。这是因为HTML5现在是一个没有版本号的活标准。
- en: Header and footer
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Header和footer
- en: 'HTML5 comes with many new features and improvements, and one of them is semantics.
    HTML5 adds new elements to improve **semantics**. We just used two of the elements:
    `header` and `footer`. **Header** gives an introduction to the section or the
    entire page. Therefore, we put the `h1` title inside the header. **Footer**, like
    the name suggests, contains the footer information of the section or the page.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5带来了许多新特性和改进，其中之一是语义。HTML5添加了新元素来提高**语义**。我们只使用了两个元素：`header`和`footer`。**Header**为部分或整个页面提供了一个介绍。因此，我们将`h1`标题放在header中。**Footer**，正如其名所示，包含部分或页面的页脚信息。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A semantic HTML means that the markup itself provides meaningful information
    to the content instead of only defining the visual outlook.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 语义化HTML意味着标记本身提供了有意义的信息给内容，而不仅仅是定义视觉外观。
- en: The best practice to place the JavaScript code
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 放置JavaScript代码的最佳实践
- en: We put the JavaScript code right before the closing `</body>` tag and after
    all the content in the page. There is a reason for putting the code there instead
    of putting it inside the `<head></head>` section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将JavaScript代码放在`</body>`标签的关闭之前，并在页面中的所有内容之后。将代码放在那里的原因而不是将其放在`<head></head>`部分中，是有原因的。
- en: Normally, browsers load content and render them from top to bottom. If the JavaScript
    code is put in the `head` section, then the content of the document will not be
    loaded until all the JavaScript code is loaded. Actually, all rendering and loading
    will be paused if the browsers load a JavaScript code in the middle of the page.
    This is the reason why we want to put the JavaScript code at the bottom, when
    possible. In this way, we can deliver the HTML content to our readers faster.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，浏览器从顶部到底部加载内容并渲染它们。如果JavaScript代码放在`head`部分，那么文档的内容将不会加载，直到所有JavaScript代码都加载完毕。实际上，如果浏览器在页面中间加载JavaScript代码，所有的渲染和加载都会暂停。这就是为什么我们希望在可能的情况下将JavaScript代码放在底部。这样，我们可以更快地将HTML内容传递给读者。
- en: At the time of writing this book, the latest jQuery version is 2.1.3\. This
    is why the jQuery file in our code examples is named `jquery-2.1.3.min.js`. The
    version number in the filename ensures that web developers don't get confused
    with different versions of the same filename in different projects. This version
    number will be different, but the usage should be the same, unless there is a
    big change in jQuery without backward compatibility.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新的jQuery版本是2.1.3。这就是为什么我们的代码示例中的jQuery文件被命名为`jquery-2.1.3.min.js`。文件名中的版本号确保了网络开发者不会在不同项目中混淆相同文件名的不同版本。这个版本号会不同，但使用方式应该是相同的，除非jQuery有重大变化而不向后兼容。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that a few JavaScript libraries have to put the `<head>` tag before
    loading any HTML elements. When you're using third-party libraries, please check
    whether they have such a requirement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些JavaScript库需要在加载任何HTML元素之前放置`<head>`标签。当您使用第三方库时，请检查它们是否有这样的要求。
- en: Choosing the jQuery file
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择jQuery文件
- en: For the jQuery library, there are currently two major versions; they are **1.x**
    and **2.x**. The 1.x version keeps backward compatibility to older browsers, mainly
    for IE versions 6, 7, and 8\. Since our HTML5 games target modern browsers, we
    chose the 2.x version that has dropped support to IE 8 or the older versions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 jQuery 库，目前有两个主要版本；它们是 **1.x** 和 **2.x**。1.x 版本保持与旧浏览器的向后兼容性，主要是针对 IE 6、7
    和 8 版本。由于我们的 HTML5 游戏针对现代浏览器，我们选择了不再支持 IE 8 或更旧版本的 2.x 版本。
- en: 'There are two common ways to include the jQuery library. We can either download
    a **hosted** version or use the **CDN** version. Hosted version means that we
    download the file, and we host the file ourselves. CDN stands for Content Delivery
    Network. The jQuery files are hosted in several central servers to improve the
    file downloading time. For the CDN version, we can find the URL at [http://code.jquery.com](http://code.jquery.com).
    We can directly include the file with the `<script>` tag in HTML as: `<script
    src="img/jquery.min.js"></script>`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 jQuery 库有两种常见方式。我们可以下载一个 **托管** 版本或使用 **CDN** 版本。托管版本意味着我们下载文件，并自行托管文件。CDN
    代表内容分发网络。jQuery 文件托管在几个中央服务器上，以提高文件下载时间。对于 CDN 版本，我们可以在 [http://code.jquery.com](http://code.jquery.com)
    找到 URL。我们可以直接在 HTML 中使用 `<script>` 标签包含文件，如下所示：`<script src="img/jquery.min.js"></script>`。
- en: 'Otherwise, we can specify the version number in the filename as: `<script src="img/jquery-2.1.3.min.js"></script>`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们可以在文件名中指定版本号，如下所示：`<script src="img/jquery-2.1.3.min.js"></script>`。
- en: Running jQuery inside a scope
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在作用域内运行 jQuery
- en: 'We need to ensure that the page is ready before our JavaScript code is executed.
    Otherwise, we may get an error when we try to access an element that is not yet
    loaded. jQuery provides us with a way to execute the code after the page is ready
    by using the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的 JavaScript 代码执行之前确保页面已准备好。否则，当我们尝试访问尚未加载的元素时，可能会出错。jQuery 通过以下代码提供了一种在页面准备好后执行代码的方法：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Most of the time, we uses a `$` sign to represent jQuery. This is a shortcut
    that makes calling our jQuery functions much easier. So essentially, we use the
    following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们使用 `$` 符号来表示 jQuery。这是一个使调用我们的 jQuery 函数变得更容易的快捷方式。因此，本质上，我们使用以下代码：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we call `$(something)`, we are actually calling `jQuery(something)`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `$(something)` 时，我们实际上是在调用 `jQuery(something)`。
- en: 'There may be conflicts on the `$` variables if we use multiple JavaScript libraries
    in one project. For best practice, we use an **anonymous function** to pass the
    jQuery object into the function scope where it becomes a `$` sign:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在一个项目中使用多个 JavaScript 库，可能会出现 `$` 变量冲突。为了最佳实践，我们使用一个 **匿名函数** 将 jQuery 对象传递到函数作用域，使其成为
    `$` 符号：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An anonymous function is a function definition that has no name. That's why
    it's called anonymous. Since we cannot refer to this function anymore, the anonymous
    function always executes itself. JavaScript's variable scope is bound to the function
    scope. We often use anonymous function to control certain variables' availability.
    For instance, we passed the jQuery into the function as the `$` variable in our
    example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是一个没有名称的函数定义。这就是为什么它被称为匿名函数。由于我们不能再引用这个函数，匿名函数总是自我执行。JavaScript 的变量作用域绑定到函数作用域。我们经常使用匿名函数来控制某些变量的可用性。例如，在我们的例子中，我们将
    jQuery 作为 `$` 变量传递到函数中。
- en: Running our code after the page is ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在页面准备好后运行我们的代码
- en: '`$(function_callback)` is another shortcut for the DOM elements'' `ready` event.
    The reason we need jQuery `ready` function is to prevent the execution of JavaScript
    logic before the HTML DOM elements are loaded. Our function that is defined in
    the jQuery `ready` function is executed after all the HTML elements are loaded.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(function_callback)` 是 DOM 元素的 `ready` 事件的另一个快捷方式。我们需要 jQuery `ready` 函数的原因是防止在
    HTML DOM 元素加载之前执行 JavaScript 逻辑。我们在 jQuery `ready` 函数中定义的函数在所有 HTML 元素加载后执行。'
- en: 'It is identical to the following line of code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它与以下代码行相同：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the jQuery `ready` event fires after the HTML structure (DOM tree)
    is loaded. However, this does not mean that the content, such as the actual image
    content, is loaded. The browser's `onload` event, on the other hands, fires after
    all the content including the images are loaded.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，jQuery 的 `ready` 事件在 HTML 结构（DOM 树）加载后触发。然而，这并不意味着内容，例如实际图像内容，已经加载。另一方面，浏览器的
    `onload` 事件在所有内容（包括图像）加载后触发。
- en: Pop quiz
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which is the best place to put JavaScript code?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 将 JavaScript 代码放在哪里是最好的位置？
- en: Before the `<head>` tag
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<head>` 标签之前
- en: Inside the `<head></head>` elements
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<head></head>` 元素内部
- en: Right after the `<body>` tag
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<body>` 标签之后
- en: Right before the `</body>` tag
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `</body>` 标签之前
- en: Downloading the image assets
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载图像资源
- en: We need some graphic files in this step. You can download the graphic files
    in the code bundle or from [http://mak.la/book-assets/](http://mak.la/book-assets/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们需要一些图形文件。你可以从代码包中下载图形文件，或者从 [http://mak.la/book-assets/](http://mak.la/book-assets/)
    下载。
- en: 'In the assets bundle, you will find image files for `Chapter 2`. After downloading
    them, put the files in the `images` folder. There should be four files, as shown
    in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源包中，你可以找到 `第 2 章` 的图像文件。下载后，将这些文件放入 `images` 文件夹。应该有四个文件，如下面的截图所示：
- en: '![Downloading the image assets](img/B04290_02_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![下载图像资源](img/B04290_02_03.jpg)'
- en: Setting up the Ping Pong game elements
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置乒乓球游戏元素
- en: We have made the preparations, and now it's time to set up the Ping Pong game.
    The following graph shows how we place the game elements. The game element contains
    our playground and later the scoreboard. Inside the playground, we place two decorative
    elements, namely **paddle hand**, which acts as the handle of the soccer machine.
    Then, we have two **paddle** elements—one on the left and one on the right.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做好了准备，现在是时候设置乒乓球游戏了。以下图表显示了游戏元素的放置方式。游戏元素包含我们的游乐场和之后的计分板。在游乐场内部，我们放置了两个装饰元素，即**挡板手**，它作为足球机的把手。然后，我们有两个**挡板**元素——一个在左边，一个在右边。
- en: '![Setting up the Ping Pong game elements](img/B04290_02_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![设置乒乓球游戏元素](img/B04290_02_04.jpg)'
- en: Time for action – placing Ping Pong game elements in the DOM
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 将乒乓球游戏元素放置在 DOM 中
- en: We will continue from our jQuery installation example, and open the `index.html`
    file in a text editor.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续从我们的 jQuery 安装示例，并在文本编辑器中打开 `index.html` 文件。
- en: 'Then, we will create the following playground and `game` objects with DIV nodes
    in the body. There are two paddles and one ball inside the playground, and the
    playground is placed inside the game:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用 DIV 节点在主体中创建以下游乐场和 `game` 对象。游乐场内部有两个挡板和一个球，并且游乐场被放置在游戏内部：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now have the structure of the `game` object ready, and it is time to apply
    styles to them. We will add the following styles to the `pingpong.css` file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了 `game` 对象的结构，现在是时候为它们应用样式了。我们将向 `pingpong.css` 文件中添加以下样式：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we will define the dimensions and positions of the two paddles by appending
    the following code inside the `pingpong.css` file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在 `pingpong.css` 文件内部追加以下代码来定义两个挡板的尺寸和位置：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will continue with the styles in the `pingpong.css` file and define `paddle-hands`,
    which is the decoration for the paddles:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续在 `pingpong.css` 文件中的样式，并定义 `paddle-hands`，这是挡板的装饰：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we are done with the CSS styles, let''s move to the `js/pingpong.js`
    file for JavaScript''s logic. We need a function to update the DOM elements of
    the paddles based on the position data. To do this, we will replace the current
    code with the following one:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们完成了 CSS 样式，让我们转到 `js/pingpong.js` 文件来处理 JavaScript 的逻辑。我们需要一个函数来根据位置数据更新挡板的
    DOM 元素。为此，我们将用以下代码替换当前代码：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we will test the setup in a browser. Open the `index.html` file in a browser;
    we should see a screen similar to the one shown in the following screenshot:![Time
    for action – placing Ping Pong game elements in the DOM](img/B04290_02_05.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在一个浏览器中测试设置。在浏览器中打开 `index.html` 文件；我们应该看到一个类似于以下截图的屏幕：![行动时间 - 将乒乓球游戏元素放置在
    DOM 中](img/B04290_02_05.jpg)
- en: '*What just happened?*'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Let's take a look at the HTML code that we just used. The HTML page contains
    header, footer information, and a DIV element with the ID, `game`. The `game`
    node contains a child named `playground`, which in turn contains three children—two
    paddles and the ball.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚使用的 HTML 代码。HTML 页面包含标题、页脚信息，以及一个具有 ID `game` 的 DIV 元素。`game` 节点包含一个名为
    `playground` 的子节点，该子节点又包含三个子节点——两个挡板和球。
- en: We often start the HTML5 game development by preparing a well-structured HTML
    hierarchy. The HTML hierarchy helps us to group similar game objects (which are
    some DIV elements) together. It is a little like grouping assets into a movie
    clip in Adobe Flash, if you have ever made animations with it. We may also consider
    it as layers of game objects for us to select and style them easily.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过准备一个结构良好的 HTML 层次结构来开始 HTML5 游戏开发。HTML 层次结构帮助我们将类似的游戏对象（这些是一些 DIV 元素）组合在一起。如果你曾经使用过
    Adobe Flash 制作过动画，这有点像将资产分组到电影剪辑中。我们也可以将其视为游戏对象的层，以便我们能够轻松地选择和设置它们的样式。
- en: Using jQuery
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 jQuery
- en: 'The jQuery command often contains two major parts: **selection** and **modification**.
    Selection uses CSS selector syntax to select all matched elements in the web page.
    Modification actions modify the selected elements, such as adding or removing
    children or style. Using jQuery often means chaining selection and modification
    actions together.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 命令通常包含两个主要部分：**选择**和**修改**。选择使用 CSS 选择器语法来选择网页中所有匹配的元素。修改操作修改所选元素，例如添加或删除子元素或样式。使用
    jQuery 通常意味着将选择和修改操作链在一起。
- en: 'For example, the following code selects all elements with the `box` class and
    sets the CSS properties:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码选择所有具有 `box` 类的元素并设置 CSS 属性：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Understanding basic jQuery selectors
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解基本的 jQuery 选择器
- en: 'jQuery is about selecting elements and performing actions on them. We need
    a method to select our required elements in the entire DOM tree. jQuery borrows
    the selectors from CSS. The selector provides a set of patterns to match elements.
    The following table lists the most common and useful selectors that we will use
    in this book:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 是关于选择元素并在其上执行操作的工具。我们需要一个方法来在整个 DOM 树中选择我们需要的元素。jQuery 从 CSS 中借用了选择器。选择器提供了一组模式来匹配元素。以下表格列出了我们将在这本书中使用的最常见和有用的选择器：
- en: '| Selector pattern | Meaning | Examples |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 选择器模式 | 含义 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `$("Element")` | Selects all elements with the given tag name | `$("p")`
    selects all the `p` tags.`$("body")` selects the `body` tag. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `$("Element")` | 选择所有具有给定标签名的元素 | `$("p")` 选择所有 `p` 标签。`$("body")` 选择 `body`
    标签。|'
- en: '| `$("#id")` | Selects the element with the given ID of the attribute | Consider
    the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '| `$("#id")` | 选择具有给定 ID 属性的元素 | 考虑以下代码：'
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`$("#box1")` selects the highlighted element. |'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`$("#box1")` 选择高亮显示的元素。|'
- en: '| `$(".className")` | Selects all elements with the given class attribute |
    Consider the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '| `$(".className")` | 选择所有具有给定类属性的元素 | 考虑以下代码：'
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`$(".apple")` selects the highlighted elements with `class` set to `apple`.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(".apple")` 选择设置了 `class` 为 `apple` 的高亮显示元素。|'
- en: '| `$("selector1, selector2, selectorN")` | Selects all elements that match
    the given selector | Consider the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '| `$("selector1, selector2, selectorN")` | 选择所有匹配给定选择器的元素 | 考虑以下代码：'
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`$(".apple,` `.orange")` selects the highlighted elements that `class` is set
    to, either `apple` or `orange`. |'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(".apple,` `.orange")` 选择 `class` 设置为 `apple` 或 `orange` 的高亮显示元素。|'
- en: Understanding the jQuery CSS function
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 jQuery CSS 函数
- en: The jQuery `css` function works to get and set the CSS properties of the selected
    elements. This is known as getting and setting pattern where many jQuery functions
    follow.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的 `css` 函数用于获取和设置所选元素的 CSS 属性。这被称为获取和设置模式，许多 jQuery 函数都遵循这种模式。
- en: 'Here is a general definition of how to use the `css` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 `css` 函数的一般定义：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `css` function accepts several types of arguments as listed in the following
    table:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`css` 函数接受以下表格中列出的几种类型的参数：'
- en: '| Function type | Arguments definitions | Discussion |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 函数类型 | 参数定义 | 讨论内容 |'
- en: '| --- | --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `.css(propertyName)` | `propertyName` is a CSS property | The function returns
    the value of the given CSS property of the selected element.For example, the following
    code returns the value of the `background-color` property of the `body` element:`$("body").css("background-color")`It
    will only read the value and not modify the property value. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `.css(propertyName)` | `propertyName` 是一个 CSS 属性 | 该函数返回所选元素的给定 CSS 属性的值。例如，以下代码返回
    `body` 元素的 `background-color` 属性的值：`$("body").css("background-color")` 它只会读取值，而不会修改属性值。|'
- en: '| `css(propertyName,` `value)` | `propertyName` is a CSS property, and `value`
    is a value to set for the property. | The function modifies the given CSS property
    to the given value.For example, the following code sets the background color of
    all elements with the `box` class to red:`$(".box").css("background-color","#ff0000")`
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `css(propertyName, value)` | `propertyName` 是一个 CSS 属性，`value` 是为该属性设置的值。
    | 该函数将给定的 CSS 属性修改为给定的值。例如，以下代码将所有具有 `box` 类的元素的背景颜色设置为红色：`$(".box").css("background-color","#ff0000")`
    |'
- en: Manipulating game elements in DOM with jQuery
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 jQuery 在 DOM 中操作游戏元素
- en: We initialized the paddles' game elements with jQuery. We will do an experiment
    on how we should use jQuery to place the game elements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 jQuery 初始化了球拍的游戏元素。我们将进行一个实验，看看我们应该如何使用 jQuery 来放置游戏元素。
- en: Understanding the behavior of absolute position
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解绝对定位的行为
- en: 'When a DOM node is set to be at the `absolute` position, the left and top properties
    can be treated as a **coordinate**. We can treat the left/top properties into
    X/Y coordinates with Y positive pointing down. The following graphs show the relationship.
    The left side is the actual CSS value, and the right side is the coordinate system
    in our mind when programming the game:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 DOM 节点被设置为 `absolute` 位置时，left 和 top 属性可以被视为一个 **坐标**。我们可以将 left/top 属性视为
    X/Y 坐标，其中 Y 轴正方向向下。以下图表显示了它们之间的关系。左侧是实际的 CSS 值，右侧是我们编程游戏时的心理坐标系：
- en: '![Understanding the behavior of absolute position](img/B04290_02_06.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![理解绝对定位的行为](img/B04290_02_06.jpg)'
- en: By default, the left and top properties refer to the top-left edge of the web
    page. This reference point is different when any parent of this DOM node has a
    `position` style set explicitly to `relative` or `absolute`. The reference point
    of the left and top properties becomes the top-left edge of that parent.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，left 和 top 属性指的是网页的左上角。如果此 DOM 节点的任何父节点明确设置了 `position` 样式为 `relative`
    或 `absolute`，则这个参考点就不同了。left 和 top 属性的参考点变为该父节点的左上角。
- en: 'This is why we need to set the game with a relative position and all game elements
    inside it with an absolute position. The following code snippet from our example
    shows the position values of the elements:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要将游戏设置为相对位置，并将所有游戏元素设置为绝对位置。以下是我们示例中的代码片段，显示了元素的定位值：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Declaring global variables in a better way
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以更好的方式声明全局变量
- en: '**Global variables** are variables that can be accessed globally in the entire
    document. Any variable that is declared outside any function is a global variable.
    For instance, in the following example code snippet, `a` and `b` are global variables,
    while `c` is a **local variable** that only exists inside the function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局变量** 是可以在整个文档中访问的变量。任何在函数外部声明的变量都是全局变量。例如，在以下示例代码片段中，`a` 和 `b` 是全局变量，而
    `c` 是一个 **局部变量**，它只存在于函数内部：'
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since global variables are available in the entire document, they may increase
    the chance of variable name conflicts if we integrate different JavaScript libraries
    into the same web page. As good practice, we should minimize the use of global
    variables.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于全局变量在整个文档中都是可用的，如果我们将不同的 JavaScript 库集成到同一个网页中，它们可能会增加变量名冲突的机会。作为良好的实践，我们应该尽量减少全局变量的使用。
- en: In the preceding *Time for action* section, we have an object to store the game
    data. Instead of just putting this object in the global scope, we created an object
    named `pingpong` and put the data inside it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 *行动时间* 部分，我们有一个对象来存储游戏数据。我们不是仅仅把这个对象放在全局作用域中，而是创建了一个名为 `pingpong` 的对象，并将数据放在里面。
- en: Moreover, when we put all our logic into a self-executing function, as we discussed
    in the last section, we make the game's data object locally inside the function
    scope.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们像上一节讨论的那样将所有逻辑放入自执行函数中时，我们使游戏的数据对象在函数作用域内局部化。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Declaring variables without `var` puts the variables in the global scope even
    when they are defined inside a function scope. So, we always declare variables
    with `var`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数作用域内声明变量而不使用 `var`，即使变量是在函数作用域内定义的，也会将变量放入全局作用域。因此，我们总是使用 `var` 声明变量。
- en: Pop quiz
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验
- en: Q1\. Which jQuery selector is to be used if you want to select all header elements?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 如果你想选择所有标题元素，应该使用哪个 jQuery 选择器？
- en: '`$("#header")`'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$("#header")`'
- en: '`$(".header")`'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$(".header")`'
- en: '`$("header")`'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$("header")`'
- en: '`$(header)`'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$(header)`'
- en: Getting mouse input
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取鼠标输入
- en: You learned how to display game objects with CSS and jQuery in the previous
    sections. The next thing we need to create in the game is a way to get input from
    the players. We will discuss about the mouse input in this section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您学习了如何使用CSS和jQuery显示游戏对象。接下来，我们需要在游戏中创建一种从玩家那里获取输入的方法。在本节中，我们将讨论鼠标输入。
- en: Time for action – moving DOM objects by mouse input
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 通过鼠标输入移动DOM对象
- en: 'We are going to create a traditional Ping Pong game. There is a paddle on both
    the left and right sides of the playground. A ball is placed in the middle of
    the playground. Players can control the right paddle and move it up and down by
    using the mouse. We will focus on the mouse input and leave the ball movement
    for a later section:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建一个传统的乒乓球游戏。游乐场的左右两侧都有一个挡板。一个球放在游乐场的中间。玩家可以通过使用鼠标控制右侧的挡板，上下移动它。我们将专注于鼠标输入，并将球的运动留到后面的章节：
- en: Let's continue with our `pingpong` directory.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续我们的`pingpong`目录。
- en: 'Next, add a `playground` object inside the `pingpong` data object in the `js/pingpong.js`
    file. This stores variables that are related to `playground`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`js/pingpong.js`文件中的`pingpong`数据对象内添加一个`playground`对象。这个对象存储与`playground`相关的变量：
- en: '[PRE21]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, create the following function that handles the mouse''s enter, move,
    and leave events, and place it inside the `js/pingpong.js` file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建以下处理鼠标的进入、移动和离开事件的函数，并将其放置在`js/pingpong.js`文件中：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We had the `renderPaddles` function in the previous section. In this section,
    we are defining a `render` function and calling the paddles rendering logic. We
    then call the `render` function on the next browser redraw via the `requestAnimationFrame`
    function.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一节中，我们有了`renderPaddles`函数。在本节中，我们定义了一个`render`函数，并调用paddle渲染逻辑。然后我们通过`requestAnimationFrame`函数在下一个浏览器重绘时调用`render`函数。
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, we create an `init` function to execute the initial logic.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`init`函数来执行初始逻辑。
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, you need to call the `init` function that starts our game logic:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要调用`init`函数来启动我们的游戏逻辑：
- en: '[PRE25]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's test the `paddle` control of the game. Open the `index.html` page in the
    web browser. Try moving the mouse up and down within the playground area. The
    right paddle should follow your mouse's movement.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试游戏中的`paddle`控制。在网页浏览器中打开`index.html`页面。尝试在游乐场区域内上下移动鼠标。右侧的挡板应该跟随鼠标的移动。
- en: '*What just happened?*'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We handled the mouse events to move the paddle based on the mouse position.
    You can play the current work-in-progress version of the game at [http://makzan.net/html5-games/pingpong-wip-step3/](http://makzan.net/html5-games/pingpong-wip-step3/).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理了鼠标事件，根据鼠标位置移动paddle。您可以在[http://makzan.net/html5-games/pingpong-wip-step3/](http://makzan.net/html5-games/pingpong-wip-step3/)上玩当前正在开发的游戏版本。
- en: Getting the mouse event
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取鼠标事件
- en: jQuery provides several handy mouse events, and the most basic ones are click,
    mouse down and mouse up. We track the mouse enter and mouse leave event to start
    and pause the game. We also use the mouse move event to get the mouse position
    and update the paddle position based on the mouse position on the playground section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了几个实用的鼠标事件，其中最基本的是点击、鼠标按下和鼠标抬起。我们跟踪鼠标进入和鼠标离开事件来开始和暂停游戏。我们还使用鼠标移动事件来获取鼠标位置，并根据游乐场区域的鼠标位置更新paddle位置。
- en: We need to get the *y* position of the cursor based on the playground's top
    left edge. The value of `Y` in the mouse event is the mouse cursor from the page's
    top left edge. We then subtract the position of the playground via `$("#playground").offset().top`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要根据游乐场的左上角来获取光标的`y`位置。鼠标事件中的`Y`值是鼠标光标从页面左上角的位置。然后我们通过`$("#playground").offset().top`减去游乐场的位置。
- en: We update the data of paddle's `Y` value by using the mouse's `X` and `Y` values.
    This value will eventually reflect on the screen when the paddle view is updated
    in the `render` function during the browser redraw.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用鼠标的`X`和`Y`值来更新paddle的`Y`值数据。当在浏览器重绘期间，`render`函数更新paddle视图时，这个值最终会在屏幕上反映出来。
- en: RequestAnimationFrame
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RequestAnimationFrame
- en: The time interval is used to execute the game loop. The `game` loop calculates
    the game logic, which calculates the movement of the game objects.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 时间间隔用于执行游戏循环。`game`循环计算游戏逻辑，计算游戏对象的运动。
- en: The `requestAnimationFrame` feature is used to update the view according to
    the data. We use the `requestAnimationFrame` feature to update the view because
    the view only needs to update in an optimal scenario, where the browser decides.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`功能用于根据数据更新视图。我们使用`requestAnimationFrame`功能来更新视图，因为视图只需要在浏览器决定的最佳场景中更新。'
- en: The interval of `requestAnimationFrame` is not fixed. When the browser is at
    the front end, the `requestAnimationFrame` feature would run often. When the battery
    is low or the browser is in the background, the browser would slow down the frequency
    of execution of the `requestAnimationFrame` feature.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`的间隔不是固定的。当浏览器处于前端时，`requestAnimationFrame`功能会频繁运行。当电池电量低或浏览器处于后台时，浏览器会降低`requestAnimationFrame`功能的执行频率。'
- en: We are using `RequestAnimationFrame` only on view-related logic. In a later
    section, we will need to handle game data calculation. For data calculation, we
    will use `setInterval` because the `setInterval` function always executes in a
    fixed time interval. That's why we use the `setInterval` function for the game
    logic calculation and animation frame for view rendering.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只使用`RequestAnimationFrame`来处理与视图相关的逻辑。在后面的部分，我们需要处理游戏数据计算。对于数据计算，我们将使用`setInterval`，因为`setInterval`函数总是在固定的时间间隔内执行。这就是为什么我们使用`setInterval`函数进行游戏逻辑计算，而使用动画帧进行视图渲染。
- en: Checking the console window
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查控制台窗口
- en: We are writing more complicated logic code now. It is good practice to keep
    an eye on the console of the **Developers Tools**. You may toggle between the
    developer tools by pressing *F12* in Windows or *command* + *option* + *I* on
    Mac OS. If the code contains any error or warning, the error message will appear
    there. It reports any found error and the line of code that contains the error.
    It is very useful and important to have the console window open when testing HTML5
    games. I have often seen people get stuck and have no idea as to why the code
    is not working. The reason for this is that they have a typo or syntax error,
    and they did not check the console window before fighting with the code for hours.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在编写更复杂的逻辑代码。保持对**开发者工具**控制台的关注是一个好习惯。您可以通过在Windows上按*F12*或在Mac OS上按*command*
    + *option* + *I*来切换开发者工具。如果代码中包含任何错误或警告，错误信息将出现在那里。它报告任何找到的错误以及包含错误的代码行。在测试HTML5游戏时，打开控制台窗口非常有用且重要。我经常看到人们陷入困境，不知道代码为什么不起作用。原因可能是他们有拼写错误或语法错误，并且在几个小时与代码斗争之前没有检查控制台窗口。
- en: 'The following screenshot shows that there is an error in the twenty-fifth line
    of the `js/pingpong.js` file. The error message is **Invalid left-hand side in
    assignment**. After inspecting the code, I found that I wrongly used an equal
    sign (`=`) when setting the CSS `top` property in jQuery:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示，在`js/pingpong.js`文件的第二十五行存在一个错误。错误信息是**赋值中的左侧无效**。在检查代码后，我发现我在设置jQuery中的CSS
    `top`属性时错误地使用了等号（`=`）：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The error is displayed as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 错误显示如下：
- en: '![Checking the console window](img/B04290_02_07.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![检查控制台窗口](img/B04290_02_07.jpg)'
- en: Moving a DOM object with JavaScript Interval
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript间隔移动DOM对象
- en: Imagine now we can make the little red ball move around the playground. The
    ball will bounce away when it hits the paddles. The player will win a score when
    the ball passes the opponent's paddle and hits the playground edge behind the
    paddle. All these actions manipulate the position of the DIVs inside the HTML
    page by jQuery. To complete this Ping Pong game, our next step is to move the
    ball.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，现在我们可以让小红球在游乐场周围移动。当球击中挡板时，它会弹开。当球穿过对手的挡板并击中挡板后面的游乐场边缘时，玩家将获得分数。所有这些动作都是通过jQuery操作HTML页面内的DIV的位置来实现的。为了完成这个乒乓球游戏，我们的下一步是移动球。
- en: Time for action – Moving the ball with JavaScript Interval
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用JavaScript间隔移动球
- en: 'We will use the function to create a timer. The timer moves the ball a little
    bit every 30 milliseconds. We are going to also change the direction of the ball
    movement once it hits the playground edge. Let''s make the ball move now:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用该函数创建一个计时器。计时器每30毫秒移动球一点。我们还将改变球运动的方向，一旦它击中游乐场边缘。现在让我们让球移动起来：
- en: We will use our last example, listening to multiple keyboard inputs, as the
    starting point.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将以我们最后的例子，监听多个键盘输入，作为起点。
- en: Open the `js/pingpong.js` file in the text editor.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`js/pingpong.js`文件。
- en: In the existing `pingpong.playground` object, we change to the following code
    that adds height and width to the playground.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的 `pingpong.playground` 对象中，我们将其更改为以下代码，为游乐场添加高度和宽度。
- en: '[PRE27]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are now moving the ball, and we need to store the ball''s status globally.
    We will put the ball-related variable inside the `pingpong` object:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在正在移动球，并且需要全局存储球的状态。我们将球相关的变量放在 `pingpong` 对象中：
- en: '[PRE28]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We define a `gameloop` function and move the ball on each game loop iteration:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个 `gameloop` 函数，并在每个游戏循环迭代中移动球：
- en: '[PRE29]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We define the functions to check whether the ball is hitting the four boundary
    walls of the playground:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了检查球是否撞击游乐场四个边界墙的函数：
- en: '[PRE30]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then, we define two functions that reset the game after either player wins.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了两个函数，在任意玩家获胜后重置游戏。
- en: '[PRE31]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is time to define the `moveBall` function. The function checks the boundaries
    of the playground, changes the direction of the ball when it hits the boundaries,
    and sets the new ball position after all these calculations. Let''s put the following
    `moveBall` function definition in the JavaScript file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候定义 `moveBall` 函数了。该函数检查游乐场的边界，当球碰到边界时改变球的方向，并在所有这些计算之后设置新的球位置。让我们在 JavaScript
    文件中放置以下 `moveBall` 函数定义：
- en: '[PRE32]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have calculated the ball's movement. Next, we want to render the view to
    update the ball's position based on the data. To do this, define a new `renderBall`
    function with the following code.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经计算了球的移动。接下来，我们想要渲染视图，根据数据更新球的位置。为此，定义一个新的 `renderBall` 函数，如下所示。
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we need to update the `render` function to render the ball''s update based
    on the updated game data:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新 `render` 函数，以便根据更新的游戏数据渲染球的更新：
- en: '[PRE34]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following lines of code is the new `init` function where we added a `gameloop`
    logic with the `setInterval` function:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行是新的 `init` 函数，我们在其中使用 `setInterval` 函数添加了 `gameloop` 逻辑：
- en: '[PRE35]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have prepared the code to move the ball every 33.3 milliseconds. Save all
    the files and open `index.html` in the web browser to test it. The paddles work
    just as in the last example, and the ball should be moving around the playground.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好了每 33.3 毫秒移动一次球的代码。保存所有文件，并在网络浏览器中打开 `index.html` 以测试它。球拍的工作方式与上一个例子一样，球应该在游乐场周围移动。
- en: '*What just happened?*'
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just successfully made the ball move around the playground. We have a loop
    to run routine game logic 30 times per second. Inside that game loop, we moved
    the ball five pixels at a time. You can try the game and view the code in progress
    at [http://makzan.net/html5-games/pingpong-wip-step6/](http://makzan.net/html5-games/pingpong-wip-step6/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚成功使球在游乐场周围移动。我们有一个每秒运行 30 次常规游戏逻辑的循环。在这个游戏循环中，我们每次移动球 5 像素。你可以尝试游戏，并在 [http://makzan.net/html5-games/pingpong-wip-step6/](http://makzan.net/html5-games/pingpong-wip-step6/)
    上查看正在进行的代码。
- en: 'There are three properties of the ball: speed, and the *x* and *y* directions.
    Speed defines how many pixels the ball moves in each step. The direction X/Y is
    either 1 or -1\. We move the ball using the following equation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 球有三个属性：速度、以及 *x* 和 *y* 方向。速度定义了球在每一步移动多少像素。X/Y 方向的值要么是 1，要么是 -1。我们使用以下方程来移动球：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The direction value is multiplied by the movement. When the direction is 1,
    the ball moves to the positive direction of the axis. When the direction is `-1`,
    the ball moves to the negative direction. By toggling the *x* and *y* directions,
    we can move the ball in four directions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 方向值乘以移动量。当方向是 1 时，球向轴的正方向移动。当方向是 `-1` 时，球向轴的负方向移动。通过切换 *x* 和 *y* 方向，我们可以使球在四个方向上移动。
- en: We compare the ball's `X` and `Y` values with the four edges of the playground
    DIV element. This checks whether the ball's next position is beyond the boundary,
    and then, we toggle the direction between 1 and -1 to create the bouncing effect.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将球的 `X` 和 `Y` 值与游乐场 DIV 元素的四个边缘进行比较。这检查球的下一个位置是否超出边界，然后，我们在 1 和 -1 之间切换方向以创建反弹效果。
- en: Creating a JavaScript timer with the setInterval function
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 setInterval 函数创建 JavaScript 计时器
- en: We have a timer to loop and move the ball periodically. This can be done by
    the `setInterval` function in JavaScript.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个计时器来循环并定期移动球。这可以通过 JavaScript 中的 `setInterval` 函数来完成。
- en: 'Here is the general definition of the `setInterval` function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `setInterval` 函数的一般定义：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `setInterval` takes two required arguments. Additional arguments are passed
    into the function as parameters:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval` 函数需要两个必需的参数。额外的参数作为参数传递给函数：'
- en: '| Argument | Definition | Discussion |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `expression` | The function callback or code expression to be executed |
    The expression can be a reference of a function callback or an inline code expression.
    The inline code expression is quoted and a reference of function callback is not.For
    example, the following code calls the `hello` function every 100 milliseconds:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '| `expression` | 要执行的功能回调或代码表达式 | 表达式可以是一个功能回调的引用或内联代码表达式。内联代码表达式用引号引用，而功能回调的引用则不用。例如，以下代码每100毫秒调用一次`hello`函数：'
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following code calls the `hi` function with parameters every 100 milliseconds:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码每100毫秒调用一次`hi`函数，并传递参数：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `milliseconds` | The duration between every execution of the expression,
    in milliseconds | The unit of the interval is in milliseconds. Therefore, setting
    it to 1000 means running the expression every second. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `milliseconds` | 表达式每次执行之间的持续时间，以毫秒为单位 | 间隔的单位是毫秒。因此，将其设置为1000意味着每秒运行一次表达式。
    |'
- en: Understanding the game loop
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解游戏循环
- en: We have a timer to execute some game-related code every 33.3 milliseconds, so
    this code is executed 30 times per second. This frequency is known as frames per
    second, or FPS. In game development, this timer is called the **game loop**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个计时器，每33.3毫秒执行一些与游戏相关的代码，因此这些代码每秒执行30次。这种频率被称为每秒帧数，或FPS。在游戏开发中，这个计时器被称为**游戏循环**。
- en: 'There are several common things that we will execute inside a game loop:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环中，我们将执行几个常见操作：
- en: Processing user input, which we just did
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户输入，这是我们刚才做的
- en: Updating game objects' status, including position and appearance
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新游戏对象的状态，包括位置和外观
- en: Checking game over
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查游戏是否结束
- en: What is actually executing in the game loop differs in different types of games,
    but the purpose is the same. The game loop is executed periodically to calculate
    the game data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环中实际执行的内容在不同类型的游戏中有所不同，但目的相同。游戏循环定期执行以计算游戏数据。
- en: Separating the data and the view logic
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离数据和视图逻辑
- en: We have separated the data and the view logic. We used `setInterval` for data
    and `requestAnimationFrame` for view rendering. The data focuses on all the game
    data calculation, including an object's dimension and position based on the calculation.
    The `view` logic focuses on updating the interface based on the keep-updating
    game data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经分离了数据和视图逻辑。我们使用`setInterval`处理数据，使用`requestAnimationFrame`进行视图渲染。数据专注于所有游戏数据的计算，包括基于计算的对象尺寸和位置。`视图`逻辑专注于根据不断更新的游戏数据更新界面。
- en: In our render function, the view updates the CSS of the DOM elements. Imagine
    later if we are rendering the game in the Canvas, or using any other techniques,
    that our view rendering logic can use a specific method to render the view based
    on the same game data. The game data's calculation is independent to the techniques
    we use to render the game interface.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的渲染函数中，视图更新DOM元素的CSS。想象一下，如果我们稍后要在Canvas中渲染游戏或使用任何其他技术，我们的视图渲染逻辑可以使用特定方法根据相同的游戏数据渲染视图。游戏数据的计算独立于我们用于渲染游戏界面的技术。
- en: Beginning collision detection
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始碰撞检测
- en: We have checked the boundary of the playground when moving the ball in the previous
    section. Now, we can control the paddles with the keyboard and watch the ball
    move around the playground. What is missing now? We cannot interact with the ball.
    We control the paddles but the ball just passes through them as if they are not
    there. This is because we missed the collision detection between the paddles and
    the moving ball.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中移动球时，我们已经检查了游乐场的边界。现在，我们可以用键盘控制拍子，并观察球在游乐场中移动。现在缺少什么？我们无法与球互动。我们控制拍子，但球就像它们不存在一样穿过它们。这是因为我们遗漏了拍子和移动球之间的碰撞检测。
- en: Time for action – hitting the ball with the paddles
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 用拍子击球
- en: 'We will use an approach, similar to that of checking the boundary, to check
    the collision:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类似于检查边界的检查方法来检查碰撞：
- en: Open the `js/pingpong.js` file that we used in the previous section.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在上一节中使用的`js/pingpong.js`文件。
- en: In the `moveBall` function, we have already reserved the place to put the collision
    detection code there. Find the line with `//` `check` `paddles` `here`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`moveBall`函数中，我们已经在那里预留了放置碰撞检测代码的位置。找到带有`//` `check` `paddles` `here`的行。
- en: 'Let''s put the following code there. The code checks whether the ball is overlapping
    with either paddle and bounces the ball away when they overlap:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把以下代码放在那里。该代码检查球是否与任一拍子重叠，并在它们重叠时将球弹开：
- en: '[PRE40]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Test the game in a browser and the ball will now bounce away after hitting the
    left or right paddle. It will also reset to the center of the playground when
    it hits the left or right edge of the playground.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中测试游戏，球现在在击中左右球拍后会弹开。当它击中游乐场的左右边缘时，它也会重置到游乐场的中心。
- en: '*What just happened?*'
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We have modified the ball by making it bounce away when it overlaps with the
    paddles. Let's see how we check the collision between the ball and the left paddle.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使球在重叠球拍时弹开来修改了球。让我们看看我们是如何检查球和左球拍之间的碰撞的。
- en: At first, we check whether the ball's *x* position is less than the left paddle's
    right edge. The right edge is the `left` value plus the `width` of the paddle.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查球的 *x* 位置是否小于左球拍的右边沿。右边沿是 `left` 值加上球拍的 `width`。
- en: '![What just happened?](img/B04290_02_08.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04290_02_08.jpg)'
- en: Then, we check whether the ball's *y* position is between the top edge and bottom
    edge of the paddle. The top edge is the `top` value and the bottom edge is the
    `top` value plus the `height` of the paddle.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查球的 *y* 位置是否在球拍的上边缘和下边缘之间。上边缘是 `top` 值，下边缘是 `top` 值加上球拍的 `height`。
- en: '![What just happened?](img/B04290_02_09.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04290_02_09.jpg)'
- en: We bounce the ball away if the ball's position passes both the checks. This
    is how we check it, and it is just a basic collision detection.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球的位置通过了这两个检查，我们就让球弹开。这就是我们检查它的方法，它只是一个基本的碰撞检测。
- en: We determine that the two objects are overlapped by checking their position
    and width/height. This type of collision detection works well in rectangle objects
    but is not good for circles and other shapes. The following screenshot illustrates
    the issue. The collision areas shown in the following graph are false positive.
    Their bounding box collides but the actual shapes do not overlap each other. This
    is a classic and efficient way to check for collisions. It may not be very accurate
    but its calculation is fast.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查它们的位置和宽/高来确定两个对象是否重叠。这种碰撞检测在矩形对象中效果很好，但不适用于圆形和其他形状。下面的截图说明了问题。以下图中显示的碰撞区域是假阳性。它们的边界框发生碰撞，但实际形状并没有重叠。这是一个经典且高效的方法来检查碰撞。它可能不是很准确，但计算速度快。
- en: '![What just happened?](img/B04290_02_10.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04290_02_10.jpg)'
- en: For special shapes, we will need more advanced collision detection techniques,
    which we will discuss later.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特殊形状，我们需要更高级的碰撞检测技术，我们将在后面讨论。
- en: Have a go hero
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: We have placed two paddles on the playground. How about we make the game more
    challenging by having an alternative paddle in the middle field? It's like having
    the goalkeeper and forwards in a soccer machine.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在游乐场上放置了两个球拍。我们为什么不通过在中间场地上添加一个替代球拍来使游戏更具挑战性呢？这就像在足球机器中拥有守门员和前锋一样。
- en: Controlling the left paddle movement
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制左球拍的运动
- en: The computer controls the left paddle. We would like to create a function that
    makes the left paddle chase the ball.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机控制左球拍。我们希望创建一个函数，使左球拍追逐球。
- en: Time for action – auto moving the left paddle
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候自动移动左球拍了
- en: 'Perform the following set of actions for automoving our paddle:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为自动移动我们的球拍执行以下操作：
- en: Let's continue with our `pingpong.js` JavaScript file. We create a function
    that follows the ball's *y* position.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续使用我们的 `pingpong.js` JavaScript 文件。我们创建一个函数来跟踪球的 *y* 位置。
- en: '[PRE41]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Then, inside the game loop function, we call our `autoMovePaddleA` function.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在游戏循环函数内部，我们调用我们的 `autoMovePaddleA` 函数。
- en: '[PRE42]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What just happened?
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We created a logic that moves the left paddle based on the ball's *y* position.
    You may try the game with its current progress at [http://makzan.net/html5-games/pingpong-wip-step6/](http://makzan.net/html5-games/pingpong-wip-step6/).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个基于球的 *y* 位置的逻辑来移动左球拍。你可以尝试使用当前进度在 [http://makzan.net/html5-games/pingpong-wip-step6/](http://makzan.net/html5-games/pingpong-wip-step6/)
    玩游戏。
- en: Since we have already implemented the view rendering in the `renderPaddles`
    function, in this section, we only need to update the paddle's data and the view
    will get updated automatically.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在 `renderPaddles` 函数中实现了视图渲染，在这个部分，我们只需要更新球拍的数据，视图将自动更新。
- en: We make the paddle speed slower than the ball's speed. Otherwise, the player
    can never win against the computer, because the computer-controlled paddle can
    always catch the ball and bounce it back if they have the same speed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使球拍的速度慢于球的速度。否则，玩家永远无法战胜电脑，因为电脑控制的球拍可以始终接住球并将其弹回，如果它们具有相同的速度。
- en: Showing text dynamically in HTML
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 HTML 中动态显示文本
- en: We have implemented the basic game mechanics in the previous sections. Our Ping
    Pong game is missing a scoring board that shows both players' scores. We discussed
    how to use jQuery to modify the CSS styles of the selected elements. Can we also
    alter the content of the selected elements with jQuery? Yes, we can.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经实现了基本的游戏机制。我们的乒乓球游戏缺少一个显示两名玩家分数的记分板。我们讨论了如何使用 jQuery 修改所选元素的 CSS
    样式。我们也可以使用 jQuery 修改所选元素的内容吗？是的，我们可以。
- en: Time for action – Showing the score of both players
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 显示两名玩家的分数
- en: 'We are going to create a text-based scoreboard and update the scores when either
    player scores a goal:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个基于文本的记分板，并在任何一名球员得分时更新分数：
- en: We are making improvements on our existing game so that we can use the last
    example as the starting point.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在改进现有的游戏，以便我们可以使用最后一个示例作为起点。
- en: Open the `index.html` in the text editor. We are going to add the scoreboard's
    DOM elements.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 `index.html`。我们将添加记分板的 DOM 元素。
- en: 'Add the `#scoreboard` HTML structure to our `#game` DIV inside index.html.
    The `#game` DIV becomes the following:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `#scoreboard` HTML 结构添加到 index.html 中的 `#game` DIV 内。`#game` DIV 变成以下形式：
- en: '[PRE43]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, let's move onto the JavaScript part. Open the `js/pingpong.js` file.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转到 JavaScript 部分。打开 `js/pingpong.js` 文件。
- en: 'We need two more variables to store the players'' scores. Add their score variables
    inside the existing `pingpong` data object:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要两个额外的变量来存储玩家的分数。在现有的 `pingpong` 数据对象中添加它们的分数变量：
- en: '[PRE44]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Find the `playerAWin` function. We increment player A''s score there and update
    the scoreboard with the following code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `playerAWin` 函数。我们在那里增加玩家 A 的分数并使用以下代码更新记分板：
- en: '[PRE45]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can add a code similar to that in the previous step to update player B''s
    score when player A is lost in the `playerBWin` function:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在上一步中添加类似的代码，在 `playerBWin` 函数中更新玩家 B 的分数，当玩家 A 失败时：
- en: '[PRE46]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s move onto the `css/pingpong.css` file. Put the following styles in the
    file to make the score board look nicer:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到 `css/pingpong.css` 文件。将以下样式放入文件，使记分板看起来更美观：
- en: '[PRE47]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is time to test our latest code. Open the `index.html` in a web browser.
    Try playing by controlling both paddles and lose some points. The scoreboard should
    be counting the scores correctly.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候测试我们最新的代码了。在网页浏览器中打开 `index.html`。尝试通过控制两个球拍来玩游戏并失去一些分数。记分板应该正确地计数。
- en: What just happened?
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'We just used another common jQuery function: `text()` to alter the content
    of the game on the fly.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用了另一个常见的 jQuery 函数：`text()` 来实时更改游戏内容。
- en: 'The `text()` function gets or updates the text content of the selected element.
    Here is a general definition of the `text`() function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`text()` 函数获取或更新所选元素的文本内容。以下是 `text()` 函数的一般定义：'
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When we use the `text()` function without an argument, it returns the text content
    of the match elements. When we use it with an argument, it sets the text content
    to all the matched elements with the given string.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用不带参数的 `text()` 函数时，它返回匹配元素的文本内容。当我们使用参数时，它将所有匹配元素的文本内容设置为给定的字符串。
- en: 'For example, provide the following HTML structure:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，提供以下 HTML 结构：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following jQuery calls return Makzan:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 jQuery 调用返回 Makzan：
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, in the following jQuery call, it sets all matched elements to the
    given HTML content:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在以下 jQuery 调用中，它将所有匹配元素设置为给定的 HTML 内容：
- en: '[PRE51]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Executing the jQuery command gives the following HTML result:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 jQuery 命令会得到以下 HTML 结果：
- en: '[PRE52]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Have a go hero – winning the game
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试 – 赢得游戏
- en: Imagine that the game is an advertisement. We set the entire game playground
    with pointer cursor so that the user knows the game is clickable and links to
    some other place. Try to use jQuery's `click` event and handle the advertisement
    that's linked to the `handleMouseInputs` function.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 假设游戏是一个广告。我们设置整个游戏游乐场使用指针光标，以便用户知道游戏是可点击的，并链接到其他地方。尝试使用 jQuery 的 `click` 事件处理链接到
    `handleMouseInputs` 函数的广告。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about the basic techniques of creating a simple
    Ping Pong game with HTML5 and JavaScript. Specifically, we created our first HTML5
    game—Ping Pong. In the game, we used jQuery to manipulate DOM objects. We were
    able to use the mouse event to get the cursor position. We used a very simple
    method to detect collisions with the bounding box. In the logic, we separated
    data manipulation and view rendering. We also discussed how to create a game loop
    and move the ball and paddles.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了使用HTML5和JavaScript创建简单乒乓球游戏的基本技巧。具体来说，我们创建了我们的第一个HTML5游戏——乒乓球。在游戏中，我们使用jQuery操作DOM对象。我们能够使用鼠标事件获取光标位置。我们使用一个非常简单的方法来检测与边界框的碰撞。在逻辑上，我们将数据处理和视图渲染分离。我们还讨论了如何创建游戏循环以及移动球和挡板。
- en: Now that we've warmed up by creating a simple DOM-based game, we are ready to
    create more advanced DOM-based games with new features from CSS3\. In the next
    chapter, we will create games with CSS3 transition and transformation.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过创建一个简单的基于DOM的游戏已经热身，我们准备使用CSS3的新特性来创建更高级的基于DOM的游戏。在下一章中，我们将创建使用CSS3过渡和变换的游戏。
