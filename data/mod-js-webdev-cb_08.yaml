- en: Expanding Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展您的应用程序
- en: 'In this chapter, we are going to focus on larger, more complex applications,
    adding recipes such as the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于更大、更复杂的应用程序，添加以下示例：
- en: Managing state with Redux
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux管理状态
- en: Doing async actions with redux-thunk
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用redux-thunk执行异步操作
- en: Adding routing with react-router
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用react-router添加路由
- en: Adding authorization to routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由中添加授权
- en: Code splitting for performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能的代码拆分
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous two chapters, we saw how to develop web applications with `React`,
    and endeavored to make them internationally usable, accessible for everybody,
    and nicely styled to boot. In this chapter, we'll add some more features, which
    are typical of most applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们看到了如何使用`React`开发Web应用程序，并努力使它们国际化可用，对每个人都可访问，并且样式良好。在本章中，我们将添加一些更多的功能，这些功能是大多数应用程序的典型功能。
- en: Managing state with Redux
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redux管理状态
- en: What's difficult about building an application? Obviously, you can do anything
    with plain, vanilla JS, but things start getting hairy when you try to keep the
    UI and the state of the application in sync. You call services, you get data.
    Data must be reflected in several places, HTML elements must be changed, added,
    or removed, and so on—this is where the complexity lies.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序有什么困难？显然，您可以使用纯粹的JS做任何事情，但当您尝试保持应用程序的UI和状态同步时，事情开始变得复杂。您调用服务，获取数据。数据必须在多个位置反映，HTML元素必须更改、添加或删除等等——这就是复杂性所在。
- en: 'So far, we''ve been working only with state in components, and you could very
    well keep doing so: your top level component''s state will include everything
    you need, and you''d be able to manage by passing everything you need as props
    to the components below. Of course, as your application grows, this won''t scale
    very well. What''s the tipping point? `Redux` is a tool to manage state, but its
    own developers suggest that you should use their package if and only if you fulfill
    the following conditions, and I quote from [https://redux.js.org/#before-proceeding-further](https://redux.js.org/#before-proceeding-further):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在组件中处理状态，您完全可以继续这样做：您顶层组件的状态将包括您需要的一切，您可以通过将一切需要的内容作为props传递给下面的组件来管理。当然，随着应用程序的增长，这种方法将不太可行。什么时候会出现临界点？`Redux`是一个管理状态的工具，但其开发人员建议只有在满足以下条件时才使用他们的软件包，我引用自[https://redux.js.org/#before-proceeding-further](https://redux.js.org/#before-proceeding-further)：
- en: <q class="calibre43">"You have reasonable amounts of data changing over time."</q>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <q class="calibre43">“您有合理数量的数据随时间变化。”</q>
- en: <q class="calibre43">"You need a single source of truth for your state."</q>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <q class="calibre43">“您需要一个状态的单一真相来源。”</q>
- en: <q class="calibre43">"You find that keeping all your state in a top-level component
    is no longer sufficient."</q>
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <q class="calibre43">“您会发现将所有状态保留在顶层组件中已不再足够。”</q>
- en: Of course, these rules are not really precise, and allow for subjectivity, so
    there's no clear-cut point at which you'll *have* to use `Redux`. However, for
    most modern large scale applications, it's quite safe to say that `Redux` will
    probably come in handy, so let's assume that for the rest of this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些规则并不是非常明确，并且允许主观性，因此没有明确的点需要使用`Redux`。然而，对于大多数现代大型应用程序来说，可以肯定地说`Redux`可能会派上用场，因此让我们在本章的其余部分假设如此。
- en: In this recipe, we'll install `Redux`, and start to see how to work with it
    in `React`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将安装`Redux`，并开始看看如何在`React`中使用它。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before anything else, we must install a couple of packages: `redux`, the state-managing
    package itself, and the `react-redux` bindings for using `Redux` with `React`.
    (You can use `Redux` with other frameworks or libraries, but this is not covered
    in this book.) Installation is simple, just use `npm`, as we have done several
    times before:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他操作之前，我们必须安装一些软件包：`redux`，状态管理软件包本身，以及用于在`React`中使用`Redux`的`react-redux`绑定。（您可以在其他框架或库中使用`Redux`，但本书不涵盖此内容。）安装很简单，只需使用`npm`，就像我们以前做过的那样：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll have to learn several concepts in order to use `Redux`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须学习几个概念才能使用`Redux`：
- en: '*Store*: The only place ("single source of truth") where you hold the application
    state. You create the store globally, at the beginning of your application, and
    then you *connect* components to it. Connected components will get re-rendered
    when the state changes, and everything they need to render themselves should come
    from the store. The store can only be updated through actions.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储*: 应用程序状态的唯一位置（“单一真相来源”）。您在应用程序开始时全局创建存储，然后将组件*连接*到它。连接的组件在状态更改时将重新呈现，并且它们渲染所需的一切都应该来自存储。存储只能通过操作进行更新。'
- en: '*Actions*: Objects that your components *dispatch* with any new data you wish.
    Actions always have a `type` attribute to distinguish different types, and any
    other data, with no restriction. Actions are usually created by *action creators* to
    simplify coding, and after being dispatched they are processed by reducers.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*操作*: 您的组件*dispatch*的对象，其中包含您希望的任何新数据。操作始终具有`type`属性以区分不同类型，并且没有限制的任何其他数据。操作通常由*操作创建者*创建以简化编码，并在被调度后由减速器处理。'
- en: '*Reducers*: Pure functions (meaning, no side effects!) that change the application''s
    state, depending on the data received in actions. The state is never modified;
    rather, a new state must be produced with whichever changes were necessary. The
    reducer produces a new state as a function of the old state and the data received
    in the action.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减速器*: 纯函数（意味着没有副作用！）根据操作接收的数据改变应用程序的状态。状态永远不会被修改；而是必须产生一个新状态，其中包含必要的任何更改。减速器根据旧状态和操作中接收的数据产生新状态。'
- en: 'This is shown in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下图表中显示：
- en: '![](img/9dd5a133-27e4-4945-a705-a4ac6f449bc2.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dd5a133-27e4-4945-a705-a4ac6f449bc2.png)'
- en: Data flow in Redux is strictly uni-directional, always following a circular
    pattern
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Redux中的数据流是严格单向的，始终遵循循环模式
- en: Using this flow cycle helps keep the state and the view in sync—since the latter
    is produced in terms of the former, and all updates to the state immediately cause
    the view to be updated. We have installed the necessary tools to use, and we know
    what we have to do; now, let's get to an actual example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种流程循环有助于保持状态和视图同步-因为后者是根据前者产生的，并且对状态的所有更新立即导致视图更新。我们已经安装了必要的工具，并且知道我们必须做什么；现在，让我们开始一个实际的例子。
- en: You may want to look at `eslint-plugin-redux`, which gives you some rules for
    how to get the best out of `Redux`. Check it out at [https://github.com/DianaSuvorova/eslint-plugin-react-redux](https://github.com/DianaSuvorova/eslint-plugin-react-redux),
    and if you're interested, add some or all of its rules to your `ESLint` configuration;
    by default, they are all disabled.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望查看`eslint-plugin-redux`，它为您提供了如何充分利用`Redux`的一些规则。在[https://github.com/DianaSuvorova/eslint-plugin-react-redux](https://github.com/DianaSuvorova/eslint-plugin-react-redux)上查看它，如果您感兴趣，将其一些或全部规则添加到您的`ESLint`配置中；默认情况下，它们都是禁用的。
- en: In this recipe, let's do a simple example to show most of the concepts in the
    previous section. After reading multiple articles and tutorials on the web, I
    think it's mandatory to provide some kind of example involving a counter, and
    let's not break that tradition and do it here too! We want to have a counter that
    we can modify by clicking on some buttons, and we also want to know how many clicks
    we've made.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，让我们做一个简单的示例，展示前一节中大部分概念。在网上阅读了多篇文章和教程之后，我认为有必要提供涉及计数器的某种示例，并且让我们不要打破传统，在这里也做一下！我们想要一个可以通过点击按钮修改的计数器，并且我们还想知道我们点击了多少次。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Before we start writing the code, let''s have it in the open: we''ll be writing
    too many lines of code for what could have been easily solved *without* `Redux`—we
    won''t have a *reasonable amount of data changing over time* but only a couple
    of counts, and we certainly won''t *find that keeping all your state in a top-level
    component* isn''t good enough, but since we want a simple initial example, we''ll
    use `Redux` anyway.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，让我们公开：我们将为本可以轻松解决的问题编写太多行代码*而不需要* `Redux` - 我们不会有*合理数量的数据随时间变化*，而只有几个计数，我们肯定不会*发现将所有状态保留在顶级组件中*不够好，但由于我们想要一个简单的初始示例，我们仍然会使用`Redux`。
- en: Defining actions
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义动作
- en: 'First, we need some actions. We''ll want to increment and decrement the counter,
    and we''ll also want to reset it to zero. The first two requirements can be achieved
    with a single action (decrementing is just incrementing by a negative amount),
    so we''ll need two actions, each identified by a constant:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些动作。我们想要增加和减少计数器，我们还想将其重置为零。前两个要求可以通过单个动作实现（减少只是通过负数增加），所以我们需要两个动作，每个都由一个常量标识：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In fact, we should say that `increment()`, `decrement()`, and `reset()` are
    action creators; the actual actions are the values returned by those functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们应该说`increment()`，`decrement()`和`reset()`是动作创建者；这些函数返回的实际动作是值。
- en: Writing a reducer
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写reducer
- en: 'Then, after defining our actions, we need a reducer to process them. Of course,
    this also means that we have to define the shape of our state, and its initial
    value:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在定义我们的动作之后，我们需要一个reducer来处理它们。当然，这也意味着我们必须定义我们状态的形状和其初始值：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our reducer is basically a switch statement; when the right type is found, a
    new state is returned. This pattern is very important, and key to `Redux`. We
    don't simply update the state, but rather we produce a new state object every
    time. We need a default case because actions are passed to all reducers (not in
    our case, since we have a single one), so it's possible that a reducer will ignore
    an action.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的reducer基本上是一个switch语句；当找到正确的类型时，将返回一个新的状态。这种模式非常重要，也是`Redux`的关键。我们不仅仅更新状态，而是每次生成一个新的状态对象。我们需要一个默认情况，因为动作会传递给所有reducer（在我们的情况下不是这样，因为我们只有一个），所以可能会有一个reducer会忽略一个动作。
- en: In our example, we have a single reducer and a single set of actions, so it
    can be argued that they could all be placed together in the same file, but that's
    not likely with most applications. Furthermore, if your state grows too large,
    check out `combineReducers()` at [https://redux.js.org/api/combinereducers](https://redux.js.org/api/combinereducers),
    and you'll be able to work in a more organized way, with multiple reducers and
    a store divided into logical pieces.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们有一个单一的reducer和一组单一的动作，因此可以说它们都可以放在同一个文件中，但这在大多数应用程序中不太可能。此外，如果您的状态增长过大，请查看`combineReducers()`，并且您将能够以更有组织的方式工作，使用多个reducer和将store分成逻辑片段。
- en: Defining the store
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义store
- en: 'Then, after all the previous definitions, we can define our store:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在所有先前的定义之后，我们可以定义我们的store：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By the way, it's also possible to define the initial value for the state by
    passing it as a second parameter to `createStore()`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，还可以通过将其作为第二个参数传递给`createStore()`来定义状态的初始值。
- en: Building our components
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的组件
- en: 'Finally, having fully defined our store plus the actions that will be dispatched
    and the reducer that will process them, we can finish quickly by defining our
    components. Our `Counter` component will have text, the counter value, and a few
    buttons. Note that we are receiving `count` (the counter value) as a prop, and
    we also have a `dispatch()` function as yet another prop:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，完全定义了我们的store以及将要分派的动作和将处理它们的reducer，我们可以通过定义我们的组件来快速完成。我们的`Counter`组件将具有文本、计数器值和一些按钮。请注意，我们将`count`（计数器值）作为prop接收，并且我们还有一个`dispatch()`函数作为另一个prop：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each button dispatches an action that was created by the action creators that
    we saw earlier.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都会分派一个动作，这个动作是由我们之前看到的动作创建者创建的。
- en: 'We need a second component. The `ClicksDisplay` component is even simpler!
    We receive the total number of `clicks` as a prop, and we simply display it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要第二个组件。`ClicksDisplay`组件更简单！我们将`clicks`的总数作为prop接收，并简单地显示它：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Connecting components to the store
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接组件到store
- en: 'A good design rule, separating concerns, says that you shouldn''t directly
    connect a component to the store, but rather create a new component, a connected
    one, that will get whatever is needed from the store and pass it on to the original
    component. This rule will simplify, for example, all of our testing: our basic
    components will still receive everything via props, and we won''t have to do any
    mocking of the store or anything like that in order to test them.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的设计规则是分离关注点，它说您不应该直接连接组件到存储，而是创建一个新组件，一个连接的组件，它将从存储中获取所需的任何内容，并将其传递给原始组件。这个规则将简化我们所有的测试：我们的基本组件仍然会通过props接收所有内容，我们不必对存储或类似的东西进行任何模拟来测试它们。
- en: A good article on defining components, by Dan Abramov, is *Presentational and
    Container Components*, at [https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0).
    More on this can be found in *Container Components*, at [https://medium.com/@learnreact/container-components-c0e67432e005](https://medium.com/@learnreact/container-components-c0e67432e005).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Dan Abramov的一篇关于定义组件的好文章是*Presentational and Container Components*，网址是[https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)。关于这一点的更多信息可以在*Container
    Components*中找到，网址是[https://medium.com/@learnreact/container-components-c0e67432e005](https://medium.com/@learnreact/container-components-c0e67432e005)。
- en: 'So, following that rule, for each component we want to connect, we''ll add
    a new connected version. In our case, the connected version of the count will
    be the following, so the `count` prop of the component will receive the `state.count`
    value:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据这个规则，对于我们想要连接的每个组件，我们将添加一个新的连接版本。在我们的情况下，计数的连接版本将如下，因此组件的`count`属性将接收`state.count`的值：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, the component to display the total number of clicks will be connected
    in a similar fashion:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，用于显示点击总数的组件将以类似的方式连接：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will place those connected components in our main code, and they will get
    the values from the store, and pass them on to our original components, which
    will be totally unchanged.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些连接的组件放在我们的主要代码中，它们将从存储中获取值，并将其传递给我们的原始组件，这些组件将完全不变。
- en: Defining the main page
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义主页
- en: 'Our last piece of code is based on the standard `App.js` file that''s produced
    by `create-react-app`; the `App` class is imported by `index.js`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一段代码是基于`create-react-app`生成的标准`App.js`文件；`index.js`导入了`App`类：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The key part here is the `<Provider>` component. This is a part of `React`'s
    latest `Context` feature (see [https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)
    for more on it), and it gives access to the `store` object to any of the following
    components; the `connect()` function (that we used in the previous section) uses
    it to provide props to those components, and to subscribe them to changes. By
    the way, we are using `Fragment` here, just because `Provider` expects a single
    element. In addition to this, `<div>` could have worked as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键部分是`<Provider>`组件。这是`React`最新的`Context`功能的一部分（有关更多信息，请参见[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)），它为任何以下组件提供对`store`对象的访问；`connect()`函数（我们在上一节中使用过）使用它为这些组件提供props，并订阅它们的更改。顺便说一句，我们在这里使用`Fragment`，只是因为`Provider`期望一个单一元素。除此之外，`<div>`也可以工作。
- en: With everything together, let's see how this works!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一起，让我们看看这是如何工作的！
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we start the application, the current state count is zero, and so is the
    number of clicks, so the screen looks like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动应用程序时，当前状态计数为零，点击次数也是如此，因此屏幕看起来如下：
- en: '![](img/ec2ddcd2-4e51-4d4e-b062-0ab272acab79.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec2ddcd2-4e51-4d4e-b062-0ab272acab79.png)'
- en: Our counter application in its initial state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计数器应用程序处于初始状态。
- en: 'After some clicks on the following buttons, the value and clicks count get
    updated, and the view automatically reflects those changes as they happen; see
    the following screenshot. Be sure to understand how everything happens:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击以下按钮后，值和点击次数会更新，并且视图会自动反映这些变化；请参见以下截图。一定要理解一切是如何发生的：
- en: Whenever you click a button, an action is dispatched.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当您点击按钮时，都会触发一个动作。
- en: When the reducer processes the action, it creates a new state.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当reducer处理动作时，它会创建一个新的状态。
- en: 'When `React` sees the state change, it redraws your application. Take a look
    at the following screenshot:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`React`看到状态改变时，它会重新绘制您的应用程序。看一下以下截图：
- en: '![](img/b13fdefc-caf6-40d0-873a-590d502d2f98.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b13fdefc-caf6-40d0-873a-590d502d2f98.png)'
- en: After every click, the counter value and the number of clicks get automatically
    updated, and the view is re-rendered
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击后，计数值和点击次数都会自动更新，并且视图会重新呈现
- en: 'So, we have seen that we can work with `Redux` in order to keep a global state
    and have the view re-rendered whenever it''s needed, without extra work on our
    part. Now, let''s consider a common problem: how would we deal with asynchronous
    changes, for example, when we do Ajax calls?'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到，我们可以使用`Redux`来保持全局状态，并在需要时重新呈现视图，而我们不需要额外的工作。现在，让我们考虑一个常见的问题：当我们进行异步更改时，例如，当我们进行Ajax调用时，我们该如何处理？
- en: See also
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`Redux` is not the only state management package that you can use with `React`.
    The most favored one is surely `MobX`, which adds reactive programming concepts,
    such as observable objects and arrays; check it out at [https://github.com/mobxjs/mobx](https://github.com/mobxjs/mobx).
    Its basic paradigm is quite different from the `Redux` one, simpler in many ways,
    and more akin to a spreadsheet; be ready, however, to change your way of thinking
    before using it!'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Redux`并不是您可以与`React`一起使用的唯一状态管理包。最受欢迎的是`MobX`，它添加了响应式编程概念，例如可观察对象和数组；请查看[https://github.com/mobxjs/mobx](https://github.com/mobxjs/mobx)。它的基本范式与`Redux`大不相同，在许多方面更简单，并更类似于电子表格；但在使用之前，请准备好改变您的思维方式！'
- en: Doing async actions with redux-thunk
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用redux-thunk进行异步操作
- en: 'How can we do async actions, such as calling a web service? This kind of call
    requires some different processing: you cannot just dispatch an action, if we
    are still waiting for the results of an Ajax call. The `Redux` *thunk* middleware
    lets you write an action creator that returns a function instead of an action;
    the function is given access to the store contents and to the dispatch function
    itself, and can then do async calls, dispatch other functions, and so on.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何执行异步动作，比如调用web服务？这种调用需要一些不同的处理：如果我们仍在等待Ajax调用的结果，那么您不能只是分派一个动作。`Redux`的*thunk*中间件允许您编写一个返回函数而不是动作的动作创建者；该函数可以访问存储内容和分派函数本身，并且可以执行异步调用，分派其他函数等。
- en: It seems that the origin of the **thunk** word comes from a very late programming
    session, in which, after many hours of work, a solution to a problem was found
    that had been *thought before*, and *thunk* became its name as a derivative of
    *think*, make of it what you will!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎**thunk**这个词的起源来自一个非常晚的编程会话，在那里，在经过多个小时的工作后，找到了一个之前*考虑过*的问题的解决方案，*thunk*成为了它的名字，作为*think*的派生词，你可以理解为什么！
- en: This sound a bit mysterious, so let's dive in and see how it works by doing
    a variation on the country/region components we built in the *Defining components*
    section in [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml), *Developing
    with React*, only that this time we'll be working with actual API calls—for which
    we already have our `Node` server, which we created in [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来有点神秘，所以让我们深入了解它是如何工作的，通过在[第6章](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml)中构建的国家/地区组件的变体，*使用React进行开发*，只是这一次我们将使用实际的API调用——对于这些调用，我们已经有了我们的`Node`服务器，我们在[第4章](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml)中创建了它，*使用Node实现RESTful服务*。
- en: How to do it…
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's modify our region application so that it will connect to the backend service.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的地区应用程序，以便它将连接到后端服务。
- en: 'First of all, to use `redux-thunk`, we will have to install the package:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要使用`redux-thunk`，我们必须安装该软件包：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we must modify the store to use the new middleware. (We''ll be seeing
    more middleware later in this chapter, and in the next one as well.) This change
    is very small, as the following code shows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须修改存储以使用新的中间件。（我们将在本章后面和下一章中看到更多的中间件。）这个改变非常小，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Defining the actions
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义动作
- en: 'Whenever you try to get data from a service, a common pattern is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您尝试从服务获取数据时，一个常见的模式如下：
- en: '*Fire an action when you do the request*; this action may set some flag, which
    will in turn be used by some component to display a "Loading..." text or a spinning
    icon to show that something''s going on, and the user should wait'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在您发出请求时触发一个动作*；这个动作可能设置一些标志，然后由某个组件使用，以显示“正在加载…”文本或旋转图标，以显示正在进行某些操作，用户应该等待'
- en: '*If the service request was successful*, fire an action signaling this success,
    resetting the *Loading...* flag, and also providing the new data that must be
    added to the store'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果服务请求成功*，触发一个表示成功的动作，重置*正在加载…*标志，并提供必须添加到存储中的新数据'
- en: '*If the service request failed*, reset the *Loading...* flag, but signal error
    in some way'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果服务请求失败*，重置*正在加载…*标志，但以某种方式表示错误'
- en: 'The actions we''ll need for our application have to do with, firstly, getting
    the list of countries for the country drop-down list, and, secondly, getting the
    list of regions for a given country. The actions are as follows; first, here are
    the country-related ones:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序需要的动作首先与获取国家下拉列表的国家列表有关，其次是获取给定国家的地区列表。动作如下；首先是与国家相关的动作：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For regions, we have a similar set:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于地区，我们有一个类似的设置：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the style of the action constants—we are using `"countries"` and `"regions"`
    as a sort of namespacing (as in `"countries:success"` versus `"regions:success"`)
    to avoid possible name duplications.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意动作常量的风格——我们使用`"countries"`和`"regions"`作为一种命名空间（如`"countries:success"`与`"regions:success"`），以避免可能的名称重复。
- en: Writing the reducer
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写reducer
- en: 'We have actions; now, we need a reducer. Its code is also not complex:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有动作；现在，我们需要一个reducer。它的代码也不复杂：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The only thing that needs to be remarked upon is the following style of code,
    using the spread operator in a way you may not have seen before:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要注意的是以下代码风格，以一种您可能以前没有见过的方式使用扩展运算符：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We must be careful when returning the new state to not lose part of the old
    state, so starting the object with `...state` is a very common coding pattern.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回新状态时，我们必须小心，以免丢失旧状态的一部分，因此以`...state`开头的对象是一种非常常见的编码模式。
- en: To avoid accidentally changing the state, a good solution is to handle state
    with packages such as `immutable-js` (at [https://github.com/facebook/immutable-js/](https://github.com/facebook/immutable-js/))
    or `seamless-immutable` (at [https://github.com/rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable)),
    because then you aren't able to modify the state object; you are forced to produce
    a new one, avoiding many hard-to-find mistakes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免意外更改状态，一个很好的解决方案是使用`immutable-js`（在[https://github.com/facebook/immutable-js/](https://github.com/facebook/immutable-js/)）或`seamless-immutable`（在[https://github.com/rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable)）等软件包处理状态，因为这样你就无法修改状态对象；你被迫产生一个新的状态对象，避免许多难以发现的错误。
- en: Modifying the country drop-down list
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改国家下拉列表
- en: 'We earlier had a country drop-down list that received a list of countries.
    Let''s rewrite it so that if no such list is provided, it will use a function
    to call a thunk, and get the countries from our server:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前有一个国家下拉列表，接收了一个国家列表。让我们重写它，以便如果没有提供这样的列表，它将使用一个函数调用thunk，并从我们的服务器获取国家：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see in the `.componentDidMount()` method, if no list is available,
    we call a function (which we'll see soon) to get that list, and put it in the
    store. A `loading` attribute will be used, so while we wait for the countries
    to arrive, a `Loading countries...` text will be shown instead of an empty `<select>`
    component. You'll also notice that I sorted the countries, because the service
    sends them ordered by country code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.componentDidMount()`方法中，如果没有可用的列表，我们调用一个函数（很快我们会看到），来获取该列表，并将其放入存储中。将使用`loading`属性，因此在等待国家到达时，将显示`加载国家...`文本，而不是空的`<select>`组件。
- en: 'The connected version of this component is not as short as before, because
    we''ll have to connect props to the store, and also to actions to be dispatched;
    I highlighted those parts of the code in the following snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的`getCountries()`函数的签名有点奇怪（一个返回异步函数的函数，带有`dispatch`参数），但这是`redux-thunk`所需的。逻辑更有趣：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Modifying the region table
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这个组件的连接版本不像以前那样简短，因为我们将不得不将props连接到存储，并且还要连接要派发的动作；我在以下片段的代码中突出显示了这些部分：
- en: 'Since most of the new behavior will occur in the country drop-down component,
    we can make do with a very simple table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大部分新行为将发生在国家下拉组件中，我们可以用一个非常简单的表格来处理：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also sort the regions in alphabetic order, and we just create a plain list
    of `<div>`, each with a single region''s name. The connected component gets access
    to the list of regions and to a loading flag so that it can show something while
    the list of regions is being fetched from the server:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还按字母顺序对区域进行排序，并创建一个简单的`<div>`列表，每个列表中都有一个区域的名称。连接的组件可以访问区域列表和加载标志，以便在从服务器获取区域列表时显示一些内容：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Setting up the main application
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置主应用程序
- en: 'We have all the necessary components, so we can now produce our application.
    (And, no, I haven''t forgotten the promised functions!) Our main code will be
    as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有所有必要的组件，所以现在我们可以制作我们的应用程序。（不，我没有忘记承诺的功能！）我们的主要代码将如下所示：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using thunks
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用thunks
- en: Now, things start getting interesting. We are providing two functions to the
    country drop-down list, both of which will work with thunks in order to connect
    to the server. Let's see them!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个函数：一个用于获取国家列表，另一个用于获取当前选择国家的区域。让我们从前者开始，并记住这段代码将添加到我们之前看到的动作文件中：
- en: 'We''ll need two functions: one will deal with getting the list of countries,
    and the other will be used to get the regions for the currently selected country.
    Let''s just begin with the former, and keep in mind that this code is to be added
    to the action file we saw earlier:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择一个国家，服务将被调用，并且结果将被显示；请参阅以下截图。这个逻辑也很有趣：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, the signature for our `getCountries()` function is a bit weird (a function
    that returns an async function, with a `dispatch` parameter), but this is what
    `redux-thunk` requires. The logic is more interesting:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择一个国家时，下拉列表使用一个thunk来获取其区域。
- en: To start, we dispatch the results of the `countriesRequest()` action creator,
    so the state of the application will show that we are waiting for some results.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们派发`countriesRequest()`动作创建者的结果，这样应用程序的状态将显示我们正在等待一些结果。
- en: Then, we use the `axios()` package, as used earlier in our Node work, to call
    our server and get the list of countries.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用`axios()`包，就像我们之前在Node工作中使用的那样，调用我们的服务器并获取国家列表。
- en: If the call is successful, we dispatch a `countriesSuccess()` action, passing
    it the list of countries that we received.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改区域表
- en: If the call failed, we dispatch a `countriesFailure()` action, to show that
    failure.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还会注意到，我对国家进行了排序，因为服务按国家代码顺序发送它们。
- en: As you can see, our code is able to dispatch many actions, but waiting until
    the right moment to do so.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当国家列表返回时，将派发一个`countriesSuccess()`动作，并附上收到的国家列表。
- en: 'To work with regions, we''ll have similar code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理区域，我们将有类似的代码：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code is quite similar to what we had before, so we don't need to do much
    analysis.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，事情开始变得有趣起来。我们为国家下拉列表提供了两个函数，这两个函数都将使用thunks来连接到服务器。让我们来看看它们！
- en: How it works…
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we `npm start` our application, we see a very plain design; see the following
    screenshot. Let''s understand how did we get here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们`npm start`我们的应用程序时，我们看到一个非常简单的设计；请参阅以下截图。让我们了解我们是如何到达这里的：
- en: The main page was displayed.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示了主页面。
- en: The countries drop-down list, on receiving an empty list of countries, used
    a thunk to get all countries.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当国家下拉列表接收到一个空的国家列表时，使用thunk获取所有国家。
- en: A `getCountries()` action was dispatched.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果调用成功，我们会派发一个`countriesSuccess()`动作，并传递我们收到的国家列表。
- en: The reducer updated the store to set the `loadingCountries` flag to true
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减速器更新了存储，将`loadingCountries`标志设置为true
- en: The page was redrawn, and a `"Loading countries..."` text was shown instead
    of the drop-down list.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面被重绘，而不是下拉列表，显示了`"加载国家..."`文本。
- en: When the countries list came back, a `countriesSuccess()` action was dispatched,
    with the received list of countries.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派发了一个`getCountries()`动作。
- en: The reducer updated the store to include all countries and to reset `loadingCountries`
    to false.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当区域表绘制时没有任何区域，会显示一些`"没有区域"`文本。
- en: 'The page was redrawn, and now the country drop-down list has a list of countries
    to show as shown, in the following screenshot:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面被重绘，现在国家下拉列表有一个国家列表要显示，如下截图所示：
- en: '![](img/ccb95d6f-41ff-4fec-976e-b6b0d1166649.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: 代码与以前相似，所以我们不需要做太多分析。
- en: Our initial screen
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始屏幕
- en: 'If we select a country, the service will be called, and results will be shown;
    see the following screenshot. The logic for this is also interesting:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的代码能够派发许多动作，但要等到合适的时机才能这样做。
- en: When the region table is drawn without any regions, some `"No regions"` text
    is displayed.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果调用失败，我们会派发一个`countriesFailure()`动作，以显示失败。
- en: When the user selects a country, the drop-down list uses a thunk to get its
    regions.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派发了一个`regionsRequest()`动作。
- en: A `regionsRequest()` action was dispatched.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减速器更新了存储，包括所有国家，并将`loadingCountries`重置为false。
- en: When the regions came back, a `regionsSuccess()` action was dispatched,
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当地区返回时，将分派一个`regionsSuccess()`动作，
- en: 'The page was redrawn after the reducer created a new state, showing the regions''
    list. Refer to the following screenshot:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在减速器创建了一个新状态后，页面被重绘，显示了地区列表。参考以下截图：
- en: '![](img/d5d2b52b-d1fc-4261-8fd0-effd7607882a.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5d2b52b-d1fc-4261-8fd0-effd7607882a.png)'
- en: The results of calling our restful server
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 调用我们的restful服务器的结果
- en: 'You could be wondering, however, where is the `"Loading countries..."` text?
    The problem (if you want to call it that!) is that the service response comes
    too quickly, so the message flashes by and disappears. We can get to see it a
    bit longer if we cheat and add some delay in the `getCountries()` function. Include
    the following line before calling `axios()` to delay execution for five seconds:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会想，`"加载国家..."`的文本在哪里？问题（如果你愿意这样说！）是服务响应太快了，所以消息一闪而过就消失了。如果我们在`getCountries()`函数中作弊并添加一些延迟，我们可以看到它更长一点。在调用`axios()`之前包含以下行以延迟执行五秒：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, you''ll have time to see the missing state, as shown in the following
    screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将有时间看到缺失的状态，如下截图所示：
- en: '![](img/5a8870bb-c738-434e-b3dd-2d74b36e3c7f.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a8870bb-c738-434e-b3dd-2d74b36e3c7f.png)'
- en: Adding some delay lets us see what's displayed while waiting for the list of
    countries
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些延迟让我们在等待国家列表时看到显示的内容
- en: So, now we can see that our state handling was correct, and that everything
    is displayed the way we wanted it to be!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们可以看到我们的状态处理是正确的，并且一切都显示得如我们所希望的那样！
- en: There's more…
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When you write your action creator, it actually gets passed not only `dispatch()` but
    also the `getState()` function. This function can be used to access the current
    state value. We didn''t use this, but, for example, you could do so for caching
    or other similar ideas. Our `getRegions()` function could be as follows, to detect
    whether you are requesting the same country''s regions again:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写你的动作创建者时，它实际上不仅传递了`dispatch()`，还传递了`getState()`函数。这个函数可以用来访问当前的状态值。我们没有使用这个，但是，例如，你可以用它来进行缓存或其他类似的想法。我们的`getRegions()`函数可以如下所示，以检测你是否再次请求相同国家的地区：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In our case, we aren't doing anything other than logging a message, but you
    could use the received parameters plus the current state contents in order to
    do some more complex logic.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们除了记录一条消息之外，没有做任何其他事情，但是你可以使用接收到的参数加上当前状态的内容来进行一些更复杂的逻辑。
- en: Adding routing with react-router
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用react-router添加路由
- en: 'When you work with `React` (as with other frontend frameworks, such as `Angular`
    or `Vue`, to name just a couple) you usually develop **Single Page Applications**
    (**SPAs**) that never do a full-page reload when you access a different part of
    them; rather, new content is swapped into view, but staying put on the original
    page. Even if this kind of navigational experience is modern and fluid, some aspects
    of more traditional routing are expected: the *back* and *forward* buttons should
    move you, depending on your browsing story, and you should also be able to bookmark
    a specific part of your application to be able to quickly return to it later.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`React`（就像其他前端框架一样，比如`Angular`或`Vue`，只是举几个例子）时，通常会开发**单页应用程序**（**SPAs**），当你访问它们的不同部分时，它们永远不会进行完整的页面重新加载；相反，新内容会被切换到视图中，但仍停留在原始页面上。即使这种导航体验现代而流畅，但仍然期望一些更传统的路由方面：*后退*和*前进*按钮应该根据你的浏览历史移动你，你还应该能够将应用程序的特定部分添加到书签中，以便以后能够快速返回到它。
- en: 'As usual, with `React`, there are many ways to handle routing, but `react-router`
    is currently by far the most used library, probably because it really fits the
    `React` paradigm: routes are just components that you render and work as expected!
    Let''s start by building a simple application to show how routes work, and in
    the next section we''ll add a bit of complexity by requiring authentication before
    allowing access to certain routes.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用`React`处理路由有很多种方式，但`react-router`目前是迄今为止最常用的库，可能是因为它真的符合`React`的范式：路由只是你渲染并且按预期工作的组件！让我们从构建一个简单的应用程序开始，以展示路由是如何工作的，然后在下一节中，我们将通过要求在允许访问某些路由之前进行身份验证来增加一些复杂性。
- en: Getting started
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'The `react-router` library is practically a standard for handling routing within
    `React` applications. Installing it requires a subtle distinction: instead of
    directly getting that package, you must pick a different package, `react-router-dom`,
    which will itself take care of getting `react-router`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router`库实际上是处理`React`应用程序中的路由的标准。安装它需要一个微妙的区别：不是直接获取那个包，而是必须选择一个不同的包，`react-router-dom`，它本身会负责获取`react-router`：'
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can easily build an application with several links, a router that will take
    care of rendering whichever view is correct, and even a 404 page for wrong links.
    Of course, we'll focus on the routing aspects, so in other terms, our application
    will be more of a skeleton than an actual usable web page—and don't get started
    on its very plain styling!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地构建一个应用程序，其中包含多个链接，一个路由器将负责渲染正确的视图，甚至为错误的链接提供一个404页面。当然，我们将专注于路由方面，因此在其他方面，我们的应用程序将更像是一个骨架，而不是一个实际可用的网页——不要开始对它非常简单的样式着迷！
- en: How to do it…
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we'll be creating a basic application but with several routes;
    let's see how.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将创建一个基本的应用程序，但有几个路由；让我们看看如何做到这一点。
- en: To begin with, we'll need to import some packages and create a few components
    that will represent the different pages in our application. For the latter, since
    we aren't going to include any actual logic or contents, we'll make do with very
    simple functional components that render a single `H1` heading... I told you our
    application would be quite bare!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入一些包并创建一些组件，这些组件将代表我们应用程序中的不同页面。对于后者，因为我们不打算包含任何实际的逻辑或内容，我们将使用非常简单的功能组件，它们只渲染一个`H1`标题...我告诉过你我们的应用程序会非常简单！
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, to continue, we must plan our application. We''ll have `<header>` with
    a `<nav>` bar, in which we''ll include links to the parts of our application.
    Below that, we''ll have a common area in which the right component will be rendered.
    Our `<App>` component could be as follows—though in real life, you''d probably
    define all routes in separate files; I''m placing everything here for brevity:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了继续，我们必须规划我们的应用程序。我们将有一个带有`<nav>`栏的`<header>`，其中我们将包括到我们应用程序各部分的链接。在下面，我们将有一个常见区域，其中将呈现正确的组件。我们的`<App>`组件可能如下所示-虽然在现实生活中，您可能会在单独的文件中定义所有路由；我在这里放置了所有内容以保持简洁：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I''ve highlighted several parts of the code; let''s see why:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了代码的几个部分；让我们看看为什么：
- en: '`<BrowserRouter>` is a component based on the HTML5 "History" API, and takes
    care of keeping your view synchronized with the URL; a change in the latter will
    be reflected by a new view.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<BrowserRouter>`是基于HTML5“History”API的组件，负责保持视图与URL同步；后者的更改将反映在新视图中。'
- en: '`<Link ...>` is the component you must use instead of the usual `<a ...>` HTML
    tags, and `to=` points to the desired route.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Link ...>`是您必须使用的组件，而不是通常的`<a ...>` HTML标签，`to=`指向所需的路由。'
- en: '`<Switch>` is a component that renders the first child `<Route>` or `<Redirect>`
    component (we''ll using `<Redirect>` soon) that happens to match the current location.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Switch>`是一个组件，它呈现第一个匹配当前位置的子`<Route>`或`<Redirect>`组件（我们很快将使用`<Redirect>`）。'
- en: '`<Route ...>` defines which component must be rendered when the path is matched.
    Note that you could have to specify exactly to avoid false coincidences; otherwise,
    visiting `"/alpha"` would be matched by the first route, `"/"`, and the wrong
    component would be displayed. You may specify what is to be rendered by using
    `component=` or by providing a `render()` function; the latter is useful when
    you need to display several components or take some parameters. In particular,
    we used this for `"/about/:something"`; when this route is matched, in a way similar
    to `Express` (check the *Adding Routes* section, in [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*) a new prop will be provided, with attributes
    coinciding with the colon-starting parts of the URL. You can omit this by specifying
    `path=`, and then you''ll have a *catch-all*, which is useful for 404 errors,
    as we did here.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Route ...>`定义了在路径匹配时必须呈现的组件。请注意，您可能需要精确指定以避免错误的巧合；否则，访问`"/alpha"`将匹配第一个路由`"/"`，并显示错误的组件。您可以通过使用`component=`或提供`render()`函数来指定要呈现的内容；当您需要显示多个组件或获取一些参数时，后者非常有用。特别是，我们在`"/about/:something"`中使用了这个；当匹配到这个路由时，类似于`Express`（查看[第4章](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml)中的*添加路由*部分，在*使用Node实现RESTful服务*中），将提供一个新的prop，其属性与URL的冒号开头部分相符。您可以通过指定`path=`来省略这一点，然后您将有一个*通配符*，这对于404错误非常有用，就像我们在这里做的那样。'
- en: So, we have the code; let's see it in action.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有了代码；让我们看看它的运行情况。
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you `npm start` the application and then navigate to it, you''ll get the
    home page, as in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您`npm start`应用程序，然后导航到它，您将得到主页，如下截图所示：
- en: '![](img/5a219e50-a1cc-4580-b82d-554e9accf5b8.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a219e50-a1cc-4580-b82d-554e9accf5b8.png)'
- en: Our routing application, showing the component for the basic "/" route
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由应用程序，显示了基本“/”路由的组件
- en: 'If you select any valid route (that is, don''t pick the Wrong one, at least
    not yet!), the matching route will be activated, and the corresponding component
    will be displayed, as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择任何有效路由（即，至少现在不要选择错误的路由！），将激活匹配的路由，并显示相应的组件，如下截图所示：
- en: '![](img/7225873e-e3b7-4868-a774-a4f76c251447.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7225873e-e3b7-4868-a774-a4f76c251447.png)'
- en: Picking a valid route gets you the corresponding component
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 选择有效路由会得到相应的组件
- en: 'Finally, if you pick a wrong route, the default component will be shown, as
    follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果选择了错误的路由，将显示默认组件，如下所示：
- en: '![](img/fe9b3a61-8712-4ef4-a3b8-ecdf78eba46d.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe9b3a61-8712-4ef4-a3b8-ecdf78eba46d.png)'
- en: The last route in our <Switch> is a catch-all for undefined routes
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的<Switch>中的最后一个路由是未定义路由的通配符
- en: There's more…
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There''s something we haven''t used yet: the possibility of directly navigating
    to a given route or going back to the previous location and more. Whenever a `<Route>`
    is matched, the rendered component gets some special props, which you can use:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事我们还没有用过：直接导航到给定路由或返回到上一个位置等。每当匹配到一个`<Route>`时，呈现的组件都会获得一些特殊的props，您可以使用：
- en: '`this.props.history`, providing access to the browser history, with several
    methods like `.goBack()` to return to the previous page, or `.push("someURL")`
    to navigate to a different page; see [https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) and
    especially [https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/history.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/history.md)
    for more on this'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.props.history`，提供对浏览器历史记录的访问，具有诸如`.goBack()`返回到上一页或`.push("someURL")`导航到不同页面等多种方法；有关更多信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)和特别是[https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/history.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/history.md)'
- en: '`this.props.location`, with several properties related to the current location
    and its URL; see [https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/location.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/location.md)
    for extra data'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.props.location`，具有与当前位置及其URL相关的几个属性；有关额外数据，请参阅[https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/location.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/location.md)'
- en: '`this.props.match`, which tells you how the current route was matched; see [https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/match.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/match.md)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.props.match`，告诉您当前路由是如何匹配的；请参阅[https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/match.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/match.md)'
- en: So, we are now able to work with routes; let's move on to routes needing authorization.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在能够处理路由；让我们继续处理需要授权的路由。
- en: Adding authorization to routes
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在路由中添加授权
- en: Our previous routing example worked very well, but in some applications, you
    might need authorization so that only logged-in users may access parts of your
    website. (You would also need the user to be identified, if you were using an
    API such as the one we developed in [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*, which required **JSON Web Token** (**JWT**).
    So, let's see what extra work we need in order to have both restricted and unrestricted
    routes on our page.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的路由示例工作得很好，但在一些应用程序中，您可能需要授权，以便只有已登录的用户才能访问您网站的部分。 （如果您使用的是我们在[第4章](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml)中开发的API，*使用Node实现RESTful服务*，则还需要用户进行标识，该API需要**JSON
    Web Token**（**JWT**）。因此，让我们看看我们需要做哪些额外工作，以便在页面上既有受限制的路由又有不受限制的路由。
- en: How to do it…
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's add authorization to our application by protecting some routes and requiring
    a previous successful login.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过保护一些路由并要求先前成功登录来为我们的应用程序添加授权。
- en: We can find a very `React`-like solution. We will have some unprotected routes
    that anybody may access without restriction, and protected routes that require
    having a login. We'll need two components for that.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找到一个非常符合`React`风格的解决方案。我们将有一些任何人都可以无限制访问的未受保护路由，以及需要登录的受保护路由。我们将需要两个组件。
- en: Creating a login component
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个登录组件
- en: 'First, let''s create a `<Login>` component that we''ll call our RESTful server,
    passing a username and a password to it, and (if the values are right) getting
    back a JWT:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个`<Login>`组件，我们将调用我们的RESTful服务器，向其传递用户名和密码，（如果值正确）然后获取JWT：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Defining actions and the reducer
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义操作和减速器
- en: 'Before getting into the details, let''s see the reducer and actions we''ll
    have. The former is quite simple, since basically all we care about is having
    a `token` and a `logging` flag:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们看看我们将拥有的减速器和操作。前者非常简单，因为基本上我们关心的只是有一个`token`和一个`logging`标志：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will have some action creators that will help us understand the rest. The
    important one is `attemptLogin()` that tries connecting to the server, and if
    successful stores the token that will mark that the user is logged in:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一些操作创建者，这将帮助我们了解其余部分。其中一个重要的是`attemptLogin()`，它尝试连接到服务器，如果成功则存储令牌，标记用户已登录：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We'll leave it as an exercise to you to write a `<LogOut>` component that will
    provide a button, which when clicked will just call an action to delete the current
    token.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把写一个`<LogOut>`组件留给您作为练习，它将提供一个按钮，当点击时将调用一个动作来删除当前令牌。
- en: Creating a component to protect a route
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个保护路由的组件
- en: 'To protect a route, let''s create a new component that will check whether a
    user is logged in or not. In the first case, the route will be shown, with no
    further ado. However, in the second case, instead of the original route''s component, `<Redirect>` will
    be produced, redirecting the user to the login page:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要保护一个路由，让我们创建一个新组件，它将检查用户是否已登录。在第一种情况下，路由将显示，而不需要进一步操作。但是，在第二种情况下，不会显示原始路由组件，而是会产生`<Redirect>`，将用户重定向到登录页面：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will connect this component to the store so that it can access the current
    token plus the path to the login page:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个组件连接到存储，以便它可以访问当前令牌和登录页面的路径：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we have everything we need; let's make it work!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有了一切我们需要的东西；让我们让它工作起来！
- en: How it works…
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'To use our new component, we''ll change something in our original routes from
    earlier in this chapter. Let''s protect a few of the routes. All it will take
    is changing `Route` to `AuthRoute`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的新组件，我们将在本章前面的原始路由中做一些更改。让我们保护一些路由。只需要将`Route`更改为`AuthRoute`：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: All the changed routes will require a previous login—and if the user enters
    a wrong route, we won't even tell them about the 404 error; we'll force them to
    first log in, and if they won't do it, they won't be able to even learn that the
    route existed or not.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所有更改后的路由都需要先前的登录——如果用户输入错误的路由，我们甚至不会告诉他们404错误；我们将强制他们首先登录，如果他们不这样做，他们甚至无法知道路由是否存在。
- en: 'Now, if we open the application and try to access the normal unprotected routes,
    everything will work as before. However, if you try to get to some of the protected
    routes, such as `"/charlie"`, you will be redirected to the login page, as in
    the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开应用程序并尝试访问普通的未受保护路由，一切都会像以前一样工作。但是，如果您尝试访问一些受保护的路由，比如`"/charlie"`，您将被重定向到登录页面，如下截图所示：
- en: '![](img/9eb6ebae-52a5-46fe-934b-6354900e3064.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9eb6ebae-52a5-46fe-934b-6354900e3064.png)'
- en: Trying to go to a protected route will redirect you to the login screen
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问受保护的路由将重定向到登录界面
- en: 'After logging in, the `<Login>` component will produce a `<Redirect>` of its
    own that will send the user back to the originally requested page. See the following
    screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，`<Login>`组件将产生自己的`<Redirect>`，将用户发送回最初请求的页面。请参见以下截图：
- en: '![](img/a5d19edd-fb7b-4603-829b-236a48fe0a59.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5d19edd-fb7b-4603-829b-236a48fe0a59.png)'
- en: After a successful login process, you'll be redirected again to the page you
    had first requested; the URL now points to the page we wanted to access
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，您将再次被重定向到您最初请求的页面；现在的URL指向我们想要访问的页面
- en: So, now you have a way to handle all kinds of routes, and in a very `React`-ish
    way, too!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在您有了一种处理各种路由的方法，而且也非常符合`React`的方式！
- en: There's more…
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In usual web development, you use cookies or possibly local storage for access
    information, but in a `React` application, storing the token (or whatever you
    use) in the state is good enough. If you need to provide the token for API calls,
    remember that actions are defined as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在通常的Web开发中，您使用cookie或可能使用本地存储来存储访问信息，但在`React`应用程序中，将令牌（或您使用的任何内容）存储在状态中就足够了。如果需要为API调用提供令牌，请记住，操作定义如下：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, you can access the token via the `getState()` function, and pass it back
    to the server as needed; go back to the `getRegions2()` code, where we saw how
    to do async actions, to see an example of using this function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以通过`getState()`函数访问令牌，并根据需要将其传回服务器；回到`getRegions2()`代码，我们看到了如何执行异步操作，以查看使用此函数的示例。
- en: Code splitting for performance
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能的代码拆分
- en: 'As your application grows in size, it will progressively be slower to load,
    and that will be off-putting to your users. (And, remember that not everybody
    has access to high-speed connections, especially in mobile devices!) Furthermore,
    users shouldn''t have to download the whole code if they only need a small part
    of it: for example, if a user wants to browse products, why should the sign-up
    view be downloaded?'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序规模的增长，加载速度将逐渐变慢，这将让用户感到不满意。（而且，请记住，并非每个人都可以访问高速连接，尤其是在移动设备上！）此外，如果用户只需要其中的一小部分，用户不应该下载整个代码：例如，如果用户想浏览产品，为什么还要下载注册视图？
- en: The solution to this space and speed problem is *code splitting*, which implies
    that your application will be broken down into smaller chunks that will be loaded
    only if needed. Fortunately, there are very good tools for this, which don't involve
    many changes to your existing code, so it's a win all around.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个空间和速度问题的方法是*代码拆分*，这意味着您的应用程序将被分解成较小的块，只有在需要时才会加载。幸运的是，有很好的工具可以做到这一点，而且不需要对现有代码进行太多更改，因此这是一个全面的胜利。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'When you import a module, it''s a static thing, and the code for the desired
    module gets included in the general source code pack. However, you can work with
    *dynamic* `import()` calls to load code at runtime. You could work with that by
    yourself, but there''s already a simple package you can import, `react-loadable`,
    that will take care of most situations. Let''s install it in the usual way:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当您导入一个模块时，它是一个静态的东西，所需模块的代码被包含在通用源代码包中。但是，您可以使用*动态*`import()`调用在运行时加载代码。您可以自己处理这个问题，但已经有一个简单的软件包可以导入，`react-loadable`，它将处理大多数情况。让我们以通常的方式安装它：
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We will be using a few of all the features of this package, so you should take
    a look at [https://github.com/jamiebuilds/react-loadable](https://github.com/jamiebuilds/react-loadable)
    to get ideas about more ways to enhance your dynamic code loading features.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此软件包的一些功能，因此您应该查看[https://github.com/jamiebuilds/react-loadable](https://github.com/jamiebuilds/react-loadable)以获取有关增强动态代码加载功能的更多想法。
- en: As of December 2018, `import()` is at stage 3, meaning that it's a candidate
    for acceptance, expecting only few a (if any) changes and is well on its way to
    stage 4, which means that it will be included in the formal ECMAScript standard.
    However, as with other JS extensions, you can already use them in your code, and
    it's supported by `Babel` and `Webpack`. You can read more about `import()` at [https://tc39.github.io/proposal-dynamic-import/](https://tc39.github.io/proposal-dynamic-import/).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2018年12月，`import()`处于第3阶段，这意味着它是一个候选项，只期望进行少量（如果有的话）更改，并且已经在通往第4阶段的道路上，这意味着它将被包含在正式的ECMAScript标准中。但是，与其他JS扩展一样，您已经可以在代码中使用它们，并且它受到`Babel`和`Webpack`的支持。您可以在[https://tc39.github.io/proposal-dynamic-import/](https://tc39.github.io/proposal-dynamic-import/)上阅读更多关于`import()`的信息。
- en: How to do it…
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's modify our routing application—even if it's quite small!—to try out code
    splitting.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的路由应用程序，即使它很小！尝试进行代码拆分。
- en: 'First, let''s see what our main code will look like:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的主要代码将是什么样子：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have separated the `Alpha`, `Bravo`, and other components so that we can
    load them dynamically. Seeing the code for one of them will be enough:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`Alpha`、`Bravo`和其他组件分开，以便我们可以动态加载它们。查看其中一个的代码就足够了：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'But what about `AsyncAlpha`, `AsyncBravo`, and the rest? These components are
    dynamically loaded versions of their normal counterparts, which we can get using
    `react-loadable`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`AsyncAlpha`、`AsyncBravo`等呢？这些组件是它们的正常对应版本的动态加载版本，我们可以使用`react-loadable`获取：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `AsyncAlpha` component can be loaded dynamically, and while it''s being
    loaded, its contents will be provided by the `LoadingStatus` component; you can
    make it as fancy as you want but I went with a very simple thing:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncAlpha`组件可以动态加载，而在加载时，其内容将由`LoadingStatus`组件提供；您可以使其变得很花哨，但我选择了一个非常简单的东西：'
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, now that we know how we can get any component to load dynamically, let's
    see how it works.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道如何动态加载任何组件，让我们看看它是如何工作的。
- en: Being able to load components dynamically, instead of whole routes as usual
    with web applications, is a great plus. For example, your application could have
    a large, heavy component in a tab, but why load it unless the user actually goes
    to that tab? Deferred loading can also help show a page faster; you could endeavor
    to first show components at the top, and use dynamic imports for the components
    at the bottom.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 能够动态加载组件，而不是像通常的Web应用程序一样加载整个路由，这是一个很大的优势。例如，您的应用程序可能在选项卡中有一个大型、重型组件，但除非用户实际转到该选项卡，否则为什么要加载它？延迟加载还可以帮助更快地显示页面；您可以尝试首先显示顶部的组件，并使用动态导入来加载底部的组件。
- en: How it works…
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'We will use the web developer tools to look at the network transfers. When
    we start the application, we get the home page and just a few transfers, including
    `bundle.js`, the main source block. This is the file that will grow heavily in
    size as your application becomes larger. See the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Web开发人员工具来查看网络传输。当我们启动应用程序时，我们会得到主页和一些传输，包括`bundle.js`，主要源代码块。随着应用程序规模的增大，这个文件的大小将大幅增加。请参阅以下截图：
- en: '![](img/da642b65-fe14-4799-8cf1-c743015c4499.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da642b65-fe14-4799-8cf1-c743015c4499.png)'
- en: The initial load of the page shows that only bundle.js was sent over the net
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的初始加载显示只有bundle.js被发送到了网络上
- en: 'If we click on a link, the corresponding chunk of split code will be transferred.
    After accessing several of the links, you''d get something like the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击一个链接，相应的分割代码块将被传输。访问几个链接后，您会得到类似以下的内容：
- en: '![](img/2eb0b6e0-d958-4832-bb6b-cd60c2f79798.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2eb0b6e0-d958-4832-bb6b-cd60c2f79798.png)'
- en: As you go to different links, chunks will get loaded, but only as needed
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当您转到不同的链接时，块将被加载，但只有在需要时。
- en: Even if our example is really tiny, you can see that you could easily partition
    the application to work in several smaller chunks. We can give no rules to suggest
    when you should start applying this technique, but, as we've seen, changing any
    component into an asynchronously loaded equivalent takes little effort, so you
    could start using the technique, even with all of your application already written.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的示例非常小，您也可以看到您可以轻松地将应用程序分成几个较小的块。我们无法给出规则来建议何时应该开始应用这种技术，但是，正如我们所见，将任何组件更改为异步加载的等效组件所需的工作很少，因此，即使您的应用程序已经编写完成，您也可以开始使用这种技术。
- en: There's more…
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The components created by `Loadable()` include a `.preload()` method that you
    can use to start the importing process before the components are actually needed.
    We can quickly test it. For example, let''s set things up so that if the user
    moves the mouse over the Alpha link, the component will be preloaded:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`Loadable()` 创建的组件包括一个`.preload()`方法，您可以在实际需要组件之前使用它来启动导入过程。我们可以快速测试一下。例如，让我们设置一下，如果用户将鼠标移动到Alpha链接上，组件将被预加载：'
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can quickly verify that this works. When you load the updated version of
    the code, if you hover over the Alpha link, you''ll see that a chunk of code gets
    downloaded—though nothing changes onscreen, as the following screenshot shows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速验证一下这个功能。当您加载代码的更新版本时，如果您将鼠标悬停在Alpha链接上，您会看到一部分代码被下载 - 尽管屏幕上没有任何变化，如下面的截图所示：
- en: '![](img/e533a515-be91-4495-91f8-1d201134bba1.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e533a515-be91-4495-91f8-1d201134bba1.png)'
- en: 'Preloading works in the background and lets you download a component in advance:
    a chunk (1.chunk.js) has been loaded, though it hasn''t been shown onscreen'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 预加载在后台工作，让您可以提前下载组件：一个块（1.chunk.js）已经被加载，尽管它还没有显示在屏幕上
- en: 'Give it some time, and note that when you actually click the Alpha link, the
    component will be shown immediately, with no further downloads. There are more
    usages for preloading: you could use `setTimeout()` after the initial page load,
    for instance, or you could do predictive downloading, trying to foresee what the
    user will want next, based on what they''ve been doing.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 给它一些时间，并注意当您实际点击Alpha链接时，组件将立即显示，无需进一步下载。预加载还有更多用途：例如，您可以在初始页面加载后使用`setTimeout()`，或者您可以进行预测性下载，试图根据用户的操作来预测他们接下来会想要什么。
