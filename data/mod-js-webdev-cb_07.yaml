- en: Enhancing Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强您的应用程序
- en: 'In this chapter, we''ll move forward and consider several tools that make for
    a better application. The recipes we''ll be seeing include the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续前进，考虑一些可以使应用程序更好的工具。我们将看到的示例包括以下内容：
- en: Adding SASS for separate styling
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加SASS进行分离样式
- en: Creating StyledComponents for inline styling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为内联样式创建StyledComponents
- en: Making your application responsive to screen sizes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的应用程序对屏幕尺寸做出响应
- en: Making your application adaptive for enhanced usability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的应用程序适应不同的屏幕尺寸
- en: Making a global application with internationalization and localization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有国际化和本地化的全局应用程序
- en: Setting up for accessibility
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为可访问性设置
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we started developing applications with `React`, and
    saw the basics of how to use it, how to create an application, and how to develop
    components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始使用`React`开发应用程序，并了解了如何使用它的基础知识，如何创建应用程序以及如何开发组件。
- en: We'll also be taking advantage of `Storybook`, which we used in the previous
    chapter, so we can demonstrate each tool separately, and so we don't have to waste
    time focusing on anything else.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将利用在上一章中使用的`Storybook`，这样我们可以单独演示每个工具，而不必浪费时间专注于其他任何事情。
- en: Adding SASS for separate styling
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加SASS进行分离样式
- en: 'Just about the very first thing we should add is some way to handle styling
    for our application. If you wish, you need learn nothing new, nor install anything
    extra, for you could go with plain old-fashioned CSS—as we already did! We used
    some CSS in the previous chapter (look for the `src/components/general.css` file),
    but we don''t even need to go there. When we created our project then, an `App.js`
    file was created with the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该添加的第一件事就是处理应用程序的样式。如果你愿意，你无需学习任何新知识，也无需安装任何额外的东西，因为你可以使用老式的CSS——就像我们之前做的那样！我们在上一章中使用了一些CSS（查找`src/components/general.css`文件），但我们甚至不需要去那里。当我们创建项目时，会创建一个`App.js`文件，其中包含以下代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By including the `import "./App.css"` line, you are getting the styles that
    were defined in the `App.css` file, and you can then use them everywhere, as shown
    in the code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含`import "./App.css"`行，你可以获取在`App.css`文件中定义的样式，并且可以在代码中随处使用它们。
- en: This usage of `import` to deal with styling is not a JS thing, but rather is
    due to `Webpack`, which is used by `create-react-app` to generate the output code
    for your application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`import`来处理样式并不是JS的事情，而是由`Webpack`引起的，`create-react-app`使用它来为你的应用程序生成输出代码。
- en: So, if you wanted to get by with just CSS, you need to do but little, and you
    are set! However, there are many tools that can help you with styling, adding
    features that really come in handy, and in this section we will consider how to
    use `SASS`, one of the best-known CSS extension languages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你只想使用CSS，你只需要做一点点，就可以了！然而，有许多工具可以帮助你处理样式，添加非常有用的功能，在本节中我们将考虑如何使用`SASS`，这是最著名的CSS扩展语言之一。
- en: If you want to fully learn `SASS`, I'd recommend browsing to [http://sass-lang.com/](http://sass-lang.com/)
    and particularly check out the LEARNING SASS and DOCUMENTATION areas, at  [http://sass-lang.com/guide](http://sass-lang.com/guide)
    and [http://sass-lang.com/documentation/file.SASS_REFERENCE.html](http://sass-lang.com/documentation/file.SASS_REFERENCE.html),
    respectively.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想完全学习`SASS`，我建议浏览[http://sass-lang.com/](http://sass-lang.com/)，特别是查看LEARNING
    SASS和DOCUMENTATION区域，分别位于[http://sass-lang.com/guide](http://sass-lang.com/guide)和[http://sass-lang.com/documentation/file.SASS_REFERENCE.html](http://sass-lang.com/documentation/file.SASS_REFERENCE.html)。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: '`SASS` is a preprocessor that works with `.scss` (*Sassy CSS*) files and produces
    standard CSS files that browsers can work with. The preprocessing step is the
    key to using features that aren''t (at least yet) available in CSS, such as variables,
    nested structures, inheritance, mixins, and many others. You can install and use
    `SASS` as a separate tool, but that isn''t really too appealing; we''ll aim to
    instead include it in the project, so all needed preprocessing will be done automatically.
    Let''s see how to do that.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`SASS`是一个预处理器，可以处理`.scss`（*Sassy CSS*）文件，并生成标准的CSS文件，供浏览器使用。预处理步骤是使用CSS中尚不可用（至少目前还不可用）的功能的关键，例如变量、嵌套结构、继承、混合等。你可以安装并使用`SASS`作为一个独立的工具，但这并不是很吸引人；相反，我们将目标放在将其包含在项目中，以便所有需要的预处理都将自动完成。让我们看看如何做到这一点。'
- en: '`SASS` has two possible syntaxes: an older, indented one, plainly known as
    *the indented syntax*, and the newer SCSS. While the former is more concise, the
    latter has the advantage of being an extension of CSS, which means that any valid
    CSS file you might already have is automatically a valid SCSS file with the very
    same meaning. This is a very good help if you are migrating from CSS to `SASS`,
    so we''ll only use SCSS in the text.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`SASS`有两种可能的语法：一种是较旧的，缩进的语法，简称为*缩进语法*，另一种是较新的SCSS。虽然前者更为简洁，但后者的优势在于它是CSS的扩展，这意味着任何有效的CSS文件在SCSS中也是有效的，具有完全相同的含义。如果你正在从CSS迁移到`SASS`，这将是一个很好的帮助，所以我们在文本中只使用SCSS。'
- en: 'First, we need to install a tool. The developers of `create-react-app` didn''t
    want to include a fixed CSS preprocessor, so you can really add whichever you
    want. There are several `SASS` tools, but the following one is recommended:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装一个工具。`create-react-app`的开发人员不想包含固定的CSS预处理器，所以你可以添加任何你想要的。有几种`SASS`工具，但推荐使用以下工具：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Second, we''ll also have to add an extra line to the `.flowconfig` file, so
    `.scss` files will be properly recognized. The changed section would become as
    follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们还需要在`.flowconfig`文件中添加一行额外的内容，以便正确识别`.scss`文件。更改后的部分将如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we''ll have to modify some scripts. `SASS` preprocessing will run
    in parallel to npm start, and for that we need a package that lets you run several
    commands in parallel:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改一些脚本。`SASS`预处理将与npm start并行运行，为此我们需要一个可以让你并行运行多个命令的包：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now the changed scripts will be the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更改后的脚本将如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see what our new and updated processes do:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的新的和更新的流程做了什么：
- en: '`build-scss` converts `.scss` files in `src/` to `.css` files; we''ll be using
    the latter ones'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build-scss`将`src/`中的`.scss`文件转换为`.css`文件；我们将使用后者。'
- en: '`watch-scss` does an initial conversion of SASS files, and then runs the conversion
    in *watch* mode, running whenever there are new or changed files to process'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watch-scss`对SASS文件进行初始转换，然后以*watch*模式运行，每当有新的或更改的文件需要处理时就会运行。'
- en: '`start-js`, `build-js`, and `storybook-js` are our old `start`, `build`, and
    `storybook` processes, which we won''t be using directly'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start-js`、`build-js`和`storybook-js`是我们的旧`start`、`build`和`storybook`进程，我们将不会直接使用它们。'
- en: '`start` now runs both `watch-scss` and `start-js`, in parallel (because of
    the `-p` option)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`现在同时运行`watch-scss`和`start-js`（因为有`-p`选项）'
- en: '`build` now runs `build-scss` followed by `build-js`, so all SCSS will have
    been converted before building the application'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`现在运行`build-scss`，然后是`build-js`，所以在构建应用程序之前所有的SCSS都已经被转换了。'
- en: '`storybook` runs both `watch-scss` and `storybook-js`, also in parallel'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storybook`现在同时运行`watch-scss`和`storybook-js`，也是并行的。'
- en: You are set! From now on, `.scss` files will be properly processed, and converted
    to `.css` files; let's see how we can make this work for us now.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好了！从现在开始，`.scss`文件将被正确处理，并转换为`.css`文件；现在让我们看看如何让这对我们起作用。
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's create and style a basic component, a colored button, trying to take advantage
    of as many `SASS` features as possible. This will be an extreme example, because
    it's not very likely you'll have such a complex way of creating simple code, but
    we want to highlight `SASS` here.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建和设计一个基本组件，一个有颜色的按钮，尽可能利用尽可能多的`SASS`功能。这将是一个极端的例子，因为你不太可能有这样一个复杂的方式来创建简单的代码，但我们想在这里突出`SASS`。
- en: 'First, the code for the button itself, which we will call `SassButton`. It
    has three props: `normal` (if true, will show *normal* colors; if false, *alert*
    ones); `buttonText`, which will be displayed by the button; and `onSelect`, a
    callback for clicks. I highlighted the CSS-related lines in the following code
    snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是按钮本身的代码，我们将其称为`SassButton`。它有三个props：`normal`（如果为true，将显示*normal*颜色；如果为false，将显示*alert*颜色）；`buttonText`，按钮上将显示的文本；以及`onSelect`，一个点击的回调。我在下面的代码片段中突出显示了与CSS相关的行。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even if working with `SASS` and `.scss` files, you'll be importing the preprocessed
    `.css` output files, not the `.scss` original ones. Be careful not to import a
    `.scss` file by mistake.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用`SASS`和`.scss`文件，你将导入预处理后的`.css`输出文件，而不是`.scss`原始文件。小心不要错误地导入`.scss`文件。
- en: 'We assume that CSS classes `.normalButton` and `.alertButton` do exist; let''s
    now get to creating them. First, let''s define a *partial* SCSS file, `_constants.scss`,
    which will define some variables with colors. The filenames of partial files always
    start with an underscore, and they won''t be converted into CSS; rather, they
    are assumed to be an `@import` from other SCSS files:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设CSS类`.normalButton`和`.alertButton`存在；现在让我们开始创建它们。首先，让我们定义一个*partial*的SCSS文件，`_constants.scss`，它将定义一些颜色变量。部分文件的文件名总是以下划线开头，并且它们不会被转换为CSS；相反，它们被认为是从其他SCSS文件中导入的`@import`。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Variables' names start with a dollar sign, and are a very good way to set standard
    definitions, such as for fonts or colors. If I were to decide that I want to change
    my normal color to be blue, I would have to change it in just a single place,
    and it would be replaced everywhere. Note that I could use `$normalColor` in many
    places, for backgrounds, texts, and more, and all would be updated with a single
    edit.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的名称以美元符号开头，是设置标准定义的一种非常好的方式，比如用于字体或颜色。如果我决定要将我的正常颜色改为蓝色，我只需要在一个地方进行更改，然后它就会在所有地方被替换。请注意，我可以在许多地方使用`$normalColor`，用于背景、文本等，所有这些都将在单个编辑中更新。
- en: Let's now define some *mixins* that can be used to include CSS code, even working
    with parameters. Our `darkenBackground()` mixin will produce code to set the `background-color`
    to a value, and to change the `:hover` attribute of whatever element it's used
    in to a 25% darker version. Note the ampersand in `&:hover`, which stands for
    the parent element, and also the `darken()` function, which is just one of many
    functions that SASS provides, for working with colors, sizes, and so on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一些*mixins*，可以用来包含CSS代码，甚至可以使用参数。我们的`darkenBackground()` mixin将生成代码来设置`background-color`的值，并将`:hover`属性更改为使用它的任何元素的颜色变暗25%。请注意`:hover`中的`&`，它代表父元素，还有`darken()`函数，这只是SASS提供的许多函数之一，用于处理颜色、大小等等。
- en: 'See [http://sass-lang.com/documentation/file.SASS_REFERENCE.html#operations](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#operations)
    for more on this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[http://sass-lang.com/documentation/file.SASS_REFERENCE.html#operations](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#operations)了解更多信息：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can build our styles in a `styles.scss` file. First, we import
    our partials:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`styles.scss`文件中构建我们的样式。首先，我们导入我们的partials：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, to show off other `SASS` features, let''s define a basic placeholder
    class, `%baseButton`, that will be extended. The initial `%` character (similar
    to class or ID initial characters) means that this code is not meant to be directly
    used:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了展示其他`SASS`功能，让我们定义一个基本的占位符类，`%baseButton`，它将被扩展。初始的`%`字符（类似于类或ID的初始字符）表示这段代码不是直接使用的：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let''s extend this base class to create our buttons: we''ll use `@extend`
    for that, and also `@include` to add the output of our mixins to the resulting
    code. We also included some `/* ... */` comments, but you can also use `//` for
    single-line comments:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们扩展这个基本类来创建我们的按钮：我们将使用`@extend`来实现，还有`@include`来将我们的mixins的输出添加到结果代码中。我们还包括了一些`/*
    ... */`的注释，但你也可以使用`//`来进行单行注释：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you are wondering what eventually comes out of all that, the produced `styles.css`
    file is as follows: check it out carefully, and you''ll see the translated mixins
    and constants, and also how extended styles are defined, how `:hover` is used,
    and so on:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道最终产生了什么，生成的`styles.css`文件如下：仔细查看，你会看到翻译后的mixins和常量，以及如何定义扩展样式，如何使用`:hover`等等。
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All we need now is to write a story and check out our buttons in `Storybook`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要编写一个故事，然后在`Storybook`中查看我们的按钮：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When a prop is meant to be `true` or `false`, just including its name makes
    it true. See how in the first story we can just write `normal` instead of `normal={true}`;
    both are equivalent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性应为`true`或`false`时，只需包含其名称即可使其为true。请看第一个故事中我们可以只写`normal`而不是`normal={true}`；两者是等价的。
- en: 'We can see the normal button in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到普通按钮：
- en: '![](img/c2374a15-638f-4fae-827d-d85937d27148.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2374a15-638f-4fae-827d-d85937d27148.png)'
- en: Our normal button, shown in Storybook
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Storybook中展示的普通按钮
- en: 'The alert button, with a hovering cursor, is seen in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 警报按钮，带有悬停光标，如下截图所示：
- en: '![](img/c7e4c158-b2ac-4d13-bf52-822ce982f2ef.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7e4c158-b2ac-4d13-bf52-822ce982f2ef.png)'
- en: Our alert button, with hovering colors
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的警报按钮，带有悬停颜色
- en: 'So, here we have seen a common solution: using `SASS` to create CSS. In the
    next section, let''s get into a more original way of working, by having the CSS
    code right within our JS code rather than separated from it!'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了一个常见的解决方案：使用`SASS`创建CSS。在下一节中，让我们以更原始的方式工作，通过在JS代码中直接使用CSS代码，而不是将其与JS代码分开！
- en: Creating StyledComponents for inline styling
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为内联样式创建StyledComponents
- en: CSS-in-JS is a sometimes controversial topic. Before `React`, it was almost
    mandatory that you'd have a trio of sets of JS, HTML, and CSS separate files.
    When `React` introduced JSX, that was a shot against the trio, because we started
    placing HTML in the JS code. CSS-in-JS is the natural extension of that idea,
    because now we want to also include styling within the same JS files.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CSS-in-JS有时是一个有争议的话题。在`React`之前，几乎是强制性的，您必须有一组JS、HTML和CSS分开的文件。当`React`引入JSX时，这是对这组的一种打击，因为我们开始在JS代码中放置HTML。CSS-in-JS是这个想法的自然延伸，因为现在我们也希望在同一个JS文件中包含样式。
- en: 'A first reaction to this is: *Isn''t that just going back to inline styles?*
    This is a valid question, but inline styles aren''t just powerful enough. While
    you can manage lots of styling by inlining styles, the fact is that there are
    several features that aren''t accessible in this way: keyframes animation, media
    queries, pseudo selectors, and more.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的第一反应是：*这不就是回到了内联样式吗？*这是一个合理的问题，但内联样式并不足够强大。虽然您可以通过内联样式管理大量样式，但事实是，有一些功能无法以这种方式访问：关键帧动画、媒体查询、伪选择器等等。
- en: The idea of going with CSS-in-JS is writing styles by using JS, but then injecting
    those styles in a `<style>` tag within the DOM, so you'll have the full power
    of CSS for your code. Furthermore, this is also well-aligned with component-based
    approaches such as React's, because you manage to pack everything you need together
    in a properly encapsulated way instead of depending on global style files and
    having to deal with CSS's single namespace.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 选择CSS-in-JS的想法是通过使用JS编写样式，然后将这些样式注入DOM中的`<style>`标签中，因此您可以完全利用CSS来编写代码。此外，这也与基于组件的方法非常一致，例如React的方法，因为您设法将您需要的一切都封装在一起，而不是依赖全局样式文件并且必须处理CSS的单一命名空间。
- en: 'There are many packages that promote this way of styling, and out of those,
    we are going to pick `styled-components`, which is one of the best-regarded packages
    for CSS-in-JS styling. Its philosophy is interesting: instead of adding styles
    to components, you create components that incorporate those styles and use them
    everywhere. Let''s start by seeing how to add this package to our code, and then
    move on to using it.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多推广这种样式的包，其中，我们将选择`styled-components`，这是最受推崇的CSS-in-JS样式包之一。它的理念很有趣：不是向组件添加样式，而是创建包含这些样式并在各处使用它们的组件。让我们开始看看如何将这个软件包添加到我们的代码中，然后继续使用它。
- en: For the original talk on CSS-in-JS, by Christopher *vjeux* Chedeau, in which
    he gives the reasons for working with styling done in JS, see [https://speakerdeck.com/vjeux/react-css-in-js](https://speakerdeck.com/vjeux/react-css-in-js).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于CSS-in-JS的原始讨论，由Christopher *vjeux* Chedeau主讲，他阐述了在JS中处理样式的原因，请参阅[https://speakerdeck.com/vjeux/react-css-in-js](https://speakerdeck.com/vjeux/react-css-in-js)。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Installing `styled-components` is quite simple—and note this is not a development
    dependency, because you''ll be actually using the package in your production code,
    not as a separate preprocessing step or anything like that:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`styled-components`非常简单 - 请注意，这不是开发依赖，因为您实际上将在生产代码中使用该软件包，而不是作为单独的预处理步骤或类似的东西：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will be using tagged template literals (which we earlier saw in the *Working
    with* *strings* section of [Chapter 2](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml),
    *Using Modern JavaScript features*), so you may want to refresh that part of the
    book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标记模板文字（我们之前在[第2章](2948d1ab-ac85-4b3a-90f1-f240b7688216.xhtml)的*使用现代JavaScript功能*中看到过），因此您可能希望刷新一下书中的那部分。
- en: Working with `Flow` won't be a problem, because `styled-components` is well
    supported by it, so we won't have to do anything in particular. Finally, for VSC
    you might want to use the `vscode-styled-components` extension to add syntax highlighting.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Flow`不会有问题，因为它对`styled-components`的支持很好，所以我们不需要做任何特别的事情。最后，对于VSC，您可能希望使用`vscode-styled-components`扩展来添加语法高亮显示。
- en: Read the full documentation for `styled-components` at [https://www.styled-components.com/docs](https://www.styled-components.com/docs).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读`styled-components`的完整文档，网址为[https://www.styled-components.com/docs](https://www.styled-components.com/docs)。
- en: How it works…
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s try to recreate the button we build with `SASS`, but through using our
    new tool. We won''t try to mimic the `SASS` code, but we''ll try to apply some
    of the same concepts like defining constants in a separate file, having functions
    work as mixins, and extending a class as we did earlier. We have a problem, because
    `styled-components` doesn''t provide color functions as `SASS` does, so we''ll
    add a new library to take care of that, `color`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过使用我们的新工具来重新创建我们用`SASS`构建的按钮。我们不会尝试模仿`SASS`代码，但我们将尝试应用一些相同的概念，比如在单独的文件中定义常量，使函数作为mixin工作，并扩展类，就像我们之前做的那样。我们有一个问题，因为`styled-components`不像`SASS`那样提供颜色函数，所以我们将添加一个新库来处理这个问题，`color`：
- en: This package provides you with lots of methods to create and manipulate colors,
    so you'll do well by taking a look at its documentation, at [https://github.com/qix-/color](https://github.com/qix-/color).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包为您提供了许多方法来创建和操作颜色，所以您最好看一下它的文档，网址是[https://github.com/qix-/color](https://github.com/qix-/color)。
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we are set. First, we''ll have some basic color constants, in file `constants.js`,
    that could be used everywhere:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了。首先，我们将在`constants.js`文件中定义一些基本的颜色常量，可以在任何地方使用：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's an alternative way of sharing global style data, by means of theming;
    if you are interested, check it out at [https://www.sty](https://www.styled-components.com/docs/advanced#theming)[led-components.com/docs/advanced#theming](https://www.styled-components.com/docs/advanced#theming).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种通过主题来共享全局样式数据的替代方法；如果您感兴趣，请查看[https://www.styled-components.com/docs/advanced#theming](https://www.styled-components.com/docs/advanced#theming)。
- en: 'Now we''ll directly get to defining our component, since all styling will also
    be there. First, we''ll need some imports:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将直接开始定义我们的组件，因为所有的样式也将在那里。首先，我们需要一些导入：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Given this, we can get to the main code. We''ll have a `makeSpan()` function
    that will work as a mixin; we''ll get to use it very shortly, and we''ll see what
    `props` means:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以开始主要的代码了。我们将有一个`makeSpan()`函数，它将作为一个mixin；我们很快就会用到它，并且我们会看到`props`的含义：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we''ll define a `BasicStyledDiv` component, with some basic styling,
    that will do as a base class for our button. (Remember, we are working in this
    unneedlessly complex way, just to highlight several features you may want to use
    in problems that really need it!) This component will roughly be the equivalent
    of our `%baseButton` declaration in `SASS`, from the previous section:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义一个`BasicStyledDiv`组件，带有一些基本样式，作为我们按钮的基类。（记住，我们正在以这种不必要的复杂方式工作，只是为了突出一些您可能想在真正需要的问题中使用的功能！）这个组件将大致相当于我们在上一节中使用`SASS`声明的`%baseButton`：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After, we can create a `StyledDiv` component by extending the previous one.
    Since `styled-component` lets us use functions and expressions, we won''t have
    to create two distinct styles, as we did with `SASS` when we built `.normalButton`
    and `.alertButton`. Also, note that we can use `&` here, meaning a reference to
    the class, just as in `SASS`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过扩展之前的组件来创建一个`StyledDiv`组件。由于`styled-component`让我们可以使用函数和表达式，我们不必像在构建`.normalButton`和`.alertButton`时那样创建两种不同的样式，就像我们在`SASS`中所做的那样。另外，请注意，我们可以在这里使用`&`，表示对类的引用，就像在`SASS`中一样：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What is this `props` parameter we see? When creating a style, the component's
    props will be passed to our code, so we can tweak our style. In this case, if
    the component's `this.props.normal` value is `true`, `NORMAL_COLOR` will be used;
    otherwise, `ALERT_COLOR` will apply. This simplifies our code a lot, because we
    won't have to create styles in a fixed fashion; we can make them adjust to whatever
    we want.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的这个`props`参数是什么？在创建样式时，组件的props将传递给我们的代码，因此我们可以调整我们的样式。在这种情况下，如果组件的`this.props.normal`值为`true`，将使用`NORMAL_COLOR`；否则，将应用`ALERT_COLOR`。这大大简化了我们的代码，因为我们不必以固定的方式创建样式；我们可以使它们调整到我们想要的任何东西。
- en: 'After all of this, the code for our button itself is very simple:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，我们的按钮本身的代码非常简单：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Writing a story to check this is actually trivial, because we only need to
    copy the previous one we wrote for the `SASS` style button and substitute `StyledButton`
    for `SassButton`; no need for anything else. (OK, I also changed some strings
    for clarity, but those edits are trivial.) If we launch `Storybook`, we can quickly
    verify that our new button works in the same way as our previous one; see following
    screenshot for evidence of that:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个故事来检查这实际上是微不足道的，因为我们只需要复制我们为`SASS`样式按钮编写的上一个故事，并用`StyledButton`替换`SassButton`；不需要其他任何东西。（好吧，我还为了清晰起见改变了一些字符串，但这些修改微不足道。）如果我们启动`Storybook`，我们可以快速验证我们的新按钮与之前的按钮以相同的方式工作；请参见以下截图作为证据：
- en: '![](img/50e77145-b3bd-4c02-9c69-e91a0659affe.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50e77145-b3bd-4c02-9c69-e91a0659affe.png)'
- en: Using `styled-components` is as successful as SASS, and more "JavaScripty"
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`styled-components`与SASS一样成功，而且更“JavaScripty”
- en: If you want to get some specific tips, and learn some new tricks, check out [https://github.com/styled-components/styled-components/blob/master/docs/tips-and-tricks.md](https://github.com/styled-components/styled-components/blob/master/docs/tips-and-tricks.md).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想获得一些具体的提示，并学习一些新技巧，请查看[https://github.com/styled-components/styled-components/blob/master/docs/tips-and-tricks.md](https://github.com/styled-components/styled-components/blob/master/docs/tips-and-tricks.md)。
- en: Making your application responsive to screen sizes
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的应用程序对屏幕尺寸做出响应
- en: Creating a web application means that you cannot assume any given display size.
    In fact, the user may change the browser's window size, and your application should
    somehow respond to that, rearranging whatever is shown on screen to better work
    with the current screen dimensions. If your web application is capable of this
    reorganization, it's said to be *responsive*. Today, given the extreme range of
    devices with browsers (ranging from small phone handsets to very large flat screens),
    doing responsive design is really a must, so in this section we'll see how to
    work with this. I'll assume you are already aware of CSS concepts such as grids
    and columnar designs; please read up on them if not.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Web应用程序意味着您不能假设任何给定的显示尺寸。实际上，用户可能会更改浏览器窗口的大小，您的应用程序应该以某种方式对此做出响应，重新排列屏幕上显示的内容，以更好地适应当前的屏幕尺寸。如果您的Web应用程序能够进行这种重新组织，就可以说它是*响应式*的。如今，鉴于具有浏览器的设备范围极其广泛（从小型手机到非常大的平板显示屏），进行响应式设计确实是必不可少的，因此在本节中我们将看到如何处理这个问题。我假设您已经了解CSS概念，比如网格和列设计；如果不了解，请阅读相关内容。
- en: 'To allay a common, fairly obvious question, if you are aware of current trends
    in CSS, you may ask why aren''t we using Flexbox or CSS Grids, both of which easily
    allow responsive designs. The answer lies in availability: if you check places
    such as[ https://www.caniuse.com/](https://www.caniuse.com/), you''ll find out
    that both those features are only recently available, and thus users may not yet
    have access to them. To sum it up, note the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除一个常见的，相当明显的问题，如果你了解当前CSS的趋势，你可能会问为什么我们不使用Flexbox或CSS Grids，这两者都可以轻松实现响应式设计。答案在于可用性：如果你查看诸如[https://www.caniuse.com/](https://www.caniuse.com/)这样的地方，你会发现这些功能最近才可用，因此用户可能还没有访问权限。总之，注意以下内容：
- en: Internet Explorer has partial support of both features, with many bugs
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Internet Explorer对这两个功能有部分支持，但有许多错误
- en: Edge supports them only since version 17, dated April 2018
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Edge自2018年4月的版本17开始支持它们
- en: FireFox supports them since version 60, dated May 2018
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FireFox自2018年5月的版本60开始支持它们
- en: Safari supports them since version 11.1, dated March 2018
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Safari自2018年3月的11.1版本开始支持它们
- en: Chrome supported FlexBox since version 49, from March 2016, but CSS Grid only
    since version 66, dated April 2018
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome自2016年3月的版本49开始支持FlexBox，但自2018年4月的版本66开始支持CSS Grid
- en: As you can see, if you want to use these features, as of today (December 2018),
    only a few of your users may have access to them, and for the vast majority, scrambled
    up displays would be the result. So, even if it means working with a larger library
    than need be, we'll go with a current-day standard, as we'll see in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，如果你想使用这些功能，截至今天（2018年12月），只有少数用户可能可以访问它们，而对于绝大多数用户来说，显示可能会混乱。因此，即使这意味着使用比需要更大的库，我们将选择当前标准，正如我们将在下一节中看到的。
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: One of the most popular frontend libraries for the design of websites and web
    applications, is `Bootstrap`, which has been available since August 2011; it's
    about seven years old. It has included responsive design handling since version
    2\. *Mobile First Design* (so you should first get your design to work in smaller
    devices, and only afterwards worry about adding handling for larger screens) was
    included in version 3, and `SASS` support appeared in version 4\. Apart from responsive
    design support, `Bootstrap` also offers other features, such as components, typography,
    and more utilities, so you should probably not miss checking the whole documentation
    at [https://getbootstrap.com/docs/4.1/getting-started/introduction/](https://getbootstrap.com/docs/4.1/getting-started/introduction/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bootstrap`是最受欢迎的用于网站和Web应用程序设计的前端库之一，自2011年8月就已经可用；它已经有大约七年的历史了。自第2版以来就包括了响应式设计处理。*移动优先设计*（所以你应该首先让你的设计在较小的设备上工作，然后才担心为较大的屏幕添加处理）是在第3版中包括的，而`SASS`支持出现在第4版中。除了响应式设计支持，`Bootstrap`还提供其他功能，如组件、排版和更多实用工具，所以你可能不要错过查看整个文档[https://getbootstrap.com/docs/4.1/getting-started/introduction/](https://getbootstrap.com/docs/4.1/getting-started/introduction/)。'
- en: '`Bootstrap` is currently GitHub''s second most starred project, following FreeCodeCamp''s
    first place. And if you wonder, `React` is practically tied at third place with
    another framework, `Vue`, and with EBook''s Foundation set of free programming
    books. You can check the results by yourself at [https://github.com/search?o=desc&q=stars%3A%3E1&s=stars&type=Repositories](https://github.com/search?o=desc&q=stars%3A%3E1&s=stars&type=Repositories).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bootstrap`目前是GitHub的第二大关注项目，紧随FreeCodeCamp的第一名。如果你想知道，`React`实际上几乎与另一个框架`Vue`和EBook的免费编程书籍套装的第三名并列。你可以在[https://github.com/search?o=desc&q=stars%3A%3E1&s=stars&type=Repositories](https://github.com/search?o=desc&q=stars%3A%3E1&s=stars&type=Repositories)上自行查看结果。'
- en: 'To install `Bootstrap`, we just need the usual `npm` command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`Bootstrap`，我们只需要常规的`npm`命令：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can save your work by downloading pre-build images, both for CSS and JS;
    see [https://getbootstrap.com/docs/4.1/getting-started/download/](https://getbootstrap.com/docs/4.1/getting-started/download/)
    for those options. Alternatively, there exists a `React` package at [https://react-bootstrap.github.io/](https://react-bootstrap.github.io/), `react-bootstrap`,
    which today only supports `Bootstrap` version 3, but promises forthcoming full
    support for `Bootstrap` version 4\. Yet another possible option you may want to
    look into is `reactstrap`, at [https://reactstrap.github.io/](https://reactstrap.github.io/).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过下载预构建的图像（包括CSS和JS）来保存你的工作；查看[https://getbootstrap.com/docs/4.1/getting-started/download/](https://getbootstrap.com/docs/4.1/getting-started/download/)获取这些选项。另外，还有一个`React`包[https://react-bootstrap.github.io/](https://react-bootstrap.github.io/)，`react-bootstrap`，它目前只支持`Bootstrap`第3版，但承诺即将全面支持`Bootstrap`第4版。你可能还想看看另一个可能的选择，`reactstrap`，在[https://reactstrap.github.io/](https://reactstrap.github.io/)。
- en: '`Bootstrap` provides lots of features, including:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bootstrap`提供了许多功能，包括：'
- en: '*Components*, such as alerts, buttons, dropdowns, navigation bars, and much
    more; see [https://getbootstrap.com/docs/4.1/components](https://getbootstrap.com/docs/4.1/components)
    for a complete list'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件*，如警报、按钮、下拉菜单、导航栏等等；查看[https://getbootstrap.com/docs/4.1/components](https://getbootstrap.com/docs/4.1/components)获取完整列表'
- en: '*Tables*, a common third-party component, with many configuration possibilities;
    see [https://getbootstrap.com/docs/4.1/content/tables](https://getbootstrap.com/docs/4.1/content/tables)
    for more'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表格*，一个常见的第三方组件，有许多配置选项；查看[https://getbootstrap.com/docs/4.1/content/tables](https://getbootstrap.com/docs/4.1/content/tables)获取更多信息。'
- en: '*Typography-related elements*, dealing with the many fonts you''ll use in your
    design; check out [https://getbootstrap.com/docs/4.1/content/typography/S](https://getbootstrap.com/docs/4.1/content/typography/)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与排版相关的元素*，处理设计中使用的许多字体；查看[https://getbootstrap.com/docs/4.1/content/typography/S](https://getbootstrap.com/docs/4.1/content/typography/)'
- en: '*Styling details*, such as borders, colors, shadows, sizing, and more; read [https://getbootstrap.com/docs/4.1/utilities/](https://getbootstrap.com/docs/4.1/utilities/)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*样式细节*，如边框、颜色、阴影、大小等；阅读[https://getbootstrap.com/docs/4.1/utilities/](https://getbootstrap.com/docs/4.1/utilities/)'
- en: In any case, we won't be specifically dealing with the preceding list, since
    it's basically just a matter of styling, and we've already done that. We are going
    to focus, instead, on positioning elements, changing their sizes, and even hiding
    or showing them according to the current screen size; let's move on to that now.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们不会专门处理前面的列表，因为这基本上只是样式的问题，而我们已经做过了。相反，我们将专注于定位元素，改变它们的大小，甚至根据当前屏幕大小隐藏或显示它们；让我们现在继续进行。
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Bootstrap` uses a grid system, based on 12 columns, with breakpoints for several
    device sizes, based on media queries:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bootstrap`使用基于12列的网格系统，具有基于媒体查询的多个设备尺寸的断点：'
- en: '`xs`: very small, such as portrait phones, less than 576 pixels wide'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xs`：非常小，例如纵向手机，宽度小于576像素'
- en: '`sm`: small, like landscape phones, up to 768 pixels'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sm`：小，如横向手机，最大到768像素'
- en: '`md`: medium, like tablets, up to 992 pixels'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`md`：中等，如平板电脑，最大到992像素'
- en: '`lg`: large, like desktops, up to 1200 pixels'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lg`：大，如台式机，最大到1200像素'
- en: '`xl`: extra large, over 1200 pixels'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xl`：超大，超过1200像素'
- en: These limits aren't hardcoded, and may be changed. Other common values are 1024
    and 1440, instead of 992 and 1200\. Yet another possibility is considering HD
    devices (1920x1080) and 4K devices, with a resolution of 2560x1600.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制并非是硬编码的，可以更改。其他常见的值是1024和1440，而不是992和1200。另一个可能性是考虑高清设备（1920x1080）和4K设备，分辨率为2560x1600。
- en: Whenever you place elements, you specify their width in terms of columns, and
    positions will be arranged depending on the available row space, moving to new
    rows if need be. You can also allow for different sizing and ordering of elements
    depending on screen dimensions, and even hide or show components (in full, or
    partially) depending on available space.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '无论何时放置元素，您都可以指定它们的宽度以列为单位，并且根据可用的行空间进行排列，如果需要，可以移动到新的行。您还可以根据屏幕尺寸允许元素的不同大小和顺序，并根据可用空间甚至隐藏或显示组件（完全或部分）。 '
- en: Resizing elements
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整元素大小
- en: 'By using `col-xx-yy` classes (such as `col-sm-3` or `col-md-5`) you can decide
    the size of elements depending on the current screen width. The following code
    example shows that—and notice I avoided a separate style sheet, just to simplify:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`col-xx-yy`类（例如`col-sm-3`或`col-md-5`），您可以根据当前屏幕宽度决定元素的大小。以下代码示例显示了这一点，并请注意我避免了使用单独的样式表，只是为了简化：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see how rendering changes with screen size; see following image:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到渲染如何随着屏幕尺寸的变化而改变；请参见以下图片：
- en: '![](img/6e9d98ed-0160-4e54-b181-991a0da3ec35.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e9d98ed-0160-4e54-b181-991a0da3ec35.png)'
- en: The same elements, rendered at different screen widths
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的元素，在不同的屏幕宽度下呈现
- en: At the smallest screen size, all elements are rendered at the same size vertically;
    this would suit, logically, a very small device. As we enlarge the window size,
    the 7/3 element now takes up 7 columns, while the 2/6, 1/5, and 1/3 elements are
    narrow. When we increase the window width even more, note the 7/3 element takes
    only three columns, and the 3 other elements become wide.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小的屏幕尺寸下，所有元素在垂直方向上都以相同的大小呈现；这在逻辑上适合非常小的设备。随着窗口大小的增加，7/3元素现在占据了7列，而2/6、1/5和1/3元素变窄了。当我们进一步增加窗口宽度时，请注意7/3元素仅占据了三列，而其他3个元素变宽了。
- en: Of course, it's highly unlikely you'd ever come up with this weird design, with
    so many different widths and such peculiar resizing rules, but the point here
    is that by using the `Bootstrap` grid, elements can vary in size and gracefully
    flow to different rows, without having to do anything special.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您几乎不太可能会设计出这种奇怪的设计，具有如此多不同的宽度和如此奇特的调整规则，但这里的重点是，通过使用`Bootstrap`网格，元素可以在大小上变化，并且可以优雅地流动到不同的行，而无需做任何特殊处理。
- en: Reordering elements
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新排序元素
- en: 'In the previous example, we saw how components resized themselves, and flowed
    across lines. However, there are other requirements: for instance, you could want
    a component to appear at a different position for a given screen size. Fortunately,
    `Bootstrap` also allows for that. Let''s have an element that will change its
    place among the rest:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了组件如何调整大小并跨行流动。然而，还有其他要求：例如，您可能希望组件在给定屏幕尺寸下出现在不同位置。幸运的是，`Bootstrap`也允许这样做。让我们有一个元素会在其他元素中改变位置：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For small devices, our special component should be the first, and for medium
    ones, it should move to the end. For very small devices (for which we haven''t
    provided any special rules) it should appear at its normal place. See the following
    images:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小设备，我们的特殊组件应该是第一个，对于中等设备，它应该移动到最后。对于非常小的设备（我们没有提供任何特殊规则），它应该出现在正常位置。请参见以下图片：
- en: '![](img/18416619-a6ae-4049-9837-2cdb861a6a2f.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18416619-a6ae-4049-9837-2cdb861a6a2f.png)'
- en: Components can also change their relative positions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 组件还可以改变它们的相对位置。
- en: This takes care of a common second set of requirements, letting you vary at
    will the sequence in which components appear on screen. We only have one more
    case, which we'll see in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这满足了常见的第二组要求，让您可以随意变化组件在屏幕上出现的顺序。我们只有一个更多的情况，我们将在下一节中看到。
- en: Hiding or showing elements
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏或显示元素
- en: 'Our final type of design rule is that some components (or parts of them) should
    possibly not be displayed at given screen sizes. For instance, if you were providing
    information about a movie, in large screens you could include a still from a scene,
    plus pictures of the main actors, in addition to the movie title and a full description,
    but in small screens you could make do with just the movie title and basic information.
    Let''s show this kind of requirement with a couple of components: one will be
    fully hidden, while the other will just hide part of its contents:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终设计规则是，某些组件（或其中的部分）在给定的屏幕尺寸下可能不应该显示。例如，如果您正在提供有关电影的信息，在大屏幕上，您可以包括一场戏的静态画面，以及主要演员的照片，以及电影标题和完整描述，但在小屏幕上，您可能只需要电影标题和基本信息。让我们用一对组件展示这种要求：一个将完全隐藏，而另一个将只隐藏部分内容：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To see this in action, check out the following image:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此操作，请查看以下图片：
- en: '![](img/f9bd9667-d8dd-4d4f-9cdc-964df4ab102c.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9bd9667-d8dd-4d4f-9cdc-964df4ab102c.png)'
- en: A component fully disappears in small screens, while others show different contents
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件在小屏幕上完全消失，而其他组件显示不同的内容
- en: The 0/4 component is set to be shown only at small screens and more, so in the
    left side screenshot it just disappears. The other component shows two lines in
    the smaller screen, but fuller contents (OK, three lines instead of two) in bigger
    screens.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 0/4组件设置为仅在小屏幕及更大屏幕上显示，因此在左侧截图中它就消失了。另一个组件在较小的屏幕上显示两行，但在较大的屏幕上显示更多内容（好吧，是三行而不是两行）。
- en: Making your application adaptive for enhanced usability
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的应用程序适应以提高可用性
- en: 'By using grids and all the styles we saw in the previous section, in many cases
    you won''t need anything extra in order to build a responsive website. However,
    in some cases moving components around, resizing them, or even hiding part or
    all of them, isn''t enough. For example, you may actually want to show totally
    different components for small and large screens—say, a screen with three tabs
    for a phone, showing only one tab at a time, but a three-column display for a
    desktop, showing everything simultaneously. Changes could be even more drastic:
    you might decide that some functionality isn''t going to be available on mobile
    devices, but only included in large screens. So, instead of doing responsive design,
    you are delving into adaptive design, meaning that the actual design and functions
    of the screen will change, and then we need to be able to handle internal changes
    in code.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我们在前一节中看到的网格和所有样式，在许多情况下，您不需要额外的东西来构建响应式网站。然而，在某些情况下，移动组件，调整它们的大小，甚至隐藏部分或全部内容是不够的。例如，您可能确实希望在小屏幕和大屏幕上显示完全不同的组件
    - 比如，手机上有三个选项卡的屏幕，一次只显示一个选项卡，但在台式机上有三列显示，同时显示所有内容。变化可能会更加激烈：您可能会决定某些功能在移动设备上不可用，而只包含在大屏幕上。因此，您不是在进行响应式设计，而是在进行自适应设计，这意味着屏幕的实际设计和功能将发生变化，然后我们需要能够处理代码中的内部变化。
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: If you wanted to do adaptive design on your own, you could certainly set things
    up to listen for screen size or orientation changes, and then produce some components
    or other. While there's nothing wrong with this approach, it can be made far simpler
    by installing `react-responsive`, a package that takes care of all that—you just
    specify the conditions under which some components will be rendered, and whenever
    they are satisfied, those components will be rendered. On any size or orientation
    change, the package will take care of whatever re-rendering is needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己进行自适应设计，您当然可以设置监听屏幕尺寸或方向变化，然后生成一些组件或其他内容。虽然这种方法没有错，但通过安装`react-responsive`，可以使其变得更简单，该软件包会处理所有这些事情
    - 您只需指定在满足某些条件时将渲染一些组件，每当满足条件时，这些组件将被渲染。在任何尺寸或方向变化时，该软件包将处理所需的任何重新渲染。
- en: 'Installation requires the usual `npm` command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 安装需要使用常规的`npm`命令：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The key component in this package is called `<MediaQuery>`, and lets you work
    with either media queries, or by using props, in a fashion more like `React`;
    I prefer the latter, but check out the documentation if you are interested about
    the more CSS-y option. Let's now see how it is used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该软件包中的关键组件称为`<MediaQuery>`，它让您可以使用媒体查询或使用属性来处理，更像是`React`；我更喜欢后者，但如果您对更像CSS的选项感兴趣，请查看文档。现在让我们看看它是如何使用的。
- en: Read more about `react-responsive` at [https://github.com/contra/react-responsive](https://github.com/contra/react-responsive).
    There are many more features than I'll be showing in this text.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://github.com/contra/react-responsive](https://github.com/contra/react-responsive)上阅读有关`react-responsive`的更多信息。它的功能比我在本文中展示的要多得多。
- en: How it works…
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Basically, all you have to do in order to detect any size changes is to produce
    one or more `<MediaQuery>` components when rendering, and those whose requirements
    are met will actually be rendered, and the rest won't appear on the page.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，您只需要在渲染时生成一个或多个`<MediaQuery>`组件来检测任何尺寸变化，那些满足要求的组件将被实际渲染，而其余的将不会出现在页面上。
- en: 'Let''s write a very basic example with plenty of media queries, to see the
    coding style you''ll be using. The following is an example given in the react-responsive
    GitHub page; we''ll just try to detect some aspects of the current device and
    window:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个非常基本的例子，其中包含大量的媒体查询，以查看您将要使用的编码风格。以下是在react-responsive GitHub页面上给出的一个例子；我们将尝试检测当前设备和窗口的一些方面：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I defined the four size constants (`XS`, `SM`, `MD`, and `LG`) to match the
    values used by `Bootstrap`, but you could certainly work with other sizes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了四个大小常量（`XS`，`SM`，`MD`和`LG`）以匹配`Bootstrap`使用的值，但您当然可以使用其他大小。
- en: 'You can also modify the values in `Bootstrap`, so it will work with different
    breakpoints: see [https://getbootstrap.com/docs/4.1/layout/grid/#grid-tiers](https://getbootstrap.com/docs/4.1/layout/grid/#grid-tiers)
    for more on this.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以修改`Bootstrap`中的值，以便它可以与不同的断点一起使用：请参阅[https://getbootstrap.com/docs/4.1/layout/grid/#grid-tiers](https://getbootstrap.com/docs/4.1/layout/grid/#grid-tiers)了解更多信息。
- en: Whenever our `App` component is rendered, the media queries are executed, and
    depending on their result, components will or won't be rendered. In our case,
    we are just producing some `<div>` instances with text, but it should be obvious
    that you could actually produce any other kind of components.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的`App`组件被渲染时，媒体查询都会被执行，根据它们的结果，组件将会或不会被渲染。在我们的情况下，我们只是生成一些带有文本的`<div>`实例，但显然您可以实际上生成任何其他类型的组件。
- en: 'We can run this application in Chrome, and see how it produces different contents
    as we resize the window: see the following image :'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Chrome中运行这个应用程序，并在调整窗口大小时查看它如何生成不同的内容：参见下图：
- en: '![](img/2fe187d5-6c91-45dd-a97f-28ef0c285530.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fe187d5-6c91-45dd-a97f-28ef0c285530.png)'
- en: Our component automatically reacts to any screen size changes, and produces
    different components, even if our example lacks variety!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件会自动对任何屏幕尺寸的变化做出反应，并生成不同的组件，即使我们的示例缺乏多样性！
- en: 'Alternatively, you could use the device toggle in the toolbar, and then you''d
    be also able to see your application as it would look in a phone or tablet; take
    a look at the following screenshot for a sample of this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在工具栏中使用设备切换功能，然后还可以查看您的应用程序在手机或平板电脑上的外观； 请查看以下屏幕截图以了解示例：
- en: '![](img/fe218775-5aee-48e5-a7c0-783ce0bae171.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe218775-5aee-48e5-a7c0-783ce0bae171.png)'
- en: Chrome's Developer Tools include a device toggle that lets you simulate multiple
    kinds of devices, including phones and tablets as well
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome的开发者工具包括设备切换功能，可以模拟多种设备，包括手机和平板电脑
- en: 'Working with `Bootstrap` for simple adjustments, and `react-responsive` for
    more complex work, you can ensure your application will fit whatever device it''s
    run on. Let''s now move on to a different kind of situation: running in different
    countries or regions!'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Bootstrap`进行简单调整，使用`react-responsive`进行更复杂的工作，可以确保您的应用程序适合在任何设备上运行。 现在让我们转向另一种情况：在不同的国家或地区运行！
- en: Making a global application with internationalization and localization
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作具有国际化和本地化的全球应用
- en: 'With the growing globalization levels, it''s most likely that any website you
    write may be required to be in two or more languages. In Canada, English and French
    would be mandatory; in Switzerland, four languages could be asked for; and even
    in a (supposedly single-language) country like the United States, a Spanish version
    of the site could well be added to the English one. Of course, translation isn''t
    enough: dates and currency amounts also require different formatting depending
    on the country, so we''ll have to take care of that too.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 随着全球化水平的不断提高，您编写的任何网站可能需要使用两种或更多种语言。 在加拿大，英语和法语是强制性的； 在瑞士，可能需要四种语言； 甚至在（据说是单一语言的）美国，西班牙语版本的网站也可能会添加到英语版本中。
    当然，仅仅翻译是不够的：日期和货币金额也需要根据国家的不同格式进行不同的格式化，因此我们也必须处理这一点。
- en: 'Some definitions, now: being able to adapt your software to different languages
    is called *internationalization*, usually abbreviated as *i18n*—the 18 stands
    for the 18 letters between the initial *i* and the final *n*. Then, the specific
    process of configuring the system for a specific area is called *localization*,
    abbreviated as *l10n* for similar reasons as in i18n. Finally, if you really are
    into these *numeronyms*, the combination of internationalization and localization
    is also known as *globalization*, shortened to *g11n*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一些定义：能够使软件适应不同语言称为*国际化*，通常缩写为*i18n*——18代表了*国际化*一词中的初始*i*和最终*n*之间的18个字母。然后，配置系统以适应特定区域的具体过程称为*本地化*，缩写为*l10n*，原因与*i18n*类似。最后，如果您真的喜欢这些*数字字母缩写*，国际化和本地化的组合也被称为*全球化*，缩写为*g11n*。
- en: This pair of definitions is based upon a document by the W3C, at [https://www.w3.org/International/questions/qa-i18n](https://www.w3.org/International/questions/qa-i18n).
    There, they define that "Internationalization is the design and development [...]
    that enables easy localization for target audiences that vary in culture, region,
    or language" and "Localization refers to the adaptation [...] to meet the language,
    cultural and other requirements of a specific target market (a locale)."
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这对定义是基于W3C的一份文件，网址为[https://www.w3.org/International/questions/qa-i18n](https://www.w3.org/International/questions/qa-i18n)。
    在那里，他们定义了“国际化是设计和开发[...]，使得易于适应不同文化，地区或语言的目标受众”，“本地化是指根据特定目标市场（区域设置）的语言，文化和其他要求进行调整”。
- en: Fortunately, handling these aspects is simple in `React`, and only requires
    some planning ahead, as we'll see in this recipe.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在`React`中处理这些方面很简单，只需要提前进行一些规划，我们将在本教程中看到。
- en: How to do it…
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'A good package for handling all i18n concerns is `i18next`. We can install
    it, together with a package for detecting the browser language, with the following
    command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 处理所有i18n问题的一个很好的包是`i18next`。 我们可以使用以下命令安装它，以及一个用于检测浏览器语言的包：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You''ll also have to decide on a fallback language (probably `"en"`, for English),
    and provide translations for all strings used in your application. To get a taste
    of this, for a fictitious data entry form (in a really very small application;
    usually, you''d have hundreds of translations!) you could have the following `translations.en.json`
    file for English:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要决定一个备用语言（可能是“en”，表示英语），并为应用程序中使用的所有字符串提供翻译。 为了体验一下，对于一个虚构的数据输入表单（在一个非常小的应用程序中；通常情况下，您可能会有数百种翻译！），您可以为英语准备以下`translations.en.json`文件：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you decided to also provide Spanish (`"es"`) translations, you''d add another
    file, `translations.es.json`. (Note: you can name your files in any way you wish,
    and you don''t have to follow my examples.) This new JSON file has the very same
    keys, but translated into Spanish:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定还提供西班牙语（“es”）翻译，您将添加另一个文件`translations.es.json`。 （注意：您可以以任何您希望的方式命名文件，不必遵循我的示例。）这个新的JSON文件具有完全相同的键，但是用西班牙语翻译：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The idea is that, whenever you want to display some text, you'll refer to it
    by its key (such as `"details"` or `"number"`), eventually providing extra parameters
    (as in `"summary"`), and the translation package will pick the correct string
    to display; let's see how it works by completing an example.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其思想是，每当您想要显示一些文本时，您将通过其键（例如“details”或“number”）引用它，最终提供额外的参数（如“summary”），然后翻译包将选择正确的字符串进行显示；
    让我们通过完成一个示例来看看它是如何工作的。
- en: 'The `i18next` package can also deal with plurals and specific formatting rules.
    You''ll first have to initialize it, as follows; we are creating a `i18n` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`i18next`包还可以处理复数和特定格式规则。 您首先必须初始化它，如下所示； 我们正在创建一个`i18n`文件：'
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Some details about the code should be noted:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码的一些细节应该注意：
- en: The `use(...)` method tells `i18next` to use the browser language detector package.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use（...）`方法告诉`i18next`使用浏览器语言检测器包。'
- en: In the `resources` attribute, you have to provide the set of translations for
    each language, which we imported from our JSON files.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`resources`属性中，您必须为每种语言提供一组翻译，我们从我们的JSON文件中导入。
- en: '`fallbackLng` specifies that English (`"en"`) will be the default language.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fallbackLng`指定英语（`"en"`）将是默认语言。'
- en: '`ns` and `defaultNS` define the namespace for translations, usually just *translations*
    as we used in the `resources` attribute.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ns`和`defaultNS`定义了翻译的命名空间，通常只是*translations*，就像我们在`resources`属性中使用的那样。'
- en: '`debug` is a good tool, for it will log to the console any keys you want to
    translate, but that haven''t been defined in the resources.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`是一个很好的工具，因为它将在控制台记录任何您想要翻译但在资源中未定义的键。'
- en: '`interpolation.escapeValue` gives you the option to escape all values: you
    could use it to display unchecked user-entered values, but we don''t need it here.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interpolation.escapeValue`为您提供了转义所有值的选项：您可以使用它来显示未选中的用户输入值，但我们在这里不需要它。'
- en: '`interpolation.format` lets you define a special formatting function that should
    produce whatever output you desire for a given value, in a specific format, for
    a given language. In our case, we used it with the `summary` and `summary_plural`
    keys to format dates in the proper style: month/day/year for English, day/month/year
    for Spanish. You could also use this function to format numbers as currency, for
    example.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interpolation.format`允许您定义一个特殊的格式化函数，该函数应该为给定值以特定格式在特定语言下产生您想要的任何输出。在我们的案例中，我们将其与`summary`和`summary_plural`键一起使用，以便以适当的样式格式化日期：英语为月/日/年，西班牙语为日/月/年。您还可以使用此函数将数字格式化为货币，例如。'
- en: You can check the full documentation for `i18next` at [https://www.i18next.com/](https://www.i18next.com/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.i18next.com/](https://www.i18next.com/)上查看`i18next`的完整文档。
- en: How it works…
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Imagine we are defining an input form that lets you order some things, picking
    their color and deciding a top date for delivery. Our `<I18nForm>` component could
    be coded as follows—and note that we are just focusing on the input form, paying
    no attention to actually *doing* anything with the user data! Also, pay no attention
    to the poor UI design; once again, we care about translation here, so I wanted
    as little extra JSX code as possible:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在定义一个输入表单，让您订购一些东西，选择它们的颜色，并决定交付的最终日期。我们的`<I18nForm>`组件可以编码如下-请注意，我们只关注输入表单，不关注实际*执行*用户数据！同样，不要关注糟糕的UI设计；再次强调，我们关心的是翻译，所以我希望尽可能少的额外JSX代码：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Some details about the code should be noted:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意代码的一些细节：
- en: Passing extra parameters for interpolation (as with the `"summary"` key) is
    done via an object, with the desired parameters
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对象传递插值的额外参数（就像`"summary"`键一样）是通过对象完成的，使用所需的参数
- en: 'If you want to have distinct lines for singular and plural versions, you have
    to define two keys as we did here: `summary` for singular, and `summary_plural`
    for plural, and then `i18next` will decide which to used based on the value of
    the `count` parameter'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要为单数和复数版本定义不同的行，您必须像我们在这里做的那样定义两个键：单数的`summary`和复数的`summary_plural`，然后`i18next`将根据`count`参数的值决定使用哪个
- en: 'How can we deal with dynamic language changes? We provided two buttons to call
    `i18n.changeLanguage(...)`, but how do we re-render components? There are (at
    least) three ways of doing so:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理动态语言更改？我们提供了两个按钮来调用`i18n.changeLanguage(...)`，但是我们如何重新渲染组件？至少有三种方法可以做到这一点：
- en: You can listen to the `"languageChanged"` event and force an update, which was
    what we did here. (We use `.on(...)` to set our component to listen, and `.off(...)`
    to stop it later, when unmounting.)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以监听`"languageChanged"`事件并强制更新，这就是我们在这里所做的。（我们使用`.on(...)`来设置我们的组件进行监听，使用`.off(...)`在卸载时停止它。）
- en: Another solution would be to include the currently selected language in the
    application state (we'll be looking into this in the next chapter) and you could
    supply it to components via props, so `React` will re-render everything on a language
    change.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个解决方案是将当前选择的语言包含在应用程序状态中（我们将在下一章中进行讨论），并且您可以通过props将其提供给组件，因此`React`将在语言更改时重新渲染所有内容。
- en: And, finally, you could use the `react-i18next` framework package at [https://github.com/i18next/react-i18next](https://github.com/i18next/react-i18next)
    to provide an even more seamless integration.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，您可以使用`react-i18next`框架包在[https://github.com/i18next/react-i18next](https://github.com/i18next/react-i18next)上提供更无缝的集成。
- en: 'We can test our translations with a very simple story:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个非常简单的故事来测试我们的翻译：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When the story is loaded, it looks as seen in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当故事加载时，它看起来如下屏幕截图所示：
- en: '![](img/802ede23-becc-4276-b0dd-98a456f2fb6b.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/802ede23-becc-4276-b0dd-98a456f2fb6b.png)'
- en: Our input form, with initial values, displayed in English
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入表单，带有初始值，显示为英文
- en: 'If you change the quantity, the text at the bottom will be updated accordingly;
    see the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改数量，底部的文本将相应更新；请参阅以下屏幕截图：
- en: '![](img/32777800-580b-4b49-9ae1-c24fdfd486fc.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32777800-580b-4b49-9ae1-c24fdfd486fc.png)'
- en: If we order more than one thing, the plural translation is used
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们订购多件物品，将使用复数翻译。
- en: 'And, if you change the language to Spanish, all texts will be automatically
    translated; take a look at the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，如果将语言更改为西班牙语，所有文本将自动翻译；请查看以下屏幕截图：
- en: '![](img/50b14774-fe5e-481d-842f-aec97602e0f4.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50b14774-fe5e-481d-842f-aec97602e0f4.png)'
- en: By listening to the language change event, we can force the component to re-render
    itself and show translations for the newly chosen language
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过监听语言更改事件，我们可以强制组件重新渲染自身，并显示新选择语言的翻译
- en: 'A small detail: whenever you use a date `<input>` element, dates are formatted
    according to your computer''s locale, so the displayed value doesn''t change for
    Spanish. However, the element''s value is always the same, in ISO format: in our
    case, `2018-09-22`. You can solve this by using a special handcrafted component,
    but we won''t be doing that, since what we cared about was showing how translations
    work.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小细节：每当您使用日期`<input>`元素时，日期将根据您计算机的区域设置进行格式化，因此对于西班牙语，显示的值不会改变。但是，元素的值始终相同，采用ISO格式：在我们的案例中是`2018-09-22`。您可以通过使用特殊手工制作的组件来解决这个问题，但我们不会这样做，因为我们关心的是展示翻译是如何工作的。
- en: As we saw, preparing an application for international usage isn't really a very
    hard problem. Even if you don't plan on doing it at the beginning, it will pay
    to work in this way; having to retrofit translations in existing code can be harder.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，为国际使用准备应用程序并不是一个非常困难的问题。即使您一开始没有计划这样做，以这种方式工作也是值得的；在现有代码中进行翻译可能更难。
- en: Setting up for accessibility (a11y)
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为辅助功能设置（a11y）
- en: 'When designing a web page, the term "accessibility" refers to providing support
    so everyone, including people with disabilities, can use your page. There are
    then many needs that have to be considered, including, for instance, the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计网页时，“可访问性”一词指的是提供支持，以便包括残疾人在内的所有人都可以使用您的页面。因此，必须考虑许多需求，例如：
- en: '*Vision limitations*, varying from poor eyesight, through color vision problems,
    all the way up to total blindness'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*视力限制*，从视力不佳，色觉问题，一直到完全失明'
- en: '*Hearing limitations*, which require some fallback method for hearing impaired
    users'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*听力限制*，需要为听力受损的用户提供一些备用方法'
- en: '*Mobility limitations*, which may imply difficulty or impossibility of using
    the hands or controlling a mouse'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移动限制*，可能意味着难以或无法使用手部或控制鼠标'
- en: '*Cognitive limitations*, which may complicate understanding the information
    shown on screen'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*认知限制*，可能会使屏幕上显示的信息变得复杂'
- en: 'There are many tools that can assist disabled users, such as screen zooming,
    speech recognition, screen readers, braille terminals, closed captioning, and
    more, but even those tools need some extra information in order to work properly.
    The **Web Content Accessibility Guidelines** (**WCAG**) are a set of guidelines,
    published by the **Web Accessibility Initiative** (**WAI**) of the **World Wide
    Web Consortium** (**W3C**). The current version, 2.1, available online at [https://www.w3.org/TR/WCAG21/](https://www.w3.org/TR/WCAG21/),
    is based on four principles, known as POUR as an acronym:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以帮助残疾用户，例如屏幕缩放，语音识别，屏幕阅读器，盲文终端，闭路字幕等，但即使这些工具也需要一些额外的信息才能正常工作。**Web内容可访问性指南**（**WCAG**）是由**万维网联盟**（**W3C**）的**Web可访问性倡议**（**WAI**）发布的一套指南。当前版本2.1，可在线获取，网址为[https://www.w3.org/TR/WCAG21/](https://www.w3.org/TR/WCAG21/)，基于四个原则，即POUR作为首字母缩写：
- en: '*Perceivable***:** Information and user interface components must be presentable
    to users in ways they can perceive'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可感知性***：信息和用户界面组件必须以用户可以感知的方式呈现给用户'
- en: '*Operable*: User interface components and navigation must be operable'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可操作性*：用户界面组件和导航必须是可操作的'
- en: '*Understandable*: Information and the operation of user interface must be understandable'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可理解性*：用户界面的信息和操作必须是可理解的'
- en: '*Robust*: Content must be robust enough that it can be interpreted by by a
    wide variety of user agents, including assistive technologies'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*健壮性*：内容必须足够健壮，以便可以被各种用户代理解释，包括辅助技术'
- en: 'These principles, quoted from the cited page, include *guidelines* for use
    of color, working with a keyboard, providing information for screen readers, having
    enough contrast, displaying errors, and more; *sufficient and advisory techniques*,
    that can help follow the guidelines; and *success criteria*, meaning testable
    conditions to be used for conformance testing. The latter criteria are also used
    to define three levels of conformance: *A*, the minimum; *AA*, medium, including
    all of *A* and *AA* success criteria, and *AAA*, the hardest to attain, fulfilling
    all existing criteria—but it is acknowledged that it may be impossible to achieve
    for some sites.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则，引用自引用页面，包括使用颜色的指南，使用键盘工作，为屏幕阅读器提供信息，具有足够的对比度，显示错误等；*足够和建议的技术*，可以帮助遵循指南；以及*成功标准*，意味着可用于符合性测试的可测试条件。后者的标准也用于定义三个符合级别：*A*，最低级别；*AA*，中等级别，包括所有*A*和*AA*的成功标准，以及*AAA*，最难达到的级别，满足所有现有的标准，但也承认对于一些网站来说可能无法实现。
- en: Trying to make sure that your web application follows all guidelines and applies
    all techniques is not easy, so we'll see how we can add some tools to `React`
    in order to make your task a bit easier.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Web应用程序遵循所有指南并应用所有技术并不容易，因此我们将看看如何向`React`添加一些工具，以使您的任务变得更加容易。
- en: How to do it…
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'In order to check our work for accessibility, we''ll install a couple of packages,
    so let''s follow the procedure mentioned: one for static checks when writing code,
    using `ESLint`, and another for dynamic checks when running our application. And,
    if you ask yourself *Why two tools instead of only one?*, the answer is that a
    static tool cannot check everything: for example, if you assign a variable''s
    value to a title, will that value not be empty at run time? On the other hand,
    since all your code is linted, you got a chance to detect some things that could
    be missed during normal tests, so by using two tools you are not doing redundant
    work, but rather increasing the odds of finding accessibility problems.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的辅助功能工作，我们将安装一些软件包，因此让我们按照提到的步骤进行：一个用于编写代码时进行静态检查的软件包，使用`ESLint`，另一个用于运行应用程序时进行动态检查。如果你问自己*为什么要使用两个工具而不是一个？*，答案是静态工具无法检查一切：例如，如果您将变量的值分配给标题，那么该值在运行时不会为空吗？另一方面，由于您的所有代码都经过了检查，您有机会检测一些在正常测试期间可能被忽略的事情，因此通过使用两个工具，您并不是在做冗余工作，而是增加了发现辅助功能问题的几率。
- en: 'Installing the `ESLint` module is quite simple. First, we''ll use `npm` to
    add the package:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`ESLint`模块非常简单。首先，我们将使用`npm`添加该软件包：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we''ll have to modify our `.eslintrc` file a bit, adding the new plugin,
    and specifying what rules we want to enforce:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将不得不稍微修改我们的`.eslintrc`文件，添加新的插件，并指定我们要强制执行的规则。
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you don''t want to use all rules (as we did here) you can specify the rules
    you care for in the `"rules"` part of the file: see [https://github.com/evcohen/eslint-plugin-jsx-a11y](https://github.com/evcohen/eslint-plugin-jsx-a11y)
    for details on this, and inspect the complete set of available rules at [https://github.com/evcohen/eslint-plugin-jsx-a11y/tree/master/docs/rules](https://github.com/evcohen/eslint-plugin-jsx-a11y/tree/master/docs/rules).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用所有规则（就像我们在这里所做的那样），您可以在文件的“rules”部分中指定您关心的规则：请参阅[https://github.com/evcohen/eslint-plugin-jsx-a11y](https://github.com/evcohen/eslint-plugin-jsx-a11y)获取有关此内容的详细信息，并检查[https://github.com/evcohen/eslint-plugin-jsx-a11y/tree/master/docs/rules](https://github.com/evcohen/eslint-plugin-jsx-a11y/tree/master/docs/rules)上提供的所有规则的完整集合。
- en: 'The second addition we want is `react-a11y`, a package that modifies React
    rendering functions internally, so accessibility problems can be detected at runtime.
    Installation is simple:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的第二个添加是`react-a11y`，这是一个在React渲染函数内部修改的软件包，因此可以在运行时检测到可访问性问题。安装很简单：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, at the start of your application, you''ll have to initialize the `a11y`
    module, along with the rules you want to check. The format of the rules is the
    same as `ESLint` uses. Check [https://github.com/reactjs/react-a11y/tree/master/docs/rules](https://github.com/reactjs/react-a11y/tree/master/docs/rules)
    for the complete list, because new rules may be added. (You''ll also have to see
    that list in order to learn which rules, if any, have special options.) By default,
    all rules are `"off"`, so you must explicitly turn them on to `"warn"` or `"error"`. A
    full configuration would be as follows, as of December 2018:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在应用程序启动时，您将不得不初始化`a11y`模块，以及您想要检查的规则。规则的格式与`ESLint`使用的相同。检查[https://github.com/reactjs/react-a11y/tree/master/docs/rules](https://github.com/reactjs/react-a11y/tree/master/docs/rules)获取完整列表，因为可能会添加新规则。（您还必须查看该列表，以了解哪些规则（如果有的话）具有特殊选项。）默认情况下，所有规则都是“关闭”的，因此您必须明确将它们打开为“警告”或“错误”。截至2018年12月，完整的配置如下：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You might want to not enable `a11y` in production, to avoid a needless slowdown.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不希望在生产中启用`a11y`，以避免不必要的减速。
- en: We have everything set up; let's now see how all of this comes together.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了；现在让我们看看所有这些是如何结合在一起的。
- en: How it works…
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, let's see what happens with the errors that are detected via `ESLint`,
    and then we'll move to the runtime problems.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看通过`ESLint`检测到的错误会发生什么，然后我们将转移到运行时问题。
- en: Solving static problems
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决静态问题
- en: 'Our first *victim* of bad `a11y` coding is our SASS button; see the following
    screenshot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们糟糕的`a11y`编码的第一个“受害者”是我们的SASS按钮；请参阅以下截图：
- en: '![](img/a92fd389-cd58-4d49-b707-ad21dcec233d.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a92fd389-cd58-4d49-b707-ad21dcec233d.png)'
- en: Our SASS button has (at least) two accessibility-related problems
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的SASS按钮至少有两个与可访问性相关的问题
- en: 'One `a11y` rule is that you should be able to use the application with only
    the keyboard, so we need to be able to tab our way to the button (this requires
    using a `tabIndex`) and providing a keyboard listener (`onKeyPress` or `onKeyDown`).
    Furthermore, the role of our element (which works as a button) must be specified.
    The corrected JSX code would be as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`a11y`规则是你应该能够只使用键盘来使用应用程序，所以我们需要能够通过`tabIndex`来切换到按钮（这需要使用`tabIndex`），并提供一个键盘监听器（`onKeyPress`或`onKeyDown`）。此外，我们的元素的角色（作为按钮工作）必须被指定。更正后的JSX代码如下：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The new method, `.keyDownAsClick()`, would check if the user pressed the spacebar
    (ASCII code 32) or the *ENTER* key (ASCII code 13), and if so, call the same logic
    as the `onClick` handler:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法`.keyDownAsClick()`将检查用户是否按下空格键（ASCII码32）或*ENTER*键（ASCII码13），如果是，则调用与`onClick`处理程序相同的逻辑：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our input form also has a problem, albeit a simpler one. See the following
    screenshot:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入表格也有一个问题，尽管更简单。请参阅以下截图：
- en: '![](img/89ec6a2d-daa2-47cc-bfe7-3cefca04daea.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89ec6a2d-daa2-47cc-bfe7-3cefca04daea.png)'
- en: Our things ordering form only has a small a11y problem
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的物品订购表格只有一个小的a11y问题
- en: 'The problem and its solution are clear: instead of using `onChange`, the suggestion
    is to substitute `onBlur`, which effectively has no consequences for users. We
    won''t show the edited code, given how small the required change is, and just
    edit the file to replace the method.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 问题及其解决方案很明显：建议用`onBlur`替换`onChange`，这对用户没有任何影响。鉴于所需更改很小，我们不会显示编辑后的代码，只需编辑文件以替换该方法。
- en: 'We could try adding an image to our form, just for the sake of getting another,
    different warning. Try adding a Packt logo to the form, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试向我们的表单添加图像，只是为了获得另一个不同的警告。尝试向表单添加Packt标志，如下所示：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this case, we''d get a warning about the need for an `alt` attribute (adding
    `alt="Packt logo"` to the `img` tag would do) to describe the image; take a look
    at the following screenshot:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将收到有关需要`alt`属性的警告（向`img`标签添加`alt="Packt logo"`即可描述图像）；请查看以下截图：
- en: '![](img/cd7cd930-222a-4f49-a07b-c807d72d98ac.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd7cd930-222a-4f49-a07b-c807d72d98ac.png)'
- en: Another a11y rule requires images to have an alt attribute to describe them
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个a11y规则要求图像具有描述它们的alt属性
- en: 'Finally, let''s see a case in which our tool fails! The button we created with
    `styled-components` has basically the same problems as our `SASS` button, but
    nothing is reported; why? The reason is simple: if you examine the code (see the
    *Adding SASS for separate styling* section earlier in this chapter) we aren''t
    using `<div>` or `<button>` instances or any other recognizable HTML tags, but
    rather `<StyledDiv>` and `<StyledButton>`, which our `a11y eslint` plugin doesn''t
    understand. So far, the only workaround for this is to manually change our styled
    components back to their original tags, solve whatever problems may pop up, and
    then go back to the styled version not a very good solution, admittedly!'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一个我们的工具失败的案例！我们使用`styled-components`创建的按钮基本上与我们的`SASS`按钮有相同的问题，但没有报告任何问题；为什么？原因很简单：如果您检查代码（请参阅本章前面的*为单独的样式添加SASS*部分），我们没有使用`<div>`或`<button>`实例或任何其他可识别的HTML标签，而是使用了`<StyledDiv>`和`<StyledButton>`，我们的`a11y
    eslint`插件无法理解。到目前为止，唯一的解决方法是手动将我们的样式组件更改回其原始标记，解决可能出现的任何问题，然后再回到样式版本，这显然不是一个很好的解决方案！
- en: Solving runtime problems
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决运行时问题
- en: 'If we now try our fixed components in `Storybook`, `react-a11y` won''t say
    anything about them, but it will report some problems with the `styled-components`
    one, which we couldn''t solve beforehand; see the following screenshot:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试在`Storybook`中使用我们的固定组件，`react-a11y`不会对它们发表任何意见，但它会报告`styled-components`的一些问题，这是我们之前无法解决的；请参见以下截图：
- en: '![](img/064f8058-9ac5-4ec0-971e-aaa551d57723.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/064f8058-9ac5-4ec0-971e-aaa551d57723.png)'
- en: The react-a11y runtime tests show some problems in our component
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: react-a11y运行时测试显示了我们组件中的一些问题
- en: 'Of course, given that we build our component to match the previous `SASS` one,
    it won''t be a surprise that the solution to the accessibility problems are the
    same: adding `onKeyDown`, `tabIndex`, `role`, and a key-handling method. The relevant
    parts of the corrected code would be as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，鉴于我们构建的组件与之前的`SASS`组件相匹配，不足为奇的是，解决辅助功能问题的解决方案是相同的：添加`onKeyDown`、`tabIndex`、`role`和一个键处理方法。已更正代码的相关部分如下：
- en: '[PRE40]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Of course, we have just seen the tip of the iceberg as to all the problems that
    can appear, and their solutions—but what really matters is that you have some
    tools to help you with the development of `a11y`-enabled applications, as we have
    shown.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们只是看到了可能出现的所有问题及其解决方案的冰山一角，但真正重要的是您有一些工具来帮助您开发启用`a11y`的应用程序，正如我们所展示的那样。
- en: There is more
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'What can we do to ensure a fully compliant `a11y` application? Unfortunately,
    you won''t be able to manage it with just some tools. For instance, none of the
    tools we selected pointed out that we should add a name to the input fields, as
    pointed out by an ARIA rule (see [https://w3c.github.io/using-aria/#fifth](https://w3c.github.io/using-aria/#fifth)
    for more on it). Also, there are some conditions that cannot be tested in code.
    For example, guidelines say that error or mandatory fields should not be highlighted
    just with color (because of color blindness) but should have some external text
    or mark; how would you test for that in an automated way? take a look at the following
    screenshot for an example, taken from [https://govuk-elements.herokuapp.com/errors/example-form-validation-multiple-questions](https://govuk-elements.herokuapp.com/errors/example-form-validation-multiple-questions),
    with enhanced visibility for errors:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做些什么来确保一个完全符合`a11y`应用程序？不幸的是，您无法仅凭一些工具来管理它。例如，我们选择的工具中没有一个指出我们应该为输入字段添加名称，正如ARIA规则所指出的那样（有关更多信息，请参见[https://w3c.github.io/using-aria/#fifth](https://w3c.github.io/using-aria/#fifth)）。此外，有些条件无法在代码中进行测试。例如，指南指出，错误或强制字段不应仅通过颜色（由于色盲）进行突出显示，而应该有一些外部文本或标记；您如何以自动化方式测试这一点？请查看以下截图，这是从[https://govuk-elements.herokuapp.com/errors/example-form-validation-multiple-questions](https://govuk-elements.herokuapp.com/errors/example-form-validation-multiple-questions)中获取的示例，增强了错误的可见性：
- en: '![](img/f020f612-b251-45d5-9e94-d7fc9ee2aeab.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f020f612-b251-45d5-9e94-d7fc9ee2aeab.png)'
- en: A sample input form from a UK government site that shows good a11y practices
    for errors
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 来自英国政府网站的示例输入表单，显示了良好的a11y实践，用于错误
- en: 'It''s not possible to get an A, AA, or AAA level without an audit, but you
    can add more tools to help out with that:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 没有经过审计，不可能获得A、AA或AAA级别，但您可以添加更多工具来帮助解决这个问题：
- en: The W3C Web Accessibility Initiative provides an extensive list of tools (113,
    as of today!) at [https://www.w3.org/WAI/ER/tools/](https://www.w3.org/WAI/ER/tools/)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3C Web Accessibility Initiative在[https://www.w3.org/WAI/ER/tools/](https://www.w3.org/WAI/ER/tools/)提供了一个庞大的工具列表（截至今天为止有113个！）
- en: The A11Y Project provides a community effort to simplify web accessibility,
    showing several useful techniques, at [https://a11yproject.com/](https://a11yproject.com/)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A11Y项目提供了一个社区努力，简化网络辅助功能，展示了一些有用的技术，网址为[https://a11yproject.com/](https://a11yproject.com/)
- en: MDN has a full overview of ARIA, a spec from the W3C geared to providing extra
    information for screen readers by way of the usage of HTML attributes, at [https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDN对ARIA进行了全面的概述，这是W3C专门为屏幕阅读器提供额外信息的规范，通过使用HTML属性，网址为[https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques)
- en: The W3C also provides many suggestions for using ARIA, including samples of
    code, at [https://w3c.github.io/using-aria/](https://w3c.github.io/using-aria/)
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3C还提供了许多关于使用ARIA的建议，包括代码示例，网址为[https://w3c.github.io/using-aria/](https://w3c.github.io/using-aria/)
- en: There are several accessibility checkers, for all main browsers, which can diagnose
    a page *on the go*, so just search for them; some work as browser extensions,
    while others are code meant to be added to your website, to detect and report
    possible problems
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几种辅助功能检查器，适用于所有主要浏览器，可以在页面*运行时*诊断页面，所以只需搜索它们；有些作为浏览器扩展，而其他一些是用于添加到您的网站的代码，以便检测和报告可能的问题
- en: Even if no single tool or set of tools can ensure `a11y` compliance, you will
    be able to build yourself a good starting lot of tools; experiment a bit!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有单个工具或一组工具可以确保`a11y`合规性，您也可以构建自己的一套良好的起始工具；多做一些实验！
