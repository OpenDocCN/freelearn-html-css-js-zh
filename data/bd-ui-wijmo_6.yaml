- en: Chapter 6. Dashboard with WijmoGrid
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 带有WijmoGrid的仪表板
- en: Developing rich client applications with jQuery UI results in a large number
    of CSS query selectors and event handlers. In this chapter, you will learn about
    another way of developing interactive user interfaces. Wijmo facilitates the shift
    to this programming paradigm, supporting it with a plugin. This chapter will get
    you started with the concepts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery UI开发丰富的客户端应用程序会导致大量的CSS查询选择器和事件处理器。在本章中，你将了解另一种开发交互式用户界面的方法。Wijmo通过插件支持这种编程范式的转变。本章将帮助你开始了解这些概念。
- en: Introduction to MVVM
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout简介
- en: Modern web applications are often built with the MVC pattern, for the backend.
    What about the frontend? Frameworks such as `Backbone.js` leave a lot of boilerplate
    code to be written. This becomes apparent for large projects. The library is lightweight,
    but lacks strong abstractions. It leaves the task of loading data from the server
    and DOM manipulation to the developer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web应用程序通常使用MVC模式构建后端。那么前端呢？例如`Backbone.js`这样的框架会留下大量的样板代码需要编写。这在大型项目中尤为明显。这个库很轻量级，但缺乏强大的抽象。它将加载数据和DOM操作的任务留给了开发者。
- en: 'With the **ModelViewViewModel** (**MVVM**) pattern, the application logic is
    encapsulated in a set of ViewModel classes that expose an object model that is
    View-friendly. Views rely on bindings to observables to be notified of changes
    in the ViewModel. As a result, the UI refreshes automatically with the data when
    using the MVVM pattern. The flow of data in the MVVM pattern is illustrated in
    this diagram:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**ModelViewViewModel**（**MVVM**）模式，应用程序逻辑封装在一系列ViewModel类中，这些类公开了一个对视图友好的对象模型。视图依赖于绑定到可观察对象来通知ViewModel中的变化。因此，当使用MVVM模式时，UI会自动与数据刷新。MVVM模式中的数据流在本图中展示：
- en: '![Introduction to MVVM](img/6067OT_6_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![MVVM简介](img/6067OT_6_01.jpg)'
- en: From a software design point of view, the MVVM pattern has the benefit of testability,
    separation of concerns, and reusability. The ViewModel doesn't contain any user
    interface elements, making it easy to test. The presentation is kept in the **View**
    with HTML and CSS, which requires different skills than those for working with
    the business logic in the **ViewModel** . The ViewModel can be reused in other
    views, such as a mobile one or in a similar application with a different look.
    In my own experience, I have used subclasses of a common ViewModel to build two
    applications. Both of the applications use the same backend **Model**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件设计角度来看，MVVM模式具有可测试性、关注点分离和可重用性的优势。ViewModel不包含任何用户界面元素，这使得它易于测试。展示层保持在**View**中，使用HTML和CSS，这需要与在**ViewModel**中处理业务逻辑不同的技能。ViewModel可以在其他视图中重用，例如移动端或具有不同外观的类似应用程序。根据我自己的经验，我使用通用ViewModel的子类构建了两个应用程序。这两个应用程序都使用了相同的后端**Model**。
- en: When the MVVM pattern is used in the browser, the Model represents the backend.
    It is an abstraction of the normalized data store for objects and the operations
    (create, read, update, delete) on it. The View is the user interface that displays
    information to the user and fires events to the ViewModel. The ViewModel retrieves
    data from the Model and notifies the View of changes. Also, it receives UI events
    from the View and updates the data in the Model in response.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当在浏览器中使用MVVM模式时，Model代表后端。它是对象和其上操作（创建、读取、更新、删除）的规范化数据存储的抽象。View是用户界面，向用户显示信息并向ViewModel触发事件。ViewModel从Model检索数据并通知View变化。此外，它接收来自View的UI事件并更新Model中的数据。
- en: Introduction to Knockout
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout简介
- en: '**Knockout** is a JavaScript library that implements the MVVM pattern. By using
    Knockout, you can avoid event handling and DOM manipulation with jQuery and work
    with declarative bindings instead. Knockout comes with a rich set of bindings
    for controlling the text, appearance, and flow. These include `foreach`, `if`,
    `visiblility`, and `style` bindings. In addition, there are specific bindings
    for working with form fields. They can be used to handle click events and to enable
    or disable UI elements. These bindings are bound to an observable or an `observableArray`
    object in the ViewModel. An observable issues notifications when their value changes.
    Knockout provides a simple syntax for reading and writing from an observable,
    as we will see. Equally important, Knockout keeps track of the right parts of
    your UI to update when the ViewModel changes. That means if you update an item
    of an `observableArray` object that is rendered with a `foreach` loop, the HTML
    element that corresponds to the item changes with it. If an observable is computed
    from another observable, then the dependency is tracked for you.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Knockout** 是一个实现MVVM模式的JavaScript库。通过使用Knockout，你可以避免使用jQuery进行事件处理和DOM操作，而是使用声明性绑定进行工作。Knockout提供了一套丰富的绑定，用于控制文本、外观和流程。这些包括
    `foreach`、`if`、`visiblility` 和 `style` 绑定。此外，还有专门用于处理表单字段的绑定。它们可以用来处理点击事件和启用或禁用UI元素。这些绑定绑定到ViewModel中的可观察对象或
    `observableArray` 对象。当可观察对象的值发生变化时，它会发出通知。Knockout提供了一个简单的语法来读取和写入可观察对象，正如我们将看到的。同样重要的是，Knockout会跟踪ViewModel变化时需要更新的UI的正确部分。这意味着如果你更新了一个用
    `foreach` 循环渲染的 `observableArray` 对象的项，对应的HTML元素也会随之改变。如果一个可观察对象是从另一个可观察对象计算得出的，那么依赖关系会为你跟踪。'
- en: Let's take a look at instantiating and using an observable. To create an observable,
    we assign it to a property of a ViewModel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实例化和使用一个可观察对象。为了创建一个可观察对象，我们将其分配给ViewModel的一个属性。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To read from the observable, just call the observable with no parameters. If
    we call `viewModel.name()`, "Bob" is returned. To write to the observable, pass
    the new value as the parameter to the observable. Calling `viewModel.name('Jeff')`
    writes the value `Jeff` to the value `name`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要从可观察对象中读取，只需不带参数调用可观察对象。如果我们调用 `viewModel.name()`，则返回 "Bob"。要写入可观察对象，将新值作为参数传递给可观察对象。调用
    `viewModel.name('Jeff')` 将值 `Jeff` 写入 `name`。
- en: 'Next, we write the View with a templating language using the `data-bind` attribute:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `data-bind` 属性编写带有模板语言的视图：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The View has the same effect as the following when initialized:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 视图初始化时具有以下相同的效果：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, to activate Knockout, we bind the ViewModel layer to the View layer
    with JavaScript:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了激活Knockout，我们使用JavaScript将ViewModel层绑定到视图层：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can place this either at the bottom of the page or a DOM-ready function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它放在页面底部或DOM就绪函数中。
- en: Building a rating system with Knockout
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Knockout构建评分系统
- en: 'In this section we build a rating system using Wijmo''s rating widget. The
    rating system lets the user vote for the factors that affect their technology
    choices. They have a total of 10 points to use. The **Finish** button is only
    enabled if the number of points left for use is valid as shown in the following
    screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用Wijmo的评分小部件构建一个评分系统。评分系统允许用户对影响他们技术选择的因素进行投票。他们总共有10分可以使用。**完成**按钮仅在剩余可用于使用的分数有效时才启用，如下截图所示：
- en: '![Building a rating system with Knockout](img/6067OT_6_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![使用Knockout构建评分系统](img/6067OT_6_02.jpg)'
- en: 'To build this rating system, we make use of Wijmo''s Knockout binding for its
    rating widgets. The survey is composed of a set of options where the user rates
    the option. For each of the options, we create an answer object with the values
    for the binding:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个评分系统，我们利用Wijmo的Knockout绑定来使用其评分小部件。调查由一组选项组成，用户对选项进行评分。对于每个选项，我们创建一个带有绑定值的答案对象：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The contents of `answerText` are displayed under the **Option** heading. The
    points are the number of stars under the **Importance** heading. The rating widget
    has many other options, but we only introduce the ones necessary for our use.
    These options are bound to the widget with the `data-bind` attribute:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`answerText` 的内容显示在 **选项** 标题下。评分是 **重要性** 标题下星星的数量。评分小部件有许多其他选项，但我们只介绍我们使用必要的那些。这些选项通过
    `data-bind` 属性绑定到小部件：'
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our ViewModel, we have an array of options called `answers` and a total
    number of points allowed, the `pointsBudget`. The `pointsUsed` is a dependent
    observable and is calculated by adding up the points in all the answers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 ViewModel 中，有一个名为 `answers` 的选项数组和一个允许的总分数，即 `pointsBudget`。`pointsUsed`
    是一个依赖的可观察对象，通过将所有答案中的分数相加来计算：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the jQuery `$.map` function, we can pass an array of option texts to
    the `SurveyViewModel`class. The first argument sets the total number of points
    allowed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jQuery 的 `$.map` 函数，我们可以将选项文本数组传递给 `SurveyViewModel` 类。第一个参数设置允许的总分数：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since Knockout is an MVVM framework, we need to write the View using a templating
    language. To display the options and the rating widget, we loop through each answer
    in the ViewModel and display the `answerText` string and the points for each answer,
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Knockout 是一个 MVVM 框架，我们需要使用模板语言编写视图。为了显示选项和评分小部件，我们遍历 ViewModel 中的每个答案，并显示
    `answerText` 字符串和每个答案的分数，如下所示：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `text` binding applied to `answerText` displays its text value, while the
    `value` binding for `wijrating` shows up as stars. Next, we want to show the number
    of points the user is left with. This is also done with the help of `text` binding,
    which converts a numeric value to a string:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `text` 绑定应用于 `answerText` 会显示其文本值，而 `wijrating` 的 `value` 绑定则以星星的形式显示。接下来，我们希望显示用户剩余的分数。这同样是通过
    `text` 绑定完成的，它将数值转换为字符串：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We enable the **Submit** button only when the value of `pointsUsed` doesn''t
    exceed the value we set in the SurveyViewModel. In this case, it''s `10`. The
    `click` binding assigns the `save` action in the SurveyViewModel to the `click`
    event on the button:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅在 `pointsUsed` 的值不超过在 SurveyViewModel 中设置的值时启用 **提交** 按钮。在这种情况下，它是 `10`。`click`
    绑定将 SurveyViewModel 中的 `save` 动作分配给按钮的 `click` 事件：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To initialize the UI, we bind the ViewModel to the HTML by calling `ko.applyBindings`
    and passing a SurveyViewModel object. Putting it all together, the rating system
    is only a few lines of JavaScript and has no DOM manipulation. For the complete
    source code for this example, refer to the code bundle available for download
    online on the Packt website. Note that in addition to the usual Wijmo imports,
    we add the Knockout library and the Wijmo bindings, which includes `wijrating`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化用户界面，我们通过调用 `ko.applyBindings` 并传递一个 `SurveyViewModel` 对象来将 ViewModel 绑定到
    HTML 上。将所有这些放在一起，评分系统只有几行 JavaScript 代码，并且没有 DOM 操作。关于本例的完整源代码，请参考 Packt 网站上提供的可下载代码包。请注意，除了常用的
    Wijmo 导入之外，我们还添加了 Knockout 库和 Wijmo 绑定，其中包括 `wijrating`。
- en: Now that you know how to build a user interface with the MVVM design pattern,
    we go on to building a more complete application with forms and grids.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用 MVVM 设计模式构建用户界面，我们将继续构建一个包含表单和网格的更完整的应用程序。
- en: Building the dashboard
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建仪表板
- en: The project for the rest of the chapter is based on a mobile-paging application.
    The application allows messages to be sent to pagers with a dashboard showing
    all of the messages. The messages in the dashboard are updated in real time and
    are sortable by column headings. In a real-world application, the messages shown
    in the dashboard would be paginated and sorting each column would send an AJAX
    request to the server. Wijmo already has an example of how to do this with the
    Grid widget, which we will also use in our project. Our project introduces the
    basics of setting up a real-time messaging platform with the MVVM pattern. The
    data is not persisted to a database. However, form submissions are sent to the
    dashboard in real time with WebSockets. After you finish this chapter, I would
    encourage you to take a look at [http://wijmo.com/grid-with-knockout-viewmodel-loading-remote-data/](http://wijmo.com/grid-with-knockout-viewmodel-loading-remote-data/).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余项目基于一个移动分页应用程序。该应用程序允许向寻呼机发送消息，并在仪表板上显示所有消息。仪表板中的消息会实时更新，并且可以按列标题排序。在实际应用中，仪表板中显示的消息将进行分页，并且对每一列的排序都会向服务器发送
    AJAX 请求。Wijmo 已经有一个使用 Grid 小部件完成此操作的示例，我们也将在我们的项目中使用它。我们的项目介绍了使用 MVVM 模式设置实时消息平台的基础。数据不会持久化到数据库中。然而，表单提交会通过
    WebSocket 实时发送到仪表板。完成本章后，我鼓励你查看 [http://wijmo.com/grid-with-knockout-viewmodel-loading-remote-data/](http://wijmo.com/grid-with-knockout-viewmodel-loading-remote-data/)。
- en: Sending a message with Knockout and Socket.IO
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Knockout 和 Socket.IO 发送消息
- en: 'The **Send Message** page is a form that lets the user submit a message with
    a subject, body, phone number, and message type. We build this form using a combination
    of the bindings that come with Knockout and those provided by Wijmo. First, let''s
    start with a subject and a body. Since the Wijmo''s textbox widget doesn''t have
    a binding for the input value, we use Knockout''s `value` binding. This binding
    can be used on the `<input>`, `<select>`, and `<textarea>` elements and links
    the element''s value with a property in the ViewModel:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送消息**页面是一个表单，允许用户提交带有主题、正文、电话号码和消息类型的消息。我们使用Knockout提供的绑定和Wijmo提供的绑定组合来构建这个表单。首先，让我们从主题和正文开始。由于Wijmo的textbox小部件没有用于输入值的绑定，我们使用Knockout的`value`绑定。这个绑定可以用在`<input>`、`<select>`和`<textarea>`元素上，并将元素的值与ViewModel中的属性链接：'
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To make these elements use the same styles as the rest of the form, we decorate
    them with the textbox widget. This is done for styling the elements, as the View
    in HTML contains the bindings:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些元素使用与表单其余部分相同的样式，我们用textbox小部件装饰它们。这是为了样式化元素，因为HTML中的视图包含绑定：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our ViewModel, we initialize the `subject` and `body` fields as observables
    with empty strings:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ViewModel中，我们将`subject`和`body`字段初始化为带有空字符串的可观察对象：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After seeing how the `subject` and `body` fields are implemented, you may want
    to use the `wijtextbox` binding directly, as shown in the following demonstration
    that does not work:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到`subject`和`body`字段是如何实现之后，你可能希望直接使用`wijtextbox`绑定，如下面的演示所示，但这不起作用：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Although Knockout has a `value` binding, the `wijtextbox` binding is purely
    for presentation. For a list of supported options for each binding, see [http://wijmo.com/wiki/index.php/Using_Wijmo_with_Knockout](http://wijmo.com/wiki/index.php/Using_Wijmo_with_Knockout).
    Only the options listed on the page support two-way bindings while other widget
    options are just used for initialization. In the next step, Wijmo bindings are
    used for the phone number and message type form components:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Knockout有`value`绑定，但`wijtextbox`绑定纯粹用于展示。有关每个绑定的支持选项列表，请参阅[http://wijmo.com/wiki/index.php/Using_Wijmo_with_Knockout](http://wijmo.com/wiki/index.php/Using_Wijmo_with_Knockout)。只有页面上列出的选项支持双向绑定，而其他小部件选项仅用于初始化。在下一步中，我们使用Wijmo绑定来处理电话号码和消息类型表单组件：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `wijinputmask` binding initializes a `WijmoInputMask` widget with the pattern
    `(___) ___-____`. The `text` option binds it to the observable `phoneNumber` in
    the ViewModel. The `wijcombobox` widget acts as a dropdown for the message type.
    The `data` option sets the `messageTypes` as available. Since the message types
    are only read and not written, we scope it outside of the ViewModel. Changes to
    objects outside of the ViewModel layer do not affect the UI. Later on, we submit
    the ViewModel object to the server and having extraneous data such as message
    types outside of the ViewModel layer simplifies the code. Wijmo's ComboBox takes
    an array of objects with the label and value for the data option. The `label`
    property is the text displayed, while `value` would be stored in the `messageType`
    observable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`wijinputmask`绑定使用模式`(___) ___-____`初始化一个`WijmoInputMask`小部件。`text`选项将其绑定到ViewModel中的`phoneNumber`可观察对象。`wijcombobox`小部件作为消息类型的下拉菜单。`data`选项设置`messageTypes`为可用。由于消息类型只读不写，我们将它放在ViewModel之外的范围。ViewModel层之外的对象更改不会影响UI。稍后，我们将ViewModel对象提交到服务器，将消息类型等额外数据放在ViewModel层之外简化了代码。Wijmo的ComboBox接受一个包含标签和值的对象数组，用于数据选项。`label`属性是显示的文本，而`value`将被存储在`messageType`可观察对象中。'
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To initialize the message type to `Gamma`, we set it in the observable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要将消息类型初始化为`Gamma`，我们在可观察对象中设置它：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the last item we have left on the form is a submit button which sends
    the data to the server using a WebSocket object. For this part, we will use Socket.IO.
    To set up `So` `cket.IO`, download and install `Node.JS` from [http://nodejs.org/download/](http://nodejs.org/download/),
    then run `npm install socket.io` on the command line. This will make the path
    `/socket.io/socket.io.js` available in the browser when the `Node.JS` server is
    running. On the server, `Socket.IO` listens for message events and broadcasts
    it as news. The `emit` function broadcasts to all clients except the one who sent
    the message:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，表单上剩下的最后一个项目是一个提交按钮，该按钮使用 WebSocket 对象将数据发送到服务器。对于这部分，我们将使用 Socket.IO。要设置
    `So` `cket.IO`，从 [http://nodejs.org/download/](http://nodejs.org/download/) 下载并安装
    `Node.JS`，然后在命令行上运行 `npm install socket.io`。这将使当 `Node.JS` 服务器运行时，浏览器中可用的路径为 `/socket.io/socket.io.js`。在服务器上，`Socket.IO`
    监听消息事件并将其广播为新闻。`emit` 函数向所有客户端广播，除了发送消息的那个客户端：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the browser, a WebSocket connection is created to `localhost` by calling
    `io.connect(''http://localhost'')`. The `submit` function sends a message event
    to the server:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，通过调用 `io.connect('http://localhost')` 创建到 `localhost` 的 WebSocket 连接。`submit`
    函数向服务器发送消息事件：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`ko.toJSON` converts the ViewModel data to JSON. JSON includes all of the observables.
    The submit button is bound to the method through the click binding:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.toJSON` 将 ViewModel 数据转换为 JSON。JSON 包括所有可观察项。提交按钮通过点击绑定绑定到该方法：'
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For decorating the button, call `$(''button'').button()`. The jQuery UI button
    method styles the submit button in the same way as other widgets. You may ask,
    why not just write the View so that the jQuery UI button is applied in the binding?
    The following code would work in a perfect world:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了装饰按钮，调用 `$('button').button()`。jQuery UI 按钮方法以与其他小部件相同的方式样式化提交按钮。您可能会问，为什么不直接编写视图，以便在绑定中应用
    jQuery UI 按钮呢？在理想的世界中，以下代码将有效：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Yet, Wijmo does not support binding to the `click` event on button widgets.
    So we use Knockout's native `click` binding and jQuery UI's `button` method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Wijmo 不支持将 `click` 事件绑定到按钮小部件上。因此，我们使用 Knockout 的原生 `click` 绑定和 jQuery UI
    的 `button` 方法。
- en: 'To make the View and the ViewModel layers work together, we apply the bindings
    to the HTML:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使视图层和 ViewModel 层协同工作，我们将绑定应用到 HTML 上：
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the Rocket theme, the **Send Message** page looks like the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用火箭主题，**发送消息**页面看起来如下截图所示：
- en: '![Sending a message with Knockout and Socket.IO](img/6067OT_6_06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Knockout 和 Socket.IO 发送消息](img/6067OT_6_06.jpg)'
- en: Displaying messages on the Dashboard
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在仪表盘上显示消息
- en: 'Our ViewModel class for the Dashboard page is simple. It is composed of an
    `observableArray` of message objects. An `observableArray` is useful when you
    want to detect and respond to changes in a collection of JavaScript objects. Since
    the messages on the Dashboard are not editable, the properties of each message
    object do not need to be an observable. Each message has `subject`, `body`, `messageType`,
    and, `phoneNumber` strings:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为仪表盘页面创建的 ViewModel 类很简单。它由一个消息对象的 `observableArray` 组成。当您想要检测和响应用户对象集合中的变化时，`observableArray`
    非常有用。由于仪表盘上的消息不可编辑，因此每个消息对象的属性不需要是可观察的。每个消息包含 `subject`、`body`、`messageType` 和
    `phoneNumber` 字符串：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'On receiving an update from the server, the message is added to the ViewModel.
    The data is received as text, as in AJAX responses. So the `JSON.parse` method
    turns it into a `message` object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当从服务器接收到更新时，消息被添加到 ViewModel 中。数据以文本形式接收，就像 AJAX 响应一样。因此，`JSON.parse` 方法将其转换为
    `message` 对象：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, a WebSocket connection is made to the server, allowing
    bi-directional communication. However, we only listen for events from the server
    for the Dashboard.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，与服务器建立了一个 WebSocket 连接，允许双向通信。然而，我们只为仪表盘监听来自服务器的事件。
- en: 'Our View layer is just a table. Wijmo makes displaying tabular data so easy
    that all we need to make it dynamic is just the `wijgrid` binding, along with
    one essential option, `data`. The `data` option takes as its parameter a `wijdatasource`
    widget, an array, or a DOM table. A `wijdatasource` can be used to load data dynamically
    from a remote source with filtering and sorting. Because our application doesn''t
    have a database in the Model, we pass an `observableArray`to the `data` option:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图层只是一个表格。Wijmo 使得显示表格数据变得如此简单，我们只需要 `wijgrid` 绑定以及一个基本选项 `data` 来使其动态化。`data`
    选项接受一个 `wijdatasource` 小部件、一个数组或一个 DOM 表格作为参数。`wijdatasource` 可以用于从远程源动态加载数据，包括过滤和排序。由于我们的应用程序在模型中没有数据库，我们通过
    `observableArray` 将其传递给 `data` 选项：
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To enhance the functionality, `allowSorting` is set so that clicking on a column
    heading sorts the table by that column. The `wijgrid` binding takes care of updating
    the table when the ViewModel data changes. As you are now familiar, we are missing
    an essential piece that links the View and the ViewModels: `ko.applyBindings(viewModel)`.
    That finishes the dashboard with the result as seen in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强功能，`allowSorting` 被设置为点击列标题时按该列排序表格。`wijgrid` 绑定负责在 ViewModel 数据变化时更新表格。正如你现在所熟悉的，我们缺少一个将视图和
    ViewModel 连接起来的关键部分：`ko.applyBindings(viewModel)`。这完成了仪表板的设置，结果如下截图所示：
- en: '![Displaying messages on the Dashboard](img/6067OT_6_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![仪表板上显示消息](img/6067OT_6_08.jpg)'
- en: The dashboard initially loads with just the first message. When the **Send Message**
    page is submitted, another message is inserted below it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板最初只加载第一条消息。当提交 **发送消息** 页面时，另一条消息将被插入其下方。
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wijmo, combined with Knockout, makes programming interactive applications easy.
    In the rating system example, we have seen how observables that are computed from
    other observables work. We've used a dependent observable to calculate the total
    number of points used as each rating changes. In the Dashboard example, we built
    a dynamic table that is updated by the server with the Wijmo grid widget. Also,
    we coded the Send Message page to use the Wijmo widgets in combination with Knockout
    bindings. The next chapter introduces mobile web development with Wijmo Mobile.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Wijmo 与 Knockout 结合使用，使得编程交互式应用程序变得简单。在评分系统示例中，我们看到了从其他可观察对象计算得出的可观察对象是如何工作的。我们使用一个依赖可观察对象来计算每个评分变化时使用的总点数。在仪表板示例中，我们构建了一个由服务器使用
    Wijmo 网格小部件更新的动态表格。此外，我们还编写了发送消息页面，以结合使用 Wijmo 小部件和 Knockout 绑定。下一章将介绍使用 Wijmo
    Mobile 进行移动网页开发。
