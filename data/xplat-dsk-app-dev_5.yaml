- en: Creating a Screen Capturer with NW.js, React, and Redux – Planning, Design,
    and Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NW.js、React和Redux创建屏幕捕捉器-规划、设计和开发
- en: In this chapter, we are starting a new application screen capturer. With this
    tool, will be able to take screenshots and record screencasts. We will build the
    application using the React components of the Material UI toolkit, which implements
    Google's Material Design specification. We already gained some experience with
    React while working on the chat example. Now, we are taking a step further towards
    scalable and highly maintainable application development. We are going to have
    an introduction to one of the hottest libraries of the time that called Redux,
    which manages the application state.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始一个新的应用程序屏幕捕捉器。使用这个工具，我们将能够截取屏幕截图和录制屏幕录像。我们将使用Material UI工具包的React组件构建应用程序，该工具包实现了Google的Material
    Design规范。在处理聊天示例时，我们已经积累了一些React的经验。现在，我们正在迈出一步，朝着可扩展和易于维护的应用程序开发迈进。我们将介绍当时最热门的库之一，名为Redux，它管理应用程序状态。
- en: At the end of the chapter, we will have a prototype, which already responds
    to user actions, but misses the service to capture display input and save it in
    a file.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将拥有一个原型，它已经响应用户操作，但缺少捕获显示输入并将其保存到文件中的服务。
- en: Application blueprint
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序蓝图
- en: This time, we will develop a screen capturer, a little tool capable of taking
    screenshots and recording screencasts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将开发一个屏幕捕捉工具，一个可以截取屏幕截图和录制屏幕录像的小工具。
- en: 'The core idea can be expressed with the following user stories:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想可以用以下用户故事来表达：
- en: As a user, I can take a screenshot and save it as a `.png` file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以截取屏幕截图并将其保存为`.png`文件
- en: As a user, I can start recording a screencast
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以开始录制屏幕录像
- en: As a user, I can start recording the screencast and save it as `.webm` file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我可以开始录制屏幕录像并将其保存为`.webm`文件
- en: 'Additionally, I expect a notification to appear when a screenshot or screencast
    file is saved. I also would like to have the application presented in the system
    notification area (**Tray**) and to respond to specified global hot-keys. With
    a help of WireframeSketcher ([http://wireframesketcher.com/](http://wireframesketcher.com/)),
    I illustrated my vision with the following wireframe:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我希望在保存屏幕截图或录像文件时出现通知。我还希望将应用程序显示在系统通知区域(**托盘**)中，并响应指定的全局热键。借助WireframeSketcher([http://wireframesketcher.com/](http://wireframesketcher.com/))，我用以下线框图说明了我的设想：
- en: '![](img/57de0862-ee30-4ff3-b481-8704cf5cb47f.png)![](img/d4f04746-888f-476a-8719-f4afadbe6ce8.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57de0862-ee30-4ff3-b481-8704cf5cb47f.png)![](img/d4f04746-888f-476a-8719-f4afadbe6ce8.png)'
- en: The wireframe implies a **Tabbed Document Interface** (**TDI**) with two panels.
    The first one, labeled as Screenshot, allows us to take a screenshot (photo icon)
    and set the filename pattern for the output file. The second panel (Animation)
    looks pretty much the same, except the action button is intended to start screencast
    recording. As soon as a user hits the button, it gets replaced with the stop recording
    button and vice versa.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 线框图暗示了一个**分页文档界面**(**TDI**)，有两个面板。第一个面板标记为屏幕截图，允许我们截取屏幕截图(照片图标)并设置输出文件的文件名模式。第二个面板(动画)看起来差不多，只是动作按钮用于开始录制屏幕录像。一旦用户点击按钮，它就会被停止录制按钮替换，反之亦然。
- en: Setting up the development environment
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: 'We will create this application with NW.js. As you may remember from [Chapter
    1](ed6645a7-d7e6-4322-909d-0777d9763560.xhtml), *Creating a File Explorer with
    NW.js - Planning, Designing, and Development* and Chapter 2, *Creating a File
    Explorer with NW.js – Enhancement and Delivery*, NW.js looks up the manifest file
    for the start page link and application window meta information:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用NW.js创建这个应用程序。正如你可能还记得[第1章](ed6645a7-d7e6-4322-909d-0777d9763560.xhtml)中所述，*使用NW.js创建文件资源管理器-规划、设计和开发*和第2章*使用NW.js创建文件资源管理器-增强和交付*，NW.js查找启动页面链接和应用程序窗口元信息的清单文件：
- en: '`./package.json`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`./package.json`'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This time, we do not need a big window. We go with `580x320px` and allow shrinking
    the window size down to `450x320px`. We set the window to open at the center of
    the screen without the frame and built-in windowing controls.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不需要一个大窗口。我们选择`580x320px`，并允许将窗口大小缩小到`450x320px`。我们设置窗口在屏幕中心打开，没有框架和内置窗口控件。
- en: 'When we were setting up NW.js in the first two chapters, we had just a few
    dependencies. Now, we are going to take advantage of React and, therefore, we
    need the corresponding packages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在前两章设置NW.js时，我们只有很少的依赖。现在，我们将利用React，并且需要相应的包：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As for dev dependencies, obviously, we need NW.js itself:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 至于开发依赖，显然，我们需要NW.js本身：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Same as for the chat application that is also based on React, we will use Babel
    compiler and Webpack bundler. So, it gives us the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于React的聊天应用程序一样，我们将使用Babel编译器和Webpack打包工具。因此，它给了我们以下内容：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we remember Babel by itself is a platform, we need to specify what exact
    preset it applies to compile our sources. We already worked with these two:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们记得的，Babel本身是一个平台，我们需要指定它应用于编译我们源代码的确切预设。我们已经使用了这两个：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we extend the list with the `stage-3` preset ([https://babeljs.io/docs/plugins/preset-stage-3/](https://babeljs.io/docs/plugins/preset-stage-3/)):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`stage-3`预设扩展列表([https://babeljs.io/docs/plugins/preset-stage-3/](https://babeljs.io/docs/plugins/preset-stage-3/))：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This plugin set includes all the features of the so-called **Stage 3** proposal
    for the **EcmaScript** specification. In particular, it comprised of spread/rest
    operators on objects, which unlocks the most expressive syntax for the object
    composition.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件集包括所谓的**EcmaScript**规范的**Stage 3**提案的所有功能。特别是，它包括了对象上的扩展/剩余运算符，这解锁了对象组合的最具表现力的语法。
- en: 'In addition, we will apply two plugins not included in Stage 3:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将应用两个不包括在Stage 3中的插件：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are already familiar with the first one (ES Class Fields and Static Properties—[https://github.com/tc39/proposal-class-public-fields](https://github.com/tc39/proposal-class-public-fields)).
    The second allows us to use decorators ([https://github.com/tc39/proposal-decorators](https://github.com/tc39/proposal-decorators)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了第一个（ES类字段和静态属性—[https://github.com/tc39/proposal-class-public-fields](https://github.com/tc39/proposal-class-public-fields)）。第二个允许我们使用装饰器（[https://github.com/tc39/proposal-decorators](https://github.com/tc39/proposal-decorators)）。
- en: 'Since everything else is ready, we will extend the manifest file with automation
    scripts:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其他一切都准备就绪，我们将使用自动化脚本扩展清单文件：
- en: '`package.json`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These targets have already been used while developing the chat application.
    The first one fires up the application. The second compiles and bundles sources.
    And the third one runs continuously and builds the project every time any of the
    source files change.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目标已经在开发聊天应用程序时使用过。第一个启动应用程序。第二个编译和捆绑源代码。第三个持续运行，并在任何源文件更改时构建项目。
- en: 'For bundling, we have to configure Webpack:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于捆绑，我们必须配置Webpack：
- en: '`./webpack.config.js`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`./webpack.config.js`'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So Webpack will start bundling ES6 modules recursively with `./js/app.jsx`.
    It will place the resulting JavaScript in `./build/app.js`. On the way, any `.js/.jsx`
    file requested for export will be compiled with Babel according to the configured
    presets and plugins.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Webpack将从`./js/app.jsx`开始递归捆绑ES6模块。它将把生成的JavaScript放在`./build/app.js`中。在此过程中，根据配置的预设和插件，任何请求导出的`.js/.jsx`文件都将使用Babel进行编译。
- en: Static prototype
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态原型
- en: 'The chat application we styled using CSS is provided by the Photon framework.
    This time, we are going to use ready-made React components of the Material-UI
    toolkit ([http://www.material-ui.com](http://www.material-ui.com)). What we get
    as developers is reusable units confronting Google Material Design guidelines
    ([https://material.io/guidelines/](https://material.io/guidelines/)). It ensures
    a good look and feel as well as providing a unified experience on different platforms
    and device sizes. We can install Material-UI with `npm`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用CSS样式化的聊天应用程序由Photon框架提供。这一次，我们将使用Material-UI工具包的现成React组件（[http://www.material-ui.com](http://www.material-ui.com)）。作为开发人员，我们得到的是符合Google
    Material Design指南的可重用单元（[https://material.io/guidelines/](https://material.io/guidelines/)）。它确保在不同平台和设备尺寸上提供统一的外观和感觉。我们可以使用`npm`安装Material-UI：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'According to Google Material Design requirements, the application shall support
    different devices, including mobile, where we need to handle specialized events,
    such as `on-tap`. Currently, React does not support them from the box; one has
    to use a plugin:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Google Material Design的要求，应用程序应支持包括移动设备在内的不同设备，在那里我们需要处理特定的事件，比如`on-tap`。目前，React不支持它们；必须使用插件：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We do not intend to run our application on a mobile, but without the plugin,
    we are going to have warnings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算在移动设备上运行我们的应用程序，但是如果没有插件，我们将会收到警告。
- en: 'Now, when we are done with preparations, we can start scaffolding, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们完成准备工作后，我们可以开始搭建脚手架，如下所示：
- en: 'We add our startup HTML:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了我们的启动HTML：
- en: '`./index.html`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`./index.html`'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, in the `head` element, we link to three external stylesheets. The first
    one (`https://fonts.googleapis.com/icon?family=Material+Icons`) unlocks Material
    Icons ([https://material.io/icons/](https://material.io/icons/)). The second (`https://fonts.googleapis.com/css?family=Roboto`)
    brings the Roboto font that is extensively used in Material Design. The last one
    (`./assets/main.css`) is our customization CSS. In the body, we set the `root`
    container for the application. I decided, instead of a custom element for readability,
    we could use an ordinary `div` instead. At the end, we load the JavaScript (`./build/app.js`)
    generated by Webpack according to our configuration.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`head`元素中，我们链接了三个外部样式表。第一个（`https://fonts.googleapis.com/icon?family=Material+Icons`）解锁了Material
    Icons（[https://material.io/icons/](https://material.io/icons/)）。第二个（`https://fonts.googleapis.com/css?family=Roboto`）引入了Material
    Design中广泛使用的Roboto字体。最后一个（`./assets/main.css`）是我们的自定义CSS。在body中，我们设置了应用程序的`root`容器。我决定，为了可读性，我们可以使用一个普通的`div`而不是自定义元素。最后，我们根据我们的配置加载由Webpack生成的JavaScript（`./build/app.js`）。
- en: 'We add the custom styles that we have already referred in `main.css`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了我们已经在`main.css`中引用的自定义样式：
- en: '`./assets/main.css`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/main.css`'
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We create the entry point script:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建入口点脚本：
- en: '`./js/app.jsx`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/app.jsx`'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we import the `App` container component and render it into the `<root>`
    element of the DOM. The component itself will look as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入`App`容器组件并将其渲染到DOM的`<root>`元素中。组件本身将如下所示：
- en: '`./js/Containers/App.jsx`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Containers/App.jsx`'
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, we wrap the application pane (`Main`) with the Material UI theme
    provider. With the `getMuiTheme` function imported from the Material UI package,
    we describe the theme and pass the derived configuration to the provider. As mentioned
    previously, we have to apply `injectTapEventPlugin` to enable the custom events
    in React that are used by the framework.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们用Material UI主题提供程序包装应用程序窗格（`Main`）。通过从Material UI包中导入`getMuiTheme`函数，我们描述主题并将派生的配置传递给提供程序。如前所述，我们必须应用`injectTapEventPlugin`来启用React中框架使用的自定义事件。
- en: 'Now is the time to add presentational components. We start with the main layout:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是添加展示组件的时候了。我们从主要布局开始：
- en: '`./js/Components/Main.jsx`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Components/Main.jsx`'
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This component comprises the title bar, two tabs (`Screenshot` and `Animation`),
    and conditionally, either the `ScreenshotTab` panel or `AnimationTab`. For rendering
    the tab menu, we apply the Material UI `Tabs` container and the `Tab` component
    for child items. We also use the `FontIcon` Material UI component to render Material
    Design icons. We assign icons declared at the beginning of the render method to
    corresponding tabs by using props:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件包括标题栏、两个选项卡（`Screenshot`和`Animation`），以及有条件地，要么`ScreenshotTab`面板，要么`AnimationTab`。为了渲染选项卡菜单，我们应用了Material
    UI的`Tabs`容器和`Tab`组件作为子项。我们还使用`FontIcon` Material UI组件来渲染Material Design图标。我们通过使用props将在渲染方法开头声明的图标分配给相应的选项卡：
- en: '`./js/Components/TitleBar.jsx`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Components/TitleBar.jsx`'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We implement the title bar with the `AppBar` Material UI component. Like in
    the previous example, we preliminarily define icons (this time, by using the `IconButton`
    component) and pass them to `AppBar` with props. We set inline handlers for the
    `IconButton` click event. The first one hides the window and the second closes
    the application. What is more, we set a custom CSS class `titlebar` to `AppBar`,
    because we are going to use this area as a window handle for drag and drop. So,
    we extend our custom style sheet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AppBar` Material UI组件实现标题栏。与前面的示例一样，我们预先定义图标（这次使用`IconButton`组件），并将它们传递给`AppBar`作为props。我们为`IconButton`的点击事件设置内联处理程序。第一个隐藏窗口，第二个关闭应用程序。此外，我们为`AppBar`设置了一个自定义CSS类`titlebar`，因为我们将使用这个区域作为拖放的窗口句柄。因此，我们扩展了我们的自定义样式表：
- en: '`./assets/main.css`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/main.css`'
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we need a component representing tab panels. We start with `ScreenshotTab`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个代表选项卡面板的组件。我们从`ScreenshotTab`开始：
- en: '`./js/Components/ScreenshotTab.jsx`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Components/ScreenshotTab.jsx`'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we use `IconButton` for the Take a screenshot action. We make it extra
    large by passing it with props custom styling (`TAB_BUTTON_STYLE`). In addition,
    we apply the `TextField` component to render text input in the style of Material
    Design.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`IconButton`来执行“截图”操作。通过传递自定义样式（`TAB_BUTTON_STYLE`）使其变得特别大。此外，我们还应用`TextField`组件以Material
    Design风格呈现文本输入。
- en: 'The second tab panel will be quite similar:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项卡面板将会非常相似：
- en: '`./js/Components/AnimationTab.jsx`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Components/AnimationTab.jsx`'
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The only difference it makes here is the conditional rendering of either the
    `Start recording` button or `Stop recording`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它在这里的唯一区别是条件渲染“开始录制”按钮或“停止录制”按钮。
- en: 'And that is pretty much everything for the static prototype. We just need to
    bundle the application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是静态原型的全部内容。我们只需要打包应用程序：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And fire it up:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后启动它：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will get the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![](img/1828ac2a-f29d-4d46-9286-a0a2ff41185f.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1828ac2a-f29d-4d46-9286-a0a2ff41185f.png)'
- en: Comprehending redux
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解redux
- en: We learned to manage the component state while working on the chat application.
    It was quite sufficient for that small example. However, as the application grows
    larger, you may notice that multiple components tend to share the state. We know
    how to lift the state up. But which exact component then shall manage the state?
    Where does the state belong? We can avoid this ambiguity by drawing on Redux,
    a JavaScript library known as a predictable state container. Redux implies an
    application-wide state tree. When we need to set the state for a component, we
    update the corresponding node in the global state tree. All the subscribed modules
    immediately receive the updated state tree. Thus, we can always easily find out
    what is going on with the application by checking the state tree. We can save
    and restore the entire application state at will. Just imagine, with a little
    effort, we can implement time traveling through application state history.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在聊天应用程序中，我们学会了管理组件状态。对于那个小例子来说，这已经足够了。然而，随着应用程序变得越来越大，你可能会注意到多个组件倾向于共享状态。我们知道如何提升状态。但是哪个组件应该管理状态？状态应该放在哪里？我们可以通过使用Redux来避免这种模糊不清。Redux是一个被称为可预测状态容器的JavaScript库。Redux意味着应用程序范围的状态树。当我们需要为一个组件设置状态时，我们更新全局状态树中的相应节点。所有订阅的模块立即接收更新后的状态树。因此，我们可以通过检查状态树轻松地找出应用程序的情况。我们可以随意保存和恢复整个应用程序状态。想象一下，只需稍加努力，我们就可以实现通过应用程序状态历史进行时间旅行。
- en: I presume you are probably a bit confused now. The approach, if you have no
    experience with it or its predecessor Flux, may look strange. In fact, it's surprisingly
    easy to grasp when you start working with it. So, let's jump in.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你现在可能有点困惑。如果你没有使用过它或它的前身Flux，这种方法可能看起来很奇怪。实际上，当你开始使用它时，你会发现它非常容易理解。所以，让我们开始吧。
- en: 'Redux has three fundamental principles:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Redux有三个基本原则：
- en: Everything that happens within the application is represented by a state.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序中发生的一切都由状态表示。
- en: The state is read-only.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态是只读的。
- en: State mutations are made with pure functions that take the previous state, dispatch
    action, and return the next state.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态变化是通过纯函数进行的，这些函数接受先前的状态，分派动作，并返回下一个状态。
- en: 'We receive new states by dispatching actions. An action is a plain object with
    the only mandatory field type that accepts a string. We are allowed to set as
    many arbitrary fields as we wish for the payload:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过分派动作来接收新状态。动作是一个带有唯一强制字段类型的普通对象，它接受一个字符串。我们可以为有效载荷设置任意多的任意字段：
- en: '![](img/ec15eab6-e352-490e-bc34-e2604db7d69e.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec15eab6-e352-490e-bc34-e2604db7d69e.png)'
- en: 'The preceding figure depicts the following flow:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图描述了以下流程：
- en: We have the store in a particular state; let's say A.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个特定状态的存储；我们称之为A。
- en: We dispatch an action (created by a pure function, called **Action Creator**).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们分派一个由纯函数创建的动作（称为**Action Creator**）。
- en: 'That invokes the **Reducer** function with arguments: state object (representing
    state A) and the dispatched action object.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会调用**Reducer**函数，并传入参数：表示状态A的状态对象和分派的动作对象。
- en: The **Reducer** clones the supplied state object and modifies the clone object
    according to the scenario defined for the given action.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Reducer**克隆提供的状态对象，并根据给定动作的定义修改克隆对象。'
- en: The **Reducer** returns the object representing the new store, **State B**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Reducer**返回表示新存储的对象，**状态B**。'
- en: Any component connected to the store receives the new state and calls the `render`
    method to reflect the state change in the view.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与存储连接的任何组件都会接收新状态，并调用`render`方法以反映视图中的状态变化。
- en: 'For example, in our application, we are going to have tabs. When a user clicks
    on all of them, the corresponding panel is supposed to show up. So, we need to
    represent the current `activeTab` in the state. We can do it as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的应用程序中，我们将有选项卡。当用户点击它们时，相应的面板应该显示出来。因此，我们需要在状态中表示当前的`activeTab`。我们可以这样做：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, we dispatch actions not directly, but via a function, which is called
    `actionCreator`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不是直接分派动作，而是通过一个名为`actionCreator`的函数：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The function takes zero or more input arguments and produces the action object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受零个或多个输入参数，并生成动作对象。
- en: 'The **Action** indicates that something happened, but doesn''t change the state.
    That is a task of another function called **Reducer**. **Reducer** receives as
    a parameter of an object representing the previous state and the last dispatched
    action object. According to the action type and payload, it produces a new state
    object and returns it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**动作**表示发生了某事，但不改变状态。这是另一个名为**Reducer**的函数的任务。**Reducer**接收表示先前状态和最后分派的动作对象的对象作为参数。根据动作类型和有效负载，它产生一个新的状态对象并返回它：'
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the previous example, we defined the initial application state in the constant
    `initialState`. We make it the default function parameter ([https://mzl.la/2qgdNr6in](https://mzl.la/2qgdNr6in))
    with the statement `state = initialState`. It means that when nothing is passed
    with the arguments, `state` takes the value of `initialState`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在常量`initialState`中定义了初始应用程序状态。我们将其作为默认函数参数（[https://mzl.la/2qgdNr6in](https://mzl.la/2qgdNr6in)）与语句`state
    = initialState`一起使用。这意味着当参数没有传递时，`state`取`initialState`的值。
- en: 'Pay attention to how we get a new state object. We declare a new object literal.
    We are destructuring the previous state object in it and extending it with the
    `activeTab` key-value pair set from action payload. Reducer must be a pure function,
    so we could not change a value passed in the state object. You know that, with
    parameters, we receive `state` as a reference, so if we simply changed the value
    of the `activeTab` field in `state`, the corresponding object outside the function
    scope would have been impacted through the link. We have to ensure the previous
    state is immutable. So, we create a new object for that. Destructuring is a considerably
    new approach. If you do not feel comfortable with it, you can go with `Object.assign`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何获得新的状态对象。我们声明了一个新的对象文字。我们在其中解构了先前的状态对象，并用来自动作有效负载的`activeTab`键值对进行扩展。减少器必须是纯函数，因此我们不能改变传递给状态对象的值。您知道，通过参数，我们接收`state`作为引用，因此如果我们简单地改变`state`中的`activeTab`字段的值，通过链接会影响函数范围之外的相应对象。我们必须确保先前的状态是不可变的。因此，我们为此创建一个新对象。解构是一种相当新的方法。如果您对此感到不舒服，可以使用`Object.assign`：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For our application, we will use the only reducer, but in general, we may have
    many. We can use the `combineReducers` function exported by `redux` to combine
    multiple reducers so that each of them represents a separate leave of the global
    state tree.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将只使用一个减少器，但一般情况下，我们可能会有很多。我们可以使用`redux`导出的`combineReducers`函数来组合多个减少器，使每个减少器代表全局状态树的一个独立分支。
- en: 'We pass to `createStore` function of `redux` the reducer (can be also a product
    of `combineReducers`). The function produces the store:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`redux`的`createStore`函数传递给减少器（也可以是`combineReducers`的产物）。该函数生成存储：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we render the React application on server-side, we can expose the state
    object into the JavaScript global scope (for example, `window.STATE_FROM_SERVER`)
    and connect it from the client:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在服务器端渲染React应用程序，我们可以将状态对象暴露到JavaScript全局作用域中（例如`window.STATE_FROM_SERVER`），并从客户端进行连接：
- en: '`const store = createStore( reducer, window.STATE_FROM_SERVER );`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`const store = createStore( reducer, window.STATE_FROM_SERVER );`'
- en: 'And now is the most exciting part. We subscribe to store events:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最激动人心的部分。我们订阅存储事件：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will then dispatch an action:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将分派一个动作：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'While dispatching, we created an action of the type `SET_ACTIVE_TAB` with `activeTab`
    set to `SCREENSHOT` in the payload. Therefore, `console.log` in the store update
    handler prints the new state updated accordingly:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在分派时，我们创建了类型为`SET_ACTIVE_TAB`的动作，并在有效负载中将`activeTab`设置为`SCREENSHOT`。因此，存储更新处理程序中的`console.log`打印相应更新的新状态：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Introducing the application state
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入应用程序状态
- en: 'After this brief tour into Redux, we will apply the newly obtained knowledge
    in practice. First, we will install the `redux` package:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Redux进行了简要介绍之后，我们将把新获得的知识应用到实践中。首先，我们将安装`redux`包：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will also use the additional helper library `redux-act` ([https://github.com/pauldijou/redux-act](https://github.com/pauldijou/redux-act))
    to simplify the declaration of action creators and reducers. By using this library,
    we can use the action creator functions as references within reducers, abandoning
    the `switch( action.type )` construction in favor of a shorter map syntax:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用额外的辅助库`redux-act`（[https://github.com/pauldijou/redux-act](https://github.com/pauldijou/redux-act)）来简化动作创建者和减少器的声明。通过使用这个库，我们可以在减少器中使用动作创建者函数作为引用，放弃`switch(
    action.type )`构造，而采用更短的映射语法：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For screen capture, we should perform the following actions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于屏幕截图，我们应执行以下操作：
- en: '`SET_ACTIVE_TAB`: It receives the identifier of the selected tab'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_ACTIVE_TAB`：接收所选选项卡的标识符'
- en: '`TOGGLE_RECORDING`: It receives `true` when screencast recording starts and
    `false` when it ends'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TOGGLE_RECORDING`：开始录屏时接收`true`，结束时接收`false`'
- en: '`SET_SCREENSHOT_FILENAME`: It receives the output filename in the panel Screenshot'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_SCREENSHOT_FILENAME`：在面板截图中接收输出文件名'
- en: '`SET_SCREENSHOT_INPUT_ERROR`: It receives a message when an input error occurs'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_SCREENSHOT_INPUT_ERROR`：当输入错误发生时接收消息'
- en: '`SET_ANIMATION_FILENAME`: It receives an output filename in the panel Animation'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_ANIMATION_FILENAME`：在面板动画中接收输出文件名'
- en: '`SET_ANIMATION_INPUT_ERROR`: It receives a message when an input error occurs'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_ANIMATION_INPUT_ERROR`：当输入错误发生时接收消息'
- en: 'The implementation will look as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '`./js/Actions/index.js`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Actions/index.js`'
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead of the canonical syntax, we have:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是规范的语法，我们有：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We go here with a shorter one, achieved with the `createAction` function of
    `redux-act`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了更简短的方法，通过`redux-act`的`createAction`函数实现：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Another function, `createReducer`, exported by `redux-act`, makes the reducer
    declaration even shorter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数`createReducer`由`redux-act`导出，使得减少声明更加简洁：
- en: '`./js/Reducers/index.js`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Reducers/index.js`'
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We do not need to describe reducer conditioning with a `switch` statement like
    we did during Redux''s introduction:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要像在Redux介绍中那样使用`switch`语句描述减少器条件：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The function `createReducer` does it for us:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`createReducer`函数为我们做到了这一点：'
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The function takes in a map-like object, where we use action creator functions
    as keys (for example, `[ Actions.setActiveTab ]`). Yeah, for dynamic object keys,
    we have to go with the syntax called **Computed property names** at [https://mzl.la/2erqyrj](https://mzl.la/2erqyrj).
    As object values, we use callbacks to generate the new state.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个类似映射的对象，在其中我们将操作创建函数用作键（例如，`[ Actions.setActiveTab ]`）。是的，对于动态对象键，我们必须使用称为**计算属性名称**的语法[https://mzl.la/2erqyrj](https://mzl.la/2erqyrj)。作为对象值，我们使用回调函数来生成新状态。
- en: In this sample, we clone the old state (`{...state}`) and change in the derived
    object `activeTab` property value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们克隆了旧状态（`{...state}`）并在派生对象中更改了`activeTab`属性值。
- en: 'If you noted, we used imports from `Constants/index.js`. In that module, we
    are going to encapsulate the application scope constants:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到了，我们使用了`Constants/index.js`中的导入。在该模块中，我们将封装应用程序范围的常量：
- en: '`./js/Constants/index.js`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Constants/index.js`'
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Well, we have actions and a reducer. That''s the time to create the store and
    connect it to the application:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们有了操作和一个减速器。现在是创建存储并将其连接到应用程序的时候了：
- en: '`./js/Containers/App.jsx`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Containers/App.jsx`'
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We build the store using the `createStore` function of `redux`. Then, we wrap
    the `App` component with `Provider` provided by the `react-redux` package. Do
    not forget to install the dependency:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`redux`的`createStore`函数构建存储。然后，我们使用`react-redux`包提供的`Provider`将`App`组件包装起来。不要忘记安装依赖：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The **Provider** takes in a previously created store with props and makes it
    available for another `react-redux` function, `connect`. We will use this function
    in our `App` container component:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Provider**接受之前创建的存储作为props，并使其对另一个`react-redux`函数`connect`可用。我们将在我们的`App`容器组件中使用这个函数：'
- en: '`./js/Containers/App.jsx`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Containers/App.jsx`'
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we define two mapper functions that `connect` accepts as arguments. The
    first `mapStateToProps` maps the stored state to the props. With the statement
    `( state ) => ({ states: state })`, we make the store state available in the component
    as `this.props.states`. The second `mapDispatchToProps` maps our actions to the
    props. The callback receives automatically from the `connect` function `dispatch`
    bound to the store. Together with the function `bindActionCreators` of `redux`,
    we can use it to map a set of actions to the props. So, we imported all the available
    actions as a plain object, `Actions`, and passed it to `bindActionCreators`. The
    return is mapped to the `actions` field, and therefore will be available within
    the component as `this.props.actions`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们定义了两个`connect`接受的映射函数。第一个`mapStateToProps`将存储的状态映射到props。通过语句`( state
    ) => ({ states: state })`，我们使存储状态在组件中作为`this.props.states`可用。第二个`mapDispatchToProps`将我们的操作映射到props。回调函数自动从`connect`函数中接收到与存储绑定的`dispatch`。结合`redux`的`bindActionCreators`函数，我们可以将一组操作映射到props。因此，我们将所有可用的操作作为普通对象`Actions`导入，并将其传递给`bindActionCreators`。返回值映射到`actions`字段，因此将在组件中作为`this.props.actions`可用。'
- en: 'Finally, we pass the component to a function produced by `connect`. It extends
    the component, which we export upstream. This expression may look a bit confusing.
    Actually, what we do here is we modify the behavior of the component without explicitly
    modifying the component itself. Traditionally, in OOP languages, we used to achieve
    it with the Decorator pattern ([https://en.wikipedia.org/wiki/Decorator_pattern](https://en.wikipedia.org/wiki/Decorator_pattern)).
    Nowadays, many languages have built-in capacities, such as attributes in C#, annotations
    in Java, and decorators in Python. ECMAScript also has a proposal, [https://tc39.github.io/proposal-decorators/](https://tc39.github.io/proposal-decorators/),
    for decorators. Thus, by using the declarative syntax, we can modify the shape
    of a class or a method without touching its code. The plugin `babel-plugin-transform-decorators-legacy`,
    which we used in our Webpack configuration unlocks this feature to us. So, we
    can already use it for connecting the component to the store:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将组件传递给`connect`生成的函数。它扩展了组件，我们将其导出到上游。这个表达式可能看起来有点令人困惑。实际上，我们在这里做的是在不显式修改组件本身的情况下修改组件的行为。在面向对象编程语言中，传统上，我们使用装饰器模式来实现它（[https://en.wikipedia.org/wiki/Decorator_pattern](https://en.wikipedia.org/wiki/Decorator_pattern)）。如今，许多语言都具有内置的功能，比如C#中的属性，Java中的注解和Python中的装饰器。ECMAScript也有一个提案，[https://tc39.github.io/proposal-decorators/](https://tc39.github.io/proposal-decorators/)，用于装饰器。因此，通过使用声明性语法，我们可以修改类或方法的形状而不触及其代码。我们在Webpack配置中使用的插件`babel-plugin-transform-decorators-legacy`为我们解锁了这个功能。因此，我们已经可以用它来连接组件到存储：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'From the container, we render the `Main` component and pass to it all the props
    of the container (by destructuring the parent props `{...this.props}`). So, `Main`
    receives the mapped state and actions in the props. We can use the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器中，我们渲染`Main`组件，并将容器的所有props传递给它（通过解构父props`{...this.props}`）。因此，`Main`在props中接收到了映射的状态和操作。我们可以使用以下内容：
- en: '`./js/Components/Main.jsx`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Components/Main.jsx`'
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you remember, this component serves the tab menu. We subscribe here for the
    *click on tab* events. We do not subscribe to the handler directly, but a function,
    `this.onTabNav`, bound to the instance scope that produces the intended handler
    according to the passed-in tab key. The constructed handler receives the key with
    the closure and passes it to the `setActiveTab` action creator extracted from
    `this.props.actions`. The action gets dispatched and the global state changes.
    From the component's perspective, it is like calling `setState`, which causes
    the component to update. The `activeTab` field extracted from `this.props.state`
    changes its value respectively and the component renders the panel matching the
    key passed with `this.onTabNav`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得，这个组件用于标签菜单。我们在这里订阅了*点击标签*事件。我们不直接订阅处理程序，而是订阅了一个函数`this.onTabNav`，该函数绑定到实例范围，根据传入的标签键生成预期的处理程序。构造的处理程序接收闭包中的键，并将其传递给从`this.props.actions`中提取的`setActiveTab`动作创建者。动作被调度，全局状态发生变化。从组件的角度来看，这就像调用`setState`，导致组件更新。从`this.props.state`中提取的`activeTab`字段相应地改变其值，组件呈现与通过`this.onTabNav`传递的键匹配的面板。
- en: 'As for the panel, we can already connect the filename form to the state:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 至于面板，我们已经可以将文件名表单连接到状态：
- en: '`./js/Components/ScreenshotTab.jsx`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Components/ScreenshotTab.jsx`'
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we subscribe the `this.onFilenameChange` handler for the `change` event
    on `TextField`. So, if the user types in `this.onFilenameChange` it invokes and
    validates the input. If the current value is less than six characters in length
    or does not end with `.png`, it is considered as invalid. So, we use the `setScreenshotInputError`
    action creator extracted from `this.props.actions` to set a value for the error
    message. As soon as it is done, the `screenshotInputError` field of the state
    changes as well as the `errorText` property of the `TextField` component, and
    the error message shows up. If the filename is valid, we dispatch the `setScreenshotInputError`
    action to reset the error message. We change the screenshot filename in the state
    tree by calling the action creator `setScreenshotFilename`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为`TextField`的`change`事件订阅了`this.onFilenameChange`处理程序。因此，如果用户输入`this.onFilenameChange`，它会调用并验证输入。如果当前值的长度小于六个字符或不以`.png`结尾，则被视为无效。因此，我们使用从`this.props.actions`中提取的`setScreenshotInputError`动作创建者来设置错误消息的值。一旦完成，状态的`screenshotInputError`字段以及`TextField`组件的`errorText`属性都会发生变化，错误消息就会显示出来。如果文件名有效，我们会调度`setScreenshotInputError`动作来重置错误消息。我们通过调用动作创建者`setScreenshotFilename`来改变状态树中的截图文件名。
- en: 'If you have noticed, we encapsulated the `IconButton` custom style in the constants
    module, so it could be shared between both panels. But we have to add the new
    constant to the module:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，我们将`IconButton`的自定义样式封装在常量模块中，这样它就可以在两个面板之间共享。但是我们必须将新的常量添加到模块中：
- en: '`./js/Constants/index.js`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Constants/index.js`'
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The second panel, in addition to form validation, also changes the state field
    `isRecording`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个面板除了表单验证之外，还会改变状态字段`isRecording`：
- en: '`./js/Components/AnimationTab.jsx`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Components/AnimationTab.jsx`'
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We subscribe the handlers for click events on both the Start recording and Stop
    recording buttons. When a user hits the first one, the `this.onRecord` handler
    invokes the action creator, `toggleRecording`, which sets the state field `isRecording`
    to `true`. It causes the component to update. According to the new state, it replaces
    the Start recording button with the Stop recording one. And vice versa, if Stop
    recording is clicked in the `this.onStop` handler, we call `toggleRecording` to
    set the state property `isRecording` to `false`. The component updates respectively.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们订阅了开始录制和停止录制按钮的点击事件处理程序。当用户点击第一个按钮时，`this.onRecord`处理程序调用动作创建者`toggleRecording`，将状态字段`isRecording`设置为`true`。这导致组件更新。根据新的状态，它用停止录制按钮替换开始录制按钮。反之亦然，如果在`this.onStop`处理程序中点击停止录制，我们调用`toggleRecording`将状态属性`isRecording`设置为`false`。组件相应地更新。
- en: 'Now, we can build the application and run it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建应用程序并运行它：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Observe that when we are switching tabs, editing file names, or toggling start/stop
    recording, the application responds as we intend.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到当我们切换标签、编辑文件名或切换开始/停止录制时，应用程序会按我们的意图做出响应。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we familiarized ourselves with the basics of Google's Material
    Design. We built the static prototype from ready-made React components of the
    Material-UI set. We had an introduction into the Redux state container. We defined
    our application state tree and set state mutators. We created the global state
    store and connected it to the container component. We passed exposed action creators
    and state tree trunk into presentation components with the props. We examined
    shorter action/reducer declaration syntaxes provided by the `redux-act` library.
    We implemented it by using Redux state machine actions, such as tabbed navigation,
    recording toggle, and form validation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了谷歌的Material Design的基础知识。我们使用Material-UI组件集中的现成的React组件构建了静态原型。我们对Redux状态容器进行了介绍。我们定义了应用程序状态树并设置了状态改变器。我们创建了全局状态存储并将其连接到容器组件。我们通过props将暴露的动作创建者和状态树主干传递给呈现组件。我们检查了`redux-act`库提供的更短的动作/减速器声明语法。我们通过使用Redux状态机动作来实现它，例如标签导航、录制切换和表单验证。
